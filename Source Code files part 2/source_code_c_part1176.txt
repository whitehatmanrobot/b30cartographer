
        {
        RpcSsFree( NodeToFree );
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    return( Status );
}


RPC_SS_THREAD_HANDLE RPC_ENTRY
RpcSmGetThreadHandle (
    OUT RPC_STATUS *    pStatus
    )
/*++

Arguments:

    pStatus - error code

Return Value:

    Same as RpcSsGetThreadHandle, except that this one returns an error code,
    as opposed to raising an exception.

--*/
{
    RPC_SS_THREAD_HANDLE  Handle = 0;
    *pStatus = RPC_S_OK;
    RpcTryExcept
        {
        Handle = RpcSsGetThreadHandle();
        }
    RpcExcept(1)
        {
        *pStatus = RpcExceptionCode();
        }
    RpcEndExcept
    return( Handle );
}


RPC_STATUS  RPC_ENTRY
RpcSmSetClientAllocFree (
    IN RPC_CLIENT_ALLOC * ClientAlloc,
    IN RPC_CLIENT_FREE  * ClientFree
    )
/*++

Routine Description:

    Same as RpcSsSetClientAllocFree, except that this one returns an error code,
    as opposed to raising an exception.

Arguments:

    ClientAlloc - Supplies the routine to use to allocate memory.
    ClientFree  - Supplies the routine to use to free memory.

Return Value:

    error code - RPC_S_OK or exception code

Exceptions:

    Exceptions are catched and an error code is returned.
--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RpcTryExcept
        {
        RpcSsSetClientAllocFree( ClientAlloc, ClientFree );
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    return( Status );
}


RPC_STATUS  RPC_ENTRY
RpcSmSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    )
/*++

Routine Description:

    Same as RpcSsSetThreadHandle, except that this one returns an error code,
    as opposed to raising an exception.

Arguments:

    Id - Supplies the allocation context to use for this thread.

Return Value:

    error code - RPC_S_OK or exception code (RPC_S_OUT_OF_MEMORY)

Exceptions:

    Exceptions are catched and an error code is returned.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RpcTryExcept
        {
        RpcSsSetThreadHandle( Id );
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    return( Status );
}


RPC_STATUS  RPC_ENTRY
RpcSmSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC     * ClientAlloc,
    IN RPC_CLIENT_FREE      * ClientFree,
    OUT RPC_CLIENT_ALLOC  * * OldClientAlloc,
    OUT RPC_CLIENT_FREE   * * OldClientFree
    )
/*++

Routine Description:

    Same as RpcSsSwapClientAllocFree, except that this one returns an error
    code, as opposed to raising an exception.

Arguments:

    ClientAlloc     - Supplies the routine to use to allocate memory.
    ClientFree      - Supplies the routine to use to free memory.
    OldClientAlloc  - Returns the old value of the client allocator.
    OldClientFree   - Returns the old value of the client deallocator.

Return Value:

    error code - RPC_S_OK or exception code (RPC_S_OUT_OF_MEMORY)

Exceptions:

    Exceptions are catched and an error code is returned.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RpcTryExcept
        {
        RpcSsSwapClientAllocFree( ClientAlloc,
                                  ClientFree,
                                  OldClientAlloc,
                                  OldClientFree );
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    return( Status );
}


// =======================================================================
//     Package initialization
// =======================================================================

// default: win32 now


DWORD RpcAllocTlsIndex = 0xFFFFFFFF;

PALLOCATION_CONTEXT
GetAllocContext (
    )
/*++

Return Value:

    The allocation context pointer for this thread will be returned.  Use
    SetAllocContext to set the allocation context pointer for this thread.
    If GetAllocContext is called before SetAllocContext has been called, zero
    will be returned.

--*/
{
    if (RpcAllocTlsIndex == 0xFFFFFFFF)
        {
        GlobalMutexRequestExternal();
        if (RpcAllocTlsIndex == 0xFFFFFFFF)
            {
            RpcAllocTlsIndex = TlsAlloc();
            if (RpcAllocTlsIndex == 0xFFFFFFFF)
                {
                GlobalMutexClearExternal();
                RpcRaiseException(RPC_S_OUT_OF_MEMORY);
                }
            }
        GlobalMutexClearExternal();
        }

    return( (PALLOCATION_CONTEXT) TlsGetValue(RpcAllocTlsIndex));
}

void
SetAllocContext (
    PALLOCATION_CONTEXT AllocContext
    )
/*++

Arguments:

    AllocContext - Supplies a new allocation context pointer for this thread.
        Use GetAllocContext to retrieve the allocation context pointer for
        a thread.

--*/
{
    if ( ! TlsSetValue(RpcAllocTlsIndex, AllocContext) )
        RpcRaiseException( GetLastError() );
}


//
// We can't rely on a call like that in Win32 as some threads hang for ever.
// The runtime doesn't call us when a thread goes away and into recycling.
//
//void
//NdrRpcDeleteAllocationContext()
//{
//}



// =======================================================================
//     Private entry points for stubs
// =======================================================================
//

void RPC_ENTRY
NdrRpcSsEnableAllocate(
    PMIDL_STUB_MESSAGE  pMessage )
{
    NdrpEnableAllocate( TRUE );

    pMessage->pfnAllocate = RpcSsAllocate;
    pMessage->pfnFree     = RpcSsFree;
}

void RPC_ENTRY
NdrRpcSsDisableAllocate(
    PMIDL_STUB_MESSAGE  pMessage )
{
    NdrpDisableAllocate( TRUE );

    pMessage->pfnAllocate = NdrRpcSsDefaultAllocate;
    pMessage->pfnFree     = NdrRpcSsDefaultFree;
}

void RPC_ENTRY
NdrRpcSmSetClientToOsf(
    PMIDL_STUB_MESSAGE  pMessage )
{
    pMessage->pfnAllocate = NdrRpcSmClientAllocate;
    pMessage->pfnFree     = NdrRpcSmClientFree;
}


void *  RPC_ENTRY
NdrRpcSsDefaultAllocate (
    IN size_t Size
    )
{
    return I_RpcAllocate( Size );
}

void  RPC_ENTRY
NdrRpcSsDefaultFree (
    IN void * NodeToFree
    )
{
    I_RpcFree( NodeToFree );
}


void *  RPC_ENTRY
NdrRpcSmClientAllocate (
    IN size_t Size
    )
/*++
    This is the client stub private entry point that checks if a memory
    manager has been enabled. If not, a default or a user's private
    allocator is called.
--*/
{

    RPC_CLIENT_ALLOC *      ClientAlloc;
    PALLOCATION_CONTEXT     AllocationContext = GetAllocContext();

    if ( AllocationContext == 0 )
        {
        return( DefaultAllocate( Size ));
        }

    // User's ClientAlloc may encapsulate a RpcSsAllocate call.

    EnterCriticalSection( &(AllocationContext->CriticalSection) );

    ClientAlloc = AllocationContext->ClientAlloc;

    LeaveCriticalSection( &(AllocationContext->CriticalSection) );

    return (*ClientAlloc)( Size );
}


void  RPC_ENTRY
NdrRpcSmClientFree (
    IN void * NodeToFree
    )
{
    RPC_CLIENT_FREE *   ClientFree;
    PALLOCATION_CONTEXT     AllocationContext = GetAllocContext();

    if ( AllocationContext == 0 )
        {
        DefaultFree( NodeToFree );
        return;
        }

    EnterCriticalSection( &(AllocationContext->CriticalSection) );

    ClientFree = AllocationContext->ClientFree;

    LeaveCriticalSection( &(AllocationContext->CriticalSection) );

    (* ClientFree)( NodeToFree );
}


// =======================================================================
//     Private entry point for test
// =======================================================================


#if defined( DEBUGRPC )

void *  RPC_ENTRY
RpcSsGetInfo(
    void )
{
    return( GetAllocContext() );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Steve Wood (stevewo) 12-Apr-1989

Revision History:

!ENDIF


TARGETNAME=rpcndr20
TARGETPATH=obj
TARGETTYPE=LIBRARY
386_STDCALL=1

MSC_WARNING_LEVEL=/W3 /WX

INCLUDES=$(INCLUDES);..;..\..\ndr20;..\..\midl\inc;..\..\runtime\mtrt;$(PROJECT_ROOT)\inc\ndrshared

SOURCES=        \
    ..\async.cxx   \
    ..\asyncu.cxx  \
    ..\attack.cxx  \
    ..\auxilary.cxx\
    ..\bufsize.cxx \
    ..\cltcall.cxx \
    ..\cvtf.cxx    \
    ..\cvtg.cxx    \
    ..\cvtglo.cxx  \
    ..\cvtibm.cxx  \
    ..\endian.cxx  \
    ..\factory.cxx \
    ..\free.cxx    \
    ..\fullptr.cxx \
    ..\global.cxx  \
    ..\hndl.cxx    \
    ..\iid.cxx     \
    ..\memsize.cxx \
    ..\misc.cxx    \
    ..\mrshl.cxx   \
    ..\mrshlp.cxx  \
    ..\pickle.cxx  \
    ..\pipes.cxx   \
    ..\proxy.cxx   \
    ..\registry.cxx\
    ..\rpcssm.cxx  \
    ..\sh.cxx      \
    ..\srvcall.cxx \
    ..\srvout.cxx  \
    ..\stream.cxx  \
    ..\stub.cxx    \
    ..\tiutil.cxx  \
    ..\typeinfo.cxx \
    ..\udt.cxx      \
    ..\unmrshl.cxx  \
    ..\relmrl.cxx \
    ..\unmrshlp.cxx \
    ..\mulsyntx.cxx \
    ..\pointerq.cxx

!ifdef DOSWIN32RPC
RPCENV=$(RPCENV) -DDOSWIN32RPC -DWIN32RPC
!else
RPCENV=$(RPCENV) -DNTENV
!endif

C_DEFINES=$(RPCENV) -D_RPCRT4_

!if $(IA64) || $(AMD64)
BUILD_NDR64=1
!endif


!ifdef BUILD_NDR64FAKE
BUILD_NDR64=1
!endif

!ifdef BUILD_NDR64
C_DEFINES=$(C_DEFINES) -DBUILD_NDR64
!endif

!ifdef BUILD_NDR64FAKE
C_DEFINES=$(C_DEFINES) -DBUILD_NDR64FAKE
!endif

UMTYPE=console
UMTEST=testc
UMLIBS=$(O)\rpcndr20.lib $(SDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\rpcrt4.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\sh.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989 Microsoft Corporation

 Module Name:

 	sh.c
	
 Abstract:

	stub helper routines.

 Notes:

	simple routines for handling pointer decisions, comm and fault
	status etc.

 History:

 	Dec-12-1993		VibhasC		Created.
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "ndrp.h"

/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

RPC_STATUS RPC_ENTRY
NdrMapCommAndFaultStatus(
/*

  Note on mapping.

   - Some errors are defined by DCE.
     These appear as mapped to DCE values on wire.
     They are mapped back to platform specific values by the rpc runtime.

   - other codes are defined by RPC runtime or by an app using rpc.
     These are not mapped, and appear both on the wire and on the client
     same as their original codes at server.

*/
	PMIDL_STUB_MESSAGE		pMessage,
	unsigned long 		*	pComm,
	unsigned long		*	pFault,
	RPC_STATUS				RetVal )
	{

// For errors that are mapped through DCE values, we use constants that
// resolve to platform specific error codes.
// For others, we have to use absolute values as the codes on wire are NT
// values set by RPC.
// We don't map any app specific error codes, of course.
//

static long CommStatArray[] = 
    {
    RPC_X_SS_CONTEXT_MISMATCH
    ,RPC_S_INVALID_BINDING
    ,RPC_S_UNKNOWN_IF
    ,RPC_S_SERVER_UNAVAILABLE
    ,RPC_S_SERVER_TOO_BUSY
    ,RPC_S_CALL_FAILED_DNE
    ,RPC_S_PROTOCOL_ERROR
    ,RPC_S_UNSUPPORTED_TRANS_SYN
    ,RPC_S_UNSUPPORTED_TYPE
    ,RPC_S_PROCNUM_OUT_OF_RANGE
    ,EPT_S_NOT_REGISTERED
    ,RPC_S_COMM_FAILURE
    ,RPC_S_ASYNC_CALL_PENDING
    };

	int Mid;
	int Low	= 0;
	int High	= (sizeof(CommStatArray)/sizeof( unsigned long)) - 1;
	BOOL		  fCmp;
	BOOL		  fCommStat = FALSE;

    // Check if there was no error.

	if( RetVal == 0 )
		return RetVal;

    // Find a comm error mapping.

	while( Low <= High )
		{
		Mid = (Low + High) / 2;
		fCmp = (long)RetVal - (long) CommStatArray[ Mid ];

		if( fCmp < 0 )
			{
			High = Mid - 1;
			}
		else if( fCmp > 0 )
			{
			Low = Mid + 1;
			}
		else
			{
			fCommStat = TRUE;
			break;
			}
		}

    // If there was a comm error, return it in the pComm, if possible;
    // If it was a non-comm error, return it in the pFault, if possible.

	if( fCommStat )
		{
		if( pComm )
			{
			*pComm = RetVal;
			RetVal = 0;
			}
		}
	else
		{
		if( pFault )
			{
			*pFault = RetVal;
			RetVal = 0;
			}
		}
	return RetVal;
	}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\registry.cxx ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1994-2000 Microsoft Corporation.  All rights reserved.

Module Name:
    registry.cxx

Abstract:
    Registers the interfaces contained in the proxy DLL.

Public Functions:
    DllRegisterServer
    NdrDllRegisterProxy
    NdrDllUnregisterProxy

Private Functions:
    NdrpGetClassID
    NdrpRegisterClass
    NdrpRegisterInterface
    NdrpUnregisterClass
    NdrpUnregisterInterface

Author:
    ShannonC    12-Oct-1994

Environment:
    Windows NT and Windows 95.

Revision History:

    RyszardK    Nov 1997    Changes for async registration.

--------------------------------------------------------------------*/

#define USE_STUBLESS_PROXY
#define CINTERFACE
#include <ndrp.h>
#include <ndrole.h>
#include <rpcproxy.h>
#include <stdlib.h>

EXTERN_C HINSTANCE g_hRpcrt4 = 0;

HRESULT NdrpGetClassID(
    OUT LPSTR                    pszClassID, 
    IN  const CLSID *            pclsid,
    IN  const ProxyFileInfo **   pProxyFileList);

HRESULT NdrpRegisterClass(
    IN LPCSTR    pszClassID, 
    IN LPCTSTR   pszClassName,
    IN LPCTSTR   pszDllFileName,
    IN LPCTSTR   pszThreadingModel);

HRESULT NdrpRegisterInterface(
    IN HKEY         hKeyInterface,
    IN REFIID       riid, 
    IN LPCSTR       pszInterfaceName,
    IN LPCSTR       pszClassID,
    IN long         NumMethods,
    IN const IID *  riidAsync 
    );

HRESULT NdrpRegisterAsyncInterface(
    IN HKEY     hKeyInterface,
    IN REFIID   riid, 
    IN LPCSTR   pszSyncInterfaceName,
    IN long     SyncNumMethods,
    IN REFIID   riidAsync
    );

HRESULT NdrpUnregisterClass(
    IN LPCSTR    pszClassID,
    IN LPCTSTR   pszDllFileName);

HRESULT NdrpUnregisterInterface(
    IN HKEY         hKeyInterface,
    IN REFIID       riid,
    IN LPCSTR       pszClassID,
    IN const IID *  riidAsync );


HRESULT RPC_ENTRY NdrDllRegisterProxy (
    IN HMODULE                hDll,
    IN const ProxyFileInfo ** pProxyFileList, 
    IN const CLSID *          pclsid OPTIONAL)
/*++

Routine Description:
    Creates registry entries for the interfaces contained in the proxy DLL.

Arguments:
    hDll            - Supplies a handle to the proxy DLL.
    pProxyFileList  - Supplies a list of proxy files to be registered.
    pclsid          - Supplies the classid for the proxy DLL.  May be zero.

Return Value:
    S_OK

See Also:
    DllRegisterServer
    NdrDllUnregisterProxy

--*/ 
{
    HRESULT hr;
    long    i, j;
    HKEY    hKeyInterface;
    DWORD   dwDisposition;
    TCHAR   szDllFileName[MAX_PATH];
    long    error;
    ULONG   length;
    char    szClassID[39];

    if(hDll != 0)
    {
        //Get the proxy dll name.
        length = GetModuleFileName(hDll,
                                   szDllFileName,
                                   sizeof(szDllFileName));

        if(length > 0)
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        //The proxy DLL's DLL_PROCESS_ATTACH did not initialize hProxyDll.
        hr = E_HANDLE;
    }

    if(SUCCEEDED(hr))
    {
        //Convert the class ID to to a registry key name.
        hr = NdrpGetClassID(szClassID, pclsid, pProxyFileList);
    }

    if(SUCCEEDED(hr))
    {
        //Register the class
        hr = NdrpRegisterClass(szClassID,
                               TEXT("PSFactoryBuffer"),
                               szDllFileName,
                               TEXT("Both"));
    }

    if(SUCCEEDED(hr))
    {
        //Create the Interface key.
        error = RegCreateKeyEx(HKEY_CLASSES_ROOT, 
                               TEXT("Interface"),
                               0, 
                               TEXT("REG_SZ"), 
                               REG_OPTION_NON_VOLATILE,
                               KEY_WRITE,
                               0,
                               &hKeyInterface,
                               &dwDisposition);

        if(!error)
        {
            HRESULT hr2;

            //iterate over the list of proxy files in the proxy DLL.
            for(i = 0; 
                pProxyFileList[i] != 0;
                i++)
                {
                if ( pProxyFileList[i]->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)
                    {
                    // Iterate through sync and async interfaces.

                    for(j = 0;
                        pProxyFileList[i]->pProxyVtblList[j] != 0;
                        j++)
                        {
                        if ( pProxyFileList[i]->pAsyncIIDLookup[j] == 0)
                            {
                            // just a sync interface, no async counterpart.
                            hr2 = NdrpRegisterInterface(hKeyInterface, 
                                                        *pProxyFileList[i]->pStubVtblList[j]->header.piid, 
                                                        pProxyFileList[i]->pNamesArray[j], 
                                                        szClassID,
                                                        pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount,
                                                        0 /* no async */);
                  
                            if(FAILED(hr2) && SUCCEEDED(hr))
                                hr = hr2;
                            }
                        else if ( (ULONG_PTR) pProxyFileList[i]->pAsyncIIDLookup[j] != -1 )
                            {
                            // Register an sync-async pair of interfaces.

                            hr2 = NdrpRegisterInterface(hKeyInterface, 
                                                        *pProxyFileList[i]->pStubVtblList[j]->header.piid, 
                                                        pProxyFileList[i]->pNamesArray[j], 
                                                        szClassID,
                                                        pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount,
                                                        pProxyFileList[i]->pAsyncIIDLookup[j]);
                  
                            if(FAILED(hr2) && SUCCEEDED(hr))
                                hr = hr2;

                            hr2 = NdrpRegisterAsyncInterface(hKeyInterface, 
                                                             *pProxyFileList[i]->pStubVtblList[j]->header.piid, 
                                                             pProxyFileList[i]->pNamesArray[j], 
                                                             pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount,
                                                             *pProxyFileList[i]->pAsyncIIDLookup[j] );
                  
                            if(FAILED(hr2) && SUCCEEDED(hr))
                                hr = hr2;
                            }
                        }
                    }
                else
                    {
                    // Plain old style sync interfaces only.
                    // iterate over the list of interfaces in the proxy file.
                    for(j = 0;
                        pProxyFileList[i]->pProxyVtblList[j] != 0;
                        j++)
                        {
                        hr2 = NdrpRegisterInterface(hKeyInterface, 
                                                    *pProxyFileList[i]->pStubVtblList[j]->header.piid, 
                                                    pProxyFileList[i]->pNamesArray[j], 
                                                    szClassID,
                                                    pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount,
                                                    0 /* no async */);
                  
                        if(FAILED(hr2) && SUCCEEDED(hr))
                            hr = hr2;
                        }
                    }
                }

            RegCloseKey(hKeyInterface);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(error);
        }
    }
    return hr;
 }

HRESULT CheckInprocServer32(
    IN HKEY  hKeyIID,
    IN LPCTSTR pszDllFileName)
{
    HRESULT hr;
    HKEY    hKey;
    TCHAR   szDll[MAX_PATH];
    long    cbData = sizeof(szDll);
    long    error;
    DWORD   dwType;

    //Open the InprocServer32 key.
    error = RegOpenKeyEx(hKeyIID, 
                         TEXT("InprocServer32"),
                         0, 
                         KEY_READ,
                         &hKey);

    if(!error)
    {
        error = RegQueryValueEx(hKey,
                                TEXT(""),
                                0,
                                &dwType,
                                (BYTE*)szDll,
                                (ulong*)&cbData);

        if(!error)
        {
            if(0 == lstrcmpi(pszDllFileName,
                            szDll))
                hr = S_OK;
            else
                hr = REGDB_E_INVALIDVALUE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(error);
        }

        RegCloseKey(hKey);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(error);
    }

    return hr;
}


HRESULT NdrpCheckClass(
    IN LPCSTR    pszClassID, 
    IN LPCTSTR   pszDllFileName)
{
    HRESULT hr;
    long    error;
    HKEY    hKeyCLSID;

    //open the CLSID key
    error = RegOpenKeyEx(HKEY_CLASSES_ROOT, 
                         TEXT("CLSID"),
                         0, 
                         KEY_WRITE,
                         &hKeyCLSID);

    if(!error)
    { 
        HKEY hKeyClassID;

        //open registry key for class ID string
        error = RegOpenKeyExA(hKeyCLSID, 
                              pszClassID,
                              0, 
                              KEY_WRITE,
                              &hKeyClassID);

        if(!error)
        {
            hr = CheckInprocServer32(hKeyClassID,
                                     pszDllFileName);

            RegCloseKey(hKeyClassID);          
        }
        else
        {
            hr = HRESULT_FROM_WIN32(error);
        }

        RegCloseKey(hKeyCLSID);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(error);
    }

    return hr;
}


HRESULT RPC_ENTRY NdrDllUnregisterProxy (
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList, 
    IN const CLSID *            pclsid OPTIONAL)
/*++

Routine Description:
    Removes registry entries for the interfaces contained in the proxy DLL.

Arguments:
    hDll            - Supplies a handle to the proxy DLL.
    pProxyFileList  - Supplies a list of proxy files to be unregistered.
    pclsid          - Supplies the classid for the proxy DLL.  May be zero.

Return Value:
    S_OK

See Also:
    DllUnregisterServer
    NdrDllRegisterProxy

--*/ 
{
    HRESULT hr;
    HKEY    hKeyInterface;
    long    i, j;
    long    error;
    TCHAR   szDllFileName[MAX_PATH];
    ULONG   length;
    char    szClassID[39];

    if(hDll != 0)
    {
        //Get the proxy dll name.
        length = GetModuleFileName(hDll, szDllFileName, sizeof(szDllFileName));

        if(length > 0)
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        //The DLL_PROCESS_ATTACH in the proxy DLL failed to initialize hProxyDll.
        hr = E_HANDLE;
    }

    if(SUCCEEDED(hr))
    {
        //Convert the class ID to a registry key name.
        hr = NdrpGetClassID(szClassID, pclsid, pProxyFileList);
    }

    if(SUCCEEDED(hr))
    {
        //Check the class
        hr = NdrpCheckClass(szClassID, szDllFileName);
    }

    if(SUCCEEDED(hr))
    {
        HRESULT hr2;

        //Open the Interface key.
        error = RegOpenKeyEx(HKEY_CLASSES_ROOT, 
                             TEXT("Interface"),
                             0, 
                             KEY_WRITE,
                             &hKeyInterface);

        if (!error)
            {
            //iterate over the list of proxy files in the proxy DLL.
            for(i = 0; 
                pProxyFileList[i] != 0;
                i++)
                {
                if ( pProxyFileList[i]->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)
                    {
                    // Iterate through sync and async interfaces.
                    for(j = 0;
                        pProxyFileList[i]->pProxyVtblList[j] != 0;
                        j++)
                        {
                        if ( (ULONG_PTR) pProxyFileList[i]->pAsyncIIDLookup[j] != -1 )
                            {
                            // Unegister a single sync only interface or an sync-async
                            // pair of interfaces. Skip async interfaces.

                            NdrpUnregisterInterface( hKeyInterface, 
                                                     *pProxyFileList[i]->pStubVtblList[j]->header.piid,
                                                     szClassID,
                                                     pProxyFileList[i]->pAsyncIIDLookup[j]);
                            }
                        }
                    }
                else
                    {
                    //iterate over the list of interfaces in the proxy file.
                    for(j = 0;
                        pProxyFileList[i]->pProxyVtblList[j] != 0;
                        j++)
                        {
                        NdrpUnregisterInterface(hKeyInterface, 
                                                *pProxyFileList[i]->pStubVtblList[j]->header.piid,
                                                szClassID,
                                                0 /* no async */);
                        }
                    }
                }

            RegCloseKey(hKeyInterface);
            }
        else
            {
            hr = HRESULT_FROM_WIN32(error);
            }

        //Unregister the class
        hr2 = NdrpUnregisterClass(szClassID, szDllFileName);

       if(FAILED(hr2) && SUCCEEDED(hr))
           hr = hr2;
    }

    return hr;
}


HRESULT NdrpGetClassID(
    OUT LPSTR                    pszClassID, 
    IN  const CLSID *            pclsid,
    IN  const ProxyFileInfo **   pProxyFileList)
/*++

Routine Description:
    Gets a string specifying the Class ID for the PSFactoryBuffer.
    If pclsid is NULL, then this function will use the IID of the 
    first interface as the class ID.

Arguments:
    pszClassID      - The Class ID string is returned in this buffer.
    pclsid          - Specifies the class ID.  May be zero.
    pProxyFileList  - Points to a list of ProxyFiles.

Return Value:
    S_OK
    E_NOINTERFACE

--*/ 
{
    HRESULT hr;
    long i, j;

    //If necessary, use the IID of the first interface as the CLSID.
    for(i = 0; 
        (pProxyFileList[i] != 0) && (!pclsid);
        i++)
    {
        for(j = 0;
            (pProxyFileList[i]->pProxyVtblList[j] != 0) && (!pclsid);
            j++)
        {
            pclsid = pProxyFileList[i]->pStubVtblList[j]->header.piid;
        }
    }

    if(pclsid != 0)
    {
        hr = NdrStringFromIID( *pclsid, pszClassID );
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return hr;
}


HRESULT NdrpRegisterClass(
    IN LPCSTR    pszClassID, 
    IN LPCTSTR   pszClassName OPTIONAL,
    IN LPCTSTR   pszDllFileName,
    IN LPCTSTR   pszThreadingModel OPTIONAL)

/*++

Routine Description:
    Creates a registry entry for an in-process server class.

Arguments:
    pszClassID          - Supplies the class ID.
    pszClassName        - Supplies the class name.  May be NULL.
    pszDllFileName      - Supplies the DLL file name.
    pszThreadingModel   - Supplies the threading model. May be NULL.
                          The threading model should be one of the following:
                          "Apartment", "Both", "Free".

Return Value:
    S_OK

See Also:
    NdrDllRegisterProxy  
    NdrpUnregisterClass

--*/ 
{
    HRESULT hr;
    long error;
    HKEY hKeyCLSID;
    HKEY hKeyClassID;
    HKEY hKey;
    DWORD dwDisposition;

    //create the CLSID key
    error = RegCreateKeyEx(HKEY_CLASSES_ROOT, 
                           TEXT("CLSID"),
                           0, 
                           TEXT("REG_SZ"), 
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           0,
                           &hKeyCLSID,
                           &dwDisposition);

    if(!error)
    {  
        //Create registry key for class ID 
        error = RegCreateKeyExA(hKeyCLSID, 
                                pszClassID,
                                0, 
                                "REG_SZ", 
                                REG_OPTION_NON_VOLATILE,
                                KEY_WRITE,
                                0,
                                &hKeyClassID,
                                &dwDisposition);

        if(!error)
        {
            //Create InProcServer32 key for the proxy dll
            error = RegCreateKeyEx(hKeyClassID, 
                                   TEXT("InProcServer32"),
                                   0, 
                                   TEXT("REG_SZ"), 
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_WRITE,
                                   0,
                                   &hKey,
                                   &dwDisposition);

            if(!error)
            {
                //register the proxy DLL filename
                error = RegSetValueEx(hKey, 
                                      TEXT(""), 
                                      0, 
                                      REG_SZ,  
                                      (BYTE*)pszDllFileName,
                                      strlen(pszDllFileName) + 1);

                if((!error) && (pszThreadingModel != 0))
                {
                    //register the threading model for the proxy DLL.
                    error = RegSetValueEx(hKey, 
                                          TEXT("ThreadingModel"), 
                                          0, 
                                          REG_SZ, 
                                          (BYTE*)pszThreadingModel,
                                          strlen(pszThreadingModel) + 1);
                }

                RegCloseKey(hKey);
            }

            if((!error) && (pszClassName != 0))
            {
    	        // put the class name in an unnamed value
                error = RegSetValueEx(hKeyClassID, 
                                      TEXT(""), 
                                      0, 
                                      REG_SZ, 
                                      (BYTE*)pszClassName,
                                      strlen(pszClassName) + 1);
            }

            RegCloseKey(hKeyClassID);          
        }

        RegCloseKey(hKeyCLSID);
    }

    if(!error)
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32(error);

    return hr;
}

HRESULT NdrpRegisterInterface(
    IN HKEY         hKeyInterface,
    IN REFIID       riid, 
    IN LPCSTR       pszInterfaceName,
    IN LPCSTR       pszClassID,
    IN long         NumMethods,
    IN const IID *  riidAsync )

/*++

Routine Description:
    Creates a registry entry for an interface proxy.

Arguments:
    hKeyInterface
    riid
    pszInterfaceName
    pszClassID
    NumMethods
    riidAsync - async iid, may be null.

Return Value:
    S_OK

See Also:
    NdrDllRegisterProxy
    NdrpUnregisterInterface
--*/ 
{
    HRESULT hr;
    long    error;
    char    szIID[39];
    char    szNumMethods[6];
    DWORD   dwDisposition;
    HKEY    hKey;
    HKEY    hKeyIID;

    //convert the IID to a registry key name.
    NdrStringFromIID( riid, szIID );

    //create registry key for the interface
    error = RegCreateKeyExA(hKeyInterface, 
                            szIID,
                            0, 
                            "REG_SZ", 
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE,
                            0,
                            &hKeyIID,
                            &dwDisposition);

    if (!error)
    {
        //create ProxyStubClsid32 key.
        error = RegCreateKeyEx(hKeyIID, 
                               TEXT("ProxyStubClsid32"),
                               0,  
                               TEXT("REG_SZ"), 
                               REG_OPTION_NON_VOLATILE,
                               KEY_WRITE,
                               0,
                               &hKey,
                               &dwDisposition);

        if (!error)
        {
            //Set the class id for the PSFactoryBuffer.
            error = RegSetValueExA(hKey, 
                                   "", 
                                   0, 
                                   REG_SZ, 
                                   (BYTE*)pszClassID,
                                   strlen(pszClassID) + 1);

            RegCloseKey(hKey);
        }
    
    	// put the interface name in the unnamed value
        if(!error)
        {
            error = RegSetValueExA(hKeyIID, 
                                   "", 
                                   0, 
                                   REG_SZ, 
                                   (BYTE*)pszInterfaceName,
                                   strlen(pszInterfaceName) + 1);
        }

        //create NumMethods key.
        if(!error)
        {
            error = RegCreateKeyEx(hKeyIID, 
                                   TEXT("NumMethods"),
                                   0, 
                                   TEXT("REG_SZ"), 
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_WRITE,
                                   0,
                                   &hKey,
                                   &dwDisposition);

            if(!error)
            {
                //Set the number of methods
                RpcItoa( NumMethods, szNumMethods, 10 );

                error = RegSetValueExA(hKey, 
                                       "", 
                                       0, 
                                       REG_SZ, 
                                       (UCHAR *) szNumMethods,
                                       strlen(szNumMethods) + 1);

                RegCloseKey(hKey);
            }
        }


        if ( riidAsync )
            {
            //create AsynchronousInterface key under the interface.
            if(!error)
                {
                error = RegCreateKeyEx( hKeyIID, 
                                        TEXT("AsynchronousInterface"),
                                        0, 
                                        TEXT("REG_SZ"), 
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_WRITE,
                                        0,
                                        &hKey,
                                        &dwDisposition);
    
                if(!error)
                    {
                    // Set the iid as value for the string.

                    NdrStringFromIID( *riidAsync, szIID );

                    error = RegSetValueExA( hKey, 
                                            "", 
                                            0, 
                                            REG_SZ, 
                                            (UCHAR *) szIID,
                                            strlen(szIID) + 1);
    
                    RegCloseKey(hKey);
                    }
                }
            }

        RegCloseKey(hKeyIID);
    }

    if(!error)
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32(error);

    return hr;
}

HRESULT NdrpRegisterAsyncInterface(
    IN HKEY     hKeyInterface,
    IN REFIID   riid, 
    IN LPCSTR   pszSyncInterfaceName,
    IN long     SyncNumMethods,
    IN REFIID   riidAsync )

/*++

Routine Description:
    Creates a registry entry for an async interface proxy.

Arguments:
    hKeyInterface
    riid
    pszInterfaceName
    pszClassID
    NumMethods
    riidAsync

Return Value:
    S_OK

See Also:
    NdrDllRegisterProxy
    NdrpUnregisterInterface
--*/ 
{
    HRESULT hr;
    long    error;
    char    szIID[39];
    char    szNumMethods[6];
    DWORD   dwDisposition;
    HKEY    hKey;
    HKEY    hKeyIID;

    //convert the IID to a registry key name.
    NdrStringFromIID( riidAsync, szIID );

    //create registry key for the interface
    error = RegCreateKeyExA(hKeyInterface, 
                            szIID,
                            0, 
                            "REG_SZ", 
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE,
                            0,
                            &hKeyIID,
                            &dwDisposition);

    // By definition, for async interfaces do not create Clsid32 key.

    // put the interface name in the unnamed value
    if(!error)
    {
        char *  pszAsyncInterfaceName;
        int     len;

        len = 5 + strlen(pszSyncInterfaceName) + 1; /* 5 is strlen("Async") */

        pszAsyncInterfaceName = (char*)alloca(len);
        
        RpcpMemoryCopy( pszAsyncInterfaceName, "Async", 5 );
        RpcpMemoryCopy( pszAsyncInterfaceName + 5, pszSyncInterfaceName, len - 5 );

        error = RegSetValueExA(hKeyIID, 
                               "", 
                               0, 
                               REG_SZ, 
                               (BYTE*)pszAsyncInterfaceName,
                               len);

        //create NumMethods key.
        if(!error)
        {
            long AsyncNumMethods = 2 * SyncNumMethods - 3;
    
            error = RegCreateKeyEx(hKeyIID, 
                                   TEXT("NumMethods"),
                                   0, 
                                   TEXT("REG_SZ"), 
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_WRITE,
                                   0,
                                   &hKey,
                                   &dwDisposition);
    
            if(!error)
            {
                //Set the number of methods
                RpcItoa( AsyncNumMethods, szNumMethods, 10 );
    
                error = RegSetValueExA(hKey, 
                                       "", 
                                       0, 
                                       REG_SZ, 
                                       (UCHAR *) szNumMethods,
                                       strlen(szNumMethods) + 1);
    
                RegCloseKey(hKey);
            }
        }

        //create SynchronousInterface key under the interface.
        if(!error)
            {
            error = RegCreateKeyEx( hKeyIID, 
                                    TEXT("SynchronousInterface"),
                                    0, 
                                    TEXT("REG_SZ"), 
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_WRITE,
                                    0,
                                    &hKey,
                                    &dwDisposition);
    
            if(!error)
                {
                // Set the iid as value for the string.

                NdrStringFromIID( riid, szIID );

                error = RegSetValueExA( hKey, 
                                        "", 
                                        0, 
                                        REG_SZ, 
                                        (UCHAR *) szIID,
                                        strlen(szIID) + 1);
    
                RegCloseKey(hKey);
                }
            }

        RegCloseKey(hKeyIID);
    }

    if(!error)
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32(error);

    return hr;
}



HRESULT NdrpUnregisterClass(
    IN LPCSTR    pszClassID, 
    IN LPCTSTR   pszDllFileName)
/*++

Routine Description:
    Removes an in-process server class from the registry.

Arguments:
    pszClassID - Supplies the class ID.

Return Value:
    S_OK

See Also:
  NdrDllUnregisterProxy
  NdrpRegisterClass

--*/ 
{
    HRESULT hr;
    HKEY    hKeyCLSID;
    HKEY    hKeyClassID;
    long    error;
 
    //open the CLSID key
    error = RegOpenKeyEx(HKEY_CLASSES_ROOT, 
                         TEXT("CLSID"),
                         0, 
                         KEY_WRITE,
                         &hKeyCLSID);

    if(!error)
    { 
        //open registry key for class ID string
        error = RegOpenKeyExA(hKeyCLSID, 
                              pszClassID,
                              0, 
                              KEY_WRITE,
                              &hKeyClassID);

        if(!error)
        {
            hr = CheckInprocServer32(hKeyClassID,
                                     pszDllFileName);

            if(SUCCEEDED(hr))
            {
                //delete InProcServer32 key. 
                error = RegDeleteKey(hKeyClassID,
                                     TEXT("InProcServer32"));

                if(error != 0)
                {
                    hr = HRESULT_FROM_WIN32(error);
                }
            }

            RegCloseKey(hKeyClassID);          
        }
        else
        {
            hr = HRESULT_FROM_WIN32(error);
        }

        if(SUCCEEDED(hr))
        {
            error = RegDeleteKeyA(hKeyCLSID, pszClassID);

            if(error != 0)
            {
                hr = HRESULT_FROM_WIN32(error);
            }
        }

        RegCloseKey(hKeyCLSID);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(error);
    }

    return hr;
}

HRESULT CheckProxyStubClsid32(
    IN HKEY   hKeyIID,
    IN LPCSTR pszClassID)
{
    HRESULT hr;
    HKEY    hKey;
    char    szClassID[39];
    long    cbData = sizeof(szClassID);
    long    error;
    DWORD   dwType;

    //Open the ProxyStubClsid32 key.
    error = RegOpenKeyEx(hKeyIID, 
                         TEXT("ProxyStubClsid32"),
                         0, 
                         KEY_READ,
                         &hKey);

    if(!error)
    {
        error = RegQueryValueExA(hKey,
                                 "",
                                 0,
                                 &dwType,
                                 (BYTE*)szClassID,
                                 (ulong*)&cbData);

        if(!error)
        {
            if(0 == memcmp(szClassID, pszClassID, cbData))
                hr = S_OK;
            else
                hr = REGDB_E_INVALIDVALUE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(error);
        }

        RegCloseKey(hKey);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(error);
    }

    return hr;
}

HRESULT NdrpUnregisterInterface(
    IN HKEY         hKeyInterface,
    IN REFIID       riid, 
    IN LPCSTR       pszClassID,
    IN const IID *  riidAsync )

/*++

Routine Description:
    Unregisters an interface proxy.

Arguments:
    hKeyInterface
    riid

Return Value:
    S_OK


See Also:
    NdrDllUnregisterProxy
    NdrpRegisterInterface

--*/ 
{
    HRESULT hr = S_OK;
    long    error;
    char    szIID[39];
    HKEY    hKeyIID;

    //convert the IID to a registry key name.
    NdrStringFromIID( riid, szIID );

    //Open the IID key.
    error = RegOpenKeyExA(hKeyInterface, 
                          szIID,
                          0, 
                          KEY_WRITE,
                          &hKeyIID);

    if (!error)
        {
        // As we call for sync singles or sync pairs (sync-async),
        // we always have the class id.

        hr = CheckProxyStubClsid32(hKeyIID, pszClassID);
        if(SUCCEEDED(hr))
            {
            // Once the class id matches, just attempt to delete
            // every possible key that may happen under the sync entry.

            // Note that additional key may be present due to oleauto
            // registering a TLB.

            RegDeleteKey(hKeyIID, TEXT("NumMethods"));
            RegDeleteKey(hKeyIID, TEXT("ProxyStubClsid32"));
            RegDeleteKey(hKeyIID, TEXT("AsynchronousInterface"));

            // Now remove the matching async interface entry, if there is one.

            if ( riidAsync )
                {
                char    szAsyncIID[39];
                HKEY    hKeyAsyncIID;

                //convert the IID to a registry key name.
                NdrStringFromIID( *riidAsync, szAsyncIID );
            
                //Open the IID key.
                error = RegOpenKeyExA(hKeyInterface, 
                                      szAsyncIID,
                                      0, 
                                      KEY_WRITE,
                                      &hKeyAsyncIID);

                if ( !error )
                    {
                    RegDeleteKey( hKeyAsyncIID, TEXT("NumMethods"));
                    RegDeleteKey( hKeyAsyncIID, TEXT("SynchronousInterface"));
        
                    RegCloseKey(hKeyAsyncIID);
                    RegDeleteKeyA(hKeyInterface, szAsyncIID);
                    }
            
                }
            }
        else
            hr = S_FALSE;

        //Close the IID key.
        RegCloseKey(hKeyIID);
        RegDeleteKeyA(hKeyInterface, szIID);
        }    

    return hr;
}

STDAPI DllRegisterServer(void)
/*++

Routine Description:
    Creates registry entries for the classes contained in rpcrt4.dll.

Return Value:
    S_OK

--*/ 
{
    HRESULT hr;
    TCHAR   szDllFileName[MAX_PATH];
    ULONG   length;

    if(!g_hRpcrt4)
        return E_HANDLE;

    //Get the proxy dll name.
    length = GetModuleFileName(g_hRpcrt4,
                               szDllFileName,
                               sizeof(szDllFileName));

    if(length > 0)
    {
        //Register the class
        hr = NdrpRegisterClass(TEXT("{b5866878-bd99-11d0-b04b-00c04fd91550}"),
                               TEXT("TypeFactory"),
                               szDllFileName,
                               TEXT("Both"));
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\relmrl.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1998 - 1999 Microsoft Corporation

Module Name :

    relmrl.c

Abstract :

    This file contains release of Marshaled Data (called before unmarshal).

Author :

    Yong Qu (yongqu@microsoft.com) Nov 1998

Revision History :

  ---------------------------------------------------------------------*/

#define USE_STUBLESS_PROXY
#define CINTERFACE
#include "ndrp.h"
#include "ndrole.h"
#include "rpcproxy.h"
#include "hndl.h"
#include "interp2.h"
#include "pipendr.h"
#include "attack.h"
#include "mulsyntx.h"

#include <stddef.h>
#include <stdarg.h>


/* client side: we only care about the [in] part. 
   it's basically like unmarshal on the server side, just that
   we immediately free the buffer (virtual stack) after unmarshalling.
   The call it not necessary always OLE call: one side raw RPC and 
   the other side OLE call is possible: do we support this?

   mostly code from NdrStubCall2, remove irrelavant code. 
*/

#define IN_BUFFER           0
#define OUT_BUFFER          1

#define IsSameDir(dwFlags,param) ((dwFlags == IN_BUFFER)? param.IsIn :param.IsOut)

HRESULT NdrpReleaseMarshalBuffer(
        RPC_MESSAGE *pRpcMsg,
        PFORMAT_STRING pFormat,
        PMIDL_STUB_DESC pStubDesc,
        DWORD dwFlags,
        BOOLEAN fServer)
{
    ushort		            StackSize;

    MIDL_STUB_MESSAGE       StubMsg;

    PPARAM_DESCRIPTION      Params;
    INTERPRETER_FLAGS       InterpreterFlags;
    INTERPRETER_OPT_FLAGS   OptFlags;
    long                    NumberParams;

    long                    n;
    PNDR_PROC_HEADER_EXTS   pHeaderExts = 0;
    HRESULT                 hr = S_OK;

    uchar *             pBuffer;
    PFORMAT_STRING      pFormatComplex;
    PFORMAT_STRING      pFormatTypes;

    NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned at server" );

    // must be auto handle.
    if (FC_AUTO_HANDLE != pFormat[0])
        return E_NOTIMPL;

    InterpreterFlags = *((PINTERPRETER_FLAGS)&pFormat[1]);
    pFormat += InterpreterFlags.HasRpcFlags ? 8 : 4;
    StackSize = *((ushort * &)pFormat)++;

    memset(&StubMsg,0,sizeof(MIDL_STUB_MESSAGE));
    StubMsg.FullPtrXlatTables = 0;


    //
    // Get new interpreter info.
    //
    NdrServerInitialize(pRpcMsg,&StubMsg,pStubDesc);
    SET_WALKIP( StubMsg.uFlags ); 

    OptFlags = *((PINTERPRETER_OPT_FLAGS)&pFormat[4]);

    NumberParams = (long) pFormat[5];

    Params = (PPARAM_DESCRIPTION) &pFormat[6];

    // Proc header extentions, from NDR ver. 5.2.
    // Params must be set correctly here because of exceptions.
    // need to setup correlation information.

    if ( OptFlags.HasExtensions )
        {
        pHeaderExts = (NDR_PROC_HEADER_EXTS *)Params;
        Params = (PPARAM_DESCRIPTION)((uchar*)Params + pHeaderExts->Size);
        StubMsg.fHasExtensions  = 1;
        StubMsg.fHasNewCorrDesc = pHeaderExts->Flags2.HasNewCorrDesc;
        }


    if ( InterpreterFlags.FullPtrUsed )
        StubMsg.FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );

    //
    // context handle is not supported in object
    //

        pFormatTypes = pStubDesc->pFormatTypes;



    // Save the original buffer pointer to restore later.
        pBuffer = StubMsg.Buffer;

    // Get the type format string.
    RpcTryFinally
    {

        RpcTryExcept
        {
        //
        // Check if we need to do any walking .
        //
        if ( (fServer && dwFlags == OUT_BUFFER)
              &&
             (pRpcMsg->DataRepresentation & 0X0000FFFFUL) !=
                      NDR_LOCAL_DATA_REPRESENTATION )
                    {
                    NdrConvert2( &StubMsg,
                                 (PFORMAT_STRING) Params,
                                 NumberParams );
                    }

        for ( n = 0; n < NumberParams; n++ )
            {

            if ( (dwFlags == IN_BUFFER ) &&
                 Params[n].ParamAttr.IsPartialIgnore )
                {
                PMIDL_STUB_MESSAGE pStubMsg = &StubMsg;
                ALIGN( StubMsg.Buffer, 0x3 );
                StubMsg.Buffer += PTR_WIRE_SIZE;
                CHECK_EOB_RAISE_BSD( StubMsg.Buffer );
                continue;
                }

            if ( ! IsSameDir(dwFlags,Params[n].ParamAttr) ||
                    Params[n].ParamAttr.IsPipe)
                continue;

            if ( Params[n].ParamAttr.IsBasetype )
                {
                ALIGN(StubMsg.Buffer, SIMPLE_TYPE_ALIGNMENT( Params[n].SimpleType.Type ));
                StubMsg.Buffer += SIMPLE_TYPE_BUFSIZE( Params[n].SimpleType.Type );
                }
            else
                {
                //
                // Complex type or pointer to complex type.
                //
                pFormatComplex = pFormatTypes + Params[n].TypeOffset;

                (*pfnMemSizeRoutines[ROUTINE_INDEX(*pFormatComplex)])
                    ( &StubMsg,
                      pFormatComplex);
                };
            }
        }
        RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        {
             hr = HRESULT_FROM_WIN32(RpcExceptionCode());
        }
        RpcEndExcept

    }
    RpcFinally
    {
        NdrFullPointerXlatFree( StubMsg.FullPtrXlatTables );

        StubMsg.Buffer = pBuffer;
    }
    RpcEndFinally

    return hr;

}


HRESULT NdrpClientReleaseMarshalBuffer(
        IReleaseMarshalBuffers *pRMB,
        RPC_MESSAGE *pRpcMsg,
        DWORD dwIOFlags,
        BOOLEAN  fAsync )
{
    CStdProxyBuffer *           pProxyBuffer;
    PMIDL_STUBLESS_PROXY_INFO   pProxyInfo;
    CInterfaceProxyHeader *     ProxyHeader;
    long                        ParamSize;
    ushort                      ProcNum;
    ushort                      FormatOffset;
    PFORMAT_STRING              pFormat;
    PMIDL_STUB_DESC             pStubDesc;
    void *                      This;
    HRESULT hr;

    pProxyBuffer = (CStdProxyBuffer *)
                  (((uchar *)pRMB) - offsetof( CStdProxyBuffer, pRMBVtbl ));

    // The channel queries for IReleaseMarshalBuffers interface and gets the interface pointer
    // only when proxy is the new proxy with bigger header, with ProxyInfo.
    // Just in case, check this condition again.
    if ( pRMB == 0 )
        return E_NOTIMPL;

    // quite often OLE pass in NULL buffer. Do an additional check here. 
    if ( NULL == pRpcMsg->Buffer )
        return E_INVALIDARG;    
    
    This = (void *)pProxyBuffer->pProxyVtbl;

    ProxyHeader = (CInterfaceProxyHeader *)
                  ( (char *)This - sizeof(CInterfaceProxyHeader));
    pProxyInfo = (PMIDL_STUBLESS_PROXY_INFO) (ProxyHeader->pStublessProxyInfo);


    // Hack just in case, the bit should not be set up, actually.
    ProcNum = pRpcMsg->ProcNum & ~RPC_FLAGS_VALID_BIT;

    // RPCMSG always has the synchronous proc number;
    if ( fAsync )
        ProcNum = 2 * ProcNum - 3;  // Begin method #

    if ( dwIOFlags != IN_BUFFER )
        return E_NOTIMPL;


    pStubDesc = pProxyInfo->pStubDesc;

#if defined(BUILD_NDR64)
    // check out ndr64
    if ( pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES  )   
        {
        SYNTAX_TYPE             SyntaxType;
        long           i;
        MIDL_SYNTAX_INFO    *   pSyntaxInfo;
        
        SyntaxType = NdrpGetSyntaxType( pRpcMsg->TransferSyntax );

        // branch into ndr64 if SyntaxType is NDR64. fall through otherwise
        if ( XFER_SYNTAX_NDR64 == SyntaxType )
            {
            for ( i = 0; i < (long)pProxyInfo->nCount; i++ )
            {
            if ( SyntaxType == NdrpGetSyntaxType( &pProxyInfo->pSyntaxInfo[i].TransferSyntax ) )
                {
                pSyntaxInfo = &pProxyInfo->pSyntaxInfo[i];
                break;
                }
            }
            return Ndr64pReleaseMarshalBuffer( pRpcMsg, pSyntaxInfo, ProcNum, pStubDesc, dwIOFlags, FALSE );
            }
        }
#endif
        
    FormatOffset = pProxyInfo->FormatStringOffset[ProcNum];
    pFormat      = &((pProxyInfo->ProcFormatString)[FormatOffset]);

    // only support Oicf mode
    if ( (MIDL_VERSION_3_0_39 > pStubDesc->MIDLVersion ) ||
         !(pFormat[1] &  Oi_OBJ_USE_V2_INTERPRETER ))
         return E_NOTIMPL;

    hr = NdrpReleaseMarshalBuffer( pRpcMsg,
                                   pFormat,
                                   pStubDesc,
                                   dwIOFlags, 
                                   FALSE );    // client

    return hr;        
}


HRESULT NdrpServerReleaseMarshalBuffer(
        IReleaseMarshalBuffers *pRMB,
        RPC_MESSAGE *pRpcMsg,
        DWORD dwIOFlags,
        BOOLEAN fAsync)
{
    CStdStubBuffer *        pStubBuffer ;
    PRPC_SERVER_INTERFACE   pServerIfInfo;
    PMIDL_SERVER_INFO       pServerInfo;
    ushort                  ProcNum;

    IUnknown *              pSrvObj;
    CInterfaceStubVtbl *    pStubVTable;

    ushort                  FormatOffset;
    PFORMAT_STRING          pFormat;
    PMIDL_STUB_DESC         pStubDesc;
    HRESULT                 hr;


    pStubBuffer = (CStdStubBuffer *) (((uchar *)pRMB) -
                                    offsetof(CStdStubBuffer, pRMBVtbl));

    // The channel queries for IReleaseMarshalBuffers interface and gets the interface pointer
    // only when proxy is the new proxy with bigger header, with ProxyInfo.
    // Just in case, check this condition again.
    if ( pRMB == 0 )
        return E_NOTIMPL;

    if ( NULL == pRpcMsg->Buffer )
        return E_INVALIDARG;
    
    pSrvObj = (IUnknown * )((CStdStubBuffer *)pStubBuffer)->pvServerObject;

    pStubVTable = (CInterfaceStubVtbl *)
                  ((uchar *)pStubBuffer->lpVtbl - sizeof(CInterfaceStubHeader));

    pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;


    // Hack just in case, this should not be set up, actually.
    ProcNum = pRpcMsg->ProcNum & ~RPC_FLAGS_VALID_BIT;
    
    // RPCMSG always has the synchronous proc number;
    if ( fAsync )
        {
        ProcNum = 2 * ProcNum - 3;  // Begin method #

        if ( dwIOFlags != IN_BUFFER )
            ProcNum++;              // Finish method
        }

    pStubDesc = pServerInfo->pStubDesc;

#if defined(BUILD_NDR64)    
    if ( pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES  )   
        {
        SYNTAX_TYPE             SyntaxType;
        long                    i;
        MIDL_SYNTAX_INFO    *   pSyntaxInfo;
        
        SyntaxType = NdrpGetSyntaxType( pRpcMsg->TransferSyntax );

        if ( XFER_SYNTAX_NDR64 == SyntaxType )
            {
            for ( i = 0; i < (long)pServerInfo->nCount; i++ )
            {
            if ( SyntaxType == NdrpGetSyntaxType( &pServerInfo->pSyntaxInfo[i].TransferSyntax ) )
                {
                pSyntaxInfo = &pServerInfo->pSyntaxInfo[i];
                break;
                }
            }
            return Ndr64pReleaseMarshalBuffer( pRpcMsg, pSyntaxInfo, ProcNum, pStubDesc, dwIOFlags, TRUE );
            }
        }
#endif

    FormatOffset = pServerInfo->FmtStringOffset[ProcNum];
    pFormat = &((pServerInfo->ProcString)[FormatOffset]);
    
    // only support Oicf mode
    if ( (MIDL_VERSION_3_0_39 > pStubDesc->MIDLVersion ) ||
         !(pFormat[1] &  Oi_OBJ_USE_V2_INTERPRETER ))
         return E_NOTIMPL;
         
    hr = NdrpReleaseMarshalBuffer(pRpcMsg,pFormat,pStubDesc,dwIOFlags,TRUE);

    return hr;        
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\srvout.cxx ===
/************************************************************************

Copyright (c) 1993 - 1999 Microsoft Corporation

Module Name :

    srvout.c

Abstract :

    Contains routines for support of [out] parameters on server side during 
    unmarshalling phase. This includes deferral, allocation and handle 
    initialization.

Author :     

    Bruce McQuistan (brucemc)   12/93.

Revision History :

    DKays   10/94   Major comment and code clean up.

 ***********************************************************************/

#include "ndrp.h"
#include "hndl.h"
#include "interp.h"

void
NdrOutInit(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    uchar **                ppArg
    )
/*++

Routine Description :        

    This routine is called to manage server side issues for [out] params 
    such as allocation and context handle initialization. Due to the fact 
    that for [out] conformant objects on stack, their size descriptors may 
    not have been unmarshalled when we need to know their size, this routine 
    must be called after all other unmarshalling has occurred. Really, we 
    could defer only [out], conformant data, but the logic in walking the 
    format string to determine if an object is conformant does not warrant 
    that principle, so all [out] data is deferred.

Arguments :      

    pStubMsg    - Pointer to stub message.
    pFormat     - Format string description for the type.
    ppArg       - Location of argument on stack.

Return :

    None.

 --*/
{
    // This must be a signed long!
    LONG_PTR    Size;  

    //
    // Check for a non-Interface pointer (they have a much different format 
    // than regular pointers).
    //
    if ( IS_BASIC_POINTER(*pFormat) )
        {
        //
        // Check for a pointer to a basetype (we don't have to worry about
        // a non-sized string pointer because these are not allowed as [out]
        // only.
        //
        if ( SIMPLE_POINTER(pFormat[1]) )
            {
            Size = SIMPLE_TYPE_MEMSIZE(pFormat[2]);
            goto DoAlloc;
            }

        //
        // Check for a pointer to a pointer.
        //
        if ( POINTER_DEREF(pFormat[1]) )
            {
            Size = PTR_MEM_SIZE;
            goto DoAlloc;
            }

        // We have a pointer to complex type.

        pFormat += 2;
        pFormat += *(signed short *)pFormat;
        }

    if ( *pFormat == FC_BIND_CONTEXT )
        {
        NDR_SCONTEXT    Context;

        Context = NdrContextHandleInitialize( pStubMsg,
                                              pFormat );

        if ( ! Context )
            RpcRaiseException( RPC_X_SS_CONTEXT_MISMATCH );

        NdrSaveContextHandle(
            pStubMsg,
            Context,
            ppArg,
            pFormat );

        return;
        }

    //
    // Don't initialize tag params if they have a tag routine since they
    // aren't on the stack in this case.
    //
    if ( FC_CS_TAG == *pFormat )
        {
        NDR_CS_TAG_FORMAT  *pTagFormat = (NDR_CS_TAG_FORMAT *) pFormat;

        if ( NDR_INVALID_TAG_ROUTINE_INDEX != pTagFormat->TagRoutineIndex )
            return;
        }

    //
    // If we get here we have to make a call to size a complex type.
    //
    Size = (LONG_PTR) NdrpMemoryIncrement( pStubMsg,
                                          0, 
                                          pFormat );

DoAlloc:

    //
    // Check for a negative size.  This an application error condition for
    // signed size specifiers.
    //
    if ( Size < 0 )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    *ppArg = (uchar*)NdrAllocate( pStubMsg, (size_t) Size);

    MIDL_memset( *ppArg, 0, (size_t) Size );

    // We are almost done, except for an out ref to ref to ... etc.
    // If this is the case keep allocating pointees of ref pointers.

    if ( *pFormat == FC_RP  &&  POINTER_DEREF(pFormat[1]) )
        {
        pFormat += 2;
        pFormat += *(signed short *)pFormat;

        if ( *pFormat == FC_RP )
            NdrOutInit( pStubMsg, pFormat, (uchar **) *ppArg );
        }
}

void
NdrPartialIgnoreServerInitialize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    void **                             ppMemory,
    PFORMAT_STRING                      pFormat
    )
{
    if ( *ppMemory)
        {

        NdrOutInit( pStubMsg, 
                    pFormat,
                    (uchar**)ppMemory );


        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\srvcall.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    srvcall.c

Abstract :

    This file contains the single call Ndr routine for the server side.

Author :

    David Kays    dkays    October 1993.

Revision History :

    brucemc     11/15/93    Added struct by value support, corrected varargs
                            use.
    brucemc     12/20/93    Binding handle support.
    brucemc     12/22/93    Reworked argument accessing method.
    ryszardk    3/12/94     Handle optimization and fixes.

  ---------------------------------------------------------------------*/

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include "ndrp.h"
#include "ndrole.h"
#include "rpcproxy.h"
#include "hndl.h"
#include "interp2.h"
#include "pipendr.h"
#include "attack.h"

#include <stdarg.h>

#if defined(DEBUG_WALKIP)
HRESULT NdrpReleaseMarshalBuffer(
        RPC_MESSAGE *pRpcMsg,
        PFORMAT_STRING pFormat,
        PMIDL_STUB_DESC pStubDesc,
        DWORD dwFlags,
        BOOLEAN fServer);
#endif

#pragma code_seg(".orpc")

#if !defined(__RPC_WIN64__)
// No support for the old interpreter on 64b platforms.

void RPC_ENTRY
NdrServerCall(
    PRPC_MESSAGE    pRpcMsg
    )
/*++

Routine Description :

    Older Server Interpreter entry point for regular RPC procs.

Arguments :

    pRpcMsg     - The RPC message.

Return :

    None.
--*/
{
    ulong dwStubPhase = STUB_UNMARSHAL;

    NdrStubCall( 0,
                 0,
                 pRpcMsg,
                 &dwStubPhase );
}

long RPC_ENTRY
NdrStubCall(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    ulong *                     pdwStubPhase
    )
/*++

Routine Description :

    Older Server Interpreter entry point for object RPC procs.  Also called by
    NdrServerCall, the entry point for regular RPC procs.

Arguments :

    pThis           - Object proc's 'this' pointer, 0 for non-object procs.
    pChannel        - Object proc's Channel Buffer, 0 for non-object procs.
    pRpcMsg         - The RPC message.
    pdwStubPhase    - Used to track the current interpreter's activity.

Return :

    Status of S_OK.

--*/
{
    PRPC_SERVER_INTERFACE   pServerIfInfo;
    PMIDL_SERVER_INFO       pServerInfo;
    PMIDL_STUB_DESC         pStubDesc;
    const SERVER_ROUTINE  * DispatchTable;
    unsigned int            ProcNum;

    ushort                  FormatOffset;
    PFORMAT_STRING          pFormat;

    ushort                  StackSize;

    MIDL_STUB_MESSAGE       StubMsg;

    double                  ArgBuffer[ARGUMENT_COUNT_THRESHOLD];
    REGISTER_TYPE *         pArg;
    ARG_QUEUE_ELEM          QueueElements[QUEUE_LENGTH];
    ARG_QUEUE               ArgQueue;

    int                     ArgNumModifier;
    BOOL                    fUsesSsAlloc;

    //
    // In the case of a context handle, the server side manager function has
    // to be called with NDRSContextValue(ctxthandle). But then we may need to
    // marshall the handle, so NDRSContextValue(ctxthandle) is put in the
    // argument buffer and the handle itself is stored in the following array.
    // When marshalling a context handle, we marshall from this array.
    //
    NDR_SCONTEXT            CtxtHndl[MAX_CONTEXT_HNDL_NUMBER];

    NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned at server" );

    //
    // Initialize the argument queue which is used by NdrServerUnmarshall,
    // NdrServerMarshall, and NdrServerFree.
    //
    ArgQueue.Length = 0;
    ArgQueue.Queue = QueueElements;

    StubMsg.pArgQueue = &ArgQueue;

    ProcNum = pRpcMsg->ProcNum;

    //
    // If OLE, Get a pointer to the stub vtbl and pServerInfo. Else
    // just get the pServerInfo the usual way.
    //
    if ( pThis )
        {
        //
        // pThis is (in unison now!) a pointer to a pointer to a vtable.
        // We want some information in this header, so dereference pThis
        // and assign that to a pointer to a vtable. Then use the result
        // of that assignment to get at the information in the header.
        //
        IUnknown *              pSrvObj;
        CInterfaceStubVtbl *    pStubVTable;

        pSrvObj = (IUnknown * )((CStdStubBuffer *)pThis)->pvServerObject;

        DispatchTable = (SERVER_ROUTINE *)pSrvObj->lpVtbl;

        pStubVTable = (CInterfaceStubVtbl *)
                      (*((uchar **)pThis) - sizeof(CInterfaceStubHeader));

        pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;
        }
    else
        {
        pServerIfInfo = (PRPC_SERVER_INTERFACE)pRpcMsg->RpcInterfaceInformation;
        pServerInfo = (PMIDL_SERVER_INFO)pServerIfInfo->InterpreterInfo;
        DispatchTable = pServerInfo->DispatchTable;
        }

    pStubDesc = pServerInfo->pStubDesc;

    FormatOffset = pServerInfo->FmtStringOffset[ProcNum];
    pFormat = &((pServerInfo->ProcString)[FormatOffset]);

    StackSize = HAS_RPCFLAGS(pFormat[1]) ?
                        *(ushort *)&pFormat[8] :
                        *(ushort *)&pFormat[4];

    fUsesSsAlloc = pFormat[1] & Oi_RPCSS_ALLOC_USED;

    //
    // Set up for context handle management.
    //
    StubMsg.SavedContextHandles = CtxtHndl;
    memset( CtxtHndl, 0, sizeof(CtxtHndl) );

    pArg = (REGISTER_TYPE *) ArgBuffer;

    if ( (StackSize / sizeof(REGISTER_TYPE)) > QUEUE_LENGTH )
        {
        ArgQueue.Queue =
            (ARG_QUEUE_ELEM *)I_RpcAllocate( ((StackSize / sizeof(REGISTER_TYPE)) + 1) *
                                            sizeof(ARG_QUEUE_ELEM) );
        }

    if ( StackSize > MAX_STACK_SIZE )
        {
        pArg = (int*)I_RpcAllocate( StackSize );
        }

    //
    // Zero this in case one of the above allocations fail and we raise an exception
    // and head to the freeing code.
    //
    StubMsg.FullPtrXlatTables = 0;

    //
    // Wrap the unmarshalling, mgr call and marshalling in the try block of
    // a try-finally. Put the free phase in the associated finally block.
    //
    RpcTryFinally
       {
        if ( ! ArgQueue.Queue || ! pArg )
            RpcRaiseException( RPC_S_OUT_OF_MEMORY );

        //
        // Zero out the arg buffer.  We must do this so that parameters
        // are properly zeroed before we start unmarshalling.  If we catch
        // an exception before finishing the unmarshalling we can not leave
        // parameters in an unitialized state since we have to do a freeing
        // pass.
        //
        MIDL_memset( pArg,
                     0,
                     StackSize );

        //
        // If OLE, put pThis in first dword of stack.
        //
        if (pThis != 0)
            pArg[0] = (REGISTER_TYPE)((CStdStubBuffer *)pThis)->pvServerObject;

        StubMsg.fHasReturn = FALSE;

        //
        // Unmarshall all of our parameters.
        //

        ArgNumModifier = NdrServerUnmarshall( pChannel,
                                              pRpcMsg,
                                              &StubMsg,
                                              pStubDesc,
                                              pFormat,
                                              pArg );

        //
        // OLE interfaces use pdwStubPhase in the exception filter.
        // See CStdStubBuffer_Invoke in rpcproxy.c.
        //
        if( pFormat[1] & Oi_IGNORE_OBJECT_EXCEPTION_HANDLING )
            *pdwStubPhase = STUB_CALL_SERVER_NO_HRESULT;
        else
            *pdwStubPhase = STUB_CALL_SERVER;

        //
        // Check for a thunk.  Compiler does all the setup for us.
        //
        if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ProcNum] )
            {
            pServerInfo->ThunkTable[ProcNum]( &StubMsg );
            }
        else
            {
            //
            // Note that this ArgNum is not the number of arguments declared
            // in the function we called, but really the number of
            // REGISTER_TYPEs occupied by the arguments to a function.
            //
            long                ArgNum;
            MANAGER_FUNCTION    pFunc;

            if ( pRpcMsg->ManagerEpv )
                pFunc = ((MANAGER_FUNCTION *)pRpcMsg->ManagerEpv)[ProcNum];
            else
                pFunc = (MANAGER_FUNCTION) DispatchTable[ProcNum];

            ArgNum = (long) StackSize / sizeof(REGISTER_TYPE);

            //
            // The StackSize includes the size of the return. If we want
            // just the number of REGISTER_TYPES, then ArgNum must be reduced
            // by 1 when there is a return value AND the current ArgNum count
            // is greater than 0.  It may also be increased in some cases
            // to cover backward compatability with older stubs which sometimes
            // had wrong stack sizes.
            //
            if ( ArgNum )
                ArgNum += ArgNumModifier;

            NdrCallServerManager( pFunc,
                                  (double *)pArg,
                                  ArgNum,
                                  StubMsg.fHasReturn );
            }

        *pdwStubPhase = STUB_MARSHAL;

        NdrServerMarshall( pThis,
                           pChannel,
                           &StubMsg,
                           pFormat );
        }
    RpcFinally
        {
        //
        // Skip procedure stuff and the per proc binding information.
        //
        pFormat += HAS_RPCFLAGS(pFormat[1]) ? 10 : 6;

        if ( IS_HANDLE(*pFormat) )
            pFormat += (*pFormat == FC_BIND_PRIMITIVE) ?  4 : 6;

        NdrServerFree( &StubMsg,
                       pFormat,
                       pThis );

        //
        // Disable rpcss allocate package if needed.
        //
        if ( fUsesSsAlloc )
            NdrRpcSsDisableAllocate( &StubMsg );

        if ( ((StackSize / sizeof(REGISTER_TYPE)) > QUEUE_LENGTH) &&
             ArgQueue.Queue )
            {
            I_RpcFree( ArgQueue.Queue );
            }

        if ( (StackSize > MAX_STACK_SIZE) && pArg )
            {
            I_RpcFree( pArg );
            }
        }
    RpcEndFinally

    return S_OK;
}

#pragma code_seg()

int RPC_ENTRY
NdrServerUnmarshall(
    struct IRpcChannelBuffer *      pChannel,
    PRPC_MESSAGE                    pRpcMsg,
    PMIDL_STUB_MESSAGE              pStubMsg,
    PMIDL_STUB_DESC                 pStubDescriptor,
    PFORMAT_STRING                  pFormat,
    void *                          pParamList
    )
{
    PFORMAT_STRING      pFormatParam;
    long                StackSize;
    void *              pArg;
    void **             ppArg;
    uchar *             ArgList;
    PARG_QUEUE          pArgQueue;
    PARG_QUEUE_ELEM     pQueue;
    long                Length;
    int                 ArgNumModifier;
    BOOL                fIsOleInterface;
    BOOL                fXlatInit;
    BOOL                fInitRpcSs;
    BOOL                fUsesNewInitRoutine;

  RpcTryExcept
    {
    ArgNumModifier = 0;

    fIsOleInterface     = IS_OLE_INTERFACE( pFormat[1] );
    fXlatInit           = pFormat[1] & Oi_FULL_PTR_USED;
    fInitRpcSs          = pFormat[1] & Oi_RPCSS_ALLOC_USED;
    fUsesNewInitRoutine = pFormat[1] & Oi_USE_NEW_INIT_ROUTINES;

    // Skip to the explicit handle description, if any.
    pFormat += HAS_RPCFLAGS(pFormat[1]) ? 10 : 6;

    //
    // For a handle_t parameter we must pass the handle field of
    // the RPC message to the server manager.
    //
    if ( *pFormat == FC_BIND_PRIMITIVE )
        {
        pArg = (char *)pParamList + *((ushort *)&pFormat[2]);

        if ( IS_HANDLE_PTR(pFormat[1]) )
            pArg = *((void **)pArg);

        *((handle_t *)pArg) = pRpcMsg->Handle;
        }

    // Skip to the param format string descriptions.
    if ( IS_HANDLE(*pFormat) )
        pFormat += (*pFormat == FC_BIND_PRIMITIVE) ?  4 : 6;

    //
    // Set ArgList pointing at the address of the first argument.
    // This will be the address of the first element of the structure
    // holding the arguments in the caller stack.
    //
    ArgList = (uchar*)pParamList;

    //
    // If it's an OLE interface, skip the first long on stack, since in this
    // case NdrStubCall put pThis in the first long on stack.
    //
    if ( fIsOleInterface )
        GET_NEXT_S_ARG(ArgList, REGISTER_TYPE);

    // Initialize the Stub message.
    //
    if ( ! pChannel )
        {
        if ( fUsesNewInitRoutine )
            {
            NdrServerInitializeNew( pRpcMsg,
                                    pStubMsg,
                                    pStubDescriptor );
            }
        else
            {
            NdrServerInitialize( pRpcMsg,
                                 pStubMsg,
                                 pStubDescriptor );
            }
        }
    else
        {
        NdrStubInitialize( pRpcMsg,
                           pStubMsg,
                           pStubDescriptor,
                           pChannel );
        }

    // Call this after initializing the stub.

    if ( fXlatInit )
        pStubMsg->FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );

    //
    // Set StackTop AFTER the initialize call, since it zeros the field
    // out.
    //
    pStubMsg->StackTop = (uchar*)pParamList;

    //
    // We must make this check AFTER the call to ServerInitialize,
    // since that routine puts the stub descriptor alloc/dealloc routines
    // into the stub message.
    //
    if ( fInitRpcSs )
        NdrRpcSsEnableAllocate( pStubMsg );

    //
    // Do endian/floating point conversions if needed.
    //
    if ( (pRpcMsg->DataRepresentation & 0X0000FFFFUL) !=
          NDR_LOCAL_DATA_REPRESENTATION )
        NdrConvert( pStubMsg, pFormat );

    pArgQueue = (PARG_QUEUE) pStubMsg->pArgQueue;

    //
    // --------------------------------------------------------------------
    // Unmarshall Pass.
    // --------------------------------------------------------------------
    //
    pStubMsg->ParamNumber = 0;

    for ( pQueue = pArgQueue->Queue;
          ;
          pStubMsg->ParamNumber++, pArgQueue->Length++, pQueue++ )
        {
        //
        // Clear out flags IsReturn, IsBasetype, IsIn, IsOut,
        // IsOutOnly, IsDeferredFree, IsDontCallFreeInst.
        //
        *((long *)(((char *)pQueue) + 0xc)) = 0;

        //
        // Zero this so that if we catch an exception before finishing the
        // unmarshalling and [out] init passes we won't try to free a
        // garbage pointer.
        //
        pQueue->pArg = 0;

        //
        // Context handles need the parameter number.
        //
        pQueue->ParamNum = (short) pStubMsg->ParamNumber;

        switch ( *pFormat )
            {
            case FC_IN_PARAM_BASETYPE :
                pQueue->IsBasetype = TRUE;

                //
                // We have to inline the simple type unmarshall so that on
                // Alpha, negative longs get properly sign extended.
                //
                switch ( pFormat[1] )
                    {
                    case FC_CHAR :
                    case FC_BYTE :
                    case FC_SMALL :
                        *((REGISTER_TYPE *)ArgList) =
                                (REGISTER_TYPE) *(pStubMsg->Buffer)++;
                        break;

                    case FC_ENUM16 :
                    case FC_WCHAR :
                    case FC_SHORT :
                        ALIGN(pStubMsg->Buffer,1);

                        *((REGISTER_TYPE *)ArgList) =
                                (REGISTER_TYPE) *((ushort *&)pStubMsg->Buffer)++;
                        break;

                    // case FC_FLOAT : not supported on -Oi
                    case FC_LONG :
                    case FC_ENUM32 :
                    case FC_ERROR_STATUS_T:
                        ALIGN(pStubMsg->Buffer,3);

                        *((REGISTER_TYPE *)ArgList) =
                                (REGISTER_TYPE) *((long *&)pStubMsg->Buffer)++;
                        break;

                    // case FC_DOUBLE : not supported on -Oi
                    case FC_HYPER :
                        ALIGN(pStubMsg->Buffer,7);

                        // Let's stay away from casts to doubles.
                        //
                        *((ulong *)ArgList) =
                                *((ulong *&)pStubMsg->Buffer)++;
                        *((ulong *)(ArgList+4)) =
                                *((ulong *&)pStubMsg->Buffer)++;
                        break;

                    case FC_IGNORE :
                        break;

                    default :
                        NDR_ASSERT(0,"NdrServerUnmarshall : bad format char");
                        RpcRaiseException( RPC_S_INTERNAL_ERROR );
                        return 0;
                    } // switch ( pFormat[1] )

                pQueue->pFormat = &pFormat[1];
                pQueue->pArg = ArgList;

                GET_NEXT_S_ARG( ArgList, REGISTER_TYPE);

                if ( pFormat[1] == FC_HYPER )
                    GET_NEXT_S_ARG( ArgList, REGISTER_TYPE);

                pFormat += 2;
                continue;

            case FC_IN_PARAM_NO_FREE_INST :
                pQueue->IsDontCallFreeInst = TRUE;
                // Fall through...

            case FC_IN_PARAM :
                //
                // Here, we break out of the switch statement to the
                // unmarshalling code below.
                //
                break;

            case FC_IN_OUT_PARAM :
                pQueue->IsOut = TRUE;
                //
                // Here, we break out of the switch statement to the
                // unmarshalling code below.
                //
                break;

            case FC_OUT_PARAM :
                pQueue->IsOut = TRUE;
                pQueue->IsOutOnly = TRUE;

                pFormat += 2;
                pFormatParam = pStubDescriptor->pFormatTypes +
                               *((short *)pFormat);
                pFormat += 2;

                pQueue->pFormat = pFormatParam;
                pQueue->ppArg = (uchar **)ArgList;

                //
                // An [out] param ALWAYS eats up 4 bytes of stack space.
                //
                GET_NEXT_S_ARG(ArgList, REGISTER_TYPE);
                continue;

            case FC_RETURN_PARAM :
                pQueue->IsOut = TRUE;
                pQueue->IsReturn = TRUE;

                pFormatParam = pStubDescriptor->pFormatTypes +
                               *((short *)(pFormat + 2));

                pQueue->pFormat = pFormatParam;

                if ( IS_BY_VALUE(*pFormatParam) )
                    {
                    pQueue->pArg = (uchar *) ArgList;
                    pQueue->ppArg = &(pQueue->pArg);
                    }
                else
                    pQueue->ppArg = (uchar **) ArgList;

                //
                // Context handle returned by value is the only reason for
                // this case here as a context handle has to be initialized.
                // A context handle cannot be returned by a pointer.
                //
                if ( *pFormatParam == FC_BIND_CONTEXT )
                    {
                    pStubMsg->SavedContextHandles[pStubMsg->ParamNumber] =
                        NdrContextHandleInitialize(
                            pStubMsg,
                            pFormatParam);
                            }
                        //
                // The return variable is used in modifying the stacksize
                // given us by midl, in order to compute how many
                // REGISTER_SIZE items to pass into the manager function.
                //
                ArgNumModifier--;

                pStubMsg->fHasReturn = TRUE;

                pArgQueue->Length++;

                goto UnmarshallLoopExit;

            case FC_RETURN_PARAM_BASETYPE :
                pQueue->IsOut = TRUE;
                pQueue->IsReturn = TRUE;
                pQueue->IsBasetype = TRUE;

                pQueue->pFormat = &pFormat[1];
                pQueue->pArg = ArgList;

                //
                // The return variable is used in modifying the stacksize
                // given us by midl, in order to compute how many
                // REGISTER_SIZE items to pass into the manager function.
                //
                ArgNumModifier--;

                pStubMsg->fHasReturn = TRUE;

                pArgQueue->Length++;

                goto UnmarshallLoopExit;

            default :
                goto UnmarshallLoopExit;
            } // end of unmarshall pass switch

        //
        // Now get what ArgList points at and increment over it.
        // In the current implementation, what we want is not on the stack
        // of the manager function, but is a local in the manager function.
        // Thus the code for ppArg below.
        //
        ppArg = (void **)ArgList;
        GET_NEXT_S_ARG( ArgList, REGISTER_TYPE);

        //
        // Get the parameter's format string description.
        //
        pFormat += 2;
        pFormatParam = pStubDescriptor->pFormatTypes + *((short *)pFormat);

        //
        // Increment main format string past offset field.
        //
        pFormat += 2;

        //
        // We must get a double pointer to structs, unions and xmit/rep as.
        //
        // On MIPS and PPC, an 8 byte aligned structure is passed at an 8 byte
        // boundary on the stack.  On PowerPC 4 bytes aligned structures which
        // are 8 bytes or larger in size are also passed at an 8 byte boundary.
        // We check for these cases here and increment our ArgList pointer
        // an additional 'int' if necessary to get to the structure.
        //
        if ( IS_BY_VALUE(*pFormatParam) )
            {
            pArg = ppArg;
            ppArg = &pArg;
            }

        (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormatParam)])
        ( pStubMsg,
          (uchar **)ppArg,
          pFormatParam,
          FALSE );

        pQueue->pFormat = pFormatParam;
        pQueue->pArg = (uchar*)*ppArg;

        //
        // The second byte of a param's description gives the number of
        // ints occupied by the param on the stack.
        //
        StackSize = pFormat[-3] * sizeof(int);

        if ( StackSize > sizeof(REGISTER_TYPE) )
            {
            StackSize -= sizeof(REGISTER_TYPE);
            ArgList += StackSize;
            }
        } // Unmarshalling loop.

UnmarshallLoopExit:

    for ( Length = pArgQueue->Length, pQueue = pArgQueue->Queue;
          Length--;
          pQueue++ )
        {
        if ( pQueue->IsOutOnly )
            {
            pStubMsg->ParamNumber = pQueue->ParamNum;

            NdrOutInit( pStubMsg,
                        pQueue->pFormat,
                        pQueue->ppArg );

            pQueue->pArg = *(pQueue->ppArg);
            }
        }
    }
  RpcExcept( RPC_BAD_STUB_DATA_EXCEPTION_FILTER )
    {
    // Filter set in rpcndr.h to catch one of the following
    //     STATUS_ACCESS_VIOLATION
    //     STATUS_DATATYPE_MISALIGNMENT
    //     RPC_X_BAD_STUB_DATA

    RpcRaiseException( RPC_X_BAD_STUB_DATA );
    }
  RpcEndExcept

    if ( pRpcMsg->BufferLength  <
         (uint)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer) )
        {
        NDR_ASSERT( 0, "NdrStubCall unmarshal: buffer overflow!" );
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

    return ArgNumModifier;
}

void RPC_ENTRY
NdrServerMarshall(
    struct IRpcStubBuffer *    pThis,
    struct IRpcChannelBuffer * pChannel,
    PMIDL_STUB_MESSAGE         pStubMsg,
    PFORMAT_STRING             pFormat )
{
    PFORMAT_STRING      pFormatParam;
    PARG_QUEUE          pArgQueue;
    PARG_QUEUE_ELEM     pQueue;
    long                Length;

    pArgQueue = (PARG_QUEUE)pStubMsg->pArgQueue;

    //
    // Remove?
    //
    pStubMsg->Memory = 0;

    //
    // -------------------------------------------------------------------
    // Sizing Pass.
    // -------------------------------------------------------------------
    //

    for ( Length = pArgQueue->Length, pQueue = pArgQueue->Queue;
          Length--;
          pQueue++ )
        {
        if ( pQueue->IsOut )
            {
            //
            // Must do some special handling for return values.
            //
            if ( pQueue->IsReturn )
                {
                if ( pQueue->IsBasetype )
                    {
                    //
                    // Add worse case size of 16 for a simple type return.
                    //
                    pStubMsg->BufferLength += 16;
                    continue;
                    }

                //
                // Get the value returned by the server.
                //
                pQueue->pArg = *(pQueue->ppArg);

                //
                // We have to do an extra special step for context handles
                // which are function return values.
                //
                // In the unmarshalling phase, we unmarshalled the context
                // handle for the return case. But the function we called put
                // the user context in the arglist buffer. Before we marshall
                // the context handle, we have to put the user context in it.
                //
                if ( pQueue->pFormat[0] == FC_BIND_CONTEXT )
                    {
                    NDR_SCONTEXT    SContext;
                    long            ParamNum;

                    ParamNum = pQueue->ParamNum;

                    SContext = pStubMsg->SavedContextHandles[ParamNum];

                    *((uchar **)NDRSContextValue(SContext)) = pQueue->pArg;
                    }
                }

            pFormatParam = pQueue->pFormat;

            (*pfnSizeRoutines[ROUTINE_INDEX(*pFormatParam)])
            ( pStubMsg,
              pQueue->pArg,
              pFormatParam );
            }
        }

    if ( ! pChannel )
        NdrGetBuffer( pStubMsg,
                      pStubMsg->BufferLength,
                      0 );
    else
        NdrStubGetBuffer( pThis,
                          pChannel,
                          pStubMsg );

    //
    // -------------------------------------------------------------------
    // Marshall Pass.
    // -------------------------------------------------------------------
    //

    for ( Length = pArgQueue->Length, pQueue = pArgQueue->Queue;
          Length--;
          pQueue++ )
        {
        if ( pQueue->IsOut )
            {
            if ( pQueue->IsBasetype )
                {
                //
                // Only possible as a return value.
                //
                NdrSimpleTypeMarshall( pStubMsg,
                                       pQueue->pArg,
                                       pQueue->pFormat[0] );
                }
            else
                {
                pFormatParam = pQueue->pFormat;

                //
                // We need this if we're marshalling a context handle.
                //
                pStubMsg->ParamNumber = pQueue->ParamNum;

                (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormatParam)])
                ( pStubMsg,
                  pQueue->pArg,
                  pFormatParam );
                }
            }
        }

    if ( pStubMsg->RpcMsg->BufferLength  <
         (uint)(pStubMsg->Buffer - (uchar *)pStubMsg->RpcMsg->Buffer) )
        {
        NDR_ASSERT( 0, "NdrStubCall marshal: buffer overflow!" );
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

    pStubMsg->RpcMsg->BufferLength =
            pStubMsg->Buffer - (uchar *) pStubMsg->RpcMsg->Buffer;
}

void
NdrServerFree(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    void *              pThis
    )
{
    PARG_QUEUE          pArgQueue;
    PARG_QUEUE_ELEM     pQueue;
    long                Length;
    PFORMAT_STRING      pFormatParam;
    uchar *             pArg;

    pArgQueue = (PARG_QUEUE)pStubMsg->pArgQueue;

    for ( Length = pArgQueue->Length, pQueue = pArgQueue->Queue;
          Length--;
          pQueue++ )
        {
        if ( pQueue->IsBasetype )
            continue;

        pFormatParam = pQueue->pFormat;

        //
        // We have to defer the freeing of pointers to base types in case
        // the parameter is [in,out] or [out] and is the size, length, or
        // switch specifier for an array, a pointer, or a union.  This is
        // because we can't free the pointer to base type before we free
        // the data structure which uses the pointer to determine it's size.
        //
        // Note that to make the check as simple as possible [in] only
        // pointers to base types will be included, as will string pointers
        // of any direction.
        //
        if ( IS_BASIC_POINTER(*pFormatParam) &&
             SIMPLE_POINTER(pFormatParam[1]) )
            {
            pQueue->IsDeferredFree = TRUE;
            continue;
            }

        pStubMsg->fDontCallFreeInst =
                pQueue->IsDontCallFreeInst;

        (*pfnFreeRoutines[ROUTINE_INDEX(*pFormatParam)])
        ( pStubMsg,
          pQueue->pArg,
          pFormatParam );

        //
        // Have to explicitly free arrays and strings.  But make sure it's
        // non-null and not sitting in the buffer.
        //
        if ( IS_ARRAY_OR_STRING(*pFormatParam) )
            {
            pArg = pQueue->pArg;

            //
            // We have to make sure the array/string is non-null in case we
            // get an exception before finishing our unmarshalling.
            //
            if ( pArg &&
                 ( (pArg < pStubMsg->BufferStart) ||
                   (pArg > pStubMsg->BufferEnd) ) )
                (*pStubMsg->pfnFree)( pArg );
            }
        }

    for ( Length = pArgQueue->Length, pQueue = pArgQueue->Queue;
          Length--;
          pQueue++ )
        {
        if ( pQueue->IsDeferredFree )
            {
            NDR_ASSERT( IS_BASIC_POINTER(*(pQueue->pFormat)),
                        "NdrServerFree : bad defer logic" );

            NdrPointerFree( pStubMsg,
                            pQueue->pArg,
                            pQueue->pFormat );
            }
        }

    //
    // Free any full pointer resources.
    //
    if ( pStubMsg->FullPtrXlatTables )
        NdrFullPointerXlatFree( pStubMsg->FullPtrXlatTables );
}

#endif // !defined(__RPC_WIN64__)

#pragma code_seg(".orpc")

void
NdrUnmarshallBasetypeInline(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pArg,
    uchar               Format
    )
{
    switch ( Format )
        {
        case FC_CHAR :
        case FC_BYTE :
        case FC_SMALL :
        case FC_USMALL :
            *((REGISTER_TYPE *)pArg) = (REGISTER_TYPE)
                                       *(pStubMsg->Buffer)++;
            break;

        case FC_ENUM16 :
        case FC_WCHAR :
        case FC_SHORT :
        case FC_USHORT :
            ALIGN(pStubMsg->Buffer,1);

            *((REGISTER_TYPE *)pArg) = (REGISTER_TYPE)
                                       *((ushort *&)pStubMsg->Buffer)++;
            break;

        case FC_FLOAT : 
        case FC_LONG :
        case FC_ULONG :
        case FC_ENUM32 :
        case FC_ERROR_STATUS_T:
            ALIGN(pStubMsg->Buffer,3);

            *((REGISTER_TYPE *)pArg) = (REGISTER_TYPE)
                                       *((long *&)pStubMsg->Buffer)++;
            break;

#if defined(__RPC_WIN64__)
        case FC_INT3264: 
            ALIGN(pStubMsg->Buffer,3);
            *((REGISTER_TYPE *)pArg) = (REGISTER_TYPE)
                                       *((long *&)pStubMsg->Buffer)++;
            break;

        case FC_UINT3264: 
            // REGISTER_TYPE is a signed integral.
            ALIGN(pStubMsg->Buffer,3);
            *((UINT64 *)pArg) = (UINT64) *((ulong * &)pStubMsg->Buffer)++;
            break;
#endif

        case FC_DOUBLE :
        case FC_HYPER :
            ALIGN(pStubMsg->Buffer,7);

            *((ulong *)pArg) = *((ulong *&)pStubMsg->Buffer)++;
            *((ulong *)(pArg+4)) = *((ulong *&)pStubMsg->Buffer)++;
            break;

        default :
            NDR_ASSERT(0,"NdrUnmarshallBasetypeInline : bad format char");
            break;
        }
}

#if !defined(__RPC_WIN64__)

void
NdrCallServerManager(
    MANAGER_FUNCTION    pFtn,
    double *            pArgs,
    ulong               NumRegisterArgs,
    BOOL                fHasReturn )
{

    REGISTER_TYPE       returnValue;
    REGISTER_TYPE     * pArg;

    pArg = (REGISTER_TYPE *)pArgs;

    //
    // If we don't have a return value, make sure we don't write past
    // the end of our argument buffer!
    //
    returnValue = Invoke(pFtn, 
                         (REGISTER_TYPE *) pArgs, 
                         NumRegisterArgs);

    if ( fHasReturn )
            pArg[NumRegisterArgs] = returnValue;

}

#endif // !defined(__RPC_WIN64__)

void RPC_ENTRY
NdrServerCall2(
    PRPC_MESSAGE    pRpcMsg
    )
/*++

Routine Description :

    Server Interpreter entry point for regular RPC procs.

Arguments :

    pRpcMsg     - The RPC message.

Return :

    None.

--*/
{
    ulong dwStubPhase = STUB_UNMARSHAL;

    NdrStubCall2( 0,
                  0,
                  pRpcMsg,
                  &dwStubPhase );
}

long RPC_ENTRY
NdrStubCall2(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    ulong *                     pdwStubPhase
    )
/*++

Routine Description :

    Server Interpreter entry point for object RPC procs.  Also called by
    NdrServerCall, the entry point for regular RPC procs.

Arguments :

    pThis           - Object proc's 'this' pointer, 0 for non-object procs.
    pChannel        - Object proc's Channel Buffer, 0 for non-object procs.
    pRpcMsg         - The RPC message.
    pdwStubPhase    - Used to track the current interpreter's activity.

Return :

    Status of S_OK.

--*/
{
    PRPC_SERVER_INTERFACE   pServerIfInfo;
    PMIDL_SERVER_INFO       pServerInfo;
    PMIDL_STUB_DESC         pStubDesc;
    const SERVER_ROUTINE  * DispatchTable;
    ushort                  ProcNum;

    ushort                  FormatOffset;
    PFORMAT_STRING          pFormat;

    MIDL_STUB_MESSAGE       StubMsg;

    uchar *                 pArgBuffer;
    uchar *                 pArg;
#if defined(_M_IX86) && (_MSC_FULL_VER <= 13008982)
    volatile BOOL           fBadStubDataException = FALSE;
#else
    BOOL                    fBadStubDataException = FALSE;
#endif
    ulong                   n;

    PNDR_PROC_HEADER_EXTS   pHeaderExts = 0;
    boolean                 NotifyAppInvoked = FALSE;
    NDR_PROC_CONTEXT        ProcContext;

    //
    // In the case of a context handle, the server side manager function has
    // to be called with NDRSContextValue(ctxthandle). But then we may need to
    // marshall the handle, so NDRSContextValue(ctxthandle) is put in the
    // argument buffer and the handle itself is stored in the following array.
    // When marshalling a context handle, we marshall from this array.
    //
    NDR_SCONTEXT            CtxtHndl[MAX_CONTEXT_HNDL_NUMBER];

    ProcNum = (ushort) pRpcMsg->ProcNum;

    NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned at server" );

    //
    // If OLE, Get a pointer to the stub vtbl and pServerInfo. Else
    // just get the pServerInfo the usual way.
    //
    if ( pThis )
    {
        //
        // pThis is (in unison now!) a pointer to a pointer to a vtable.
        // We want some information in this header, so dereference pThis
        // and assign that to a pointer to a vtable. Then use the result
        // of that assignment to get at the information in the header.
        //
        IUnknown *              pSrvObj;
        CInterfaceStubVtbl *    pStubVTable;

        pSrvObj = (IUnknown * )((CStdStubBuffer *)pThis)->pvServerObject;

        DispatchTable = (SERVER_ROUTINE *)pSrvObj->lpVtbl;

        pStubVTable = (CInterfaceStubVtbl *)
                      (*((uchar **)pThis) - sizeof(CInterfaceStubHeader));

        pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;
    }
    else
    {
        pServerIfInfo = (PRPC_SERVER_INTERFACE)pRpcMsg->RpcInterfaceInformation;
        pServerInfo = (PMIDL_SERVER_INFO)pServerIfInfo->InterpreterInfo;
        DispatchTable = pServerInfo->DispatchTable;
    }

    pStubDesc = pServerInfo->pStubDesc;

    FormatOffset = pServerInfo->FmtStringOffset[ProcNum];
    pFormat      = &((pServerInfo->ProcString)[FormatOffset]);

    MulNdrpInitializeContextFromProc( XFER_SYNTAX_DCE, pFormat, &ProcContext, NULL );
    
    //
    // Yes, do this here outside of our RpcTryFinally block.  If we
    // can't allocate the arg buffer there's nothing more to do, so
    // raise an exception and return control to the RPC runtime.
    //
    // Alloca throws an exception on an error.
    
    pArgBuffer = (uchar*)alloca(ProcContext.StackSize);

    //
    // Zero out the arg buffer.  We must do this so that parameters
    // are properly zeroed before we start unmarshalling.  If we catch
    // an exception before finishing the unmarshalling we can not leave
    // parameters in an unitialized state since we have to do a freeing
    // pass.
    //
    MIDL_memset( pArgBuffer,
                 0,
                 ProcContext.StackSize );

    // we have to setup this again because we don't know the size when
    // initializing the proc context.
    ProcContext.StartofStack = pArgBuffer;
    StubMsg.pContext = &ProcContext;
    // We need to setup stack AFTER proc header is read so we can
    // know how big the virtual stack is.
    

    //
    // Set up for context handle management.
    //
    StubMsg.SavedContextHandles = CtxtHndl;
    memset( CtxtHndl, 0, sizeof(CtxtHndl) );

    if ( ProcContext.NdrInfo.pProcDesc->Oi2Flags.HasExtensions )
        pHeaderExts = &ProcContext.NdrInfo.pProcDesc->NdrExts;
    //
    // Wrap the unmarshalling, mgr call and marshalling in the try block of
    // a try-finally. Put the free phase in the associated finally block.
    //
    RpcTryFinally
    {
        // General server initializaiton (NULL async message)
        NdrpServerInit( &StubMsg, pRpcMsg, pStubDesc, pThis, pChannel, NULL );

        // Raise exceptions after initializing the stub.

        RpcTryExcept
            {

            // --------------------------------
            // Unmarshall all of our parameters.
            // --------------------------------

            NdrpServerUnMarshal( &StubMsg );
            
            if ( pRpcMsg->BufferLength  <
                 (uint)(StubMsg.Buffer - (uchar *)pRpcMsg->Buffer) )
                {
                RpcRaiseException( RPC_X_BAD_STUB_DATA );
                }

            }
        RpcExcept( NdrServerUnmarshallExceptionFlag(GetExceptionInformation()) )
            {
            // Filter set in rpcndr.h to catch one of the following
            //     STATUS_ACCESS_VIOLATION
            //     STATUS_DATATYPE_MISALIGNMENT
            //     RPC_X_BAD_STUB_DATA

            NdrpFreeMemoryList( &StubMsg );

            fBadStubDataException = TRUE;
            if ( RPC_BAD_STUB_DATA_EXCEPTION_FILTER )
                RpcRaiseException( RPC_X_BAD_STUB_DATA );
            else
                RpcRaiseException( RpcExceptionCode() );
            }
        RpcEndExcept

        NdrpServerOutInit( &StubMsg );
        //
        // Do [out] initialization.
        //

        //
        // Unblock the first pipe; this needs to be after unmarshalling
        // because the buffer may need to be changed to the secondary one.
        // In the out only pipes case this happens immediately.
        //

        if ( ProcContext.HasPipe )
            NdrMarkNextActivePipe( ProcContext.pPipeDesc );

        //
        // OLE interfaces use pdwStubPhase in the exception filter.
        // See CStdStubBuffer_Invoke in rpcproxy.c.
        //
        if( pFormat[1] & Oi_IGNORE_OBJECT_EXCEPTION_HANDLING )
            *pdwStubPhase = STUB_CALL_SERVER_NO_HRESULT;
        else
            *pdwStubPhase = STUB_CALL_SERVER;

        NotifyAppInvoked = TRUE;
        //
        // Check for a thunk.  Compiler does all the setup for us.
        //
        if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ProcNum] )
            {
            pServerInfo->ThunkTable[ProcNum]( &StubMsg );
            }
        else
            {
            //
            // Note that this ArgNum is not the number of arguments declared
            // in the function we called, but really the number of
            // REGISTER_TYPEs occupied by the arguments to a function.
            //
            long                ArgNum;
            MANAGER_FUNCTION    pFunc;
            REGISTER_TYPE       returnValue;

            if ( pRpcMsg->ManagerEpv )
                pFunc = ((MANAGER_FUNCTION *)pRpcMsg->ManagerEpv)[ProcNum];
            else
                pFunc = (MANAGER_FUNCTION) DispatchTable[ProcNum];

            ArgNum = (long) ProcContext.StackSize / sizeof(REGISTER_TYPE);
           
            //
            // The StackSize includes the size of the return. If we want
            // just the number of REGISTER_TYPES, then ArgNum must be reduced
            // by 1 when there is a return value AND the current ArgNum count
            // is greater than 0.
            //
            if ( ArgNum && 
                 ProcContext.NdrInfo.pProcDesc->Oi2Flags.HasReturn && 
                 !ProcContext.HasComplexReturn )
                ArgNum--;

            returnValue = Invoke( pFunc, 
                                  (REGISTER_TYPE *)pArgBuffer,
                          #if defined(_IA64_)
                                  pHeaderExts != NULL ? ((PNDR_PROC_HEADER_EXTS64)pHeaderExts)->FloatArgMask
                                                      : 0,
                          #endif
                                  ArgNum);

            if( ProcContext.NdrInfo.pProcDesc->Oi2Flags.HasReturn)            
                {
                if ( !ProcContext.HasComplexReturn )
                    ((REGISTER_TYPE *)pArgBuffer)[ArgNum] = returnValue;

                // Pass the app's return value to OLE channel
                if ( pThis )
                    (*pfnDcomChannelSetHResult)( pRpcMsg, 
                                                 NULL,   // reserved
                                                 (HRESULT) returnValue );
                }
            }

        // Important for context handle cleanup.
        *pdwStubPhase = STUB_MARSHAL;

            if ( ProcContext.HasPipe )
                {
                NdrIsAppDoneWithPipes( ProcContext.pPipeDesc );
                StubMsg.BufferLength += ProcContext.NdrInfo.pProcDesc->ServerBufferSize;
                }
            else
                StubMsg.BufferLength = ProcContext.NdrInfo.pProcDesc->ServerBufferSize;
    
            if ( ProcContext.NdrInfo.pProcDesc->Oi2Flags.ServerMustSize )
                {
                //
                // Buffer size pass.
                //
                NdrpSizing( &StubMsg, 
                            FALSE );    // is server
                }
    
            if ( ProcContext.HasPipe && ProcContext.pPipeDesc->OutPipes ) 
                {
                NdrGetPartialBuffer( & StubMsg );
                StubMsg.RpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;
                }
            else
                {
                if ( ! pChannel )
                    {
                    NdrGetBuffer( &StubMsg,
                                  StubMsg.BufferLength,
                                  0 );
                    }
                else
                    NdrStubGetBuffer( pThis,
                                      pChannel,
                                      &StubMsg );
                }
    
            //
            // Marshall pass.
            //
            NdrpServerMarshal( &StubMsg,
                               ( pThis != NULL ) );
                               
            pRpcMsg->BufferLength = (ulong) ( StubMsg.Buffer - (uchar *) pRpcMsg->Buffer );

#if defined(DEBUG_WALKIP)
        if ( pChannel )
            {
            NdrpReleaseMarshalBuffer(
                StubMsg.RpcMsg,
                pFormat,
                StubMsg.StubDesc,
                1, //BUFFER_OUT
                true );
            }
#endif

        }
    RpcFinally
        {
        // clean up context handles if exception is thrown in either marshalling or 
        // manager routine. 

        if ( RpcAbnormalTermination()  && ! pChannel )
            {
            NdrpCleanupServerContextHandles( &StubMsg,
                                             pArgBuffer,
                                             STUB_MARSHAL != *pdwStubPhase);
            }

        // If we died because of bad stub data, don't free the params here since they
        // were freed using a linked list of memory in the exception handler above.

        if ( ! fBadStubDataException )
            {
            NdrpFreeParams( &StubMsg,
                            ProcContext.NumberParams,
                            ( PARAM_DESCRIPTION * )ProcContext.Params,
                            pArgBuffer );
            }

        //
        // Deferred frees.  Actually, this should only be necessary if you
        // had a pointer to enum16 in a *_is expression.
        //

        //
        // Free any full pointer resources.
        //
        NdrFullPointerXlatFree( StubMsg.FullPtrXlatTables );

        //
        // Disable rpcss allocate package if needed.
        //
        if ( ProcContext.NdrInfo.InterpreterFlags.RpcSsAllocUsed )
            NdrRpcSsDisableAllocate( &StubMsg );

        //
        // Clean up pipe objects
        //

        NdrCorrelationFree( &StubMsg );

        NdrpAllocaDestroy( &ProcContext.AllocateContext );
         
        if ( pHeaderExts != 0  
             && ( pHeaderExts->Flags2.HasNotify 
                    || pHeaderExts->Flags2.HasNotify2 ) )
            {
            NDR_NOTIFY_ROUTINE     pfnNotify;

            pfnNotify = StubMsg.StubDesc->NotifyRoutineTable[ pHeaderExts->NotifyIndex ];

            if ( pHeaderExts->Flags2.HasNotify2 )
                {
                ((NDR_NOTIFY2_ROUTINE)pfnNotify)(NotifyAppInvoked);
                }
            else
                pfnNotify();
            }
        }
    RpcEndFinally

    return S_OK;
}

void
NdrpFreeParams(
    MIDL_STUB_MESSAGE       * pStubMsg,
    long                    NumberParams,
    PPARAM_DESCRIPTION      Params,
    uchar *                 pArgBuffer 
    )
/*++

Routine Description :

    Frees the memory associated with function parameters as required.

Arguments :

    pStubMsg     - Supplies a pointer to the stub message.
    NumberParams - Supplies the number of parameters for this procedure.
    Params       - Supplies a pointer to the parameter list for this function.
    pArgBuffer   - Supplies a pointer to the virtual stack.
    pParamFilter - Supplies a filter that is used to determine which functions
                   are to be considered.  This function should return TRUE if
                   the parameter should be considered.   If pParamFilter is NULL,
                   the default filter is used which is all parameters that have
                   MustFree set. 

Return :

    None.

--*/
{

    long n;
    PMIDL_STUB_DESC         pStubDesc      = pStubMsg->StubDesc;

    PFORMAT_STRING          pFormatParam;
    uchar *                 pArg;

    for ( n = 0; n < NumberParams; n++ )
        {
        
        if ( ! Params[n].ParamAttr.MustFree )
            continue;

        pArg = pArgBuffer + Params[n].StackOffset;

        if ( ! Params[n].ParamAttr.IsByValue )
            pArg = *((uchar **)pArg);

        pFormatParam = pStubDesc->pFormatTypes +
                       Params[n].TypeOffset;

        if ( pArg )
            {
            pStubMsg->fDontCallFreeInst =
                    Params[n].ParamAttr.IsDontCallFreeInst;

            (*pfnFreeRoutines[ROUTINE_INDEX(*pFormatParam)])
                ( pStubMsg,
                  pArg,
                  pFormatParam );
            }

        //
        // We have to check if we need to free any simple ref pointer,
        // since we skipped it's NdrPointerFree call.  We also have
        // to explicitly free arrays and strings.  But make sure it's
        // non-null and not sitting in the buffer.
        //
        if ( Params[n].ParamAttr.IsSimpleRef ||
             IS_ARRAY_OR_STRING(*pFormatParam) )
            {
            //
            // Don't free [out] params that we're allocated on the
            // interpreter's stack.
            //

            if ( Params[n].ParamAttr.ServerAllocSize != 0 )
                continue;

            //
            // We have to make sure the array/string is non-null in case we
            // get an exception before finishing our unmarshalling.
            //
            if ( pArg &&
                 ( (pArg < pStubMsg->BufferStart) ||
                   (pArg > pStubMsg->BufferEnd) ) )
                (*pStubMsg->pfnFree)( pArg );
            }
        } // for
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\tiutil.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

#ifndef _TIUTIL_H_
#define _TIUTIL_H_

// This is a special value that is used internally for marshaling interfaces
#define VT_INTERFACE (VT_CLSID+1)
#define VT_MULTIINDIRECTIONS (VT_TYPEMASK - 1)

#define IfFailGo(expression, label)	\
    { hresult = (expression);		\
      if(FAILED(hresult))	\
	goto label;         		\
    }

#define IfFailRet(expression)		\
    { HRESULT hresult = (expression);	\
      if(FAILED(hresult))	\
	return hresult;			\
    }

class PARAMINFO;

HRESULT 
VarVtOfTypeDesc(
    IN  ITypeInfo * pTypeInfo,
    IN  TYPEDESC  * pTypeDesc,
    OUT PARAMINFO * pParamInfo);

HRESULT 
VarVtOfUDT(
    IN  ITypeInfo  * pTypeInfo,
    IN  TYPEDESC   * pTypeDesc,
    OUT  PARAMINFO * pParamInfo);

HRESULT VarVtOfIface(
    IN  ITypeInfo * pTypeInfo,
    IN  TYPEATTR  * pTypeAttr,
    OUT PARAMINFO * pParamInfo);


#endif //_TIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\testc.c ===
/*++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    dceclnt.c

Abstract:

    This is the client side of the test program for newndr.dll.

Author:

    Michael Montague (mikemon) 13-Apr-1993

Revision History:

    RyszardK    Nov 30, 1993    Added tests for rpc_sm* package.
    RyszardK    Jan  3, 1993    Carved out this independent test for newndr
                                

--*/

#include <sysinc.h>
#include <rpc.h>
#include "rpcndr.h"

void
ApiError (
    char * TestName,
    char * ApiName,
    RPC_STATUS RpcStatus
    )
{
    PrintToConsole("    ApiError in %s (%s = %u [%lx])\n", TestName, ApiName,
            RpcStatus, RpcStatus);
}

unsigned int MississippiBlockCount = 0;
unsigned int VistulaBlockCount = 0;

void *
MississippiAllocate (
    unsigned long Size
    )
{
    MississippiBlockCount += 1;
    return(I_RpcAllocate((unsigned int) Size));
}

void
MississippiFree (
    void * Pointer
    )
{
    MississippiBlockCount -= 1;
    I_RpcFree(Pointer);
}

void *
VistulaAllocate (
    unsigned long Size
    )
{
    VistulaBlockCount += 1;
    return(I_RpcAllocate((unsigned int) Size));
}

void
VistulaFree (
    void * Pointer
    )
{
    VistulaBlockCount -= 1;
    I_RpcFree(Pointer);
}

#define MISSISSIPPI_MAXIMUM 256
#define VISTULA_MAXIMUM     4

void * __RPC_API
MIDL_user_allocate (
    size_t Size
    );

void __RPC_API
MIDL_user_free (
    void * Buffer
    );


void
Mississippi (
    )
/*++

Routine Description:

    We will test the memory allocator, both client and server, in this routine.

--*/
{
    unsigned int Count, Iterations;
    void * Pointer;
//    void * AllocatedBlocks[MISSISSIPPI_MAXIMUM];
    unsigned int MississippiPassed = 1;

    PrintToConsole("Mississippi : Test Ss* Memory Allocation\n");

    RpcTryExcept
        {
        for (Iterations = 1; Iterations < 64; Iterations++)
            {
            PrintToConsole(".");
            RpcSsEnableAllocate();

            for (Count = 0; Count < 2048; Count++)
                {
                Pointer = RpcSsAllocate(Count);
                if ( Count % Iterations == 0 )
                    {
                    RpcSsFree(Pointer);
                    }
                }

            RpcSsDisableAllocate();
            }
        PrintToConsole("\n");
        }
    RpcExcept(1)
        {
        PrintToConsole("Mississippi : FAIL - Exception %d (%lx)\n",
                RpcExceptionCode(), RpcExceptionCode());
        MississippiPassed = 0;
        }
    RpcEndExcept

#if 0
    RpcTryExcept
        {
        for (Count = 0; Count < MISSISSIPPI_MAXIMUM; Count++)
            {
            AllocatedBlocks[Count] = MIDL_user_allocate(Count);
            }

        for (Count = 0; Count < MISSISSIPPI_MAXIMUM; Count++)
            {
            MIDL_user_free(AllocatedBlocks[Count]);
            }

        RpcSsSetClientAllocFree(MississippiAllocate, MississippiFree);

        for (Count = 0; Count < MISSISSIPPI_MAXIMUM; Count++)
            {
            AllocatedBlocks[Count] = MIDL_user_allocate(Count);
            }

        if ( MississippiBlockCount != MISSISSIPPI_MAXIMUM )
            {
            PrintToConsole("Mississippi : FAIL - ");
            PrintToConsole("MississippiBlockCount != MISSISSIPPI_MAXIMUM\n");
            MississippiPassed = 0;
            }

        for (Count = 0; Count < MISSISSIPPI_MAXIMUM; Count++)
            {
            MIDL_user_free(AllocatedBlocks[Count]);
            }

        if ( MississippiBlockCount != 0 )
            {
            PrintToConsole("Mississippi : FAIL - ");
            PrintToConsole("MississippiBlockCount != 0");
            PrintToConsole(" (%d)\n", MississippiBlockCount );
            MississippiPassed = 0;
            }
        }
    RpcExcept(1)
        {
        PrintToConsole("Mississippi : FAIL - Exception %d (%lx)\n",
                RpcExceptionCode(), RpcExceptionCode());
        MississippiPassed = 0;
        }
    RpcEndExcept
#endif

    if ( MississippiPassed != 0 )
        {
        PrintToConsole("Mississippi : PASS\n");
        }
}


void
Vistula (
    )
/*++

Routine Description:

    We will test the memory allocator in this routine.
    This is cloned from the Mississippi bvt case.

--*/
{
    unsigned int Count, Iterations;
    void * Pointer;
//    void * AllocatedBlocks[VISTULA_MAXIMUM];
    RPC_SS_THREAD_HANDLE ThreadHandle = 0;
    unsigned int VistulaPassed = 1;
    RPC_STATUS  Status;
    int Result = 0;

    PrintToConsole("Vistula : Test Sm* Memory Allocation\n");

    RpcTryExcept
        {
        for (Iterations = 1; Iterations < 64; Iterations++)
            {
            PrintToConsole(".");
            ThreadHandle = RpcSmGetThreadHandle( &Status );
            if ( ThreadHandle != 0 )
                PrintToConsole("H");
            if ( RpcSmEnableAllocate() != RPC_S_OK )
                {
                Result++;
                PrintToConsole("!");
                }
            ThreadHandle = RpcSmGetThreadHandle( &Status );
            if ( ThreadHandle == 0 )
                PrintToConsole("h");

            for (Count = 0; Count < 2048; Count++)
                {
                Pointer = RpcSmAllocate( Count, &Status );
                if ( Status != RPC_S_OK )
                    {
                    Result++;
                    PrintToConsole("a");
                    }
                
                if ( Count % Iterations == 0 )
                    {
                    Status = RpcSmFree(Pointer);
                    if ( Status != RPC_S_OK )
                        {
                        Result++;
                        PrintToConsole("f");
                        }
                    }
                }

            if ( RpcSmDisableAllocate() != RPC_S_OK )
                {
                Result++;
                PrintToConsole("?");
                }

            }
        PrintToConsole("\n");
        }
    RpcExcept(1)
        {
        PrintToConsole("Vistula : FAIL - Exception %d (%lx)\n",
                RpcExceptionCode(), RpcExceptionCode());
        VistulaPassed = 0;
        }
    RpcEndExcept

    if ( Result )
        {
        PrintToConsole("Vistula : FAIL -  %d\n", Result );
        VistulaPassed = 0;
        }

#if 0
    RpcTryExcept
        {
        for (Count = 0; Count < VISTULA_MAXIMUM; Count++)
            {
            AllocatedBlocks[Count] = MIDL_user_allocate(Count);
            }

        for (Count = 0; Count < VISTULA_MAXIMUM; Count++)
            {
            MIDL_user_free(AllocatedBlocks[Count]);
            }

        Status = RpcSmSetClientAllocFree( VistulaAllocate, VistulaFree);

        for (Count = 0; Count < VISTULA_MAXIMUM; Count++)
            {
            AllocatedBlocks[Count] = MIDL_user_allocate(Count);
            }

        if ( Status != RPC_S_OK  ||
             VistulaBlockCount != VISTULA_MAXIMUM )
            {
            PrintToConsole("Vistula : FAIL - ");
            PrintToConsole("VistulaBlockCount != VISTULA_MAXIMUM\n");
            VistulaPassed = 0;
            }

        for (Count = 0; Count < VISTULA_MAXIMUM; Count++)
            {
            MIDL_user_free(AllocatedBlocks[Count]);
            }

        if ( VistulaBlockCount != 0 )
            {
            PrintToConsole("Vistula : FAIL - ");
            PrintToConsole("VistulaBlockCount != 0\n");
            VistulaPassed = 0;
            }
        }
    RpcExcept(1)
        {
        PrintToConsole("Vistula : FAIL - Exception %d (%lx)\n",
                RpcExceptionCode(), RpcExceptionCode());
        VistulaPassed = 0;
        }
    RpcEndExcept
#endif

    if ( VistulaPassed != 0 )
        {
        PrintToConsole("Vistula : PASS\n");
        }
}


#ifdef NTENV
int __cdecl
#else // NTENV
int
#endif // NTENV
main (
    int argc,
    char * argv[]
    )
{
    Mississippi();
    Vistula();

    // To keep the compiler happy.  There is nothing worse than an unhappy
    // compiler.

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\stub.cxx ===
/*++

Microsoft Windows
Copyright (c) 1994-2000 Microsoft Corporation.  All rights reserved.

Module Name:
    stub.c

Abstract:
    Implements the IRpcStubBuffer interface.

Author:
    ShannonC    12-Oct-1994

Environment:
    Windows NT and Windows 95.  We do not support DOS and Win16.

Revision History:

--*/

#define USE_STUBLESS_PROXY
#define CINTERFACE
                 
#include <ndrp.h>
#include <ndrole.h>
#include <rpcproxy.h>
#include <stddef.h>
#include "ndrtypes.h"

EXTERN_C const IID IID_IPrivStubBuffer = { /* 3e0ac23f-eff6-41f3-b44b-fbfa4544265f */
    0x3e0ac23f,
    0xeff6,
    0x41f3,
    {0xb4, 0x4b, 0xfb, 0xfa, 0x45, 0x44, 0x26, 0x5f}
  };

const IID * RPC_ENTRY
NdrpGetStubIID(
    IRpcStubBuffer *This);

void
MakeSureWeHaveNonPipeArgs(
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       BufferSize );


BOOL NdrpFindInterface(
    IN  const ProxyFileInfo **  pProxyFileList,
    IN  REFIID                  riid,
    OUT const ProxyFileInfo **  ppProxyFileInfo,
    OUT long *                  pIndex );

extern void ReleaseTemplateForwardVtbl(void ** pVtbl);

//+-------------------------------------------------------------------------
//
//  Global data
//
//--------------------------------------------------------------------------

// ICallFactory interface on the StubBuffer objects.
// ICallFactory is an interface on a sync stub only.
// It has been introduced for NT5 beta2.

extern const ICallFactoryVtbl CStdStubBuffer_CallFactoryVtbl = {
    CStdStubBuffer_CF_QueryInterface,
    CStdStubBuffer_CF_AddRef,
    CStdStubBuffer_CF_Release,
    CStdStubBuffer_CF_CreateCall };

extern const ICallFactoryVtbl CStdStubBuffer2_CallFactoryVtbl = {
    CStdStubBuffer_CF_QueryInterface,
    CStdStubBuffer_CF_AddRef,
    CStdStubBuffer_CF_Release,
    CStdStubBuffer2_CF_CreateCall };

extern const IReleaseMarshalBuffersVtbl CStdStubBuffer_ReleaseMarshalBuffersVtbl = {
    CStdStubBuffer_RMB_QueryInterface,
    CStdStubBuffer_RMB_AddRef,
    CStdStubBuffer_RMB_Release,
    CStdStubBuffer_RMB_ReleaseMarshalBuffer};

extern const IReleaseMarshalBuffersVtbl CStdAsyncStubBuffer_ReleaseMarshalBuffersVtbl = {
    CStdStubBuffer_RMB_QueryInterface,
    CStdStubBuffer_RMB_AddRef,
    CStdStubBuffer_RMB_Release,
    CStdAsyncStubBuffer_RMB_ReleaseMarshalBuffer };

extern const ISynchronizeVtbl CStdAsyncStubBuffer_ISynchronizeVtbl = {
    CStdAsyncStubBuffer_Synchronize_QueryInterface,
    CStdAsyncStubBuffer_Synchronize_AddRef,
    CStdAsyncStubBuffer_Synchronize_Release,
    CStdAsyncStubBuffer_Synchronize_Wait,
    CStdAsyncStubBuffer_Synchronize_Signal,
    CStdAsyncStubBuffer_Synchronize_Reset };



//+-------------------------------------------------------------------------
//
//  End of Global data
//
//--------------------------------------------------------------------------


#pragma code_seg(".orpc")

//
//  ICallFactory interface on the sync stub object.
//

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_CF_QueryInterface(
    IN  ICallFactory   *This,
    IN  REFIID          riid,
    OUT void **         ppvObject)
/*++

Routine Description:
    Query for an interface on the interface stub CallFactory pointer.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    The relative position of lpVtbl and pCallFactoryVtbl is the same for
        CStdStubBuffer,
        CStdStubBuffer2,
        CStdAsyncStubBuffer,


--*/
{
    IRpcStubBuffer * pStubBuffer = (IRpcStubBuffer *) (((uchar *)This) -
                                    (offsetof(CStdStubBuffer, pCallFactoryVtbl) - offsetof(CStdStubBuffer,lpVtbl)) );

    return pStubBuffer->lpVtbl->QueryInterface( pStubBuffer,
                                                riid,
                                                ppvObject );
}

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CF_AddRef(
    IN  ICallFactory   *This )
/*++

Routine Description:
    No need to go through punkOuter.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE

--*/
{
    IRpcStubBuffer * pStubBuffer = (IRpcStubBuffer *) (((uchar *)This) -
                                    (offsetof(CStdStubBuffer, pCallFactoryVtbl) - offsetof(CStdStubBuffer,lpVtbl)) );

    return pStubBuffer->lpVtbl->AddRef( pStubBuffer );
}

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CF_Release(
    IN  ICallFactory   *This )
/*++

Routine Description:

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE

--*/
{
    IRpcStubBuffer * pStubBuffer = (IRpcStubBuffer *) (((uchar *)This) -
                                    (offsetof(CStdStubBuffer, pCallFactoryVtbl) - offsetof(CStdStubBuffer,lpVtbl)) );

    return pStubBuffer->lpVtbl->Release( pStubBuffer );
}



HRESULT
NdrpCreateNonDelegatedAsyncStub(
    IN  IRpcStubBuffer     *This,
    IN  REFIID              riid,      // async IID
    IN  IUnknown *          punkOuter, // controlling unknown
    OUT IRpcStubBuffer **   ppAsyncStub
    )
{
    BOOL                    fFound;
    long                    j;   // if index
    const ProxyFileInfo *   pProxyFileInfo;

    CStdStubBuffer *        pSyncSB = (CStdStubBuffer *)This;
    CStdAsyncStubBuffer *   pAsyncSB;

    *ppAsyncStub = 0;

    if ( ! pSyncSB->pCallFactoryVtbl  ||  !pSyncSB->pAsyncIID )
        return E_NOINTERFACE;

    if ( memcmp( &riid, pSyncSB->pAsyncIID, sizeof(IID)) != 0 )
        return E_NOINTERFACE;

    if ( 0 == pSyncSB->pvServerObject )
        return CO_E_OBJNOTCONNECTED;

    if ( 0 != punkOuter )
        return CLASS_E_NOAGGREGATION;

    // same file, so we can use the sync pPSFactory.

    fFound = NdrpFindInterface( ((CStdPSFactoryBuffer *)pSyncSB->pPSFactory)->pProxyFileList,
                                riid,
                                &pProxyFileInfo,
                                & j);
    if ( !fFound )
        return E_NOINTERFACE;

    pAsyncSB = (CStdAsyncStubBuffer *)(*pfnCoTaskMemAlloc)(sizeof(CStdAsyncStubBuffer));

    if( ! pAsyncSB )
        return E_OUTOFMEMORY;

    memset( pAsyncSB, 0, sizeof(CStdAsyncStubBuffer));

    //Initialize the new stub buffer.
    pAsyncSB->lpVtbl   = &pProxyFileInfo->pStubVtblList[j]->Vtbl;
    pAsyncSB->RefCount = 1;
    pAsyncSB->pSynchronizeVtbl = & CStdAsyncStubBuffer_ISynchronizeVtbl;

    // Create the stub disconnected from the server call object.
    // There will be a separate Connect call later.
    //      pAsyncSB->pvServerObject = 0;

    NdrpAsyncStubMsgConstructor( pAsyncSB );

    //Increment the DLL reference count for DllCanUnloadNow.
    pSyncSB->pPSFactory->lpVtbl->AddRef( pSyncSB->pPSFactory );
    pAsyncSB->pPSFactory = pSyncSB->pPSFactory;

    *ppAsyncStub = (IRpcStubBuffer *) & pAsyncSB->lpVtbl;

    return S_OK;
}


HRESULT
NdrpCreateDelegatedAsyncStub(
    IN  IRpcStubBuffer         *This,
    IN  REFIID                  riid,      // async IID
    IN  IUnknown *              punkOuter, // controlling unknown
    OUT IRpcStubBuffer **       ppAsyncStub
    )
{
    HRESULT                 hr;
    BOOL                    fFound;
    long                    j;   // if index
    const ProxyFileInfo *   pProxyFileInfo;
    BOOL                    fDelegate = FALSE;

    CStdStubBuffer2 *       pSyncSB = (CStdStubBuffer2 *)This;
    CStdAsyncStubBuffer  *  pAsyncSB;
    ICallFactory *          pCallFactory;
    IRpcStubBuffer *        pBaseSyncSB;

    *ppAsyncStub = 0;

    pSyncSB = (CStdStubBuffer2 *) ((uchar*)This -
                                  offsetof(CStdStubBuffer2,lpVtbl)) ;

    if ( ! pSyncSB->pCallFactoryVtbl  ||  !pSyncSB->pAsyncIID )
        return E_NOINTERFACE;

    if ( memcmp( &riid, pSyncSB->pAsyncIID, sizeof(IID)) != 0 )
        return E_NOINTERFACE;

    if ( 0 == pSyncSB->pvServerObject )
        return CO_E_OBJNOTCONNECTED;

    if ( 0 != punkOuter )
        return CLASS_E_NOAGGREGATION;

    // same file, so we can use the sync pPSFactory.

    fFound = NdrpFindInterface( ((CStdPSFactoryBuffer *)pSyncSB->pPSFactory)->pProxyFileList,
                                riid,
                                &pProxyFileInfo,
                                & j);
    if ( !fFound )
        return E_NOINTERFACE;

    pAsyncSB = (CStdAsyncStubBuffer*)(*pfnCoTaskMemAlloc)(sizeof(CStdAsyncStubBuffer));

    if( ! pAsyncSB )
        return E_OUTOFMEMORY;

    memset( pAsyncSB, 0, sizeof(CStdAsyncStubBuffer));

    //Initialize the new stub buffer.
    pAsyncSB->lpVtbl   = &pProxyFileInfo->pStubVtblList[j]->Vtbl;
    pAsyncSB->RefCount = 1;
    pAsyncSB->pSynchronizeVtbl = & CStdAsyncStubBuffer_ISynchronizeVtbl;

    // As the Connect connects to real server we don't need that.
    // pAsyncSB->lpForwardingVtbl = & ForwardingVtbl;

    // Create the stub disconnected from the server call object.
    // There will be a separate Connect call later.
    //      pAsyncSB->pvServerObject = 0;

    // Create an async stub for the base interface.
    // We don't know if the base is delegated, so we have to use
    //  the base create call method.
    // The base async stub will also be disconnected.

    pBaseSyncSB = pSyncSB->pBaseStubBuffer;

    hr = pBaseSyncSB->lpVtbl->QueryInterface( pBaseSyncSB,
                                              IID_ICallFactory,
                                              (void**)& pCallFactory );

    if ( SUCCEEDED(hr) )
        {
        // Aggregate the base async stub with the current async stub,
        // not with the channel's punkOuter.
        // We should not need it, and the base stub is aggregated with
        // upper stub mostly for debug tracing.

        const IID * pBaseAsyncIID;

        pBaseAsyncIID = *(const IID **) ( (uchar*)pBaseSyncSB
                                           + offsetof(CStdStubBuffer, pAsyncIID) );

        hr = pCallFactory->lpVtbl->CreateCall( pCallFactory,
                                               *pBaseAsyncIID,
                                               0, // no need for punkOuter (IUnknown*) & pAsyncSB->lpVtbl,
                                               IID_IUnknown,
                                               (IUnknown**)& pAsyncSB->pBaseStubBuffer );

        pCallFactory->lpVtbl->Release( pCallFactory );
        }

    if(SUCCEEDED(hr))
        {
        NdrpAsyncStubMsgConstructor( pAsyncSB );

        //Increment the DLL reference count for DllCanUnloadNow.
        pSyncSB->pPSFactory->lpVtbl->AddRef( pSyncSB->pPSFactory );
        pAsyncSB->pPSFactory = pSyncSB->pPSFactory;

        *ppAsyncStub = (IRpcStubBuffer *) & pAsyncSB->lpVtbl;
        }
    else
        {
        (*pfnCoTaskMemFree)(pAsyncSB);
        }

    return hr;
}


HRESULT STDMETHODCALLTYPE
CStdStubBuffer_CF_CreateCall(
    IN  ICallFactory *This,
    IN  REFIID        riid,
    IN  IUnknown *    punkOuter, // controlling unknown
    IN  REFIID        riid2,
    OUT IUnknown **   ppv
    )
/*
    Creates a call object, i.e. an async stub object.

    Note, because the call comes via a CStdStubBuffer, not Buffer2,
    we know that we need to create only a non-delegated async stub.
*/
{
    IRpcStubBuffer * pStubBuffer;

    if ( memcmp( &riid2, & IID_IUnknown, sizeof(IID)) != 0 )
        return E_INVALIDARG;

    pStubBuffer = (IRpcStubBuffer*) (((uchar *)This)
                            - offsetof(CStdStubBuffer, pCallFactoryVtbl)
                            + offsetof(CStdStubBuffer, lpVtbl) );

    return NdrpCreateNonDelegatedAsyncStub( pStubBuffer,
                                            riid,
                                            punkOuter,
                                            (IRpcStubBuffer **) ppv );
}

HRESULT STDMETHODCALLTYPE
CStdStubBuffer2_CF_CreateCall(
    IN  ICallFactory *This,
    IN  REFIID        riid,
    IN  IUnknown *    punkOuter, // controlling unknown
    IN  REFIID        riid2,
    OUT IUnknown **   ppv
    )
/*
    Creates a call object, i.e. an async stub object.

    Note, because the call comes via a CStdStubBuffer, not Buffer2,
    we know that we need to create only a non-delegated async stub.
*/
{
    IRpcStubBuffer * pStubBuffer;

    if ( memcmp( &riid2, & IID_IUnknown, sizeof(IID)) != 0 )
        return E_INVALIDARG;

    pStubBuffer = (IRpcStubBuffer *) ( (uchar *)This
                            - offsetof(CStdStubBuffer2, pCallFactoryVtbl)
                            + offsetof(CStdStubBuffer2, lpVtbl) );

    return NdrpCreateDelegatedAsyncStub( pStubBuffer,
                                         riid,
                                         punkOuter,
                                         (IRpcStubBuffer **) ppv );
}


HRESULT STDMETHODCALLTYPE
CStdStubBuffer_RMB_QueryInterface(
    IN  IReleaseMarshalBuffers   *This,
    IN  REFIID          riid,
    OUT void **         ppvObject)
/*++

Routine Description:
    Query for an interface on the interface stub CallFactory pointer.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    The relative position of lpVtbl and pCallFactoryVtbl is the same for
        CStdStubBuffer,
        CStdStubBuffer2,
        CStdAsyncStubBuffer,


--*/
{
    IRpcStubBuffer * pStubBuffer = (IRpcStubBuffer *) (((uchar *)This) -
                                    (offsetof(CStdStubBuffer, pRMBVtbl) - 
                                    offsetof(CStdStubBuffer,lpVtbl)) );

    return pStubBuffer->lpVtbl->QueryInterface( pStubBuffer,
                                                riid,
                                                ppvObject );
}

ULONG STDMETHODCALLTYPE
CStdStubBuffer_RMB_AddRef(
    IN  IReleaseMarshalBuffers   *This )
/*++

Routine Description:
    No need to go through punkOuter.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE

--*/
{
    IRpcStubBuffer * pStubBuffer = (IRpcStubBuffer *) (((uchar *)This) -
                                    (offsetof(CStdStubBuffer, pRMBVtbl) - 
                                    offsetof(CStdStubBuffer,lpVtbl)) );

    return pStubBuffer->lpVtbl->AddRef( pStubBuffer );
}

ULONG STDMETHODCALLTYPE
CStdStubBuffer_RMB_Release(
    IN  IReleaseMarshalBuffers   *This )
/*++

Routine Description:

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE

--*/
{
    IRpcStubBuffer * pStubBuffer = (IRpcStubBuffer *) (((uchar *)This) -
                                    (offsetof(CStdStubBuffer, pRMBVtbl) - 
                                    offsetof(CStdStubBuffer,lpVtbl)) );

    return pStubBuffer->lpVtbl->Release( pStubBuffer );
}



HRESULT STDMETHODCALLTYPE
CStdStubBuffer_RMB_ReleaseMarshalBuffer(
    IN IReleaseMarshalBuffers *pRMB,
    IN RPCOLEMESSAGE * pMsg,
    IN DWORD dwIOFlags,
    IN IUnknown *pChnl)
{
    HRESULT hr;
    CStdStubBuffer * pStubBuffer = (CStdStubBuffer *) (((uchar *)pRMB) -
                                    offsetof(CStdStubBuffer, pRMBVtbl));

    hr = NdrpServerReleaseMarshalBuffer(pRMB,(RPC_MESSAGE *)pMsg,dwIOFlags,FALSE);
    
    return hr;
}


HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_RMB_ReleaseMarshalBuffer(
    IN IReleaseMarshalBuffers *pRMB,
    IN RPCOLEMESSAGE * pMsg,
    IN DWORD dwIOFlags,
    IN IUnknown *pChnl)
{
    HRESULT hr;
    CStdStubBuffer * pStubBuffer = (CStdStubBuffer *) (((uchar *)pRMB) -
                                    offsetof(CStdStubBuffer, pRMBVtbl));

    hr = NdrpServerReleaseMarshalBuffer(pRMB,(RPC_MESSAGE *)pMsg,dwIOFlags,TRUE);
    
    return hr;
}


//
//   The ISynchronize interface on an async stub object
//

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_QueryInterface(
    IN  ISynchronize   *This,
    IN  REFIID          riid,
    OUT void **         ppvObject)
/*++

Routine Description:
    Query for an interface on the interface stub CallFactory pointer.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    Works for delegated and non-delegated async stubs.
    ISynchronize is public, go through punkOuter.
--*/
{
    IRpcStubBuffer  * pStubBuffer;

    pStubBuffer = (IRpcStubBuffer *) ( (uchar *)This
                             - offsetof(CStdAsyncStubBuffer,pSynchronizeVtbl)
                             + offsetof(CStdAsyncStubBuffer,lpVtbl) );

   return pStubBuffer->lpVtbl->QueryInterface( pStubBuffer,
                                               riid,
                                               ppvObject );
}

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_AddRef(
    IN  ISynchronize   *This )
/*++

Routine Description:

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    Works for delegated and non-delegated async stubs.

--*/
{
    IRpcStubBuffer  * pStubBuffer;

    pStubBuffer = (IRpcStubBuffer *) ( (uchar *)This
                             - offsetof(CStdAsyncStubBuffer,pSynchronizeVtbl)
                             + offsetof(CStdAsyncStubBuffer,lpVtbl) );

    return pStubBuffer->lpVtbl->AddRef( pStubBuffer );
}

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_Release(
    IN  ISynchronize   *This )
/*++

Routine Description:

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    Works for delegated and non-delegated async stubs.

--*/
{
    IRpcStubBuffer  * pStubBuffer;

    pStubBuffer = (IRpcStubBuffer *) ( (uchar *)This
                             - offsetof(CStdAsyncStubBuffer,pSynchronizeVtbl)
                             + offsetof(CStdAsyncStubBuffer,lpVtbl) );

    return pStubBuffer->lpVtbl->Release( pStubBuffer );
}



HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_Wait(
    IN  ISynchronize   *This,
    IN  DWORD           dwFlags,
    IN  DWORD           dwMilisec )
/*++

Routine Description:
    It should never be called.
Arguments:
Return Value:
Note:
    Works for delegated and non-delegated async stubs.

--*/
{
    IRpcStubBuffer * pStubBuffer = (IRpcStubBuffer *) ( (uchar *)This -
                        (offsetof(CStdAsyncStubBuffer, pSynchronizeVtbl) - offsetof(CStdAsyncStubBuffer, lpVtbl)) );

    // It should never be called.
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_Signal(
    IN  ISynchronize   *This )
/*++

Routine Description:
    Query for an interface on the interface stub CallFactory pointer.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    Works for delegated and non-delegated async stubs.

--*/
{
    CStdAsyncStubBuffer *   pAsyncSB;
    HRESULT                 hr;

    pAsyncSB = (CStdAsyncStubBuffer *) ( (uchar *)This -
                      offsetof(CStdAsyncStubBuffer, pSynchronizeVtbl) );

    // It causes the Finish call to happen.
    hr = NdrpAsyncStubSignal( pAsyncSB );

    return hr;
}

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_Reset(
    IN  ISynchronize   *This )
/*++

Routine Description:
    This is called by the Server's Call Object as part of its Begin_* method.

Arguments:

Return Value: Always S_OK.

Note:
    Works for delegated and non-delegated async stubs.

--*/
{
    IRpcStubBuffer * pStubBuffer = (IRpcStubBuffer *) ( (uchar *)This -
                        (offsetof(CStdAsyncStubBuffer, pSynchronizeVtbl) - offsetof(CStdAsyncStubBuffer, lpVtbl)) );

    // Server's Call object gets S_OK...
    return S_OK;
}


//
//  Implementation of the stub buffer itself.
//

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_QueryInterface(
    IN  IRpcStubBuffer *This,
    IN  REFIID          riid,
    OUT void **         ppvObject)
/*++

Routine Description:
    Query for an interface on the interface stub.  The interface
    stub supports the IUnknown and IRpcStubBuffer interfaces.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    The relative position of lpVtbl and pCallFactoryVtbl is the same for
        CStdStubBuffer,
        CStdStubBuffer2,
    This is correct for the stubs supporting async_uuid.
--*/
{
    HRESULT hr;

    if ((memcmp(&riid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcStubBuffer, sizeof(IID)) == 0))
    {
        This->lpVtbl->AddRef(This);
        *ppvObject = This;
        hr = S_OK;
    }
    else if ( ((CStdStubBuffer*)This)->pCallFactoryVtbl != 0  &&
              memcmp(&riid, &IID_ICallFactory, sizeof(IID)) == 0 )
    {
        This->lpVtbl->AddRef(This);
        *ppvObject = ( (uchar *)This +
                     (offsetof(CStdStubBuffer, pCallFactoryVtbl) - offsetof(CStdStubBuffer,lpVtbl)) );
        hr = S_OK;
    }
    else if ( (((CStdStubBuffer*)This)->pRMBVtbl) && 
              (memcmp(&riid, &IID_IReleaseMarshalBuffers,sizeof(IID)) == 0))
    {
        This->lpVtbl->AddRef(This);
        *ppvObject = ( (uchar *)This + offsetof(CStdStubBuffer,pRMBVtbl)) ;
        hr = S_OK;
    }   
    else if ( riid == IID_IPrivStubBuffer )
    {
        This->lpVtbl->AddRef(This);
        *ppvObject = This;
        hr = S_OK;        
    }
    else
    {
        *ppvObject = 0;
        hr = E_NOINTERFACE;
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_QueryInterface(
    IN  IRpcStubBuffer *This,
    IN  REFIID          riid,
    OUT void **         ppvObject)
/*++

Routine Description:
    Query for an interface on the interface stub.  The interface
    stub supports the IUnknown and IRpcStubBuffer interfaces.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    The relative position of lpVtbl and pCallFactoryVtbl is the same for
        CStdAsyncStubBuffer
    So this works for AsyncStubBuffer2_QueryInterface.

--*/
{
    HRESULT hr = E_NOINTERFACE;

    *ppvObject = 0;

    if ((memcmp(&riid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcStubBuffer, sizeof(IID)) == 0))
        {
        *ppvObject = This;
        hr = S_OK;
        }
    else if ( memcmp(&riid, &IID_ISynchronize, sizeof(IID)) == 0 )
        {
        // For pSynchronize return  &pAsyncSB->pSynchronizeVtbl.
        *ppvObject = ( (uchar *)This +
                     (offsetof(CStdAsyncStubBuffer, pSynchronizeVtbl) - offsetof(CStdAsyncStubBuffer,lpVtbl)) );

        hr = S_OK;
    }
    else if ( (((CStdStubBuffer*)This)->pRMBVtbl) && 
              (memcmp(&riid, &IID_IReleaseMarshalBuffers,sizeof(IID)) == 0))
    {
        This->lpVtbl->AddRef(This);
        *ppvObject = (void *)((CStdStubBuffer*)This)->pRMBVtbl;
        hr = S_OK;
    }   
    else if ( riid == IID_IPrivStubBuffer )
    {
        This->lpVtbl->AddRef(This);
        *ppvObject = This;
        hr = S_OK;        
    }


    if ( SUCCEEDED(hr) )
        ((IUnknown*)*ppvObject)->lpVtbl->AddRef( (IUnknown*)*ppvObject );

    // This is async stub, the channel would never call a query
    // for anything else.

    return hr;
}



ULONG STDMETHODCALLTYPE
CStdStubBuffer_AddRef(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    Increment reference count.

Arguments:

Return Value:
    Reference count.

Note:
    The relative position of lpVtbl and pCallFactoryVtbl is the same for
        CStdStubBuffer,
        CStdStubBuffer2,

--*/
{
        InterlockedIncrement(&((CStdStubBuffer *)This)->RefCount);
        return (ULONG) ((CStdStubBuffer *)This)->RefCount;
}


ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_AddRef(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    Increment reference count.

Arguments:

Return Value:
    Reference count.

Note:
    The relative position of lpVtbl and pCallFactoryVtbl is the same for
        CStdAsyncStubBuffer,

--*/
{
// ok: ISynchronize is not really public

    InterlockedIncrement(&((CStdStubBuffer *)This)->RefCount);

    return (ULONG) ((CStdStubBuffer *)This)->RefCount;
}



//
// This is needed and used only by the synchronous stubs.
//

HRESULT STDMETHODCALLTYPE
Forwarding_QueryInterface(
    IN  IUnknown *  This,
    IN  REFIID      riid,
    OUT void **     ppv)
{
    *ppv = This;
    return S_OK;
}

ULONG STDMETHODCALLTYPE
Forwarding_AddRef(
    IN  IUnknown *This)
{
    return 1;
}

ULONG STDMETHODCALLTYPE
Forwarding_Release(
    IN  IUnknown *This)
{
   return 1;
}


ULONG STDMETHODCALLTYPE
NdrCStdStubBuffer_Release(
    IN  IRpcStubBuffer *    This,
    IN  IPSFactoryBuffer *  pFactory)
/*++

Routine Description:
    Decrement reference count.

Arguments:

Return Value:
    Reference count.

--*/
{
    ULONG       count;

    NDR_ASSERT(((CStdStubBuffer *)This)->RefCount > 0, "Invalid reference count");

    count = (ULONG) ((CStdStubBuffer *)This)->RefCount - 1;

    if(InterlockedDecrement(&((CStdStubBuffer *)This)->RefCount) == 0)
    {
        count = 0;

#if DBG == 1
        memset(This,  '\0', sizeof(CStdStubBuffer));
#endif

        //Free the stub buffer
        NdrOleFree(This);

        //Decrement the DLL reference count.
        ((CStdPSFactoryBuffer*)pFactory)->lpVtbl->Release( pFactory );
    }

    return count;
}


ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_Release(
    IN  IRpcStubBuffer *    This
    )
{
    CStdAsyncStubBuffer * pAsyncSB;
    ULONG                 count;

    pAsyncSB = (CStdAsyncStubBuffer*)((uchar*)This
                                      - offsetof(CStdAsyncStubBuffer,lpVtbl));

    NDR_ASSERT(pAsyncSB->RefCount > 0, "Async stub Invalid reference count");

    count = (ULONG) pAsyncSB->RefCount - 1;

    if ( InterlockedDecrement( &pAsyncSB->RefCount) == 0)
        {
        IPSFactoryBuffer *  pFactory = pAsyncSB->pPSFactory;

        count = 0;

        NdrpAsyncStubMsgDestructor( pAsyncSB );

#if DBG == 1
        memset( pAsyncSB, '\33', sizeof(CStdAsyncStubBuffer));
#endif

        //Free the stub buffer
        NdrOleFree( pAsyncSB );

        //Decrement the DLL reference count.
        pFactory->lpVtbl->Release( pFactory );
        }

    return count;
}



ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer2_Release(
    IN  IRpcStubBuffer *    This
    )
{
    // O well, the main desctructor for the delegated async stub.

    CStdAsyncStubBuffer *   pAsyncSB;
    ULONG                   count;

    pAsyncSB = (CStdAsyncStubBuffer*)((uchar*)This
                                      - offsetof(CStdAsyncStubBuffer,lpVtbl));

    NDR_ASSERT(pAsyncSB->RefCount > 0, "Async stub Invalid reference count");

    count = (ULONG) pAsyncSB->RefCount - 1;

    if ( InterlockedDecrement(&pAsyncSB->RefCount) == 0)
        {
        IPSFactoryBuffer * pFactory      = pAsyncSB->pPSFactory;
        IRpcStubBuffer * pBaseStubBuffer = pAsyncSB->pBaseStubBuffer;

        count = 0;

        if( pBaseStubBuffer != 0)
            pBaseStubBuffer->lpVtbl->Release( pBaseStubBuffer );

        NdrpAsyncStubMsgDestructor( pAsyncSB );

#if DBG == 1
        memset( pAsyncSB, '\33', sizeof(CStdAsyncStubBuffer));
#endif

        //Free the stub buffer
        NdrOleFree( pAsyncSB );

        //Decrement the DLL reference count.
        pFactory->lpVtbl->Release( pFactory );
        }

    return count;
}



ULONG STDMETHODCALLTYPE
NdrCStdStubBuffer2_Release(
    IN  IRpcStubBuffer *    This,
    IN  IPSFactoryBuffer *  pFactory)
/*++

Routine Description:
    Decrement reference count.  This function supports delegation to the stub
    for the base interface.

Arguments:

Return Value:
    Reference count.

--*/
{
    ULONG       count;
    unsigned char *pTemp;
    CStdStubBuffer2 * pStubBuffer;
    IRpcStubBuffer *pBaseStubBuffer;

    pTemp = (unsigned char *)This;
    pTemp -= offsetof(CStdStubBuffer2, lpVtbl);
    pStubBuffer = (CStdStubBuffer2 *) pTemp;

    NDR_ASSERT(pStubBuffer->RefCount > 0, "Invalid reference count");

    count = (ULONG) pStubBuffer->RefCount - 1;

    if(InterlockedDecrement(&pStubBuffer->RefCount) == 0)
    {
        count = 0;

        pBaseStubBuffer = pStubBuffer->pBaseStubBuffer;

        if(pBaseStubBuffer != 0)
            pBaseStubBuffer->lpVtbl->Release(pBaseStubBuffer);

#if DBG == 1
        memset(pStubBuffer,  '\0', sizeof(CStdStubBuffer2));
#endif

        if (pStubBuffer->lpForwardingVtbl)
        ReleaseTemplateForwardVtbl((void **)pStubBuffer->lpForwardingVtbl);
        //Free the stub buffer
        NdrOleFree(pStubBuffer);

        //Decrement the DLL reference count.
        ((CStdPSFactoryBuffer*)pFactory)->lpVtbl->Release( pFactory );
    }

    return count;
}


HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Connect(
    IN  IRpcStubBuffer *This,
    IN  IUnknown *      pUnkServer)
/*++

Routine Description:
    Connect the stub buffer to the server object.
    This is the non-delegated case.

Arguments:

Return Value:

Notes:
    This works for CStdAsyncBuffer_Connect

--*/
{
    HRESULT hr;
    const IID *pIID;
    IUnknown *punk = 0;

    NDR_ASSERT(pUnkServer != 0, "pUnkServer parameter is invalid.");

    pIID = NdrpGetStubIID(This);
    hr = pUnkServer->lpVtbl->QueryInterface(pUnkServer, *pIID, (void**)&punk);

    punk = (IUnknown *) InterlockedExchangePointer(
        (PVOID *) &((CStdStubBuffer *) This)->pvServerObject, (PVOID) punk);

    if(punk != 0)
    {
        //The stub was already connected.  Release the old interface pointer.
        punk->lpVtbl->Release(punk);
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Connect(
    IN  IRpcStubBuffer *This,
    IN  IUnknown *      punkServer)
/*++

Routine Description:
    Connect the stub buffer to the server object.
    This is the non-delegated case.

Arguments:
    punkServer - this is a pointer to AsyncIFoo already queried by the channel.
                 (when delegation same thing)

Return Value:

Notes:
    This works the same as for StubBuffer_Connect.

    Note that an async stub is always created disconnected.
    It also always keep a pointer to the real server not
    to a forwarder object.
--*/
{
    IUnknown *punk = 0;

    NDR_ASSERT(punkServer != 0, "pUnkServer parameter is invalid.");

    punkServer->lpVtbl->AddRef( punkServer );

    punk = (IUnknown *) InterlockedExchangePointer(
        (PVOID *) &((CStdStubBuffer *) This)->pvServerObject, (PVOID) punkServer);

    if( punk != 0 )
        {
        // The stub was already connected.  Release the old interface pointer.
        punk->lpVtbl->Release(punk);
        }

    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CStdStubBuffer2_Connect(
    IN  IRpcStubBuffer *This,
    IN  IUnknown *      pUnkServer)
/*++

Routine Description:
    Connect the stub buffer to the server object.
    This is the delegated case.

Arguments:

Return Value:

--*/
{
    HRESULT             hr;
    unsigned char *     pTemp;
    CStdStubBuffer2 *   pStubBuffer;
    IRpcStubBuffer *    pBaseStubBuffer;

    hr = CStdStubBuffer_Connect(This, pUnkServer);

    if(SUCCEEDED(hr))
    {
        //Connect the stub for the base interface.
        pTemp = (unsigned char *)This;
        pTemp -= offsetof(CStdStubBuffer2, lpVtbl);
        pStubBuffer = (CStdStubBuffer2 *) pTemp;

        pBaseStubBuffer = pStubBuffer->pBaseStubBuffer;

        if(pBaseStubBuffer != 0)
        {
            hr = pBaseStubBuffer->lpVtbl->Connect(pBaseStubBuffer,
                                                  (IUnknown *) &pStubBuffer->lpForwardingVtbl);
        }
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer2_Connect(
    IN  IRpcStubBuffer *This,
    IN  IUnknown *      pUnkServer)
/*++

Routine Description:
    Connect the stub buffer to the server object.
    This is the delegated case.

Arguments:

Return Value:

Notes:
    This is different from CStdAsyncBuffer2_Connect
    as the base is connected to the real server here.

    Note that an async stub is always created disconnected.
    It also always keep a pointer to the real server not
    to a forwarder object.

--*/
{
    HRESULT             hr;
    unsigned char *     pTemp;
    CStdStubBuffer2 *   pStubBuffer;
    IRpcStubBuffer *    pBaseStubBuffer;

    hr = CStdAsyncStubBuffer_Connect(This, pUnkServer);

    if(SUCCEEDED(hr))
    {
        //Connect the stub for the base interface.
        pTemp = (unsigned char *)This;
        pTemp -= offsetof(CStdStubBuffer2, lpVtbl);
        pStubBuffer = (CStdStubBuffer2 *) pTemp;

        pBaseStubBuffer = pStubBuffer->pBaseStubBuffer;

        if(pBaseStubBuffer != 0)
        {
            hr = pBaseStubBuffer->lpVtbl->Connect(
                                     pBaseStubBuffer,
                                     pUnkServer );
        }
    }
    return hr;
}


void STDMETHODCALLTYPE
CStdStubBuffer_Disconnect(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    Disconnect the stub from the server object.

Arguments:

Return Value:
    None.

Notes:
    This works for CStdAsyncBuffer_Disconnect

--*/
{
    IUnknown *          punk;

    //Set pvServerObject to zero.
    punk = (IUnknown *) InterlockedExchangePointer(
                        (PVOID*) &((CStdStubBuffer *)This)->pvServerObject, 0);

    if(punk != 0)
    {
        //
        // Free the old interface pointer.
        //
        punk->lpVtbl->Release(punk);
    }
}

void STDMETHODCALLTYPE
CStdAsyncStubBuffer_Disconnect(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    Disconnect the stub from the server object.

Arguments:

Return Value:
    None.
--*/
{
    // Same as Buffer_Disconnect

    IUnknown *          punk;

    //Set pvServerObject to zero.
    punk = (IUnknown *) InterlockedExchangePointer(
                        (PVOID*) &((CStdStubBuffer *)This)->pvServerObject, 0);

    // Free the old interface pointer.
    if(punk != 0)
        punk->lpVtbl->Release(punk);
}

void STDMETHODCALLTYPE
CStdStubBuffer2_Disconnect(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    Disconnect the stub buffer from the server object.

Arguments:

Return Value:
    None.

--*/
{
    IUnknown *          punk;
    unsigned char *pTemp;
    CStdStubBuffer2 * pStubBuffer;
    IRpcStubBuffer *pBaseStubBuffer;

    pTemp = (unsigned char *)This;
    pTemp -= offsetof(CStdStubBuffer2, lpVtbl);
    pStubBuffer = (CStdStubBuffer2 *) pTemp;

    //Disconnect the stub for the base interface.
    pBaseStubBuffer = pStubBuffer->pBaseStubBuffer;

    if(pBaseStubBuffer != 0)
        pBaseStubBuffer->lpVtbl->Disconnect(pBaseStubBuffer);

    //Set pvServerObject to zero.
    punk = (IUnknown *) InterlockedExchangePointer(
                        (PVOID*) &pStubBuffer->pvServerObject, 0);

    if(punk != 0)
    {
        //
        // Free the old interface pointer.
        //
        punk->lpVtbl->Release(punk);
    }
}

void STDMETHODCALLTYPE
CStdAsyncStubBuffer2_Disconnect(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    Disconnect the stub buffer from the server object.

Arguments:

Return Value:
    None.

--*/
{
    IUnknown *          punk;
    unsigned char *pTemp;
    CStdStubBuffer2 * pStubBuffer;
    IRpcStubBuffer *pBaseStubBuffer;

    pTemp = (unsigned char *)This;
    pTemp -= offsetof(CStdStubBuffer2, lpVtbl);
    pStubBuffer = (CStdStubBuffer2 *) pTemp;

    //Disconnect the stub for the base interface.
    pBaseStubBuffer = pStubBuffer->pBaseStubBuffer;

    if(pBaseStubBuffer != 0)
        pBaseStubBuffer->lpVtbl->Disconnect(pBaseStubBuffer);

    //Set pvServerObject to zero.
    punk = (IUnknown *) InterlockedExchangePointer(
                (PVOID*) &pStubBuffer->pvServerObject, 0);

    // Free the old interface pointer.
    if(punk != 0)
        punk->lpVtbl->Release(punk);
}


HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Invoke(
    IN  IRpcStubBuffer *    This,
    IN  RPCOLEMESSAGE *     prpcmsg,
    IN  IRpcChannelBuffer * pRpcChannelBuffer)
/*++

Routine Description:
    Invoke a stub function via the dispatch table.

Arguments:

Return Value:

--*/
{
    HRESULT             hr = S_OK;
    unsigned char **    ppTemp;
    unsigned char *     pTemp;
    CInterfaceStubVtbl *pStubVtbl;
    unsigned long       dwServerPhase = STUB_UNMARSHAL;

    //Get a pointer to the stub vtbl.
    ppTemp = (unsigned char **) This;
    pTemp = *ppTemp;
    pTemp -= sizeof(CInterfaceStubHeader);
    pStubVtbl = (CInterfaceStubVtbl *) pTemp;

    RpcTryExcept

        //
        //Check if procnum is valid.
        //
        if((prpcmsg->iMethod >= pStubVtbl->header.DispatchTableCount) ||
           (prpcmsg->iMethod < 3))
        {
            RpcRaiseException(RPC_S_PROCNUM_OUT_OF_RANGE);
        }

        // null indicates pure-interpreted
        if ( pStubVtbl->header.pDispatchTable != 0)
        {
            (*pStubVtbl->header.pDispatchTable[prpcmsg->iMethod])(
                This,
                pRpcChannelBuffer,
                (PRPC_MESSAGE) prpcmsg,
                &dwServerPhase);
        }
        else
        {
            PMIDL_SERVER_INFO   pServerInfo;
            PMIDL_STUB_DESC     pStubDesc;

            pServerInfo = (PMIDL_SERVER_INFO) pStubVtbl->header.pServerInfo;
            pStubDesc = pServerInfo->pStubDesc;

#ifdef BUILD_NDR64
            if ( pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES  )
            {

                NdrStubCall3(This,
                             pRpcChannelBuffer,
                             (PRPC_MESSAGE) prpcmsg,
                             &dwServerPhase);
            }
            else
#endif
            if ( MIDL_VERSION_3_0_39 <= pServerInfo->pStubDesc->MIDLVersion )
                {
                // Since MIDL 3.0.39 we have a proc flag that indicates
                // which interpeter to call. This is because the NDR version
                // may be bigger than 1.1 for other reasons.

                PFORMAT_STRING pProcFormat;
                unsigned short ProcOffset;

                ProcOffset = pServerInfo->FmtStringOffset[ prpcmsg->iMethod ];
                pProcFormat = & pServerInfo->ProcString[ ProcOffset ];

                if ( pProcFormat[1]  &  Oi_OBJ_USE_V2_INTERPRETER )
                    {
                    NdrStubCall2(
                        This,
                        pRpcChannelBuffer,
                        (PRPC_MESSAGE) prpcmsg,
                        &dwServerPhase );
                    }
                else
                    {
#if defined(__RPC_WIN64__)
                    RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
#else
                    NdrStubCall(
                        This,
                        pRpcChannelBuffer,
                        (PRPC_MESSAGE) prpcmsg,
                        &dwServerPhase );
#endif
                    }
                }
            else
                {
                // Prior to that, the NDR version (on per file basis)
                // was the only indication of -Oi2.

                if ( pStubDesc->Version <= NDR_VERSION_1_1 )
                    {
#if defined(__RPC_WIN64__)
                    RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
#else
                    NdrStubCall(
                        This,
                        pRpcChannelBuffer,
                        (PRPC_MESSAGE) prpcmsg,
                        &dwServerPhase );
#endif
                    }
                else
                    {
                    NdrStubCall2(
                        This,
                        pRpcChannelBuffer,
                        (PRPC_MESSAGE) prpcmsg,
                        &dwServerPhase );
                    }
                }
        }
    RpcExcept(dwServerPhase == STUB_CALL_SERVER ?
        EXCEPTION_CONTINUE_SEARCH :
        EXCEPTION_EXECUTE_HANDLER)
        hr = NdrStubErrorHandler( RpcExceptionCode() );
    RpcEndExcept

    return hr;
}


HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Invoke(
    IN  IRpcStubBuffer *    This,
    IN  RPCOLEMESSAGE *     prpcmsg,
    IN  IRpcChannelBuffer * pRpcChannelBuffer)
/*++

Routine Description:
    Invoke a stub function via the dispatch table.

Arguments:

Return Value:

--*/
{
    HRESULT             hr = S_OK;
    unsigned char **    ppTemp;
    unsigned char *     pTemp;
    CInterfaceStubVtbl *pStubVtbl;
    unsigned long       dwServerPhase = STUB_UNMARSHAL;

    //Get a pointer to the stub vtbl.
    ppTemp = (unsigned char **) This;
    pTemp = *ppTemp;
    pTemp -= sizeof(CInterfaceStubHeader);
    pStubVtbl = (CInterfaceStubVtbl *) pTemp;

    RpcTryExcept
        {
        PMIDL_SERVER_INFO  pServerInfo;

        // Check if procnum is valid.
        // Note, this is a sync proc number.
        //
        if((prpcmsg->iMethod >= pStubVtbl->header.DispatchTableCount) ||
           (prpcmsg->iMethod < 3))
            {
            RpcRaiseException(RPC_S_PROCNUM_OUT_OF_RANGE);
            }

        // Async DCOM is supported only in the new interpreter,
        // and only since MIDL 5.0.+

        pServerInfo = (PMIDL_SERVER_INFO) pStubVtbl->header.pServerInfo;

        if ( pServerInfo->pStubDesc->MIDLVersion < MIDL_VERSION_5_0_136 )
            RpcRaiseException( RPC_S_INTERNAL_ERROR );

        // Non null would indicate an -Os stub or a delegation case.
        if ( pStubVtbl->header.pDispatchTable != 0)
            {
            (*pStubVtbl->header.pDispatchTable[prpcmsg->iMethod])(
                This,
                pRpcChannelBuffer,
                (PRPC_MESSAGE) prpcmsg,
                &dwServerPhase);
            }
        else
            {
#if defined(BUILD_NDR64)
            if ( pServerInfo->pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES )
                {
                switch ( NdrpGetSyntaxType( ( (PRPC_MESSAGE) prpcmsg )->TransferSyntax ) )
                    {
                    case XFER_SYNTAX_DCE:
                        NdrDcomAsyncStubCall( This,
                                  pRpcChannelBuffer,
                                  (PRPC_MESSAGE) prpcmsg,
                                  &dwServerPhase );
                        break;

                    case XFER_SYNTAX_NDR64:
                        Ndr64DcomAsyncStubCall( This,
                                        pRpcChannelBuffer,
                                       (PRPC_MESSAGE) prpcmsg,
                                       &dwServerPhase );
                        break;
                    }
                }
            else
#endif
                NdrDcomAsyncStubCall( This,
                                  pRpcChannelBuffer,
                                  (PRPC_MESSAGE) prpcmsg,
                                  &dwServerPhase );
            }
        }
    RpcExcept(dwServerPhase == STUB_CALL_SERVER ?
        EXCEPTION_CONTINUE_SEARCH :
        EXCEPTION_EXECUTE_HANDLER)
        hr = NdrStubErrorHandler( RpcExceptionCode() );
    RpcEndExcept

    return hr;
}


IRpcStubBuffer * STDMETHODCALLTYPE
CStdStubBuffer_IsIIDSupported(
    IN  IRpcStubBuffer *This,
    IN  REFIID          riid)
/*++

Routine Description:
    If the stub buffer supports the specified interface,
    then return an IRpcStubBuffer *.  If the interface is not
    supported, then return zero.

Arguments:

Return Value:

Notes:
    This works for CStdAsyncStubBuffer,CStdAsyncStubBuffer2.

--*/
{
    CStdStubBuffer   *  pCThis  = (CStdStubBuffer *) This;
    const IID *         pIID;
    IRpcStubBuffer *    pInterfaceStub = 0;

    pIID = NdrpGetStubIID(This);

    if(memcmp(&riid, pIID, sizeof(IID)) == 0)
    {
        if(pCThis->pvServerObject != 0)
        {
            pInterfaceStub = This;
            pInterfaceStub->lpVtbl->AddRef(pInterfaceStub);
        }
    }

    return pInterfaceStub;
}

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CountRefs(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    Count the number of references to the server object.

Arguments:

Return Value:

Notes:
    This works for CStdAsyncStubBuffer.

--*/
{
    ULONG   count = 0;

    if(((CStdStubBuffer *)This)->pvServerObject != 0)
        count++;

    return count;
}

ULONG STDMETHODCALLTYPE
CStdStubBuffer2_CountRefs(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    Count the number of references to the server object.

Arguments:

Return Value:

Notes:
    This works for CStdAsyncStubBuffer2.

--*/
{
    ULONG           count;
    unsigned char *pTemp;
    CStdStubBuffer2 * pStubBuffer;
    IRpcStubBuffer *pBaseStubBuffer;

    pTemp = (unsigned char *)This;
    pTemp -= offsetof(CStdStubBuffer2, lpVtbl);
    pStubBuffer = (CStdStubBuffer2 *) pTemp;

    count = CStdStubBuffer_CountRefs(This);

    pBaseStubBuffer = pStubBuffer->pBaseStubBuffer;

    if(pBaseStubBuffer != 0)
        count += pBaseStubBuffer->lpVtbl->CountRefs(pBaseStubBuffer);

    return count;
}


HRESULT STDMETHODCALLTYPE
CStdStubBuffer_DebugServerQueryInterface(
    IN  IRpcStubBuffer *This,
    OUT void **ppv)
/*++

Routine Description:
    Return the interface pointer to the server object.

Arguments:

Return Value:

--*/
{
    HRESULT hr;

    *ppv = ((CStdStubBuffer *)This)->pvServerObject;

    if(*ppv != 0)
        hr = S_OK;
    else
        hr = CO_E_OBJNOTCONNECTED;

    return hr;
}

void STDMETHODCALLTYPE
CStdStubBuffer_DebugServerRelease(
    IN  IRpcStubBuffer *This,
    IN  void *pv)
/*++

Routine Description:
    Release a pointer previously obtained via
    DebugServerQueryInterface.  This function does nothing.

Arguments:
    This
    pv

Return Value:
    None.

--*/
{
}


const IID * RPC_ENTRY
NdrpGetStubIID(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    This function returns a pointer to the IID for the interface stub.

Arguments:

Return Value:

--*/
{
    unsigned char **    ppTemp;
    unsigned char *     pTemp;
    CInterfaceStubVtbl *pStubVtbl;

    //Get a pointer to the stub vtbl.
    ppTemp = (unsigned char **) This;
    pTemp = *ppTemp;
    pTemp -= sizeof(CInterfaceStubHeader);
    pStubVtbl = (CInterfaceStubVtbl *) pTemp;

    return pStubVtbl->header.piid;
}


void RPC_ENTRY
NdrStubInitialize(
    IN  PRPC_MESSAGE         pRpcMsg,
    IN  PMIDL_STUB_MESSAGE   pStubMsg,
    IN  PMIDL_STUB_DESC      pStubDescriptor,
    IN  IRpcChannelBuffer *  pRpcChannelBuffer )
/*++

Routine Description:
    This routine is called by the server stub before unmarshalling.
    It sets up some stub message fields.

Arguments:
    pRpcMsg
    pStubMsg
    pStubDescriptor
    pRpcChannelBuffer

Return Value:
    None.

--*/
{
    NdrServerInitialize( pRpcMsg,
                         pStubMsg,
                         pStubDescriptor);

    pStubMsg->pRpcChannelBuffer = pRpcChannelBuffer;

    // This exception should be raised after initializing StubMsg.

    if ( pStubDescriptor->Version > NDR_VERSION )
        {
        NDR_ASSERT( 0, "ServerInitializePartial : bad version number" );

        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
        }

    pRpcChannelBuffer->lpVtbl->GetDestCtx( pRpcChannelBuffer,
                                           &pStubMsg->dwDestContext,
                                           &pStubMsg->pvDestContext);
}

void RPC_ENTRY
NdrStubInitializePartial(
    IN  PRPC_MESSAGE         pRpcMsg,
    IN  PMIDL_STUB_MESSAGE   pStubMsg,
    IN  PMIDL_STUB_DESC      pStubDescriptor,
    IN  IRpcChannelBuffer *  pRpcChannelBuffer,
    IN  unsigned long        RequestedBufferSize )
/*++

Routine Description:
    This routine is called by the server stub before unmarshalling.
    It sets up some stub message fields.

Arguments:
    pRpcMsg
    pStubMsg
    pStubDescriptor
    pRpcChannelBuffer

Return Value:
    None.

--*/
{
    NdrServerInitialize( pRpcMsg,
                         pStubMsg,
                         pStubDescriptor);

    pStubMsg->pRpcChannelBuffer = pRpcChannelBuffer;

    pRpcChannelBuffer->lpVtbl->GetDestCtx( pRpcChannelBuffer,
                                           &pStubMsg->dwDestContext,
                                           &pStubMsg->pvDestContext);

    MakeSureWeHaveNonPipeArgs( pStubMsg, RequestedBufferSize );
}

void RPC_ENTRY
NdrStubGetBuffer(
    IN  IRpcStubBuffer *    This,
    IN  IRpcChannelBuffer * pChannel,
    IN  PMIDL_STUB_MESSAGE  pStubMsg)
/*++

Routine Description:
    Get a message buffer from the channel

Arguments:
    This
    pChannel
    pStubMsg

Return Value:
    None.  If an error occurs, this functions raises an exception.

--*/
{
    HRESULT     hr;
    const IID * pIID;

    pIID = NdrpGetStubIID(This);
    pStubMsg->RpcMsg->BufferLength = pStubMsg->BufferLength;
    pStubMsg->RpcMsg->DataRepresentation = NDR_LOCAL_DATA_REPRESENTATION;
    hr = pChannel->lpVtbl->GetBuffer(pChannel, (RPCOLEMESSAGE *) pStubMsg->RpcMsg, *pIID);

    if(FAILED(hr))
    {
        RpcRaiseException(hr);
    }

    pStubMsg->Buffer = (unsigned char *) pStubMsg->RpcMsg->Buffer;
    pStubMsg->fBufferValid = TRUE;
}


HRESULT RPC_ENTRY
NdrStubErrorHandler(
    IN  DWORD dwExceptionCode)
/*++

Routine Description:
    Map exceptions into HRESULT failure codes.  If we caught an
    exception from the server object, then propagate the
    exception to the channel.

Arguments:
    dwExceptionCode

Return Value:
    This function returns an HRESULT failure code.

--*/
{
    HRESULT hr;

    if(FAILED((HRESULT) dwExceptionCode))
        hr = (HRESULT) dwExceptionCode;
    else
        hr = HRESULT_FROM_WIN32(dwExceptionCode);

    return hr;
}

EXTERN_C void RPC_ENTRY
NdrStubInitializeMarshall (
    IN  PRPC_MESSAGE        pRpcMsg,
    IN  PMIDL_STUB_MESSAGE  pStubMsg,
    IN  IRpcChannelBuffer * pRpcChannelBuffer )
/*++

Routine Description:
    This routine is called by the server stub before marshalling.  It
    sets up some stub message fields.

Arguments:
    pRpcMsg
    pStubMsg
    pRpcChannelBuffer

Return Value:
    None.

--*/
{
    pStubMsg->BufferLength = 0;

    pStubMsg->IgnoreEmbeddedPointers = FALSE;

    pStubMsg->fDontCallFreeInst = 0;

    pStubMsg->StackTop = 0;

    pRpcChannelBuffer->lpVtbl->GetDestCtx(
        pRpcChannelBuffer,
        &pStubMsg->dwDestContext,
        &pStubMsg->pvDestContext);
}


void __RPC_STUB NdrStubForwardingFunction(
    IN  IRpcStubBuffer *    This,
    IN  IRpcChannelBuffer * pChannel,
    IN  PRPC_MESSAGE        pmsg,
    OUT DWORD           *   pdwStubPhase)
/*++

Routine Description:
    This function forwards a call to the stub for the base interface.

Arguments:
    pChannel
    pmsg
    pdwStubPhase

Return Value:
    None.

--*/
{
    HRESULT hr;
    unsigned char *pTemp;
    CStdStubBuffer2 * pStubBuffer;
    IRpcStubBuffer *pBaseStubBuffer;

    pTemp = (unsigned char *)This;
    pTemp -= offsetof(CStdStubBuffer2, lpVtbl);
    pStubBuffer = (CStdStubBuffer2 *) pTemp;
    pBaseStubBuffer = pStubBuffer->pBaseStubBuffer;

    hr = pBaseStubBuffer->lpVtbl->Invoke(pBaseStubBuffer,
                                         (RPCOLEMESSAGE *) pmsg,
                                         pChannel);
    if(FAILED(hr))
        RpcRaiseException(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\typegen.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       typegen.h
//
//  Contents:   Generates a type format string from an ITypeInfo.
//
//  Classes:    CTypeGen
//
//  History:    26-Apr-97 ShannonC  Created
//
//----------------------------------------------------------------------------
#ifndef _TYPEGEN_H_
#define _TYPEGEN_H_

#include <ndrtypes.h>
#include <tiutil.h>

#ifndef _PARAMINFO
#define _PARAMINFO

class PARAMINFO
{
public:
    PARAMINFO() 
        {vt = VT_ILLEGAL;
         pTypeInfo = NULL; 
         pArray = NULL; 
         pTypeAttr = NULL; 
         cbAlignment = 7; 
         lLevelCount = 0;
         realvt = VT_ILLEGAL;
         }
    DWORD   wIDLFlags;
    VARTYPE vt;
    ITypeInfo *  pTypeInfo;
    TYPEATTR* pTypeAttr;
    USHORT cbAlignment;
    LONG   lLevelCount;
    VARTYPE realvt;
    union
    {
        IID         iid;
        ARRAYDESC *pArray;
    };
    ~PARAMINFO() {
// this header file is included form both typeinfo.h, where CINTERFACE is defined, 
// and udt.cxx, where CINTERFACE is NOT defined. 
#ifndef CINTERFACE
        if (pTypeInfo)
        {
            if (pTypeAttr)   // we got it from TKIND_ALIAS. need to free both
                pTypeInfo->ReleaseTypeAttr(pTypeAttr);
            pTypeInfo->Release();
        }
#else
        if (pTypeInfo)
        {
            if (pTypeAttr)   // we got it from TKIND_ALIAS. need to free both
                pTypeInfo->lpVtbl->ReleaseTypeAttr(pTypeInfo,pTypeAttr);
            pTypeInfo->lpVtbl->Release(pTypeInfo);
        }
#endif
    }

};


#endif

// When changing the MIDL compiler version to 5.1.158 or higher, please remember to fix
// the RpcFlags in typeinfo.cxx\GetProcFormat routine.

#define rmj 3
#define rmm 0
#define rup 44
#define MIDL_VERSION_3_0_44 (rmj<<24 | rmm << 16 | rup)
class CTypeGen
{
private:
    PFORMAT_STRING _pTypeFormat;
    USHORT         _cbTypeFormat;
    USHORT         _offset;
    ULONG          _uStructSize;

    void Init();

    HRESULT GrowTypeFormat(
        IN  USHORT cb);

    HRESULT PushStruct(
        IN  PARAMINFO        * parainfo,
        IN  FORMAT_CHARACTER   fcStruct,
        IN  VARDESC         ** ppVarDesc,
        IN  USHORT           * poffsets,
        IN  DWORD            * pdwStructInfo,
        IN  USHORT             size, 
        OUT USHORT           * pOffset,
        OUT DWORD            * pStructInfo);
		
    HRESULT PushByte(
        IN  byte b);

    HRESULT PushShort(
        IN  USHORT s);

    HRESULT PushOffset(
        IN  USHORT s);

    HRESULT PushIID(
        IN  IID iid);

    HRESULT PushLong(
        IN  ULONG s);
    
    HRESULT SetShort(
        IN  USHORT offset,
        IN  USHORT data);

    HRESULT SetByte(
        IN  USHORT offset,
        IN  BYTE   data);

    HRESULT GetShort(
        IN  USHORT  offset,
        OUT USHORT* data);
	    
    HRESULT GetByte(
        IN  USHORT offset,
        OUT BYTE * data);

    HRESULT RegisterInterfacePointer(
        IN  PARAMINFO * parainfo,
        OUT USHORT    * pOffset);

    HRESULT GetSizeStructSimpleTypesFormatString(
        VARTYPE vt,
        USHORT uPackingLevel,
        USHORT* pAlign,
        BOOL *fChangeToBogus);
    
    HRESULT GenStructSimpleTypesFormatString(
        IN  PARAMINFO * parainfo,
        IN  VARDESC   * pVarDesc,
        OUT USHORT    * pad);
	    
    
    HRESULT RegisterSafeArray(
        IN  PARAMINFO * parainfo,
        OUT USHORT    * pOffset);

    HRESULT RegisterStruct(
        IN  PARAMINFO * parainfo,
    	OUT USHORT    * pOffset,
    	OUT DWORD     * pStructInfo);

    HRESULT RegisterUDT(
        IN  PARAMINFO * parainfo,
    	OUT USHORT    * pOffset,
    	OUT DWORD     * pStructInfo);

    HRESULT ConvertStructToBogusStruct(
        IN  USHORT offset);

    HRESULT ParseStructMembers(
        IN PARAMINFO *parainfo,
        IN OUT FORMAT_CHARACTER *pfcStruct,
        IN VARDESC **ppVarDesc,
        IN USHORT *poffsets,
        IN DWORD *pdwStructInfo,
        IN USHORT uNumElements,
        OUT DWORD *pStructInfo);
    
	USHORT Alignment(DWORD dwReq,DWORD dwMax);

    USHORT AlignSimpleTypeInStruct(DWORD dwReq,DWORD dwMax, BOOL *fChangeToBogus);

public:
    CTypeGen();

    ~CTypeGen();

    HRESULT RegisterType(
        IN  PARAMINFO * parainfo,
        OUT USHORT    * pOffset,
        OUT DWORD     * dwStructInfo);

    HRESULT GetOffset(
        IN  USHORT   addr,
        OUT USHORT * poffset);
		
    HRESULT GetTypeFormatString(
        OUT PFORMAT_STRING * pTypeFormatString,
        OUT USHORT         * pLength);
        
    // Simple, non-destructive version of GetTypeFormatString
    PFORMAT_STRING GetFormatString()    {return _pTypeFormat;}

    HRESULT RegisterVector(
        IN  PARAMINFO * pParainfo,
        OUT USHORT    * pOffset,
        OUT DWORD *pdwStructInfo);

    HRESULT RegisterCArray(
        IN PARAMINFO * parainfo,
    	OUT USHORT   * pOffset,
        OUT DWORD    * pStructInfo);
        
    HRESULT AdjustTopLevelRef(USHORT offset);

    ULONG GetStructSize()       {return _uStructSize;}
};

HRESULT ReleaseTypeFormatString(
    PFORMAT_STRING pTypeFormat);

#endif // _TYPEGEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\stream.cxx ===
/*++

Microsoft Windows
Copyright (c) 1994 Microsoft Corporation.  All rights reserved.

Module Name:
    stream.cxx

Abstract:
    Implements the IStream interface on a memory buffer.

Author:
    ShannonC    09-Mar-1994

Environment:
    Windows NT and Windows 95.  We do not support DOS and Win16.

Revision History:
    12-Oct-94   ShannonC    Reformat for code review.

--*/

#include <ndrp.h>
#include <ndrole.h>

class CNdrStream : public IStream
{
public:
    virtual HRESULT STDMETHODCALLTYPE 
    QueryInterface(
        IN  REFIID riid, 
        OUT void **ppvObj);

    virtual ULONG STDMETHODCALLTYPE 
    AddRef();

    virtual ULONG STDMETHODCALLTYPE 
    Release();

    virtual HRESULT STDMETHODCALLTYPE 
    Read(
        IN  void *  pv, 
        IN  ULONG   cb, 
        OUT ULONG * pcbRead);

    virtual HRESULT STDMETHODCALLTYPE 
    Write(
        IN  void const *pv, 
        IN  ULONG       cb, 
        OUT ULONG *     pcbWritten);

    virtual HRESULT STDMETHODCALLTYPE 
    Seek(
        IN  LARGE_INTEGER   dlibMove, 
        IN  DWORD           dwOrigin, 
        OUT ULARGE_INTEGER *plibNewPosition);

    virtual HRESULT STDMETHODCALLTYPE 
    SetSize(
        IN  ULARGE_INTEGER libNewSize);

    virtual HRESULT STDMETHODCALLTYPE 
    CopyTo(
        IN  IStream *       pstm,
        IN  ULARGE_INTEGER  cb,
        OUT ULARGE_INTEGER *pcbRead,
        OUT ULARGE_INTEGER *pcbWritten);

    virtual HRESULT STDMETHODCALLTYPE 
    Commit(
        IN  DWORD grfCommitFlags);

    virtual HRESULT STDMETHODCALLTYPE 
    Revert();

    virtual HRESULT STDMETHODCALLTYPE 
    LockRegion(
        IN  ULARGE_INTEGER  libOffset,
        IN  ULARGE_INTEGER  cb,
        IN  DWORD           dwLockType);

    virtual HRESULT STDMETHODCALLTYPE 
    UnlockRegion(
        IN  ULARGE_INTEGER  libOffset,
        IN  ULARGE_INTEGER  cb,
        IN  DWORD           dwLockType);

    virtual HRESULT STDMETHODCALLTYPE 
    Stat(
        OUT STATSTG *   pstatstg, 
        IN  DWORD       grfStatFlag);

    virtual HRESULT STDMETHODCALLTYPE 
    Clone(
        OUT IStream **ppstm);

    CNdrStream(
        IN  unsigned char * pData, 
        IN  unsigned long   cbMax);

private:
    long            RefCount;
    unsigned char * pBuffer;
    unsigned long   cbBufferLength;
    unsigned long   position;
};

EXTERN_C IStream *STDAPICALLTYPE 
NdrpCreateStreamOnMemory(
    IN  unsigned char * pData, 
    IN  unsigned long   cbSize)
/*++

Routine Description:
    This function creates a stream on the specified memory buffer.

Arguments:
    pData   - Supplies pointer to memory buffer.
    cbSize  - Supplies size of memory buffer.

Return Value:
    This function returns a pointer to the newly created stream.

--*/ 
{
    CNdrStream *pStream = new CNdrStream(pData, cbSize);
    return (IStream *)pStream;
}

CNdrStream::CNdrStream(
    IN  unsigned char * pData, 
    IN  unsigned long   cbMax)
    : pBuffer(pData), cbBufferLength(cbMax)
/*++

Routine Description:
    This function creates a stream on the specified memory buffer.

Arguments:
    pData - Supplies pointer to memory buffer.
    cbMax - Supplies size of memory buffer.

Return Value:
    None.

--*/ 
{
    RefCount = 1;
    position = 0;
}


ULONG STDMETHODCALLTYPE 
CNdrStream::AddRef()
/*++

Routine Description:
    Increment the reference count.

Arguments:

Return Value:
    Reference count.

--*/ 
{
    InterlockedIncrement(&RefCount);
    return (ULONG) RefCount;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::Clone(
    OUT IStream **ppstm)
/*++

Routine Description:
    Create a new IStream object.  The new IStream gets an 
    independent seek pointer but it shares the underlying
    data buffer with the original IStream object.

Arguments:
    ppstm - Pointer to the new stream.

Return Value:
    S_OK            - The stream was successfully copied.
    E_OUTOFMEMORY   - The stream could not be copied due to lack of memory.

--*/ 
{
    HRESULT     hr;
    CNdrStream *pStream = new CNdrStream(pBuffer, cbBufferLength);

    if(pStream != 0)
    {
        pStream->position = position;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    *ppstm = (IStream *) pStream;

    return hr;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::Commit(
    IN DWORD grfCommitFlags)
/*++

Routine Description:
    This stream does not support transacted mode.  This function does nothing.

Arguments:
    grfCommitFlags

Return Value:
    S_OK

--*/ 
{
  return S_OK;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::CopyTo(
    IN  IStream *       pstm,
    IN  ULARGE_INTEGER  cb,
    OUT ULARGE_INTEGER *pcbRead,
    OUT ULARGE_INTEGER *pcbWritten)
/*++

Routine Description:
    Copies data from one stream to another stream.

Arguments:
    pstm        - Specifies the destination stream.
    cb          - Specifies the number of bytes to be copied to the destination stream.
    pcbRead     - Returns the number of bytes read from the source stream.
    pcbWritten  - Returns the number of bytes written to the destination stream.

Return Value:
    S_OK        - The data was successfully copied.
    Other errors from IStream::Write.

--*/ 
{
    HRESULT         hr;
    unsigned char * pSource;
    unsigned long   cbRead;
    unsigned long   cbWritten;
    unsigned long   cbRemaining;

    //Check if we are going off the end of the buffer.
    if(position < cbBufferLength)
        cbRemaining = cbBufferLength - position;
    else
        cbRemaining = 0;

    if((cb.HighPart == 0) && (cb.LowPart <= cbRemaining))
        cbRead = cb.LowPart;
    else
        cbRead = cbRemaining;

    pSource = pBuffer + position;

    //copy the data
    hr = pstm->Write(pSource, cbRead, &cbWritten);

    //advance the current position
    position += cbRead;

    if (pcbRead != 0)
    {
        pcbRead->LowPart = cbRead;
        pcbRead->HighPart = 0;
    }
    if (pcbWritten != 0)
    {
        pcbWritten->LowPart = cbWritten;
        pcbWritten->HighPart = 0;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::LockRegion(
    IN ULARGE_INTEGER   libOffset,
    IN ULARGE_INTEGER   cb,
    IN DWORD            dwLockType)
/*++

Routine Description:
    Range locking is not supported by this stream.

Return Value:
    STG_E_INVALIDFUNCTION.

--*/ 
{
    return STG_E_INVALIDFUNCTION;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::QueryInterface( 
    REFIID riid, 
    void **ppvObj)
/*++

Routine Description:
    Query for an interface on the stream.  The stream supports
    the IUnknown and IStream interfaces.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

--*/ 
{
    HRESULT hr;

    if ((memcmp(&riid, &IID_IUnknown, sizeof(IID)) == 0) ||
       (memcmp(&riid, &IID_IStream, sizeof(IID)) == 0))
    {
        this->AddRef();
        *ppvObj = (IStream *) this;
        hr = S_OK;
    }
    else
    {
        *ppvObj = 0;
        hr = E_NOINTERFACE;
    }
    
    return hr;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::Read(
    OUT void * pv,
    IN  ULONG  cb, 
    OUT ULONG *pcbRead)
/*++

Routine Description:
    Reads data from the stream starting at the current seek pointer.

Arguments:
    pv      - Returns the data read from the stream.
    cb      - Supplies the number of bytes to read from the stream.
    pcbRead - Returns the number of bytes actually read from the stream.

Return Value:
    S_OK    - The data was successfully read from the stream.
    S_FALSE - The number of bytes read was smaller than the number requested.

--*/ 
{
    HRESULT         hr;
    unsigned long   cbRead;
    unsigned long   cbRemaining;

    //Check if we are reading past the end of the buffer.
    if(position < cbBufferLength)
        cbRemaining = cbBufferLength - position;
    else
        cbRemaining = 0;

    if(cb <= cbRemaining)
    {
        cbRead = cb;
        hr = S_OK;
    }
    else
    {
        cbRead = cbRemaining;
        hr = S_FALSE;
    }

    //copy the data
    RpcpMemoryCopy(pv, pBuffer + position, cbRead);

    //advance the current position
    position += cbRead;
    
    if(pcbRead != 0)
        *pcbRead = cbRead;

    return hr;
}

ULONG STDMETHODCALLTYPE 
CNdrStream::Release()
/*++

Routine Description:
    Decrement the reference count.  When the reference count
    reaches zero, the stream is deleted.

Arguments:

Return Value:
    Reference count.

--*/ 
{
    unsigned long count;

    count = RefCount - 1;
    if(InterlockedDecrement(&RefCount) == 0)
    {
        count = 0;
        delete this;
    }

    return count;
}


HRESULT STDMETHODCALLTYPE 
CNdrStream::Revert()
/*++

Routine Description:
    This stream does not support transacted mode.  This function does nothing.

Arguments:
    None.

Return Value:
    S_OK.

--*/ 
{
  return S_OK;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::Seek(
    IN  LARGE_INTEGER   dlibMove,
    IN  DWORD           dwOrigin,
    OUT ULARGE_INTEGER *plibNewPosition)
/*++

Routine Description:
    Sets the position of the seek pointer.  It is an error to seek
    before the beginning of the stream or past the end of the stream.

Arguments:
    dlibMove        - Supplies the offset from the position specified in dwOrigin.
    dwOrigin        - Supplies the seek mode.
    plibNewPosition - Returns the new position of the seek pointer.

Return Value:
    S_OK                    - The seek pointer was successfully adjusted.
    STG_E_INVALIDFUNCTION   - dwOrigin contains invalid value.
    STG_E_SEEKERROR         - The seek pointer cannot be positioned before the
                              beginning of the stream or past the 
                              end of the stream.

--*/ 
{
    HRESULT         hr;
    long            high;
    long            low;
    unsigned long   offset;
    unsigned long   cbRemaining;

    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:
        //Set the seek position relative to the beginning of the stream.
        if((dlibMove.HighPart == 0) && (dlibMove.LowPart <= cbBufferLength))
        {
            position = dlibMove.LowPart;
            hr = S_OK;
        }
        else
        {
            //It is an error to seek past the end of the stream.
            hr = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_CUR:
        //Set the seek position relative to the current position of the stream.
        high = (long) dlibMove.HighPart;
        if(high < 0)
        {
            //Negative offset
            low = (long) dlibMove.LowPart;
            offset = -low;
            
            if((high == -1) && (offset <= position))
            {
                position -= offset;
                hr = S_OK;
            }
            else
            {
                //It is an error to seek before the beginning of the stream.
                hr = STG_E_SEEKERROR;
            }
        }
        else
        {
            //Positive offset
            if(position < cbBufferLength)
                cbRemaining = cbBufferLength - position;
            else
                cbRemaining = 0;
    
            if((dlibMove.HighPart == 0) && (dlibMove.LowPart <= cbRemaining))
            {
                position += dlibMove.LowPart;
                hr = S_OK;
            }
            else
            {
                //It is an error to seek past the end of the stream.
                hr = STG_E_SEEKERROR;
            }
        }
        break;

    case STREAM_SEEK_END:
    //Set the seek position relative to the end of the stream.
        high = (long) dlibMove.HighPart;
        if(high < 0)
        {
            //Negative offset
            low = (long) dlibMove.LowPart;
            offset = -low;
            
            if((high == -1) && (offset <= cbBufferLength))
            {
                position = cbBufferLength - offset;
                hr = S_OK;
            }
            else
            {
                //It is an error to seek before the beginning of the stream.
                hr = STG_E_SEEKERROR;
            }
        }
        else if(dlibMove.QuadPart == 0)
        {
            position = cbBufferLength;
            hr = S_OK;
        }
        else
        {
            //Positive offset
            //It is an error to seek past the end of the stream.
            hr = STG_E_SEEKERROR;
        }
        break;

    default:
        //dwOrigin contains an invalid value.
        hr = STG_E_INVALIDFUNCTION;
    }

    if (plibNewPosition != 0)
    {
        plibNewPosition->LowPart = position;
        plibNewPosition->HighPart = 0;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::SetSize(
    IN ULARGE_INTEGER libNewSize)
/*++

Routine Description:
    Changes the size of the stream.  

Arguments:
    libNewSize - Supplies the new size of the stream.

Return Value:
    S_OK                - The stream size was successfully changed.
    STG_E_MEDIUMFULL    - The stream size could not be changed.

--*/ 
{
    HRESULT hr;

    if((libNewSize.HighPart == 0) && (libNewSize.LowPart <= cbBufferLength))
    {
        cbBufferLength = libNewSize.LowPart;
        hr = S_OK;
    }
    else
    {
        hr = STG_E_MEDIUMFULL;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::Stat(
    OUT STATSTG *   pstatstg, 
    IN  DWORD       grfStatFlag)
/*++

Routine Description:
    This function gets information about this stream.

Arguments:
    pstatstg    - Returns information about this stream.
    grfStatFlg  - Specifies the information to be returned in pstatstg.

Return Value:
    S_OK.

--*/ 
{
    memset(pstatstg, 0, sizeof(STATSTG));
    pstatstg->type = STGTY_STREAM;
    pstatstg->cbSize.LowPart = cbBufferLength;
    pstatstg->cbSize.HighPart = 0;
       
    return S_OK;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::UnlockRegion(
    IN ULARGE_INTEGER   libOffset,
    IN ULARGE_INTEGER   cb,
    IN DWORD            dwLockType)
/*++

Routine Description:
    Range locking is not supported by this stream.

Return Value:
    STG_E_INVALIDFUNCTION.

--*/ 
{
    return STG_E_INVALIDFUNCTION;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::Write(
    IN  void const *pv,
    IN  ULONG       cb,
    OUT ULONG *     pcbWritten)
/*++

Routine Description:
    Write data to the stream starting at the current seek pointer.

Arguments:
    pv          - Supplies the data to be written to the stream.
    cb          - Specifies the number of bytes to be written to the stream.
    pcbWritten  - Returns the number of bytes actually written to the stream.

Return Value:
    S_OK                - The data was successfully written to the stream.
    STG_E_MEDIUMFULL    - Data cannot be written past the end of the stream.

--*/ 
{
    HRESULT         hr;
    unsigned long   cbRemaining;
    unsigned long   cbWritten;

    //Check if we are writing past the end of the buffer.
    if(position < cbBufferLength)
        cbRemaining = cbBufferLength - position;
    else
        cbRemaining = 0;
    
    if(cb <= cbRemaining)
    {
        cbWritten = cb;
        hr = S_OK;
    }
    else
    {
        cbWritten = cbRemaining;
        hr = STG_E_MEDIUMFULL;
    }

    // Write the data.
    RpcpMemoryCopy(pBuffer + position, pv, cbWritten);

    //Advance the current position
    position += cbWritten;

    //update pcbWritten
    if (pcbWritten != 0)
        *pcbWritten = cbWritten;

    return hr;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\tiutil.cxx ===
// Copyright (c) 1993-2000 Microsoft Corporation

#include <windows.h>
#include <ole2.h>
#include <oleauto.h>
#include <typegen.h>
#include <tiutil.h>
#define ASSERT(x) 
#define UNREACHED 0

//---------------------------------------------------------------------
//                            Utilities
//---------------------------------------------------------------------
/***
*PUBLIC HRESULT GetPrimaryInterface
*Purpose:
*  Given a TypeInfo describing a Coclass, search for and return
*  type TypeInfo that describes that class' primary interface.
*
*Entry:
*  ptinfo = the TypeInfo of the base class.
*
*Exit:
*  return value = HRESULT
*
*  *ptinfoPrimary = the TypeInfo of the primary interface, NULL
*           if the class does not have a primary interface.
*
***********************************************************************/
HRESULT 
GetPrimaryInterface(ITypeInfo *ptinfo, ITypeInfo **pptinfoPri)
{
    BOOL fIsDual;
    TYPEKIND tkind;
    HRESULT hresult;
    HREFTYPE hreftype;
    int impltypeflags;
    TYPEATTR *ptattr;
    unsigned int iImplType, cImplTypes;
    ITypeInfo *ptinfoRef;

    ptinfoRef = NULL;

    IfFailGo(ptinfo->GetTypeAttr(&ptattr), Error);
    cImplTypes = ptattr->cImplTypes;
    tkind = ptattr->typekind;
    ptinfo->ReleaseTypeAttr(ptattr);

    if(tkind != TKIND_COCLASS)
      return E_INVALIDARG;

    // Look for the interface marked [default] and not [source]
    for(iImplType = 0; iImplType < cImplTypes; ++iImplType){
      IfFailGo(ptinfo->GetImplTypeFlags(iImplType, &impltypeflags), Error);
      if(IMPLTYPEFLAG_FDEFAULT  == (impltypeflags & (IMPLTYPEFLAG_FDEFAULT | IMPLTYPEFLAG_FSOURCE)))
      {
    // Found It!
    IfFailGo(ptinfo->GetRefTypeOfImplType(iImplType, &hreftype), Error);
    IfFailGo(ptinfo->GetRefTypeInfo(hreftype, &ptinfoRef), Error);

    // If its dual, get the interface portion
        IfFailGo(ptinfoRef->GetTypeAttr(&ptattr), Error);
        fIsDual = (ptattr->wTypeFlags & TYPEFLAG_FDUAL)
           && (ptattr->typekind == TKIND_DISPATCH);
        ptinfoRef->ReleaseTypeAttr(ptattr);

    if (fIsDual) {
      IfFailGo(ptinfoRef->GetRefTypeOfImplType((UINT)-1, &hreftype), Error);
      IfFailGo(ptinfoRef->GetRefTypeInfo(hreftype, pptinfoPri), Error);
      ptinfoRef->Release();
    }
    else {
      *pptinfoPri = ptinfoRef;
    }

    return NOERROR;
      }
    }
    // NotFound
    *pptinfoPri = NULL;
    return NOERROR;

Error:
    if(ptinfoRef != NULL)
      ptinfoRef->Release();
    return hresult;
}

HRESULT 
VarVtOfIface(ITypeInfo FAR* ptinfo,
         TYPEATTR FAR* ptattr,
       PARAMINFO *pPinfo)
{
    HRESULT hresult;

    switch(ptattr->typekind){
    case TKIND_DISPATCH:
      if ((ptattr->wTypeFlags & TYPEFLAG_FDUAL) == 0) {
    // regular (non-dual) dispinterface is just VT_DISPATCH.
    pPinfo->vt = VT_DISPATCH;
    // don't have to set up *pguid, since not VT_INTERFACE
    break;
      }
      // The interface typeinfo version of a dual interface has the same
      // same guid as the dispinterface portion does, hence we can just use
      // the dispinterface guid here.
      /* FALLTHROUGH */

    case TKIND_INTERFACE:
      pPinfo->vt = VT_INTERFACE;
      pPinfo->iid = ptattr->guid;
      break;

    default:
      ASSERT(UNREACHED);
      hresult = DISP_E_BADVARTYPE;
      goto Error;
    }

    hresult = NOERROR;

Error:;
    return hresult;
}

HRESULT 
VarVtOfUDT(ITypeInfo FAR* ptinfo,
       TYPEDESC FAR* ptdesc,
       PARAMINFO *pPinfo)
{
    HRESULT hresult;
    TYPEATTR FAR* ptattrRef;
    ITypeInfo FAR* ptinfoRef;
    BOOLEAN fReleaseAttr = TRUE;

    ASSERT(ptdesc->vt == VT_USERDEFINED);

    ptinfoRef = NULL;
    ptattrRef = NULL;

    IfFailGo(ptinfo->GetRefTypeInfo(ptdesc->hreftype, &ptinfoRef), Error);
    IfFailGo(ptinfoRef->GetTypeAttr(&ptattrRef), Error);

    pPinfo->cbAlignment = ptattrRef->cbAlignment - 1;

    switch (ptattrRef->typekind) {
    case TKIND_ENUM:
      pPinfo->vt = VT_I4;
      hresult = NOERROR;
      break;

    case TKIND_ALIAS:
      hresult = VarVtOfTypeDesc(ptinfoRef,
                &ptattrRef->tdescAlias,
                pPinfo);
      if ((pPinfo->vt & (~VT_BYREF)) == VT_CARRAY)
      {
        if (pPinfo->pArray != NULL && pPinfo->pTypeAttr == NULL)    // immediate upper level
        {
            fReleaseAttr = FALSE;
            pPinfo->pTypeInfo->AddRef();
            pPinfo->pTypeAttr = ptattrRef;
        }
      }
      break;

    case TKIND_DISPATCH:
    case TKIND_INTERFACE:
      hresult = VarVtOfIface(ptinfoRef, ptattrRef, pPinfo);
      break;

    case TKIND_COCLASS:
    { TYPEATTR FAR* ptattrPri;
      ITypeInfo FAR* ptinfoPri;

      if((hresult = GetPrimaryInterface(ptinfoRef, &ptinfoPri)) == NOERROR){
    if((hresult = ptinfoPri->GetTypeAttr(&ptattrPri)) == NOERROR){
      hresult = VarVtOfIface(ptinfoPri, ptattrPri, pPinfo);
      ptinfoPri->ReleaseTypeAttr(ptattrPri);
    }
    ptinfoPri->Release();
      }
    }
      break;

    // this is a struct, handle indiviudal member later.
    case TKIND_RECORD:
        pPinfo->vt= VT_USERDEFINED;
        (*pPinfo).pTypeInfo = ptinfoRef;
        ptinfoRef->AddRef();
        
      break;

    default:
      IfFailGo(DISP_E_BADVARTYPE, Error);
      break;
    }

Error:;
    if(ptinfoRef != NULL){
      if(ptattrRef != NULL && fReleaseAttr)
    ptinfoRef->ReleaseTypeAttr(ptattrRef);
      ptinfoRef->Release();
    }
    return hresult;
}


/***
*PRIVATE HRESULT VarVtOfTypeDesc
*Purpose:
*  Convert the given typeinfo TYPEDESC into a VARTYPE that can be
*  represented in a VARIANT.  For some this is a 1:1 mapping, for
*  others we convert to a (possibly machine dependent, eg VT_INT->VT_I2)
*  base type, and others we cant represent in a VARIANT.
*  
*  Now we are supporting multiple levels of pointer indirection. To support
*  this, we created an internal VT_MULTIINDIRECTIONS. If vt in PARAMINFO is
*  VT_MULTIINDIRECTIONS, the real vt is on PARAMINFO::realvt, and VT_BYREF
*  must be true; additional levels of indirection is saved in PARAMINFO::
*  lLevelCount.
*
*Entry:
*  ptinfo = 
*  ptdesc = * to the typedesc to convert
*  pvt = 
*  pguid = 
*
*Exit:
*  return value = HRESULT
*
*  *pvt = a VARTYPE that may be stored in a VARIANT.
*  *pguid = a guid for a custom interface.
*
*
*  Following is a summary of how types are represented in typeinfo.
*  Note the difference between the apparent levels of indirection
*  between IDispatch* / DispFoo*, and DualFoo*.
*
*  I2		=> VT_I2
*  I2*		=> VT_PTR - VT_I2
*
*  IDispatch *	=> VT_DISPATCH
*  IDispatch **	=> VT_PTR - VT_DISPATCH
*  DispFoo *    => VT_DISPATCH
*  DispFoo **   => VT_PTR - VT_DISPATCH
*  DualFoo *	=> VT_PTR - VT_INTERFACE (DispIID)
*  DualFoo **	=> VT_PTR - VT_PTR - VT_INTERFACE (DispIID)
*  IFoo *	=> VT_PTR - VT_INTERFACE (IID)
*  IFoo **	=> VT_PTR - VT_PTR - VT_INTERFACE (IID)
*
***********************************************************************/
HRESULT 
VarVtOfTypeDesc(ITypeInfo FAR* ptinfo,
        TYPEDESC FAR* ptdesc,
       PARAMINFO *pPinfo)
{
    HRESULT hresult = NOERROR;

    switch (ptdesc->vt) {
    case VT_I2:
    case VT_I4:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_BSTR:
    case VT_DISPATCH:
    case VT_ERROR:
    case VT_BOOL:
    case VT_VARIANT:
    case VT_UNKNOWN:
    case VT_DECIMAL:
    case VT_I1:
    case VT_UI1:
    case VT_UI2:
    case VT_UI4:
    case VT_I8:
    case VT_UI8:
    case VT_HRESULT:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_FILETIME:
    case VT_STREAM:
    case VT_STORAGE:
      pPinfo->vt = ptdesc->vt;
      break;

    case VT_INT:
      pPinfo->vt = VT_I4;
      break;

    case VT_UINT:
      pPinfo->vt = VT_UI4;
      break;
    
    case VT_USERDEFINED:
      hresult = VarVtOfUDT(ptinfo, ptdesc, pPinfo);
      break;

    case VT_PTR:
        switch (ptdesc->lptdesc->vt)
        {
        // VT_PTR + VT_DISPATCH: it's IDispatch**
        case VT_DISPATCH:
        case VT_UNKNOWN:
        case VT_STREAM:
        case VT_STORAGE:
            pPinfo->vt  = ptdesc->lptdesc->vt |VT_BYREF;
            hresult = NOERROR;
            break;

      // Special case: dispinterface** (represented by VT_PTR-VT_PTR-VT_USERDEFINED-TKIND_DISPATCH
        case VT_PTR:
            if ( VT_USERDEFINED == ptdesc->lptdesc->lptdesc->vt )
                {
                // we need to read forward in VT_PTR-VT_PTR-VT_UDT case for 
                // dispinterface **
                hresult = VarVtOfUDT(ptinfo, ptdesc->lptdesc->lptdesc,pPinfo);
                if (hresult == NOERROR)
                    {
                    if (pPinfo->vt == VT_INTERFACE)
                        {
                        pPinfo->vt = (VT_BYREF | VT_INTERFACE);
                        }
                    else if (pPinfo->vt == VT_DISPATCH)
                        {
                        pPinfo->vt = (VT_BYREF | VT_DISPATCH);
                        }
                    else if ( pPinfo->vt == VT_MULTIINDIRECTIONS )
                        {
                        // add an additional level if it's ** already
                        pPinfo->lLevelCount++;
                        }
                    else
                        {
                        // VT_PTR-VT_PTR-something_other_than_interface:
                        pPinfo->realvt = pPinfo->vt;
                        pPinfo->vt = VT_MULTIINDIRECTIONS;
                        if ( pPinfo->realvt & VT_BYREF )
                            pPinfo->lLevelCount = 2;
                        else
                            {
                            pPinfo->realvt = pPinfo->realvt | VT_BYREF;
                            pPinfo->lLevelCount = 1;
                            }
                        }
                    }                    
                break;
                }
         // fall through if not VT_PTR-VT_PTR-VT_USERDEFINED case
        default:
            hresult = VarVtOfTypeDesc(ptinfo, ptdesc->lptdesc, pPinfo);
            if(hresult == NOERROR)
                {
                if(pPinfo->vt & VT_BYREF)
                    {
                    pPinfo->realvt = pPinfo->vt;
                    pPinfo->vt = VT_MULTIINDIRECTIONS;
                    pPinfo->lLevelCount = 1;
                    }
                else if ( pPinfo->vt == VT_MULTIINDIRECTIONS )
                    {
                    pPinfo->lLevelCount++;
                    }
                else if ((pPinfo->vt != VT_INTERFACE) && (pPinfo->vt != VT_DISPATCH))
                    {
                    // need to get rid of one level of indirection for interface
                    pPinfo->vt |= VT_BYREF;
                    }
                break;
                }
        }

            
      
      break;

    case VT_SAFEARRAY:
      hresult = VarVtOfTypeDesc(ptinfo, ptdesc->lptdesc, pPinfo);
      if(hresult == NOERROR){
        if(pPinfo->vt & (VT_BYREF | VT_ARRAY)){
      // error if nested array or array of pointers
        hresult = DISP_E_BADVARTYPE;
        break;
        }
        pPinfo->vt |= VT_ARRAY;
      }
      break;

        // VT_CARRAY in fact is fix length array. 
    case VT_CARRAY: 
        pPinfo->vt = ptdesc->vt;
        (*pPinfo).pArray = ptdesc->lpadesc;
        (*pPinfo).pTypeInfo = ptinfo;
        ptinfo->AddRef();
        break;

    default:
      ASSERT(UNREACHED);
      hresult = DISP_E_BADVARTYPE;
      break;
    }

    return hresult;
}

//
// Simple wrapper for VarVtOfTypeDesc that only returns
// the vt, not an entire PARAMINFO structure.  Used
// by the callframe code in ole32.
//
EXTERN_C
HRESULT NdrpVarVtOfTypeDesc(IN ITypeInfo *pTypeInfo,
							IN TYPEDESC  *ptdesc,
							OUT VARTYPE  *vt)
{
	PARAMINFO pinfo;
	HRESULT hr;

	if (vt == NULL)
		return E_POINTER;

	*vt = VT_EMPTY;

	hr = VarVtOfTypeDesc(pTypeInfo, ptdesc, &pinfo);
	if (SUCCEEDED(hr))
		*vt = pinfo.vt;
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\typeinfo.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-2000.
//
//  File:       typeinfo.h
//
//  Contents:   Generates -Oi2 proxies and stubs from an ITypeInfo.
//
//  Classes:    CTypeGen
//              CProcGen
//
//  History:    26-Apr-96 ShannonC  Created
//
//----------------------------------------------------------------------------
#ifndef _TYPEINFO_H_
#define _TYPEINFO_H_

#define USE_STUBLESS_PROXY
#define CINTERFACE
#include <ndrp.h>
#include <ndrole.h>
#include <rpcproxy.h>
#include <typegen.h>


struct TypeInfoVtbl
{
    LONG                     cRefs;
    IID                      iid;
    BOOL                     fIsDual;
    MIDL_STUB_DESC           stubDesc;
    MIDL_SERVER_INFO         stubInfo;
    CInterfaceStubVtbl       stubVtbl;
    MIDL_STUBLESS_PROXY_INFO proxyInfo;
    CInterfaceProxyVtbl      proxyVtbl;
}; 

struct TypeInfoCache
{
    IID iid;
    TypeInfoVtbl *pVtbl;
    DWORD dwTickCount;
};

typedef struct tagMethodInfo 
{
    FUNCDESC  * pFuncDesc;
    ITypeInfo * pTypeInfo;
} MethodInfo;


class CProcGen{
private:
    PFORMAT_STRING _pProcFormatString;
    USHORT         _offset;
    USHORT         _stackSize;
    ULONG          _clientBufferSize;
    ULONG          _serverBufferSize;
    BOOL           _fClientMustSize;
    BOOL           _fServerMustSize;
    BOOL           _fClientCorrCheck;
    BOOL           _fServerCorrCheck;
    USHORT         _usFloatArgMask;
    USHORT         _usFloatSlots;
    CTypeGen     * _pTypeGen;

    HRESULT CalcSize(
        IN  VARTYPE    vt,
        IN  DWORD      wIDLFlags,
        IN  ULONG      nParam);

    HRESULT GenParamDescriptor(
    	IN  PARAMINFO *pInfo,
    	OUT BOOLEAN *fChangeSize);

    HRESULT PushByte(
        IN  byte b);

    HRESULT PushShort(
        IN  USHORT s);

    HRESULT PushLong(
        IN  ULONG s);

    HRESULT SetShort(
        IN  USHORT offset,
        IN  USHORT data);

#if defined(__RPC_WIN64__)
    void AnalyzeFloatTypes(
        IN  USHORT ParamOffset,
        IN  USHORT offset);

    bool IsHomogeneous(
        IN  PFORMAT_STRING pFormat, 
        IN  FORMAT_CHARACTER fc);

    bool IsHomogeneousMemberLayout(
        IN  PFORMAT_STRING pFormat, 
        IN  FORMAT_CHARACTER fc);
#endif

public:
    HRESULT GetProcFormat(
        IN  CTypeGen     * pTypeGen,
        IN  ITypeInfo    * pTypeInfo,
        IN  FUNCDESC     * pFuncDesc,
        IN  USHORT         iMethod,
        OUT PFORMAT_STRING pProcFormatString,
        OUT USHORT       * pcbFormat);
};

HRESULT GetProxyVtblFromTypeInfo
(
    IN  ITypeInfo *         pTypeInfo,
    IN  REFIID              riid,
    OUT BOOL *              pfIsDual,
    OUT void **             ppVtbl
);

HRESULT GetStubVtblFromTypeInfo
(
    IN  ITypeInfo *           pTypeInfo,
    IN  REFIID                riid,
    OUT BOOL *                pfIsDual,
    OUT IRpcStubBufferVtbl ** ppVtbl
);

HRESULT GetVtbl(
    IN  ITypeInfo *         pTypeInfo,
    IN  REFIID              riid,
    OUT TypeInfoVtbl **     ppVtbl);

HRESULT CreateVtblFromTypeInfo(
    IN  REFIID              riid,
    IN  BOOL                fIsDual,
    IN  USHORT              numMethods,
    IN  MethodInfo   *      pMethodInfo,
    OUT TypeInfoVtbl **     ppVtbl);

HRESULT GetFuncDescs(
    IN  ITypeInfo *pTypeInfo,
    OUT MethodInfo *pMethodInfo);

HRESULT ReleaseFuncDescs(
    IN  USHORT cMethods,
    OUT MethodInfo *pMethodInfo);

HRESULT ReleaseProxyVtbl(void * pVtbl);

HRESULT ReleaseStubVtbl(void * pVtbl);

HRESULT ReleaseVtbl(TypeInfoVtbl *pInfo);

HRESULT CountMethods(
    IN  ITypeInfo * pTypeInfo,
    OUT USHORT    * pNumMethods);


EXTERN_C HRESULT NdrpCreateProxy(
    IN  REFIID              riid, 
    IN  IUnknown *          punkOuter, 
    OUT IRpcProxyBuffer **  ppProxy, 
    OUT void **             ppv);


ULONG STDMETHODCALLTYPE
CStdProxyBuffer3_Release(
    IN  IRpcProxyBuffer *   This);

ULONG STDMETHODCALLTYPE
CStdStubBuffer3_Release(
    IN  IRpcStubBuffer *    This);

//Cache functions.
HRESULT CacheRegister(IID riid,TypeInfoVtbl ** pVtbl);
HRESULT CacheLookup(REFIID riid, TypeInfoVtbl **pVtbl);
void ReleaseList(TypeInfoVtbl *pFirst);

EXTERN_C HRESULT NdrpCreateStub(
    IN  REFIID              riid, 
    IN  IUnknown *          punkServer, 
    OUT IRpcStubBuffer **   ppStub);

HRESULT	NdrLoadOleAutomationRoutines();

extern const IRpcStubBufferVtbl CStdStubBuffer2Vtbl;
extern USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[3];

extern USER_MARSHAL_SIZING_ROUTINE        pfnLPSAFEARRAY_UserSize;
extern USER_MARSHAL_MARSHALLING_ROUTINE   pfnLPSAFEARRAY_UserMarshal;
extern USER_MARSHAL_UNMARSHALLING_ROUTINE pfnLPSAFEARRAY_UserUnmarshal;

typedef unsigned long
(__RPC_USER * PFNSAFEARRAY_SIZE)
    (ULONG * pFlags, 
     ULONG Offset, 
     LPSAFEARRAY * ppSafeArray,
     const IID *piid);

typedef unsigned char *
(__RPC_USER * PFNSAFEARRAY_MARSHAL)
    (ULONG * pFlags, 
     BYTE * pBuffer, 
     LPSAFEARRAY * ppSafeArray,
     const IID *piid);

typedef unsigned char *
(__RPC_USER * PFNSAFEARRAY_UNMARSHAL)
    (ULONG * pFlags, 
     BYTE * pBuffer, 
     LPSAFEARRAY * ppSafeArray,
     const IID *piid);

extern PFNSAFEARRAY_SIZE      pfnLPSAFEARRAY_Size;
extern PFNSAFEARRAY_MARSHAL   pfnLPSAFEARRAY_Marshal;
extern PFNSAFEARRAY_UNMARSHAL pfnLPSAFEARRAY_Unmarshal;

#define VTABLE_BASE 0

#endif // _TYPEINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\typeinfo.cxx ===
//************************************************************************
//
//  Copyright (C) Microsoft Corporation, 1996-2000.
//
//  File:       typeinfo.cxx
//
//  Contents:   Generates -Oi2 proxies and stubs from an ITypeInfo.
//
//  Functions:  CacheRegister
//              CacheRelease
//              CacheLookup
//
//  History:    26-Apr-96 ShannonC  Created
//              June 1997 YongQu    Add UDT support
//              Oct  1998 YongQu    arbitrary length vtbl
//
//----------------------------------------------------------------------------
#include <typeinfo.h>
#include <interp.h>
#include <stddef.h>
#include <ndrtypes.h>
#include <tiutil.h>
#ifdef DOSWIN32RPC
#include <critsec.hxx>
#endif
#include <sysinc.h>
#include <limits.h>
#include "fmtstr.h"

#define MAKESTRUCTINFO(x,y,z) MAKELONG(x,y > z ? z : y);
#define GETSIZE LOWORD
#define GETALIGNMENT HIWORD

extern const IRpcProxyBufferVtbl CStdProxyBuffer3Vtbl = {
    CStdProxyBuffer_QueryInterface,
    CStdProxyBuffer_AddRef,
    CStdProxyBuffer3_Release,
    CStdProxyBuffer2_Connect,
    CStdProxyBuffer2_Disconnect };


HRESULT NdrpInitializeStublessVtbl(ULONG numMethods);
void GetTemplateVtbl(void *** pVtbl);
void ReleaseTemplateVtbl(void ** pVtbl);
void GetTemplateForwardVtbl(void *** pVtbl);
void ReleaseTemplateForwardVtbl(void ** pVtbl);
extern const IReleaseMarshalBuffersVtbl CStdProxyBuffer_ReleaseMarshalBuffersVtbl;
extern const IReleaseMarshalBuffersVtbl CStdStubBuffer_ReleaseMarshalBuffersVtbl;


static I_RPC_MUTEX TypeInfoMutex = 0;

//#define CACHE_BLOCK  32
//#define INIT_HIGH_MARK  20
//#define THRASHING_TIME  1000*30    // 30 sec

//The constants can be tunable instead of constants.
static LONG CACHE_BLOCK=32;
static ULONG INIT_HIGH_MARK = 20;
static ULONG IDLE_TIME= 1000 * 60 *5;   // 5 minutes.

#define THRASHING_TIME  1000*30
#define DELTA_MARK 4       // shrink 25% each time.



HINSTANCE       hOleAut32 = 0;
// local to this file only
static TypeInfoCache*  g_pCache = NULL;//array of cache entries.
static LONG            g_lActiveCacheRef = 0;
static LONG            g_lCacheSize = 0;
static LONG            g_lTotalCacheRef = 0;
#ifdef DEBUGRPC
static LONG            g_lCount = 0;
#endif


//+---------------------------------------------------------------------------
//
//  Function:   CreateProxyFromTypeInfo
//
//  Synopsis:   Creates an interface proxy using the type information supplied
//              in pTypeInfo.
//
//  Arguments:
//    pTypeInfo   - Supplies the ITypeInfo * describing the interface.
//    punkOuter   - Specifies the controlling unknown.
//    riid        - Specifies the interface ID.
//    ppProxy     - Returns a pointer to the IRpcProxyBuffer interface.
//    ppv         - Returns a pointer to the specified interface.
//
//  Returns:
//    S_OK
//    E_NOINTERFACE
//    E_OUTOFMEMORY
//
//----------------------------------------------------------------------------
HRESULT STDAPICALLTYPE
CreateProxyFromTypeInfo
(
    IN  ITypeInfo *         pTypeInfo,
    IN  IUnknown *          punkOuter,
    IN  REFIID              riid,
    OUT IRpcProxyBuffer **  ppProxy,
    OUT void **             ppv
)
{
    HRESULT hr = E_FAIL;
    BOOL    fIsDual;
    void  * pVtbl;

    *ppProxy = NULL;
    *ppv = NULL;

    //Get the proxy vtable.
    hr = GetProxyVtblFromTypeInfo(pTypeInfo, riid, &fIsDual, &pVtbl);

    if(SUCCEEDED(hr))
    {
        //Create the proxy.
        CStdProxyBuffer2 *pProxyBuffer;

        pProxyBuffer = new CStdProxyBuffer2;
        if(pProxyBuffer != NULL)
        {
            memset(pProxyBuffer, 0, sizeof(CStdProxyBuffer2));
            pProxyBuffer->lpVtbl = &CStdProxyBuffer3Vtbl;
            pProxyBuffer->RefCount = 1;
            pProxyBuffer->punkOuter = punkOuter ?
                                      punkOuter : (IUnknown *) pProxyBuffer;
            pProxyBuffer->pProxyVtbl = pVtbl;
            pProxyBuffer->pRMBVtbl = &CStdProxyBuffer_ReleaseMarshalBuffersVtbl;

            if(fIsDual)
            {
                pProxyBuffer->iidBase = IID_IDispatch;

                //Create the proxy for the base interface.
                hr = NdrpCreateProxy(IID_IDispatch,
                                     (IUnknown *) pProxyBuffer,
                                     &pProxyBuffer->pBaseProxyBuffer,
                                     (void **)&pProxyBuffer->pBaseProxy);
            }
            else
            {
                hr = S_OK;
            }

            if(SUCCEEDED(hr))
            {
                *ppProxy = (IRpcProxyBuffer *) pProxyBuffer;
                pProxyBuffer->punkOuter->lpVtbl->AddRef(pProxyBuffer->punkOuter);
                *ppv = &pProxyBuffer->pProxyVtbl;
            }
            else
            {
                delete pProxyBuffer;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if(FAILED(hr))
        {
            ReleaseProxyVtbl(pVtbl);
        }

    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetProxyVtblFromTypeInfo
//
//  Synopsis: Get a pointer to the proxy vtbl. The proxy vtbl should be
//            released via ReleaseProxyVtbl.
//
//  Arguments:
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT GetProxyVtblFromTypeInfo

(
    IN  ITypeInfo *         pTypeInfo,
    IN  REFIID              riid,
    OUT BOOL *              pfIsDual,
    OUT void **             ppVtbl
)
{
    HRESULT hr = E_FAIL;
    TypeInfoVtbl *pInfo;

    //Get the vtbl.
    hr = GetVtbl(pTypeInfo, riid, &pInfo);
    if(SUCCEEDED(hr))
    {
        *pfIsDual = pInfo->fIsDual;
        *ppVtbl = &pInfo->proxyVtbl.Vtbl;
    }
    else
    {
        *ppVtbl = NULL;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateStubFromTypeInfo
//
//  Synopsis:   Create an interface stub from the type information
//              supplied in pTypeInfo.
//
//  Arguments:
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT STDAPICALLTYPE
CreateStubFromTypeInfo
(
    IN  ITypeInfo *         pTypeInfo,
    IN  REFIID              riid,
    IN  IUnknown *          punkServer,
    OUT IRpcStubBuffer **   ppStub
)
{
    HRESULT hr = E_FAIL;
    BOOL    fIsDual;
    IRpcStubBufferVtbl *pVtbl;
    void ** pForwardingVtbl;


    *ppStub = NULL;

    //Get the stub vtable.
    hr = GetStubVtblFromTypeInfo(pTypeInfo, riid, &fIsDual, &pVtbl);

    if(SUCCEEDED(hr))
    {
        //Create the stub
        IUnknown *              punkForward;

        CStdStubBuffer2 *pStubBuffer = new CStdStubBuffer2;

        if(pStubBuffer != NULL)
        {
            GetTemplateForwardVtbl(&pForwardingVtbl);

            //Initialize the new stub buffer.
            pStubBuffer->lpForwardingVtbl = pForwardingVtbl;
            pStubBuffer->pBaseStubBuffer = 0;
            pStubBuffer->lpVtbl = pVtbl;
            pStubBuffer->RefCount= 1;
            pStubBuffer->pvServerObject = 0;
            pStubBuffer->pRMBVtbl = &CStdStubBuffer_ReleaseMarshalBuffersVtbl;

            *ppStub = (IRpcStubBuffer *) &pStubBuffer->lpVtbl;

             //Connect the stub to the server object.
            if(punkServer != 0)
            {
                hr = punkServer->lpVtbl->QueryInterface(
                        punkServer,
                        riid,
                        (void **) &pStubBuffer->pvServerObject);
            }
            else
            {
                hr = S_OK;
            }

            if(SUCCEEDED(hr))
            {
                if(punkServer != 0)
                    punkForward = (IUnknown *) &pStubBuffer->lpForwardingVtbl;
                else
                    punkForward = 0;

                if(fIsDual)
                {
                    //Create a stub for the base interface
                    hr = NdrpCreateStub(IID_IDispatch,
                                        punkForward,
                                        &pStubBuffer->pBaseStubBuffer);
                }

                if(FAILED(hr))
                {
                    if(pStubBuffer->pvServerObject)
                        pStubBuffer->pvServerObject->lpVtbl->Release(pStubBuffer->pvServerObject);
                    NdrOleFree(pStubBuffer);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if(FAILED(hr))
        {
            ReleaseTemplateForwardVtbl(pForwardingVtbl);
            ReleaseStubVtbl(pVtbl);
        }
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetStubVtblFromTypeInfo
//
//  Synopsis: Get a pointer to the stub vtbl. The stub vtbl should be
//            released via ReleaseStubVtbl.
//
//  Arguments:
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT GetStubVtblFromTypeInfo(
    IN  ITypeInfo *           pTypeInfo,
    IN  REFIID                riid,
    OUT BOOL  *               pfIsDual,
    OUT IRpcStubBufferVtbl ** ppVtbl)
{
    HRESULT hr = E_FAIL;
    TypeInfoVtbl *pInfo;

    //Get the vtbl.
    hr = GetVtbl(pTypeInfo, riid, &pInfo);
    if(SUCCEEDED(hr))
    {
        *pfIsDual = pInfo->fIsDual;
        *ppVtbl = &pInfo->stubVtbl.Vtbl;
    }

    return hr;
}


HRESULT CheckTypeInfo(
    IN  ITypeInfo  *pTypeInfo,
    OUT ITypeInfo **pptinfoProxy,
    OUT USHORT     *pcMethods,
    OUT BOOL       *pfIsDual)
{
    HRESULT      hr;
    TYPEATTR   * pTypeAttr;
    HREFTYPE     hRefType;
    UINT         cbSizeVft = 0;
    ITypeInfo   *ptinfoProxy = NULL;
    USHORT       cMethods;

    *pfIsDual = FALSE;

    hr = pTypeInfo->lpVtbl->GetTypeAttr(pTypeInfo, &pTypeAttr);
    if(SUCCEEDED(hr))
    {
        if(pTypeAttr->wTypeFlags & TYPEFLAG_FDUAL)
        {
            *pfIsDual = TRUE;

            if(TKIND_DISPATCH == pTypeAttr->typekind)
            {
                //Get the TKIND_INTERFACE type info.
                hr = pTypeInfo->lpVtbl->GetRefTypeOfImplType(pTypeInfo, (UINT) -1, &hRefType);
                if(SUCCEEDED(hr))
                {
                    hr = pTypeInfo->lpVtbl->GetRefTypeInfo(pTypeInfo, hRefType, &ptinfoProxy);
                    if(SUCCEEDED(hr))
                    {
                        TYPEATTR * ptattrProxy;
                        hr = ptinfoProxy->lpVtbl->GetTypeAttr(ptinfoProxy, &ptattrProxy);
                        if(SUCCEEDED(hr))
                        {
                            cbSizeVft = ptattrProxy->cbSizeVft;
                            ptinfoProxy->lpVtbl->ReleaseTypeAttr(ptinfoProxy, ptattrProxy);
                        }
                    }
                }
            }
            else if (TKIND_INTERFACE == pTypeAttr->typekind)
            {
                pTypeInfo->lpVtbl->AddRef(pTypeInfo);
                ptinfoProxy = pTypeInfo;
                cbSizeVft = pTypeAttr->cbSizeVft;
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else if((pTypeAttr->wTypeFlags & TYPEFLAG_FOLEAUTOMATION) &&
                (TKIND_INTERFACE == pTypeAttr->typekind))
        {
            pTypeInfo->lpVtbl->AddRef(pTypeInfo);
            ptinfoProxy = pTypeInfo;
            cbSizeVft = pTypeAttr->cbSizeVft;
        }
        else
        {
            hr = E_FAIL;
        }
        pTypeInfo->lpVtbl->ReleaseTypeAttr(pTypeInfo, pTypeAttr);
    }

    cMethods = (USHORT) ( (cbSizeVft - VTABLE_BASE) / sizeof(void *) );

    if(SUCCEEDED(hr))
    {
        *pptinfoProxy = ptinfoProxy;

        //Calculate the number of methods in the vtable.
        *pcMethods = cMethods;
    }
    else
    {
        *pptinfoProxy = NULL;

        if(ptinfoProxy != NULL)
        {
            ptinfoProxy->lpVtbl->Release(ptinfoProxy);
        }
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetVtbl
//
//  Synopsis: Get a pointer to the vtbl structure.
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT GetVtbl(
    IN  ITypeInfo *         pTypeInfo,
    IN  REFIID              riid,
    OUT TypeInfoVtbl **     ppVtbl)
{
    HRESULT hr;
    RPC_STATUS   rc;
    USHORT       numMethods;
    MethodInfo * aMethodInfo;
    BOOL         fIsDual = FALSE;
    ITypeInfo  * ptinfoProxy = NULL;

    *ppVtbl = NULL;

    rc = NdrpPerformRpcInitialization();

    if (RPC_S_OK != rc)
        return HRESULT_FROM_WIN32(rc);

    // the other two mutexes will be initialized in NdrpInitializeStublessVtbl
    if ( TypeInfoMutex == NULL )
        {
        hr = NdrpInitializeMutex( &TypeInfoMutex );
        if ( FAILED( hr ) )
            return hr;
        }
	
    //Check the cache.
    I_RpcRequestMutex(&TypeInfoMutex);
    hr = CacheLookup(riid, ppVtbl);
    I_RpcClearMutex(TypeInfoMutex);

    if(FAILED(hr))
    {
        //We didn't find the interface in the cache.
        //Create a vtbl from the ITypeInfo.
        hr = CheckTypeInfo(pTypeInfo, &ptinfoProxy, &numMethods, &fIsDual);

        if(SUCCEEDED(hr))
        {
            //allocate space for per-method data.
            aMethodInfo = (MethodInfo *) alloca(numMethods * sizeof(MethodInfo));
            if(aMethodInfo != NULL)
            {
                memset(aMethodInfo, 0, numMethods * sizeof(MethodInfo));

                //Get the per-method data.
                hr = GetFuncDescs(ptinfoProxy, aMethodInfo);
                if(SUCCEEDED(hr))
                {
                    hr = CreateVtblFromTypeInfo(riid, fIsDual, numMethods, aMethodInfo, ppVtbl);
                    if(SUCCEEDED(hr))
                    {
                        hr = CacheRegister(riid,ppVtbl);
                    }
                }
                ReleaseFuncDescs(numMethods, aMethodInfo);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            ptinfoProxy->lpVtbl->Release(ptinfoProxy);
        }
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateVtblFromTypeInfo
//
//  Synopsis:   Create a vtbl structure from the type information.
//
//  Arguments:
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT CreateVtblFromTypeInfo(
    IN  REFIID          riid,
    IN  BOOL            fIsDual,
    IN  USHORT          numMethods,
    IN  MethodInfo    * pMethodInfo,
    OUT TypeInfoVtbl ** ppVtbl)
{
    HRESULT hr = S_OK;
    USHORT  iMethod;
    ULONG   cbVtbl;
    ULONG   cbOffsetTable;
    USHORT  cbProcFormatString = 0;
    ULONG   cbSize;
    TypeInfoVtbl *pInfo = NULL;
    byte *pTemp;
    PFORMAT_STRING pTypeFormatString = NULL;
    PFORMAT_STRING pProcFormatString;
    unsigned short *pFormatStringOffsetTable;
    CTypeGen typeGen;
    CProcGen procGen;
    USHORT   cbFormat;
    USHORT offset = 0;
    ULONG cbDelegationTable;
    void **pDispatchTable = NULL;
    void **pStublessClientVtbl = NULL;
    void **pForwardingVtbl = NULL;

    *ppVtbl = NULL;

#ifdef DEBUGRPC
    InterlockedIncrement(&g_lCount);
#endif

    //Compute the size of the vtbl structure;
    cbVtbl = numMethods * sizeof(void *);

    if(fIsDual)
        cbDelegationTable = cbVtbl;
    else
        cbDelegationTable = 0;

    cbOffsetTable = numMethods * sizeof(USHORT);

    //Compute the size of the proc format string.
    for(iMethod = 3;
        iMethod < numMethods;
        iMethod++)
    {
        if(pMethodInfo[iMethod].pFuncDesc != NULL)
        {
#if !defined(__RPC_WIN64__)
            cbProcFormatString += 22;
#else
            // proc format string in 64bit is longer
            cbProcFormatString += 22 + sizeof(NDR_PROC_HEADER_EXTS64);
#endif
            cbProcFormatString += pMethodInfo[iMethod].pFuncDesc->cParams * 6;
        }
    }

    cbSize = sizeof(TypeInfoVtbl) + cbVtbl + cbDelegationTable + cbOffsetTable + cbProcFormatString;

    //Allocate the structure
    pInfo = (TypeInfoVtbl *) I_RpcAllocate(cbSize);

    if(pInfo != NULL)
    {
        memset(pInfo, 0, cbSize);

        pTemp = (byte *) pInfo->proxyVtbl.Vtbl + cbVtbl;

        if(cbDelegationTable != 0)
        {
            pDispatchTable = (void **) pTemp;
            pInfo->stubVtbl.header.pDispatchTable = (const PRPC_STUB_FUNCTION *) pDispatchTable;
            pTemp += cbDelegationTable;
        }

        pFormatStringOffsetTable = (unsigned short *) pTemp;
        pTemp += cbOffsetTable;
        pProcFormatString = (PFORMAT_STRING) pTemp;


        pInfo->proxyVtbl.Vtbl[0] = IUnknown_QueryInterface_Proxy;
        pInfo->proxyVtbl.Vtbl[1] = IUnknown_AddRef_Proxy;
        pInfo->proxyVtbl.Vtbl[2] = IUnknown_Release_Proxy;

        hr = NdrpInitializeStublessVtbl((ULONG)numMethods);
        if (FAILED(hr))
        {
            if (pInfo)
                I_RpcFree(pInfo);
            return hr;
        }

        //Get the format strings.
        //Generate -Oi2 proc format string from the ITypeInfo.
        GetTemplateVtbl(&pStublessClientVtbl);
        GetTemplateForwardVtbl(&pForwardingVtbl);
        for(iMethod = 3;
            SUCCEEDED(hr) && iMethod < numMethods;
            iMethod++)
        {
            if(pMethodInfo[iMethod].pFuncDesc != NULL)
            {
                pFormatStringOffsetTable[iMethod] = offset;
                hr = procGen.GetProcFormat(&typeGen,
                                           pMethodInfo[iMethod].pTypeInfo,
                                           pMethodInfo[iMethod].pFuncDesc,
                                           iMethod,
                                           (PFORMAT_STRING)pTemp,
                                           &cbFormat);

                if (FAILED(hr))
                {
                    ReleaseTemplateVtbl(pStublessClientVtbl);
                    ReleaseTemplateForwardVtbl(pForwardingVtbl);
                    if (pInfo)
                        I_RpcFree(pInfo);
                    return hr;
                }
                pTemp += cbFormat;
                offset += cbFormat;

                //Stubless client function.
                pInfo->proxyVtbl.Vtbl[iMethod] = pStublessClientVtbl[iMethod];
                if(pDispatchTable != NULL)
                {
                    //Interpreted server function.
                    pDispatchTable[iMethod] = NdrStubCall2;
                }
            }
            else
            {
                pFormatStringOffsetTable[iMethod] = (USHORT) -1;

                //Proxy delegation forwarding function.
                pInfo->proxyVtbl.Vtbl[iMethod] =  pForwardingVtbl[iMethod];

                if(pDispatchTable != NULL)
                {
                    //Stub delegation forwarding function.
                    pDispatchTable[iMethod] = NdrStubForwardingFunction;
                }
            }
        }

        ReleaseTemplateForwardVtbl(pForwardingVtbl);
        ReleaseTemplateVtbl(pStublessClientVtbl);

        if(SUCCEEDED(hr))
        {
            USHORT length;

            hr = typeGen.GetTypeFormatString(&pTypeFormatString, &length);
        }

        if(SUCCEEDED(hr))
        {
            //Initialize the vtbl.
            pInfo->cRefs = 1;

            //Initialize the iid.
            pInfo->iid = riid;
            pInfo->fIsDual = fIsDual;

            //Initialize the MIDL_STUB_DESC.
            pInfo->stubDesc.pfnAllocate = NdrOleAllocate;
            pInfo->stubDesc.pfnFree = NdrOleFree;
            //pInfo->stubDesc.apfnExprEval = ExprEvalRoutines;
            pInfo->stubDesc.pFormatTypes = pTypeFormatString;
#if !defined(__RPC_WIN64__)
            pInfo->stubDesc.Version = 0x20000; /* Ndr library version */
            pInfo->stubDesc.MIDLVersion = MIDL_VERSION_3_0_44;
#else
            pInfo->stubDesc.Version = 0x50002; /* Ndr library version */
            pInfo->stubDesc.MIDLVersion = MIDL_VERSION_5_2_202;
#endif
            pInfo->stubDesc.aUserMarshalQuadruple = UserMarshalRoutines;

            //Initialize the MIDL_SERVER_INFO.
            pInfo->stubInfo.pStubDesc = &pInfo->stubDesc;
            pInfo->stubInfo.ProcString = pProcFormatString;
            pInfo->stubInfo.FmtStringOffset = pFormatStringOffsetTable;

            //Initialize the stub vtbl.
            pInfo->stubVtbl.header.piid = &pInfo->iid;
            pInfo->stubVtbl.header.pServerInfo = &pInfo->stubInfo;
            pInfo->stubVtbl.header.DispatchTableCount = numMethods;

            //Initialize stub methods.
            memcpy(&pInfo->stubVtbl.Vtbl, &CStdStubBuffer2Vtbl, sizeof(CStdStubBuffer2Vtbl));
            pInfo->stubVtbl.Vtbl.Release = CStdStubBuffer3_Release;

            //Initialize the proxy info.
            pInfo->proxyInfo.pStubDesc = &pInfo->stubDesc;
            pInfo->proxyInfo.ProcFormatString = pProcFormatString;
            pInfo->proxyInfo.FormatStringOffset = pFormatStringOffsetTable;

            //Initialize the proxy vtbl.
            pInfo->proxyVtbl.header.pStublessProxyInfo = &pInfo->proxyInfo;
            pInfo->proxyVtbl.header.piid = &pInfo->iid;

            *ppVtbl = pInfo;
        }
        else
        {
            //Free the memory.
            I_RpcFree(pInfo);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;

}


//+---------------------------------------------------------------------------
//
//  Function:   GetFuncDescs
//
//  Synopsis:   Get the funcdesc for each method.
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT GetFuncDescs(
    IN  ITypeInfo *pTypeInfo,
    OUT MethodInfo *pMethodInfo)
{
    HRESULT hr;
    TYPEATTR *pTypeAttr;
    HREFTYPE hRefType;
    ITypeInfo *pRefTypeInfo;

    hr = pTypeInfo->lpVtbl->GetTypeAttr(pTypeInfo, &pTypeAttr);

    if(SUCCEEDED(hr))
    {
        if(IsEqualIID(IID_IUnknown, pTypeAttr->guid))
        {
            hr = S_OK;
        }
        else if(IsEqualIID(IID_IDispatch, pTypeAttr->guid))
        {
            hr = S_OK;
        }
        else
        {
            //This is an oleautomation interface.
            ULONG i, iMethod;
            FUNCDESC *pFuncDesc;

            if(pTypeAttr->cImplTypes)
            {
                //Recursively get the inherited member functions.
                hr = pTypeInfo->lpVtbl->GetRefTypeOfImplType(pTypeInfo, 0, &hRefType);
                if(SUCCEEDED(hr))
                {
                    hr = pTypeInfo->lpVtbl->GetRefTypeInfo(pTypeInfo, hRefType, &pRefTypeInfo);
                    if(SUCCEEDED(hr))
                    {
                        hr = GetFuncDescs(pRefTypeInfo, pMethodInfo);
                        pRefTypeInfo->lpVtbl->Release(pRefTypeInfo);
                    }
                }
            }

            //Get the member functions.
            for(i = 0; SUCCEEDED(hr) && i < pTypeAttr->cFuncs; i++)
            {
                hr = pTypeInfo->lpVtbl->GetFuncDesc(pTypeInfo, i, &pFuncDesc);
                if(SUCCEEDED(hr))
                {
                    iMethod = (pFuncDesc->oVft - VTABLE_BASE) / sizeof(void *);
                    pMethodInfo[iMethod].pFuncDesc = pFuncDesc;
                    pTypeInfo->lpVtbl->AddRef(pTypeInfo);
                    pMethodInfo[iMethod].pTypeInfo = pTypeInfo;
                }
            }
        }

        pTypeInfo->lpVtbl->ReleaseTypeAttr(pTypeInfo, pTypeAttr);
   }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseFuncDescs
//
//  Synopsis:   Release the funcdescs.
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT ReleaseFuncDescs(USHORT numMethods, MethodInfo *pMethodInfo)
{
    USHORT iMethod;

    //Release the funcdescs.
    if(pMethodInfo != NULL)
    {
        for(iMethod = 0;
            iMethod < numMethods;
            iMethod++)
        {
            if(pMethodInfo[iMethod].pFuncDesc != NULL)
            {
                 //Release the funcdesc.
                 pMethodInfo[iMethod].pTypeInfo->lpVtbl->ReleaseFuncDesc(
                     pMethodInfo[iMethod].pTypeInfo,
                      pMethodInfo[iMethod].pFuncDesc);

                 pMethodInfo[iMethod].pFuncDesc = NULL;

                 //release the type info
                 pMethodInfo[iMethod].pTypeInfo->lpVtbl->Release(
                     pMethodInfo[iMethod].pTypeInfo);

                 pMethodInfo[iMethod].pTypeInfo = NULL;
            }
        }
    }
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseProxyVtbl
//
//  Synopsis:   Releases the proxy vtbl.
//
//  Arguments:
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT ReleaseProxyVtbl(void * pVtbl)
{
    HRESULT hr = S_OK;
    byte *pTemp;
    TypeInfoVtbl *pInfo;

    pTemp = (byte *)pVtbl - offsetof(TypeInfoVtbl, proxyVtbl.Vtbl);
    pInfo = (TypeInfoVtbl *) pTemp;

    hr = ReleaseVtbl(pInfo);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseStubVtbl
//
//  Synopsis:   Releases the stub vtbl.
//
//  Arguments:
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT ReleaseStubVtbl(void * pVtbl)
{
    HRESULT hr = S_OK;
    byte *pTemp;
    TypeInfoVtbl *pInfo;

    pTemp = (byte *)pVtbl - offsetof(TypeInfoVtbl, stubVtbl.Vtbl);
    pInfo = (TypeInfoVtbl *) pTemp;

    hr = ReleaseVtbl(pInfo);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseTypeFormatString
//
//  Synopsis:   Frees the type format string.
//
//----------------------------------------------------------------------------
HRESULT ReleaseTypeFormatString(
    PFORMAT_STRING pTypeFormat)
{
    if((pTypeFormat != 0) &&
       (pTypeFormat != __MIDL_TypeFormatString.Format))
    {
        I_RpcFree((void *)pTypeFormat);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CStdProxyBuffer3_Release
//
//  Synopsis:   Decrement the proxy's reference count
//
//  Returns:    Reference count.
//
//----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CStdProxyBuffer3_Release(
    IN  IRpcProxyBuffer *   This)
{
    ULONG               count;
    IRpcProxyBuffer *   pBaseProxyBuffer;

    count = (ULONG) ((CStdProxyBuffer2 *)This)->RefCount - 1;

    if(InterlockedDecrement(&((CStdProxyBuffer2 *)This)->RefCount) == 0)
    {
        count = 0;

        ReleaseProxyVtbl((void *) ((CStdProxyBuffer2 *)This)->pProxyVtbl);

        //Delegation support.
        pBaseProxyBuffer = ((CStdProxyBuffer2 *)This)->pBaseProxyBuffer;

        if( pBaseProxyBuffer != 0)
        {
            pBaseProxyBuffer->lpVtbl->Release(pBaseProxyBuffer);
        }

        //Free the memory
        delete (CStdProxyBuffer2 *)This;
    }

    return count;
};


//+---------------------------------------------------------------------------
//
//  Function:   CStdStubBuffer3_Release
//
//  Synopsis:   Decrement the proxy's reference count
//
//  Returns:    Reference count.
//
//----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CStdStubBuffer3_Release(
    IN  IRpcStubBuffer *    This)
{
    ULONG       count;
    unsigned char *pTemp;
    CStdStubBuffer2 * pStubBuffer;
    IRpcStubBuffer *pBaseStubBuffer;

    pTemp = (unsigned char *)This;
    pTemp -= offsetof(CStdStubBuffer2, lpVtbl);
    pStubBuffer = (CStdStubBuffer2 *) pTemp;

    count = (ULONG) pStubBuffer->RefCount - 1;

    if(InterlockedDecrement(&pStubBuffer->RefCount) == 0)
    {
        count = 0;

        ReleaseStubVtbl((void *) This->lpVtbl);

        pBaseStubBuffer = pStubBuffer->pBaseStubBuffer;

        if(pBaseStubBuffer != 0)
            pBaseStubBuffer->lpVtbl->Release(pBaseStubBuffer);

        //Free the stub buffer
        if (pStubBuffer->lpForwardingVtbl)
        ReleaseTemplateForwardVtbl((void **)pStubBuffer->lpForwardingVtbl);
        delete pStubBuffer;

    }

    return count;
}

//+---------------------------------------------------------------------------
//
//  Function:   GrowCacheIfNecessary
//
//  Synopsis:   increase the size of cache array if it's too small.
//
//  Arguments:
//
//  Returns:
//
//----------------------------------------------------------------------------
HRESULT GrowCacheIfNecessary()
{
    TypeInfoCache *pTemp = NULL;
    DWORD *pIndex = NULL;
    if (NULL == g_pCache)
    {
        g_pCache = (TypeInfoCache *)I_RpcAllocate(CACHE_BLOCK * sizeof(TypeInfoCache));
        if (g_pCache )
        {
            memset(g_pCache,0,CACHE_BLOCK * sizeof(TypeInfoCache));
            g_lCacheSize = CACHE_BLOCK;
            return S_OK;
        }
        else
            return E_OUTOFMEMORY;

    }

    if (g_lCacheSize <= g_lTotalCacheRef)
    {
        pTemp = (TypeInfoCache *)I_RpcAllocate((g_lCacheSize + CACHE_BLOCK)* sizeof(TypeInfoCache));

        if (NULL == pTemp)
            return E_OUTOFMEMORY;

        memset(pTemp,0,(g_lCacheSize + CACHE_BLOCK)* sizeof(TypeInfoCache));
        memcpy(pTemp,g_pCache,g_lCacheSize*sizeof(TypeInfoCache));
        I_RpcFree(g_pCache);
        g_pCache = pTemp;
        g_lCacheSize += CACHE_BLOCK;
    }

    return S_OK;


}

void swapCache(ULONG src, ULONG dest)
{
    if (src == dest)
        return;

    TypeInfoCache temp;
    memcpy(&temp,&g_pCache[src],sizeof(TypeInfoCache));
    memcpy(&g_pCache[src],&g_pCache[dest],sizeof(TypeInfoCache));
    memcpy(&g_pCache[dest],&temp,sizeof(TypeInfoCache));
}

//+---------------------------------------------------------------------------
//
//  Function:   CacheRegister
//
//  Synopsis:   add a new instance of interface into the cache list. before
//                  inserting the newly generated vtbl, make sure no other thread
//                  has generated it first. If existing, discard the one this
//                  thread generated and use the one already in the list. Otherwise
//                  put it at the end of the array and adjust cache length.
//
//  Arguments:  riid,
//              pVtbl
//
//  Returns:
//
//----------------------------------------------------------------------------
HRESULT CacheRegister(
    IID riid,
    TypeInfoVtbl ** ppVtbl)
{
    HRESULT hr = E_FAIL;
    TypeInfoVtbl *pVtbl = *ppVtbl;

    // this exact same item has been registered by others while we
    // are busying building our own: use the existing one instead.
    I_RpcRequestMutex(&TypeInfoMutex);
    if (CacheLookup(riid,ppVtbl) == S_OK)
    {
        if(pVtbl->stubDesc.pFormatTypes != __MIDL_TypeFormatString.Format)
        {
            I_RpcFree((void *) pVtbl->stubDesc.pFormatTypes);
        }
        I_RpcFree(pVtbl);
        I_RpcClearMutex(TypeInfoMutex);
        return S_OK;
    }

    hr = GrowCacheIfNecessary();
    if (SUCCEEDED(hr))
    {
        g_pCache[g_lTotalCacheRef].iid = (*ppVtbl)->iid;
        g_pCache[g_lTotalCacheRef].dwTickCount = 0;
        g_pCache[g_lTotalCacheRef].pVtbl = *ppVtbl;

        swapCache(g_lTotalCacheRef,g_lActiveCacheRef);
        g_lTotalCacheRef++;
        g_lActiveCacheRef++;
    }


    I_RpcClearMutex(TypeInfoMutex);
    return hr;

}


void swap(ULONG *dwDelta,
          ULONG *dwIndex,
          ULONG src,
          ULONG dest)
{
    if (src == dest)
        return;

    ULONG temp;
    temp = dwDelta[src];
    dwDelta[src] = dwDelta[dest];
    dwDelta[dest] = temp;

    temp = dwIndex[src];
    dwIndex[src] = dwIndex[dest];
    dwIndex[dest] = temp;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindEntrysToShrink
//
//  Synopsis:   find the largest ulPivot number of entrys in the array.
//              a modification of algorithm due to C.A.R. Hoare in Programming
//              Pearls in Novermber 1985 Communications of ACM.
//
//  Arguments:
//
//  Returns:
//
//----------------------------------------------------------------------------

void  FindEntrysToShrink(ULONG *dwDelta,
                         ULONG *dwIndex,
                         ULONG ulPivot)
{
    ULONG ulLow = 0 , ulUp , ulSeq;
    ULONG ulMid ,ulIndex;
    ulUp = g_lTotalCacheRef - g_lActiveCacheRef -1 ;
    while (ulLow < ulUp)
    {
        ulSeq = ulLow;
        // pick a random number and assume it's the kth largest.
        ulIndex = ulLow + ((GetTickCount() & 0xff)*(ulUp-ulLow)/0xff);
        ulMid = dwDelta[ulIndex];
        swap(dwDelta,dwIndex,ulIndex,ulLow);
        for (ULONG i = ulLow + 1; i <= ulUp; i++)
        {
            if (dwDelta[i] >= ulMid)
                swap(dwDelta,dwIndex,++ulSeq,i);
        }
        // ulSeq is the ulSeq'th largest.
        swap(dwDelta,dwIndex,ulSeq,ulLow);
        if (ulSeq == ulPivot)
            break;  // done
        if (ulSeq < ulPivot)
            ulLow = ulSeq + 1 ;
        else
            ulUp = ulSeq - 1;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ShrinkReleasedCacheIfNecessary
//
//  Synopsis:   adjust the released cache size if necessary.
//              the algorithm:
//              find the eldest DELTA_MARK released interfaces. to avoid thrashing,
//                  increase the released cache size if eldest one is released within
//                  30 sec. fill the empty spots with active entries.
//
//  Arguments:
//
//  Returns:    S_OK. leave the HRESULT return for possible future change.
//
//----------------------------------------------------------------------------

HRESULT ShrinkReleasedCacheIfNecessary(TypeInfoVtbl*** pppVtbl, DWORD *dwLength)
{
    static ULONG dwHigh = INIT_HIGH_MARK;
    HRESULT hr = E_FAIL;
    ULONG dwShrink ;
    ULONG *dwDelta = NULL;
    ULONG *dwIndex = NULL;
    TypeInfoVtbl **ppvtbl = NULL;
    ULONG dwTime = GetTickCount(), dwMax = 0;
    ULONG i,j, dwMin=0xffffffff;
    ULONG dwReleasedCache = g_lTotalCacheRef - g_lActiveCacheRef;

    // doesn't need to shrink
    if (dwReleasedCache <= dwHigh)
        return S_FALSE;

    dwShrink = (ULONG)(dwHigh / DELTA_MARK); // number to shrink
    dwDelta = (ULONG *)I_RpcAllocate(dwReleasedCache * sizeof(ULONG));
    dwIndex = (ULONG *)I_RpcAllocate(dwReleasedCache * sizeof(ULONG));
    ppvtbl = (TypeInfoVtbl **)I_RpcAllocate(dwShrink * sizeof(TypeInfoVtbl *));

    if ( ( NULL == ppvtbl ) || ( NULL == dwDelta ) || ( NULL == dwIndex ) )
    {
        if ( NULL != dwDelta ) I_RpcFree( dwDelta );
        if ( NULL != dwIndex ) I_RpcFree( dwIndex );
        if ( NULL != ppvtbl ) I_RpcFree( ppvtbl );
        return E_OUTOFMEMORY;
    }

    for ( i = 0; i < dwReleasedCache; i++)
    {
        dwDelta[i] = dwTime - g_pCache[g_lActiveCacheRef+i].dwTickCount;
        dwIndex[i] = g_lActiveCacheRef+i;
        // basic book keeping to find the eldest and latest release.
        if (dwDelta[i] > dwMax)
            dwMax = dwDelta[i];
        if (dwDelta[i] < dwMin)
            dwMin = dwDelta[i];
    }

    // don't reclaim those released entries if it's thrashing.
    if (dwMax <= THRASHING_TIME)
    {
        dwHigh += (ULONG)(dwHigh / DELTA_MARK);
        return S_FALSE;
    }

    FindEntrysToShrink(dwDelta,dwIndex,dwShrink);


    // cleanup the entries to be removed.
    for (i = 0; i < dwShrink; i++)
    {
        ppvtbl[i] = g_pCache[dwIndex[i]].pVtbl;
        ASSERT(ppvtbl[i]->cRefs == 0);
        g_pCache[dwIndex[i]].pVtbl = 0;
    }


    // fill in the empty spots.
    j = g_lTotalCacheRef -1;
    for (i = 0; i < dwShrink; i++)
    {

        while (j > 0 && (g_pCache[j].pVtbl == 0)) j--;
        if (j > dwIndex[i])
        {
            memcpy(&g_pCache[dwIndex[i]],&g_pCache[j],sizeof(TypeInfoCache));
            memset(&g_pCache[j],0,sizeof(TypeInfoCache));
            j--;
        }
        else
            memset(&g_pCache[dwIndex[i]],0,sizeof(TypeInfoCache));

    }
    g_lTotalCacheRef -= dwShrink;

#ifdef DEBUGRPC
    for (i = 0; (LONG)i < g_lTotalCacheRef; i++)
        ASSERT(g_pCache[i].pVtbl != 0);
#endif

    if (dwMin > IDLE_TIME)
    {
        dwHigh -= (ULONG)(dwHigh / DELTA_MARK);
        if (dwHigh < INIT_HIGH_MARK)
            dwHigh = INIT_HIGH_MARK;
    }

    // don't free those vtbls: do it out of CS
    *pppVtbl = ppvtbl;
    *dwLength = dwShrink;
    return S_OK;

}



//+---------------------------------------------------------------------------
//
//  Function:   ReleaseVtbl
//
//  Synopsis:   Releases the vtbl.
//
//  Arguments:
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT ReleaseVtbl(TypeInfoVtbl *pInfo)
{
    TypeInfoVtbl **ppvtbl = NULL;
    DWORD dwLength = 0;
    LONG i;
    HRESULT hr = E_FAIL;

    I_RpcRequestMutex(&TypeInfoMutex);
    if (0 == --pInfo->cRefs)
    {
        for (i = 0 ; i < g_lTotalCacheRef; i++)
        {
            if (IsEqualIID(pInfo->iid,g_pCache[i].iid))
            {
                g_pCache[i].dwTickCount = GetTickCount();
                g_lActiveCacheRef--;
                swapCache(i,g_lActiveCacheRef);
                hr = ShrinkReleasedCacheIfNecessary(&ppvtbl,&dwLength);
                break;
             }
        }
    }
    else
    {
        I_RpcClearMutex(TypeInfoMutex);
        return S_OK;
    }
    I_RpcClearMutex(TypeInfoMutex);

    // free the vtbl outof mutex.
    if (S_OK == hr)
    {
        for (i = 0; i < (LONG)dwLength; i++)
        {

            if((ppvtbl[i])->stubDesc.pFormatTypes != __MIDL_TypeFormatString.Format)
            {
                I_RpcFree((void *) (ppvtbl[i])->stubDesc.pFormatTypes);
            }

            I_RpcFree((void *) ppvtbl[i]);
        }
        I_RpcFree(ppvtbl);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CacheLookup
//
//  Synopsis:   look up a TypeInfoVtbl from cache array using IID.
//              adjust the cache state if the entry is released.
//
//  Arguments:  riid
//              ppInfo
//
//  Returns:    S_OK if an entry is found in cache. E_NOINTERFACE is not.
//
//----------------------------------------------------------------------------
HRESULT CacheLookup(
    REFIID riid,
    TypeInfoVtbl **ppInfo)
{
    HRESULT hr = E_NOINTERFACE;
    LONG i;

    if (NULL == g_pCache)
        goto Exit;

    for ( i = 0; i < g_lTotalCacheRef; i++)
    {
        if (IsEqualIID(riid,g_pCache[i].iid))
        {
            *ppInfo = g_pCache[i].pVtbl;
            if (0 == (*ppInfo)->cRefs++)
            {
                g_pCache[i].dwTickCount = 0;
                swapCache(i,g_lActiveCacheRef++);
            }
            hr = S_OK;
            goto Exit;
        }
    }

Exit:
    return hr;

}


//+---------------------------------------------------------------------------
//
//  Function:   NdrpGetTypeGenCookie
//
//  Synopsis:   Allocate a cookie that can be used in subsequent calls to
//              NdrpGetProcFormatString, NdrpGetTypeFormatString, and
//              NdrpReleaseTypeGenCookie.
//
//  Parameters:
//
//  Returns:    ppvTypeGenCookie: A type gen cookie
//
//----------------------------------------------------------------------------
EXTERN_C
HRESULT NdrpGetTypeGenCookie(void **ppvTypeGenCookie)
{
	HRESULT hr = S_OK;
	CTypeGen *pTypeGen;

	if (ppvTypeGenCookie == NULL)
		return E_POINTER;

	pTypeGen = new CTypeGen;
	if (pTypeGen)
		*ppvTypeGenCookie = pTypeGen;
	else
		hr = E_OUTOFMEMORY;

	return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   NdrpReleaseTypeGenCookie
//
//  Synopsis:   Free memory associeated with type gen cookie allocated with
//              NdrpGetTypeGenCookie
//
//  Parameters: pvTypeGenCookie: cookie returned from NdrpGetTypeGenCookie
//
//  Returns:
//
//----------------------------------------------------------------------------
EXTERN_C
HRESULT NdrpReleaseTypeGenCookie(void *pvTypeGenCookie)
{
	CTypeGen *pTypeGen = (CTypeGen *)pvTypeGenCookie;

	delete pTypeGen;

	return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   NdrpGetProcFormatString
//
//  Synopsis:   Generate proc format string and type format string for specified
//              function.
//
//  Parameters: pTypeGenCookie: Type format generator object
//              pTypeInfo:      ITypeInfo interface.
//              pFuncDesc:      Function descriptor.
//              iMethod:        # of methods.
//
//  Returns:    pProcFormatString: Address for proc format string.
//              pcbFormat: Size of format string.
//
//----------------------------------------------------------------------------
EXTERN_C
HRESULT NdrpGetProcFormatString(IN  void      *pvTypeGenCookie,
								IN  ITypeInfo *pTypeInfo,
								IN  FUNCDESC  *pFuncDesc,
								IN  USHORT     iMethod,
								OUT PFORMAT_STRING pProcFormatString,
								OUT USHORT    *pcbFormat)
{
	CProcGen proc;
	CTypeGen *pTypeGen = (CTypeGen *)pvTypeGenCookie;

	if (pTypeGen == NULL)
		return E_INVALIDARG;
	else
		return proc.GetProcFormat(pTypeGen, pTypeInfo, pFuncDesc, iMethod,
								  pProcFormatString, pcbFormat);
}

//+---------------------------------------------------------------------------
//
//  Function:   NdrpGetTypeFormatString
//
//  Synopsis:   Get the MIDL_TYPE_FORMAT_STRING.
//
//  Arguments:  pvTypeGenCookie - cookie allocated with NdrpGetTypeGenCookie
//                                and used in subsequent NdrpGetProcFormatString
//                                calls.
//
//              ppTypeFormatString - Returns a pointer to the type format
//                                   string.
//
//              pLength - Returns the length of the format string.
//
//----------------------------------------------------------------------------
EXTERN_C
HRESULT NdrpGetTypeFormatString(IN void *pvTypeGenCookie,
								OUT PFORMAT_STRING * pTypeFormatString,
								OUT USHORT *         pLength)
{
	CTypeGen *pTypeGen = (CTypeGen *)pvTypeGenCookie;

	if (pTypeGen == NULL)
		return E_INVALIDARG;
	else
		return pTypeGen->GetTypeFormatString(pTypeFormatString, pLength);
}

//+---------------------------------------------------------------------------
//
//  Function:   NdrpReleaseTypeFormatString
//
//  Synopsis:   Free the memory returned from NdrpGetTypeFormatString function.
//
//  Parameters: pTypeFormatString: Address of format string returned from
//                                 NdrpGetTypeFormatString.
//
//----------------------------------------------------------------------------
EXTERN_C
HRESULT NdrpReleaseTypeFormatString(PFORMAT_STRING pTypeFormatString)
{
	if (pTypeFormatString)
	{
		if(pTypeFormatString != __MIDL_TypeFormatString.Format)
		{
			I_RpcFree((void *)pTypeFormatString);
		}	
	}

	return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetProcFormat
//
//  Synopsis:   Generate proc format string and type format string for specified
//              function.
//
//  Parameters: pTeypGen: Type format generator object
//              pTypeInfo: ITypeInfo interface.
//              pFuncDesc: Function descriptor.
//              iMethod:   # of methods.
//
//  Returns:    pProcFormatString: Address for proc format string.
//
//----------------------------------------------------------------------------
HRESULT CProcGen::GetProcFormat(
    IN  CTypeGen     * pTypeGen,
    IN  ITypeInfo    * pTypeInfo,
    IN  FUNCDESC     * pFuncDesc,
    IN  USHORT         iMethod,
    OUT PFORMAT_STRING pProcFormatString,
    OUT USHORT       * pcbFormat)
{
    HRESULT hr = S_OK;
    USHORT  iParam;
    INTERPRETER_FLAGS OiFlags ;
    INTERPRETER_OPT_FLAGS Oi2Flags ;
    INTERPRETER_OPT_FLAGS2 Oi2Flags2;
    PARAMINFO *aParamInfo;
    BOOLEAN fChangeSize,fNeedChange = FALSE;
    USHORT offset;

    aParamInfo = new PARAMINFO[pFuncDesc->cParams];

    if(0 == aParamInfo)
    {
        return E_OUTOFMEMORY;
    }

    for(iParam = 0;
        iParam < pFuncDesc->cParams;
        iParam++)
    {
        hr = VarVtOfTypeDesc(pTypeInfo,
                             &pFuncDesc->lprgelemdescParam[iParam].tdesc,
                             &aParamInfo[iParam]);

        if(SUCCEEDED(hr))
        {
            // PARAMFlags should give us enough information.
            DWORD wIDLFlags = pFuncDesc->lprgelemdescParam[iParam].idldesc.wIDLFlags;

            if(wIDLFlags & IDLFLAG_FRETVAL)
            {
                wIDLFlags |= IDLFLAG_FOUT;
            }

            if(!(wIDLFlags & (IDLFLAG_FIN | IDLFLAG_FOUT)))
            {
                //Set the direction flags.
                if(aParamInfo[iParam].vt & (VT_BYREF | VT_ARRAY))
                {
                    wIDLFlags |= IDLFLAG_FIN | IDLFLAG_FOUT;
                }
                else
                {
                    wIDLFlags |= IDLFLAG_FIN;
                }
            }

            aParamInfo[iParam].wIDLFlags = wIDLFlags;
        }
        else
        {
            goto Error;
        }
    }


    _pTypeGen = pTypeGen;
    _offset = 0;
    _pProcFormatString = pProcFormatString;
    _fClientMustSize  = FALSE;
    _fServerMustSize  = FALSE;
    _fClientCorrCheck = FALSE;
    _fServerCorrCheck = FALSE;
    _clientBufferSize = 0;
    _serverBufferSize = 0;
    _usFloatArgMask   = 0;
    _usFloatSlots     = 0;

    // The "this" pointer uses 8 bytes of stack on Alpha and 64bit platforms
    // and 4 bytes of stack on other platforms.
    _stackSize = sizeof(REGISTER_TYPE);


    //Compute the size of the parameters. leave out structures. We can only determine
    // the size later.
    // Also, we calculate the Oi2 extension flags / FloatMask for 64bit
    for(iParam = 0;
        SUCCEEDED(hr) && iParam < pFuncDesc->cParams;
        iParam++)
    {
        hr = CalcSize(aParamInfo[iParam].vt,
                      aParamInfo[iParam].wIDLFlags,
                      iParam);
    }

    if(SUCCEEDED(hr))
    {
        //Compute the size of the HRESULT return value.
        _stackSize += sizeof(REGISTER_TYPE);

        LENGTH_ALIGN(_serverBufferSize, 3);
        _serverBufferSize += 8;     // HRESULT is simple type, overestimate it also

        //Handle type
        PushByte(FC_AUTO_HANDLE);

        //Oi interpreter flags
        OiFlags.FullPtrUsed           = FALSE;
        OiFlags.RpcSsAllocUsed        = FALSE;
        OiFlags.ObjectProc            = TRUE;
        OiFlags.HasRpcFlags           = TRUE;
        OiFlags.IgnoreObjectException = FALSE;
        OiFlags.HasCommOrFault        = TRUE;
        OiFlags.UseNewInitRoutines    = TRUE;
        OiFlags.Unused                = FALSE;
        PushByte(*((byte *) &OiFlags));

        PushLong(0);       // RpcFlags

        //Method number
        PushShort(iMethod);

        offset = _offset;   // _stackSize,_clientBufferSize and _serverBufferSize could be
        //Stack size
        PushShort(_stackSize);

        //Size of client RPC message buffer.
        // place holder if there is a UDT parameter
        if(_clientBufferSize <= 65535)
            PushShort((USHORT) _clientBufferSize);
        else
        {
            hr = E_FAIL;
            goto Error;
        }

        //Size of server RPC message buffer.
        if(_serverBufferSize <= 65535)
            PushShort((USHORT) _serverBufferSize);
        else
        {
            hr = E_FAIL;
            goto Error;
        }

        //Oi2 interpreter flags
        *(byte*)&Oi2Flags = 0;
        Oi2Flags.ServerMustSize = _fServerMustSize;
        Oi2Flags.ClientMustSize = _fClientMustSize;
        Oi2Flags.HasReturn = TRUE;
        Oi2Flags.HasPipes = FALSE;
        Oi2Flags.Unused = 0;

#if defined(__RPC_WIN64__)
//      robust is only availble in 64bit tlb
        Oi2Flags.HasExtensions = TRUE;
#endif
        PushByte(*((byte *) &Oi2Flags));

        //Number of parameters + return value.
        PushByte(pFuncDesc->cParams + 1);

#if defined(__RPC_WIN64__)
//      robust is only availble in 64bit tlb
        if ( Oi2Flags.HasExtensions )
            {
            *(byte*)&Oi2Flags2 = 0;
            Oi2Flags2.HasNewCorrDesc = _fClientCorrCheck | _fServerCorrCheck ;
            Oi2Flags2.ClientCorrCheck = _fClientCorrCheck;
            Oi2Flags2.ServerCorrCheck = _fServerCorrCheck;
            PushByte( sizeof(NDR_PROC_HEADER_EXTS64) );   // header extension size
            PushByte( *( (byte *) &Oi2Flags2 ) ); // extension flags
            PushShort(0);   // client correlation count
            PushShort(0);   // server collrelation count
            PushShort(0);   // notify index
            PushShort(0);   // placeholder for ia64 float mask
            }
#endif

        // only a place holder for now if there are struct parameters.
        //Generate the parameter info.

        //The "this" pointer uses 8 bytes of stack on Alpha
        //and 4 bytes of stack on other platforms.
        _stackSize = sizeof(REGISTER_TYPE);

        for(iParam = 0;
            SUCCEEDED(hr) && iParam < pFuncDesc->cParams;
            iParam++)
        {
            hr = GenParamDescriptor(&aParamInfo[iParam],&fChangeSize);
            if (fChangeSize)    // there are structs as parameters.
            // _stackSize etc. might need to be changed.
            {
                fNeedChange = TRUE;
            }
        }


        if(SUCCEEDED(hr))
        {
            //Generate the HRESULT return value.
            PushShort( 0x70); //IsOut, IsReturn, IsBaseType
            PushShort(_stackSize);
            PushByte(FC_LONG);
            PushByte(0);
            *pcbFormat = _offset;
        }

         if (fNeedChange)
         {
            //Compute the size of the HRESULT return value.
            LENGTH_ALIGN(_serverBufferSize, 3);
            _serverBufferSize += 4;
            _stackSize += sizeof(REGISTER_TYPE);
            SetShort(offset,_stackSize);
            SetShort(offset + sizeof(SHORT),(USHORT)_clientBufferSize);
            SetShort(offset + 2*sizeof(SHORT),(USHORT)_serverBufferSize);
            if (_clientBufferSize > 0xffff || _serverBufferSize > 0xffff)
            {
                hr = E_FAIL;
                goto Error;
            }
         }

#if defined(__RPC_WIN64__)
         // Set the ia64 floatarg mask
         SetShort(24, _usFloatArgMask);
#endif
   }
Error:
    delete [] aParamInfo;
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   CProcGen::CalcSize
//
//  Synopsis:   calculate the stack size of current parameter in a method, also
//              calculate Oi2 extension flags for 64bit
//
//
//  Arguments:
//    IN VARTYPE vt       - vt type of current parameter
//    IN DWORD wIDLFlags  - IDL flags of this paramter
//    IN ULONG nParam     - parameter number
//
//  Returns:
//    S_OK
//    DISP_E_BADVARTYPE
//
//----------------------------------------------------------------------------
HRESULT CProcGen::CalcSize(
        IN  VARTYPE vt,
        IN  DWORD   wIDLFlags,
        IN  ULONG   nParam)
{
    HRESULT    hr = S_OK;

    switch(vt & (~VT_BYREF))
    {
    case VT_I1:
    case VT_UI1:
        _stackSize += sizeof(REGISTER_TYPE);

         if(wIDLFlags & IDLFLAG_FIN)
         {
            _clientBufferSize += 1;
         }

         if(wIDLFlags & IDLFLAG_FOUT)
         {
            _serverBufferSize += 1;
         }
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        _stackSize += sizeof(REGISTER_TYPE);

         if(wIDLFlags & IDLFLAG_FIN)
         {
            _clientBufferSize = (_clientBufferSize + 1) & ~1;
            _clientBufferSize += 4;
         }

         if(wIDLFlags & IDLFLAG_FOUT)
         {
            _serverBufferSize = (_serverBufferSize + 1) & ~1;
            _serverBufferSize += 4;
         }
        break;

    case VT_R4:
#if defined(_AMD64_) || defined(_IA64_)
        // setup float mask for ia64
        if ( !( vt & VT_BYREF ) && ( _stackSize/sizeof(REGISTER_TYPE)  < 8 ) ) 
            _usFloatArgMask |= 1 << ( 2 * _stackSize/sizeof(REGISTER_TYPE)  );
#endif
    case VT_I4:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
    case VT_HRESULT:
        _stackSize += sizeof(REGISTER_TYPE);

         if(wIDLFlags & IDLFLAG_FIN)
         {
            _clientBufferSize = (_clientBufferSize + 3) & ~3;
            _clientBufferSize += 8;
         }

         if(wIDLFlags & IDLFLAG_FOUT)
         {
            _serverBufferSize = (_serverBufferSize + 3) & ~3;
            _serverBufferSize += 8;
         }
        break;

    case VT_R8:
    case VT_DATE:
#if defined(_AMD64_) || defined(_IA64_)
        // setup float mask for ia64
        if ( !( vt & VT_BYREF )  && ( _stackSize/sizeof(REGISTER_TYPE)  < 8 ) ) 
            _usFloatArgMask |= 1 << ( 2 * _stackSize/sizeof(REGISTER_TYPE) + 1 );
#endif
    case VT_CY:
    case VT_I8:
    case VT_UI8:
        if(vt & VT_BYREF)
        {
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
            _stackSize += 8;
        }

        if(wIDLFlags & IDLFLAG_FIN)
        {
            _clientBufferSize = (_clientBufferSize + 7) & ~7;
            _clientBufferSize += 16;
        }

        if(wIDLFlags & IDLFLAG_FOUT)
        {
            _serverBufferSize = (_serverBufferSize + 7) & ~7;
            _serverBufferSize += 16;
        }
        break;

    case VT_DECIMAL:
        if(vt & VT_BYREF)
        {
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
            // On _IA64_ no need to align when size is up to 8 bytes
            _stackSize += sizeof(DECIMAL);
        }

        // overestimate the alignment to avoid buffer underrun during marshalling
        if(wIDLFlags & IDLFLAG_FIN)
        {
            _clientBufferSize = (_clientBufferSize + 7) & ~7;
            _clientBufferSize += sizeof(DECIMAL)  + 8;
        }

        if(wIDLFlags & IDLFLAG_FOUT)
        {
            _serverBufferSize = (_serverBufferSize + 7) & ~7;
            _serverBufferSize += sizeof(DECIMAL)  + 8;
        }
        break;

    case VT_VARIANT:
        if(vt & VT_BYREF)
        {
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
// in new spec, VARIANT is aligned to 8 again.
#if defined(_AMD64_) || defined(_IA64_)
            LENGTH_ALIGN(_stackSize, 7);
#endif // defined(_AMD64_) || defined(_IA64_)
            _stackSize += sizeof(VARIANT);
        }

        if(wIDLFlags & IDLFLAG_FIN)
        {
            _fClientMustSize = TRUE;
            _fServerCorrCheck= TRUE;
        }

        if(wIDLFlags & IDLFLAG_FOUT)
        {
            _fServerMustSize = TRUE;
            _fClientCorrCheck= TRUE;
        }
        break;

    case VT_INTERFACE:
    case VT_UNKNOWN:
    case VT_DISPATCH:
    case VT_STREAM:
    case VT_STORAGE:
    // structure
    case VT_USERDEFINED:
    case VT_BSTR:
    case VT_MULTIINDIRECTIONS:
    case VT_CARRAY:
        // set robust check for interfaces
        if(wIDLFlags & IDLFLAG_FIN)
        {
            _fServerCorrCheck= TRUE;
        }

        if(wIDLFlags & IDLFLAG_FOUT)
        {
            _fClientCorrCheck= TRUE;
        }
        // fall through for sizing

    case VT_LPSTR:
    case VT_LPWSTR:
        _stackSize += sizeof(REGISTER_TYPE);

        if(wIDLFlags & IDLFLAG_FIN)
        {
            _fClientMustSize = TRUE;
        }

        if(wIDLFlags & IDLFLAG_FOUT)
        {
            _fServerMustSize = TRUE;
        }
        break;

    case VT_FILETIME:
        if(vt & VT_BYREF)
        {
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
            _stackSize += sizeof(FILETIME);
        }

        if(wIDLFlags & IDLFLAG_FIN)
        {
            _clientBufferSize = (_clientBufferSize + 3) & ~3;
            _clientBufferSize += sizeof(FILETIME) + 4;
        }

        if(wIDLFlags & IDLFLAG_FOUT)
        {
            _serverBufferSize = (_serverBufferSize + 3) & ~3;
            _serverBufferSize += sizeof(FILETIME) + 4;
        }
        break;

    default:
        if(vt & VT_ARRAY)
        {
            _stackSize += sizeof(REGISTER_TYPE);

            if(wIDLFlags & IDLFLAG_FIN)
            {
                _fClientMustSize = TRUE;
                _fServerCorrCheck= TRUE;
            }

            if(wIDLFlags & IDLFLAG_FOUT)
            {
                _fServerMustSize = TRUE;
                _fClientCorrCheck= TRUE;
            }
        }
        else
        {
            hr = DISP_E_BADVARTYPE;
        }
        break;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   GenParamDescriptor
//
//  Synopsis:   generate proc string and format string for one parameter.
//
//  Parameter:  parainfo. the parameter information. vt for VARTYPE,
//                  IID if VARTYPE is interface,
//                  ITypeInfo if VARTYPE is UDT
//
//  Returns:    fChangeSize. TRUE if the parameter is a UDT. member variable of
//              CProcGen (_stackSize,_clientBufferSize and _serverBufferSize need to
//              be written back)
//
//----------------------------------------------------------------------------
HRESULT
CProcGen::GenParamDescriptor(
    IN  PARAMINFO  *parainfo,
    OUT BOOLEAN  * fChangeSize)
{
    HRESULT hr = S_OK;
    PARAM_ATTRIBUTES attr;
    USHORT     offset;
    *fChangeSize = FALSE;
    VARTYPE vt = parainfo->vt;
    DWORD dwStructInfo;
    USHORT ParamOffset = _stackSize;

    //Parameter attributes
#if 0
    attr.MustSize = FALSE;
    attr.MustFree = FALSE;
    attr.IsPipe = FALSE;
    attr.IsReturn = FALSE;
    attr.IsBasetype = FALSE;
    attr.IsByValue = FALSE;
    attr.IsSimpleRef = FALSE;
    attr.IsDontCallFreeInst = FALSE;
    attr.Unused = 0;
    attr.ServerAllocSize = 0;
#endif

    memset( &attr, 0, sizeof(attr) );
    attr.IsIn = (parainfo->wIDLFlags & IDLFLAG_FIN) ? 1 : 0;
    attr.IsOut = (parainfo->wIDLFlags & IDLFLAG_FOUT) ? 1 : 0;

    // VT_VECTOR: lookup from "canned" format string.
    switch(vt & (~VT_BYREF))
    {
    case VT_I1:
        attr.IsBasetype = TRUE;
        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        PushShort(*((short *) &attr));

        PushShort(_stackSize);
        _stackSize += sizeof(REGISTER_TYPE);

        PushShort(FC_SMALL);
        break;

    case VT_UI1:
        attr.IsBasetype = TRUE;
        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        PushShort(*((short *) &attr));

        PushShort(_stackSize);
        _stackSize += sizeof(REGISTER_TYPE);

        PushShort(FC_USMALL);
        break;

    case VT_I2:
    case VT_BOOL:
        attr.IsBasetype = TRUE;
        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        PushShort(*((short *) &attr));

        PushShort(_stackSize);
        _stackSize += sizeof(REGISTER_TYPE);

        PushShort(FC_SHORT);
        break;

    case VT_UI2:
        attr.IsBasetype = TRUE;
        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        PushShort(*((short *) &attr));

        PushShort(_stackSize);
        _stackSize += sizeof(REGISTER_TYPE);

        PushShort(FC_USHORT);
        break;

    case VT_I4:
    case VT_INT:
    case VT_ERROR:
    case VT_HRESULT:
        attr.IsBasetype = TRUE;
        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        PushShort(*((short *) &attr));

        PushShort(_stackSize);
        _stackSize += sizeof(REGISTER_TYPE);

        PushShort(FC_LONG);
        break;

    case VT_UINT:
    case VT_UI4:
        attr.IsBasetype = TRUE;
        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        PushShort(*((short *) &attr));

        PushShort(_stackSize);
        _stackSize += sizeof(REGISTER_TYPE);

        PushShort(FC_ULONG);
        break;

    case VT_I8:
    case VT_UI8:
    case VT_CY:
        attr.IsBasetype = TRUE;
        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        PushShort(*((short *) &attr));

        if(vt & VT_BYREF)
        {
            PushShort(_stackSize);
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
            PushShort(_stackSize);
            _stackSize += 8;
        }

        PushShort(FC_HYPER);
        break;

    case VT_R4:
        attr.IsBasetype = TRUE;
        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        PushShort(*((short *) &attr));

        PushShort(_stackSize);
        _stackSize += sizeof(REGISTER_TYPE);

        PushShort(FC_FLOAT);
        break;

    case VT_R8:
    case VT_DATE:
        attr.IsBasetype = TRUE;
        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        PushShort(*((short *) &attr));

        if(vt & VT_BYREF)
        {
            PushShort(_stackSize);
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
            PushShort(_stackSize);
            _stackSize += 8;
        }

        PushShort(FC_DOUBLE);
        break;

    case VT_DISPATCH:
    case VT_UNKNOWN:
    case VT_INTERFACE:
    case VT_STREAM:
    case VT_STORAGE:
        attr.MustSize = TRUE;
        attr.MustFree = TRUE;
        PushShort(*((short *) &attr));

        PushShort(_stackSize);
        _stackSize += sizeof(REGISTER_TYPE);

        hr = _pTypeGen->RegisterType(parainfo, &offset,NULL);
        PushShort(offset);
        break;

    case VT_BSTR:
        attr.MustSize = TRUE;
        attr.MustFree = TRUE;

        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        else
        {
            attr.IsByValue = TRUE;
        }

        PushShort(*((short *) &attr));

        PushShort(_stackSize);
        _stackSize += sizeof(REGISTER_TYPE);

        hr = _pTypeGen->RegisterType(parainfo, &offset,NULL);
        PushShort(offset);
        break;

    case VT_VARIANT:
        attr.MustSize = TRUE;
        attr.MustFree = TRUE;

        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                // size of VARIANT in 64bit is larger.
                attr.ServerAllocSize = (sizeof(VARIANT) +7 ) >> 3;
            }
        }
        else
        {
            attr.IsByValue = TRUE;
        }

        PushShort(*((short *) &attr));

        if(vt & VT_BYREF)
        {
            PushShort(_stackSize);
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
#if defined(_AMD64_) || defined(_IA64_)
            LENGTH_ALIGN(_stackSize, 7);
#endif // defined(_AMD64_) || defined(_IA64_)
            PushShort(_stackSize);
            _stackSize += sizeof(VARIANT);
        }

        hr = _pTypeGen->RegisterType(parainfo, &offset,NULL);
        PushShort(offset);
        break;

    case VT_LPSTR:
    case VT_LPWSTR:
        attr.MustSize = TRUE;
        attr.MustFree = TRUE;

        if(vt & VT_BYREF)
        {
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        else
        {
            attr.IsSimpleRef = TRUE;
        }

        PushShort(*((short *) &attr));

        PushShort(_stackSize);
        _stackSize += sizeof(REGISTER_TYPE);

        hr = _pTypeGen->RegisterType(parainfo, &offset,NULL);
        PushShort(offset);
        break;

    case VT_DECIMAL:
        attr.MustFree = TRUE;

        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                // we should use the size instead of hardcoded constant
                attr.ServerAllocSize = (sizeof( DECIMAL ) + 7 ) >> 3;
            }
        }
        else
        {
            attr.IsByValue = TRUE;
        }

        PushShort(*((short *) &attr));

        if(vt & VT_BYREF)
        {
            PushShort(_stackSize);
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
            // On _IA64_ no need to align when size is up to 8 bytes
            PushShort(_stackSize);
            _stackSize += sizeof(DECIMAL);
        }

        hr = _pTypeGen->RegisterType(parainfo, &offset,NULL);
        PushShort(offset);
        break;

    case VT_FILETIME:
        attr.MustFree = TRUE;

        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        else
        {
            attr.IsByValue = TRUE;
        }

        PushShort(*((short *) &attr));

        if(vt & VT_BYREF)
        {
            PushShort(_stackSize);
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
            // On _IA64_ no need to align when size is up to 8 bytes
            PushShort(_stackSize);
            _stackSize += sizeof(FILETIME);
        }

        hr = _pTypeGen->RegisterType(parainfo, &offset,&dwStructInfo);
        PushShort(offset);
        break;

    case VT_CARRAY:
    case VT_USERDEFINED:
        SHORT pad,length;

        hr = _pTypeGen->RegisterType(parainfo, &offset,&dwStructInfo);
        if (FAILED(hr))
            break;
        pad = GETALIGNMENT(dwStructInfo);
        length = GETSIZE(dwStructInfo);

        attr.MustSize = TRUE;
        attr.MustFree = TRUE;
        if ((vt & (~VT_BYREF)) != VT_CARRAY)
        {
            if(vt & VT_BYREF)
            {
                USHORT serverSize = length + 7;
                serverSize = serverSize >> 3;
                if (serverSize < 8 && !attr.IsIn)
                    attr.ServerAllocSize = serverSize;
                attr.IsSimpleRef = TRUE;
                hr = _pTypeGen->GetOffset(offset + 2 * sizeof (BYTE), &offset);
                if(FAILED(hr))
                    break;
            }
            else
            {
                attr.IsByValue = TRUE;
            }
        }

        PushShort(*((short *) &attr));
        PushShort(_stackSize);
        PushShort(offset);

        if(vt & VT_BYREF)
        {
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
            if (vt == VT_CARRAY)
                _stackSize += sizeof(REGISTER_TYPE);
            else
            {
                USHORT ualign = sizeof(REGISTER_TYPE) -1;
                _stackSize += length;
                _stackSize = (_stackSize + ualign) & ~ualign;
            #if defined(__RPC_WIN64__)
                // only check for floatmask if it UDT. top level float/double is handled already
                AnalyzeFloatTypes(ParamOffset, offset);
            #endif
            }
        }

        // over estimate the buffersize to avoid buffer underrun during marshalling
        if (parainfo->wIDLFlags & IDLFLAG_FIN)
        {
            _clientBufferSize += pad + 1;
        }
        if (parainfo->wIDLFlags & IDLFLAG_FOUT)
        {
            _serverBufferSize += pad + 1;
        }


        *fChangeSize = TRUE;
        break;

    case VT_MULTIINDIRECTIONS:
        attr.MustSize = TRUE;
        attr.MustFree = TRUE;
        PushShort(*((short *) &attr));

        PushShort(_stackSize);
        _stackSize += sizeof(REGISTER_TYPE);

        // top level double pointers should be FC_RP FC_ALLOCED_ON_STACK|DEREF
        // we have to change the type format string here because RegisterType
        // doesn't know if the ** is in top level or embedded
        hr = _pTypeGen->RegisterType(parainfo, &offset,&dwStructInfo);
        if (SUCCEEDED(hr))
            {
            hr = _pTypeGen->AdjustTopLevelRef(offset);
            }
        if (SUCCEEDED(hr))
            {
            PushShort(offset);
            }
        break;

    default:
        if(vt & VT_ARRAY)
        {
            attr.MustSize = TRUE;
            attr.MustFree = TRUE;

            if(vt & VT_BYREF)
            {
                attr.IsSimpleRef = TRUE;
                if(!attr.IsIn)
                {
                    attr.ServerAllocSize = 1;
                }
            }
            else
            {
                attr.IsByValue = TRUE;
            }

            PushShort(*((short *) &attr));

            PushShort(_stackSize);
            _stackSize += sizeof(REGISTER_TYPE);

            hr = _pTypeGen->RegisterType(parainfo, &offset,NULL);
            PushShort(offset);
        }
        else
            if (vt & VT_VECTOR)
                {
            attr.MustSize = TRUE;
            attr.MustFree = TRUE;

                hr = _pTypeGen->RegisterVector(parainfo, &offset,&dwStructInfo);
            if (SUCCEEDED(hr))
                {
               pad = GETALIGNMENT(dwStructInfo);
                   length = GETSIZE(dwStructInfo);
                   if(vt & VT_BYREF)
               {
                   USHORT serverSize = length + 7;
                   serverSize = serverSize >> 3;
                   attr.IsSimpleRef = TRUE;
                    hr = _pTypeGen->GetOffset(offset + 2 * sizeof (BYTE), &offset);
                    if (FAILED(hr))
                        return hr;
                    if(!attr.IsIn && serverSize < 8)
                        attr.ServerAllocSize = serverSize;
                }
                else
                {
                    attr.IsByValue = TRUE;
                }

                PushShort(*((short *) &attr));
                PushShort(_stackSize);
                PushShort(offset);
                if(vt & VT_BYREF)
                {
                    _stackSize += sizeof(REGISTER_TYPE);
                }
                else
                {
                    USHORT ualign = sizeof(REGISTER_TYPE) -1;
                    _stackSize += length;
                    _stackSize = (_stackSize + ualign) & ~ualign;
                }

                if (parainfo->wIDLFlags & IDLFLAG_FIN)
                {
                   _clientBufferSize += pad + 1 ;
                   if (_clientBufferSize & pad)
                    {
                        _clientBufferSize += pad;
                        _clientBufferSize &= ~pad;
                    }
                   _clientBufferSize += length ;
                }
                if (parainfo->wIDLFlags & IDLFLAG_FOUT)
                {
                    _serverBufferSize += pad + 1 ;
                    if (_clientBufferSize & pad)
                    {
                        _serverBufferSize += pad;
                        _serverBufferSize &= ~pad;
                    }
                    _serverBufferSize += length ;
                }

                *fChangeSize = TRUE;
                }
            }
                else
                        hr = DISP_E_BADVARTYPE;
                break;
    }


    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CProcGen::IsHomogeneous
//
//  Synopsis:   Determine if a type is a homogeneous floating point type
//
//  Parameter:  pFormat     -- The type info string
//              fc          -- FC_FLOAT or FC_DOUBLE
//
//  Returns:    true if the type is a homogeneous type of the specified
//              FC_FLOAT or FC_DOUBLE
//
//  Notes:      Base types are homogeneous.  Structs are homogeneous if each
//              member is homogeneous.
//
//----------------------------------------------------------------------------
#if defined(__RPC_WIN64__)
bool CProcGen::IsHomogeneous(PFORMAT_STRING pFormat, FORMAT_CHARACTER fc)
{
    switch (*pFormat)
    {
    case FC_FLOAT:
    case FC_DOUBLE:
        return ( *pFormat == fc );

    case FC_STRUCT:
        return IsHomogeneousMemberLayout(pFormat + 4, fc);

    case FC_BOGUS_STRUCT:
        return IsHomogeneousMemberLayout(pFormat + 8, fc);

/*
    case FC_PSTRUCT:
    case FC_CSTRUCT:
    case FC_CPSTRUCT:
    case FC_CVSTRUCT:
        // Structures with pointers are by definition not homogenous.
        // Arrays are not valid pieces of a homogeneous struct..
        return false;
*/
    }

    return false;
}
#endif // __RPC_WIN64__


//+---------------------------------------------------------------------------
//
//  Method:     CProcGen::IsHomogeneousMemberLayout
//
//  Synopsis:   Determine if a member layout is homogeneous
//
//  Parameter:  pFormat     -- The type info string
//              fc          -- FC_FLOAT or FC_DOUBLE
//
//  Returns:    true if the type is a homogeneous layout of the specified
//              FC_FLOAT or FC_DOUBLE
//
//  Notes:      Base types are homogeneous.  Structs are homogeneous if each
//              member is homogeneous.
//
//----------------------------------------------------------------------------
#if defined(__RPC_WIN64__)
bool CProcGen::IsHomogeneousMemberLayout(PFORMAT_STRING pFormat, FORMAT_CHARACTER fc)
{
    while (*pFormat != FC_END)
    {
        switch (*pFormat)
        {           
        case FC_FLOAT:
        case FC_DOUBLE:
            if ( *pFormat != fc )
                return false;

            ++pFormat;
            break;

        case FC_EMBEDDED_COMPLEX:
            pFormat += 2;
            if ( !IsHomogeneous( pFormat + *(short UNALIGNED  *)pFormat, fc ) )
                return false;

            pFormat += 2;
            break;

        case FC_PAD:
            pFormat += 1;
            break;

        default:
            return false;
        }
    }

    return true;
}
#endif __RPC_WIN64__



//+---------------------------------------------------------------------------
//
//  Method:     CProcGen::AnalyzeFloatTypes
//
//  Synopsis:   Analyse a type to see if it is a homogeneous floating point
//              type and adjust the floating point mask accordingly.
//
//  Parameter:  ParamOffset -- Offset of the param from the stack top
//              offset      -- The offset into the type string of the type
//
//----------------------------------------------------------------------------
#if defined(__RPC_WIN64__)
void CProcGen::AnalyzeFloatTypes(USHORT ParamOffset, USHORT offset)
{
    enum FloatType
    {
        NonFloat    = 0,
        Single      = 1,
        Double      = 2,
        DualSingle  = 3
    }
    type;

    PFORMAT_STRING pFormat = _pTypeGen->GetFormatString() + offset;

    bool issingle = IsHomogeneous(pFormat, FC_FLOAT);
    bool isdouble = IsHomogeneous(pFormat, FC_DOUBLE);

    if ( issingle || isdouble )
    {
        ULONG   paramSlot = ParamOffset /= sizeof(REGISTER_TYPE);
        long    members;

        if ( FC_FLOAT == *pFormat || FC_DOUBLE == *pFormat )
            members = 1;
        else
            members = _pTypeGen->GetStructSize() / ( isdouble ? 8 : 4 );
        
        while (members > 0 && _usFloatSlots < 8 && paramSlot < 8)
        {
            if ( isdouble )
                type = Double;
            else if ( members > 1 && _usFloatSlots < 7 )
                type = DualSingle;
            else
                type = Single;
            
            _usFloatArgMask |= type << (paramSlot * 2);

            paramSlot     += 1;
            members       -= 1 + (DualSingle == type);
            _usFloatSlots += 1 + (DualSingle == type);
        }
    }
}
#endif // __RPC_WIN64__


HRESULT CProcGen::PushByte(
    IN  byte b)
{
    BYTE *pb = (BYTE *) &_pProcFormatString[_offset];

    *pb = b;

    _offset += sizeof(b);

    return S_OK;
}

HRESULT CProcGen::PushShort(
    IN  USHORT s)
{
    short UNALIGNED *ps = (UNALIGNED short*)&_pProcFormatString[_offset];

    *ps = s;

    _offset += sizeof(s);

    return S_OK;
}

HRESULT CProcGen::PushLong(
    IN  ULONG s)
{
    long UNALIGNED *ps = (UNALIGNED long*)&_pProcFormatString[_offset];

    *ps = s;

    _offset += sizeof(s);

    return S_OK;
}


HRESULT CProcGen::SetShort(
    IN  USHORT offset,
    IN  USHORT data)
{
    if (offset >=  _offset)
        return E_INVALIDARG;

    *((UNALIGNED short *) &_pProcFormatString[offset]) = data;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::CTypeGen
//
//  Synopsis:   Constructor for type generator.
//
//----------------------------------------------------------------------------
CTypeGen::CTypeGen()
{
    Init();
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::Init
//
//  Synopsis:   Initialize the type generator.
//
//----------------------------------------------------------------------------
void CTypeGen::Init()
{
    _pTypeFormat = __MIDL_TypeFormatString.Format;

    _cbTypeFormat = TYPE_FORMAT_STRING_SIZE;

    //The _offset must be aligned on a 4 byte boundary.
    //Note that this may result in _offset > _cbTypeFormat.
    _offset = (TYPE_FORMAT_STRING_SIZE + 3) & ~3;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::~CTypeGen
//
//  Synopsis:   Destructor for type generator.
//
//----------------------------------------------------------------------------
CTypeGen::~CTypeGen()
{
    ReleaseTypeFormatString(_pTypeFormat);
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::GetTypeFormatString
//
//  Synopsis:   Get the MIDL_TYPE_FORMAT_STRING.
//
//  Arguments:  ppTypeFormatString - Returns a pointer to the type format
//                                   string.
//
//              pLength - Returns the length of the format string.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::GetTypeFormatString(
    OUT PFORMAT_STRING * ppTypeFormatString,
    OUT USHORT         * pLength)
{
    HRESULT hr = S_OK;

    *ppTypeFormatString = _pTypeFormat;

    if(_offset < _cbTypeFormat)
    {
        *pLength = _offset;
    }
    else
    {
        *pLength = _cbTypeFormat;
    }

    //Clear the type format string.
    Init();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::RegisterType
//
//  Synopsis:   Registers a top-level type in the type format string.
//
//  Arguments:  pTypeDesc - Supplies the type descriptor.
//              pOffset - Returns the offset in the type format string.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::RegisterType(
    IN  PARAMINFO * parainfo,
    OUT USHORT    * pOffset,
    OUT DWORD     * pStructInfo)
{
    HRESULT hr = S_OK;
    VARTYPE vt = parainfo->vt;
    IID *piid = &(parainfo->iid);
    USHORT maxAlignment = parainfo->cbAlignment;

    *pOffset = 0;
    switch(vt & (~VT_BYREF))
    {
    case VT_BSTR:
        if(vt & VT_BYREF)
        {
            //BSTR *pBSTR
            *pOffset = BYREF_BSTR_TYPE_FS_OFFSET ;
        }
        else
        {
            //BSTR bstr
            *pOffset = BSTR_TYPE_FS_OFFSET ;
        }
        if (pStructInfo)
            *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE,PTR_MEM_ALIGN,maxAlignment);   //  usermarshall
        break;

    case VT_LPWSTR:
        if(vt & VT_BYREF)
        {
            //LPWSTR *ppwsz
            // it's ok to point to FC_RP: it's right if it's top level parameter;
            // and if it's embedded, later analysis on PushStruct will force it to FC_UP.
            *pOffset = BYREF_LPWSTR_TYPE_FS_OFFSET ;
        }
        else
        {
            //LPWSTR lpwstr
            *pOffset = LPWSTR_TYPE_FS_OFFSET ;
        }
        if (pStructInfo)
            *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);   //  usermarshall
        break;

    case VT_LPSTR:
        if(vt & VT_BYREF)
        {
            //LPSTR *ppsz
            *pOffset = BYREF_LPSTR_TYPE_FS_OFFSET ;
        }
        else
        {
            //LPSTR lpstr
            *pOffset = LPSTR_TYPE_FS_OFFSET ;
        }
        if (pStructInfo)
            *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);   //  usermarshall
        break;

    case VT_VARIANT:
        if(vt & VT_BYREF)
        {
            //VARIANT *pVariant
            *pOffset = BYREF_VARIANT_TYPE_FS_OFFSET ;
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);
       }
        else
        {
            //VARIANT variant
            *pOffset = VARIANT_TYPE_FS_OFFSET ;
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO( sizeof(VARIANT) ,7,maxAlignment);// usrmarshall. bug 13193
        }
        break;

    case VT_DISPATCH:
        if(vt & VT_BYREF)
        {
            //IDispatch **ppDispatch
            *pOffset = BYREF_DISPATCH_TYPE_FS_OFFSET ;
        }
        else
        {
            //IDispatch *pDispatch
            *pOffset = DISPATCH_TYPE_FS_OFFSET ;
        }
        if (pStructInfo)
            *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);   //  usermarshall
        break;

    case VT_UNKNOWN:
        if(vt & VT_BYREF)
        {
            //IUnknown **ppunk
            *pOffset = BYREF_UNKNOWN_TYPE_FS_OFFSET ;
        }
        else
        {
            //IUnknown *punk
            *pOffset = UNKNOWN_TYPE_FS_OFFSET ;
        }
        if (pStructInfo)
            *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);   //  usermarshall
        break;

    case VT_DECIMAL:
        if(vt & VT_BYREF)
        {
            //DECIMAL *pDecimal
            // this is for top level parameter only. (srv alloc). in struct case
            // a FC_UP is added.
            *pOffset = DECIMAL_TYPE_FS_OFFSET ;
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);   //  usermarshall
        }
        else
        {
            //DECIMAL decimal
            *pOffset = DECIMAL_TYPE_FS_OFFSET ;
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO(sizeof( DECIMAL ),7,maxAlignment);
        }
        break;

    case VT_STREAM:
        if(vt & VT_BYREF)
        {
            //IStream **ppStream
            *pOffset = BYREF_STREAM_TYPE_FS_OFFSET ;
        }
        else
        {
            //IStream *pStream
            *pOffset = STREAM_TYPE_FS_OFFSET ;
        }
        if (pStructInfo)
            *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);   //  usermarshall
       break;

    case VT_STORAGE:
        if(vt & VT_BYREF)
        {
            //IStorage **ppStorage
            *pOffset = BYREF_STORAGE_TYPE_FS_OFFSET ;
        }
        else
        {
            //IStorage *pStorage
            *pOffset = STORAGE_TYPE_FS_OFFSET ;
        }
        if (pStructInfo)
            *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);
        break;

    case VT_FILETIME:
        if(vt & VT_BYREF)
        {
            //FILETIME *pfileTime
            *pOffset = BYREF_FILETIME_TYPE_FS_OFFSET ;
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);
        }
        else
        {
            //FILETIME FileTime
            *pOffset = FILETIME_TYPE_FS_OFFSET ;
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO(8,3,maxAlignment);
        }
        break;

    case VT_INTERFACE:
        hr = RegisterInterfacePointer(parainfo, pOffset);
        if (pStructInfo)
            *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);
        break;

    case VT_USERDEFINED:
        hr = RegisterUDT(parainfo, pOffset, pStructInfo);
        break;

    case VT_I1:
    case VT_UI1:
        if (vt & VT_BYREF)
        {
            *pOffset = BYREF_I1_TYPE_FS_OFFSET ;
        if (pStructInfo)
            *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);
        }
        else
        {
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO(1,0,maxAlignment);
        }
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        if (vt & VT_BYREF)
        {
            *pOffset = BYREF_I2_TYPE_FS_OFFSET ;
        if (pStructInfo)
            *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);
        }
        else
        {
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO(2,1,maxAlignment);
        }
        break;

    case VT_I4:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
    case VT_HRESULT:
        if (vt & VT_BYREF)
        {
            *pOffset = BYREF_I4_TYPE_FS_OFFSET ;
            if (pStructInfo)
            *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);
        }
        else
        {
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO(4,3,maxAlignment);
        }
        break;

    case VT_I8:
    case VT_UI8:
    case VT_CY:
        if (vt & VT_BYREF)
        {
            *pOffset = _offset;
            PushByte(FC_UP);
            PushByte(FC_SIMPLE_POINTER);
            PushByte(FC_HYPER);
            PushByte(FC_PAD);
            if (pStructInfo)
            *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);
        }
        else
        {
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO(8,7,maxAlignment);
        }
        break;

    case VT_R4:
        if (vt & VT_BYREF)
        {
            *pOffset = BYREF_R4_TYPE_FS_OFFSET ;
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);
        }
        else
        {
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO(4,3,maxAlignment);
        }
        break;

    case VT_R8:
    case VT_DATE:
        if (vt & VT_BYREF)
        {
            *pOffset = BYREF_R8_TYPE_FS_OFFSET ;
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);
        }
        else
        {
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO(8,7,maxAlignment);
        }
        break;


    case VT_CARRAY:
        hr = RegisterCArray(parainfo,pOffset,pStructInfo);
        break;

    case VT_MULTIINDIRECTIONS:
        // realvt is already VT_BYREF | something.
        // in multiple indirections case, we generate multiple
        // FC_UP FC_POINTER_DEREF. It'll be fixed up if it's
        // top level parameter.
        parainfo->vt = parainfo->realvt;
        ASSERT(parainfo->vt != VT_MULTIINDIRECTIONS);
        hr = RegisterType( parainfo,pOffset, pStructInfo );
        parainfo->vt = VT_MULTIINDIRECTIONS;

        if (SUCCEEDED(hr))
            {
            USHORT tmpOffset = *pOffset;
            USHORT prevOffset;
            ASSERT(parainfo->lLevelCount > 0);

            for (LONG i = 0; i < parainfo->lLevelCount; i++ )
                {
                prevOffset = _offset;
                PushByte(FC_UP);
                PushByte(FC_POINTER_DEREF);
                PushOffset(tmpOffset);
                tmpOffset = prevOffset;
                }
            *pOffset = prevOffset;
            }
        break;

     default:
        if(vt & VT_ARRAY)
        {
            hr = RegisterSafeArray(parainfo, pOffset);
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO(PTR_MEM_SIZE, PTR_MEM_ALIGN,maxAlignment);
        }
        else
        if (vt & VT_VECTOR)
        {
            hr = RegisterVector(parainfo,pOffset,pStructInfo);
        }
        else
        {
            hr = DISP_E_BADVARTYPE;
        }
        break;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::RegisterInterfacePointer
//
//  Synopsis:   Register an interface pointer in the type format string.
//
//  Arguments:  riid - Supplies the IID of the interface.
//              pOffset - Returns the type offset of the interface pointer.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::RegisterInterfacePointer(
    IN  PARAMINFO* parainfo,
    OUT USHORT    *pOffset)
{
    HRESULT hr = E_FAIL;
    USHORT  offset;
    VARTYPE vt = parainfo->vt;
    IID* piid = &(parainfo->iid);

    offset = _offset;
    hr = PushByte(FC_IP);
    if(FAILED(hr))
        return hr;

    hr = PushByte(FC_CONSTANT_IID);
    if(FAILED(hr))
        return hr;

    hr = PushIID(*piid);
    if(FAILED(hr))
        return hr;

    if(vt & VT_BYREF)
    {
        *pOffset = _offset;
        hr = PushByte(FC_RP);
        if(FAILED(hr))
            return hr;

        hr = PushByte(FC_POINTER_DEREF);
        if(FAILED(hr))
            return hr;

        hr = PushOffset(offset);
    }
    else
    {
        *pOffset = offset;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::RegisterCArray
//
//  Synopsis:   Registers a top-level type in the type format string.
//
//  Arguments:  pTypeDesc - Supplies the type descriptor.
//              pOffset - Returns the offset in the type format string.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::RegisterCArray(
    IN  PARAMINFO* parainfo,
    OUT USHORT   *pOffset,
    OUT DWORD *pStructInfo)
{
    HRESULT hr = S_OK;
    ARRAYDESC *padesc = parainfo->pArray;
    VARTYPE vt = padesc->tdescElem.vt;
    ULONG ulCount=1;
    USHORT pad = 0,ussize = 0,offset;
    BYTE fcElem,fcStruct;
    DWORD dwStructInfo;
    PARAMINFO iteminfo;
    USHORT maxAlignment = parainfo->cbAlignment;

    for ( int i = 0; i < padesc->cDims; i++)
        ulCount *= padesc->rgbounds[i].cElements ;

    switch (vt)
    {
    case VT_I1:
    case VT_UI1:
        fcElem = FC_SMALL;
        pad = 0;
        ussize = 1;
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        fcElem = FC_SHORT;
        pad = 1;
        ussize = 2;
        break;

    case VT_I4:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
    case VT_HRESULT:

        fcElem = FC_LONG;
        pad = 3;
        ussize = 4;
        break;

    case VT_I8:
    case VT_UI8:
    case VT_CY:

        fcElem = FC_HYPER;
        pad = 7;
        ussize = 8;
        break;

    case VT_R4:
        fcElem = FC_FLOAT;
        pad = 3;
        ussize = 4;
        break;

    case VT_R8:
    case VT_DATE:

        fcElem = FC_DOUBLE;
        pad = 7;
        ussize = 8;
        break;

    case VT_USERDEFINED:
    case VT_INTERFACE:
    case VT_PTR:
    case VT_CARRAY:
    // we need some more information other than vt type.
        {
        ITypeInfo* pTempInfo = parainfo->pTypeInfo;
        fcElem = FC_EMBEDDED_COMPLEX;
        hr = VarVtOfTypeDesc(parainfo->pTypeInfo,&(padesc->tdescElem),&iteminfo);
        if (SUCCEEDED(hr))
        {
            hr = RegisterType(&iteminfo,&offset,&dwStructInfo);
            pad = GETALIGNMENT(dwStructInfo);
            ussize = GETSIZE(dwStructInfo);
        }
        if (FAILED(hr))
            goto Error;
        }
        if (0 == offset)
        {
            fcElem = (BYTE)iteminfo.vt;
        }
        break;

    case VT_DISPATCH:
    case VT_UNKNOWN:
    case VT_STREAM:
    case VT_STORAGE:
    case VT_BSTR:
    case VT_VARIANT:
    case VT_LPSTR:
    case VT_LPWSTR:
        fcElem = FC_EMBEDDED_COMPLEX;
        iteminfo.vt = vt;
        hr = RegisterType(&iteminfo,&offset,&dwStructInfo);
        pad = GETALIGNMENT(dwStructInfo);
        ussize = GETSIZE(dwStructInfo);
        if (FAILED(hr))
            goto Error;
        break;
    default:
        hr = DISP_E_BADVARTYPE;
        goto Error;
        break;
    }

    *pOffset = _offset;
    if (fcElem != FC_EMBEDDED_COMPLEX)
    {
        ulCount *= ussize;
        if (ulCount <= 0xffff)
        {
            PushByte(FC_SMFARRAY);
            PushByte((BYTE)pad);
            PushShort((SHORT)ulCount);
            PushByte(fcElem);
        }
        else
        {
            PushByte(FC_LGFARRAY);
            PushByte((BYTE)pad);
            PushLong(ulCount);
            PushByte(fcElem);
        }
    }
    else
    {
        hr = GetByte(offset,&fcStruct);
        if (FAILED(hr))
            return hr;
        switch (fcStruct)
        {
        case FC_STRUCT:
            ulCount *= ussize;
            PushByte(FC_SMFARRAY);
            PushByte((BYTE)pad);
            PushShort((SHORT)ulCount);     // total size
            PushByte(FC_EMBEDDED_COMPLEX);
            PushByte(0);
            PushOffset(offset);
            PushByte(FC_PAD);
            break;

        // FC_EMBEDDED_COMPLEX-FC_UP within a complex array
        // should be the same as FC_BOGUSY_ARRAY-FC_UP directly
        case FC_UP:
        case FC_RP:
            {
            byte fctmp,bflag;
            USHORT tmpoffset;

            PushByte(FC_BOGUS_ARRAY);
            PushByte((BYTE)pad);
            PushShort((SHORT)ulCount); // this is the count
            PushLong(0xffffffff);   // no conformance description
#if defined(__RPC_WIN64__)
            PushShort(0);           // 6 bytes description in /robust
#endif
            PushLong(0xffffffff);   // no variance description
#if defined(__RPC_WIN64__)
            PushShort(0);
#endif
            GetByte(offset, &fctmp);
            PushByte(fctmp);
            GetByte(offset+1, &bflag);
            PushByte(bflag);
            GetOffset(offset+2, &tmpoffset);
            PushOffset(tmpoffset);
            PushByte(FC_PAD);
            ulCount *= PTR_MEM_SIZE;
            break;
            }

        case FC_BOGUS_STRUCT:
        case FC_USER_MARSHAL:
        case FC_IP:
            PushByte(FC_BOGUS_ARRAY);
            PushByte((BYTE)pad);
            PushShort((SHORT)ulCount); // this is the count
            PushLong(0xffffffff);   // no conformance description
#if defined(__RPC_WIN64__)
            PushShort(0);
#endif
            PushLong(0xffffffff);   // no variance description
#if defined(__RPC_WIN64__)
            PushShort(0);       // correlation description
#endif
            PushByte(FC_EMBEDDED_COMPLEX);
            PushByte(0);        // the first element
            PushOffset(offset);
            PushByte(FC_PAD);
            ulCount *= ussize;
            break;
        default:
            hr = DISP_E_BADVARTYPE;
        }

    }
    PushByte(FC_END);

    if (parainfo->vt & VT_BYREF)
    {
        USHORT uTemp = _offset;
        PushByte(FC_UP);
        PushByte(0);
        PushOffset(*pOffset);
        *pOffset = uTemp;
        if (pStructInfo)
            *pStructInfo = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);
    }
    else
    {
        if (ulCount > 0xffff)
        {
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO(0,pad,maxAlignment);
        }
        else
        {
            if (pStructInfo)
                *pStructInfo = MAKESTRUCTINFO((SHORT)ulCount,pad,maxAlignment);
        }
    }

Error:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::RegisterUDT
//
//  Synopsis:   Register a user defined type in the type format string.
//
//  Arguments:  pParamInfo  - Supplies the user defined type.
//              pOffset     - Returns the type offset of the struct.
//              pStructInfo - HIWORD is alignment, LOWORD is size.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::RegisterUDT(
    IN  PARAMINFO * pParamInfo,
    OUT USHORT    * pOffset,
    OUT DWORD     * pStructInfo)
{
    HRESULT     hr;
    TYPEATTR  * pTypeAttr;
    PARAMINFO   paramInfo;
    ITypeInfo * pTypeInfo = pParamInfo->pTypeInfo;

    *pOffset = 0;

    hr = pTypeInfo->lpVtbl->GetTypeAttr(pTypeInfo,
                                        &pTypeAttr);
    if(SUCCEEDED(hr))
    {
        pParamInfo->cbAlignment = pTypeAttr->cbAlignment -1;

        switch(pTypeAttr->typekind)
        {
        case TKIND_RECORD:
            hr = RegisterStruct(pParamInfo, pOffset, pStructInfo);
            break;

        case TKIND_ALIAS:
            hr = VarVtOfTypeDesc(pTypeInfo, &pTypeAttr->tdescAlias, &paramInfo);
            if(SUCCEEDED(hr))
            {
                hr = RegisterType(&paramInfo, pOffset, pStructInfo);
            }
            if (FAILED(hr))
                break;
            if (0 == *pOffset)
            // this is an aliases to a simple type. We should just pass the vt type back
            {
                pParamInfo->vt = paramInfo.vt;
            }
            break;

        case TKIND_DISPATCH:
        case TKIND_INTERFACE:
            hr = VarVtOfIface(pTypeInfo, pTypeAttr, &paramInfo);
            if(SUCCEEDED(hr))
            {
                hr = RegisterType(&paramInfo, pOffset, pStructInfo);
            }
            break;

        case TKIND_ENUM:
            pParamInfo->vt = VT_I4;
            *pOffset = 0;
            if (pStructInfo)
            *pStructInfo = MAKESTRUCTINFO(4,3,pParamInfo->cbAlignment);
            break;

        case TKIND_MODULE:
        case TKIND_COCLASS:
        case TKIND_UNION:
        default:
            hr = DISP_E_BADVARTYPE;
            break;
        }
    }
    pTypeInfo->lpVtbl->ReleaseTypeAttr(pTypeInfo,pTypeAttr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::RegisterStruct
//
//  Synopsis:   Register an user defined struct in the type format string.
//
//  Arguments:  riid - Supplies the ITypeInfo for that struct.
//              pOffset - Returns the type offset of the struct.
//              pStructInfo: HIWORD is alignment, LOWORD is size.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::RegisterStruct(
    IN PARAMINFO * parainfo,
    OUT USHORT   * pOffset,
    OUT DWORD    * pStructInfo)
{
    HRESULT hr = S_OK;
    TYPEATTR *pTypeAttr;
    VARDESC  **ppVarDesc;
    ITypeInfo* pInfo = parainfo->pTypeInfo;
    VARTYPE vt = parainfo->vt;
    FORMAT_CHARACTER fcStruct = FC_STRUCT;
    BYTE fcTemp;
    USHORT *poffsets;
    DWORD* pdwStructInfo;
    DWORD maxAlignment;
    int i = 0;

    hr = pInfo->lpVtbl->GetTypeAttr(pInfo,&pTypeAttr);

    if (FAILED(hr))
        return hr;

    *pOffset = 0;

    maxAlignment = parainfo->cbAlignment;
    poffsets = (USHORT *)alloca(pTypeAttr->cVars * sizeof(USHORT));
    memset(poffsets,0,pTypeAttr->cVars * sizeof(USHORT));
    pdwStructInfo = (DWORD *)alloca(pTypeAttr->cVars * sizeof(DWORD));
    memset(pdwStructInfo,0,pTypeAttr->cVars * sizeof(DWORD));
    ppVarDesc = (VARDESC **)alloca(pTypeAttr->cVars * sizeof(VARDESC *));
    memset(ppVarDesc,0,pTypeAttr->cVars * sizeof(VARDESC *));


    for(i = 0; SUCCEEDED(hr) && i < pTypeAttr->cVars; i++)
    {
        hr = pInfo->lpVtbl->GetVarDesc(pInfo,i, &ppVarDesc[i]);
        if(SUCCEEDED(hr))
        {
            VARKIND varkind = ppVarDesc[i]->varkind;
            PARAMINFO iteminfo;
            iteminfo.cbAlignment = pTypeAttr->cbAlignment - 1;

            switch (varkind)
            {
                case VAR_PERINSTANCE:
                    iteminfo.wIDLFlags = parainfo->wIDLFlags;
                    iteminfo.vt = ppVarDesc[i]->elemdescVar.tdesc.vt;

                    switch (iteminfo.vt  & ~VT_BYREF)
                    {
                    case VT_USERDEFINED:
                        ITypeInfo *pTempTI;
                        hr = pInfo->lpVtbl->GetRefTypeInfo(pInfo,ppVarDesc[i]->elemdescVar.tdesc.hreftype, &pTempTI);
                        if (FAILED(hr))
                            goto Error;
                        iteminfo.pTypeInfo = pTempTI;
                        hr = RegisterUDT(&iteminfo,&poffsets[i],&pdwStructInfo[i]);
                        if (FAILED(hr))
                            goto Error;

                        if (0 == poffsets[i])
                        // the UDT in fact is a simple type (alias or TKIND_ENUM). pass the type back
                        {
                            ppVarDesc[i]->elemdescVar.tdesc.vt = iteminfo.vt;
                        }
                        break;

                    // special case: the top level parameter case is treated differently
                    case VT_DECIMAL:
                        if (iteminfo.vt & VT_BYREF)
                        {
                            // pDecimal
                            poffsets[i] = BYREF_DECIMAL_TYPE_FS_OFFSET ;
                            pdwStructInfo[i] = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);
                        }                            

                        else
                        {
                            // decimal
                            poffsets[i] = DECIMAL_TYPE_FS_OFFSET;
                            pdwStructInfo[i] = MAKESTRUCTINFO( sizeof( DECIMAL ), 7, maxAlignment);
                        }
                        break;
                     case VT_LPSTR:
                        if (iteminfo.vt & VT_BYREF)
                        {
                            poffsets[i] = BYREF_LPSTR_TYPE_FS_OFFSET ;
                        }
                        else
                        {
                            poffsets[i] = EMBEDDED_LPSTR_TYPE_FS_OFFSET ;
                        }
                        pdwStructInfo[i] = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);
                        break;
                     case VT_LPWSTR:
                        if (iteminfo.vt & VT_BYREF)
                        {
                            poffsets[i] = BYREF_LPWSTR_TYPE_FS_OFFSET ;
                            pdwStructInfo[i] = MAKESTRUCTINFO( PTR_MEM_SIZE, PTR_MEM_ALIGN, maxAlignment);
                        }
                        else
                        {
                            poffsets[i] = EMBEDDED_LPWSTR_TYPE_FS_OFFSET ;
                            pdwStructInfo[i] = MAKESTRUCTINFO( PTR_MEM_SIZE , PTR_MEM_ALIGN ,maxAlignment);
                        }
                        break;

                    // doesn't need special case
                    case VT_FILETIME:
                    //  all the following are user marshalls.

                     case VT_DISPATCH:
                     case VT_UNKNOWN:
                     case VT_INTERFACE:
                     case VT_STREAM:
                     case VT_STORAGE:
                     case VT_BSTR:
                     case VT_VARIANT:
                        hr = RegisterType(&iteminfo,&(poffsets[i]),&(pdwStructInfo[i]));
                        if (FAILED(hr))
                            goto Error;
                        break;


                     case VT_PTR:
                     case VT_SAFEARRAY:     // 13129
                     {
                        PARAMINFO ptrInfo;
                        hr = VarVtOfTypeDesc(pInfo,&(ppVarDesc[i]->elemdescVar.tdesc),&ptrInfo);
                        if (SUCCEEDED(hr))
                            hr = RegisterType(&ptrInfo,&(poffsets[i]),&(pdwStructInfo[i]));
                        if (FAILED(hr))
                            goto Error;
                     }
                        break;


                     case VT_CARRAY:
                        iteminfo.pArray = ppVarDesc[i]->elemdescVar.tdesc.lpadesc;
                        iteminfo.pTypeInfo = parainfo->pTypeInfo;
                        iteminfo.pTypeInfo->lpVtbl->AddRef(iteminfo.pTypeInfo);
                        iteminfo.vt = ppVarDesc[i]->elemdescVar.tdesc.vt;
                        hr = RegisterCArray(&iteminfo,&poffsets[i],&pdwStructInfo[i]);
                        if (FAILED(hr))
                            goto Error;
                        break;

                    }

                    // this member is not a simple type.
                    if (poffsets[i])
                    {
                        hr = GetByte(poffsets[i],&fcTemp);
                        if (FAILED(hr))
                            return hr;
                        // we can only have one level of indirection
                        if (fcTemp == FC_UP || fcTemp == FC_RP || fcTemp == FC_OP )
                        {
                            USHORT uTempOff;
                            hr = GetByte(poffsets[i] + sizeof (BYTE), &fcTemp);
                            if (fcTemp == FC_SIMPLE_POINTER)
                                hr = GetByte(poffsets[i] + 2 * sizeof (BYTE), &fcTemp);
                            else
                            {
                                hr = GetOffset(poffsets[i] + 2 * sizeof (BYTE), &uTempOff);
                                if (FAILED(hr))
                                    return hr;
                                hr = GetByte(uTempOff,(BYTE *)&fcTemp);
                            }
                            if (FAILED(hr))
                                return hr;
                        }

                        switch (fcTemp)
                        {
                        case FC_STRUCT:
                            fcStruct = FC_BOGUS_STRUCT;
                            break;
                        case FC_PSTRUCT:
                            if (FC_STRUCT == fcStruct)
                                fcStruct = FC_PSTRUCT;
                            if (FC_CSTRUCT == fcStruct)
                                fcStruct = FC_CPSTRUCT;
                            break;
                        case FC_CSTRUCT:
                            if (FC_STRUCT == fcStruct)
                                fcStruct = FC_CSTRUCT;
                            if (FC_PSTRUCT == fcStruct)
                                fcStruct = FC_CPSTRUCT;
                            break;
                        case FC_CVSTRUCT:
                            hr = DISP_E_BADVARTYPE;
                            break;
                        case FC_BOGUS_STRUCT:
                            fcStruct = FC_BOGUS_STRUCT;
                            break;
                        case FC_USER_MARSHAL:
                            fcStruct = FC_BOGUS_STRUCT;
                            break;
                        case FC_SMFARRAY:
                        case FC_BOGUS_ARRAY:
                        case FC_IP:
                            fcStruct = FC_BOGUS_STRUCT;
                            break;
                        default:
                            fcStruct = FC_BOGUS_STRUCT;
                        break;
                        }
                    }
                break;

                default:    // all other types shouldn't happen .

                    hr = DISP_E_BADVARTYPE;
                break;
            }
        }
        else
            goto Error;
    }
    if (FAILED(hr))
        goto Error;

    hr = PushStruct(parainfo,fcStruct,ppVarDesc,poffsets,pdwStructInfo,pTypeAttr->cVars,pOffset,pStructInfo);

Error:
    for (int j = 0; j < pTypeAttr->cVars ; j++)
        if (ppVarDesc[j])
            pInfo->lpVtbl->ReleaseVarDesc(pInfo,ppVarDesc[j]);

    pInfo->lpVtbl->ReleaseTypeAttr(pInfo,pTypeAttr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::PushStruct
//
//  Synopsis:   This should be part of RegisterStruct, seperate them just because
//              the function is too long.
//
//  Arguments:  parainfo - parameter information.
//              fcStruct - type of struct.
//              ppVarDesc - variable description, if applicable.
//              poffsets  - offset of embedded complex members.
//              pdwStructInfo - size/pad of embedded complex members.
//              uNumElement     - number of members in the struct.
//              pOffset - Returns the type offset of the struct.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::PushStruct(
    IN PARAMINFO *parainfo,
    IN FORMAT_CHARACTER fcStruct,
    IN VARDESC **ppVarDesc,
    IN USHORT *poffsets,
    IN DWORD *pdwStructInfo,
    IN USHORT uNumElements,
    OUT USHORT *pOffset,
    OUT DWORD *pStructInfo)
{
    HRESULT hr = S_OK;
    USHORT  uStartoffset;
    USHORT cbSize = 0,uSize = 0,maxpad=0, pad = 0;
    USHORT structpad;
    int i;
    VARTYPE vt = parainfo->vt;
    boolean fHasPointer = FALSE;
    USHORT maxAlignment = parainfo->cbAlignment;

    _uStructSize = 0;

    // sizing pass, find out the size of the struct and check if we need to convert struct into bogus struct.

    hr = ParseStructMembers(parainfo,&fcStruct,ppVarDesc,poffsets,pdwStructInfo,uNumElements,pStructInfo);

    if (FAILED(hr))
        return hr;

    uStartoffset = _offset;   // the starting point of this struct.
    _uStructSize = 0;
    maxpad = GETALIGNMENT(*pStructInfo);
    uSize = GETSIZE(*pStructInfo);

    PushByte(fcStruct);
    PushByte((BYTE)maxpad);
    PushShort(uSize);

    switch (fcStruct)
    {
    case FC_STRUCT:
    break;

    case FC_CSTRUCT:
    case FC_PSTRUCT:
    case FC_CVSTRUCT:
        hr = E_NOTIMPL;
    break;

    case FC_BOGUS_STRUCT:
        PushShort(0);   // offset to array. E_NOTIMPLE;
        PushShort(0);   // offset to pointer layout.
    break;

    default:
    hr = DISP_E_BADVARTYPE;
    break;

    }
    if (FAILED(hr))
        return hr;

    for (i = 0; i < uNumElements; i++)
    {
        if (poffsets[i] > 0)
        {
            // The struct member is an embedded complex, the descsriptor of which
            // is already generated.

            USHORT uPrevSize;
            BYTE fcTemp;

            hr = GetByte(poffsets[i],&fcTemp);
            if (FAILED(hr))
                return hr;

            pad = GETALIGNMENT(pdwStructInfo[i]) > maxAlignment ? maxAlignment : GETALIGNMENT(pdwStructInfo[i]);
            uSize = GETSIZE(pdwStructInfo[i]);

            if (fcTemp == FC_UP || fcTemp == FC_RP || fcTemp == FC_OP )
            {
                if (_uStructSize & PTR_MEM_ALIGN )
                {
                    LENGTH_ALIGN( _uStructSize, PTR_MEM_ALIGN);

                    #if defined(__RPC_WIN64__)
                        PushByte(FC_ALIGNM8);
                    #else
                        PushByte(FC_ALIGNM4);
                    #endif
                }
                PushByte(FC_POINTER);
                fHasPointer = TRUE;
                _uStructSize += PTR_MEM_SIZE;
            }
            else
            {
                PushByte(FC_EMBEDDED_COMPLEX);
                // push the padding required the previous field and
                // following FC_EMBEDDED_COMPLEX
                uPrevSize = (SHORT )_uStructSize;
                LENGTH_ALIGN( _uStructSize, pad );
                PushByte( (BYTE)( _uStructSize - uPrevSize ) );
                PushOffset(poffsets[i]);
                _uStructSize += uSize;  // size of the struct
            }
        }
        else
        {
            hr = GenStructSimpleTypesFormatString(parainfo,ppVarDesc[i],&pad);
            if (FAILED(hr))
                return hr;
        }
        maxpad = maxpad > pad? maxpad:pad;
    }
    // cbSize is the real size, and header is always odd number. so we need to
    // add padding if real size is even.
    structpad = (USHORT)_uStructSize & maxpad;
    if (structpad )
    {
        structpad = maxpad - structpad;
        hr = PushByte((BYTE)FC_STRUCTPAD1 + structpad) ;
        if (FAILED(hr))
            return hr;
    }

    if (!((_offset - uStartoffset) & 1))
    {
        hr = PushByte(FC_PAD);
        if (FAILED(hr))
            return hr;
    }

    PushByte(FC_END);

    // one level of indirection if it's a pointer
    // prepare for future support of pointer struct member.
    if (fHasPointer)
    {
        USHORT tempOffset, tempAddr;
        BYTE fcTemp,fcType;
        tempOffset = uStartoffset + 2*sizeof(BYTE) + 2*sizeof(SHORT);

        SetShort(tempOffset,_offset-tempOffset);
        for (i = 0 ; i < uNumElements; i++)
        {
            if (poffsets[i] > 0)
            {
                hr = GetByte(poffsets[i],&fcTemp);
                hr = GetByte(poffsets[i] + 1, &fcType);
                if (FAILED(hr))
                    return hr;
                if (fcTemp == FC_UP || fcTemp == FC_RP || fcTemp == FC_OP )
                {
                   // should really be FC_OP here!!!
                   // MIDL generate FC_OP for [out] and [in,out] param.
                   // We can always generate FC_OP here: the engine behave differently
                   // only on unmarshaling in client side, and force no buffer reuse on
                   // server side, but even we set the flag on [in] only parameter,
                   // unmarshall routine is not called on the client side so it doesn't matter.
                   PushByte(FC_UP);
                   PushByte(fcType);
                   if (FC_SIMPLE_POINTER == fcType)
                   {
                       GetByte(poffsets[i] + 2 * sizeof(BYTE), &fcTemp);
                       PushByte(fcTemp);
                       PushByte(FC_PAD);
                   }
                   else
                   {
                       GetOffset(poffsets[i] + 2*sizeof(BYTE) , &tempAddr);
                       PushOffset(tempAddr);
                   }
                }
            }
        }
    }
    if (vt & VT_BYREF)
    {
        *pOffset = _offset;
        PushByte(FC_UP);
        PushByte(0);
        PushOffset(uStartoffset);
    }
    else
        *pOffset = uStartoffset;

    if (_offset & 2)    // align the starting point of next struct to 4 byte boundary.
        PushShort(0);

    return hr;

}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::ParseStructMembers
//
//  Synopsis:   basically sizing pass of the struct, check if we need to convert
//              struct into bogus struct when we can't memcpy the buffer.
//
//  Arguments:  parainfo - parameter information.
//              pfcStruct - type of struct.
//              ppVarDesc - variable description, if applicable.
//              poffsets  - offset of embedded complex members.
//              pdwStructInfo - size/pad of embedded complex members.
//              uNumElement     - number of members in the struct.
//              pStructInfo - return the struct info.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::ParseStructMembers(
    IN PARAMINFO *parainfo,
    IN OUT FORMAT_CHARACTER *pfcStruct,
    IN VARDESC **ppVarDesc,
    IN USHORT *poffsets,
    IN DWORD *pdwStructInfo,
    IN USHORT uNumElements,
    OUT DWORD *pStructInfo)
{
    USHORT uStartoffset = 0;
    BOOL fChangeToBogus = FALSE;
    int i;
    USHORT cbSize = 0,uSize = 0,maxpad=0, pad = 0;
    USHORT structpad;
    HRESULT hr;
    USHORT maxAlignment = parainfo->cbAlignment;

    for (i = 0; i < uNumElements; i++)
    {
        // internal struct padding.
        if (poffsets[i] > 0)
        {
            BYTE fcTemp;

            hr = GetByte(poffsets[i],&fcTemp);
            if (FAILED(hr))
                return hr;

            pad = (GETALIGNMENT(pdwStructInfo[i]) > maxAlignment) ? maxAlignment
                                                                  : GETALIGNMENT(pdwStructInfo[i]);

            // need to change to bogus struct if the struct is not naturally aligned.
            if (pad != GETALIGNMENT(pdwStructInfo[i]))
                fChangeToBogus = TRUE;

            uSize = GETSIZE(pdwStructInfo[i]);

            if (fcTemp == FC_UP || fcTemp == FC_RP)
            {
                LENGTH_ALIGN( _uStructSize, PTR_MEM_ALIGN);
                _uStructSize += PTR_MEM_SIZE;
            }
            else
            {
                LENGTH_ALIGN( _uStructSize, pad );
                _uStructSize += uSize;  // size of the struct
            }
        }
        else
        {
            // calculate the size of simple types in the struct.
            // This call adds to _uStuctSize
            hr = GetSizeStructSimpleTypesFormatString(ppVarDesc[i]->elemdescVar.tdesc.vt,
                                                      parainfo->cbAlignment,&pad,&fChangeToBogus);
            if (FAILED(hr))
                return hr;
        }
        maxpad = maxpad > pad? maxpad:pad;
    }

    structpad = (USHORT)_uStructSize & maxpad;
    if (structpad )
    {
        // it's a bogus struct if we have trailing padding.
        structpad = maxpad - structpad;
        fChangeToBogus = TRUE;
    }

    if (fChangeToBogus && (FC_BOGUS_STRUCT != *pfcStruct))
        *pfcStruct = FC_BOGUS_STRUCT;

    _uStructSize = _uStructSize + maxpad;
    _uStructSize &= ~maxpad;

    // we are returning the real size of struct up. In the type format generating code,
    // embedded pointer size is always PTR_MEM_SIZE and the sizing info returned from here
    // is ignored.
    if (pStructInfo)
        *pStructInfo = MAKESTRUCTINFO((USHORT)_uStructSize,maxpad,maxAlignment);

    if (_uStructSize > _UI16_MAX)
    {
        hr = DISP_E_BADVARTYPE;
    }

    return hr;

}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::GetSizeStructSimpleTypesFormatString
//
//  Synopsis:   calculate the size requirement of simple types in the struct.
//              and set fChangeToBogus if the alignment is not natural.
//
//  Arguments:  vt - what's the simple type.
//              uPackingLevel - packing level of the struct..
//              pAlign - variable description, if applicable.
//              fChangeToBogus  - if we need to change to bogus_struct
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::GetSizeStructSimpleTypesFormatString(VARTYPE vt,USHORT uPackingLevel,USHORT* pAlign,BOOL *fChangeToBogus)
{
    HRESULT hr = S_OK;
    switch (vt & ~VT_BYREF)
    {
    case VT_I1:
    case VT_UI1:
        *pAlign = 0;
        _uStructSize += 1;
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        *pAlign = AlignSimpleTypeInStruct(1,uPackingLevel,fChangeToBogus);
        _uStructSize += 2;
        break;

    case VT_I4:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
    case VT_HRESULT:
        *pAlign = AlignSimpleTypeInStruct(3,uPackingLevel,fChangeToBogus);
        _uStructSize += 4;
        break;

    case VT_I8:
    case VT_UI8:
    case VT_CY:
        *pAlign = AlignSimpleTypeInStruct(7,uPackingLevel,fChangeToBogus);
        _uStructSize += 8;
        break;

    case VT_R4:
        *pAlign = AlignSimpleTypeInStruct(3,uPackingLevel,fChangeToBogus);
        _uStructSize += 4;
        break;

    case VT_R8:
    case VT_DATE:
        *pAlign = AlignSimpleTypeInStruct(7,uPackingLevel,fChangeToBogus);
        _uStructSize += 8;
        break;

    case VT_USERDEFINED:
        // invalid case here!!! structs should have been handled.

    default:
            hr = DISP_E_BADVARTYPE;
        break;
    }
    return hr;
}

USHORT CTypeGen::AlignSimpleTypeInStruct(DWORD dwReq,DWORD dwMax, BOOL *fChangeToBogus)
{
    USHORT pad = (USHORT)(dwReq > dwMax ? dwMax : dwReq);
    if (pad != dwReq)
        *fChangeToBogus = TRUE;

//    if (_uStructSize & pad)
    {
        _uStructSize += pad;
        _uStructSize &= ~pad;
    }
    return pad;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::RegisterSafeArray
//
//  Synopsis:   Register a safe array in the type format string.
//
//  Arguments:  riid - Supplies the IID of the interface.
//              pOffset - Returns the type offset of the safe array.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::RegisterSafeArray(
          IN PARAMINFO* pParainfo,
          OUT USHORT    *pOffset)
{
    HRESULT hr = S_OK;
    USHORT  offset;
    VARTYPE vt = pParainfo->vt;
    IID *piid = &(pParainfo->iid);

    switch(vt & ~(VT_ARRAY | VT_BYREF))
    {
    case VT_I2:
    case VT_I4:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_BSTR:
    case VT_DISPATCH:
    case VT_ERROR:
    case VT_BOOL:
    case VT_VARIANT:
    case VT_UNKNOWN:
    case VT_DECIMAL:
    case VT_I1:
    case VT_UI1:
    case VT_UI2:
    case VT_UI4:
    case VT_I8:
    case VT_UI8:
    case VT_INT:
    case VT_UINT:
    case VT_USERDEFINED:    // 13129
    case VT_CARRAY:
        //This is actually an LPSAFEARRAY pSafeArray.
        if(vt & VT_BYREF)
        {
            *pOffset = BYREF_SAFEARRAY_TYPE_FS_OFFSET ;
        }
        else
        {
            *pOffset = SAFEARRAY_TYPE_FS_OFFSET ;
        }
        break;

    case VT_INTERFACE:
        offset = _offset;
        hr = PushByte(FC_USER_MARSHAL);
        if(FAILED(hr))
            return hr;

        hr = PushByte(USER_MARSHAL_UNIQUE | USER_MARSHAL_IID | 3);
        if(FAILED(hr))
            return hr;

        hr = PushShort(2);
        if(FAILED(hr))
            return hr;

        hr = PushShort(4);
        if(FAILED(hr))
            return hr;

        hr = PushShort(0);
        if(FAILED(hr))
            return hr;

        if(vt & VT_BYREF)
        {
            hr = PushOffset(904); //LPSAFEARRAY * type offset
            if(FAILED(hr))
                return hr;
        }
        else
        {
            hr = PushOffset(768); //LPSAFEARRAY type offset
            if(FAILED(hr))
                return hr;
        }

        hr = PushIID(*piid);
        if(FAILED(hr))
            return hr;

        *pOffset = offset;
        break;

    default:
        hr = DISP_E_BADVARTYPE;
        break;
    }


    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::RegisterVector
//
//  Synopsis:   Register a safe array in the type format string.
//
//  Arguments:  riid - Supplies the IID of the interface.
//              pOffset - Returns the type offset of the safe array.
//
//----------------------------------------------------------------------------
// Note: VECTOR of interface, IDISPATCH, DECIMAL etc. are not supported.
HRESULT CTypeGen::RegisterVector(
    IN PARAMINFO* pParainfo,
    OUT USHORT    *pOffset,
    OUT DWORD *pdwStructInfo)
{
    HRESULT hr = S_OK;
    VARTYPE vt = pParainfo->vt;
    USHORT maxAlignment = pParainfo->cbAlignment;
    *pOffset = 0;

    // we are in marshalling, and marshaller doesn't care about signed or not
    switch(vt & ~VT_VECTOR)
    {
    case VT_I1:
    case VT_UI1:
        if (vt & VT_BYREF)
        {
            // pcab
            *pOffset = BYREF_I1_VECTOR_TYPE_FS_OFFSET ;
        }
        else
        {
            // cab
            *pOffset = I1_VECTOR_TYPE_FS_OFFSET ;
        }
        break;
    case VT_I2:
    case VT_UI2:
        if (vt & VT_BYREF)
        {
            // pcai
            *pOffset = BYREF_I2_VECTOR_TYPE_FS_OFFSET ;
        }
        else
        {
            // cai
            *pOffset = I2_VECTOR_TYPE_FS_OFFSET ;
        }
        break;
    case VT_I4:
    case VT_INT:
    case VT_UI4:
    case VT_UINT:
        if (vt & VT_BYREF)
        {
            // pcal
            *pOffset = BYREF_I4_VECTOR_TYPE_FS_OFFSET ;
        }
        else
        {
            // cal
            *pOffset = I4_VECTOR_TYPE_FS_OFFSET ;
        }
        break;
    case VT_R4:
        if (vt & VT_BYREF)
        {
            // pcaflt
            *pOffset = BYREF_R4_VECTOR_TYPE_FS_OFFSET ;
        }
        else
        {
            // caflt
            *pOffset = R4_VECTOR_TYPE_FS_OFFSET ;
        }
        break;
    case VT_R8:
        if (vt & VT_BYREF)
        {
            // pcadbl
            *pOffset = BYREF_R8_VECTOR_TYPE_FS_OFFSET ;
        }
        else
        {
            // cadbl
            *pOffset = R8_VECTOR_TYPE_FS_OFFSET ;
        }
        break;
    case VT_CY:
        if (vt & VT_BYREF)
        {
            // pcacy
            *pOffset = BYREF_CY_VECTOR_TYPE_FS_OFFSET ;
        }
        else
        {
            // cacy
            *pOffset = CY_VECTOR_TYPE_FS_OFFSET ;
        }
        break;
    case VT_DATE:
        if (vt & VT_BYREF)
        {
            // pcadate
            *pOffset = BYREF_DATE_VECTOR_TYPE_FS_OFFSET ;
        }
        else
        {
            // cadate
            *pOffset = DATE_VECTOR_TYPE_FS_OFFSET ;
        }
        break;
    case VT_BSTR:
        if (vt & VT_BYREF)
        {
            // pcabstr
            *pOffset = BYREF_BSTR_VECTOR_TYPE_FS_OFFSET ;
        }
        else
        {
            // cabstr
            *pOffset = BSTR_VECTOR_TYPE_FS_OFFSET ;
        }
        break;
    case VT_BSTR_BLOB:
        if(vt & VT_BYREF)
        {
            // pcabstrblob
            *pOffset = BYREF_BSTRBLOB_VECTOR_TYPE_FS_OFFSET ;
        }
        else
        {
            // cabstrblob
            *pOffset = BSTRBLOB_VECTOR_TYPE_FS_OFFSET ;
        }
        break;
    case VT_BOOL:
        if (vt & VT_BYREF)
        {
            // pcabool
            *pOffset = BYREF_I2_VECTOR_TYPE_FS_OFFSET;
        }
        else
        {
            //cabool
            *pOffset = I2_VECTOR_TYPE_FS_OFFSET;
        }
        break;
    case VT_ERROR:
        if (vt & VT_BYREF)
        {
            // pcascode
            *pOffset = BYREF_ERROR_VECTOR_TYPE_FS_OFFSET ;
        }
        else
        {
            // cascode
            *pOffset = ERROR_VECTOR_TYPE_FS_OFFSET ;
        }
        break;
    case VT_I8:
    case VT_UI8:
        if (vt & VT_BYREF)
        {
            // pcah
            *pOffset = BYREF_I8_VECTOR_TYPE_FS_OFFSET ;
        }
        else
        {
            // cah
            *pOffset = I8_VECTOR_TYPE_FS_OFFSET ;
        }
        break;

    case VT_LPSTR:
        if(vt & VT_BYREF)
        {
            // pcalpstr
            *pOffset = BYREF_LPSTR_VECTOR_TYPE_FS_OFFSET ;
        }
        else
        {
            // calpstr
            *pOffset = LPSTR_VECTOR_TYPE_FS_OFFSET ;
        }
        break;
    case VT_LPWSTR:
        if(vt & VT_BYREF)
        {
            // pcalpwstr
            *pOffset = BYREF_LPWSTR_VECTOR_TYPE_FS_OFFSET ;
        }
        else
        {
            // calpwstr
            *pOffset = LPWSTR_VECTOR_TYPE_FS_OFFSET ;
        }
        break;
    case VT_FILETIME:
        if(vt & VT_BYREF)
        {
            // pcafiletime
            *pOffset = BYREF_FILETIME_VECTOR_TYPE_FS_OFFSET ;
        }
        else
        {
            // cafiletime
            *pOffset = FILETIME_VECTOR_TYPE_FS_OFFSET ;
        }
        break;
        /*
    case VT_DISPATCH:
        if (vt & VT_BYREF)
        {
            *pOffset = ;
        }
        else
        {
            *pOffset = ;
        }
        break;
    case VT_VARIANT:
        if (vt & VT_BYREF)
        {
            *pOffset = ;
        }
        else
        {
            *pOffset = ;
        }
        break;
    case VT_UNKNOWN:
        if (vt & VT_BYREF)
        {
            *pOffset = ;
        }
        else
        {
            *pOffset = ;
        }
        break;
    case VT_DECIMAL:
        if (vt & VT_BYREF)
        {
            *pOffset = ;
        }
        else
        {
            *pOffset = ;
        }
        break;
    case VT_INTERFACE:
        offset = _offset;
        hr = PushByte(FC_USER_MARSHAL);
        if(FAILED(hr))
            return hr;

        hr = PushByte(USER_MARSHAL_UNIQUE | USER_MARSHAL_IID | 3);
        if(FAILED(hr))
            return hr;

        hr = PushShort(2);
        if(FAILED(hr))
            return hr;

        hr = PushShort(4);
        if(FAILED(hr))
            return hr;

        hr = PushShort(0);
        if(FAILED(hr))
            return hr;

        if(vt & VT_BYREF)
        {
//            hr = PushOffset(906); //LPSAFEARRAY * type offset
            hr = PushOffset(904); //LPSAFEARRAY * type offset
            if(FAILED(hr))
                return hr;
        }
        else
        {
//            hr = PushOffset(772); //LPSAFEARRAY type offset
            hr = PushOffset(768); //LPSAFEARRAY type offset
            if(FAILED(hr))
                return hr;
        }

        hr = PushIID(*piid);
        if(FAILED(hr))
            return hr;

        *pOffset = offset;
        break;
*/
    default:
        hr = DISP_E_BADVARTYPE;
        break;
    }


    if (pdwStructInfo)
        *pdwStructInfo = MAKESTRUCTINFO(8,3,maxAlignment);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::GenStructFormatString
//
//  Synopsis:   generate type format string for a simple type member of a struct.
//
//  Arguments:  parainfo - parameter information
//                              pVarDesc - variable description.
//              pOffset - Returns the type offset of the safe array.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::GenStructSimpleTypesFormatString(
        IN PARAMINFO *parainfo,
        IN VARDESC *pVarDesc,
        OUT USHORT *pad)
{
    VARTYPE vt = pVarDesc->elemdescVar.tdesc.vt;
    USHORT maxAlignment = parainfo->cbAlignment;
    HRESULT hr = S_OK;

    switch (vt & ~VT_BYREF)
    {
    case VT_I1:
    case VT_UI1:
        PushByte(FC_SMALL);
        *pad = 0;
        _uStructSize += 1;
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        *pad = Alignment(1,maxAlignment);

        PushByte(FC_SHORT);
        _uStructSize += 2;
        break;

    case VT_I4:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
    case VT_HRESULT:
        *pad = Alignment(3,maxAlignment);

        PushByte(FC_LONG);
        _uStructSize += 4;
        break;

    case VT_I8:
    case VT_UI8:
    case VT_CY:
        *pad = Alignment(7,maxAlignment);

        PushByte(FC_HYPER);
        _uStructSize += 8;
        break;

    case VT_R4:
        *pad = Alignment(3,maxAlignment);

        PushByte(FC_FLOAT);
        _uStructSize += 4;
        break;

    case VT_R8:
    case VT_DATE:
        *pad = Alignment(7,maxAlignment);
        PushByte(FC_DOUBLE);
        _uStructSize += 8;
        break;

    case VT_USERDEFINED:
        // invalid case here!!! structs should have been handled.

    default:
            hr = DISP_E_BADVARTYPE;
        break;
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::AdjustTopLevelRef
//
//  Synopsis:   Adjust the top level multiple level pointer to
//              FC_RP FC_ALLOCED_ON_STACK|FC_POINTER_DEREF
//
//  Arguments:  dwReq - basic alignment requirement of the member.
//              dwMax - the alignment requirement of the struct.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::AdjustTopLevelRef(USHORT offset)
{
    HRESULT hr;
    hr = SetByte(offset,FC_RP);
    if (SUCCEEDED(hr))
        hr = SetByte(offset+1, FC_ALLOCED_ON_STACK|FC_POINTER_DEREF);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::Alignment
//
//  Synopsis:   get the alignment info of a type and push FC_ALIGN when required.
//
//  Arguments:  dwReq - basic alignment requirement of the member.
//              dwMax - the alignment requirement of the struct.
//
//----------------------------------------------------------------------------
USHORT CTypeGen::Alignment(DWORD dwReq,DWORD dwMax)
{
    USHORT pad = (USHORT)(dwReq > dwMax ? dwMax : dwReq);

    if (_uStructSize & pad)
    {
        _uStructSize += pad;
        _uStructSize &= ~pad;
        switch (pad)
        {
        case 1:
            PushByte(FC_ALIGNM2);
            break;
        case 3:
            PushByte(FC_ALIGNM4);
            break;
        case 7:
            PushByte(FC_ALIGNM8);
            break;
        }
    }
    return pad;
}

HRESULT CTypeGen::GrowTypeFormat(
    USHORT cb)
{
    HRESULT hr = S_OK;

    //Check if we need to grow the type format string.
    if((_offset + cb) >= _cbTypeFormat)
    {
        void  *pTemp;
        USHORT cbTemp;

        cbTemp = _cbTypeFormat * 2;
        pTemp = I_RpcAllocate(cbTemp);
        if(pTemp != NULL)
        {
            //copy the memory
            memcpy(pTemp, _pTypeFormat, _cbTypeFormat);

            //free the old memory
            if(_pTypeFormat != __MIDL_TypeFormatString.Format)
            {
                I_RpcFree((void *) _pTypeFormat);
            }

            _pTypeFormat = (PFORMAT_STRING) pTemp;
            _cbTypeFormat = cbTemp;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT CTypeGen::PushByte(
    IN  byte b)
{
    HRESULT hr;

    hr = GrowTypeFormat(sizeof(b));
    if(SUCCEEDED(hr))
    {
        *((BYTE *) &_pTypeFormat[_offset]) = b;
        _offset += sizeof(b);
    }

    return hr;
}

HRESULT CTypeGen::PushShort(
    IN  USHORT s)
{
    HRESULT hr;

    hr = GrowTypeFormat(sizeof(s));
    if(SUCCEEDED(hr))
    {
        *((UNALIGNED short *) &_pTypeFormat[_offset]) = s;
        _offset += sizeof(s);
    }

    return hr;
}

HRESULT CTypeGen::PushLong(
    IN  ULONG s)
{
    HRESULT hr;

    hr = GrowTypeFormat(sizeof(s));
    if(SUCCEEDED(hr))
    {
        *((UNALIGNED long *) &_pTypeFormat[_offset]) = s;
        _offset += sizeof(s);
    }

    return hr;
}

HRESULT CTypeGen::PushOffset(
    IN  USHORT offset)
{
    HRESULT hr;

    hr = PushShort(offset - _offset);
    return hr;
}


HRESULT CTypeGen::PushIID(
    IN  IID iid)
{
    HRESULT hr;

    hr = GrowTypeFormat(sizeof(IID));
    if(SUCCEEDED(hr))
    {
        memcpy((void *)&_pTypeFormat[_offset], &iid, sizeof(IID));
        _offset += sizeof(IID);
    }

    return hr;
}

HRESULT CTypeGen::SetShort(
    IN  USHORT offset,
    IN  USHORT data)
{
    if (offset >=  _offset)
        return E_INVALIDARG;

    *((UNALIGNED short *) &_pTypeFormat[offset]) = data;
    return S_OK;
}

HRESULT CTypeGen::SetByte(
    IN  USHORT offset,
    IN  BYTE data)
{
    if (offset >=  _offset)
        return E_INVALIDARG;

    *((BYTE *) &_pTypeFormat[offset]) = data;
    return S_OK;
}

HRESULT CTypeGen::GetShort(
    IN  USHORT offset,
    OUT  USHORT* data)
{
    if (offset >=  _offset)
        return E_INVALIDARG;

    *data = *((UNALIGNED short*)&_pTypeFormat[offset]);
    return S_OK;
}

HRESULT CTypeGen::GetOffset(
    IN USHORT addr,
    OUT USHORT* poffset)
{
    USHORT delta;
    HRESULT hr;

    hr = GetShort(addr,&delta);
    if (FAILED(hr))
        return hr;
    *poffset = addr + (SHORT) delta;
//  hr = GetShort(addr + (SHORT)delta,poffset);
    return hr;
}


HRESULT CTypeGen::GetByte(
    IN  USHORT offset,
    OUT  BYTE* data)
{
    if (offset >=  _offset)
        return E_INVALIDARG;

    *data = *((BYTE *) &_pTypeFormat[offset]);
    return S_OK;
}


ULONG __RPC_USER
BSTR_UserSize(ULONG * pFlags, ULONG Offset, BSTR * pBstr)

{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (UserMarshalRoutines[0].pfnBufferSize)(pFlags, Offset, pBstr);
}

BYTE * __RPC_USER
BSTR_UserMarshal (ULONG * pFlags, BYTE * pBuffer, BSTR * pBstr)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (UserMarshalRoutines[0].pfnMarshall)(pFlags, pBuffer, pBstr);
}

BYTE * __RPC_USER
BSTR_UserUnmarshal(ULONG * pFlags, BYTE * pBuffer, BSTR * pBstr)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (UserMarshalRoutines[0].pfnUnmarshall)(pFlags, pBuffer, pBstr);
}

void __RPC_USER
BSTR_UserFree(ULONG * pFlags, BSTR * pBstr)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    (UserMarshalRoutines[0].pfnFree)(pFlags, pBstr);
}

ULONG __RPC_USER
VARIANT_UserSize(ULONG * pFlags, ULONG Offset, VARIANT * pVariant)

{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (UserMarshalRoutines[1].pfnBufferSize)(pFlags, Offset, pVariant);
}

BYTE * __RPC_USER
VARIANT_UserMarshal (ULONG * pFlags, BYTE * pBuffer, VARIANT * pVariant)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (UserMarshalRoutines[1].pfnMarshall)(pFlags, pBuffer, pVariant);
}

BYTE * __RPC_USER
VARIANT_UserUnmarshal(ULONG * pFlags, BYTE * pBuffer, VARIANT * pVariant)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (UserMarshalRoutines[1].pfnUnmarshall)(pFlags, pBuffer, pVariant);
}

void __RPC_USER
VARIANT_UserFree(ULONG * pFlags, VARIANT * pVariant)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    (UserMarshalRoutines[1].pfnFree)(pFlags, pVariant);
}

ULONG __RPC_USER
LPSAFEARRAY_UserSize(ULONG * pFlags, ULONG Offset, LPSAFEARRAY * ppSafeArray)

{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (pfnLPSAFEARRAY_UserSize)(pFlags, Offset, ppSafeArray);
}

BYTE * __RPC_USER
LPSAFEARRAY_UserMarshal (ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (pfnLPSAFEARRAY_UserMarshal)(pFlags, pBuffer, ppSafeArray);
}

BYTE * __RPC_USER
LPSAFEARRAY_UserUnmarshal(ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (pfnLPSAFEARRAY_UserUnmarshal)(pFlags, pBuffer, ppSafeArray);
}

void __RPC_USER
LPSAFEARRAY_UserFree(ULONG * pFlags, LPSAFEARRAY * ppSafeArray)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    (UserMarshalRoutines[2].pfnFree)(pFlags, ppSafeArray);
}


ULONG __RPC_USER
LPSAFEARRAY_Size(ULONG * pFlags, ULONG Offset, LPSAFEARRAY * ppSafeArray, const IID *piid)
{
    HINSTANCE h;
    void * pfnTemp;

    //Load oleaut32.dll
    if(0 == hOleAut32)
    {
        h = LoadLibraryA("OLEAUT32");

        if(h != 0)
        {
            hOleAut32 = h;
        }
        else
        {
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    pfnTemp = GetProcAddress(hOleAut32, "LPSAFEARRAY_Size");
    if(pfnTemp != 0)
    {
        pfnLPSAFEARRAY_Size = (PFNSAFEARRAY_SIZE) pfnTemp;
    }
    else
    {
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }

    return (pfnLPSAFEARRAY_Size)(pFlags, Offset, ppSafeArray, piid);
}

BYTE * __RPC_USER
LPSAFEARRAY_Marshal (ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray, const IID *piid)
{
    HINSTANCE h;
    void * pfnTemp;

    //Load oleaut32.dll
    if(0 == hOleAut32)
    {
        h = LoadLibraryA("OLEAUT32");

        if(h != 0)
        {
            hOleAut32 = h;
        }
        else
        {
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    pfnTemp = GetProcAddress(hOleAut32, "LPSAFEARRAY_Marshal");
    if(pfnTemp != 0)
    {
        pfnLPSAFEARRAY_Marshal = (PFNSAFEARRAY_MARSHAL) pfnTemp;
    }
    else
    {
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }

    return (pfnLPSAFEARRAY_Marshal)(pFlags, pBuffer, ppSafeArray, piid);
}

BYTE * __RPC_USER
LPSAFEARRAY_Unmarshal(ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray, const IID *piid)
{
    HINSTANCE h;
    void * pfnTemp;

    //Load oleaut32.dll
    if(0 == hOleAut32)
    {
        h = LoadLibraryA("OLEAUT32");

        if(h != 0)
        {
            hOleAut32 = h;
        }
        else
        {
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    pfnTemp = GetProcAddress(hOleAut32, "LPSAFEARRAY_Unmarshal");
    if(pfnTemp != 0)
    {
        pfnLPSAFEARRAY_Unmarshal = (PFNSAFEARRAY_UNMARSHAL) pfnTemp;
    }
    else
    {
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }
    return (pfnLPSAFEARRAY_Unmarshal)(pFlags, pBuffer, ppSafeArray, piid);
}

PFNSAFEARRAY_SIZE      pfnLPSAFEARRAY_Size      = LPSAFEARRAY_Size;
PFNSAFEARRAY_MARSHAL   pfnLPSAFEARRAY_Marshal   = LPSAFEARRAY_Marshal;
PFNSAFEARRAY_UNMARSHAL pfnLPSAFEARRAY_Unmarshal = LPSAFEARRAY_Unmarshal;

ULONG __RPC_USER
SafeArraySize(ULONG * pFlags, ULONG Offset, LPSAFEARRAY * ppSafeArray)

{
    USER_MARSHAL_CB *pUserMarshal = (USER_MARSHAL_CB *) pFlags;

    if(pUserMarshal->pReserve != 0)
    {
        IID iid;
        memcpy(&iid, pUserMarshal->pReserve, sizeof(IID));
        return (pfnLPSAFEARRAY_Size)(pFlags, Offset, ppSafeArray, &iid);
    }
    else
    {
        return (pfnLPSAFEARRAY_UserSize)(pFlags, Offset, ppSafeArray);
    }
}

BYTE * __RPC_USER
SafeArrayMarshal (ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray)
{
    USER_MARSHAL_CB *pUserMarshal = (USER_MARSHAL_CB *) pFlags;

    if(pUserMarshal->pReserve != 0)
    {
        IID iid;
        memcpy(&iid, pUserMarshal->pReserve, sizeof(IID));
        return (pfnLPSAFEARRAY_Marshal)(pFlags, pBuffer, ppSafeArray, &iid);
    }
    else
    {
        return (pfnLPSAFEARRAY_UserMarshal)(pFlags, pBuffer, ppSafeArray);
    }
}

BYTE * __RPC_USER
SafeArrayUnmarshal(ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray)
{
    USER_MARSHAL_CB *pUserMarshal = (USER_MARSHAL_CB *) pFlags;

    if(pUserMarshal->pReserve != 0)
    {
        IID iid;
        memcpy(&iid, pUserMarshal->pReserve, sizeof(IID));
        return (pfnLPSAFEARRAY_Unmarshal)(pFlags, pBuffer, ppSafeArray, &iid);
    }
    else
    {
        return (pfnLPSAFEARRAY_UserUnmarshal)(pFlags, pBuffer, ppSafeArray);
    }
}


USER_MARSHAL_SIZING_ROUTINE
pfnLPSAFEARRAY_UserSize = (USER_MARSHAL_SIZING_ROUTINE) LPSAFEARRAY_UserSize;

USER_MARSHAL_MARSHALLING_ROUTINE
pfnLPSAFEARRAY_UserMarshal = (USER_MARSHAL_MARSHALLING_ROUTINE) LPSAFEARRAY_UserMarshal;

USER_MARSHAL_UNMARSHALLING_ROUTINE
pfnLPSAFEARRAY_UserUnmarshal = (USER_MARSHAL_UNMARSHALLING_ROUTINE) LPSAFEARRAY_UserUnmarshal;

USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[3] =
{
    {
        (USER_MARSHAL_SIZING_ROUTINE) BSTR_UserSize,
        (USER_MARSHAL_MARSHALLING_ROUTINE) BSTR_UserMarshal,
        (USER_MARSHAL_UNMARSHALLING_ROUTINE) BSTR_UserUnmarshal,
        (USER_MARSHAL_FREEING_ROUTINE) BSTR_UserFree
    },
    {
        (USER_MARSHAL_SIZING_ROUTINE) VARIANT_UserSize,
        (USER_MARSHAL_MARSHALLING_ROUTINE) VARIANT_UserMarshal,
        (USER_MARSHAL_UNMARSHALLING_ROUTINE) VARIANT_UserUnmarshal,
        (USER_MARSHAL_FREEING_ROUTINE) VARIANT_UserFree
    },
    {
        (USER_MARSHAL_SIZING_ROUTINE) SafeArraySize,
        (USER_MARSHAL_MARSHALLING_ROUTINE) SafeArrayMarshal,
        (USER_MARSHAL_UNMARSHALLING_ROUTINE) SafeArrayUnmarshal,
        (USER_MARSHAL_FREEING_ROUTINE) LPSAFEARRAY_UserFree
    }
};

HRESULT NdrLoadOleAutomationRoutines()
{

    void * pfnTemp;

    //Load oleaut32.dll
    if(hOleAut32 == 0)
    {
        hOleAut32 = LoadLibraryA("OLEAUT32");

        if(0 == hOleAut32)
            return HRESULT_FROM_WIN32(GetLastError());
    }

    pfnTemp = GetProcAddress(hOleAut32, "BSTR_UserSize");
    if(pfnTemp != 0)
        UserMarshalRoutines[0].pfnBufferSize = (USER_MARSHAL_SIZING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());

    pfnTemp = GetProcAddress(hOleAut32, "BSTR_UserMarshal");
    if(pfnTemp != 0)
        UserMarshalRoutines[0].pfnMarshall = (USER_MARSHAL_MARSHALLING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());


    pfnTemp = GetProcAddress(hOleAut32, "BSTR_UserUnmarshal");
    if(pfnTemp != 0)
        UserMarshalRoutines[0].pfnUnmarshall = (USER_MARSHAL_UNMARSHALLING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());


    pfnTemp = GetProcAddress(hOleAut32, "BSTR_UserFree");
    if(pfnTemp != 0)
        UserMarshalRoutines[0].pfnFree = (USER_MARSHAL_FREEING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());

    pfnTemp = GetProcAddress(hOleAut32, "VARIANT_UserSize");
    if(pfnTemp != 0)
        UserMarshalRoutines[1].pfnBufferSize = (USER_MARSHAL_SIZING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());

    pfnTemp = GetProcAddress(hOleAut32, "VARIANT_UserMarshal");
    if(pfnTemp != 0)
        UserMarshalRoutines[1].pfnMarshall = (USER_MARSHAL_MARSHALLING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());


    pfnTemp = GetProcAddress(hOleAut32, "VARIANT_UserUnmarshal");
    if(pfnTemp != 0)
        UserMarshalRoutines[1].pfnUnmarshall = (USER_MARSHAL_UNMARSHALLING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());


    pfnTemp = GetProcAddress(hOleAut32, "VARIANT_UserFree");
    if(pfnTemp != 0)
        UserMarshalRoutines[1].pfnFree = (USER_MARSHAL_FREEING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());

    pfnTemp = GetProcAddress(hOleAut32, "LPSAFEARRAY_UserSize");
    if(pfnTemp != 0)
        pfnLPSAFEARRAY_UserSize = (USER_MARSHAL_SIZING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());

    pfnTemp = GetProcAddress(hOleAut32, "LPSAFEARRAY_UserMarshal");
    if(pfnTemp != 0)
        pfnLPSAFEARRAY_UserMarshal = (USER_MARSHAL_MARSHALLING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());


    pfnTemp = GetProcAddress(hOleAut32, "LPSAFEARRAY_UserUnmarshal");
    if(pfnTemp != 0)
        pfnLPSAFEARRAY_UserUnmarshal = (USER_MARSHAL_UNMARSHALLING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());


    pfnTemp = GetProcAddress(hOleAut32, "LPSAFEARRAY_UserFree");
    if(pfnTemp != 0)
        UserMarshalRoutines[2].pfnFree = (USER_MARSHAL_FREEING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\udt.cxx ===
/*++

Microsoft Windows
Copyright (c) 1997 - 1999 Microsoft Corporation.  All rights reserved.

File:
    udt.cxx

Abstract:
    Marshalling support for user defined data types.

Author:
    ShannonC    21-Apr-1997

Environment:
    Windows NT and Windows 95.  We do not support DOS and Win16.

Revision History:

--*/
#include <ndrp.h>
#include <oaidl.h>
#include <typegen.h>
#include <interp2.h>

extern USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[3];


class CTypeFactory : public ITypeFactory, public IClassFactory
{
public:
    HRESULT STDMETHODCALLTYPE QueryInterface(
        IN  REFIID riid,
        OUT void **ppv);

    ULONG   STDMETHODCALLTYPE AddRef();

    ULONG   STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE CreateFromTypeInfo(
        IN  ITypeInfo *pTypeInfo,
        IN  REFIID riid,
        OUT IUnknown **ppv);

    HRESULT STDMETHODCALLTYPE CreateInstance(
        IN  IUnknown * pUnkOuter,
        IN  REFIID     riid,
        OUT void    ** ppv);

    HRESULT STDMETHODCALLTYPE LockServer(
	IN  BOOL fLock);

    CTypeFactory();

private:
    long _cRefs;
};

CLSID CLSID_TypeFactory = { /* b5866878-bd99-11d0-b04b-00c04fd91550 */
    0xb5866878,
    0xbd99,
    0x11d0,
    {0xb0, 0x4b, 0x00, 0xc0, 0x4f, 0xd9, 0x15, 0x50}
  };

class CTypeMarshal : public ITypeMarshal, public IMarshal
{
public:
    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface(
        IN  REFIID riid,
        OUT void **ppvObject);

    ULONG   STDMETHODCALLTYPE AddRef();

    ULONG   STDMETHODCALLTYPE Release();

    // ITypeMarshal methods
    HRESULT STDMETHODCALLTYPE Size(
        IN  void *  pType,
        IN  DWORD   dwDestContext,
        IN  void  * pvDestContext,
        OUT ULONG * pSize);

    HRESULT STDMETHODCALLTYPE Marshal(
        IN  void *  pType,
        IN  DWORD   dwDestContext,
        IN  void  * pvDestContext,
        IN  ULONG   cbBufferLength,
        OUT BYTE  * pBuffer,
        OUT ULONG * pcbWritten);

    HRESULT STDMETHODCALLTYPE Unmarshal(
        IN  void   * pType,
        IN  DWORD    dwFlags,
        IN  ULONG    cbBufferLength,
        IN  BYTE   * pBuffer,
        OUT ULONG  * pcbRead);

    HRESULT STDMETHODCALLTYPE Free(
        IN void * pType);

    // IMarshal methods.
    HRESULT STDMETHODCALLTYPE GetUnmarshalClass
    (
        IN  REFIID riid,
        IN  void *pv,
        IN  DWORD dwDestContext,
        IN  void *pvDestContext,
        IN  DWORD mshlflags,
        OUT CLSID *pCid
    );

    HRESULT STDMETHODCALLTYPE GetMarshalSizeMax
    (
        IN  REFIID riid,
        IN  void *pv,
        IN  DWORD dwDestContext,
        IN  void *pvDestContext,
        IN  DWORD mshlflags,
        OUT DWORD *pSize
    );

    HRESULT STDMETHODCALLTYPE MarshalInterface
    (
        IN  IStream *pStm,
        IN  REFIID riid,
        IN  void *pv,
        IN  DWORD dwDestContext,
        IN  void *pvDestContext,
        IN  DWORD mshlflags
    );

    HRESULT STDMETHODCALLTYPE UnmarshalInterface
    (
        IN  IStream *pStm,
        IN  REFIID riid,
        OUT void **ppv
    );

    HRESULT STDMETHODCALLTYPE ReleaseMarshalData
    (
        IN  IStream *pStm
    );

    HRESULT STDMETHODCALLTYPE DisconnectObject
    (
        IN  DWORD dwReserved
    );

    CTypeMarshal(
        IN PFORMAT_STRING pFormatString,
        IN ULONG          length,
        IN ULONG          offset);

private:
    ~CTypeMarshal();

    long           _cRefs;
    ULONG          _offset;
    ULONG          _length;
    PFORMAT_STRING _pFormatString;
    MIDL_STUB_DESC _StubDesc;
};


//+---------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Gets an interface pointer to the specified class object.
//
//  Arguments:  rclsid - CLSID for the class object.
//              riid   - IID for the requested interface
//		[ppv]  - Returns the interface pointer to the class object.
//
//  Returns:   	S_OK
//              CLASS_E_CLASSNOTAVAILABLE
//              E_INVALIDARG
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//
//----------------------------------------------------------------------------
STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    void ** ppv)
{
    HRESULT hr;
    RPC_STATUS rc;

    __try
    {
        *ppv = NULL;

        //Initialize the RPC heap.
        rc = NdrpPerformRpcInitialization();

        if (rc == RPC_S_OK)
        {
            if(rclsid == CLSID_TypeFactory)
            {
                CTypeFactory * pTypeFactory;
    
                pTypeFactory = new CTypeFactory;
                if(pTypeFactory != NULL)
                {
                    hr = pTypeFactory->QueryInterface(riid, ppv);
                    pTypeFactory->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = CLASS_E_CLASSNOTAVAILABLE;
            }
        }
        else
            hr = HRESULT_FROM_WIN32(rc);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeFactory::CTypeFactory
//
//  Synopsis:   Constructor for CTypeFactory
//
//----------------------------------------------------------------------------
CTypeFactory::CTypeFactory()
: _cRefs(1)
{
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeFactory::QueryInterface
//
//  Synopsis:   Gets a pointer to the specified interface.
//
//  Arguments:  riid - IID of the requested interface.
//		ppv  - Returns the interface pointer.
//
//  Returns:   	S_OK
//              E_INVALIDARG
//              E_NOINTERFACE
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CTypeFactory::QueryInterface(
    REFIID riid,
    void **ppv)
{
    HRESULT hr;

    __try
    {
        *ppv = NULL;

        if(IsEqualIID(riid, IID_IUnknown) ||
           IsEqualIID(riid, IID_ITypeFactory))
        {
            AddRef();
            *ppv = (ITypeFactory *) this;
            hr = S_OK;
        }
        else if(IsEqualIID(riid, IID_IClassFactory))
        {
            AddRef();
            *ppv = (IClassFactory *) this;
            hr = S_OK;
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeFactory::AddRef
//
//  Synopsis:   Increment the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the new reference count
//
//  Notes:      Use InterlockedIncrement to make it multi-thread safe.
//
//----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CTypeFactory::AddRef(void)
{
    InterlockedIncrement(&_cRefs);
    return _cRefs;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeFactory::Release
//
//  Synopsis:   Decrement the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the remaining reference count
//
//  Notes:      Use InterlockedDecrement to make it multi-thread safe.
//              We use a local variable so that we don't access
//              a data member after decrementing the reference count.
//
//----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CTypeFactory::Release(void)
{
    ULONG count = _cRefs - 1;

    if(0 == InterlockedDecrement(&_cRefs))
    {
	    delete this;
	    count = 0;
    }

    return count;
}

//+-------------------------------------------------------------------------
//
//  Member:   	CTypeFactory::LockServer
//
//  Synopsis:   Lock the server. Does nothing.
//
//  Arguments:  fLock
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP CTypeFactory::LockServer(BOOL fLock)
{
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CTypeFactory::CreateInstance
//
//  Synopsis:   Creates a CTypeMarshal.
//
//  Arguments:  [pUnkOuter] - The controlling unknown (for aggregation)
//		[iid]       - The requested interface ID.
//		[ppv]       - Returns the pointer to the new object
//
//  Returns:    S_OK
//              CLASS_E_NOAGGREGATION
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//              E_INVALIDARG
//
//--------------------------------------------------------------------------
STDMETHODIMP CTypeFactory::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID     riid, 
    void **    ppv)
{
    HRESULT hr;
    IID     iid;

    __try
    {
        //Parameter validation.
        *ppv = NULL;
        iid = riid;

        if(NULL == pUnkOuter)
        {
            CTypeMarshal *pTypeMarshal = new CTypeMarshal(NULL, 0, 0);
            if(pTypeMarshal != NULL)
            {
                hr = pTypeMarshal->QueryInterface(iid, ppv);
                pTypeMarshal->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            //CTypeMarshal does not support aggregation.
            hr = CLASS_E_NOAGGREGATION;            
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeFactory::CreateFromTypeInfo
//
//  Synopsis:   Create a type marshaller from the typeinfo.
//
//  Arguments:  void
//
//  Returns:    S_OK
//              DISP_E_BADVARTYPE
//              E_INVALIDARG
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE 
CTypeFactory::CreateFromTypeInfo(
    IN  ITypeInfo * pTypeInfo,
    IN  REFIID      riid,
    OUT IUnknown ** ppv)
{
    HRESULT        hr;
    CTypeMarshal * pTypeMarshal;
    PFORMAT_STRING pFormatString;
    USHORT         length;
    USHORT         offset;
    PARAMINFO      paramInfo;
    CTypeGen       *ptypeGen = new CTypeGen;
    DWORD          structInfo = 0;

    if (NULL == ptypeGen)
        return E_OUTOFMEMORY;

    __try
    {
        *ppv = NULL;

        //Build a type format string from the typeinfo.

        paramInfo.vt = VT_USERDEFINED;
        paramInfo.pTypeInfo = pTypeInfo;
        pTypeInfo->AddRef();
   
        hr = ptypeGen->RegisterType(&paramInfo,
                                  &offset,
                                  &structInfo);

        if (SUCCEEDED(hr) && (0 == offset))
        {
            ASSERT( !(paramInfo.vt & VT_BYREF));
            switch (paramInfo.vt)
            {
            case VT_I1:
            case VT_UI1:
                    offset = 734;
                break;

            case VT_I2:
            case VT_UI2:
            case VT_BOOL:
                    offset = 738;
                break;

            case VT_I4:
            case VT_UI4:
            case VT_INT:
            case VT_UINT:
            case VT_ERROR:
            case VT_HRESULT:
                    offset = 742;
                break;

            case VT_I8:
            case VT_UI8:
            case VT_CY:
                    offset = 310;
                break;

            case VT_R4:
                    offset = 746;
                break;

            case VT_R8:
            case VT_DATE:
                    offset = 750;
                break;  
            }
        }
        
        if(SUCCEEDED(hr))
        {
            hr = ptypeGen->GetTypeFormatString(&pFormatString, &length);
            if(SUCCEEDED(hr))
            {
                pTypeMarshal = new CTypeMarshal(pFormatString, length, offset);
                if(pTypeMarshal != NULL)
                {
                    hr = pTypeMarshal->QueryInterface(riid, (void **) ppv);
                    pTypeMarshal->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    ReleaseTypeFormatString(pFormatString);
                }
            }
        }
        delete ptypeGen;    // fix compile warning
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        delete ptypeGen;    // fix compile warning
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::CTypeMarshal
//
//  Synopsis:   Constructor for CTypeMarshal
//
//----------------------------------------------------------------------------
CTypeMarshal::CTypeMarshal(
    IN PFORMAT_STRING pFormatString,
    IN ULONG          length,
    IN ULONG          offset)
: _pFormatString(pFormatString), _length(length), _offset(offset), _cRefs(1)
{
    //Initialize the MIDL_STUB_DESC.
    MIDL_memset(&_StubDesc, 0, sizeof(_StubDesc));
    _StubDesc.pfnAllocate = NdrOleAllocate;
    _StubDesc.pfnFree = NdrOleFree;
    _StubDesc.pFormatTypes = pFormatString;
#if !defined(__RPC_WIN64__)
    _StubDesc.Version = 0x20000; /* Ndr library version */
    _StubDesc.MIDLVersion = MIDL_VERSION_3_0_44;
#else
    _StubDesc.Version = 0x50002; /* Ndr library version */
    _StubDesc.MIDLVersion = MIDL_VERSION_5_2_202;
#endif
    _StubDesc.aUserMarshalQuadruple = UserMarshalRoutines;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::~CTypeMarshal
//
//  Synopsis:   Destructor for CTypeMarshal
//
//----------------------------------------------------------------------------
CTypeMarshal::~CTypeMarshal()
{
    ReleaseTypeFormatString(_pFormatString);
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::QueryInterface
//
//  Synopsis:   Gets a pointer to the specified interface.
//
//  Arguments:  riid - IID of the requested interface.
//		ppv  - Returns the interface pointer.
//
//  Returns:   	S_OK
//              E_INVALIDARG
//              E_NOINTERFACE
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CTypeMarshal::QueryInterface(
    REFIID riid,
    void **ppv)
{
    HRESULT hr;

    __try
    {
        *ppv = NULL;

        if(IsEqualIID(riid, IID_IUnknown) ||
           IsEqualIID(riid, IID_ITypeMarshal))
        {
            AddRef();
            *ppv = (ITypeMarshal *) this;
            hr = S_OK;
        }
        else if (IsEqualIID(riid, IID_IMarshal))
        {
            AddRef();
            *ppv = (IMarshal *) this;
            hr = S_OK;
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::AddRef
//
//  Synopsis:   Increment the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the new reference count
//
//  Notes:      Use InterlockedIncrement to make it multi-thread safe.
//
//----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CTypeMarshal::AddRef(void)
{
    InterlockedIncrement(&_cRefs);
    return _cRefs;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::Release
//
//  Synopsis:   Decrement the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the remaining reference count
//
//  Notes:      Use InterlockedDecrement to make it multi-thread safe.
//              We use a local variable so that we don't access
//              a data member after decrementing the reference count.
//
//----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CTypeMarshal::Release(void)
{
    ULONG count = _cRefs - 1;

    if(0 == InterlockedDecrement(&_cRefs))
    {
	    delete this;
	    count = 0;
    }

    return count;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::Size
//
//  Synopsis:   Computes the size of the marshalled data type.
//
//  Returns:    S_OK
//              E_INVALIDARG
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CTypeMarshal::Size(
    IN  void *  pType,
    IN  DWORD   dwDestContext,
    IN  void  * pvDestContext,
    OUT ULONG * pSize)
{
    HRESULT           hr = S_OK;
    MIDL_STUB_MESSAGE StubMsg;
    PFORMAT_STRING    pTypeFormat;

    __try
    {
        if(!_pFormatString)
            return E_UNEXPECTED;

        pTypeFormat = _pFormatString + _offset;

        MIDL_memset(&StubMsg, 0, sizeof(StubMsg));
        StubMsg.StubDesc = &_StubDesc;
        StubMsg.pfnFree = NdrOleFree;
        StubMsg.pfnAllocate = NdrOleAllocate;
        StubMsg.IsClient = 1;
        StubMsg.BufferLength = 1; //Reserve space for an alignment gap.
        StubMsg.dwDestContext = dwDestContext;
        StubMsg.pvDestContext = pvDestContext;

        (*pfnSizeRoutines[ROUTINE_INDEX(*pTypeFormat)])(
            &StubMsg,
            (unsigned char *)pType,
            pTypeFormat);

        *pSize = StubMsg.BufferLength - 1;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::Marshal
//
//  Synopsis:   Marshals the user-defined type into a buffer.
//
//  Returns:    S_OK
//              E_INVALIDARG
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CTypeMarshal::Marshal(
    IN  void *  pType,
    IN  DWORD   dwDestContext,
    IN  void  * pvDestContext,
    IN  ULONG   cbBufferLength,
    OUT BYTE  * pBuffer,
    OUT ULONG * pcbWritten)
{
    HRESULT           hr = S_OK;    
    MIDL_STUB_MESSAGE StubMsg;
    RPC_MESSAGE       RpcMsg;
    PFORMAT_STRING    pTypeFormat;

    __try
    {
        if(!_pFormatString)
            return E_UNEXPECTED;

        pTypeFormat = _pFormatString + _offset;

        MIDL_memset(&StubMsg, 0, sizeof(StubMsg));
        StubMsg.StubDesc = &_StubDesc;
        StubMsg.pfnFree = NdrOleFree;
        StubMsg.pfnAllocate = NdrOleAllocate;
        StubMsg.IsClient = 1;
        StubMsg.dwDestContext = dwDestContext;
        StubMsg.pvDestContext = pvDestContext;
        StubMsg.Buffer = pBuffer;

        MIDL_memset(&RpcMsg, 0, sizeof(RpcMsg));
        RpcMsg.DataRepresentation = NDR_LOCAL_DATA_REPRESENTATION;
        RpcMsg.Buffer = pBuffer;
        RpcMsg.BufferLength = cbBufferLength;
        StubMsg.RpcMsg = &RpcMsg;

        (*pfnMarshallRoutines[ROUTINE_INDEX(*pTypeFormat)])(
            &StubMsg,
            (unsigned char *)pType,
            pTypeFormat);

        *pcbWritten = (ULONG)(StubMsg.Buffer - pBuffer);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::Unmarshal
//
//  Synopsis:   Unmarshals a user-defined type from a buffer.
//
//  Returns:    S_OK
//              E_INVALIDARG
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CTypeMarshal::Unmarshal(
    OUT void   * pType,
    IN  DWORD    dwFlags,
    IN  ULONG    cbBufferLength,
    IN  BYTE   * pBuffer,
    OUT ULONG  * pcbRead)
{
    HRESULT           hr = S_OK;
    MIDL_STUB_MESSAGE StubMsg;
    RPC_MESSAGE       RpcMsg;
    PFORMAT_STRING    pTypeFormat;

    __try
    {
        if(pcbRead)
            *pcbRead = 0;

        if(!_pFormatString)
            return E_UNEXPECTED;

        pTypeFormat = _pFormatString + _offset;
        // HACK! OA might pass in 0xffffffff, which 
        // will break the attack checking in ndr engine.
        // what we do now is mask off the highest byte.
        // This will lead to a 64M limit buffer, but that
        // should be good enough for now.
        cbBufferLength &= 0xffffff;

        MIDL_memset(&StubMsg, 0, sizeof(StubMsg));
        StubMsg.StubDesc = &_StubDesc;
        StubMsg.pfnFree = NdrOleFree;
        StubMsg.pfnAllocate = NdrOleAllocate;
        StubMsg.IsClient = 1;
        StubMsg.dwDestContext = dwFlags & 0x0000FFFF;
        StubMsg.Buffer = pBuffer;
        StubMsg.BufferStart = pBuffer;
        StubMsg.BufferLength = cbBufferLength;
        StubMsg.BufferEnd = pBuffer + cbBufferLength;

        MIDL_memset(&RpcMsg, 0, sizeof(RpcMsg));
        RpcMsg.DataRepresentation = dwFlags >> 16;
        RpcMsg.Buffer = pBuffer;
        RpcMsg.BufferLength = cbBufferLength;
        StubMsg.RpcMsg = &RpcMsg;

        NdrClientZeroOut(&StubMsg,
                         pTypeFormat,
                         (uchar *) pType); 

        //Endianness
        if(RpcMsg.DataRepresentation != NDR_LOCAL_DATA_REPRESENTATION)
        {
            (*pfnConvertRoutines[ROUTINE_INDEX(*pTypeFormat)])(&StubMsg,
                                                               pTypeFormat,
                                                               FALSE);
            StubMsg.Buffer = pBuffer;
        }
        
        //Unmarshal
        (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pTypeFormat)])(
            &StubMsg,
            (unsigned char **)&pType,
            pTypeFormat,
            FALSE);

        if(pcbRead)
            *pcbRead = (ULONG)(StubMsg.Buffer - pBuffer);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::Free
//
//  Synopsis:   Frees a user-defined type.
//
//  Returns:    S_OK
//              E_INVALIDARG
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CTypeMarshal::Free(
    void * pType)
{
    HRESULT           hr = S_OK;
    MIDL_STUB_MESSAGE StubMsg;
    PFORMAT_STRING    pTypeFormat;

    __try
    {
        if(pType != NULL)
        {
            if(!_pFormatString)
                return E_UNEXPECTED;

            pTypeFormat = _pFormatString + _offset;

            MIDL_memset(&StubMsg, 0, sizeof(StubMsg));
            StubMsg.StubDesc = &_StubDesc;
            StubMsg.pfnFree = NdrOleFree;
            StubMsg.pfnAllocate = NdrOleAllocate;
            StubMsg.IsClient = 1;

            (*pfnFreeRoutines[ROUTINE_INDEX(*pTypeFormat)])(
                 &StubMsg,
                 (unsigned char *)pType,
                 pTypeFormat);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::GetUnmarshalClass
//
//  Synopsis:   Get the class ID.
//
//----------------------------------------------------------------------------
STDMETHODIMP CTypeMarshal::GetUnmarshalClass(
    REFIID  riid,
    LPVOID  pv,
    DWORD   dwDestContext,
    LPVOID  pvDestContext,
    DWORD   mshlflags,
    CLSID * pClassID)
{
    HRESULT hr = S_OK;

    __try
    {
        *pClassID = CLSID_TypeFactory;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::GetMarshalSizeMax
//
//  Synopsis:   Get maximum size of marshalled moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CTypeMarshal::GetMarshalSizeMax(
    REFIID riid,
    LPVOID pv,
    DWORD  dwDestContext,
    LPVOID pvDestContext,
    DWORD  mshlflags,
    DWORD *pSize)
{
    HRESULT hr;

    __try
    {
        *pSize =  sizeof(_offset) + sizeof(_length) + _length;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::MarshalInterface
//
//  Synopsis:   Marshal moniker into a stream.
//
//----------------------------------------------------------------------------
STDMETHODIMP CTypeMarshal::MarshalInterface(
    IStream * pStream,
    REFIID    riid,
    void    * pv,
    DWORD     dwDestContext,
    LPVOID    pvDestContext,
    DWORD     mshlflags)
{
    HRESULT hr;
    ULONG cb;

    hr = pStream->Write(&_offset, sizeof(_offset), &cb);
    if(SUCCEEDED(hr))
    {
        hr = pStream->Write(&_length, sizeof(_length), &cb);
        if(SUCCEEDED(hr))
        {
            hr = pStream->Write(_pFormatString, _length, &cb);
        }
    }
   
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::UnmarshalInterface
//
//  Synopsis:   Unmarshal moniker from a stream.
//
//----------------------------------------------------------------------------
STDMETHODIMP CTypeMarshal::UnmarshalInterface(
    IStream * pStream,
    REFIID    riid,
    void   ** ppv)
{
    HRESULT hr;
    ULONG   cb;

    __try
    {
        //Validate parameters.
        *ppv = NULL;

        hr = pStream->Read(&_offset, sizeof(_offset), &cb);
        if(SUCCEEDED(hr) && 
           (sizeof(_offset) == cb))
        {
            hr = pStream->Read(&_length, sizeof(_length), &cb);
            if(SUCCEEDED(hr) && 
               (sizeof(_length) == cb))
            {
                _pFormatString = (PFORMAT_STRING) I_RpcAllocate(_length);
                if(_pFormatString != NULL)
                {
                    hr = pStream->Read((void *) _pFormatString, _length, &_length);
                    if(SUCCEEDED(hr))
                    {
                        hr = QueryInterface(riid, ppv);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::ReleaseMarshalData
//
//  Synopsis:   Release a marshalled class moniker.
//              Just seek to the end of the marshalled class moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CTypeMarshal::ReleaseMarshalData(
    IStream * pStream)
{
    HRESULT hr;
    ULONG   cb;    

    hr = pStream->Read(&_offset, sizeof(_offset), &cb);
    if(SUCCEEDED(hr) && 
       (sizeof(_offset) == cb))
    {
        hr = pStream->Read(&_length, sizeof(_length), &cb);
        if(SUCCEEDED(hr) && 
           (sizeof(_length) == cb))
        {
            LARGE_INTEGER liSize;
 
            liSize.LowPart = _length;
            liSize.HighPart = 0;
            hr = pStream->Seek(liSize, STREAM_SEEK_CUR, NULL);
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::DisconnectObject
//
//  Synopsis:   Disconnect the object.
//
//----------------------------------------------------------------------------
STDMETHODIMP CTypeMarshal::DisconnectObject(
    DWORD dwReserved)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\unmrshlp.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 Microsoft Corporation

Module Name :

    unmrshlp.c

Abstract :

    This file contains the routines for unmarshalling an array's or a
    structure's embedded pointers.

Author :

    David Kays  dkays   September 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "ndrp.h"
#include "attack.h"
#include "pointerq.h"


PFORMAT_STRING
NdrpEmbeddedPointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    uchar               fNewMemory )
/*++

Routine Description :

    Unmarshalls an array's or a structure's embedded pointers.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure or array whose embedded pointers
                  are being unmarshalled.
    pFormat     - Pointer layout format string description.
    fNewMemory  - TRUE if the array or structure was allocated during
                  unmarshalling, FALSE otherwise.

Return :

    Format string pointer after the pointer layout.

--*/
{
    uchar **        ppMemPtr;
    uchar **        ppBufPtr;
    uchar *         pBufferMark;
    ULONG_PTR       MaxCountSave;
    long            OffsetSave;

    MaxCountSave =  pStubMsg->MaxCount;
    OffsetSave = pStubMsg->Offset;
    pStubMsg->Memory = pMemory;

    POINTER_BUFFER_SWAP_CONTEXT SwapContext(pStubMsg);
    
    // Save BufferMark in a local.
    pBufferMark = pStubMsg->BufferMark;

    // Increment past FC_PP and FC_PAD.
    pFormat += 2;

    for (;;)
        {
        if ( *pFormat == FC_END )
            {
            return pFormat;
            }

        // Check for FC_FIXED_REPEAT or FC_VARIABLE_REPEAT.
        if ( *pFormat != FC_NO_REPEAT )
            {
            pStubMsg->MaxCount = MaxCountSave;
            pStubMsg->Offset = OffsetSave;

            pStubMsg->BufferMark = pBufferMark;

            pFormat = NdrpEmbeddedRepeatPointerUnmarshall( pStubMsg,
                                                           pMemory,
                                                           pFormat,
                                                           fNewMemory );

            // Continue to the next pointer.
            continue;
            }

        // Compute the pointer to the current memory pointer to the data.
        ppMemPtr = (uchar **)( pMemory + *((signed short *)(pFormat + 2)) );

        // Compute the pointer to the pointer in the buffer.
        ppBufPtr = (uchar **)(pBufferMark + *((signed short *)(pFormat + 4)));

        // Increment to the pointer description.
        pFormat += 6;

        //
        // If the incomming encapsulating memory pointer was just allocated,
        // then explicitly null out the current pointer.
        //
        if ( fNewMemory )
            *ppMemPtr = 0;

        NdrpPointerUnmarshall( 
             pStubMsg,
             (uchar**)ppMemPtr, // Memory rep written here
             *ppMemPtr,
             (long *)ppBufPtr,  // Wire rep written here
             pFormat );

        // Increment to the next pointer description.
        pFormat += 4;
        }
}


PFORMAT_STRING
NdrpEmbeddedRepeatPointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    uchar               fNewMemory )
/*++

Routine Description :

    Unmarshalls an array's embedded pointers.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array whose embedded pointers are being
                  unmarshalled.
    pFormat     - Pointer layout format string description.
    fNewMemory  - TRUE if the array was allocated during unmarshalling,
                  FALSE otherwise.

Return :

    Format string pointer after the pointer layout.

--*/
{
    uchar **        ppMemPtr;
    uchar **        ppBufPtr;
    PFORMAT_STRING  pFormatSave;
    uchar *         pBufferMark;
    uchar *         pArrayElement;
    ulong           RepeatCount, RepeatIncrement, Pointers, PointersSave;

    CORRELATION_RESOURCE_SAVE;

    SAVE_CORRELATION_MEMORY();

    // Get the beginning of the contained structure in the buffer.
    pBufferMark = pStubMsg->BufferMark;

    // Get the repeat count.
    switch ( *pFormat )
        {
        case FC_FIXED_REPEAT :
            pFormat += 2;

            RepeatCount = *((ushort *)pFormat);

            break;

        case FC_VARIABLE_REPEAT :
            RepeatCount = (ulong)pStubMsg->MaxCount;

            //
            // Check if this variable repeat instance also has a variable
            // offset (this would be the case for a conformant varying array
            // of pointers, or structures which contain pointers).  If so then
            // increment the format string to point to the actual first array
            // element which is being marshalled.
            //
            if ( pFormat[1] == FC_VARIABLE_OFFSET )
                pMemory += *((ushort *)(pFormat + 2)) * pStubMsg->Offset;

            // else pFormat[1] == FC_FIXED_OFFSET - do nothing

            break;

        default :
            NDR_ASSERT(0,"NdrpEmbeddedRepeatPointerUnmarshall : bad format");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    // Increment format string to increment field.
    pFormat += 2;

    // Get the increment amount between successive pointers.
    RepeatIncrement = *((ushort * &)pFormat)++;

    // Load up pointer to first element of embedded array.
    pArrayElement = pBufferMark + *((ushort * &)pFormat)++;

    // Get number of pointers in each array element.
    PointersSave = Pointers = *((ushort * &)pFormat)++;

    pFormatSave = pFormat;

    //
    // Loop over the number of shipped array elements.
    //
    for ( ; RepeatCount--;
            pBufferMark += RepeatIncrement,
            pMemory += RepeatIncrement,
            pArrayElement += RepeatIncrement )
        {
        pFormat = pFormatSave;
        Pointers = PointersSave;

        // Set the correlation check context to be the beginning of each element
        // in the array. This is necessary since other functions will assume that
        // the context points to the top of the flat part of the containing structure.
        // If the containing structure is embedded in another structure, the offset
        // for correlation checks will be relative to the topmost structure.
        pStubMsg->pCorrMemory = pArrayElement;

        //
        // Loop over the number of pointer per array element (which can
        // be greater than one for an array of structures).
        //
        for ( ; Pointers--; )
            {
            // Pointer to the pointer in memory.
            ppMemPtr = (uchar **)(pMemory + *((signed short * &)pFormat)++);

            // Pointer to the pointer's id in the buffer.
            ppBufPtr = (uchar **)(pBufferMark + *((signed short * &)pFormat)++);

            //
            // If the incomming encapsulating memory pointer was just
            // allocated, then explicitly null out the current pointer.
            //
            if ( fNewMemory )
                *ppMemPtr = 0;

            NdrpPointerUnmarshall( 
                pStubMsg,
                (uchar**)ppMemPtr, // Memory rep written here
                *ppMemPtr,
                (long *)ppBufPtr,  // Wire rep written here
                pFormat );

            // Increment past the pointer description.
            pFormat += 4;
            }
        }

    RESET_CORRELATION_MEMORY();

    // Return the format string pointer past the array's pointer description.
    return pFormatSave + PointersSave * 8;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\unmrshl.cxx ===
/**********************************************************************

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    unmrshl.cxx

Abstract :

    This file contains the unmarshalling routines called by MIDL generated
    stubs and the interpreter.

Author :

    David Kays  dkays   September 1993.

Revision History :

  **********************************************************************/

#include "ndrp.h"
#include "hndl.h"
#include "ndrole.h"
#include "attack.h"
#include "pointerq.h"

unsigned char * RPC_ENTRY
NdrUDTSimpleTypeUnmarshall1(
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned char * *   ppMemory,
    PFORMAT_STRING      pFormat,
    unsigned char       fMustAlloc
    );


//
// Function table of unmarshalling routines.
//
extern const
PUNMARSHALL_ROUTINE UnmarshallRoutinesTable[] =
                    {
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,

                    NdrPointerUnmarshall,
                    NdrPointerUnmarshall,
                    NdrPointerUnmarshall,
                    NdrPointerUnmarshall,

                    NdrSimpleStructUnmarshall,
                    NdrSimpleStructUnmarshall,
                    NdrConformantStructUnmarshall,
                    NdrConformantStructUnmarshall,
                    NdrConformantVaryingStructUnmarshall,

                    NdrComplexStructUnmarshall,

                    NdrConformantArrayUnmarshall,
                    NdrConformantVaryingArrayUnmarshall,
                    NdrFixedArrayUnmarshall,
                    NdrFixedArrayUnmarshall,
                    NdrVaryingArrayUnmarshall,
                    NdrVaryingArrayUnmarshall,

                    NdrComplexArrayUnmarshall,

                    NdrConformantStringUnmarshall,
                    NdrConformantStringUnmarshall,
                    NdrConformantStringUnmarshall,
                    NdrConformantStringUnmarshall,

                    NdrNonConformantStringUnmarshall,
                    NdrNonConformantStringUnmarshall,
                    NdrNonConformantStringUnmarshall,
                    NdrNonConformantStringUnmarshall,

                    NdrEncapsulatedUnionUnmarshall,
                    NdrNonEncapsulatedUnionUnmarshall,

                    NdrByteCountPointerUnmarshall,

                    NdrXmitOrRepAsUnmarshall,  // transmit as
                    NdrXmitOrRepAsUnmarshall,  // represent as

                    NdrPointerUnmarshall,

                    NdrUnmarshallHandle,

                    // New Post NT 3.5 tokens serviced from here on.

                    0,   // FC_HARD_STRUCT     // NdrHardStructUnmarshall,

                    NdrXmitOrRepAsUnmarshall,  // transmit as ptr
                    NdrXmitOrRepAsUnmarshall,  // represent as ptr

                    NdrUserMarshalUnmarshall,

                    0,   // FC_PIPE
                    0,   // FC_BLK_HOLE

                    NdrRangeUnmarshall,
                
                    0,   // FC_INT3264
                    0,   // FC_UINT3264

                    0, // NdrCsArrayUnmarshall,
                    0, // NdrCsTagUnmarshall

                    };

extern const
PUNMARSHALL_ROUTINE * pfnUnmarshallRoutines = UnmarshallRoutinesTable;

RPCRTAPI
unsigned char * RPC_ENTRY
NdrTypeUnmarshall( PMIDL_STUB_MESSAGE pStubMsg,
                   uchar **           ppMemory,
                   PFORMAT_STRING     pFormat,
                   uchar              fMustAlloc )
{
    return 
    (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                       ppMemory,
                                                       pFormat,
                                                       fMustAlloc );
}

__inline unsigned char * RPC_ENTRY
NdrUDTSimpleTypeUnmarshall1(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               /* fSkipRefCheck */)
{
    NdrSimpleTypeUnmarshall(pStubMsg,*ppMemory,*pFormat);
    return NULL;
}

void 
NdrpInterfacePointerUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat );


void RPC_ENTRY
NdrSimpleTypeUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    uchar               FormatChar )
/*++

Routine Description :

    Unmarshalls a simple type.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Memory pointer to unmarshall into.
    FormatChar  - Simple type format character.

Return :

    None.

--*/
{
    switch ( FormatChar )
        {
        case FC_CHAR :
        case FC_BYTE :
        case FC_SMALL :
        case FC_USMALL :
            *pMemory = *(pStubMsg->Buffer)++;
            break;

        case FC_ENUM16 :
            *((ulong *)pMemory) &= 0x0000ffff;

            // fall through...

        case FC_WCHAR :
        case FC_SHORT :
        case FC_USHORT :
            ALIGN(pStubMsg->Buffer,1);

            *((ushort *)pMemory) = *((ushort * &)pStubMsg->Buffer)++;
            break;

#if defined(__RPC_WIN64__)
        case FC_INT3264:
            ALIGN(pStubMsg->Buffer,3);
            // sign exted long to __int64
            *((__int64 *)pMemory) = *((long * &)pStubMsg->Buffer)++;
            break;

        case FC_UINT3264:
            ALIGN(pStubMsg->Buffer,3);

            *((unsigned __int64 *)pMemory) = *((ulong * &)pStubMsg->Buffer)++;
            break;
#endif

        case FC_LONG :
        case FC_ULONG :
        case FC_FLOAT :
        case FC_ENUM32 :
        case FC_ERROR_STATUS_T:
            ALIGN(pStubMsg->Buffer,3);

            *((ulong *)pMemory) = *((ulong * &)pStubMsg->Buffer)++;
            break;

        case FC_HYPER :
        case FC_DOUBLE :
            ALIGN(pStubMsg->Buffer,7);

            //
            // Let's stay away from casts to doubles.
            //
            *((ulong *)pMemory) = *((ulong * &)pStubMsg->Buffer)++;
            *((ulong *)(pMemory + 4)) = *((ulong * &)pStubMsg->Buffer)++;
            break;

        case FC_IGNORE :
            break;

        default :
            NDR_ASSERT(0,"NdrSimpleTypeUnmarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }
}


unsigned char * RPC_ENTRY
NdrRangeUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++
    Unmarshals a range FC_RANGE descriptor.
--*/
{
     FORMAT_CHARACTER   FcType = (FORMAT_CHARACTER)(pFormat[1] & 0xf);
     NDR_DEF_FC_RANGE * pRange = (NDR_DEF_FC_RANGE *)pFormat;
     uchar *        pMemory;
     long               Value;
     unsigned long      Low, High;

     ALIGN( pStubMsg->Buffer, SIMPLE_TYPE_ALIGNMENT( FcType ) ); 
     CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + SIMPLE_TYPE_BUFSIZE(FcType )  );
     
    if ( fMustAlloc )
        *ppMemory = (uchar*)NdrAllocate( pStubMsg, SIMPLE_TYPE_MEMSIZE(FcType) );
    else
        {
        if (REUSE_BUFFER(pStubMsg) && ! *ppMemory )
            *ppMemory = pStubMsg->Buffer;
        else if ( ppMemory == NULL )
            {
            NDR_ASSERT(0, "invalid range memory\n");
            }
        }
     pMemory= *ppMemory;

     switch ( FcType )
     {
        case FC_CHAR :
        case FC_BYTE :
        case FC_USMALL :
            Value = *pMemory = *(pStubMsg->Buffer)++;
            break;

        case FC_SMALL :
            Value = *(small *)pMemory = *(small *)(pStubMsg->Buffer)++;
            break;

        case FC_ENUM16 :
            Value = *((ulong *)pMemory) &= 0x0000ffff;

            // fall through...

        case FC_WCHAR :
        case FC_USHORT :
            ALIGN(pStubMsg->Buffer,1);
            Value = *((ushort *)pMemory) = *((ushort * &)pStubMsg->Buffer)++;
            break;

        case FC_SHORT :
            ALIGN(pStubMsg->Buffer,1);
            Value = *((short *)pMemory) = *((short * &)pStubMsg->Buffer)++;
            break;

        case FC_ULONG :
        case FC_ENUM32 :
        case FC_ERROR_STATUS_T:
            ALIGN(pStubMsg->Buffer,3);
            Value = *((ulong *)pMemory) = *((ulong * &)pStubMsg->Buffer)++;
            break;

        case FC_LONG :
            ALIGN(pStubMsg->Buffer,3);
            Value = *((long *)pMemory) = *((long * &)pStubMsg->Buffer)++;
            break;

//        case FC_IGNORE :
//        case FC_FLOAT :
//        case FC_HYPER :
//        case FC_DOUBLE :
//        case FC_INT3264 :
//        case FC_UINT3264 :
        default :
            NDR_ASSERT(0,"NdrSimpleTypeUnmarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
     }

     Low  = *(unsigned long UNALIGNED *)(pFormat + 2);
     High = *(unsigned long UNALIGNED *)(pFormat + 6);

     if ( FcType == FC_ULONG )
         {
         if ( (ulong)Value < Low  ||  (ulong)Value > High )
             RpcRaiseException( RPC_X_INVALID_BOUND );
         }
     else
         if ( Value < (long)Low  ||  Value > (long)High )
             RpcRaiseException( RPC_X_INVALID_BOUND );

    return 0;
}


unsigned char * RPC_ENTRY
NdrPointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               /*fSkipRefCheck*/ )
/*++

Routine Description :

    Unmarshalls a top level pointer to anything.  Pointers embedded in
    structures, arrays, or unions call NdrpPointerUnmarshall directly.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg        - Pointer to the stub message.
    ppMemory        - Double pointer to where to unmarshall the pointer.
    pFormat         - Pointer's format string description.
    fSkipRefCheck   - This is for cases like [in,out] unique to unique to ref 
                      pointer or unique to unique to structure with embedded
                      ref pointer. Client pass in NULL and server allocate some
                      memory back. The flag is set when fPointerAlloc is true
                      in NdrpPointerUnmarshall.
                      In fact, we probably should skip the check for all the
                      ref pointer from fPointerAlloc. So we add a new flag in
                      pStubMsg->uFlag

Return :

    None.

--*/
{
    //
    // If the pointer is not a ref pointer then get a pointer to it's
    // incomming value's location in the buffer.  If it's a ref then set
    // up some stack space to temporarily act as the buffer.
    //
    long * pBufferPointer;
    if ( *pFormat != FC_RP )
        {
        ALIGN( pStubMsg->Buffer, 3 );
        pBufferPointer = (long*)pStubMsg->Buffer;
        pStubMsg->Buffer += PTR_WIRE_SIZE;
        }
    else
        {
        //
        // If we're on the client unmarshalling a top level [out] ref pointer,
        // we have to make sure that it is non-null.
        //
        if ( pStubMsg->IsClient && 
             !IS_SKIP_REF_CHECK( pStubMsg->uFlags )  && 
             ! *ppMemory )
            RpcRaiseException( RPC_X_NULL_REF_POINTER );

        //
        // Do this so unmarshalling ref pointers works the same as
        // unmarshalling unique and ptr pointers.
        //
        pBufferPointer = NULL;
        }

    NdrpPointerUnmarshall( pStubMsg,
                           ppMemory,
                           *ppMemory,
                           pBufferPointer,
                           pFormat );
    return 0;
}

void
NdrpFreeOlePointer(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar             *pMemory,
    PFORMAT_STRING     pFormat )
{
    NDR_POINTER_QUEUE *pOldQueue;
    if ( pStubMsg->pPointerQueueState )
        {
        pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
        pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
        }

    RpcTryFinally
        {
        NdrPointerFree( pStubMsg,
                        pMemory,
                        pFormat );                    
        }
    RpcFinally
        {
        if (pStubMsg->pPointerQueueState)
            {
            pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
            }
        }
    RpcEndFinally

}

NDR_ALLOC_ALL_NODES_CONTEXT *
NdrpGetAllocateAllNodesContext(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING     pFormat )
{
    uchar *pBuffer = pStubMsg->Buffer;

    // Clear memory size before calling mem size routine.
    pStubMsg->MemorySize = 0;

    //
    // Get the allocate all nodes memory size. Need to make sure
    // all the pointee as finished before continuing
    //
    {
        NDR_POINTER_QUEUE *pOldQueue;
        if ( pStubMsg->pPointerQueueState )
            {
            pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
            pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
            }

        RpcTryFinally
            {
            (*pfnMemSizeRoutines[ROUTINE_INDEX(*pFormat)])
                ( pStubMsg,
                  pFormat );
            }
        RpcFinally
            {
            if ( pStubMsg->pPointerQueueState )
                {
                pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
                }
            }
        RpcEndFinally

    }

    pStubMsg->Buffer = pBuffer;

    ulong AllocSize = pStubMsg->MemorySize;
    pStubMsg->MemorySize = 0;
    LENGTH_ALIGN( AllocSize, __alignof(NDR_ALLOC_ALL_NODES_CONTEXT) - 1);

    uchar *pAllocMemory = 
        (uchar*)NdrAllocate( pStubMsg, AllocSize + sizeof(NDR_ALLOC_ALL_NODES_CONTEXT) );

    NDR_ALLOC_ALL_NODES_CONTEXT *pAllocContext = 
        (NDR_ALLOC_ALL_NODES_CONTEXT*)(pAllocMemory + AllocSize);
    pAllocContext->AllocAllNodesMemory      = pAllocMemory;
    pAllocContext->AllocAllNodesMemoryBegin = pAllocMemory;
    pAllocContext->AllocAllNodesMemoryEnd   = (uchar*)pAllocContext;
    
    return pAllocContext;
}


__forceinline void
NdrpPointerUnmarshallInternal(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,       // Where allocated pointer is written
    uchar *             pMemory,
    long  *             pBufferPointer, // Pointer to the wire rep.
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for unmarshalling a pointer to anything.  This is the
    entry point for pointers embedded in structures, arrays, and unions.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg        - Pointer to the stub message.
    ppBufferPointer - Address of the location in the buffer which holds the
                      incomming pointer's value and will hold the final
                      unmarshalled pointer's value.
    pMemory         - Current memory pointer's value which we want to
                      unmarshall into.  If this value is valid the it will
                      be copied to *ppBufferPointer and this is where stuff
                      will get unmarshalled into.
    pFormat         - Pointer's format string description.

    pStubMsg->Buffer - set to the pointee.

Return :

    None.

--*/
{
    ulong       FullPtrRefId;
    uchar       fPointeeAlloc;
    int         fNewAllocAllNodes;
    int         fNewDontFreeContext;
    uchar       uFlagsSave;

    fNewAllocAllNodes = FALSE;
    fNewDontFreeContext = FALSE;

    // we need to have a check here for pointer embedded in a struct, 
    // or pointer to pointer case. 
    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );
    //
    // Check the pointer type.
    //
    switch ( *pFormat )
        {
        case FC_RP :
            break;

        case FC_IP :
            // On the client side, release the [in,out] interface pointer.

            if ( IS_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags ) )
                {
                NdrInterfacePointerUnmarshall( pStubMsg,
                                               ppMemory,
                                               pFormat,
                                               true );
                return;
                }

            if ((pStubMsg->IsClient == TRUE) && (pMemory != 0))
                {
                ((IUnknown*)pMemory)->Release();
                *ppMemory = NULL ;
                }
            
            if ( !*pBufferPointer ) return;
                
            NdrpInterfacePointerUnmarshall( pStubMsg,
                                            ppMemory,
                                            pFormat );

            if ( pBufferPointer ) *pBufferPointer = PTR_WIRE_REP(*ppMemory);

            return;

        case FC_OP :
            //
            // Burn some instructions for OLE unique pointer support.
            //
            if ( pStubMsg->IsClient )
                {
                //
                // It's ok if this is an [out] unique pointer.  It will get
                // zeroed before this routine is called and NdrPointerFree
                // will simply return. Need to finish all the pointees before
                // continueing.
                
                NdrpFreeOlePointer( 
                    pStubMsg,
                    pMemory,
                    pFormat);

                // Set the current memory pointer to 0 so that we'll alloc.
                pMemory = 0;
                }

            // Fall through.

        case FC_UP :
            //
            // Check for a null incomming pointer.  Routines which call this
            // routine insure that the memory pointer gets nulled.
            //
            if ( ! *pBufferPointer )
                {
                *ppMemory = NULL;
                return;
                }

            break;

        case FC_FP :
            //
            // We have to remember the incomming ref id because we overwrite
            // it during the QueryRefId call.
            //
            FullPtrRefId = *pBufferPointer;

            // we couldn't pass pBufferPointer to QueryRefId because it's 4bytes
            // on wire but 8bytes on 64bit. (and it'll have mix alignment issue)
            if ( 0 == FullPtrRefId )
                {
                *ppMemory = NULL;
                return;
                }
            //
            // Lookup the ref id.
            //
            if ( NdrFullPointerQueryRefId( pStubMsg->FullPtrXlatTables,
                                           FullPtrRefId,
                                           FULL_POINTER_UNMARSHALLED,
                                           (void**)ppMemory) )
                {
                // true means the RefId had been unmarshalled.
                *pBufferPointer = PTR_WIRE_REP( *ppMemory );
                return;
                }

            //
            // If our query returned false then check if the returned pointer
            // is 0.  If so then we have to scribble away the ref id in the
            // stub message FullPtrRefId field so that we can insert the
            // pointer translation later, after we've allocated the pointer.
            // If the returned pointer was non-null then we leave the stub
            // message FullPtrRefId field alone so that we don't try to
            // re-insert the pointer to ref id translation later.
            //
            // We also copy the returned pointer value into pMemory.  This
            // will allow our allocation decision to be made correctly.
            //
            pMemory = *ppMemory;
            if ( !pMemory )
                {
                //
                // Put the unmarshalled ref id into the stub message to
                // be used later in a call to NdrFullPointerInsertRefId.
                //
                pStubMsg->FullPtrRefId = FullPtrRefId;
                }

            break;

        default :
            NDR_ASSERT(0,"NdrpPointerUnmarshall : bad pointer type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    //
    // Make the initial "must allocate" decision.
    //
    // The fPointeeAlloc flag is set on the client side if the current memory
    // pointer is null, and on the server side it is set if the current memory
    // pointer has the allocate don't free attribute applied to it.
    //
    // On the client side we also set the pointer's value in the buffer equal
    // to the current memory pointer.
    //
    // On the server side we explicitly null out the pointer's value in the
    // buffer as long as it's not allocated on the stack, otherwise we set it
    // equal to the current memory pointer (stack allocated).
    //
    if ( pStubMsg->IsClient )
        {
        *ppMemory = pMemory;

        fPointeeAlloc = ! pMemory;
        }
    else
        {
        if ( ! ALLOCED_ON_STACK(pFormat[1]) )
            *ppMemory = 0;
        else
            *ppMemory = pMemory;

        //
        // If this is a don't free pointer or a parent pointer of this pointer
        // was a don't free pointer then we set the alloc flag.
        //
        if ( fPointeeAlloc = (DONT_FREE(pFormat[1]) 
                             || pStubMsg->ReuseBuffer 
                             || pStubMsg->fInDontFree) )
            {
            //
            // If we encounter a don't free pointer which is not nested inside
            // of another don't free pointer then set the local and stub message
            // flags.
            //
            if ( ! pStubMsg->fInDontFree )
                {
                fNewDontFreeContext = TRUE;
                pStubMsg->fInDontFree = TRUE;
                }
            }

        //
        // We also set the alloc flag for object interface pointers.
        //
        if ( *pFormat == FC_OP )
            fPointeeAlloc = TRUE;

        }

    //
    // Pointer to complex type.
    //
    if ( ! SIMPLE_POINTER(pFormat[1]) )
        {
        PFORMAT_STRING pFormatPointee;

        pFormatPointee = pFormat + 2;

        // Set the pointee format string.
        // Cast must be to a signed short since some offsets are negative.
        pFormatPointee += *((signed short *)pFormatPointee);

        //
        // Right now the server will always allocate for allocate all nodes
        // when told to.  Eventually we want to use the rpc buffer when
        // possible.
        //

        //
        // Check if this is an allocate all nodes pointer AND that we're
        // not already in an allocate all nodes context.
        //
        if ( ALLOCATE_ALL_NODES(pFormat[1]) && ! pStubMsg->pAllocAllNodesContext )
            {
            fNewAllocAllNodes = TRUE;

            pStubMsg->pAllocAllNodesContext =
                NdrpGetAllocateAllNodesContext(
                    pStubMsg,
                    pFormatPointee );

            *ppMemory = 0;

            fPointeeAlloc = TRUE;

            //
            // I think this is what we'll have to add to support an [in,out]
            // allocate all nodes full pointer ([in] only and [out] only
            // allocate all nodes full pointer shouldn't need any special
            // treatment).
            //
            // if ( *pFormat == FC_FP )
            //     {
            //     pStubMsg->FullPtrRefId = FullPtrRefId;
            //     }
            //
            }

        if ( POINTER_DEREF(pFormat[1]) )
            {
            //
            // Re-align the buffer.  This is to cover embedded pointer to
            // pointers.
            //
            ALIGN(pStubMsg->Buffer,0x3);

            //
            // We can't re-use the buffer for a pointer to a pointer
            // because we can't null out the pointee before we've unmarshalled
            // it.  We need the stubs to alloc pointers to pointers on the
            // stack.
            //
            if ( ! *ppMemory && ! pStubMsg->IsClient )
                fPointeeAlloc = TRUE;

            if ( fPointeeAlloc )
                {
                *ppMemory = (uchar*)NdrAllocate( pStubMsg, PTR_MEM_SIZE );
                *((void **)*ppMemory) = 0;
                }

            if ( pStubMsg->FullPtrRefId )
                FULL_POINTER_INSERT( pStubMsg, *ppMemory );

            if ( pBufferPointer ) 
                *pBufferPointer = PTR_WIRE_REP(*ppMemory);

            pBufferPointer = 0;
            ppMemory = (uchar**)*ppMemory;
            }

        //
        // Now call the proper unmarshalling routine.
        //
        uFlagsSave = pStubMsg->uFlags;
        RESET_CONF_FLAGS_TO_STANDALONE(pStubMsg->uFlags);
        if ( fPointeeAlloc )
            SET_SKIP_REF_CHECK( pStubMsg->uFlags );

        (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormatPointee)])
        ( pStubMsg,
          ppMemory,
          pFormatPointee,
          fPointeeAlloc );

        pStubMsg->uFlags = uFlagsSave;

        if ( *pFormatPointee == FC_USER_MARSHAL )
            {
            if ( pStubMsg->FullPtrRefId )
                FULL_POINTER_INSERT( pStubMsg, *ppMemory );
            }

        goto PointerUnmarshallEnd;
        }

    //
    // Else handle a pointer to a simple type, pointer, or string.
    //

    switch ( pFormat[2] )
        {
        case FC_C_CSTRING :
        case FC_C_BSTRING :
        case FC_C_WSTRING :
        case FC_C_SSTRING :
            NdrConformantStringUnmarshall( pStubMsg,
                                           ppMemory,
                                           &pFormat[2],
                                           fPointeeAlloc );
            goto PointerUnmarshallEnd;

        default :
            // Break to handle a simple type.
            break;
        }

    //
    // Handle pointers to simple types.
    //

    //
    // Align the buffer.
    //
    ALIGN(pStubMsg->Buffer,SIMPLE_TYPE_ALIGNMENT(pFormat[2]));

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + SIMPLE_TYPE_BUFSIZE(pFormat[2]) );
    
    //
    // We can't use the buffer for pointers to enum16 since these force
    // us to zero out the upper 16 bits of the memory pointer, and this
    // might overwrite data in the buffer that we still need!
    // Similar thing happens for int3264 values.
    //
    if ( pFormat[2] == FC_ENUM16
       #if defined(__RPC_WIN64__)
         ||  pFormat[2] == FC_INT3264  ||  pFormat[2] == FC_UINT3264
       #endif
       )
        {
        if ( ! pStubMsg->IsClient && ! *ppMemory )
            fPointeeAlloc = TRUE;
        }

    //
    // Check for allocation or buffer reuse.
    //
    if ( fPointeeAlloc )
        {
        *ppMemory = 
            (uchar*)NdrAllocate( pStubMsg,
                                 SIMPLE_TYPE_MEMSIZE(pFormat[2]) );
        }
    else
        {
        if ( ! pStubMsg->IsClient && ! *ppMemory )
            {
            // Set pointer into buffer.
            *ppMemory = pStubMsg->Buffer;
            }
        }

    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    //
    // We always get here for simple types.  What this means is that
    // when we reuse the buffer on the server side we end up copying the
    // data with source and destination memory pointer equal.  But this
    // way we can cover the enum and error_status_t cases without duplicating
    // a lot of code.
    //
    NdrSimpleTypeUnmarshall( pStubMsg,
                             *ppMemory,
                             pFormat[2] );

PointerUnmarshallEnd:

    if ( fNewDontFreeContext )
        pStubMsg->fInDontFree = FALSE;

    if ( pBufferPointer ) 
        *pBufferPointer = PTR_WIRE_REP(*ppMemory);

    if ( fNewAllocAllNodes )
        pStubMsg->pAllocAllNodesContext = 0;
}



NDR_UNMRSHL_POINTER_QUEUE_ELEMENT::NDR_UNMRSHL_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg, 
    uchar **           ppMemoryNew,      
    uchar *            pMemoryNew,
    long  *            pBufferPointerNew,
    PFORMAT_STRING     pFormatNew ) :

        ppMemory(ppMemoryNew),
        pMemory(pMemoryNew),
        pBufferPointer(pBufferPointerNew),
        pFormat(pFormatNew),
        Memory(pStubMsg->Memory),
        uFlags(pStubMsg->uFlags),
        fInDontFree( pStubMsg->fInDontFree ),
        pAllocAllNodesContext( pStubMsg->pAllocAllNodesContext ),
        pCorrMemory( pStubMsg->pCorrMemory )
{

}

void 
NDR_UNMRSHL_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{
    SAVE_CONTEXT<uchar*> MemorySave( pStubMsg->Memory, Memory );
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );
    NDR_ASSERT( !pStubMsg->PointerBufferMark, "PointerBufferMark is not 0\n");
    int fInDontFreeSave = pStubMsg->fInDontFree;
    pStubMsg->fInDontFree = fInDontFree;
    SAVE_CONTEXT<uchar*> pCorrMemorySave(pStubMsg->pCorrMemory, pCorrMemory );
    SAVE_CONTEXT<NDR_ALLOC_ALL_NODES_CONTEXT *> 
        AllNodesContextSave(pStubMsg->pAllocAllNodesContext, pAllocAllNodesContext); 
    
    NdrpPointerUnmarshallInternal( pStubMsg,
                                   ppMemory,
                                   pMemory,
                                   pBufferPointer,
                                   pFormat );

    pStubMsg->fInDontFree = fInDontFreeSave;
}

#if defined(DBG)
void 
NDR_UNMRSHL_POINTER_QUEUE_ELEMENT::Print() 
{
    DbgPrint("NDR_MRSHL_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("ppMemory:                %p\n", ppMemory );
    DbgPrint("pBufferPointer:          %p\n", pBufferPointer );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("Memory:                  %p\n", Memory );
    DbgPrint("uFlags:                  %x\n", uFlags );
    DbgPrint("fInDontFree:             %u\n", fInDontFree );
    DbgPrint("pAllocAllNodesContext:   %p\n", pAllocAllNodesContext );
    DbgPrint("pCorrMemorySave:         %p\n", pCorrMemory );
}
#endif

void
NdrpEnquePointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,       // Where allocated pointer is written
    uchar *             pMemory,
    long  *             pBufferPointer, // Pointer to the wire rep.
    PFORMAT_STRING      pFormat )
{
    NDR32_POINTER_CONTEXT PointerContext( pStubMsg );

    RpcTryFinally
        {
        NDR_UNMRSHL_POINTER_QUEUE_ELEMENT*pElement = 
            new(PointerContext.GetActiveState()) 
                NDR_UNMRSHL_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                  ppMemory,
                                                  pMemory,
                                                  pBufferPointer,
                                                  pFormat );
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
        }
    RpcFinally
        {
        PointerContext.EndContext();
        }
    RpcEndFinally
}

void
NdrpPointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,       // Where allocated pointer is written
    uchar *             pMemory,
    long  *             pBufferPointer, // Pointer to the wire rep.
    PFORMAT_STRING      pFormat )
{
    if ( !NdrIsLowStack( pStubMsg ) )
        {
        NdrpPointerUnmarshallInternal( 
            pStubMsg,
            ppMemory,
            pMemory,
            pBufferPointer,
            pFormat );

        return;
        }

    NdrpEnquePointerUnmarshall(
        pStubMsg,
        ppMemory,
        pMemory,
        pBufferPointer,
        pFormat );
}


unsigned char * RPC_ENTRY
NdrSimpleStructUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine description :

    Unmarshalls a simple structure.

    Used for FC_STRUCT and FC_PSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to the structure being unmarshalled.
    pFormat     - Structure's format string description.
    fMustAlloc  - TRUE if the structure must be allocate, FALSE otherwise.

--*/
{
    uchar *     pBufferSave;
    uint        StructSize;

    CORRELATION_RESOURCE_SAVE;

    // Align the buffer.
    ALIGN(pStubMsg->Buffer,pFormat[1]);

    // Increment to the struct size field.
    pFormat += 2;

    // Get struct size and increment.
    StructSize = (ulong) *((ushort * &)pFormat)++;

    // Remember the current buffer position for the struct copy later.
    pBufferSave = pStubMsg->Buffer;

    // Set BufferMark to the beginning of the struct in the buffer.
    pStubMsg->BufferMark = pBufferSave;

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + StructSize );

    // Increment Buffer past struct data.
    pStubMsg->Buffer += StructSize;

    // Initialize the memory pointer if needed.
    if ( fMustAlloc )
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, StructSize );
    else
        // we'll get rid of pStubMsg->ReuseBuffer given it's basically !IsClient now
        // we might set the flag again through compiler flag later on.
        if ( REUSE_BUFFER(pStubMsg) && ! *ppMemory )
            *ppMemory = pBufferSave;

    SET_CORRELATION_MEMORY( pBufferSave );

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    // Unmarshall embedded pointers before copying the struct.
    if ( *pFormat == FC_PP )
        {
        NdrpEmbeddedPointerUnmarshall( pStubMsg,
                                       *ppMemory,
                                       pFormat,
                                       fMustAlloc );
        }

    // Copy the struct if we're not using the rpc buffer.
    if ( *ppMemory != pBufferSave )
        {
        RpcpMemoryCopy( *ppMemory,
                        pBufferSave,
                        StructSize );
        }

    RESET_CORRELATION_MEMORY();

    return 0;
}


unsigned char * RPC_ENTRY
NdrConformantStructUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine description :

    Unmarshalls a conformant structure.

    Used for FC_CSTRUCT and FC_CPSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the structure should be unmarshalled.
    pFormat     - Structure's format string description.
    fMustAlloc  - TRUE if the structure must be allocate, FALSE otherwise.

Return :

    None.

--*/
{
    uchar *         pBufferStart;
    PFORMAT_STRING  pFormatArray;
    uint            StructSize;
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    CORRELATION_RESOURCE_SAVE;

    // Unmarshall the conformance count into the stub message.
    // Only a bogus struct can embed a conf struct; if so, ->BufferMark is set.

    if ( fIsEmbeddedStruct )
        pStubMsg->MaxCount = *((ulong *)pStubMsg->BufferMark);
    else
        {
        // Align the buffer for unmarshalling the conformance count.
        ALIGN(pStubMsg->Buffer,3);
        pStubMsg->MaxCount = *((ulong * &)pStubMsg->Buffer)++;
        }

    // Re-align the buffer
    ALIGN(pStubMsg->Buffer, pFormat[1]);

    // Increment format string to structure size field.
    pFormat += 2;

    // Get flat struct size and increment format string.
    StructSize = (ulong) *((ushort * &)pFormat)++;

    // Get the conformant array's description.
    pFormatArray = pFormat + *((signed short *)pFormat);

    CHECK_EOB_RAISE_IB( pStubMsg->Buffer + StructSize );

    if ( F_CORRELATION_CHECK )
        {
        SET_CORRELATION_MEMORY( pStubMsg->Buffer + StructSize);

        NdrpCheckCorrelation( pStubMsg,
                              pStubMsg->MaxCount,
                              pFormatArray,
                              NDR_CHECK_CONFORMANCE );
        RESET_CORRELATION_MEMORY();
        }

    // Add the size of the conformant array to the structure size.
    // check for possible mulitplication overflow attack here.
    StructSize += MultiplyWithOverflowCheck( (ulong)pStubMsg->MaxCount, *((ushort *)(pFormatArray + 2) ) );

    // Check the size and the buffer limit.
    CHECK_BOUND( (ulong)pStubMsg->MaxCount, pFormatArray[4] & 0x0f );
    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, StructSize );

    //
    // Remember where we're going to copy from.
    //
    pBufferStart = pStubMsg->Buffer;

    // Set stub message Buffer field to the end of the structure in the buffer.
    pStubMsg->Buffer += StructSize;

    // Increment pFormat past the array description
    pFormat += 2;

    // Initialize the memory pointer if needed.
    if ( fMustAlloc )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, StructSize );
        }
    else
        if ( REUSE_BUFFER(pStubMsg) && ! *ppMemory )
            *ppMemory = pBufferStart;

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    SET_CORRELATION_MEMORY( pBufferStart );

    // Unmarshall embedded pointers before copying the struct.
    if ( *pFormat == FC_PP )
        {
        //
        // Set BufferMark to the beginning of the structure in the buffer.
        //
        pStubMsg->BufferMark = pBufferStart;

        NdrpEmbeddedPointerUnmarshall( pStubMsg,
                                       *ppMemory,
                                       pFormat,
                                       fMustAlloc );
        }

    // Copy the struct if we're not using the rpc buffer.
    if ( *ppMemory != pBufferStart )
        {
        RpcpMemoryCopy( *ppMemory,
                        pBufferStart,
                        StructSize );
        }

    RESET_CORRELATION_MEMORY();

    // Set the reverse flag to signal that the array has been unmarshaled.
    if ( fIsEmbeddedStruct )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    return 0;
}


unsigned char * RPC_ENTRY
NdrConformantVaryingStructUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine description :

    Unmarshalls a structure which contains a conformant varying array.

    Used for FC_CVSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the structure should be unmarshalled.
    pFormat     - Structure's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatArray;
    uchar *         pBufferStruct;
    uchar *         pBufferArray;
    uint            StructSize, ArrayCopySize, ArrayOffset;
    ulong           AllocationSize;
    ulong           Elements;
    uchar           Alignment;
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    CORRELATION_RESOURCE_SAVE;

    IGNORED(fMustAlloc);

    // Save structure's alignment.
    Alignment = pFormat[1];

    // Increment format string to struct size field.
    pFormat += 2;

    // Get non-conformant struct size and increment format string.
    StructSize = (ulong) *((ushort * &)pFormat)++;

    // Get conformant varying array's description.
    pFormatArray = pFormat + *((signed short *)pFormat);

    AllocationSize = 0;

    // Conformant array size
    // Only a bogus struct can embed a conf struct; if so, ->BufferMark is set.

    if ( fIsEmbeddedStruct )
        Elements = *((ulong *)pStubMsg->BufferMark);
    else
        {
        // Align the buffer for conformance count unmarshalling.
        ALIGN(pStubMsg->Buffer,3);
        Elements = *((ulong * &)pStubMsg->Buffer)++;
        }

    // Check the size.
    if ( *pFormatArray == FC_CVARRAY )
        CHECK_BOUND( Elements, pFormatArray[4] & 0x0f );
    else
        if ( pFormatArray[1] == FC_STRING_SIZED )
            CHECK_BOUND( Elements, pFormatArray[2] & 0x0f );

    CHECK_EOB_RAISE_IB( pStubMsg->Buffer + StructSize );

    if ( F_CORRELATION_CHECK )
        {
        SET_CORRELATION_MEMORY( pStubMsg->Buffer + StructSize);

        NdrpCheckCorrelation( pStubMsg,
                              Elements,
                              pFormatArray,
                              NDR_CHECK_CONFORMANCE );
        RESET_CORRELATION_MEMORY();
        }

    //
    // For a conformant varying struct we ignore all allocation flags.
    // Memory must always be allocated on both client and server stubs
    // if the current memory pointer is null.
    //
    if ( ! *ppMemory )
        {
        AllocationSize = StructSize;
        ULONG ElementSize;

        if ( *pFormatArray == FC_CVARRAY )
            {
            // check for possible mulitplication overflow attack here.
            AllocationSize += MultiplyWithOverflowCheck( Elements, *((ushort *)(pFormatArray + 2)) );
            }
        else // must be a conformant string
            {
            if ( *pFormatArray != FC_C_WSTRING )
                AllocationSize += Elements;
            else
                {
                AllocationSize += MultiplyWithOverflowCheck( Elements, 2 );
                }
            }
        // do the real allocation after correlation checks.
        }

    // Align for the struct
    ALIGN(pStubMsg->Buffer,Alignment);

    // Remember where the structure starts in the buffer.
    pBufferStruct = pStubMsg->Buffer;

    // Mark the start of the structure in the buffer.
    pStubMsg->BufferMark = pStubMsg->Buffer;

    // Increment past the non-conformant part of the structure.
    //
    pStubMsg->Buffer += StructSize;

    // Align again for variance unmarshalling.
    ALIGN(pStubMsg->Buffer,3);

    //
    // Get offset and actual count.  Put the actual count into the MaxCount
    // field of the stub message, where it is used if the array has pointers.
    //
    pStubMsg->Offset = ArrayOffset = *((ulong * &)pStubMsg->Buffer)++;
    ArrayCopySize = *((ulong * &)pStubMsg->Buffer)++;
    pStubMsg->MaxCount = ArrayCopySize;

    // Check the offset and lentgth.

    if ( *pFormatArray == FC_CVARRAY )
        {
        PFORMAT_STRING  pFormatVar = pFormatArray + 8;
        CORRELATION_DESC_INCREMENT( pFormatVar );

        CHECK_BOUND( ArrayOffset,   FC_LONG );
        CHECK_BOUND( ArrayCopySize, *pFormatVar & 0x0f );

       if ( F_CORRELATION_CHECK )
           {
           SET_CORRELATION_MEMORY( pBufferStruct + StructSize );  // at the end of the fixed part

           NdrpCheckCorrelation( pStubMsg,
                              (ulong)pStubMsg->MaxCount,    // yes, this is variance from above
                              pFormatArray,
                              NDR_CHECK_VARIANCE );
           NdrpCheckCorrelation( pStubMsg,
                              pStubMsg->Offset,
                              pFormatArray,
                              NDR_CHECK_OFFSET );
           RESET_CORRELATION_MEMORY();
            }
        }
    else
        // has to be strings here. check for invalid offset
        {
        if ( ArrayOffset != 0 )
            RpcRaiseException( RPC_X_INVALID_BOUND );
        }

    if ( (Elements < (ArrayOffset + ArrayCopySize)) )
        RpcRaiseException( RPC_X_INVALID_BOUND );


    SET_CORRELATION_MEMORY( pBufferStruct );

    // Remember where the array starts in the buffer.
    pBufferArray = pStubMsg->Buffer;

    // we don't need to check overflow for length_is and first_is: 
    // if size_is doesn't overflow, and size_is > length_is+first_is, neither of them can overflow.
    if ( *pFormatArray == FC_CVARRAY )
        {
        // Skip to array element size field.
        pFormatArray += 2;

        //
        // Compute the real offset (in bytes) from the beginning of the
        // array for the copy and the real total number of bytes to copy.
        //
        ArrayOffset = MultiplyWithOverflowCheck( ArrayOffset, *((ushort *)pFormatArray) );
        ArrayCopySize = MultiplyWithOverflowCheck( ArrayCopySize, *((ushort *)pFormatArray) );
        }
    else
        {
        ulong CharSize = 1;
        // Conformant string.

        if ( *pFormatArray == FC_C_WSTRING )
            {
            // Double the offset and copy size for wide char string.
            ArrayOffset = MultiplyWithOverflowCheck( ArrayOffset, sizeof(wchar_t) );
            ArrayCopySize = MultiplyWithOverflowCheck( ArrayCopySize, sizeof(wchar_t) );
            CharSize = sizeof(wchar_t);
            }

        if ( ArrayCopySize )
            {
            uchar * p;

            // Check if the terminator is there.
            for ( p = pStubMsg->Buffer + ArrayCopySize - CharSize;  CharSize--;  )
                {
                if ( *p++ != 0 )
                    RpcRaiseException( RPC_X_INVALID_BOUND );
                }
            }
        else    // cannot be zero here.
            {
            RpcRaiseException( RPC_X_INVALID_BOUND );            
            }
            
        }

    // Set the stub message Buffer field to the end of the array/string.
    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, ArrayCopySize );
    pStubMsg->Buffer += ArrayCopySize;

    // Increment format string past offset to array description field.
    pFormat += 2;

    // allocate the memory after correlation checks. Should help avoid allocation in
    // early correlation.
    if ( AllocationSize != 0 )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, (uint) AllocationSize );
        }

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );


    //
    // Unmarshall embedded pointers before copying the struct.
    //
    if ( *pFormat == FC_PP )
        {
        pStubMsg->BufferMark = pBufferStruct;

        NdrpEmbeddedPointerUnmarshall( pStubMsg,
                                       *ppMemory,
                                       pFormat,
                                       (uchar) (AllocationSize != 0) );
        }

    RESET_CORRELATION_MEMORY();

    //
    // Copy the array.  Make sure the destination memory pointer is at
    // the proper offset from the beginning of the array in memory.
    //
    RpcpMemoryCopy( *ppMemory,
                    pBufferStruct,
                    StructSize );

    RpcpMemoryCopy( *ppMemory + StructSize + ArrayOffset,
                    pBufferArray,
                    ArrayCopySize );
    // Set the reverse flag to signal that the array has been unmarshaled.

    if ( fIsEmbeddedStruct )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    return 0;
}


#if 0
unsigned char * RPC_ENTRY
NdrHardStructUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine description :

    Unmarshalls a hard structure.

    Used for FC_HARD_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the structure should be unmarshalled.
    pFormat     - Structure's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    uchar *     pUnion;
    uchar *     pEnum;
    BOOL        fNewMemory;
    ushort      CopySize;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    pFormat += 2;

    if ( fNewMemory = (! *ppMemory || fMustAlloc) )
        {
        //
        // Allocate if forced to, or if we have a union.
        //
        if ( fMustAlloc || *((short *)&pFormat[12]) )
            *ppMemory = (uchar *) NdrAllocate( pStubMsg, *((ushort *)pFormat) );
        else // pStubMsg->ReuseBuffer assumed
            *ppMemory = pStubMsg->Buffer;
        }

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    pFormat += 8;

    CopySize = *((ushort *)pFormat);

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + CopySize );

    if ( *ppMemory != pStubMsg->Buffer )
        {
        RpcpMemoryCopy( *ppMemory,
                        pStubMsg->Buffer,
                        CopySize );
        }

    //
    // Zero out the upper two bytes of enums!
    //
    if ( *((short *)&pFormat[-2]) != (short) -1 )
        {
        pEnum = *ppMemory + *((ushort *)&pFormat[-2]);
        *((int *)(pEnum)) = *((int *)pEnum) & ((int)0x7fff) ;
        }

    pStubMsg->Buffer += *((ushort *)pFormat)++;

    //
    // See if we have a union.
    //
    if ( *((short *)&pFormat[2]) )
        {
        pUnion = *ppMemory + *((ushort *)pFormat);

        if ( fNewMemory )
            MIDL_memset( pUnion,
                         0,
                         *((ushort *)&pFormat[-10]) - *((ushort *)pFormat) );

        pFormat += 2;

        pFormat += *((short *)pFormat);

        (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                           &pUnion,
                                                           pFormat,
                                                           FALSE );
        }

    return 0;
}
#endif // 0


unsigned char * RPC_ENTRY
NdrComplexStructUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine description :

    Unmarshalls a complex structure.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the structure should be unmarshalled.
    pFormat     - Structure's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    uchar *         pBuffer;
    uchar *         pBufferMark;
    uchar *         pMemory;
    PFORMAT_STRING  pFormatPointers;
    PFORMAT_STRING  pFormatArray;
    PFORMAT_STRING  pFormatComplex;
    PFORMAT_STRING  pFormatSave;
    uint            StructSize;
    long            Alignment;
    long            Align8Mod;
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    BOOL            fOldIgnore;
    BOOL            fSetPointerBufferMark;
    BOOL            fEmbedConfStructContext;


    CORRELATION_RESOURCE_SAVE;

    IGNORED(fMustAlloc);

    pFormatSave = pFormat;

    StructSize = 0;

    // Get structure's buffer alignment.
    Alignment = pFormat[1];

    // Increment to the conformat array offset field.
    pFormat += 4;

    // Get conformant array description.
    if ( *((ushort *)pFormat) )
        pFormatArray = pFormat + *((signed short *)pFormat);
    else
        pFormatArray = 0;

    pFormat += 2;

    // Get pointer layout description.
    if ( *((ushort *)pFormat) )
        pFormatPointers = pFormat + *((ushort *)pFormat);
    else
        pFormatPointers = 0;

    pFormat += 2;

    //
    // If the stub message PointerBufferMark field is not currently set, then
    // set it to the end of the flat part of structure in the buffer.
    //
    // We do this to handle embedded pointers.
    //
    if ( fSetPointerBufferMark = ! pStubMsg->PointerBufferMark )
        {
        pBuffer = pStubMsg->Buffer;

        // Save field.
        fOldIgnore = pStubMsg->IgnoreEmbeddedPointers;

        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        // Clear MemorySize.
        pStubMsg->MemorySize = 0;

        //
        // Get a buffer pointer to where the struct's pointees will be
        // unmarshalled from and remember the flat struct size in case we
        // have to allocate.
        //

        // Note that this function will recursively do buffer overrun
        // checks, bound checks, and sanity checks on size, actual count,
        // and offset.  And further checks in this function or called functions
        // are redundant.

        StructSize = NdrComplexStructMemorySize( pStubMsg,
                                                 pFormatSave );

        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );

        // This is where any pointees begin in the buffer.
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;

        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;

        pStubMsg->Buffer = pBuffer;
        }

    if ( fMustAlloc || ! *ppMemory )
        {
        //
        // We can only get here if pStubMsg->PointerBufferMark was 0 upon
        // entry to this proc.
        //
        NDR_ASSERT( StructSize ,"Complex struct size is 0" );

        *ppMemory = (uchar*)NdrAllocate( pStubMsg, StructSize );

        //
        // Zero out all of the allocated memory so that deeply nested pointers
        // getted properly zeroed out.
        //
        MIDL_memset( *ppMemory, 0, StructSize );
        }

    // Insert the full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    //
    // Now check if there is a conformant array and mark where the conformance
    // will be unmarshalled from.
    //
    fEmbedConfStructContext = fIsEmbeddedStruct;

    if ( pFormatArray && !fIsEmbeddedStruct )
        {
        ALIGN(pStubMsg->Buffer,3);

        pStubMsg->BufferMark = pStubMsg->Buffer;

        //
        // Increment the buffer pointer 4 bytes for every dimension in the
        // conformant array.
        //
        pStubMsg->Buffer += NdrpArrayDimensions( pStubMsg, pFormatArray, FALSE ) * 4;

        if ( FixWireRepForDComVerGTE54( pStubMsg ) )
            fEmbedConfStructContext = TRUE;
        }

    // BufferMark may be set up by an outer bogus struct.
    pBufferMark = pStubMsg->BufferMark;

    // conformance count mark
    pStubMsg->BufferMark = pBufferMark;

    // Align the buffer on the struct's alignment.
    ALIGN(pStubMsg->Buffer,Alignment);

    // Get the beginning memory pointer.
    pMemory = *ppMemory;

    // Set it to the beginning of the struct.
    SET_CORRELATION_MEMORY( pMemory );

    //
    // This is used for support of structs with doubles passed on an
    // i386 stack.  The alignment of such struct's is no guaranteed to be on
    // an 8 byte boundary. Similarly, od 16 bit platforms for 4 byte align.
    //
    // A cast to long is what we need.
    Align8Mod = 0x7 & PtrToLong( pMemory );

    //
    // Unmarshall the structure member by member.
    //
    for ( ; ; pFormat++ )
        {
        switch ( *pFormat )
            {
            //
            // simple types
            //
            case FC_CHAR :
            case FC_BYTE :
            case FC_SMALL :
            case FC_WCHAR :
            case FC_SHORT :
            case FC_LONG :
#if defined(__RPC_WIN64__)
            case FC_INT3264 :
            case FC_UINT3264 :
#endif
            case FC_FLOAT :
            case FC_HYPER :
            case FC_DOUBLE :
            case FC_ENUM16 :
            case FC_ENUM32 :
                NdrSimpleTypeUnmarshall( pStubMsg,
                                         pMemory,
                                         *pFormat );

                pMemory += SIMPLE_TYPE_MEMSIZE(*pFormat);
                break;

            case FC_IGNORE :
                ALIGN(pStubMsg->Buffer,3);
                pStubMsg->Buffer += 4;
                pMemory += PTR_MEM_SIZE;
                break;

            case FC_POINTER :
                {
                uchar *         pMemorySave = NULL;
                ALIGN( pStubMsg->Buffer, 0x3 );
                long *pPointerId = (long*)pStubMsg->Buffer;
                pStubMsg->Buffer += PTR_WIRE_SIZE;

                // A sized pointer here would have an offset from the beginning of the struct.

                // for [in,out] struct containing "[size_is(num)] IFoo ** pfoo",
                // we need to setup the pStub->memory pointing to the beginning of the struct
                // such that we can get the conformance correctly during freeing pass, before
                // unmarshall the returning result to the same memory spot.
                if (FC_OP == *pFormatPointers )
                {
                    pMemorySave = pStubMsg->Memory;
                    pStubMsg->Memory = *ppMemory;
                }

                POINTER_BUFFER_SWAP_CONTEXT SwapContext(pStubMsg);

                NdrpPointerUnmarshall( pStubMsg,
                                       (uchar **)pMemory, // Where the memory pointer will be written
                                       *((uchar **)pMemory),
                                       pPointerId,        // Where the pointer in the buffer is. 
                                       pFormatPointers );  

                if (FC_OP == *pFormatPointers )
                    pStubMsg->Memory = pMemorySave;

                // Increment past the memory for the pointer.
                pMemory          += PTR_MEM_SIZE;

                pFormatPointers += 4;
                break;
                }


            //
            // Embedded complex things.
            //
            case FC_EMBEDDED_COMPLEX :
                {
                // Note, we opened a new block, so this is a different set of
                // save variables than the one on the top.
                CORRELATION_RESOURCE_SAVE;

                // Add memory padding.
                pMemory += pFormat[1];

                pFormat += 2;

                // Get the type's description.
                pFormatComplex = pFormat + *((signed short UNALIGNED *)pFormat);

                if ( FC_IP == *pFormatComplex ) 
                    {

                    // Treat like an embedded pointer except set the
                    // mark for iid_is.

                    SET_CORRELATION_MEMORY( pMemory );
                    
                    ALIGN( pStubMsg->Buffer, 0x3 );
                    long *pPointerId = (long*)pStubMsg->Buffer;
                    pStubMsg->Buffer += PTR_WIRE_SIZE;

                    POINTER_BUFFER_SWAP_CONTEXT SwapContext(pStubMsg);

                    NdrpPointerUnmarshall( pStubMsg,
                                           (uchar **)pMemory, // Where the memory pointer will be written
                                           *((uchar **)pMemory),
                                           pPointerId,        // Where the pointer in the buffer is. 
                                           pFormatComplex );  

                    pMemory          += PTR_MEM_SIZE;
                    pFormat++;
                    RESET_CORRELATION_MEMORY();

                    break;
                    }

                // A sized thingy here is relative to its position.

                SET_CORRELATION_MEMORY( pMemory );

                // Needed for an embedded conf struct.
                //
                pStubMsg->BufferMark = pBufferMark;
                if ( fEmbedConfStructContext )
                    SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

                (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormatComplex)])
                ( pStubMsg,
                  &pMemory,
                  pFormatComplex,
                  FALSE );

                pMemory = NdrpMemoryIncrement( pStubMsg,
                                               pMemory,
                                               pFormatComplex );

                RESET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

                RESET_CORRELATION_MEMORY();
                //
                // Increment the main format string one byte.  The loop
                // will increment it one more byte past the offset field.
                //
                pFormat++;
                }
                break;

            case FC_ALIGNM2 :
                ALIGN( pMemory, 0x1 );
                break;

            case FC_ALIGNM4 :
                ALIGN( pMemory, 0x3 );
                break;

            case FC_ALIGNM8 :
                //
                // We have to play some tricks for the i386 to handle the case
                // when an 8 byte aligned structure is passed by value.  The
                // alignment of the struct on the stack is not guaranteed to be
                // on an 8 byte boundary.
                //
                pMemory -= Align8Mod;
                ALIGN( pMemory, 0x7 );
                pMemory += Align8Mod;

                break;

            case FC_STRUCTPAD1 :
            case FC_STRUCTPAD2 :
            case FC_STRUCTPAD3 :
            case FC_STRUCTPAD4 :
            case FC_STRUCTPAD5 :
            case FC_STRUCTPAD6 :
            case FC_STRUCTPAD7 :
                //
                // Increment memory pointer by amount of padding.
                //
                pMemory += (*pFormat - FC_STRUCTPAD1) + 1;
                break;

            case FC_STRUCTPADN :
                // FC_STRUCTPADN 0 <unsigned short>
                pMemory += *(((unsigned short *)pFormat) + 1);
                pFormat += 3;
                break;

            case FC_PAD :
                break;

            //
            // Done with layout.
            //
            case FC_END :
                goto ComplexUnmarshallEnd;

            default :
                NDR_ASSERT(0,"NdrComplexStructUnmarshall : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return 0;
            }
        }

ComplexUnmarshallEnd:

    RESET_CORRELATION_MEMORY();

    //
    // Unmarshall conformant array if the struct has one.
    //
    if ( pFormatArray && !fIsEmbeddedStruct  &&
         ! IS_CONF_ARRAY_DONE( pStubMsg->uFlags ) )
        {
        PPRIVATE_UNMARSHALL_ROUTINE   pfnPUnmarshall;

        switch ( *pFormatArray )
            {
            case FC_CARRAY :
                pfnPUnmarshall = NdrpConformantArrayUnmarshall;
                break;

            case FC_CVARRAY :
                pfnPUnmarshall = NdrpConformantVaryingArrayUnmarshall;
                break;

            case FC_BOGUS_ARRAY :
                pfnPUnmarshall = NdrpComplexArrayUnmarshall;
                break;

            case FC_C_WSTRING :
                ALIGN( pMemory, 1 );
                // fall through

            // case FC_C_CSTRING :
            // case FC_C_BSTRING :
            // case FC_C_SSTRING :

            default :
                pfnPUnmarshall = NdrpConformantStringUnmarshall;
                break;
            }


        // Set it to the end of the non-conformant part of the struct.
        SET_CORRELATION_MEMORY( pMemory );

        //
        // Unmarshall the conformance count of the outer array dimension for
        // unidimensional arrays.
        //
        pStubMsg->MaxCount = *((ulong *)pBufferMark);

        //
        // Mark where conformace counts are in the buffer.
        //
        pStubMsg->BufferMark = pBufferMark;

        //
        // Unmarshall the array/string.  The final flag is the fMustCopy flag,
        // which must be set.
        //
        (*pfnPUnmarshall)( pStubMsg,
                           &pMemory,
                           pFormatArray,
                           TRUE,
                           FALSE );

        RESET_CORRELATION_MEMORY();
        }

    //
    // Now fix up the stub message Buffer field if we set the PointerBufferMark
    // field.
    //
    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer = pStubMsg->PointerBufferMark;

        pStubMsg->PointerBufferMark = 0;
        }

    if ( fIsEmbeddedStruct )
        SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    else
        RESET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    return 0;
}



unsigned char * RPC_ENTRY
NdrNonConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine description :

    Unmarshalls a non conformant string.

    Used for FC_CSTRING, FC_WSTRING, FC_SSTRING, and FC_BSTRING (NT Beta2
    compatability only).

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Double pointer to the string should be unmarshalled.
    pFormat     - String's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    ulong       Offset, Count, AllocSize, CharSize;

    IGNORED(fMustAlloc);

    // Align the buffer.
    ALIGN(pStubMsg->Buffer,3);

    // Get the count.
    Offset = *((ulong * &)pStubMsg->Buffer)++;
    Count = *((ulong * &)pStubMsg->Buffer)++;

    // Get total number of elements.
    AllocSize = (ulong) *((ushort *)(pFormat + 2));

    CharSize = 1;

    // Adjust count for wide char strings and stringable structs.
    // Adjust alloc size for wide char strings and stringable structs.
    switch ( *pFormat )
        {
        case FC_WSTRING :
            CharSize = 2;
            Count *= 2;
            AllocSize = MultiplyWithOverflowCheck( AllocSize , 2 );
            break;
        case FC_SSTRING :
            CharSize = pFormat[1];
            Count *= pFormat[1];
            AllocSize = MultiplyWithOverflowCheck( AllocSize, pFormat[1] );
            break;
        default :
            break;
        }

    if ( Offset != 0  ||  AllocSize < Count )
        RpcRaiseException( RPC_X_INVALID_BOUND );
    
    if ( Count )
        {
        uchar * p;

        CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, Count );

        // Check if the terminator is there.
        for ( p = pStubMsg->Buffer + Count - CharSize; CharSize--;  )
            {
            if ( *p++ != 0 )
                RpcRaiseException( RPC_X_INVALID_BOUND );
            }
        }
    else
        {
        // any MS product will generate non-zero out;
        // what about interop? will they send zero in valid case?
        RpcRaiseException( RPC_X_INVALID_BOUND );
        }

    // Allocate memory if needed.
    if ( ! *ppMemory )
        {
        *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) AllocSize );
        }

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    RpcpMemoryCopy( *ppMemory,
                    pStubMsg->Buffer,
                    (uint) Count );

    // Update buffer pointer.
    pStubMsg->Buffer += Count;

    return 0;
}


unsigned char * RPC_ENTRY
NdrConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine description :

    Unmarshalls a top level conformant string.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING
    (NT Beta2 compatability only).

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the string should be unmarshalled.
    pFormat     - String's format string description.
    fMustAlloc  - TRUE if the string must be allocated, FALSE otherwise.

Return :

    None.

--*/
{
    uchar   fMustCopy;
    ulong   MaxCount;

    if ( pStubMsg->pArrayInfo == 0 )
        {

        ulong   ActualCount, Offset;
        ulong   ElementSize;
        ulong   ConformanceType = FC_LONG;
        BOOL    fIsSized;

        // find string type
        if ( *pFormat != FC_C_SSTRING )
            {
            // Typical case: char and wchar strings

            ElementSize = (*pFormat == FC_C_WSTRING) ? 2
                                                     : 1;
            fIsSized = (pFormat[1] == FC_STRING_SIZED);
            if ( fIsSized )
                ConformanceType = (pFormat[2] & 0x0f);
            }
        else
            {
            ElementSize = pFormat[1];
            fIsSized = (pFormat[2] == FC_STRING_SIZED);
            if ( fIsSized )
                ConformanceType = (pFormat[4] & 0x0f);
            }

        // Align the buffer for conformance unmarshalling.
        ALIGN( pStubMsg->Buffer,3 );


        MaxCount = *((ulong * &)pStubMsg->Buffer)++;
        Offset   = ((ulong *)pStubMsg->Buffer)[0];
        ActualCount = ((ulong *)pStubMsg->Buffer)[1];

        CHECK_BOUND( MaxCount, ConformanceType );
        if ( (Offset != 0) ||
             (MaxCount < ActualCount) )
            RpcRaiseException( RPC_X_INVALID_BOUND );

        MultiplyWithOverflowCheck( MaxCount, ElementSize );

        CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, (ActualCount * ElementSize) + 8);

        // Defer the termination check till NdrpConformantStringUnmarshall.

        //
        // Initialize the memory pointer if needed.  If the string is sized
        // then we always malloc on the server side.
        //
        fMustAlloc = fMustAlloc || (!pStubMsg->IsClient && fIsSized);
        if ( fMustAlloc )
            {
            fMustCopy = TRUE;
            }
        else
            {
            if ( REUSE_BUFFER(pStubMsg) )
                *ppMemory = pStubMsg->Buffer + 8;
            fMustCopy = FALSE;

             // Insert full pointer to ref id translation if needed.
            if ( pStubMsg->FullPtrRefId )
                FULL_POINTER_INSERT( pStubMsg, *ppMemory );

            }
        }
    else
        {

        //
        // If this is part of a multidimensional array then we get the location
        // where the conformance is located from a special place.
        // When coming here, the StubMsg->Buffer is already behind conf sizes.
        //
        MaxCount = (pStubMsg->pArrayInfo->
                           BufferConformanceMark[pStubMsg->pArrayInfo->Dimension]);
        //
        // We must copy the string from the buffer to new memory.
        //
        fMustCopy = TRUE;

        // Since this case is called by NdrComplexArrayUnmarshall, the buffer will
        // have already been validated for buffer overruns and bound checks in
        // NdrComplexArrayMemorySize.
        // The offset and actual counts will also have been checked for sanity.
        }

    // Load up conformant size for next stage.
    pStubMsg->MaxCount = MaxCount;

    // Call the private unmarshalling routine to do the work.
    NdrpConformantStringUnmarshall( pStubMsg,
                                    ppMemory,
                                    pFormat,
                                    fMustCopy,
                                    fMustAlloc );

    return 0;
}


void
NdrpConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **             ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustCopy ,
    uchar	              fMustAlloc )
/*++

Routine description :

    Private routine for unmarshalling a conformant string.  This is the
    entry point for unmarshalling an embedded conformant strings.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING
    (NT Beta2 compatability only).

    Note this functions is only called from NdrConformantStringUnmarshall
    and NdrComplexStructUnmarshall.  NdrComplexStructUnmarshall calls
    NdrComplexStructMemSize which validates everything except correlation.
    This allows many validation checks to be skipped.  If the call is through
    NdrConformantStringUnmarshall, most of the necessary checks are in
    NdrConformantStringUnmarshall.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to where the string should be unmarshalled.
    pFormat     - String's format string description.
    fMustCopy   - TRUE if the string must be copied from the buffer to memory,
                  FALSE otherwise.

Return :

    None.

--*/
{
    ulong       Offset, Count, CharSize;
    BOOL        fIsSized;

    fIsSized = (*pFormat != FC_C_SSTRING)  ?  (pFormat[1] == FC_STRING_SIZED)
                                           :  (pFormat[2] == FC_STRING_SIZED);
    if ( fIsSized && F_CORRELATION_CHECK)
        {
        NdrpCheckCorrelation( pStubMsg,
                           (long)pStubMsg->MaxCount,
                           pFormat,
                           NDR_CHECK_CONFORMANCE );
        }

    // Align for variance unmarshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Unmarshall the string count.
    Offset = *((ulong * &)pStubMsg->Buffer)++;
    Count = *((ulong * &)pStubMsg->Buffer)++;

    // Adjust the count for a wide strings and stringable structs.
    // This is good enough for BSTRs as the mem pointer has already moved.

    switch ( *pFormat )
        {
        case FC_C_WSTRING :
            CharSize = 2;
            Count *= 2;
            break;
        case FC_C_SSTRING :
            CharSize = pFormat[1];
            Count *= pFormat[1];
            break;
        default :
            CharSize = 1;
            break;
        }

        // String must have a terminator since we computed the size
        // in marshaling with wcslen/strlen+charsize and the app has no
        // method to size a string without a terminator.
        
        if ( 0 == Count )
           {
           RpcRaiseException( RPC_X_INVALID_BOUND );
           }

    
    if ( Count )
        {
        uchar * p;
        ulong ElemSize = CharSize;

        // Check if the terminator is there.
        for ( p = pStubMsg->Buffer + Count - ElemSize;  ElemSize--;  )
            {
            if ( *p++ != 0 )
                RpcRaiseException( RPC_X_INVALID_BOUND );
            }
        }

    if ( fMustAlloc )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, pStubMsg->MaxCount * CharSize );

        // Insert full pointer to ref id translation if needed.
        if ( pStubMsg->FullPtrRefId )
            FULL_POINTER_INSERT( pStubMsg, *ppMemory );
        }


    // Copy the string if needed.
    if ( pStubMsg->IsClient || fMustCopy )
        {
        RpcpMemoryCopy( *ppMemory,
                        pStubMsg->Buffer,
                        (uint) Count );
        }

    // Update buffer pointer.
    pStubMsg->Buffer += Count;
}


unsigned char * RPC_ENTRY
NdrFixedArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a fixed array of any number of dimensions.

    Used for FC_SMFARRAY and FC_LGFARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to the array to unmarshall.
    pFormat     - Array's format string description.
    fMustAlloc  - TRUE if the array must be allocated, FALSE otherwise.

Return :

    None.

--*/
{
    uchar *     pBufferStart;
    ulong       Size;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    // Get the total array size.
    if ( *pFormat == FC_SMFARRAY )
        {
        pFormat += 2;
        Size = (ulong) *((ushort * &)pFormat)++;
        }
    else // *pFormat++ == FC_LGFARRAY
        {
        pFormat += 2;
        Size = *((ulong UNALIGNED * &)pFormat)++;
        }

    pBufferStart = pStubMsg->Buffer;

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + Size );

    // Set stub message buffer pointer past array.
    pStubMsg->Buffer += Size;

    // Initialize the memory pointer if necessary.
    if ( fMustAlloc )
        *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) Size );
    else
        if (REUSE_BUFFER(pStubMsg) && ! *ppMemory )
            *ppMemory = pBufferStart;

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    // Unmarshall embedded pointers.
    if ( *pFormat == FC_PP )
        {
        // Mark the beginning of the array in the buffer.
        pStubMsg->BufferMark = pBufferStart;

        NdrpEmbeddedPointerUnmarshall( pStubMsg,
                                       *ppMemory,
                                       pFormat,
                                       fMustAlloc );
        }

    // Copy the array if we're not using the rpc buffer to hold it.
    if ( *ppMemory != pBufferStart )
        {
        RpcpMemoryCopy( *ppMemory,
                        pBufferStart,
                        (uint) Size );
        }

    return 0;
}


unsigned char * RPC_ENTRY
NdrConformantArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a top level one dimensional conformant array.

    Used for FC_CARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to array to be unmarshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    ulong    CopySize;

    // Align the buffer for conformance unmarshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Unmarshall the conformance count.
    pStubMsg->MaxCount = *((ulong * &)pStubMsg->Buffer)++;

    CHECK_BOUND( (ulong)pStubMsg->MaxCount, pFormat[4] & 0x0f );
    CopySize = MultiplyWithOverflowCheck( (ulong)pStubMsg->MaxCount , *((ushort *)(pFormat + 2)) );

    // Buffer size checking will be done in NdrpConformantArrayUnmarshall after alignment.
    // Initialize the memory pointer if necessary.
        if (!fMustAlloc && REUSE_BUFFER(pStubMsg) && ! *ppMemory )
            {
            *ppMemory = pStubMsg->Buffer;

            //
            // Align memory pointer on an 8 byte boundary if needed.
            // We can't align the buffer pointer because we haven't made
            // the check for size_is == 0 yet.
            //
            ALIGN(*ppMemory, pFormat[1]);
            // Insert full pointer to ref id translation if needed.
            if ( pStubMsg->FullPtrRefId )
                FULL_POINTER_INSERT( pStubMsg, *ppMemory );    
            }


    NdrpConformantArrayUnmarshall( pStubMsg,
                                   ppMemory,
                                   pFormat,
                                   fMustAlloc,
                                   fMustAlloc);

    return 0;
}


void
NdrpConformantArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **             ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustCopy,
    uchar               fMustAlloc )
/*++

Routine Description :

    Private routine for unmarshalling a one dimensional conformant array.
    This is the entry point for unmarshalling an embedded conformant array.

    Used for FC_CARRAY.

    Note this functions is only called from NdrConformantArrayUnmarshall
    and NdrComplexStructUnmarshall.  NdrComplexStructUnmarshall calls
    NdrComplexStructMemSize which validates everything except correlation.
    NdrConformantArrayUnmarshall also does buffer validation.
    This allows many validation checks to be skipped.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Array being unmarshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    uchar *     pBufferStart;
    ulong       CopySize;

    // do correlation testing even if the array size is zero
    if (F_CORRELATION_CHECK )
        {
        NdrpCheckCorrelation( pStubMsg,
                           (long) pStubMsg->MaxCount,
                           pFormat,
                           NDR_CHECK_CONFORMANCE );
        }

    // Return if array size is 0 so that we don't align the buffer.
    if ( ! pStubMsg->MaxCount )
        {
        // allocate before return; shouldn't happen here.
        if ( fMustAlloc )
            {
            // Compute total array size in bytes.
            *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) 0 );
    
            // Insert full pointer to ref id translation if needed.
            if ( pStubMsg->FullPtrRefId )
                FULL_POINTER_INSERT( pStubMsg, *ppMemory );
            }
        return;
        }

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    // Compute total array size in bytes.
    CopySize = MultiplyWithOverflowCheck( (ulong)pStubMsg->MaxCount , *((ushort *)(pFormat + 2)) );

    pBufferStart = pStubMsg->Buffer;

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, CopySize);
    pStubMsg->Buffer += CopySize;

    // we need to copy the whole allocated size in conformance array
    if ( fMustAlloc )
        {
        // Compute total array size in bytes.
        *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) CopySize );

        // Insert full pointer to ref id translation if needed.
        if ( pStubMsg->FullPtrRefId )
            FULL_POINTER_INSERT( pStubMsg, *ppMemory );
        }


    // Increment the format string pointer to possible pointer layout.
    pFormat += 8;
    CORRELATION_DESC_INCREMENT( pFormat );

    // Unmarshall embedded pointers.
    if ( *pFormat == FC_PP )
        {
        // Mark the beginning of the array in the buffer.
        pStubMsg->BufferMark = pBufferStart;

        NdrpEmbeddedPointerUnmarshall( pStubMsg,
                                       *ppMemory,
                                       pFormat,
                                       fMustCopy );
        }

    // Copy the array if we're not using the rpc message buffer for it.
    if ( pStubMsg->IsClient || fMustCopy )
        {
        RpcpMemoryCopy( *ppMemory,
                        pBufferStart,
                        (uint) CopySize );
        }
}


unsigned char * RPC_ENTRY
NdrConformantVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a top level one dimensional conformant varying array.

    Used for FC_CVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to the array being unmarshalled.
    pFormat     - Array's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    ulong   ArrayElements = 0;

    // Align the buffer for conformance unmarshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Unmarshall the conformance size.
    ArrayElements = *((ulong * &)pStubMsg->Buffer)++;

        {
        ulong           Size;
        ulong           Offset, ActualCount;
        PFORMAT_STRING  pFormatVar;

        CHECK_BOUND( ArrayElements, pFormat[4] & 0x0f );

        Offset = *((ulong *)pStubMsg->Buffer);
        CHECK_BOUND( Offset, FC_LONG );

        ActualCount = *((ulong *)(pStubMsg->Buffer + 4));

        pFormatVar = pFormat + 8;
        CORRELATION_DESC_INCREMENT( pFormatVar );

        CHECK_BOUND( ActualCount, *pFormatVar & 0x0f );

        // we only need to check overflow for conformant size . we don't need
        // to check varying overflow after we check conformance overflow
        MultiplyWithOverflowCheck( ArrayElements,  *((ushort *)(pFormat + 2)) );

        Size = ActualCount * *((ushort *)(pFormat + 2));

        if ( ((long)Offset < 0) ||
             (ArrayElements < (Offset + ActualCount)) )
            RpcRaiseException( RPC_X_INVALID_BOUND );

        if ( (pStubMsg->Buffer + 8 + Size) > pStubMsg->BufferEnd )
            RpcRaiseException( RPC_X_INVALID_BOUND );
        }


    //
    // For a conformant varying array, we can't reuse the buffer
    // because it doesn't hold the total size of the array.  So
    // allocate if the current memory pointer is 0.
    //
    if ( ! *ppMemory )
        {
        fMustAlloc = TRUE;
        }
    else
        {
        fMustAlloc = FALSE;
         // Insert full pointer to ref id translation if needed.
         // do this only when not allocating memory. this will be done 
         // in p version if new memory is allocated.
        if ( pStubMsg->FullPtrRefId )
            FULL_POINTER_INSERT( pStubMsg, *ppMemory );
        }


    pStubMsg->MaxCount = ArrayElements;

    NdrpConformantVaryingArrayUnmarshall( pStubMsg,
                                          ppMemory,
                                          pFormat,
                                          fMustAlloc,
                                          fMustAlloc);

    return 0;
}


void
NdrpConformantVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **             ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustCopy,
    uchar               fMustAlloc )
/*++

Routine Description :

    Private routine for unmarshalling a one dimensional conformant varying
    array. This is the entry point for unmarshalling an embedded conformant
    varying array.

    Used for FC_CVARRAY.

    Note this functions is only called from NdrConformantVaryingArrayUnmarshall
    and NdrComplexStructUnmarshall.  NdrComplexStructUnmarshall calls
    NdrComplexStructMemSize which validates everything except correlation.
    NdrConformantVaryingArrayUnmarshall also does buffer validation.
    This allows many validation checks to be skipped.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Array being unmarshalled.
    pFormat     - Array's format string description.
    fMustCopy   - Ignored.

Return :

    None.

--*/
{
    uchar *     pBufferStart;
    ulong       CopyOffset, CopySize;
    ushort      ElemSize;

    IGNORED(fMustCopy);

    // Align the buffer for conformance unmarshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Unmarshall offset and actual count.
    pStubMsg->Offset = *((ulong * &)pStubMsg->Buffer)++;
    pStubMsg->ActualCount = *((ulong * &)pStubMsg->Buffer)++;

    if (F_CORRELATION_CHECK )
        {
        NdrpCheckCorrelation( pStubMsg,
                           (long) pStubMsg->MaxCount,
                           pFormat,
                           NDR_CHECK_CONFORMANCE );
        NdrpCheckCorrelation( pStubMsg,
                           (long) pStubMsg->ActualCount,
                           pFormat,
                           NDR_CHECK_VARIANCE );
        NdrpCheckCorrelation( pStubMsg,
                           (long) pStubMsg->Offset,
                           pFormat,
                           NDR_CHECK_OFFSET );
        }


    ElemSize = *((ushort *)(pFormat + 2));

    //
    // Return if length is 0.
    //
    if ( ! pStubMsg->ActualCount )
        {
        // needs to allocate before return. 
        if ( fMustAlloc )
            {
            *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) pStubMsg->MaxCount * ElemSize );
            // Insert full pointer to ref id translation if needed.
            if ( pStubMsg->FullPtrRefId )
                FULL_POINTER_INSERT( pStubMsg, *ppMemory );
            }
        return;
        }

    
    CopyOffset = MultiplyWithOverflowCheck(pStubMsg->Offset , ElemSize );
    CopySize = MultiplyWithOverflowCheck( pStubMsg->ActualCount , ElemSize );

    ALIGN(pStubMsg->Buffer, pFormat[1]);

    pBufferStart = pStubMsg->Buffer;

    // Increment buffer pointer past array.
    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, CopySize );
    pStubMsg->Buffer += CopySize;

    // Increment format string to possible pointer description.
    pFormat += 12;
    CORRELATION_DESC_INCREMENT( pFormat );
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( fMustAlloc )
        {
        *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) pStubMsg->MaxCount * ElemSize );
        // Insert full pointer to ref id translation if needed.
        if ( pStubMsg->FullPtrRefId )
            FULL_POINTER_INSERT( pStubMsg, *ppMemory );
        }


    // Unmarshall embedded pointers first.
    if ( *pFormat == FC_PP )
        {
        //
        // Set the MaxCount field equal to the variance count.
        // The pointer unmarshalling routine uses the MaxCount field
        // to determine the number of times an FC_VARIABLE_REPEAT
        // pointer is unmarshalled.  In the face of variance the
        // correct number of time is the actual count, not MaxCount.
        //
        pStubMsg->MaxCount = pStubMsg->ActualCount;

        //
        // Mark the location of the first transmitted array element in
        // the buffer.
        //
        pStubMsg->BufferMark = pBufferStart;

        NdrpEmbeddedPointerUnmarshall( pStubMsg,
                                       *ppMemory,
                                       pFormat,
                                       fMustCopy );
        }

    // Always copy.  Buffer reuse is not possible.
    RpcpMemoryCopy( *ppMemory + CopyOffset,
                    pBufferStart,
                    (uint) CopySize );
}


unsigned char * RPC_ENTRY
NdrVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls top level or embedded a one dimensional varying array.

    Used for FC_SMVARRAY and FC_LGVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Array being unmarshalled.
    pFormat     - Array's format string description.
    fMustAlloc  - Ignored.

--*/
{
    uchar *     pBufferStart;
    ulong       TotalSize;
    ulong       Offset, Count;
    ulong       CopyOffset, CopySize;
    ushort      ElemSize;
    uchar       fNewMemory;
    long        Elements;

    // Align the buffer for variance unmarshalling.
    ALIGN(pStubMsg->Buffer,3);

    Offset = *((ulong * &)pStubMsg->Buffer)++;
    Count = *((ulong * &)pStubMsg->Buffer)++;

    if ( ! Count )
        return 0;

    // We fish out type from the (old part of the) variance descriptor.

    CHECK_BOUND( Offset, FC_LONG);
    CHECK_BOUND( Count,
                 pFormat[(*pFormat == FC_SMVARRAY) ? 8 : 12] & 0x0f );

    Elements =
        (*pFormat == FC_SMVARRAY) ?
        *((ushort *)(pFormat + 4)) : *((ulong UNALIGNED *)(pFormat + 6));

    if ( ((long)Offset < 0 ) ||
         (Elements < (long)(Count + Offset)) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    if (F_CORRELATION_CHECK )
        {
        NdrpCheckCorrelation( pStubMsg,
                              (long)Count,
                              pFormat,
                              NDR_CHECK_VARIANCE );
        NdrpCheckCorrelation( pStubMsg,
                              (long)Offset,
                              pFormat,
                              NDR_CHECK_OFFSET );
        }

    ALIGN(pStubMsg->Buffer, pFormat[1]);

    // Get array's total size and increment to element size field.
    if ( *pFormat == FC_SMVARRAY )
        {
        TotalSize = (ulong) *((ushort *)(pFormat + 2));

        pFormat += 6;
        }
    else
        {
        TotalSize = *((ulong UNALIGNED *)(pFormat + 2));

        pFormat += 10;
        }

    if ( fNewMemory = ! *ppMemory )
        {
        *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) TotalSize );
        }

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    ElemSize = *((ushort *)pFormat);

    CopyOffset = MultiplyWithOverflowCheck( Offset, ElemSize );
    CopySize = MultiplyWithOverflowCheck( Count, ElemSize );
    
    if ( (long) CopyOffset < 0 ||
        ( TotalSize < CopyOffset + CopySize ) )
        RpcRaiseException( RPC_X_INVALID_BOUND );
    
    pBufferStart = pStubMsg->Buffer;

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, CopySize );
    pStubMsg->Buffer += CopySize;

    // Increment format string to possible pointer description.
    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );

    // Unmarshall embedded pointers.
    if ( *pFormat == FC_PP )
        {
        //
        // Set the MaxCount field equal to the variance count.
        // The pointer unmarshalling routine uses the MaxCount field
        // to determine the number of times an FC_VARIABLE_REPEAT
        // pointer is unmarshalled.  In the face of variance the
        // correct number of time is the actual count, not MaxCount.
        //
        pStubMsg->MaxCount = Count;

        //
        // Mark the location of the first transmitted array element in
        // the buffer
        //
        pStubMsg->BufferMark = pBufferStart;

        NdrpEmbeddedPointerUnmarshall( pStubMsg,
                                       *ppMemory,
                                       pFormat,
                                       fNewMemory );
        }

    RpcpMemoryCopy( *ppMemory + CopyOffset,
                    pBufferStart,
                    (uint) CopySize );

    return 0;
}


unsigned char * RPC_ENTRY
NdrComplexArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a top level complex array.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to the array being unmarshalled.
    pFormat     - Array's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    uchar *     pBuffer;
    long        ArraySize;
    BOOL        fSetPointerBufferMark;

    ArraySize = 0;

    //
    // Setting this flag means that the array is not embedded inside of
    // another complex struct or array.
    //
    fSetPointerBufferMark = ! pStubMsg->PointerBufferMark;

    if ( fSetPointerBufferMark )
        {
        BOOL            fOldIgnore;
        PFORMAT_STRING  pFormatPP;

        pBuffer = pStubMsg->Buffer;

        fOldIgnore = pStubMsg->IgnoreEmbeddedPointers;

        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        pStubMsg->MemorySize = 0;

        //
        // Get a buffer pointer to where the arrays's pointees will be
        // unmarshalled from and remember the array size in case we
        // have to allocate.
        //

        // Note this function will recursively check buffer overflows,
        // bounds, and trial sanity checks on array offsets, sizes,
        // and actual counts.  This make additional checks in this
        // function redundant.

        ArraySize = NdrComplexArrayMemorySize( pStubMsg,
                                               pFormat );

        // at least we are not out of bound in flat part. not really necessary
        // but good to have.
        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );
        //
        // PointerBufferaMark is where the pointees begin in the buffer.
        // If this is an array of ref pointers then we don't want to set
        // this, all we wanted was the array size.
        //

        pFormatPP = pFormat + 12;
        CORRELATION_DESC_INCREMENT( pFormatPP );
        CORRELATION_DESC_INCREMENT( pFormatPP );

        if ( *pFormatPP != FC_RP )
            {
            pStubMsg->PointerBufferMark = pStubMsg->Buffer;
            }
        else
            fSetPointerBufferMark = FALSE;

        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;

        pStubMsg->Buffer = pBuffer;
        }

    if ( fMustAlloc || ! *ppMemory )
        {
        *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) ArraySize );

        //
        // Zero out the memory of the array if we allocated it, to insure
        // that all embedded pointers are zeroed out.  Blech.
        //
        MIDL_memset( *ppMemory, 0, (uint) ArraySize );
        }


    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    //
    // Check for a conformance description.
    //
    if ( ( *((long UNALIGNED *)(pFormat + 4)) != 0xffffffff ) &&
         ( pStubMsg->pArrayInfo == 0 ) )
        {
        //
        // The outer most array dimension sets the conformance marker.
        //

        ALIGN(pStubMsg->Buffer,0x3);

        // Mark where the conformance count(s) will be unmarshalled from.
        pStubMsg->BufferMark = pStubMsg->Buffer;

        // Increment past conformance count(s).
        pStubMsg->Buffer += NdrpArrayDimensions( pStubMsg, pFormat, FALSE ) * 4;

        }

    NdrpComplexArrayUnmarshall( pStubMsg,
                                ppMemory,
                                pFormat,
                                TRUE,
                                FALSE );

    if ( fSetPointerBufferMark )
        {
        //
        // This will set the buffer pointer to end of all of the array's
        // unmarshalled data in the buffer.
        //
        pStubMsg->Buffer = pStubMsg->PointerBufferMark;

        pStubMsg->PointerBufferMark = 0;
        }

    return 0;
}


void
NdrpComplexArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **             ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustCopy,
    uchar               fMustAlloc )
/*++

Routine Description :

    Private routine for unmarshalling a complex array.  This is the entry
    point for unmarshalling an embedded complex array.

    Used for FC_BOGUS_ARRAY.

    Note this functions is only called from NdrComplexArrayUnmarshall
    and NdrComplexStructUnmarshall.  NdrComplexStructUnmarshall calls
    NdrComplexStructMemSize which validates everything except correlation.
    MdrComplexArrayUnmarshall has a similar check.
    This allows many validation checks to be skipped.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to the array being unmarshalled.
    pFormat     - Array's format string description.
    fMustCopy   - Ignored.

Return :

    None.

--*/
{
    ARRAY_INFO              ArrayInfo;
    PARRAY_INFO             pArrayInfo;
    PUNMARSHALL_ROUTINE     pfnUnmarshall;
    PFORMAT_STRING          pFormatSave;
    ulong                   Elements;
    ulong                   Offset, Count;
    ulong                   MemoryElementSize;
    long                    Dimension;
    uchar                   Alignment;
    bool                    UseBrokenInterfacePointer = false;

    // this is called from ComplexStruct & ComplexArray, and in either case, we
    // cann't prevent allocation before correlation check. These are "can't solve"
    // scenarios.
    uchar *                pMemory = *ppMemory;

    //
    // Setup if we are the outer dimension.  All this is for multidimensional
    // array support.  If we didn't have to worry about Beta2 stub
    // compatability we could this much better.
    //
    if ( ! pStubMsg->pArrayInfo )
        {
        pStubMsg->pArrayInfo = &ArrayInfo;

        ArrayInfo.Dimension = 0;
        ArrayInfo.BufferConformanceMark = (unsigned long *)pStubMsg->BufferMark;
        ArrayInfo.BufferVarianceMark = 0;
        }

    pFormatSave = pFormat;

    pArrayInfo = pStubMsg->pArrayInfo;

    Dimension = pArrayInfo->Dimension;

    Alignment = pFormat[1];

    pFormat += 2;

    // This is 0 if the array has conformance.
    Elements = *((ushort * &)pFormat)++;

    //
    // Check for conformance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        Elements = pArrayInfo->BufferConformanceMark[Dimension];
        if ( F_CORRELATION_CHECK )
            {
            NdrpCheckCorrelation( pStubMsg,
                               Elements,
                               pFormatSave,
                               NDR_CHECK_CONFORMANCE );
            }
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    //
    // Check for variance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        if ( Dimension == 0 )
            {
            ulong   VarianceSize;

            ALIGN(pStubMsg->Buffer,0x3);

            // Mark where the variance counts are.
            pArrayInfo->BufferVarianceMark = (unsigned long *)pStubMsg->Buffer;

            // Handle multidimensional arrays.
            VarianceSize =  NdrpArrayDimensions( pStubMsg, pFormatSave, TRUE ) * 8;

            pStubMsg->Buffer += VarianceSize;
            }

        Offset = pArrayInfo->BufferVarianceMark[Dimension * 2];
        Count = pArrayInfo->BufferVarianceMark[(Dimension * 2) + 1];
        if ( F_CORRELATION_CHECK )
            {
            NdrpCheckCorrelation( pStubMsg,
                               Offset,
                               pFormatSave,
                               NDR_CHECK_OFFSET );
            NdrpCheckCorrelation( pStubMsg,
                       Count,
                       pFormatSave,
                       NDR_CHECK_VARIANCE );
            }
        }
    else
        {
        Offset = 0;
        Count = Elements;
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( ! Count )
        goto ComplexArrayUnmarshallEnd;

    ALIGN(pStubMsg->Buffer,Alignment);

    switch ( *pFormat )
        {
        case FC_EMBEDDED_COMPLEX :
            pFormat += 2;
            pFormat += *((signed short *)pFormat);

            if ( *pFormat == FC_IP )
                goto HandleInterfacePointer;

            pfnUnmarshall = pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormat)];

            pArrayInfo->Dimension = Dimension + 1;
            pArrayInfo->MaxCountArray = pArrayInfo->BufferConformanceMark;

            MemoryElementSize = (ulong) ( NdrpMemoryIncrement( pStubMsg,
                                                               pMemory,
                                                               pFormat ) - pMemory );

            pArrayInfo->MaxCountArray = 0;
            break;

        // note : midl doesn't seems to generate FC_OP in here, so we don't want
        // to change it for now. but there is potential bug here that pStubMsg->Memory
        // is not set and NdrPointerFree might fail if FC_OP points to a conformance
        // struct/array.
        case FC_RP :
        case FC_UP :
        case FC_FP :
        case FC_OP :
            pfnUnmarshall = (PUNMARSHALL_ROUTINE) NdrpPointerUnmarshall;

            // Need this in case we have a variant offset.
            MemoryElementSize = PTR_MEM_SIZE;
            break;

        case FC_IP :
HandleInterfacePointer:
            
            UseBrokenInterfacePointer = !FixWireRepForDComVerGTE54( pStubMsg );
            // Probably this code is not used, as for arrays of IPs the compiler
            // (as of ver. 5.1.+) generates array of embedded complex.
            //
            pfnUnmarshall = (PUNMARSHALL_ROUTINE)NdrpPointerUnmarshall;

            // Need this in case we have a variant offset.
            MemoryElementSize = PTR_MEM_SIZE;
            break;

        case FC_ENUM16 :
            pfnUnmarshall = 0;
            MemoryElementSize = sizeof(int);
            break;

#if defined(__RPC_WIN64__)
        case FC_INT3264:
        case FC_UINT3264:
            pfnUnmarshall = 0;
            MemoryElementSize = sizeof(__int64);
            break;
#endif

        case FC_RANGE:
            pfnUnmarshall = NdrRangeUnmarshall;
            MemoryElementSize = SIMPLE_TYPE_MEMSIZE( pFormat[1] );
            break;
        default :
            NDR_ASSERT( IS_SIMPLE_TYPE(*pFormat),
                        "NdrpComplexArrayUnmarshall : bad format char" );

            Count = MultiplyWithOverflowCheck( Count, SIMPLE_TYPE_BUFSIZE(*pFormat) );

            pMemory += MultiplyWithOverflowCheck( Offset , SIMPLE_TYPE_MEMSIZE(*pFormat) );

            RpcpMemoryCopy( pMemory,
                            pStubMsg->Buffer,
                            (uint) Count );

            pStubMsg->Buffer += Count;

            goto ComplexArrayUnmarshallEnd;
        }

    //
    // If there is variance then increment the memory pointer to the first
    // element actually being marshalled.
    //
    if ( Offset )
        pMemory += MultiplyWithOverflowCheck( Offset , MemoryElementSize );

    //
    // Check for an array of enum16 or int3264.
    //
    if ( ! pfnUnmarshall )
        {
      #if defined(__RPC_WIN64__)
        if ( *pFormat != FC_ENUM16 )
            {
            // int3264

            if ( *pFormat == FC_INT3264 )
                {
                for ( ; Count--; )
                    *((INT64 * &)pMemory)++ = *((long * &)pStubMsg->Buffer)++;
                }
            else
                {
                for ( ; Count--; )
                    *((UINT64 * &)pMemory)++ = *((ulong * &)pStubMsg->Buffer)++;
                }
            }
        else
      #endif
            {
            for ( ; Count--; )
                {
                // Cast to ushort since we don't want to sign extend.
                *((int * &)pMemory)++ = (int) *((ushort * &)pStubMsg->Buffer)++;
                }
            }

        goto ComplexArrayUnmarshallEnd;
        } // !pfnUnmarshall

    //
    // Array of pointers.
    //
    if ( (pfnUnmarshall == (PUNMARSHALL_ROUTINE) NdrpPointerUnmarshall) )
        {

        // If the broken interface pointer is used,
        // the pointer will not show up in the flat part
        // but in the pointee.
        if ( UseBrokenInterfacePointer )
            {
            pStubMsg->pArrayInfo = 0;
            SET_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags );

            POINTER_BUFFER_SWAP_CONTEXT SwapContext( pStubMsg );

            for ( ; Count--; )
                {
                
                NdrpPointerUnmarshall( 
                    pStubMsg,
                    (uchar **)pMemory,
                    *((uchar **)pMemory),
                    NULL,
                    pFormat );
                pMemory += PTR_MEM_SIZE;
                }

            RESET_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags );
            }
        else
            {
            long *pBufferPtr;
            ulong DoPtrWireInc;

            if ( *pFormat != FC_RP )
                {
                pBufferPtr = (long*)pStubMsg->Buffer;
                pStubMsg->Buffer += MultiplyWithOverflowCheck( PTR_WIRE_SIZE , Count );
                DoPtrWireInc = 1;
                }
            else 
                {
                pBufferPtr = 0;
                DoPtrWireInc = 0;
                }

            pStubMsg->pArrayInfo = 0;

            POINTER_BUFFER_SWAP_CONTEXT SwapContext( pStubMsg );

            for ( ; Count--; )
                {

                NdrpPointerUnmarshall( 
                    pStubMsg,
                    (uchar **)pMemory,
                    *((uchar **)pMemory),
                    pBufferPtr,
                    pFormat );

                pBufferPtr += DoPtrWireInc;
                pMemory += PTR_MEM_SIZE;
                }

            }

        goto ComplexArrayUnmarshallEnd;
        }

    //
    // Unmarshall the complex array elements.
    //

    if ( ! IS_ARRAY_OR_STRING(*pFormat) )
        pStubMsg->pArrayInfo = 0;

    for ( ; Count--; )
        {
        // Keep track of multidimensional array dimension.
        if ( IS_ARRAY_OR_STRING(*pFormat) )
            pArrayInfo->Dimension = Dimension + 1;

        (*pfnUnmarshall)( pStubMsg,
                          &pMemory,
                          pFormat,
                          FALSE );

        // Increment the memory pointer by the element size.
        pMemory += MemoryElementSize;
        }

ComplexArrayUnmarshallEnd:

    // pArrayInfo must be zero when not valid.
    pStubMsg->pArrayInfo = (Dimension == 0) ? 0 : pArrayInfo;
}


unsigned char * RPC_ENTRY
NdrEncapsulatedUnionUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls an encapsulated array.

    Used for FC_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the union should be unmarshalled.
    pFormat     - Union's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    uchar *     pBuffer;
    uchar *     pUnion;
    uchar       SwitchType;

    IGNORED(fMustAlloc);

    NO_CORRELATION;

    //
    // Since we can never use the buffer to hold a union we simply have
    // to check the current memory pointer to see if memory must be allocated.
    //
    // The memory size of an encapsulated union is the union size plus
    // the memory needed for the switch_is member (including any padding
    // for alignment).
    //
    if ( ! *ppMemory )
        {
        uint   Size;

        Size = *((ushort *)(pFormat + 2)) + HIGH_NIBBLE(pFormat[1]);

        *ppMemory = (uchar*)NdrAllocate( pStubMsg, Size );

        //
        // We must zero out all of the new memory in case there are pointers
        // in any of the arms.
        //
        MIDL_memset( *ppMemory, 0, Size );
        }

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    SwitchType = LOW_NIBBLE(pFormat[1]);

    pBuffer = pStubMsg->Buffer;

    //
    // Unmarshall the switch_is field into memory.
    //
    NdrSimpleTypeUnmarshall( pStubMsg,
                             *ppMemory,
                             SwitchType );

    //
    // The above call incremented the buffer pointer.  Set it back to before
    // the switch is value in the buffer.
    //
    pStubMsg->Buffer = pBuffer;

    // Get a memory pointer to the union.
    pUnion = *ppMemory + HIGH_NIBBLE(pFormat[1]);

    NdrpUnionUnmarshall( pStubMsg,
                         &pUnion,
                         pFormat + 2,
                         SwitchType,
                         0 );   // Encapsulated union

    return 0;
}


unsigned char * RPC_ENTRY
NdrNonEncapsulatedUnionUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a non encapsulated array.

    Used for FC_NON_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the union should be unmarshalled.
    pFormat     - Union's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    uchar               SwitchType;
    PFORMAT_STRING      pFormatSave = pFormat;

    IGNORED(fMustAlloc);

    SwitchType = pFormat[1];

    //
    // Get the memory size and arm description part of the format string
    // description.
    //
    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );
    pFormat += *((signed short *)pFormat);

    //
    // Since we can never use the buffer to hold a union we simply have
    // to check the current memory pointer to see if memory must be allocated.
    //
    if ( fMustAlloc || ! *ppMemory )
        {
        uint   Size;

        Size = *((ushort *)pFormat);

        *ppMemory = (uchar*)NdrAllocate( pStubMsg, Size );

        //
        // We must zero out all of the new memory in case there are pointers
        // in any of the arms.
        //
        MIDL_memset( *ppMemory, 0, Size );
        }

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    NdrpUnionUnmarshall( pStubMsg,
                         ppMemory,
                         pFormat,
                         SwitchType,
                         pFormatSave );

    return 0;
}


void
NdrpUnionUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               SwitchType,
    PFORMAT_STRING      pFormatNonEncUnion
    )
/*++

Routine description :

    Private routine for unmarshalling a union.  This routine is shared for
    both encapsulated and non-encapsulated unions and handles the actual
    unmarshalling of the proper union arm.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the union should be unmarshalled.
    pFormat     - Union's format string description.
    SwitchType  - Union's switch type.

Return :

    None.

--*/
{
    long        SwitchIs;
    long        Arms;
    uchar       Alignment;

    //
    // Unmarshall the switch is.  We have to do it inline here so that a
    // switch_is which is negative will be properly sign extended.
    //
    switch ( SwitchType )
        {
        case FC_SMALL :
        case FC_CHAR :
            SwitchIs = (long) *((char * &)pStubMsg->Buffer)++;
            break;
        case FC_USMALL :
            SwitchIs = (long) *((uchar * &)pStubMsg->Buffer)++;
            break;
        case FC_SHORT :
        case FC_ENUM16 :
            ALIGN(pStubMsg->Buffer,1);
            SwitchIs = (long) *((short * &)pStubMsg->Buffer)++;
            break;
        case FC_USHORT :
        case FC_WCHAR :
            ALIGN(pStubMsg->Buffer,1);
            SwitchIs = (long) *((ushort * &)pStubMsg->Buffer)++;
            break;
        case FC_LONG :
        case FC_ULONG :
        case FC_ENUM32 :
          // FC_INT3264 gets mapped to FC_LONG.
            ALIGN(pStubMsg->Buffer,3);
            SwitchIs = *((long * &)pStubMsg->Buffer)++;
            break;
        default :
            NDR_ASSERT(0,"NdrpUnionUnmarshall : Illegal union switch_type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    if ( pFormatNonEncUnion )
        {
        if ( F_CORRELATION_CHECK )
            {
            // Unions offset in the switch_is correlation descriptor is relative
            // to the union position itself, not to the beginning of the struct.
            // This is set properly at the complex struct level.

            NdrpCheckCorrelation( pStubMsg,
                                  SwitchIs,
                                  pFormatNonEncUnion,
                                  NDR_CHECK_CONFORMANCE );
            }
        }

    // Skip the memory size field.
    pFormat += 2;

    //
    // We're at the union_arms<2> field now, which contains both the
    // Microsoft union aligment value and the number of union arms.
    //

    //
    // Get the union alignment (0 if this is a DCE union).  Get your gun.
    //
    Alignment = (uchar) ( *((ushort *)pFormat) >> 12 );

    ALIGN(pStubMsg->Buffer,Alignment);

    //
    // Number of arms is the lower 12 bits.  Ok shoot me.
    //
    Arms = (long) ( *((ushort * &)pFormat)++ & 0x0fff);

    //
    // Search for union arm.
    //
    for ( ; Arms; Arms-- )
        {
        if ( *((long UNALIGNED * &)pFormat)++ == SwitchIs )
            {
            //
            // Found the right arm, break out.
            //
            break;
            }

        // Else increment format string.
        pFormat += 2;
        }

    //
    // Check if we took the default arm and no default arm is specified.
    //
    if ( ! Arms && (*((ushort *)pFormat) == (ushort) 0xffff) )
        {
        RpcRaiseException( RPC_S_INVALID_TAG );
        }

    //
    // Return if the arm is empty.
    //
    if ( ! *((ushort *)pFormat) )
        return;

    // check we aren't EOB after unmarshalling arm selector
    // not really necessary ( we shouldn't overwrite buffer in union) but we shouldn't
    // go further if it failes here.
    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );    

    //
    // Get the arm's description.
    //
    // We need a real solution after beta for simple type arms.  This could
    // break if we have a format string larger than about 32K.
    //
    if ( IS_MAGIC_UNION_BYTE(pFormat) )
        {
        // we could read pass the end of buffer, but won't corrupt memory
        // here. We always allocate memory for union in the server side. 
        NdrSimpleTypeUnmarshall( pStubMsg,
                                 *ppMemory,
                                 pFormat[0] );
        return;
        }

    pFormat += *((signed short *)pFormat);

    //
    // Determine the double memory pointer that we pass to the arm's
    // unmarshalling routine.
    // If the union arm we take is a pointer, we have to dereference the
    // current memory pointer since we're passed the pointer to a pointer
    // to the union (regardless of whether the actual parameter was a by-value
    // union or a pointer to a union).
    //
    // We also have to do a bunch of other special stuff to handle unions
    // embedded inside of strutures.
    //
    if ( IS_POINTER_TYPE(*pFormat) )
        {
        ppMemory = (uchar **) *ppMemory;

       //
       // If we're embedded in a struct or array we have do some extra stuff.
       //
       if ( pStubMsg->PointerBufferMark )
            {
            
            ALIGN(pStubMsg->Buffer,3);
            long *pPointerId = (long*)pStubMsg->Buffer;
            pStubMsg->Buffer += PTR_WIRE_SIZE;

            POINTER_BUFFER_SWAP_CONTEXT SwapContext( pStubMsg );

            NdrpPointerUnmarshall( pStubMsg,
                                   ppMemory,
                                   *((uchar **)ppMemory),
                                   pPointerId,
                                   pFormat );

            return;
            }
        }

    //
    // Union arm of a non-simple type.
    //
    (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormat)])
    ( pStubMsg,
      ppMemory,
      pFormat,
      FALSE );
}



unsigned char * RPC_ENTRY
NdrByteCountPointerUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a pointer with the byte count attribute applied to it.

    Used for FC_BYTE_COUNT_POINTER.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the byte count pointer should be
                  unmarshalled.
    pFormat     - Byte count pointer's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatComplex;
    long            ByteCount;
    long            DataSize;

    ByteCount = (ulong) NdrpComputeConformance( pStubMsg,
                                                NULL,
                                                pFormat );

    pFormatComplex = pFormat + 6;
    CORRELATION_DESC_INCREMENT( pFormatComplex );
    pFormatComplex += *((signed short *)pFormatComplex);

    //
    // Determine incoming data size.
    //
    if ( pFormat[1] != FC_PAD )
        {
        DataSize = SIMPLE_TYPE_MEMSIZE(pFormat[1]);
        }
    else
        {
        uchar *     pBuffer;

        pBuffer = pStubMsg->Buffer;

        pStubMsg->MemorySize = 0;

        //
        // This will give us the allocate(all_nodes) size of the data.
        //
        DataSize = (*pfnMemSizeRoutines[ROUTINE_INDEX(*pFormatComplex)])
                   ( pStubMsg,
                     pFormatComplex );

        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );

        pStubMsg->Buffer = pBuffer;
        }

    if ( DataSize > ByteCount )
        RpcRaiseException( RPC_X_BYTE_COUNT_TOO_SMALL );

    //
    // Now make things look like we're handling an allocate all nodes.
    //
    NDR_ALLOC_ALL_NODES_CONTEXT AllocContext;
    AllocContext.AllocAllNodesMemory = *ppMemory;
    AllocContext.AllocAllNodesMemoryBegin = *ppMemory;
    AllocContext.AllocAllNodesMemoryEnd = *ppMemory + ByteCount;
    pStubMsg->pAllocAllNodesContext = &AllocContext;

    //
    // Now unmarshall.
    //
    if ( pFormat[1] != FC_PAD )
        {
        ALIGN(pStubMsg->Buffer,SIMPLE_TYPE_ALIGNMENT(pFormat[1]));

        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + SIMPLE_TYPE_BUFSIZE(pFormat[1]) );
        
        NdrSimpleTypeUnmarshall( pStubMsg,
                                 *ppMemory,
                                 pFormat[1] );
        }
    else
        {
        (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormatComplex)])
        ( pStubMsg,
          ppMemory,
          pFormatComplex,
          TRUE );
        }

    pStubMsg->pAllocAllNodesContext = 0;

    return 0;
}


unsigned char * RPC_ENTRY
NdrpXmitOrRepAsPtrUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a transmit as (or represent as) object given by pointers.
    (FC_TRANSMIT_AS_PTR or FC_REPRESENT_AS_PTR)

    See NdrXmitOrRepAsUnmarshall for more detals.

Arguments :

    pStubMsg    - a pointer to the stub message
    ppMemory    - pointer to the presented type where to put data
    pFormat     - format string description
    fMustAlloc  - allocate flag

Note.
    fMustAlloc is ignored as we always allocate outside of the buffer.

--*/
{
    unsigned char *          pTransmittedType;
    unsigned char  *         pPresentedType = *ppMemory;
    BOOL                     fMustFreeXmit = FALSE;
    const XMIT_ROUTINE_QUINTUPLE * pQuintuple = pStubMsg->StubDesc->aXmitQuintuple;
    unsigned short           QIndex;
    unsigned long            PresentedTypeSize;
    uchar *                  PointerBufferMarkSave;
    void *                   XmitTypePtr = 0;
    void *                   pMemoryListSave;
    (void)                   fMustAlloc;

    // Fetch the QuintupleIndex.

    QIndex = *(unsigned short *)(pFormat + 2);
    PresentedTypeSize = *(unsigned short *)(pFormat + 4);

    if ( ! pPresentedType )
        {
        //Allocate a presented type object first.

        pPresentedType = (uchar*)NdrAllocate( pStubMsg, (uint) PresentedTypeSize );
        MIDL_memset( pPresentedType, 0, (uint) PresentedTypeSize );
        }

    // Allocate the transmitted object outside of the buffer
    // and unmarshall into it

    pFormat += 8;
    pFormat = pFormat + *(short *)pFormat;

    // Save the current state of the memory list so that the temporary
    // memory allocated for the transmitted type can be easily removed
    // from the list.   This assumes that the memory allocated here 
    // will not have any pointers to other blocks of memory.   This is true
    // as long as full pointers are not used.  The current compiler does 
    // not support full pointers, so this in not a problem.
   
    pMemoryListSave = pStubMsg->pMemoryList;

    pTransmittedType = NULL;  // asking the engine to allocate

    // only when ptr is ref: make it look like UP.

    if ( *pFormat == FC_RP )
        pTransmittedType = (uchar *)& XmitTypePtr;
    
    {
        uchar *PointerBufferMarkSave = pStubMsg->PointerBufferMark;
        pStubMsg->PointerBufferMark = 0;
        NDR_POINTER_QUEUE *pOldQueue = NULL;

        // Set the current queue to NULL so that all pointees will be
        // queued and unmarshalled together
        if ( pStubMsg->pPointerQueueState )
            {
            pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
            pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
            }

        RpcTryFinally
            {
            (*pfnUnmarshallRoutines[ ROUTINE_INDEX( *pFormat )])
                   ( pStubMsg,
                     & pTransmittedType,
                     pFormat,
                     TRUE );
            }
        RpcFinally
            {
            pStubMsg->PointerBufferMark = PointerBufferMarkSave;
            
            if ( pStubMsg->pPointerQueueState )
                {
                pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
                }
            }
        RpcEndFinally

    }

    // Translate from the transmitted type into the presented type.

    pStubMsg->pTransmitType = (uchar *)& pTransmittedType;
    pStubMsg->pPresentedType = pPresentedType;

    pQuintuple[ QIndex ].pfnTranslateFromXmit( pStubMsg );

    *ppMemory = pStubMsg->pPresentedType;

    // Free the transmitted object (it was allocated by the engine)
    // and its pointees. The call through the table frees the pointees
    // plus it frees the object itself as it is a pointer.

    // Remove the memory that will be freed from the allocated memory
    // list by restoring the memory list pointer.
    // If an exception occures during one of these free routines, we 
    // are in trouble anyway.
        
    pStubMsg->pMemoryList = pMemoryListSave;

    {
        uchar *PointerBufferMarkSave = pStubMsg->PointerBufferMark;
        pStubMsg->PointerBufferMark = 0;
        NDR_POINTER_QUEUE *pOldQueue = NULL;

        // Set the current queue to NULL so that all pointees will be
        // queued and freed together
        if ( pStubMsg->pPointerQueueState )
            {
            pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
            pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
            }

        RpcTryFinally
            {
            (*pfnFreeRoutines[ ROUTINE_INDEX( *pFormat )])( pStubMsg,
                                                            pTransmittedType,
                                                            pFormat );
            }
        RpcFinally
            {
            pStubMsg->PointerBufferMark = PointerBufferMarkSave;
            if ( pStubMsg->pPointerQueueState )
                {
                pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
                }
            }
        RpcEndFinally

    }

    return 0;
}

unsigned char * RPC_ENTRY
NdrXmitOrRepAsUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a transmit as (or represent as)object.

    Means:  allocate the transmitted object,
            unmarshall transmitted object,
            translate the transmitted into presented
            free the transmitted.

    See mrshl.c for the description of the FC layout.

Arguments :

    pStubMsg    - a pointer to the stub message
    ppMemory    - pointer to the presented type where to put data
    pFormat     - format string description
    fMustAlloc  - allocate flag

Note.
    fMustAlloc is ignored as we always allocate outside of the buffer.

--*/
{
    unsigned char *          pTransmittedType;
    unsigned char  *         pPresentedType = *ppMemory;
    __int64                  SimpleTypeValueBuffer[2];
    const XMIT_ROUTINE_QUINTUPLE * pQuintuple = pStubMsg->StubDesc->aXmitQuintuple;
    unsigned short           QIndex;
    unsigned long            PresentedTypeSize;
    uchar *                  PointerBufferMarkSave;
    BOOL                     fXmitByPtr = *pFormat == FC_TRANSMIT_AS_PTR ||
                                          *pFormat == FC_REPRESENT_AS_PTR;
    (void)                   fMustAlloc;

    if ( fXmitByPtr )
        {
        NdrpXmitOrRepAsPtrUnmarshall( pStubMsg,
                                      ppMemory,
                                      pFormat,
                                      fMustAlloc );
        return 0;
        }

    // Fetch the QuintupleIndex.

    QIndex = *(unsigned short *)(pFormat + 2);
    PresentedTypeSize = *(unsigned short *)(pFormat + 4);

    if ( ! pPresentedType )
        {
        //Allocate a presented type object first.

        pPresentedType = (uchar*)NdrAllocate( pStubMsg, (uint) PresentedTypeSize );
        MIDL_memset( pPresentedType, 0, (uint) PresentedTypeSize );
        }

    // Allocate the transmitted object outside of the buffer
    // and unmarshall into it

    pFormat += 8;
    pFormat = pFormat + *(short *)pFormat;

    if ( IS_SIMPLE_TYPE( *pFormat ))
        {
        pTransmittedType = (unsigned char *)SimpleTypeValueBuffer;
        
        NdrSimpleTypeUnmarshall( pStubMsg,
                                 pTransmittedType,
                                *pFormat );
        
        // Translate from the transmitted type into the presented type.

        pStubMsg->pTransmitType = pTransmittedType;
        pStubMsg->pPresentedType = pPresentedType;

        pQuintuple[ QIndex ].pfnTranslateFromXmit( pStubMsg );

        *ppMemory = pStubMsg->pPresentedType;
        }
    else
        {

        // Save the current state of the memory list so that the temporary
        // memory allocated for the transmitted type can be easily removed
        // from the list.   This assumes that the memory allocated here 
        // will not have any linkes to other blocks of memory.   This is true
        // as long as full pointers are not used.  Fortunatly, full pointers
        // do not work correctly in the current code.
   
        void *pMemoryListSave = pStubMsg->pMemoryList;        
    
        {
            uchar *PointerBufferMarkSave = pStubMsg->PointerBufferMark;
            pStubMsg->PointerBufferMark = 0;
            NDR_POINTER_QUEUE *pOldQueue = NULL;

            // Set the current queue to NULL so that all pointees will be
            // queued and unmarshalled together
            if ( pStubMsg->pPointerQueueState )
                {
                pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
                pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
                }

            pTransmittedType = NULL; //asking the engine to allocate

            RpcTryFinally
                {
                (*pfnUnmarshallRoutines[ ROUTINE_INDEX( *pFormat )])
                       ( pStubMsg,
                         & pTransmittedType,
                         pFormat,
                         TRUE );
                }
            RpcFinally
                {
                pStubMsg->PointerBufferMark = PointerBufferMarkSave;
                if ( pStubMsg->pPointerQueueState )
                    {
                    pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
                    }
                }
            RpcEndFinally

        }

        // Translate from the transmitted type into the presented type.
    
        pStubMsg->pTransmitType = pTransmittedType;
        pStubMsg->pPresentedType = pPresentedType;
    
        pQuintuple[ QIndex ].pfnTranslateFromXmit( pStubMsg );
    
        *ppMemory = pStubMsg->pPresentedType;

        // Free the transmitted object (it was allocated by the engine)
        // and its pointees. The call through the table frees the pointees
        // only (plus it'd free the object itself if it were a pointer).
        // As the transmitted type is not a pointer here, we need to free it
        // explicitely later.

        // Remove the memory that will be freed from the allocated memory
        // list by restoring the memory list pointer.
        // If an exception occures during one of these free routines, we 
        // are in trouble anyway.
        
        pStubMsg->pMemoryList = pMemoryListSave;        

        {        
            uchar *PointerBufferMarkSave = pStubMsg->PointerBufferMark;
            pStubMsg->PointerBufferMark = 0;
            NDR_POINTER_QUEUE *pOldQueue = NULL;

            // Set the current queue to NULL so that all pointees will be
            // queued and freed together
            if ( pStubMsg->pPointerQueueState )
                {
                pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
                pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
                }

            RpcTryFinally
                {
                (*pfnFreeRoutines[ ROUTINE_INDEX( *pFormat )])( pStubMsg,
                                                                pTransmittedType,
                                                                pFormat );
                }
            RpcFinally
                {
                pStubMsg->PointerBufferMark = PointerBufferMarkSave;
                if ( pStubMsg->pPointerQueueState )
                    {
                    pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
                    }
                }
            RpcEndFinally

        }

        // The buffer reusage check.

        if ( pTransmittedType < pStubMsg->BufferStart  ||
             pTransmittedType > pStubMsg->BufferEnd )
            (*pStubMsg->pfnFree)( pTransmittedType );

        }

    return 0;
}


void
NdrpUserMarshalUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Unmarshals a user_marshal object.
    The layout is described in marshalling.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the memory where the object should be unmarshalled to.
    pFormat     - Object's format string description.

Return :

    None.

--*/
{
    unsigned char *pUserBuffer = pStubMsg->Buffer;
    unsigned char *pUserBufferSaved = pUserBuffer;
    USER_MARSHAL_CB UserMarshalCB;

    NdrpInitUserMarshalCB( pStubMsg,
                           pFormat,
                           USER_MARSHAL_CB_UNMARSHALL, 
                           & UserMarshalCB );

    unsigned short QIndex = *(unsigned short *)(pFormat + 2);
    const USER_MARSHAL_ROUTINE_QUADRUPLE *pQuadruple = 
        pStubMsg->StubDesc->aUserMarshalQuadruple;

    if ((pUserBufferSaved < (uchar *) pStubMsg->RpcMsg->Buffer) ||
        ((unsigned long) (pUserBufferSaved - (uchar *) pStubMsg->RpcMsg->Buffer) 
                                           > pStubMsg->RpcMsg->BufferLength)) 
        {
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        }

    pUserBuffer = pQuadruple[ QIndex ].pfnUnmarshall( (ulong*) &UserMarshalCB,
                                                      pUserBuffer,
                                                      pMemory );

    if ((pUserBufferSaved > pUserBuffer) || 
        ((unsigned long) (pUserBuffer - (uchar *) pStubMsg->RpcMsg->Buffer)
                                      > pStubMsg->RpcMsg->BufferLength )) 
        {
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        }

    pStubMsg->Buffer = pUserBuffer;

    return;
}

void 
NDR_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT::Dispatch(MIDL_STUB_MESSAGE *pStubMsg)
{
    NdrpUserMarshalUnmarshall( pStubMsg,
                               pMemory,
                               pFormat );
}
#if defined(DBG)
void 
NDR_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
}
#endif


unsigned char *
NdrUserMarshalUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )

{
    // Align for the object or a pointer to it.
    unsigned long PointerMarker = 0;
    ALIGN( pStubMsg->Buffer, LOW_NIBBLE(pFormat[1]) );

    // Take care of the pointer, if any.

    if ( (pFormat[1] & USER_MARSHAL_UNIQUE)  ||
         ((pFormat[1] & USER_MARSHAL_REF) && pStubMsg->PointerBufferMark) )
        {
        PointerMarker = *((unsigned long * &)pStubMsg->Buffer)++;
        }

    // We always call user's routine to unmarshall the user object.

    // However, the top level object is allocated by the engine.
    // Thus, the behavior is exactly the same as for represent_as(),
    // with regard to the top level presented type.

    if ( *ppMemory == NULL )
        {
        // Allocate a presented type object first.

        uint MemSize = *(ushort *)(pFormat + 4);

        *ppMemory = (uchar *) NdrAllocate( pStubMsg, MemSize );

        MIDL_memset( *ppMemory, 0, MemSize );
        }

    if ( pFormat[1] & USER_MARSHAL_POINTER )
       {

       if ((pFormat[1] & USER_MARSHAL_UNIQUE) && !PointerMarker )
           return 0;

       if ( !pStubMsg->pPointerQueueState ||
            !pStubMsg->pPointerQueueState->GetActiveQueue())
           {           
           POINTER_BUFFER_SWAP_CONTEXT NewContext(pStubMsg);
           NdrpUserMarshalUnmarshall( 
               pStubMsg,
               *ppMemory,
               pFormat );
           }
       else
           {
           NDR_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT*pElement = 
              new(pStubMsg->pPointerQueueState) 
                  NDR_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT(*ppMemory,
                                                              pFormat );
           pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );
           }

       return 0;
       }

    NdrpUserMarshalUnmarshall( 
        pStubMsg,
        *ppMemory,
        pFormat );

    return 0;
}


void 
NdrpInterfacePointerUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Unmarshalls an interface pointer.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to the interface pointer being unmarshalled.
    pFormat     - Interface pointer's format string description.

Return :

    None.

Notes : There are two data representation formats for a marshalled
        interface pointer. The NDR engine examines the format string
        to determine the appropriate data format.  The format string
        contains FC_IP followed by either FC_CONSTANT_IID or FC_PAD.

        Here is the data representation for the FC_CONSTANT_IID case.

            typedef struct
            {
                unsigned long size;
                [size_is(size)] byte data[];
            }MarshalledInterface;

        Here is the data representation for the FC_PAD case.  This format
        is used when [iid_is] is specified in the IDL file.

            typedef struct
            {
                uuid_t iid;
                unsigned long size;
                [size_is(size)] byte data[];
            }MarshalledInterfaceWithIid;

--*/
{
    HRESULT         hr;
    unsigned long   MaxCount, Size;
    IStream *       pStream;

    ALIGN(pStubMsg->Buffer,0x3);

    // Unmarshal the conformant size and the count field.
    MaxCount = *((unsigned long * &) pStubMsg->Buffer)++;
    Size     = *((unsigned long * &) pStubMsg->Buffer)++;

    //Check the array bounds
    if ( Size != MaxCount )
        RpcRaiseException( RPC_X_BAD_STUB_DATA );

    if( MaxCount > 0)
        {
        CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, MaxCount );

      if ( F_CORRELATION_CHECK )
            {
            IID     *piid, *piidValue;
            BOOL    fDoCheck = FALSE;

            // Get a pointer to the IID hidden in the interface pointer
            // representation in the buffer with Rick's IRpcHelper.
            //
            NdrpGetIIDFromBuffer( pStubMsg, & piidValue );

            //
            // Get an IID pointer to compare.
            //
            if ( pFormat[1] == FC_CONSTANT_IID )
                {
                //
                // The IID may not be aligned properly in the format string,
                // so we copy it to a local variable.
                //
                piid = (IID*) (pFormat + 2);
                fDoCheck = TRUE;
                }
            else
                {
                ULONG_PTR     MaxCountSave = pStubMsg->MaxCount;
                uchar *       pMemorySave  = pStubMsg->Memory;

                pStubMsg->MaxCount = 0;
                pStubMsg->Memory   = pStubMsg->pCorrMemory;
                piid = (IID *)
                              NdrpComputeIIDPointer( pStubMsg,
                                                     *ppMemory, // should not be used
                                                     pFormat );
                if (piid != 0)
                    {
                    PNDR_FCDEF_CORRELATION  pFormatCorr = (PNDR_FCDEF_CORRELATION)(pFormat+2);

                    if ( pFormatCorr->CorrFlags.Early )
                        fDoCheck = TRUE;
                    else
                        {
                        // save ptr as a value to check
                        NdrpAddCorrelationData( pStubMsg,
                                                pStubMsg->pCorrMemory,
                                                pFormat + 2,
                                                (LONG_PTR) piid,  // "value"
                                                NDR_CHECK_CONFORMANCE );
                        }
                    }
                    // else could not check for -Os etc.

                pStubMsg->MaxCount = MaxCountSave;
                pStubMsg->Memory   = pMemorySave;
                }

            if ( fDoCheck  &&
                 0 != memcmp( piidValue, piid, sizeof(IID) ) )
                RpcRaiseException( RPC_X_BAD_STUB_DATA );
            }

        pStream = (*NdrpCreateStreamOnMemory)(pStubMsg->Buffer, MaxCount);
        if(pStream == 0)
            RpcRaiseException(RPC_S_OUT_OF_MEMORY);

        hr = (*pfnCoUnmarshalInterface)(pStream, IID_NULL, (void**)ppMemory);
        pStream->Release();
        pStream = 0;

        if(FAILED(hr))
            RpcRaiseException(hr);
        }

    //Advance the stub message pointer.

    pStubMsg->Buffer += MaxCount;
}

unsigned char * RPC_ENTRY
NdrInterfacePointerUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               /*fMustAlloc*/ )
{

    // This is only called for toplevel interface pointers
    // in Os mode stubs.
    IUnknown **     ppunk = (IUnknown **)ppMemory;
    
    // On the client side, release the [in,out] interface pointer.

    if ((pStubMsg->IsClient == TRUE) && (*ppunk != 0))
        (*ppunk)->Release();

    *ppunk = 0;

    //
    // We always have to pickup the pointer itself from the wire
    // as it behaves like a unique pointer.

    ALIGN(pStubMsg->Buffer,0x3);
    long PtrValue = *((long * &)pStubMsg->Buffer)++;

    // If the pointer is null, we are done.

    if ( 0 == PtrValue )
        return 0;

    NdrpInterfacePointerUnmarshall(
        pStubMsg,
        ppMemory,
        pFormat );

    return 0;
}


void RPC_ENTRY
NdrClientContextUnmarshall(
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_CCONTEXT *        pContextHandle,
    RPC_BINDING_HANDLE    BindHandle )
/*++

Routine Description :

    Unmarshalls a context handle on the client side.

Arguments :

    pStubMsg        - Pointer to stub message.
    pContextHandle  - Pointer to context handle to unmarshall.
    BindHandle      - The handle value used by the client for binding.

Return :

    None.

--*/
{
    // Note, this is a routine called directly from -Os stubs.
    // The routine called by interpreter is called NdrUnmarshallHandle
    // and can be found in hndl.c

    ALIGN(pStubMsg->Buffer,3);

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + CONTEXT_HANDLE_WIRE_SIZE );    

    // All 20 bytes of the buffer are touched so a check is not needed here.

    NDRCContextUnmarshall( pContextHandle,
                           BindHandle,
                           pStubMsg->Buffer,
                           pStubMsg->RpcMsg->DataRepresentation );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;
}

NDR_SCONTEXT RPC_ENTRY
NdrServerContextUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg )
/*++

Routine Description :

    Unmarshalls a context handle on the server side.

Arguments :

    pStubMsg    - Pointer to stub message.

Return :

    The unmarshalled context handle.

--*/
{
    // Note, this is a routine called directly from -Os stubs.
    // The routine called by interpreter is called NdrUnmarshallHandle
    // and can be found in hndl.c

    NDR_SCONTEXT    Context;

    ALIGN(pStubMsg->Buffer,3);

    // we might corrupt the memory during the byte swap 
    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + CONTEXT_HANDLE_WIRE_SIZE );    

    // All 20 bytes of the buffer are touched so a check is not needed here.

    Context = NDRSContextUnmarshall2(pStubMsg->RpcMsg->Handle,
                                     pStubMsg->Buffer,
                                     pStubMsg->RpcMsg->DataRepresentation,
                                     RPC_CONTEXT_HANDLE_DEFAULT_GUARD,
                                     RPC_CONTEXT_HANDLE_DEFAULT_FLAGS );

    if ( ! Context )
        RpcRaiseException( RPC_X_SS_CONTEXT_MISMATCH );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;

    return Context;
}

NDR_SCONTEXT  RPC_ENTRY
NdrContextHandleInitialize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*
    This routine is to initialize a context handle with a new NT5 flavor.
    It is used in conjunction with NdrContextHandleUnmarshal.
*/
{
    NDR_SCONTEXT    SContext;
    void *          pGuard = RPC_CONTEXT_HANDLE_DEFAULT_GUARD;
    DWORD           Flags  = RPC_CONTEXT_HANDLE_DEFAULT_FLAGS;

    // NT5 beta2 features: strict context handle, serialize and noserialize.

    if ( pFormat[1] & NDR_STRICT_CONTEXT_HANDLE )
        {
        // The guard is defined as the interface ID.
        // If you change it, modify hndlsvr.cxx in the same way.

        pGuard = pStubMsg->StubDesc->RpcInterfaceInformation;
        pGuard = & ((PRPC_SERVER_INTERFACE)pGuard)->InterfaceId;
        }
    if ( pFormat[1] & NDR_CONTEXT_HANDLE_NOSERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_DONT_SERIALIZE;
        }
    else if ( pFormat[1] & NDR_CONTEXT_HANDLE_SERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_SERIALIZE;
        }

    SContext = NDRSContextUnmarshall2(
                    pStubMsg->RpcMsg->Handle,
                    (void *)0,  // buffer
                    pStubMsg->RpcMsg->DataRepresentation,
                    pGuard,
                    Flags );

    return SContext;
}

NDR_SCONTEXT RPC_ENTRY
NdrServerContextNewUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*
    This routine to unmarshal a context handle with a new NT5 flavor.
    For the old style handles, we call an optimized routine
    NdrServerContextUnmarshall below.
    Interpreter calls NdrUnmarshallHandle from hndl.c

      ppMemory - note, this is not a pointer to user's context handle but
                 a pointer to NDR_SCONTEXT pointer to the runtime internal object.
                 User's handle is a field of that object.
*/
{
    NDR_SCONTEXT    SContext;

    void *          pGuard = RPC_CONTEXT_HANDLE_DEFAULT_GUARD;
    DWORD           Flags  = RPC_CONTEXT_HANDLE_DEFAULT_FLAGS;

    // Anti-attack defense for servers, NT5 beta3 feature.

    if ( pFormat[1] & NDR_CONTEXT_HANDLE_CANNOT_BE_NULL )
        {
        // Check the incoming context handle on the server.
        // Context handle wire layout: ulong with version (always 0), then a uuid.
        //
        if ( !pStubMsg->IsClient  &&  0 == memcmp( pStubMsg->Buffer + 4,
                                                   &GUID_NULL,
                                                   sizeof(GUID) ) )
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

    // NT5 beta2 features: strict context handle, serialize and noserialize.

    if ( pFormat[1] & NDR_STRICT_CONTEXT_HANDLE )
        {
        pGuard = pStubMsg->StubDesc->RpcInterfaceInformation;
        pGuard = & ((PRPC_SERVER_INTERFACE)pGuard)->InterfaceId;
        }
    if ( pFormat[1] & NDR_CONTEXT_HANDLE_NOSERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_DONT_SERIALIZE;
        }
    else if ( pFormat[1] & NDR_CONTEXT_HANDLE_SERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_SERIALIZE;
        }

    ALIGN( pStubMsg->Buffer, 0x3 );
    // All 20 bytes of the buffer are touched so a check is not needed here.

    SContext = NDRSContextUnmarshall2(
                    pStubMsg->RpcMsg->Handle,
                    pStubMsg->Buffer,
                    pStubMsg->RpcMsg->DataRepresentation,
                    pGuard,
                    Flags );

    if ( ! SContext )
        RpcRaiseException( RPC_X_SS_CONTEXT_MISMATCH );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;

    return SContext;
}


#ifdef _CS_CHAR_
unsigned char * RPC_ENTRY
NdrCsTagUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a cs tag.

Arguments :

    pStubMsg    - Pointer to stub message.
    ppMemory    - Double pointer to where to unmarshall to
    pFormat     - The format string entry
    fMustAlloc  - TRUE if we can't reuse the buffer (not relevant in this case)

--*/
{
    NDR_CS_TAG_FORMAT *pTagFormat = (NDR_CS_TAG_FORMAT *) pFormat;

    ulong Codeset = NdrpGetSetCSTagUnmarshall(
                            pStubMsg, 
                            (NDR_CS_TAG_FORMAT *) pFormat);

    // If there is a tag routine, then this parameter is not on the stack

    if ( NDR_INVALID_TAG_ROUTINE_INDEX == pTagFormat->TagRoutineIndex )
        ** (ulong **) ppMemory = Codeset;

    pStubMsg->Buffer += sizeof(ulong);

    return 0;
}


unsigned char * RPC_ENTRY
NdrCsArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a international character (cs) array tag.

Arguments :

    pStubMsg    - Pointer to stub message.
    ppMemory    - Double pointer to where to unmarshall to
    pFormat     - The format string entry
    fMustAlloc  - TRUE if we can't reuse the buffer

--*/
{
    ulong                       LocalCodeset;
    error_status_t              status;
    uchar                      *ConvertedData;
    uchar                      *UnconvertedData;
    ulong                       ArraySize;
    ulong                       WireLength;
    uchar                      *OldBuffer;
    uchar                       fMustAllocOriginal;
    BOOL                        IsClient;

    NDR_CS_ARRAY_FORMAT            *pCSFormat;
    NDR_CS_SIZE_CONVERT_ROUTINES   *CSRoutines;
    CS_TYPE_LOCAL_SIZE_ROUTINE      LocalSizeRoutine;
    CS_TYPE_FROM_NETCS_ROUTINE      FromNetCSRoutine;
    IDL_CS_CONVERT                  ConversionType;

    pCSFormat = (NDR_CS_ARRAY_FORMAT *) pFormat;

    NDR_ASSERT( NULL != pStubMsg->pCSInfo, "cs stub info not set up");

    // Get all the info out of the FC_CS_ARRAY structure and bump pFormat
    // to point to the underlying data descriptor

    CSRoutines = pStubMsg->StubDesc->CsRoutineTables->pSizeConvertRoutines;
    LocalSizeRoutine = CSRoutines[ pCSFormat->CSRoutineIndex].pfnLocalSize;
    FromNetCSRoutine = CSRoutines[ pCSFormat->CSRoutineIndex].pfnFromNetCs;

    pFormat += pCSFormat->DescriptionOffset;

// REVIEW:  A lot of this code can be eleminted by calling memsize on the 
//          cs_char array instead of the underlying one.

    // Get the size of the data on the wire

    OldBuffer = pStubMsg->Buffer;

    WireLength = PtrToUlong( NdrpMemoryIncrement( pStubMsg, 0, pFormat ) );

    // Figure out whether we need to convert and how much we need to allocate
    // if we do

    LocalSizeRoutine(
            pStubMsg->RpcMsg->Handle,
            pStubMsg->pCSInfo->WireCodeset,
            WireLength,
            &ConversionType,
            &ArraySize,
            &status);

    if ( RPC_S_OK != status )
        RpcRaiseException( status );

    // If we need to convert we just want the unmarshalling routine to give us
    // back a pointer and not do any allocations.  We'll do the allocation 
    // later if need be.

    IsClient = pStubMsg->IsClient;

    if ( IDL_CS_NO_CONVERT != ConversionType )
        {
        fMustAllocOriginal = fMustAlloc;
        OldBuffer = *ppMemory;
        *ppMemory = NULL;
        fMustAlloc = FALSE;
        
        // Slimy hack to enable buffer reuse on the client side
        pStubMsg->IsClient = FALSE;
        }

    // Unmarshall the base array

    pfnUnmarshallRoutines[ ROUTINE_INDEX( *pFormat ) ] (
            pStubMsg,
            ppMemory,
            pFormat,
            fMustAlloc );

    pStubMsg->IsClient = IsClient;

    // If we don't need to convert, we're done

    if ( IDL_CS_NO_CONVERT == ConversionType )
        return 0;
   
    // Make sure we've got a buffer to convert into

    NDR_ASSERT( NULL != *ppMemory, "Invalid memory pointer" );

    UnconvertedData = *ppMemory;
    *ppMemory = OldBuffer;

    if ( fMustAllocOriginal || NULL == *ppMemory )
        {
        *ppMemory = (uchar *) NdrAllocate( 
                                    pStubMsg, 
                                    ArraySize * pCSFormat->UserTypeSize );
        }
    else if ( pStubMsg->IsClient )
        {
        // Make sure we don't overflow the client's buffer

        long ClientArraySize;
        long ClientArrayLength;
        long ClientWireSize;

        NdrpGetArraySizeLength(
                            pStubMsg,
                            *ppMemory,
                            pFormat,
                            pCSFormat->UserTypeSize,
                            &ClientArraySize,
                            &ClientArrayLength,
                            &ClientWireSize );

        ArraySize = min( ArraySize, (ulong)ClientArraySize );
        }

    // Reset the conformance variable to the new array size

    if ( NdrpArrayMarshallFlags[ *pFormat - FC_CARRAY ] & MARSHALL_CONFORMANCE )
        {
        uchar *pOldCorrMemory = pStubMsg->pCorrMemory;

        if ( !pStubMsg->pCorrMemory )
            pStubMsg->pCorrMemory = pStubMsg->StackTop;

        NdrpCheckCorrelation(
                pStubMsg,
                ArraySize,
                pFormat,
                NDR_CHECK_CONFORMANCE | NDR_RESET_VALUE );

        pStubMsg->pCorrMemory = pOldCorrMemory;
        }

    // Do the conversion

    FromNetCSRoutine(
            pStubMsg->RpcMsg->Handle,
            pStubMsg->pCSInfo->WireCodeset,
            UnconvertedData,
            WireLength,
            ArraySize,
            *ppMemory,
            &ArraySize,     // Actually it returns the length not the size
            &status);

    if ( RPC_S_OK != status )
        RpcRaiseException( status );

    // Reset the variance variable to the new array length

    if ( NdrpArrayMarshallFlags[ *pFormat - FC_CARRAY ] & MARSHALL_VARIANCE )
        {
        NdrpCheckCorrelation(
                pStubMsg,
                ArraySize,
                pFormat,
                NDR_CHECK_VARIANCE | NDR_RESET_VALUE );
        }

    return 0;
}
#endif // _CS_CHAR_


void
NdrPartialIgnoreServerUnmarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    void **                             ppMemory 
    )
{
    ALIGN( pStubMsg->Buffer, 0x3 );
    *ppMemory = UlongToPtr( *(ulong*)pStubMsg->Buffer );
    pStubMsg->Buffer += PTR_WIRE_SIZE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\unmrshlp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993 Microsoft Corporation

Module Name :

	unmrshlp.h

Abtract :

	Contains private definitions for unmrshl.c.

Author :

	David Kays  dkays   September 1993

Revision History :

--------------------------------------------------------------------*/

#ifndef _UNMRSHLP_
#define _UNMRSHLP_

void
NdrpPointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,       // Where allocated pointer is written
    uchar *             pMemory,
    long  *             pBufferPointer, // Pointer to the wire rep.
    PFORMAT_STRING      pFormat );

void 
NdrpConformantArrayUnmarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar **						pMemory, 
	PFORMAT_STRING				pFormat,
	uchar 						fMustCopy ,
	uchar				              fMustAlloc 
	);

void 
NdrpConformantVaryingArrayUnmarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar **						pMemory, 
	PFORMAT_STRING				pFormat,
	uchar 						fMustCopy,
	uchar				              fMustAlloc 
	);

void 
NdrpComplexArrayUnmarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar **						pMemory, 
	PFORMAT_STRING				pFormat,
	uchar 						fMustCopy,
	uchar				              fMustAlloc 
	);

void 
NdrpConformantStringUnmarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar **						pMemory, 
	PFORMAT_STRING				pFormat,
	uchar 						fMustCopy ,
	uchar				              fMustAlloc 
	);

void 
NdrpUnionUnmarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar **					ppMemory, 
	PFORMAT_STRING				pFormat,
	uchar 						SwitchType,
    PFORMAT_STRING              pNonEncUnion
	);

PFORMAT_STRING
NdrpEmbeddedPointerUnmarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat,
	uchar						fNewMemory
	);

PFORMAT_STRING 
NdrpEmbeddedRepeatPointerUnmarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat,
	uchar						fNewMemory
	);

#define FULL_POINTER_INSERT( pStubMsg, Pointer )	\
				{ \
			    NdrFullPointerInsertRefId( pStubMsg->FullPtrXlatTables, \
                                           pStubMsg->FullPtrRefId, \
                                           Pointer ); \
 \
                pStubMsg->FullPtrRefId = 0; \
				}

typedef uchar * (RPC_ENTRY * PUNMARSHALL_ROUTINE)( 
					PMIDL_STUB_MESSAGE, 
					uchar **, 
					PFORMAT_STRING,
					uchar 
				);

typedef void  	(* PPRIVATE_UNMARSHALL_ROUTINE)( 
					PMIDL_STUB_MESSAGE, 
					uchar **, 
					PFORMAT_STRING,
					uchar,
					uchar
				);

//
// Function table defined in unmrshl.c.
//
IMPORTSPEC
extern const PUNMARSHALL_ROUTINE * pfnUnmarshallRoutines;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\amd64\stblsclt.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    stblsclt.c

Abstract:

    This file contains the routines for support of stubless clients in
    object interfaces.

Author :

    David Kays (dkays) February 1995.

--*/

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include <stdarg.h>
#include "ndrp.h"
#include "hndl.h"
#include "interp2.h"
#include "ndrtypes.h"
#include "mulsyntx.h"

#include "ndrole.h"
#include "rpcproxy.h"

#pragma code_seg(".orpc")

CLIENT_CALL_RETURN
RPC_ENTRY
NdrClientCall2 (
    PMIDL_STUB_DESC pStubDescriptor,
    PFORMAT_STRING pFormat,
    ...
    );

CLIENT_CALL_RETURN
RPC_ENTRY
NdrDcomAsyncClientCall (
    PMIDL_STUB_DESC pStubDescriptor,
    PFORMAT_STRING pFormat,
    ...
    );

extern "C"
{

long
ObjectStublessClient (
    void *ParamAddress,
    REGISTER_TYPE *FloatRegisters,
    long Method
    );

void ObjectStublessClient3(void);
void ObjectStublessClient4(void);
void ObjectStublessClient5(void);
void ObjectStublessClient6(void);
void ObjectStublessClient7(void);
void ObjectStublessClient8(void);
void ObjectStublessClient9(void);
void ObjectStublessClient10(void);
void ObjectStublessClient11(void);
void ObjectStublessClient12(void);
void ObjectStublessClient13(void);
void ObjectStublessClient14(void);
void ObjectStublessClient15(void);
void ObjectStublessClient16(void);
void ObjectStublessClient17(void);
void ObjectStublessClient18(void);
void ObjectStublessClient19(void);
void ObjectStublessClient20(void);
void ObjectStublessClient21(void);
void ObjectStublessClient22(void);
void ObjectStublessClient23(void);
void ObjectStublessClient24(void);
void ObjectStublessClient25(void);
void ObjectStublessClient26(void);
void ObjectStublessClient27(void);
void ObjectStublessClient28(void);
void ObjectStublessClient29(void);
void ObjectStublessClient30(void);
void ObjectStublessClient31(void);
void ObjectStublessClient32(void);
void ObjectStublessClient33(void);
void ObjectStublessClient34(void);
void ObjectStublessClient35(void);
void ObjectStublessClient36(void);
void ObjectStublessClient37(void);
void ObjectStublessClient38(void);
void ObjectStublessClient39(void);
void ObjectStublessClient40(void);
void ObjectStublessClient41(void);
void ObjectStublessClient42(void);
void ObjectStublessClient43(void);
void ObjectStublessClient44(void);
void ObjectStublessClient45(void);
void ObjectStublessClient46(void);
void ObjectStublessClient47(void);
void ObjectStublessClient48(void);
void ObjectStublessClient49(void);
void ObjectStublessClient50(void);
void ObjectStublessClient51(void);
void ObjectStublessClient52(void);
void ObjectStublessClient53(void);
void ObjectStublessClient54(void);
void ObjectStublessClient55(void);
void ObjectStublessClient56(void);
void ObjectStublessClient57(void);
void ObjectStublessClient58(void);
void ObjectStublessClient59(void);
void ObjectStublessClient60(void);
void ObjectStublessClient61(void);
void ObjectStublessClient62(void);
void ObjectStublessClient63(void);
void ObjectStublessClient64(void);
void ObjectStublessClient65(void);
void ObjectStublessClient66(void);
void ObjectStublessClient67(void);
void ObjectStublessClient68(void);
void ObjectStublessClient69(void);
void ObjectStublessClient70(void);
void ObjectStublessClient71(void);
void ObjectStublessClient72(void);
void ObjectStublessClient73(void);
void ObjectStublessClient74(void);
void ObjectStublessClient75(void);
void ObjectStublessClient76(void);
void ObjectStublessClient77(void);
void ObjectStublessClient78(void);
void ObjectStublessClient79(void);
void ObjectStublessClient80(void);
void ObjectStublessClient81(void);
void ObjectStublessClient82(void);
void ObjectStublessClient83(void);
void ObjectStublessClient84(void);
void ObjectStublessClient85(void);
void ObjectStublessClient86(void);
void ObjectStublessClient87(void);
void ObjectStublessClient88(void);
void ObjectStublessClient89(void);
void ObjectStublessClient90(void);
void ObjectStublessClient91(void);
void ObjectStublessClient92(void);
void ObjectStublessClient93(void);
void ObjectStublessClient94(void);
void ObjectStublessClient95(void);
void ObjectStublessClient96(void);
void ObjectStublessClient97(void);
void ObjectStublessClient98(void);
void ObjectStublessClient99(void);
void ObjectStublessClient100(void);
void ObjectStublessClient101(void);
void ObjectStublessClient102(void);
void ObjectStublessClient103(void);
void ObjectStublessClient104(void);
void ObjectStublessClient105(void);
void ObjectStublessClient106(void);
void ObjectStublessClient107(void);
void ObjectStublessClient108(void);
void ObjectStublessClient109(void);
void ObjectStublessClient110(void);
void ObjectStublessClient111(void);
void ObjectStublessClient112(void);
void ObjectStublessClient113(void);
void ObjectStublessClient114(void);
void ObjectStublessClient115(void);
void ObjectStublessClient116(void);
void ObjectStublessClient117(void);
void ObjectStublessClient118(void);
void ObjectStublessClient119(void);
void ObjectStublessClient120(void);
void ObjectStublessClient121(void);
void ObjectStublessClient122(void);
void ObjectStublessClient123(void);
void ObjectStublessClient124(void);
void ObjectStublessClient125(void);
void ObjectStublessClient126(void);
void ObjectStublessClient127(void);
void ObjectStublessClient128(void);
void ObjectStublessClient129(void);
void ObjectStublessClient130(void);
void ObjectStublessClient131(void);
void ObjectStublessClient132(void);
void ObjectStublessClient133(void);
void ObjectStublessClient134(void);
void ObjectStublessClient135(void);
void ObjectStublessClient136(void);
void ObjectStublessClient137(void);
void ObjectStublessClient138(void);
void ObjectStublessClient139(void);
void ObjectStublessClient140(void);
void ObjectStublessClient141(void);
void ObjectStublessClient142(void);
void ObjectStublessClient143(void);
void ObjectStublessClient144(void);
void ObjectStublessClient145(void);
void ObjectStublessClient146(void);
void ObjectStublessClient147(void);
void ObjectStublessClient148(void);
void ObjectStublessClient149(void);
void ObjectStublessClient150(void);
void ObjectStublessClient151(void);
void ObjectStublessClient152(void);
void ObjectStublessClient153(void);
void ObjectStublessClient154(void);
void ObjectStublessClient155(void);
void ObjectStublessClient156(void);
void ObjectStublessClient157(void);
void ObjectStublessClient158(void);
void ObjectStublessClient159(void);
void ObjectStublessClient160(void);
void ObjectStublessClient161(void);
void ObjectStublessClient162(void);
void ObjectStublessClient163(void);
void ObjectStublessClient164(void);
void ObjectStublessClient165(void);
void ObjectStublessClient166(void);
void ObjectStublessClient167(void);
void ObjectStublessClient168(void);
void ObjectStublessClient169(void);
void ObjectStublessClient170(void);
void ObjectStublessClient171(void);
void ObjectStublessClient172(void);
void ObjectStublessClient173(void);
void ObjectStublessClient174(void);
void ObjectStublessClient175(void);
void ObjectStublessClient176(void);
void ObjectStublessClient177(void);
void ObjectStublessClient178(void);
void ObjectStublessClient179(void);
void ObjectStublessClient180(void);
void ObjectStublessClient181(void);
void ObjectStublessClient182(void);
void ObjectStublessClient183(void);
void ObjectStublessClient184(void);
void ObjectStublessClient185(void);
void ObjectStublessClient186(void);
void ObjectStublessClient187(void);
void ObjectStublessClient188(void);
void ObjectStublessClient189(void);
void ObjectStublessClient190(void);
void ObjectStublessClient191(void);
void ObjectStublessClient192(void);
void ObjectStublessClient193(void);
void ObjectStublessClient194(void);
void ObjectStublessClient195(void);
void ObjectStublessClient196(void);
void ObjectStublessClient197(void);
void ObjectStublessClient198(void);
void ObjectStublessClient199(void);
void ObjectStublessClient200(void);
void ObjectStublessClient201(void);
void ObjectStublessClient202(void);
void ObjectStublessClient203(void);
void ObjectStublessClient204(void);
void ObjectStublessClient205(void);
void ObjectStublessClient206(void);
void ObjectStublessClient207(void);
void ObjectStublessClient208(void);
void ObjectStublessClient209(void);
void ObjectStublessClient210(void);
void ObjectStublessClient211(void);
void ObjectStublessClient212(void);
void ObjectStublessClient213(void);
void ObjectStublessClient214(void);
void ObjectStublessClient215(void);
void ObjectStublessClient216(void);
void ObjectStublessClient217(void);
void ObjectStublessClient218(void);
void ObjectStublessClient219(void);
void ObjectStublessClient220(void);
void ObjectStublessClient221(void);
void ObjectStublessClient222(void);
void ObjectStublessClient223(void);
void ObjectStublessClient224(void);
void ObjectStublessClient225(void);
void ObjectStublessClient226(void);
void ObjectStublessClient227(void);
void ObjectStublessClient228(void);
void ObjectStublessClient229(void);
void ObjectStublessClient230(void);
void ObjectStublessClient231(void);
void ObjectStublessClient232(void);
void ObjectStublessClient233(void);
void ObjectStublessClient234(void);
void ObjectStublessClient235(void);
void ObjectStublessClient236(void);
void ObjectStublessClient237(void);
void ObjectStublessClient238(void);
void ObjectStublessClient239(void);
void ObjectStublessClient240(void);
void ObjectStublessClient241(void);
void ObjectStublessClient242(void);
void ObjectStublessClient243(void);
void ObjectStublessClient244(void);
void ObjectStublessClient245(void);
void ObjectStublessClient246(void);
void ObjectStublessClient247(void);
void ObjectStublessClient248(void);
void ObjectStublessClient249(void);
void ObjectStublessClient250(void);
void ObjectStublessClient251(void);
void ObjectStublessClient252(void);
void ObjectStublessClient253(void);
void ObjectStublessClient254(void);
void ObjectStublessClient255(void);
void ObjectStublessClient256(void);
void ObjectStublessClient257(void);
void ObjectStublessClient258(void);
void ObjectStublessClient259(void);
void ObjectStublessClient260(void);
void ObjectStublessClient261(void);
void ObjectStublessClient262(void);
void ObjectStublessClient263(void);
void ObjectStublessClient264(void);
void ObjectStublessClient265(void);
void ObjectStublessClient266(void);
void ObjectStublessClient267(void);
void ObjectStublessClient268(void);
void ObjectStublessClient269(void);
void ObjectStublessClient270(void);
void ObjectStublessClient271(void);
void ObjectStublessClient272(void);
void ObjectStublessClient273(void);
void ObjectStublessClient274(void);
void ObjectStublessClient275(void);
void ObjectStublessClient276(void);
void ObjectStublessClient277(void);
void ObjectStublessClient278(void);
void ObjectStublessClient279(void);
void ObjectStublessClient280(void);
void ObjectStublessClient281(void);
void ObjectStublessClient282(void);
void ObjectStublessClient283(void);
void ObjectStublessClient284(void);
void ObjectStublessClient285(void);
void ObjectStublessClient286(void);
void ObjectStublessClient287(void);
void ObjectStublessClient288(void);
void ObjectStublessClient289(void);
void ObjectStublessClient290(void);
void ObjectStublessClient291(void);
void ObjectStublessClient292(void);
void ObjectStublessClient293(void);
void ObjectStublessClient294(void);
void ObjectStublessClient295(void);
void ObjectStublessClient296(void);
void ObjectStublessClient297(void);
void ObjectStublessClient298(void);
void ObjectStublessClient299(void);
void ObjectStublessClient300(void);
void ObjectStublessClient301(void);
void ObjectStublessClient302(void);
void ObjectStublessClient303(void);
void ObjectStublessClient304(void);
void ObjectStublessClient305(void);
void ObjectStublessClient306(void);
void ObjectStublessClient307(void);
void ObjectStublessClient308(void);
void ObjectStublessClient309(void);
void ObjectStublessClient310(void);
void ObjectStublessClient311(void);
void ObjectStublessClient312(void);
void ObjectStublessClient313(void);
void ObjectStublessClient314(void);
void ObjectStublessClient315(void);
void ObjectStublessClient316(void);
void ObjectStublessClient317(void);
void ObjectStublessClient318(void);
void ObjectStublessClient319(void);
void ObjectStublessClient320(void);
void ObjectStublessClient321(void);
void ObjectStublessClient322(void);
void ObjectStublessClient323(void);
void ObjectStublessClient324(void);
void ObjectStublessClient325(void);
void ObjectStublessClient326(void);
void ObjectStublessClient327(void);
void ObjectStublessClient328(void);
void ObjectStublessClient329(void);
void ObjectStublessClient330(void);
void ObjectStublessClient331(void);
void ObjectStublessClient332(void);
void ObjectStublessClient333(void);
void ObjectStublessClient334(void);
void ObjectStublessClient335(void);
void ObjectStublessClient336(void);
void ObjectStublessClient337(void);
void ObjectStublessClient338(void);
void ObjectStublessClient339(void);
void ObjectStublessClient340(void);
void ObjectStublessClient341(void);
void ObjectStublessClient342(void);
void ObjectStublessClient343(void);
void ObjectStublessClient344(void);
void ObjectStublessClient345(void);
void ObjectStublessClient346(void);
void ObjectStublessClient347(void);
void ObjectStublessClient348(void);
void ObjectStublessClient349(void);
void ObjectStublessClient350(void);
void ObjectStublessClient351(void);
void ObjectStublessClient352(void);
void ObjectStublessClient353(void);
void ObjectStublessClient354(void);
void ObjectStublessClient355(void);
void ObjectStublessClient356(void);
void ObjectStublessClient357(void);
void ObjectStublessClient358(void);
void ObjectStublessClient359(void);
void ObjectStublessClient360(void);
void ObjectStublessClient361(void);
void ObjectStublessClient362(void);
void ObjectStublessClient363(void);
void ObjectStublessClient364(void);
void ObjectStublessClient365(void);
void ObjectStublessClient366(void);
void ObjectStublessClient367(void);
void ObjectStublessClient368(void);
void ObjectStublessClient369(void);
void ObjectStublessClient370(void);
void ObjectStublessClient371(void);
void ObjectStublessClient372(void);
void ObjectStublessClient373(void);
void ObjectStublessClient374(void);
void ObjectStublessClient375(void);
void ObjectStublessClient376(void);
void ObjectStublessClient377(void);
void ObjectStublessClient378(void);
void ObjectStublessClient379(void);
void ObjectStublessClient380(void);
void ObjectStublessClient381(void);
void ObjectStublessClient382(void);
void ObjectStublessClient383(void);
void ObjectStublessClient384(void);
void ObjectStublessClient385(void);
void ObjectStublessClient386(void);
void ObjectStublessClient387(void);
void ObjectStublessClient388(void);
void ObjectStublessClient389(void);
void ObjectStublessClient390(void);
void ObjectStublessClient391(void);
void ObjectStublessClient392(void);
void ObjectStublessClient393(void);
void ObjectStublessClient394(void);
void ObjectStublessClient395(void);
void ObjectStublessClient396(void);
void ObjectStublessClient397(void);
void ObjectStublessClient398(void);
void ObjectStublessClient399(void);
void ObjectStublessClient400(void);
void ObjectStublessClient401(void);
void ObjectStublessClient402(void);
void ObjectStublessClient403(void);
void ObjectStublessClient404(void);
void ObjectStublessClient405(void);
void ObjectStublessClient406(void);
void ObjectStublessClient407(void);
void ObjectStublessClient408(void);
void ObjectStublessClient409(void);
void ObjectStublessClient410(void);
void ObjectStublessClient411(void);
void ObjectStublessClient412(void);
void ObjectStublessClient413(void);
void ObjectStublessClient414(void);
void ObjectStublessClient415(void);
void ObjectStublessClient416(void);
void ObjectStublessClient417(void);
void ObjectStublessClient418(void);
void ObjectStublessClient419(void);
void ObjectStublessClient420(void);
void ObjectStublessClient421(void);
void ObjectStublessClient422(void);
void ObjectStublessClient423(void);
void ObjectStublessClient424(void);
void ObjectStublessClient425(void);
void ObjectStublessClient426(void);
void ObjectStublessClient427(void);
void ObjectStublessClient428(void);
void ObjectStublessClient429(void);
void ObjectStublessClient430(void);
void ObjectStublessClient431(void);
void ObjectStublessClient432(void);
void ObjectStublessClient433(void);
void ObjectStublessClient434(void);
void ObjectStublessClient435(void);
void ObjectStublessClient436(void);
void ObjectStublessClient437(void);
void ObjectStublessClient438(void);
void ObjectStublessClient439(void);
void ObjectStublessClient440(void);
void ObjectStublessClient441(void);
void ObjectStublessClient442(void);
void ObjectStublessClient443(void);
void ObjectStublessClient444(void);
void ObjectStublessClient445(void);
void ObjectStublessClient446(void);
void ObjectStublessClient447(void);
void ObjectStublessClient448(void);
void ObjectStublessClient449(void);
void ObjectStublessClient450(void);
void ObjectStublessClient451(void);
void ObjectStublessClient452(void);
void ObjectStublessClient453(void);
void ObjectStublessClient454(void);
void ObjectStublessClient455(void);
void ObjectStublessClient456(void);
void ObjectStublessClient457(void);
void ObjectStublessClient458(void);
void ObjectStublessClient459(void);
void ObjectStublessClient460(void);
void ObjectStublessClient461(void);
void ObjectStublessClient462(void);
void ObjectStublessClient463(void);
void ObjectStublessClient464(void);
void ObjectStublessClient465(void);
void ObjectStublessClient466(void);
void ObjectStublessClient467(void);
void ObjectStublessClient468(void);
void ObjectStublessClient469(void);
void ObjectStublessClient470(void);
void ObjectStublessClient471(void);
void ObjectStublessClient472(void);
void ObjectStublessClient473(void);
void ObjectStublessClient474(void);
void ObjectStublessClient475(void);
void ObjectStublessClient476(void);
void ObjectStublessClient477(void);
void ObjectStublessClient478(void);
void ObjectStublessClient479(void);
void ObjectStublessClient480(void);
void ObjectStublessClient481(void);
void ObjectStublessClient482(void);
void ObjectStublessClient483(void);
void ObjectStublessClient484(void);
void ObjectStublessClient485(void);
void ObjectStublessClient486(void);
void ObjectStublessClient487(void);
void ObjectStublessClient488(void);
void ObjectStublessClient489(void);
void ObjectStublessClient490(void);
void ObjectStublessClient491(void);
void ObjectStublessClient492(void);
void ObjectStublessClient493(void);
void ObjectStublessClient494(void);
void ObjectStublessClient495(void);
void ObjectStublessClient496(void);
void ObjectStublessClient497(void);
void ObjectStublessClient498(void);
void ObjectStublessClient499(void);
void ObjectStublessClient500(void);
void ObjectStublessClient501(void);
void ObjectStublessClient502(void);
void ObjectStublessClient503(void);
void ObjectStublessClient504(void);
void ObjectStublessClient505(void);
void ObjectStublessClient506(void);
void ObjectStublessClient507(void);
void ObjectStublessClient508(void);
void ObjectStublessClient509(void);
void ObjectStublessClient510(void);
void ObjectStublessClient511(void);
void ObjectStublessClient512(void);
void ObjectStublessClient513(void);
void ObjectStublessClient514(void);
void ObjectStublessClient515(void);
void ObjectStublessClient516(void);
void ObjectStublessClient517(void);
void ObjectStublessClient518(void);
void ObjectStublessClient519(void);
void ObjectStublessClient520(void);
void ObjectStublessClient521(void);
void ObjectStublessClient522(void);
void ObjectStublessClient523(void);
void ObjectStublessClient524(void);
void ObjectStublessClient525(void);
void ObjectStublessClient526(void);
void ObjectStublessClient527(void);
void ObjectStublessClient528(void);
void ObjectStublessClient529(void);
void ObjectStublessClient530(void);
void ObjectStublessClient531(void);
void ObjectStublessClient532(void);
void ObjectStublessClient533(void);
void ObjectStublessClient534(void);
void ObjectStublessClient535(void);
void ObjectStublessClient536(void);
void ObjectStublessClient537(void);
void ObjectStublessClient538(void);
void ObjectStublessClient539(void);
void ObjectStublessClient540(void);
void ObjectStublessClient541(void);
void ObjectStublessClient542(void);
void ObjectStublessClient543(void);
void ObjectStublessClient544(void);
void ObjectStublessClient545(void);
void ObjectStublessClient546(void);
void ObjectStublessClient547(void);
void ObjectStublessClient548(void);
void ObjectStublessClient549(void);
void ObjectStublessClient550(void);
void ObjectStublessClient551(void);
void ObjectStublessClient552(void);
void ObjectStublessClient553(void);
void ObjectStublessClient554(void);
void ObjectStublessClient555(void);
void ObjectStublessClient556(void);
void ObjectStublessClient557(void);
void ObjectStublessClient558(void);
void ObjectStublessClient559(void);
void ObjectStublessClient560(void);
void ObjectStublessClient561(void);
void ObjectStublessClient562(void);
void ObjectStublessClient563(void);
void ObjectStublessClient564(void);
void ObjectStublessClient565(void);
void ObjectStublessClient566(void);
void ObjectStublessClient567(void);
void ObjectStublessClient568(void);
void ObjectStublessClient569(void);
void ObjectStublessClient570(void);
void ObjectStublessClient571(void);
void ObjectStublessClient572(void);
void ObjectStublessClient573(void);
void ObjectStublessClient574(void);
void ObjectStublessClient575(void);
void ObjectStublessClient576(void);
void ObjectStublessClient577(void);
void ObjectStublessClient578(void);
void ObjectStublessClient579(void);
void ObjectStublessClient580(void);
void ObjectStublessClient581(void);
void ObjectStublessClient582(void);
void ObjectStublessClient583(void);
void ObjectStublessClient584(void);
void ObjectStublessClient585(void);
void ObjectStublessClient586(void);
void ObjectStublessClient587(void);
void ObjectStublessClient588(void);
void ObjectStublessClient589(void);
void ObjectStublessClient590(void);
void ObjectStublessClient591(void);
void ObjectStublessClient592(void);
void ObjectStublessClient593(void);
void ObjectStublessClient594(void);
void ObjectStublessClient595(void);
void ObjectStublessClient596(void);
void ObjectStublessClient597(void);
void ObjectStublessClient598(void);
void ObjectStublessClient599(void);
void ObjectStublessClient600(void);
void ObjectStublessClient601(void);
void ObjectStublessClient602(void);
void ObjectStublessClient603(void);
void ObjectStublessClient604(void);
void ObjectStublessClient605(void);
void ObjectStublessClient606(void);
void ObjectStublessClient607(void);
void ObjectStublessClient608(void);
void ObjectStublessClient609(void);
void ObjectStublessClient610(void);
void ObjectStublessClient611(void);
void ObjectStublessClient612(void);
void ObjectStublessClient613(void);
void ObjectStublessClient614(void);
void ObjectStublessClient615(void);
void ObjectStublessClient616(void);
void ObjectStublessClient617(void);
void ObjectStublessClient618(void);
void ObjectStublessClient619(void);
void ObjectStublessClient620(void);
void ObjectStublessClient621(void);
void ObjectStublessClient622(void);
void ObjectStublessClient623(void);
void ObjectStublessClient624(void);
void ObjectStublessClient625(void);
void ObjectStublessClient626(void);
void ObjectStublessClient627(void);
void ObjectStublessClient628(void);
void ObjectStublessClient629(void);
void ObjectStublessClient630(void);
void ObjectStublessClient631(void);
void ObjectStublessClient632(void);
void ObjectStublessClient633(void);
void ObjectStublessClient634(void);
void ObjectStublessClient635(void);
void ObjectStublessClient636(void);
void ObjectStublessClient637(void);
void ObjectStublessClient638(void);
void ObjectStublessClient639(void);
void ObjectStublessClient640(void);
void ObjectStublessClient641(void);
void ObjectStublessClient642(void);
void ObjectStublessClient643(void);
void ObjectStublessClient644(void);
void ObjectStublessClient645(void);
void ObjectStublessClient646(void);
void ObjectStublessClient647(void);
void ObjectStublessClient648(void);
void ObjectStublessClient649(void);
void ObjectStublessClient650(void);
void ObjectStublessClient651(void);
void ObjectStublessClient652(void);
void ObjectStublessClient653(void);
void ObjectStublessClient654(void);
void ObjectStublessClient655(void);
void ObjectStublessClient656(void);
void ObjectStublessClient657(void);
void ObjectStublessClient658(void);
void ObjectStublessClient659(void);
void ObjectStublessClient660(void);
void ObjectStublessClient661(void);
void ObjectStublessClient662(void);
void ObjectStublessClient663(void);
void ObjectStublessClient664(void);
void ObjectStublessClient665(void);
void ObjectStublessClient666(void);
void ObjectStublessClient667(void);
void ObjectStublessClient668(void);
void ObjectStublessClient669(void);
void ObjectStublessClient670(void);
void ObjectStublessClient671(void);
void ObjectStublessClient672(void);
void ObjectStublessClient673(void);
void ObjectStublessClient674(void);
void ObjectStublessClient675(void);
void ObjectStublessClient676(void);
void ObjectStublessClient677(void);
void ObjectStublessClient678(void);
void ObjectStublessClient679(void);
void ObjectStublessClient680(void);
void ObjectStublessClient681(void);
void ObjectStublessClient682(void);
void ObjectStublessClient683(void);
void ObjectStublessClient684(void);
void ObjectStublessClient685(void);
void ObjectStublessClient686(void);
void ObjectStublessClient687(void);
void ObjectStublessClient688(void);
void ObjectStublessClient689(void);
void ObjectStublessClient690(void);
void ObjectStublessClient691(void);
void ObjectStublessClient692(void);
void ObjectStublessClient693(void);
void ObjectStublessClient694(void);
void ObjectStublessClient695(void);
void ObjectStublessClient696(void);
void ObjectStublessClient697(void);
void ObjectStublessClient698(void);
void ObjectStublessClient699(void);
void ObjectStublessClient700(void);
void ObjectStublessClient701(void);
void ObjectStublessClient702(void);
void ObjectStublessClient703(void);
void ObjectStublessClient704(void);
void ObjectStublessClient705(void);
void ObjectStublessClient706(void);
void ObjectStublessClient707(void);
void ObjectStublessClient708(void);
void ObjectStublessClient709(void);
void ObjectStublessClient710(void);
void ObjectStublessClient711(void);
void ObjectStublessClient712(void);
void ObjectStublessClient713(void);
void ObjectStublessClient714(void);
void ObjectStublessClient715(void);
void ObjectStublessClient716(void);
void ObjectStublessClient717(void);
void ObjectStublessClient718(void);
void ObjectStublessClient719(void);
void ObjectStublessClient720(void);
void ObjectStublessClient721(void);
void ObjectStublessClient722(void);
void ObjectStublessClient723(void);
void ObjectStublessClient724(void);
void ObjectStublessClient725(void);
void ObjectStublessClient726(void);
void ObjectStublessClient727(void);
void ObjectStublessClient728(void);
void ObjectStublessClient729(void);
void ObjectStublessClient730(void);
void ObjectStublessClient731(void);
void ObjectStublessClient732(void);
void ObjectStublessClient733(void);
void ObjectStublessClient734(void);
void ObjectStublessClient735(void);
void ObjectStublessClient736(void);
void ObjectStublessClient737(void);
void ObjectStublessClient738(void);
void ObjectStublessClient739(void);
void ObjectStublessClient740(void);
void ObjectStublessClient741(void);
void ObjectStublessClient742(void);
void ObjectStublessClient743(void);
void ObjectStublessClient744(void);
void ObjectStublessClient745(void);
void ObjectStublessClient746(void);
void ObjectStublessClient747(void);
void ObjectStublessClient748(void);
void ObjectStublessClient749(void);
void ObjectStublessClient750(void);
void ObjectStublessClient751(void);
void ObjectStublessClient752(void);
void ObjectStublessClient753(void);
void ObjectStublessClient754(void);
void ObjectStublessClient755(void);
void ObjectStublessClient756(void);
void ObjectStublessClient757(void);
void ObjectStublessClient758(void);
void ObjectStublessClient759(void);
void ObjectStublessClient760(void);
void ObjectStublessClient761(void);
void ObjectStublessClient762(void);
void ObjectStublessClient763(void);
void ObjectStublessClient764(void);
void ObjectStublessClient765(void);
void ObjectStublessClient766(void);
void ObjectStublessClient767(void);
void ObjectStublessClient768(void);
void ObjectStublessClient769(void);
void ObjectStublessClient770(void);
void ObjectStublessClient771(void);
void ObjectStublessClient772(void);
void ObjectStublessClient773(void);
void ObjectStublessClient774(void);
void ObjectStublessClient775(void);
void ObjectStublessClient776(void);
void ObjectStublessClient777(void);
void ObjectStublessClient778(void);
void ObjectStublessClient779(void);
void ObjectStublessClient780(void);
void ObjectStublessClient781(void);
void ObjectStublessClient782(void);
void ObjectStublessClient783(void);
void ObjectStublessClient784(void);
void ObjectStublessClient785(void);
void ObjectStublessClient786(void);
void ObjectStublessClient787(void);
void ObjectStublessClient788(void);
void ObjectStublessClient789(void);
void ObjectStublessClient790(void);
void ObjectStublessClient791(void);
void ObjectStublessClient792(void);
void ObjectStublessClient793(void);
void ObjectStublessClient794(void);
void ObjectStublessClient795(void);
void ObjectStublessClient796(void);
void ObjectStublessClient797(void);
void ObjectStublessClient798(void);
void ObjectStublessClient799(void);
void ObjectStublessClient800(void);
void ObjectStublessClient801(void);
void ObjectStublessClient802(void);
void ObjectStublessClient803(void);
void ObjectStublessClient804(void);
void ObjectStublessClient805(void);
void ObjectStublessClient806(void);
void ObjectStublessClient807(void);
void ObjectStublessClient808(void);
void ObjectStublessClient809(void);
void ObjectStublessClient810(void);
void ObjectStublessClient811(void);
void ObjectStublessClient812(void);
void ObjectStublessClient813(void);
void ObjectStublessClient814(void);
void ObjectStublessClient815(void);
void ObjectStublessClient816(void);
void ObjectStublessClient817(void);
void ObjectStublessClient818(void);
void ObjectStublessClient819(void);
void ObjectStublessClient820(void);
void ObjectStublessClient821(void);
void ObjectStublessClient822(void);
void ObjectStublessClient823(void);
void ObjectStublessClient824(void);
void ObjectStublessClient825(void);
void ObjectStublessClient826(void);
void ObjectStublessClient827(void);
void ObjectStublessClient828(void);
void ObjectStublessClient829(void);
void ObjectStublessClient830(void);
void ObjectStublessClient831(void);
void ObjectStublessClient832(void);
void ObjectStublessClient833(void);
void ObjectStublessClient834(void);
void ObjectStublessClient835(void);
void ObjectStublessClient836(void);
void ObjectStublessClient837(void);
void ObjectStublessClient838(void);
void ObjectStublessClient839(void);
void ObjectStublessClient840(void);
void ObjectStublessClient841(void);
void ObjectStublessClient842(void);
void ObjectStublessClient843(void);
void ObjectStublessClient844(void);
void ObjectStublessClient845(void);
void ObjectStublessClient846(void);
void ObjectStublessClient847(void);
void ObjectStublessClient848(void);
void ObjectStublessClient849(void);
void ObjectStublessClient850(void);
void ObjectStublessClient851(void);
void ObjectStublessClient852(void);
void ObjectStublessClient853(void);
void ObjectStublessClient854(void);
void ObjectStublessClient855(void);
void ObjectStublessClient856(void);
void ObjectStublessClient857(void);
void ObjectStublessClient858(void);
void ObjectStublessClient859(void);
void ObjectStublessClient860(void);
void ObjectStublessClient861(void);
void ObjectStublessClient862(void);
void ObjectStublessClient863(void);
void ObjectStublessClient864(void);
void ObjectStublessClient865(void);
void ObjectStublessClient866(void);
void ObjectStublessClient867(void);
void ObjectStublessClient868(void);
void ObjectStublessClient869(void);
void ObjectStublessClient870(void);
void ObjectStublessClient871(void);
void ObjectStublessClient872(void);
void ObjectStublessClient873(void);
void ObjectStublessClient874(void);
void ObjectStublessClient875(void);
void ObjectStublessClient876(void);
void ObjectStublessClient877(void);
void ObjectStublessClient878(void);
void ObjectStublessClient879(void);
void ObjectStublessClient880(void);
void ObjectStublessClient881(void);
void ObjectStublessClient882(void);
void ObjectStublessClient883(void);
void ObjectStublessClient884(void);
void ObjectStublessClient885(void);
void ObjectStublessClient886(void);
void ObjectStublessClient887(void);
void ObjectStublessClient888(void);
void ObjectStublessClient889(void);
void ObjectStublessClient890(void);
void ObjectStublessClient891(void);
void ObjectStublessClient892(void);
void ObjectStublessClient893(void);
void ObjectStublessClient894(void);
void ObjectStublessClient895(void);
void ObjectStublessClient896(void);
void ObjectStublessClient897(void);
void ObjectStublessClient898(void);
void ObjectStublessClient899(void);
void ObjectStublessClient900(void);
void ObjectStublessClient901(void);
void ObjectStublessClient902(void);
void ObjectStublessClient903(void);
void ObjectStublessClient904(void);
void ObjectStublessClient905(void);
void ObjectStublessClient906(void);
void ObjectStublessClient907(void);
void ObjectStublessClient908(void);
void ObjectStublessClient909(void);
void ObjectStublessClient910(void);
void ObjectStublessClient911(void);
void ObjectStublessClient912(void);
void ObjectStublessClient913(void);
void ObjectStublessClient914(void);
void ObjectStublessClient915(void);
void ObjectStublessClient916(void);
void ObjectStublessClient917(void);
void ObjectStublessClient918(void);
void ObjectStublessClient919(void);
void ObjectStublessClient920(void);
void ObjectStublessClient921(void);
void ObjectStublessClient922(void);
void ObjectStublessClient923(void);
void ObjectStublessClient924(void);
void ObjectStublessClient925(void);
void ObjectStublessClient926(void);
void ObjectStublessClient927(void);
void ObjectStublessClient928(void);
void ObjectStublessClient929(void);
void ObjectStublessClient930(void);
void ObjectStublessClient931(void);
void ObjectStublessClient932(void);
void ObjectStublessClient933(void);
void ObjectStublessClient934(void);
void ObjectStublessClient935(void);
void ObjectStublessClient936(void);
void ObjectStublessClient937(void);
void ObjectStublessClient938(void);
void ObjectStublessClient939(void);
void ObjectStublessClient940(void);
void ObjectStublessClient941(void);
void ObjectStublessClient942(void);
void ObjectStublessClient943(void);
void ObjectStublessClient944(void);
void ObjectStublessClient945(void);
void ObjectStublessClient946(void);
void ObjectStublessClient947(void);
void ObjectStublessClient948(void);
void ObjectStublessClient949(void);
void ObjectStublessClient950(void);
void ObjectStublessClient951(void);
void ObjectStublessClient952(void);
void ObjectStublessClient953(void);
void ObjectStublessClient954(void);
void ObjectStublessClient955(void);
void ObjectStublessClient956(void);
void ObjectStublessClient957(void);
void ObjectStublessClient958(void);
void ObjectStublessClient959(void);
void ObjectStublessClient960(void);
void ObjectStublessClient961(void);
void ObjectStublessClient962(void);
void ObjectStublessClient963(void);
void ObjectStublessClient964(void);
void ObjectStublessClient965(void);
void ObjectStublessClient966(void);
void ObjectStublessClient967(void);
void ObjectStublessClient968(void);
void ObjectStublessClient969(void);
void ObjectStublessClient970(void);
void ObjectStublessClient971(void);
void ObjectStublessClient972(void);
void ObjectStublessClient973(void);
void ObjectStublessClient974(void);
void ObjectStublessClient975(void);
void ObjectStublessClient976(void);
void ObjectStublessClient977(void);
void ObjectStublessClient978(void);
void ObjectStublessClient979(void);
void ObjectStublessClient980(void);
void ObjectStublessClient981(void);
void ObjectStublessClient982(void);
void ObjectStublessClient983(void);
void ObjectStublessClient984(void);
void ObjectStublessClient985(void);
void ObjectStublessClient986(void);
void ObjectStublessClient987(void);
void ObjectStublessClient988(void);
void ObjectStublessClient989(void);
void ObjectStublessClient990(void);
void ObjectStublessClient991(void);
void ObjectStublessClient992(void);
void ObjectStublessClient993(void);
void ObjectStublessClient994(void);
void ObjectStublessClient995(void);
void ObjectStublessClient996(void);
void ObjectStublessClient997(void);
void ObjectStublessClient998(void);
void ObjectStublessClient999(void);
void ObjectStublessClient1000(void);
void ObjectStublessClient1001(void);
void ObjectStublessClient1002(void);
void ObjectStublessClient1003(void);
void ObjectStublessClient1004(void);
void ObjectStublessClient1005(void);
void ObjectStublessClient1006(void);
void ObjectStublessClient1007(void);
void ObjectStublessClient1008(void);
void ObjectStublessClient1009(void);
void ObjectStublessClient1010(void);
void ObjectStublessClient1011(void);
void ObjectStublessClient1012(void);
void ObjectStublessClient1013(void);
void ObjectStublessClient1014(void);
void ObjectStublessClient1015(void);
void ObjectStublessClient1016(void);
void ObjectStublessClient1017(void);
void ObjectStublessClient1018(void);
void ObjectStublessClient1019(void);
void ObjectStublessClient1020(void);
void ObjectStublessClient1021(void);
void ObjectStublessClient1022(void);
void ObjectStublessClient1023(void);

extern void * const g_StublessClientVtbl[1024] =
    {
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy,
    ObjectStublessClient3,
    ObjectStublessClient4,
    ObjectStublessClient5,
    ObjectStublessClient6,
    ObjectStublessClient7,
    ObjectStublessClient8,
    ObjectStublessClient9,
    ObjectStublessClient10,
    ObjectStublessClient11,
    ObjectStublessClient12,
    ObjectStublessClient13,
    ObjectStublessClient14,
    ObjectStublessClient15,
    ObjectStublessClient16,
    ObjectStublessClient17,
    ObjectStublessClient18,
    ObjectStublessClient19,
    ObjectStublessClient20,
    ObjectStublessClient21,
    ObjectStublessClient22,
    ObjectStublessClient23,
    ObjectStublessClient24,
    ObjectStublessClient25,
    ObjectStublessClient26,
    ObjectStublessClient27,
    ObjectStublessClient28,
    ObjectStublessClient29,
    ObjectStublessClient30,
    ObjectStublessClient31,
    ObjectStublessClient32,
    ObjectStublessClient33,
    ObjectStublessClient34,
    ObjectStublessClient35,
    ObjectStublessClient36,
    ObjectStublessClient37,
    ObjectStublessClient38,
    ObjectStublessClient39,
    ObjectStublessClient40,
    ObjectStublessClient41,
    ObjectStublessClient42,
    ObjectStublessClient43,
    ObjectStublessClient44,
    ObjectStublessClient45,
    ObjectStublessClient46,
    ObjectStublessClient47,
    ObjectStublessClient48,
    ObjectStublessClient49,
    ObjectStublessClient50,
    ObjectStublessClient51,
    ObjectStublessClient52,
    ObjectStublessClient53,
    ObjectStublessClient54,
    ObjectStublessClient55,
    ObjectStublessClient56,
    ObjectStublessClient57,
    ObjectStublessClient58,
    ObjectStublessClient59,
    ObjectStublessClient60,
    ObjectStublessClient61,
    ObjectStublessClient62,
    ObjectStublessClient63,
    ObjectStublessClient64,
    ObjectStublessClient65,
    ObjectStublessClient66,
    ObjectStublessClient67,
    ObjectStublessClient68,
    ObjectStublessClient69,
    ObjectStublessClient70,
    ObjectStublessClient71,
    ObjectStublessClient72,
    ObjectStublessClient73,
    ObjectStublessClient74,
    ObjectStublessClient75,
    ObjectStublessClient76,
    ObjectStublessClient77,
    ObjectStublessClient78,
    ObjectStublessClient79,
    ObjectStublessClient80,
    ObjectStublessClient81,
    ObjectStublessClient82,
    ObjectStublessClient83,
    ObjectStublessClient84,
    ObjectStublessClient85,
    ObjectStublessClient86,
    ObjectStublessClient87,
    ObjectStublessClient88,
    ObjectStublessClient89,
    ObjectStublessClient90,
    ObjectStublessClient91,
    ObjectStublessClient92,
    ObjectStublessClient93,
    ObjectStublessClient94,
    ObjectStublessClient95,
    ObjectStublessClient96,
    ObjectStublessClient97,
    ObjectStublessClient98,
    ObjectStublessClient99,
    ObjectStublessClient100,
    ObjectStublessClient101,
    ObjectStublessClient102,
    ObjectStublessClient103,
    ObjectStublessClient104,
    ObjectStublessClient105,
    ObjectStublessClient106,
    ObjectStublessClient107,
    ObjectStublessClient108,
    ObjectStublessClient109,
    ObjectStublessClient110,
    ObjectStublessClient111,
    ObjectStublessClient112,
    ObjectStublessClient113,
    ObjectStublessClient114,
    ObjectStublessClient115,
    ObjectStublessClient116,
    ObjectStublessClient117,
    ObjectStublessClient118,
    ObjectStublessClient119,
    ObjectStublessClient120,
    ObjectStublessClient121,
    ObjectStublessClient122,
    ObjectStublessClient123,
    ObjectStublessClient124,
    ObjectStublessClient125,
    ObjectStublessClient126,
    ObjectStublessClient127,
    ObjectStublessClient128,
    ObjectStublessClient129,
    ObjectStublessClient130,
    ObjectStublessClient131,
    ObjectStublessClient132,
    ObjectStublessClient133,
    ObjectStublessClient134,
    ObjectStublessClient135,
    ObjectStublessClient136,
    ObjectStublessClient137,
    ObjectStublessClient138,
    ObjectStublessClient139,
    ObjectStublessClient140,
    ObjectStublessClient141,
    ObjectStublessClient142,
    ObjectStublessClient143,
    ObjectStublessClient144,
    ObjectStublessClient145,
    ObjectStublessClient146,
    ObjectStublessClient147,
    ObjectStublessClient148,
    ObjectStublessClient149,
    ObjectStublessClient150,
    ObjectStublessClient151,
    ObjectStublessClient152,
    ObjectStublessClient153,
    ObjectStublessClient154,
    ObjectStublessClient155,
    ObjectStublessClient156,
    ObjectStublessClient157,
    ObjectStublessClient158,
    ObjectStublessClient159,
    ObjectStublessClient160,
    ObjectStublessClient161,
    ObjectStublessClient162,
    ObjectStublessClient163,
    ObjectStublessClient164,
    ObjectStublessClient165,
    ObjectStublessClient166,
    ObjectStublessClient167,
    ObjectStublessClient168,
    ObjectStublessClient169,
    ObjectStublessClient170,
    ObjectStublessClient171,
    ObjectStublessClient172,
    ObjectStublessClient173,
    ObjectStublessClient174,
    ObjectStublessClient175,
    ObjectStublessClient176,
    ObjectStublessClient177,
    ObjectStublessClient178,
    ObjectStublessClient179,
    ObjectStublessClient180,
    ObjectStublessClient181,
    ObjectStublessClient182,
    ObjectStublessClient183,
    ObjectStublessClient184,
    ObjectStublessClient185,
    ObjectStublessClient186,
    ObjectStublessClient187,
    ObjectStublessClient188,
    ObjectStublessClient189,
    ObjectStublessClient190,
    ObjectStublessClient191,
    ObjectStublessClient192,
    ObjectStublessClient193,
    ObjectStublessClient194,
    ObjectStublessClient195,
    ObjectStublessClient196,
    ObjectStublessClient197,
    ObjectStublessClient198,
    ObjectStublessClient199,
    ObjectStublessClient200,
    ObjectStublessClient201,
    ObjectStublessClient202,
    ObjectStublessClient203,
    ObjectStublessClient204,
    ObjectStublessClient205,
    ObjectStublessClient206,
    ObjectStublessClient207,
    ObjectStublessClient208,
    ObjectStublessClient209,
    ObjectStublessClient210,
    ObjectStublessClient211,
    ObjectStublessClient212,
    ObjectStublessClient213,
    ObjectStublessClient214,
    ObjectStublessClient215,
    ObjectStublessClient216,
    ObjectStublessClient217,
    ObjectStublessClient218,
    ObjectStublessClient219,
    ObjectStublessClient220,
    ObjectStublessClient221,
    ObjectStublessClient222,
    ObjectStublessClient223,
    ObjectStublessClient224,
    ObjectStublessClient225,
    ObjectStublessClient226,
    ObjectStublessClient227,
    ObjectStublessClient228,
    ObjectStublessClient229,
    ObjectStublessClient230,
    ObjectStublessClient231,
    ObjectStublessClient232,
    ObjectStublessClient233,
    ObjectStublessClient234,
    ObjectStublessClient235,
    ObjectStublessClient236,
    ObjectStublessClient237,
    ObjectStublessClient238,
    ObjectStublessClient239,
    ObjectStublessClient240,
    ObjectStublessClient241,
    ObjectStublessClient242,
    ObjectStublessClient243,
    ObjectStublessClient244,
    ObjectStublessClient245,
    ObjectStublessClient246,
    ObjectStublessClient247,
    ObjectStublessClient248,
    ObjectStublessClient249,
    ObjectStublessClient250,
    ObjectStublessClient251,
    ObjectStublessClient252,
    ObjectStublessClient253,
    ObjectStublessClient254,
    ObjectStublessClient255,
    ObjectStublessClient256,
    ObjectStublessClient257,
    ObjectStublessClient258,
    ObjectStublessClient259,
    ObjectStublessClient260,
    ObjectStublessClient261,
    ObjectStublessClient262,
    ObjectStublessClient263,
    ObjectStublessClient264,
    ObjectStublessClient265,
    ObjectStublessClient266,
    ObjectStublessClient267,
    ObjectStublessClient268,
    ObjectStublessClient269,
    ObjectStublessClient270,
    ObjectStublessClient271,
    ObjectStublessClient272,
    ObjectStublessClient273,
    ObjectStublessClient274,
    ObjectStublessClient275,
    ObjectStublessClient276,
    ObjectStublessClient277,
    ObjectStublessClient278,
    ObjectStublessClient279,
    ObjectStublessClient280,
    ObjectStublessClient281,
    ObjectStublessClient282,
    ObjectStublessClient283,
    ObjectStublessClient284,
    ObjectStublessClient285,
    ObjectStublessClient286,
    ObjectStublessClient287,
    ObjectStublessClient288,
    ObjectStublessClient289,
    ObjectStublessClient290,
    ObjectStublessClient291,
    ObjectStublessClient292,
    ObjectStublessClient293,
    ObjectStublessClient294,
    ObjectStublessClient295,
    ObjectStublessClient296,
    ObjectStublessClient297,
    ObjectStublessClient298,
    ObjectStublessClient299,
    ObjectStublessClient300,
    ObjectStublessClient301,
    ObjectStublessClient302,
    ObjectStublessClient303,
    ObjectStublessClient304,
    ObjectStublessClient305,
    ObjectStublessClient306,
    ObjectStublessClient307,
    ObjectStublessClient308,
    ObjectStublessClient309,
    ObjectStublessClient310,
    ObjectStublessClient311,
    ObjectStublessClient312,
    ObjectStublessClient313,
    ObjectStublessClient314,
    ObjectStublessClient315,
    ObjectStublessClient316,
    ObjectStublessClient317,
    ObjectStublessClient318,
    ObjectStublessClient319,
    ObjectStublessClient320,
    ObjectStublessClient321,
    ObjectStublessClient322,
    ObjectStublessClient323,
    ObjectStublessClient324,
    ObjectStublessClient325,
    ObjectStublessClient326,
    ObjectStublessClient327,
    ObjectStublessClient328,
    ObjectStublessClient329,
    ObjectStublessClient330,
    ObjectStublessClient331,
    ObjectStublessClient332,
    ObjectStublessClient333,
    ObjectStublessClient334,
    ObjectStublessClient335,
    ObjectStublessClient336,
    ObjectStublessClient337,
    ObjectStublessClient338,
    ObjectStublessClient339,
    ObjectStublessClient340,
    ObjectStublessClient341,
    ObjectStublessClient342,
    ObjectStublessClient343,
    ObjectStublessClient344,
    ObjectStublessClient345,
    ObjectStublessClient346,
    ObjectStublessClient347,
    ObjectStublessClient348,
    ObjectStublessClient349,
    ObjectStublessClient350,
    ObjectStublessClient351,
    ObjectStublessClient352,
    ObjectStublessClient353,
    ObjectStublessClient354,
    ObjectStublessClient355,
    ObjectStublessClient356,
    ObjectStublessClient357,
    ObjectStublessClient358,
    ObjectStublessClient359,
    ObjectStublessClient360,
    ObjectStublessClient361,
    ObjectStublessClient362,
    ObjectStublessClient363,
    ObjectStublessClient364,
    ObjectStublessClient365,
    ObjectStublessClient366,
    ObjectStublessClient367,
    ObjectStublessClient368,
    ObjectStublessClient369,
    ObjectStublessClient370,
    ObjectStublessClient371,
    ObjectStublessClient372,
    ObjectStublessClient373,
    ObjectStublessClient374,
    ObjectStublessClient375,
    ObjectStublessClient376,
    ObjectStublessClient377,
    ObjectStublessClient378,
    ObjectStublessClient379,
    ObjectStublessClient380,
    ObjectStublessClient381,
    ObjectStublessClient382,
    ObjectStublessClient383,
    ObjectStublessClient384,
    ObjectStublessClient385,
    ObjectStublessClient386,
    ObjectStublessClient387,
    ObjectStublessClient388,
    ObjectStublessClient389,
    ObjectStublessClient390,
    ObjectStublessClient391,
    ObjectStublessClient392,
    ObjectStublessClient393,
    ObjectStublessClient394,
    ObjectStublessClient395,
    ObjectStublessClient396,
    ObjectStublessClient397,
    ObjectStublessClient398,
    ObjectStublessClient399,
    ObjectStublessClient400,
    ObjectStublessClient401,
    ObjectStublessClient402,
    ObjectStublessClient403,
    ObjectStublessClient404,
    ObjectStublessClient405,
    ObjectStublessClient406,
    ObjectStublessClient407,
    ObjectStublessClient408,
    ObjectStublessClient409,
    ObjectStublessClient410,
    ObjectStublessClient411,
    ObjectStublessClient412,
    ObjectStublessClient413,
    ObjectStublessClient414,
    ObjectStublessClient415,
    ObjectStublessClient416,
    ObjectStublessClient417,
    ObjectStublessClient418,
    ObjectStublessClient419,
    ObjectStublessClient420,
    ObjectStublessClient421,
    ObjectStublessClient422,
    ObjectStublessClient423,
    ObjectStublessClient424,
    ObjectStublessClient425,
    ObjectStublessClient426,
    ObjectStublessClient427,
    ObjectStublessClient428,
    ObjectStublessClient429,
    ObjectStublessClient430,
    ObjectStublessClient431,
    ObjectStublessClient432,
    ObjectStublessClient433,
    ObjectStublessClient434,
    ObjectStublessClient435,
    ObjectStublessClient436,
    ObjectStublessClient437,
    ObjectStublessClient438,
    ObjectStublessClient439,
    ObjectStublessClient440,
    ObjectStublessClient441,
    ObjectStublessClient442,
    ObjectStublessClient443,
    ObjectStublessClient444,
    ObjectStublessClient445,
    ObjectStublessClient446,
    ObjectStublessClient447,
    ObjectStublessClient448,
    ObjectStublessClient449,
    ObjectStublessClient450,
    ObjectStublessClient451,
    ObjectStublessClient452,
    ObjectStublessClient453,
    ObjectStublessClient454,
    ObjectStublessClient455,
    ObjectStublessClient456,
    ObjectStublessClient457,
    ObjectStublessClient458,
    ObjectStublessClient459,
    ObjectStublessClient460,
    ObjectStublessClient461,
    ObjectStublessClient462,
    ObjectStublessClient463,
    ObjectStublessClient464,
    ObjectStublessClient465,
    ObjectStublessClient466,
    ObjectStublessClient467,
    ObjectStublessClient468,
    ObjectStublessClient469,
    ObjectStublessClient470,
    ObjectStublessClient471,
    ObjectStublessClient472,
    ObjectStublessClient473,
    ObjectStublessClient474,
    ObjectStublessClient475,
    ObjectStublessClient476,
    ObjectStublessClient477,
    ObjectStublessClient478,
    ObjectStublessClient479,
    ObjectStublessClient480,
    ObjectStublessClient481,
    ObjectStublessClient482,
    ObjectStublessClient483,
    ObjectStublessClient484,
    ObjectStublessClient485,
    ObjectStublessClient486,
    ObjectStublessClient487,
    ObjectStublessClient488,
    ObjectStublessClient489,
    ObjectStublessClient490,
    ObjectStublessClient491,
    ObjectStublessClient492,
    ObjectStublessClient493,
    ObjectStublessClient494,
    ObjectStublessClient495,
    ObjectStublessClient496,
    ObjectStublessClient497,
    ObjectStublessClient498,
    ObjectStublessClient499,
    ObjectStublessClient500,
    ObjectStublessClient501,
    ObjectStublessClient502,
    ObjectStublessClient503,
    ObjectStublessClient504,
    ObjectStublessClient505,
    ObjectStublessClient506,
    ObjectStublessClient507,
    ObjectStublessClient508,
    ObjectStublessClient509,
    ObjectStublessClient510,
    ObjectStublessClient511,
    ObjectStublessClient512,
    ObjectStublessClient513,
    ObjectStublessClient514,
    ObjectStublessClient515,
    ObjectStublessClient516,
    ObjectStublessClient517,
    ObjectStublessClient518,
    ObjectStublessClient519,
    ObjectStublessClient520,
    ObjectStublessClient521,
    ObjectStublessClient522,
    ObjectStublessClient523,
    ObjectStublessClient524,
    ObjectStublessClient525,
    ObjectStublessClient526,
    ObjectStublessClient527,
    ObjectStublessClient528,
    ObjectStublessClient529,
    ObjectStublessClient530,
    ObjectStublessClient531,
    ObjectStublessClient532,
    ObjectStublessClient533,
    ObjectStublessClient534,
    ObjectStublessClient535,
    ObjectStublessClient536,
    ObjectStublessClient537,
    ObjectStublessClient538,
    ObjectStublessClient539,
    ObjectStublessClient540,
    ObjectStublessClient541,
    ObjectStublessClient542,
    ObjectStublessClient543,
    ObjectStublessClient544,
    ObjectStublessClient545,
    ObjectStublessClient546,
    ObjectStublessClient547,
    ObjectStublessClient548,
    ObjectStublessClient549,
    ObjectStublessClient550,
    ObjectStublessClient551,
    ObjectStublessClient552,
    ObjectStublessClient553,
    ObjectStublessClient554,
    ObjectStublessClient555,
    ObjectStublessClient556,
    ObjectStublessClient557,
    ObjectStublessClient558,
    ObjectStublessClient559,
    ObjectStublessClient560,
    ObjectStublessClient561,
    ObjectStublessClient562,
    ObjectStublessClient563,
    ObjectStublessClient564,
    ObjectStublessClient565,
    ObjectStublessClient566,
    ObjectStublessClient567,
    ObjectStublessClient568,
    ObjectStublessClient569,
    ObjectStublessClient570,
    ObjectStublessClient571,
    ObjectStublessClient572,
    ObjectStublessClient573,
    ObjectStublessClient574,
    ObjectStublessClient575,
    ObjectStublessClient576,
    ObjectStublessClient577,
    ObjectStublessClient578,
    ObjectStublessClient579,
    ObjectStublessClient580,
    ObjectStublessClient581,
    ObjectStublessClient582,
    ObjectStublessClient583,
    ObjectStublessClient584,
    ObjectStublessClient585,
    ObjectStublessClient586,
    ObjectStublessClient587,
    ObjectStublessClient588,
    ObjectStublessClient589,
    ObjectStublessClient590,
    ObjectStublessClient591,
    ObjectStublessClient592,
    ObjectStublessClient593,
    ObjectStublessClient594,
    ObjectStublessClient595,
    ObjectStublessClient596,
    ObjectStublessClient597,
    ObjectStublessClient598,
    ObjectStublessClient599,
    ObjectStublessClient600,
    ObjectStublessClient601,
    ObjectStublessClient602,
    ObjectStublessClient603,
    ObjectStublessClient604,
    ObjectStublessClient605,
    ObjectStublessClient606,
    ObjectStublessClient607,
    ObjectStublessClient608,
    ObjectStublessClient609,
    ObjectStublessClient610,
    ObjectStublessClient611,
    ObjectStublessClient612,
    ObjectStublessClient613,
    ObjectStublessClient614,
    ObjectStublessClient615,
    ObjectStublessClient616,
    ObjectStublessClient617,
    ObjectStublessClient618,
    ObjectStublessClient619,
    ObjectStublessClient620,
    ObjectStublessClient621,
    ObjectStublessClient622,
    ObjectStublessClient623,
    ObjectStublessClient624,
    ObjectStublessClient625,
    ObjectStublessClient626,
    ObjectStublessClient627,
    ObjectStublessClient628,
    ObjectStublessClient629,
    ObjectStublessClient630,
    ObjectStublessClient631,
    ObjectStublessClient632,
    ObjectStublessClient633,
    ObjectStublessClient634,
    ObjectStublessClient635,
    ObjectStublessClient636,
    ObjectStublessClient637,
    ObjectStublessClient638,
    ObjectStublessClient639,
    ObjectStublessClient640,
    ObjectStublessClient641,
    ObjectStublessClient642,
    ObjectStublessClient643,
    ObjectStublessClient644,
    ObjectStublessClient645,
    ObjectStublessClient646,
    ObjectStublessClient647,
    ObjectStublessClient648,
    ObjectStublessClient649,
    ObjectStublessClient650,
    ObjectStublessClient651,
    ObjectStublessClient652,
    ObjectStublessClient653,
    ObjectStublessClient654,
    ObjectStublessClient655,
    ObjectStublessClient656,
    ObjectStublessClient657,
    ObjectStublessClient658,
    ObjectStublessClient659,
    ObjectStublessClient660,
    ObjectStublessClient661,
    ObjectStublessClient662,
    ObjectStublessClient663,
    ObjectStublessClient664,
    ObjectStublessClient665,
    ObjectStublessClient666,
    ObjectStublessClient667,
    ObjectStublessClient668,
    ObjectStublessClient669,
    ObjectStublessClient670,
    ObjectStublessClient671,
    ObjectStublessClient672,
    ObjectStublessClient673,
    ObjectStublessClient674,
    ObjectStublessClient675,
    ObjectStublessClient676,
    ObjectStublessClient677,
    ObjectStublessClient678,
    ObjectStublessClient679,
    ObjectStublessClient680,
    ObjectStublessClient681,
    ObjectStublessClient682,
    ObjectStublessClient683,
    ObjectStublessClient684,
    ObjectStublessClient685,
    ObjectStublessClient686,
    ObjectStublessClient687,
    ObjectStublessClient688,
    ObjectStublessClient689,
    ObjectStublessClient690,
    ObjectStublessClient691,
    ObjectStublessClient692,
    ObjectStublessClient693,
    ObjectStublessClient694,
    ObjectStublessClient695,
    ObjectStublessClient696,
    ObjectStublessClient697,
    ObjectStublessClient698,
    ObjectStublessClient699,
    ObjectStublessClient700,
    ObjectStublessClient701,
    ObjectStublessClient702,
    ObjectStublessClient703,
    ObjectStublessClient704,
    ObjectStublessClient705,
    ObjectStublessClient706,
    ObjectStublessClient707,
    ObjectStublessClient708,
    ObjectStublessClient709,
    ObjectStublessClient710,
    ObjectStublessClient711,
    ObjectStublessClient712,
    ObjectStublessClient713,
    ObjectStublessClient714,
    ObjectStublessClient715,
    ObjectStublessClient716,
    ObjectStublessClient717,
    ObjectStublessClient718,
    ObjectStublessClient719,
    ObjectStublessClient720,
    ObjectStublessClient721,
    ObjectStublessClient722,
    ObjectStublessClient723,
    ObjectStublessClient724,
    ObjectStublessClient725,
    ObjectStublessClient726,
    ObjectStublessClient727,
    ObjectStublessClient728,
    ObjectStublessClient729,
    ObjectStublessClient730,
    ObjectStublessClient731,
    ObjectStublessClient732,
    ObjectStublessClient733,
    ObjectStublessClient734,
    ObjectStublessClient735,
    ObjectStublessClient736,
    ObjectStublessClient737,
    ObjectStublessClient738,
    ObjectStublessClient739,
    ObjectStublessClient740,
    ObjectStublessClient741,
    ObjectStublessClient742,
    ObjectStublessClient743,
    ObjectStublessClient744,
    ObjectStublessClient745,
    ObjectStublessClient746,
    ObjectStublessClient747,
    ObjectStublessClient748,
    ObjectStublessClient749,
    ObjectStublessClient750,
    ObjectStublessClient751,
    ObjectStublessClient752,
    ObjectStublessClient753,
    ObjectStublessClient754,
    ObjectStublessClient755,
    ObjectStublessClient756,
    ObjectStublessClient757,
    ObjectStublessClient758,
    ObjectStublessClient759,
    ObjectStublessClient760,
    ObjectStublessClient761,
    ObjectStublessClient762,
    ObjectStublessClient763,
    ObjectStublessClient764,
    ObjectStublessClient765,
    ObjectStublessClient766,
    ObjectStublessClient767,
    ObjectStublessClient768,
    ObjectStublessClient769,
    ObjectStublessClient770,
    ObjectStublessClient771,
    ObjectStublessClient772,
    ObjectStublessClient773,
    ObjectStublessClient774,
    ObjectStublessClient775,
    ObjectStublessClient776,
    ObjectStublessClient777,
    ObjectStublessClient778,
    ObjectStublessClient779,
    ObjectStublessClient780,
    ObjectStublessClient781,
    ObjectStublessClient782,
    ObjectStublessClient783,
    ObjectStublessClient784,
    ObjectStublessClient785,
    ObjectStublessClient786,
    ObjectStublessClient787,
    ObjectStublessClient788,
    ObjectStublessClient789,
    ObjectStublessClient790,
    ObjectStublessClient791,
    ObjectStublessClient792,
    ObjectStublessClient793,
    ObjectStublessClient794,
    ObjectStublessClient795,
    ObjectStublessClient796,
    ObjectStublessClient797,
    ObjectStublessClient798,
    ObjectStublessClient799,
    ObjectStublessClient800,
    ObjectStublessClient801,
    ObjectStublessClient802,
    ObjectStublessClient803,
    ObjectStublessClient804,
    ObjectStublessClient805,
    ObjectStublessClient806,
    ObjectStublessClient807,
    ObjectStublessClient808,
    ObjectStublessClient809,
    ObjectStublessClient810,
    ObjectStublessClient811,
    ObjectStublessClient812,
    ObjectStublessClient813,
    ObjectStublessClient814,
    ObjectStublessClient815,
    ObjectStublessClient816,
    ObjectStublessClient817,
    ObjectStublessClient818,
    ObjectStublessClient819,
    ObjectStublessClient820,
    ObjectStublessClient821,
    ObjectStublessClient822,
    ObjectStublessClient823,
    ObjectStublessClient824,
    ObjectStublessClient825,
    ObjectStublessClient826,
    ObjectStublessClient827,
    ObjectStublessClient828,
    ObjectStublessClient829,
    ObjectStublessClient830,
    ObjectStublessClient831,
    ObjectStublessClient832,
    ObjectStublessClient833,
    ObjectStublessClient834,
    ObjectStublessClient835,
    ObjectStublessClient836,
    ObjectStublessClient837,
    ObjectStublessClient838,
    ObjectStublessClient839,
    ObjectStublessClient840,
    ObjectStublessClient841,
    ObjectStublessClient842,
    ObjectStublessClient843,
    ObjectStublessClient844,
    ObjectStublessClient845,
    ObjectStublessClient846,
    ObjectStublessClient847,
    ObjectStublessClient848,
    ObjectStublessClient849,
    ObjectStublessClient850,
    ObjectStublessClient851,
    ObjectStublessClient852,
    ObjectStublessClient853,
    ObjectStublessClient854,
    ObjectStublessClient855,
    ObjectStublessClient856,
    ObjectStublessClient857,
    ObjectStublessClient858,
    ObjectStublessClient859,
    ObjectStublessClient860,
    ObjectStublessClient861,
    ObjectStublessClient862,
    ObjectStublessClient863,
    ObjectStublessClient864,
    ObjectStublessClient865,
    ObjectStublessClient866,
    ObjectStublessClient867,
    ObjectStublessClient868,
    ObjectStublessClient869,
    ObjectStublessClient870,
    ObjectStublessClient871,
    ObjectStublessClient872,
    ObjectStublessClient873,
    ObjectStublessClient874,
    ObjectStublessClient875,
    ObjectStublessClient876,
    ObjectStublessClient877,
    ObjectStublessClient878,
    ObjectStublessClient879,
    ObjectStublessClient880,
    ObjectStublessClient881,
    ObjectStublessClient882,
    ObjectStublessClient883,
    ObjectStublessClient884,
    ObjectStublessClient885,
    ObjectStublessClient886,
    ObjectStublessClient887,
    ObjectStublessClient888,
    ObjectStublessClient889,
    ObjectStublessClient890,
    ObjectStublessClient891,
    ObjectStublessClient892,
    ObjectStublessClient893,
    ObjectStublessClient894,
    ObjectStublessClient895,
    ObjectStublessClient896,
    ObjectStublessClient897,
    ObjectStublessClient898,
    ObjectStublessClient899,
    ObjectStublessClient900,
    ObjectStublessClient901,
    ObjectStublessClient902,
    ObjectStublessClient903,
    ObjectStublessClient904,
    ObjectStublessClient905,
    ObjectStublessClient906,
    ObjectStublessClient907,
    ObjectStublessClient908,
    ObjectStublessClient909,
    ObjectStublessClient910,
    ObjectStublessClient911,
    ObjectStublessClient912,
    ObjectStublessClient913,
    ObjectStublessClient914,
    ObjectStublessClient915,
    ObjectStublessClient916,
    ObjectStublessClient917,
    ObjectStublessClient918,
    ObjectStublessClient919,
    ObjectStublessClient920,
    ObjectStublessClient921,
    ObjectStublessClient922,
    ObjectStublessClient923,
    ObjectStublessClient924,
    ObjectStublessClient925,
    ObjectStublessClient926,
    ObjectStublessClient927,
    ObjectStublessClient928,
    ObjectStublessClient929,
    ObjectStublessClient930,
    ObjectStublessClient931,
    ObjectStublessClient932,
    ObjectStublessClient933,
    ObjectStublessClient934,
    ObjectStublessClient935,
    ObjectStublessClient936,
    ObjectStublessClient937,
    ObjectStublessClient938,
    ObjectStublessClient939,
    ObjectStublessClient940,
    ObjectStublessClient941,
    ObjectStublessClient942,
    ObjectStublessClient943,
    ObjectStublessClient944,
    ObjectStublessClient945,
    ObjectStublessClient946,
    ObjectStublessClient947,
    ObjectStublessClient948,
    ObjectStublessClient949,
    ObjectStublessClient950,
    ObjectStublessClient951,
    ObjectStublessClient952,
    ObjectStublessClient953,
    ObjectStublessClient954,
    ObjectStublessClient955,
    ObjectStublessClient956,
    ObjectStublessClient957,
    ObjectStublessClient958,
    ObjectStublessClient959,
    ObjectStublessClient960,
    ObjectStublessClient961,
    ObjectStublessClient962,
    ObjectStublessClient963,
    ObjectStublessClient964,
    ObjectStublessClient965,
    ObjectStublessClient966,
    ObjectStublessClient967,
    ObjectStublessClient968,
    ObjectStublessClient969,
    ObjectStublessClient970,
    ObjectStublessClient971,
    ObjectStublessClient972,
    ObjectStublessClient973,
    ObjectStublessClient974,
    ObjectStublessClient975,
    ObjectStublessClient976,
    ObjectStublessClient977,
    ObjectStublessClient978,
    ObjectStublessClient979,
    ObjectStublessClient980,
    ObjectStublessClient981,
    ObjectStublessClient982,
    ObjectStublessClient983,
    ObjectStublessClient984,
    ObjectStublessClient985,
    ObjectStublessClient986,
    ObjectStublessClient987,
    ObjectStublessClient988,
    ObjectStublessClient989,
    ObjectStublessClient990,
    ObjectStublessClient991,
    ObjectStublessClient992,
    ObjectStublessClient993,
    ObjectStublessClient994,
    ObjectStublessClient995,
    ObjectStublessClient996,
    ObjectStublessClient997,
    ObjectStublessClient998,
    ObjectStublessClient999,
    ObjectStublessClient1000,
    ObjectStublessClient1001,
    ObjectStublessClient1002,
    ObjectStublessClient1003,
    ObjectStublessClient1004,
    ObjectStublessClient1005,
    ObjectStublessClient1006,
    ObjectStublessClient1007,
    ObjectStublessClient1008,
    ObjectStublessClient1009,
    ObjectStublessClient1010,
    ObjectStublessClient1011,
    ObjectStublessClient1012,
    ObjectStublessClient1013,
    ObjectStublessClient1014,
    ObjectStublessClient1015,
    ObjectStublessClient1016,
    ObjectStublessClient1017,
    ObjectStublessClient1018,
    ObjectStublessClient1019,
    ObjectStublessClient1020,
    ObjectStublessClient1021,
    ObjectStublessClient1022,
    ObjectStublessClient1023
    };
}

void
MergeFpArguments (
    REGISTER_TYPE *ArgumentList,
    REGISTER_TYPE *FloatRegisters,
    ULONG FloatMask
    )

/*++

Routine Description:

    This function merges floating arguments into the specified argument list.

    N.B. It is not possible for the first argument to be a floating value.

Arguments:

    ArgumentList - Supplies a pointer to the argument list.

    FloatingRegister - Supplies a pointer to possible floating register
        arguments.

    FloatMask - Supplies the floating value mask. Each pair of bits in the
        mask describe one argument.

Return Value:

    None.

--*/

{

    //
    // Merge floating values into argument list.
    //
    // N.B. It is not possible for the first argument to be a floating value.
    //

    if ((FloatMask & 0xe)) {
        ArgumentList[1] = FloatRegisters[0];
    }

    if ((FloatMask & 0x30)) {
        ArgumentList[2] = FloatRegisters[1];
    }

    if ((FloatMask & 0xe0)) {
        ArgumentList[3] = FloatRegisters[2];
    }
}

void ** StublessClientVtbl = (void **)g_StublessClientVtbl;

long
ObjectStublessClient(
    void *ParamAddress,
    REGISTER_TYPE *FloatRegisters,
    long Method
    )

/*++

Routine Description:

Arguments:

    ParamAddress - Supplies a pointer to the argument list.

    FloatRegisters - Supplies a pointer to the three saved floating argument
        registers (parameter zero is the this pointer).

    Method - Supplies the method number.

Return Value:

--*/

{

    PMIDL_STUBLESS_PROXY_INFO ProxyInfo;
    CInterfaceProxyHeader *ProxyHeader;
    PFORMAT_STRING ProcFormat;
    unsigned short ProcFormatOffset;
    CLIENT_CALL_RETURN Return;
    void *This;

    This = *(void **)ParamAddress;
    ProxyHeader =
        (CInterfaceProxyHeader *)(*((char **)This) - sizeof(CInterfaceProxyHeader));

    ProxyInfo = (PMIDL_STUBLESS_PROXY_INFO)ProxyHeader->pStublessProxyInfo;
    if (ProxyInfo->pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES) {
        NDR_PROC_CONTEXT ProcContext;
        HRESULT          hr;

        Ndr64ClientInitializeContext(NdrpGetSyntaxType(ProxyInfo->pTransferSyntax),
                                     ProxyInfo,
                                     Method,
                                     &ProcContext,
                                     (uchar *)ParamAddress);

        if (ProcContext.FloatDoubleMask != 0) {
            MergeFpArguments((REGISTER_TYPE *)ParamAddress,
                             FloatRegisters,
                             ProcContext.FloatDoubleMask);
        }

        if (ProcContext.IsAsync) {
            if (Method & 0x1) {
                hr =  MulNdrpBeginDcomAsyncClientCall(ProxyInfo,
                                                      Method,
                                                      &ProcContext,
                                                      ParamAddress);

            } else {
                hr =  MulNdrpFinishDcomAsyncClientCall(ProxyInfo,
                                                       Method,
                                                       &ProcContext,
                                                       ParamAddress);
            }

            Return.Simple = hr;

        } else {
            Return = NdrpClientCall3(This,
                                     ProxyInfo,
                                     Method,
                                     NULL,
                                     &ProcContext,
                                     (uchar *)ParamAddress);
        }

        return (long)Return.Simple;
    }

    ProcFormatOffset = ProxyInfo->FormatStringOffset[Method];
    ProcFormat = &ProxyInfo->ProcFormatString[ProcFormatOffset];

    //
    // The first public MIDL with 64b support was released with NT5 betA2.
    // We will ignore any MIDL earlier than the MIDL released with NT5/2000 beta3.
    // Change MIDL_VERSION_5_2_202 to the MIDL version for beta3, now at 5.2.221.
    //

    if (ProxyInfo->pStubDesc->MIDLVersion < MIDL_VERSION_5_2_202) {
        RpcRaiseException(RPC_X_WRONG_STUB_VERSION);
    }

    //
    // Since MIDL 3.0.39 we have a proc flag that indicates
    // which interpeter to call. This is because the NDR version
    // may be bigger than 1.1 for other reasons.
    // MIDL version is 5.2.+ so the flag is guaranteed to be there.
    //

    if (ProcFormat[1]  &  Oi_OBJ_USE_V2_INTERPRETER) {
        if (((PNDR_DCOM_OI2_PROC_HEADER)ProcFormat)->Oi2Flags.HasExtensions) {
            PNDR_PROC_HEADER_EXTS64 pExts =
                (PNDR_PROC_HEADER_EXTS64)(ProcFormat + sizeof(NDR_DCOM_OI2_PROC_HEADER));

            if (pExts->FloatArgMask != 0) {
                MergeFpArguments((REGISTER_TYPE *)ParamAddress,
                                 FloatRegisters,
                                 pExts->FloatArgMask);
            }
        }

        if (((PNDR_DCOM_OI2_PROC_HEADER)ProcFormat)->Oi2Flags.HasAsyncUuid) {
            Return = NdrDcomAsyncClientCall(ProxyInfo->pStubDesc,
                                            ProcFormat,
                                            ParamAddress);

        } else {
            Return = NdrClientCall2(ProxyInfo->pStubDesc,
                                    ProcFormat,
                                    ParamAddress);
        }

    } else {
        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
    }

    return (long)Return.Simple;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\amd64\forward.asm ===
title   "Ndr Proxy Forwarding Functions"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   forward.asm
;
; Abstract:
;
;   This module implements the proxy forwarding functions.
;
; Author:
;
;   David N. Cutler 30-Dec-2000
;
; Environment:
;
;   Any mode.
;
;-

include ksamd64.inc

        subttl  "Delegation Forwarding Functions"
;++
;
; VOID
; NdrProxyForwardingFunction<nnn>(
;    IN IUnknown *This,
;    ...
;    )
;
; Routine Description:
;
;   This function forwards a call to the proxy for the base interface.
;
; Arguments:
;
;   This (rcx) - Supplies a pointer to the interface proxy.
;
; Return Value:
;
;   None.
;
;--

;
; Define macro to generate forwarder functions.
;

subclass_offset equ 32

DELEGATION_FORWARDER macro Method

        LEAF_ENTRY NdrProxyForwardingFunction&Method, _TEXT$00

        mov     rcx, subclass_offset[rcx] ; get subclass object address
        mov     r10, [rcx]              ; get vtable address
        jmp     qword ptr (&Method * 8)[r10] ; transfer to method

        LEAF_END NdrProxyForwardingFunction&Method, _TEXT$00

        endm

;
; Generate forwarder functions.
;

index = 3

        rept    (255 - 3 + 1)

        DELEGATION_FORWARDER %index

index = index + 1

        endm

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\daytona\makefile.inc ===
# Copyright (c) 1993-1999 Microsoft Corporation
#
# Build wxndr20.lib from rpcndr20.lib. We need to remove all objects that
# have functions that are thunked (ie, under EXPORT_RT in rpcrt4.src) and
# not emulated.
$(O)\wxndr20.lib: $(O)\rpcndr20.lib
    lib /remove:$(O)\rpcssm.obj /out:$@ $?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\i386\forward.c ===
/*++

  Copyright  c  1994  Microsoft Corporation.  All rights reserved.

  Module Name:
     forward.c

  Abstract:
     This module implements the proxy forwarding functions.

  Author:
    ShannonC    26-Oct-94

  Environment:                     
   
     Any mode.
  Revision History:

--*/

#define STDMETHODCALLTYPE __stdcall
/*++

 VOID
 NdrProxyForwardingFunction<nnn>(...)

 Routine Description:

    This function forwards a call to the proxy for the base interface.

 Arguments:

    This [esp+4] - Points to an interface proxy.

 Return Value:

    None.

--*/

// Here is what a forwarder looks like
// we must:
//      change the "this" pointer in [esp+4] to point to the delegated object
//      fetch the correct entry from the vtable
//      call the function

#define SUBCLASS_OFFSET     16
#define VTABLE_ENTRY(n)     n*4

// Stop the C++ compiler from adding additional push instructions
// as well as generating the return sequence for the forwarder
// and so messing up our assembly stack when using -Od, etc.
// by using the _declspec().

#define DELEGATION_FORWARDER(method_num)        \
_declspec(naked) \
void STDMETHODCALLTYPE NdrProxyForwardingFunction##method_num() \
{ \
    /*Get this->pBaseProxy */ \
    __asm{mov   eax,  [esp + 4]} \
    __asm{mov   eax,  [eax + SUBCLASS_OFFSET]} \
    __asm{mov   [esp + 4], eax} \
    /*Get this->pBaseProxy->lpVtbl*/ \
    __asm{mov   eax,  [eax]} \
    /*Jump to interface member function*/ \
    __asm{mov   eax,  [eax + VTABLE_ENTRY(method_num)]} \
    __asm{jmp   eax} \
}

    DELEGATION_FORWARDER(3)

    DELEGATION_FORWARDER(4)

    DELEGATION_FORWARDER(5)

    DELEGATION_FORWARDER(6)

    DELEGATION_FORWARDER(7)
    
    DELEGATION_FORWARDER(8)
    
    DELEGATION_FORWARDER(9)
    
    DELEGATION_FORWARDER(10)
    
    DELEGATION_FORWARDER(11)
    
    DELEGATION_FORWARDER(12)
    
    DELEGATION_FORWARDER(13)
    
    DELEGATION_FORWARDER(14)
    
    DELEGATION_FORWARDER(15)
    
    DELEGATION_FORWARDER(16)
    
    DELEGATION_FORWARDER(17)
    
    DELEGATION_FORWARDER(18)
    
    DELEGATION_FORWARDER(19)
    
    DELEGATION_FORWARDER(20)
    
    DELEGATION_FORWARDER(21)
    
    DELEGATION_FORWARDER(22)
    
    DELEGATION_FORWARDER(23)
    
    DELEGATION_FORWARDER(24)
    
    DELEGATION_FORWARDER(25)
    
    DELEGATION_FORWARDER(26)
    
    DELEGATION_FORWARDER(27)
    
    DELEGATION_FORWARDER(28)
    
    DELEGATION_FORWARDER(29)
    
    DELEGATION_FORWARDER(30)
    
    DELEGATION_FORWARDER(31)
    
    DELEGATION_FORWARDER(32)
    
    DELEGATION_FORWARDER(33)
    
    DELEGATION_FORWARDER(34)
    
    DELEGATION_FORWARDER(35)
    
    DELEGATION_FORWARDER(36)
    
    DELEGATION_FORWARDER(37)
    
    DELEGATION_FORWARDER(38)
    
    DELEGATION_FORWARDER(39)
    
    DELEGATION_FORWARDER(40)
    
    DELEGATION_FORWARDER(41)
    
    DELEGATION_FORWARDER(42)
    
    DELEGATION_FORWARDER(43)
    
    DELEGATION_FORWARDER(44)
    
    DELEGATION_FORWARDER(45)
    
    DELEGATION_FORWARDER(46)
    
    DELEGATION_FORWARDER(47)
    
    DELEGATION_FORWARDER(48)
    
    DELEGATION_FORWARDER(49)
    
    DELEGATION_FORWARDER(50)
    
    DELEGATION_FORWARDER(51)
    
    DELEGATION_FORWARDER(52)
    
    DELEGATION_FORWARDER(53)
    
    DELEGATION_FORWARDER(54)
    
    DELEGATION_FORWARDER(55)
    
    DELEGATION_FORWARDER(56)
    
    DELEGATION_FORWARDER(57)
    
    DELEGATION_FORWARDER(58)
    
    DELEGATION_FORWARDER(59)
    
    DELEGATION_FORWARDER(60)
    
    DELEGATION_FORWARDER(61)
    
    DELEGATION_FORWARDER(62)
    
    DELEGATION_FORWARDER(63)
    
    DELEGATION_FORWARDER(64)
    
    DELEGATION_FORWARDER(65)
    
    DELEGATION_FORWARDER(66)
    
    DELEGATION_FORWARDER(67)
    
    DELEGATION_FORWARDER(68)
    
    DELEGATION_FORWARDER(69)
    
    DELEGATION_FORWARDER(70)
    
    DELEGATION_FORWARDER(71)
    
    DELEGATION_FORWARDER(72)
    
    DELEGATION_FORWARDER(73)
    
    DELEGATION_FORWARDER(74)
    
    DELEGATION_FORWARDER(75)
    
    DELEGATION_FORWARDER(76)
    
    DELEGATION_FORWARDER(77)
    
    DELEGATION_FORWARDER(78)
    
    DELEGATION_FORWARDER(79)
    
    DELEGATION_FORWARDER(80)
    
    DELEGATION_FORWARDER(81)
    
    DELEGATION_FORWARDER(82)
    
    DELEGATION_FORWARDER(83)
    
    DELEGATION_FORWARDER(84)
    
    DELEGATION_FORWARDER(85)
    
    DELEGATION_FORWARDER(86)
    
    DELEGATION_FORWARDER(87)
    
    DELEGATION_FORWARDER(88)
    
    DELEGATION_FORWARDER(89)
    
    DELEGATION_FORWARDER(90)
    
    DELEGATION_FORWARDER(91)
    
    DELEGATION_FORWARDER(92)
    
    DELEGATION_FORWARDER(93)
    
    DELEGATION_FORWARDER(94)
    
    DELEGATION_FORWARDER(95)
    
    DELEGATION_FORWARDER(96)
    
    DELEGATION_FORWARDER(97)
    
    DELEGATION_FORWARDER(98)
    
    DELEGATION_FORWARDER(99)
    
    DELEGATION_FORWARDER(100)
    
    DELEGATION_FORWARDER(101)
    
    DELEGATION_FORWARDER(102)
    
    DELEGATION_FORWARDER(103)
    
    DELEGATION_FORWARDER(104)
    
    DELEGATION_FORWARDER(105)
    
    DELEGATION_FORWARDER(106)
    
    DELEGATION_FORWARDER(107)
    
    DELEGATION_FORWARDER(108)
    
    DELEGATION_FORWARDER(109)
    
    DELEGATION_FORWARDER(110)
    
    DELEGATION_FORWARDER(111)
    
    DELEGATION_FORWARDER(112)
    
    DELEGATION_FORWARDER(113)
    
    DELEGATION_FORWARDER(114)
    
    DELEGATION_FORWARDER(115)
    
    DELEGATION_FORWARDER(116)
    
    DELEGATION_FORWARDER(117)
    
    DELEGATION_FORWARDER(118)
    
    DELEGATION_FORWARDER(119)
    
    DELEGATION_FORWARDER(120)
    
    DELEGATION_FORWARDER(121)
    
    DELEGATION_FORWARDER(122)
    
    DELEGATION_FORWARDER(123)
    
    DELEGATION_FORWARDER(124)
    
    DELEGATION_FORWARDER(125)
    
    DELEGATION_FORWARDER(126)
    
    DELEGATION_FORWARDER(127)
    

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\i386\stblsclt.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name :

    stblsclt.c

Abstract :

    This file contains the routines for support of stubless clients in
    object interfaces.

Note:
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IMPORTANT!
    THIS FILE IS PLATFORM SPECIFIC AND DUPLICATE AMONG ALL PLATFORMS. CHANING
        ONE FILE MEANS CHANGE ALL OF THEM!!!

Author :

    David Kays    dkays    February 1995.

Revision History :
    Yong Qu       YongQu    Oct. 1998 change to platform specific and allow unlimited
                                vtbl & delegation vtbl

---------------------------------------------------------------------*/

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include <stdarg.h>
#include "ndrp.h"
#include "hndl.h"
#include "interp2.h"
#include "ndrtypes.h"

#include "ndrole.h"
#include "mulsyntx.h"
#include "rpcproxy.h"

#pragma code_seg(".orpc")


typedef unsigned short  ushort;

#define NUMBER_OF_BLOCKS_PER_ALLOC 4

// for dynamically generated vtbl
#define NUMBER_OF_METHODS_PER_BLOCK 56
#define NUMBER_OF_FORWARDING_METHODS_PER_BLOCK 48
// pointed to array of masm macro. don't need to generate the buffer everytime.
#define CB_METHOD 4
// vtbl jmp talble
const BYTE CASM_GENERATESTUBLESS[] =
{
0x33, 0xC9,                 // xor eax,eax
0x8A, 0xC8,                 // move al,cl
0x81, 0xC1, 00,00,04,00,    // method id
0xFF, 0x25, 00,00,00,00     // long jmp to ObjectStubless@0
};

const BYTE CASM_GENERATEFORWARD[] = 
{
0x8b, 0x4c, 0x24, 0x04,     // mov ecx, [esp+4]
0x8b, 0x49, 0x10,           // mov ecx, [ecx+a]
0x89, 0x4c, 0x24, 0x4,      // mov [esp+4], ecx
0x8b, 0x09,                 // mov ecx, [ecx]
0x66, 0x98,                 // cbw
0x98,                       // cwde
5, 00, 10, 00, 00,          // add eax, 0x1000
0xc1, 0xe0, 0x02,           // shl eax, 0x2
0x8b, 0x04, 0x01,           // mov eax, [eax+ecx]
0xff, 0xe0                  // jmp eax
};


typedef struct tagStublessProcBuffer 
{
    BYTE pMethodsa[NUMBER_OF_METHODS_PER_BLOCK/2][CB_METHOD];
    struct tagStublessProcBuffer* pNext;
    BYTE pAsm[sizeof(CASM_GENERATESTUBLESS)];
    BYTE pMethodsb[NUMBER_OF_METHODS_PER_BLOCK/2][CB_METHOD];
} StublessProcBuffer, *PStublessProcBuffer;

static StublessProcBuffer * g_pStublessProcBuffer = NULL;

typedef struct tagForwardProcBuffer 
{
    BYTE pMethodsa[NUMBER_OF_FORWARDING_METHODS_PER_BLOCK/2][CB_METHOD];
    struct tagForwardProcBuffer* pNext;
    BYTE pAsm[sizeof(CASM_GENERATEFORWARD)];
    BYTE pMethodsb[NUMBER_OF_FORWARDING_METHODS_PER_BLOCK/2][CB_METHOD];
} ForwardProcBuffer, *PForwardProcBuffer;

static ForwardProcBuffer * g_pForwardProcBuffer = NULL;
extern void ** ProxyForwardVtbl;

EXTERN_C void ObjectStubless(void);
void ReleaseTemplateForwardVtbl(void ** pVtbl);
void ReleaseTemplateVtbl(void ** pVtbl);

static DWORD g_ObjectStubless = (DWORD)ObjectStubless;
extern ULONG g_dwVtblSize,g_dwForwardVtblSize;

extern "C"
{

long
ObjectStublessClient(
    void *  ParamAddress,
    long    Method
    );

void ObjectStublessClient3(void);
void ObjectStublessClient4(void);
void ObjectStublessClient5(void);
void ObjectStublessClient6(void);
void ObjectStublessClient7(void);

void ObjectStublessClient8(void);
void ObjectStublessClient9(void);
void ObjectStublessClient10(void);
void ObjectStublessClient11(void);
void ObjectStublessClient12(void);
void ObjectStublessClient13(void);
void ObjectStublessClient14(void);
void ObjectStublessClient15(void);
void ObjectStublessClient16(void);
void ObjectStublessClient17(void);
void ObjectStublessClient18(void);
void ObjectStublessClient19(void);
void ObjectStublessClient20(void);
void ObjectStublessClient21(void);
void ObjectStublessClient22(void);
void ObjectStublessClient23(void);
void ObjectStublessClient24(void);
void ObjectStublessClient25(void);
void ObjectStublessClient26(void);
void ObjectStublessClient27(void);
void ObjectStublessClient28(void);
void ObjectStublessClient29(void);
void ObjectStublessClient30(void);
void ObjectStublessClient31(void);
void ObjectStublessClient32(void);
void ObjectStublessClient33(void);
void ObjectStublessClient34(void);
void ObjectStublessClient35(void);
void ObjectStublessClient36(void);
void ObjectStublessClient37(void);
void ObjectStublessClient38(void);
void ObjectStublessClient39(void);
void ObjectStublessClient40(void);
void ObjectStublessClient41(void);
void ObjectStublessClient42(void);
void ObjectStublessClient43(void);
void ObjectStublessClient44(void);
void ObjectStublessClient45(void);
void ObjectStublessClient46(void);
void ObjectStublessClient47(void);
void ObjectStublessClient48(void);
void ObjectStublessClient49(void);
void ObjectStublessClient50(void);
void ObjectStublessClient51(void);
void ObjectStublessClient52(void);
void ObjectStublessClient53(void);
void ObjectStublessClient54(void);
void ObjectStublessClient55(void);
void ObjectStublessClient56(void);
void ObjectStublessClient57(void);
void ObjectStublessClient58(void);
void ObjectStublessClient59(void);
void ObjectStublessClient60(void);
void ObjectStublessClient61(void);
void ObjectStublessClient62(void);
void ObjectStublessClient63(void);
void ObjectStublessClient64(void);
void ObjectStublessClient65(void);
void ObjectStublessClient66(void);
void ObjectStublessClient67(void);
void ObjectStublessClient68(void);
void ObjectStublessClient69(void);
void ObjectStublessClient70(void);
void ObjectStublessClient71(void);
void ObjectStublessClient72(void);
void ObjectStublessClient73(void);
void ObjectStublessClient74(void);
void ObjectStublessClient75(void);
void ObjectStublessClient76(void);
void ObjectStublessClient77(void);
void ObjectStublessClient78(void);
void ObjectStublessClient79(void);
void ObjectStublessClient80(void);
void ObjectStublessClient81(void);
void ObjectStublessClient82(void);
void ObjectStublessClient83(void);
void ObjectStublessClient84(void);
void ObjectStublessClient85(void);
void ObjectStublessClient86(void);
void ObjectStublessClient87(void);
void ObjectStublessClient88(void);
void ObjectStublessClient89(void);
void ObjectStublessClient90(void);
void ObjectStublessClient91(void);
void ObjectStublessClient92(void);
void ObjectStublessClient93(void);
void ObjectStublessClient94(void);
void ObjectStublessClient95(void);
void ObjectStublessClient96(void);
void ObjectStublessClient97(void);
void ObjectStublessClient98(void);
void ObjectStublessClient99(void);
void ObjectStublessClient100(void);
void ObjectStublessClient101(void);
void ObjectStublessClient102(void);
void ObjectStublessClient103(void);
void ObjectStublessClient104(void);
void ObjectStublessClient105(void);
void ObjectStublessClient106(void);
void ObjectStublessClient107(void);
void ObjectStublessClient108(void);
void ObjectStublessClient109(void);
void ObjectStublessClient110(void);
void ObjectStublessClient111(void);
void ObjectStublessClient112(void);
void ObjectStublessClient113(void);
void ObjectStublessClient114(void);
void ObjectStublessClient115(void);
void ObjectStublessClient116(void);
void ObjectStublessClient117(void);
void ObjectStublessClient118(void);
void ObjectStublessClient119(void);
void ObjectStublessClient120(void);
void ObjectStublessClient121(void);
void ObjectStublessClient122(void);
void ObjectStublessClient123(void);
void ObjectStublessClient124(void);
void ObjectStublessClient125(void);
void ObjectStublessClient126(void);
void ObjectStublessClient127(void);

extern void * const g_StublessClientVtbl[128] =
    {
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy,
    ObjectStublessClient3,
    ObjectStublessClient4,
    ObjectStublessClient5,
    ObjectStublessClient6,
    ObjectStublessClient7,
    ObjectStublessClient8,
    ObjectStublessClient9,
    ObjectStublessClient10,
    ObjectStublessClient11,
    ObjectStublessClient12,
    ObjectStublessClient13,
    ObjectStublessClient14,
    ObjectStublessClient15,
    ObjectStublessClient16,
    ObjectStublessClient17,
    ObjectStublessClient18,
    ObjectStublessClient19,
    ObjectStublessClient20,
    ObjectStublessClient21,
    ObjectStublessClient22,
    ObjectStublessClient23,
    ObjectStublessClient24,
    ObjectStublessClient25,
    ObjectStublessClient26,
    ObjectStublessClient27,
    ObjectStublessClient28,
    ObjectStublessClient29,
    ObjectStublessClient30,
    ObjectStublessClient31,
    ObjectStublessClient32,
    ObjectStublessClient33,
    ObjectStublessClient34,
    ObjectStublessClient35,
    ObjectStublessClient36,
    ObjectStublessClient37,
    ObjectStublessClient38,
    ObjectStublessClient39,
    ObjectStublessClient40,
    ObjectStublessClient41,
    ObjectStublessClient42,
    ObjectStublessClient43,
    ObjectStublessClient44,
    ObjectStublessClient45,
    ObjectStublessClient46,
    ObjectStublessClient47,
    ObjectStublessClient48,
    ObjectStublessClient49,
    ObjectStublessClient50,
    ObjectStublessClient51,
    ObjectStublessClient52,
    ObjectStublessClient53,
    ObjectStublessClient54,
    ObjectStublessClient55,
    ObjectStublessClient56,
    ObjectStublessClient57,
    ObjectStublessClient58,
    ObjectStublessClient59,
    ObjectStublessClient60,
    ObjectStublessClient61,
    ObjectStublessClient62,
    ObjectStublessClient63,
    ObjectStublessClient64,
    ObjectStublessClient65,
    ObjectStublessClient66,
    ObjectStublessClient67,
    ObjectStublessClient68,
    ObjectStublessClient69,
    ObjectStublessClient70,
    ObjectStublessClient71,
    ObjectStublessClient72,
    ObjectStublessClient73,
    ObjectStublessClient74,
    ObjectStublessClient75,
    ObjectStublessClient76,
    ObjectStublessClient77,
    ObjectStublessClient78,
    ObjectStublessClient79,
    ObjectStublessClient80,
    ObjectStublessClient81,
    ObjectStublessClient82,
    ObjectStublessClient83,
    ObjectStublessClient84,
    ObjectStublessClient85,
    ObjectStublessClient86,
    ObjectStublessClient87,
    ObjectStublessClient88,
    ObjectStublessClient89,
    ObjectStublessClient90,
    ObjectStublessClient91,
    ObjectStublessClient92,
    ObjectStublessClient93,
    ObjectStublessClient94,
    ObjectStublessClient95,
    ObjectStublessClient96,
    ObjectStublessClient97,
    ObjectStublessClient98,
    ObjectStublessClient99,
    ObjectStublessClient100,
    ObjectStublessClient101,
    ObjectStublessClient102,
    ObjectStublessClient103,
    ObjectStublessClient104,
    ObjectStublessClient105,
    ObjectStublessClient106,
    ObjectStublessClient107,
    ObjectStublessClient108,
    ObjectStublessClient109,
    ObjectStublessClient110,
    ObjectStublessClient111,
    ObjectStublessClient112,
    ObjectStublessClient113,
    ObjectStublessClient114,
    ObjectStublessClient115,
    ObjectStublessClient116,
    ObjectStublessClient117,
    ObjectStublessClient118,
    ObjectStublessClient119,
    ObjectStublessClient120,
    ObjectStublessClient121,
    ObjectStublessClient122,
    ObjectStublessClient123,
    ObjectStublessClient124,
    ObjectStublessClient125,
    ObjectStublessClient126,
    ObjectStublessClient127
};

}

void ** StublessClientVtbl = (void **)g_StublessClientVtbl;

long
ObjectStublessClient(
    void *  ParamAddress,
    long    Method
    )
{
    PMIDL_STUBLESS_PROXY_INFO   ProxyInfo;
    CInterfaceProxyHeader *     ProxyHeader;
    PFORMAT_STRING              ProcFormat;
    unsigned short              ProcFormatOffset;
    CLIENT_CALL_RETURN          Return;
    long                        ParamSize;
    void *                      This;

        
    This = *((void **)ParamAddress);

    ProxyHeader = (CInterfaceProxyHeader *)
                  (*((char **)This) - sizeof(CInterfaceProxyHeader));
    ProxyInfo = (PMIDL_STUBLESS_PROXY_INFO) ProxyHeader->pStublessProxyInfo;

#if defined(BUILD_NDR64)
    
    if ( ProxyInfo->pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES  )
    {

        NDR_PROC_CONTEXT ProcContext;
        HRESULT  hr;
        
        Ndr64ClientInitializeContext(  
                               NdrpGetSyntaxType( ProxyInfo->pTransferSyntax),
                               ProxyInfo,
                               Method,
                               &ProcContext,
                               (uchar*)ParamAddress );

        if ( ProcContext.IsAsync )
            {
            if ( Method & 0x1 )
                hr =  MulNdrpBeginDcomAsyncClientCall( ProxyInfo,
                                                   Method,
                                                   &ProcContext,
                                                   ParamAddress );
            else
                hr =  MulNdrpFinishDcomAsyncClientCall(ProxyInfo,
                                                   Method,
                                                   &ProcContext,
                                                   ParamAddress );
                Return.Simple = hr;
            }
        else
            Return = NdrpClientCall3(This, 
                                     ProxyInfo,
                                     Method,
                                     NULL,      // return value
                                     &ProcContext,
                                     (uchar*)ParamAddress);
                               
        ParamSize = ProcContext.StackSize;        
        goto Finish;
    }

#endif
    
    ProcFormatOffset = ProxyInfo->FormatStringOffset[Method];
    ProcFormat = &ProxyInfo->ProcFormatString[ProcFormatOffset];

    ParamSize = (long)
        ( (ProcFormat[1] & Oi_HAS_RPCFLAGS) ?
          *((ushort *)&ProcFormat[8]) : *((ushort *)&ProcFormat[4]) );
          
    if ( MIDL_VERSION_3_0_39 <= ProxyInfo->pStubDesc->MIDLVersion )
        {
        // Since MIDL 3.0.39 we have a proc flag that indicates
        // which interpeter to call. This is because the NDR version
        // may be bigger than 1.1 for other reasons.

        if ( ProcFormat[1]  &  Oi_OBJ_USE_V2_INTERPRETER )
            {

            if ( MIDL_VERSION_5_0_136 <= ProxyInfo->pStubDesc->MIDLVersion
                 &&
                 ((PNDR_DCOM_OI2_PROC_HEADER) ProcFormat)->Oi2Flags.HasAsyncUuid )
                {
                Return = NdrDcomAsyncClientCall( ProxyInfo->pStubDesc,
                                                 ProcFormat,
                                                 ParamAddress );
                }
            else
                {
                Return = NdrClientCall2( ProxyInfo->pStubDesc,
                                         ProcFormat,
                                         ParamAddress );
                }
            }
        else
            {
              Return = NdrClientCall( ProxyInfo->pStubDesc,
                                    ProcFormat,
                                    ParamAddress );
            }

        }
    else
        {
        // Prior to that, the NDR version (on per file basis)
        // was the only indication of -Oi2.

        if ( ProxyInfo->pStubDesc->Version <= NDR_VERSION_1_1 )
            {
            Return = NdrClientCall( ProxyInfo->pStubDesc,
                                    ProcFormat,
                                    ParamAddress );
              Return.Simple = E_FAIL;
            }
        else
            {
            Return = NdrClientCall2( ProxyInfo->pStubDesc,
                                    ProcFormat,
                                    ParamAddress );
            }
        }

#if defined(BUILD_NDR64)
Finish:
#endif
    //
    // Return the size of the parameter stack minus 4 bytes for the HRESULT
    // return in ecx.  The ObjectStublessClient* routines need this to pop
    // the stack the correct number of bytes.  We don't have to worry about
    // this on RISC platforms since the caller pops any argument stack space
    // needed .
    //
    _asm { mov  ecx, ParamSize }
    _asm { sub  ecx, 4 }

    return (long) Return.Simple;
}



//+---------------------------------------------------------------------------
//
//  Function:   CreateStublessProcBuffer
//
//  Synopsis:   Create a StublessClientProcBuffer for vtbl to point to. starting from g_dwVtblSize,
//              till the larger of numMethods and maximum vtbls created in the block
//
//  Arguments:  USHORT numMethods   // number of methods in this interface
//              StublessProcBuffer **pTail // the last pNext in the allocated block
//
//  Note:       in x86, we are using short move & short jmps such that each method entry is 4 bytes.
//                  this  force we to have two method table in each block
//              in alpha, each entry has to be 8 bytes (2 instructions) so we can just have one
//                  method table in a block.
//  
//  Returns:
//    pointer to ProcBuffer if succeeded;
//    NULL if failed. GetLastError() to retrieve error.
//
//----------------------------------------------------------------------------
HRESULT CreateStublessProcBuffer(IN ULONG numMethods, 
                                 OUT void *** lpTempVtbl)
{
    // pointer to the last "pNext" pointer in vtbl link list: only increase, never release.
    static StublessProcBuffer** pVtblTail = NULL;
    ULONG i,j,k,iBlock = 0;
    ULONG nMethodsToAlloc = numMethods - g_dwVtblSize;
    StublessProcBuffer InitBuffer, *pStart = NULL, **pTail = NULL, *pBuf = NULL;
    DWORD* lpdwTemp, dwStartMethod = g_dwVtblSize ;
    LPBYTE  lpByte;
    BYTE lDist;
    ULONG dwNewLength;
    void ** TempVtbl = NULL;
    HRESULT hr;

    //  get number of blocks need to be allocated
    iBlock = nMethodsToAlloc / (NUMBER_OF_BLOCKS_PER_ALLOC * NUMBER_OF_METHODS_PER_BLOCK);
    
    if (nMethodsToAlloc % (NUMBER_OF_BLOCKS_PER_ALLOC * NUMBER_OF_METHODS_PER_BLOCK) != 0)    
        iBlock++;

    // size of new vtbl tempplate.
    dwNewLength = g_dwVtblSize + iBlock * (NUMBER_OF_BLOCKS_PER_ALLOC * NUMBER_OF_METHODS_PER_BLOCK);
    
    TempVtbl = (void **)I_RpcAllocate(dwNewLength * sizeof(void *) + sizeof(LONG));
    if (NULL == TempVtbl)
        return E_OUTOFMEMORY;
        
    *(LONG*)TempVtbl = 1;    // ref count
    TempVtbl = (void **)((LPBYTE)TempVtbl + sizeof(LONG));
    memcpy(TempVtbl,StublessClientVtbl,g_dwVtblSize*sizeof(void *));

    // the template other StublessProcBuffers copy from.
    if (NULL == g_pStublessProcBuffer)
    {
        BYTE nRelativeID = 0;
        memset(&InitBuffer,0,sizeof(StublessProcBuffer));
        memcpy(InitBuffer.pAsm,CASM_GENERATESTUBLESS,sizeof(CASM_GENERATESTUBLESS));
        *((DWORD *)&InitBuffer.pAsm[12]) = (DWORD)&g_ObjectStubless;

        lpByte = (LPBYTE)InitBuffer.pMethodsa;
        lDist = CB_METHOD * NUMBER_OF_METHODS_PER_BLOCK / 2;

        for (i = 0; i < NUMBER_OF_METHODS_PER_BLOCK / 2; i++)
        {
            *lpByte++ = 0xB0;   // _asm mov al
            *lpByte++ = nRelativeID++;
            *lpByte++ = 0xEB;   // _asm jmp 
            *lpByte++ = lDist;
            lDist -=CB_METHOD;          // goes further and further
        }

        lpByte = (LPBYTE)InitBuffer.pMethodsb;
        lDist = sizeof(CASM_GENERATESTUBLESS) + CB_METHOD;
        lDist = -lDist;
        for (i = 0; i < NUMBER_OF_METHODS_PER_BLOCK /2 ; i++)
        {
            *lpByte++ = 0xB0;   // _asm mov al
            *lpByte++ = nRelativeID++;
            *lpByte++ = 0xEB;   // _asm jmp 
            *lpByte++ = lDist;
            lDist -=CB_METHOD;          // goes further and further
        }
    }
    else
        memcpy(&InitBuffer,g_pStublessProcBuffer,sizeof(StublessProcBuffer));

    for (i = 0; i < iBlock; i++)
    {
        // we need to create a buffer 
        pBuf = (StublessProcBuffer *)I_RpcAllocate(NUMBER_OF_BLOCKS_PER_ALLOC * sizeof(StublessProcBuffer) );
        if (NULL == pBuf)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }            

        // remember the starting block of all the block in the call.
        if (NULL == pStart)
            pStart = pBuf; 

        if (pTail)
            *pTail = pBuf;   // link up the link list.
            
        for (j = 0; j < NUMBER_OF_BLOCKS_PER_ALLOC; j++)
        {
            memcpy(&pBuf[j],&InitBuffer,sizeof(StublessProcBuffer));
            if (j < NUMBER_OF_BLOCKS_PER_ALLOC -1 )
                pBuf[j].pNext = &pBuf[j+1];
            else
            {
                pTail = &(pBuf[NUMBER_OF_BLOCKS_PER_ALLOC-1].pNext);
                *pTail = NULL;
            }
                

            // adjust the starting methodid in this block
            lpdwTemp = (DWORD *)& (pBuf[j].pAsm[6]);
            *lpdwTemp = dwStartMethod;

            for (k = 0; k < NUMBER_OF_METHODS_PER_BLOCK / 2; k++)
                TempVtbl[dwStartMethod++] = (void *)pBuf[j].pMethodsa[k];

            for (k = 0; k < NUMBER_OF_METHODS_PER_BLOCK / 2; k++)
                TempVtbl[dwStartMethod++] = (void *)pBuf[j].pMethodsb[k];
            
        }
    }

    if (NULL == g_pStublessProcBuffer)
        g_pStublessProcBuffer = pStart;
    else
        *pVtblTail = pStart;
        
    *lpTempVtbl = TempVtbl;
    pVtblTail = pTail;
    g_dwVtblSize = dwNewLength;
    return S_OK;

Cleanup:
    while (pStart)
    {    
        pTail = &pStart[NUMBER_OF_BLOCKS_PER_ALLOC-1].pNext;
        I_RpcFree(pStart);
        pStart = *pTail;
    }
    if (TempVtbl)
        I_RpcFree(TempVtbl);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateForwardProcBuffer
//
//  Synopsis:   Create a StublessClientProcBuffer for vtbl to point to. starting from g_dwVtblSize,
//              till the larger of numMethods and maximum vtbls created in the block
//
//  Arguments:  USHORT numMethods   // number of methods in this interface
//              StublessProcBuffer **pTail // the last pNext in the allocated block
//
//  Note:       in x86, we are using short move & short jmps such that each method entry is 4 bytes.
//                  this  force we to have two method table in each block
//              in alpha, each entry has to be 8 bytes (2 instructions) so we can just have one
//                  method table in a block.
//  
//  Returns:
//    pointer to ProcBuffer if succeeded;
//    NULL if failed. GetLastError() to retrieve error.
//
//----------------------------------------------------------------------------
HRESULT  CreateForwardProcBuffer(ULONG numMethods, void ***lpTempVtbl)
{
    // pointer to the last "pNext" pointer in vtbl link list: only increase, never release.
    static ForwardProcBuffer** pVtblTail = NULL;
    ULONG i,j,k,iBlock = 0;
    ULONG nMethodsToAlloc = numMethods - g_dwForwardVtblSize;
    ForwardProcBuffer InitBuffer, *pStart = NULL, **pTail = NULL, *pBuf = NULL;
    DWORD* lpdwTemp, dwStartMethod = g_dwForwardVtblSize ;
    LPBYTE  lpByte;
    BYTE lDist;
    ULONG dwNewLength;
    void ** TempVtbl;
    HRESULT hr;

    //  get number of blocks need to be allocated
    iBlock = nMethodsToAlloc / (NUMBER_OF_BLOCKS_PER_ALLOC * NUMBER_OF_FORWARDING_METHODS_PER_BLOCK);
    
    if (nMethodsToAlloc % (NUMBER_OF_BLOCKS_PER_ALLOC * NUMBER_OF_FORWARDING_METHODS_PER_BLOCK) != 0)    
        iBlock++;

    // size of new vtbl tempplate.
    dwNewLength = g_dwForwardVtblSize + iBlock * (NUMBER_OF_BLOCKS_PER_ALLOC * NUMBER_OF_FORWARDING_METHODS_PER_BLOCK);
    
    TempVtbl = (void **)I_RpcAllocate(dwNewLength * sizeof(void *) + sizeof(LONG));
    if (NULL == TempVtbl)
        return E_OUTOFMEMORY;
        
    *(LONG*)TempVtbl = 1;    // ref count
    TempVtbl = (void **)((LPBYTE)TempVtbl + sizeof(LONG));
    memcpy(TempVtbl,ProxyForwardVtbl,g_dwForwardVtblSize*sizeof(void *));

    // the template other StublessProcBuffers copy from.
    if (NULL == g_pForwardProcBuffer)
    {
        BYTE nRelativeID = 0;
        memset(&InitBuffer,0,sizeof(ForwardProcBuffer));
        memcpy(&InitBuffer.pAsm,CASM_GENERATEFORWARD,sizeof(CASM_GENERATEFORWARD));

        lpByte = (LPBYTE)InitBuffer.pMethodsa;
        lDist = CB_METHOD * NUMBER_OF_FORWARDING_METHODS_PER_BLOCK / 2;

        for (i = 0; i < NUMBER_OF_FORWARDING_METHODS_PER_BLOCK / 2; i++)
        {
            *lpByte++ = 0xB0;   // _asm mov al
            *lpByte++ = nRelativeID++;
            *lpByte++ = 0xEB;   // _asm jmp 
            *lpByte++ = lDist;
            lDist -=CB_METHOD;          // goes further and further
        }

        lpByte = (LPBYTE)InitBuffer.pMethodsb;
        lDist = sizeof(CASM_GENERATEFORWARD) + CB_METHOD;
        lDist = -lDist;
        for (i = 0; i < NUMBER_OF_FORWARDING_METHODS_PER_BLOCK /2 ; i++)
        {
            *lpByte++ = 0xB0;   // _asm mov al
            *lpByte++ = nRelativeID++;
            *lpByte++ = 0xEB;   // _asm jmp 
            *lpByte++ = lDist;
            lDist -=CB_METHOD;          // goes further and further
        }
    }
    else
        memcpy(&InitBuffer,g_pForwardProcBuffer,sizeof(ForwardProcBuffer));

    for (i = 0; i < iBlock; i++)
    {
        // we need to create a buffer 
        pBuf = (ForwardProcBuffer *)I_RpcAllocate(NUMBER_OF_BLOCKS_PER_ALLOC * sizeof(ForwardProcBuffer) );
        if (NULL == pBuf)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }            

        // remember the starting block of all the block in the call.
        if (NULL == pStart)
            pStart = pBuf; 

        if (pTail)
            *pTail = pBuf;   // link up the link list.
            
        for (j = 0; j < NUMBER_OF_BLOCKS_PER_ALLOC; j++)
        {
            memcpy(&pBuf[j],&InitBuffer,sizeof(ForwardProcBuffer));
            if (j < NUMBER_OF_BLOCKS_PER_ALLOC -1 )
                pBuf[j].pNext = &pBuf[j+1];
            else
            {
                pTail = &(pBuf[NUMBER_OF_BLOCKS_PER_ALLOC-1].pNext);
                *pTail = NULL;
            }
                

            // adjust the starting methodid in this block
            lpdwTemp = (DWORD *)& (pBuf[j].pAsm[17]);
            *lpdwTemp = dwStartMethod;

            for (k = 0; k < NUMBER_OF_FORWARDING_METHODS_PER_BLOCK / 2; k++)
                TempVtbl[dwStartMethod++] = (void *)pBuf[j].pMethodsa[k];

            for (k = 0; k < NUMBER_OF_FORWARDING_METHODS_PER_BLOCK / 2; k++)
                TempVtbl[dwStartMethod++] = (void *)pBuf[j].pMethodsb[k];
            
        }
    }

    if (NULL == g_pForwardProcBuffer)
        g_pForwardProcBuffer = pStart;
    else
        *pVtblTail = pStart;
        
    *lpTempVtbl = TempVtbl;
    pVtblTail = pTail;
    g_dwForwardVtblSize = dwNewLength;
    return S_OK;

Cleanup:
    while (pStart)
    {    
        pTail = &pStart[NUMBER_OF_BLOCKS_PER_ALLOC-1].pNext;
        I_RpcFree(pStart);
        pStart = *pTail;
    }
    if (TempVtbl)
        I_RpcFree(TempVtbl);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\i386\stubless.asm ===
;+---------------------------------------------------------------------------
;
;  Microsoft Windows
;  Copyright (C) Microsoft Corporation, 1996.
;
;  File:       stubless.asm
;
;  Contents:   This module contains interpreter support routines for
;              Intel platforms.
;
;  Functions:  Invoke - Calls a function from an interpreter.
;              ObjectStublessClient3 - ObjectStublessClient511
;
;  History:    07-Nov-94 DKays     Created
;              24-Apr-96 ShannonC  Added Invoke and support for 
;                                  512 stubless client methods.
;
;----------------------------------------------------------------------------

.386p

EXTRN   _ObjectStublessClient@8:NEAR

_TEXT   SEGMENT DWORD PUBLIC 'CODE'


;+---------------------------------------------------------------------------
;
;  Function:   REGISTER_TYPE __stdcall Invoke(MANAGER_FUNCTION pFunction, 
;                                             REGISTER_TYPE   *pArgumentList,
;                                             ULONG            cArguments);
;
;  Synopsis:   Given a function pointer and an argument list, Invoke builds 
;              a stack frame and calls the function.
;
;  Arguments:  pFunction - Pointer to the function to be called.
;
;              pArgumentList - Pointer to the buffer containing the 
;                              function parameters.
;
;              cArguments - The size of the argument list in REGISTER_TYPEs.
;
;  Notes:     In the __stdcall calling convention, the callee must pop
;             the parameters.
;
;----------------------------------------------------------------------------
_Invoke@12 PROC PUBLIC

push ebp;          Save ebp
mov  ebp, esp;     Set ebp so the debugger can display the stack trace.

;Here is our stack layout.
;[ebp+0]  = saved ebp
;[ebp+4]  = return address
;[ebp+8]  = pFunction
;[ebp+12] = pArgumentList
;[ebp+16] = cArguments

push edi;          Save edi
push esi;          Save esi
pushf;	           Save the direction flag - pushes 2 bytes
pushf;		   To keep stack aligned at 4 push 2 more bytes 

mov eax, [ebp+16]; Load number of parameters
shl eax, 2;        Calculate size of parameters
sub esp, eax;      Grow the stack

;Copy parameters from bottom to top.
mov esi, [ebp+12]; Load pointer to parameters
mov ecx, [ebp+16]; Load number of parameters
sub eax, 4;
mov edi, esp
add esi, eax;      Get pointer to last source parameter
add edi, eax;      Get pointer last destination parameter

std;               Set direction flag
rep movsd;         Copy the parameters

mov eax, [ebp-12]; Get the direction flag (2+2 bytes)
push eax;	   Push it in order to restore it
popf;              Restore the direction flag
popf;		   Do it again as we pushed 4 bytes when saving the flag

;call the server
mov eax, [ebp+8];  Load pointer to function.
call eax

mov edi, [ebp-4];  Restore edi
mov esi, [ebp-8];  Restore esi
mov esp, ebp;      Restore stack pointer
pop ebp;           Restore ebp
ret 12 ;           Pop parameters       

_Invoke@12 ENDP 


;
; Define ObjectStublessClient routine macro.
;
StublessClientProc macro    Method

    _ObjectStublessClient&Method&@0 PROC PUBLIC
        
        ;
        ; NOTE :
        ; Don't use edi, esi, or ebx unless you add code to save them on 
        ; the stack!
        ;
    
        mov     ecx, Method
        jmp     _ObjectStubless@0

    _ObjectStublessClient&Method&@0 ENDP 

endm


;On entry, ecx contains method number.
_ObjectStubless@0 PROC PUBLIC
        
        ;
        ; NOTE :
        ; Don't use edi, esi, or ebx unless you add code to save them on 
        ; the stack!
        ;
    
        ;
        ; Do this so the debugger can figure out the stack trace correctly.
        ; Will make debugging much easier.
        ;
        push    ebp
        mov     ebp, esp

        ; Push the method number.
        push    ecx

        ; Push the stack address of the parameters.
        mov     eax, ebp
        add     eax, 8
        push    eax

        call    _ObjectStublessClient@8

        ;
        ; After the call :
        ;   Real return for the proxy is in eax.
        ;   Parameter stack size is put in ecx by ObjectStublessClient for us.
        ;
        ; At this pointer eax (return), ecx (ParamSize), and edi, esi, ebx
        ; (non-volatile registers) can not be written!!!
        ;

        ; Don't forget to pop ebp.
        pop     ebp

        ; Pop our return address.
        pop     edx

        ; Pop params explicitly.
        add     esp, ecx

        ; This will return us from whichever StublessClient routine was called.
        jmp     edx

    _ObjectStubless@0 ENDP 

StublessClientProc  3
StublessClientProc  4
StublessClientProc  5
StublessClientProc  6
StublessClientProc  7
StublessClientProc  8
StublessClientProc  9
StublessClientProc  10
StublessClientProc  11
StublessClientProc  12
StublessClientProc  13
StublessClientProc  14
StublessClientProc  15
StublessClientProc  16
StublessClientProc  17
StublessClientProc  18
StublessClientProc  19
StublessClientProc  20
StublessClientProc  21
StublessClientProc  22
StublessClientProc  23
StublessClientProc  24
StublessClientProc  25
StublessClientProc  26
StublessClientProc  27
StublessClientProc  28
StublessClientProc  29
StublessClientProc  30
StublessClientProc  31
StublessClientProc  32
StublessClientProc  33
StublessClientProc  34
StublessClientProc  35
StublessClientProc  36
StublessClientProc  37
StublessClientProc  38
StublessClientProc  39
StublessClientProc  40
StublessClientProc  41
StublessClientProc  42
StublessClientProc  43
StublessClientProc  44
StublessClientProc  45
StublessClientProc  46
StublessClientProc  47
StublessClientProc  48
StublessClientProc  49
StublessClientProc  50
StublessClientProc  51
StublessClientProc  52
StublessClientProc  53
StublessClientProc  54
StublessClientProc  55
StublessClientProc  56
StublessClientProc  57
StublessClientProc  58
StublessClientProc  59
StublessClientProc  60
StublessClientProc  61
StublessClientProc  62
StublessClientProc  63
StublessClientProc  64
StublessClientProc  65
StublessClientProc  66
StublessClientProc  67
StublessClientProc  68
StublessClientProc  69
StublessClientProc  70
StublessClientProc  71
StublessClientProc  72
StublessClientProc  73
StublessClientProc  74
StublessClientProc  75
StublessClientProc  76
StublessClientProc  77
StublessClientProc  78
StublessClientProc  79
StublessClientProc  80
StublessClientProc  81
StublessClientProc  82
StublessClientProc  83
StublessClientProc  84
StublessClientProc  85
StublessClientProc  86
StublessClientProc  87
StublessClientProc  88
StublessClientProc  89
StublessClientProc  90
StublessClientProc  91
StublessClientProc  92
StublessClientProc  93
StublessClientProc  94
StublessClientProc  95
StublessClientProc  96
StublessClientProc  97
StublessClientProc  98
StublessClientProc  99
StublessClientProc  100
StublessClientProc  101
StublessClientProc  102
StublessClientProc  103
StublessClientProc  104
StublessClientProc  105
StublessClientProc  106
StublessClientProc  107
StublessClientProc  108
StublessClientProc  109
StublessClientProc  110
StublessClientProc  111
StublessClientProc  112
StublessClientProc  113
StublessClientProc  114
StublessClientProc  115
StublessClientProc  116
StublessClientProc  117
StublessClientProc  118
StublessClientProc  119
StublessClientProc  120
StublessClientProc  121
StublessClientProc  122
StublessClientProc  123
StublessClientProc  124
StublessClientProc  125
StublessClientProc  126
StublessClientProc  127

_TEXT   ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\ia64\forward.s ===
/*++

  Copyright  c  1994  Microsoft Corporation.  All rights reserved.

  Module Name:
     forward.s

  Abstract:
     This module implements the proxy forwarding functions.

  Author:
    ShannonC    26-Oct-94

  Environment:                     
   
     Any mode.
  Revision History:

--*/

#include "ksia64.h"
        .file   "forward.s"
/*++

 VOID
 NdrProxyForwardingFunction<nnn>(...)

 Routine Description:

    This function forwards a call to the proxy for the base interface.

 Arguments:

    This [a0] - Points to an interface proxy.

 Return Value:

    None.

--*/


// here is what a forwarder looks like
// we must:
//      change the "this" pointer in [esp+4] to point to the delegated object
//      fetch the correct entry from the vtable
//      call the function

#define SUBCLASS_OFFSET     32
#define VTABLE_ENTRY(n)     n*8

/*
    this is a macro for delegation methods. It first retrives BaseProxyBuffer
    from the proxy vtbl, then deference to get the base vtbl.  From the offset
    in vtbl, we get the pair of real .ObjectStublessClient##method_number
    and gp. bp & b6 is loaded up accordingly and the code is branched into
    ObjectStublessClient##method_number
*/
#define DELEGATION_FORWARDER(method_number)        \
        LEAF_ENTRY( NdrProxyForwardingFunction##method_number );        \
        add             r32 = SUBCLASS_OFFSET, r32;                     \
        ;;                                                              \
        LDPTR           (r32, r32);;                                     \
        LDPTR           (r2, r32);;                                     \
        add             r2 = VTABLE_ENTRY(method_number), r2;;          \
        LDPTR           (r2, r2 );;                                       \
        LDPTRINC        (r3, r2, 8);                                    \
        ;;                                                              \
        LDPTR           (gp, r2);                                       \
        mov             b6 = r3;                                        \
        br##.##sptk##.##clr     b6;                                     \
        LEAF_EXIT( NdrProxyForwardingFunction##method_number )

    DELEGATION_FORWARDER(3)

    DELEGATION_FORWARDER(4)

    DELEGATION_FORWARDER(5)

    DELEGATION_FORWARDER(6)

    DELEGATION_FORWARDER(7)
    
    DELEGATION_FORWARDER(8)
    
    DELEGATION_FORWARDER(9)
    
    DELEGATION_FORWARDER(10)
    
    DELEGATION_FORWARDER(11)
    
    DELEGATION_FORWARDER(12)
    
    DELEGATION_FORWARDER(13)
    
    DELEGATION_FORWARDER(14)
    
    DELEGATION_FORWARDER(15)
    
    DELEGATION_FORWARDER(16)
    
    DELEGATION_FORWARDER(17)
    
    DELEGATION_FORWARDER(18)
    
    DELEGATION_FORWARDER(19)
    
    DELEGATION_FORWARDER(20)
    
    DELEGATION_FORWARDER(21)
    
    DELEGATION_FORWARDER(22)
    
    DELEGATION_FORWARDER(23)
    
    DELEGATION_FORWARDER(24)
    
    DELEGATION_FORWARDER(25)
    
    DELEGATION_FORWARDER(26)
    
    DELEGATION_FORWARDER(27)
    
    DELEGATION_FORWARDER(28)
    
    DELEGATION_FORWARDER(29)
    
    DELEGATION_FORWARDER(30)
    
    DELEGATION_FORWARDER(31)
    
    DELEGATION_FORWARDER(32)
    
    DELEGATION_FORWARDER(33)
    
    DELEGATION_FORWARDER(34)
    
    DELEGATION_FORWARDER(35)
    
    DELEGATION_FORWARDER(36)
    
    DELEGATION_FORWARDER(37)
    
    DELEGATION_FORWARDER(38)
    
    DELEGATION_FORWARDER(39)
    
    DELEGATION_FORWARDER(40)
    
    DELEGATION_FORWARDER(41)
    
    DELEGATION_FORWARDER(42)
    
    DELEGATION_FORWARDER(43)
    
    DELEGATION_FORWARDER(44)
    
    DELEGATION_FORWARDER(45)
    
    DELEGATION_FORWARDER(46)
    
    DELEGATION_FORWARDER(47)
    
    DELEGATION_FORWARDER(48)
    
    DELEGATION_FORWARDER(49)
    
    DELEGATION_FORWARDER(50)
    
    DELEGATION_FORWARDER(51)
    
    DELEGATION_FORWARDER(52)
    
    DELEGATION_FORWARDER(53)
    
    DELEGATION_FORWARDER(54)
    
    DELEGATION_FORWARDER(55)
    
    DELEGATION_FORWARDER(56)
    
    DELEGATION_FORWARDER(57)
    
    DELEGATION_FORWARDER(58)
    
    DELEGATION_FORWARDER(59)
    
    DELEGATION_FORWARDER(60)
    
    DELEGATION_FORWARDER(61)
    
    DELEGATION_FORWARDER(62)
    
    DELEGATION_FORWARDER(63)
    
    DELEGATION_FORWARDER(64)
    
    DELEGATION_FORWARDER(65)
    
    DELEGATION_FORWARDER(66)
    
    DELEGATION_FORWARDER(67)
    
    DELEGATION_FORWARDER(68)
    
    DELEGATION_FORWARDER(69)
    
    DELEGATION_FORWARDER(70)
    
    DELEGATION_FORWARDER(71)
    
    DELEGATION_FORWARDER(72)
    
    DELEGATION_FORWARDER(73)
    
    DELEGATION_FORWARDER(74)
    
    DELEGATION_FORWARDER(75)
    
    DELEGATION_FORWARDER(76)
    
    DELEGATION_FORWARDER(77)
    
    DELEGATION_FORWARDER(78)
    
    DELEGATION_FORWARDER(79)
    
    DELEGATION_FORWARDER(80)
    
    DELEGATION_FORWARDER(81)
    
    DELEGATION_FORWARDER(82)
    
    DELEGATION_FORWARDER(83)
    
    DELEGATION_FORWARDER(84)
    
    DELEGATION_FORWARDER(85)
    
    DELEGATION_FORWARDER(86)
    
    DELEGATION_FORWARDER(87)
    
    DELEGATION_FORWARDER(88)
    
    DELEGATION_FORWARDER(89)
    
    DELEGATION_FORWARDER(90)
    
    DELEGATION_FORWARDER(91)
    
    DELEGATION_FORWARDER(92)
    
    DELEGATION_FORWARDER(93)
    
    DELEGATION_FORWARDER(94)
    
    DELEGATION_FORWARDER(95)
    
    DELEGATION_FORWARDER(96)
    
    DELEGATION_FORWARDER(97)
    
    DELEGATION_FORWARDER(98)
    
    DELEGATION_FORWARDER(99)
    
    DELEGATION_FORWARDER(100)
    
    DELEGATION_FORWARDER(101)
    
    DELEGATION_FORWARDER(102)
    
    DELEGATION_FORWARDER(103)
    
    DELEGATION_FORWARDER(104)
    
    DELEGATION_FORWARDER(105)
    
    DELEGATION_FORWARDER(106)
    
    DELEGATION_FORWARDER(107)
    
    DELEGATION_FORWARDER(108)
    
    DELEGATION_FORWARDER(109)
    
    DELEGATION_FORWARDER(110)
    
    DELEGATION_FORWARDER(111)
    
    DELEGATION_FORWARDER(112)
    
    DELEGATION_FORWARDER(113)
    
    DELEGATION_FORWARDER(114)
    
    DELEGATION_FORWARDER(115)
    
    DELEGATION_FORWARDER(116)
    
    DELEGATION_FORWARDER(117)
    
    DELEGATION_FORWARDER(118)
    
    DELEGATION_FORWARDER(119)
    
    DELEGATION_FORWARDER(120)
    
    DELEGATION_FORWARDER(121)
    
    DELEGATION_FORWARDER(122)
    
    DELEGATION_FORWARDER(123)
    
    DELEGATION_FORWARDER(124)
    
    DELEGATION_FORWARDER(125)
    
    DELEGATION_FORWARDER(126)
    
    DELEGATION_FORWARDER(127)
    
    DELEGATION_FORWARDER(128)
    
    DELEGATION_FORWARDER(129)
    
    DELEGATION_FORWARDER(130)
    
    DELEGATION_FORWARDER(131)
    
    DELEGATION_FORWARDER(132)
    
    DELEGATION_FORWARDER(133)
    
    DELEGATION_FORWARDER(134)
    
    DELEGATION_FORWARDER(135)
    
    DELEGATION_FORWARDER(136)
    
    DELEGATION_FORWARDER(137)
    
    DELEGATION_FORWARDER(138)
    
    DELEGATION_FORWARDER(139)
    
    DELEGATION_FORWARDER(140)
    
    DELEGATION_FORWARDER(141)
    
    DELEGATION_FORWARDER(142)
    
    DELEGATION_FORWARDER(143)
    
    DELEGATION_FORWARDER(144)
    
    DELEGATION_FORWARDER(145)
    
    DELEGATION_FORWARDER(146)
    
    DELEGATION_FORWARDER(147)
    
    DELEGATION_FORWARDER(148)
    
    DELEGATION_FORWARDER(149)
    
    DELEGATION_FORWARDER(150)
    
    DELEGATION_FORWARDER(151)
    
    DELEGATION_FORWARDER(152)
    
    DELEGATION_FORWARDER(153)
    
    DELEGATION_FORWARDER(154)
    
    DELEGATION_FORWARDER(155)
    
    DELEGATION_FORWARDER(156)
    
    DELEGATION_FORWARDER(157)
    
    DELEGATION_FORWARDER(158)
    
    DELEGATION_FORWARDER(159)
    
    DELEGATION_FORWARDER(160)
    
    DELEGATION_FORWARDER(161)
    
    DELEGATION_FORWARDER(162)
    
    DELEGATION_FORWARDER(163)
    
    DELEGATION_FORWARDER(164)
    
    DELEGATION_FORWARDER(165)
    
    DELEGATION_FORWARDER(166)
    
    DELEGATION_FORWARDER(167)
    
    DELEGATION_FORWARDER(168)
    
    DELEGATION_FORWARDER(169)
    
    DELEGATION_FORWARDER(170)
    
    DELEGATION_FORWARDER(171)
    
    DELEGATION_FORWARDER(172)
    
    DELEGATION_FORWARDER(173)
    
    DELEGATION_FORWARDER(174)
    
    DELEGATION_FORWARDER(175)
    
    DELEGATION_FORWARDER(176)
    
    DELEGATION_FORWARDER(177)
    
    DELEGATION_FORWARDER(178)
    
    DELEGATION_FORWARDER(179)
    
    DELEGATION_FORWARDER(180)
    
    DELEGATION_FORWARDER(181)
    
    DELEGATION_FORWARDER(182)
    
    DELEGATION_FORWARDER(183)
    
    DELEGATION_FORWARDER(184)
    
    DELEGATION_FORWARDER(185)
    
    DELEGATION_FORWARDER(186)
    
    DELEGATION_FORWARDER(187)
    
    DELEGATION_FORWARDER(188)
    
    DELEGATION_FORWARDER(189)
    
    DELEGATION_FORWARDER(190)
    
    DELEGATION_FORWARDER(191)
    
    DELEGATION_FORWARDER(192)
    
    DELEGATION_FORWARDER(193)
    
    DELEGATION_FORWARDER(194)
    
    DELEGATION_FORWARDER(195)
    
    DELEGATION_FORWARDER(196)
    
    DELEGATION_FORWARDER(197)
    
    DELEGATION_FORWARDER(198)
    
    DELEGATION_FORWARDER(199)
    
    DELEGATION_FORWARDER(200)
    
    DELEGATION_FORWARDER(201)
    
    DELEGATION_FORWARDER(202)
    
    DELEGATION_FORWARDER(203)
    
    DELEGATION_FORWARDER(204)
    
    DELEGATION_FORWARDER(205)
    
    DELEGATION_FORWARDER(206)
    
    DELEGATION_FORWARDER(207)
    
    DELEGATION_FORWARDER(208)
    
    DELEGATION_FORWARDER(209)
    
    DELEGATION_FORWARDER(210)
    
    DELEGATION_FORWARDER(211)
    
    DELEGATION_FORWARDER(212)
    
    DELEGATION_FORWARDER(213)
    
    DELEGATION_FORWARDER(214)
    
    DELEGATION_FORWARDER(215)
    
    DELEGATION_FORWARDER(216)
    
    DELEGATION_FORWARDER(217)
    
    DELEGATION_FORWARDER(218)
    
    DELEGATION_FORWARDER(219)
    
    DELEGATION_FORWARDER(220)
    
    DELEGATION_FORWARDER(221)
    
    DELEGATION_FORWARDER(222)
    
    DELEGATION_FORWARDER(223)
    
    DELEGATION_FORWARDER(224)
    
    DELEGATION_FORWARDER(225)
    
    DELEGATION_FORWARDER(226)
    
    DELEGATION_FORWARDER(227)
    
    DELEGATION_FORWARDER(228)
    
    DELEGATION_FORWARDER(229)
    
    DELEGATION_FORWARDER(230)
    
    DELEGATION_FORWARDER(231)
    
    DELEGATION_FORWARDER(232)
    
    DELEGATION_FORWARDER(233)
    
    DELEGATION_FORWARDER(234)
    
    DELEGATION_FORWARDER(235)
    
    DELEGATION_FORWARDER(236)
    
    DELEGATION_FORWARDER(237)
    
    DELEGATION_FORWARDER(238)
    
    DELEGATION_FORWARDER(239)
    
    DELEGATION_FORWARDER(240)
    
    DELEGATION_FORWARDER(241)
    
    DELEGATION_FORWARDER(242)
    
    DELEGATION_FORWARDER(243)
    
    DELEGATION_FORWARDER(244)
    
    DELEGATION_FORWARDER(245)
    
    DELEGATION_FORWARDER(246)
    
    DELEGATION_FORWARDER(247)
    
    DELEGATION_FORWARDER(248)
    
    DELEGATION_FORWARDER(249)
    
    DELEGATION_FORWARDER(250)
    
    DELEGATION_FORWARDER(251)
    
    DELEGATION_FORWARDER(252)
    
    DELEGATION_FORWARDER(253)
    
    DELEGATION_FORWARDER(254)
    
    DELEGATION_FORWARDER(255)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\ia64\stblsclt.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1995 Microsoft Corporation

Module Name :

    stblsclt.c

Abstract :

    This file contains the routines for support of stubless clients in
    object interfaces.

Author :

    David Kays    dkays    February 1995.

Revision History :

---------------------------------------------------------------------*/

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include <stdarg.h>
#include "ndrp.h"
#include "hndl.h"
#include "interp2.h"
#include "ndrtypes.h"
#include "mulsyntx.h"

#include "ndrole.h"
#include "rpcproxy.h"

#pragma code_seg(".orpc")


typedef unsigned short  ushort;

EXTERN_C long
ObjectStublessClient(
    void *  ParamAddress,
    long    Method
    );

CLIENT_CALL_RETURN RPC_ENTRY
NdrpClientCall2(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    uchar *             StartofStack
    );

CLIENT_CALL_RETURN  RPC_ENTRY
NdrpDcomAsyncClientCall(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    uchar *             StartofStack
    );

EXTERN_C void
SpillFPRegsForIA64(
    REGISTER_TYPE * pStack,
    ULONG           FloatArgMask
    );

extern "C"
{

void ObjectStublessClient3(void);
void ObjectStublessClient4(void);
void ObjectStublessClient5(void);
void ObjectStublessClient6(void);
void ObjectStublessClient7(void);

void ObjectStublessClient8(void);
void ObjectStublessClient9(void);
void ObjectStublessClient10(void);
void ObjectStublessClient11(void);
void ObjectStublessClient12(void);
void ObjectStublessClient13(void);
void ObjectStublessClient14(void);
void ObjectStublessClient15(void);
void ObjectStublessClient16(void);
void ObjectStublessClient17(void);
void ObjectStublessClient18(void);
void ObjectStublessClient19(void);
void ObjectStublessClient20(void);
void ObjectStublessClient21(void);
void ObjectStublessClient22(void);
void ObjectStublessClient23(void);
void ObjectStublessClient24(void);
void ObjectStublessClient25(void);
void ObjectStublessClient26(void);
void ObjectStublessClient27(void);
void ObjectStublessClient28(void);
void ObjectStublessClient29(void);
void ObjectStublessClient30(void);
void ObjectStublessClient31(void);
void ObjectStublessClient32(void);
void ObjectStublessClient33(void);
void ObjectStublessClient34(void);
void ObjectStublessClient35(void);
void ObjectStublessClient36(void);
void ObjectStublessClient37(void);
void ObjectStublessClient38(void);
void ObjectStublessClient39(void);
void ObjectStublessClient40(void);
void ObjectStublessClient41(void);
void ObjectStublessClient42(void);
void ObjectStublessClient43(void);
void ObjectStublessClient44(void);
void ObjectStublessClient45(void);
void ObjectStublessClient46(void);
void ObjectStublessClient47(void);
void ObjectStublessClient48(void);
void ObjectStublessClient49(void);
void ObjectStublessClient50(void);
void ObjectStublessClient51(void);
void ObjectStublessClient52(void);
void ObjectStublessClient53(void);
void ObjectStublessClient54(void);
void ObjectStublessClient55(void);
void ObjectStublessClient56(void);
void ObjectStublessClient57(void);
void ObjectStublessClient58(void);
void ObjectStublessClient59(void);
void ObjectStublessClient60(void);
void ObjectStublessClient61(void);
void ObjectStublessClient62(void);
void ObjectStublessClient63(void);
void ObjectStublessClient64(void);
void ObjectStublessClient65(void);
void ObjectStublessClient66(void);
void ObjectStublessClient67(void);
void ObjectStublessClient68(void);
void ObjectStublessClient69(void);
void ObjectStublessClient70(void);
void ObjectStublessClient71(void);
void ObjectStublessClient72(void);
void ObjectStublessClient73(void);
void ObjectStublessClient74(void);
void ObjectStublessClient75(void);
void ObjectStublessClient76(void);
void ObjectStublessClient77(void);
void ObjectStublessClient78(void);
void ObjectStublessClient79(void);
void ObjectStublessClient80(void);
void ObjectStublessClient81(void);
void ObjectStublessClient82(void);
void ObjectStublessClient83(void);
void ObjectStublessClient84(void);
void ObjectStublessClient85(void);
void ObjectStublessClient86(void);
void ObjectStublessClient87(void);
void ObjectStublessClient88(void);
void ObjectStublessClient89(void);
void ObjectStublessClient90(void);
void ObjectStublessClient91(void);
void ObjectStublessClient92(void);
void ObjectStublessClient93(void);
void ObjectStublessClient94(void);
void ObjectStublessClient95(void);
void ObjectStublessClient96(void);
void ObjectStublessClient97(void);
void ObjectStublessClient98(void);
void ObjectStublessClient99(void);
void ObjectStublessClient100(void);
void ObjectStublessClient101(void);
void ObjectStublessClient102(void);
void ObjectStublessClient103(void);
void ObjectStublessClient104(void);
void ObjectStublessClient105(void);
void ObjectStublessClient106(void);
void ObjectStublessClient107(void);
void ObjectStublessClient108(void);
void ObjectStublessClient109(void);
void ObjectStublessClient110(void);
void ObjectStublessClient111(void);
void ObjectStublessClient112(void);
void ObjectStublessClient113(void);
void ObjectStublessClient114(void);
void ObjectStublessClient115(void);
void ObjectStublessClient116(void);
void ObjectStublessClient117(void);
void ObjectStublessClient118(void);
void ObjectStublessClient119(void);
void ObjectStublessClient120(void);
void ObjectStublessClient121(void);
void ObjectStublessClient122(void);
void ObjectStublessClient123(void);
void ObjectStublessClient124(void);
void ObjectStublessClient125(void);
void ObjectStublessClient126(void);
void ObjectStublessClient127(void);
void ObjectStublessClient128(void);
void ObjectStublessClient129(void);
void ObjectStublessClient130(void);
void ObjectStublessClient131(void);
void ObjectStublessClient132(void);
void ObjectStublessClient133(void);
void ObjectStublessClient134(void);
void ObjectStublessClient135(void);
void ObjectStublessClient136(void);
void ObjectStublessClient137(void);
void ObjectStublessClient138(void);
void ObjectStublessClient139(void);
void ObjectStublessClient140(void);
void ObjectStublessClient141(void);
void ObjectStublessClient142(void);
void ObjectStublessClient143(void);
void ObjectStublessClient144(void);
void ObjectStublessClient145(void);
void ObjectStublessClient146(void);
void ObjectStublessClient147(void);
void ObjectStublessClient148(void);
void ObjectStublessClient149(void);
void ObjectStublessClient150(void);
void ObjectStublessClient151(void);
void ObjectStublessClient152(void);
void ObjectStublessClient153(void);
void ObjectStublessClient154(void);
void ObjectStublessClient155(void);
void ObjectStublessClient156(void);
void ObjectStublessClient157(void);
void ObjectStublessClient158(void);
void ObjectStublessClient159(void);
void ObjectStublessClient160(void);
void ObjectStublessClient161(void);
void ObjectStublessClient162(void);
void ObjectStublessClient163(void);
void ObjectStublessClient164(void);
void ObjectStublessClient165(void);
void ObjectStublessClient166(void);
void ObjectStublessClient167(void);
void ObjectStublessClient168(void);
void ObjectStublessClient169(void);
void ObjectStublessClient170(void);
void ObjectStublessClient171(void);
void ObjectStublessClient172(void);
void ObjectStublessClient173(void);
void ObjectStublessClient174(void);
void ObjectStublessClient175(void);
void ObjectStublessClient176(void);
void ObjectStublessClient177(void);
void ObjectStublessClient178(void);
void ObjectStublessClient179(void);
void ObjectStublessClient180(void);
void ObjectStublessClient181(void);
void ObjectStublessClient182(void);
void ObjectStublessClient183(void);
void ObjectStublessClient184(void);
void ObjectStublessClient185(void);
void ObjectStublessClient186(void);
void ObjectStublessClient187(void);
void ObjectStublessClient188(void);
void ObjectStublessClient189(void);
void ObjectStublessClient190(void);
void ObjectStublessClient191(void);
void ObjectStublessClient192(void);
void ObjectStublessClient193(void);
void ObjectStublessClient194(void);
void ObjectStublessClient195(void);
void ObjectStublessClient196(void);
void ObjectStublessClient197(void);
void ObjectStublessClient198(void);
void ObjectStublessClient199(void);
void ObjectStublessClient200(void);
void ObjectStublessClient201(void);
void ObjectStublessClient202(void);
void ObjectStublessClient203(void);
void ObjectStublessClient204(void);
void ObjectStublessClient205(void);
void ObjectStublessClient206(void);
void ObjectStublessClient207(void);
void ObjectStublessClient208(void);
void ObjectStublessClient209(void);
void ObjectStublessClient210(void);
void ObjectStublessClient211(void);
void ObjectStublessClient212(void);
void ObjectStublessClient213(void);
void ObjectStublessClient214(void);
void ObjectStublessClient215(void);
void ObjectStublessClient216(void);
void ObjectStublessClient217(void);
void ObjectStublessClient218(void);
void ObjectStublessClient219(void);
void ObjectStublessClient220(void);
void ObjectStublessClient221(void);
void ObjectStublessClient222(void);
void ObjectStublessClient223(void);
void ObjectStublessClient224(void);
void ObjectStublessClient225(void);
void ObjectStublessClient226(void);
void ObjectStublessClient227(void);
void ObjectStublessClient228(void);
void ObjectStublessClient229(void);
void ObjectStublessClient230(void);
void ObjectStublessClient231(void);
void ObjectStublessClient232(void);
void ObjectStublessClient233(void);
void ObjectStublessClient234(void);
void ObjectStublessClient235(void);
void ObjectStublessClient236(void);
void ObjectStublessClient237(void);
void ObjectStublessClient238(void);
void ObjectStublessClient239(void);
void ObjectStublessClient240(void);
void ObjectStublessClient241(void);
void ObjectStublessClient242(void);
void ObjectStublessClient243(void);
void ObjectStublessClient244(void);
void ObjectStublessClient245(void);
void ObjectStublessClient246(void);
void ObjectStublessClient247(void);
void ObjectStublessClient248(void);
void ObjectStublessClient249(void);
void ObjectStublessClient250(void);
void ObjectStublessClient251(void);
void ObjectStublessClient252(void);
void ObjectStublessClient253(void);
void ObjectStublessClient254(void);
void ObjectStublessClient255(void);
void ObjectStublessClient256(void);
void ObjectStublessClient257(void);
void ObjectStublessClient258(void);
void ObjectStublessClient259(void);
void ObjectStublessClient260(void);
void ObjectStublessClient261(void);
void ObjectStublessClient262(void);
void ObjectStublessClient263(void);
void ObjectStublessClient264(void);
void ObjectStublessClient265(void);
void ObjectStublessClient266(void);
void ObjectStublessClient267(void);
void ObjectStublessClient268(void);
void ObjectStublessClient269(void);
void ObjectStublessClient270(void);
void ObjectStublessClient271(void);
void ObjectStublessClient272(void);
void ObjectStublessClient273(void);
void ObjectStublessClient274(void);
void ObjectStublessClient275(void);
void ObjectStublessClient276(void);
void ObjectStublessClient277(void);
void ObjectStublessClient278(void);
void ObjectStublessClient279(void);
void ObjectStublessClient280(void);
void ObjectStublessClient281(void);
void ObjectStublessClient282(void);
void ObjectStublessClient283(void);
void ObjectStublessClient284(void);
void ObjectStublessClient285(void);
void ObjectStublessClient286(void);
void ObjectStublessClient287(void);
void ObjectStublessClient288(void);
void ObjectStublessClient289(void);
void ObjectStublessClient290(void);
void ObjectStublessClient291(void);
void ObjectStublessClient292(void);
void ObjectStublessClient293(void);
void ObjectStublessClient294(void);
void ObjectStublessClient295(void);
void ObjectStublessClient296(void);
void ObjectStublessClient297(void);
void ObjectStublessClient298(void);
void ObjectStublessClient299(void);
void ObjectStublessClient300(void);
void ObjectStublessClient301(void);
void ObjectStublessClient302(void);
void ObjectStublessClient303(void);
void ObjectStublessClient304(void);
void ObjectStublessClient305(void);
void ObjectStublessClient306(void);
void ObjectStublessClient307(void);
void ObjectStublessClient308(void);
void ObjectStublessClient309(void);
void ObjectStublessClient310(void);
void ObjectStublessClient311(void);
void ObjectStublessClient312(void);
void ObjectStublessClient313(void);
void ObjectStublessClient314(void);
void ObjectStublessClient315(void);
void ObjectStublessClient316(void);
void ObjectStublessClient317(void);
void ObjectStublessClient318(void);
void ObjectStublessClient319(void);
void ObjectStublessClient320(void);
void ObjectStublessClient321(void);
void ObjectStublessClient322(void);
void ObjectStublessClient323(void);
void ObjectStublessClient324(void);
void ObjectStublessClient325(void);
void ObjectStublessClient326(void);
void ObjectStublessClient327(void);
void ObjectStublessClient328(void);
void ObjectStublessClient329(void);
void ObjectStublessClient330(void);
void ObjectStublessClient331(void);
void ObjectStublessClient332(void);
void ObjectStublessClient333(void);
void ObjectStublessClient334(void);
void ObjectStublessClient335(void);
void ObjectStublessClient336(void);
void ObjectStublessClient337(void);
void ObjectStublessClient338(void);
void ObjectStublessClient339(void);
void ObjectStublessClient340(void);
void ObjectStublessClient341(void);
void ObjectStublessClient342(void);
void ObjectStublessClient343(void);
void ObjectStublessClient344(void);
void ObjectStublessClient345(void);
void ObjectStublessClient346(void);
void ObjectStublessClient347(void);
void ObjectStublessClient348(void);
void ObjectStublessClient349(void);
void ObjectStublessClient350(void);
void ObjectStublessClient351(void);
void ObjectStublessClient352(void);
void ObjectStublessClient353(void);
void ObjectStublessClient354(void);
void ObjectStublessClient355(void);
void ObjectStublessClient356(void);
void ObjectStublessClient357(void);
void ObjectStublessClient358(void);
void ObjectStublessClient359(void);
void ObjectStublessClient360(void);
void ObjectStublessClient361(void);
void ObjectStublessClient362(void);
void ObjectStublessClient363(void);
void ObjectStublessClient364(void);
void ObjectStublessClient365(void);
void ObjectStublessClient366(void);
void ObjectStublessClient367(void);
void ObjectStublessClient368(void);
void ObjectStublessClient369(void);
void ObjectStublessClient370(void);
void ObjectStublessClient371(void);
void ObjectStublessClient372(void);
void ObjectStublessClient373(void);
void ObjectStublessClient374(void);
void ObjectStublessClient375(void);
void ObjectStublessClient376(void);
void ObjectStublessClient377(void);
void ObjectStublessClient378(void);
void ObjectStublessClient379(void);
void ObjectStublessClient380(void);
void ObjectStublessClient381(void);
void ObjectStublessClient382(void);
void ObjectStublessClient383(void);
void ObjectStublessClient384(void);
void ObjectStublessClient385(void);
void ObjectStublessClient386(void);
void ObjectStublessClient387(void);
void ObjectStublessClient388(void);
void ObjectStublessClient389(void);
void ObjectStublessClient390(void);
void ObjectStublessClient391(void);
void ObjectStublessClient392(void);
void ObjectStublessClient393(void);
void ObjectStublessClient394(void);
void ObjectStublessClient395(void);
void ObjectStublessClient396(void);
void ObjectStublessClient397(void);
void ObjectStublessClient398(void);
void ObjectStublessClient399(void);
void ObjectStublessClient400(void);
void ObjectStublessClient401(void);
void ObjectStublessClient402(void);
void ObjectStublessClient403(void);
void ObjectStublessClient404(void);
void ObjectStublessClient405(void);
void ObjectStublessClient406(void);
void ObjectStublessClient407(void);
void ObjectStublessClient408(void);
void ObjectStublessClient409(void);
void ObjectStublessClient410(void);
void ObjectStublessClient411(void);
void ObjectStublessClient412(void);
void ObjectStublessClient413(void);
void ObjectStublessClient414(void);
void ObjectStublessClient415(void);
void ObjectStublessClient416(void);
void ObjectStublessClient417(void);
void ObjectStublessClient418(void);
void ObjectStublessClient419(void);
void ObjectStublessClient420(void);
void ObjectStublessClient421(void);
void ObjectStublessClient422(void);
void ObjectStublessClient423(void);
void ObjectStublessClient424(void);
void ObjectStublessClient425(void);
void ObjectStublessClient426(void);
void ObjectStublessClient427(void);
void ObjectStublessClient428(void);
void ObjectStublessClient429(void);
void ObjectStublessClient430(void);
void ObjectStublessClient431(void);
void ObjectStublessClient432(void);
void ObjectStublessClient433(void);
void ObjectStublessClient434(void);
void ObjectStublessClient435(void);
void ObjectStublessClient436(void);
void ObjectStublessClient437(void);
void ObjectStublessClient438(void);
void ObjectStublessClient439(void);
void ObjectStublessClient440(void);
void ObjectStublessClient441(void);
void ObjectStublessClient442(void);
void ObjectStublessClient443(void);
void ObjectStublessClient444(void);
void ObjectStublessClient445(void);
void ObjectStublessClient446(void);
void ObjectStublessClient447(void);
void ObjectStublessClient448(void);
void ObjectStublessClient449(void);
void ObjectStublessClient450(void);
void ObjectStublessClient451(void);
void ObjectStublessClient452(void);
void ObjectStublessClient453(void);
void ObjectStublessClient454(void);
void ObjectStublessClient455(void);
void ObjectStublessClient456(void);
void ObjectStublessClient457(void);
void ObjectStublessClient458(void);
void ObjectStublessClient459(void);
void ObjectStublessClient460(void);
void ObjectStublessClient461(void);
void ObjectStublessClient462(void);
void ObjectStublessClient463(void);
void ObjectStublessClient464(void);
void ObjectStublessClient465(void);
void ObjectStublessClient466(void);
void ObjectStublessClient467(void);
void ObjectStublessClient468(void);
void ObjectStublessClient469(void);
void ObjectStublessClient470(void);
void ObjectStublessClient471(void);
void ObjectStublessClient472(void);
void ObjectStublessClient473(void);
void ObjectStublessClient474(void);
void ObjectStublessClient475(void);
void ObjectStublessClient476(void);
void ObjectStublessClient477(void);
void ObjectStublessClient478(void);
void ObjectStublessClient479(void);
void ObjectStublessClient480(void);
void ObjectStublessClient481(void);
void ObjectStublessClient482(void);
void ObjectStublessClient483(void);
void ObjectStublessClient484(void);
void ObjectStublessClient485(void);
void ObjectStublessClient486(void);
void ObjectStublessClient487(void);
void ObjectStublessClient488(void);
void ObjectStublessClient489(void);
void ObjectStublessClient490(void);
void ObjectStublessClient491(void);
void ObjectStublessClient492(void);
void ObjectStublessClient493(void);
void ObjectStublessClient494(void);
void ObjectStublessClient495(void);
void ObjectStublessClient496(void);
void ObjectStublessClient497(void);
void ObjectStublessClient498(void);
void ObjectStublessClient499(void);
void ObjectStublessClient500(void);
void ObjectStublessClient501(void);
void ObjectStublessClient502(void);
void ObjectStublessClient503(void);
void ObjectStublessClient504(void);
void ObjectStublessClient505(void);
void ObjectStublessClient506(void);
void ObjectStublessClient507(void);
void ObjectStublessClient508(void);
void ObjectStublessClient509(void);
void ObjectStublessClient510(void);
void ObjectStublessClient511(void);
void ObjectStublessClient512(void);
void ObjectStublessClient513(void);
void ObjectStublessClient514(void);
void ObjectStublessClient515(void);
void ObjectStublessClient516(void);
void ObjectStublessClient517(void);
void ObjectStublessClient518(void);
void ObjectStublessClient519(void);
void ObjectStublessClient520(void);
void ObjectStublessClient521(void);
void ObjectStublessClient522(void);
void ObjectStublessClient523(void);
void ObjectStublessClient524(void);
void ObjectStublessClient525(void);
void ObjectStublessClient526(void);
void ObjectStublessClient527(void);
void ObjectStublessClient528(void);
void ObjectStublessClient529(void);
void ObjectStublessClient530(void);
void ObjectStublessClient531(void);
void ObjectStublessClient532(void);
void ObjectStublessClient533(void);
void ObjectStublessClient534(void);
void ObjectStublessClient535(void);
void ObjectStublessClient536(void);
void ObjectStublessClient537(void);
void ObjectStublessClient538(void);
void ObjectStublessClient539(void);
void ObjectStublessClient540(void);
void ObjectStublessClient541(void);
void ObjectStublessClient542(void);
void ObjectStublessClient543(void);
void ObjectStublessClient544(void);
void ObjectStublessClient545(void);
void ObjectStublessClient546(void);
void ObjectStublessClient547(void);
void ObjectStublessClient548(void);
void ObjectStublessClient549(void);
void ObjectStublessClient550(void);
void ObjectStublessClient551(void);
void ObjectStublessClient552(void);
void ObjectStublessClient553(void);
void ObjectStublessClient554(void);
void ObjectStublessClient555(void);
void ObjectStublessClient556(void);
void ObjectStublessClient557(void);
void ObjectStublessClient558(void);
void ObjectStublessClient559(void);
void ObjectStublessClient560(void);
void ObjectStublessClient561(void);
void ObjectStublessClient562(void);
void ObjectStublessClient563(void);
void ObjectStublessClient564(void);
void ObjectStublessClient565(void);
void ObjectStublessClient566(void);
void ObjectStublessClient567(void);
void ObjectStublessClient568(void);
void ObjectStublessClient569(void);
void ObjectStublessClient570(void);
void ObjectStublessClient571(void);
void ObjectStublessClient572(void);
void ObjectStublessClient573(void);
void ObjectStublessClient574(void);
void ObjectStublessClient575(void);
void ObjectStublessClient576(void);
void ObjectStublessClient577(void);
void ObjectStublessClient578(void);
void ObjectStublessClient579(void);
void ObjectStublessClient580(void);
void ObjectStublessClient581(void);
void ObjectStublessClient582(void);
void ObjectStublessClient583(void);
void ObjectStublessClient584(void);
void ObjectStublessClient585(void);
void ObjectStublessClient586(void);
void ObjectStublessClient587(void);
void ObjectStublessClient588(void);
void ObjectStublessClient589(void);
void ObjectStublessClient590(void);
void ObjectStublessClient591(void);
void ObjectStublessClient592(void);
void ObjectStublessClient593(void);
void ObjectStublessClient594(void);
void ObjectStublessClient595(void);
void ObjectStublessClient596(void);
void ObjectStublessClient597(void);
void ObjectStublessClient598(void);
void ObjectStublessClient599(void);
void ObjectStublessClient600(void);
void ObjectStublessClient601(void);
void ObjectStublessClient602(void);
void ObjectStublessClient603(void);
void ObjectStublessClient604(void);
void ObjectStublessClient605(void);
void ObjectStublessClient606(void);
void ObjectStublessClient607(void);
void ObjectStublessClient608(void);
void ObjectStublessClient609(void);
void ObjectStublessClient610(void);
void ObjectStublessClient611(void);
void ObjectStublessClient612(void);
void ObjectStublessClient613(void);
void ObjectStublessClient614(void);
void ObjectStublessClient615(void);
void ObjectStublessClient616(void);
void ObjectStublessClient617(void);
void ObjectStublessClient618(void);
void ObjectStublessClient619(void);
void ObjectStublessClient620(void);
void ObjectStublessClient621(void);
void ObjectStublessClient622(void);
void ObjectStublessClient623(void);
void ObjectStublessClient624(void);
void ObjectStublessClient625(void);
void ObjectStublessClient626(void);
void ObjectStublessClient627(void);
void ObjectStublessClient628(void);
void ObjectStublessClient629(void);
void ObjectStublessClient630(void);
void ObjectStublessClient631(void);
void ObjectStublessClient632(void);
void ObjectStublessClient633(void);
void ObjectStublessClient634(void);
void ObjectStublessClient635(void);
void ObjectStublessClient636(void);
void ObjectStublessClient637(void);
void ObjectStublessClient638(void);
void ObjectStublessClient639(void);
void ObjectStublessClient640(void);
void ObjectStublessClient641(void);
void ObjectStublessClient642(void);
void ObjectStublessClient643(void);
void ObjectStublessClient644(void);
void ObjectStublessClient645(void);
void ObjectStublessClient646(void);
void ObjectStublessClient647(void);
void ObjectStublessClient648(void);
void ObjectStublessClient649(void);
void ObjectStublessClient650(void);
void ObjectStublessClient651(void);
void ObjectStublessClient652(void);
void ObjectStublessClient653(void);
void ObjectStublessClient654(void);
void ObjectStublessClient655(void);
void ObjectStublessClient656(void);
void ObjectStublessClient657(void);
void ObjectStublessClient658(void);
void ObjectStublessClient659(void);
void ObjectStublessClient660(void);
void ObjectStublessClient661(void);
void ObjectStublessClient662(void);
void ObjectStublessClient663(void);
void ObjectStublessClient664(void);
void ObjectStublessClient665(void);
void ObjectStublessClient666(void);
void ObjectStublessClient667(void);
void ObjectStublessClient668(void);
void ObjectStublessClient669(void);
void ObjectStublessClient670(void);
void ObjectStublessClient671(void);
void ObjectStublessClient672(void);
void ObjectStublessClient673(void);
void ObjectStublessClient674(void);
void ObjectStublessClient675(void);
void ObjectStublessClient676(void);
void ObjectStublessClient677(void);
void ObjectStublessClient678(void);
void ObjectStublessClient679(void);
void ObjectStublessClient680(void);
void ObjectStublessClient681(void);
void ObjectStublessClient682(void);
void ObjectStublessClient683(void);
void ObjectStublessClient684(void);
void ObjectStublessClient685(void);
void ObjectStublessClient686(void);
void ObjectStublessClient687(void);
void ObjectStublessClient688(void);
void ObjectStublessClient689(void);
void ObjectStublessClient690(void);
void ObjectStublessClient691(void);
void ObjectStublessClient692(void);
void ObjectStublessClient693(void);
void ObjectStublessClient694(void);
void ObjectStublessClient695(void);
void ObjectStublessClient696(void);
void ObjectStublessClient697(void);
void ObjectStublessClient698(void);
void ObjectStublessClient699(void);
void ObjectStublessClient700(void);
void ObjectStublessClient701(void);
void ObjectStublessClient702(void);
void ObjectStublessClient703(void);
void ObjectStublessClient704(void);
void ObjectStublessClient705(void);
void ObjectStublessClient706(void);
void ObjectStublessClient707(void);
void ObjectStublessClient708(void);
void ObjectStublessClient709(void);
void ObjectStublessClient710(void);
void ObjectStublessClient711(void);
void ObjectStublessClient712(void);
void ObjectStublessClient713(void);
void ObjectStublessClient714(void);
void ObjectStublessClient715(void);
void ObjectStublessClient716(void);
void ObjectStublessClient717(void);
void ObjectStublessClient718(void);
void ObjectStublessClient719(void);
void ObjectStublessClient720(void);
void ObjectStublessClient721(void);
void ObjectStublessClient722(void);
void ObjectStublessClient723(void);
void ObjectStublessClient724(void);
void ObjectStublessClient725(void);
void ObjectStublessClient726(void);
void ObjectStublessClient727(void);
void ObjectStublessClient728(void);
void ObjectStublessClient729(void);
void ObjectStublessClient730(void);
void ObjectStublessClient731(void);
void ObjectStublessClient732(void);
void ObjectStublessClient733(void);
void ObjectStublessClient734(void);
void ObjectStublessClient735(void);
void ObjectStublessClient736(void);
void ObjectStublessClient737(void);
void ObjectStublessClient738(void);
void ObjectStublessClient739(void);
void ObjectStublessClient740(void);
void ObjectStublessClient741(void);
void ObjectStublessClient742(void);
void ObjectStublessClient743(void);
void ObjectStublessClient744(void);
void ObjectStublessClient745(void);
void ObjectStublessClient746(void);
void ObjectStublessClient747(void);
void ObjectStublessClient748(void);
void ObjectStublessClient749(void);
void ObjectStublessClient750(void);
void ObjectStublessClient751(void);
void ObjectStublessClient752(void);
void ObjectStublessClient753(void);
void ObjectStublessClient754(void);
void ObjectStublessClient755(void);
void ObjectStublessClient756(void);
void ObjectStublessClient757(void);
void ObjectStublessClient758(void);
void ObjectStublessClient759(void);
void ObjectStublessClient760(void);
void ObjectStublessClient761(void);
void ObjectStublessClient762(void);
void ObjectStublessClient763(void);
void ObjectStublessClient764(void);
void ObjectStublessClient765(void);
void ObjectStublessClient766(void);
void ObjectStublessClient767(void);
void ObjectStublessClient768(void);
void ObjectStublessClient769(void);
void ObjectStublessClient770(void);
void ObjectStublessClient771(void);
void ObjectStublessClient772(void);
void ObjectStublessClient773(void);
void ObjectStublessClient774(void);
void ObjectStublessClient775(void);
void ObjectStublessClient776(void);
void ObjectStublessClient777(void);
void ObjectStublessClient778(void);
void ObjectStublessClient779(void);
void ObjectStublessClient780(void);
void ObjectStublessClient781(void);
void ObjectStublessClient782(void);
void ObjectStublessClient783(void);
void ObjectStublessClient784(void);
void ObjectStublessClient785(void);
void ObjectStublessClient786(void);
void ObjectStublessClient787(void);
void ObjectStublessClient788(void);
void ObjectStublessClient789(void);
void ObjectStublessClient790(void);
void ObjectStublessClient791(void);
void ObjectStublessClient792(void);
void ObjectStublessClient793(void);
void ObjectStublessClient794(void);
void ObjectStublessClient795(void);
void ObjectStublessClient796(void);
void ObjectStublessClient797(void);
void ObjectStublessClient798(void);
void ObjectStublessClient799(void);
void ObjectStublessClient800(void);
void ObjectStublessClient801(void);
void ObjectStublessClient802(void);
void ObjectStublessClient803(void);
void ObjectStublessClient804(void);
void ObjectStublessClient805(void);
void ObjectStublessClient806(void);
void ObjectStublessClient807(void);
void ObjectStublessClient808(void);
void ObjectStublessClient809(void);
void ObjectStublessClient810(void);
void ObjectStublessClient811(void);
void ObjectStublessClient812(void);
void ObjectStublessClient813(void);
void ObjectStublessClient814(void);
void ObjectStublessClient815(void);
void ObjectStublessClient816(void);
void ObjectStublessClient817(void);
void ObjectStublessClient818(void);
void ObjectStublessClient819(void);
void ObjectStublessClient820(void);
void ObjectStublessClient821(void);
void ObjectStublessClient822(void);
void ObjectStublessClient823(void);
void ObjectStublessClient824(void);
void ObjectStublessClient825(void);
void ObjectStublessClient826(void);
void ObjectStublessClient827(void);
void ObjectStublessClient828(void);
void ObjectStublessClient829(void);
void ObjectStublessClient830(void);
void ObjectStublessClient831(void);
void ObjectStublessClient832(void);
void ObjectStublessClient833(void);
void ObjectStublessClient834(void);
void ObjectStublessClient835(void);
void ObjectStublessClient836(void);
void ObjectStublessClient837(void);
void ObjectStublessClient838(void);
void ObjectStublessClient839(void);
void ObjectStublessClient840(void);
void ObjectStublessClient841(void);
void ObjectStublessClient842(void);
void ObjectStublessClient843(void);
void ObjectStublessClient844(void);
void ObjectStublessClient845(void);
void ObjectStublessClient846(void);
void ObjectStublessClient847(void);
void ObjectStublessClient848(void);
void ObjectStublessClient849(void);
void ObjectStublessClient850(void);
void ObjectStublessClient851(void);
void ObjectStublessClient852(void);
void ObjectStublessClient853(void);
void ObjectStublessClient854(void);
void ObjectStublessClient855(void);
void ObjectStublessClient856(void);
void ObjectStublessClient857(void);
void ObjectStublessClient858(void);
void ObjectStublessClient859(void);
void ObjectStublessClient860(void);
void ObjectStublessClient861(void);
void ObjectStublessClient862(void);
void ObjectStublessClient863(void);
void ObjectStublessClient864(void);
void ObjectStublessClient865(void);
void ObjectStublessClient866(void);
void ObjectStublessClient867(void);
void ObjectStublessClient868(void);
void ObjectStublessClient869(void);
void ObjectStublessClient870(void);
void ObjectStublessClient871(void);
void ObjectStublessClient872(void);
void ObjectStublessClient873(void);
void ObjectStublessClient874(void);
void ObjectStublessClient875(void);
void ObjectStublessClient876(void);
void ObjectStublessClient877(void);
void ObjectStublessClient878(void);
void ObjectStublessClient879(void);
void ObjectStublessClient880(void);
void ObjectStublessClient881(void);
void ObjectStublessClient882(void);
void ObjectStublessClient883(void);
void ObjectStublessClient884(void);
void ObjectStublessClient885(void);
void ObjectStublessClient886(void);
void ObjectStublessClient887(void);
void ObjectStublessClient888(void);
void ObjectStublessClient889(void);
void ObjectStublessClient890(void);
void ObjectStublessClient891(void);
void ObjectStublessClient892(void);
void ObjectStublessClient893(void);
void ObjectStublessClient894(void);
void ObjectStublessClient895(void);
void ObjectStublessClient896(void);
void ObjectStublessClient897(void);
void ObjectStublessClient898(void);
void ObjectStublessClient899(void);
void ObjectStublessClient900(void);
void ObjectStublessClient901(void);
void ObjectStublessClient902(void);
void ObjectStublessClient903(void);
void ObjectStublessClient904(void);
void ObjectStublessClient905(void);
void ObjectStublessClient906(void);
void ObjectStublessClient907(void);
void ObjectStublessClient908(void);
void ObjectStublessClient909(void);
void ObjectStublessClient910(void);
void ObjectStublessClient911(void);
void ObjectStublessClient912(void);
void ObjectStublessClient913(void);
void ObjectStublessClient914(void);
void ObjectStublessClient915(void);
void ObjectStublessClient916(void);
void ObjectStublessClient917(void);
void ObjectStublessClient918(void);
void ObjectStublessClient919(void);
void ObjectStublessClient920(void);
void ObjectStublessClient921(void);
void ObjectStublessClient922(void);
void ObjectStublessClient923(void);
void ObjectStublessClient924(void);
void ObjectStublessClient925(void);
void ObjectStublessClient926(void);
void ObjectStublessClient927(void);
void ObjectStublessClient928(void);
void ObjectStublessClient929(void);
void ObjectStublessClient930(void);
void ObjectStublessClient931(void);
void ObjectStublessClient932(void);
void ObjectStublessClient933(void);
void ObjectStublessClient934(void);
void ObjectStublessClient935(void);
void ObjectStublessClient936(void);
void ObjectStublessClient937(void);
void ObjectStublessClient938(void);
void ObjectStublessClient939(void);
void ObjectStublessClient940(void);
void ObjectStublessClient941(void);
void ObjectStublessClient942(void);
void ObjectStublessClient943(void);
void ObjectStublessClient944(void);
void ObjectStublessClient945(void);
void ObjectStublessClient946(void);
void ObjectStublessClient947(void);
void ObjectStublessClient948(void);
void ObjectStublessClient949(void);
void ObjectStublessClient950(void);
void ObjectStublessClient951(void);
void ObjectStublessClient952(void);
void ObjectStublessClient953(void);
void ObjectStublessClient954(void);
void ObjectStublessClient955(void);
void ObjectStublessClient956(void);
void ObjectStublessClient957(void);
void ObjectStublessClient958(void);
void ObjectStublessClient959(void);
void ObjectStublessClient960(void);
void ObjectStublessClient961(void);
void ObjectStublessClient962(void);
void ObjectStublessClient963(void);
void ObjectStublessClient964(void);
void ObjectStublessClient965(void);
void ObjectStublessClient966(void);
void ObjectStublessClient967(void);
void ObjectStublessClient968(void);
void ObjectStublessClient969(void);
void ObjectStublessClient970(void);
void ObjectStublessClient971(void);
void ObjectStublessClient972(void);
void ObjectStublessClient973(void);
void ObjectStublessClient974(void);
void ObjectStublessClient975(void);
void ObjectStublessClient976(void);
void ObjectStublessClient977(void);
void ObjectStublessClient978(void);
void ObjectStublessClient979(void);
void ObjectStublessClient980(void);
void ObjectStublessClient981(void);
void ObjectStublessClient982(void);
void ObjectStublessClient983(void);
void ObjectStublessClient984(void);
void ObjectStublessClient985(void);
void ObjectStublessClient986(void);
void ObjectStublessClient987(void);
void ObjectStublessClient988(void);
void ObjectStublessClient989(void);
void ObjectStublessClient990(void);
void ObjectStublessClient991(void);
void ObjectStublessClient992(void);
void ObjectStublessClient993(void);
void ObjectStublessClient994(void);
void ObjectStublessClient995(void);
void ObjectStublessClient996(void);
void ObjectStublessClient997(void);
void ObjectStublessClient998(void);
void ObjectStublessClient999(void);
void ObjectStublessClient1000(void);
void ObjectStublessClient1001(void);
void ObjectStublessClient1002(void);
void ObjectStublessClient1003(void);
void ObjectStublessClient1004(void);
void ObjectStublessClient1005(void);
void ObjectStublessClient1006(void);
void ObjectStublessClient1007(void);
void ObjectStublessClient1008(void);
void ObjectStublessClient1009(void);
void ObjectStublessClient1010(void);
void ObjectStublessClient1011(void);
void ObjectStublessClient1012(void);
void ObjectStublessClient1013(void);
void ObjectStublessClient1014(void);
void ObjectStublessClient1015(void);
void ObjectStublessClient1016(void);
void ObjectStublessClient1017(void);
void ObjectStublessClient1018(void);
void ObjectStublessClient1019(void);
void ObjectStublessClient1020(void);
void ObjectStublessClient1021(void);
void ObjectStublessClient1022(void);
void ObjectStublessClient1023(void);

extern void * const g_StublessClientVtbl[1024] =
    {
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy,
    ObjectStublessClient3,
    ObjectStublessClient4,
    ObjectStublessClient5,
    ObjectStublessClient6,
    ObjectStublessClient7,
    ObjectStublessClient8,
    ObjectStublessClient9,
    ObjectStublessClient10,
    ObjectStublessClient11,
    ObjectStublessClient12,
    ObjectStublessClient13,
    ObjectStublessClient14,
    ObjectStublessClient15,
    ObjectStublessClient16,
    ObjectStublessClient17,
    ObjectStublessClient18,
    ObjectStublessClient19,
    ObjectStublessClient20,
    ObjectStublessClient21,
    ObjectStublessClient22,
    ObjectStublessClient23,
    ObjectStublessClient24,
    ObjectStublessClient25,
    ObjectStublessClient26,
    ObjectStublessClient27,
    ObjectStublessClient28,
    ObjectStublessClient29,
    ObjectStublessClient30,
    ObjectStublessClient31,
    ObjectStublessClient32,
    ObjectStublessClient33,
    ObjectStublessClient34,
    ObjectStublessClient35,
    ObjectStublessClient36,
    ObjectStublessClient37,
    ObjectStublessClient38,
    ObjectStublessClient39,
    ObjectStublessClient40,
    ObjectStublessClient41,
    ObjectStublessClient42,
    ObjectStublessClient43,
    ObjectStublessClient44,
    ObjectStublessClient45,
    ObjectStublessClient46,
    ObjectStublessClient47,
    ObjectStublessClient48,
    ObjectStublessClient49,
    ObjectStublessClient50,
    ObjectStublessClient51,
    ObjectStublessClient52,
    ObjectStublessClient53,
    ObjectStublessClient54,
    ObjectStublessClient55,
    ObjectStublessClient56,
    ObjectStublessClient57,
    ObjectStublessClient58,
    ObjectStublessClient59,
    ObjectStublessClient60,
    ObjectStublessClient61,
    ObjectStublessClient62,
    ObjectStublessClient63,
    ObjectStublessClient64,
    ObjectStublessClient65,
    ObjectStublessClient66,
    ObjectStublessClient67,
    ObjectStublessClient68,
    ObjectStublessClient69,
    ObjectStublessClient70,
    ObjectStublessClient71,
    ObjectStublessClient72,
    ObjectStublessClient73,
    ObjectStublessClient74,
    ObjectStublessClient75,
    ObjectStublessClient76,
    ObjectStublessClient77,
    ObjectStublessClient78,
    ObjectStublessClient79,
    ObjectStublessClient80,
    ObjectStublessClient81,
    ObjectStublessClient82,
    ObjectStublessClient83,
    ObjectStublessClient84,
    ObjectStublessClient85,
    ObjectStublessClient86,
    ObjectStublessClient87,
    ObjectStublessClient88,
    ObjectStublessClient89,
    ObjectStublessClient90,
    ObjectStublessClient91,
    ObjectStublessClient92,
    ObjectStublessClient93,
    ObjectStublessClient94,
    ObjectStublessClient95,
    ObjectStublessClient96,
    ObjectStublessClient97,
    ObjectStublessClient98,
    ObjectStublessClient99,
    ObjectStublessClient100,
    ObjectStublessClient101,
    ObjectStublessClient102,
    ObjectStublessClient103,
    ObjectStublessClient104,
    ObjectStublessClient105,
    ObjectStublessClient106,
    ObjectStublessClient107,
    ObjectStublessClient108,
    ObjectStublessClient109,
    ObjectStublessClient110,
    ObjectStublessClient111,
    ObjectStublessClient112,
    ObjectStublessClient113,
    ObjectStublessClient114,
    ObjectStublessClient115,
    ObjectStublessClient116,
    ObjectStublessClient117,
    ObjectStublessClient118,
    ObjectStublessClient119,
    ObjectStublessClient120,
    ObjectStublessClient121,
    ObjectStublessClient122,
    ObjectStublessClient123,
    ObjectStublessClient124,
    ObjectStublessClient125,
    ObjectStublessClient126,
    ObjectStublessClient127,
    ObjectStublessClient128,
    ObjectStublessClient129,
    ObjectStublessClient130,
    ObjectStublessClient131,
    ObjectStublessClient132,
    ObjectStublessClient133,
    ObjectStublessClient134,
    ObjectStublessClient135,
    ObjectStublessClient136,
    ObjectStublessClient137,
    ObjectStublessClient138,
    ObjectStublessClient139,
    ObjectStublessClient140,
    ObjectStublessClient141,
    ObjectStublessClient142,
    ObjectStublessClient143,
    ObjectStublessClient144,
    ObjectStublessClient145,
    ObjectStublessClient146,
    ObjectStublessClient147,
    ObjectStublessClient148,
    ObjectStublessClient149,
    ObjectStublessClient150,
    ObjectStublessClient151,
    ObjectStublessClient152,
    ObjectStublessClient153,
    ObjectStublessClient154,
    ObjectStublessClient155,
    ObjectStublessClient156,
    ObjectStublessClient157,
    ObjectStublessClient158,
    ObjectStublessClient159,
    ObjectStublessClient160,
    ObjectStublessClient161,
    ObjectStublessClient162,
    ObjectStublessClient163,
    ObjectStublessClient164,
    ObjectStublessClient165,
    ObjectStublessClient166,
    ObjectStublessClient167,
    ObjectStublessClient168,
    ObjectStublessClient169,
    ObjectStublessClient170,
    ObjectStublessClient171,
    ObjectStublessClient172,
    ObjectStublessClient173,
    ObjectStublessClient174,
    ObjectStublessClient175,
    ObjectStublessClient176,
    ObjectStublessClient177,
    ObjectStublessClient178,
    ObjectStublessClient179,
    ObjectStublessClient180,
    ObjectStublessClient181,
    ObjectStublessClient182,
    ObjectStublessClient183,
    ObjectStublessClient184,
    ObjectStublessClient185,
    ObjectStublessClient186,
    ObjectStublessClient187,
    ObjectStublessClient188,
    ObjectStublessClient189,
    ObjectStublessClient190,
    ObjectStublessClient191,
    ObjectStublessClient192,
    ObjectStublessClient193,
    ObjectStublessClient194,
    ObjectStublessClient195,
    ObjectStublessClient196,
    ObjectStublessClient197,
    ObjectStublessClient198,
    ObjectStublessClient199,
    ObjectStublessClient200,
    ObjectStublessClient201,
    ObjectStublessClient202,
    ObjectStublessClient203,
    ObjectStublessClient204,
    ObjectStublessClient205,
    ObjectStublessClient206,
    ObjectStublessClient207,
    ObjectStublessClient208,
    ObjectStublessClient209,
    ObjectStublessClient210,
    ObjectStublessClient211,
    ObjectStublessClient212,
    ObjectStublessClient213,
    ObjectStublessClient214,
    ObjectStublessClient215,
    ObjectStublessClient216,
    ObjectStublessClient217,
    ObjectStublessClient218,
    ObjectStublessClient219,
    ObjectStublessClient220,
    ObjectStublessClient221,
    ObjectStublessClient222,
    ObjectStublessClient223,
    ObjectStublessClient224,
    ObjectStublessClient225,
    ObjectStublessClient226,
    ObjectStublessClient227,
    ObjectStublessClient228,
    ObjectStublessClient229,
    ObjectStublessClient230,
    ObjectStublessClient231,
    ObjectStublessClient232,
    ObjectStublessClient233,
    ObjectStublessClient234,
    ObjectStublessClient235,
    ObjectStublessClient236,
    ObjectStublessClient237,
    ObjectStublessClient238,
    ObjectStublessClient239,
    ObjectStublessClient240,
    ObjectStublessClient241,
    ObjectStublessClient242,
    ObjectStublessClient243,
    ObjectStublessClient244,
    ObjectStublessClient245,
    ObjectStublessClient246,
    ObjectStublessClient247,
    ObjectStublessClient248,
    ObjectStublessClient249,
    ObjectStublessClient250,
    ObjectStublessClient251,
    ObjectStublessClient252,
    ObjectStublessClient253,
    ObjectStublessClient254,
    ObjectStublessClient255,
    ObjectStublessClient256,
    ObjectStublessClient257,
    ObjectStublessClient258,
    ObjectStublessClient259,
    ObjectStublessClient260,
    ObjectStublessClient261,
    ObjectStublessClient262,
    ObjectStublessClient263,
    ObjectStublessClient264,
    ObjectStublessClient265,
    ObjectStublessClient266,
    ObjectStublessClient267,
    ObjectStublessClient268,
    ObjectStublessClient269,
    ObjectStublessClient270,
    ObjectStublessClient271,
    ObjectStublessClient272,
    ObjectStublessClient273,
    ObjectStublessClient274,
    ObjectStublessClient275,
    ObjectStublessClient276,
    ObjectStublessClient277,
    ObjectStublessClient278,
    ObjectStublessClient279,
    ObjectStublessClient280,
    ObjectStublessClient281,
    ObjectStublessClient282,
    ObjectStublessClient283,
    ObjectStublessClient284,
    ObjectStublessClient285,
    ObjectStublessClient286,
    ObjectStublessClient287,
    ObjectStublessClient288,
    ObjectStublessClient289,
    ObjectStublessClient290,
    ObjectStublessClient291,
    ObjectStublessClient292,
    ObjectStublessClient293,
    ObjectStublessClient294,
    ObjectStublessClient295,
    ObjectStublessClient296,
    ObjectStublessClient297,
    ObjectStublessClient298,
    ObjectStublessClient299,
    ObjectStublessClient300,
    ObjectStublessClient301,
    ObjectStublessClient302,
    ObjectStublessClient303,
    ObjectStublessClient304,
    ObjectStublessClient305,
    ObjectStublessClient306,
    ObjectStublessClient307,
    ObjectStublessClient308,
    ObjectStublessClient309,
    ObjectStublessClient310,
    ObjectStublessClient311,
    ObjectStublessClient312,
    ObjectStublessClient313,
    ObjectStublessClient314,
    ObjectStublessClient315,
    ObjectStublessClient316,
    ObjectStublessClient317,
    ObjectStublessClient318,
    ObjectStublessClient319,
    ObjectStublessClient320,
    ObjectStublessClient321,
    ObjectStublessClient322,
    ObjectStublessClient323,
    ObjectStublessClient324,
    ObjectStublessClient325,
    ObjectStublessClient326,
    ObjectStublessClient327,
    ObjectStublessClient328,
    ObjectStublessClient329,
    ObjectStublessClient330,
    ObjectStublessClient331,
    ObjectStublessClient332,
    ObjectStublessClient333,
    ObjectStublessClient334,
    ObjectStublessClient335,
    ObjectStublessClient336,
    ObjectStublessClient337,
    ObjectStublessClient338,
    ObjectStublessClient339,
    ObjectStublessClient340,
    ObjectStublessClient341,
    ObjectStublessClient342,
    ObjectStublessClient343,
    ObjectStublessClient344,
    ObjectStublessClient345,
    ObjectStublessClient346,
    ObjectStublessClient347,
    ObjectStublessClient348,
    ObjectStublessClient349,
    ObjectStublessClient350,
    ObjectStublessClient351,
    ObjectStublessClient352,
    ObjectStublessClient353,
    ObjectStublessClient354,
    ObjectStublessClient355,
    ObjectStublessClient356,
    ObjectStublessClient357,
    ObjectStublessClient358,
    ObjectStublessClient359,
    ObjectStublessClient360,
    ObjectStublessClient361,
    ObjectStublessClient362,
    ObjectStublessClient363,
    ObjectStublessClient364,
    ObjectStublessClient365,
    ObjectStublessClient366,
    ObjectStublessClient367,
    ObjectStublessClient368,
    ObjectStublessClient369,
    ObjectStublessClient370,
    ObjectStublessClient371,
    ObjectStublessClient372,
    ObjectStublessClient373,
    ObjectStublessClient374,
    ObjectStublessClient375,
    ObjectStublessClient376,
    ObjectStublessClient377,
    ObjectStublessClient378,
    ObjectStublessClient379,
    ObjectStublessClient380,
    ObjectStublessClient381,
    ObjectStublessClient382,
    ObjectStublessClient383,
    ObjectStublessClient384,
    ObjectStublessClient385,
    ObjectStublessClient386,
    ObjectStublessClient387,
    ObjectStublessClient388,
    ObjectStublessClient389,
    ObjectStublessClient390,
    ObjectStublessClient391,
    ObjectStublessClient392,
    ObjectStublessClient393,
    ObjectStublessClient394,
    ObjectStublessClient395,
    ObjectStublessClient396,
    ObjectStublessClient397,
    ObjectStublessClient398,
    ObjectStublessClient399,
    ObjectStublessClient400,
    ObjectStublessClient401,
    ObjectStublessClient402,
    ObjectStublessClient403,
    ObjectStublessClient404,
    ObjectStublessClient405,
    ObjectStublessClient406,
    ObjectStublessClient407,
    ObjectStublessClient408,
    ObjectStublessClient409,
    ObjectStublessClient410,
    ObjectStublessClient411,
    ObjectStublessClient412,
    ObjectStublessClient413,
    ObjectStublessClient414,
    ObjectStublessClient415,
    ObjectStublessClient416,
    ObjectStublessClient417,
    ObjectStublessClient418,
    ObjectStublessClient419,
    ObjectStublessClient420,
    ObjectStublessClient421,
    ObjectStublessClient422,
    ObjectStublessClient423,
    ObjectStublessClient424,
    ObjectStublessClient425,
    ObjectStublessClient426,
    ObjectStublessClient427,
    ObjectStublessClient428,
    ObjectStublessClient429,
    ObjectStublessClient430,
    ObjectStublessClient431,
    ObjectStublessClient432,
    ObjectStublessClient433,
    ObjectStublessClient434,
    ObjectStublessClient435,
    ObjectStublessClient436,
    ObjectStublessClient437,
    ObjectStublessClient438,
    ObjectStublessClient439,
    ObjectStublessClient440,
    ObjectStublessClient441,
    ObjectStublessClient442,
    ObjectStublessClient443,
    ObjectStublessClient444,
    ObjectStublessClient445,
    ObjectStublessClient446,
    ObjectStublessClient447,
    ObjectStublessClient448,
    ObjectStublessClient449,
    ObjectStublessClient450,
    ObjectStublessClient451,
    ObjectStublessClient452,
    ObjectStublessClient453,
    ObjectStublessClient454,
    ObjectStublessClient455,
    ObjectStublessClient456,
    ObjectStublessClient457,
    ObjectStublessClient458,
    ObjectStublessClient459,
    ObjectStublessClient460,
    ObjectStublessClient461,
    ObjectStublessClient462,
    ObjectStublessClient463,
    ObjectStublessClient464,
    ObjectStublessClient465,
    ObjectStublessClient466,
    ObjectStublessClient467,
    ObjectStublessClient468,
    ObjectStublessClient469,
    ObjectStublessClient470,
    ObjectStublessClient471,
    ObjectStublessClient472,
    ObjectStublessClient473,
    ObjectStublessClient474,
    ObjectStublessClient475,
    ObjectStublessClient476,
    ObjectStublessClient477,
    ObjectStublessClient478,
    ObjectStublessClient479,
    ObjectStublessClient480,
    ObjectStublessClient481,
    ObjectStublessClient482,
    ObjectStublessClient483,
    ObjectStublessClient484,
    ObjectStublessClient485,
    ObjectStublessClient486,
    ObjectStublessClient487,
    ObjectStublessClient488,
    ObjectStublessClient489,
    ObjectStublessClient490,
    ObjectStublessClient491,
    ObjectStublessClient492,
    ObjectStublessClient493,
    ObjectStublessClient494,
    ObjectStublessClient495,
    ObjectStublessClient496,
    ObjectStublessClient497,
    ObjectStublessClient498,
    ObjectStublessClient499,
    ObjectStublessClient500,
    ObjectStublessClient501,
    ObjectStublessClient502,
    ObjectStublessClient503,
    ObjectStublessClient504,
    ObjectStublessClient505,
    ObjectStublessClient506,
    ObjectStublessClient507,
    ObjectStublessClient508,
    ObjectStublessClient509,
    ObjectStublessClient510,
    ObjectStublessClient511,
    ObjectStublessClient512,
    ObjectStublessClient513,
    ObjectStublessClient514,
    ObjectStublessClient515,
    ObjectStublessClient516,
    ObjectStublessClient517,
    ObjectStublessClient518,
    ObjectStublessClient519,
    ObjectStublessClient520,
    ObjectStublessClient521,
    ObjectStublessClient522,
    ObjectStublessClient523,
    ObjectStublessClient524,
    ObjectStublessClient525,
    ObjectStublessClient526,
    ObjectStublessClient527,
    ObjectStublessClient528,
    ObjectStublessClient529,
    ObjectStublessClient530,
    ObjectStublessClient531,
    ObjectStublessClient532,
    ObjectStublessClient533,
    ObjectStublessClient534,
    ObjectStublessClient535,
    ObjectStublessClient536,
    ObjectStublessClient537,
    ObjectStublessClient538,
    ObjectStublessClient539,
    ObjectStublessClient540,
    ObjectStublessClient541,
    ObjectStublessClient542,
    ObjectStublessClient543,
    ObjectStublessClient544,
    ObjectStublessClient545,
    ObjectStublessClient546,
    ObjectStublessClient547,
    ObjectStublessClient548,
    ObjectStublessClient549,
    ObjectStublessClient550,
    ObjectStublessClient551,
    ObjectStublessClient552,
    ObjectStublessClient553,
    ObjectStublessClient554,
    ObjectStublessClient555,
    ObjectStublessClient556,
    ObjectStublessClient557,
    ObjectStublessClient558,
    ObjectStublessClient559,
    ObjectStublessClient560,
    ObjectStublessClient561,
    ObjectStublessClient562,
    ObjectStublessClient563,
    ObjectStublessClient564,
    ObjectStublessClient565,
    ObjectStublessClient566,
    ObjectStublessClient567,
    ObjectStublessClient568,
    ObjectStublessClient569,
    ObjectStublessClient570,
    ObjectStublessClient571,
    ObjectStublessClient572,
    ObjectStublessClient573,
    ObjectStublessClient574,
    ObjectStublessClient575,
    ObjectStublessClient576,
    ObjectStublessClient577,
    ObjectStublessClient578,
    ObjectStublessClient579,
    ObjectStublessClient580,
    ObjectStublessClient581,
    ObjectStublessClient582,
    ObjectStublessClient583,
    ObjectStublessClient584,
    ObjectStublessClient585,
    ObjectStublessClient586,
    ObjectStublessClient587,
    ObjectStublessClient588,
    ObjectStublessClient589,
    ObjectStublessClient590,
    ObjectStublessClient591,
    ObjectStublessClient592,
    ObjectStublessClient593,
    ObjectStublessClient594,
    ObjectStublessClient595,
    ObjectStublessClient596,
    ObjectStublessClient597,
    ObjectStublessClient598,
    ObjectStublessClient599,
    ObjectStublessClient600,
    ObjectStublessClient601,
    ObjectStublessClient602,
    ObjectStublessClient603,
    ObjectStublessClient604,
    ObjectStublessClient605,
    ObjectStublessClient606,
    ObjectStublessClient607,
    ObjectStublessClient608,
    ObjectStublessClient609,
    ObjectStublessClient610,
    ObjectStublessClient611,
    ObjectStublessClient612,
    ObjectStublessClient613,
    ObjectStublessClient614,
    ObjectStublessClient615,
    ObjectStublessClient616,
    ObjectStublessClient617,
    ObjectStublessClient618,
    ObjectStublessClient619,
    ObjectStublessClient620,
    ObjectStublessClient621,
    ObjectStublessClient622,
    ObjectStublessClient623,
    ObjectStublessClient624,
    ObjectStublessClient625,
    ObjectStublessClient626,
    ObjectStublessClient627,
    ObjectStublessClient628,
    ObjectStublessClient629,
    ObjectStublessClient630,
    ObjectStublessClient631,
    ObjectStublessClient632,
    ObjectStublessClient633,
    ObjectStublessClient634,
    ObjectStublessClient635,
    ObjectStublessClient636,
    ObjectStublessClient637,
    ObjectStublessClient638,
    ObjectStublessClient639,
    ObjectStublessClient640,
    ObjectStublessClient641,
    ObjectStublessClient642,
    ObjectStublessClient643,
    ObjectStublessClient644,
    ObjectStublessClient645,
    ObjectStublessClient646,
    ObjectStublessClient647,
    ObjectStublessClient648,
    ObjectStublessClient649,
    ObjectStublessClient650,
    ObjectStublessClient651,
    ObjectStublessClient652,
    ObjectStublessClient653,
    ObjectStublessClient654,
    ObjectStublessClient655,
    ObjectStublessClient656,
    ObjectStublessClient657,
    ObjectStublessClient658,
    ObjectStublessClient659,
    ObjectStublessClient660,
    ObjectStublessClient661,
    ObjectStublessClient662,
    ObjectStublessClient663,
    ObjectStublessClient664,
    ObjectStublessClient665,
    ObjectStublessClient666,
    ObjectStublessClient667,
    ObjectStublessClient668,
    ObjectStublessClient669,
    ObjectStublessClient670,
    ObjectStublessClient671,
    ObjectStublessClient672,
    ObjectStublessClient673,
    ObjectStublessClient674,
    ObjectStublessClient675,
    ObjectStublessClient676,
    ObjectStublessClient677,
    ObjectStublessClient678,
    ObjectStublessClient679,
    ObjectStublessClient680,
    ObjectStublessClient681,
    ObjectStublessClient682,
    ObjectStublessClient683,
    ObjectStublessClient684,
    ObjectStublessClient685,
    ObjectStublessClient686,
    ObjectStublessClient687,
    ObjectStublessClient688,
    ObjectStublessClient689,
    ObjectStublessClient690,
    ObjectStublessClient691,
    ObjectStublessClient692,
    ObjectStublessClient693,
    ObjectStublessClient694,
    ObjectStublessClient695,
    ObjectStublessClient696,
    ObjectStublessClient697,
    ObjectStublessClient698,
    ObjectStublessClient699,
    ObjectStublessClient700,
    ObjectStublessClient701,
    ObjectStublessClient702,
    ObjectStublessClient703,
    ObjectStublessClient704,
    ObjectStublessClient705,
    ObjectStublessClient706,
    ObjectStublessClient707,
    ObjectStublessClient708,
    ObjectStublessClient709,
    ObjectStublessClient710,
    ObjectStublessClient711,
    ObjectStublessClient712,
    ObjectStublessClient713,
    ObjectStublessClient714,
    ObjectStublessClient715,
    ObjectStublessClient716,
    ObjectStublessClient717,
    ObjectStublessClient718,
    ObjectStublessClient719,
    ObjectStublessClient720,
    ObjectStublessClient721,
    ObjectStublessClient722,
    ObjectStublessClient723,
    ObjectStublessClient724,
    ObjectStublessClient725,
    ObjectStublessClient726,
    ObjectStublessClient727,
    ObjectStublessClient728,
    ObjectStublessClient729,
    ObjectStublessClient730,
    ObjectStublessClient731,
    ObjectStublessClient732,
    ObjectStublessClient733,
    ObjectStublessClient734,
    ObjectStublessClient735,
    ObjectStublessClient736,
    ObjectStublessClient737,
    ObjectStublessClient738,
    ObjectStublessClient739,
    ObjectStublessClient740,
    ObjectStublessClient741,
    ObjectStublessClient742,
    ObjectStublessClient743,
    ObjectStublessClient744,
    ObjectStublessClient745,
    ObjectStublessClient746,
    ObjectStublessClient747,
    ObjectStublessClient748,
    ObjectStublessClient749,
    ObjectStublessClient750,
    ObjectStublessClient751,
    ObjectStublessClient752,
    ObjectStublessClient753,
    ObjectStublessClient754,
    ObjectStublessClient755,
    ObjectStublessClient756,
    ObjectStublessClient757,
    ObjectStublessClient758,
    ObjectStublessClient759,
    ObjectStublessClient760,
    ObjectStublessClient761,
    ObjectStublessClient762,
    ObjectStublessClient763,
    ObjectStublessClient764,
    ObjectStublessClient765,
    ObjectStublessClient766,
    ObjectStublessClient767,
    ObjectStublessClient768,
    ObjectStublessClient769,
    ObjectStublessClient770,
    ObjectStublessClient771,
    ObjectStublessClient772,
    ObjectStublessClient773,
    ObjectStublessClient774,
    ObjectStublessClient775,
    ObjectStublessClient776,
    ObjectStublessClient777,
    ObjectStublessClient778,
    ObjectStublessClient779,
    ObjectStublessClient780,
    ObjectStublessClient781,
    ObjectStublessClient782,
    ObjectStublessClient783,
    ObjectStublessClient784,
    ObjectStublessClient785,
    ObjectStublessClient786,
    ObjectStublessClient787,
    ObjectStublessClient788,
    ObjectStublessClient789,
    ObjectStublessClient790,
    ObjectStublessClient791,
    ObjectStublessClient792,
    ObjectStublessClient793,
    ObjectStublessClient794,
    ObjectStublessClient795,
    ObjectStublessClient796,
    ObjectStublessClient797,
    ObjectStublessClient798,
    ObjectStublessClient799,
    ObjectStublessClient800,
    ObjectStublessClient801,
    ObjectStublessClient802,
    ObjectStublessClient803,
    ObjectStublessClient804,
    ObjectStublessClient805,
    ObjectStublessClient806,
    ObjectStublessClient807,
    ObjectStublessClient808,
    ObjectStublessClient809,
    ObjectStublessClient810,
    ObjectStublessClient811,
    ObjectStublessClient812,
    ObjectStublessClient813,
    ObjectStublessClient814,
    ObjectStublessClient815,
    ObjectStublessClient816,
    ObjectStublessClient817,
    ObjectStublessClient818,
    ObjectStublessClient819,
    ObjectStublessClient820,
    ObjectStublessClient821,
    ObjectStublessClient822,
    ObjectStublessClient823,
    ObjectStublessClient824,
    ObjectStublessClient825,
    ObjectStublessClient826,
    ObjectStublessClient827,
    ObjectStublessClient828,
    ObjectStublessClient829,
    ObjectStublessClient830,
    ObjectStublessClient831,
    ObjectStublessClient832,
    ObjectStublessClient833,
    ObjectStublessClient834,
    ObjectStublessClient835,
    ObjectStublessClient836,
    ObjectStublessClient837,
    ObjectStublessClient838,
    ObjectStublessClient839,
    ObjectStublessClient840,
    ObjectStublessClient841,
    ObjectStublessClient842,
    ObjectStublessClient843,
    ObjectStublessClient844,
    ObjectStublessClient845,
    ObjectStublessClient846,
    ObjectStublessClient847,
    ObjectStublessClient848,
    ObjectStublessClient849,
    ObjectStublessClient850,
    ObjectStublessClient851,
    ObjectStublessClient852,
    ObjectStublessClient853,
    ObjectStublessClient854,
    ObjectStublessClient855,
    ObjectStublessClient856,
    ObjectStublessClient857,
    ObjectStublessClient858,
    ObjectStublessClient859,
    ObjectStublessClient860,
    ObjectStublessClient861,
    ObjectStublessClient862,
    ObjectStublessClient863,
    ObjectStublessClient864,
    ObjectStublessClient865,
    ObjectStublessClient866,
    ObjectStublessClient867,
    ObjectStublessClient868,
    ObjectStublessClient869,
    ObjectStublessClient870,
    ObjectStublessClient871,
    ObjectStublessClient872,
    ObjectStublessClient873,
    ObjectStublessClient874,
    ObjectStublessClient875,
    ObjectStublessClient876,
    ObjectStublessClient877,
    ObjectStublessClient878,
    ObjectStublessClient879,
    ObjectStublessClient880,
    ObjectStublessClient881,
    ObjectStublessClient882,
    ObjectStublessClient883,
    ObjectStublessClient884,
    ObjectStublessClient885,
    ObjectStublessClient886,
    ObjectStublessClient887,
    ObjectStublessClient888,
    ObjectStublessClient889,
    ObjectStublessClient890,
    ObjectStublessClient891,
    ObjectStublessClient892,
    ObjectStublessClient893,
    ObjectStublessClient894,
    ObjectStublessClient895,
    ObjectStublessClient896,
    ObjectStublessClient897,
    ObjectStublessClient898,
    ObjectStublessClient899,
    ObjectStublessClient900,
    ObjectStublessClient901,
    ObjectStublessClient902,
    ObjectStublessClient903,
    ObjectStublessClient904,
    ObjectStublessClient905,
    ObjectStublessClient906,
    ObjectStublessClient907,
    ObjectStublessClient908,
    ObjectStublessClient909,
    ObjectStublessClient910,
    ObjectStublessClient911,
    ObjectStublessClient912,
    ObjectStublessClient913,
    ObjectStublessClient914,
    ObjectStublessClient915,
    ObjectStublessClient916,
    ObjectStublessClient917,
    ObjectStublessClient918,
    ObjectStublessClient919,
    ObjectStublessClient920,
    ObjectStublessClient921,
    ObjectStublessClient922,
    ObjectStublessClient923,
    ObjectStublessClient924,
    ObjectStublessClient925,
    ObjectStublessClient926,
    ObjectStublessClient927,
    ObjectStublessClient928,
    ObjectStublessClient929,
    ObjectStublessClient930,
    ObjectStublessClient931,
    ObjectStublessClient932,
    ObjectStublessClient933,
    ObjectStublessClient934,
    ObjectStublessClient935,
    ObjectStublessClient936,
    ObjectStublessClient937,
    ObjectStublessClient938,
    ObjectStublessClient939,
    ObjectStublessClient940,
    ObjectStublessClient941,
    ObjectStublessClient942,
    ObjectStublessClient943,
    ObjectStublessClient944,
    ObjectStublessClient945,
    ObjectStublessClient946,
    ObjectStublessClient947,
    ObjectStublessClient948,
    ObjectStublessClient949,
    ObjectStublessClient950,
    ObjectStublessClient951,
    ObjectStublessClient952,
    ObjectStublessClient953,
    ObjectStublessClient954,
    ObjectStublessClient955,
    ObjectStublessClient956,
    ObjectStublessClient957,
    ObjectStublessClient958,
    ObjectStublessClient959,
    ObjectStublessClient960,
    ObjectStublessClient961,
    ObjectStublessClient962,
    ObjectStublessClient963,
    ObjectStublessClient964,
    ObjectStublessClient965,
    ObjectStublessClient966,
    ObjectStublessClient967,
    ObjectStublessClient968,
    ObjectStublessClient969,
    ObjectStublessClient970,
    ObjectStublessClient971,
    ObjectStublessClient972,
    ObjectStublessClient973,
    ObjectStublessClient974,
    ObjectStublessClient975,
    ObjectStublessClient976,
    ObjectStublessClient977,
    ObjectStublessClient978,
    ObjectStublessClient979,
    ObjectStublessClient980,
    ObjectStublessClient981,
    ObjectStublessClient982,
    ObjectStublessClient983,
    ObjectStublessClient984,
    ObjectStublessClient985,
    ObjectStublessClient986,
    ObjectStublessClient987,
    ObjectStublessClient988,
    ObjectStublessClient989,
    ObjectStublessClient990,
    ObjectStublessClient991,
    ObjectStublessClient992,
    ObjectStublessClient993,
    ObjectStublessClient994,
    ObjectStublessClient995,
    ObjectStublessClient996,
    ObjectStublessClient997,
    ObjectStublessClient998,
    ObjectStublessClient999,
    ObjectStublessClient1000,
    ObjectStublessClient1001,
    ObjectStublessClient1002,
    ObjectStublessClient1003,
    ObjectStublessClient1004,
    ObjectStublessClient1005,
    ObjectStublessClient1006,
    ObjectStublessClient1007,
    ObjectStublessClient1008,
    ObjectStublessClient1009,
    ObjectStublessClient1010,
    ObjectStublessClient1011,
    ObjectStublessClient1012,
    ObjectStublessClient1013,
    ObjectStublessClient1014,
    ObjectStublessClient1015,
    ObjectStublessClient1016,
    ObjectStublessClient1017,
    ObjectStublessClient1018,
    ObjectStublessClient1019,
    ObjectStublessClient1020,
    ObjectStublessClient1021,
    ObjectStublessClient1022,
    ObjectStublessClient1023
    };

}

void ** StublessClientVtbl = (void **)g_StublessClientVtbl;
long
ObjectStublessClient(
    void *  ParamAddress,
    long    Method
    )
{
    PMIDL_STUBLESS_PROXY_INFO   ProxyInfo;
    CInterfaceProxyHeader *     ProxyHeader;
    PFORMAT_STRING              ProcFormat;
    unsigned short              ProcFormatOffset;
    CLIENT_CALL_RETURN          Return;
    void *                      This;

    This = *((void **)ParamAddress);

    ProxyHeader = (CInterfaceProxyHeader *)
                  (*((char **)This) - sizeof(CInterfaceProxyHeader));
    ProxyInfo = (PMIDL_STUBLESS_PROXY_INFO) ProxyHeader->pStublessProxyInfo;

    if ( ProxyInfo->pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES  )
    {
        NDR_PROC_CONTEXT ProcContext;
        HRESULT          hr;

        Ndr64ClientInitializeContext(
                               NdrpGetSyntaxType( ProxyInfo->pTransferSyntax),
                               ProxyInfo,
                               Method,
                               &ProcContext,
                               (uchar*)ParamAddress );

        if ( ProcContext.FloatDoubleMask != 0 )
            SpillFPRegsForIA64( (REGISTER_TYPE*)ParamAddress, ProcContext.FloatDoubleMask );


        if ( ProcContext.IsAsync )
            {
            if ( Method & 0x1 )
                hr =  MulNdrpBeginDcomAsyncClientCall( ProxyInfo,
                                               Method,
                                               &ProcContext,
                                               ParamAddress );
            else
                hr =  MulNdrpFinishDcomAsyncClientCall(ProxyInfo,
                                               Method,
                                               &ProcContext,
                                               ParamAddress );
            Return.Simple = hr;
            }
        else
            Return = NdrpClientCall3(This,
                                     ProxyInfo,
                                     Method,
                                     NULL,
                                     &ProcContext,
                                     (uchar*)ParamAddress);

        return (long) Return.Simple;
    }

    ProcFormatOffset = ProxyInfo->FormatStringOffset[Method];
    ProcFormat = &ProxyInfo->ProcFormatString[ProcFormatOffset];

    // The first public MIDL with 64b support was released with NT5 betA2.
    // We will ignore any MIDL earlier than the MIDL released with NT5/2000 beta3.
    // Change MIDL_VERSION_5_2_202 to the MIDL version for beta3, now at 5.2.221.

    if ( ProxyInfo->pStubDesc->MIDLVersion < MIDL_VERSION_5_2_202 )
        {
        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
        }

    // Since MIDL 3.0.39 we have a proc flag that indicates
    // which interpeter to call. This is because the NDR version
    // may be bigger than 1.1 for other reasons.
    // MIDL version is 5.2.+ so the flag is guaraneed to be there.

    if ( ProcFormat[1]  &  Oi_OBJ_USE_V2_INTERPRETER )
        {
            {
            ULONG   FloatArgMask = 0;

            if ( ((PNDR_DCOM_OI2_PROC_HEADER) ProcFormat)->Oi2Flags.HasExtensions )
                {
                PNDR_PROC_HEADER_EXTS64 pExts = (PNDR_PROC_HEADER_EXTS64)
                                    (ProcFormat + sizeof(NDR_DCOM_OI2_PROC_HEADER));

                FloatArgMask = pExts->FloatArgMask;
                }

            if ( FloatArgMask != 0 )
                SpillFPRegsForIA64( (REGISTER_TYPE*)ParamAddress, FloatArgMask );
            }

        if ( ((PNDR_DCOM_OI2_PROC_HEADER) ProcFormat)->Oi2Flags.HasAsyncUuid )
            {
            Return = NdrpDcomAsyncClientCall( ProxyInfo->pStubDesc,
                                             ProcFormat,
                                             (uchar*)ParamAddress );
            }
        else
            {
            Return = NdrpClientCall2( ProxyInfo->pStubDesc,
                                     ProcFormat,
                                     (uchar*)ParamAddress );
            }
        }
    else
        {
        // No support for old interpreter on 64b platform.
        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
        }

    return (long) Return.Simple;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\amd64\stubless.asm ===
title   "Stubless Support"
;++
;
; Copyright (C) 2000  Microsoft Corporation
;
; Module Name:
;
;   stubless.asm
;
; Abstract:
;
;   This module contains interpreter support routines for the AMD64 platform.
;
; Author:
;
;   David N. Cutler 30-Dec-2000
;
; Environment:
;
;   User mode.
;
;--

include ksamd64.inc

        extern  ObjectStublessClient:proc
        extern  __chkstk:proc

;
; Define object stubless client macro.
;

STUBLESS_CLIENT macro Method

        LEAF_ENTRY ObjectStublessClient&Method, _TEXT$00

        mov     r10d, Method            ; set method number
        jmp     ObjectStubless          ; finish in common code

        LEAF_END ObjectStublessClient&Method, _TEXT$00

        endm

;
; Generate stubless client thunks.
;

index = 3

        rept    (1023 - 3 + 1)

        STUBLESS_CLIENT %index

index = index + 1

        endm

        subttl  "Common Object Stubless Client Code"
;++
;
; long
; ObjectStubless (
;     ...
;     )
;
; Routine description:
;
;   This function is jumped to from the corresponding linkage stub and calls
;   the object stubless client routine to invoke the ultimate function.
;
;   N.B. Only three of the possible floating argument registers are saved.
;        The first argument is the "this" pointer, and therefore, cannot be
;        a floating value.
;
; Arguments:
;
;   ...
;
; Implicit Arguments:
;
;   Method (r10d) - Supplies the method number from the thunk code.
;
; Return Value:
;
;   The value as returned by the target function.
;
;--

OsFrame struct
        SavedXmm1 dq ?                  ; saved nonvolatile registers
        SavedXmm2 dq ?                  ;
        SavedXmm3 dq ?                  ;
OsFrame ends

        NESTED_ENTRY ObjectStubless, _TEXT$00

        alloc_stack sizeof OsFrame      ; allocate stack frame
        save_xmm xmm1, OsFrame.SavedXmm1 ; save nonvolatile registers
        save_xmm xmm2, OsFrame.SavedXmm2 ;
        save_xmm xmm3, OsFrame.SavedXmm3 ;

        END_PROLOGUE

        mov     sizeof OsFrame + 8[rsp], rcx ; save register arguments in
        mov     sizeof OsFrame + 16[rsp], rdx ;    home addresses
        mov     sizeof OsFrame + 24[rsp], r8 ;
        mov     sizeof OsFrame + 32[rsp], r9 ;
        lea     rcx, sizeof OsFrame + 8[rsp] ; set address of argument list
        mov     rdx, rsp                ; set address of floating registers
        mov     r8d, r10d               ; set method number
        call    ObjectStublessClient    ;
        add     rsp, sizeof OsFrame     ; deallocate stack frame
        ret                             ; return

        NESTED_END ObjectStubless, _TEXT$00

        subttl  "Invoke Function with Parameter List"
;++
;
; REGISTER_TYPE
; Invoke (
;     MANAGER_FUNCTION Function,
;     REGISTER_TYPE *ArgumentList,
;     ULONG Arguments
;     )
;
; Routine description:
;
;   This function builds an appropriate argument list and calls the specified
;   function.
;
; Arguments:
;
;   Function (rcx) - Supplies a pointer to the target function.
;
;   ArgumentList (rdx) - Supplies a pointer to the argument list.
;
;   Arguments (r8d) - Supplies the number of arguments.
;
; Return Value:
;
;   The value as returned by the target function.
;
;--

        NESTED_ENTRY Invoke, _TEXT$00

        push_reg rdi                    ; save nonvolatile registers
        push_reg rsi                    ;
        push_reg rbp                    ;
        set_frame rbp, 0                ; set frame pointer

        END_PROLOGUE

        mov     eax, r8d                ; round to even argument count
        inc     eax                     ;
        and     al, 0feh                ;
        shl     eax, 3                  ; compute number of bytes
        call    __chkstk                ; check stack allocation
        sub     rsp, rax                ; allocate argument list
        mov     r10, rcx                ; save address of function
        mov     rsi, rdx                ; set source argument list address
        mov     rdi, rsp                ; set destination argument list address
        mov     ecx, r8d                ; set number of arguments
    rep movsq                           ; copy arguments to the stack

;
; N.B. All four argument registers are loaded regardless of the actual number
;      of arguments.
;
; N.B. The first argument cannot be in a floating point register and therefore
;      xmm0 is not loaded.
;

        mov     rcx, 0[rsp]             ; load first four argument registers
        mov     rdx, 8[rsp]             ;
        movq    xmm1, 8[rsp]            ;
        mov     r8, 16[rsp]             ;
        movq    xmm2, 16[rsp]           ;
        mov     r9, 24[rsp]             ;
        movq    xmm3, 24[rsp]           ;
        call    r10                     ; call target function
        mov     rsp, rbp                ; deallocate argument list
        pop     rbp                     ; restore nonvolatile register
        pop     rsi                     ;
        pop     rdi                     ;
        ret                             ;

        NESTED_END Invoke, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\ia64\stubless.s ===
// Copyright (c) 1993-1999 Microsoft Corporation

        .file       "stubless.s"

#include "ksia64.h"

        .global ObjectStublessClient
        .type   ObjectStublessClient, @function

//++
//
//  Function:   REGISTER_TYPE __stdcall Invoke(MANAGER_FUNCTION pFunction, 
//                                             REGISTER_TYPE   *pArgumentList,
//                                             ULONG            FloatMask,
//                                             ULONG            cArguments);
//
//  Synopsis:   Given a function pointer and an argument list, Invoke builds 
//              a stack frame and calls the function.
//
//  Arguments:  pFunction - Pointer to the function to be called.
//
//              pArgumentList - Pointer to the buffer containing the 
//                              function parameters.
//
//              FloatMask - A mask that indicates argument slots passed as float/double registers
//                          Each nibble indicates if the argument slot contains a float
//                          Float       : D8 F8 D7 F7 D6 F6 D5 F5 D4 F4 D3 F3 D2 F2 D1 F1
//                          bit position: 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
//                          16 bits represents 8 slots
//                          If both the D and F bits are set then the argument slot contains
//                          *two* floating point args.
//
//              cArguments - The size of the argument list in REGISTER_TYPEs.
//
//
//  Notes:     In the __stdcall calling convention, the callee must pop
//             the parameters.
//
//--
        NESTED_ENTRY(Invoke)
        NESTED_SETUP(4,4,8,0)

        NumParam        = a3
        FloatMask       = a2
        ParamStartAddr  = a1
        CallFuncAddr    = a0

        savedSP         = loc2
        savedLC         = loc3

        paramSz         = t10
        funcAddr        = t11
        paramAddr       = t12
                
        startP          = t13
        endP            = t14

        ARGPTR          (a0)
        ARGPTR          (a1)

        .vframe savedSP
        mov             savedSP = sp                    // save sp
		mov             savedLC = ar.lc                 // preserve loop count
        shl             paramSz = NumParam, 3           // num * szof(register)
        ;;

        PROLOGUE_END

        mov             paramAddr = ParamStartAddr      // param address
        add             startP = ParamStartAddr,paramSz // to copy bottom to top
        ;;

//
//  Check if the parameter list is > 64 bytes. If so then jump to the default
//  label. This will copy parameters > 64 bytes to the stack.
//
//  If the paramter list is < 64 bytes then calculate the number of registers required
//  and dispatch to the correct load label.
//
        
        add             startP = -8, startP             // compute start address
                                                        // = pAddr + pSz - 8
        cmp4.ge         pt0, pt1 = 64, paramSz          // if paramSz > 64 bytes
(pt1)   br.cond.spnt    default                         // yes

        movl            t0 = label0                     // no. mem copy not needed 
        shl             t1 = NumParam, 4;;
        sub             t0 = t0, t1;;                   // get correct bundle addr    
        mov             bt0 = t0                        // to jump to
        br.cond.sptk    bt0        

default:                                                // copy in-memory args

        tbit.nz         pt2, pt3 = NumParam, 0          // is NumParam even?
        add             endP = 64, paramAddr            // last address
        add             t0 = -64, paramSz
        ;;

(pt2)   add             t0 = -8, t0
(pt3)   add             t0 = -16, t0
(pt2)   mov             t2 = savedSP
(pt3)   add             t2 = 8, savedSP
        ;;

        sub             sp = sp, t0                     // allocate stack frame

//
//      Load arguments > 64 bytes on to the stack
//
NextParam:
        ld8             t3 = [startP], -8            
        ;;
        st8             [t2] = t3, -8
        cmp.lt          pt0, pt1 = startP, endP         // while current >= end
(pt1)   br.cond.sptk    NextParam   
        ;;

//
//      Load the appropriate number of registers
//

label8:
        ld8             out7 = [startP], -8
        nop.i           0
        nop.i           0;;
label7:
        ld8             out6 = [startP], -8
        nop.i           0
        nop.i           0;;

label6:
        ld8             out5 = [startP], -8
        nop.i           0
        nop.i           0;;

label5:
        ld8             out4 = [startP], -8
        nop.i           0
        nop.i           0;;

label4:
        ld8             out3 = [startP], -8
        nop.i           0
        nop.i           0;;

label3:
        ld8             out2 = [startP], -8
        nop.i           0
        nop.i           0;;

label2:
        ld8             out1 = [startP], -8
        nop.i           0
        nop.i           0;;

label1:
        ld8             out0 = [startP]
        nop.i           0
        nop.i           0;;

label0:
//
// If there are any floating point registers load them here      
//
        cmp.eq          pt1 = 0,FloatMask           // Check for Zero FP Arguments
(pt1)   br.cond.sptk    NoFloat                     // If eql zero we are All done

//
//  Loop through the floating mask looking for slots containing fp values
//  Algorithm:
//     The position of float arguments is unknown so iterate sequentially
//     through the FloatMask. Each time a float is found rotate the registers
//     using a counted loop. 
//
//  lc  - Loop count. Initialize to the maximum number of arguments   
//  t15 - Contains the floatmask. Shifted each iteration of the loop
//  t14 - bits<1:0> contain the current float descriptor
//  t12 - Contains the current parameter (i.e., slot) address
//  f32 - Rotated float register
//  pt1 - True if FloatMask equals zero
//  pt2 - True if current descriptor equals zero
//  pr16 - True if current descriptor contains a float. Rotate (pr17,pr18,etc) each iteration of the loop
//  pt3  - True if current descriptor contains float value
//  pt4  - True if current descriptor contanis double value
//
//        
        mov         t15    = FloatMask;;            // Make a copy 
        popcnt      t4     = t15;;                  // Count the number of floating point regs needed
        mov         t12    = paramAddr
        mov         ar.lc  = t4;;                   // The maximum loop count

GetNextFloatDescriptor:
        extr.u      t14 = t15, 0, 2                 // Extract the current descriptor (D or F)
        shr         t15 = t15,2;;                   // Shift to get next descriptor
        cmp.eq      pt1 = 0,t15                     // See if the mask is zero ( 0 = all done)
        cmp.eq      pt2 = 0,t14                     // If the current descriptor is zero get the next descriptor
        cmp.eq      pt3 = 1,t14                     // Check for float 
        cmp.eq      pt4 = 2,t14                     // Check for double
        cmp.ne      pt5 = 3,t14;;                   // Check for dual floats

(pt3)   ldfs        f32 = [t12];;                   // Load float
(pt4)   ldfd        f32 = [t12];;                   // Load double
(pt5)   br.cond.sptk    SkipDualFloat

        br.ctop.sptk    DualFloatRegBump;;          // Force an extra register rotate if dual floats
DualFloatRegBump:
        ldfps       f33,f32 = [t12];;               // Load two floats
    
SkipDualFloat:
        add         t12 = 8,t12;;                   // Increment argument slot address
(pt1)   br.cond.sptk    MoveFloat                   // If the mask is zero exit loop
(pt2)   br.cond.sptk    GetNextFloatDescriptor      // A zero descriptor pays a branch penality
                                                    // but it does not rotate the registers                 
        br.ctop.sptk    GetNextFloatDescriptor      // Counted loop no penalty for branch rotate f32&pr16 
        ;;
//
// At this point the fp values are in f32-f39. Predicate registers pr16-pr23 
// are set for each float found. Copy the float values to f8-f15
//
MoveFloat:

        cmp.eq      pt1 = 1, t4;;           // look at the number of floats and move accordingly.
(pt1)   br.cond.sptk    MoveOne
        cmp.eq      pt2 = 2, t4;;
(pt2)   br.cond.sptk    MoveTwo
        cmp.eq      pt3 = 3, t4;;
(pt3)   br.cond.sptk    MoveThree
        cmp.eq      pt4 = 4, t4;;
(pt4)   br.cond.sptk    MoveFour
        cmp.eq      pt5 = 5, t4;;
(pt5)   br.cond.sptk    MoveFive
        cmp.eq      pt6 = 6, t4;;
(pt6)   br.cond.sptk    MoveSix
        cmp.eq      pt7 = 7, t4;;
(pt7)   br.cond.sptk    MoveSeven
        cmp.eq      pt8 = 8, t4;;
(pt8)   br.cond.sptk    MoveEight

        br.cond.sptk DoneMoveFloat;;        // we should never get here, but just in case, exit.

MoveOne:
        mov         f8 = f32
        br.cond.sptk DoneMoveFloat;;

MoveTwo:
        mov         f8 = f33
        mov         f9 = f32
        br.cond.sptk DoneMoveFloat;;

MoveThree:
        mov         f8 = f34
        mov         f9 = f33
        mov         f10 = f32
        br.cond.sptk DoneMoveFloat;;

MoveFour:
        mov         f8 = f35
        mov         f9 = f34
        mov         f10 = f33
        mov         f11 = f32
        br.cond.sptk DoneMoveFloat;;

MoveFive:
        mov         f8 = f36
        mov         f9 = f35
        mov         f10 = f34
        mov         f11 = f33
        mov         f12 = f32
        br.cond.sptk DoneMoveFloat;;

MoveSix:
        mov         f8 = f37
        mov         f9 = f36
        mov         f10 = f35
        mov         f11 = f34
        mov         f12 = f33
        mov         f13 = f32
        br.cond.sptk DoneMoveFloat;;

MoveSeven:
        mov         f8 = f38
        mov         f9 = f37
        mov         f10 = f36
        mov         f11 = f35
        mov         f12 = f34
        mov         f13 = f33
        mov         f14 = f32
        br.cond.sptk DoneMoveFloat;;

MoveEight:
        mov         f8 = f39
        mov         f9 = f38
        mov         f10 = f37
        mov         f11 = f36
        mov         f12 = f35
        mov         f13 = f34
        mov         f14 = f33
        mov         f15 = f32


DoneMoveFloat:
        rum         1 << PSR_MFH
        

NoFloat:

        add        sp = -STACK_SCRATCH_AREA, sp             // space for scratch area

        ld8        funcAddr = [CallFuncAddr],PlGlobalPointer-PlEntryPoint
        ;;
        ld8        gp = [CallFuncAddr] 
        mov        bt1 = funcAddr                           // call the function
        br.call.sptk brp = bt1
        ;;

        mov        ar.lc = savedLC             // restore loop count register
        .restore
        mov        sp = savedSP

        NESTED_RETURN
     
        NESTED_EXIT(Invoke)

//
// Define ObjectStublessClientBig routine macro.
// This macro can be used for any number of arguments
//

#define StublessClientProc(Method)                                      \
                                                                        \
        .##global       ObjectStublessClient##Method;                   \
        NESTED_ENTRY(ObjectStublessClient##Method);                     \
        NESTED_SETUP(8, 3, 2, 0);                                       \
/*                                                                      \
 *      Assume we have more than 8 arguments, starting from nineth      \
 *      argument is located STACK_SCRATCH_AREA(sp'),                    \
 *      STACK_SCRATCH_AREA+8(sp') and so on ... sp' is sp at point of   \
 *      call                                                            \
 *                                                                      \
 *      We have to push those 8 arguments into contiguous stack         \
 *      starting at STACK_SCRATCH_AREA(sp). A local frame size of 64    \
 *      bytes is allocated for the 8 arguments, 8 bytes each.           \
 */                                                                     \
        .##fframe 64;                                                   \
        add     sp = -64, sp;                                           \
        ;;                                                              \
                                                                        \
        .##save  ar##.##unat, loc2;                                     \
        mov     loc2 = ar##.##unat;                                     \
        add     r2 = 64+STACK_SCRATCH_AREA-8, sp;                       \
        add     r3 = STACK_SCRATCH_AREA, sp;                            \
        ;;                                                              \
                                                                        \
        .##mem##.##offset 0,0;                                          \
        st8.spill     [r2] = a7, -8;                                    \
        .##mem##.##offset 8,0;                                          \
        st8.spill     [r3] = a0, 8;                                     \
        PROLOGUE_END                                                    \
        ;;                                                              \
                                                                        \
        .##mem##.##offset 0,0;                                          \
        st8.spill     [r2] = a6, -8;                                    \
        .##mem##.##offset 8,0;                                          \
        st8.spill     [r3] = a1, 8;                                     \
        ;;                                                              \
                                                                        \
        .##mem##.##offset 0,0;                                          \
        st8.spill     [r2] = a5, -8;                                    \
        .##mem##.##offset 8,0;                                          \
        st8.spill     [r3] = a2, 8;                                     \
        ;;                                                              \
                                                                        \
        .##mem##.##offset 0,0;                                          \
        st8.spill     [r2] = a4;                                        \
        .##mem##.##offset 8,0;                                          \
        st8.spill     [r3] = a3;                                        \
        ;;                                                              \
                                                                        \
        mov     ar##.##unat = loc2;                                     \
        add     out0 = STACK_SCRATCH_AREA, sp;                          \
        mov     out1 = ##Method;                                        \
                                                                        \
        br##.##call##.##sptk    brp = ObjectStublessClient;             \
        ;;                                                              \
                                                                        \
        .##restore;                                                     \
        add     sp = 64, sp;                                            \
        NESTED_RETURN;                                                  \
        NESTED_EXIT(ObjectStublessClient##Method)       

//++
//
//  Function:   void __stdcall SpillFPRegsForIA64(
//                                 REGISTER_TYPE* pStack, 
//                                 ULONG          FloatMask
//                                 );
//
//  Synopsis:   Given a pointer to the virtual stack and floating-point mask,
//              SpillFPRegsForIA64 copies the contents of the floating-point 
//              registers to the appropriate slots in pStack.
//
//  Arguments:  pStack - Pointer to the virtual stack in memory.
//
//              FloatMask - A mask that indicates argument slots passed as float/double registers
//                          Each nibble indicates if the argument slot contains a float
//                          Float       : D8 F8 D7 F7 D6 F6 D5 F5 D4 F4 D3 F3 D2 F2 D1 F1
//                          bit position: 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
//                          16 bits represents 8 slots
//                          If both the D and F bits are set then the argument slot contains
//                          *two* floating point args.
//
//  Notes:     In the __stdcall calling convention, the callee must pop
//             the parameters.
//
//--
        NESTED_ENTRY(SpillFPRegsForIA64)
        NESTED_SETUP(4,4,8,0)

        savedSP         = loc2                  // savedSP aliased to loc2
        savedLC         = loc3
        pStack          = a0                    // pStack  aliased to first param passed in
        FloatMask       = a1                    // FloatMask  aliased to second param passed in

        mov             savedSP = sp            // save sp
        mov             savedLC = ar.lc         // save lc

        PROLOGUE_END

        ARGPTR          (a0)                    // sign-extend pStack for WIN32

        //----------------------------------------------------------------
        // start of main algorithm
        //----------------------------------------------------------------
        mov             t0 = FloatMask;;        // FloatMask copied to t0
        mov             t1 = pStack             // pStack copied to t1

        popcnt          t4 = t0;;               // count number of bits in FloatMask; i.e. how many
                                                // active slots

        cmp.eq          pt0 = 8, t4             // look at the number of parameters and branch accordingly.
(pt0)   br.cond.sptk    ReverseFP8;;            
        cmp.eq          pt0 = 7, t4             // the fp args are ordered by their arguement order; i.e.
(pt0)   br.cond.sptk    ReverseFP7;;            // fp32 contains the first fp arg, fp32 contains the next
        cmp.eq          pt0 = 6, t4             // fp arg...etc. 
(pt0)   br.cond.sptk    ReverseFP6;;              
        cmp.eq          pt0 = 5, t4             // rotating registers rotate downward. because of this we
(pt0)   br.cond.sptk    ReverseFP5;;            // reverse the order of the fp regs fp8 - fp15 to 
        cmp.eq          pt0 = 4, t4             // fp47 - fp40. (see ReverseFP8 to ReverseFP1)
(pt0)   br.cond.sptk    ReverseFP4;;
        cmp.eq          pt0 = 3, t4             
(pt0)   br.cond.sptk    ReverseFP3;;
        cmp.eq          pt0 = 2, t4
(pt0)   br.cond.sptk    ReverseFP2;;
        cmp.eq          pt0 = 1, t4
(pt0)   br.cond.sptk    ReverseFP1;;


ReverseFP8:                                     // reverse fp reg order
        mov             f40 = f15
ReverseFP7:
        mov             f41 = f14
ReverseFP6:
        mov             f42 = f13
ReverseFP5:
        mov             f43 = f12
ReverseFP4:
        mov             f44 = f11
ReverseFP3:
        mov             f45 = f10
ReverseFP2:
        mov             f46 = f9
ReverseFP1:
        mov             f47 = f8
     

StartSpill:
        mov             ar.lc  = t4             // the maximum loop count is total fp slots used


ProcessNextSlot:
        extr.u          t10 = t0, 0, 2          // extract the two FP slot nibbles into t10
        shr.u           t0  = t0, 2;;           // shift FloatMask, since we've extracted the slot

        cmp.eq          pt0 = 0, t0             // check if FloatMask is zero; if so, we are done.
        cmp.eq          pt1 = 0, t10            // check if slot is 0; i.e. not a float or double
        cmp.eq          pt2 = 1, t10            // check first nibble of extracted slot is float
        cmp.eq          pt3 = 2, t10            // check second nibble of extracted slot is double
        cmp.ne          pt4 = 3, t10;;          // check for dual floats

(pt2)   stfs            [t1] = f47;;            // store float at pStack
(pt3)   stfd            [t1] = f47;;            // store double at pStack
(pt4)   br.cond.sptk    SkipDualFloat2;;

        stfs            [t1] = f47, 4;;         // store dual floats
        stfs            [t1] = f46, -4;;
        br.ctop.sptk    SkipDualFloat2;;        // Force an extra register rotate if dual floats

SkipDualFloat2:        
        add             t1 = 8, t1              // increment address to point to the next slot

(pt0)   br.cond.sptk    Done                    // FloatMask is zero, so we are done
(pt1)   br.cond.sptk    ProcessNextSlot         // a zero slot pays a branch penality; but it does not 
                                                // rotate the fp & pr registers
        br.ctop.sptk    ProcessNextSlot;;       // counted loop no penalty for branch rotate f32&pr16 
        ;;


        //----------------------------------------------------------------
        // done, restore sp and exit
        //----------------------------------------------------------------
Done:
		mov             ar.lc = savedLC         // restore loop count register
        .restore
        mov             sp = savedSP            // restore sp

        NESTED_RETURN
     
        NESTED_EXIT(SpillFPRegsForIA64)


StublessClientProc( 3 )
StublessClientProc( 4 )
StublessClientProc( 5 )
StublessClientProc( 6 )
StublessClientProc( 7 )
StublessClientProc( 8 )
StublessClientProc( 9 )
StublessClientProc( 10 )
StublessClientProc( 11 )
StublessClientProc( 12 )
StublessClientProc( 13 )
StublessClientProc( 14 )
StublessClientProc( 15 )
StublessClientProc( 16 )
StublessClientProc( 17 )
StublessClientProc( 18 )
StublessClientProc( 19 )
StublessClientProc( 20 )
StublessClientProc( 21 )
StublessClientProc( 22 )
StublessClientProc( 23 )
StublessClientProc( 24 )
StublessClientProc( 25 )
StublessClientProc( 26 )
StublessClientProc( 27 )
StublessClientProc( 28 )
StublessClientProc( 29 )
StublessClientProc( 30 )
StublessClientProc( 31 )
StublessClientProc( 32 )
StublessClientProc( 33 )
StublessClientProc( 34 )
StublessClientProc( 35 )
StublessClientProc( 36 )
StublessClientProc( 37 )
StublessClientProc( 38 )
StublessClientProc( 39 )
StublessClientProc( 40 )
StublessClientProc( 41 )
StublessClientProc( 42 )
StublessClientProc( 43 )
StublessClientProc( 44 )
StublessClientProc( 45 )
StublessClientProc( 46 )
StublessClientProc( 47 )
StublessClientProc( 48 )
StublessClientProc( 49 )
StublessClientProc( 50 )
StublessClientProc( 51 )
StublessClientProc( 52 )
StublessClientProc( 53 )
StublessClientProc( 54 )
StublessClientProc( 55 )
StublessClientProc( 56 )
StublessClientProc( 57 )
StublessClientProc( 58 )
StublessClientProc( 59 )
StublessClientProc( 60 )
StublessClientProc( 61 )
StublessClientProc( 62 )
StublessClientProc( 63 )
StublessClientProc( 64 )
StublessClientProc( 65 )
StublessClientProc( 66 )
StublessClientProc( 67 )
StublessClientProc( 68 )
StublessClientProc( 69 )
StublessClientProc( 70 )
StublessClientProc( 71 )
StublessClientProc( 72 )
StublessClientProc( 73 )
StublessClientProc( 74 )
StublessClientProc( 75 )
StublessClientProc( 76 )
StublessClientProc( 77 )
StublessClientProc( 78 )
StublessClientProc( 79 )
StublessClientProc( 80 )
StublessClientProc( 81 )
StublessClientProc( 82 )
StublessClientProc( 83 )
StublessClientProc( 84 )
StublessClientProc( 85 )
StublessClientProc( 86 )
StublessClientProc( 87 )
StublessClientProc( 88 )
StublessClientProc( 89 )
StublessClientProc( 90 )
StublessClientProc( 91 )
StublessClientProc( 92 )
StublessClientProc( 93 )
StublessClientProc( 94 )
StublessClientProc( 95 )
StublessClientProc( 96 )
StublessClientProc( 97 )
StublessClientProc( 98 )
StublessClientProc( 99 )
StublessClientProc( 100 )
StublessClientProc( 101 )
StublessClientProc( 102 )
StublessClientProc( 103 )
StublessClientProc( 104 )
StublessClientProc( 105 )
StublessClientProc( 106 )
StublessClientProc( 107 )
StublessClientProc( 108 )
StublessClientProc( 109 )
StublessClientProc( 110 )
StublessClientProc( 111 )
StublessClientProc( 112 )
StublessClientProc( 113 )
StublessClientProc( 114 )
StublessClientProc( 115 )
StublessClientProc( 116 )
StublessClientProc( 117 )
StublessClientProc( 118 )
StublessClientProc( 119 )
StublessClientProc( 120 )
StublessClientProc( 121 )
StublessClientProc( 122 )
StublessClientProc( 123 )
StublessClientProc( 124 )
StublessClientProc( 125 )
StublessClientProc( 126 )
StublessClientProc( 127 )
StublessClientProc( 128 )
StublessClientProc( 129 )
StublessClientProc( 130 )
StublessClientProc( 131 )
StublessClientProc( 132 )
StublessClientProc( 133 )
StublessClientProc( 134 )
StublessClientProc( 135 )
StublessClientProc( 136 )
StublessClientProc( 137 )
StublessClientProc( 138 )
StublessClientProc( 139 )
StublessClientProc( 140 )
StublessClientProc( 141 )
StublessClientProc( 142 )
StublessClientProc( 143 )
StublessClientProc( 144 )
StublessClientProc( 145 )
StublessClientProc( 146 )
StublessClientProc( 147 )
StublessClientProc( 148 )
StublessClientProc( 149 )
StublessClientProc( 150 )
StublessClientProc( 151 )
StublessClientProc( 152 )
StublessClientProc( 153 )
StublessClientProc( 154 )
StublessClientProc( 155 )
StublessClientProc( 156 )
StublessClientProc( 157 )
StublessClientProc( 158 )
StublessClientProc( 159 )
StublessClientProc( 160 )
StublessClientProc( 161 )
StublessClientProc( 162 )
StublessClientProc( 163 )
StublessClientProc( 164 )
StublessClientProc( 165 )
StublessClientProc( 166 )
StublessClientProc( 167 )
StublessClientProc( 168 )
StublessClientProc( 169 )
StublessClientProc( 170 )
StublessClientProc( 171 )
StublessClientProc( 172 )
StublessClientProc( 173 )
StublessClientProc( 174 )
StublessClientProc( 175 )
StublessClientProc( 176 )
StublessClientProc( 177 )
StublessClientProc( 178 )
StublessClientProc( 179 )
StublessClientProc( 180 )
StublessClientProc( 181 )
StublessClientProc( 182 )
StublessClientProc( 183 )
StublessClientProc( 184 )
StublessClientProc( 185 )
StublessClientProc( 186 )
StublessClientProc( 187 )
StublessClientProc( 188 )
StublessClientProc( 189 )
StublessClientProc( 190 )
StublessClientProc( 191 )
StublessClientProc( 192 )
StublessClientProc( 193 )
StublessClientProc( 194 )
StublessClientProc( 195 )
StublessClientProc( 196 )
StublessClientProc( 197 )
StublessClientProc( 198 )
StublessClientProc( 199 )
StublessClientProc( 200 )
StublessClientProc( 201 )
StublessClientProc( 202 )
StublessClientProc( 203 )
StublessClientProc( 204 )
StublessClientProc( 205 )
StublessClientProc( 206 )
StublessClientProc( 207 )
StublessClientProc( 208 )
StublessClientProc( 209 )
StublessClientProc( 210 )
StublessClientProc( 211 )
StublessClientProc( 212 )
StublessClientProc( 213 )
StublessClientProc( 214 )
StublessClientProc( 215 )
StublessClientProc( 216 )
StublessClientProc( 217 )
StublessClientProc( 218 )
StublessClientProc( 219 )
StublessClientProc( 220 )
StublessClientProc( 221 )
StublessClientProc( 222 )
StublessClientProc( 223 )
StublessClientProc( 224 )
StublessClientProc( 225 )
StublessClientProc( 226 )
StublessClientProc( 227 )
StublessClientProc( 228 )
StublessClientProc( 229 )
StublessClientProc( 230 )
StublessClientProc( 231 )
StublessClientProc( 232 )
StublessClientProc( 233 )
StublessClientProc( 234 )
StublessClientProc( 235 )
StublessClientProc( 236 )
StublessClientProc( 237 )
StublessClientProc( 238 )
StublessClientProc( 239 )
StublessClientProc( 240 )
StublessClientProc( 241 )
StublessClientProc( 242 )
StublessClientProc( 243 )
StublessClientProc( 244 )
StublessClientProc( 245 )
StublessClientProc( 246 )
StublessClientProc( 247 )
StublessClientProc( 248 )
StublessClientProc( 249 )
StublessClientProc( 250 )
StublessClientProc( 251 )
StublessClientProc( 252 )
StublessClientProc( 253 )
StublessClientProc( 254 )
StublessClientProc( 255 )
StublessClientProc( 256 )
StublessClientProc( 257 )
StublessClientProc( 258 )
StublessClientProc( 259 )
StublessClientProc( 260 )
StublessClientProc( 261 )
StublessClientProc( 262 )
StublessClientProc( 263 )
StublessClientProc( 264 )
StublessClientProc( 265 )
StublessClientProc( 266 )
StublessClientProc( 267 )
StublessClientProc( 268 )
StublessClientProc( 269 )
StublessClientProc( 270 )
StublessClientProc( 271 )
StublessClientProc( 272 )
StublessClientProc( 273 )
StublessClientProc( 274 )
StublessClientProc( 275 )
StublessClientProc( 276 )
StublessClientProc( 277 )
StublessClientProc( 278 )
StublessClientProc( 279 )
StublessClientProc( 280 )
StublessClientProc( 281 )
StublessClientProc( 282 )
StublessClientProc( 283 )
StublessClientProc( 284 )
StublessClientProc( 285 )
StublessClientProc( 286 )
StublessClientProc( 287 )
StublessClientProc( 288 )
StublessClientProc( 289 )
StublessClientProc( 290 )
StublessClientProc( 291 )
StublessClientProc( 292 )
StublessClientProc( 293 )
StublessClientProc( 294 )
StublessClientProc( 295 )
StublessClientProc( 296 )
StublessClientProc( 297 )
StublessClientProc( 298 )
StublessClientProc( 299 )
StublessClientProc( 300 )
StublessClientProc( 301 )
StublessClientProc( 302 )
StublessClientProc( 303 )
StublessClientProc( 304 )
StublessClientProc( 305 )
StublessClientProc( 306 )
StublessClientProc( 307 )
StublessClientProc( 308 )
StublessClientProc( 309 )
StublessClientProc( 310 )
StublessClientProc( 311 )
StublessClientProc( 312 )
StublessClientProc( 313 )
StublessClientProc( 314 )
StublessClientProc( 315 )
StublessClientProc( 316 )
StublessClientProc( 317 )
StublessClientProc( 318 )
StublessClientProc( 319 )
StublessClientProc( 320 )
StublessClientProc( 321 )
StublessClientProc( 322 )
StublessClientProc( 323 )
StublessClientProc( 324 )
StublessClientProc( 325 )
StublessClientProc( 326 )
StublessClientProc( 327 )
StublessClientProc( 328 )
StublessClientProc( 329 )
StublessClientProc( 330 )
StublessClientProc( 331 )
StublessClientProc( 332 )
StublessClientProc( 333 )
StublessClientProc( 334 )
StublessClientProc( 335 )
StublessClientProc( 336 )
StublessClientProc( 337 )
StublessClientProc( 338 )
StublessClientProc( 339 )
StublessClientProc( 340 )
StublessClientProc( 341 )
StublessClientProc( 342 )
StublessClientProc( 343 )
StublessClientProc( 344 )
StublessClientProc( 345 )
StublessClientProc( 346 )
StublessClientProc( 347 )
StublessClientProc( 348 )
StublessClientProc( 349 )
StublessClientProc( 350 )
StublessClientProc( 351 )
StublessClientProc( 352 )
StublessClientProc( 353 )
StublessClientProc( 354 )
StublessClientProc( 355 )
StublessClientProc( 356 )
StublessClientProc( 357 )
StublessClientProc( 358 )
StublessClientProc( 359 )
StublessClientProc( 360 )
StublessClientProc( 361 )
StublessClientProc( 362 )
StublessClientProc( 363 )
StublessClientProc( 364 )
StublessClientProc( 365 )
StublessClientProc( 366 )
StublessClientProc( 367 )
StublessClientProc( 368 )
StublessClientProc( 369 )
StublessClientProc( 370 )
StublessClientProc( 371 )
StublessClientProc( 372 )
StublessClientProc( 373 )
StublessClientProc( 374 )
StublessClientProc( 375 )
StublessClientProc( 376 )
StublessClientProc( 377 )
StublessClientProc( 378 )
StublessClientProc( 379 )
StublessClientProc( 380 )
StublessClientProc( 381 )
StublessClientProc( 382 )
StublessClientProc( 383 )
StublessClientProc( 384 )
StublessClientProc( 385 )
StublessClientProc( 386 )
StublessClientProc( 387 )
StublessClientProc( 388 )
StublessClientProc( 389 )
StublessClientProc( 390 )
StublessClientProc( 391 )
StublessClientProc( 392 )
StublessClientProc( 393 )
StublessClientProc( 394 )
StublessClientProc( 395 )
StublessClientProc( 396 )
StublessClientProc( 397 )
StublessClientProc( 398 )
StublessClientProc( 399 )
StublessClientProc( 400 )
StublessClientProc( 401 )
StublessClientProc( 402 )
StublessClientProc( 403 )
StublessClientProc( 404 )
StublessClientProc( 405 )
StublessClientProc( 406 )
StublessClientProc( 407 )
StublessClientProc( 408 )
StublessClientProc( 409 )
StublessClientProc( 410 )
StublessClientProc( 411 )
StublessClientProc( 412 )
StublessClientProc( 413 )
StublessClientProc( 414 )
StublessClientProc( 415 )
StublessClientProc( 416 )
StublessClientProc( 417 )
StublessClientProc( 418 )
StublessClientProc( 419 )
StublessClientProc( 420 )
StublessClientProc( 421 )
StublessClientProc( 422 )
StublessClientProc( 423 )
StublessClientProc( 424 )
StublessClientProc( 425 )
StublessClientProc( 426 )
StublessClientProc( 427 )
StublessClientProc( 428 )
StublessClientProc( 429 )
StublessClientProc( 430 )
StublessClientProc( 431 )
StublessClientProc( 432 )
StublessClientProc( 433 )
StublessClientProc( 434 )
StublessClientProc( 435 )
StublessClientProc( 436 )
StublessClientProc( 437 )
StublessClientProc( 438 )
StublessClientProc( 439 )
StublessClientProc( 440 )
StublessClientProc( 441 )
StublessClientProc( 442 )
StublessClientProc( 443 )
StublessClientProc( 444 )
StublessClientProc( 445 )
StublessClientProc( 446 )
StublessClientProc( 447 )
StublessClientProc( 448 )
StublessClientProc( 449 )
StublessClientProc( 450 )
StublessClientProc( 451 )
StublessClientProc( 452 )
StublessClientProc( 453 )
StublessClientProc( 454 )
StublessClientProc( 455 )
StublessClientProc( 456 )
StublessClientProc( 457 )
StublessClientProc( 458 )
StublessClientProc( 459 )
StublessClientProc( 460 )
StublessClientProc( 461 )
StublessClientProc( 462 )
StublessClientProc( 463 )
StublessClientProc( 464 )
StublessClientProc( 465 )
StublessClientProc( 466 )
StublessClientProc( 467 )
StublessClientProc( 468 )
StublessClientProc( 469 )
StublessClientProc( 470 )
StublessClientProc( 471 )
StublessClientProc( 472 )
StublessClientProc( 473 )
StublessClientProc( 474 )
StublessClientProc( 475 )
StublessClientProc( 476 )
StublessClientProc( 477 )
StublessClientProc( 478 )
StublessClientProc( 479 )
StublessClientProc( 480 )
StublessClientProc( 481 )
StublessClientProc( 482 )
StublessClientProc( 483 )
StublessClientProc( 484 )
StublessClientProc( 485 )
StublessClientProc( 486 )
StublessClientProc( 487 )
StublessClientProc( 488 )
StublessClientProc( 489 )
StublessClientProc( 490 )
StublessClientProc( 491 )
StublessClientProc( 492 )
StublessClientProc( 493 )
StublessClientProc( 494 )
StublessClientProc( 495 )
StublessClientProc( 496 )
StublessClientProc( 497 )
StublessClientProc( 498 )
StublessClientProc( 499 )
StublessClientProc( 500 )
StublessClientProc( 501 )
StublessClientProc( 502 )
StublessClientProc( 503 )
StublessClientProc( 504 )
StublessClientProc( 505 )
StublessClientProc( 506 )
StublessClientProc( 507 )
StublessClientProc( 508 )
StublessClientProc( 509 )
StublessClientProc( 510 )
StublessClientProc( 511 )
StublessClientProc( 512 )
StublessClientProc( 513 )
StublessClientProc( 514 )
StublessClientProc( 515 )
StublessClientProc( 516 )
StublessClientProc( 517 )
StublessClientProc( 518 )
StublessClientProc( 519 )
StublessClientProc( 520 )
StublessClientProc( 521 )
StublessClientProc( 522 )
StublessClientProc( 523 )
StublessClientProc( 524 )
StublessClientProc( 525 )
StublessClientProc( 526 )
StublessClientProc( 527 )
StublessClientProc( 528 )
StublessClientProc( 529 )
StublessClientProc( 530 )
StublessClientProc( 531 )
StublessClientProc( 532 )
StublessClientProc( 533 )
StublessClientProc( 534 )
StublessClientProc( 535 )
StublessClientProc( 536 )
StublessClientProc( 537 )
StublessClientProc( 538 )
StublessClientProc( 539 )
StublessClientProc( 540 )
StublessClientProc( 541 )
StublessClientProc( 542 )
StublessClientProc( 543 )
StublessClientProc( 544 )
StublessClientProc( 545 )
StublessClientProc( 546 )
StublessClientProc( 547 )
StublessClientProc( 548 )
StublessClientProc( 549 )
StublessClientProc( 550 )
StublessClientProc( 551 )
StublessClientProc( 552 )
StublessClientProc( 553 )
StublessClientProc( 554 )
StublessClientProc( 555 )
StublessClientProc( 556 )
StublessClientProc( 557 )
StublessClientProc( 558 )
StublessClientProc( 559 )
StublessClientProc( 560 )
StublessClientProc( 561 )
StublessClientProc( 562 )
StublessClientProc( 563 )
StublessClientProc( 564 )
StublessClientProc( 565 )
StublessClientProc( 566 )
StublessClientProc( 567 )
StublessClientProc( 568 )
StublessClientProc( 569 )
StublessClientProc( 570 )
StublessClientProc( 571 )
StublessClientProc( 572 )
StublessClientProc( 573 )
StublessClientProc( 574 )
StublessClientProc( 575 )
StublessClientProc( 576 )
StublessClientProc( 577 )
StublessClientProc( 578 )
StublessClientProc( 579 )
StublessClientProc( 580 )
StublessClientProc( 581 )
StublessClientProc( 582 )
StublessClientProc( 583 )
StublessClientProc( 584 )
StublessClientProc( 585 )
StublessClientProc( 586 )
StublessClientProc( 587 )
StublessClientProc( 588 )
StublessClientProc( 589 )
StublessClientProc( 590 )
StublessClientProc( 591 )
StublessClientProc( 592 )
StublessClientProc( 593 )
StublessClientProc( 594 )
StublessClientProc( 595 )
StublessClientProc( 596 )
StublessClientProc( 597 )
StublessClientProc( 598 )
StublessClientProc( 599 )
StublessClientProc( 600 )
StublessClientProc( 601 )
StublessClientProc( 602 )
StublessClientProc( 603 )
StublessClientProc( 604 )
StublessClientProc( 605 )
StublessClientProc( 606 )
StublessClientProc( 607 )
StublessClientProc( 608 )
StublessClientProc( 609 )
StublessClientProc( 610 )
StublessClientProc( 611 )
StublessClientProc( 612 )
StublessClientProc( 613 )
StublessClientProc( 614 )
StublessClientProc( 615 )
StublessClientProc( 616 )
StublessClientProc( 617 )
StublessClientProc( 618 )
StublessClientProc( 619 )
StublessClientProc( 620 )
StublessClientProc( 621 )
StublessClientProc( 622 )
StublessClientProc( 623 )
StublessClientProc( 624 )
StublessClientProc( 625 )
StublessClientProc( 626 )
StublessClientProc( 627 )
StublessClientProc( 628 )
StublessClientProc( 629 )
StublessClientProc( 630 )
StublessClientProc( 631 )
StublessClientProc( 632 )
StublessClientProc( 633 )
StublessClientProc( 634 )
StublessClientProc( 635 )
StublessClientProc( 636 )
StublessClientProc( 637 )
StublessClientProc( 638 )
StublessClientProc( 639 )
StublessClientProc( 640 )
StublessClientProc( 641 )
StublessClientProc( 642 )
StublessClientProc( 643 )
StublessClientProc( 644 )
StublessClientProc( 645 )
StublessClientProc( 646 )
StublessClientProc( 647 )
StublessClientProc( 648 )
StublessClientProc( 649 )
StublessClientProc( 650 )
StublessClientProc( 651 )
StublessClientProc( 652 )
StublessClientProc( 653 )
StublessClientProc( 654 )
StublessClientProc( 655 )
StublessClientProc( 656 )
StublessClientProc( 657 )
StublessClientProc( 658 )
StublessClientProc( 659 )
StublessClientProc( 660 )
StublessClientProc( 661 )
StublessClientProc( 662 )
StublessClientProc( 663 )
StublessClientProc( 664 )
StublessClientProc( 665 )
StublessClientProc( 666 )
StublessClientProc( 667 )
StublessClientProc( 668 )
StublessClientProc( 669 )
StublessClientProc( 670 )
StublessClientProc( 671 )
StublessClientProc( 672 )
StublessClientProc( 673 )
StublessClientProc( 674 )
StublessClientProc( 675 )
StublessClientProc( 676 )
StublessClientProc( 677 )
StublessClientProc( 678 )
StublessClientProc( 679 )
StublessClientProc( 680 )
StublessClientProc( 681 )
StublessClientProc( 682 )
StublessClientProc( 683 )
StublessClientProc( 684 )
StublessClientProc( 685 )
StublessClientProc( 686 )
StublessClientProc( 687 )
StublessClientProc( 688 )
StublessClientProc( 689 )
StublessClientProc( 690 )
StublessClientProc( 691 )
StublessClientProc( 692 )
StublessClientProc( 693 )
StublessClientProc( 694 )
StublessClientProc( 695 )
StublessClientProc( 696 )
StublessClientProc( 697 )
StublessClientProc( 698 )
StublessClientProc( 699 )
StublessClientProc( 700 )
StublessClientProc( 701 )
StublessClientProc( 702 )
StublessClientProc( 703 )
StublessClientProc( 704 )
StublessClientProc( 705 )
StublessClientProc( 706 )
StublessClientProc( 707 )
StublessClientProc( 708 )
StublessClientProc( 709 )
StublessClientProc( 710 )
StublessClientProc( 711 )
StublessClientProc( 712 )
StublessClientProc( 713 )
StublessClientProc( 714 )
StublessClientProc( 715 )
StublessClientProc( 716 )
StublessClientProc( 717 )
StublessClientProc( 718 )
StublessClientProc( 719 )
StublessClientProc( 720 )
StublessClientProc( 721 )
StublessClientProc( 722 )
StublessClientProc( 723 )
StublessClientProc( 724 )
StublessClientProc( 725 )
StublessClientProc( 726 )
StublessClientProc( 727 )
StublessClientProc( 728 )
StublessClientProc( 729 )
StublessClientProc( 730 )
StublessClientProc( 731 )
StublessClientProc( 732 )
StublessClientProc( 733 )
StublessClientProc( 734 )
StublessClientProc( 735 )
StublessClientProc( 736 )
StublessClientProc( 737 )
StublessClientProc( 738 )
StublessClientProc( 739 )
StublessClientProc( 740 )
StublessClientProc( 741 )
StublessClientProc( 742 )
StublessClientProc( 743 )
StublessClientProc( 744 )
StublessClientProc( 745 )
StublessClientProc( 746 )
StublessClientProc( 747 )
StublessClientProc( 748 )
StublessClientProc( 749 )
StublessClientProc( 750 )
StublessClientProc( 751 )
StublessClientProc( 752 )
StublessClientProc( 753 )
StublessClientProc( 754 )
StublessClientProc( 755 )
StublessClientProc( 756 )
StublessClientProc( 757 )
StublessClientProc( 758 )
StublessClientProc( 759 )
StublessClientProc( 760 )
StublessClientProc( 761 )
StublessClientProc( 762 )
StublessClientProc( 763 )
StublessClientProc( 764 )
StublessClientProc( 765 )
StublessClientProc( 766 )
StublessClientProc( 767 )
StublessClientProc( 768 )
StublessClientProc( 769 )
StublessClientProc( 770 )
StublessClientProc( 771 )
StublessClientProc( 772 )
StublessClientProc( 773 )
StublessClientProc( 774 )
StublessClientProc( 775 )
StublessClientProc( 776 )
StublessClientProc( 777 )
StublessClientProc( 778 )
StublessClientProc( 779 )
StublessClientProc( 780 )
StublessClientProc( 781 )
StublessClientProc( 782 )
StublessClientProc( 783 )
StublessClientProc( 784 )
StublessClientProc( 785 )
StublessClientProc( 786 )
StublessClientProc( 787 )
StublessClientProc( 788 )
StublessClientProc( 789 )
StublessClientProc( 790 )
StublessClientProc( 791 )
StublessClientProc( 792 )
StublessClientProc( 793 )
StublessClientProc( 794 )
StublessClientProc( 795 )
StublessClientProc( 796 )
StublessClientProc( 797 )
StublessClientProc( 798 )
StublessClientProc( 799 )
StublessClientProc( 800 )
StublessClientProc( 801 )
StublessClientProc( 802 )
StublessClientProc( 803 )
StublessClientProc( 804 )
StublessClientProc( 805 )
StublessClientProc( 806 )
StublessClientProc( 807 )
StublessClientProc( 808 )
StublessClientProc( 809 )
StublessClientProc( 810 )
StublessClientProc( 811 )
StublessClientProc( 812 )
StublessClientProc( 813 )
StublessClientProc( 814 )
StublessClientProc( 815 )
StublessClientProc( 816 )
StublessClientProc( 817 )
StublessClientProc( 818 )
StublessClientProc( 819 )
StublessClientProc( 820 )
StublessClientProc( 821 )
StublessClientProc( 822 )
StublessClientProc( 823 )
StublessClientProc( 824 )
StublessClientProc( 825 )
StublessClientProc( 826 )
StublessClientProc( 827 )
StublessClientProc( 828 )
StublessClientProc( 829 )
StublessClientProc( 830 )
StublessClientProc( 831 )
StublessClientProc( 832 )
StublessClientProc( 833 )
StublessClientProc( 834 )
StublessClientProc( 835 )
StublessClientProc( 836 )
StublessClientProc( 837 )
StublessClientProc( 838 )
StublessClientProc( 839 )
StublessClientProc( 840 )
StublessClientProc( 841 )
StublessClientProc( 842 )
StublessClientProc( 843 )
StublessClientProc( 844 )
StublessClientProc( 845 )
StublessClientProc( 846 )
StublessClientProc( 847 )
StublessClientProc( 848 )
StublessClientProc( 849 )
StublessClientProc( 850 )
StublessClientProc( 851 )
StublessClientProc( 852 )
StublessClientProc( 853 )
StublessClientProc( 854 )
StublessClientProc( 855 )
StublessClientProc( 856 )
StublessClientProc( 857 )
StublessClientProc( 858 )
StublessClientProc( 859 )
StublessClientProc( 860 )
StublessClientProc( 861 )
StublessClientProc( 862 )
StublessClientProc( 863 )
StublessClientProc( 864 )
StublessClientProc( 865 )
StublessClientProc( 866 )
StublessClientProc( 867 )
StublessClientProc( 868 )
StublessClientProc( 869 )
StublessClientProc( 870 )
StublessClientProc( 871 )
StublessClientProc( 872 )
StublessClientProc( 873 )
StublessClientProc( 874 )
StublessClientProc( 875 )
StublessClientProc( 876 )
StublessClientProc( 877 )
StublessClientProc( 878 )
StublessClientProc( 879 )
StublessClientProc( 880 )
StublessClientProc( 881 )
StublessClientProc( 882 )
StublessClientProc( 883 )
StublessClientProc( 884 )
StublessClientProc( 885 )
StublessClientProc( 886 )
StublessClientProc( 887 )
StublessClientProc( 888 )
StublessClientProc( 889 )
StublessClientProc( 890 )
StublessClientProc( 891 )
StublessClientProc( 892 )
StublessClientProc( 893 )
StublessClientProc( 894 )
StublessClientProc( 895 )
StublessClientProc( 896 )
StublessClientProc( 897 )
StublessClientProc( 898 )
StublessClientProc( 899 )
StublessClientProc( 900 )
StublessClientProc( 901 )
StublessClientProc( 902 )
StublessClientProc( 903 )
StublessClientProc( 904 )
StublessClientProc( 905 )
StublessClientProc( 906 )
StublessClientProc( 907 )
StublessClientProc( 908 )
StublessClientProc( 909 )
StublessClientProc( 910 )
StublessClientProc( 911 )
StublessClientProc( 912 )
StublessClientProc( 913 )
StublessClientProc( 914 )
StublessClientProc( 915 )
StublessClientProc( 916 )
StublessClientProc( 917 )
StublessClientProc( 918 )
StublessClientProc( 919 )
StublessClientProc( 920 )
StublessClientProc( 921 )
StublessClientProc( 922 )
StublessClientProc( 923 )
StublessClientProc( 924 )
StublessClientProc( 925 )
StublessClientProc( 926 )
StublessClientProc( 927 )
StublessClientProc( 928 )
StublessClientProc( 929 )
StublessClientProc( 930 )
StublessClientProc( 931 )
StublessClientProc( 932 )
StublessClientProc( 933 )
StublessClientProc( 934 )
StublessClientProc( 935 )
StublessClientProc( 936 )
StublessClientProc( 937 )
StublessClientProc( 938 )
StublessClientProc( 939 )
StublessClientProc( 940 )
StublessClientProc( 941 )
StublessClientProc( 942 )
StublessClientProc( 943 )
StublessClientProc( 944 )
StublessClientProc( 945 )
StublessClientProc( 946 )
StublessClientProc( 947 )
StublessClientProc( 948 )
StublessClientProc( 949 )
StublessClientProc( 950 )
StublessClientProc( 951 )
StublessClientProc( 952 )
StublessClientProc( 953 )
StublessClientProc( 954 )
StublessClientProc( 955 )
StublessClientProc( 956 )
StublessClientProc( 957 )
StublessClientProc( 958 )
StublessClientProc( 959 )
StublessClientProc( 960 )
StublessClientProc( 961 )
StublessClientProc( 962 )
StublessClientProc( 963 )
StublessClientProc( 964 )
StublessClientProc( 965 )
StublessClientProc( 966 )
StublessClientProc( 967 )
StublessClientProc( 968 )
StublessClientProc( 969 )
StublessClientProc( 970 )
StublessClientProc( 971 )
StublessClientProc( 972 )
StublessClientProc( 973 )
StublessClientProc( 974 )
StublessClientProc( 975 )
StublessClientProc( 976 )
StublessClientProc( 977 )
StublessClientProc( 978 )
StublessClientProc( 979 )
StublessClientProc( 980 )
StublessClientProc( 981 )
StublessClientProc( 982 )
StublessClientProc( 983 )
StublessClientProc( 984 )
StublessClientProc( 985 )
StublessClientProc( 986 )
StublessClientProc( 987 )
StublessClientProc( 988 )
StublessClientProc( 989 )
StublessClientProc( 990 )
StublessClientProc( 991 )
StublessClientProc( 992 )
StublessClientProc( 993 )
StublessClientProc( 994 )
StublessClientProc( 995 )
StublessClientProc( 996 )
StublessClientProc( 997 )
StublessClientProc( 998 )
StublessClientProc( 999 )
StublessClientProc( 1000 )
StublessClientProc( 1001 )
StublessClientProc( 1002 )
StublessClientProc( 1003 )
StublessClientProc( 1004 )
StublessClientProc( 1005 )
StublessClientProc( 1006 )
StublessClientProc( 1007 )
StublessClientProc( 1008 )
StublessClientProc( 1009 )
StublessClientProc( 1010 )
StublessClientProc( 1011 )
StublessClientProc( 1012 )
StublessClientProc( 1013 )
StublessClientProc( 1014 )
StublessClientProc( 1015 )
StublessClientProc( 1016 )
StublessClientProc( 1017 )
StublessClientProc( 1018 )
StublessClientProc( 1019 )
StublessClientProc( 1020 )
StublessClientProc( 1021 )
StublessClientProc( 1022 )
StublessClientProc( 1023 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\async.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name :

    async.c

Abstract :

    This file contains the ndr async implementation.

Author :

    Ryszard K. Kott     (ryszardk)    Nov 1996

Revision History :

---------------------------------------------------------------------*/

#include "precomp.hxx"

#define USE_STUBLESS_PROXY

#define CINTERFACE

#include "ndrole.h"
#include "rpcproxy.h"
#include "interp2.h"
#include "asyndr64.h"
#include <stdarg.h>

#pragma code_seg(".ndr64")

#ifdef _PPC_
#error PPC code has been removed
#endif


void RPC_ENTRY
Ndr64AsyncServerWorker(
    PRPC_MESSAGE            pRpcMsg,
    ulong                   Index );


CLIENT_CALL_RETURN  RPC_VAR_ENTRY
Ndr64AsyncClientCall(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    ulong                       nProcNum,
    void                       *pReturnValue,
    ...
    )
/*
    This entry is used for raw rpc only.
    No support for OLE [async] attribute anymore.
*/
{
    va_list             ArgList;
    unsigned char  *    StartofStack;
    CLIENT_CALL_RETURN  Ret;
    //
    // Get address of argument to this function following pFormat. This
    // is the address of the address of the first argument of the function
    // calling this function.
    // Then get the address of the stack where the parameters are.
    //

    RPC_ASYNC_HANDLE            AsyncHandle;
    PNDR_ASYNC_MESSAGE          pAsyncMsg;

    RPC_MESSAGE *               pRpcMsg;
    MIDL_STUB_MESSAGE *         pStubMsg;
    ulong                       ProcNum;

    uchar *                     pArg;
    ushort                      StackSize;
    PPARAM_DESCRIPTION          Params;
    long                        n;

    RPC_STATUS                  Status;
    NDR_PROC_CONTEXT            ProcContext, * pContext;
    PMIDL_STUB_DESC             pStubDesc;
    

    Ret.Simple = NULL;
    
    if ( NULL == pReturnValue )
        pReturnValue = &Ret;

    INIT_ARG( ArgList, pReturnValue );
    GET_FIRST_IN_ARG(ArgList);
    StartofStack = (uchar *) GET_STACK_START(ArgList);


    RPC_ASYNC_HANDLE * pHandleArg;

    // async message needs to be allocated on heap to be passed between calls.
    pAsyncMsg = (NDR_ASYNC_MESSAGE*) I_RpcBCacheAllocate( sizeof( NDR_ASYNC_MESSAGE) );
    if ( ! pAsyncMsg )
        Status = RPC_S_OUT_OF_MEMORY;
    else
        {

        memset( pAsyncMsg, 0, sizeof( NDR_ASYNC_MESSAGE ) );
        Ndr64ClientInitializeContext( NdrpGetSyntaxType( pProxyInfo->pTransferSyntax),
                                      pProxyInfo,
                                      nProcNum,
                                      &pAsyncMsg->ProcContext,
                                      StartofStack );

        Status = NdrpInitializeAsyncMsg( StartofStack,
                                         pAsyncMsg );
        }

    pContext = & pAsyncMsg->ProcContext;
    // We need to cleanup and return if something wrong in the async message
    if ( Status )
        {
        MIDL_STUB_MESSAGE StubMsgTemp;
        
        StubMsgTemp.StubDesc = pProxyInfo->pStubDesc;
        StubMsgTemp.StackTop = StartofStack;
        StubMsgTemp.pContext = &ProcContext;
        (pContext->pfnExceptionHandling)(&StubMsgTemp,
                                             nProcNum,
                                             ( RPC_STATUS )Ret.Simple,
                                             &Ret );
        return Ret;                                    
        }

    // proc context 
    // We need to switch to our copy of the stack everywhere, including pStubMsg.

    StartofStack = pAsyncMsg->ProcContext.StartofStack;

    // We abstract the level of indirection here.
    AsyncHandle = pAsyncMsg->AsyncHandle;

    pRpcMsg   = & pAsyncMsg->RpcMsg;
    pStubMsg  = & pAsyncMsg->StubMsg;


    // Wrap everything in a try-finally pair. The finally clause does the
    // required freeing of resources (RpcBuffer and Full ptr package).
    //
    RpcTryFinally
        {
        // Use a nested try-except pair to support [comm_status][fault_status].
        //
        RpcTryExcept
            {
            BOOL fRaiseExcFlag;

            pContext->RpcFlags |= RPC_BUFFER_ASYNC;

            Ndr64pClientSetupTransferSyntax( NULL, // pThis
                           pRpcMsg,
                           pStubMsg,
                           pProxyInfo,
                           pContext,
                           nProcNum );

            
            pStubMsg->pAsyncMsg = pAsyncMsg;
            pStubMsg->pContext       = pContext;

            (* pAsyncMsg->ProcContext.pfnInit) ( pStubMsg,
                                                 pReturnValue );

            ( * pAsyncMsg->ProcContext.pfnSizing) ( pStubMsg,
                                         TRUE );    // isclient
                                                          

            //
            // Do the GetBuffer.
            //

            pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

            Ndr64GetBuffer( pStubMsg,
                              pStubMsg->BufferLength );

            NDR_ASSERT( pStubMsg->fBufferValid, "Invalid buffer" );

            // Let runtime associate async handle with the call.

            NdrpRegisterAsyncHandle( pStubMsg, AsyncHandle );

            pAsyncMsg->StubPhase = NDR_ASYNC_SET_PHASE;

            //
            // ----------------------------------------------------------
            // Marshall Pass.
            // ----------------------------------------------------------
            //

            (* pAsyncMsg->ProcContext.pfnMarshal) (pStubMsg,
                    FALSE );    

            //
            // Make the RPC call.
            //

            pAsyncMsg->StubPhase = NDR_ASYNC_CALL_PHASE;

            NdrAsyncSend( pStubMsg,
                           pContext->HasPipe && pContext->pPipeDesc->InPipes );

            pAsyncMsg->Flags.ValidCallPending = 1;
            }
        RpcExcept( pAsyncMsg->ProcContext.ExceptionFlag )
            {
            RPC_STATUS ExceptionCode = RpcExceptionCode();

            // Actually dismantle the call.
            // This is a request call and there is nothing left at the runtime.

            pAsyncMsg->StubPhase = NDR_ASYNC_ERROR_PHASE;

            (* pAsyncMsg->ProcContext.pfnExceptionHandling) ( pStubMsg,
                                             nProcNum,
                                             ExceptionCode,
                                             &Ret );
            }
        RpcEndExcept
        }
    RpcFinally
        {
        if ( pAsyncMsg->Flags.ValidCallPending )
            {
            if ( pContext->HasPipe )
                {
                NdrMarkNextActivePipe( pContext->pPipeDesc );
                pContext->pPipeDesc->Flags.NoBufferCallPending = 1;
                }
            }
        else
            {
            // Cleanup everything but the user's handle.

            NdrpFreeAsyncMsg( pAsyncMsg );

            AsyncHandle->StubInfo = 0;
            }

        InterlockedDecrement( & AsyncHandle->Lock );
        }
    RpcEndFinally

    return Ret;
}


RPC_STATUS
Ndr64pCompleteAsyncClientCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    PNDR_ASYNC_MESSAGE          pAsyncMsg,
    void *                      pReturnValue
    )
{
    RPC_MESSAGE *               pRpcMsg   = & pAsyncMsg->RpcMsg;
    MIDL_STUB_MESSAGE *         pStubMsg  = & pAsyncMsg->StubMsg;
    NDR_PROC_CONTEXT    *       pContext  = & pAsyncMsg->ProcContext;

    PMIDL_STUB_DESC             pStubDescriptor  = pStubMsg->StubDesc;

    CLIENT_CALL_RETURN          RetVal           ;

    uchar *                     pArg;

    long                        n;
    NDR_ASYNC_CALL_FLAGS        CallFlags = pAsyncMsg->Flags;

    RetVal.Simple = 0;
    
    RpcTryFinally
        {
        // Use a nested try-except pair to support [comm_status][fault_status].
        //
        RpcTryExcept
            {

            if ( ! CallFlags.ValidCallPending )
                RpcRaiseException( RPC_S_INVALID_ASYNC_HANDLE );

            CallFlags.ValidCallPending = 0;

            // Non-pipe case or after pipe args case.

            if ( pContext->HasPipe )
                NdrIsAppDoneWithPipes( pContext->pPipeDesc );

            NdrLastAsyncReceive( pStubMsg );

            //
            // ----------------------------------------------------------
            // Unmarshall Pass.
            // ----------------------------------------------------------
            //
            (*pAsyncMsg->ProcContext.pfnUnMarshal)( pStubMsg,
                                  (CLIENT_CALL_RETURN *) pReturnValue );
            



            }
        RpcExcept( pAsyncMsg->ProcContext.ExceptionFlag )
            {
            RPC_STATUS ExceptionCode = RpcExceptionCode();

            CallFlags.ValidCallPending = ExceptionCode == RPC_S_ASYNC_CALL_PENDING;

            (* pAsyncMsg->ProcContext.pfnExceptionHandling) ( pStubMsg,
                                             pRpcMsg->ProcNum,
                                             ExceptionCode,
                                             &RetVal );
            }
        RpcEndExcept

        }
    RpcFinally
        {
        // There is only one way a valid call may be pending at this stage:
        // that is the receive call returned with RPC_S_CALL_PENDING.

        if ( ! CallFlags.ValidCallPending )
            {
            // Cleanup everything. However, don't free user's handle.

            NdrpFreeAsyncMsg( pAsyncMsg );

            AsyncHandle->StubInfo = 0;
            }

        InterlockedDecrement( & AsyncHandle->Lock );
        }
    RpcEndFinally

    return (RPC_STATUS)RetVal.Simple;
}

RPCRTAPI
void
RPC_ENTRY
Ndr64AsyncServerCall64(
    PRPC_MESSAGE    pRpcMsg )
{
    // When compiled with -protocol ndr64, 
    // NDR64 is the 1st (and only one) in MIDL_SYNTAX_INFO array.
    Ndr64AsyncServerWorker(
                     pRpcMsg,
                     0 );   // Index 0
}

RPCRTAPI
void
RPC_ENTRY
Ndr64AsyncServerCallAll(
    PRPC_MESSAGE    pRpcMsg )
{   
    // When compiles with -protocol all, 
    // NDR64 is the 2nd in MIDL_SYNTAX_INFO array
    Ndr64AsyncServerWorker(
                     pRpcMsg,
                     1 );  // Index 1
}                     


void RPC_ENTRY
Ndr64AsyncServerWorker(
    PRPC_MESSAGE            pRpcMsg,
    ulong                   SyntaxIndex )
/*++
Routine Description :

    The server side entry point for regular asynchronous RPC procs.

Arguments :

    pRpcMsg         - The RPC message.

Return :

    None.
--*/
{
    ulong dwStubPhase = STUB_UNMARSHAL;
    PRPC_SERVER_INTERFACE   pServerIfInfo;
    PMIDL_SERVER_INFO       pServerInfo;
    const SERVER_ROUTINE  * DispatchTable;
    MIDL_SYNTAX_INFO *      pSyntaxInfo;
    RPC_ASYNC_HANDLE        AsyncHandle = 0;
    PNDR_ASYNC_MESSAGE      pAsyncMsg;

    ushort                  ProcNum;
    
    PMIDL_STUB_MESSAGE      pStubMsg;

    uchar *                 pArgBuffer;
    uchar *                 pArg;
    uchar **                ppArg;

    NDR64_PROC_FORMAT *     pHeader;
    NDR64_PARAM_FORMAT  *   Params;
    long                    NumberParams;
    NDR64_PROC_FLAGS *      pNdr64Flags;


    ushort                  ClientBufferSize;
    BOOL                    HasExplicitHandle;
    long                    n;

    // This context is just for setting up the call. embedded one in asyncmsg is the
    // one to be used during the life of this async call.
    NDR_PROC_CONTEXT        *pContext;
    RPC_STATUS              Status = RPC_S_OK;
    NDR64_PARAM_FLAGS   *       pParamFlags;
    NDR64_BIND_AND_NOTIFY_EXTENSION * pHeaderExts = NULL;

    pServerIfInfo = (PRPC_SERVER_INTERFACE)pRpcMsg->RpcInterfaceInformation;
    pServerInfo = (PMIDL_SERVER_INFO)pServerIfInfo->InterpreterInfo;
    DispatchTable = pServerInfo->DispatchTable;

    pSyntaxInfo = &pServerInfo->pSyntaxInfo[SyntaxIndex];
    NDR_ASSERT( XFER_SYNTAX_NDR64 == NdrpGetSyntaxType(&pSyntaxInfo->TransferSyntax),
                " invalid transfer syntax" );

    //
    // In the case of a context handle, the server side manager function has
    // to be called with NDRSContextValue(ctxthandle). But then we may need to
    // marshall the handle, so NDRSContextValue(ctxthandle) is put in the
    // argument buffer and the handle itself is stored in the following array.
    // When marshalling a context handle, we marshall from this array.
    //
    // The handle table is part of the async handle.

    ProcNum = (ushort) pRpcMsg->ProcNum;

    NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned at server" );

    AsyncHandle = 0;
    pAsyncMsg = (NDR_ASYNC_MESSAGE*) I_RpcBCacheAllocate( sizeof( NDR_ASYNC_MESSAGE) );
    if ( ! pAsyncMsg )
        Status = RPC_S_OUT_OF_MEMORY;
    else
        {
        memset( pAsyncMsg, 0, sizeof( NDR_ASYNC_MESSAGE ) );
        
        NdrServerSetupNDR64TransferSyntax(
                                         ProcNum,
                                         pSyntaxInfo,
                                         &pAsyncMsg->ProcContext );
                                     
        Status = NdrpInitializeAsyncMsg( 0,                 // StartofStack, server
                                         pAsyncMsg
                                        );
        }
        
    if ( Status )
        RpcRaiseException( Status );

    pContext = &pAsyncMsg->ProcContext;
    
    PFORMAT_STRING pFormat = pContext->pProcFormat;
    
    pAsyncMsg->StubPhase = STUB_UNMARSHAL;

    pStubMsg = & pAsyncMsg->StubMsg; 
 
    // same in ndr20
    pStubMsg->RpcMsg = pRpcMsg;

    // The arg buffer is zeroed out already.
    pArgBuffer = pContext->StartofStack;

    pHeader = (NDR64_PROC_FORMAT *) pFormat;
    pNdr64Flags = (NDR64_PROC_FLAGS *) &pHeader->Flags;
    HasExplicitHandle = !NDR64MAPHANDLETYPE( NDR64GETHANDLETYPE ( pNdr64Flags ) );

    if ( pNdr64Flags->HasOtherExtensions )
        pHeaderExts = (NDR64_BIND_AND_NOTIFY_EXTENSION *) (pFormat + sizeof( NDR64_PROC_FORMAT ) );


    if ( HasExplicitHandle )
    {
        NDR_ASSERT( pHeaderExts, "NULL extension header" );
        //
        // For a handle_t parameter we must pass the handle field of
        // the RPC message to the server manager.
        //
        if ( pHeaderExts->Binding.HandleType == FC64_BIND_PRIMITIVE )
        {
            pArg = pArgBuffer + pHeaderExts->Binding.StackOffset;

            if ( NDR64_IS_HANDLE_PTR( pHeaderExts->Binding.Flags ) )
                pArg = *((uchar **)pArg);

            *((handle_t *)pArg) = pRpcMsg->Handle;
        }

    }

    //
    // Get new interpreter info.
    //
    NumberParams = pHeader->NumberOfParams;

    Params = (NDR64_PARAM_FORMAT *)( (uchar *) pFormat + sizeof( NDR64_PROC_FORMAT ) + pHeader->ExtensionSize );


    //
    // Wrap the unmarshalling and the invoke call in the try block of
    // a try-finally. Put the free phase in the associated finally block.
    //
    BOOL        fManagerCodeInvoked = FALSE;
    BOOL        fErrorInInvoke = FALSE;
    RPC_STATUS  ExceptionCode = 0;

    // We abstract the level of indirection here.

    AsyncHandle = pAsyncMsg->AsyncHandle;

    RpcTryFinally
    {
        RpcTryExcept
        {
        // Put the async handle on stack.

        ((void **)pArgBuffer)[0] = AsyncHandle;  

        //
        // Initialize the Stub message.
        // Note that for pipes we read non-pipe data synchronously,
        // and so the init routine doesn't need to know about async.
        //
        if ( ! pNdr64Flags->UsesPipes )
           {
            Ndr64ServerInitialize( pRpcMsg,
                                    pStubMsg,
                                    pServerInfo->pStubDesc );
           }
        else
            Ndr64ServerInitializePartial( pRpcMsg,
                                        pStubMsg,
                                        pServerInfo->pStubDesc,
                                        pHeader->ConstantClientBufferSize );

        // We need to set up this flag because the runtime does not know whether
        //   it dispatched a sync or async call to us. same as ndr20

        pRpcMsg->RpcFlags         |= RPC_BUFFER_ASYNC;
        pStubMsg->pAsyncMsg       = pAsyncMsg;
        pStubMsg->RpcMsg = pRpcMsg;
        pStubMsg->pContext       = &pAsyncMsg->ProcContext;

         //
        // Set up for context handle management.
        //
        pStubMsg->SavedContextHandles = & pAsyncMsg->CtxtHndl[0];
        
       // Raise exceptions after initializing the stub.

        if ( pNdr64Flags->UsesFullPtrPackage  )
            pStubMsg->FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );

        if ( pNdr64Flags->ServerMustSize & pNdr64Flags->UsesPipes )
            RpcRaiseException( RPC_X_WRONG_PIPE_VERSION );

        //
        // Set StackTop AFTER the initialize call, since it zeros the field
        // out.
        //
        pStubMsg->pCorrMemory = pStubMsg->StackTop; 

        if ( pNdr64Flags->UsesPipes )
            NdrpPipesInitialize64( pStubMsg,
                                   &pContext->AllocateContext,
                                   (PFORMAT_STRING) Params,
                                   (char*)pArgBuffer,
                                   NumberParams );

        //
        // We must make this check AFTER the call to ServerInitialize,
        // since that routine puts the stub descriptor alloc/dealloc routines
        // into the stub message.
        //
        if ( pNdr64Flags->UsesRpcSmPackage )
            NdrRpcSsEnableAllocate( pStubMsg );

        // Let runtime associate async handle with the call.

        NdrpRegisterAsyncHandle( pStubMsg, AsyncHandle );

        pAsyncMsg->StubPhase = NDR_ASYNC_SET_PHASE;
            
            // --------------------------------
            // Unmarshall all of our parameters.
            // --------------------------------

        NDR_ASSERT( pContext->StartofStack == pArgBuffer, "startofstack is not set" );
        Ndr64pServerUnMarshal( pStubMsg  );


        if ( pRpcMsg->BufferLength  <
             (uint)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer) )
            {
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
            }                                               

            }
        RpcExcept( NdrServerUnmarshallExceptionFlag(GetExceptionInformation()) )
            {
            ExceptionCode = RpcExceptionCode();

            if( RPC_BAD_STUB_DATA_EXCEPTION_FILTER )
                {
                ExceptionCode = RPC_X_BAD_STUB_DATA;
                }

            NdrpFreeMemoryList( pStubMsg );
            pAsyncMsg->Flags.BadStubData = 1;
            pAsyncMsg->ErrorCode = ExceptionCode;
            RpcRaiseException( ExceptionCode );
            }
        RpcEndExcept

        // Two separate blocks because the filters are different.
        // We need to catch exception in the manager code separately
        // as the model implies that there will be no other call from
        // the server app to clean up.

        RpcTryExcept
            {
            //
            // Do [out] initialization before the invoke.
            //
            Ndr64pServerOutInit( pStubMsg );


            //
            // Unblock the first pipe; this needs to be after unmarshalling
            // because the buffer may need to be changed to the secondary one.
            // In the out only pipes case this happens immediately.
            //
            if ( pNdr64Flags->UsesPipes )
                NdrMarkNextActivePipe( pContext->pPipeDesc );

            pAsyncMsg->StubPhase = STUB_CALL_SERVER;

            //
            // Check for a thunk.  Compiler does all the setup for us.
            //
            if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ProcNum] )
                {
                pAsyncMsg->Flags.ValidCallPending = 1;
                InterlockedDecrement( & AsyncHandle->Lock );

                fManagerCodeInvoked = TRUE;
                fErrorInInvoke = TRUE;
                pServerInfo->ThunkTable[ProcNum]( pStubMsg );
                }
            else
                {
                //
                // Note that this ArgNum is not the number of arguments declared
                // in the function we called, but really the number of
                // REGISTER_TYPEs occupied by the arguments to a function.
                //
                long                ArgNum;
                MANAGER_FUNCTION    pFunc;
                REGISTER_TYPE       returnValue;

                if ( pRpcMsg->ManagerEpv )
                    pFunc = ((MANAGER_FUNCTION *)pRpcMsg->ManagerEpv)[ProcNum];
                else
                    pFunc = (MANAGER_FUNCTION) DispatchTable[ProcNum];

                ArgNum = (long) pContext->StackSize / sizeof(REGISTER_TYPE);

                //
                // The StackSize includes the size of the return. If we want
                // just the number of REGISTER_TYPES, then ArgNum must be reduced
                // by 1 when there is a return value AND the current ArgNum count
                // is greater than 0.
                //
                if ( ArgNum &&  pNdr64Flags->HasReturn )
                    ArgNum--;

                // Being here means that we can expect results. Note that the user
                // can call RpcCompleteCall from inside of the manager code.

                pAsyncMsg->Flags.ValidCallPending = 1;

                // Unlock the handle - the app is allowed to call RpCAsyncComplete
                //  or RpcAsyncAbort from the manager code.

                InterlockedDecrement( & AsyncHandle->Lock );

                fManagerCodeInvoked = TRUE;
                fErrorInInvoke = TRUE;

                returnValue = Invoke( pFunc,
                                      (REGISTER_TYPE *)pArgBuffer,
                            #if defined(_IA64_)
                                      pHeader->FloatDoubleMask,
                            #endif
                                      ArgNum);

                // We are discarding the return value as it is not the real one.
                // The real return value is passed in the complete call.
                }

            fErrorInInvoke = FALSE;
            }
        RpcExcept( 1 )
            {
            ExceptionCode = RpcExceptionCode();

            if ( ExceptionCode == 0 )
                ExceptionCode = ERROR_INVALID_PARAMETER;

            // We may not have the async message around anymore.

            RpcRaiseException( ExceptionCode );
            }
        RpcEndExcept

        }
    RpcFinally
        {
        if ( fManagerCodeInvoked  &&  !fErrorInInvoke )
            {
            // Success. Just skip everything if the manager code was invoked
            // and returned successfully.
            // Note that manager code could have called Complete or Abort by now
            // and so the async handle may not be valid anymore.
            }
        else
            {
            // See if we can clean up;

            Status = RPC_S_OK;
            if ( fErrorInInvoke )
                {
                // After an exception in invoking, let's see if we can get a hold
                // of the handle. If so, we will be able to clean up.
                // If not, there may be a leak there that we can do nothing about.
                // The rule is: after an exception the app cannot call Abort or
                // Complete. So, we need to force complete if we can.

                Status = NdrValidateBothAndLockAsyncHandle( AsyncHandle );
                }

            if ( Status == RPC_S_OK )
                {
                // Something went wrong but we are able to do the cleanup.

                // Cleanup parameters and async message/handle.
                // propagate the exception.
                Ndr64pCleanupServerContextHandles( pStubMsg, 
                                           NumberParams,
                                           Params,
                                           pArgBuffer,
                                           TRUE );     // fail before/during manager routine

                if (!pAsyncMsg->Flags.BadStubData)
                   {
                   Ndr64pFreeParams( pStubMsg,
                                   NumberParams,
                                   Params,
                                   pArgBuffer );
                   }

                NdrpFreeAsyncHandleAndMessage( AsyncHandle );
                }

            // else manager code invoked and we could not recover.
            // Exception will be raised by the EndFinally below.
            }

        }
    RpcEndFinally
}


RPC_STATUS
Ndr64pCompleteAsyncServerCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    PNDR_ASYNC_MESSAGE          pAsyncMsg,
    void *                      pReturnValue
    )
/*++

Routine Description :

    Complete an async call on the server side.  If an exception occurs, the
    asynchronous rpc call is aborted with the exception code and the server side
    caller is returned S_OK.

Arguments :

    AsyncHandle  - validated asynchronous handle,
    pAsyncMsg    - pointer to async msg structure,
    pReturnValue - pointer to the return value to be passed to the client.

Return :

    Status of S_OK.

--*/
{
    MIDL_STUB_MESSAGE *     pStubMsg       = & pAsyncMsg->StubMsg;
    RPC_MESSAGE *           pRpcMsg        = pStubMsg->RpcMsg;

    NDR64_PARAM_FORMAT  *   Params ;
    uchar *                 pArgBuffer     = pAsyncMsg->ProcContext.StartofStack;
    ushort                  StackSize      = (ushort)pAsyncMsg->ProcContext.StackSize;

    uchar *                 pArg;
    long                    NumberParams ;
    long                    n;
    boolean                 fParamsFreed   = FALSE;
    NDR64_PROC_FORMAT     * pHeader = pAsyncMsg->ProcContext.Ndr64Header;
    NDR64_PROC_FLAGS *      pNdr64Flags      = ( NDR64_PROC_FLAGS * )&pHeader->Flags;
    
    
    NumberParams    = pAsyncMsg->ProcContext.NumberParams;
    Params          = ( NDR64_PARAM_FORMAT * ) pAsyncMsg->ProcContext.Params;
    //
    // Wrap the unmarshalling, mgr call and marshalling in the try block of
    // a try-except. Put the call to abort in the except clause.
    //
    RpcTryExcept
    {
        // At this point, this is a valid RPC call since the asynchronous handle
        // is owned by NDR on the server side and NDR passes the handle
        // to the server during the invoke call.  During invoke
        // the parameters have already been unmarshalled.

        pAsyncMsg->StubPhase = STUB_MARSHAL;
    
        if( pNdr64Flags->HasReturn )
            {
            // Put user's return value on the stack as usual.
            // See the invoke for comments on folding return into the arg satck.

            long  ArgNum = (long) StackSize / sizeof(REGISTER_TYPE);

            if ( ArgNum )
                ArgNum--;

            if ( ! pReturnValue )
                RpcRaiseException( RPC_S_INVALID_ARG );

            if ( Params[NumberParams-1].Attributes.IsBasetype )
                memcpy( &((REGISTER_TYPE *)pArgBuffer)[ArgNum], 
                    pReturnValue, 
                    (size_t)NDR64_SIMPLE_TYPE_MEMSIZE( *(PFORMAT_STRING) Params[NumberParams-1].Type ) );
            else
                ((REGISTER_TYPE *)pArgBuffer)[ArgNum] = *(REGISTER_TYPE*)pReturnValue;
            }

        //
        // Buffer size pass.
        //
        ushort  ConstantBufferSize = (ushort)pHeader->ConstantServerBufferSize;

        if ( pNdr64Flags->UsesPipes )
            {
            NdrIsAppDoneWithPipes( pStubMsg->pContext->pPipeDesc );
            pStubMsg->BufferLength += ConstantBufferSize;
            }
        else
            pStubMsg->BufferLength = ConstantBufferSize;

        if ( pNdr64Flags->ServerMustSize )
            {
            NDR_ASSERT( pAsyncMsg->ProcContext.StartofStack == pArgBuffer, 
                        "startofstack is not set" );
            
            Ndr64pSizing( pStubMsg,
                          FALSE );
                          
            }

        // Get buffer.

        if ( pNdr64Flags->UsesPipes && pStubMsg->pContext->pPipeDesc->OutPipes )
            {
            NdrGetPartialBuffer( pStubMsg );
            pStubMsg->RpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;
            }
        else
            {
            Ndr64GetBuffer( pStubMsg,
                          pStubMsg->BufferLength );
            }

                       
        //
        // Marshall pass.
        //

        Ndr64pServerMarshal( pStubMsg );

        pRpcMsg->BufferLength = (ulong)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer);

        // We don't drop to the runtime like for synchronous calls,
        // we send the last buffer explicitly.

        // set the freed flag.
        fParamsFreed = TRUE;
        /*
            we have to do release twice here:
                After the last piece of data is sent via NdrAsyncSend, dispatch buffer
            will be freed by runtime. We'll have problem calling ndr free routines to
            free unique pointers (where both pointer and pointee are in the buffer). So
            we call ndr free routines BEFORE the send, because it won't free anything
            inside dispatch buffer, and runtime send only cares about dispatch buffer.
                We still have to call ndr free routines in RpcFinally for exception cleanup. we
            check the flag to avoid calling free twice.
        */
        Ndr64pFreeParams( pStubMsg,
                        NumberParams,
                        Params,
                        pArgBuffer );

        NdrAsyncSend( pStubMsg,
                      FALSE );    // the last call is always non-partial
        }
    RpcExcept(1)
        {
        // If we died during the marshaling phase, see if context handles are fine.

        // Abort the call which will result in the exception being propagated to
        // the client.

        Ndr64pAsyncAbortCall( AsyncHandle,
                            pAsyncMsg,
                            RpcExceptionCode(),
                            !fParamsFreed ); // Do not free if second attempt.
        return S_OK;
        }
    RpcEndExcept

    NdrpFreeAsyncHandleAndMessage( AsyncHandle );
    return S_OK;
}


RPC_STATUS
Ndr64pAsyncAbortCall (
    PRPC_ASYNC_STATE   AsyncHandle,
    PNDR_ASYNC_MESSAGE pAsyncMsg,
    unsigned long      ExceptionCode,
    BOOL               bFreeParams
    )
/*++
Routine Description:

    Aborts the asynchronous RPC call indicated by AsyncHandle on the server and
    frees memory allocated for the parameters, message, and handle.

Arguments:
    AsyncHandle   - supplies the async handle for the call
    AsyncMessage  - supplies the async message for the call
    ExceptionCode - supplies the exception code to send to the client.
    bFreeParams   - TRUE if the parameters should be freed.

Return Value:
    NONE.

--*/
{

    RPC_STATUS Status = RPC_S_OK;

    // If the async call is aborted, see if context handles are fine.
    // We are dying after manager routine is called
        Ndr64pCleanupServerContextHandles( &pAsyncMsg->StubMsg, 
                                           pAsyncMsg->ProcContext.NumberParams,
                                           (NDR64_PARAM_FORMAT *) pAsyncMsg->ProcContext.Params,
                                           pAsyncMsg->ProcContext.StartofStack,
                                           FALSE );     // no exception in manager routine


    if (bFreeParams)
        {
        Ndr64pFreeParams( & pAsyncMsg->StubMsg,
                        pAsyncMsg->ProcContext.NumberParams,  //Number of parameters
                        (NDR64_PARAM_FORMAT *) pAsyncMsg->ProcContext.Params,
                        pAsyncMsg->ProcContext.StartofStack );
        }

    if ( ! pAsyncMsg->Flags.RuntimeCleanedUp )
        Status = I_RpcAsyncAbortCall( AsyncHandle, ExceptionCode);

    NdrpFreeAsyncHandleAndMessage( AsyncHandle );

    return Status;
}


#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\asyncu.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996 - 2000 Microsoft Corporation

Module Name :

    asyncu.c

Abstract :

    This file contains the ndr async uuid implementation.

Author :

    Ryszard K. Kott     (ryszardk)    Oct 1997

Revision History :

---------------------------------------------------------------------*/

#include "precomp.hxx"

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include "ndrole.h"
#include "rpcproxy.h"
#include "interp2.h"
#include "asyncu64.h"
#include "expr.h"
#include "ndrtypes.h"
#include "ndr64types.h"
#include <stddef.h>

#include <stdarg.h>

#pragma code_seg(".ndr64")

void
Ndr64pCloneInOnlyCorrArgs(
                       NDR_DCOM_ASYNC_MESSAGE * pAsyncMsg,
                       PFORMAT_STRING           pFormatType
                       );

HRESULT
Ndr64pCompleteDcomAsyncStubCall(
                             CStdAsyncStubBuffer *   pAsyncSB
                             );


CLIENT_CALL_RETURN RPC_VAR_ENTRY
Ndr64DcomAsyncClientCall(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    ulong                       nProcNum,
    void                       *pReturnValue,
    ...
    )
{
    NDR_PROC_CONTEXT ProcContext;
    RPC_STATUS status;
    CLIENT_CALL_RETURN      Ret;
    va_list                 ArgList;
    unsigned char  *        StartofStack;

    INIT_ARG( ArgList, pReturnValue);
    GET_FIRST_IN_ARG(ArgList);
    StartofStack = (uchar *) GET_STACK_START(ArgList);

    Ndr64ClientInitializeContext( NdrpGetSyntaxType( pProxyInfo->pTransferSyntax),
                                   pProxyInfo,
                                   nProcNum,
                                  &ProcContext,
                                   StartofStack );

    NDR_ASSERT( ProcContext.IsAsync, "invalid async proc" );
    if ( nProcNum & 0x1 )
        status =  MulNdrpBeginDcomAsyncClientCall( pProxyInfo,
                                       nProcNum,
                                       &ProcContext,
                                       StartofStack );
    else
        status =  MulNdrpFinishDcomAsyncClientCall(pProxyInfo,
                                       nProcNum,
                                       &ProcContext,
                                       StartofStack );

    Ret.Simple = status;
   
    return Ret;

}



VOID
Ndr64pAsyncDCOMFreeParams(
                       PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg )
{
/*++

Routine Description:
    Frees the parameters for both the begin and finish calls.

Arguments:
    pAsyncMsg - Supplies a pointer to the async message.

Return Value:
    None.

--*/
   NDR64_PARAM_FLAGS   *   pParamFlags;

   if ( pAsyncMsg->BeginStack )
      {

      if ( pAsyncMsg->FinishStack )
         {

         // Clear out the IN OUT parameters on the begin stack
         // so that they are not freed twice.
         int n;
         REGISTER_TYPE       *pBeginStack      = (REGISTER_TYPE *)pAsyncMsg->BeginStack;
         NDR64_PARAM_FORMAT  *BeginParams       = (NDR64_PARAM_FORMAT*)pAsyncMsg->BeginParams;
         int                 BeginNumberParams = pAsyncMsg->nBeginParams ;

         for( n = 0; n < BeginNumberParams; n++ ) 
            {
            pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( BeginParams[n].Attributes );

            if ( pParamFlags->IsIn  &&
                 pParamFlags->IsOut )
               {

               pBeginStack[ BeginParams[ n ].StackOffset / sizeof(REGISTER_TYPE) ] = 0;
               
               }
                  
            }
         }

      Ndr64pFreeParams( & (pAsyncMsg->StubMsg),
                       pAsyncMsg->nBeginParams,
                      ( NDR64_PARAM_FORMAT * ) pAsyncMsg->BeginParams,
                      pAsyncMsg->BeginStack );
      }

   if ( pAsyncMsg->FinishStack )
      {

      Ndr64pFreeParams( & (pAsyncMsg->StubMsg),
                      pAsyncMsg->nFinishParams,
                      ( NDR64_PARAM_FORMAT * ) pAsyncMsg->FinishParams,
                      pAsyncMsg->FinishStack );
      }

}


HRESULT
MulNdrpBeginDcomAsyncClientCall(
                            MIDL_STUBLESS_PROXY_INFO    *     pProxyInfo,
                            ulong                             nProcNum,
                            NDR_PROC_CONTEXT *                pContext, 
                            void *                            StartofStack )
/*
    Notes: OLE Refcounting.
    The model for async_uuid() is that async proxies or stubs
    are created with RefCount==1 and should never ever be
    addrefed by the engine.
    What the engine does is only the AsyncMsg clean up when done.

    The decision to destroy the AsyncPB or AsyncSB object is
    up to the client side PM or channel's SM for the server side.
*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;

   RPC_MESSAGE *               pRpcMsg;
   MIDL_STUB_MESSAGE *         pStubMsg;

   uchar *                     pArg;
   void *                      pThis = *(void **)StartofStack;
   void *                      Params;
   long                        NumberParams;
   long                        n;

   RPC_STATUS                  Status;
   CStdAsyncProxyBuffer    *   pAsyncPB;
   const IID *                 piid;
   HRESULT                     hr = S_OK;
   BOOL                        fSendCalled = FALSE;

   pAsyncPB = (CStdAsyncProxyBuffer*)
              ((uchar*)pThis - offsetof(CStdProxyBuffer, pProxyVtbl));

   piid = NdrGetProxyIID( pThis );


   Status = MulNdrpSetupBeginClientCall( pAsyncPB,
                                      StartofStack,
                                      pContext,
                                      *piid );
   if ( !SUCCEEDED(Status) )
      return Status;

   pAsyncMsg = (NDR_DCOM_ASYNC_MESSAGE *)pAsyncPB->CallState.pAsyncMsg;

   // We need to switch to our copy of the stack everywhere, including pStubMsg.

   StartofStack = pAsyncMsg->ProcContext.StartofStack;

   pRpcMsg   = & pAsyncMsg->RpcMsg;
   pStubMsg  = & pAsyncMsg->StubMsg;
   pStubMsg->pContext = &pAsyncMsg->ProcContext;
   pContext = &pAsyncMsg->ProcContext;
   

   NumberParams = pContext->NumberParams;

   // This is OLE only code path - use a single TryExcept.
   // After catching it just map it to OLE exception.

   RpcTryExcept
   {
      ulong  RpcFlags;
      PFORMAT_STRING              pFormat;

      pContext->RpcFlags |= RPC_BUFFER_ASYNC;
      Ndr64pClientSetupTransferSyntax(pThis, 
                           pRpcMsg,
                           pStubMsg,
                           pProxyInfo,
                           pContext,
                           nProcNum );

      pStubMsg->pAsyncMsg = (struct _NDR_ASYNC_MESSAGE *) pAsyncMsg;

   //
   // Parameter descriptions are nicely spit out by MIDL.
   //
      Params = (NDR64_PARAM_FORMAT *) ( pContext->Params );

      pFormat      = NdrpGetProcString( pContext->pSyntaxInfo,
                                        pContext->CurrentSyntaxType,
                                        nProcNum );

      pStubMsg->pContext       = pContext;

      pAsyncMsg->nBeginParams = NumberParams;
      pAsyncMsg->BeginParams  = (void *)Params;
      pAsyncMsg->pThis        = pThis;
      pAsyncMsg->SyntaxType   = pContext->CurrentSyntaxType;

      ( * pContext->pfnInit)(pStubMsg, 
                             NULL );        // return value
                             


      ( * pContext->pfnSizing) ( pStubMsg,
                                   TRUE );    // isclient
      //
      // Do the GetBuffer.
      //

      pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

      NdrProxyGetBuffer( pThis, pStubMsg );

      NDR_ASSERT( pStubMsg->fBufferValid, "Invalid buffer" );

      pAsyncMsg->StubPhase = STUB_MARSHAL;

      //
      // ----------------------------------------------------------
      // Marshall Pass.
      // ----------------------------------------------------------
      //

      ( * pContext->pfnMarshal ) ( pStubMsg,
                                TRUE ); // IsObject

      //
      // Make the RPC call.
      //

      pAsyncMsg->StubPhase = NDR_ASYNC_CALL_PHASE;

      fSendCalled = NdrpDcomAsyncClientSend( pStubMsg,
                                             pAsyncPB->punkOuter );  // PM's entry
      if ( fSendCalled )
         hr = S_OK;
   }
   RpcExcept( 1 )
   {
      RPC_STATUS ExceptionCode = RpcExceptionCode();

      pAsyncPB->CallState.Flags.BeginError = 1;

      // Actually dismantle the call.
      // This is a request call and there is nothing left at the runtime.

      pAsyncMsg->StubPhase = NDR_ASYNC_ERROR_PHASE;
      pAsyncMsg->ErrorCode = ExceptionCode;

      hr = NdrHrFromWin32Error(ExceptionCode);
      pAsyncPB->CallState.Hr = hr;

      // Async call in request phase: don't touch [out] params.
   }
   RpcEndExcept

   // "Finally"
   // Dont touch anything, the client has to call the Finish method anyway.

   pAsyncPB->CallState.Flags.BeginDone = 1;
   if ( SUCCEEDED(hr) )
      {
      if ( pContext->CurrentSyntaxType == XFER_SYNTAX_DCE )
          NdrpCloneInOnlyCorrArgs( pAsyncMsg,
                                   pContext->pSyntaxInfo->TypeString );
      else
          Ndr64pCloneInOnlyCorrArgs( pAsyncMsg,
                                     pContext->pSyntaxInfo->TypeString );
      // Channel will prompt signal
      }
   else
      if (!fSendCalled )
      NdrpAsyncProxySignal( pAsyncPB );

   // No need to release, our refcount should be 1 at this point.

   return hr;
}


void
Ndr64pCloneInOnlyCorrArgs(
                       NDR_DCOM_ASYNC_MESSAGE * pAsyncMsg,
                       PFORMAT_STRING             pFormatTypes
                       )
/*
    Walk the client stack looking for an in only argument flagged to clone.
    For each one, replace the arg with a clone that we control.
    Assumption is, we do it before returning to the user from the Begin call
    and also we clone walking the copy of the app's stack not the app stack.

    The stack modified in this way will be the one to access for the weird
    crossreferenced correlated args.

    This issue doesn't happen on the server, as we keep the Begin stack around
    when the Finish call is processed.

*/
{
   unsigned char        *  pBeginStack  = pAsyncMsg->BeginStack;
   NDR64_PARAM_FORMAT   *  Params       = ( NDR64_PARAM_FORMAT *)pAsyncMsg->BeginParams;
   NDR64_PARAM_FLAGS    *  pParamFlags;
   
   int                 NumberParams = pAsyncMsg->nBeginParams;
   unsigned char  *    pArg;
   int                 n;

   for ( n = 0; n < NumberParams; n++ )
      {
      pParamFlags = ( NDR64_PARAM_FLAGS * ) & Params[n].Attributes ;
      
      if ( pParamFlags->SaveForAsyncFinish )
         {
         // Note that the arguments that need cloning come from top level size_is,
         // length_is etc, switch_is and iid_is attributes.
         // Hence, the only types of interest are uuid clones and integral types
         // different from hyper.
         // On top of it, we deal with stack-slot chunks of memory, so we don't
         // have to care about mac issues.

         pArg = pBeginStack + Params[n].StackOffset;

         if ( pParamFlags->IsBasetype )
            {
            if ( pParamFlags->IsSimpleRef )
               {
               void * pPointee = AsyncAlloca( pAsyncMsg, 8 );
               NDR64_FORMAT_CHAR type = *(PFORMAT_STRING)Params[n].Type;

               // The assignment needs to follow the type.
               RpcpMemoryCopy( pPointee, *(void **)pArg, 
                               NDR64_SIMPLE_TYPE_MEMSIZE( type ) );  
               *(void**)pArg = pPointee;
               }
            // else the stack slot has the simple value already.
            }
         else
            {
            // If it's not a base type, then it cannot be by value.
            // It has to be a pointer to a simple type or to an iid.

            PFORMAT_STRING  pParamFormat;
            const NDR64_POINTER_FORMAT *pPointerFormat ;
            PFORMAT_STRING pPointeeFormat; 

            pParamFormat = (PFORMAT_STRING)Params[n].Type;

            pPointerFormat = (const NDR64_POINTER_FORMAT*)pParamFormat;
            pPointeeFormat = (PFORMAT_STRING)pPointerFormat->Pointee;
            if ( NDR64_IS_BASIC_POINTER(*pParamFormat) )  // not FC64_IP
               {
               if ( NDR64_SIMPLE_POINTER( pPointerFormat->Flags ) )
                  {
                  // Covers things like a unique pointer to a size
                  // Essentially the same as for the simple ref above.

                  void * pPointee = AsyncAlloca( pAsyncMsg, 8 );
                  NDR64_FORMAT_CHAR type = *pPointeeFormat;

                  // The assignment needs to follow the type.
                  RpcpMemoryCopy( pPointee, *(void **)pArg, 
                                  NDR64_SIMPLE_TYPE_MEMSIZE( type ) );
                  *(void**)pArg = pPointee;
                  }
               else
                  {
                  // has to be the riid case.
                  // REFIID* comes out as FC64_?P -> FC64_?P -> FC64_STRUCT


                  if ( NDR64_IS_BASIC_POINTER(*pPointeeFormat)  &&
                       ! NDR64_SIMPLE_POINTER( pPointerFormat->Flags) )
                     {

                     if ( *pPointeeFormat == FC64_STRUCT )
                        {
                        // one alloc for REFIID and IID itself.
                        IID** ppIID = (IID**)AsyncAlloca( pAsyncMsg,
                                                          sizeof(IID *) + sizeof(IID));
                        IID* pIID = (IID *)(ppIID + 1);


                        *ppIID = pIID; //set pointer
                        RpcpMemoryCopy( pIID, **(IID ***)pArg, sizeof(IID));
                        *(IID ***)pArg = ppIID;
                        }
                     else
                        RpcRaiseException( RPC_S_INTERNAL_ERROR );
                     }
                  else
                     RpcRaiseException( RPC_S_INTERNAL_ERROR );
                  }
               }
            else
               {
               // has to be the riid case.
               // REFIID comes out as FC64_STRUCT

               if ( *pParamFormat == FC64_STRUCT )
                  {
                  IID *pIID = (IID*)AsyncAlloca( pAsyncMsg, sizeof(IID) );

                  RpcpMemoryCopy( pIID, *(IID **)pArg, sizeof(IID));
                  *(IID **)pArg = pIID;
                  }
               else
                  RpcRaiseException( RPC_S_INTERNAL_ERROR );
               }

            }

         }
      }
}


HRESULT
MulNdrpFinishDcomAsyncClientCall(
                            MIDL_STUBLESS_PROXY_INFO    *     pProxyInfo,
                            ulong                             nProcNum,
                            NDR_PROC_CONTEXT *                pContext ,
                            void *                            StartofStack )
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;


   RPC_MESSAGE *               pRpcMsg;
   MIDL_STUB_MESSAGE *         pStubMsg;

   uchar *                     pArg;
   void *                      pThis = *(void **)StartofStack;
   CLIENT_CALL_RETURN          ReturnValue;

   NDR64_PARAM_FORMAT      *   Params;
   long                        NumberParams;
   long                        n;
   NDR_ASYNC_CALL_FLAGS        CallFlags;

   CStdAsyncProxyBuffer    *   pAsyncPB;
   const IID *                 piid;
   HRESULT                     hr = S_OK;
   NDR64_PARAM_FLAGS *         pParamFlags;
   
   ReturnValue.Simple = 0;

                                              
   pAsyncPB = (CStdAsyncProxyBuffer*)
              ((uchar*)pThis - offsetof(CStdProxyBuffer, pProxyVtbl));

   piid = NdrGetProxyIID( pThis );
                                 
   hr = MulNdrpSetupFinishClientCall( pAsyncPB,
                                   StartofStack,
                                   *piid,
                                   nProcNum,
                                   pContext );
   if ( !SUCCEEDED(hr) )
      return hr;

   // Note that we cant call to Ndr64ProxyInitialize again.

   pAsyncMsg = (NDR_DCOM_ASYNC_MESSAGE*)pAsyncPB->CallState.pAsyncMsg;

   pRpcMsg   = & pAsyncMsg->RpcMsg;
   pStubMsg  = & pAsyncMsg->StubMsg;

   // begin method negotiate to a different syntax than default
   if ( pContext->CurrentSyntaxType != pAsyncMsg->SyntaxType )
        {        
        PFORMAT_STRING pFormat;
        pContext->CurrentSyntaxType = pAsyncMsg->SyntaxType;
        pContext->pSyntaxInfo = pAsyncMsg->ProcContext.pSyntaxInfo;
        pFormat = NdrpGetProcString( pContext->pSyntaxInfo,
                                     pContext->CurrentSyntaxType,
                                     nProcNum );

        MulNdrpInitializeContextFromProc(  pContext->CurrentSyntaxType, 
                                           pFormat, 
                                           pContext, 
                                           (uchar *)StartofStack );        
        }
   
   
   // we can directly call to ndr20 finish routine because there is extra setup cost.
   if ( pContext->CurrentSyntaxType == XFER_SYNTAX_DCE )
       return NdrpFinishDcomAsyncClientCall( pProxyInfo->pStubDesc, 
                                              pContext->pProcFormat,
                                              (uchar*)StartofStack );

   memcpy ( & pAsyncMsg->ProcContext, pContext, offsetof( NDR_PROC_CONTEXT, AllocateContext ) );
  
   NumberParams = pContext->NumberParams;

   CallFlags = pAsyncMsg->Flags;

   // Initialize the stack top in the stub msg to be
   // this stack, the stack for the finish call parameters.
   pAsyncMsg->nFinishParams = NumberParams;
   pAsyncMsg->FinishParams = pContext->Params;
   Params = (NDR64_PARAM_FORMAT *) pContext->Params;
   pStubMsg->StackTop = (uchar*)StartofStack;
   pStubMsg->pContext = &pAsyncMsg->ProcContext;

   // OLE only code path - single RpcTryExcept.
   //
   RpcTryExcept
   {
      BOOL fRaiseExcFlag = FALSE;

      if ( CallFlags.ErrorPending )
         RpcRaiseException( pAsyncMsg->ErrorCode );

      // We need to zero out the [out] parameters and to check
      // the ref pointers.

      for ( n = 0; n < NumberParams; n++ )
         {
         pParamFlags = ( NDR64_PARAM_FLAGS * ) & Params[n].Attributes ;
         
         pArg = (uchar *)StartofStack + Params[n].StackOffset;

         if ( pParamFlags->IsSimpleRef )
            {
            // We cannot raise the exception here,
            // as some out args may not be zeroed out yet.

            if ( ! *((uchar **)pArg) )
               {
               fRaiseExcFlag = TRUE;
               continue;
               }
            }

         // We do the basetype check to cover the
         // [out] simple ref to basetype case.
         //
         if ( pParamFlags->IsPartialIgnore ||
              ( ! pParamFlags->IsIn &&
                ! pParamFlags->IsReturn ))
            {
            if ( pParamFlags->IsBasetype )
               {
               // [out] only arg can only be ref, we checked that above.

               NDR64_FORMAT_CHAR type = *(PFORMAT_STRING)Params[n].Type;

               MIDL_memset( *(uchar **)pArg, 
                            0, 
                            (size_t)NDR64_SIMPLE_TYPE_MEMSIZE( type ));
               }
            else
               {
               Ndr64ClientZeroOut(
                               pStubMsg,
                               Params[n].Type,
                               *(uchar **)pArg );
               }
            }
         }

      if ( fRaiseExcFlag )
         RpcRaiseException( RPC_X_NULL_REF_POINTER );


      NdrDcomAsyncReceive( pStubMsg );

      Ndr64pClientUnMarshal( pStubMsg,
                        &ReturnValue );
      

      // Pass the HR from the Finish call, if there was any, to the client.
      if ( pArg == (uchar *) &ReturnValue )
         hr = (HRESULT) ReturnValue.Simple;
   }
   RpcExcept( 1 )
   {
      RPC_STATUS ExceptionCode = RpcExceptionCode();

      //
      // In OLE, since they don't know about error_status_t and wanted to
      // reinvent the wheel, check to see if we need to map the exception.
      // In either case, set the return value and then try to free the
      // [out] params, if required.
      //
      hr = NdrHrFromWin32Error(ExceptionCode);

      //
      // Set the Buffer endpoints so the Ndr64Free routines work.
      //

      Ndr64pDcomClientExceptionHandling ( pStubMsg,
                                          nProcNum,
                                          hr,
                                          &ReturnValue );
                                                    
   }
   RpcEndExcept

   // Finish
   // Cleanup everything. However, don't free pAsyncPB itself.

   NdrpAsyncProxyMsgDestructor( pAsyncPB );

   //  Never addref or release async proxy object, this is app's/PM's job.

   return hr;
}


HRESULT RPC_ENTRY
Ndr64DcomAsyncStubCall(
                    struct IRpcStubBuffer *     pThis,
                    struct IRpcChannelBuffer *  pChannel,
                    PRPC_MESSAGE                pRpcMsg,
                    ulong *                     pdwStubPhase
                    )
/*++

Routine Description :

    Server Interpreter entry point for DCOM async procs.
    This is the Begin entry for channel (regular dispatch entry from stub.c).
    The Finish happen when the channel calls stub's Synchronize::Signal method
    on the stub object. The call then comes to NdrpAsyncStubSignal later below.

Arguments :

    pThis           - Object proc's 'this' pointer.
    pChannel        - Object proc's Channel Buffer.
    pRpcMsg         - The RPC message.
    pdwStubPhase    - Used to track the current interpreter's activity.

Return :

    Status of S_OK.

Notes :
    The engine never calls a signal on behalf of the user, regardless what kind of
    errors happen during begin (cannot setup begin, cannot unmarshal, app dies in invoke).
    In each of these cases, the engine simply returns an error code to the channel.

    The only time the engine would call FreeBuffer on the server is if the engine died
    between a successful GetBuffer and the final Send.

Notes on OLE Refcounting.
    The model for async_uuid() is that async proxies or stubs are created
    with RefCount==1 and should never ever be addrefed by the engine.
    What the engine does is only the AsyncMsg clean up when done.

    The decision to destroy the AsyncPB or AsyncSB object is
    up to the client side PM or channel's SM for the server side.
*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;

   PMIDL_SERVER_INFO           pServerInfo;
   PMIDL_STUB_DESC             pStubDesc;
   const SERVER_ROUTINE  *     DispatchTable;
   unsigned long               ProcNum;

   ushort                      FormatOffset;
   PFORMAT_STRING              pFormat;

   PMIDL_STUB_MESSAGE          pStubMsg;

   uchar *                     pArgBuffer;
   uchar *                     pArg;
   uchar **                    ppArg;

   NDR64_PARAM_FORMAT  *       Params;

   BOOL                        fBadStubDataException = FALSE;
   BOOL                        fManagerCodeInvoked = FALSE;
   unsigned long               n, i;

   CStdAsyncStubBuffer *       pAsyncSB;

   HRESULT                     hr;

   const IID *                 piid = 0;
   BOOL                        fErrorInInvoke = FALSE;
   BOOL                        fRecoverableErrorInInvoke = FALSE;

   IUnknown *                  pSrvObj;
   CInterfaceStubVtbl *        pStubVTable;
   NDR_PROC_CONTEXT            ProcContext, *pContext;
   NDR64_PROC_FORMAT    *      pProcFormat;
   NDR64_PROC_FLAGS    *       pNdr64Flags;
   NDR64_PARAM_FLAGS   *       pParamFlags;
   SYNTAX_TYPE                 SyntaxType;
   RPC_STATUS                  ExceptionCode = 0;
   MIDL_SYNTAX_INFO *          pSyntaxInfo = NULL;
   

   NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
               "marshaling buffer misaligned at server" );

   // The channel dispatches to the engine with the sync proc num.
   // We need only async proc num at the engine level.
   ProcNum = pRpcMsg->ProcNum;
   ProcNum = 2 * ProcNum - 3;  // Begin method #

   pSrvObj = (IUnknown *)((CStdStubBuffer *)pThis)->pvServerObject;
   DispatchTable = (SERVER_ROUTINE *)pSrvObj->lpVtbl;

   pStubVTable = (CInterfaceStubVtbl *)
                 (*((uchar **)pThis) - sizeof(CInterfaceStubHeader));

   piid        = pStubVTable->header.piid;
   pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;

    SyntaxType = NdrpGetSyntaxType( pRpcMsg->TransferSyntax );

    if ( SyntaxType == XFER_SYNTAX_DCE )
        return NdrDcomAsyncStubCall( pThis, pChannel, pRpcMsg, pdwStubPhase );
  
   pStubDesc    = pServerInfo->pStubDesc;
   pAsyncSB = (CStdAsyncStubBuffer *)
              ((uchar *)pThis - offsetof(CStdAsyncStubBuffer,lpVtbl));

   for ( i = 0; i < (ulong)pServerInfo->nCount; i++ )
       {
       if ( SyntaxType == NdrpGetSyntaxType( &pServerInfo->pSyntaxInfo[i].TransferSyntax ) )
           {
           pSyntaxInfo = &pServerInfo->pSyntaxInfo[i];
           break;
           }
       }

   if ( NULL == pSyntaxInfo )
        return HRESULT_FROM_WIN32( RPC_S_UNSUPPORTED_TRANS_SYN );

   NdrServerSetupNDR64TransferSyntax( ProcNum, pSyntaxInfo, &ProcContext);

   pProcFormat = ProcContext.Ndr64Header;
   pNdr64Flags = (NDR64_PROC_FLAGS *)&pProcFormat->Flags;
        
   hr = NdrpValidateAsyncStubCall( pAsyncSB );
   if ( ! SUCCEEDED(hr) )
      return hr;
      
   hr = Ndr64pSetupBeginStubCall( pAsyncSB, &ProcContext, *piid );
   if ( FAILED(hr) )
      return hr;

   pAsyncMsg = (NDR_DCOM_ASYNC_MESSAGE*)pAsyncSB->CallState.pAsyncMsg;
   pStubMsg  = & pAsyncMsg->StubMsg;


   // Both rpc runtime and channel require that we use a copy of the rpc message.

   RpcpMemoryCopy( & pAsyncMsg->RpcMsg, pRpcMsg, sizeof(RPC_MESSAGE) );
   pRpcMsg = & pAsyncMsg->RpcMsg;

   pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

   pStubMsg->RpcMsg = pRpcMsg;
   pContext = &pAsyncMsg->ProcContext;

   // The arg buffer is zeroed out already.
   pArgBuffer = pAsyncMsg->ProcContext.StartofStack;

   //
   // Get new interpreter info.
   //
   Params = (NDR64_PARAM_FORMAT *) pContext->Params;

   pAsyncMsg->nBeginParams     = pContext->NumberParams;
   pAsyncMsg->BeginParams      = pContext->Params;
   pAsyncMsg->pThis            = pThis;
   pAsyncMsg->SyntaxType       = pContext->CurrentSyntaxType;

   //
   // Wrap the unmarshalling and the invoke call in the try block of
   // a try-finally. Put the free phase in the associated finally block.
   //
   // We abstract the level of indirection here.

   RpcTryFinally
   {
      // OLE: put pThis in first dword of stack.
      //
      ((void **)pArgBuffer)[0] = ((CStdStubBuffer *)pThis)->pvServerObject;

      // Initialize the Stub message.
      //
      NdrStubInitialize( pRpcMsg,
                         pStubMsg,
                         pStubDesc,
                         pChannel );

      pStubMsg->pAsyncMsg     = (struct _NDR_ASYNC_MESSAGE *) pAsyncMsg;
      pStubMsg->pContext       = pContext;

      pAsyncMsg->BeginParams  = Params;
      pAsyncMsg->pdwStubPhase = pdwStubPhase;    // the phase is STUB_UNMARSHAL

      // Raise exceptions after initializing the stub.

      if ( pNdr64Flags->UsesFullPtrPackage )
         pStubMsg->FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );
      else
         pStubMsg->FullPtrXlatTables = 0;

      //
      // Set StackTop AFTER the initialize call, since it zeros the field
      // out.
      //
      pStubMsg->StackTop  = pArgBuffer;

      // StubPhase set up by invoke is STUB_UNMARSHAL

      RpcTryExcept
      {
         NDR_ASSERT( pContext->StartofStack == pArgBuffer, "startofstack is not set" );

         Ndr64pServerUnMarshal ( pStubMsg  );  



      // Last ditch checks.

      if ( pRpcMsg->BufferLength  <
           (uint)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer) )
         {
         RpcRaiseException( RPC_X_BAD_STUB_DATA );
         }

      }
      RpcExcept( NdrServerUnmarshallExceptionFlag(GetExceptionInformation()) )
      {
         // Filter set in rpcndr.h to catch one of the following
         //     STATUS_ACCESS_VIOLATION
         //     STATUS_DATATYPE_MISALIGNMENT
         //     RPC_X_BAD_STUB_DATA

         ExceptionCode = RpcExceptionCode();
         fBadStubDataException = TRUE;

         if ( RPC_BAD_STUB_DATA_EXCEPTION_FILTER ) 
            ExceptionCode = RPC_X_BAD_STUB_DATA;
            
         pAsyncMsg->Flags.ErrorPending = 1;
         pAsyncMsg->Flags.BadStubData = 1;
         pAsyncMsg->ErrorCode = ExceptionCode;

         pAsyncSB->CallState.Flags.BeginError = 1;
         pAsyncSB->CallState.Hr = NdrHrFromWin32Error( ExceptionCode);
         NdrpFreeMemoryList( pStubMsg );

         RpcRaiseException( ExceptionCode );

      }
      RpcEndExcept

      //
      // Do [out] initialization before the invoke.
      //
      for ( n = 0; n < pContext->NumberParams; n++ )
         {
         pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
         
         if ( pParamFlags->IsIn     ||
              pParamFlags->IsReturn )
            continue;

         // This is a Begin call, there cannot be any [out] only args.

         RpcRaiseException( RPC_S_INTERNAL_ERROR );
         }


      //
      // OLE interfaces use pdwStubPhase in the exception filter.
      // See CStdStubBuffer_Invoke in stub.c.
      //
      *pdwStubPhase = STUB_CALL_SERVER;

      // We need to catch exception in the manager code separately
      // as the model implies that there will be no other call from
      // the server app to clean up.

      pAsyncSB->CallState.Flags.BeginDone = 1;

      RpcTryExcept
      {
         //
         // Check for a thunk.  Compiler does all the setup for us.
         //
         if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ ProcNum ] )
            {
            fManagerCodeInvoked = TRUE;
            pServerInfo->ThunkTable[ ProcNum ]( pStubMsg );
            }
         else
            {
            //
            // Note that this ArgNum is not the number of arguments declared
            // in the function we called, but really the number of
            // REGISTER_TYPEs occupied by the arguments to a function.
            //
            long                ArgNum;
            MANAGER_FUNCTION    pFunc;
            REGISTER_TYPE       ReturnValue;

            pFunc  = (MANAGER_FUNCTION) DispatchTable[ ProcNum ];
            ArgNum = (long)pProcFormat->StackSize  / sizeof(REGISTER_TYPE);

            //
            // The StackSize includes the size of the return. If we want
            // just the number of REGISTER_TYPES, then ArgNum must be reduced
            // by 1 when there is a return value AND the current ArgNum count
            // is greater than 0.
            //
            if ( ArgNum && pNdr64Flags->HasReturn )
               ArgNum--;

            // Being here means that we can expect results. Note that the user
            // can call RpcCompleteCall from inside of the manager code.

            fManagerCodeInvoked = TRUE;
            ReturnValue = Invoke( pFunc,
                                  (REGISTER_TYPE *)pArgBuffer,
#if defined(_IA64_)
                                  pProcFormat->FloatDoubleMask,
#endif
                                  ArgNum);

            if ( pNdr64Flags->HasReturn )
               {
               // Pass the app's HR from Begin call to the channel.
               (*pfnDcomChannelSetHResult)( pRpcMsg, 
                                            NULL,   // reserved
                                            (HRESULT) ReturnValue);
               }

            // We are discarding the return value as it is not the real one.
            }
      }
      RpcExcept( 1 )
      {
         fErrorInInvoke = TRUE;

         pAsyncMsg->Flags.ErrorPending = 1;
         pAsyncMsg->ErrorCode = RpcExceptionCode();

         pAsyncSB->CallState.Flags.BeginError = 1;
         pAsyncSB->CallState.Hr = NdrHrFromWin32Error( RpcExceptionCode());
      }
      RpcEndExcept

      //  Done with invoking Begin
   }
   RpcFinally
   {
      if ( !fManagerCodeInvoked )
         {
         // Failed without invoking Begin - return an error. Remember the error.

         if ( fBadStubDataException )
            pAsyncMsg->ErrorCode = RPC_X_BAD_STUB_DATA;

         pAsyncSB->CallState.Flags.BeginDone = 1;
         hr = pAsyncSB->CallState.Hr;
         }
      else // fManagerCodeInvoked
         {
         hr = S_OK;

         if ( fErrorInInvoke )
            hr = pAsyncSB->CallState.Hr;
         }
   }
   RpcEndFinally

   return hr;
}




void
Ndr64pCloneInOutStubArgs(
                      NDR_DCOM_ASYNC_MESSAGE * pAsyncMsg )
/*
    Walk the second stack looking for an in-out argument.
    For each one, find the corresponding in-out atgument from the first stack
    and clone it to the second stack.

    Note, we need to do it only on the server side where we preserver the first
    stack, the dispatch buffer and all the arguments from the first stack. 

    On the client, this is the app's task to supply meaningful in-out arguments
    for the second stack.
*/
{
   REGISTER_TYPE *   pBeginStack  = (REGISTER_TYPE *)pAsyncMsg->BeginStack;
   REGISTER_TYPE *   pFinishStack = (REGISTER_TYPE *)pAsyncMsg->FinishStack;

   NDR64_PARAM_FORMAT * BeginParams       =  ( NDR64_PARAM_FORMAT *) pAsyncMsg->BeginParams;
   int                  BeginNumberParams =  pAsyncMsg->nBeginParams;
   NDR64_PARAM_FLAGS  * pParamFlags, * pBeginParamFlags;

   NDR64_PARAM_FORMAT * FinishParams       = ( NDR64_PARAM_FORMAT *) pAsyncMsg->FinishParams;
   int                  FinishNumberParams =  pAsyncMsg->nFinishParams;

   int FirstIO = 0;
   int n;

   for ( n = 0; n < FinishNumberParams; n++ )
      {
      pParamFlags = ( NDR64_PARAM_FLAGS *) & FinishParams[n].Attributes;
      // Find in-out arg that needs cloning.

      if ( pParamFlags->IsIn  &&
           pParamFlags->IsOut )
         {
         // Find the first IO on the first stack

         while ( FirstIO < BeginNumberParams )
            {
            pBeginParamFlags = ( NDR64_PARAM_FLAGS *) & BeginParams[FirstIO].Attributes;
            if ( pBeginParamFlags->IsIn  &&
                 pBeginParamFlags->IsOut )
               {
               break;
               }

            FirstIO++;
            }

         if ( BeginNumberParams <= FirstIO )
            RpcRaiseException( RPC_S_INTERNAL_ERROR );

         // Clone it to the second stack

         pFinishStack[ FinishParams[n].StackOffset / sizeof(REGISTER_TYPE) ] =
         pBeginStack[ BeginParams[ FirstIO ].StackOffset / sizeof(REGISTER_TYPE) ];
         FirstIO++;
         }
      }
}


HRESULT
Ndr64pCompleteDcomAsyncStubCall(
                             CStdAsyncStubBuffer *   pAsyncSB
                             )
/*++

Routine Description :

    Complete an async call on the server side.

Arguments :

    AsyncHandle  - raw or object handle (if pointer) as appropriate,
    pAsyncMsg    - pointer to async msg structure,
    pReturnValue - from the user to pass back to caller.

Return :

    Status of S_OK.

--*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;

   PMIDL_SERVER_INFO           pServerInfo;
   const SERVER_ROUTINE  *     DispatchTable;  // should be the same
   unsigned long               ProcNum;        // should be 1+

   RPC_MESSAGE *               pRpcMsg;
   MIDL_STUB_MESSAGE *         pStubMsg;

   NDR64_PARAM_FORMAT *        Params;         // Finish params
   uchar *                     pArgBuffer;     // new stack
   
   // MZ, BUG BUG, Fix after ship
   // ulong *                     pdwStubPhase;
 
   uchar *                     pArg;

   long                        NumberParams;
   long                        n;
   NDR64_PROC_FORMAT   *       pProcHeader;

   IUnknown *                  pSrvObj;
   CInterfaceStubVtbl *        pStubVTable;
   void *                      pThis;

   HRESULT                     hr;
   const IID *                 piid;           // should be the same

   BOOL                        fManagerCodeInvoked = FALSE;
   BOOL                        fErrorInInvoke = FALSE;
   RPC_STATUS                  ExceptionCode = 0;
   boolean                     fParamsFreed = FALSE;
   NDR64_PARAM_FLAGS *         pParamFlags;
   NDR64_PROC_FLAGS    *       pNdr64Flags;
   NDR_PROC_CONTEXT *          pContext = NULL;
   
   // We validated both the stub and the async context in the signal call.

   // We validated the pAsyncSB in the Signal call.
   // Do additional checks.

   pAsyncMsg = (NDR_DCOM_ASYNC_MESSAGE*)pAsyncSB->CallState.pAsyncMsg;
   pThis     = pAsyncMsg->pThis;

   // See if channel calls on the right stub
   if ( & pAsyncSB->lpVtbl != pThis)
      return E_INVALIDARG;


   pRpcMsg   = & pAsyncMsg->RpcMsg;
   pStubMsg  = & pAsyncMsg->StubMsg;
   pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext ;
   // We have preserved the sync proc num that the channel used.
   // We need only async proc num at the engine level.
   //

   ProcNum = pRpcMsg->ProcNum;
   ProcNum = 2 * ProcNum - 3 + 1;  // Finish method #

   pSrvObj = (IUnknown *)((CStdStubBuffer *)pThis)->pvServerObject;
   DispatchTable = (SERVER_ROUTINE *)pSrvObj->lpVtbl;

   pStubVTable = (CInterfaceStubVtbl *)
                 (*((uchar **)pThis) - sizeof(CInterfaceStubHeader));

   piid        = pStubVTable->header.piid;
   pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;

   // The proc header has a fixed layout now.

   pProcHeader = 
       (PNDR64_PROC_FORMAT)NdrpGetProcString( pAsyncMsg->ProcContext.pSyntaxInfo,
                                              XFER_SYNTAX_NDR64,
                                              ProcNum );
   pNdr64Flags = ( NDR64_PROC_FLAGS * )&pProcHeader->Flags;

   // Validate and setup for finish.

   hr = NdrpSetupFinishStubCall( pAsyncSB,
                                 (ushort )pProcHeader->StackSize,
                                 *piid );
   if ( hr )
      return hr;

   // The arg buffer is zeroed out already. Note, this is the second stack.

   pArgBuffer = pAsyncMsg->ProcContext.StartofStack;
   pStubMsg->StackTop = pArgBuffer;
   
   // MZ, BUG BUG, fix after ship
   // pdwStubPhase = pAsyncMsg->pdwStubPhase;
   
   //
   // Get new interpreter info.
   //
   NumberParams = pProcHeader->NumberOfParams;

   Params = (NDR64_PARAM_FORMAT *)(((PFORMAT_STRING)( pProcHeader + 1 )) + pProcHeader->ExtensionSize );


   pAsyncMsg->nFinishParams = pContext->NumberParams = NumberParams;
   pAsyncMsg->FinishParams = pContext->Params = Params;

   // Wrap the unmarshalling, mgr call and marshalling in the try block of
   // a try-finally. Put the free phase in the associated finally block.
   //
   RpcTryFinally
   {
      if ( pAsyncMsg->Flags.ErrorPending )
         RpcRaiseException( pAsyncMsg->ErrorCode );

      // Initialize the args of the new stack.

      // OLE: put pThis in first dword of stack.
      //
      ((void **)pArgBuffer)[0] = ((CStdStubBuffer *)pThis)->pvServerObject;

      //
      // Do [out] initialization before invoking Finish
      //

      Ndr64pCloneInOutStubArgs( pAsyncMsg );
      Ndr64pServerOutInit( pStubMsg );


      //
      // OLE interfaces use pdwStubPhase in the exception filter.
      // See CStdStubBuffer_Invoke in stub.c.
      //

      // MZ, BUG BUG, fix after ship
      // *pdwStubPhase = STUB_CALL_SERVER;

      // We need to catch exception in the manager code separately
      // as the model implies that there will be no other call from
      // the server app to clean up.

      RpcTryExcept
      {
         //
         // Check for a thunk.  Compiler does all the setup for us.
         //
         if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ProcNum] )
            {
            fManagerCodeInvoked = TRUE;
            pServerInfo->ThunkTable[ProcNum]( pStubMsg );
            }
         else
            {
            //
            // Note that this ArgNum is not the number of arguments declared
            // in the function we called, but really the number of
            // REGISTER_TYPEs occupied by the arguments to a function.
            //
            long                ArgNum;
            MANAGER_FUNCTION    pFunc;
            REGISTER_TYPE       ReturnValue;

            pFunc  = (MANAGER_FUNCTION) DispatchTable[ProcNum];
            ArgNum = (long)pProcHeader->StackSize / sizeof(REGISTER_TYPE);

            //
            // The StackSize includes the size of the return. If we want
            // just the number of REGISTER_TYPES, then ArgNum must be reduced
            // by 1 when there is a return value AND the current ArgNum count
            // is greater than 0.
            //
            if ( ArgNum && pNdr64Flags->HasReturn )
               ArgNum--;

            fManagerCodeInvoked = TRUE;
            ReturnValue = Invoke( pFunc,
                                  (REGISTER_TYPE *)pArgBuffer,
#if defined(_IA64_)
                                  pProcHeader->FloatDoubleMask,
#endif
                                  ArgNum);

            // This is the return value that should be marshaled back.
            if ( pNdr64Flags->HasReturn )
               {
               ((REGISTER_TYPE *)pArgBuffer)[ArgNum] = ReturnValue;
               // Pass the app's HR to the channel.
               (*pfnDcomChannelSetHResult)( pRpcMsg, 
                                            NULL,   // reserved
                                            (HRESULT) ReturnValue);
               }
            }
      }
      RpcExcept( 1 )
      {
         pAsyncMsg->Flags.ErrorPending = 1;

         pAsyncMsg->ErrorCode = RpcExceptionCode();
         fErrorInInvoke = TRUE;
      }
      RpcEndExcept

      //  Done with invoking Finish

      if ( pAsyncMsg->Flags.ErrorPending )
         RpcRaiseException( pAsyncMsg->ErrorCode );

      // MZ, BUG BUG, fix after ship
      // *pdwStubPhase = STUB_MARSHAL;

      //
      // Buffer size pass.
      //
      pStubMsg->BufferLength = pProcHeader->ConstantServerBufferSize;

      if ( pNdr64Flags->ServerMustSize )
         {
         Ndr64pSizing( pStubMsg,
                       FALSE );  //server
         }

      // Get buffer.

      NdrStubGetBuffer( (IRpcStubBuffer *)pAsyncMsg->pThis,
                        pStubMsg->pRpcChannelBuffer,
                        pStubMsg );

      // Marshalling pass.
      Ndr64pServerMarshal ( pStubMsg );

      if ( pRpcMsg->BufferLength <
           (uint)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer) )
         {
         NDR_ASSERT( 0, "Ndr64StubCall2 marshal: buffer overflow!" );
         RpcRaiseException( RPC_X_BAD_STUB_DATA );
         }

      pRpcMsg->BufferLength = (ulong)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer);

      // We don't drop to the runtime like for synchronous calls,
      // we send the last buffer explicitly.

      fParamsFreed = TRUE;
      // see comment on async.cxx on why we call this twice.

      Ndr64pAsyncDCOMFreeParams( pAsyncMsg );

      NdrpDcomAsyncSend( pStubMsg,
                         0 );  // server doesn't pass pSynchronize back to channel.
   }
   RpcFinally
   {
      // Don't free parameters if we died because of bad stub data in unmarshaling.

      if ( ! pAsyncMsg->Flags.BadStubData && !fParamsFreed)
         {

         Ndr64pAsyncDCOMFreeParams( pAsyncMsg );

         }

      if ( pAsyncMsg->Flags.ErrorPending )
         hr = NdrHrFromWin32Error( pAsyncMsg->ErrorCode );
      else
         hr = S_OK;

      // If we are here, error or not, it means that we can (and need to) dispose of
      // the async context information

      NdrpAsyncStubMsgDestructor( pAsyncSB );

      // The engine never addrefs or releases the call object.
   }
   RpcEndFinally

   return hr;
}

HRESULT
Ndr64pSetupBeginStubCall(
                      CStdAsyncStubBuffer *   pAsyncSB,
                      NDR_PROC_CONTEXT *      pContext,
                      REFIID                  riid )
/*
    This method creates and initializes async msg.

*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;
   HRESULT                     hr = S_OK;


   if ( pAsyncSB->CallState.pAsyncMsg != 0  ||
        pAsyncSB->CallState.Flags.BeginStarted )
      hr = E_FAIL;
   else
      {
      pAsyncMsg = (NDR_DCOM_ASYNC_MESSAGE*)
                  I_RpcBCacheAllocate( sizeof( NDR_DCOM_ASYNC_MESSAGE) +
                                       pContext->StackSize + NDR_ASYNC_GUARD_SIZE );
      if ( ! pAsyncMsg )
         hr = E_OUTOFMEMORY;
      }

   if ( ! SUCCEEDED(hr) )
      {
      // The stub never signals.

      pAsyncSB->CallState.Flags.BeginError = 1;
      pAsyncSB->CallState.Hr = hr;
      return hr;
      }

   // Initialize the async message properly

   MIDL_memset( pAsyncMsg, 0x0, sizeof( NDR_DCOM_ASYNC_MESSAGE) );

   pAsyncMsg->Signature = NDR_DCOM_ASYNC_SIGNATURE;
   pAsyncMsg->Version   = NDR_DCOM_ASYNC_VERSION;
   pAsyncMsg->SyntaxType = XFER_SYNTAX_NDR64;

   memcpy( &pAsyncMsg->ProcContext, pContext, offsetof( NDR_PROC_CONTEXT, AllocateContext ) );
   NdrpAllocaInit( &pAsyncMsg->ProcContext.AllocateContext );

   
   pAsyncMsg->ProcContext.StartofStack = (uchar *) & pAsyncMsg->AppStack;
   pAsyncMsg->BeginStack   = (uchar *) & pAsyncMsg->AppStack;
   pAsyncMsg->BeginStackSize = pContext->StackSize;
   pAsyncMsg->StubPhase    = STUB_UNMARSHAL;
   pAsyncMsg->StubMsg.pContext  = &pAsyncMsg->ProcContext;

   // Server: zero out stack for allocs.
   MIDL_memset( & pAsyncMsg->AppStack, 0x0, pContext->StackSize );

   MIDL_memset( ((char *)& pAsyncMsg->AppStack) + pContext->StackSize,
                0x71,
                NDR_ASYNC_GUARD_SIZE );

   pAsyncSB->CallState.pAsyncMsg = pAsyncMsg;
   pAsyncSB->CallState.Flags.BeginStarted = 1;
   pAsyncMsg->pAsyncSB = pAsyncSB;

   return S_OK;
}

HRESULT
MulNdrpSetupFinishClientCall(
                         CStdAsyncProxyBuffer *  pAsyncPB,
                         void *                  StartofStack,
                         REFIID                  riid,
                         unsigned long           FinishProcNum,
                         NDR_PROC_CONTEXT    *   pContext )
/*
    This method creates and initializes async msg.
*/
{
   PNDR_DCOM_ASYNC_MESSAGE  pAsyncMsg;
   HRESULT                  hr = S_OK;

   hr = NdrpValidateAsyncProxyCall( pAsyncPB );
   if ( ! SUCCEEDED(hr) )
      return hr;

   if ( !pAsyncPB->CallState.Flags.BeginStarted  ||
        !pAsyncPB->CallState.Flags.BeginDone     ||
        pAsyncPB->CallState.Flags.FinishStarted )
      return E_FAIL;

   pAsyncMsg = 
       (NDR_DCOM_ASYNC_MESSAGE*)pAsyncPB->CallState.pAsyncMsg;

      
   hr = NdrpValidateDcomAsyncMsg( pAsyncMsg );
   if ( ! SUCCEEDED(hr) )
      return hr;

   if ( (FinishProcNum + 3)/2  != (pAsyncMsg->RpcMsg.ProcNum & 0x7fff) )
      return E_FAIL;

   // return S_FALSE in SYNTAX_DCE: we'll call into 
   // NdrpDcomFinishClientCall
   if ( pAsyncMsg->SyntaxType == XFER_SYNTAX_DCE )
      return S_OK;
      
   pAsyncMsg->ProcContext.StartofStack = (uchar *) StartofStack;
   pAsyncMsg->FinishStack  = (uchar *) StartofStack;
   pAsyncMsg->FinishStackSize = pContext->StackSize;
   pAsyncMsg->StubPhase    = NDR_ASYNC_PREP_PHASE;

   // Dont allocate or copy the new stack anywhere.

   pAsyncPB->CallState.Flags.FinishStarted = 1;

   return S_OK;
}

HRESULT
MulNdrpSetupBeginClientCall(
                        CStdAsyncProxyBuffer *  pAsyncPB,
                        void *                  StartofStack,
                        NDR_PROC_CONTEXT *      pContext,
                        REFIID                  riid )
/*
    This method creates and initializes async msg.
*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;
   HRESULT                     hr = S_OK;

   hr = NdrpValidateAsyncProxyCall( pAsyncPB );
   if ( ! SUCCEEDED(hr) )
      return hr;

   if ( pAsyncPB->CallState.pAsyncMsg != 0  ||
        pAsyncPB->CallState.Flags.BeginStarted )
      return E_FAIL;

   // Do this first to simplify error conditions.

   pAsyncMsg = (NDR_DCOM_ASYNC_MESSAGE*)
               I_RpcBCacheAllocate( sizeof(NDR_DCOM_ASYNC_MESSAGE) +
                                    pContext->StackSize + NDR_ASYNC_GUARD_SIZE );
   if ( ! pAsyncMsg )
      {
      NdrpAsyncProxySignal( pAsyncPB );
      return E_OUTOFMEMORY;
      }

   // Initialize the async message properly

   MIDL_memset( pAsyncMsg, 0x0, sizeof( NDR_DCOM_ASYNC_MESSAGE) );

   pAsyncMsg->Signature = NDR_DCOM_ASYNC_SIGNATURE;
   pAsyncMsg->Version   = NDR_DCOM_ASYNC_VERSION;

   pAsyncMsg->ProcContext.StartofStack = (uchar *) & pAsyncMsg->AppStack;
   pAsyncMsg->BeginStack   = (uchar *) & pAsyncMsg->AppStack;
   pAsyncMsg->BeginStackSize = pContext->StackSize;
   pAsyncMsg->StubPhase    = NDR_ASYNC_PREP_PHASE;

   RpcpMemoryCopy( & pAsyncMsg->ProcContext, pContext, offsetof( NDR_PROC_CONTEXT, AllocateContext ) );
   NdrpAllocaInit( &pAsyncMsg->ProcContext.AllocateContext );

   // Client: copy stack from the app's request call.
   RpcpMemoryCopy( & pAsyncMsg->AppStack, StartofStack, pContext->StackSize );

   MIDL_memset( ((char *)& pAsyncMsg->AppStack) + pContext->StackSize,
                0x71,
                NDR_ASYNC_GUARD_SIZE );

   pAsyncMsg->pAsyncPB = pAsyncPB;
   pAsyncMsg->StubMsg.pContext = &pAsyncMsg->ProcContext;
   pAsyncPB->CallState.Flags.BeginStarted = 1;
   pAsyncPB->CallState.pAsyncMsg          = pAsyncMsg;

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\asyncu64.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name :

    asyncu.h

Abstract :

    This file contains the ndr async uuid implementation.

Author :

    Ryszard K. Kott     (ryszardk)    Oct 1997

Revision History :

---------------------------------------------------------------------*/

#ifndef  __ASYNCU64_H__
#define  __ASYNCU64_H__
#include "asyncu.h"


RPC_STATUS
NdrpFinishDcomAsyncClientCall(
                             PMIDL_STUB_DESC     pStubDescriptor,
                             PFORMAT_STRING      pFormat,
                             unsigned char  *    StartofStack
                             );

HRESULT
MulNdrpSetupBeginClientCall( 
    CStdAsyncProxyBuffer *  pAsyncPB,
    void *                  StartofStack,
    NDR_PROC_CONTEXT *      pContext,
    REFIID                  riid );

HRESULT
MulNdrpSetupFinishClientCall( 
    CStdAsyncProxyBuffer *  pAsyncPB,
    void *                  StartofStack,
    REFIID                  riid,
    unsigned long           AsyncProcNum,
    NDR_PROC_CONTEXT    *   pContext);

HRESULT
Ndr64pSetupBeginStubCall( 
    CStdAsyncStubBuffer *   pAsyncSB,
    NDR_PROC_CONTEXT *      pContext,
    REFIID                  riid );

HRESULT
Ndr64pSetupFinishStubCall( 
    CStdAsyncStubBuffer *   pAsyncSB,
    unsigned long           StackSize,
    REFIID                  riid );

HRESULT
Ndr64pBeginDcomAsyncStubCall(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    ulong *                     pdwStubPhase );

ULONG STDMETHODCALLTYPE
Ndr64pAsyncProxyAddRef( 
    CStdAsyncProxyBuffer *  pAsyncPB );

ULONG STDMETHODCALLTYPE
Ndr64pAsyncProxyRelease( 
    CStdAsyncProxyBuffer *  pAsyncPB );

HRESULT
Ndr64pAsyncProxyLock( 
    CStdAsyncProxyBuffer *  pAsyncPB );

void
Ndr64pAsyncProxyUnlock( 
    CStdAsyncProxyBuffer *  pAsyncPB );

HRESULT
Ndr64pAsyncProxyCleanup( 
    CStdAsyncProxyBuffer *  pAsyncPB );

HRESULT
Ndr64pSetupBeginServerCall( 
    CStdAsyncStubBuffer *   pAsyncPB,
    void *                  StartofStack,
    unsigned short          StackSize,
    REFIID                  riid );


void
Ndr64pCloneInOutArgs( 
    NDR_DCOM_ASYNC_MESSAGE * pAsyncMsg, 
    PPARAM_DESCRIPTION       FinishParams,
    int                      FinishParamCount ); 

void
Ndr64pFreeDcomAsyncMsg( 
    PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg );


HRESULT
Ndr64pAsyncStubSignal(
    CStdAsyncStubBuffer *  pAsyncSB );


HRESULT
Ndr64pAsyncStubAddRef( 
    CStdAsyncStubBuffer *  pAsyncSB );

ULONG STDMETHODCALLTYPE
Ndr64pAsyncStubRelease( 
    CStdAsyncStubBuffer *  pAsyncSB );

HRESULT
Ndr64pAsyncStubLock( 
    CStdAsyncStubBuffer *  pAsyncSB );

void
Ndr64pAsyncStubUnlock( 
    CStdAsyncStubBuffer *  pAsyncSB );

HRESULT
Ndr64pAsyncStubCleanup( 
    CStdAsyncStubBuffer *  pAsyncSB );


BOOL
Ndr64pDcomAsyncSend(
    PMIDL_STUB_MESSAGE  pStubMsg,
    ISynchronize *      pSynchronize );

BOOL
Ndr64pDcomAsyncClientSend(
    PMIDL_STUB_MESSAGE  pStubMsg,
    IUnknown *          punkOuter );

void
Ndr64DcomAsyncReceive(
    PMIDL_STUB_MESSAGE  pStubMsg );


#define NdrHrFromWin32Error( exc )  NdrStubErrorHandler( exc )

#endif  // __ASYNCU64_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\asyndr64.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996 - 2000 Microsoft Corporation

Module Name :

    asyncndr.h

Abstract :

    This file contains the ndr async related definitions.

Author :

    Ryszard K. Kott     (ryszardk)    Nov 1996

Revision History :

---------------------------------------------------------------------*/

#ifndef  __ASYNCNDR64_H__
#define  __ASYNCNDR64_H__

#include "asyncndr.h"
#define RPC_ASYNC_CURRENT_VERSION     RPC_ASYNC_VERSION_1_0


RPC_STATUS
Ndr64pCompleteAsyncCall (
    IN PRPC_ASYNC_STATE     AsyncHandle,
    IN PNDR_ASYNC_MESSAGE   pAsyncMsg,
    IN void *               pReply
    );

RPC_STATUS
Ndr64pCompleteAsyncClientCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    IN PNDR_ASYNC_MESSAGE       pAsyncMsg,
    void *                      pReturnValue
    );

RPC_STATUS
Ndr64pCompleteAsyncServerCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    IN PNDR_ASYNC_MESSAGE       pAsyncMsg,
    void *                      pReturnValue
    );

RPC_STATUS
Ndr64pAsyncAbortCall(
    PRPC_ASYNC_STATE   AsyncHandle,
    PNDR_ASYNC_MESSAGE pAsyncMsg,
    unsigned long      ExceptionCode,
    BOOL               bFreeParams
    );
 

#endif  // __ASYNCNDR64_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\expr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    expr.cxx

Abstract :

    This file contains the ndr expression evaluation and correlation
    check routines.

Author :

    Yong Qu     (yongqu)    Jan 2000
    Mike Zoran  (mzoran)    Jan 2000

Revision History :

---------------------------------------------------------------------*/

#include "precomp.hxx"
#include "..\..\ndr20\ndrole.h"
#include "asyncu.h"
       
extern "C" {
extern const GUID CLSID_RpcHelper;
}

typedef void ( * PFNNDR64CHECKCORRELATION )(
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE            ExpressionType  );

PFNNDR64CHECKCORRELATION pfnCorrCheck[] = 
{
    Ndr64pLateCheckCorrelation,
    Ndr64pEarlyCheckCorrelation,
    Ndr64pNoCheckCorrelation,
    Ndr64pNoCheckCorrelation
};

EXPR_VALUE 
Ndr64pExprGetVar( PMIDL_STUB_MESSAGE pStubMsg,
                  PNDR64_FORMAT pFormat,
                  PNDR64_FORMAT * pNext )
{
    NDR64_EXPR_VAR * pExpr = (NDR64_EXPR_VAR *)pFormat;

    NDR_ASSERT( pExpr->ExprType == FC_EXPR_VAR, "must be a variable!");
    
    uchar *pCount = pStubMsg->pCorrMemory + pExpr->Offset;

    EXPR_VALUE Value = 
        Ndr64pSimpleTypeToExprValue( pExpr->VarType,
                                       pCount ); 

    *pNext = 
        (PNDR64_FORMAT)((PFORMAT_STRING)pFormat + sizeof( NDR64_EXPR_VAR ));
    
    return Value;
}

EXPR_VALUE EvaluateExpr( PMIDL_STUB_MESSAGE pStubMsg, 
                         PNDR64_FORMAT pFormat,
                         PNDR64_FORMAT * pNext );



EXPR_VALUE 
Ndr64CalculateExpr( PMIDL_STUB_MESSAGE pStubMsg,
                    NDR64_EXPR_OPERATOR * pExpr,
                    PNDR64_FORMAT *pNext )
{
    EXPR_VALUE   Value, LeftValue, RightValue ;
    PNDR64_FORMAT pTempNext;
    BOOL    fRational;

    switch ( pExpr->Operator )
        {
        case OP_UNARY_PLUS:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext );
            Value = +Value;
            break;

        case OP_UNARY_MINUS:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = -Value;
            break;

        case OP_UNARY_NOT:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = !Value;
            break;
            
        case OP_UNARY_COMPLEMENT:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = ~Value;
            break;
            
        case OP_UNARY_CAST:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = Ndr64pCastExprValueToExprValue( pExpr->CastType, Value );
            break;

        case OP_UNARY_AND:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = ~Value;
            break;

        case OP_UNARY_SIZEOF:
            NDR_ASSERT(0 , "Ndr64CalculateExpr : OP_UNARY_SIZEOF is invalid\n");
            return 0;
            break;

        case OP_UNARY_INDIRECTION:
            Value = Ndr64pExprGetVar( pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext );
            Value = Ndr64pSimpleTypeToExprValue( pExpr->CastType,
                                                 (uchar*)Value );             
            break;
            
        case OP_PRE_INCR:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = ++Value;
            break;
            
        case OP_PRE_DECR:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = --Value;
            break;
            
        case OP_POST_INCR:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = Value++;
            break;
            
        case OP_POST_DECR:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = Value--;
            break;
            

        case OP_PLUS:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue + RightValue;
            break;
            
        case OP_MINUS:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue - RightValue;
            break;
            
        case OP_STAR:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue * RightValue;
            break;           
        
        case OP_SLASH:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = (EXPR_VALUE) (LeftValue / RightValue);
            break;
            
        case OP_MOD:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue % RightValue;
            break;
                  
        case OP_LEFT_SHIFT:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue << RightValue;
            break;
            
        case OP_RIGHT_SHIFT:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue >> RightValue;
            break;
            
        case OP_LESS:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue + RightValue;
            break;
            
        
        case OP_LESS_EQUAL:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue <= RightValue;
            break;
            
        case OP_GREATER_EQUAL:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue >= RightValue;
            break;
            
        case OP_GREATER:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue > RightValue;
            break;
            
        case OP_EQUAL:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue == RightValue;
            break;
            
        case OP_NOT_EQUAL:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue != RightValue;
            break;
            

        case OP_AND:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue & RightValue;
            break;
            
        case OP_OR:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue | RightValue;
            break;
            
        case OP_XOR:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue ^ RightValue;
            break;
            
        case OP_LOGICAL_AND:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue && RightValue;
            break;
            
        case OP_LOGICAL_OR:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue || RightValue;
            break;
            
 
        case OP_QM:   
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , &pTempNext  );
            fRational = ( BOOL ) EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = fRational ? LeftValue : RightValue;
            break;
            
        case OP_ASYNCSPLIT:
            {
            PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg =  
                (PNDR_DCOM_ASYNC_MESSAGE) pStubMsg->pAsyncMsg;
            CORRELATION_CONTEXT CorrCtxt( pStubMsg, pAsyncMsg->BeginStack );
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            break;
            }

        case OP_CORR_POINTER:
            pStubMsg->pCorrMemory = pStubMsg->Memory;
            break;

        case OP_CORR_TOP_LEVEL:
            pStubMsg->pCorrMemory = pStubMsg->StackTop;
            break;

        default:
            NDR_ASSERT(0 ,
                   "Ndr64CalculateExpr : invalid operator");
            
        }

    return Value;
}

EXPR_VALUE
EvaluateExpr( PMIDL_STUB_MESSAGE pStubMsg, 
              PNDR64_FORMAT pFormat,
              PNDR64_FORMAT  * pNext )
{
    EXPR_VALUE Value;
    
    switch ( *(PFORMAT_STRING)pFormat )
        {
        case FC_EXPR_NOOP:
            {
            PFORMAT_STRING pContinueFormat =
                ((PFORMAT_STRING)pFormat) + (( NDR64_EXPR_NOOP *)pFormat )->Size;
            Value = EvaluateExpr( pStubMsg, (PNDR64_FORMAT)pContinueFormat, pNext );
            break;
            }
            
        case FC_EXPR_CONST32:
            {
            NDR64_EXPR_CONST32 *pExpr = ( NDR64_EXPR_CONST32 *) pFormat;
            Value = (EXPR_VALUE) pExpr->ConstValue;
            *pNext = (PNDR64_FORMAT)(pExpr + 1);
            break;
            }
        case FC_EXPR_CONST64:
            {
            NDR64_EXPR_CONST64 *pExpr;
            pExpr = ( NDR64_EXPR_CONST64 * )pFormat;
            Value = (EXPR_VALUE) pExpr->ConstValue;
            *pNext = (PNDR64_FORMAT)(pExpr + 1);
            break;
            }
        case FC_EXPR_VAR:
            {
            NDR64_EXPR_VAR * pExpr = ( NDR64_EXPR_VAR * )pFormat;
            Value = Ndr64pExprGetVar( pStubMsg, pFormat, pNext );     // indirection. 
            break;
            }
        case FC_EXPR_OPER:
            {
            Value = Ndr64CalculateExpr( pStubMsg, ( NDR64_EXPR_OPERATOR * )pFormat, pNext );
            break;
            }
        default:
            NDR_ASSERT(0 ,
                   "Ndr64pComputeConformance : no expr eval routines");
        }
    return Value;
}


EXPR_VALUE   
Ndr64EvaluateExpr(
    PMIDL_STUB_MESSAGE  pStubMsg,
//    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE            ExpressionType )
{   
    PNDR64_FORMAT pNext;
    EXPR_VALUE Value;
    
    NDR_ASSERT( pStubMsg->pCorrMemory, "Ndr64EvaluateExpr: pCorrMemory not initialized." );

    // we don't need to care about correlation flag in evaluation
    PFORMAT_STRING pActualFormat =
        ((PFORMAT_STRING)pFormat) + sizeof( NDR64_UINT32 );

    Value = EvaluateExpr( pStubMsg, (PNDR64_FORMAT)pActualFormat, &pNext );

    switch ( ExpressionType )
        {
        case EXPR_MAXCOUNT:
            pStubMsg->MaxCount = (ULONG_PTR)Value;
            break;
        case EXPR_ACTUALCOUNT:
            pStubMsg->ActualCount = ( unsigned long )Value;
            break;
        case EXPR_OFFSET:
            pStubMsg->Offset = ( unsigned long )Value;
            break;
        }

    return Value;
}

void
Ndr64pAddCorrelationData( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    EXPR_VALUE          Value,
    NDR64_EXPRESSION_TYPE                 CheckKind 
    )
/* 
    Adds a check data to the correlation data base for a later evaluation.
*/  
{
    PNDR64_CORRELATION_INFO  pCorrInfo = (PNDR64_CORRELATION_INFO)pStubMsg->pCorrInfo;

    if ( !pCorrInfo || NDR64_SLOTS_PER_CORRELATION_INFO == pCorrInfo->SlotsUsed )
        {
        NDR_PROC_CONTEXT *pProcContext = (NDR_PROC_CONTEXT*)pStubMsg->pContext;

        PNDR64_CORRELATION_INFO pCorrInfoNew = (PNDR64_CORRELATION_INFO)
            NdrpAlloca(&pProcContext->AllocateContext, sizeof(NDR64_CORRELATION_INFO));

        pCorrInfoNew->pNext     = pCorrInfo;
        pCorrInfoNew->SlotsUsed = 0;
        pCorrInfo = pCorrInfoNew;
        pStubMsg->pCorrInfo = (PNDR_CORRELATION_INFO)pCorrInfo;
        }

    NDR64_UINT32 CurrentSlot = pCorrInfo->SlotsUsed;

    pCorrInfo->Data[ CurrentSlot ].pMemoryObject = pMemory; 
    pCorrInfo->Data[ CurrentSlot ].Value         = Value; 
    pCorrInfo->Data[ CurrentSlot ].pCorrDesc     = pFormat; 
    pCorrInfo->Data[ CurrentSlot ].CheckKind     = CheckKind;

    pCorrInfo->SlotsUsed++;
}

RPCRTAPI
void
RPC_ENTRY
Ndr64CorrelationPass( 
    PMIDL_STUB_MESSAGE  pStubMsg
    )
/* 
    Walks the data base to check all the correlated values that could not be checked 
    on fly.
*/  
{
    
    if ( !pStubMsg->pCorrInfo )
        {
        return;
        }

    for( PNDR64_CORRELATION_INFO  pCorrInfo = (PNDR64_CORRELATION_INFO)pStubMsg->pCorrInfo;
         NULL != pCorrInfo;
         pCorrInfo = pCorrInfo->pNext )
        {

        for(NDR64_UINT32 SlotNumber = 0; SlotNumber < pCorrInfo->SlotsUsed; SlotNumber++)
            {

            CORRELATION_CONTEXT CorrCtxt( pStubMsg, pCorrInfo->Data[ SlotNumber ].pMemoryObject );
            
            // we must check now.
            Ndr64pEarlyCheckCorrelation( pStubMsg,
                                     pCorrInfo->Data[ SlotNumber ].Value,
                                     pCorrInfo->Data[ SlotNumber ].pCorrDesc,
                                     (NDR64_EXPRESSION_TYPE)pCorrInfo->Data[ SlotNumber ].CheckKind );
            }

        }
    
}

// no-check flag is set.
void Ndr64pNoCheckCorrelation( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE  ExpressionType  )
{
    return;
}

void Ndr64pEarlyCheckCorrelation(
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE            ExpressionType  )
{
    EXPR_VALUE  ExprValue ;
    EXPR_VALUE  DestValue = Value;
    BOOL        fCheckOk; 
    
    ExprValue = Ndr64EvaluateExpr( pStubMsg, pFormat, ExpressionType );
    fCheckOk = ( DestValue == ExprValue );

    if ( !fCheckOk && ( ExpressionType == EXPR_IID ) )
        {
        IID * piidValue = (IID *)ExprValue;
        IID * piidArg   = (IID *)DestValue;
        
        fCheckOk = !memcmp( piidValue, piidArg, sizeof( IID )) ;
        }

    if ( !fCheckOk )
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        
    return;
}

void Ndr64pLateCheckCorrelation(
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE            ExpressionType  )
{
    Ndr64pAddCorrelationData( pStubMsg, pStubMsg->pCorrMemory, pFormat, Value, ExpressionType );
    return;
}

void 
Ndr64pCheckCorrelation(
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE            ExpressionType  )
{
    NDR64_UINT32 Flags;

    Flags = * (NDR64_UINT32 *)pFormat;
    ASSERT(  Flags <= ( FC_NDR64_EARLY_CORRELATION | FC_NDR64_NOCHECK_CORRELATION ) );

    pfnCorrCheck[Flags]( pStubMsg, Value, pFormat, ExpressionType );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\auxilary.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    auxilary.cxx

Abstract :

    This file contains auxilary routines used for initialization of the
    RPC and stub messages and the offline batching of common code sequences
    needed by the stubs.

Author :

    David Kays  dkays   September 1993.

Revision History :

  ---------------------------------------------------------------------*/
#include "precomp.hxx"
#include "..\..\ndr20\ndrole.h"
#include "asyncndr.h"
#include "auxilary.h"


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Static data for NS library operations
  ---------------------------------------------------------------------*/

#pragma code_seg(".ndr64")

void
MakeSureWeHaveNonPipeArgs(
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       BufferSize );

void
EnsureNSLoaded();

void
Ndr64ClientInitialize(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUBLESS_PROXY_INFO           pProxyInfo,
    unsigned int                        ProcNum )
/*++

Routine Description :

    This routine is called by client side stubs to initialize the RPC message
    and stub message, and to get the RPC buffer.

Arguments :

    pRpcMsg          - pointer to RPC message structure
    pStubMsg         - pointer to stub message structure
    pStubDescriptor  - pointer to stub descriptor structure
    ProcNum          - remote procedure number

--*/
{
    //
    // Initialize RPC message fields.
    //
    // The leftmost bit of the procnum field is supposed to be set to 1 inr
    // order for the runtime to know if it is talking to the older stubs or
    // not.
    //

    NDR_PROC_CONTEXT * pContext = ( NDR_PROC_CONTEXT *) pStubMsg->pContext ;
    memset ( pRpcMsg, 0, sizeof( RPC_MESSAGE ) );
    pRpcMsg->RpcInterfaceInformation = pProxyInfo->pStubDesc->
                                        RpcInterfaceInformation;

    // default transfer syntax 
    if ( pProxyInfo->pTransferSyntax )
        pRpcMsg->TransferSyntax = pProxyInfo->pTransferSyntax;
    else
        pRpcMsg->TransferSyntax = (PRPC_SYNTAX_IDENTIFIER)&NDR_TRANSFER_SYNTAX;
        
//#if !defined(__RPC_WIN64__)
    pRpcMsg->ProcNum = ProcNum | RPC_FLAGS_VALID_BIT;
//#endif    

    //
    // Initialize the Stub messsage fields.
    //

    memset( pStubMsg, 0, sizeof(MIDL_STUB_MESSAGE) );

    pStubMsg->RpcMsg = pRpcMsg;

    pStubMsg->StubDesc = pProxyInfo->pStubDesc;

    pStubMsg->pfnAllocate = pProxyInfo->pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pProxyInfo->pStubDesc->pfnFree;

    pStubMsg->dwDestContext = MSHCTX_DIFFERENTMACHINE;
    pStubMsg->pContext = pContext;
    pStubMsg->StackTop = pContext->StartofStack;

    pStubMsg->IsClient = TRUE;
    
    NdrSetupLowStackMark( pStubMsg );

    if ( pProxyInfo->pStubDesc->pMallocFreeStruct )
        {
        MALLOC_FREE_STRUCT *pMFS = pProxyInfo->pStubDesc->pMallocFreeStruct;

        NdrpSetRpcSsDefaults(pMFS->pfnAllocate, pMFS->pfnFree);
        }

    // This exception should be raised after initializing StubMsg.

    if ( pProxyInfo->pStubDesc->Version > NDR_VERSION )
        {
        NDR_ASSERT( 0, "ClientInitialize : Bad version number" );

        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
        }

    // This is where we would need to deal with initializing StubMsg fields 
    // added after NT 5.1 release, if we added them.
}

inline void 
Ndr64ServerInitializeCommon(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor )
/*++

Routine Description :

    This routine is called by the server stubs before unmarshalling.
    It initializes the stub message fields.

Aruguments :

    pStubMsg        - pointer to the stub message structure
    pStubDescriptor - pointer to the stub descriptor structure

Note :

    This is a core server-side initializer, called by everybody,
    pipes or not.

--*/
{
    NDR_PROC_CONTEXT * pContext = ( NDR_PROC_CONTEXT *) pStubMsg->pContext ;   

    memset( pStubMsg, 0, sizeof( MIDL_STUB_MESSAGE ) );
    
    pStubMsg->dwDestContext = MSHCTX_DIFFERENTMACHINE;

    //
    // Set BufferStart and BufferEnd before unmarshalling.
    // Ndr64PointerFree uses these values to detect pointers into the
    // rpc message buffer.
    //
    pStubMsg->BufferStart = (uchar*)pRpcMsg->Buffer;
    pStubMsg->BufferEnd   = pStubMsg->BufferStart + pRpcMsg->BufferLength;

    pStubMsg->pfnAllocate = pStubDescriptor->pfnAllocate;
    pStubMsg->pfnFree     = pStubDescriptor->pfnFree;
    pStubMsg->ReuseBuffer = FALSE;

    pStubMsg->StubDesc = pStubDescriptor;

    pStubMsg->RpcMsg = pRpcMsg;
    pStubMsg->Buffer = (uchar*)pRpcMsg->Buffer;
    pStubMsg->pContext = pContext;
    pStubMsg->StackTop = pContext->StartofStack;
    
    NdrSetupLowStackMark( pStubMsg );

    if ( pStubDescriptor->pMallocFreeStruct )
        {
        MALLOC_FREE_STRUCT *pMFS = pStubDescriptor->pMallocFreeStruct;

        NdrpSetRpcSsDefaults(pMFS->pfnAllocate, pMFS->pfnFree);
        }

    // This exception should be raised after initializing StubMsg.
    NdrRpcSetNDRSlot( pStubMsg );

    if ( pStubDescriptor->Version > NDR_VERSION )
        {
        NDR_ASSERT( 0, "ServerInitialize : bad version number" );

        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
        }

    // This is where we would need to deal with initializing StubMsg fields 
    // added after NT 5.1 release, if we added them.
}

void 
Ndr64ServerInitializePartial(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned long           RequestedBufferSize )
/*++

Routine Description :

    This routine is called by the server stubs for pipes.
    It is almost identical to Ndr64ServerInitializeNew, except that
    it calls Ndr64pServerInitialize.

Aruguments :

    pStubMsg        - pointer to the stub message structure
    pStubDescriptor - pointer to the stub descriptor structure
    pBuffer         - pointer to the beginning of the RPC message buffer

--*/
{
    Ndr64ServerInitializeCommon( pRpcMsg,
                                 pStubMsg,
                                 pStubDescriptor );

    // Last but not least...

    MakeSureWeHaveNonPipeArgs( pStubMsg, RequestedBufferSize );

}


unsigned char *
Ndr64ServerInitialize(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor
    )
/*++

Routine Description :

    This routine is called by the server stubs before unmarshalling.
    It initializes the stub message fields.

Aruguments :

    pStubMsg        - pointer to the stub message structure
    pStubDescriptor - pointer to the stub descriptor structure

Note.
    Ndr64ServerInitializeNew is almost identical to Ndr64ServerInitializePartial.
    Ndr64ServerInitializeNew is generated for non-pipes and is backward comp.
    Ndr64ServerInitializePartial is generated for routines with pipes args.

--*/
{
    Ndr64ServerInitializeCommon( pRpcMsg,
                                 pStubMsg,
                                 pStubDescriptor );

    if ( !(pRpcMsg->RpcFlags & RPC_BUFFER_COMPLETE ) )
        {
        // A non-pipe call with an incomplete buffer.
        // This can happen only for non-pipe calls in an interface that
        // has some pipe calls. 

        RPC_STATUS Status;

        pRpcMsg->RpcFlags = RPC_BUFFER_EXTRA;

        // The size argument is ignored, we will get everything.

        Status = I_RpcReceive( pRpcMsg, 0 );

        if ( Status != RPC_S_OK )
            {
            // This is the same behavior (and comment) as in MakeSure..
            //    routine above for non-pipe data case in a pipe call.
            // For this particular error case, i.e. a call to Receive to get 
            // all (non-pipe) data failing, we don't want to restore the 
            // original dispatch buffer into the rpc message.
            // In case of an error the buffer coming back here would be 0.
            //
            RpcRaiseException( Status );
            }

        NDR_ASSERT( 0 == pRpcMsg->BufferLength ||
                    NULL != pRpcMsg->Buffer,
                    "Rpc runtime returned an invalid buffer.");

        // In case this is a new buffer

        pStubMsg->Buffer      = (uchar*)pRpcMsg->Buffer;
        pStubMsg->BufferStart = (uchar*)pRpcMsg->Buffer;
        pStubMsg->BufferEnd   = pStubMsg->BufferStart + pRpcMsg->BufferLength;
        }

    return 0;
}


unsigned char *
Ndr64GetBuffer(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned long           BufferLength )
/*++

Routine Description :

    Performs an RpcGetBuffer.

Arguments :

    pStubMsg        - Pointer to stub message structure.
    BufferLength    - Length of requested rpc message buffer.
    Handle          - Bound handle.

--*/
{
    RPC_STATUS    Status;

    pStubMsg->RpcMsg->BufferLength = BufferLength;

    Status = I_RpcGetBuffer( pStubMsg->RpcMsg );

    if ( Status )
        {
        // For raw rpc, if async, don't call abort later.

        if ( pStubMsg->pAsyncMsg )
            pStubMsg->pAsyncMsg->Flags.RuntimeCleanedUp = 1;

        RpcRaiseException( Status );
        }

    NDR_ASSERT( 0 == BufferLength ||
                NULL != pStubMsg->RpcMsg->Buffer,
                "Rpc runtime returned an invalid buffer.");

    NDR_ASSERT( ! ((ULONG_PTR)pStubMsg->RpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned" );

    pStubMsg->Buffer = (uchar *) pStubMsg->RpcMsg->Buffer;
    pStubMsg->fBufferValid = TRUE;

    return pStubMsg->Buffer;
}


unsigned char *
Ndr64NsGetBuffer( PMIDL_STUB_MESSAGE    pStubMsg,
                unsigned long         BufferLength )
/*++
Routine Description :

    Performs an RpcNsGetBuffer.
    Will load the RpcNs4 DLL if not already loaded

Arguments :

    pStubMsg        - Pointer to stub message structure.
    BufferLength    - Length of requested rpc message buffer.
    Handle          - Bound handle

--*/
{
    RPC_STATUS    Status;

    EnsureNSLoaded();

    pStubMsg->RpcMsg->BufferLength = BufferLength;

    Status = (*pRpcNsGetBuffer)( pStubMsg->RpcMsg );

    if ( Status )
        RpcRaiseException( Status );

    NDR_ASSERT( ! ((ULONG_PTR)pStubMsg->RpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned" );

    pStubMsg->Buffer = (uchar *) pStubMsg->RpcMsg->Buffer;
    pStubMsg->fBufferValid = TRUE;

    return pStubMsg->Buffer;
}

void
Ndr64pInitUserMarshalCB(
    MIDL_STUB_MESSAGE *pStubMsg,
    NDR64_USER_MARSHAL_FORMAT *    pUserFormat,
    USER_MARSHAL_CB_TYPE CBType,
    USER_MARSHAL_CB   *pUserMarshalCB
    )
/*++

Routine Description :

    Initialize a user marshall callback structure.
    
Arguments :

    pStubMsg         - Supplies the stub message for the call.
    pFormat          - Supplies the format string for the type(FC64_USER_MARSHAL). 
    CBType           - Supplies the callback type.   
    pUserMarshalCB   - Pointer to the callback to be initialized.

Return :

    None.

--*/
{

    pUserMarshalCB->Flags    = USER_CALL_CTXT_MASK( pStubMsg->dwDestContext );
    if ( USER_MARSHAL_CB_UNMARSHALL == CBType )
        {
        pUserMarshalCB->Flags |=
            (((pStubMsg->RpcMsg->DataRepresentation & (ulong)0x0000FFFF)) << 16 );  
        }
    if ( pStubMsg->pAsyncMsg )
        pUserMarshalCB->Flags |= USER_CALL_IS_ASYNC;
    if ( pStubMsg->fHasNewCorrDesc )
        pUserMarshalCB->Flags |= USER_CALL_NEW_CORRELATION_DESC;
    
    pUserMarshalCB->pStubMsg = pStubMsg;
    pUserMarshalCB->pReserve = ( pUserFormat->Flags & USER_MARSHAL_IID)  ? 
                                        (PFORMAT_STRING)pUserFormat + sizeof( NDR64_USER_MARSHAL_FORMAT )
                                        : 0;
    pUserMarshalCB->Signature = USER_MARSHAL_CB_SIGNATURE;
    pUserMarshalCB->CBType = CBType;

    pUserMarshalCB->pFormat = ( PFORMAT_STRING )pUserFormat;
    pUserMarshalCB->pTypeFormat = (PFORMAT_STRING)pUserFormat->TransmittedType;

}


#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\expr.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996 Microsoft Corporation

Module Name :

    expr.h

Abstract :

    This file contains code for ndr correlations.

Author :

    Ryszard K. Kott     (ryszardk)    Sep 1997

Revision History :

---------------------------------------------------------------------*/

#include "ndrp.h"

#if !defined(__EXPR_H__)
#define  __EXPR_H__

class CORRELATION_CONTEXT
{
    PMIDL_STUB_MESSAGE const pStubMsg;
    uchar * const pCorrMemorySave;
public:
    CORRELATION_CONTEXT(PMIDL_STUB_MESSAGE pCurStubMsg,
                        uchar *pNewContext ) :
        pStubMsg( pCurStubMsg ),
        pCorrMemorySave( pCurStubMsg->pCorrMemory )
    {
    pCurStubMsg->pCorrMemory = pNewContext;
    }
    ~CORRELATION_CONTEXT()
    {
        pStubMsg->pCorrMemory = pCorrMemorySave;
    }
};

typedef  __int64 EXPR_VALUE;

EXPR_VALUE
Ndr64EvaluateExpr(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE            ExpressionType );


typedef struct _NDR64_CORRELATION_INFO_DATA
    {
    unsigned char *                 pMemoryObject;
    PNDR64_FORMAT                   pCorrDesc;
    EXPR_VALUE                      Value;
    long                            CheckKind;
    } NDR64_CORRELATION_INFO_DATA;

#define NDR64_SLOTS_PER_CORRELATION_INFO 5

typedef struct _NDR64_CORRELATION_INFO
    {
    struct _NDR64_CORRELATION_INFO  *pNext;
    NDR64_UINT32                    SlotsUsed;
    NDR64_CORRELATION_INFO_DATA     Data[NDR64_SLOTS_PER_CORRELATION_INFO];
    } NDR64_CORRELATION_INFO, *PNDR64_CORRELATION_INFO;


void 
Ndr64pCheckCorrelation(
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE                 CheckKind );

void
Ndr64pAddCorrelationData( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    EXPR_VALUE          Value,
    NDR64_EXPRESSION_TYPE                 CheckKind );

void Ndr64pNoCheckCorrelation( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE  ExpressionType  );

void Ndr64pEarlyCheckCorrelation(
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE            ExpressionType  );

void Ndr64pLateCheckCorrelation(
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE            ExpressionType  );

void
Ndr64CorrelationPass(
    PMIDL_STUB_MESSAGE                  pStubMsg
    );

#endif // __EXPR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\bufsize.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 - 2000 Microsoft Corporation

Module Name :

    bufsize.c

Abstract :

    This file contains the routines called by MIDL 2.0 stubs and the 
    interpreter for computing the buffer size needed for a parameter.  

Author :

    David Kays  dkays   September 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "precomp.hxx"
#include "..\..\ndr20\ndrole.h"

void 
Ndr64UDTSimpleTypeSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Get the size a top level or embedded simple type.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data being sized.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    LENGTH_ALIGN( pStubMsg->BufferLength,
                  NDR64_SIMPLE_TYPE_BUFALIGN(*(PFORMAT_STRING)pFormat) );

    pStubMsg->BufferLength += NDR64_SIMPLE_TYPE_BUFSIZE(*(PFORMAT_STRING)pFormat);

    pMemory += NDR64_SIMPLE_TYPE_MEMSIZE(*(PFORMAT_STRING)pFormat);
}


void 
Ndr64pInterfacePointerBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for an interface pointer.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - The interface pointer being sized.
    pFormat     - Interface pointer's format string description.

Return :

    None.

    // wire representation of a marshalled interface pointer
    typedef struct tagMInterfacePointer
    {
        ULONG           ulCntData;          // size of data
        [size_is(ulCntData)] BYTE abData[]; // data (OBJREF)
    } MInterfacePointer;

--*/
{

    const NDR64_CONSTANT_IID_FORMAT *pConstInterfaceFormat =
        (NDR64_CONSTANT_IID_FORMAT*)pFormat;
    const NDR64_IID_FORMAT *pInterfaceFormat =
        (NDR64_IID_FORMAT*)pFormat;

    //
    // Get an IID pointer.
    //
    IID *piid;
    if ( ((NDR64_IID_FLAGS*)&pInterfaceFormat->Flags)->ConstantIID )
        {
        piid = (IID*)&pConstInterfaceFormat->Guid;
        }
    else
        {
        piid = (IID *) Ndr64EvaluateExpr( pStubMsg,
                                          pInterfaceFormat->IIDDescriptor,
                                          EXPR_IID );
        if(piid == 0)
            {
            RpcRaiseException( RPC_S_INVALID_ARG );
            }
        }

    // Allocate space for the length and array bounds.

    LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN );
    pStubMsg->BufferLength += sizeof(NDR64_WIRE_COUNT_TYPE);
    pStubMsg->BufferLength += sizeof(ulong);

    unsigned long size;
    HRESULT hr = (*pfnCoGetMarshalSizeMax)(&size, *piid, (IUnknown *)pMemory, 
                                           pStubMsg->dwDestContext, pStubMsg->pvDestContext, 0);
    if(FAILED(hr))
        {
        RpcRaiseException(hr);
        }

    pStubMsg->BufferLength += size;

}


__forceinline void 
Ndr64pPointerBufferSizeInternal( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Private routine for sizing a pointee.  This is the entry
    point for pointers embedded in structures, arrays, or unions.

    Used for FC64_RP, FC64_UP, FC64_FP, FC64_OP.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data being sized.
    pFormat     - Pointer's format string description.
    
    pStubMsg->BufferLength - ready for the pointee.

Return :

    None.

--*/
{   const NDR64_POINTER_FORMAT *pPointerFormat = (NDR64_POINTER_FORMAT*) pFormat;
    PFORMAT_STRING pPointeeFormat = (PFORMAT_STRING)pPointerFormat->Pointee;

    if ( ! pMemory )
        return;

    switch( pPointerFormat->FormatCode )
        {
        case FC64_IP:
            Ndr64pInterfacePointerBufferSize( pStubMsg,
                                              pMemory,
                                              pPointeeFormat
                                              );
            return;
        
        case FC64_FP:
            //
            // Check if we have already sized this full pointer.
            //
            if ( Ndr64pFullPointerQueryPointer( pStubMsg,
                                                pMemory,
                                                FULL_POINTER_BUF_SIZED,
                                                0 ) )
                return;

            break;

        default:
            break;
        }

    if ( NDR64_SIMPLE_POINTER( pPointerFormat->Flags ) )
        {
        // Pointer to simple type.
        LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_SIMPLE_TYPE_BUFALIGN(*pPointeeFormat));
        pStubMsg->BufferLength += NDR64_SIMPLE_TYPE_BUFSIZE(*pPointeeFormat);       
        return;
        }

    //
    // Pointer to complex type.
    //
    if ( NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
        pMemory = *((uchar **)pMemory);

    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    NDR64_RESET_EMBEDDED_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

    Ndr64TopLevelTypeSize( pStubMsg,
                           pMemory,
                           pPointeeFormat );
}
   
NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT::NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg, 
    uchar * const pMemoryNew,
    const PFORMAT_STRING pFormatNew) :

        pMemory(pMemoryNew),
        pFormat(pFormatNew),
        uFlags(pStubMsg->uFlags),
        pCorrMemory(pStubMsg->pCorrMemory)
{

}

void 
NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{
    SAVE_CONTEXT<uchar> uFlagsSave(pStubMsg->uFlags, uFlags );
    CORRELATION_CONTEXT CorrCtxt(pStubMsg, pCorrMemory); 

    Ndr64pPointerBufferSizeInternal( pStubMsg,
                                     pMemory,
                                     pFormat);
}                          

#if defined(DBG)
void 
NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT::Print() 
{
    DbgPrint("NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("uFlags:                  %x\n", uFlags );
    DbgPrint("pCorrMemory:             %p\n", pCorrMemory );
}
#endif

void
Ndr64pEnquePointerBufferSize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    NDR64_POINTER_CONTEXT PointerContext( pStubMsg );

    RpcTryFinally
        {
        NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT *pElement = 
            new(PointerContext.GetActiveState()) 
                NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                    pMemory,
                                                    (PFORMAT_STRING)pFormat);
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
        }
    RpcFinally
        {
        PointerContext.EndContext();
        }
    RpcEndFinally

}

void 
Ndr64pPointerBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    
    if (!NdrIsLowStack(pStubMsg))
        {
        Ndr64pPointerBufferSizeInternal( 
            pStubMsg,
            pMemory,
            pFormat );
        return;
        }

    Ndr64pEnquePointerBufferSize( 
        pStubMsg,
        pMemory,
        pFormat );
}


__forceinline void 
Ndr64TopLevelPointerBufferSize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    if ( *(PFORMAT_STRING)pFormat != FC64_RP )
        {
        LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_PTR_WIRE_ALIGN );

        pStubMsg->BufferLength += sizeof(NDR64_PTR_WIRE_TYPE);
        }

    Ndr64pPointerBufferSize( pStubMsg,
                             pMemory,
                             pFormat );
}

__forceinline void 
Ndr64EmbeddedPointerBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{

    LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_PTR_WIRE_ALIGN );
    pStubMsg->BufferLength += sizeof(NDR64_PTR_WIRE_TYPE);

    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext( pStubMsg );
    Ndr64pPointerBufferSize( pStubMsg,
                             *(uchar**)pMemory,
                             pFormat );
}


void 
Ndr64pRangeBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a simple type with range on it.
    Used for FC64_RANGE.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    const NDR64_RANGE_FORMAT * pRangeFormat =
        (const NDR64_RANGE_FORMAT*)pFormat;

    LENGTH_ALIGN( pStubMsg->BufferLength, NDR64_SIMPLE_TYPE_BUFALIGN(pRangeFormat->RangeType) );
    pStubMsg->BufferLength += NDR64_SIMPLE_TYPE_BUFSIZE(pRangeFormat->RangeType);
}


void 
Ndr64SimpleStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a simple structure.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    const NDR64_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_STRUCTURE_HEADER_FORMAT*) pFormat;

    LENGTH_ALIGN( pStubMsg->BufferLength, pStructFormat->Alignment );

    pStubMsg->BufferLength += pStructFormat->MemorySize;  
    
    if ( pStructFormat->Flags.HasPointerInfo ) 
        {

        CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );
        Ndr64pPointerLayoutBufferSize( pStubMsg,
                                       pStructFormat + 1,
                                       0,
                                       pMemory );

        }
}


void 
Ndr64ConformantStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a conformant structure.

    Used for FC64_CSTRUCT and FC64_CPSTRUCT.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    const NDR64_CONF_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_CONF_STRUCTURE_HEADER_FORMAT*) pFormat;
    
    const NDR64_CONF_ARRAY_HEADER_FORMAT * const pArrayFormat =  
        (NDR64_CONF_ARRAY_HEADER_FORMAT *)pStructFormat->ArrayDescription;
    
    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );

    if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        // Align and add size for conformance count.
        LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN);

        pStubMsg->BufferLength += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    
    // Align 
    LENGTH_ALIGN(pStubMsg->BufferLength, pStructFormat->Alignment );

    NDR64_WIRE_COUNT_TYPE MaxCount =
        Ndr64EvaluateExpr( pStubMsg,
                           pArrayFormat->ConfDescriptor, 
                           EXPR_MAXCOUNT );

    pStubMsg->BufferLength += pStructFormat->MemorySize + 
                              Ndr64pConvertTo2GB(MaxCount * 
                                                 (NDR64_UINT64)pArrayFormat->ElementSize );

    if ( pStructFormat->Flags.HasPointerInfo )  
        {

        Ndr64pPointerLayoutBufferSize( pStubMsg,
                                       pStructFormat + 1,
                                       (NDR64_UINT32)MaxCount,
                                       pMemory );
        }
}


void 
Ndr64ComplexStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a complex structure.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    const NDR64_BOGUS_STRUCTURE_HEADER_FORMAT *  pStructFormat =
        (NDR64_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;
    const NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT * pConfStructFormat =
        (NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;

    bool  fSetPointerBufferMark = !pStubMsg->IgnoreEmbeddedPointers &&
                                  !pStubMsg->PointerBufferMark;
    if ( fSetPointerBufferMark )
        {

        pStubMsg->IgnoreEmbeddedPointers = TRUE;
        ulong BufferLengthSave = pStubMsg->BufferLength;
        
        Ndr64ComplexStructBufferSize( 
            pStubMsg,
            pMemory,
            pFormat );

        // complex struct may not have a zero length
        NDR_ASSERT( pStubMsg->BufferLength, "Flat part of struct had a zero length!" );

        pStubMsg->IgnoreEmbeddedPointers = FALSE;
        pStubMsg->PointerBufferMark = (uchar*) ULongToPtr(pStubMsg->BufferLength);
        pStubMsg->BufferLength = BufferLengthSave;
        
        }

    PFORMAT_STRING  pFormatPointers = (PFORMAT_STRING) pStructFormat->PointerLayout;
    PFORMAT_STRING  pFormatArray = NULL;

    PFORMAT_STRING  pMemberLayout =  ( *(PFORMAT_STRING)pFormat == FC64_CONF_BOGUS_STRUCT ||
                                       *(PFORMAT_STRING)pFormat == FC64_FORCED_CONF_BOGUS_STRUCT ) ?
                                     (PFORMAT_STRING)( pConfStructFormat + 1) :
                                     (PFORMAT_STRING)( pStructFormat + 1);

    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );

    // Get conformant array description.
    if ( pStructFormat->Flags.HasConfArray )
        {
        pFormatArray = (PFORMAT_STRING)pConfStructFormat->ConfArrayDescription;

        // accounted for by the outermost embedding complex struct 
        if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
            {
            //
            // Align and add size of conformance count(s).
            //
            LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN );
        
            pStubMsg->BufferLength += pConfStructFormat->Dimensions * sizeof(NDR64_WIRE_COUNT_TYPE);

            NDR64_SET_CONF_MARK_VALID( pStubMsg->uFlags );
            }
        }
     else
        pFormatArray = 0;

     LENGTH_ALIGN(pStubMsg->BufferLength, pStructFormat->Alignment);
        
     //
     // Shallow size the structure member by member.
     //
     for ( ; ; ) 
         {
         switch ( *pMemberLayout ) 
             {
             
             case FC64_STRUCT:
             {
             const NDR64_SIMPLE_REGION_FORMAT *pRegion = 
                 (NDR64_SIMPLE_REGION_FORMAT*) pMemberLayout;
             
             LENGTH_ALIGN(pStubMsg->BufferLength, pRegion->Alignment );  
             pStubMsg->BufferLength += pRegion->RegionSize;

             pMemory          += pRegion->RegionSize;

             pMemberLayout    += sizeof( *pRegion );
             break;
             }

             case FC64_STRUCTPADN :
             {
             const NDR64_MEMPAD_FORMAT *pMemPad = (NDR64_MEMPAD_FORMAT*)pMemberLayout;
             pMemory        += pMemPad->MemPad;
             pMemberLayout  += sizeof(*pMemPad);
             break;
             }

             case FC64_POINTER :
             {
             
             Ndr64EmbeddedPointerBufferSize( 
                 pStubMsg,
                 pMemory,
                 pFormatPointers );

             pMemory                += PTR_MEM_SIZE;     
             
             pFormatPointers += sizeof(NDR64_POINTER_FORMAT);
             pMemberLayout += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);             
             break;
             }

             //
             // Embedded complex types.
             //
             case FC64_EMBEDDED_COMPLEX :
                 {
                 const NDR64_EMBEDDED_COMPLEX_FORMAT * pEmbeddedFormat =
                 (NDR64_EMBEDDED_COMPLEX_FORMAT*) pMemberLayout;

                 PFORMAT_STRING pTypeFormat = (PFORMAT_STRING)pEmbeddedFormat->Type;
                 
                 Ndr64EmbeddedTypeSize( pStubMsg,
                                        pMemory,
                                        pTypeFormat );

                 pMemory = Ndr64pMemoryIncrement( pStubMsg,
                                                  pMemory,
                                                  pTypeFormat,
                                                  FALSE );

                 pMemberLayout += sizeof( *pEmbeddedFormat );
                 break;
                 }

             case FC64_BUFFER_ALIGN:
                 { 
                 const NDR64_BUFFER_ALIGN_FORMAT *pBufAlign = 
                     (NDR64_BUFFER_ALIGN_FORMAT*) pMemberLayout;
                 LENGTH_ALIGN(pStubMsg->BufferLength, pBufAlign->Alignment);                 
                 pMemberLayout += sizeof( *pBufAlign );
                 break;
                 }

             //
             // simple types
             //
             case FC64_CHAR :
             case FC64_WCHAR :
             case FC64_INT8:
             case FC64_UINT8:
             case FC64_INT16:
             case FC64_UINT16:
             case FC64_INT32:
             case FC64_UINT32:
             case FC64_INT64:
             case FC64_UINT64:
             case FC64_FLOAT32 :
             case FC64_FLOAT64 :
             case FC64_ERROR_STATUS_T:
                 LENGTH_ALIGN( pStubMsg->BufferLength,
                               NDR64_SIMPLE_TYPE_BUFALIGN(*pMemberLayout) );
                 pStubMsg->BufferLength += NDR64_SIMPLE_TYPE_BUFSIZE(*pMemberLayout);
                 pMemory += NDR64_SIMPLE_TYPE_MEMSIZE(*pMemberLayout);
                 
                 pMemberLayout += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);
                 break;

             case FC64_IGNORE :
                 LENGTH_ALIGN( pStubMsg->BufferLength, NDR64_PTR_WIRE_ALIGN );
                 pStubMsg->BufferLength += sizeof(NDR64_PTR_WIRE_TYPE);
                 pMemory += PTR_MEM_SIZE;
                 pMemberLayout += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);
                 break;

             //
             // Done with layout.
             //
             case FC64_END :
                 goto ComplexStructBufferSizeEnd;

             default :
                 NDR_ASSERT(0,"Ndr64ComplexStructBufferSize : bad format char");
                 RpcRaiseException( RPC_S_INTERNAL_ERROR );
                 return;
             } // switch 
         } // for

ComplexStructBufferSizeEnd:
     //
     // Size any conformant array.
     //

     if ( pFormatArray )
         {
         Ndr64EmbeddedTypeSize( pStubMsg,
                                pMemory,
                                pFormatArray );          
         }
    else 
        {
        // If the structure doesn't have a conformant array, align it again
        LENGTH_ALIGN( pStubMsg->BufferLength, pStructFormat->Alignment );
        }

    if ( fSetPointerBufferMark )
        {
        pStubMsg->BufferLength = PtrToUlong(pStubMsg->PointerBufferMark);
        pStubMsg->PointerBufferMark = NULL;
        }
}


void 
Ndr64FixedArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a fixed array of any number of 
    dimensions.

    Used for FC64_SMFARRAY and FC64_LGFARRAY.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    const NDR64_FIX_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_FIX_ARRAY_HEADER_FORMAT*) pFormat;

    LENGTH_ALIGN(pStubMsg->BufferLength, pArrayFormat->Alignment );
    pStubMsg->BufferLength += pArrayFormat->TotalSize;

    if ( pArrayFormat->Flags.HasPointerInfo ) 
        {

        Ndr64pPointerLayoutBufferSize( pStubMsg,
                                       pArrayFormat + 1,
                                       0,
                                       pMemory );
        }
}


void 
Ndr64ConformantArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level one dimensional conformant 
    array.

    Used for FC64_CARRAY.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{

    const NDR64_CONF_ARRAY_HEADER_FORMAT *pArrayFormat =
        (NDR64_CONF_ARRAY_HEADER_FORMAT*) pFormat;

    if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        
        LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN);
    
        pStubMsg->BufferLength += sizeof(NDR64_WIRE_COUNT_TYPE);

        }

    NDR64_WIRE_COUNT_TYPE ConformanceCount = 
        Ndr64EvaluateExpr( pStubMsg, 
                           pArrayFormat->ConfDescriptor, 
                           EXPR_MAXCOUNT );
    
    NDR64_UINT32 BufferSize = Ndr64pConvertTo2GB( (NDR64_UINT64)pArrayFormat->ElementSize * 
                                                  ConformanceCount );

    LENGTH_ALIGN(pStubMsg->BufferLength,pArrayFormat->Alignment);

    pStubMsg->BufferLength += BufferSize;

    if ( pArrayFormat->Flags.HasPointerInfo ) 
        {

        Ndr64pPointerLayoutBufferSize( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)ConformanceCount,
                                       pMemory );
        }

}


void 
Ndr64ConformantVaryingArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level one dimensional conformant
    varying array.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{

    const NDR64_CONF_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_CONF_VAR_ARRAY_HEADER_FORMAT*) pFormat;

    if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN );
    
        pStubMsg->BufferLength += sizeof( NDR64_WIRE_COUNT_TYPE );
        }

    LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN );

    pStubMsg->BufferLength += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_WIRE_COUNT_TYPE ActualCount = 
        Ndr64EvaluateExpr( pStubMsg, 
                           pArrayFormat->VarDescriptor, 
                           EXPR_ACTUALCOUNT );

    NDR64_UINT32 CopySize = Ndr64pConvertTo2GB( ActualCount * 
                                                (NDR64_UINT64)pArrayFormat->ElementSize );

    LENGTH_ALIGN(pStubMsg->BufferLength, pArrayFormat->Alignment );


    pStubMsg->BufferLength += CopySize;

    if ( pArrayFormat->Flags.HasPointerInfo ) 
        {

        Ndr64pPointerLayoutBufferSize( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)ActualCount,
                                       pMemory );
        }
}


void 
Ndr64VaryingArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level or embedded one 
    dimensional varying array.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

Arguments : 

    pMemory     - pointer to the parameter to size
    pFormat     - pointer to the format string description of the parameter

--*/
{
    const NDR64_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_VAR_ARRAY_HEADER_FORMAT*) pFormat;
    
    //
    // Align and add size for offset and actual count.
    //
    LENGTH_ALIGN( pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN);

    pStubMsg->BufferLength += (sizeof(NDR64_WIRE_COUNT_TYPE) * 2);

    NDR64_WIRE_COUNT_TYPE ActualCount =
        Ndr64EvaluateExpr( pStubMsg, 
                           pArrayFormat->VarDescriptor, 
                           EXPR_ACTUALCOUNT );

    // Check if the bounds are valid

    NDR64_UINT32 BufferSize = Ndr64pConvertTo2GB( ActualCount * 
                                                  (NDR64_UINT64)pArrayFormat->ElementSize );

    if ( BufferSize > pArrayFormat->TotalSize  )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    LENGTH_ALIGN(pStubMsg->BufferLength, pArrayFormat->Alignment );

    pStubMsg->BufferLength += BufferSize;

    if ( pArrayFormat->Flags.HasPointerInfo ) 
        {
        
        Ndr64pPointerLayoutBufferSize( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)ActualCount,
                                       pMemory );
        
        }
}


void 
Ndr64ComplexArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level complex array.

    Used for FC64_BOGUS_STRUCT.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.
    
--*/
{
    const NDR64_BOGUS_ARRAY_HEADER_FORMAT *pArrayFormat =
          (NDR64_BOGUS_ARRAY_HEADER_FORMAT *) pFormat;

    bool fSetPointerBufferMark = !pStubMsg->IgnoreEmbeddedPointers &&
                                 (! pStubMsg->PointerBufferMark );

    if ( fSetPointerBufferMark )
        {
        ulong BufferLengthSave = pStubMsg->BufferLength;
        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        Ndr64ComplexArrayBufferSize( 
            pStubMsg,
            pMemory,
            pFormat );

        // In NDR64 the flat part of a array may not have a zero length.
        NDR_ASSERT( pStubMsg->BufferLength, "Flat part of array had a zero length!" );

        pStubMsg->PointerBufferMark = (uchar*)ULongToPtr(pStubMsg->BufferLength);        
        pStubMsg->IgnoreEmbeddedPointers = FALSE;
        pStubMsg->BufferLength = BufferLengthSave;

        }

    BOOL                IsFixed = ( pArrayFormat->FormatCode == FC64_FIX_BOGUS_ARRAY ) ||
                                  ( pArrayFormat->FormatCode == FC64_FIX_FORCED_BOGUS_ARRAY );

    PFORMAT_STRING pElementFormat = (PFORMAT_STRING) pArrayFormat->Element;

    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    
    NDR64_WIRE_COUNT_TYPE Elements = pArrayFormat->NumberElements;
    NDR64_WIRE_COUNT_TYPE Count = Elements;
    NDR64_WIRE_COUNT_TYPE Offset   = 0;
    
    if ( !IsFixed )
        {

        const NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT* pConfVarFormat =
              (NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT*)pFormat;

        if ( pConfVarFormat->ConfDescription )
            {
            Elements = Ndr64EvaluateExpr( pStubMsg,
                                          pConfVarFormat->ConfDescription,
                                          EXPR_MAXCOUNT );
            Count  =  Elements;
            Offset =  0;

            if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
                {

                LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN);

                pStubMsg->BufferLength += pArrayFormat->NumberDims * 
                                          sizeof(NDR64_WIRE_COUNT_TYPE);

                NDR64_SET_CONF_MARK_VALID( pStubMsg->uFlags );

                }

            }

        if ( pConfVarFormat->VarDescription )
            {

            Count = 
                Ndr64EvaluateExpr( pStubMsg,
                                   pConfVarFormat->VarDescription,
                                   EXPR_ACTUALCOUNT );

            Offset = 
                Ndr64EvaluateExpr( pStubMsg,
                                   pConfVarFormat->OffsetDescription,
                                   EXPR_OFFSET);

            if ( ! NDR64_IS_VAR_MARK_VALID( pStubMsg->uFlags ) )
                {

                NDR64_UINT32 Dimensions;

                LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN );

                Dimensions = ( pArrayFormat->Flags.IsArrayofStrings ) ? ( pArrayFormat->NumberDims - 1 ) :
                                                                        ( pArrayFormat->NumberDims );
                pStubMsg->BufferLength += Dimensions * sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

                if ( NDR64_IS_ARRAY_OR_STRING( *pElementFormat ) )
                    NDR64_SET_VAR_MARK_VALID( pStubMsg->uFlags );

                }
            else if ( !NDR64_IS_ARRAY_OR_STRING( *pElementFormat ) )
                NDR64_RESET_VAR_MARK_VALID( pStubMsg->uFlags );
               
            }
        }

    NDR64_UINT32 ElementMemorySize = 
        Ndr64pMemorySize( pStubMsg,
                          pElementFormat,
                          FALSE );

    pMemory += Ndr64pConvertTo2GB(Offset * 
                                  (NDR64_UINT64)ElementMemorySize);

    Ndr64pConvertTo2GB( Elements *
                        (NDR64_UINT64)ElementMemorySize );
    Ndr64pConvertTo2GB( Count *
                        (NDR64_UINT64)ElementMemorySize );

    if ( (Offset + Count) > Elements )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    LENGTH_ALIGN( pStubMsg->BufferLength, pArrayFormat->Alignment );    

    for ( ; Count--; )
        {
        Ndr64EmbeddedTypeSize( pStubMsg,
                               pMemory,
                               pElementFormat );
        pMemory += ElementMemorySize;
        }

    if ( fSetPointerBufferMark )
        {
        pStubMsg->BufferLength = PtrToUlong(pStubMsg->PointerBufferMark);
        pStubMsg->PointerBufferMark = NULL;
        }
}


void 
Ndr64NonConformantStringBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a non conformant string.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    const NDR64_NON_CONFORMANT_STRING_FORMAT * pStringFormat = 
        (NDR64_NON_CONFORMANT_STRING_FORMAT*) pFormat;

    NDR64_UINT32 CopySize = 
        Ndr64pCommonStringSize(pStubMsg,
                               pMemory,
                               &pStringFormat->Header);
    
    if ( CopySize > pStringFormat->TotalSize )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN );

    pStubMsg->BufferLength += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;    

    pStubMsg->BufferLength += CopySize;

}


void 
Ndr64ConformantStringBufferSize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Routine for computing the buffer size needed for a conformant 
    string.  

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    const NDR64_CONFORMANT_STRING_FORMAT * pStringFormat =
        (NDR64_CONFORMANT_STRING_FORMAT*) pFormat;
    const NDR64_SIZED_CONFORMANT_STRING_FORMAT * pSizedStringFormat =
        (NDR64_SIZED_CONFORMANT_STRING_FORMAT*) pFormat;

    NDR64_UINT32 CopySize = 
        Ndr64pCommonStringSize(pStubMsg,
                               pMemory,
                                &pStringFormat->Header);    

    if ( pStringFormat->Header.Flags.IsSized )
        {
        
        Ndr64EvaluateExpr( pStubMsg,
                           pSizedStringFormat->SizeDescription,
                           EXPR_MAXCOUNT );

        if ( pStubMsg->ActualCount >  pStubMsg->MaxCount )
            RpcRaiseException(RPC_X_INVALID_BOUND);
        
        }

    if ( !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
       {
       LENGTH_ALIGN( pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN );
       pStubMsg->BufferLength += sizeof(NDR64_WIRE_COUNT_TYPE);
       }

    // Align and add size for variance.
    LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN);
    pStubMsg->BufferLength += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;
    pStubMsg->BufferLength += CopySize;

}



void 
Ndr64UnionBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for an encapsulated union.

    Used for FC64_ENCAPSULATED_UNION.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the union being sized.
    pFormat     - Union's format string description.

Return :

    None.

--*/
{
    const NDR64_UNION_ARM_SELECTOR* pArmSelector;

    EXPR_VALUE          SwitchIs;
    NDR64_FORMAT_CHAR   SwitchType;

    uchar *pArmMemory;
    switch(*(PFORMAT_STRING)pFormat)
        {
        case FC64_NON_ENCAPSULATED_UNION:
            {
            const NDR64_NON_ENCAPSULATED_UNION* pNonEncapUnionFormat =
                (const NDR64_NON_ENCAPSULATED_UNION*) pFormat;

            LENGTH_ALIGN(pStubMsg->BufferLength, pNonEncapUnionFormat->Alignment);
            SwitchType      = pNonEncapUnionFormat->SwitchType;
            pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pNonEncapUnionFormat + 1);

            SwitchIs   = Ndr64EvaluateExpr( pStubMsg,
                                            pNonEncapUnionFormat->Switch,
                                            EXPR_SWITCHIS );

            pArmMemory      = pMemory;
            break;
            }
        case FC64_ENCAPSULATED_UNION:
            {
            const NDR64_ENCAPSULATED_UNION* pEncapUnionFormat =
                (const NDR64_ENCAPSULATED_UNION*)pFormat;

            LENGTH_ALIGN(pStubMsg->BufferLength, pEncapUnionFormat->Alignment);
            SwitchType      = pEncapUnionFormat->SwitchType;
            pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pEncapUnionFormat + 1);
                
            SwitchIs        = Ndr64pSimpleTypeToExprValue(SwitchType,
                                                          pMemory);

            pArmMemory      = pMemory + pEncapUnionFormat->MemoryOffset;
            break;
            }
        default:
            NDR_ASSERT("Bad union format\n", 0);
            return;
        }

    //
    // Size the switch_is.
    //
    LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_SIMPLE_TYPE_BUFALIGN(SwitchType));
    
    pStubMsg->BufferLength += NDR64_SIMPLE_TYPE_BUFSIZE(SwitchType);

    LENGTH_ALIGN( pStubMsg->BufferLength, pArmSelector->Alignment);

    PNDR64_FORMAT pArmFormat = 
        Ndr64pFindUnionArm( pStubMsg,
                            pArmSelector,
                            SwitchIs );

    if ( ! pArmFormat )
        return;

    Ndr64EmbeddedTypeSize( pStubMsg,
                           pArmMemory,
                           pArmFormat );

}


void 
Ndr64XmitOrRepAsBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    bool                IsEmbedded ) 
/*++

Routine Description :

    Computes the buffer size needed for a transmit as or represent as object.

    See mrshl.c for the description of the FC layout.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the transmit/represent as object being sized.
    pFormat     - Object's format string description.

Return :

    None.

--*/
{
    NDR64_TRANSMIT_AS_FORMAT    *pTransFormat = ( NDR64_TRANSMIT_AS_FORMAT *) pFormat;
    NDR_ASSERT( pTransFormat->FormatCode == FC64_TRANSMIT_AS || pTransFormat->FormatCode , "invalid format string for user marshal" );

    unsigned short QIndex = pTransFormat->RoutineIndex;

    NDR64_UINT32 XmitTypeSize = pTransFormat->TransmittedTypeBufferSize;

    const XMIT_ROUTINE_QUINTUPLE * pQuintuple = pStubMsg->StubDesc->aXmitQuintuple;

    if ( XmitTypeSize )
        {
        LENGTH_ALIGN( pStubMsg->BufferLength, pTransFormat->TransmittedTypeWireAlignment );
        pStubMsg->BufferLength += XmitTypeSize;
        }
    else
        {
        // We have to create an object to size it.

        // First translate the presented type into the transmitted type.
        // This includes an allocation of a transmitted type object.
    
        pStubMsg->pPresentedType = pMemory;
        pStubMsg->pTransmitType = NULL;
        pQuintuple[ QIndex ].pfnTranslateToXmit( pStubMsg );
    
        // bufsize the transmitted type.

        unsigned char *  pTransmittedType = pStubMsg->pTransmitType;

        // In NDR64, Xmit/Rep cannot be a pointer or contain a pointer.
        // So we don't need to worry about the pointer queue here.

        if ( IsEmbedded )
            {
            Ndr64EmbeddedTypeSize( pStubMsg,
                                   pTransmittedType,
                                   pTransFormat->TransmittedType );
            }
        else
            {
            Ndr64TopLevelTypeSize( pStubMsg,
                                   pTransmittedType,
                                   pTransFormat->TransmittedType );
            }

        pStubMsg->pTransmitType = pTransmittedType;
    
        // Free the temporary transmitted object (it was alloc'ed by the user).
    
        pQuintuple[ QIndex ].pfnFreeXmit( pStubMsg );
        }
}

void 
Ndr64TopLevelXmitOrRepAsBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    Ndr64XmitOrRepAsBufferSize( pStubMsg,
                                pMemory,
                                pFormat,
                                false );
}

void
Ndr64EmbeddedXmitOrRepAsBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    Ndr64XmitOrRepAsBufferSize( pStubMsg,
                                pMemory,
                                pFormat,
                                true );
}

void
Ndr64UserMarshallBufferSizeInternal(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{

    NDR64_USER_MARSHAL_FORMAT  *pUserFormat = ( NDR64_USER_MARSHAL_FORMAT *) pFormat;

    // We are here to size a flat object or a pointee object.
    // Optimization: if we know the wire size, don't call the user to size it.

    if ( pUserFormat->TransmittedTypeBufferSize != 0 )
        {
        pStubMsg->BufferLength += pUserFormat->TransmittedTypeBufferSize;
        }
    else
        {
        // Unknown wire size: Call the user to size his stuff.
        USER_MARSHAL_CB UserMarshalCB;
        Ndr64pInitUserMarshalCB( pStubMsg,
                               pUserFormat,
                               USER_MARSHAL_CB_BUFFER_SIZE,
                               & UserMarshalCB);

        unsigned long UserOffset = pStubMsg->BufferLength;

        unsigned short QIndex = pUserFormat->RoutineIndex;
        const USER_MARSHAL_ROUTINE_QUADRUPLE * pQuadruple = 
            (const USER_MARSHAL_ROUTINE_QUADRUPLE *)( (  NDR_PROC_CONTEXT *)pStubMsg->pContext )->pSyntaxInfo->aUserMarshalQuadruple;

        UserOffset = pQuadruple[ QIndex ].pfnBufferSize( (ulong*) &UserMarshalCB,
                                                         UserOffset,
                                                         pMemory );
        pStubMsg->BufferLength = UserOffset;
        }
}

void
NDR64_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT::Dispatch(MIDL_STUB_MESSAGE *pStubMsg)
{
    Ndr64UserMarshallBufferSizeInternal( pStubMsg,
                                         pMemory,
                                         pFormat );
}

#if defined(DBG)
void 
NDR64_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
}
#endif


void
Ndr64UserMarshallPointeeBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    
    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    if ( !pStubMsg->pPointerQueueState ||
         !pStubMsg->pPointerQueueState->GetActiveQueue() )
        {

        POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext( pStubMsg );
        Ndr64UserMarshallBufferSizeInternal( pStubMsg,
                                             pMemory,
                                             pFormat );
        return;
        }
    
    NDR64_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT*pElement = 
       new(pStubMsg->pPointerQueueState) 
           NDR64_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT(pMemory,
                                                       (PFORMAT_STRING)pFormat );
    pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );
}


void
Ndr64UserMarshalBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    bool                bIsEmbedded ) 
/*++

Routine Description :

    Computes the buffer size needed for a usr_marshall object.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the usr_marshall object to buffer size.
    pFormat     - Object's format string description.

Return :

    None.

--*/
{

    NDR64_USER_MARSHAL_FORMAT  *pUserFormat = ( NDR64_USER_MARSHAL_FORMAT *) pFormat;
    NDR_ASSERT( pUserFormat->FormatCode == FC64_USER_MARSHAL, "invalid format string for user marshal" );

    // Align for the flat object or a pointer to the user object.
    LENGTH_ALIGN( pStubMsg->BufferLength, pUserFormat->TransmittedTypeWireAlignment );

    if ( pUserFormat->Flags & USER_MARSHAL_POINTER )
        {
        
        if ( ( pUserFormat->Flags & USER_MARSHAL_UNIQUE) ||
            ( ( pUserFormat->Flags & USER_MARSHAL_REF) && bIsEmbedded ) )
           {
           LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_PTR_WIRE_ALIGN );
           pStubMsg->BufferLength += sizeof( NDR64_PTR_WIRE_TYPE );
           }
           
        
        Ndr64UserMarshallPointeeBufferSize( pStubMsg,
                                            pMemory,
                                            pFormat );
        return;
        }

    Ndr64UserMarshallBufferSizeInternal( pStubMsg,
                                         pMemory,
                                         pFormat );
        
}

void
Ndr64TopLevelUserMarshalBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    Ndr64UserMarshalBufferSize(
        pStubMsg,
        pMemory,
        pFormat,
        false );
}

void
Ndr64EmbeddedUserMarshallBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    Ndr64UserMarshalBufferSize(
        pStubMsg,
        pMemory,
        pFormat,
        true );
}


void 
Ndr64ContextHandleSize(
    PMIDL_STUB_MESSAGE     pStubMsg,
    uchar *                pMemory,
    PNDR64_FORMAT          pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a context handle.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Ignored.
    pFormat     - Ignored.

Return :

    None.

--*/
{
    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
    pStubMsg->BufferLength += CONTEXT_HANDLE_WIRE_SIZE;
}

// define the jump table
#define NDR64_BEGIN_TABLE  \
PNDR64_SIZE_ROUTINE extern const Ndr64SizeRoutinesTable[] = \
{                                                          

#define NDR64_TABLE_END    \
};                        

#define NDR64_ZERO_ENTRY   NULL
#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) ,NULL
#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number ) ,NULL

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,buffersize                    

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, buffersize,  memorysize ) \
   ,Ndr64UDTSimpleTypeSize
           
#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64SizeRoutinesTable)/sizeof(PNDR64_SIZE_ROUTINE) == 256 );

#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_ENTRY

#define NDR64_BEGIN_TABLE \
PNDR64_SIZE_ROUTINE extern const Ndr64EmbeddedSizeRoutinesTable[] = \
{

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,embeddedbuffersize
   
#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64EmbeddedSizeRoutinesTable) / sizeof(PNDR64_SIZE_ROUTINE) == 256 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\cltcall.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 - 2000 Microsoft Corporation

Module Name :

    cltcall.c

Abstract :

    This file contains the single call Ndr64 routine for the client side.

Author :

    David Kays    dkays    October 1993.

Revision History :

    brucemc     11/15/93    Added struct by value support, corrected
                            varargs use.
    brucemc     12/20/93    Binding handle support
    ryszardk    3/12/94     handle optimization and fixes

---------------------------------------------------------------------*/
#include "precomp.hxx"

#define CINTERFACE
#define USE_STUBLESS_PROXY

#include <stdarg.h>
#include "hndl.h"
#include "interp2.h"
#include "pipendr.h"

#include "ndrole.h"
#include "rpcproxy.h"

#pragma code_seg(".ndr64")

#define NDR_MAX_RESEND_COUNT    5

#define WIN32RPC
#include "rpcerrp.h"


void
Ndr64ClearOutParameters(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    uchar *             pArg
    )
/*++

Routine Description :

    Free and clear an [out] parameter in case of exceptions for object
    interfaces.

Arguments :

    pStubMsg    - pointer to stub message structure
    pFormat     - The format string offset
    pArg        - The [out] pointer to clear.

Return :

    NA

Notes:

--*/
{
    const NDR64_POINTER_FORMAT *pPointerFormat = 
        (const NDR64_POINTER_FORMAT*)pFormat;
    PFORMAT_STRING pPointee = (PFORMAT_STRING)pPointerFormat->Pointee;

    if( pStubMsg->dwStubPhase != PROXY_UNMARSHAL)
        return;

    // Let's not die on a null ref pointer.

    if ( !pArg )
        return;

    NDR64_UINT32 Size = 0;
    uchar *pArgSaved = pArg;

    //
    // Look for a non-Interface pointer.
    //
    if ( NDR64_IS_BASIC_POINTER(*(PFORMAT_STRING)pFormat) )
        {
        // Pointer to a basetype.
        if ( NDR64_SIMPLE_POINTER(pPointerFormat->Flags) )
            {
            //
            // It seems wierd to zero an [out] pointer to a basetypes, but this
            // is what we did in NT 3.5x and I wouldn't be surprised if
            // something broke if we changed this behavior.
            //
            Size = NDR64_SIMPLE_TYPE_MEMSIZE( *pPointee );
            goto DoZero;
            }

        // Pointer to a pointer.
        if ( NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
            {
            Size = PTR_MEM_SIZE;
            pArg = *((uchar **)pArg);
            }


        if ( *(PFORMAT_STRING)pFormat == FC64_BIND_CONTEXT )
            {
            *((NDR_CCONTEXT *)pArg) = (NDR_CCONTEXT) 0;
            return;
            }
        }

    // We have a pointer to complex type.
    Ndr64ToplevelTypeFree( pStubMsg,
                           pArg,
                           pPointee );

    if ( ! Size )
        {
        Size = Ndr64pMemorySize( pStubMsg,
                                 pPointee,
                                 FALSE );
        }

DoZero:

    MIDL_memset( pArgSaved, 0, (size_t)Size );
}


__forceinline void 
Ndr64pGetBuffer( void * pThis, 
                 MIDL_STUB_MESSAGE * pStubMsg,
                 NDR_PROC_CONTEXT *  pContext )
{
    if ( pThis )
        NdrProxyGetBuffer( pThis,
                           pStubMsg );
    else
        {
        if ( pContext->HandleType != FC64_AUTO_HANDLE )
            {
            Ndr64GetBuffer( pStubMsg,
                          pStubMsg->BufferLength );
            }
        else
            Ndr64NsGetBuffer( pStubMsg,
                          pStubMsg->BufferLength );

        // We only need to save the stubmsg in sync interfaces. 
        // In the client side, runtime tls would be available AFTER call
        // to runtime, it might be after I_RpcNegotiateTransferSyntax or 
        // GetBuffer, and we are sure the slot is available now.
        }

    NdrRpcSetNDRSlot( pStubMsg );
}

__forceinline void 
Ndr64pSendReceive( void * pThis,
                   MIDL_STUB_MESSAGE * pStubMsg,
                   NDR_PROC_CONTEXT  * pContext )
{
    if ( pContext->HasPipe )
        NdrPipeSendReceive( pStubMsg, pContext->pPipeDesc );
    else
        {
        if ( pThis )
            NdrProxySendReceive( pThis, pStubMsg );
        else
            if ( pContext->HandleType != FC64_AUTO_HANDLE )
                NdrSendReceive( pStubMsg, pStubMsg->Buffer );
            else
                NdrNsSendReceive( pStubMsg,
                                  pStubMsg->Buffer,
                                  (RPC_BINDING_HANDLE*) pStubMsg->StubDesc
                                    ->IMPLICIT_HANDLE_INFO.pAutoHandle );
        }
}


CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall3(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    ulong                       nProcNum,
    void                       *pReturnValue,
    ...
    )
/*
    This routine is called from the object stubless proxy dispatcher.
*/
{
    va_list                     ArgList;
    RPC_STATUS                  res = RPC_S_OK;
    NDR_PROC_CONTEXT            ProcContext;

    INIT_ARG( ArgList, pReturnValue );
    GET_FIRST_IN_ARG(ArgList);
    uchar * StartofStack = (uchar *)GET_STACK_START(ArgList);

    Ndr64ClientInitializeContext( NdrpGetSyntaxType( pProxyInfo->pTransferSyntax),
                                  pProxyInfo,
                                  nProcNum,
                                 &ProcContext,
                                  StartofStack );


    // call_as routines in ORPC interface come through here also.
    return NdrpClientCall3(  ProcContext.IsObject ? *(void **)StartofStack : NULL, 
                            pProxyInfo, 
                            nProcNum, 
                            pReturnValue,
                            &ProcContext,
                            StartofStack );
}

CLIENT_CALL_RETURN RPC_ENTRY
NdrpClientCall3(
    void *                      pThis,
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    ulong                       nProcNum,
    void                       *pReturnValue,
    NDR_PROC_CONTEXT        *   pContext,
    uchar *                     StartofStack
    )
{

    RPC_MESSAGE                 RpcMsg;
    MIDL_STUB_MESSAGE           StubMsg;
    PMIDL_STUB_MESSAGE          pStubMsg = &StubMsg;
    CLIENT_CALL_RETURN          ReturnValue;

    ReturnValue.Pointer = 0;

    if ( NULL == pReturnValue )
        pReturnValue = &ReturnValue;

    //
    // Wrap everything in a try-finally pair. The finally clause does the
    // required freeing of resources (RpcBuffer and Full ptr package).
    //
    RpcTryFinally
        {
        //
        // Use a nested try-except pair to support OLE. In OLE case, test the
        // exception and map it if required, then set the return value. In
        // nonOLE case, just reraise the exception.
        //
        RpcTryExcept
            {

            // client initialization and syntax negotiation.
            Ndr64pClientSetupTransferSyntax(pThis, 
                           &RpcMsg,
                           pStubMsg,
                           pProxyInfo,
                           pContext,
                           nProcNum );

            ( * pContext->pfnInit) ( pStubMsg, 
                                pReturnValue );

            ( * pContext->pfnSizing) ( pStubMsg,
                                       TRUE );    // isclient
            
            //
            // Do the GetBuffer.
            //

            Ndr64pGetBuffer( pThis, &StubMsg, pContext );
            

            NDR_ASSERT( StubMsg.fBufferValid, "Invalid buffer" );

            (* pContext->pfnMarshal) (&StubMsg,
                                     ( pThis != NULL ) );   // isobject


            //
            // Make the RPC call.
            //


            Ndr64pSendReceive( pThis, &StubMsg, pContext ) ;

            ( * pContext->pfnUnMarshal )( &StubMsg,
                                 pContext->HasComplexReturn
                                        ? &pReturnValue
                                        : pReturnValue );
                                
            }       
        RpcExcept( EXCEPTION_FLAG )
            {

            RPC_STATUS ExceptionCode = RpcExceptionCode();
            NDR_ASSERT( pContext->NeedsResend == FALSE, "resend flag should be false here" );

            // fail after some retries.
            if ( ExceptionCode == RPC_P_TRANSFER_SYNTAX_CHANGED && 
                 ( pContext->ResendCount < NDR_MAX_RESEND_COUNT ) &&
                 ( pProxyInfo->nCount > 1 ) ) 
                {
                // we'll retry only if: 
                // . runtime returns changed syntax error code
                // . client support multiple transfer syntax
                // . we retried less than the max retried number
                pContext->ResendCount ++;
                pContext->NeedsResend = TRUE;
                }
            else
                (pContext->pfnExceptionHandling) ( pStubMsg,
                                             nProcNum,
                                             ExceptionCode,
                                             &ReturnValue );
            }
        RpcEndExcept
        }
    RpcFinally
        {

        (pContext->pfnClientFinally )(  pStubMsg,
                                        pThis );

        // recurse back if resend is needed. we are very much making a new call again because runtime doesn't
        // know which tranfer syntax the new server supports when the previous negotiated transfer syntax failes.
        if ( pContext->NeedsResend )
            NdrpClientCall3( pThis, pProxyInfo, nProcNum, pReturnValue, pContext, StartofStack );
        }
    RpcEndFinally

    return ReturnValue;
}


#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\global.cxx ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993 Microsoft Corporation

Module Name :

    global.cxx

Abtract :

    Contains some global variable declarations for the NDR library.

Author :

    David Kays  dkays   October 1993

Revision History :

--------------------------------------------------------------------*/

#include "precomp.hxx"

extern "C"
{

#define NDR64_BEGIN_TABLE  \
extern const unsigned char Ndr64SimpleTypeBufferSize[] = \
{                                                          

#define NDR64_TABLE_END    \
};                         

#define NDR64_ZERO_ENTRY   0
#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) ,0
#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number ) ,0

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,0                      

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, buffersize, memorysize) \
   ,buffersize   
   
#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64SimpleTypeBufferSize)/sizeof(char) == 256 );

#undef NDR64_BEGIN_TABLE
#undef NDR64_SIMPLE_TYPE_TABLE_ENTRY

#define NDR64_BEGIN_TABLE  \
extern const unsigned char Ndr64SimpleTypeMemorySize[] = \
{                                                  

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, buffersize, memorysize) \
   ,memorysize
   
#include "tokntbl.h"
   
C_ASSERT( sizeof(Ndr64SimpleTypeMemorySize)/sizeof(char) == 256 );

#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_ENTRY
#undef NDR64_SIMPLE_TYPE_TABLE_ENTRY

#define NDR64_BEGIN_TABLE  \
extern const unsigned long Ndr64TypeFlags[] = \
{

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
    ,typeflags
    
#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, buffersize, memorysize) \
    ,_SIMPLE_TYPE_
    
#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64TypeFlags)/sizeof(unsigned long) == 256 );

#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_END
#undef NDR64_ZERO_ENTRY
#undef NDR64_UNUSED_TABLE_ENTRY
#undef NDR64_UNUSED_TABLE_ENTRY_NOSYM
#undef NDR64_TABLE_ENTRY
#undef NDR64_SIMPLE_TYPE_TABLE_ENTRY

#define NDR64_BEGIN_TABLE
#define NDR64_TABLE_END
#define NDR64_ZERO_ENTRY
#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) C_ASSERT( (number) == (tokenname) ); 
#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number )
#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
    C_ASSERT( (number) == (tokenname) );
#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, buffersize, memorysize) \
    C_ASSERT( (number) == (tokenname) );        \
    C_ASSERT( (buffersize) == (memorysize) );
                                              
#include "tokntbl.h"

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\hndl.h ===
/************************************************************************

Copyright (c) 1993 Microsoft Corporation

Module Name :

    hndl.h

Abstract :

    To hold prototypes of support routines for interpreting handles in 
    support of Format Strings.

Author :

    Bruce McQuistan (brucemc)

Revision History :

  ***********************************************************************/

#ifndef __HNDL_H__
#define __HNDL_H__

//
// The following is to be used in as masks for flags passed in these
// routines.
//
#define     MARSHALL_MASK           0x2
#define     IMPLICIT_MASK           0x4
#define     BINDING_MASK            0x8

//
// Next, a macro for getting the current call handle. On dos,win16, it'll
// never be called.
//
#if  defined(__RPC_MAC__)
#define GET_CURRENT_CALL_HANDLE()	NULL
#else
#define GET_CURRENT_CALL_HANDLE()   I_RpcGetCurrentCallHandle()
#endif

//
// Some typedefs to keep the front end of the C compiler happy and possibly to
// improve code generation.
//
typedef void *  (__RPC_API * GENERIC_BIND_FUNC_ARGCHAR)(uchar);
typedef void *  (__RPC_API * GENERIC_BIND_FUNC_ARGSHORT)(ushort);
typedef void *  (__RPC_API * GENERIC_BIND_FUNC_ARGLONG)(ulong);

typedef void    (__RPC_API * GENERIC_UNBIND_FUNC_ARGCHAR)(uchar, handle_t);
typedef void    (__RPC_API * GENERIC_UNBIND_FUNC_ARGSHORT)(ushort, handle_t);
typedef void    (__RPC_API * GENERIC_UNBIND_FUNC_ARGLONG)(ulong, handle_t);

#if defined(__RPC_WIN64__)
typedef void *  (__RPC_API * GENERIC_BIND_FUNC_ARGINT64)(uint64);
typedef void    (__RPC_API * GENERIC_UNBIND_FUNC_ARGINT64)(uint64, handle_t);
#endif

handle_t
GenericHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    uint                    Flags,
    handle_t *              pSavedGenericHandle
    );

void
GenericHandleUnbind(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    uint                    Flags,
    handle_t *              pSavedGenericHandle
    );

handle_t
ExplicitBindHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    handle_t *              pSavedGenericHandle
    );

handle_t
ImplicitBindHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar                   HandleType,
    handle_t *              pSavedGenericHandle
    );

handle_t
Ndr64GenericHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    uint                    Flags,
    handle_t *              pSavedGenericHandle
    );

void
Ndr64GenericHandleUnbind(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    uint                    Flags,
    handle_t *              pSavedGenericHandle
    );

handle_t
Ndr64ExplicitBindHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    handle_t *              pSavedGenericHandle
    );

handle_t
Ndr64ImplicitBindHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar                   HandleType,
    handle_t *              pSavedGenericHandle
    );


void
Ndr64MarshallHandle(
    PMIDL_STUB_MESSAGE      pStubMsg,
    uchar *                 pArg,
    PNDR64_FORMAT           FmtString
    );

void
Ndr64UnmarshallHandle(
    PMIDL_STUB_MESSAGE      pStubMsg,
    uchar **                ppArg,
    PNDR64_FORMAT           FmtString,
	bool				    fIgnored
    );

void
Ndr64SaveContextHandle (
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_SCONTEXT            CtxtHandle,
    uchar **                ppArg,
    PFORMAT_STRING          pFormat
    );

void
Ndr64ContextHandleQueueFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    void *                  FixedArray
    );

#endif __HNDL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\hndl.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
Copyright (c) 1993  - 1999 Microsoft Corporation

Module Name :

    hndl.c

Abstract :

    To hold support routines for interpreting handles
    in support of Format Strings.

Author :
    
    Bruce McQuistan (brucemc)

Revision History :

    ryszardk    3/12/94     handle optimization and fixes

  ---------------------------------------------------------------------*/

#include "precomp.hxx"
#include "interp.h"

extern const IID GUID_NULL;

handle_t
Ndr64GenericHandleMgr(
    PMIDL_STUB_DESC     pStubDesc,
    uchar *             ArgPtr,
    PFORMAT_STRING      pFormat,
    uint                Flags,
    handle_t *          pGenericHandle
    )
/*++

Description :

    Provides a filter for generic binding handle management issues.
    Deals with implicit or explicit generic binding handles calling
    user functions as appropriate.

Arguments :

    pStubDesc - pointer to current StubDescriptor.
    ArgPtr    - pointer to handle.
    pFormat   - pointer to Format string such that *pFormat is a
                handle descriptor.
    Flag      - flag indicating either binding or unbinding.

Returns :     

    Valid binding handle.

*/
{
    uchar                                GHandleSize;
    handle_t                             ReturnHandle = 0;
    BOOL                                 fBinding;
    GENERIC_BINDING_ROUTINE              pBindFunc = 0;
    GENERIC_UNBIND_ROUTINE               pUnBindFunc = 0;
    const GENERIC_BINDING_ROUTINE_PAIR * Table;
    NDR64_BIND_GENERIC  *                pExplicitFormat;
    BOOL                                 fIsPtr = FALSE;

    Table = pStubDesc->aGenericBindingRoutinePairs;

    fBinding = (Flags & BINDING_MASK);

    if ( Flags & IMPLICIT_MASK )
        {
        //
        // Implicit generic: All the info is taken from the implicit generic
        // handle info structure accessed via stub descriptor.
        //
        PGENERIC_BINDING_INFO pGenHandleInfo;

        pGenHandleInfo = pStubDesc->IMPLICIT_HANDLE_INFO.pGenericBindingInfo;

        GHandleSize = (uchar) pGenHandleInfo->Size;

        if ( fBinding )
            pBindFunc = pGenHandleInfo->pfnBind;
        else
            pUnBindFunc = pGenHandleInfo->pfnUnbind;
        }
    else
        {
        //
        // Explicit generic: Get index into array of function ptrs and
        // the gen handle size the format string.
        //
        NDR64_UINT8 TableIndex;
        pExplicitFormat = ( NDR64_BIND_GENERIC * )pFormat;
        NDR_ASSERT ( pExplicitFormat->HandleType == FC64_BIND_GENERIC, "invalid format char" );
        TableIndex = pExplicitFormat->RoutineIndex;
        
        GHandleSize = pExplicitFormat->Size;

        if ( fBinding )
            pBindFunc = Table[TableIndex].pfnBind;
        else
            pUnBindFunc = Table[TableIndex].pfnUnbind;

        if ( NDR64_IS_HANDLE_PTR(( ( NDR64_BIND_GENERIC * )pFormat )->Flags ) )
            fIsPtr = TRUE;
        }

    //
    // Call users routine on correctly dereferenced pointer.
    //
    switch (GHandleSize)
        {
        case 1:
            {
            uchar HandlePtr = (uchar)(ULONG_PTR)ArgPtr;
            if ( fIsPtr )
                HandlePtr = * (uchar *)ArgPtr;
        
            if ( fBinding )
                ReturnHandle = 
                    (handle_t)(ULONG_PTR)
                    (*(GENERIC_BIND_FUNC_ARGCHAR)pBindFunc)(
                        (uchar)(ULONG_PTR)HandlePtr );
            else
                (*(GENERIC_UNBIND_FUNC_ARGCHAR)pUnBindFunc)(
                    (uchar)(ULONG_PTR)HandlePtr,
                    *pGenericHandle );
            break;
            }

        case 2:
            {
            ushort HandlePtr = (ushort)(ULONG_PTR)ArgPtr;
            if ( fIsPtr )
                HandlePtr = * (ushort *)ArgPtr;
        
            if ( fBinding )
                ReturnHandle = 
                    (handle_t)(ULONG_PTR)
                    (*(GENERIC_BIND_FUNC_ARGSHORT)pBindFunc)(
                        (ushort)(ULONG_PTR)HandlePtr );
            else
                (*(GENERIC_UNBIND_FUNC_ARGSHORT)pUnBindFunc)(
                    (ushort)(ULONG_PTR)HandlePtr,
                    *pGenericHandle );
            break;
            }

        case 4:
            {
            ulong HandlePtr = (ulong)(ULONG_PTR)ArgPtr;
            if ( fIsPtr )
                HandlePtr = * (ulong *)ArgPtr;
        
            if ( fBinding )
                ReturnHandle = 
                    (handle_t)(ULONG_PTR)
                    (*(GENERIC_BIND_FUNC_ARGLONG)pBindFunc)(
                        (ulong)(ULONG_PTR)HandlePtr );
            else
                (*(GENERIC_UNBIND_FUNC_ARGLONG)pUnBindFunc)(
                    (ulong)(ULONG_PTR)HandlePtr,
                    *pGenericHandle );
            break;
            }

#if defined(__RPC_WIN64__)
        case 8:
            {
            ULONG_PTR HandlePtr = (ULONG_PTR)ArgPtr;
            if ( fIsPtr )
                HandlePtr = * (ULONG_PTR *)ArgPtr;
        
            if ( fBinding )
                ReturnHandle = 
                    (handle_t)(ULONG_PTR)
                    (*(GENERIC_BIND_FUNC_ARGINT64)pBindFunc)(
                        (ULONG_PTR)HandlePtr );
            else
                (*(GENERIC_UNBIND_FUNC_ARGINT64)pUnBindFunc)(
                    (ULONG_PTR)HandlePtr,
                    *pGenericHandle );
            break;
            }
#endif

        default:
            NDR_ASSERT(0,"GenericHandleMgr : Handle size too big");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    if ( fBinding )
        {
        *pGenericHandle = ReturnHandle;
        if ( ReturnHandle == NULL )
            RpcRaiseException( RPC_S_INVALID_BINDING );
        }
    else
        *pGenericHandle = NULL;

    return ReturnHandle;
}


void
Ndr64GenericHandleUnbind(
    PMIDL_STUB_DESC     pStubDesc,
    uchar *             ArgPtr,
    PFORMAT_STRING      pFormat,
    uint                Flags,
    handle_t *          pGenericHandle
    )
/*++

Description :

    Unbinds a generic handle: checks if it is implicit or explicit,
    gets the handle and calls GenericHandleMgr.

Arguments :

    pStubDesc - pointer to current StubDescriptor.
    ArgPtr    - pointer to beginning of the stack.
    pFormat   - pointer to Format string such that *pFormat is a
                  handle descriptor.
    Flag      - flag indicating implicit vs. explicit.

 --*/
{
    if ( Flags & IMPLICIT_MASK )
        {
        PGENERIC_BINDING_INFO BindInfo;

        BindInfo = pStubDesc->IMPLICIT_HANDLE_INFO.pGenericBindingInfo;

        NDR_ASSERT( BindInfo != 0, "GenericHandleUnbind : null bind info" );

        ArgPtr = (uchar *) BindInfo->pObj;
        }
    else
        {
        ArgPtr += ( ( NDR64_BIND_GENERIC * )pFormat )->StackOffset;

        ArgPtr = *(uchar **)ArgPtr;

//        if ( NDR64_IS_HANDLE_PTR(( ( NDR64_BIND_GENERIC * )pFormat )->Flags ) )
//            ArgPtr = *(uchar * UNALIGNED *)ArgPtr;
        }

    (void) Ndr64GenericHandleMgr( pStubDesc,
                             ArgPtr,
                             pFormat,
                             Flags,
                             pGenericHandle );
}


handle_t
Ndr64ImplicitBindHandleMgr(
    PMIDL_STUB_DESC pStubDesc,
    uchar           HandleType,
    handle_t *      pSavedGenericHandle
    )
/*++

Description :

    Provides a filter for implicit handle management issues. Deals
    with binding handles (generic, primitive or auto), extracting
    a valid handle from pStubDesc.

Arguments :

    pStubDesc  - pointer to current StubDescriptor.
    HandleType - handle format code.

Return :     
    
    Valid handle.

--*/
{
    handle_t                ReturnHandle;
    PGENERIC_BINDING_INFO   pBindInfo;

    switch ( HandleType )
        {
        case FC64_BIND_PRIMITIVE :
            ReturnHandle = *(pStubDesc->IMPLICIT_HANDLE_INFO.pPrimitiveHandle);
            break;

        case FC64_BIND_GENERIC :
            pBindInfo = pStubDesc->IMPLICIT_HANDLE_INFO.pGenericBindingInfo;

            NDR_ASSERT( pBindInfo != 0, 
                        "ImplicitBindHandleMgr : no generic bind info" );

            ReturnHandle = Ndr64GenericHandleMgr( pStubDesc,
                                             (uchar *)pBindInfo->pObj,
                                             &HandleType,
                                             BINDING_MASK | IMPLICIT_MASK,
                                             pSavedGenericHandle );
            break;

        case FC64_AUTO_HANDLE :
            ReturnHandle = *(pStubDesc->IMPLICIT_HANDLE_INFO.pAutoHandle);
            break;

        case FC64_CALLBACK_HANDLE :
            ReturnHandle = GET_CURRENT_CALL_HANDLE();
            break;

        default :
            NDR_ASSERT(0, "ImplicitBindHandleMgr : bad handle type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    return ReturnHandle;
}


handle_t
Ndr64ExplicitBindHandleMgr(
    PMIDL_STUB_DESC pStubDesc,
    uchar *         ArgPtr,
    PFORMAT_STRING  pFormat,
    handle_t *      pSavedGenericHandle
    )
/*

Description :

    Provides a filter for explicit binding handle management issues.
    Deals with binding handles (primitive, generic or context), calling
    either no routine, NDR routines or user functions as appropriate.

    To be called in the following cases:
    1) if handle is explicit.
        a) before calling I_RpcGetBuffer (to bind).
        b) after unmarshalling (to unbind).

Arguments :

    pStubDesc - pointer to current StubDescriptor.
    ArgPtr    - Pointer to start of stack
    pFormat   - pointer to Format string such that *pFormat is a
                  handle descriptor.

Return :     

    Valid binding handle.

*/
{
    handle_t    ReturnHandle;
    NDR64_BIND_CONTEXT * pExplicitFormat;

    //
    // We need to manage Explicit and Implicit handles.
    // Implicit handles are managed with info accessed via the StubMessage.
    // Explicit handles have their information stored in the format string.
    // We manage explicit handles for binding here.
    //

    pExplicitFormat = ( NDR64_BIND_CONTEXT * )pFormat;
    //
    // Get location in stack of handle referent.
    //
    ArgPtr += pExplicitFormat->StackOffset;

    ArgPtr = *(uchar **)ArgPtr;


    //
    // At this point ArgPtr is an address of the handle.
    //
    switch ( pExplicitFormat->HandleType )
        {
        case FC64_BIND_PRIMITIVE :
            if ( NDR64_IS_HANDLE_PTR( pExplicitFormat->Flags) )
                ArgPtr = *(uchar **)ArgPtr;
            ReturnHandle = (handle_t)(ULONG_PTR)ArgPtr;
            break;

        case FC64_BIND_GENERIC :
            ReturnHandle = Ndr64GenericHandleMgr( pStubDesc,
                                             ArgPtr,
                                             pFormat,
                                             BINDING_MASK,
                                             pSavedGenericHandle );
            break;
    
        case FC64_BIND_CONTEXT :
            if ( NDR64_IS_HANDLE_PTR( pExplicitFormat->Flags) )
                ArgPtr = *(uchar **)ArgPtr;
        
            if ( (!(ArgPtr)) && (!NDR64_IS_HANDLE_OUT(pExplicitFormat->Flags)) )
                 RpcRaiseException( RPC_X_SS_IN_NULL_CONTEXT );

            ReturnHandle = 0;    // covers NULL case below.

            if ( ArgPtr && ! 
                 (ReturnHandle = NDRCContextBinding((NDR_CCONTEXT)ArgPtr)) )
                 RpcRaiseException( RPC_X_SS_CONTEXT_MISMATCH );

            break;

        default :
            NDR_ASSERT( 0, "ExplictBindHandleMgr : bad handle type" );
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    return ReturnHandle;
}


void
Ndr64MarshallHandle(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pArg,
    PNDR64_FORMAT       pFormat
    )
/*++

Routine description :

    Marshalls a context handle.

Arguments :
    
    pStubMsg    - Pointer to stub message.
    pArg        - Context handle to marshall (NDR_CCONTEXT or NDR_SCONTEXT).
    pFormat     - Context handle's format string description.

Return :

    Buffer pointer after marshalling the context handle.

--*/
{
    long    Index;
    NDR64_CONTEXT_HANDLE_FORMAT * pExplicitFormat;

    pExplicitFormat = ( NDR64_CONTEXT_HANDLE_FORMAT * ) pFormat;
    NDR_ASSERT( pExplicitFormat->FormatCode == FC64_BIND_CONTEXT, 
                "Ndr64MarshallHandle : Expected a context handle" );


    if ( pStubMsg->IsClient )
        {
        NDR_CCONTEXT Context;

        ALIGN( pStubMsg->Buffer, 0x3 );

        //
        // Get the context handle.
        //
        Context = NDR64_IS_HANDLE_PTR( pExplicitFormat->ContextFlags ) ? 
                        *((NDR_CCONTEXT *)pArg) : (NDR_CCONTEXT)pArg;

        //
        // An [in] only context handle must be non-zero.
        //
        if ( ! Context && ! NDR64_IS_HANDLE_OUT( pExplicitFormat->ContextFlags ) )
            RpcRaiseException( RPC_X_SS_IN_NULL_CONTEXT );

        NDRCContextMarshall( Context, (void *) pStubMsg->Buffer );

        pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;

        }
    else    
        {
 
        Index = pExplicitFormat->Ordinal;

        if ( NDR64_IS_HANDLE_RETURN( pExplicitFormat->ContextFlags ) )
            {
            NDR_SCONTEXT    SContext;

            //
            // Initialize the context handle.
            //
            SContext = Ndr64ContextHandleInitialize ( pStubMsg,
                                                      (PFORMAT_STRING)pFormat );

            //
            // Put the user context that was returned into the context
            // handle.
            //
            *((uchar **)NDRSContextValue(SContext)) = pArg;

            pStubMsg->SavedContextHandles[Index] = SContext;
            }

        // add a marker to indicate runtime is marshalling the context handle, 
        NDR_SCONTEXT pContext = pStubMsg->SavedContextHandles[Index];
        pStubMsg->SavedContextHandles[Index] = (NDR_SCONTEXT) CONTEXT_HANDLE_BEFORE_MARSHAL_MARKER;

        Ndr64ServerContextNewMarshall( pStubMsg,
                                     pContext,
                                     pStubMsg->StubDesc->apfnNdrRundownRoutines[pExplicitFormat->RundownRoutineIndex],
                                     (PFORMAT_STRING)pFormat );

        // after marshalling is finised, the hContext becomes invalid and 
        // We need to zero out the saved context to avoid referencing garbage.
        pStubMsg->SavedContextHandles[Index] = (NDR_SCONTEXT)CONTEXT_HANDLE_AFTER_MARSHAL_MARKER;
        }
}

void
Ndr64UnmarshallHandle(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppArg,
    PNDR64_FORMAT       pFormat,
    bool 		        /*fIgnored*/
    )
/*++

Routine description :

    Unmarshall a context handle.

Arguments :
    
    pStubMsg    - Pointer to stub message.
    ppArg       - Pointer to the context handle on the client/server stack.
                  On the client this is a NDR_CCONTEXT *.  On the server
                  side this is a NDR_SCONTEXT (regardless of direction).
    pFormat     - Context handle's format string description.
    fIgnored    - Ignored, but needed to match necessary routine prototype.

Return :

    Buffer pointer after unmarshalling the context handle.

--*/
{
    NDR64_CONTEXT_HANDLE_FORMAT *   pExplicitFormat;

    pExplicitFormat = (NDR64_CONTEXT_HANDLE_FORMAT * )pFormat;
    NDR_ASSERT( pExplicitFormat->FormatCode == FC64_BIND_CONTEXT, 
                "Ndr64UnmarshallHHandle : Expected a context handle" );

    if ( pStubMsg->IsClient )
        {

        ALIGN( pStubMsg->Buffer, 0x3 );

        //
        // Check if we have a pointer to a context handle
        // (the pointer can't be null).
        //
        if ( NDR64_IS_HANDLE_PTR( pExplicitFormat->ContextFlags ) )
            {
            ppArg = (uchar **) *ppArg;
            }

        //
        // Zero an [out] only context handle before unmarshalling.
        //
        if ( ! NDR64_IS_HANDLE_IN( pExplicitFormat->ContextFlags ) )
            *ppArg = 0;

        //
        // We must use the original binding handle in this call.   
        //
        NDRCContextUnmarshall( (NDR_CCONTEXT *)ppArg,
                               pStubMsg->SavedHandle,
                               (void *)pStubMsg->Buffer,
                               pStubMsg->RpcMsg->DataRepresentation );

        pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;

        }
    else
        {
        NDR_SCONTEXT SContext = 
            Ndr64ServerContextNewUnmarshall( pStubMsg,
                                             (PFORMAT_STRING)pFormat );

        Ndr64SaveContextHandle( pStubMsg, 
                              SContext, 
                              ppArg, 
                              (PFORMAT_STRING)pFormat );
        }
}


void 
Ndr64SaveContextHandle (
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_SCONTEXT        CtxtHandle,
    uchar **            ppArg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description : 

    Saves a context handle's current value and then extracts the user's
    context value.

Arguments :

    pStubMsg    - The stub message.
    CtxtHandle  - The context handle.
    ppArg       - Pointer to where user's context value should go.

Return : 

    None.

*/
{
    long    Index;

    // no NT3.5 stub in ndr64.
    Index = ( ( NDR64_CONTEXT_HANDLE_FORMAT * ) pFormat)->Ordinal;

    pStubMsg->SavedContextHandles[Index] = CtxtHandle;

    // On 32b alphas, a handle pointer needs to be properly sign extended
    // to a 64b virtual stack value, as this will become the register value.
    // So, we cast to the REGISTER_TYPE to get the sign extension

    if ( ! NDR64_IS_HANDLE_PTR(( ( NDR64_CONTEXT_HANDLE_FORMAT * ) pFormat)->ContextFlags) )
        *((REGISTER_TYPE*)ppArg) = (REGISTER_TYPE) *(NDRSContextValue(CtxtHandle));
    else
        *((REGISTER_TYPE*)ppArg) = (REGISTER_TYPE) NDRSContextValue(CtxtHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\makefile.inc ===
# Copyright (c) 1993-1999 Microsoft Corporation
#
# Build wxndr20.lib from rpcndr20.lib. We need to remove all objects that
# have functions that are thunked (ie, under EXPORT_RT in rpcrt4.src) and 
# not emulated.
$(BASEDIR)\public\sdk\lib\i386\wxndr64.lib: $(BASEDIR)\public\sdk\lib\i386\rpcndr64.lib
     lib /remove:obj\i386\rpcssm.obj /out:$(BASEDIR)\public\sdk\lib\i386\wxndr64.lib $(BASEDIR)\public\sdk\lib\i386\rpcndr64.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\free.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993  - 1999 Microsoft Corporation

Module Name :

    free.c

Abstract :

    This file contains the routines called by MIDL 2.0 stubs and the 
    interpreter for freeing unmarshalled data on the server. 

Author :

    David Kays  dkays   September 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "precomp.hxx"
#include "..\..\ndr20\ndrole.h"

__forceinline void
Ndr64FreeTypeMemory( 
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory )
{

    if ( !pStubMsg->pPointerQueueState ||
         !pStubMsg->pPointerQueueState->GetActiveQueue() )
        {
        (*pStubMsg->pfnFree)(pMemory);
        return;
        }
    
    NDR_PFNFREE_POINTER_QUEUE_ELEMENT*pElement = 
        new(pStubMsg->pPointerQueueState) 
            NDR_PFNFREE_POINTER_QUEUE_ELEMENT(pStubMsg->pfnFree,
                                              pMemory );
    pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );
}

NDR64_FREE_POINTER_QUEUE_ELEMENT::NDR64_FREE_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg, 
    uchar * const pMemoryNew,
    const PFORMAT_STRING pFormatNew) :
        pMemory(pMemoryNew),
        pFormat(pFormatNew),
        uFlags(pStubMsg->uFlags),
        pCorrMemory(pStubMsg->pCorrMemory)
{

}

void 
NDR64_FREE_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{

    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );
    CORRELATION_CONTEXT CorrContext( pStubMsg, pCorrMemory );
    
    Ndr64ToplevelTypeFree( pStubMsg,
                           pMemory,
                           pFormat );
}

#if defined(DBG)
void 
NDR64_FREE_POINTER_QUEUE_ELEMENT::Print() 
{
    DbgPrint("NDR_FREE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("uFlags:                  %x\n", uFlags );
    DbgPrint("pCorrMemory:             %p\n", pCorrMemory );
}
#endif

void
Ndr64EnquePointeeFree(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{

    NDR64_POINTER_CONTEXT PointerContext( pStubMsg );

    RpcTryFinally
        {

        NDR64_FREE_POINTER_QUEUE_ELEMENT*pElement = 
            new(PointerContext.GetActiveState()) 
                NDR64_FREE_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                 (uchar*)pMemory,
                                                 (PFORMAT_STRING)pFormat);
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
        }
    RpcFinally
        {
        PointerContext.EndContext();
        }
    RpcEndFinally

}

__forceinline void
Ndr64PointeeFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    NDR64_RESET_EMBEDDED_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

    if ( !NdrIsLowStack( pStubMsg ) )
        {
        Ndr64ToplevelTypeFree( pStubMsg,
                               pMemory,
                               pFormat );
        return;
        }

    Ndr64EnquePointeeFree( 
        pStubMsg,
        pMemory,
        pFormat );

}

void
Ndr64pNoopFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    return;
}



__forceinline void 
Ndr64PointerFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a top level or embedded pointer to anything.

    Used for FC64_RP, FC64_UP, FC64_FP, FC64_OP.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_POINTER_FORMAT *pPointerFormat = (NDR64_POINTER_FORMAT*) pFormat;
    uchar *         pMemoryPointee = pMemory;

    if ( ! pMemory )
        return;

    if ( *(PFORMAT_STRING)pFormat == FC64_IP )
        {
        ((IUnknown *)pMemory)->Release();
        return;
        }

    if ( *(PFORMAT_STRING)pFormat == FC64_FP )
        {
        //
        // Check if we've already freed this full pointer.
        //
        if ( ! NdrFullPointerFree( pStubMsg->FullPtrXlatTables,
                                   pMemory ) )
            return;
        }

    if ( 0 == pPointerFormat->Flags )
        goto FreeEmbeddedPointers;  

    //
    // Check if this pointer and any possible embedded pointers should not
    // be freed.
    //
    if ( NDR64_DONT_FREE( pPointerFormat->Flags) )
        return;

    // 
    // Just go free a pointer to a simple type.
    //
    if ( NDR64_SIMPLE_POINTER( pPointerFormat->Flags ) ) 
        goto FreeTopPointer;

    // 
    // Check if this is an allocate all nodes pointer.  
    // IDL symantics say that we only free the top most allocate all nodes
    // pointer on the server even in the [out] only case.  So jump to the 
    // check for the pointer free at the end of the routine.  
    //  
    if ( NDR64_ALLOCATE_ALL_NODES( pPointerFormat->Flags ) )
        goto FreeTopPointer;

    if ( NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
        pMemoryPointee = *((uchar **)pMemory);

FreeEmbeddedPointers:


    Ndr64PointeeFree( pStubMsg,
                      pMemoryPointee,
                      pPointerFormat->Pointee );

FreeTopPointer:

    //
    // Now free the pointer.  Pointer guaranteed to be non-null here.
    //
    // We only free the pointer if it lies outside of the message buffer
    // that the server stub received from the RPC runtime. Otherwise we
    // used the RPC buffer to hold the pointer's data and should not free it.
    //
    if ( (pMemory < pStubMsg->BufferStart) || (pMemory > pStubMsg->BufferEnd) )
        {
        //
        // Also check to make sure that the pointer was not allocated on the
        // server stub's stack (this may happen for ref pointers).
        //
        // full pointer can't be allocated on stack
        if ( ! NDR64_ALLOCED_ON_STACK( pPointerFormat->Flags ) || 
             *(PFORMAT_STRING)pFormat == FC64_FP )
            {
            Ndr64FreeTypeMemory( pStubMsg, pMemory );
            }
        }
}


__forceinline void
Ndr64TopLevelPointerFree(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a top level or embedded pointer to anything.

    Used for FC64_RP, FC64_UP, FC64_FP, FC64_OP.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    Ndr64PointerFree( pStubMsg,
                      pMemory,
                      pFormat );

}

__forceinline void
Ndr64EmbeddedPointerFree(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )

{
    Ndr64PointerFree( pStubMsg,
                      *(uchar**)pMemory,
                      pFormat );
}


void 
Ndr64pRangeFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++
--*/
{
    return;
}


void 
Ndr64SimpleStructFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a simple structure's embedded pointers which were allocated during 
    a remote call.  

    Used for FC64_STRUCT and FC64_PSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_STRUCTURE_HEADER_FORMAT*) pFormat;

    if ( !pMemory || !pStructFormat->Flags.HasPointerInfo ) 
        return;

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );

    Ndr64pPointerLayoutFree( pStubMsg,
                             pStructFormat + 1,
                             0,
                             pMemory );
}


void 
Ndr64ConformantStructFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a conformant structure's embedded pointers which were allocated 
    during a remote call.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.
    
--*/
{
    const NDR64_CONF_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_CONF_STRUCTURE_HEADER_FORMAT*) pFormat;
    
    const NDR64_CONF_ARRAY_HEADER_FORMAT * const pArrayFormat =  
        (NDR64_CONF_ARRAY_HEADER_FORMAT *) pStructFormat->ArrayDescription;

    if ( !pMemory || !pStructFormat->Flags.HasPointerInfo )
        return;

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );

    NDR64_UINT32 MaxCount = (NDR64_UINT32)
    Ndr64EvaluateExpr( pStubMsg,
                       pArrayFormat->ConfDescriptor,
                       EXPR_MAXCOUNT );

    Ndr64pPointerLayoutFree( pStubMsg,
                             pStructFormat + 1,
                             MaxCount,
                             pMemory );
}


void 
Ndr64ComplexStructFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a complex structure's embedded pointers which were allocated during 
    a remote call.  

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_BOGUS_STRUCTURE_HEADER_FORMAT *  pStructFormat =
        (NDR64_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;
    const NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT * pConfStructFormat =
        (NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;

    PFORMAT_STRING  pFormatPointers = (PFORMAT_STRING)(pStructFormat->PointerLayout );

    PFORMAT_STRING  pFormatArray = NULL;

    PFORMAT_STRING  pMemberLayout = ( *(PFORMAT_STRING)pFormat == FC64_CONF_BOGUS_STRUCT ||
                                      *(PFORMAT_STRING)pFormat == FC64_FORCED_CONF_BOGUS_STRUCT ) ?
                                    (PFORMAT_STRING)( pConfStructFormat + 1) :
                                    (PFORMAT_STRING)( pStructFormat + 1);
    
    if ( !pMemory )
        return;

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );
    
    if ( pStructFormat->Flags.HasConfArray )
        {
        pFormatArray = (PFORMAT_STRING)pConfStructFormat->ConfArrayDescription;
        }

    for ( ; ; )
        {
        switch ( *pMemberLayout )
            {

            case FC64_STRUCT:
                {
                const NDR64_SIMPLE_REGION_FORMAT *pRegion = 
                    (NDR64_SIMPLE_REGION_FORMAT*) pMemberLayout;
                
                pMemory          += pRegion->RegionSize;

                pMemberLayout    += sizeof( *pRegion );
                break;
                }
            
            case FC64_STRUCTPADN :
                {
                const NDR64_MEMPAD_FORMAT *pMemPad = (NDR64_MEMPAD_FORMAT*)pMemberLayout;
                pMemory       += pMemPad->MemPad;
                pMemberLayout += sizeof(*pMemPad);
                break;
                }

            case FC64_POINTER :
                Ndr64EmbeddedPointerFree( pStubMsg,
                                          pMemory,
                                          pFormatPointers );

                pMemory += PTR_MEM_SIZE;

                pFormatPointers += sizeof(NDR64_POINTER_FORMAT);                
                pMemberLayout       += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);
                
                break;

            case FC64_EMBEDDED_COMPLEX :
                
                {

                const NDR64_EMBEDDED_COMPLEX_FORMAT * pEmbeddedFormat =
                    (NDR64_EMBEDDED_COMPLEX_FORMAT*) pMemberLayout;

                Ndr64EmbeddedTypeFree( pStubMsg,
                                       pMemory,
                                       pEmbeddedFormat->Type );

                pMemory = Ndr64pMemoryIncrement( pStubMsg,
                                                 pMemory,
                                                 pEmbeddedFormat->Type,
                                                 FALSE );

                pMemberLayout += sizeof( *pEmbeddedFormat );

                break;
                }

            case FC64_BUFFER_ALIGN:
                {
                const NDR64_BUFFER_ALIGN_FORMAT *pBufAlign = 
                    (NDR64_BUFFER_ALIGN_FORMAT*) pMemberLayout;
                pMemberLayout += sizeof( *pBufAlign );
                break;
                }

             case FC64_CHAR :
             case FC64_WCHAR :
             case FC64_INT8:
             case FC64_UINT8:
             case FC64_INT16:
             case FC64_UINT16:
             case FC64_INT32:
             case FC64_UINT32:
             case FC64_INT64:
             case FC64_UINT64:
             case FC64_FLOAT32 :
             case FC64_FLOAT64 :
             case FC64_ERROR_STATUS_T:
                pMemory       += NDR64_SIMPLE_TYPE_MEMSIZE(*pMemberLayout);
                pMemberLayout += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);
                break;
                        
            case FC64_IGNORE :
                pMemory             += PTR_MEM_SIZE;
                pMemberLayout       += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);
                break;
            
            case FC64_END :
                goto ComplexFreeEnd;

            default :
                NDR_ASSERT(0,"Ndr64ComplexStructFree : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return;
            } // switch
        } // for

ComplexFreeEnd :

    if ( pFormatArray )
        {

        Ndr64EmbeddedTypeFree( pStubMsg,
                               pMemory,
                               pFormatArray );
        }
}


void 
Ndr64FixedArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a fixed array's embedded pointers which were allocated during 
    a remote call.  

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_FIX_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_FIX_ARRAY_HEADER_FORMAT*) pFormat;
    
    if ( ! pMemory || !pArrayFormat->Flags.HasPointerInfo ) 
        return;
    
    Ndr64pPointerLayoutFree( pStubMsg,
                             pArrayFormat + 1,
                             0,
                             pMemory );

}


void 
Ndr64ConformantArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a one dimensional conformant array's embedded pointers which were 
    allocated during a remote call.  Called for both top level and embedded
    conformant arrays.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_CONF_ARRAY_HEADER_FORMAT *pArrayFormat =
        (NDR64_CONF_ARRAY_HEADER_FORMAT*) pFormat;
    
    if ( ! pMemory || !pArrayFormat->Flags.HasPointerInfo ) 
        return;

    NDR64_UINT32 MaxCount = (NDR64_UINT32)
    Ndr64EvaluateExpr( pStubMsg,
                       pArrayFormat->ConfDescriptor,
                       EXPR_MAXCOUNT );

    Ndr64pPointerLayoutFree( pStubMsg,
                             pArrayFormat + 1,
                             MaxCount,
                             pMemory );
        
}


void 
Ndr64ConformantVaryingArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a one dimensional conformant varying array's embedded pointers which 
    were allocated during a remote call.  Called for both top level and 
    embedded conformant varying arrays.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_CONF_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_CONF_VAR_ARRAY_HEADER_FORMAT*) pFormat;

    if ( ! pMemory || !pArrayFormat->Flags.HasPointerInfo) 
        return;
    
    NDR64_UINT32 ActualCount = (NDR64_UINT32)
        Ndr64EvaluateExpr( pStubMsg,
                           pArrayFormat->VarDescriptor,
                           EXPR_ACTUALCOUNT );

    Ndr64pPointerLayoutFree( pStubMsg,
                             pArrayFormat + 1,
                             ActualCount,
                             pMemory );
}


void 
Ndr64VaryingArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a varying array's embedded pointers which were allocated 
    during a remote call.  Called for both top level and embedded varying
    arrays.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_VAR_ARRAY_HEADER_FORMAT*) pFormat;
    
    if ( ! pMemory || !pArrayFormat->Flags.HasPointerInfo) 
        return;

    NDR64_UINT32 ActualCount = (NDR64_UINT32)
    Ndr64EvaluateExpr( pStubMsg,
                       pArrayFormat->VarDescriptor,
                       EXPR_ACTUALCOUNT );

    Ndr64pPointerLayoutFree( pStubMsg,
                             pArrayFormat + 1,
                             ActualCount,
                             pMemory );

}


void 
Ndr64ComplexArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a complex array's embedded pointers which were allocated 
    during a remote call.  Called for both top level and embedded complex
    arrays.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_BOGUS_ARRAY_HEADER_FORMAT *pArrayFormat =
        (NDR64_BOGUS_ARRAY_HEADER_FORMAT *) pFormat;
        
    BOOL                IsFixed = ( pArrayFormat->FormatCode == FC64_FIX_BOGUS_ARRAY ) ||
                                  ( pArrayFormat->FormatCode == FC64_FIX_FORCED_BOGUS_ARRAY );
    
    PFORMAT_STRING      pElementFormat  = (PFORMAT_STRING)pArrayFormat->Element;

    //
    // We have to check this in case we get an exception before actually 
    // unmarshalling the array.
    // 
    if ( ! pMemory ) 
        return;
    
    NDR64_WIRE_COUNT_TYPE    Elements = pArrayFormat->NumberElements; 
    NDR64_WIRE_COUNT_TYPE    Count    = Elements;
    NDR64_WIRE_COUNT_TYPE    Offset   = 0;

    if ( !IsFixed )
        {
        const NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT* pConfVarFormat=
             (NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT*)pFormat;

        //
        // Check for conformance description.
        //
        if ( pConfVarFormat->ConfDescription )
            {
            Elements = (NDR64_UINT32)Ndr64EvaluateExpr( pStubMsg,
                                                        pConfVarFormat->ConfDescription,
                                                        EXPR_MAXCOUNT );
            Offset = 0;
            Count = Elements;

            }

        //
        // Check for variance description.
        //
        if ( pConfVarFormat->VarDescription )
            {
            Count = (NDR64_UINT32)
                Ndr64EvaluateExpr( pStubMsg,
                                   pConfVarFormat->VarDescription,
                                   EXPR_ACTUALCOUNT );

            Offset = (NDR64_UINT32)
                Ndr64EvaluateExpr( pStubMsg,
                                   pConfVarFormat->OffsetDescription,
                                   EXPR_OFFSET );

            }
        
        }

    NDR64_UINT32    ElementMemorySize = 
        Ndr64pMemorySize( pStubMsg,
                          pElementFormat,
                          FALSE );

    pMemory += Ndr64pConvertTo2GB((NDR64_UINT64)Offset * 
                                  (NDR64_UINT64)ElementMemorySize);

    Ndr64pConvertTo2GB( (NDR64_UINT64)Elements *
                        (NDR64_UINT64)ElementMemorySize );
    Ndr64pConvertTo2GB( (NDR64_UINT64)Count *
                        (NDR64_UINT64)ElementMemorySize );

    for ( ; Count--; )
        {

        Ndr64EmbeddedTypeFree( pStubMsg,
                               pMemory,
                               pElementFormat );

        pMemory += ElementMemorySize;
        }

}


void 
Ndr64UnionFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees an encapsulated union's embedded pointers which were allocated 
    during a remote call.  

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_UNION_ARM_SELECTOR* pArmSelector;

    EXPR_VALUE          SwitchIs;
    NDR64_FORMAT_CHAR   SwitchType;
    uchar *pArmMemory;
    
    if ( !pMemory )
        return;
    
    switch(*(PFORMAT_STRING)pFormat)
        {
        case FC64_NON_ENCAPSULATED_UNION:
            {
            const NDR64_NON_ENCAPSULATED_UNION* pNonEncapUnionFormat =
                (const NDR64_NON_ENCAPSULATED_UNION*) pFormat;

            SwitchType      = pNonEncapUnionFormat->SwitchType;
            pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pNonEncapUnionFormat + 1);

            SwitchIs   = Ndr64EvaluateExpr( pStubMsg,
                                            pNonEncapUnionFormat->Switch,
                                            EXPR_SWITCHIS );
            
            pArmMemory = pMemory;
            break;
            }
        case FC64_ENCAPSULATED_UNION:
            {
            const NDR64_ENCAPSULATED_UNION* pEncapUnionFormat =
                (const NDR64_ENCAPSULATED_UNION*)pFormat;

            SwitchType      = pEncapUnionFormat->SwitchType;
            pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pEncapUnionFormat + 1);
                
            SwitchIs        = Ndr64pSimpleTypeToExprValue( SwitchType,
                                                           pMemory );
            pArmMemory      = pMemory + pEncapUnionFormat->MemoryOffset;
            break;
            }
        default:
            NDR_ASSERT("Bad union format\n", 0);
            return;
        }

    PNDR64_FORMAT pArmFormat = 
        Ndr64pFindUnionArm( pStubMsg,
                            pArmSelector, 
                            SwitchIs );
    
    if ( !pArmFormat )
        return;

    Ndr64EmbeddedTypeFree( pStubMsg,
                           pArmMemory,
                           pArmFormat );
}


void 
Ndr64XmitOrRepAsFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees the transmit-as object (actually the presented type instance)
    and steps over the object.

    There is an exceptional situation where the spec forbids stub to free
    the instance. This happens when there is an [in] only parameter with
    a [transmit_as()] on a component of the parameter, and the presented
    typedef is composed of one or more pointers.
    We have a flag in the stub msg that is set when this happens.

    See mrshl.c for the description of the FC layout.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_TRANSMIT_AS_FORMAT *pTransFormat =
        ( const NDR64_TRANSMIT_AS_FORMAT *) pFormat;
    
    if ( !pMemory )
        return;

    NDR_ASSERT( pTransFormat->FormatCode == FC64_TRANSMIT_AS || pTransFormat->FormatCode , "invalid format string for user marshal" );

    unsigned short QIndex = pTransFormat->RoutineIndex;
    const XMIT_ROUTINE_QUINTUPLE * pQuintuple = pStubMsg->StubDesc->aXmitQuintuple;

    // Free the presented type instance unless forbidden explicitely.

    if ( ! pStubMsg->fDontCallFreeInst )
        {
        pStubMsg->pPresentedType = pMemory;
        pQuintuple[ QIndex ].pfnFreeInst( pStubMsg );
        }
}


void 
Ndr64UserMarshalFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees the usr_marshal object and steps over the object.
    See mrshl.c for the description of the layouts.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    NDR64_USER_MARSHAL_FORMAT  *      pUserFormat = 
        ( NDR64_USER_MARSHAL_FORMAT *) pFormat;

    NDR_ASSERT( pUserFormat->FormatCode == FC64_USER_MARSHAL, "invalid format string for user marshal" );

    unsigned short QIndex = pUserFormat->RoutineIndex;
    const USER_MARSHAL_ROUTINE_QUADRUPLE * pQuadruple = 
        (const USER_MARSHAL_ROUTINE_QUADRUPLE *)( (  NDR_PROC_CONTEXT *)pStubMsg->pContext )->pSyntaxInfo->aUserMarshalQuadruple;

    // Call the user to free his stuff.
    USER_MARSHAL_CB        UserMarshalCB;
    Ndr64pInitUserMarshalCB( pStubMsg,
                           pUserFormat,
                           USER_MARSHAL_CB_FREE,
                           & UserMarshalCB);

    // The user shouldn't ever free the top level object as we free it.
    // He should free only pointees of his top level object.

    pQuadruple[ QIndex ].pfnFree( (ulong*) &UserMarshalCB, pMemory );

    // Ndr64pMemoryIncrement steps over the memory object.
}

// define the jump table
#define NDR64_BEGIN_TABLE  \
PNDR64_FREE_ROUTINE extern const Ndr64FreeRoutinesTable[] = \
{                                                          

#define NDR64_TABLE_END    \
};                         

#define NDR64_ZERO_ENTRY   NULL
#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) ,NULL
#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number ) ,NULL

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,free                     

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, buffersize, memorysize) \
   ,Ndr64pNoopFree         
   

#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64FreeRoutinesTable)/sizeof(PNDR64_FREE_ROUTINE) == 256 );

#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_ENTRY

#define NDR64_BEGIN_TABLE \
PNDR64_FREE_ROUTINE extern const Ndr64EmbeddedFreeRoutinesTable[] = \
{

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,embeddedfree
   
#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64EmbeddedFreeRoutinesTable) / sizeof(PNDR64_FREE_ROUTINE) == 256 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\memsize.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 - 1999 Microsoft Corporation

Module Name :

    memsize.c

Abstract :

    This file contains the routines called by MIDL 2.0 stubs and the
    intepreter for computing the memory size needed to hold a parameter being
    unmarshalled.

Author :

    David Kays  dkays   November 1993.

Revision History :

Note:
    Simple types are not checked for buffer over-run since we are
    only reading from the buffer and not writing from it.  So if
    a buffer overun actually occures, no real damage is done.

  ---------------------------------------------------------------------*/

#include "precomp.hxx"
#include "..\..\ndr20\ndrole.h"


void
Ndr64UDTSimpleTypeMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT      pFormat )

/*++
--*/
{
    ALIGN(pStubMsg->Buffer, NDR64_SIMPLE_TYPE_MEMALIGN(*(PFORMAT_STRING)pFormat));

    pStubMsg->Buffer += NDR64_SIMPLE_TYPE_BUFSIZE(*(PFORMAT_STRING)pFormat);

    LENGTH_ALIGN( pStubMsg->MemorySize,
                  NDR64_SIMPLE_TYPE_MEMALIGN(*(PFORMAT_STRING)pFormat) );

    pStubMsg->MemorySize += NDR64_SIMPLE_TYPE_MEMSIZE(*(PFORMAT_STRING)pFormat);
}



void
Ndr64pRangeMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++
--*/
{
   const NDR64_RANGE_FORMAT * pRangeFormat =
        (const NDR64_RANGE_FORMAT*)pFormat;

   Ndr64UDTSimpleTypeMemorySize( pStubMsg,
                                 (PFORMAT_STRING)&pRangeFormat->RangeType );
}


void
Ndr64pInterfacePointerMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size needed for an interface pointer.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The current memory size.

    // wire representation of a marshalled interface pointer
    typedef struct tagMInterfacePointer
    {
        ULONG           ulCntData;          // size of data
        [size_is(ulCntData)] BYTE abData[]; // data (OBJREF)
    } MInterfacePointer;

--*/
{

    ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

    // Unmarshal the conformant size and the count field.
    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, (sizeof(NDR64_WIRE_COUNT_TYPE)+sizeof(ulong)) );
    NDR64_UINT32 MaxCount = Ndr64pConvertTo2GB( *(NDR64_WIRE_COUNT_TYPE *) pStubMsg->Buffer );
    pStubMsg->Buffer      += sizeof(NDR64_WIRE_COUNT_TYPE);
    ulong ulCntData       = *(ulong *) pStubMsg->Buffer;
    pStubMsg->Buffer      += sizeof(ulong);

    if ( MaxCount != ulCntData )
        {
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        return;
        }

    RpcTryFinally
        {

        CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, MaxCount );

        if( (MaxCount > 0) && NDR64_IS_WALKIP(pStubMsg->uFlags) )
        {

#if defined(DEBUG_WALKIP)
            CHAR AppName[MAX_PATH];
            memset(AppName, 0, sizeof(AppName ) );
            GetModuleFileNameA( NULL, AppName, sizeof(AppName ) );
            DbgPrint("WALKIP64 %s %p\n", AppName, pStubMsg->Buffer );
#else
            IStream *pStream = (*NdrpCreateStreamOnMemory)(pStubMsg->Buffer, MaxCount);
            if(pStream == 0)
                RpcRaiseException(RPC_S_OUT_OF_MEMORY);

            HRESULT hr = (*pfnCoReleaseMarshalData)(pStream);
            pStream->Release();

            if(FAILED(hr))
                RpcRaiseException(hr);
#endif
        }

        }
    RpcFinally
        {

        pStubMsg->Buffer += MaxCount;

        }
    RpcEndFinally
}


__forceinline void
Ndr64pPointerMemorySizeInternal(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE *pBufferMark,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Private routine for computing the memory size required for a pointer to
    anything.  This is the entry point for pointers embedded in structures
    arrays, or unions.

    Used for FC64_RP, FC64_UP, FC64_FP, FC64_OP.

Arguments :

    pStubMsg    - Pointer to stub message.
    pBufferMark - Location in the buffer where a unique or full pointer's id is.
                  Unused for ref pointers.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_POINTER_FORMAT *pPointerFormat = (NDR64_POINTER_FORMAT*) pFormat;

    PFORMAT_STRING pPointeeFormat = (PFORMAT_STRING)pPointerFormat->Pointee;

    switch ( pPointerFormat->FormatCode )
        {
        case FC64_RP :
            break;

        case FC64_UP :
        case FC64_OP :
            if ( ! *pBufferMark )
                return;
            break;

        case FC64_IP :
            if ( ! *pBufferMark )
                return;


            Ndr64pInterfacePointerMemorySize(pStubMsg,
                                             pPointeeFormat );
            return;

        case FC64_FP :
            //
            // Check if we've already mem sized this full pointer.
            //
            if ( Ndr64pFullPointerQueryRefId( pStubMsg,
                                              Ndr64pWirePtrToRefId(*pBufferMark),
                                              FULL_POINTER_MEM_SIZED,
                                              0 ) )
                return;

            break;

        default :
            NDR_ASSERT(0,"Ndr64pPointerMemorySize : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    //
    // We align all memory pointers on at least a void * boundary.
    //
    LENGTH_ALIGN( pStubMsg->MemorySize, PTR_MEM_ALIGN );

    if ( NDR64_SIMPLE_POINTER( pPointerFormat->Flags ) )
        {
        ALIGN(pStubMsg->Buffer, NDR64_SIMPLE_TYPE_BUFALIGN( *pPointeeFormat ));
        pStubMsg->Buffer += NDR64_SIMPLE_TYPE_BUFSIZE( *pPointeeFormat );

        LENGTH_ALIGN( pStubMsg->MemorySize,
                      NDR64_SIMPLE_TYPE_MEMALIGN( *pPointeeFormat ) );
        pStubMsg->MemorySize += NDR64_SIMPLE_TYPE_MEMSIZE( *pPointeeFormat );

        return;
        }

    // Pointer to complex type.

    if ( NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
        pStubMsg->MemorySize += PTR_MEM_SIZE;

    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    NDR64_RESET_EMBEDDED_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

    Ndr64TopLevelTypeMemorySize( pStubMsg,
                                 pPointeeFormat );

    return;
}


void NDR64_MEMSIZE_POINTER_QUEUE_ELEMENT::Dispatch(PMIDL_STUB_MESSAGE pStubMsg)
{
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );

    Ndr64pPointerMemorySizeInternal( pStubMsg,
                                     pBufferMark,
                                     pFormat );

}

#if defined(DBG)
void NDR64_MEMSIZE_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR64_MEMSIZE_POINTER_QUEUE_ELEMENT:\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("uFlags:                  %u\n", uFlags );
    DbgPrint("pBufferMark:             %p\n", pBufferMark );
}
#endif

void
Ndr64pEnquePointerMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE *pBufferMark,
    PNDR64_FORMAT       pFormat )
{

    NDR64_POINTER_CONTEXT PointerContext( pStubMsg );

    RpcTryFinally
        {
        if ( !PointerContext.ShouldEnque() )
            {
            Ndr64pPointerMemorySizeInternal( pStubMsg,
                                             pBufferMark,
                                             pFormat );

            }
        else
            {
            NDR64_MEMSIZE_POINTER_QUEUE_ELEMENT*pElement =
                new(PointerContext.GetActiveState())
                    NDR64_MEMSIZE_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                        (PFORMAT_STRING)pFormat,
                                                        pBufferMark );
            PointerContext.Enque( pElement );
            }
        PointerContext.DispatchIfRequired();
        }
    RpcFinally
        {
        PointerContext.EndContext();
        }
    RpcEndFinally

}

void
Ndr64pPointerMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE *pBufferMark,
    PNDR64_FORMAT       pFormat )
{
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    NDR64_RESET_EMBEDDED_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

    if ( !NdrIsLowStack(pStubMsg) )
        {
        Ndr64pPointerMemorySizeInternal(
            pStubMsg,
            pBufferMark,
            pFormat );
        return;
        }


    Ndr64pEnquePointerMemorySize(
        pStubMsg,
        pBufferMark,
        pFormat );

}


__forceinline void
Ndr64TopLevelPointerMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
{
    NDR64_PTR_WIRE_TYPE * pBufferMark = NULL;

    //
    // If this is not a ref pointer then mark where the pointer's id is in
    // the buffer and increment the stub message buffer pointer.
    //
    if ( *(PFORMAT_STRING)pFormat != FC64_RP )
        {
        ALIGN(pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );

        pBufferMark = (NDR64_PTR_WIRE_TYPE*)pStubMsg->Buffer;

        pStubMsg->Buffer += sizeof( NDR64_PTR_WIRE_TYPE );
        }
     pStubMsg->MemorySize += PTR_MEM_SIZE;

     Ndr64pPointerMemorySize( pStubMsg,
                             pBufferMark,
                             pFormat );

}


__forceinline void
Ndr64EmbeddedPointerMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
{

    ALIGN(pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );
    NDR64_PTR_WIRE_TYPE * pBufferMark = (NDR64_PTR_WIRE_TYPE*)pStubMsg->Buffer;
    pStubMsg->Buffer += sizeof( NDR64_PTR_WIRE_TYPE );
    pStubMsg->MemorySize += PTR_MEM_SIZE;

    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    POINTER_MEMSIZE_SWAP_CONTEXT SwapContext( pStubMsg );

    Ndr64pPointerMemorySize( pStubMsg,
                             pBufferMark,
                             pFormat );

}


void
Ndr64SimpleStructMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size required for a simple structure.

    Used for FC64_STRUCT and FC64_PSTRUCT.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Structure's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_STRUCTURE_HEADER_FORMAT*) pFormat;

    ALIGN( pStubMsg->Buffer, pStructFormat->Alignment );

    uchar *pBufferSave = pStubMsg->Buffer;

    LENGTH_ALIGN( pStubMsg->MemorySize, pStructFormat->Alignment );

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + pStructFormat->MemorySize );
    pStubMsg->Buffer += pStructFormat->MemorySize;
    pStubMsg->MemorySize += pStructFormat->MemorySize;

    if ( pStructFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMemorySize( pStubMsg,
                                       pStructFormat + 1,
                                       0,
                                       pBufferSave );
        }
}


void
Ndr64ConformantStructMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size required for a conformant structure.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_CONF_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_CONF_STRUCTURE_HEADER_FORMAT*) pFormat;

    NDR64_WIRE_COUNT_TYPE MaxCount;

    const NDR64_CONF_ARRAY_HEADER_FORMAT * const pArrayFormat =
        (NDR64_CONF_ARRAY_HEADER_FORMAT *) pStructFormat->ArrayDescription;

    if ( !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        // Align for the conformance count.
        ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );
        MaxCount = *((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else
        {
        MaxCount = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
        }

    NDR64_UINT32 StructSize =  Ndr64pConvertTo2GB( (NDR64_UINT64)pStructFormat->MemorySize +
                                                   ( MaxCount * (NDR64_UINT64)pArrayFormat->ElementSize ) );

    // Realign for struct
    ALIGN(pStubMsg->Buffer, pStructFormat->Alignment);

    uchar *pBufferSave = pStubMsg->Buffer;

    LENGTH_ALIGN( pStubMsg->MemorySize, pStructFormat->Alignment );

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, StructSize );
    pStubMsg->Buffer        += StructSize;
    pStubMsg->MemorySize    += StructSize;

    if ( pStructFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMemorySize( pStubMsg,
                                       pStructFormat + 1,
                                       (NDR64_UINT32)MaxCount,
                                       pBufferSave );

        }
}


void
Ndr64ComplexStructMemorySize(
    PMIDL_STUB_MESSAGE    pStubMsg,
    PNDR64_FORMAT         pFormat )
/*++

Routine Description :

    Computes the memory size required for a complex structure.

    Used for FC64_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

Notes:
    This routine can calculate the memory size with or without pointees.
    When calculating size with pointees at the top level, the routine calls
    itself recursively to find out where pointees would be and then remember
    the context using pStubMsg->MemorySize and pStubMsg->PointerBufferMark.

--*/
{
    const NDR64_BOGUS_STRUCTURE_HEADER_FORMAT *  pStructFormat =
        (NDR64_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;
    const NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT * pConfStructFormat =
        (NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;

    bool fSetPointerBufferMark = !pStubMsg->IgnoreEmbeddedPointers &&
                                 !pStubMsg->PointerBufferMark;

    if ( fSetPointerBufferMark )
        {
        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        // This gets clobbered.
        uchar * BufferSave = pStubMsg->Buffer;
        ulong MemorySizeSave = pStubMsg->MemorySize;

        //
        // Get a buffer pointer to where the struct's pointees are.
        //
        Ndr64ComplexStructMemorySize(
            pStubMsg,
            pFormat );


        // Mark where the pointees begin.
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;
        pStubMsg->PointerLength     = pStubMsg->MemorySize;

        pStubMsg->IgnoreEmbeddedPointers = FALSE;

        pStubMsg->MemorySize = MemorySizeSave;
        pStubMsg->Buffer = BufferSave;
        }

    PFORMAT_STRING  pFormatPointers = (PFORMAT_STRING)pStructFormat->PointerLayout;
    PFORMAT_STRING  pFormatArray = NULL;

    PFORMAT_STRING  pMemberLayout = ( *(PFORMAT_STRING)pFormat == FC64_CONF_BOGUS_STRUCT ||
                                      *(PFORMAT_STRING)pFormat == FC64_FORCED_CONF_BOGUS_STRUCT ) ?
                                    (PFORMAT_STRING)( pConfStructFormat + 1) :
                                    (PFORMAT_STRING)( pStructFormat + 1);

    SAVE_CONTEXT<uchar>  uFlagsSave( pStubMsg->uFlags );
    SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark );

    // Get conformant array description.
    if ( pStructFormat->Flags.HasConfArray )
        {
        pFormatArray = (PFORMAT_STRING)pConfStructFormat->ConfArrayDescription;

        if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
            {

            NDR64_WIRE_COUNT_TYPE ConformanceSize;

            ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

            // conformance count marker
            pStubMsg->ConformanceMark = pStubMsg->Buffer;

            // Handle multidimensional arrays.
            ConformanceSize = pConfStructFormat->Dimensions * sizeof(NDR64_WIRE_COUNT_TYPE);

            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + ConformanceSize );
            pStubMsg->Buffer += ConformanceSize;

            NDR64_SET_CONF_MARK_VALID( pStubMsg->uFlags );
            }
        }
    else
        {
        pFormatArray = 0;
        }

    ALIGN(pStubMsg->Buffer, pStructFormat->Alignment);

    for ( ; ; )
        {
        switch ( *pMemberLayout )
            {

            case FC64_STRUCT:
                {
                const NDR64_SIMPLE_REGION_FORMAT *pRegion =
                    (NDR64_SIMPLE_REGION_FORMAT*) pMemberLayout;

                ALIGN( pStubMsg->Buffer, pRegion->Alignment );

                CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + pRegion->RegionSize );
                pStubMsg->Buffer        += pRegion->RegionSize;
                pStubMsg->MemorySize    += pRegion->RegionSize;

                pMemberLayout           += sizeof( *pRegion );
                break;
                }

            case FC64_STRUCTPADN :
                {
                const NDR64_MEMPAD_FORMAT *pMemPad = (NDR64_MEMPAD_FORMAT*)pMemberLayout;
                pStubMsg->MemorySize    += pMemPad->MemPad;
                pMemberLayout           += sizeof(*pMemPad);
                break;
                }

            case FC64_POINTER :

                Ndr64EmbeddedPointerMemorySize(
                    pStubMsg,
                    pFormatPointers );

                pFormatPointers += sizeof(NDR64_POINTER_FORMAT);
                pMemberLayout += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);

                break;

            case FC64_EMBEDDED_COMPLEX :
                {
                const NDR64_EMBEDDED_COMPLEX_FORMAT * pEmbeddedFormat =
                    (NDR64_EMBEDDED_COMPLEX_FORMAT*) pMemberLayout;

                Ndr64EmbeddedTypeMemorySize( pStubMsg,
                                             pEmbeddedFormat->Type );

                pMemberLayout += sizeof(*pEmbeddedFormat);

                break;

                }

            case FC64_BUFFER_ALIGN:
                {
                const NDR64_BUFFER_ALIGN_FORMAT *pBufAlign =
                    (NDR64_BUFFER_ALIGN_FORMAT*) pMemberLayout;
                ALIGN( pStubMsg->Buffer, pBufAlign->Alignment );
                pMemberLayout += sizeof( *pBufAlign );
                break;
                }

             case FC64_CHAR :
             case FC64_WCHAR :
             case FC64_INT8:
             case FC64_UINT8:
             case FC64_INT16:
             case FC64_UINT16:
             case FC64_INT32:
             case FC64_UINT32:
             case FC64_INT64:
             case FC64_UINT64:
             case FC64_FLOAT32 :
             case FC64_FLOAT64 :
             case FC64_ERROR_STATUS_T:
                ALIGN(pStubMsg->Buffer, NDR64_SIMPLE_TYPE_BUFALIGN(*pMemberLayout));

                pStubMsg->Buffer += NDR64_SIMPLE_TYPE_BUFSIZE( *pMemberLayout );
                pStubMsg->MemorySize += NDR64_SIMPLE_TYPE_MEMSIZE(*pMemberLayout);

                pMemberLayout += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);
                break;

            case FC64_IGNORE:
                ALIGN(pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );
                pStubMsg->Buffer     += sizeof(NDR64_PTR_WIRE_TYPE) ;
                pStubMsg->MemorySize += PTR_MEM_SIZE;

                pMemberLayout += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);
                break;

            case FC64_END :
                goto ComplexMemorySizeEnd;

            default :
                NDR_ASSERT(0,"Ndr64ComplexStructMemorySize : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return;
            }
        }

ComplexMemorySizeEnd :

    if ( pFormatArray )
        {
        Ndr64EmbeddedTypeMemorySize( pStubMsg,
                                     pFormatArray );
        }
    else
        {
        // If the structure doesn't have a conformant array, align it again
        ALIGN( pStubMsg->Buffer, pStructFormat->Alignment );
        }

    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer            = pStubMsg->PointerBufferMark;
        pStubMsg->MemorySize        = pStubMsg->PointerLength;
        pStubMsg->PointerBufferMark = 0;
        pStubMsg->PointerLength     = 0;
        }
}


void
Ndr64FixedArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size of a fixed array of any number of dimensions.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_FIX_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_FIX_ARRAY_HEADER_FORMAT*) pFormat;

    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment );
    LENGTH_ALIGN( pStubMsg->MemorySize, pArrayFormat->Alignment );

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + pArrayFormat->TotalSize );
    uchar *pBufferStart = pStubMsg->Buffer;

    pStubMsg->Buffer        += pArrayFormat->TotalSize;
    pStubMsg->MemorySize    += pArrayFormat->TotalSize;

    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMemorySize( pStubMsg,
                                       pArrayFormat + 1,
                                       0,
                                       pBufferStart );
        }
}


void
Ndr64ConformantArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size of a top level one dimensional conformant array.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{


    const NDR64_CONF_ARRAY_HEADER_FORMAT *pArrayFormat =
        (NDR64_CONF_ARRAY_HEADER_FORMAT*) pFormat;

    NDR64_WIRE_COUNT_TYPE MaxCount;
    if ( !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );
        MaxCount = *((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else
        {
        MaxCount = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
        }

    NDR64_UINT32 Size = Ndr64pConvertTo2GB( MaxCount *
                               (NDR64_UINT64)pArrayFormat->ElementSize );

    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment );
    LENGTH_ALIGN( pStubMsg->MemorySize, pArrayFormat->Alignment );

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, Size );
    uchar *pBufferStart     =  pStubMsg->Buffer;
    pStubMsg->Buffer        += Size;
    pStubMsg->MemorySize    += Size;

    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMemorySize( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)MaxCount,
                                       pBufferStart );

        }
}


void
Ndr64ConformantVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size of a one dimensional top level conformant
    varying array.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_CONF_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_CONF_VAR_ARRAY_HEADER_FORMAT*) pFormat;

    NDR64_WIRE_COUNT_TYPE MaxCount;
    if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        // Align the buffer for conformance unmarshalling.
        ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

        MaxCount = *((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else
        {
        MaxCount = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
        }

    //
    // Get the offset and actual count in case needed for pointer sizing.
    //
    ALIGN(pStubMsg->Buffer,NDR64_WIRE_COUNT_ALIGN);

    NDR64_WIRE_COUNT_TYPE Offset      = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[0];
    NDR64_WIRE_COUNT_TYPE ActualCount = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[1];
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_UINT32 MemorySize  = Ndr64pConvertTo2GB(MaxCount *
                                     (NDR64_UINT64)pArrayFormat->ElementSize );
    NDR64_UINT32 BufferSize  = Ndr64pConvertTo2GB(ActualCount *
                                     (NDR64_UINT64)pArrayFormat->ElementSize );

    if ( (Offset != 0) ||
         (MaxCount < ActualCount) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    //
    // Do the memory size increment now in case the actual count is 0.
    //
    LENGTH_ALIGN( pStubMsg->MemorySize, pArrayFormat->Alignment );
    pStubMsg->MemorySize += MemorySize;

    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment);

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, BufferSize );
    uchar *pBufferStart =  pStubMsg->Buffer;
    pStubMsg->Buffer    += BufferSize;

    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMemorySize( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)ActualCount,
                                       pBufferStart );

        }
}


void
Ndr64VaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size of a top level or embedded varying array.

    Used for FC64_SMVARRAY and FC64_LGVARRAY.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_VAR_ARRAY_HEADER_FORMAT*) pFormat;

    //
    // Get the offset and actual count.
    //

    ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

    NDR64_WIRE_COUNT_TYPE Offset = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[0];
    NDR64_WIRE_COUNT_TYPE ActualCount = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[1];
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_UINT32 BufferSize =
        Ndr64pConvertTo2GB( ActualCount *
                            (NDR64_UINT64)pArrayFormat->ElementSize );

    if ( ( Offset != 0 ) ||
         ( BufferSize > pArrayFormat->TotalSize ) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    LENGTH_ALIGN( pStubMsg->MemorySize, pArrayFormat->Alignment );

    pStubMsg->MemorySize += pArrayFormat->TotalSize;

    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment);

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, BufferSize );
    uchar *pBufferStart     =  pStubMsg->Buffer;
    pStubMsg->Buffer        += BufferSize;

    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMemorySize( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)ActualCount,
                                       pBufferStart );

        }
}


void
Ndr64ComplexArrayMemorySize(
                           PMIDL_STUB_MESSAGE  pStubMsg,
                           PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size of a top level complex array.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_BOGUS_ARRAY_HEADER_FORMAT *pArrayFormat =
    (NDR64_BOGUS_ARRAY_HEADER_FORMAT *) pFormat;

    bool fSetPointerBufferMark = ! pStubMsg->IgnoreEmbeddedPointers &&
                                 ! pStubMsg->PointerBufferMark;
    if ( fSetPointerBufferMark )
        {
        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        // Save this since it gets clobbered.
        ulong MemorySizeSave = pStubMsg->MemorySize;
        uchar* pBufferSave = pStubMsg->Buffer;

        //
        // Get a buffer pointer to where the array's pointees are.
        //
        Ndr64ComplexArrayMemorySize(
            pStubMsg,
            pFormat );


        // This is where the array pointees start.
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;
        pStubMsg->PointerLength     = pStubMsg->MemorySize;
        pStubMsg->IgnoreEmbeddedPointers = FALSE;

        pStubMsg->MemorySize = MemorySizeSave;
        pStubMsg->Buffer = pBufferSave;
        }

    BOOL                IsFixed = ( pArrayFormat->FormatCode == FC64_FIX_BOGUS_ARRAY ) ||
                                  ( pArrayFormat->FormatCode == FC64_FIX_FORCED_BOGUS_ARRAY );

    PFORMAT_STRING      pElementFormat = (PFORMAT_STRING)pArrayFormat->Element;

    SAVE_CONTEXT<uchar>  uFlagsSave( pStubMsg->uFlags );
    SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark );
    SAVE_CONTEXT<uchar*> VarianceMarkSave( pStubMsg->VarianceMark );

    NDR64_WIRE_COUNT_TYPE Elements = pArrayFormat->NumberElements;
    NDR64_WIRE_COUNT_TYPE Count = Elements;
    NDR64_WIRE_COUNT_TYPE Offset = 0;

    if ( !IsFixed )
        {

        const NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT* pConfVarFormat=
        (NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT*)pFormat;

        if ( pConfVarFormat->ConfDescription )
            {

            if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
                {
                //
                // The outer most array dimension sets the conformance marker.
                //

                ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN);

                pStubMsg->ConformanceMark = pStubMsg->Buffer;

                // Increment past conformance count(s).
                pStubMsg->Buffer += pArrayFormat->NumberDims * sizeof(NDR64_WIRE_COUNT_TYPE);

                CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );

                NDR64_SET_CONF_MARK_VALID( pStubMsg->uFlags );

                }

            Elements = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
            pStubMsg->ConformanceMark += sizeof(NDR64_WIRE_COUNT_TYPE);
            Offset   = 0;
            Count    = Elements;

            }

        if ( pConfVarFormat->VarDescription )
            {

            if ( ! NDR64_IS_VAR_MARK_VALID( pStubMsg->uFlags ) )
                {

                NDR64_UINT32 Dimensions;

                ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN);

                // Mark where the variance counts are.
                pStubMsg->VarianceMark = pStubMsg->Buffer;

                Dimensions = pArrayFormat->Flags.IsArrayofStrings ?
                             (pArrayFormat->NumberDims - 1) :
                             (pArrayFormat->NumberDims);

                pStubMsg->Buffer += Dimensions * sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

                CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );

                if ( NDR64_IS_ARRAY_OR_STRING( *pElementFormat ) )
                    NDR64_SET_VAR_MARK_VALID( pStubMsg->uFlags );
                }
            else if ( !NDR64_IS_ARRAY_OR_STRING( *pElementFormat ) )
                NDR64_RESET_VAR_MARK_VALID( pStubMsg->uFlags );

            Offset  = ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->VarianceMark)[0];
            Count   = ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->VarianceMark)[1];
            pStubMsg->VarianceMark += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

            if ( Elements < (Offset + Count) )
                RpcRaiseException( RPC_X_INVALID_BOUND );
            }

        }


    NDR64_UINT32        ElementMemorySize =
        Ndr64pMemorySize( pStubMsg,
                          pElementFormat,
                          TRUE );

    pStubMsg->MemorySize+= Ndr64pConvertTo2GB(Offset *
                                              (NDR64_UINT64)ElementMemorySize);

    Ndr64pConvertTo2GB( Elements *
                        (NDR64_UINT64)ElementMemorySize );
    Ndr64pConvertTo2GB( Count *
                        (NDR64_UINT64)ElementMemorySize );

    NDR64_WIRE_COUNT_TYPE LeftOverGap = Elements - Count - Offset;

    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment);

    for ( ; Count--; )
        {
        Ndr64EmbeddedTypeMemorySize( pStubMsg,
                                     pElementFormat );
        }

    pStubMsg->MemorySize += Ndr64pConvertTo2GB(LeftOverGap *
                                               ElementMemorySize );
    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer            = pStubMsg->PointerBufferMark;
        pStubMsg->MemorySize        = pStubMsg->PointerLength;
        pStubMsg->PointerBufferMark = 0;
        pStubMsg->PointerLength     = 0;
        }
}


void
Ndr64NonConformantStringMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size of a non conformant string.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_NON_CONFORMANT_STRING_FORMAT * pStringFormat =
        (NDR64_NON_CONFORMANT_STRING_FORMAT*) pFormat;

    ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

    NDR64_WIRE_COUNT_TYPE Offset      = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[0];
    NDR64_WIRE_COUNT_TYPE ActualCount = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[1];
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_UINT32 BufferSize =
        Ndr64pConvertTo2GB( ActualCount *
                           (NDR64_UINT64)pStringFormat->Header.ElementSize );

    if ( pStringFormat->Header.FormatCode == FC64_WCHAR_STRING )
        {
        // Align memory just in case.
        LENGTH_ALIGN( pStubMsg->MemorySize, 0x1 );
        }

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, BufferSize );
    pStubMsg->Buffer        += BufferSize;
    pStubMsg->MemorySize    += pStringFormat->TotalSize;

}


void
Ndr64ConformantStringMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size of a top level conformant string.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{

    const NDR64_CONFORMANT_STRING_FORMAT * const pStringFormat =
        (NDR64_CONFORMANT_STRING_FORMAT*) pFormat;

    NDR64_WIRE_COUNT_TYPE    MaxCount;
    if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );
        MaxCount =  *((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else
        {
        MaxCount =  *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
        }

    ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );
    NDR64_WIRE_COUNT_TYPE Offset      = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[0];
    NDR64_WIRE_COUNT_TYPE ActualCount = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[1];
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_UINT32 TransmittedSize =
        Ndr64pConvertTo2GB( ActualCount *
                            (NDR64_UINT64)pStringFormat->Header.ElementSize );
    NDR64_UINT32 MemorySize      =
        Ndr64pConvertTo2GB( MaxCount *
                            (NDR64_UINT64)pStringFormat->Header.ElementSize );

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, TransmittedSize );

    if ( pStringFormat->Header.FormatCode == FC64_CONF_WCHAR_STRING )
        {
        // Align memory just in case.
        LENGTH_ALIGN( pStubMsg->MemorySize, 0x1 );
        }


    pStubMsg->Buffer        += TransmittedSize;
    pStubMsg->MemorySize    += MemorySize;
}


void
Ndr64UnionMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size of an encapsulated union.

    Used for FC64_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_UNION_ARM_SELECTOR* pArmSelector;

    NDR64_FORMAT_CHAR   SwitchType;
    NDR64_UINT32        MemorySize;

    switch(*(PFORMAT_STRING)pFormat)
    {
    case FC64_NON_ENCAPSULATED_UNION:
        {
        const NDR64_NON_ENCAPSULATED_UNION* pNonEncapUnionFormat =
            (const NDR64_NON_ENCAPSULATED_UNION*) pFormat;

        ALIGN(pStubMsg->Buffer, pNonEncapUnionFormat->Alignment);
        SwitchType      = pNonEncapUnionFormat->SwitchType;
        pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pNonEncapUnionFormat + 1);
        MemorySize      = pNonEncapUnionFormat->MemorySize;

        break;
        }
    case FC64_ENCAPSULATED_UNION:
        {
        const NDR64_ENCAPSULATED_UNION* pEncapUnionFormat =
            (const NDR64_ENCAPSULATED_UNION*)pFormat;


        ALIGN(pStubMsg->Buffer, pEncapUnionFormat->Alignment);
        SwitchType      = pEncapUnionFormat->SwitchType;
        pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pEncapUnionFormat + 1);
        MemorySize      = pEncapUnionFormat->MemorySize;
        break;
        }

    default:
        NDR_ASSERT("Bad union format\n", 0);
        return;
        }

    EXPR_VALUE SwitchIs =
        Ndr64pSimpleTypeToExprValue( SwitchType,
                                     pStubMsg->Buffer );

    pStubMsg->MemorySize += MemorySize;

    pStubMsg->Buffer     += NDR64_SIMPLE_TYPE_BUFSIZE(SwitchType);

    ALIGN(pStubMsg->Buffer, pArmSelector->Alignment);

    PNDR64_FORMAT pArmFormat =
        Ndr64pFindUnionArm( pStubMsg,
                            pArmSelector,
                            SwitchIs );

    if ( ! pArmFormat )
        return;

    Ndr64EmbeddedTypeMemorySize( pStubMsg,
                                 pArmFormat );

}


void
Ndr64XmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    bool bIsEmbedded )
/*++

Routine Description :

    Computes the memory size required for the presented type of a
    transmit as or represent as.

    See mrshl.c for the description of the FC layout.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size of the presented type object.

--*/
{
    NDR64_TRANSMIT_AS_FORMAT *pTransFormat = ( NDR64_TRANSMIT_AS_FORMAT *) pFormat;
    NDR_ASSERT( pTransFormat->FormatCode == FC64_TRANSMIT_AS || pTransFormat->FormatCode , "invalid format string for user marshal" );

    pStubMsg->MemorySize += pTransFormat->PresentedTypeMemorySize;

    // In NDR64, Xmit/Rep cannot be a pointer or contain a pointer.
    // So we don't need to worry about the pointer queue here.

    if ( bIsEmbedded )
        {
        Ndr64EmbeddedTypeMemorySize( pStubMsg,
                                     pTransFormat->TransmittedType );
        }
    else
        {
        Ndr64TopLevelTypeMemorySize( pStubMsg,
                                     pTransFormat->TransmittedType );
        }
}

void
Ndr64TopLevelXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
{
    Ndr64XmitOrRepAsMemorySize( pStubMsg,
                                pFormat,
                                false );
}

void
Ndr64EmbeddedXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
{
    Ndr64XmitOrRepAsMemorySize( pStubMsg,
                                pFormat,
                                true );
}


void
NDR64_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT::Dispatch(MIDL_STUB_MESSAGE *pStubMsg)
{

    Ndr64TopLevelTypeMemorySize( pStubMsg,
                                 pFormat );

}

#if defined(DBG)
void
NDR64_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR64_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pFormat:                 %p\n", pFormat );
}
#endif


void
Ndr64UserMarshallPointeeMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
{

    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    if ( !pStubMsg->pPointerQueueState ||
         !pStubMsg->pPointerQueueState->GetActiveQueue() )
        {

        POINTER_MEMSIZE_SWAP_CONTEXT SwapContext( pStubMsg );

        Ndr64TopLevelTypeMemorySize(
            pStubMsg,
            pFormat );
        return;
        }

    NDR64_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT*pElement =
       new(pStubMsg->pPointerQueueState)
           NDR64_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT((PFORMAT_STRING)pFormat );
    pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );

}


void
Ndr64UserMarshalMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    bool                bIsEmbedded )
/*++

Routine Description :

    Computes the memory size required for a usr_marshal type.
    See mrshl.c for the description of the layouts.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The memory size of the usr_marshall object.

--*/
{
    NDR64_USER_MARSHAL_FORMAT  *pUserFormat = ( NDR64_USER_MARSHAL_FORMAT *) pFormat;

    pStubMsg->MemorySize += pUserFormat->UserTypeMemorySize;

    ALIGN( pStubMsg->Buffer, pUserFormat->TransmittedTypeWireAlignment );

    if ( pUserFormat->Flags & USER_MARSHAL_POINTER )
        {

        if ( ( pUserFormat->Flags & USER_MARSHAL_UNIQUE )  ||
             (( pUserFormat->Flags & USER_MARSHAL_REF ) && bIsEmbedded) )
            {
            // it's embedded: unique or ref.
            pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);
            }

        Ndr64UserMarshallPointeeMemorySize( pStubMsg,
                                            pUserFormat->TransmittedType );

        return;

        }

    if ( bIsEmbedded )
        {
        Ndr64EmbeddedTypeMemorySize( pStubMsg,
                                     pUserFormat->TransmittedType );
        }
    else
        {
        Ndr64TopLevelTypeMemorySize( pStubMsg,
                                     pUserFormat->TransmittedType );
        }

    return;
}

void
Ndr64TopLevelUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
{
    Ndr64UserMarshalMemorySize( pStubMsg,
                                pFormat,
                                false );
}

void
Ndr64EmbeddedUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
{
    Ndr64UserMarshalMemorySize( pStubMsg,
                                pFormat,
                                true );
}

// define the jump table
#define NDR64_BEGIN_TABLE  \
PNDR64_MEM_SIZE_ROUTINE extern const Ndr64MemSizeRoutinesTable[] = \
{

#define NDR64_TABLE_END    \
};

#define NDR64_ZERO_ENTRY   NULL
#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) ,NULL
#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number ) ,NULL

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,memsize

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, buffersize, memorysize) \
   ,Ndr64UDTSimpleTypeMemorySize

#include "tokntbl.h"


C_ASSERT( sizeof(Ndr64MemSizeRoutinesTable)/sizeof(PNDR64_MEM_SIZE_ROUTINE) == 256 );

#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_ENTRY

#define NDR64_BEGIN_TABLE  \
PNDR64_MEM_SIZE_ROUTINE extern const Ndr64EmbeddedMemSizeRoutinesTable[] = \
{

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,embeddedmemsize

#include "tokntbl.h"


C_ASSERT( sizeof(Ndr64EmbeddedMemSizeRoutinesTable)/sizeof(PNDR64_MEM_SIZE_ROUTINE) == 256 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\mrshl.cxx ===
/************************************************************************

Copyright (c) 1993 - 1999 Microsoft Corporation

Module Name :

    mrshl.c

Abstract :

    This file contains the marshalling routines called by MIDL generated
    stubs and the interpreter.

Author :

    David Kays  dkays   September 1993.

Revision History :

  ***********************************************************************/

#include "precomp.hxx"

#include "..\..\ndr20\ndrole.h"


void 
Ndr64SimpleTypeMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    uchar               FormatChar )
/*++

Routine Description :

    Marshalls a simple type.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data to be marshalled.
    FormatChar  - Simple type format character.

Return :

    None.

--*/
{
    switch ( FormatChar )
        {
        case FC64_CHAR :
        case FC64_UINT8:
        case FC64_INT8:
            *(pStubMsg->Buffer)++ = *pMemory;
            break;
        case FC64_WCHAR :
        case FC64_UINT16:
        case FC64_INT16:
            ALIGN(pStubMsg->Buffer,1);

            *((NDR64_UINT16 *)pStubMsg->Buffer) = *((NDR64_UINT16 *)pMemory);
            pStubMsg->Buffer += sizeof(NDR64_UINT16);
            break;

        case FC64_UINT32:
        case FC64_INT32:
        case FC64_ERROR_STATUS_T:
        case FC64_FLOAT32:
            ALIGN(pStubMsg->Buffer,3);

            *((NDR64_UINT32 *)pStubMsg->Buffer)  = *((NDR64_UINT32 *)pMemory);
            pStubMsg->Buffer += sizeof(NDR64_UINT32);
            break;

        case FC64_UINT64:
        case FC64_INT64:
        case FC64_FLOAT64:
            ALIGN(pStubMsg->Buffer,7);
            *((NDR64_UINT64 *)pStubMsg->Buffer)   = *((NDR64_UINT64 *)pMemory);
            pStubMsg->Buffer += sizeof(NDR64_UINT64);
            break;

        case FC64_IGNORE:
            break;

        default :
            NDR_ASSERT(0,"Ndr64SimpleTypeMarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }
}

void
Ndr64UDTSimpleTypeMarshall1(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       FormatString )
{
    Ndr64SimpleTypeMarshall(pStubMsg,pMemory,*(PFORMAT_STRING)FormatString);
}


void 
Ndr64pRangeMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++
--*/
{
    const NDR64_RANGE_FORMAT * pRangeFormat =
        (const NDR64_RANGE_FORMAT*)pFormat;

    Ndr64SimpleTypeMarshall( pStubMsg, pMemory, pRangeFormat->RangeType );
}


void 
Ndr64pInterfacePointerMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Marshalls an interface pointer.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the interface pointer being marshalled.
    pFormat     - Interface pointer's format string description.

Return :

    None.

Notes : There is now one representation of a marshalled interface pointer.

    // wire representation of a marshalled interface pointer
    typedef struct tagMInterfacePointer
    {
        ULONG           ulCntData;          // size of data
        [size_is(ulCntData)] BYTE abData[]; // data (OBJREF)
    } MInterfacePointer;

--*/
{

    const NDR64_CONSTANT_IID_FORMAT *pConstInterfaceFormat =
        (NDR64_CONSTANT_IID_FORMAT*)pFormat;
    const NDR64_IID_FORMAT *pInterfaceFormat =
        (NDR64_IID_FORMAT*)pFormat;

    //
    // Get an IID pointer.
    //
    IID *piid;
    if ( ((NDR64_IID_FLAGS*)&pInterfaceFormat->Flags)->ConstantIID )
        {
        piid = (IID*)&pConstInterfaceFormat->Guid;
        
        }
    else
        {

        piid = (IID *) Ndr64EvaluateExpr( pStubMsg,
                                          pInterfaceFormat->IIDDescriptor,
                                          EXPR_IID );
        if(piid == 0)
            {
            RpcRaiseException( RPC_S_INVALID_ARG );
            return;
            }

        }

    // Leave space in the buffer for the conformant size.

    ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );
    NDR64_WIRE_COUNT_TYPE * pMaxCount = (NDR64_WIRE_COUNT_TYPE *) pStubMsg->Buffer;
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
    ulong *pulCntData = (ulong *) pStubMsg->Buffer;
    pStubMsg->Buffer += sizeof(ulong);

    //Calculate the maximum size of the stream.

    ulong position = (ulong)( pStubMsg->Buffer - (uchar *)pStubMsg->RpcMsg->Buffer);
    ulong cbMax = pStubMsg->RpcMsg->BufferLength - position;

    //Create a stream on memory.

#if defined(DEBUG_WALKIP)
    {
    CHAR AppName[MAX_PATH];
    memset(AppName, 0, sizeof(AppName ) );
    GetModuleFileNameA( NULL, AppName, sizeof(AppName ) );
    DbgPrint("MRSHL64 %s %p\n", AppName, pStubMsg->Buffer );
    }
#endif

    IStream *pStream = NdrpCreateStreamOnMemory(pStubMsg->Buffer, cbMax);
    if(pStream == 0)
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY);
        return;
        }

    RpcTryFinally
        {
        
        HRESULT hr = (*pfnCoMarshalInterface)(pStream, *piid, (IUnknown *)pMemory, 
                                              pStubMsg->dwDestContext, pStubMsg->pvDestContext, 0);
        if(FAILED(hr))
            {
            RpcRaiseException(hr);
            return;
            }
        
        ULARGE_INTEGER libPosition;
        LARGE_INTEGER libMove;
        libMove.QuadPart = 0;
        pStream->Seek(libMove, STREAM_SEEK_CUR, &libPosition);

        //Update the array bounds.
        *pMaxCount = libPosition.QuadPart;

        //Advance the stub message buffer pointer.
        pStubMsg->Buffer += (*pulCntData = Ndr64pConvertTo2GB(libPosition.QuadPart));

        }
    RpcFinally
        {
        pStream->Release(); 
        }
    RpcEndFinally
}


__forceinline void
Ndr64pPointerMarshallInternal(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE *pBufferMark,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )

/*++

Routine Description :

    Private routine for marshalling a pointer and its pointee.  This is the
    entry point for pointers embedded in structures, arrays, and unions.

    Used for FC64_RP, FC64_UP, FC64_FP, FC64_OP.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pBufferMark - Pointer to the pointer in the wire buffer.
    pMemory     - Pointer to the data to be marshalled.
    pFormat     - Pointer format string description.

    pStubMsg->Buffer - the place for the pointee.

Return :

    None.

--*/

{
    
    const NDR64_POINTER_FORMAT *pPointerFormat = (NDR64_POINTER_FORMAT*) pFormat;

    //
    // Check the pointer type.
    //
    switch ( pPointerFormat->FormatCode )
        {

        case FC64_RP :
            if ( pBufferMark )
                {
                // Put the pointer in the buffer.
                *((NDR64_PTR_WIRE_TYPE*)pBufferMark) = PTR_WIRE_REP(pMemory);
                }

            if ( !pMemory )
                {
                RpcRaiseException( RPC_X_NULL_REF_POINTER );
                }
            break;

        case FC64_UP :
        case FC64_OP :
            // Put the pointer in the buffer.
            *((NDR64_PTR_WIRE_TYPE*)pBufferMark) = PTR_WIRE_REP(pMemory);

            if ( ! pMemory )
                {
                return;
                }

            break;

        case FC64_IP :
            // Put the pointer in the buffer
            *((NDR64_PTR_WIRE_TYPE*)pBufferMark) = PTR_WIRE_REP(pMemory);

            if ( ! pMemory )
                {
                return;
                }

            Ndr64pInterfacePointerMarshall (pStubMsg,
                                            pMemory,
                                            pPointerFormat->Pointee
                                            );
            return;

        case FC64_FP :
            //
            // Marshall the pointer's ref id and see if we've already
            // marshalled the pointer's data.
            //
            
            {
            ulong RefId;
 
            BOOL Result = 
                Ndr64pFullPointerQueryPointer( pStubMsg,
                                               pMemory,
                                               FULL_POINTER_MARSHALLED,
                                               &RefId );
            
            *(NDR64_PTR_WIRE_TYPE*)pBufferMark = Ndr64pRefIdToWirePtr( RefId );
            if ( Result )
                return;
            
            }
            break;

        default :
            NDR_ASSERT(0,"Ndr64pPointerMarshall : bad pointer type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    if ( NDR64_SIMPLE_POINTER( pPointerFormat->Flags ) )
        {
        Ndr64SimpleTypeMarshall( pStubMsg,
                                 pMemory,
                                 *(PFORMAT_STRING)pPointerFormat->Pointee );
        return;
        }

    if ( NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
        pMemory = *((uchar **)pMemory);

    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags ); 
    NDR64_RESET_EMBEDDED_FLAGS_TO_STANDALONE(pStubMsg->uFlags);
    
    Ndr64TopLevelTypeMarshall(
        pStubMsg,
        pMemory,
        pPointerFormat->Pointee );

}

NDR64_MRSHL_POINTER_QUEUE_ELEMENT::NDR64_MRSHL_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg, 
    NDR64_PTR_WIRE_TYPE * pBufferMarkNew,
    uchar * const pMemoryNew,
    const PFORMAT_STRING pFormatNew) :

        pBufferMark(pBufferMarkNew),
        pMemory(pMemoryNew),
        pFormat(pFormatNew),
        uFlags(pStubMsg->uFlags),
        pCorrMemory(pStubMsg->pCorrMemory)
{

}

void 
NDR64_MRSHL_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{

    SAVE_CONTEXT<uchar> uFlagsSave(pStubMsg->uFlags, uFlags ); 
    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pCorrMemory ); 
    
    Ndr64pPointerMarshallInternal( pStubMsg,
                                   pBufferMark,
                                   pMemory,
                                   (PNDR64_FORMAT)pFormat );
}

#if defined(DBG)
void 
NDR64_MRSHL_POINTER_QUEUE_ELEMENT::Print() 
{
    DbgPrint("NDR_MRSHL_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pBufferMark:             %p\n", pBufferMark );
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("pCorrMemory:             %p\n", pCorrMemory );
    DbgPrint("uFlags:                  %x\n", uFlags );
}
#endif

void
Ndr64pEnquePointerMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE *pBufferMark,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{

    NDR64_POINTER_CONTEXT PointerContext( pStubMsg );

    RpcTryFinally
        {
        NDR64_MRSHL_POINTER_QUEUE_ELEMENT*pElement = 
            new(PointerContext.GetActiveState()) 
                NDR64_MRSHL_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                 pBufferMark,
                                                 pMemory,
                                                 (PFORMAT_STRING)pFormat);
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
        }
    RpcFinally
        {
        PointerContext.EndContext();
        }
    RpcEndFinally

}

void
Ndr64pPointerMarshall( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE *pBufferMark,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    SAVE_CONTEXT<uchar> uFlagsSave(pStubMsg->uFlags);
    
    if ( !NdrIsLowStack(pStubMsg) )
        {
        Ndr64pPointerMarshallInternal( pStubMsg,
                                       pBufferMark,
                                       pMemory,
                                       pFormat );
        return;
        }

    Ndr64pEnquePointerMarshall(
        pStubMsg,
        pBufferMark,
        pMemory,
        pFormat );
}

__forceinline void
Ndr64TopLevelPointerMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{

    NDR64_PTR_WIRE_TYPE *pBufferMark = NULL;

    // Non embedded ref pointers do not have a wire representation
    if ( *(PFORMAT_STRING)pFormat != FC64_RP )
        {
        ALIGN( pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );
        pBufferMark        = (NDR64_PTR_WIRE_TYPE*)pStubMsg->Buffer;
        pStubMsg->Buffer   += sizeof(NDR64_PTR_WIRE_TYPE);
        }

    Ndr64pPointerMarshall( pStubMsg,
                           pBufferMark,
                           pMemory,
                           pFormat );
}

__forceinline void
Ndr64EmbeddedPointerMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{

    ALIGN( pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );
    NDR64_PTR_WIRE_TYPE* pBufferMark = (NDR64_PTR_WIRE_TYPE*)pStubMsg->Buffer;
    pStubMsg->Buffer   += sizeof(NDR64_PTR_WIRE_TYPE);

    POINTER_BUFFER_SWAP_CONTEXT SwapContext(pStubMsg);

    Ndr64pPointerMarshall( pStubMsg,
                           pBufferMark,
                           *(uchar**)pMemory,
                           pFormat );

}


void 
Ndr64SimpleStructMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine description :

    Marshalls a simple structure.

    Used for FC64_STRUCT and FC64_PSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure to be marshalled.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    const NDR64_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_STRUCTURE_HEADER_FORMAT*) pFormat;
    const NDR64_UINT32 StructSize = pStructFormat->MemorySize;

    ALIGN(pStubMsg->Buffer, pStructFormat->Alignment);

    uchar *pBufferSave = pStubMsg->Buffer;

    RpcpMemoryCopy( pBufferSave,
                    pMemory,
                    pStructFormat->MemorySize );

    pStubMsg->Buffer += pStructFormat->MemorySize;

    // Marshall embedded pointers.
    if ( pStructFormat->Flags.HasPointerInfo )
        {
        CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory); 

        Ndr64pPointerLayoutMarshall( pStubMsg,
                                     pStructFormat + 1,
                                     0,
                                     pMemory,
                                     pBufferSave );
        
        }

}


void 
Ndr64ConformantStructMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine description :

    Marshalls a conformant structure.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure to be marshalled.
    pFormat     - Structure's format string description.

Return :

    None.       

Note

--*/
{

    const NDR64_CONF_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_CONF_STRUCTURE_HEADER_FORMAT*) pFormat;
    
    const NDR64_CONF_ARRAY_HEADER_FORMAT * const pArrayFormat =  
        (NDR64_CONF_ARRAY_HEADER_FORMAT *) pStructFormat->ArrayDescription;

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );
    
    NDR64_WIRE_COUNT_TYPE MaxCount = 
        Ndr64EvaluateExpr( pStubMsg,
                           pArrayFormat->ConfDescriptor,
                           EXPR_MAXCOUNT );

    if ( NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        *(NDR64_WIRE_COUNT_TYPE *)pStubMsg->ConformanceMark = MaxCount;
    else
        {
        ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

        *((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer) = MaxCount;
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }


    ALIGN(pStubMsg->Buffer, pStructFormat->Alignment);
    uchar *pBufferStart = pStubMsg->Buffer;

    NDR64_UINT32 StructSize = Ndr64pConvertTo2GB( (NDR64_UINT64)pStructFormat->MemorySize +
                                                  ( MaxCount * (NDR64_UINT64)pArrayFormat->ElementSize ) );

    RpcpMemoryCopy( pBufferStart,
                    pMemory,
                    StructSize );

    pStubMsg->Buffer += StructSize;

    if ( pStructFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMarshall( pStubMsg,
                                     pStructFormat + 1,
                                     (NDR64_UINT32)MaxCount,
                                     pMemory,
                                     pBufferStart );
        }
}


void 
Ndr64ComplexStructMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine description :

    Marshalls a complex structure.

    Used for FC64_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being marshalled.
    pFormat     - Structure's format string description.
    
Return :

    None.
    
Notes :

--*/
{
    const NDR64_BOGUS_STRUCTURE_HEADER_FORMAT *  pStructFormat =
        (NDR64_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;
    const NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT * pConfStructFormat =
        (NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;

    uchar *         pBufferSave = pStubMsg->Buffer;

    bool fSetPointerBufferMark = ! pStubMsg->PointerBufferMark;
    // Compute where the pointees should be unmarshalled to.
    if ( fSetPointerBufferMark )
        {
        BOOL fOldIgnore = pStubMsg->IgnoreEmbeddedPointers;
        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        //
        // Set BufferLength equal to the current buffer pointer, and then
        // when we return from NdrComplexStructBufferSize it will pointer to
        // the location in the buffer where the pointees should be marshalled.
        //     pStubMsg->BufferLength = pBufferSave;
        // Instead of pointer, we now calculate pointer increment explicitly.

        // Set the pointer alignment as a base.
        // We use pBufferSave as the sizing routine accounts for the conf sizes.
        //
        ulong BufferLenOffset = 0xf & PtrToUlong( pBufferSave );
        ulong BufferLengthSave = pStubMsg->BufferLength;
        pStubMsg->BufferLength = BufferLenOffset;

        Ndr64ComplexStructBufferSize( 
            pStubMsg,
            pMemory,
            pFormat );

        // Pointer increment including alignments.
        BufferLenOffset = pStubMsg->BufferLength - BufferLenOffset;

        // Set the location in the buffer where pointees will be marshalled.
        pStubMsg->PointerBufferMark = pStubMsg->Buffer + BufferLenOffset;
        pStubMsg->BufferLength = BufferLengthSave;
        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;
        }

    PFORMAT_STRING  pFormatPointers = (PFORMAT_STRING)pStructFormat->PointerLayout;
    PFORMAT_STRING  pFormatArray = NULL;
    
    BOOL            fIsFullBogus  = ( *(PFORMAT_STRING)pFormat == FC64_BOGUS_STRUCT ||
                                      *(PFORMAT_STRING)pFormat == FC64_CONF_BOGUS_STRUCT );

    PFORMAT_STRING  pMemberLayout =  ( *(PFORMAT_STRING)pFormat == FC64_CONF_BOGUS_STRUCT ||
                                       *(PFORMAT_STRING)pFormat == FC64_FORCED_CONF_BOGUS_STRUCT ) ?
                                     (PFORMAT_STRING)( pConfStructFormat + 1) :
                                     (PFORMAT_STRING)( pStructFormat + 1);

    SAVE_CONTEXT<uchar*> ConformanceMarkSave(pStubMsg->ConformanceMark);
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );

    // Get conformant array description.
    if ( pStructFormat->Flags.HasConfArray )
        {
        pFormatArray = (PFORMAT_STRING)pConfStructFormat->ConfArrayDescription;

        if ( !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
            {
            // Align for conformance marshalling.
            ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN);

            // Remember where the conformance count(s) will be marshalled.
            pStubMsg->ConformanceMark = pStubMsg->Buffer;

            // Increment the buffer pointer for every array dimension.
            pStubMsg->Buffer += pConfStructFormat->Dimensions * sizeof(NDR64_WIRE_COUNT_TYPE);

            NDR64_SET_CONF_MARK_VALID( pStubMsg->uFlags );
            }
        }
    else
        pFormatArray = 0;

    // Align buffer on struct's alignment.
    ALIGN(pStubMsg->Buffer, pStructFormat->Alignment);

    //
    // Marshall the structure member by member.
    //
    for ( ; ; )
        {
        switch ( *pMemberLayout )
            {

            case FC64_STRUCT:
                {
                const NDR64_SIMPLE_REGION_FORMAT *pRegion = 
                    (NDR64_SIMPLE_REGION_FORMAT*) pMemberLayout;
                
                ALIGN( pStubMsg->Buffer, pRegion->Alignment );
                
                RpcpMemoryCopy( pStubMsg->Buffer,
                                pMemory,
                                pRegion->RegionSize );

                pStubMsg->Buffer += pRegion->RegionSize;
                pMemory          += pRegion->RegionSize;

                pMemberLayout    += sizeof( *pRegion );
                break;
                }

            case FC64_STRUCTPADN :
                {
                const NDR64_MEMPAD_FORMAT *pMemPad = (NDR64_MEMPAD_FORMAT*)pMemberLayout;
                pMemory         += pMemPad->MemPad;
                pMemberLayout   += sizeof(*pMemPad);
                break;
                }

            case FC64_POINTER :
                {

                NDR_ASSERT(pFormatPointers, "Ndr64ComplexStructMarshall: pointer field but no pointer layout");

                Ndr64EmbeddedPointerMarshall( 
                    pStubMsg,
                    pMemory,
                    pFormatPointers );

                pMemory += PTR_MEM_SIZE;

                pFormatPointers     += sizeof(NDR64_POINTER_FORMAT);
                pMemberLayout       += sizeof(NDR64_SIMPLE_MEMBER_FORMAT); 

                break;
                }

            case FC64_EMBEDDED_COMPLEX :

                {
                const NDR64_EMBEDDED_COMPLEX_FORMAT * pEmbeddedFormat =
                    (NDR64_EMBEDDED_COMPLEX_FORMAT*) pMemberLayout;

                Ndr64EmbeddedTypeMarshall( pStubMsg,
                                           pMemory,
                                           pEmbeddedFormat->Type );

                pMemory = Ndr64pMemoryIncrement( pStubMsg,
                                               pMemory,
                                               pEmbeddedFormat->Type,
                                               FALSE );

                pMemberLayout += sizeof(*pEmbeddedFormat);
                break;                
                }

            case FC64_BUFFER_ALIGN:
                 { 
                 const NDR64_BUFFER_ALIGN_FORMAT *pBufAlign = 
                     (NDR64_BUFFER_ALIGN_FORMAT*) pMemberLayout;
                 ALIGN(pStubMsg->Buffer, pBufAlign->Alignment);                 
                 pMemberLayout += sizeof( *pBufAlign );
                 break;
                 }
            
            case FC64_CHAR :
            case FC64_WCHAR :
            case FC64_INT8:
            case FC64_UINT8:
            case FC64_INT16:
            case FC64_UINT16:
            case FC64_INT32:
            case FC64_UINT32:
            case FC64_INT64:
            case FC64_UINT64:
            case FC64_FLOAT32 :
            case FC64_FLOAT64 :
            case FC64_ERROR_STATUS_T:
                Ndr64SimpleTypeMarshall( pStubMsg,
                                       pMemory,
                                       *pMemberLayout );

                pMemory       += NDR64_SIMPLE_TYPE_MEMSIZE(*pMemberLayout);
                pMemberLayout += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);
                break;

            case FC64_IGNORE :
                ALIGN(pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );
                pMemory          += PTR_MEM_SIZE;
                *(NDR64_PTR_WIRE_TYPE*)pStubMsg->Buffer = 0;
                pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);
                pMemberLayout    += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);                
                break;

            case FC64_END :
                goto ComplexMarshallEnd;

            default :
                NDR_ASSERT(0,"Ndr64ComplexStructMarshall : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return;
            } // switch
        } // for

ComplexMarshallEnd:

    //
    // Marshall conformant array if we have one.
    if ( pFormatArray )
        {

        Ndr64EmbeddedTypeMarshall( pStubMsg,
                                   pMemory,
                                   pFormatArray );

        }
    else 
        {
        // If the structure doesn't have a conformant array, align it again
        ALIGN( pStubMsg->Buffer, pStructFormat->Alignment );
        }

    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer = pStubMsg->PointerBufferMark;
        pStubMsg->PointerBufferMark = 0;
        }
}


void 
Ndr64NonConformantStringMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine description :

    Marshalls a non conformant string.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the string to be marshalled.
    pFormat     - String's format string description.

Return :

    None.

--*/
{
    const NDR64_NON_CONFORMANT_STRING_FORMAT * pStringFormat = 
        (NDR64_NON_CONFORMANT_STRING_FORMAT*) pFormat;

    NDR64_UINT32 CopySize = 
        Ndr64pCommonStringSize( pStubMsg,
                                pMemory,
                                &pStringFormat->Header );    

    if ( CopySize >  pStringFormat->TotalSize )
        RpcRaiseException(RPC_X_INVALID_BOUND);

    ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );
    ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer)[0] = pStubMsg->Offset;
    ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer)[1] = pStubMsg->ActualCount;
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    // Copy the string.
    RpcpMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    CopySize );

    pStubMsg->Buffer += CopySize;

}


void 
Ndr64ConformantStringMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine description :

    Marshalls a conformant string.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the string to be marshalled.
    pFormat     - String's format string description.

Return :

    None.

--*/
{

    const NDR64_CONFORMANT_STRING_FORMAT * pStringFormat =
        (const NDR64_CONFORMANT_STRING_FORMAT*) pFormat;
    const NDR64_SIZED_CONFORMANT_STRING_FORMAT * pSizedStringFormat =
        (const NDR64_SIZED_CONFORMANT_STRING_FORMAT*) pFormat;

    NDR64_WIRE_COUNT_TYPE    *pMaxCountMark;
    if ( !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
       {
       ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );
       pMaxCountMark = (NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer;
       pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
       }
    else 
       {
       pMaxCountMark = (NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
       }    
    
    NDR64_UINT32 CopySize = 
        Ndr64pCommonStringSize( pStubMsg,
                                pMemory,
                                &pStringFormat->Header );    
    
    //
    // If the string is sized then compute the max count, otherwise the
    // max count is equal to the actual count.
    //
    NDR64_WIRE_COUNT_TYPE MaxCount = pStubMsg->ActualCount;    
    if ( pStringFormat->Header.Flags.IsSized )
        {
        MaxCount = 
            Ndr64EvaluateExpr( pStubMsg,
                               pSizedStringFormat->SizeDescription,
                               EXPR_MAXCOUNT );

        if ( pStubMsg->ActualCount >  MaxCount )
            RpcRaiseException(RPC_X_INVALID_BOUND);
        
        }

    
    // Marshall the max count.
    *pMaxCountMark  = MaxCount;

    ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN);
    ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer)[0] = pStubMsg->Offset;
    ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer)[1] = pStubMsg->ActualCount;
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    RpcpMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    CopySize );

    // Update the Buffer pointer.
    pStubMsg->Buffer += CopySize;

}


void 
Ndr64FixedArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Marshalls a fixed array of any number of dimensions.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array to be marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{

    const NDR64_FIX_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_FIX_ARRAY_HEADER_FORMAT*) pFormat;

    // Align the buffer.
    ALIGN( pStubMsg->Buffer, pArrayFormat->Alignment );
    uchar *pBufferStart = pStubMsg->Buffer;                                                
    
    // Copy the array.
    RpcpMemoryCopy( pBufferStart,
                    pMemory,
                    pArrayFormat->TotalSize );

    // Increment stub message buffer pointer.
    pStubMsg->Buffer += pArrayFormat->TotalSize;

    // Marshall embedded pointers.
    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMarshall( pStubMsg,
                                     pArrayFormat + 1,
                                     0,
                                     pMemory,
                                     pBufferStart );
        }

}


void 
Ndr64ConformantArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Marshalls a top level one dimensional conformant array.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    
    const NDR64_CONF_ARRAY_HEADER_FORMAT *pArrayFormat =
        (NDR64_CONF_ARRAY_HEADER_FORMAT*) pFormat;
    
    uchar *pConformanceMark;
    if ( !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        
        // Align the buffer for conformance marshalling.
        ALIGN(pStubMsg->Buffer,NDR64_WIRE_COUNT_ALIGN);
        pConformanceMark = pStubMsg->Buffer;
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else 
        {
        pConformanceMark = pStubMsg->ConformanceMark;
        }

    NDR64_WIRE_COUNT_TYPE MaxCount =
        Ndr64EvaluateExpr( pStubMsg,
                           pArrayFormat->ConfDescriptor,
                           EXPR_MAXCOUNT );

    *(NDR64_WIRE_COUNT_TYPE*)pConformanceMark = MaxCount;

    ALIGN( pStubMsg->Buffer, pArrayFormat->Alignment );

    // Compute the total array size in bytes.
    NDR64_UINT32 CopySize = 
        Ndr64pConvertTo2GB(MaxCount * (NDR64_UINT64)pArrayFormat->ElementSize);


    RpcpMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    CopySize );

    // Update buffer pointer.
    uchar *pBufferStart =  pStubMsg->Buffer;
    pStubMsg->Buffer += CopySize;

    // Marshall embedded pointers.
    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMarshall( pStubMsg,
                                     pArrayFormat + 1,
                                     (NDR64_UINT32)MaxCount,
                                     pMemory,
                                     pBufferStart );
        
        }
}


void 
Ndr64ConformantVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Marshalls a top level one dimensional conformant varying array.

    Used for FC64_CVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    const NDR64_CONF_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_CONF_VAR_ARRAY_HEADER_FORMAT*) pFormat;
    
    uchar *pConformanceMark;
    if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN);
        pConformanceMark = pStubMsg->Buffer;
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else
        {
        pConformanceMark = pStubMsg->ConformanceMark;
        }

    NDR64_WIRE_COUNT_TYPE MaxCount =
        Ndr64EvaluateExpr( pStubMsg,
                           pArrayFormat->ConfDescriptor,
                           EXPR_MAXCOUNT );

    NDR64_WIRE_COUNT_TYPE ActualCount =
        Ndr64EvaluateExpr( pStubMsg,
                           pArrayFormat->VarDescriptor,
                           EXPR_ACTUALCOUNT );
    
    if ( ActualCount > MaxCount )
        RpcRaiseException( RPC_X_INVALID_BOUND );
    
    *(NDR64_WIRE_COUNT_TYPE*)pConformanceMark = MaxCount;

    // Align the buffer for variance marshalling.
    ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN);

    // Marshall variance.
    ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[0] = 0;
    ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[1] = ActualCount;
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_UINT32 CopySize = 
        Ndr64pConvertTo2GB( ActualCount * 
                           (NDR64_UINT64)pArrayFormat->ElementSize );

    ALIGN( pStubMsg->Buffer, pArrayFormat->Alignment );

    RpcpMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    CopySize );

    uchar *pBufferStart = pStubMsg->Buffer;
    pStubMsg->Buffer += CopySize;

    // Marshall embedded pointers.
    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMarshall( pStubMsg,
                                     pArrayFormat + 1,
                                     (NDR64_UINT32)ActualCount,
                                     pMemory,
                                     pBufferStart );
        }

}


void 
Ndr64VaryingArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Marshalls a top level or embedded one dimensional varying array.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    const NDR64_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_VAR_ARRAY_HEADER_FORMAT*) pFormat;

    // Compute the variance offset and count.
    NDR64_WIRE_COUNT_TYPE ActualCount =
        Ndr64EvaluateExpr( pStubMsg,
                           pArrayFormat->VarDescriptor,
                           EXPR_ACTUALCOUNT );
    
    NDR64_UINT32 CopySize = 
        Ndr64pConvertTo2GB( ActualCount * (NDR64_UINT64)pArrayFormat->ElementSize );

    // Align the buffer for variance marshalling.
    ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

    // Marshall variance.
    ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[0] = 0;
    ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[1] = ActualCount;
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment);
 
    // Copy the array.
    RpcpMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    CopySize );

    // Update buffer pointer.
    uchar *pBufferStart =  pStubMsg->Buffer;
    pStubMsg->Buffer += CopySize;

    // Marshall embedded pointers.
    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMarshall( pStubMsg,
                                     pArrayFormat + 1,
                                     (NDR64_UINT32)ActualCount,
                                     pMemory,
                                     pBufferStart );
        }

}


void 
Ndr64ComplexArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Marshalls a top level complex array.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    const NDR64_BOGUS_ARRAY_HEADER_FORMAT *pArrayFormat =
        (NDR64_BOGUS_ARRAY_HEADER_FORMAT *) pFormat;

    bool fSetPointerBufferMark = ! pStubMsg->PointerBufferMark;

    if ( fSetPointerBufferMark )
        {
        BOOL fOldIgnore = pStubMsg->IgnoreEmbeddedPointers;

        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        ulong BufferLenOffset = 0xf & PtrToUlong( pStubMsg->Buffer );
        ulong BufferLengthSave = pStubMsg->BufferLength;
        pStubMsg->BufferLength = BufferLenOffset;

        Ndr64ComplexArrayBufferSize( pStubMsg,
                                     pMemory,
                                     pFormat );

        // Pointer increment including alignments.
        BufferLenOffset = pStubMsg->BufferLength - BufferLenOffset;

        //
        // This is the buffer pointer to the position where embedded pointers
        // will be marshalled.
        //
        pStubMsg->PointerBufferMark = pStubMsg->Buffer + BufferLenOffset;
        pStubMsg->BufferLength = BufferLengthSave;
        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;
        }

    BOOL                IsFixed = ( pArrayFormat->FormatCode == FC64_FIX_BOGUS_ARRAY ) ||
                                  ( pArrayFormat->FormatCode == FC64_FIX_FORCED_BOGUS_ARRAY );

    PFORMAT_STRING      pElementFormat   = (PFORMAT_STRING)pArrayFormat->Element;

    NDR64_WIRE_COUNT_TYPE Elements = pArrayFormat->NumberElements;
    NDR64_WIRE_COUNT_TYPE Count = Elements;
    NDR64_WIRE_COUNT_TYPE Offset   = 0;

    SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark );
    SAVE_CONTEXT<uchar*> VarianceMarkSave( pStubMsg->VarianceMark );
    SAVE_CONTEXT<uchar>  uFlagsSave( pStubMsg->uFlags );

    if ( !IsFixed )
        {
        
        const NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT* pConfVarFormat=
             (NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT*)pFormat;

        if (  pConfVarFormat->ConfDescription != 0 )
            {

            if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
                {
                //
                // Outer most dimension sets the conformance marker.
                //

                // Align the buffer for conformance marshalling.
                ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN);

                // Mark where the conformance count(s) will be marshalled.
                pStubMsg->ConformanceMark = pStubMsg->Buffer;

                // Increment past where the conformance will go.
                pStubMsg->Buffer += pArrayFormat->NumberDims * sizeof(NDR64_WIRE_COUNT_TYPE);

                NDR64_SET_CONF_MARK_VALID( pStubMsg->uFlags );
                }

            Elements = Ndr64EvaluateExpr( pStubMsg,
                                          pConfVarFormat->ConfDescription,
                                          EXPR_MAXCOUNT );

            *(NDR64_WIRE_COUNT_TYPE*) pStubMsg->ConformanceMark = Elements;
            pStubMsg->ConformanceMark += sizeof(NDR64_WIRE_COUNT_TYPE);

            Offset = 0;
            Count  = Elements;
            }

        //
        // Check for variance description.
        //
        if ( pConfVarFormat->VarDescription != 0 )
            {
            if ( ! NDR64_IS_VAR_MARK_VALID( pStubMsg->uFlags ) )
                {

                NDR64_UINT32 Dimensions;
                //
                // Set the variance marker.
                //

                ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

                Dimensions = ( pArrayFormat->Flags.IsArrayofStrings ) ? ( pArrayFormat->NumberDims - 1) :
                                                                        ( pArrayFormat->NumberDims );

                // Increment past where the variance will go.
                pStubMsg->VarianceMark  =  pStubMsg->Buffer;
                pStubMsg->Buffer        += Dimensions * sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

                if ( NDR64_IS_ARRAY_OR_STRING( *pElementFormat ) )
                    NDR64_SET_VAR_MARK_VALID( pStubMsg->uFlags );

                }

            else if ( !NDR64_IS_ARRAY_OR_STRING( *pElementFormat ) )
                NDR64_RESET_VAR_MARK_VALID( pStubMsg->uFlags );
                
            Count =
                Ndr64EvaluateExpr( pStubMsg,
                                   pConfVarFormat->VarDescription,
                                   EXPR_ACTUALCOUNT );

            Offset =
                Ndr64EvaluateExpr( pStubMsg,
                                   pConfVarFormat->OffsetDescription,
                                   EXPR_OFFSET );

            if ( Count + Offset > Elements )
                RpcRaiseException( RPC_X_INVALID_BOUND );

            ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->VarianceMark)[0]  =   Offset;
            ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->VarianceMark)[1]  =   Count;
            pStubMsg->VarianceMark += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

            }

        }


    NDR64_UINT32 ElementMemorySize =
        Ndr64pMemorySize( pStubMsg,
                          pElementFormat,
                          FALSE );

    pMemory += Ndr64pConvertTo2GB( Offset * 
                                  (NDR64_UINT64)ElementMemorySize);

    Ndr64pConvertTo2GB( Elements *
                        (NDR64_UINT64)ElementMemorySize );
    Ndr64pConvertTo2GB( Count *
                        (NDR64_UINT64)ElementMemorySize );

    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment);

    for ( ; Count--; )
        {
        Ndr64EmbeddedTypeMarshall( pStubMsg,
                                   pMemory,
                                   pElementFormat );
        pMemory += ElementMemorySize;
        }

    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer = pStubMsg->PointerBufferMark;
        pStubMsg->PointerBufferMark = 0;
        }
}


void 
Ndr64UnionMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Marshalls an encapsulated union.

    Used for FC64_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the union being marshalled.
    pFormat     - Union's format string description.

Return :

    None.

--*/
{   
    const NDR64_UNION_ARM_SELECTOR* pArmSelector;

    EXPR_VALUE          SwitchIs;
    NDR64_FORMAT_CHAR   SwitchType;

    uchar *pArmMemory;
    switch(*(PFORMAT_STRING)pFormat)
        {
        case FC64_NON_ENCAPSULATED_UNION:
            {
            const NDR64_NON_ENCAPSULATED_UNION* pNonEncapUnionFormat =
                (const NDR64_NON_ENCAPSULATED_UNION*) pFormat;

            ALIGN(pStubMsg->Buffer, pNonEncapUnionFormat->Alignment);
            SwitchType      = pNonEncapUnionFormat->SwitchType;
            pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pNonEncapUnionFormat + 1);
                        
            SwitchIs   = Ndr64EvaluateExpr( pStubMsg,
                                            pNonEncapUnionFormat->Switch,
                                            EXPR_SWITCHIS );

            pArmMemory = pMemory;
            break;
            }
        case FC64_ENCAPSULATED_UNION:
            {
            const NDR64_ENCAPSULATED_UNION* pEncapUnionFormat =
                (const NDR64_ENCAPSULATED_UNION*)pFormat;

            ALIGN(pStubMsg->Buffer, pEncapUnionFormat->Alignment);
            SwitchType      = pEncapUnionFormat->SwitchType;
            pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pEncapUnionFormat + 1);

            SwitchIs        = Ndr64pSimpleTypeToExprValue(SwitchType,
                                                          pMemory);

            pArmMemory      = pMemory + pEncapUnionFormat->MemoryOffset;
            break;
            }
        default:
            NDR_ASSERT(0, "Bad union format\n");
        }

    Ndr64SimpleTypeMarshall( pStubMsg,
                           (uchar *)&SwitchIs,
                           SwitchType );

    ALIGN(pStubMsg->Buffer, pArmSelector->Alignment);
    
    PNDR64_FORMAT pArmFormat = 
        Ndr64pFindUnionArm( pStubMsg,
                            pArmSelector,
                            SwitchIs );

    if ( !pArmFormat )
        return;

    Ndr64EmbeddedTypeMarshall( pStubMsg,
                               pArmMemory,
                               pArmFormat );
}


void 
Ndr64XmitOrRepAsMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    bool                bIsEmbedded )
/*++

Routine Description :

    Marshalls a transmit as or represent as argument:
        - translate the presented object into a transmitted object
        - marshall the transmitted object
        - free the transmitted object

    Format string layout:
        check out ndr64types.h

Arguments :

    pStubMsg    - a pointer to the stub message
    pMemory     - presented type translated into transmitted type
                  and than to be marshalled
    pFormat     - format string description

--*/
{

    // Skip the token itself and Oi flag. Fetch the QuintupleIndex.

    NDR64_TRANSMIT_AS_FORMAT    *  pTransFormat = 
        ( NDR64_TRANSMIT_AS_FORMAT *) pFormat;

    NDR_ASSERT( pTransFormat->FormatCode == FC64_TRANSMIT_AS || pTransFormat->FormatCode , "invalid format string for user marshal" );
    
    unsigned short QIndex = pTransFormat->RoutineIndex;

    // First translate the presented type into the transmitted type.
    // This includes an allocation of a transmitted type object.

    pStubMsg->pPresentedType = pMemory;
    pStubMsg->pTransmitType = NULL;
    const XMIT_ROUTINE_QUINTUPLE * pQuintuple = 
        pStubMsg->StubDesc->aXmitQuintuple;
    pQuintuple[ QIndex ].pfnTranslateToXmit( pStubMsg );

    unsigned char * pTransmittedType = pStubMsg->pTransmitType;
   
    // In NDR64, Xmit/Rep cannot be a pointer or contain a pointer.
    // So we don't need to worry about the pointer queue here.

    if ( bIsEmbedded )
        {
        Ndr64EmbeddedTypeMarshall( pStubMsg,
                                   pTransmittedType,
                                   pTransFormat->TransmittedType );
        }
    else 
        {
        Ndr64TopLevelTypeMarshall( pStubMsg,
                                   pTransmittedType,
                                   pTransFormat->TransmittedType );
        }

    pStubMsg->pTransmitType = pTransmittedType;

    // Free the temporary transmitted object (it was allocated by the user).

    pQuintuple[ QIndex ].pfnFreeXmit( pStubMsg );

}

void 
Ndr64TopLevelXmitOrRepAsMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    Ndr64XmitOrRepAsMarshall( pStubMsg,
                              pMemory,
                              pFormat,
                              false );
}

void 
Ndr64EmbeddedXmitOrRepAsMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    Ndr64XmitOrRepAsMarshall( pStubMsg,
                              pMemory,
                              pFormat,
                              true );
}

void
Ndr64UserMarshallMarshallInternal( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    NDR64_PTR_WIRE_TYPE *pWirePtr )
{

    NDR64_USER_MARSHAL_FORMAT  * pUserFormat = 
        ( NDR64_USER_MARSHAL_FORMAT *) pFormat;

    unsigned char * pUserBuffer = pStubMsg->Buffer;
    unsigned char * pUserBufferSaved = pUserBuffer;

    // We always call user's routine to marshall.
    USER_MARSHAL_CB UserMarshalCB;
    Ndr64pInitUserMarshalCB( pStubMsg,
                           pUserFormat,
                           USER_MARSHAL_CB_MARSHALL,  
                           & UserMarshalCB );

    unsigned short QIndex = pUserFormat->RoutineIndex;
    const USER_MARSHAL_ROUTINE_QUADRUPLE * pQuadruple = 
        (const USER_MARSHAL_ROUTINE_QUADRUPLE *)( ( NDR_PROC_CONTEXT *)pStubMsg->pContext )->pSyntaxInfo->aUserMarshalQuadruple;   

    if ((pUserBufferSaved < (uchar *) pStubMsg->RpcMsg->Buffer) ||
        ((unsigned long) (pUserBufferSaved - (uchar *) pStubMsg->RpcMsg->Buffer) 
                                           > pStubMsg->RpcMsg->BufferLength)) 
        {
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        } 

    pUserBuffer = pQuadruple[ QIndex ].pfnMarshall( (ulong*) &UserMarshalCB,
                                                    pUserBuffer,
                                                    pMemory );

    if ((pUserBufferSaved > pUserBuffer) || 
        ((unsigned long) (pUserBuffer - (uchar *) pStubMsg->RpcMsg->Buffer)
                                      > pStubMsg->RpcMsg->BufferLength )) 
        {
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        }

    if ( pUserBuffer == pUserBufferSaved )
        {
        // This is valid only if the wire type was a unique type.

        if ( ( pUserFormat->Flags & USER_MARSHAL_UNIQUE) )
            {
            *pWirePtr = 0;
            return;
            }
        else
            RpcRaiseException( RPC_X_NULL_REF_POINTER );
        }

    pStubMsg->Buffer = pUserBuffer;
    
}

void 
NDR64_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT::Dispatch(MIDL_STUB_MESSAGE *pStubMsg)
{
    Ndr64UserMarshallMarshallInternal( pStubMsg,
                                       pMemory,
                                       pFormat,
                                       pWireMarkerPtr );
}

#if defined(DBG)
void 
NDR64_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("pWireMarkerPtr:          %p\n", pWireMarkerPtr );
}
#endif


void
Ndr64UserMarshallPointeeMarshall( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    NDR64_PTR_WIRE_TYPE *pWirePtr )
{

    if ( !pStubMsg->pPointerQueueState ||
         !pStubMsg->pPointerQueueState->GetActiveQueue() )
        {

        POINTER_BUFFER_SWAP_CONTEXT SwapContext( pStubMsg );

        Ndr64UserMarshallMarshallInternal( 
            pStubMsg,
            pMemory,
            pFormat,
            pWirePtr );
        return;
        }

    NDR64_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT*pElement = 
       new(pStubMsg->pPointerQueueState) 
           NDR64_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT(pMemory,
                                                       (PFORMAT_STRING)pFormat,
                                                       pWirePtr);
    pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );

}


void
Ndr64UserMarshalMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    bool                bIsEmbedded )
/*++

Routine Description :

    Marshals a usr_marshall object.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the usr_marshall object to marshall.
    pFormat     - Object's format string description.

Return :

    None.

--*/
{
    

    NDR64_USER_MARSHAL_FORMAT  * pUserFormat = 
        ( NDR64_USER_MARSHAL_FORMAT *) pFormat;

    NDR_ASSERT( pUserFormat->FormatCode == FC64_USER_MARSHAL, "invalid format string for user marshal" );

    ALIGN( pStubMsg->Buffer, pUserFormat->TransmittedTypeWireAlignment );

    if ( pUserFormat->Flags & USER_MARSHAL_POINTER )
        {
        
        NDR64_PTR_WIRE_TYPE *pWireMarkerPtr = NULL;
        if ( ( pUserFormat->Flags & USER_MARSHAL_UNIQUE )  ||
             (( pUserFormat->Flags & USER_MARSHAL_REF ) && bIsEmbedded) )
            {
            pWireMarkerPtr = (NDR64_PTR_WIRE_TYPE *) pStubMsg->Buffer;
            *((NDR64_PTR_WIRE_TYPE *)pStubMsg->Buffer) = NDR64_USER_MARSHAL_MARKER;
            pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);

            }
        
        Ndr64UserMarshallPointeeMarshall( pStubMsg,
                                          pMemory,
                                          pFormat,
                                          pWireMarkerPtr );
        return;

        }


    Ndr64UserMarshallMarshallInternal(
        pStubMsg,
        pMemory,
        pFormat,
        NULL );

}

void
Ndr64TopLevelUserMarshalMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    Ndr64UserMarshalMarshall( pStubMsg,
                              pMemory,
                              pFormat,
                              false );
}

void
Ndr64EmbeddedUserMarshalMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    Ndr64UserMarshalMarshall( pStubMsg,
                              pMemory,
                              pFormat,
                              true );
}



void 
Ndr64ServerContextNewMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_SCONTEXT        ContextHandle,
    NDR_RUNDOWN         RundownRoutine,
    PFORMAT_STRING      pFormat )
/*
    This is a non-optimized NDR engine entry for context handle marshaling.
    In particular it is able to handle all the new NT5 context handle flavors.
    The optimized routine follows below.
    
      ContextHandle - note, this is not the user's handle but a
                      NDR_SCONTEXT pointer from the stub local stack. 
                      User's handle is a field in that object.
                
    Note that intepreter calls Ndr64MarshallHandle. However, we can't use it 
    as it assumes a helper array of saved context handles that we don't need.
   
*/
{   
    void *  pGuard = RPC_CONTEXT_HANDLE_DEFAULT_GUARD;
    DWORD   Flags  = RPC_CONTEXT_HANDLE_DEFAULT_FLAGS;
    NDR64_CONTEXT_HANDLE_FORMAT * pContextFormat;

    pContextFormat = ( NDR64_CONTEXT_HANDLE_FORMAT * )pFormat;
    NDR_ASSERT( pContextFormat->FormatCode == FC64_BIND_CONTEXT, "invalid format char " );
    // NT5 beta2 features: strict context handle, serialize and noserialize.

    if ( pContextFormat->ContextFlags & NDR_STRICT_CONTEXT_HANDLE )
        {
        pGuard = pStubMsg->StubDesc->RpcInterfaceInformation;
        pGuard = & ((PRPC_SERVER_INTERFACE)pGuard)->InterfaceId;
        }
    if ( pContextFormat->ContextFlags & NDR_CONTEXT_HANDLE_NOSERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_DONT_SERIALIZE;
        }
    else if ( pContextFormat->ContextFlags & NDR_CONTEXT_HANDLE_SERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_SERIALIZE;
        }

    ALIGN( pStubMsg->Buffer, 0x3 );

    NDRSContextMarshall2( 
        pStubMsg->RpcMsg->Handle,
        ContextHandle,
        pStubMsg->Buffer,
        RundownRoutine,
        pGuard,
        Flags );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;
}

// define the jump table
#define NDR64_BEGIN_TABLE  \
PNDR64_MARSHALL_ROUTINE extern const Ndr64MarshallRoutinesTable[] = \
{                                                     

#define NDR64_TABLE_END    \
};                       

#define NDR64_ZERO_ENTRY   NULL
#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) ,NULL
#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number ) ,NULL

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
    ,marshall                      

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, typebuffersize, memorysize) \
   ,Ndr64UDTSimpleTypeMarshall1 

#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64MarshallRoutinesTable)/sizeof(PNDR64_MARSHALL_ROUTINE) == 256 );

#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_ENTRY

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
    ,embeddedmarshall
    
#define NDR64_BEGIN_TABLE \
PNDR64_MARSHALL_ROUTINE extern const Ndr64EmbeddedMarshallRoutinesTable[] = \
{

#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64EmbeddedMarshallRoutinesTable) / sizeof(PNDR64_MARSHALL_ROUTINE) == 256 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\mulsyntx.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    mulsyntx.c

Abstract :

    This file contains multiple transfer syntaxes negotiation related code

Author :

    Yong Qu    yongqu    September 1999. 

Revision History :


  ---------------------------------------------------------------------*/


#include "precomp.hxx"

#define CINTERFACE
#include "ndrole.h"
#include "rpcproxy.h"

#include "expr.h"
#include "auxilary.h"
#include "..\..\ndr20\pipendr.h"

uchar Ndr64HandleTypeMap[] = 
{
    0,
    FC64_BIND_GENERIC,
    FC64_BIND_PRIMITIVE,
    FC64_AUTO_HANDLE,
    FC64_CALLBACK_HANDLE
} ;

extern const SYNTAX_DISPATCH_TABLE SyncDceClient =
{
    NdrpClientInit,
    NdrpSizing,
    NdrpClientMarshal,
    NdrpClientUnMarshal,
    NdrpClientExceptionHandling,
    NdrpClientFinally
};

extern const SYNTAX_DISPATCH_TABLE AsyncDceClient =
{
    NdrpClientInit,
    NdrpSizing,
    NdrpClientMarshal,
    NdrpClientUnMarshal,
    NdrpAsyncClientExceptionHandling,
    NdrpClientFinally
};

extern const SYNTAX_DISPATCH_TABLE SyncDcomDceClient =
{
    NdrpClientInit,
    NdrpSizing,
    NdrpClientMarshal,
    NdrpClientUnMarshal,
    NdrpDcomClientExceptionHandling,
    NdrpClientFinally
};

extern const SYNTAX_DISPATCH_TABLE SyncNdr64Client =
{
    Ndr64pClientInit,
    Ndr64pSizing,
    Ndr64pClientMarshal,
    Ndr64pClientUnMarshal,
    Ndr64pClientExceptionHandling,
    Ndr64pClientFinally
};

extern const SYNTAX_DISPATCH_TABLE SyncDcomNdr64Client =
{
    Ndr64pClientInit,
    Ndr64pSizing,
    Ndr64pClientMarshal,
    Ndr64pClientUnMarshal,
    Ndr64pDcomClientExceptionHandling,
    Ndr64pClientFinally
};


const RPC_SYNTAX_IDENTIFIER NDR_TRANSFER_SYNTAX = {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
const RPC_SYNTAX_IDENTIFIER NDR64_TRANSFER_SYNTAX = {{0x71710533,0xbeba,0x4937,{0x83, 0x19, 0xb5, 0xdb, 0xef, 0x9c, 0xcc, 0x36}},{1,0}};
const RPC_SYNTAX_IDENTIFIER FAKE_NDR64_TRANSFER_SYNTAX = { { 0xb4537da9,0x3d03,0x4f6b,{0xb5, 0x94, 0x52, 0xb2, 0x87, 0x4e, 0xe9, 0xd0} }, {1,0} };

CStdProxyBuffer * RPC_ENTRY
NdrGetProxyBuffer(
    void *pThis);

void
EnsureNSLoaded();

#pragma code_seg(".ndr64")

__inline
const IID * RPC_ENTRY
NdrGetSyncProxyIID(
    IN  void *pThis)
/*++

Routine Description:
    The NDRGetSyncProxyIID function returns a pointer to IID.

Arguments:
    pThis - Supplies a pointer to the async interface proxy.

Return Value:
    This function returns a pointer to the corresponding sync IID.

--*/
{
    CStdAsyncProxyBuffer * pAsyncPB = ( CStdAsyncProxyBuffer *) NdrGetProxyBuffer( pThis );

    return pAsyncPB->pSyncIID;
}

 

void RPC_ENTRY
Ndr64SetupClientContextVtbl ( NDR_PROC_CONTEXT * pContext )
{
     if ( pContext->CurrentSyntaxType == XFER_SYNTAX_DCE )
         {
         if ( pContext->IsObject )
             memcpy( & (pContext->pfnInit), &SyncDcomDceClient, sizeof( SYNTAX_DISPATCH_TABLE ) );
         else
             {
             if ( pContext->IsAsync )
                 memcpy( & (pContext->pfnInit), &AsyncDceClient, sizeof( SYNTAX_DISPATCH_TABLE ) );
             else
                 memcpy( & (pContext->pfnInit), &SyncDceClient, sizeof( SYNTAX_DISPATCH_TABLE ) );
             }
         }
     else
         {
         if ( pContext->IsObject )
             memcpy( & (pContext->pfnInit), &SyncDcomNdr64Client, sizeof( SYNTAX_DISPATCH_TABLE ) );
         else
             memcpy( & (pContext->pfnInit), &SyncNdr64Client, sizeof( SYNTAX_DISPATCH_TABLE ) );
         }
}

/*++

Routine Description :
    This routine initialize the server side NDR_PROC_CONTEXT when using
    NDR64. 

Arguments :


Return :
    None. 
    
--*/
void 
NdrServerSetupNDR64TransferSyntax(
    ulong                   ProcNum,
    MIDL_SYNTAX_INFO  *     pSyntaxInfo,
    NDR_PROC_CONTEXT  *     pContext)
{

    PFORMAT_STRING      pFormat;
    SYNTAX_TYPE         SyntaxType = XFER_SYNTAX_NDR64;

    NDR_ASSERT( SyntaxType == NdrpGetSyntaxType( &pSyntaxInfo->TransferSyntax ) ,
                "invalid transfer sytnax" );

    pFormat = NdrpGetProcString( pSyntaxInfo,
                                 SyntaxType,
                                 ProcNum );

    MulNdrpInitializeContextFromProc( 
                                 SyntaxType,
                                 pFormat,
                                 pContext,
                                 NULL );    // StartofStack. Don't have it yet.

    pContext->pSyntaxInfo = pSyntaxInfo;

}

/*++

Routine Description :

    Setup the client side transfer syntax information from MIDL_PROXY_INFO
    This is the first thing the engine do from the public entries, so if 
    somethings goes wrong here, we don't have enough information about the 
    procedure and we can't recover from the error. We have to raise exception
    back to the application. 
    

Arguments :


Return :

    RPC_S_OK    if 

--*/
void RPC_ENTRY 
Ndr64ClientInitializeContext( 
    SYNTAX_TYPE                         SyntaxType, 
    const MIDL_STUBLESS_PROXY_INFO *    pProxyInfo,
    ulong                               nProcNum,
    NDR_PROC_CONTEXT *                  pContext,
    uchar *                             StartofStack )
{                          
    PFORMAT_STRING                      pFormat;
    RPC_STATUS                          res = RPC_S_OK;
    MIDL_SYNTAX_INFO *                  pSyntaxInfo = NULL;
    ulong                               i;

    pContext->StartofStack = StartofStack;

    for ( i = 0; i < pProxyInfo->nCount; i ++ )
        if ( SyntaxType == NdrpGetSyntaxType( &pProxyInfo->pSyntaxInfo[i].TransferSyntax ) )
            {
            pSyntaxInfo = & pProxyInfo->pSyntaxInfo[i];
            break;
            }

    // We can't do much if we are reading invalid format string
    if ( NULL == pSyntaxInfo )
        RpcRaiseException( RPC_S_UNSUPPORTED_TRANS_SYN );
    else
        {
        pFormat = NdrpGetProcString( pSyntaxInfo, SyntaxType, nProcNum );

        MulNdrpInitializeContextFromProc( SyntaxType, pFormat, pContext, StartofStack );
        pContext->pSyntaxInfo = pSyntaxInfo;
        }

}

// Fill in RPC_CLIENT_INTERFACE in rpcmessage if the proxy only support one transfer syntax.
__inline 
HRESULT NdrpDcomSetupSimpleClientInterface( 
                                        MIDL_STUB_MESSAGE * pStubMsg,
                                        RPC_CLIENT_INTERFACE * pClientIf,
                                        const IID * riid,
                                        MIDL_STUBLESS_PROXY_INFO * pProxyInfo )
{                                        
    memset(pClientIf, 0, sizeof( RPC_CLIENT_INTERFACE ) );
    pClientIf->Length = sizeof( RPC_CLIENT_INTERFACE );
    pClientIf->InterfaceId.SyntaxGUID = *riid;
    memcpy(&pClientIf->TransferSyntax, 
                pProxyInfo->pTransferSyntax, 
                sizeof(RPC_SYNTAX_IDENTIFIER) );
    pClientIf->InterpreterInfo = pProxyInfo;
    pStubMsg->RpcMsg->RpcInterfaceInformation = pClientIf;
    return S_OK;
}


RPC_STATUS RPC_ENTRY
Ndr64pClientSetupTransferSyntax( void * pThis,
                           RPC_MESSAGE  *                   pRpcMsg,
                           MIDL_STUB_MESSAGE  *             pStubMsg,
                           MIDL_STUBLESS_PROXY_INFO *       pProxyInfo,
                           NDR_PROC_CONTEXT *               pContext,
                           ulong                            nProcNum )
{                                   
    const MIDL_STUB_DESC *              pStubDesc = pProxyInfo->pStubDesc;  
    RPC_STATUS                          res = S_OK;

    // setup vtbl first so we can recover from error
    Ndr64SetupClientContextVtbl( pContext );
    
    pStubMsg->pContext       = pContext;
    pStubMsg->StackTop       = pContext->StartofStack;
    if ( pThis )
        {
        ulong SyncProcNum;

        // In DCOM async interface, the proc number in rpcmessage is the sync method id
        // instead of async methodid, so we need to setup the proxy differently.
        if ( pContext->IsAsync )
            SyncProcNum = (nProcNum + 3 ) / 2;
        else
            SyncProcNum = nProcNum;
           
        Ndr64ProxyInitialize( pThis,
                            pRpcMsg,
                            pStubMsg,
                            pProxyInfo,
                            SyncProcNum ); 
        }
    else
        {
        handle_t Handle;
        PFNEXPLICITBINDHANDLEMGR            pfnExpBindMgr = NULL; 
        PFNIMPLICITBINDHANDLEMGR            pfnImpBindMgr = NULL; 

        if ( pContext->CurrentSyntaxType == XFER_SYNTAX_NDR64 )
            {
            pfnExpBindMgr = &Ndr64ExplicitBindHandleMgr;
            pfnImpBindMgr = &Ndr64ImplicitBindHandleMgr;
            }
        else
            {                                   
            pfnExpBindMgr = &ExplicitBindHandleMgr;
            pfnImpBindMgr = &ImplicitBindHandleMgr;
            }
            
        Ndr64ClientInitialize( pRpcMsg,
                               pStubMsg,
                               pProxyInfo,
                               (uint) nProcNum );

        if ( pContext->HandleType )
            {
            //
            // We have an implicit handle.
            //
            Handle = (*pfnImpBindMgr)( pStubDesc,
                                       pContext->HandleType,
                                       &(pContext->SavedGenericHandle) );
            }
        else
            {
            PFORMAT_STRING      pFormat;
            if ( pContext->CurrentSyntaxType == XFER_SYNTAX_DCE )
                pFormat = (PFORMAT_STRING) pContext->pHandleFormatSave;
            else
                pFormat = (uchar *) pContext->Ndr64Header+ sizeof(NDR64_PROC_FORMAT);
                
            Handle = (*pfnExpBindMgr)( pStubDesc,
                                       pContext->StartofStack,
                                       pFormat,
                                       &(pContext->SavedGenericHandle ) );
            }

            pStubMsg->RpcMsg->Handle = pStubMsg->SavedHandle = Handle;

        }

        pStubMsg->RpcMsg->RpcFlags = pContext->RpcFlags;


        // The client only negotiates when the stub support more than one 
        // transfer syntax. 
        if ( pProxyInfo->nCount > 1 )
            {
            res = Ndr64ClientNegotiateTransferSyntax( pThis,
                                                      pStubMsg,
                                                      pProxyInfo,
                                                      pContext );

            if ( RPC_S_OK == res )
                {
                PFORMAT_STRING   pFormat;
                SYNTAX_TYPE      SyntaxType;
                ulong            i = 0;

                SyntaxType = NdrpGetSyntaxType( pStubMsg->RpcMsg->TransferSyntax );
                if ( SyntaxType != pContext->CurrentSyntaxType )
                    {
                    for (i = 0; i < pProxyInfo->nCount; i++)
                        {
                        if ( SyntaxType == NdrpGetSyntaxType( &pProxyInfo->pSyntaxInfo[i].TransferSyntax ) )
                            {
                            pContext->pSyntaxInfo = &( pProxyInfo->pSyntaxInfo[i] );
                            break;
                            }
                        }

                    NDR_ASSERT( i < pProxyInfo->nCount, "can't find the right syntax" );

                    // Reread the format string if we select a different transfer syntax
                    pFormat = NdrpGetProcString( pContext->pSyntaxInfo,
                                             SyntaxType,
                                             nProcNum );
            
                    MulNdrpInitializeContextFromProc( SyntaxType , 
                                                      pFormat, 
                                                      pContext, 
                                                      pContext->StartofStack,
                                                      TRUE );   // reset
                    Ndr64SetupClientContextVtbl( pContext );           
                    }
                }
            }
        else
            {
            pContext->pSyntaxInfo = pProxyInfo->pSyntaxInfo;

            // we need to fake the RPC_CLIENT_INTERFACE if client only support NDR64
            if ( pThis )
                {
                const IID * riid;
                RPC_CLIENT_INTERFACE * pClientIf;

                pClientIf = (RPC_CLIENT_INTERFACE *)NdrpAlloca( &pContext->AllocateContext, sizeof( RPC_CLIENT_INTERFACE ) );
                
                if ( pContext->IsAsync )
                    {
                    riid = NdrGetSyncProxyIID( pThis );
                    }
                else
                    riid = NdrGetProxyIID(pThis);
                    
                NdrpDcomSetupSimpleClientInterface( pStubMsg,
                                                    pClientIf,
                                                    riid,
                                                    pProxyInfo );
                }
            
            }
    return res;
    
}


HRESULT NdrpDcomNegotiateSyntax( void * pThis,
                                 MIDL_STUB_MESSAGE *pStubMsg,
                                 MIDL_STUBLESS_PROXY_INFO * pProxyInfo,
                                 NDR_PROC_CONTEXT         * pContext
                                 )
{
    IRpcSyntaxNegotiate * pNegotiate = NULL;
    IRpcChannelBuffer * pChannel = pStubMsg->pRpcChannelBuffer;
    HRESULT hr = E_FAIL ; 
    ulong nPrefer;
    const IID * riid;

    RPC_CLIENT_INTERFACE * pclientIf;

    pclientIf = ( RPC_CLIENT_INTERFACE * ) NdrpAlloca( &pContext->AllocateContext, sizeof( RPC_CLIENT_INTERFACE ) );

    if ( pContext->IsAsync )
        {
        riid = NdrGetSyncProxyIID( pThis );
        }
    else
        riid = NdrGetProxyIID(pThis);
        
    hr = pChannel->lpVtbl->QueryInterface( pChannel, IID_IRpcSyntaxNegotiate, (void **)&pNegotiate );

    if ( SUCCEEDED( hr ) )
        {
        // create RPC_CLIENT_INTERFACE here.
        memset(pclientIf, 0, sizeof( RPC_CLIENT_INTERFACE ) );
        pclientIf->Length = sizeof( RPC_CLIENT_INTERFACE ) ;
        pclientIf->InterfaceId.SyntaxGUID = *riid;
        memcpy(&pclientIf->TransferSyntax, 
                pProxyInfo->pTransferSyntax, 
                sizeof(RPC_SYNTAX_IDENTIFIER) );
        pclientIf->InterpreterInfo = pProxyInfo;
        pclientIf->Flags |= RPCFLG_HAS_MULTI_SYNTAXES;

        pStubMsg->RpcMsg->RpcInterfaceInformation = pclientIf;

        hr = pNegotiate->lpVtbl->NegotiateSyntax( pNegotiate, (RPCOLEMESSAGE *)pStubMsg->RpcMsg );

        // OLE will return S_FALSE in local server case, where OLE doesn't involve RPC runtime
        // to send package, such that I_RpcNegotiateSyntax can't be called. 
        if ( hr == S_FALSE )
            {
            NdrpGetPreferredSyntax( (ulong )pProxyInfo->nCount, pProxyInfo->pSyntaxInfo, &nPrefer );
            pStubMsg->RpcMsg->TransferSyntax = &pProxyInfo->pSyntaxInfo[nPrefer].TransferSyntax;
            hr = S_OK;
            }

        pNegotiate->lpVtbl->Release( pNegotiate );
        }
    else
        {
        // old style proxy
        hr  = NdrpDcomSetupSimpleClientInterface( pStubMsg, pclientIf, riid, pProxyInfo );
        }

    return hr;
}



RPC_STATUS RPC_ENTRY
Ndr64ClientNegotiateTransferSyntax(
    void *                       pThis,
    MIDL_STUB_MESSAGE           *pStubMsg,
    MIDL_STUBLESS_PROXY_INFO    *pProxyInfo,
    NDR_PROC_CONTEXT            *pContext  )
{
    RPC_STATUS status =         RPC_S_UNSUPPORTED_TRANS_SYN ;
    RPC_MESSAGE                 *pRpcMsg = pStubMsg->RpcMsg;
    const MIDL_STUB_DESC  *     pStubDesc = pProxyInfo->pStubDesc;
    ulong                        i;
    ushort                      FormatOffset;
    ushort  *                   pFormat; 
    uchar                       HandleType;
    HRESULT                     hr;
    SYNTAX_TYPE                 SyntaxType;

    if ( pThis )
        {
        hr = NdrpDcomNegotiateSyntax( pThis, pStubMsg, pProxyInfo, pContext );
        if ( FAILED( hr ) )
            RpcRaiseException( hr );

        status = RPC_S_OK;
        }
    else
        {
        if ( pContext->UseLocator )
            {
            // call into locator's negotiation code 
            EnsureNSLoaded();
            status = (*pRpcNsNegotiateTransferSyntax)( pStubMsg->RpcMsg );           
            }
        else
            {
            status = I_RpcNegotiateTransferSyntax( pStubMsg->RpcMsg );
            }
        if ( status != RPC_S_OK )
            RpcRaiseException( status );
        }


    return status;
}

void RPC_ENTRY
Ndr64pSizing( MIDL_STUB_MESSAGE *   pStubMsg,
            BOOL                    IsClient )
{
    long n;   
    uchar *                     pArg;
    NDR64_PARAM_FLAGS   *   pParamFlags;
    NDR_PROC_CONTEXT  *     pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;
    NDR64_PARAM_FORMAT  *   Params = 
         (NDR64_PARAM_FORMAT*)pContext->Params;

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pContext->StartofStack );
    
    for (ulong n = 0; n < pContext->NumberParams; n++ )
        {
        pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
        
        if ( IsClient && pParamFlags->IsPartialIgnore )
            {

            LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_PTR_WIRE_ALIGN );
            pStubMsg->BufferLength += sizeof(NDR64_PTR_WIRE_TYPE);
            continue;
            }

        if (  !NDR64SAMEDIRECTION(IsClient, pParamFlags) ||
             ! ( pParamFlags->MustSize ) )
            continue;

        //
        // Note : Basetypes will always be factored into the
        // constant buffer size emitted by in the format strings.
        //

        pArg = pContext->StartofStack + Params[n].StackOffset;

        if ( ! pParamFlags->IsByValue )
            pArg = *((uchar **)pArg);

        Ndr64TopLevelTypeSize( pStubMsg,
                               pArg,
                               Params[n].Type );

        }
}    


void
Ndr64ClientZeroOut(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    uchar *             pArg
    )
{
    const NDR64_POINTER_FORMAT *pPointerFormat = 
        (const NDR64_POINTER_FORMAT*)pFormat;

    //
    // In an object proc, we must zero all [out] unique and interface
    // pointers which occur as the referent of a ref pointer or embedded in a
    // structure or union.
    //

    // Let's not die on a null ref pointer.

    if ( !pArg )
        return;

    //
    // The only top level [out] type allowed is a ref pointer or an array.
    //
    if ( *(PFORMAT_STRING)pFormat == FC64_RP )
        {
        pFormat = pPointerFormat->Pointee;
        // Double pointer.
        if ( NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
            {
            *((void **)pArg) = 0;
            return;
            }

        // we need to zero out basetype because it might be conformant/
        // varying descriptor.
        if ( NDR64_SIMPLE_POINTER( pPointerFormat->Flags ) )
            {
            MIDL_memset( pArg, 0, 
                         (uint) NDR64_SIMPLE_TYPE_MEMSIZE( *(PFORMAT_STRING)pFormat ) );
            return;
            }

        }

    NDR64_UINT32 Size = Ndr64pMemorySize( pStubMsg,
                                          pFormat, 
                                          FALSE );

    MIDL_memset( pArg, 0, (size_t)Size );
}



void RPC_ENTRY
Ndr64pClientInit( MIDL_STUB_MESSAGE * pStubMsg,
                           void *              pReturnValue )
{
    NDR_PROC_CONTEXT    *       pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;
    NDR64_PROC_FORMAT   *       pHeader = pContext->Ndr64Header;
    BOOL                        fRaiseExcFlag = FALSE;    
    ulong                       n;
    uchar *                     pArg;
    NDR64_PARAM_FORMAT  *       Params;
    NDR64_PROC_FLAGS  *         pNdr64Flags;   
    NDR64_PARAM_FLAGS   *       pParamFlags;


    pNdr64Flags = (NDR64_PROC_FLAGS  * )&(pHeader->Flags) ;

    Params = ( NDR64_PARAM_FORMAT *) pContext->Params;
    

    if ( pNdr64Flags->UsesFullPtrPackage )
        pStubMsg->FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_CLIENT );
    else
        pStubMsg->FullPtrXlatTables = 0;


    if ( pNdr64Flags->UsesRpcSmPackage )
        NdrRpcSmSetClientToOsf( pStubMsg );

    if ( pNdr64Flags->UsesPipes )
        NdrpPipesInitialize64( pStubMsg,
                               &pContext->AllocateContext,
                               (PFORMAT_STRING) Params,
                               (char *)pContext->StartofStack,
                               pContext->NumberParams  );

    pStubMsg->StackTop = pContext->StartofStack;

    pStubMsg->pCorrMemory = pStubMsg->StackTop;

    // get initial size here: we might not need to get into sizing code.
    pStubMsg->BufferLength = pHeader->ConstantClientBufferSize;

    for ( n = 0; n < pContext->NumberParams; n++ )
        {
        pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
        
        if ( pParamFlags->IsReturn )
            pArg = (uchar *) &pReturnValue;
        else
            pArg = pContext->StartofStack + Params[n].StackOffset;

        if ( pParamFlags->IsSimpleRef && !pParamFlags->IsReturn )
            {
            // We cannot raise the exception here,
            // as some out args may not be zeroed out yet.
            
            if ( ! *((uchar **)pArg) )
                {
                fRaiseExcFlag = TRUE;
                continue;
                }
            
            }

        // if top level point is ref pointer and the stack is NULL, we'll catch this
        // before the call goes to server. 
        if ( pParamFlags->IsOut && !pParamFlags->IsBasetype )
            {
            if ( *(PFORMAT_STRING) Params[n].Type == FC64_RP &&  !*((uchar **)pArg) )
                {
                fRaiseExcFlag = TRUE;
                continue;
                }            
            }
        
        if ( ( pNdr64Flags->IsObject  &&
               ! pContext->IsAsync &&
               ( pParamFlags->IsPartialIgnore ||
                   ( ! pParamFlags->IsIn &&
                     ! pParamFlags->IsReturn &&
                     ! pParamFlags->IsPipe ) ) ) ||
             ( pNdr64Flags->HasComplexReturn &&
                        pParamFlags->IsReturn ) )
         {
        if ( pParamFlags->IsBasetype )
            {
            // [out] only arg can only be ref, we checked that above.

            NDR64_FORMAT_CHAR type = *(PFORMAT_STRING) Params[n].Type;
            
            MIDL_memset( *(uchar **)pArg, 
                         0, 
                         (size_t)NDR64_SIMPLE_TYPE_MEMSIZE( type ));
            }
        else
            { 
            Ndr64ClientZeroOut(
                    pStubMsg,
                    Params[n].Type,
                    *(uchar **)pArg );
            }
         }
    }

    if ( fRaiseExcFlag )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );
    
    if ( pNdr64Flags->ClientMustSize )
        {
        if ( pNdr64Flags->UsesPipes )
            RpcRaiseException( RPC_X_WRONG_PIPE_VERSION );

        
        }
    else
        pContext->pfnSizing = (PFNSIZING)NdrpNoopSizing;
}

void RPC_ENTRY
Ndr64pDcomClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                      ulong                             ProcNum,
                      RPC_STATUS                        ExceptionCode,
                      CLIENT_CALL_RETURN  *   pReturnValue  )
{
    ulong                   NumberParams ;
    NDR64_PARAM_FORMAT  *   Params ;
    ulong                   n;
    uchar               *   pArg;
    NDR64_PARAM_FLAGS   *   pParamFlags;
    NDR_PROC_CONTEXT    *   pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;

    pReturnValue->Simple = NdrProxyErrorHandler(ExceptionCode);

    if( pStubMsg->dwStubPhase != PROXY_UNMARSHAL)
        return ;

    NumberParams = pContext->NumberParams;
    Params = ( NDR64_PARAM_FORMAT * ) pContext->Params;
    //
    // Set the Buffer endpoints so the Ndr64Free routines work.
    //
    pStubMsg->BufferStart = 0;
    pStubMsg->BufferEnd   = 0;

    for ( n = 0; n < NumberParams; n++ )
        {
        pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
        
        //
        // Skip everything but [out] only parameters.  We make
        // the basetype check to cover [out] simple ref pointers
        // to basetypes.
        //
        
        if ( !pParamFlags->IsPartialIgnore )
            {
            if ( pParamFlags->IsIn ||
                 pParamFlags->IsReturn ||
                 pParamFlags->IsBasetype ||
                 pParamFlags->IsPipe )
                continue;            
            }

        pArg = pContext->StartofStack + Params[n].StackOffset;

        Ndr64ClearOutParameters( pStubMsg,
                               Params[n].Type,
                               *((uchar **)pArg) );
        }

    return ;
}


void RPC_ENTRY
Ndr64pClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                      ulong                             ProcNum,
                      RPC_STATUS                        ExceptionCode,
                      CLIENT_CALL_RETURN  *   pReturnValue  )
{
    NDR_PROC_CONTEXT    *   pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;

        if ( ( (NDR64_PROC_FLAGS *) & pContext->Ndr64Header->Flags)->HandlesExceptions )
            {
            NdrClientMapCommFault( pStubMsg,
                                   ProcNum,
                                   ExceptionCode,
                                   (ULONG_PTR*)&pReturnValue->Simple );
            }
        else
            {
            RpcRaiseException(ExceptionCode);
            }

    return;
}


void RPC_ENTRY 
Ndr64pClientMarshal( MIDL_STUB_MESSAGE *    pStubMsg,
             BOOL                   IsObject )
{
    NDR_PROC_CONTEXT *      pContext = ( NDR_PROC_CONTEXT *) pStubMsg->pContext;

//    if ( (ULONG_PTR)pStubMsg->Buffer & 15 )
//        RpcRaiseException( RPC_X_INVALID_BUFFER );

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pContext->StartofStack ); 
    
    NDR64_PARAM_FORMAT  *Params = (NDR64_PARAM_FORMAT *) pContext->Params;

    for ( ulong n = 0; n < pContext->NumberParams; n++ )
        {
        NDR64_PARAM_FLAGS   *pParamFlags = 
            ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );

        uchar *pArg = pContext->StartofStack + Params[n].StackOffset;
        
        if ( pParamFlags->IsPartialIgnore )
            {
            ALIGN( pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );
            *((NDR64_PTR_WIRE_TYPE*)pStubMsg->Buffer) = (*pArg) ? (NDR64_PTR_WIRE_TYPE)1 :
                                                                  (NDR64_PTR_WIRE_TYPE)0;
			pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);
            continue;

            }

        if ( !pParamFlags->IsIn || 
             pParamFlags->IsPipe )
            continue;        

        if ( pParamFlags->IsBasetype )
            {

            NDR64_FORMAT_CHAR type = *(PFORMAT_STRING)Params[n].Type;
            
            //
            // Check for pointer to basetype.
            //
            if ( pParamFlags->IsSimpleRef )
                pArg = *((uchar **)pArg);
            else
                {

#ifdef _IA64_    
                 if ( !IsObject && type == FC64_FLOAT32 )
                    {
                    // Due to the fact that NdrClientCall2 is called with the
                    // parameters in ... arguments, floats get promoted to doubles.
                    // This is not true for DCOM since an assembly langauge wrapper
                    // is used that saves the floats as floats.
                    //
                    // BUG, BUG.  IA64 passes byval structures that consist 
                    // entirely of float fields with each field in a separate register.
                    // We do not handle this case properly. 
                    *((float *) pArg) = (float) *((double *)pArg);     

                    }
#endif     

                }

            ALIGN( pStubMsg->Buffer, NDR64_SIMPLE_TYPE_BUFALIGN( type ) );

            RpcpMemoryCopy(
                pStubMsg->Buffer,
                pArg,
                NDR64_SIMPLE_TYPE_BUFSIZE( type ) );

            pStubMsg->Buffer +=
                NDR64_SIMPLE_TYPE_BUFSIZE( type );

            continue;
            }

        if ( ! pParamFlags->IsByValue )
            pArg = *((uchar **)pArg);

        Ndr64TopLevelTypeMarshall( pStubMsg,
                                   pArg,
                                   Params[n].Type );

        }     
        if ( pStubMsg->RpcMsg->BufferLength <
                 (uint)(pStubMsg->Buffer - (uchar *)pStubMsg->RpcMsg->Buffer) )
            {
            NDR_ASSERT( 0, "Ndr64pClientmarshal: buffer overflow!" );
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
            }        
}



void RPC_ENTRY 
Ndr64pServerMarshal( MIDL_STUB_MESSAGE *    pStubMsg )
{
    NDR_PROC_CONTEXT    *   pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;

//    if ( (ULONG_PTR)pStubMsg->Buffer & 15 )
//        RpcRaiseException( RPC_X_INVALID_BUFFER );

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pContext->StartofStack );
    NDR64_PARAM_FORMAT  *Params = (NDR64_PARAM_FORMAT *) pContext->Params;

    for ( ulong n = 0; n < pContext->NumberParams; n++ )
        {
        NDR64_PARAM_FLAGS   *pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );

        uchar *pArg = pContext->StartofStack + Params[n].StackOffset;
        
        if (!pParamFlags->IsOut || 
             pParamFlags->IsPipe )
            continue;        

        if ( pParamFlags->IsBasetype )
            {
            NDR64_FORMAT_CHAR type = *(PFORMAT_STRING)Params[n].Type;

            //
            // Check for pointer to basetype.
            //
            if ( pParamFlags->IsSimpleRef )
                pArg = *((uchar **)pArg);

            ALIGN( pStubMsg->Buffer, NDR64_SIMPLE_TYPE_BUFALIGN( type ) );

            RpcpMemoryCopy(
                pStubMsg->Buffer,
                pArg,
                NDR64_SIMPLE_TYPE_BUFSIZE( type ) );

            pStubMsg->Buffer +=
                NDR64_SIMPLE_TYPE_BUFSIZE( type );

            continue;
            }   

        if ( ! pParamFlags->IsByValue )
            pArg = *((uchar **)pArg);

        Ndr64TopLevelTypeMarshall( pStubMsg,
                                   pArg,
                                   Params[n].Type);

        }     
    if ( pStubMsg->RpcMsg->BufferLength <
             (uint)(pStubMsg->Buffer - (uchar *)pStubMsg->RpcMsg->Buffer) )
        {
        NDR_ASSERT( 0, "Ndr64pCompleteAsyncServerCall marshal: buffer overflow!" );
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }
        
}

void RPC_ENTRY 
Ndr64pClientUnMarshal ( MIDL_STUB_MESSAGE *     pStubMsg,
                void *                  pReturnValue )
{
    uchar *                     pArg;
    NDR_PROC_CONTEXT *          pContext = ( NDR_PROC_CONTEXT *) pStubMsg->pContext;

    NDR64_PARAM_FORMAT  *Params = (NDR64_PARAM_FORMAT *)pContext->Params;

//    if ( (ULONG_PTR)pStubMsg->Buffer & 15 )
//        RpcRaiseException( RPC_X_INVALID_BUFFER );

    CORRELATION_CONTEXT( pStubMsg, pContext->StartofStack );
   
    //
    // ----------------------------------------------------------
    // Unmarshall Pass.
    // ----------------------------------------------------------
    //

    for ( ulong n = 0; n < pContext->NumberParams; n++ )
        {
        NDR64_PARAM_FLAGS   *pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
        
        if ( pParamFlags->IsPipe )
            continue;

        if ( !pParamFlags->IsOut )
            {
            if ( !pParamFlags->IsIn && !pParamFlags->IsReturn )
                {
                // If a param is not [in], [out], or a return value,
                // then it is a "hidden" client-side only status
                // paramater.  It will get set below if an exception
                // happens.  If everything is ok we need to zero it
                // out here.

                NDR_ASSERT( pParamFlags->IsSimpleRef
                                && pParamFlags->IsBasetype
                                && FC64_ERROR_STATUS_T == 
                                          *(PFORMAT_STRING)Params[n].Type,
                            "Apparently not a hidden status param" );

                pArg = pContext->StartofStack + Params[n].StackOffset;

                ** (error_status_t **) pArg = RPC_S_OK;
                }

            continue;
            }

        if ( pParamFlags->IsReturn )
            {
            if ( ! pReturnValue )
                RpcRaiseException( RPC_S_INVALID_ARG );

            pArg = (uchar *) pReturnValue;
            }
        else
            pArg = pContext->StartofStack + Params[n].StackOffset;

        //
        // This is for returned basetypes and for pointers to
        // basetypes.
        //
        if ( pParamFlags->IsBasetype )
            {
            NDR64_FORMAT_CHAR type = *(PFORMAT_STRING)Params[n].Type;

            //
            // Check for a pointer to a basetype.
            //
            if ( pParamFlags->IsSimpleRef )
                pArg = *((uchar **)pArg);

            ALIGN( pStubMsg->Buffer, NDR64_SIMPLE_TYPE_BUFALIGN( type ) );

            RpcpMemoryCopy(
                pArg,
                pStubMsg->Buffer,
                NDR64_SIMPLE_TYPE_BUFSIZE( type ) );

            pStubMsg->Buffer +=
                NDR64_SIMPLE_TYPE_BUFSIZE( type );

            continue;
            }


        uchar **ppArg = pParamFlags->IsByValue ? &pArg : (uchar **)pArg;

        //
        // Transmit/Represent as can be passed as [out] only, thus
        // the IsByValue check.
        //
        Ndr64TopLevelTypeUnmarshall( pStubMsg,
                                     ppArg,
                                     Params[n].Type,
                                     false );
        }

    if ( pStubMsg->pCorrInfo )
        Ndr64CorrelationPass( pStubMsg );

    return ;
   
}


void  RPC_ENTRY
Ndr64pClientFinally( PMIDL_STUB_MESSAGE pStubMsg,
                     void *  pThis )
{
    NDR_PROC_CONTEXT * pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;
    PMIDL_STUB_DESC   pStubDesc = pStubMsg->StubDesc;
    NdrFullPointerXlatFree(pStubMsg->FullPtrXlatTables);

    //
    // Free the RPC buffer.
    //
    if ( pThis )
        {
        NdrProxyFreeBuffer( pThis, pStubMsg );
        }
    else
        {
        NdrFreeBuffer( pStubMsg );

        //
        // Unbind if generic handle used.  We do this last so that if the
        // the user's unbind routine faults, then all of our internal stuff
        // will already have been freed.
        //
        if ( pContext->SavedGenericHandle )
            Ndr64GenericHandleUnbind( pStubDesc,
                             pContext->StartofStack,
                             (uchar *)pContext->Ndr64Header+ sizeof(NDR64_PROC_FORMAT),
                             (pContext->HandleType) ? IMPLICIT_MASK : 0,
                             &pContext->SavedGenericHandle );
        }

    NdrpAllocaDestroy( & pContext->AllocateContext );
}
              

void 
Ndr64pServerOutInit( PMIDL_STUB_MESSAGE pStubMsg )
{
    NDR_PROC_CONTEXT * pContext = ( NDR_PROC_CONTEXT *) pStubMsg->pContext;
    NDR64_PARAM_FLAGS   *       pParamFlags;
    NDR64_PARAM_FORMAT* Params =   (NDR64_PARAM_FORMAT*)pContext->Params;
    NDR64_PROC_FLAGS *      pNdr64Flags = (NDR64_PROC_FLAGS *)&pContext->Ndr64Header->Flags;
    uchar *                 pArg;    
    
    for ( ulong n = 0; n < pContext->NumberParams; n++ )
        {
        pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
        
        if ( !pParamFlags->IsPartialIgnore )
            {
            
            if (  pParamFlags->IsIn     ||
                  (pParamFlags->IsReturn && !pNdr64Flags->HasComplexReturn) ||
                  pParamFlags->IsPipe )
                continue;

            pArg = pContext->StartofStack + Params[n].StackOffset;


            }
        else 
            {

            pArg = pContext->StartofStack + Params[n].StackOffset;

            if ( !*(void**)pArg )
                continue;
            }

        //
        // Check if we can initialize this parameter using some of our
        // stack.
        //
        if ( pParamFlags->UseCache  )
            {
            *((void **)pArg) = NdrpAlloca( &pContext->AllocateContext, 64 ); 
             
            MIDL_memset( *((void **)pArg),
                         0,
                         64 );
            continue;
            }
        else if ( pParamFlags->IsBasetype )
            {
            *((void **)pArg) = NdrpAlloca( &pContext->AllocateContext,8);
            MIDL_memset( *((void **)pArg), 0, 8 );
            continue;
            };

        Ndr64OutInit( pStubMsg,
                    Params[n].Type,
                    (uchar **)pArg );
        }

}


#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\pipes.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                                                   
Copyright (c) 1995 - 2000 Microsoft Corporation

Module Name :

    pipes.cxx

Abstract :

    This file contains the 64bit specified pipe code.

Author :

    Mike Zoran     (mzoran)    Feb 2000

Revision History :

---------------------------------------------------------------------*/

#include "precomp.hxx"
#include "..\ndr20\pipendr.h"


class NDR_PIPE_HELPER64 : public NDR_PIPE_HELPER
{

private:

    PMIDL_STUB_MESSAGE pStubMsg;
    char *pStackTop;

    unsigned long NumberParameters;
    NDR64_PARAM_FORMAT* pFirstParameter;

    NDR64_PARAM_FORMAT* pCurrentParameter;
    unsigned long CurrentParamNumber;

    NDR_PIPE_DESC PipeDesc;

public:

    void *operator new( size_t stAllocateBlock, PNDR_ALLOCA_CONTEXT pAllocContext )
    {
        return NdrpAlloca( pAllocContext, (UINT)stAllocateBlock );
    }
    // Do nothing since the memory will be deleted automatically
    void operator delete(void *pMemory) {}

    NDR_PIPE_HELPER64( PMIDL_STUB_MESSAGE  pStubMsg,
                       PFORMAT_STRING      Params,
                       char *              pStackTop,
                       unsigned long       NumberParams )
    {
        NDR_PIPE_HELPER64::pStubMsg  = pStubMsg;
        NDR_PIPE_HELPER64::pStackTop = pStackTop; 
        pFirstParameter  = (NDR64_PARAM_FORMAT*)Params;
        NumberParameters = NumberParams;

    }

    virtual PNDR_PIPE_DESC GetPipeDesc() 
        {
        return &PipeDesc;
        }

    virtual bool InitParamEnum() 
        {
        pCurrentParameter = pFirstParameter;
        CurrentParamNumber = 0;
        return NumberParameters > 0;
        }

    virtual bool GotoNextParam() 
        {
        if ( CurrentParamNumber + 1 >= NumberParameters )
            {
            return false;
            }
        
        CurrentParamNumber++;
        pCurrentParameter = pFirstParameter + CurrentParamNumber;
        return true;
        }

    virtual unsigned short GetParamPipeFlags()
        {
            NDR64_PARAM_FLAGS *pParamFlags = (NDR64_PARAM_FLAGS *)&pCurrentParameter->Attributes;
            if ( !pParamFlags->IsPipe )
                return 0;

            unsigned short Flags = 0;

            if ( pParamFlags->IsIn )
                Flags |= NDR_IN_PIPE;
            if ( pParamFlags->IsOut )
                Flags |= NDR_OUT_PIPE;

            if ( pParamFlags->IsSimpleRef )
                Flags |= NDR_REF_PIPE;

            return Flags;
        }

    virtual PFORMAT_STRING GetParamTypeFormat() 
        {
            return (PFORMAT_STRING)pCurrentParameter->Type;
        }

    virtual char *GetParamArgument() 
        {
            return pStackTop + pCurrentParameter->StackOffset;
        }

    virtual void InitPipeStateWithType( PNDR_PIPE_MESSAGE pPipeMsg )
        {

        NDR64_PIPE_FORMAT*   pPipeFc = (NDR64_PIPE_FORMAT *) pPipeMsg->pTypeFormat;
        NDR_PIPE_STATE *pState   = & PipeDesc.RuntimeState;
        NDR64_PIPE_FLAGS *pPipeFlags = (NDR64_PIPE_FLAGS*)&pPipeFc->Flags;
        NDR64_RANGE_PIPE_FORMAT *pRangePipeFc = (NDR64_RANGE_PIPE_FORMAT*)pPipeFc;

        pState->LowChunkLimit = 0;
        pState->HighChunkLimit = NDR_DEFAULT_PIPE_HIGH_CHUNK_LIMIT;
        pState->ElemAlign = pPipeFc->Alignment;
        pState->ElemMemSize  = pPipeFc->MemorySize;
        pState->ElemWireSize = pPipeFc->BufferSize;

        if ( pPipeFlags->HasRange )
            {
            pState->LowChunkLimit  = pRangePipeFc->MinValue;
            pState->HighChunkLimit = pRangePipeFc->MaxValue;
            }

        pState->ElemPad     = WIRE_PAD( pState->ElemWireSize, pState->ElemAlign );
        pState->fBlockCopy  = pPipeFlags->BlockCopy; 
        }
    
    virtual void MarshallType( PNDR_PIPE_MESSAGE pPipeMsg,
                               uchar *pMemory,
                               unsigned long Elements )
        {

            unsigned long ElemMemSize =  PipeDesc.RuntimeState.ElemMemSize;
            
            NDR64_PIPE_FORMAT*   pPipeFc = (NDR64_PIPE_FORMAT *) pPipeMsg->pTypeFormat;
            while( Elements-- )
                {
                Ndr64TopLevelTypeMarshall( pPipeMsg->pStubMsg,
                                           pMemory,
                                           pPipeFc->Type );

                pMemory += ElemMemSize;
                }
        }
    
    virtual void UnmarshallType( PNDR_PIPE_MESSAGE pPipeMsg,
                                 uchar *pMemory,
                                 unsigned long Elements )
        {

            unsigned long ElemMemSize =  PipeDesc.RuntimeState.ElemMemSize;
            
            NDR64_PIPE_FORMAT*   pPipeFc = (NDR64_PIPE_FORMAT *) pPipeMsg->pTypeFormat;

            while( Elements-- )
                {
                Ndr64TopLevelTypeUnmarshall( pPipeMsg->pStubMsg,
                                             &pMemory,
                                             pPipeFc->Type,
                                             false );
                pMemory += ElemMemSize;
                }

        }
    
    virtual void BufferSizeType( PNDR_PIPE_MESSAGE pPipeMsg,
                                 uchar *pMemory,
                                 unsigned long Elements )
        { 
        
        unsigned long ElemMemSize = PipeDesc.RuntimeState.ElemMemSize;
        
        NDR64_PIPE_FORMAT*   pPipeFc = (NDR64_PIPE_FORMAT *) pPipeMsg->pTypeFormat;

        while( Elements-- )
            {
            Ndr64TopLevelTypeSize( pPipeMsg->pStubMsg,
                                   pMemory,
                                   pPipeFc->Type );

            pMemory += ElemMemSize;
            }

        }
    
    virtual void ConvertType( PNDR_PIPE_MESSAGE /* pPipeMsg */,
                              unsigned long /* Elements */ ) 
        {
        }

    virtual void BufferSizeChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg ) 
    {
        PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;
        LENGTH_ALIGN( pStubMsg->BufferLength, sizeof(NDR64_UINT64)-1 );
        pStubMsg->BufferLength += sizeof(NDR64_UINT64);
    }

    virtual bool UnmarshallChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                          ulong *pOut )
    {
        PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;
        ALIGN( pStubMsg->Buffer, sizeof(NDR64_UINT64)-1);
        
        if ( 0 == REMAINING_BYTES() )
            {
            return false;
            }

        // transition: end of src

        if (REMAINING_BYTES() < sizeof(NDR64_UINT64))
            {
            // with packet sizes being a multiple of 8,
            // this cannot happen.

            NDR_ASSERT( 0, "Chunk counter split is not possible.");

            NdrpRaisePipeException( &PipeDesc,  RPC_S_INTERNAL_ERROR );
            return false;
            }
        
        NDR64_UINT64 Counter = *(NDR64_UINT64*)pStubMsg->Buffer;
        pStubMsg->Buffer += sizeof(NDR64_UINT64);
        
        *pOut = Ndr64pConvertTo2GB( Counter );
        return true;
    }

    virtual void MarshallChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg, 
                                       ulong Counter )
    {
        PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;
        ALIGN( pStubMsg->Buffer, sizeof(NDR64_UINT64)-1);
        
        Ndr64pConvertTo2GB( Counter );
        *(NDR64_UINT64*)pStubMsg->Buffer = (NDR64_UINT64)Counter;
        pStubMsg->Buffer += sizeof(NDR64_UINT64);
    }

    virtual void BufferSizeChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg ) 
       { 
       BufferSizeChunkCounter( pPipeMsg ); 
       }

    virtual void MarshallChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                           ulong Counter ) 
       { 
       PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;
       ALIGN( pStubMsg->Buffer, sizeof(NDR64_UINT64)-1);
       
       Ndr64pConvertTo2GB( Counter );
       NDR64_UINT64 TailCounter = (NDR64_UINT64)-(NDR64_INT64)(NDR64_UINT64)Counter;
       *(NDR64_UINT64*)pStubMsg->Buffer = TailCounter;
       pStubMsg->Buffer += sizeof(NDR64_UINT64);

       }

    virtual bool VerifyChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                         ulong HeaderCounter ) 
       { 
       PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;
       ALIGN( pStubMsg->Buffer, sizeof(NDR64_UINT64)-1);

       if ( 0 == REMAINING_BYTES() )
           {
           return false;
           }

       // transition: end of src

       if (REMAINING_BYTES() < sizeof(NDR64_UINT64))
           {
           // with packet sizes being a multiple of 8,
           // this cannot happen.

           NDR_ASSERT( 0, "Chunk counter split is not possible.");

           NdrpRaisePipeException( &PipeDesc,  RPC_S_INTERNAL_ERROR );
           return false;
           }

       NDR64_UINT64 TailCounter = *(NDR64_UINT64*)pStubMsg->Buffer;
       pStubMsg->Buffer += sizeof(NDR64_UINT64);
       
       Ndr64pConvertTo2GB( HeaderCounter );
       NDR64_UINT64 TailCounterChk = (NDR64_UINT64)-(NDR64_INT64)(NDR64_UINT64)HeaderCounter;
       
       if ( TailCounterChk != TailCounter )
           {
           RpcRaiseException( RPC_X_INVALID_BOUND );
           }

       return true;
       }

    virtual bool HasChunkTailCounter() { return TRUE; }


};





void
NdrpPipesInitialize64(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR_ALLOCA_CONTEXT pAllocContext,
    PFORMAT_STRING      Params,
    char *              pStackTop,
    unsigned long       NumberParams
    )
{

    /* C wrapper to initialize the 32 pipe helper and call NdrPipesInitialize*/
    NDR_PIPE_HELPER64 *pPipeHelper =
        new( pAllocContext ) NDR_PIPE_HELPER64( pStubMsg,
                                                Params,
                                                pStackTop,
                                                NumberParams );
    NdrPipesInitialize( pStubMsg,
                        pPipeHelper,
                        pAllocContext );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\pointer.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    pointer.cxx

Abstract :

    This file contains the routines for handling pointers and pointer
    layouts.
    
Author :

    Mike Zoran  mzoran   January 2000.

Revision History :

  ---------------------------------------------------------------------*/
#include "precomp.hxx"

#if !defined(DBG)
// Optimize for time to force inlining.
#pragma optimize("gt", on)

#endif

typedef enum 
{
    NDR64_CORRELATION_NONE=0,
    NDR64_CORRELATION_MEMORY=1,
    NDR64_CORRELATION_BUFFER=2
} NDR64_CORRELATION_TYPE;

template<class Function>
static __forceinline void
Ndr64pProcessPointerLayout( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pLayoutFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory,
    uchar *             pBuffer,
    const NDR64_CORRELATION_TYPE CorrType,
    Function            func )
/*++

Routine Description :

    Marshalls an array's or a structure's embedded pointers.

Arguments :

    pStubMsg        - Pointer to the stub message.
    pFormat         - The format string pointer layout.
    ArrayIterations - Numbers of iterations for variable sized arrays.
    pMemory         - Pointer to the structure or array whose embedded pointers 
                      are being marshalled.
    pBuffer         - Pointer to the buffer for the structure or arrays
    CorrType        - Determines how to set pCorrMemory.
    func            - Function to call to do the processing 
 

Return :

    Format string pointer after the pointer layout.

 --*/
{

    PFORMAT_STRING pFormat = (PFORMAT_STRING)pLayoutFormat;

    for (;;) 
        {

        const NDR64_REPEAT_FORMAT *pRepeatFormat;
        NDR64_UINT32 Iterations;

        switch( *pFormat )
            {

            case FC64_NO_REPEAT:
                {
                const NDR64_NO_REPEAT_FORMAT                *pNoRepeatHeader  = 
                    (NDR64_NO_REPEAT_FORMAT*)pFormat;
                
                const NDR64_POINTER_INSTANCE_HEADER_FORMAT  *pPointerInstance =
                    (NDR64_POINTER_INSTANCE_HEADER_FORMAT   *)(pNoRepeatHeader + 1);
                
                const NDR64_POINTER_FORMAT           *pPointerFormat = 
                    (NDR64_POINTER_FORMAT*)(pPointerInstance + 1);

                uchar *pMemPtr = pMemory + pPointerInstance->Offset;
                uchar *pBufPtr = pBuffer + pPointerInstance->Offset;
                
                func( pStubMsg,
                      pMemPtr,
                      pBufPtr ,
                      pPointerFormat );

                pFormat += sizeof(NDR64_NO_REPEAT_FORMAT) + 
                           sizeof(NDR64_POINTER_INSTANCE_HEADER_FORMAT) +
                           sizeof(NDR64_POINTER_FORMAT);

                break;
                }
            
            case FC64_FIXED_REPEAT:
                Iterations = ((NDR64_FIXED_REPEAT_FORMAT*)pFormat)->Iterations;
                pRepeatFormat = (NDR64_REPEAT_FORMAT*)pFormat;
                pFormat += sizeof(NDR64_FIXED_REPEAT_FORMAT);
                goto RepeatCommon;

            case FC64_VARIABLE_REPEAT:
                Iterations = ArrayIterations;
                pRepeatFormat = (NDR64_REPEAT_FORMAT*)pFormat;
                pFormat += sizeof(NDR64_REPEAT_FORMAT);
                // Fall through to Repeat Common
RepeatCommon:
                {

                uchar *pArrayMemory = pMemory + pRepeatFormat->OffsetToArray;
                uchar *pArrayBuffer = pBuffer + pRepeatFormat->OffsetToArray;
                PFORMAT_STRING pFormatSave = pFormat;

                uchar *pCorrMemorySave;
                if ( CorrType ) 
                    pCorrMemorySave = pStubMsg->pCorrMemory;

                    {
                    // Loop over the array elements
                    for( ; Iterations; 
                         Iterations--,
                         pArrayMemory += pRepeatFormat->Increment,
                         pArrayBuffer += pRepeatFormat->Increment)
                        {

                        pFormat = pFormatSave;

                        if ( CorrType ) 
                            {
                            if ( CorrType == NDR64_CORRELATION_MEMORY ) 
                                {
                                if (pRepeatFormat->Flags.SetCorrMark)
                                    pStubMsg->pCorrMemory = pArrayMemory;                      
                                }
                            else 
                                {
                                if (pRepeatFormat->Flags.SetCorrMark)
                                    pStubMsg->pCorrMemory = pArrayBuffer;                      
                                }
                            }

                        // Loop over the pointers per element
                        for ( NDR64_UINT32 Pointers = pRepeatFormat->NumberOfPointers;
                              Pointers; Pointers-- ) 
                            {

                            const NDR64_POINTER_INSTANCE_HEADER_FORMAT  *pPointerInstance =
                                  (NDR64_POINTER_INSTANCE_HEADER_FORMAT   *)pFormat;
                            const NDR64_POINTER_FORMAT           *pPointerFormat = 
                                  (NDR64_POINTER_FORMAT*)(pPointerInstance + 1);

                            uchar *pMemPtr = pArrayMemory + pPointerInstance->Offset;
                            uchar *pBufPtr = pArrayBuffer + pPointerInstance->Offset;

                            func( pStubMsg,
                                  pMemPtr,
                                  pBufPtr,
                                  pPointerFormat );

                            pFormat += sizeof(NDR64_POINTER_INSTANCE_HEADER_FORMAT) +
                                       sizeof(NDR64_POINTER_FORMAT);
                            }
                        }
                    
                    }

                if ( CorrType ) 
                    pStubMsg->pCorrMemory = pCorrMemorySave;
                
                }
            
            case FC64_END:

                return;

            default :
                NDR_ASSERT(0,"Ndr64pProcessPointerLayout : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
        
            } // switch
        }    
}

static __forceinline void 
Ndr64pPointerLayoutMarshallCallback(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar*              pMemPtr,
    uchar*              pBufPtr,
    PNDR64_FORMAT       pFormat )
{

    Ndr64pPointerMarshall
        ( pStubMsg,
          (NDR64_PTR_WIRE_TYPE*)pBufPtr,
          *(uchar**)pMemPtr,
          (PFORMAT_STRING)pFormat );        
}


void
Ndr64pPointerLayoutMarshall( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory,
    uchar *             pBuffer )
{

    POINTER_BUFFER_SWAP_CONTEXT SwapContext( pStubMsg );

    Ndr64pProcessPointerLayout(
        pStubMsg,
        pFormat,
        ArrayIterations,
        pMemory,
        pBuffer,
        NDR64_CORRELATION_MEMORY,
        Ndr64pPointerLayoutMarshallCallback);

}

static __forceinline void 
Ndr64pPointerLayoutUnmarshallCallback(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar*              pMemPtr,
    uchar*              pBufPtr,
    PNDR64_FORMAT       pFormat )
{

   Ndr64pPointerUnmarshall( 
       pStubMsg,
       *(NDR64_PTR_WIRE_TYPE*)pBufPtr,
       (uchar **)pMemPtr,
       *(uchar**)pMemPtr,
       pFormat );

    // Need to copy the value written to the memory pointer back to 
    // the buffer pointer since the buffer will be block copied to the memory. 
    *(uchar **)pBufPtr = *(uchar **)pMemPtr; 
}

void
Ndr64pPointerLayoutUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory,
    uchar *             pBuffer ) 
{

    POINTER_BUFFER_SWAP_CONTEXT SwapContext( pStubMsg );

    uchar *pBufferSave = 0;

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, pMemory );

    Ndr64pProcessPointerLayout(
        pStubMsg,
        pFormat,
        ArrayIterations,
        pMemory,
        pBuffer,
        NDR64_CORRELATION_BUFFER,
        Ndr64pPointerLayoutUnmarshallCallback);

}

static __forceinline void 
Ndr64pPointerLayoutMemorySizeCallback(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar*              pMemPtr,
    uchar*              pBufPtr,
    PNDR64_FORMAT       pFormat )
{

    // Discard the pMemPtr
    Ndr64pPointerMemorySize( 
        pStubMsg,
        (NDR64_PTR_WIRE_TYPE*)pBufPtr,
        pFormat );

}

void
Ndr64pPointerLayoutMemorySize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pBuffer )
{

    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    POINTER_MEMSIZE_SWAP_CONTEXT SwapContext( pStubMsg );

    Ndr64pProcessPointerLayout(
        pStubMsg,
        pFormat,
        ArrayIterations,
        pBuffer,
        pBuffer,
        NDR64_CORRELATION_NONE,
        Ndr64pPointerLayoutMemorySizeCallback );

}

static __forceinline void 
Ndr64pPointerLayoutBufferSizeCallback(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar*              pMemPtr,
    uchar*              pBufPtr,
    PNDR64_FORMAT       pFormat )
{

    // Discard the BufferPointer
    Ndr64pPointerBufferSize( 
        pStubMsg,
        *(uchar**)pMemPtr,
        pFormat );

}


void 
Ndr64pPointerLayoutBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory )
{

    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext( pStubMsg );

    Ndr64pProcessPointerLayout(
        pStubMsg,
        pFormat,
        ArrayIterations,
        pMemory,
        pMemory,
        NDR64_CORRELATION_MEMORY,
        Ndr64pPointerLayoutBufferSizeCallback );

}

static __forceinline void 
Ndr64pPointerLayoutFreeCallback(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar*              pMemPtr,
    uchar*              pBufPtr,
    PNDR64_FORMAT       pFormat )
{

    Ndr64PointerFree( 
        pStubMsg,
        *(uchar**)pMemPtr,
        pFormat );

}


void 
Ndr64pPointerLayoutFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory )

{
    Ndr64pProcessPointerLayout(
        pStubMsg,
        pFormat,
        ArrayIterations,
        pMemory,
        pMemory,
        NDR64_CORRELATION_MEMORY,
        Ndr64pPointerLayoutFreeCallback );
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\misc.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 Microsoft Corporation

Module Name :

    misc.c

Abstract :

    Contains miscelaneous helper routines.

Author :

    David Kays  dkays   December 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "precomp.hxx"

uchar *
Ndr64pMemoryIncrement( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    BOOL                fUseBufferConformance
    )
/*++

Routine Description :

    Returns a memory pointer incremeted past a complex data type.  This routine
    is also overloaded to compute the size of a complex data type by passing
    a 0 memory pointer.

Arguments :

    pStubMsg                - Pointer to the stub message.
    pMemory                 - Pointer to the complex type, or 0 if a size is being computed.
    pFormat                 - Format string description.
    fUseBufferConformance   - Use conformance from buffer(During unmarshalling).

Return :

    A memory pointer incremented past the complex type.  If a 0 memory pointer
    was passed in then the returned value is the size of the complex type.

--*/
{
    long    Elements;
    long    ElementSize;

    switch ( *(PFORMAT_STRING)pFormat )
        {
         //
         // simple types
         //
         case FC64_CHAR :
         case FC64_WCHAR :
         case FC64_INT8:
         case FC64_UINT8:
         case FC64_INT16:
         case FC64_UINT16:
         case FC64_INT32:
         case FC64_UINT32:
         case FC64_INT64:
         case FC64_UINT64:
         case FC64_FLOAT32 :
         case FC64_FLOAT64 :
         case FC64_ERROR_STATUS_T:
         case FC64_IGNORE :
             pMemory +=  NDR64_SIMPLE_TYPE_MEMSIZE(*(PFORMAT_STRING)pFormat);
             break;

        //
        // Structs
        //
        case FC64_STRUCT :
        case FC64_PSTRUCT :
            pMemory += ((const NDR64_STRUCTURE_HEADER_FORMAT*)pFormat)->MemorySize;
            break;

        case FC64_CONF_STRUCT :
        case FC64_CONF_PSTRUCT :
            {
            const NDR64_CONF_STRUCTURE_HEADER_FORMAT *pStructFormat = 
                (const NDR64_CONF_STRUCTURE_HEADER_FORMAT*) pFormat;
            
            pMemory += pStructFormat->MemorySize;
            pMemory = Ndr64pMemoryIncrement( pStubMsg,
                                             pMemory,
                                             pStructFormat->ArrayDescription,
                                             fUseBufferConformance );
            }

            break;
            
        case FC64_BOGUS_STRUCT :
        case FC64_FORCED_BOGUS_STRUCT:
            pMemory += ((const NDR64_BOGUS_STRUCTURE_HEADER_FORMAT*)pFormat)->MemorySize;
            break;

        case FC64_CONF_BOGUS_STRUCT:
        case FC64_FORCED_CONF_BOGUS_STRUCT:
            {
            const NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT *pStructFormat = 
                (const NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;

            CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );
            
            pMemory += pStructFormat->MemorySize;
            pMemory = Ndr64pMemoryIncrement( pStubMsg,
                                             pMemory,
                                             pStructFormat->ConfArrayDescription,
                                             fUseBufferConformance );
            
            }
            break;

            
        //
        // Unions
        //
        case FC64_ENCAPSULATED_UNION :
            pMemory += ((const NDR64_ENCAPSULATED_UNION*)pFormat)->MemorySize;
            break;

        case FC64_NON_ENCAPSULATED_UNION :            
            pMemory += ((const NDR64_NON_ENCAPSULATED_UNION*)pFormat)->MemorySize;
            break;

        //
        // Arrays
        //
        case FC64_FIX_ARRAY :
            pMemory += ((const NDR64_FIX_ARRAY_HEADER_FORMAT*)pFormat)->TotalSize;
            break;

        case FC64_CONF_ARRAY:
            {
            const NDR64_CONF_ARRAY_HEADER_FORMAT *pArrayFormat =
                (const NDR64_CONF_ARRAY_HEADER_FORMAT *)pFormat;
            SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark );

            NDR64_WIRE_COUNT_TYPE Elements;

            if ( fUseBufferConformance )
                {
                Elements = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
                pStubMsg->ConformanceMark += sizeof(NDR64_WIRE_COUNT_TYPE);
                }
            else 
                {
                Elements = 
                Ndr64EvaluateExpr( pStubMsg,
                                   pArrayFormat->ConfDescriptor,
                                   EXPR_MAXCOUNT );
                }


            pMemory += Ndr64pConvertTo2GB( (NDR64_UINT64)pArrayFormat->ElementSize *
                                           Elements );

            }
            break;

        case FC64_CONFVAR_ARRAY:
            {
            const NDR64_CONF_VAR_ARRAY_HEADER_FORMAT *pArrayFormat =
                (const NDR64_CONF_VAR_ARRAY_HEADER_FORMAT *)pFormat;
            SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark );
            NDR64_WIRE_COUNT_TYPE Elements;

            if ( fUseBufferConformance )
                {
                Elements = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
                pStubMsg->ConformanceMark += sizeof(NDR64_WIRE_COUNT_TYPE);
                }
            else 
                {
                Elements =
                Ndr64EvaluateExpr( pStubMsg,
                                   pArrayFormat->ConfDescriptor,
                                   EXPR_MAXCOUNT );
                }


            pMemory += Ndr64pConvertTo2GB( (NDR64_UINT64)pArrayFormat->ElementSize *
                                           Elements );
            }
            break;

        case FC64_VAR_ARRAY:
            {
            const NDR64_VAR_ARRAY_HEADER_FORMAT *pArrayFormat =
                (NDR64_VAR_ARRAY_HEADER_FORMAT*)pFormat;
            pMemory += pArrayFormat->TotalSize;
            }
            break;

        case FC64_FIX_BOGUS_ARRAY :
        case FC64_FIX_FORCED_BOGUS_ARRAY:
        case FC64_BOGUS_ARRAY:
        case FC64_FORCED_BOGUS_ARRAY:
            
            {
            
            const NDR64_BOGUS_ARRAY_HEADER_FORMAT *pArrayFormat =
                (NDR64_BOGUS_ARRAY_HEADER_FORMAT*)pFormat;
            
            NDR64_WIRE_COUNT_TYPE Elements = pArrayFormat->NumberElements;

            BOOL IsFixed = ( pArrayFormat->FormatCode == FC64_FIX_BOGUS_ARRAY ) ||
                           ( pArrayFormat->FormatCode == FC64_FIX_FORCED_BOGUS_ARRAY );

            SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark ); 

            if ( !IsFixed )
                {

                const NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT* pConfVarFormat=
                    (NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT*)pFormat;

                if ( pConfVarFormat->ConfDescription )
                    {
                    if ( fUseBufferConformance )
                        {
                        Elements = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
                        pStubMsg->ConformanceMark += sizeof(NDR64_WIRE_COUNT_TYPE);
                        }
                    else 
                        {
                        Elements = (NDR64_UINT32)
                                   Ndr64EvaluateExpr(pStubMsg,
                                                     pConfVarFormat->ConfDescription,
                                                     EXPR_MAXCOUNT);

                        }
                    }
                
                }

            NDR64_UINT32 ElementMemorySize = 
                (NDR64_UINT32)( Ndr64pMemoryIncrement( pStubMsg,
                                                       pMemory,
                                                       pArrayFormat->Element,
                                                       fUseBufferConformance ) - pMemory );

            pMemory += Ndr64pConvertTo2GB( (NDR64_UINT64)ElementMemorySize *
                                           Elements );                
            }
            break;

        //
        // String arrays (a.k.a. non-conformant strings).
        //
        case FC64_CHAR_STRING:
        case FC64_WCHAR_STRING:
        case FC64_STRUCT_STRING:
            {
            const NDR64_NON_CONFORMANT_STRING_FORMAT *pStringFormat =
                (const NDR64_NON_CONFORMANT_STRING_FORMAT*) pFormat;
            pMemory += pStringFormat->TotalSize;
            break;
            }
        //
        // Sized conformant strings.
        //
        case FC64_CONF_CHAR_STRING:
        case FC64_CONF_WCHAR_STRING:
        case FC64_CONF_STRUCT_STRING:
            {

            const NDR64_SIZED_CONFORMANT_STRING_FORMAT *pStringFormat =
                (const NDR64_SIZED_CONFORMANT_STRING_FORMAT *) pFormat;            
            NDR64_WIRE_COUNT_TYPE Elements;

            SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark );

            NDR_ASSERT( pStringFormat->Header.Flags.IsSized,, 
                       "Ndr64pMemoryIncrement : called for non-sized string");

            if ( fUseBufferConformance )
                {
                Elements = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
                pStubMsg->ConformanceMark += sizeof(NDR64_WIRE_COUNT_TYPE);
                }
            else
                {
                Elements =  Ndr64EvaluateExpr( pStubMsg, 
                                               pStringFormat->SizeDescription, 
                                               EXPR_MAXCOUNT );                
                }

            pMemory += Ndr64pConvertTo2GB( Elements * 
                                           (NDR64_UINT64)pStringFormat->Header.ElementSize );
            }
            break;

        case FC64_RP :
        case FC64_UP :
        case FC64_OP :
        case FC64_IP :
        case FC64_FP :
            pMemory += PTR_MEM_SIZE;
            break;

        case FC64_RANGE:
            pMemory += NDR64_SIMPLE_TYPE_MEMSIZE( ((NDR64_RANGE_FORMAT *)pFormat)->RangeType );
            break;
        //
        // Transmit as, represent as, user marshal
        //
        case FC64_TRANSMIT_AS :
        case FC64_REPRESENT_AS :
            pMemory += ( ( NDR64_TRANSMIT_AS_FORMAT * )pFormat )->PresentedTypeMemorySize;
            break;
            
        case FC64_USER_MARSHAL :
            // Get the presented type size.
            pMemory += ( ( NDR64_USER_MARSHAL_FORMAT * )pFormat )->UserTypeMemorySize;
            break;
            

        default :
            NDR_ASSERT(0,"Ndr64pMemoryIncrement : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    return pMemory;
}

BOOL
Ndr64pIsStructStringTerminator(
    NDR64_UINT8*    pMemory,
    NDR64_UINT32    ElementSize
    )
/*--

RoutineDescription :

    Determines is pMemory is a struct string terminator.

Arguments :

    pMemory     - Pointer to struct string character.
    ElementSize - Number of bytes of each string character.

Return :

    Length of string.

--*/
{
    while( ElementSize-- ) 
        {
        if ( *pMemory++ != 0)
            return FALSE;
        }
    return TRUE;
}

NDR64_UINT32
Ndr64pStructStringLen( 
    NDR64_UINT8*    pMemory,
    NDR64_UINT32    ElementSize
    )
/*--

RoutineDescription :

    Determines a stringable struct's length.

Arguments :

    pMemory     - Pointer to stringable struct.
    ElementSize - Number of bytes of each string element.

Return :

    Length of string.

--*/
{
    NDR64_UINT32 StringSize = 0;
    
    while( !Ndr64pIsStructStringTerminator( pMemory, ElementSize ) )
        {
        StringSize++;
        pMemory += ElementSize;
        }
    return StringSize;
}
 
NDR64_UINT32 
Ndr64pCommonStringSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    uchar *                             pMemory,
    const NDR64_STRING_HEADER_FORMAT    *pStringFormat
    )
{
    NDR64_UINT64    CopySize64;

    // Compute the element count of the string and the total copy size.
    switch ( pStringFormat->FormatCode )
        {
        case FC64_CHAR_STRING:
        case FC64_CONF_CHAR_STRING:
            CopySize64 = pStubMsg->ActualCount = strlen((char *)pMemory) + 1;
            break;

        case FC64_WCHAR_STRING:
        case FC64_CONF_WCHAR_STRING:
            pStubMsg->ActualCount = wcslen((wchar_t *)pMemory) + 1;
            CopySize64  = (NDR64_UINT64)pStubMsg->ActualCount * (NDR64_UINT64)sizeof(wchar_t);
            break;

        case FC64_STRUCT_STRING:
        case FC64_CONF_STRUCT_STRING:
            pStubMsg->ActualCount = Ndr64pStructStringLen( (NDR64_UINT8*)pMemory, 
                                                           pStringFormat->ElementSize ) + 1;
            CopySize64  = (NDR64_UINT64)pStubMsg->ActualCount * 
                          (NDR64_UINT64)pStringFormat->ElementSize;
            break;

        default :
            NDR_ASSERT(0,"Ndr64pConformantStringMarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    pStubMsg->Offset = 0;
    return Ndr64pConvertTo2GB( CopySize64 );
}

PNDR64_FORMAT
Ndr64pFindUnionArm(
    PMIDL_STUB_MESSAGE pStubMsg,
    const NDR64_UNION_ARM_SELECTOR* pArmSelector,
    EXPR_VALUE Value
    )
{
    const NDR64_UNION_ARM *pUnionArm  = (NDR64_UNION_ARM*)(pArmSelector + 1);
    NDR64_UINT32 Arms                 = pArmSelector->Arms;

    while(1) 
        {

        if (0 == Arms--)
            {

            PNDR64_FORMAT DefaultType = *(PNDR64_FORMAT*)pUnionArm;

            if (DefaultType != (PNDR64_FORMAT)-1)
                {
                return DefaultType ? *(PNDR64_FORMAT*)pUnionArm :
                                     NULL;
                }
            else
                {
                RpcRaiseException( RPC_S_INVALID_TAG );
                return 0;
                }
            }

        if ( (EXPR_VALUE)pUnionArm->CaseValue == Value )
            {
            return pUnionArm->Type ? pUnionArm->Type : NULL;
            }

        pUnionArm++;
        }
}


EXPR_VALUE
Ndr64pSimpleTypeToExprValue(
    NDR64_FORMAT_CHAR FormatChar,
    uchar *pSimple)
{
    switch( FormatChar )
        {
        case FC64_UINT8:
            return (EXPR_VALUE)*(unsigned char *)pSimple;
        
        case FC64_CHAR:
        case FC64_INT8:
            return (EXPR_VALUE)*(signed char *)pSimple;
        
        case FC64_WCHAR:
        case FC64_UINT16:
            return (EXPR_VALUE)*(unsigned short *)pSimple;
        
        case FC64_INT16:
            return (EXPR_VALUE)*(signed short *)pSimple;
        
        case FC64_UINT32:
            return (EXPR_VALUE)*(unsigned long *)pSimple;
        
        case FC64_INT32:
        case FC64_ERROR_STATUS_T:
            return (EXPR_VALUE)*(signed long *)pSimple;

        case FC64_INT64:
            return (EXPR_VALUE)*(NDR64_INT64 *)pSimple;

        case FC64_UINT64:
            return (EXPR_VALUE)*(NDR64_UINT64 *)pSimple;

        case FC64_POINTER:
            return (EXPR_VALUE)*(void **)pSimple;
     default :
         NDR_ASSERT(0,"Ndr64pSimpleTypeToExprValue : bad swith type");
         RpcRaiseException( RPC_S_INTERNAL_ERROR );
         return 0;
     }
}

EXPR_VALUE
Ndr64pCastExprValueToExprValue(
    NDR64_FORMAT_CHAR FormatChar,
    EXPR_VALUE Value)
{
    switch ( FormatChar )
        {
        
        case FC64_UINT8:
            return (EXPR_VALUE)(unsigned char)Value;
        
        case FC64_INT8:
        case FC64_CHAR:
            return (EXPR_VALUE)(signed char)Value;
        
        case FC64_UINT16:
        case FC64_WCHAR:
            return (EXPR_VALUE)(unsigned short)Value;
        
        case FC64_INT16:
            return (EXPR_VALUE)(signed short)Value;
        
        case FC64_UINT32:
            return (EXPR_VALUE)(unsigned long)Value;
        
        case FC64_INT32:
            return (EXPR_VALUE)(signed long)Value;

        case FC64_UINT64:
            return (EXPR_VALUE)(NDR64_UINT64)Value;

        case FC64_INT64:
            return (EXPR_VALUE)(NDR64_INT64)Value;
        
        case FC64_POINTER:
            return (EXPR_VALUE)(void *)Value;
        
        default:
            NDR_ASSERT(0,"Ndr64pCastExprValueToExprValue : Illegal type.");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\ndrp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993-2000 Microsoft Corporation

Module Name :

    ndrp.h

Abtract :

    Contains private definitions for Ndr64 files in this directory.  This
    file is included by all source files in this directory.

Author :

    David Kays  dkays   October 1993

Revision History :

--------------------------------------------------------------------*/

#ifndef _NDRP_
#define _NDRP_

#include <sysinc.h>

#include "rpc.h"
#include "rpcndr.h"

// Get new token definitions for 64b.
#define RPC_NDR_64
#include "ndrtypes.h"
#include "ndr64types.h"

#include "..\ndr20\ndrpall.h"

// Jump table defines

//
// Marshal jump tables
//
typedef void (* PNDR64_MARSHALL_ROUTINE)( 
					PMIDL_STUB_MESSAGE, 
					uchar *, 
					PNDR64_FORMAT
				);

extern PNDR64_MARSHALL_ROUTINE const Ndr64MarshallRoutinesTable[];
extern PNDR64_MARSHALL_ROUTINE const Ndr64EmbeddedMarshallRoutinesTable[];

inline void
Ndr64TopLevelTypeMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    (*Ndr64MarshallRoutinesTable[*(PFORMAT_STRING)pFormat] )
                                ( pStubMsg,
                                  pMemory,
                                  pFormat );
}

inline void
Ndr64EmbeddedTypeMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT     pFormat )
{
    (*Ndr64EmbeddedMarshallRoutinesTable[*(PFORMAT_STRING)pFormat] )
                                        ( pStubMsg,
                                          pMemory,
                                          pFormat );
}

//
// Buffer size jump tables
//

typedef  void   (* PNDR64_SIZE_ROUTINE)(
                        PMIDL_STUB_MESSAGE	pStubMsg,
						uchar *				pMemory,
                        PNDR64_FORMAT		pFormat
                    );

extern PNDR64_SIZE_ROUTINE const  Ndr64SizeRoutinesTable[];
extern PNDR64_SIZE_ROUTINE const  Ndr64EmbeddedSizeRoutinesTable[];


inline void
Ndr64TopLevelTypeSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    (*Ndr64SizeRoutinesTable[*(PFORMAT_STRING)pFormat])( pStubMsg,
                                         pMemory,
                                         pFormat );
}

inline void
Ndr64EmbeddedTypeSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    (*Ndr64EmbeddedSizeRoutinesTable[*(PFORMAT_STRING)pFormat])( pStubMsg,
                                                 pMemory,
                                                 pFormat );
}

void 
Ndr64ComplexStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat );

void 
Ndr64ComplexArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat );

//
// Memsize jump tables
//

typedef     void	(* PNDR64_MEM_SIZE_ROUTINE)(
                        PMIDL_STUB_MESSAGE	pStubMsg,
                        PNDR64_FORMAT 		pFormat
                    );

extern PNDR64_MEM_SIZE_ROUTINE   const Ndr64MemSizeRoutinesTable[];
extern PNDR64_MEM_SIZE_ROUTINE   const Ndr64EmbeddedMemSizeRoutinesTable[];

inline void
Ndr64TopLevelTypeMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PNDR64_FORMAT      pFormat )
{
    (*Ndr64MemSizeRoutinesTable[*(PFORMAT_STRING)pFormat] )
                                ( pStubMsg,
                                  pFormat );
}

inline void
Ndr64EmbeddedTypeMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PNDR64_FORMAT      pFormat )
{
    (*Ndr64EmbeddedMemSizeRoutinesTable[*(PFORMAT_STRING)pFormat] )
                                        ( pStubMsg,
                                          pFormat );
}

void 
Ndr64ComplexStructMemorySize(
    PMIDL_STUB_MESSAGE    pStubMsg,
    PNDR64_FORMAT         pFormat );

void 
Ndr64ComplexArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat );
//
// Unmarshal
//

typedef void (* PNDR64_UNMARSHALL_ROUTINE)( 
                    PMIDL_STUB_MESSAGE, 
					uchar **, 
					PNDR64_FORMAT,
					bool 
				);

extern PNDR64_UNMARSHALL_ROUTINE const Ndr64UnmarshallRoutinesTable[];
extern PNDR64_UNMARSHALL_ROUTINE const Ndr64EmbeddedUnmarshallRoutinesTable[];

inline void
Ndr64EmbeddedTypeUnmarshall( 
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar **           ppMemory,
    PNDR64_FORMAT      pFormat )
{
    (*Ndr64EmbeddedUnmarshallRoutinesTable[*(PFORMAT_STRING)pFormat])
        (pStubMsg,
         ppMemory,
         pFormat,
         false );
}

inline void 
Ndr64TopLevelTypeUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar **           ppMemory,
    PNDR64_FORMAT      pFormat,
    bool               fMustAlloc )
{

    (*Ndr64UnmarshallRoutinesTable[*(PFORMAT_STRING)pFormat])
        (pStubMsg,
         ppMemory,
         pFormat,
         fMustAlloc );


}

//
// Free routines
//

typedef     void    (* PNDR64_FREE_ROUTINE)( 
						PMIDL_STUB_MESSAGE, 
					 	uchar *, 
						PNDR64_FORMAT
					);

extern PNDR64_FREE_ROUTINE const Ndr64FreeRoutinesTable[];
extern PNDR64_FREE_ROUTINE const Ndr64EmbeddedFreeRoutinesTable[];  

inline void 
Ndr64EmbeddedTypeFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    (*Ndr64EmbeddedFreeRoutinesTable[*(PFORMAT_STRING)pFormat])
            ( pStubMsg,
              pMemory,
              pFormat );
}

inline void 
Ndr64ToplevelTypeFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{

    (*Ndr64FreeRoutinesTable[*(PFORMAT_STRING)pFormat])
            ( pStubMsg,
              pMemory,
              pFormat );

}

#include "..\..\ndr20\fullptr.h"
#include "pipendr.h"

#include "mulsyntx.h"
#include "pointer.h"

#include "expr.h"

uchar *
Ndr64pMemoryIncrement(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    BOOL                fUseBufferConformance
    );

inline
NDR64_UINT32
Ndr64pMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PNDR64_FORMAT      pFormat,
    BOOL fUseBufferConformance )
{
    return
        PtrToUlong(Ndr64pMemoryIncrement( pStubMsg,
                                          NULL,
                                          pFormat,
                                          fUseBufferConformance ) );
}

BOOL
Ndr64pIsStructStringTerminator(
    NDR64_UINT8*    pMemory,
    NDR64_UINT32    ElementSize
    );

NDR64_UINT32
Ndr64pStructStringLen(       
    NDR64_UINT8*    pMemory,
    NDR64_UINT32    ElementSize
    );

NDR64_UINT32 
Ndr64pCommonStringSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    uchar *                             pMemory,
    const NDR64_STRING_HEADER_FORMAT    *pStringFormat
    );

inline NDR64_UINT32
Ndr64pConvertTo2GB(
    NDR64_UINT64        Data64
    )
{
    if ( Data64 > 0x7FFFFFFF )
        {
        RpcRaiseException( RPC_X_INVALID_BOUND );
        return 0;
        }
    return (NDR64_UINT32) Data64;
}

void
Ndr64pInitUserMarshalCB(
    MIDL_STUB_MESSAGE *pStubMsg,
    NDR64_USER_MARSHAL_FORMAT *     pUserFormat,
    USER_MARSHAL_CB_TYPE CBType,
    USER_MARSHAL_CB   *pUserMarshalCB
    );

CLIENT_CALL_RETURN RPC_ENTRY
NdrpClientCall3(
    void *                      pThis,
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    unsigned long               nProcNum,
    void                       *pReturnValue,
    NDR_PROC_CONTEXT        *   pContext,
    unsigned char *             StartofStack
    );

PNDR64_FORMAT
Ndr64pFindUnionArm(
    PMIDL_STUB_MESSAGE pStubMsg,
    const NDR64_UNION_ARM_SELECTOR* pArmSelector,
    EXPR_VALUE Value
    );

EXPR_VALUE
Ndr64pSimpleTypeToExprValue(
    NDR64_FORMAT_CHAR FormatChar,
    uchar *pSimple);

EXPR_VALUE
Ndr64pCastExprValueToExprValue(
    NDR64_FORMAT_CHAR FormatChar,
    EXPR_VALUE Value);

// Context Handle Functions

NDR_SCONTEXT
RPC_ENTRY
Ndr64ContextHandleInitialize(
    IN  PMIDL_STUB_MESSAGE  pStubMsg,
    IN  PFORMAT_STRING      pFormat
    );

void
RPC_ENTRY
Ndr64ServerContextNewMarshall(
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_SCONTEXT          ContextHandle,
    NDR_RUNDOWN           RundownRoutine,
    PFORMAT_STRING        pFormat
    );

NDR_SCONTEXT
RPC_ENTRY
Ndr64ServerContextNewUnmarshall(
    IN  PMIDL_STUB_MESSAGE  pStubMsg,
    IN  PFORMAT_STRING      pFormat
    );

void
Ndr64pCleanupServerContextHandles(
    MIDL_STUB_MESSAGE * pStubMsg,
    long                NumberParams,
    NDR64_PARAM_FORMAT* Params,
    uchar *             pArgBuffer,
    BOOL                fManagerRoutineException 
    );


// Free

void
RPC_ENTRY
Ndr64PointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PNDR64_FORMAT                       pFormat
    );

// Mrshl
void
RPC_ENTRY
Ndr64SimpleTypeMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    unsigned char                       FormatChar
    );

// Unmarshall

void
RPC_ENTRY
Ndr64SimpleTypeUnmarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    unsigned char                       FormatChar
    );

// Initialization                           

void
Ndr64ClientInitialize(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUBLESS_PROXY_INFO           pProxyInfo,
    unsigned int                        ProcNum
    );

unsigned char *
Ndr64ServerInitialize(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor
    );

void
Ndr64ServerInitializePartial(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned long                       RequestedBufferSize
    );

// Get Buffer variations

unsigned char *
Ndr64GetBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength );

unsigned char *
Ndr64NsGetBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength );

unsigned char *
Ndr64GetPipeBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength );

void
Ndr64ClearOutParameters(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PNDR64_FORMAT           pFormat,
    uchar *                 ArgAddr
    );


// These end of buffer checks can be performed on a receiving side only.
// The necessary setup is there for memorysize, unmarshal and convert walks.
// This also includes pickling walk.
// Don't use this on the sending side.

// Checks if the pointer is past the end of the buffer.  Do not check for wraparound.

#define CHECK_EOB_RAISE_BSD( p )                                      \
    {                                                                 \
       if( (char *)(p) > (char*)pStubMsg->BufferEnd )                 \
           {                                                          \
           RpcRaiseException( RPC_X_BAD_STUB_DATA );                  \
           }                                                          \
    }

#define CHECK_EOB_RAISE_IB( p )                                       \
    {                                                                 \
        if( (char *)(p) > (char*)pStubMsg->BufferEnd )                \
            {                                                         \
            RpcRaiseException( RPC_X_INVALID_BOUND );                 \
            }                                                         \
    }

// Checks if p + incsize is past the end of the bufffer.
// 

#define CHECK_EOB_WITH_WRAP_RAISE_BSD( p, incsize )                          \
    {                                                                        \
        char *NewBuffer = ((char *)(p)) + (SIZE_T)(incsize);                 \
        if( (NewBuffer > (char*)(pStubMsg->BufferEnd)) || (NewBuffer < (char*)(p)) )  \
             {                                                               \
             RpcRaiseException( RPC_X_BAD_STUB_DATA );                       \
             }                                                               \
    }

#define CHECK_EOB_WITH_WRAP_RAISE_IB( p, incsize )                           \
    {                                                                        \
        char *NewBuffer = ((char *)(p)) + (SIZE_T)(incsize);                 \
        if(  (NewBuffer > (char*)(pStubMsg->BufferEnd)) || (NewBuffer < (char*)(p)) ) \
             {                                                               \
             RpcRaiseException( RPC_X_INVALID_BOUND );                       \
             }                                                               \
    }

// This would be appropriate on the sending side for marshaling.

#define CHECK_SEND_EOB_RAISE_BSD( p )  \
        if ( (char*)(pStubMsg->RpcMsg->Buffer + pStubMsg->RpcMsg->BufferLength) < (char*)( p ) ) \
            RpcRaiseException( RPC_X_BAD_STUB_DATA )


//
// Defined in global.c
//
extern const unsigned char Ndr64SimpleTypeBufferSize[];
extern const unsigned char Ndr64SimpleTypeMemorySize[];
extern const unsigned long Ndr64TypeFlags[];

// This definition is adjusted for a native platform.
// The wire size is fixed for DCE NDR regardless of platform.

#define PTR_MEM_SIZE                    sizeof(void *)
#define PTR_MEM_ALIGN                   (sizeof(void *)-1)

#define PTR_WIRE_REP(p)  ((NDR64_PTR_WIRE_TYPE)(p))

#define CONTEXT_HANDLE_WIRE_SIZE        20

#define IGNORED(Param)

//
// Proc info flags macros.
//
#define IS_OLE_INTERFACE(Flags)         ((Flags) & Oi_OBJECT_PROC)

#define HAS_RPCFLAGS(Flags)             ((Flags) & Oi_HAS_RPCFLAGS)

#define DONT_HANDLE_EXCEPTION(Flags)    \
                    ((Flags) & Oi_IGNORE_OBJECT_EXCEPTION_HANDLING)


//
// Routine index macro.
//
#define NDR64_ROUTINE_INDEX(FC)       ( (FC) )

//
// Simple type alignment and size lookup macros.
//
#define NDR64_SIMPLE_TYPE_BUFALIGN(FormatChar)    (Ndr64SimpleTypeBufferSize[FormatChar]-1)

#define NDR64_SIMPLE_TYPE_MEMALIGN(FormatChar)    (Ndr64SimpleTypeMemorySize[FormatChar]-1)

#define NDR64_SIMPLE_TYPE_BUFSIZE(FormatChar)     (Ndr64SimpleTypeBufferSize[FormatChar])

#define NDR64_SIMPLE_TYPE_MEMSIZE(FormatChar)     (Ndr64SimpleTypeMemorySize[FormatChar])

#if defined(__RPC_WIN32__)
#define NDR64_USER_MARSHAL_MARKER (0x72657355);
#else
#define NDR64_USER_MARSHAL_MARKER (0x7265735572657355);
#endif

#if defined(__RPC_WIN32__)
#define NDR64_CONTEXT_HANDLE_MARSHAL_MARKER (0xbaadbeef);
#else
#define NDR64_CONTEXT_HANDLE_MARSHAL_MARKER (0xbaadbeefbaadbeef);
#endif

//
// Format character attribute bits used in global Ndr64TypesFlags defined in
// global.c.
//
#define     _SIMPLE_TYPE_       0x0001L
#define     _POINTER_           0x0002L
#define     _STRUCT_            0x0004L
#define     _ARRAY_             0x0008L
#define     _STRING_            0x0010L
#define     _UNION_             0x0020L
#define     _XMIT_AS_           0x0040L

#define     _BY_VALUE_          0x0080L

#define     _HANDLE_            0x0100L

#define     _BASIC_POINTER_     0x0200L

//
// Format character query macros.
//
#define NDR64_IS_SIMPLE_TYPE(FC)     (Ndr64TypeFlags[(FC)] & _SIMPLE_TYPE_)

#define NDR64_IS_POINTER_TYPE(FC)    (Ndr64TypeFlags[(FC)] & _POINTER_)

#define NDR64_IS_BASIC_POINTER(FC)   (Ndr64TypeFlags[(FC)] & _BASIC_POINTER_)

#define NDR64_IS_ARRAY(FC)           (Ndr64TypeFlags[(FC)] & _ARRAY_)

#define NDR64_IS_STRUCT(FC)          (Ndr64TypeFlags[(FC)] & _STRUCT_)

#define NDR64_IS_UNION(FC)           (Ndr64TypeFlags[(FC)] & _UNION_)

#define NDR64_IS_STRING(FC)          (Ndr64TypeFlags[(FC)] & _STRING_)

#define NDR64_IS_ARRAY_OR_STRING(FC) (Ndr64TypeFlags[(FC)] & (_STRING_ | _ARRAY_))

#define NDR64_IS_XMIT_AS(FC)         (Ndr64TypeFlags[(FC)] & _XMIT_AS_)

#define NDR64_IS_BY_VALUE(FC)        (Ndr64TypeFlags[(FC)] & _BY_VALUE_)

#define NDR64_IS_HANDLE(FC)          (Ndr64TypeFlags[(FC)] & _HANDLE_)

//
// Pointer attribute extraction and querying macros.
//
#define NDR64_ALLOCATE_ALL_NODES( FC )    ((FC) & FC_ALLOCATE_ALL_NODES)

#define NDR64_DONT_FREE( FC )             ((FC) & FC_DONT_FREE)

#define NDR64_ALLOCED_ON_STACK( FC )      ((FC) & FC_ALLOCED_ON_STACK)

#define NDR64_SIMPLE_POINTER( FC )        ((FC) & FC_SIMPLE_POINTER)

#define NDR64_POINTER_DEREF( FC )         ((FC) & FC_POINTER_DEREF)

//
// Handle query macros.
//
#define NDR64_IS_HANDLE_PTR( FC )         ((FC) & HANDLE_PARAM_IS_VIA_PTR)

#define NDR64_IS_HANDLE_IN( FC )          ((FC) & HANDLE_PARAM_IS_IN)

#define NDR64_IS_HANDLE_OUT( FC )         ((FC) & HANDLE_PARAM_IS_OUT)

#define NDR64_IS_HANDLE_RETURN( FC )      ((FC) & HANDLE_PARAM_IS_RETURN)


#define NDR64_NEW_EMBEDDED_ALLOCATION_FLAG     ( ( unsigned char ) 0x01 )
#define NDR64_CONF_MARK_VALID_FLAG             ( ( unsigned char ) 0x02 )
#define NDR64_VAR_MARK_VALID_FLAG              ( ( unsigned char ) 0x04 )
#define NDR64_WALKIP_FLAG                      ( ( unsigned char ) 0x08 )
#define NDR64_SKIP_REF_CHECK_FLAG              ( ( unsigned char ) 0x40 )

#define NDR64_IS_CONF_MARK_VALID( f )                 ( ( f ) &  NDR64_CONF_MARK_VALID_FLAG )
#define NDR64_SET_CONF_MARK_VALID( f )                ( ( f ) |= NDR64_CONF_MARK_VALID_FLAG )
#define NDR64_RESET_CONF_MARK_VALID( f )              ( ( f ) &= ~NDR64_CONF_MARK_VALID_FLAG )

#define NDR64_IS_VAR_MARK_VALID( f )                  ( ( f ) &  NDR64_VAR_MARK_VALID_FLAG )
#define NDR64_SET_VAR_MARK_VALID( f )                 ( ( f ) |= NDR64_VAR_MARK_VALID_FLAG )
#define NDR64_RESET_VAR_MARK_VALID( f )               ( ( f ) &= ~NDR64_VAR_MARK_VALID_FLAG )

#define NDR64_IS_NEW_EMBEDDED_ALLOCATION( f )         ( ( f ) & NDR64_NEW_EMBEDDED_ALLOCATION_FLAG )
#define NDR64_SET_NEW_EMBEDDED_ALLOCATION( f )        ( ( f ) |= NDR64_NEW_EMBEDDED_ALLOCATION_FLAG )
#define NDR64_RESET_IS_NEW_EMBEDDED_ALLOCATION( f )   ( ( f ) &= ~NDR64_NEW_EMBEDDED_ALLOCATION_FLAG )

#define NDR64_IS_WALKIP( f )        ( ( f ) & NDR64_WALKIP_FLAG )
#define NDR64_SET_WALKIP( f )       ( ( f ) |= NDR64_WALKIP_FLAG ) 
#define NDR64_RESET_WALKIP( f )     ( ( f ) &= ~NDR64_WALKIP_FLAG )

#define NDR64_IS_SKIP_REF_CHECK( f ) ( ( f ) & NDR64_SKIP_REF_CHECK_FLAG )
#define NDR64_SET_SKIP_REF_CHECK( f ) ( ( f ) |= NDR64_SKIP_REF_CHECK_FLAG )
#define NDR64_RESET_SKIP_REF_CHECK( f ) ( ( f ) &= ~NDR64_SKIP_REF_CHECK_FLAG )



#define NDR64_RESET_EMBEDDED_FLAGS_TO_STANDALONE( f )      \
    ( ( f ) &= ~ ( NDR64_NEW_EMBEDDED_ALLOCATION_FLAG |    \
                   NDR64_CONF_MARK_VALID_FLAG |            \
                   NDR64_VAR_MARK_VALID_FLAG  ) )  


#define EXCEPTION_FLAG   ( pContext->ExceptionFlag )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\pickle64.cxx ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    pickle64.cxx

Abstract:

    This module contains ndr64 related pickling ndr library routines.

Notes:

Author:

    Yong Qu     Nov, 1993

Revision History:


------------------------------------------------------------------------*/
#include "precomp.hxx"

#include <midles.h>
#include "endianp.h"

#include "picklep.hxx"

extern "C"
{
void  RPC_ENTRY
NdrpPicklingClientFinally( PMIDL_STUB_MESSAGE pStubMsg,
                   void *  pThis );

void  RPC_ENTRY
Ndr64pPicklingClientFinally( PMIDL_STUB_MESSAGE pStubMsg,
                   void *  pThis );
}

const SYNTAX_DISPATCH_TABLE SyncDcePicklingClient =
{
    NdrpClientInit,
    NdrpSizing,
    NdrpClientMarshal,
    NdrpClientUnMarshal,
    NdrpClientExceptionHandling,
    NdrpPicklingClientFinally
};

const SYNTAX_DISPATCH_TABLE SyncNdr64PicklingClient =
{
    Ndr64pClientInit,
    Ndr64pSizing,
    Ndr64pClientMarshal,
    Ndr64pClientUnMarshal,
    Ndr64pClientExceptionHandling,
    Ndr64pPicklingClientFinally
};


extern const MIDL_FORMAT_STRING __MIDLFormatString;

__inline 
void Ndr64pMesTypeInit( PMIDL_STUB_MESSAGE   pStubMsg,
                        NDR_PROC_CONTEXT   * pContext,
                        PMIDL_STUB_DESC      pStubDesc )
{                        

    // we need this for correlation cache.
    NdrpInitializeProcContext( pContext );
    pStubMsg->pContext = pContext;

    pStubMsg->fHasExtensions  = 1;
    pStubMsg->StubDesc = pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;
    pStubMsg->pCorrInfo = NULL;
}

#define NdrpSetupMesTypeCommon( pfnName, pfnDCE, pfnNDR64 ) \
                                                            \
    if ( pMesMsg->Operation == MES_ENCODE || pMesMsg->Operation == MES_DECODE )   \
        {                                                   \
        SyntaxType = XFER_SYNTAX_DCE;                       \
        pfnName = &pfnDCE;                                  \
        }                                                   \
    else                                                    \
        {                                                   \
        SyntaxType = XFER_SYNTAX_NDR64;                     \
        pfnName = &pfnNDR64;                                \
        }                                                   \
                                                            \
    for ( long i = 0; i < (long) pProxyInfo->nCount; i ++ ) \
        if ( NdrpGetSyntaxType( &pProxyInfo->pSyntaxInfo[i].TransferSyntax ) == SyntaxType )  \
            {                                               \
            pSyntaxInfo = &pProxyInfo->pSyntaxInfo[i];      \
            break;                                          \
            }                                               \
                                                            \
    if (NULL == pSyntaxInfo )                               \
        RpcRaiseException( RPC_S_UNSUPPORTED_TRANS_SYN );   \
                                                            \
    if ( XFER_SYNTAX_DCE == SyntaxType )                    \
        {                                                   \
        ulong nFormatOffset = ArrTypeOffset[i][nTypeIndex]; \
        pTypeFormat = &pSyntaxInfo->TypeString[nFormatOffset];  \
        }                                                   \
    else                                                    \
        {                                                   \
        if ( SyntaxType == XFER_SYNTAX_NDR64 )              \
            Ndr64pMesTypeInit( &pMesMsg->StubMsg, &ProcContext, pProxyInfo->pStubDesc );    \
                                                            \
        pTypeFormat = (PFORMAT_STRING)(((const FormatInfoRef **) ArrTypeOffset)[i][nTypeIndex]);   \
        }                                                   \
                                                            \
    ProcContext.pSyntaxInfo = pSyntaxInfo;              


void
Ndr64pValidateMesHandle(
    PMIDL_ES_MESSAGE_EX  pMesMsgEx )
{
    RpcTryExcept
        {
        if ( pMesMsgEx == 0  ||  
             pMesMsgEx->Signature != MIDL_ES_SIGNATURE  ||
             ( pMesMsgEx->MesMsg.MesVersion != MIDL_NDR64_ES_VERSION &&
               pMesMsgEx->MesMsg.MesVersion != MIDL_ES_VERSION ) )
            RpcRaiseException( RPC_S_INVALID_ARG );
        }
    RpcExcept( 1 )
        {
        RpcRaiseException( RPC_S_INVALID_ARG );
        }
    RpcEndExcept
}

RPC_STATUS
Ndr64pValidateMesHandleReturnStatus(
    PMIDL_ES_MESSAGE_EX  pMesMsgEx )
{
    RPC_STATUS  Status = RPC_S_OK;

    RpcTryExcept
        {
        if ( pMesMsgEx == 0  ||  pMesMsgEx->Signature != MIDL_NDR64_ES_SIGNATURE  ||
             pMesMsgEx->MesMsg.MesVersion != MIDL_NDR64_ES_VERSION )
            Status = RPC_S_INVALID_ARG;
        }
    RpcExcept( 1 )
        {
        Status = RPC_S_INVALID_ARG;
        }
    RpcEndExcept

    return Status;
}


void
Ndr64pCommonTypeHeaderSize(
    PMIDL_ES_MESSAGE    pMesMsg
    )
{
    // This check is to prevent a decoding handle from being used
    // for both encoding and sizing of types.

    if ( pMesMsg->Operation != MES_ENCODE_NDR64 )
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    if ( ! GET_COMMON_TYPE_HEADER_SIZED( pMesMsg ) )
        {
        pMesMsg->StubMsg.BufferLength += MES_NDR64_CTYPE_HEADER_SIZE;

        SET_COMMON_TYPE_HEADER_SIZED( pMesMsg );
        }
}


size_t RPC_ENTRY
Ndr64MesTypeAlignSize( 
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,
    const MIDL_STUB_DESC          * pStubDesc,
    PFORMAT_STRING                  pFormat,
    const void __RPC_FAR *          pObject
    )
{
    PMIDL_ES_MESSAGE            pMesMsg = ( PMIDL_ES_MESSAGE )Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    size_t                      OldLength = pStubMsg->BufferLength;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;
    
    Ndr64pValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    if ( ! pObject )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    if( (long)pStubMsg->BufferLength & 0xf )
        RpcRaiseException( RPC_X_INVALID_BUFFER );

    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;

    NDR_ASSERT( pPicklingInfo->Flags.Oicf, "Oicf should always be on" );


    // See if we need to size the common type header.

    Ndr64pCommonTypeHeaderSize( (PMIDL_ES_MESSAGE)Handle );

    // Now the individual type object.

    pStubMsg->BufferLength += MES_NDR64_HEADER_SIZE;

    if ( NDR64_IS_POINTER_TYPE(*pFormat) )
        {
        // We have to dereference the pointer once.
        pObject = *(void __RPC_FAR * __RPC_FAR *)pObject;
        }

    (Ndr64SizeRoutinesTable[ NDR64_ROUTINE_INDEX(*pFormat) ])
                                        ( pStubMsg,
                                        (uchar __RPC_FAR *)pObject,
                                        pFormat );

   LENGTH_ALIGN( pStubMsg->BufferLength, 0xf );

   Ndr64pPicklingClientFinally( pStubMsg, NULL );   // object
   return( pStubMsg->BufferLength - OldLength );

    
}


// ndr64 entries.

size_t  RPC_ENTRY
NdrMesTypeAlignSize3(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pPicklingInfo,
    const MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
    const unsigned long **          ArrTypeOffset,
    unsigned long                   nTypeIndex,
    const void __RPC_FAR *          pObject )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PFORMAT_STRING              pTypeFormat;
    MIDL_SYNTAX_INFO    *       pSyntaxInfo = NULL;
    PFNMESTYPEALIGNSIZE         pfnSize;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    SYNTAX_TYPE                 SyntaxType;
    NDR_PROC_CONTEXT            ProcContext;
    if ( (( PMIDL_ES_MESSAGE)Handle )->Operation != MES_ENCODE &&
         (( PMIDL_ES_MESSAGE)Handle )->Operation != MES_ENCODE_NDR64 )
         RpcRaiseException( RPC_X_INVALID_ES_ACTION );
    
    NdrpSetupMesTypeCommon( pfnSize, NdrMesTypeAlignSize2, Ndr64MesTypeAlignSize );

    return 
    ( *pfnSize )( Handle, pPicklingInfo, pProxyInfo->pStubDesc, pTypeFormat, pObject );
}


// common type header for type pickling is longer than before:
//  if version is 1, the header size is 8,
//  if version is higher than 1, the header size is 24+2*sizeof(RPC_SYNTAX_IDENTIFIER)
//  starting 8 bytes is still the same as old one: 
//  <version:1><endian:1><header_size:2><endian info: 4>
//  addtional header: 
//  <reserved: 16> <transfer_syntax><iid>
//
size_t
Ndr64pCommonTypeHeaderMarshall(
    PMIDL_ES_MESSAGE    pMesMsg
    )
/*++
    Returns the space used by the common header.
--*/
{
    if ( ! GET_COMMON_TYPE_HEADER_IN( pMesMsg ) )
        {
        PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

        if ( (ULONG_PTR)pStubMsg->Buffer & 15 )
            RpcRaiseException( RPC_X_INVALID_BUFFER );
            
        MIDL_memset( pStubMsg->Buffer, 0xcc, MES_NDR64_CTYPE_HEADER_SIZE );

        *pStubMsg->Buffer++ = MIDL_NDR64_ES_VERSION;
        *pStubMsg->Buffer++ = NDR_LOCAL_ENDIAN;
        * PSHORT_CAST pStubMsg->Buffer = MES_NDR64_CTYPE_HEADER_SIZE;

        pStubMsg->Buffer += MES_CTYPE_HEADER_SIZE + 16 -2 ; // skip over reserved, make header size 64bytes

        RpcpMemoryCopy( pStubMsg->Buffer,
                    & NDR64_TRANSFER_SYNTAX,
                    sizeof(RPC_SYNTAX_IDENTIFIER) );

        pStubMsg->Buffer += sizeof( RPC_SYNTAX_IDENTIFIER );
        RpcpMemoryCopy( pStubMsg->Buffer ,
                    & pMesMsg->InterfaceId,
                    sizeof(RPC_SYNTAX_IDENTIFIER) + sizeof(long) );
        pStubMsg->Buffer += sizeof( RPC_SYNTAX_IDENTIFIER );


        SET_COMMON_TYPE_HEADER_IN( pMesMsg );
        return( MES_NDR64_CTYPE_HEADER_SIZE );
        }

    return( 0 );
}


void RPC_ENTRY
Ndr64MesTypeEncode( 
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,
    const MIDL_STUB_DESC          * pStubDesc,
    PFORMAT_STRING                  pFormat,
    const void __RPC_FAR *          pObject
    )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;
    uchar __RPC_FAR *           pBufferSaved, *pTypeHeader;
    size_t                      RequiredLen, CommonHeaderSize, LengthSaved;
    

    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;
    NDR_ASSERT( pPicklingInfo->Flags.Oicf, "Oicf should always be on" )

    Ndr64pValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    if ( ! pObject )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    if( (LONG_PTR)pStubMsg->Buffer & 0xf )
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        

    pStubMsg->BufferLength = 0xf & PtrToUlong( pStubMsg->Buffer );

    RequiredLen = Ndr64MesTypeAlignSize( Handle,
                                       pxPicklingInfo, 
                                       pStubDesc,
                                       pFormat,
                                       pObject );

    NdrpAllocPicklingBuffer( pMesMsg, RequiredLen );

    pBufferSaved = pStubMsg->Buffer;
    LengthSaved  = RequiredLen;

    // See if we need to marshall the common type header

    CommonHeaderSize = Ndr64pCommonTypeHeaderMarshall( pMesMsg );

    // Marshall the header and the object.

    memset( pStubMsg->Buffer, 0, MES_NDR64_HEADER_SIZE );
    pStubMsg->Buffer += MES_NDR64_HEADER_SIZE;

    if ( NDR64_IS_POINTER_TYPE(*pFormat) )
        {
        // We have to dereference the pointer once.
        pObject = *(void __RPC_FAR * __RPC_FAR *)pObject;
        }

    RpcTryFinally
        {
        ALIGN( pStubMsg->Buffer, 0xf );
        (Ndr64MarshallRoutinesTable[ NDR64_ROUTINE_INDEX(*pFormat) ])
                                      ( pStubMsg,
                                      (uchar __RPC_FAR *)pObject,
                                      pFormat );

        // We adjust the buffer to the next align by 16 and
        // so, we tell the user that we've written out till next mod 16.


        // cleanup possible leaks before raising exception.
        }
    RpcFinally
        {
        Ndr64pPicklingClientFinally( pStubMsg, NULL );  //  object
        }
    RpcEndFinally

    ALIGN( pStubMsg->Buffer, 0xf );
    size_t WriteLength = (size_t)(pStubMsg->Buffer - pBufferSaved);

    // We always save the rounded up object length in the type header.

    *(unsigned long __RPC_FAR *)(pBufferSaved + CommonHeaderSize) =
                     WriteLength - CommonHeaderSize - MES_NDR64_HEADER_SIZE;

    if ( LengthSaved < WriteLength )
        {
        NDR_ASSERT( 0, "NdrMesTypeEncode: encode buffer overflow" );
        RpcRaiseException( RPC_S_INTERNAL_ERROR );
        }

    NdrpWritePicklingBuffer( pMesMsg, pBufferSaved, WriteLength );
    
    
}

void  RPC_ENTRY
NdrMesTypeEncode3(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pPicklingInfo,    
    const MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
    const unsigned long **          ArrTypeOffset,    
    unsigned long                   nTypeIndex,
    const void __RPC_FAR *          pObject )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PFORMAT_STRING              pTypeFormat;
    MIDL_SYNTAX_INFO    *       pSyntaxInfo = NULL;
    PFNMESTYPEENCODE            pfnEncode;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    SYNTAX_TYPE                 SyntaxType;
    NDR_PROC_CONTEXT            ProcContext;
    if ( (( PMIDL_ES_MESSAGE)Handle )->Operation != MES_ENCODE &&
         (( PMIDL_ES_MESSAGE)Handle )->Operation != MES_ENCODE_NDR64 )
         RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    NdrpSetupMesTypeCommon( pfnEncode, NdrMesTypeEncode2, Ndr64MesTypeEncode );

    ( *pfnEncode )( Handle, pPicklingInfo, pProxyInfo->pStubDesc, pTypeFormat, pObject );
}

// read the type header, and determine if the buffer is marshalled 
// using ndr or ndr64
// for future extension, we can allow other transfer syntaxes. 
void RPC_ENTRY
Ndr64pCommonTypeHeaderUnmarshall(
    PMIDL_ES_MESSAGE    pMesMsg
    )
{
    BOOL IsNewPickling = FALSE;

    if ( pMesMsg->Operation != MES_DECODE && 
         pMesMsg->Operation != MES_DECODE_NDR64 )
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    if ( ! GET_COMMON_TYPE_HEADER_IN( pMesMsg ) )
        {
        PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

        // read the common header first.
        NdrpReadPicklingBuffer( pMesMsg, MES_CTYPE_HEADER_SIZE );

        // Check the version number, endianness.

        if ( *pStubMsg->Buffer == MIDL_ES_VERSION )
            {
            IsNewPickling = FALSE;           
            pMesMsg->Operation = MES_DECODE;
            }
        else
            {
            IsNewPickling = TRUE;
            }

        if ( pStubMsg->Buffer[1] == NDR_LOCAL_ENDIAN )
            {
            // Read the note about endianess at NdrMesTypeDecode.
            //
            pMesMsg->AlienDataRep = NDR_LOCAL_DATA_REPRESENTATION;
            }
        else
            {
            NDR_ASSERT( pMesMsg->Operation != MES_DECODE_NDR64, 
                    "endian convertion is not supported in ndr64" );
            unsigned char temp = pStubMsg->Buffer[2];
            pStubMsg->Buffer[2] = pStubMsg->Buffer[3];
            pStubMsg->Buffer[3] = temp;

            pMesMsg->AlienDataRep = ( NDR_ASCII_CHAR       |     // chars
                                      pStubMsg->Buffer[1]  |     // endianness
                                      NDR_IEEE_FLOAT );          // float
            }

        pStubMsg->Buffer += MES_CTYPE_HEADER_SIZE;
        if ( IsNewPickling )
            {
            SYNTAX_TYPE SyntaxType;
            // read the remaining header.
            NdrpReadPicklingBuffer( pMesMsg, MES_NDR64_CTYPE_HEADER_SIZE - MES_CTYPE_HEADER_SIZE );
            pStubMsg->Buffer += 16;  // skip over Reserved;
            SyntaxType = NdrpGetSyntaxType( (RPC_SYNTAX_IDENTIFIER *)pStubMsg->Buffer );
            if ( SyntaxType == XFER_SYNTAX_DCE )
                {
                pMesMsg->Operation = MES_DECODE;
                }
            else if ( SyntaxType = XFER_SYNTAX_NDR64 )
                {
                pMesMsg->Operation = ( MIDL_ES_CODE )MES_DECODE_NDR64;
                }
            else 
                {
                RpcRaiseException( RPC_S_UNSUPPORTED_TRANS_SYN );
                } 

            // skip over iid: we don't need it for now. might be used for verification.
            pStubMsg->Buffer += 2*sizeof( RPC_SYNTAX_IDENTIFIER );            
            }

        SET_COMMON_TYPE_HEADER_IN( pMesMsg );
        }

}

void RPC_ENTRY
Ndr64MesTypeDecode( 
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,
    const MIDL_STUB_DESC          * pStubDesc,
    PFORMAT_STRING                  pFormat,
    void __RPC_FAR *                pObject
    )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;
    uchar __RPC_FAR *   pBufferSaved, pTypeHeader;
    size_t              RequiredLen, CommonHeaderSize, LengthSaved;
    

    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;
    NDR_ASSERT( pPicklingInfo->Flags.Oicf, "Oicf should always be on" )

    Ndr64pValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    if( (LONG_PTR)pStubMsg->Buffer & 0xf )
        RpcRaiseException( RPC_X_INVALID_BUFFER );

   
    pStubMsg->BufferLength = 0xf & PtrToUlong( pStubMsg->Buffer );

    NdrpReadPicklingBuffer( pMesMsg, MES_NDR64_HEADER_SIZE );

    RequiredLen = (size_t) *(unsigned long __RPC_FAR *)pStubMsg->Buffer;
    pStubMsg->Buffer += MES_NDR64_HEADER_SIZE;

    NdrpReadPicklingBuffer( pMesMsg, RequiredLen );

    void * pArg = pObject;

    if ( NDR64_IS_POINTER_TYPE(*pFormat) )
        {
        // We have to dereference the pointer once.
        //
        pArg = *(void **)pArg;
        }

   RpcTryFinally
        {
    
        (Ndr64UnmarshallRoutinesTable[ NDR64_ROUTINE_INDEX( *pFormat )])
                            ( pStubMsg,
                              (uchar __RPC_FAR * __RPC_FAR *)&pArg,
                              pFormat,
                              FALSE );

        if ( NDR64_IS_POINTER_TYPE(*pFormat) )
            {
            // Don't drop the pointee, if it was allocated.

            *(void **)pObject = pArg;
            }

    // Next decoding needs to start at aligned to 8.

        ALIGN( pStubMsg->Buffer, 15 );
        }
    RpcFinally
        {   
        Ndr64pPicklingClientFinally( pStubMsg, NULL );  // object
        }
   RpcEndFinally        
}

void  RPC_ENTRY
NdrMesTypeDecode3(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pPicklingInfo,    
    const MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
    const unsigned long **          ArrTypeOffset,    
    unsigned long                   nTypeIndex,
    void __RPC_FAR *                pObject )
{
    size_t              RequiredLen;

    PMIDL_ES_MESSAGE    pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;
    uchar *             BufferSaved;
    PFNMESDECODE        pfnDecode;
    MIDL_SYNTAX_INFO *  pSyntaxInfo;
    PFORMAT_STRING      pTypeFormat;
    SYNTAX_TYPE         SyntaxType;
    NDR_PROC_CONTEXT    ProcContext;

    if ( ! pObject )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    Ndr64pCommonTypeHeaderUnmarshall( pMesMsg );

    NdrpSetupMesTypeCommon( pfnDecode, NdrMesTypeDecode2, Ndr64MesTypeDecode );

    (* pfnDecode )( Handle, pPicklingInfo, pProxyInfo->pStubDesc, pTypeFormat, pObject );
}


void  RPC_ENTRY
Ndr64MesTypeFree(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,
    const MIDL_STUB_DESC          * pStubDesc,
    PFORMAT_STRING                  pFormat,
    void __RPC_FAR *                pObject
    )
/*++

Routine description:

    Free the object.

Arguments:

    Handle      - a pickling handle,
    pStubDesc   - a pointer to the stub descriptor,
    pFormat     - a pointer to the format code describing the object type
    pObject     - a pointer to the object being freed.

Returns:

Note:

    The pickling header is included in the sizing.

--*/
{
    NDR_PROC_CONTEXT            ProcContext;
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;

    Ndr64pValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;

    NDR_ASSERT( pPicklingInfo->Flags.Oicf, "Oicf should always be on" )

    if ( ! pObject )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    if( (LONG_PTR)pStubMsg->Buffer & 0xf )
        RpcRaiseException( RPC_X_INVALID_BUFFER );


    // Now the individual type object.

    if ( NDR64_IS_POINTER_TYPE(*pFormat) )
        {
        // We have to dereference the pointer once.
        pObject = *(void __RPC_FAR * __RPC_FAR *)pObject;
        }

    (Ndr64FreeRoutinesTable[ NDR64_ROUTINE_INDEX(*pFormat) ])
                                        ( pStubMsg,
                                        (uchar __RPC_FAR *)pObject,
                                        pFormat );

    Ndr64pPicklingClientFinally( pStubMsg, NULL );  // object
}

void  RPC_ENTRY
NdrMesTypeFree3(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,    
    const MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
    const unsigned long **          ArrTypeOffset,    
    unsigned long                   nTypeIndex,
    void __RPC_FAR *                pObject )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;
    PFNMESFREE                  pfnFree;
    MIDL_SYNTAX_INFO        *   pSyntaxInfo;
    PFORMAT_STRING              pTypeFormat;
    SYNTAX_TYPE                 SyntaxType;
    NDR_PROC_CONTEXT            ProcContext;


    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;

    NdrpSetupMesTypeCommon( pfnFree, NdrMesTypeFree2, Ndr64MesTypeFree );

    (*pfnFree)(Handle, pxPicklingInfo, pProxyInfo->pStubDesc, pTypeFormat, pObject );
}

void 
Ndr64pMesProcEncodeInit( PMIDL_ES_MESSAGE                 pMesMsg,
                         const MIDL_STUBLESS_PROXY_INFO * pProxyInfo,
                         unsigned long                    nProcNum,
                         MIDL_ES_CODE                     Operation,
                         NDR_PROC_CONTEXT   *             pContext,
                         uchar *                          StartofStack)
{
    PMIDL_STUB_DESC         pStubDesc = pProxyInfo->pStubDesc;
    SYNTAX_TYPE             syntaxType;
    BOOL                    fUseEncode, fIsSupported = FALSE;
    PMIDL_STUB_MESSAGE      pStubMsg = &pMesMsg->StubMsg;
    RPC_STATUS              res;

    // TODO: verify stub version.
   
    if ( Operation == MES_ENCODE )
        {
        syntaxType = XFER_SYNTAX_DCE;
        memcpy( &( (PMIDL_ES_MESSAGE_EX)pMesMsg )->TransferSyntax,
                &NDR_TRANSFER_SYNTAX ,
                sizeof( RPC_SYNTAX_IDENTIFIER ) );
        }
    else
        {
        syntaxType = XFER_SYNTAX_NDR64;
        memcpy( &( (PMIDL_ES_MESSAGE_EX)pMesMsg )->TransferSyntax,
                &NDR64_TRANSFER_SYNTAX ,
                sizeof( RPC_SYNTAX_IDENTIFIER ) );
        }

    Ndr64ClientInitializeContext( syntaxType, pProxyInfo, nProcNum, pContext, StartofStack );
       
    pStubMsg->pContext = pContext;
    pStubMsg->StubDesc = pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;
    
    // varify proc header
    if ( syntaxType == XFER_SYNTAX_DCE )
        {
        uchar InterpreterFlag = * ((uchar *)&pContext->NdrInfo.InterpreterFlags );
        fUseEncode = InterpreterFlag & ENCODE_IS_USED;
        memcpy( & (pContext->pfnInit), &SyncDcePicklingClient, sizeof( SYNTAX_DISPATCH_TABLE ) );
        }
    else 
        {
        fUseEncode = ( ( (NDR64_PROC_FLAGS *) & pContext->Ndr64Header->Flags)->IsEncode );
        memcpy( & (pContext->pfnInit), &SyncNdr64PicklingClient, sizeof( SYNTAX_DISPATCH_TABLE ) );
        }

    if (!fUseEncode )
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );
}

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrMesProcEncode3(
    PMIDL_ES_MESSAGE                pMesMsg,
    const MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
    unsigned long                   nProcNum,
    uchar *                         StartofStack )
{
    PMIDL_STUB_MESSAGE  pStubMsg = & pMesMsg->StubMsg;
    NDR_PROC_CONTEXT    ProcContext;
    unsigned long       ulAlignment;
    unsigned char *             BufferSaved;
    size_t                      WriteLength;
    CLIENT_CALL_RETURN  Ret;

    Ret.Simple = NULL;

    pMesMsg->ProcNumber = nProcNum;
    

        Ndr64pMesProcEncodeInit( pMesMsg, 
                       pProxyInfo, 
                       nProcNum,
                       pMesMsg->Operation, 
                       &ProcContext,
                       StartofStack );

    RpcTryFinally
        {
        ProcContext.pfnInit( pStubMsg, 
                             NULL );    // return value
                         
        ProcContext.pfnSizing( pStubMsg,
                            TRUE );

        if ( pMesMsg->Operation == MES_ENCODE )
            ulAlignment = 0x7;
        else
            ulAlignment = 0xf;
        
        // we are not changing the proc header, but we need to overestimate because
        // proc header is marshalled first.
        LENGTH_ALIGN( pStubMsg->BufferLength, ulAlignment );
    
        pStubMsg->BufferLength += MES_PROC_HEADER_SIZE ;
    
        LENGTH_ALIGN( pStubMsg->BufferLength, ulAlignment );

        size_t  LengthSaved;

        NdrpAllocPicklingBuffer( pMesMsg, pStubMsg->BufferLength );
        BufferSaved = pStubMsg->Buffer;
        LengthSaved = pStubMsg->BufferLength;

        NDR_ASSERT( ( (ULONG_PTR)pStubMsg->Buffer & ulAlignment ) == 0, "pickling buffer is not aligned" );

        NdrpProcHeaderMarshallAll( pMesMsg );

        ALIGN( pStubMsg->Buffer, ulAlignment );

        ProcContext.pfnMarshal( pStubMsg,
                            FALSE );

        ALIGN( pStubMsg->Buffer, ulAlignment );

        WriteLength = (size_t)(pStubMsg->Buffer - BufferSaved);
        * (unsigned long __RPC_FAR *)
            ( BufferSaved + MES_PROC_HEADER_SIZE - 4) =
                                WriteLength - MES_PROC_HEADER_SIZE;

        if ( LengthSaved < WriteLength )
            {
            NDR_ASSERT( 0, "NdrMesProcEncodeDecode: encode buffer overflow" );
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            }

        NdrpWritePicklingBuffer( pMesMsg, BufferSaved, WriteLength );
        }
    RpcFinally
        {
        ( *ProcContext.pfnClientFinally)( pStubMsg, NULL ); // not object
        }
   RpcEndFinally

    return Ret;
}


// both encode and decode acts like the client side.
void
Ndr64pMesProcDecodeInit( PMIDL_ES_MESSAGE                   pMesMsg,
                         const MIDL_STUBLESS_PROXY_INFO *   pProxyInfo,
                         SYNTAX_TYPE                        SyntaxType,
                         unsigned long                      nProcNum,
                         NDR_PROC_CONTEXT *                 pContext,
                         uchar *                            StartofStack )
{
    RPC_STATUS            res;
    PMIDL_STUB_MESSAGE    pStubMsg = &pMesMsg->StubMsg;
    unsigned long         nFormatOffset;
    PMIDL_STUB_DESC       pStubDesc = pProxyInfo->pStubDesc;
    BOOL                  fUseDecode;

    // REVIEW: Calling the "Client" init for decode seems weird but it does
    //         the right thing and NdrServerSetupMultipleTransferSyntax assumes
    //         ndr64.

	Ndr64ClientInitializeContext(
	        SyntaxType,
            pProxyInfo,
            nProcNum,
            pContext,
            StartofStack );

    pStubMsg->pContext = pContext;
    pStubMsg->StubDesc = pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;
    
    NdrpDataBufferInit( pMesMsg, pContext->pProcFormat );
    
    if ( SyntaxType == XFER_SYNTAX_DCE )
        {
        uchar InterpreterFlag = * ((uchar *)&pContext->NdrInfo.InterpreterFlags );
        fUseDecode = InterpreterFlag & DECODE_IS_USED;
        memcpy( & (pContext->pfnInit), &SyncDcePicklingClient, sizeof( SYNTAX_DISPATCH_TABLE ) );
        }
    else 
        {
        fUseDecode = ( ( (NDR64_PROC_FLAGS *) & pContext->Ndr64Header->Flags)->IsDecode );
        memcpy( & (pContext->pfnInit), &SyncNdr64PicklingClient, sizeof( SYNTAX_DISPATCH_TABLE ) );
        }

    if (!fUseDecode )
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );        
}


CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrMesProcDecode3(
    PMIDL_ES_MESSAGE                pMesMsg,
    const MIDL_STUBLESS_PROXY_INFO *pProxyInfo,
    unsigned long                   nProcNum,
    uchar *                         StartofStack,
    void *                          pReturnValue )
{
    CLIENT_CALL_RETURN      RetVal;
    NDR_PROC_CONTEXT        ProcContext;
    SYNTAX_TYPE             SyntaxType;
    PMIDL_STUB_MESSAGE      pStubMsg = & pMesMsg->StubMsg;
    NDR64_PROC_FLAGS           *ProcFlags;
    unsigned long           ulAlign;
    long                        HasComplexReturn;

    RetVal.Simple = NULL;
    if (NULL == pReturnValue )
        pReturnValue = &RetVal;
    
    if ( GET_MES_HEADER_PEEKED( pMesMsg ) )
        {
        // This makes it possible to encode/decode several procs one after
        // another with the same pickling handle (using the same buffer).

        CLEAR_MES_HEADER_PEEKED( pMesMsg );
        }
    else
        NdrpProcHeaderUnmarshallAll( pMesMsg );

    SyntaxType = NdrpGetSyntaxType( &((PMIDL_ES_MESSAGE_EX)pMesMsg)->TransferSyntax );

    if ( SyntaxType ==  XFER_SYNTAX_DCE )
        {
        pMesMsg->Operation = MES_DECODE;
        ulAlign = 0x7;
        }
    else if ( SyntaxType == XFER_SYNTAX_NDR64 )
        {
        pMesMsg->Operation = ( MIDL_ES_CODE )MES_DECODE_NDR64;
        ulAlign = 0xf;
        }
    else
        RpcRaiseException( RPC_S_UNSUPPORTED_TRANS_SYN );

    if ( (LONG_PTR)pStubMsg->BufferStart & ulAlign )
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        
    Ndr64pMesProcDecodeInit( pMesMsg,
                             pProxyInfo,
                             SyntaxType,
                             nProcNum,
                             &ProcContext,
                             StartofStack );

    RpcTryFinally
        {

        ProcContext.pfnInit( pStubMsg, 
                             NULL );    // return value
                         
        ALIGN( pStubMsg->Buffer, ulAlign );
    
        ProcContext.pfnUnMarshal( pStubMsg,
                                  ProcContext.HasComplexReturn
                                        ? &pReturnValue
                                        : pReturnValue );

    // prepare for new decoding.
        ALIGN( pStubMsg->Buffer, ulAlign );

        }
   RpcFinally
        {
    
        ( *ProcContext.pfnClientFinally)( pStubMsg, NULL );  // object
        }
   RpcEndFinally

   return *(CLIENT_CALL_RETURN *)pReturnValue;
            
}

CLIENT_CALL_RETURN  RPC_VAR_ENTRY
NdrMesProcEncodeDecode3(
    handle_t                        Handle,
    const MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
    unsigned long                   nProcNum,
    void                            *pReturnValue,    
    ... )
{
    BOOL                fMoreParams;
    PFORMAT_STRING      pProcFormat;
    void __RPC_FAR *    pArg;
    va_list             ArgList;
    unsigned char *     BufferSaved;
    size_t              WriteLength;
    uchar *             StartofStack;

    Ndr64pValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );
    PMIDL_ES_MESSAGE    pMesMsg  = (PMIDL_ES_MESSAGE) Handle;

    INIT_ARG( ArgList, pReturnValue );
    GET_FIRST_IN_ARG(ArgList);
    StartofStack = (uchar *)GET_STACK_START(ArgList);

    if ( pMesMsg->Operation == MES_ENCODE ||
         pMesMsg->Operation == MES_ENCODE_NDR64 )
        return NdrMesProcEncode3( (PMIDL_ES_MESSAGE)Handle, pProxyInfo, nProcNum, StartofStack );
    else
        return NdrMesProcDecode3( (PMIDL_ES_MESSAGE)Handle, pProxyInfo, nProcNum, StartofStack, pReturnValue );
  

}


void  RPC_ENTRY
NdrpPicklingClientFinally( PMIDL_STUB_MESSAGE pStubMsg,
                   void *  pThis )
{
    NDR_PROC_CONTEXT    *   pContext = (NDR_PROC_CONTEXT *) pStubMsg->pContext;
    PMIDL_STUB_DESC     pStubDesc = pStubMsg->StubDesc;

    NdrFullPointerXlatFree(pStubMsg->FullPtrXlatTables);

    NdrCorrelationFree( pStubMsg );

    NdrpAllocaDestroy( & pContext->AllocateContext );

}

void  RPC_ENTRY
Ndr64pPicklingClientFinally( PMIDL_STUB_MESSAGE pStubMsg,
                   void *  pThis )
{
    NdrFullPointerXlatFree(pStubMsg->FullPtrXlatTables);

    NdrpAllocaDestroy( & ( (NDR_PROC_CONTEXT *)pStubMsg->pContext )->AllocateContext );
}


// =======================================================================
//
//   Ready to use AlignSize routines for simple types
//
// =======================================================================
void ValidateMesSimpleTypeAll( const MIDL_STUBLESS_PROXY_INFO * pProxyInfo,
                               MIDL_ES_CODE Operation )
{
    ulong i;
    SYNTAX_TYPE SyntaxType;
    
    if ( Operation == MES_ENCODE ||
         Operation == MES_DECODE )
        SyntaxType = XFER_SYNTAX_DCE;
    else
        SyntaxType = XFER_SYNTAX_NDR64;

    for ( i = 0; i < ( ulong )pProxyInfo->nCount; i++ )
        {
        if ( NdrpGetSyntaxType( &pProxyInfo->pSyntaxInfo[i].TransferSyntax ) == SyntaxType )
            break;
        }

    // Raise exception if we didn't find the supported syntax in proxyinfo.
    if ( i >= pProxyInfo->nCount )  
        RpcRaiseException( RPC_S_UNSUPPORTED_TRANS_SYN );
}


size_t  RPC_ENTRY
NdrMesSimpleTypeAlignSizeAll(
    handle_t Handle,
    const MIDL_STUBLESS_PROXY_INFO *  pProxyInfo
    )
/*++
    Size is always 8 bytes for data and there is no header here per data.
    However, the common header gets included for the first object.
--*/
{
    if ( (( PMIDL_ES_MESSAGE)Handle )->Operation != MES_ENCODE &&
         (( PMIDL_ES_MESSAGE)Handle )->Operation != MES_ENCODE_NDR64 )
         RpcRaiseException( RPC_X_INVALID_ES_ACTION );
         
    Ndr64pValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_STUB_MESSAGE  pStubMsg = &((PMIDL_ES_MESSAGE) Handle)->StubMsg;

    ValidateMesSimpleTypeAll( pProxyInfo, ((PMIDL_ES_MESSAGE)Handle)->Operation );
    
    unsigned long OldLength = pStubMsg->BufferLength;

    if ( ((PMIDL_ES_MESSAGE)Handle)->Operation == MES_ENCODE )
        {
        if( (long)( pStubMsg->BufferLength & 0x7 ) )
            RpcRaiseException( RPC_X_INVALID_BUFFER );
            
        NdrpCommonTypeHeaderSize( (PMIDL_ES_MESSAGE)Handle );
        pStubMsg->BufferLength += 8;
        }
    else
        {
        if( (long)( pStubMsg->BufferLength & 0xf ) )
            RpcRaiseException( RPC_X_INVALID_BUFFER );
            
        Ndr64pCommonTypeHeaderSize( (PMIDL_ES_MESSAGE)Handle );
        LENGTH_ALIGN( pStubMsg->BufferLength, 0xf );
        pStubMsg->BufferLength += 16;
        }

    return( (size_t)(pStubMsg->BufferLength - OldLength) );
}


// =======================================================================
//
//   Ready to use Encode routines for simple types
//
// =======================================================================

void  RPC_ENTRY
NdrMesSimpleTypeEncodeAll(
    handle_t                Handle,
    const MIDL_STUBLESS_PROXY_INFO *  pProxyInfo,
    const void __RPC_FAR *  pData,
    short                   Size )
/*++
    Marshall a simple type entity. There is no header here per data.
    However, the common header gets included for the first object.
--*/
{
    if ( (( PMIDL_ES_MESSAGE)Handle )->Operation != MES_ENCODE &&
         (( PMIDL_ES_MESSAGE)Handle )->Operation != MES_ENCODE_NDR64 )
         RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    Ndr64pValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_ES_MESSAGE    pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;
    PMIDL_STUB_DESC     pStubDesc = pProxyInfo->pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;
    unsigned long       ulAlignment;
    size_t RequiredLen;

    // Size and allocate the buffer.
    // The req len includes: (the common header) and the data

    // Take the pointer alignment to come up with the right size.

    pStubMsg->BufferLength = 0xf & PtrToUlong( pStubMsg->Buffer );

    RequiredLen = NdrMesSimpleTypeAlignSizeAll( Handle, pProxyInfo );
    NdrpAllocPicklingBuffer( pMesMsg, RequiredLen );

    // See if we need to marshall the common type header

    uchar __RPC_FAR *   pBufferSaved = pStubMsg->Buffer;

    if ( pMesMsg->Operation == MES_ENCODE )
        {
        NdrpCommonTypeHeaderMarshall( pMesMsg );
        ulAlignment = 0x7;
        }
    else if ( pMesMsg->Operation == MES_ENCODE_NDR64 )
        {
        Ndr64pCommonTypeHeaderMarshall( pMesMsg );
        ulAlignment = 0xf;
        }
    else
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    ALIGN( pStubMsg->Buffer, ulAlignment );
    
    switch ( Size )
        {
        case 1:
            * PCHAR_CAST pStubMsg->Buffer  = * PCHAR_CAST pData;
            break;

        case 2:
            * PSHORT_CAST pStubMsg->Buffer = * PSHORT_CAST pData;
            break;

        case 4:
            * PLONG_CAST pStubMsg->Buffer  = * PLONG_CAST pData;
            break;

        case 8:
            * PHYPER_CAST pStubMsg->Buffer = * PHYPER_CAST pData;
            break;

        default:
            NDR_ASSERT( 0, " Size generation problem" );
        }

    pStubMsg->Buffer += ulAlignment+1;

    NdrpWritePicklingBuffer( pMesMsg, pBufferSaved, RequiredLen );
}



// =======================================================================
//
//   Ready to use Decode routines for simple types
//
// =======================================================================

void  RPC_ENTRY
NdrMesSimpleTypeDecodeAll(
    handle_t Handle,
    const MIDL_STUBLESS_PROXY_INFO *  pProxyInfo,
    void  __RPC_FAR *  pData,
    short    FormatChar )
/*++
    Does not include the header for the data.
    However, the common header gets included for the first object.

    Note. Endianness and other conversions for decode.
    This has been deemed as not worthy doing in the Daytona time frame.
    However, to be able to add it in future without backward compatibility
    problems, we have the last argument to be the format character as
    opposed to the size.
    This makes it possible to call NdrSimpleTypeConvert, if needed.
    
    Note that the compiler uses the 32bit tokens for this since this routine 
    is common to both formats.
--*/
{
    if ( ( (PMIDL_ES_MESSAGE)Handle )->Operation != MES_DECODE &&
         ( (PMIDL_ES_MESSAGE)Handle )->Operation != MES_DECODE_NDR64 )
         RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    Ndr64pValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_ES_MESSAGE    pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = &((PMIDL_ES_MESSAGE)Handle)->StubMsg;
    uchar *             BufferSaved;
    unsigned long       ulAlignment;

    // See if we need to unmarshall the common type header.
    Ndr64pCommonTypeHeaderUnmarshall( pMesMsg );
    

    // Now the data.

    if ( pMesMsg->Operation == MES_DECODE )
        {
        NdrpReadPicklingBuffer( (PMIDL_ES_MESSAGE) Handle, 8);
        ulAlignment = 0x7;
        }
    else
        {
        NdrpReadPicklingBuffer( (PMIDL_ES_MESSAGE) Handle, 16);
        ulAlignment = 0xf;
        }

    NDR_ASSERT( ( (ULONG_PTR)pStubMsg->Buffer & ulAlignment ) == 0, "invalid buffer alignment in simple type pickling" );

    ValidateMesSimpleTypeAll( pProxyInfo, ((PMIDL_ES_MESSAGE)Handle)->Operation );
    if ( pMesMsg->AlienDataRep != NDR_LOCAL_DATA_REPRESENTATION )
        {
        pStubMsg->RpcMsg->DataRepresentation = pMesMsg->AlienDataRep;

        BufferSaved = pStubMsg->Buffer;
        NdrSimpleTypeConvert( pStubMsg, (unsigned char)FormatChar );
        pStubMsg->Buffer = BufferSaved;
        }

    switch ( FormatChar )
        {
        case FC_BYTE:
        case FC_CHAR:
        case FC_SMALL:
        case FC_USMALL:
            * PCHAR_CAST  pData = * PCHAR_CAST pStubMsg->Buffer;
            break;

        case FC_WCHAR:
        case FC_SHORT:
        case FC_USHORT:
            * PSHORT_CAST pData = * PSHORT_CAST pStubMsg->Buffer;
            break;

        case FC_LONG:
        case FC_ULONG:
        case FC_FLOAT:
        case FC_ENUM32:
        case FC_ERROR_STATUS_T:
            * PLONG_CAST  pData = * PLONG_CAST pStubMsg->Buffer;
            break;

        case FC_HYPER:
        case FC_DOUBLE:
            * PHYPER_CAST pData = * PHYPER_CAST pStubMsg->Buffer;
            break;

#if defined(__RPC_WIN64__)
        case FC_INT3264:
            if (pMesMsg->Operation == MES_DECODE )           
                *((INT64 *)pData)  = *((long *) pStubMsg->Buffer);
            else
                *((INT64 *)pData)  = *((INT64 *) pStubMsg->Buffer);            
            break;

        case FC_UINT3264:
            if (pMesMsg->Operation == MES_DECODE )           
                *((UINT64 *)pData) = *((ulong *)pStubMsg->Buffer);
            else
                *((UINT64 *)pData) = *((UINT64 *)pStubMsg->Buffer);
            break;
#endif

        default:
            NDR_ASSERT( 0, " Size generation problem for simple types" );
        }

    pStubMsg->Buffer += ulAlignment+1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\proxy.cxx ===
/*++

Microsoft Windows
Copyright (c) 1994 Microsoft Corporation.  All rights reserved.

Module Name:
    proxy.c

Abstract:
    Implements the IRpcProxyBuffer interface.

Author:
    ShannonC    12-Oct-1994

Environment:
    Windows NT and Windows 95 and PowerMac.
    We do not support DOS, Win16 and Mac.

Revision History:

--*/

#include "precomp.hxx"

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include <ndrole.h>
#include <rpcproxy.h>
#include <stddef.h>



CStdProxyBuffer * RPC_ENTRY
NdrGetProxyBuffer(
    void *pThis);
#pragma code_seg(".ndr64")


void RPC_ENTRY
Ndr64ProxyInitialize(
    IN  void * pThis,
    IN  PRPC_MESSAGE                    pRpcMsg,
    IN  PMIDL_STUB_MESSAGE              pStubMsg,
    IN  PMIDL_STUBLESS_PROXY_INFO       pProxyInfo,
    IN  unsigned int                    ProcNum )
/*++

Routine Description:
    Initialize the MIDL_STUB_MESSAGE.

Arguments:
    pThis - Supplies a pointer to the interface proxy.
    pRpcMsg
        pStubMsg
        pStubDescriptor
        ProcNum

Return Value:

--*/
{
    CStdProxyBuffer *   pProxyBuffer;
    HRESULT             hr;

    pProxyBuffer = NdrGetProxyBuffer(pThis);

    //
    // Initialize the stub message fields.
    //
    pStubMsg->dwStubPhase = PROXY_CALCSIZE;

    Ndr64ClientInitialize(
        pRpcMsg,
        pStubMsg,
        pProxyInfo,
        ProcNum );

    //Note that NdrClientInitializeNew sets RPC_FLAGS_VALID_BIT in the ProcNum.
    //We don't want to do this for object interfaces, so we clear the flag here.
    pRpcMsg->ProcNum &= ~RPC_FLAGS_VALID_BIT;

    pStubMsg->pRpcChannelBuffer = pProxyBuffer->pChannel;

    //Check if we are connected to a channel.
    if(pStubMsg->pRpcChannelBuffer != 0)
    {
        //AddRef the channel.
        //We will release it later in NdrProxyFreeBuffer.
        pStubMsg->pRpcChannelBuffer->lpVtbl->AddRef(pStubMsg->pRpcChannelBuffer);

        //Get the destination context from the channel
        hr = pStubMsg->pRpcChannelBuffer->lpVtbl->GetDestCtx(
            pStubMsg->pRpcChannelBuffer, &pStubMsg->dwDestContext, &pStubMsg->pvDestContext);
    }
    else
    {
        //We are not connected to a channel.
        RpcRaiseException(CO_E_OBJNOTCONNECTED);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\pointer.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    pointer.h

Abstract :

    This file contains the routines for handling pointers and pointer
    layouts.
    
Author :

    Mike Zoran  mzoran   January 2000.

Revision History :

  ---------------------------------------------------------------------*/

#include "ndrp.h"

#if !defined(__POINTER_H__)
#define  __POINTER_H__

void
Ndr64pPointerLayoutMarshall( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory,
    uchar *             pBuffer );

void
Ndr64pPointerLayoutMarshallInternal( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory,
    uchar *             pBuffer );

void
Ndr64pPointerLayoutUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory,
    uchar *             pBuffer );

void
Ndr64pPointerLayoutMemorySize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pBuffer );

void 
Ndr64pPointerLayoutBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory );

void 
Ndr64pPointerLayoutFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory );

void 
Ndr64pPointerMarshall( 
    PMIDL_STUB_MESSAGE  pStubMsg, 
    NDR64_PTR_WIRE_TYPE *pBufferMark,
    uchar *             pMemory, 
    PNDR64_FORMAT       pFormat
    );

void 
Ndr64pPointerMemorySize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE *pBufferMark,
    PNDR64_FORMAT       pFormat
    );

void
Ndr64pPointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE WirePtr,
    uchar **            ppMemory,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat 
    );


void
Ndr64pPointerBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat
    );

__forceinline ulong 
Ndr64pWirePtrToRefId(
        NDR64_PTR_WIRE_TYPE WireRef )
    {

    if ( WireRef > 0x7FFFFFFF )
        {
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        return 0;
        }

    return (ulong)WireRef;
    }

__forceinline NDR64_PTR_WIRE_TYPE
Ndr64pRefIdToWirePtr(
        ulong RefId )
    {
    // Check if wire ref will fit in a 2GB number.
    
    if ( RefId > 0x7FFFFFFF )
        {
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        return 0;
        }
    return (NDR64_PTR_WIRE_TYPE)RefId;
    }

__forceinline BOOL
Ndr64pFullPointerQueryPointer( 
    PMIDL_STUB_MESSAGE      pStubMsg,
    void *                  pPointer,
    uchar                   QueryType,
    ulong *                 pRefId )
{

    return (BOOL)
    NdrFullPointerQueryPointer( pStubMsg->FullPtrXlatTables,
                                pPointer,
                                QueryType,
                                pRefId );
        
}


__forceinline BOOL
Ndr64pFullPointerQueryRefId( 
    PMIDL_STUB_MESSAGE      pStubMsg,
    ulong                   RefId,
    uchar                   QueryType,
    void **                 ppPointer )
    {

    return (BOOL)
    NdrFullPointerQueryRefId( pStubMsg->FullPtrXlatTables,
                              RefId,
                              QueryType,
                              ppPointer );

    }

__forceinline void
Ndr64pFullPointerInsertRefId(
    PMIDL_STUB_MESSAGE     pStubMsg,
    ulong                  RefId,
    void *                 pPointer )
    {
    
    NdrFullPointerInsertRefId( pStubMsg->FullPtrXlatTables,
                               RefId,
                               pPointer );

    }

#define FULL_POINTER_INSERT( pStubMsg, Pointer )    \
                { \
                Ndr64pFullPointerInsertRefId( pStubMsg, \
                                           pStubMsg->FullPtrRefId, \
                                           Pointer ); \
 \
                pStubMsg->FullPtrRefId = 0; \
                }

#endif // __POINTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Yong  Qu   (yongqu)  Dec-12-1999

Revision History:

!ENDIF

TARGETNAME=rpcndr64
TARGETPATH=obj
TARGETTYPE=LIBRARY
386_STDCALL=1

MSC_WARNING_LEVEL=/W3 /WX

INCLUDES=..;..\..\ndr20;..\..\midl\inc;..\..\runtime\mtrt;$(INCLUDES);$(PROJECT_ROOT)\inc\ndrshared

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.hxx

SOURCES=        \
    ..\async.cxx   \
    ..\auxilary.cxx\
    ..\bufsize.cxx \
    ..\free.cxx    \
    ..\global.cxx  \
    ..\memsize.cxx \
    ..\misc.cxx    \
    ..\srvout.cxx  \
    ..\pickle64.cxx\
    ..\pointer.cxx \
    ..\expr.cxx    \
    ..\mrshl.cxx   \
    ..\unmrshl.cxx \
    ..\hndl.cxx    \
    ..\asyncu.cxx  \
    ..\cltcall.cxx \
    ..\mulsyntx.cxx\
    ..\proxy.cxx   \
    ..\srvcall.cxx \
    ..\srvwrap.cxx \
    ..\relmrl.cxx  \
    ..\pipes.cxx   


!ifdef DOSWIN32RPC
RPCENV=$(RPCENV) -DDOSWIN32RPC -DWIN32RPC
!else
RPCENV=$(RPCENV) -DNTENV
!endif

C_DEFINES=$(RPCENV) -D_RPCRT4_ -DBUILD_NDR64

BUILD_NDR64=1
!ifdef BUILD_NDR64FAKE
C_DEFINES=$(C_DEFINES) -DBUILD_NDR64FAKE
!endif


UMTYPE=console
UMTEST=testc
UMLIBS=$(O)\rpcndr64.lib $(SDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\rpcrt4.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\srvout.cxx ===
/************************************************************************

Copyright (c) 1993 - 1999 Microsoft Corporation

Module Name :

    srvout.cxx

Abstract :

    Contains routines for support of [out] parameters on server side during 
    unmarshalling phase. This includes deferral, allocation and handle 
    initialization.

Author :     

    Bruce McQuistan (brucemc)   12/93.

Revision History :

    DKays   10/94   Major comment and code clean up.

 ***********************************************************************/

#include "precomp.hxx"

void
Ndr64OutInit(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PNDR64_FORMAT           pFormat,
    uchar **                ppArg
    )
/*++

Routine Description :        

    This routine is called to manage server side issues for [out] params 
    such as allocation and context handle initialization. Due to the fact 
    that for [out] conformant objects on stack, their size descriptors may 
    not have been unmarshalled when we need to know their size, this routine 
    must be called after all other unmarshalling has occurred. Really, we 
    could defer only [out], conformant data, but the logic in walking the 
    format string to determine if an object is conformant does not warrant 
    that principle, so all [out] data is deferred.

Arguments :      

    pStubMsg    - Pointer to stub message.
    pFormat     - Format string description for the type.
    ppArg       - Location of argument on stack.

Return :

    None.

 --*/
{

    const NDR64_POINTER_FORMAT *pPointerFormat = 
        (const NDR64_POINTER_FORMAT*)pFormat;

    // This must be a signed long!
    LONG_PTR    Size;  

    //
    // Check for a non-Interface pointer (they have a much different format 
    // than regular pointers).
    //
    if ( NDR64_IS_BASIC_POINTER(*(PFORMAT_STRING)pFormat) )
        {
        //
        // Check for a pointer to a basetype (we don't have to worry about
        // a non-sized string pointer because these are not allowed as [out]
        // only.
        //
        if ( NDR64_SIMPLE_POINTER( pPointerFormat->Flags ) )
            {
            Size = NDR64_SIMPLE_TYPE_MEMSIZE( *(PFORMAT_STRING)pPointerFormat->Pointee );
            goto DoAlloc;
            }

        //
        // Check for a pointer to a pointer.
        //
        if ( NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
            {
            Size = PTR_MEM_SIZE;
            goto DoAlloc;
            }

        // We have a pointer to complex type.
        pFormat = pPointerFormat->Pointee;

        }

    if ( *(PFORMAT_STRING)pFormat == FC64_BIND_CONTEXT )
        {
        NDR_SCONTEXT Context = 
            Ndr64ContextHandleInitialize( pStubMsg,
                                          (PFORMAT_STRING)pFormat );

        if ( ! Context )
            RpcRaiseException( RPC_X_SS_CONTEXT_MISMATCH );

        Ndr64SaveContextHandle(
            pStubMsg,
            Context,
            ppArg,
            (PFORMAT_STRING)pFormat );

        return;
        }

    //
    // If we get here we have to make a call to size a complex type.
    //
    Size = Ndr64pMemorySize( pStubMsg,
                             pFormat,
                             FALSE );

DoAlloc:

    //
    // Check for a negative size.  This an application error condition for
    // signed size specifiers.
    //
    if ( Size < 0 )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    *ppArg = (uchar *)NdrAllocate( pStubMsg, (size_t) Size);

    MIDL_memset( *ppArg, 0, (size_t) Size );

    // We are almost done, except for an out ref to ref to ... etc.
    // If this is the case keep allocating pointees of ref pointers.

    if ( *(PFORMAT_STRING)pFormat == FC64_RP  &&  NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
        {

        pFormat = pPointerFormat->Pointee;

        if ( *(PFORMAT_STRING)pFormat == FC64_RP )
            Ndr64OutInit( pStubMsg, pFormat, (uchar **) *ppArg );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\unmrshl.cxx ===
/**********************************************************************

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    unmrshl.cxx

Abstract :

    This file contains the unmarshalling routines called by MIDL generated
    stubs and the interpreter.

Author :

    David Kays  dkays   September 1993.

Revision History :

  **********************************************************************/

#include "precomp.hxx"

#include "..\..\ndr20\ndrole.h"


void 
Ndr64UDTSimpleTypeUnmarshall1(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
{

    //
    // Align the buffer.
    //
    ALIGN( pStubMsg->Buffer, NDR64_SIMPLE_TYPE_BUFALIGN(*(PFORMAT_STRING)pFormat) );

    // Initialize the memory pointer if needed.
    if ( fMustAlloc )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, 
                                           NDR64_SIMPLE_TYPE_MEMSIZE(*(PFORMAT_STRING)pFormat) );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }
    else if ( !*ppMemory )
        {
        // Set pointer into buffer.
        *ppMemory = pStubMsg->Buffer;
        }

    Ndr64SimpleTypeUnmarshall( pStubMsg,
                               *ppMemory,
                               *(PFORMAT_STRING)pFormat );
}


void 
Ndr64SimpleTypeUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    uchar               FormatChar )
/*++

Routine Description :

    Unmarshalls a simple type.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Memory pointer to unmarshall into.
    FormatChar  - Simple type format character.

Return :

    None.

--*/
{
    switch ( FormatChar )
        {
        case FC64_CHAR :
        case FC64_UINT8 :
        case FC64_INT8 :
            *pMemory = *(pStubMsg->Buffer)++;
            break;

        case FC64_WCHAR :
        case FC64_UINT16 :
        case FC64_INT16 :
            ALIGN(pStubMsg->Buffer,1);

            *((NDR64_UINT16 *)pMemory) = *((NDR64_UINT16 *)pStubMsg->Buffer);
            pStubMsg->Buffer += sizeof(NDR64_UINT16);
            break;

        case FC64_INT32 :
        case FC64_UINT32 :
        case FC64_FLOAT32 :
        case FC64_ERROR_STATUS_T:
            ALIGN(pStubMsg->Buffer,3);

            *((NDR64_UINT32 *)pMemory) = *((NDR64_UINT32 *)pStubMsg->Buffer);
            pStubMsg->Buffer += sizeof(NDR64_UINT32);
            break;
        
        case FC64_UINT64 :
        case FC64_INT64 :
        case FC64_FLOAT64 :
            ALIGN(pStubMsg->Buffer,7);
            *((NDR64_UINT64 *)pMemory) = *((NDR64_UINT64 *)pStubMsg->Buffer);
            pStubMsg->Buffer += sizeof(NDR64_UINT64);
            break;

        case FC64_IGNORE :
            break;

        default :
            NDR_ASSERT(0,"Ndr64SimpleTypeUnmarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }
}


void 
Ndr64RangeUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++
    Unmarshals a range FC64_RANGE descriptor.
--*/
{
     const NDR64_RANGE_FORMAT * pRangeFormat =
        (const NDR64_RANGE_FORMAT*)pFormat;
     
     Ndr64UDTSimpleTypeUnmarshall1( pStubMsg,
                                    ppMemory,
                                    (PNDR64_FORMAT)&pRangeFormat->RangeType,
                                    fMustAlloc );

     EXPR_VALUE Value = Ndr64pSimpleTypeToExprValue( pRangeFormat->RangeType, *ppMemory ); 

     if ( Value < (EXPR_VALUE)pRangeFormat->MinValue || 
          Value > (EXPR_VALUE)pRangeFormat->MaxValue )
         RpcRaiseException( RPC_X_INVALID_BOUND );

}


IUnknown *
Ndr64pInterfacePointerUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat)
/*++

Routine Description :

    Unmarshalls an interface pointer.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pFormat     - Interface pointer's format string description.

Return :

    None.

Notes : Here is the data representation.

    // wire representation of a marshalled interface pointer
    typedef struct tagMInterfacePointer
    {
        ULONG           ulCntData;          // size of data
        [size_is(ulCntData)] BYTE abData[]; // data (OBJREF)
    } MInterfacePointer;
    
--*/
{
    const NDR64_CONSTANT_IID_FORMAT *pConstInterfaceFormat =
        (NDR64_CONSTANT_IID_FORMAT*)pFormat;
    const NDR64_IID_FORMAT *pInterfaceFormat =
        (NDR64_IID_FORMAT*)pFormat;
       
    // Unmarshal the conformant size and the count field.
    ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );
    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, (sizeof(NDR64_WIRE_COUNT_TYPE)+sizeof(ulong)) );
    
    NDR64_UINT32 MaxCount = Ndr64pConvertTo2GB( *(NDR64_WIRE_COUNT_TYPE *) pStubMsg->Buffer );
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
    ulong ulCntData = *(ulong *) pStubMsg->Buffer;
    pStubMsg->Buffer += sizeof(ulong);

    if ( MaxCount != ulCntData )
        {
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        return NULL;
        }


    if ( !MaxCount )
        {
        return NULL;
        }

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, MaxCount );
        
    // Get a pointer to the IID hidden in the interface pointer
    // representation in the buffer with Rick's IRpcHelper.
    //
    IID *piidValue;
    NdrpGetIIDFromBuffer( pStubMsg, & piidValue );

    //
    // Validate the IID.
    //
    if ( ((NDR64_IID_FLAGS*)&pConstInterfaceFormat->Flags)->ConstantIID )
        {
        if ( memcmp( &pConstInterfaceFormat->Guid,
                     piidValue,
                     sizeof(GUID)) != 0) 
            {
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
            return NULL;
            }
        }
    else
        {

        Ndr64pCheckCorrelation(pStubMsg,
                               (EXPR_VALUE)piidValue,
                               pInterfaceFormat->IIDDescriptor,
                               EXPR_IID
                               );
        }

    IStream *pStream = (*NdrpCreateStreamOnMemory)(pStubMsg->Buffer, MaxCount);
    if(pStream == 0)
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY);
        return NULL;
        }

    IUnknown *      punk = NULL;
    HRESULT hr = (*pfnCoUnmarshalInterface)(pStream, IID_NULL, (void**)&punk );
    pStream->Release();

    if(FAILED(hr))
        {
        RpcRaiseException(hr);
        return NULL;
        }

    pStubMsg->Buffer += MaxCount;

    return punk;
}



class FINDONTFREE_CONTEXT
{
    PMIDL_STUB_MESSAGE const pStubMsg;
    const int fInDontFreeSave;
public:
    __forceinline FINDONTFREE_CONTEXT( PMIDL_STUB_MESSAGE pStubMsg ) :
        pStubMsg( pStubMsg ),
        fInDontFreeSave(pStubMsg->fInDontFree)
    {}
    __forceinline FINDONTFREE_CONTEXT( PMIDL_STUB_MESSAGE pStubMsg,
                         int fInDontFree ) :
        pStubMsg( pStubMsg ),
        fInDontFreeSave(pStubMsg->fInDontFree)
    {
        pStubMsg->fInDontFree = fInDontFree;
    }
    __forceinline ~FINDONTFREE_CONTEXT()
    {
        pStubMsg->fInDontFree = fInDontFreeSave;
    }
};

void
Ndr64pFreeOlePointer(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    
    NDR_POINTER_QUEUE *pOldQueue = NULL;
    if ( pStubMsg->pPointerQueueState )
        {
        pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
        pStubMsg->pPointerQueueState->SetActiveQueue(pOldQueue);
        }

    RpcTryFinally
        {
        Ndr64PointerFree( pStubMsg,
                        pMemory,
                        pFormat );
        }
    RpcFinally
        {
        if ( pStubMsg->pPointerQueueState )
            {
            pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
            }
        }
    RpcEndFinally

}

NDR_ALLOC_ALL_NODES_CONTEXT *
Ndr64pGetAllocateAllNodesContext(
    PMIDL_STUB_MESSAGE pStubMsg,
    PNDR64_FORMAT      pFormat )
{
    uchar *pBuffer = pStubMsg->Buffer;

    // Clear memory size before calling mem size routine.
    pStubMsg->MemorySize = 0;

    //
    // Get the allocate all nodes memory size.
    //
    {
        NDR_POINTER_QUEUE *pOldQueue = NULL; 

        if (pStubMsg->pPointerQueueState)
            {
            pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
            pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
            }

        RpcTryFinally
            {
            Ndr64TopLevelTypeMemorySize( pStubMsg,
                                         pFormat );
            }
        RpcFinally
            {
            if ( pStubMsg->pPointerQueueState )
                {
                pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
                }
            }
        RpcEndFinally


    }

    ulong AllocSize = pStubMsg->MemorySize;
    pStubMsg->MemorySize = 0;
    LENGTH_ALIGN( AllocSize, __alignof(NDR_ALLOC_ALL_NODES_CONTEXT) - 1);

    uchar *pAllocMemory = 
        (uchar*)NdrAllocate( pStubMsg, AllocSize + sizeof(NDR_ALLOC_ALL_NODES_CONTEXT) );

    NDR_ALLOC_ALL_NODES_CONTEXT *pAllocContext = 
        (NDR_ALLOC_ALL_NODES_CONTEXT*)(pAllocMemory + AllocSize);
    pAllocContext->AllocAllNodesMemory      = pAllocMemory;
    pAllocContext->AllocAllNodesMemoryBegin = pAllocMemory;
    pAllocContext->AllocAllNodesMemoryEnd   = (uchar*)pAllocContext;

    pStubMsg->Buffer = pBuffer;

    return pAllocContext;
}

__forceinline void
Ndr64pPointerUnmarshallInternal(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE WirePtr,
    uchar **            ppMemory,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Private routine for unmarshalling a pointer to anything.  This is the
    entry point for pointers embedded in structures, arrays, and unions.

    Used for FC64_RP, FC64_UP, FC64_FP, FC64_OP.

Arguments :

    pStubMsg        - Pointer to the stub message.
    ppBufferPointer - Address of the location in the buffer which holds the
                      incomming pointer's value and will hold the final
                      unmarshalled pointer's value.
    pMemory         - Current memory pointer's value which we want to
                      unmarshall into.  If this value is valid the it will
                      be copied to *ppBufferPointer and this is where stuff
                      will get unmarshalled into.
    pFormat         - Pointer's format string description.

    pStubMsg->Buffer - set to the pointee.

Return :

    None.

--*/
{

    const NDR64_POINTER_FORMAT *pPointerFormat = (NDR64_POINTER_FORMAT*) pFormat;
    bool        fPointeeAlloc;
    bool        fNewAllocAllNodes = false;

    // make sure we are not out out of bound. We need this check for embedded pointers / pointer 
    // to pointer cases. 
    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );
    
    SAVE_CONTEXT<ulong> FullPtrRefIdSave( pStubMsg->FullPtrRefId );
    FINDONTFREE_CONTEXT fInDontFreeSave( pStubMsg );

    if ( NDR64_IS_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags) )
        {
        pMemory = 0;
        }

    //
    // Check the pointer type.
    //
    switch ( *(PFORMAT_STRING)pFormat )
        {
        case FC64_RP :
            break;

        case FC64_OP :
            //
            // Burn some instructions for OLE unique pointer support.
            //
            if ( pStubMsg->IsClient )
                {
                //
                // It's ok if this is an [out] unique pointer.  It will get
                // zeroed before this routine is called and Ndr64PointerFree
                // will simply return.
                //
                Ndr64pFreeOlePointer( 
                    pStubMsg,
                    pMemory,
                    pFormat );

                // Set the current memory pointer to 0 so that we'll alloc.
                pMemory = 0;
                }

            // Fall through.

        case FC64_UP :
            //
            // Check for a null incomming pointer.  Routines which call this
            // routine insure that the memory pointer gets nulled.
            //
            if ( ! WirePtr )
                {
                *ppMemory = NULL;
                return;
                }

            break;

        case FC64_IP:

            if ( pStubMsg->IsClient )
                {
                Ndr64PointerFree( pStubMsg,
                                pMemory,
                                pFormat );

                pMemory = 0;
                }

            if ( ! WirePtr )
                {
                *ppMemory = NULL;
                return;
                }
           
            *(IUnknown **)ppMemory =  (IUnknown*)
              Ndr64pInterfacePointerUnmarshall( pStubMsg,
                                                pPointerFormat->Pointee
                                                );

            return;


        case FC64_FP :
            {
                //
                // We have to remember the incomming ref id because we overwrite
                // it during the QueryRefId call.
                //
                ulong FullPtrRefId = 
                    Ndr64pWirePtrToRefId( WirePtr );

    			if ( !FullPtrRefId )
    			    {
    				*ppMemory = NULL;
    				return;
    			    }

                //
                // Lookup the ref id.
                //
                if ( Ndr64pFullPointerQueryRefId( pStubMsg,
                                                  FullPtrRefId,
                                                  FULL_POINTER_UNMARSHALLED,
                                                  (void**)ppMemory ) )
                    {
                    return;
                    }

                //
                // If our query returned false then check if the returned pointer
                // is 0.  If so then we have to scribble away the ref id in the
                // stub message FullPtrRefId field so that we can insert the
                // pointer translation later, after we've allocated the pointer.
                // If the returned pointer was non-null then we leave the stub
                // message FullPtrRefId field alone so that we don't try to
                // re-insert the pointer to ref id translation later.
                //
                // We also copy the returned pointer value into pMemory.  This
                // will allow our allocation decision to be made correctly.
                //
                if ( ! ( pMemory = *ppMemory ) )
                    {
                    //
                    // Put the unmarshalled ref id into the stub message to
                    // be used later in a call to Ndr64FullPointerInsertRefId.
                    //
                    pStubMsg->FullPtrRefId = FullPtrRefId;
                    }
            }
            break;

        default :
            NDR_ASSERT(0,"Ndr64pPointerUnmarshall : bad pointer type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    //
    // Make the initial "must allocate" decision.
    //
    // The fPointeeAlloc flag is set on the client side if the current memory
    // pointer is null, and on the server side it is set if the current memory
    // pointer has the allocate don't free attribute applied to it.
    //
    // On the client side we also set the pointer's value in the buffer equal
    // to the current memory pointer.
    //
    // On the server side we explicitly null out the pointer's value in the
    // buffer as long as it's not allocated on the stack, otherwise we set it
    // equal to the current memory pointer (stack allocated).
    //
    if ( pStubMsg->IsClient )
        {
        *ppMemory = pMemory;

        fPointeeAlloc = ! pMemory;
        }
    else
        {
        if ( ! NDR64_ALLOCED_ON_STACK( pPointerFormat->Flags ) )
            *ppMemory = 0;
        else
            *ppMemory = pMemory;

        //
        // If this is a don't free pointer or a parent pointer of this pointer
        // was a don't free pointer then we set the alloc flag.
        //
        if ( fPointeeAlloc = (NDR64_DONT_FREE( pPointerFormat->Flags ) || 
                             pStubMsg->fInDontFree || 
                             pStubMsg->ReuseBuffer ) )
            {
            pStubMsg->fInDontFree = TRUE;
            }

        //
        // We also set the alloc flag for object interface pointers.
        //
        if ( *(PFORMAT_STRING)pFormat == FC64_OP )
            fPointeeAlloc = true;

        }
    //
    // Check if this is an allocate all nodes pointer AND that we're
    // not already in an allocate all nodes context.
    //
    if ( NDR64_ALLOCATE_ALL_NODES( pPointerFormat->Flags ) && ! pStubMsg->pAllocAllNodesContext )
        {
        fNewAllocAllNodes = true;

        pStubMsg->pAllocAllNodesContext =
            Ndr64pGetAllocateAllNodesContext( 
                pStubMsg,
                pPointerFormat->Pointee );
        *ppMemory = 0;

        fPointeeAlloc = true;

        }

    if ( NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
        {
        //
        // Re-align the buffer.  This is to cover embedded pointer to
        // pointers.
        //
        ALIGN(pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );

        //
        // We can't re-use the buffer for a pointer to a pointer
        // because we can't null out the pointee before we've unmarshalled
        // it.  We need the stubs to alloc pointers to pointers on the
        // stack.
        //
        if ( ! *ppMemory && ! pStubMsg->IsClient )
            fPointeeAlloc = true;

        if ( fPointeeAlloc )
            {
            *ppMemory = (uchar*)NdrAllocate( pStubMsg, PTR_MEM_SIZE );
            *((void **)*ppMemory) = 0;
            }

        if ( pStubMsg->FullPtrRefId )
            FULL_POINTER_INSERT( pStubMsg, *ppMemory );

        ppMemory = (uchar **) *ppMemory;
        }
    
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    NDR64_RESET_EMBEDDED_FLAGS_TO_STANDALONE(pStubMsg->uFlags);
    if ( fPointeeAlloc )
        NDR64_SET_SKIP_REF_CHECK( pStubMsg->uFlags );

    PNDR64_FORMAT pPointee = pPointerFormat->Pointee;
    if ( NDR64_IS_SIMPLE_TYPE( *(PFORMAT_STRING)pPointee) )
        {
        ALIGN(pStubMsg->Buffer,NDR64_SIMPLE_TYPE_BUFALIGN(*(PFORMAT_STRING)pPointee) );
    
        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 
                NDR64_SIMPLE_TYPE_BUFSIZE( *(PFORMAT_STRING)pPointee ) );
        
        }
    // we don't need to check for buffer over run here. For non simple types,
    // unmarshal routines have checks available; for pointer to pointer, we have
    // the check at the beginning of this routine; and for pointer to simple types,
    // we'll unmarshal in place, but that's in current pStubMsg->Buffer, which is
    // covered by the above check too. 
    Ndr64TopLevelTypeUnmarshall(
         pStubMsg,
         ppMemory,
         pPointerFormat->Pointee,
         fPointeeAlloc );

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    //
    // Reset the memory allocator and allocate all nodes flag if this was
    // an allocate all nodes case.
    //
    if ( fNewAllocAllNodes )
        {
        pStubMsg->pAllocAllNodesContext = 0;
        }

}

NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT::NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg,
    uchar **            ppMemoryNew,      
    uchar *             pMemoryNew,
    NDR64_PTR_WIRE_TYPE WirePtrNew,
    PFORMAT_STRING      pFormatNew )  :

    WirePtr(WirePtrNew),
    ppMemory(ppMemoryNew),
    pMemory(pMemoryNew),
    pFormat(pFormatNew),
    pCorrMemory(pStubMsg->pCorrMemory),
    pAllocAllNodesContext(pStubMsg->pAllocAllNodesContext),
    fInDontFree(pStubMsg->fInDontFree),
    uFlags(pStubMsg->uFlags)    
{

}

void NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT::Dispatch( PMIDL_STUB_MESSAGE pStubMsg )
{

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pCorrMemory );
    SAVE_CONTEXT<NDR_ALLOC_ALL_NODES_CONTEXT*> 
        AllocNodesSave(pStubMsg->pAllocAllNodesContext,pAllocAllNodesContext ); 
    FINDONTFREE_CONTEXT fInDoneFreeSave( pStubMsg, fInDontFree );
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );

    Ndr64pPointerUnmarshallInternal(
        pStubMsg,
        WirePtr,
        ppMemory,
        pMemory,
        pFormat );

}

#if defined(DBG)
void NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT:\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("WirePtr:                 %I64u\n", WirePtr ); 
    DbgPrint("ppMemory:                %p\n", ppMemory );
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("pCorrMemory:             %p\n", pCorrMemory );
    DbgPrint("pAllocAllNodesContext:   %p\n", pAllocAllNodesContext );
    DbgPrint("fInDontFree:             %u\n", fInDontFree );
    DbgPrint("uFlags:                  %u\n", uFlags );
}
#endif

void
Ndr64pEnquePointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE WirePtr,
    uchar **            ppMemory,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{

    NDR64_POINTER_CONTEXT PointerContext( pStubMsg );

    RpcTryFinally
        {
        NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT*pElement = 
            new(pStubMsg->pPointerQueueState) 
                NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                    ppMemory,
                                                    pMemory,
                                                    WirePtr,
                                                    (PFORMAT_STRING)pFormat );
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
        }
    RpcFinally
        {
        PointerContext.EndContext();
        }
    RpcEndFinally

}

void
Ndr64pPointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE WirePtr,
    uchar **            ppMemory,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{

    if ( !NdrIsLowStack( pStubMsg ) )
        {
        Ndr64pPointerUnmarshallInternal(
            pStubMsg,
            WirePtr,
            ppMemory,
            pMemory,
            pFormat );
        return;
        }

    Ndr64pEnquePointerUnmarshall(
        pStubMsg,
        WirePtr,
        ppMemory,
        pMemory,
        pFormat );

}

__forceinline void
Ndr64EmbeddedPointerUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                /*fSkipRefCheck*/ )
{

    ALIGN( pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );
    NDR64_PTR_WIRE_TYPE WirePtr = *(NDR64_PTR_WIRE_TYPE*) pStubMsg->Buffer;
    pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);

    POINTER_BUFFER_SWAP_CONTEXT SwapContext(pStubMsg);

    Ndr64pPointerUnmarshall( pStubMsg,
                             WirePtr,
                             *(uchar***)ppMemory,
                             **(uchar***)ppMemory,
                             pFormat );
}

__forceinline void
Ndr64TopLevelPointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                /* fSkipRefCheck */)
{
    if ( *(PFORMAT_STRING)pFormat != FC64_RP )
        {
        ALIGN( pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );
        NDR64_PTR_WIRE_TYPE WirePtr = *(NDR64_PTR_WIRE_TYPE*) pStubMsg->Buffer;
        pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);

        Ndr64pPointerUnmarshall( pStubMsg,
                                 WirePtr,
                                 ppMemory,
                                 *ppMemory,
                                 pFormat );
        return;
        }
    
    //
    // If we're on the client unmarshalling a top level [out] ref pointer,
    // we have to make sure that it is non-null.

    if ( pStubMsg->IsClient && 
         !NDR64_IS_SKIP_REF_CHECK( pStubMsg->uFlags ) &&
         ! *ppMemory )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );


    Ndr64pPointerUnmarshall( pStubMsg,
                             0,
                             ppMemory,
                             *ppMemory,
                             pFormat );
}


void 
Ndr64SimpleStructUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine description :

    Unmarshalls a simple structure.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to the structure being unmarshalled.
    pFormat     - Structure's format string description.
    fMustAlloc  - TRUE if the structure must be allocate, FALSE otherwise.

--*/
{
    const NDR64_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_STRUCTURE_HEADER_FORMAT*) pFormat;
    
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    
    // Align the buffer.
    ALIGN(pStubMsg->Buffer, pStructFormat->Alignment);

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, pStructFormat->MemorySize );

    uchar *pBufferSave = pStubMsg->Buffer;

    pStubMsg->Buffer += pStructFormat->MemorySize;

    if ( fMustAlloc )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, pStructFormat->MemorySize );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }
    else if ( !*ppMemory )
        {
        *ppMemory = pBufferSave;
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }

    if ( pStructFormat->Flags.HasPointerInfo )
        {
        
        CORRELATION_CONTEXT CorrCtxt( pStubMsg, pBufferSave ); 
        
        Ndr64pPointerLayoutUnmarshall( pStubMsg,
                                       pStructFormat + 1,
                                       0,
                                       *ppMemory,
                                       pBufferSave );
        }

    // Copy the struct if we're not using the rpc buffer.
    if ( *ppMemory != pBufferSave )
        {
        RpcpMemoryCopy( *ppMemory,
                        pBufferSave,
                        pStructFormat->MemorySize );
        }
}


void 
Ndr64ConformantStructUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine description :

    Unmarshalls a conformant structure.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the structure should be unmarshalled.
    pFormat     - Structure's format string description.
    fMustAlloc  - TRUE if the structure must be allocate, FALSE otherwise.

Return :

    None.

--*/
{
    const NDR64_CONF_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_CONF_STRUCTURE_HEADER_FORMAT*) pFormat;
    
    const NDR64_CONF_ARRAY_HEADER_FORMAT * const pArrayFormat =  
        (NDR64_CONF_ARRAY_HEADER_FORMAT *) pStructFormat->ArrayDescription;

    SAVE_CONTEXT<uchar> uFlagsSave(pStubMsg->uFlags );
    
    NDR64_WIRE_COUNT_TYPE MaxCount;
    if ( !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        // Align the buffer for unmarshalling the conformance count.
        ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN);
        MaxCount = *((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else 
        MaxCount = *((NDR64_WIRE_COUNT_TYPE *)pStubMsg->ConformanceMark);

    // Re-align the buffer
    ALIGN(pStubMsg->Buffer, pStructFormat->Alignment );

    uchar *pBufferStart = pStubMsg->Buffer;

    CHECK_EOB_RAISE_IB( pBufferStart + pStructFormat->MemorySize );

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pBufferStart );
    
    Ndr64pCheckCorrelation( pStubMsg,
                          MaxCount,
                          pArrayFormat->ConfDescriptor,
                          EXPR_MAXCOUNT );
    
    NDR64_UINT32 StructSize = Ndr64pConvertTo2GB( (NDR64_UINT64)pStructFormat->MemorySize +
                                                  ( MaxCount * (NDR64_UINT64)pArrayFormat->ElementSize ) );

    CHECK_EOB_WITH_WRAP_RAISE_IB( pBufferStart, StructSize );

    pStubMsg->Buffer += StructSize;

    if ( fMustAlloc )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, StructSize );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }
    else if ( !*ppMemory )
        {
        *ppMemory = pBufferStart;
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }

    if ( pStructFormat->Flags.HasPointerInfo )
        {
        
        Ndr64pPointerLayoutUnmarshall( pStubMsg,
                                       pStructFormat + 1,
                                       (NDR64_UINT32)MaxCount,
                                       *ppMemory,
                                       pBufferStart );

        }
    
    if ( *ppMemory != pBufferStart )
        {
        RpcpMemoryCopy( *ppMemory,
                        pBufferStart,
                        StructSize );
        }

}


void 
Ndr64ComplexStructUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine description :

    Unmarshalls a complex structure.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the structure should be unmarshalled.
    pFormat     - Structure's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    const NDR64_BOGUS_STRUCTURE_HEADER_FORMAT *  pStructFormat =
        (NDR64_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;
    const NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT * pConfStructFormat =
        (NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;

    bool fSetPointerBufferMark = !pStubMsg->PointerBufferMark;
    if ( fSetPointerBufferMark )
        {
        uchar *pBufferSave = pStubMsg->Buffer;
        BOOL fOldIgnore = pStubMsg->IgnoreEmbeddedPointers;
        pStubMsg->IgnoreEmbeddedPointers = TRUE;
        pStubMsg->MemorySize = 0;

        Ndr64ComplexStructMemorySize( 
            pStubMsg,
            pFormat );

        // check buffer overrun for flat part of the struct.
        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );    
        
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;
        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;
        pStubMsg->Buffer = pBufferSave;

        }

    uchar *         pMemory;
    PFORMAT_STRING  pFormatPointers = (PFORMAT_STRING)pStructFormat->PointerLayout;
    PFORMAT_STRING  pFormatArray    = NULL;

    bool            fIsFullBogus    = ( *(PFORMAT_STRING)pFormat == FC64_BOGUS_STRUCT ||
                                        *(PFORMAT_STRING)pFormat == FC64_CONF_BOGUS_STRUCT );

    PFORMAT_STRING  pMemberLayout =  ( *(PFORMAT_STRING)pFormat == FC64_CONF_BOGUS_STRUCT ||
                                       *(PFORMAT_STRING)pFormat == FC64_FORCED_CONF_BOGUS_STRUCT ) ?
                                     (PFORMAT_STRING)( pConfStructFormat + 1) :
                                     (PFORMAT_STRING)( pStructFormat + 1);

    SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark );
    SAVE_CONTEXT<uchar>  uFlagsSave( pStubMsg->uFlags );
    
    // Get conformant array description.
    if ( pStructFormat->Flags.HasConfArray )
        {
        pFormatArray = (PFORMAT_STRING)pConfStructFormat->ConfArrayDescription;
        }

    //
    // Now check if there is a conformant array and mark where the conformance
    // will be unmarshalled from.
    //

    if ( pFormatArray && !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN);

        pStubMsg->ConformanceMark = pStubMsg->Buffer;

        //
        // Increment the buffer pointer for every dimension in the
        // conformant array.
        //
        pStubMsg->Buffer += pConfStructFormat->Dimensions * sizeof(NDR64_WIRE_COUNT_TYPE);

        NDR64_SET_CONF_MARK_VALID( pStubMsg->uFlags );


        }

    // Align the buffer on the struct's alignment.
    ALIGN( pStubMsg->Buffer, pStructFormat->Alignment );

    bool fMustCopy;
    if ( fMustAlloc || ( fIsFullBogus && ! *ppMemory ) )
        {
        NDR64_UINT32    StructSize =
            Ndr64pMemorySize( pStubMsg,
                              pFormat,
                              TRUE );        

        *ppMemory = (uchar*)NdrAllocate( pStubMsg, StructSize );

        memset( *ppMemory, 0, StructSize );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION( pStubMsg->uFlags );

        fMustCopy = true;

        }
    else if ( ! *ppMemory )
        {
        *ppMemory = pStubMsg->Buffer;
        NDR64_SET_NEW_EMBEDDED_ALLOCATION( pStubMsg->uFlags );
        fMustCopy = false;
        }
    else
		// reuse the clients memory
        fMustCopy = true;

    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    // Get the beginning memory pointer.
    pMemory = *ppMemory;

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );
    
    for ( ; ; )
        {
        switch ( *pMemberLayout )
            {

            case FC64_STRUCT:
                {
                const NDR64_SIMPLE_REGION_FORMAT *pRegion = 
                    (NDR64_SIMPLE_REGION_FORMAT*) pMemberLayout;
                
                ALIGN( pStubMsg->Buffer, pRegion->Alignment );
                
                CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + pRegion->RegionSize );

                if ( fMustCopy )
                    RpcpMemoryCopy( pMemory,
                                    pStubMsg->Buffer,
                                    pRegion->RegionSize );

                pStubMsg->Buffer += pRegion->RegionSize;
                pMemory          += pRegion->RegionSize;

                pMemberLayout    += sizeof( *pRegion );
                break;
                }

            case FC64_STRUCTPADN :
                {
                const NDR64_MEMPAD_FORMAT *pMemPad = (NDR64_MEMPAD_FORMAT*)pMemberLayout;
                pMemory       += pMemPad->MemPad;
                pMemberLayout += sizeof(*pMemPad);
                break;
                }

            case FC64_POINTER :
                {

                Ndr64EmbeddedTypeUnmarshall( pStubMsg,
                                             &pMemory,
                                             pFormatPointers );
                
                pMemory += PTR_MEM_SIZE;

                pFormatPointers += sizeof(NDR64_POINTER_FORMAT);
                pMemberLayout       += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);                
                break;
                
                }

            case FC64_EMBEDDED_COMPLEX :
                {
                
                const NDR64_EMBEDDED_COMPLEX_FORMAT * pEmbeddedFormat =
                    (NDR64_EMBEDDED_COMPLEX_FORMAT*) pMemberLayout;

                Ndr64EmbeddedTypeUnmarshall( pStubMsg,
                                             &pMemory,
                                             pEmbeddedFormat->Type );

                pMemory = Ndr64pMemoryIncrement( pStubMsg,
                                               pMemory,
                                               pEmbeddedFormat->Type,
                                               TRUE );

                pMemberLayout += sizeof(*pEmbeddedFormat);
                break;
                }

            case FC64_BUFFER_ALIGN:
                {
                const NDR64_BUFFER_ALIGN_FORMAT *pBufAlign = 
                    (NDR64_BUFFER_ALIGN_FORMAT*) pMemberLayout;
                ALIGN( pStubMsg->Buffer, pBufAlign->Alignment );
                pMemberLayout += sizeof( *pBufAlign );
                break;
                }

            case FC64_CHAR :
            case FC64_WCHAR :
            case FC64_INT8:
            case FC64_UINT8:
            case FC64_INT16:
            case FC64_UINT16:
            case FC64_INT32:
            case FC64_UINT32:
            case FC64_INT64:
            case FC64_UINT64:
            case FC64_FLOAT32 :
            case FC64_FLOAT64 :
            case FC64_ERROR_STATUS_T:
                Ndr64SimpleTypeUnmarshall( pStubMsg,
                                           pMemory,
                                           *pMemberLayout );

                pMemory += NDR64_SIMPLE_TYPE_MEMSIZE(*pMemberLayout);
                pMemberLayout       += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);                                
                break;                    

            case FC64_IGNORE :
                ALIGN(pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN);
                pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);
                if ( NDR64_IS_NEW_EMBEDDED_ALLOCATION( pStubMsg->uFlags ) ) 
                    {
                    *(char**)pMemory = (char*)0;
                    }
                pMemory          += PTR_MEM_SIZE;
                pMemberLayout    += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);                                
                break;

            case FC64_END :                
                goto ComplexUnmarshallEnd;

            default :
                NDR_ASSERT(0,"Ndr64ComplexStructUnmarshall : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return;
            }
        }

ComplexUnmarshallEnd:

    if ( pFormatArray )
        {

        Ndr64EmbeddedTypeUnmarshall( pStubMsg,
                                     &pMemory,
                                     pFormatArray );

        }
    else 
        {
        // If the structure doesn't have a conformant array, align it again
        ALIGN( pStubMsg->Buffer, pStructFormat->Alignment );
        }

    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer = pStubMsg->PointerBufferMark;
        pStubMsg->PointerBufferMark = 0;
        }

} 

void
Ndr64pCommonStringUnmarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    uchar **                            ppMemory,
    const NDR64_STRING_HEADER_FORMAT    *pStringFormat,
    bool                                fMustAlloc,
    NDR64_UINT32                        MemorySize )
{
    ALIGN(pStubMsg->Buffer,NDR64_WIRE_COUNT_ALIGN);
   
    NDR64_WIRE_COUNT_TYPE  Offset   = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[0];
    NDR64_WIRE_COUNT_TYPE  Count    = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[1];
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_UINT32 TransmittedSize = 
        Ndr64pConvertTo2GB( (NDR64_UINT64)pStringFormat->ElementSize *
                            Count );
    
    if ( ( Offset != 0 ) ||  
         ( 0 == Count ) || 
         ( TransmittedSize > MemorySize ) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, TransmittedSize );

    // In this code, we check that a terminator is 
    // where the marshaller tells us it is.   We could check
    // if another terminator exists in addition to the other 
    // terminator, but it doesn't make sense to do this
    // since it wouldn't close any attacks.

    switch( pStringFormat->FormatCode )
        {
        case FC64_CHAR_STRING:
        case FC64_CONF_CHAR_STRING: 
            {
            char *p = (char *) pStubMsg->Buffer;
            NDR64_WIRE_COUNT_TYPE ActualChars = Count - 1;

            if ( '\0' != p[ActualChars] )
                 {
                 RpcRaiseException( RPC_X_INVALID_BOUND );
                 return;
                 }
            break;            
            }
        case FC64_WCHAR_STRING:
        case FC64_CONF_WCHAR_STRING:            
            {
            wchar_t *p = ( wchar_t* ) pStubMsg->Buffer;
            NDR64_WIRE_COUNT_TYPE ActualChars = Count - 1;
            
            if ( L'\0' != p[ActualChars] )
                {
                RpcRaiseException( RPC_X_INVALID_BOUND );
                return;
                }
            break;            
            }
        case FC64_STRUCT_STRING:
        case FC64_CONF_STRUCT_STRING:
            {
            NDR64_UINT8 *p = (NDR64_UINT8 *) pStubMsg->Buffer;
            NDR64_WIRE_COUNT_TYPE ActualChars = Count - 1;
            NDR64_UINT32 ElementSize = pStringFormat->ElementSize;
            NDR64_UINT8 *t = p + Ndr64pConvertTo2GB( ActualChars * ElementSize );

            if ( !Ndr64pIsStructStringTerminator( t, ElementSize ) )
                {
                RpcRaiseException( RPC_X_INVALID_BOUND );
                return;
                }
            break;
            }
        }
    
    if ( fMustAlloc )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, MemorySize );
        }
    else if ( ! *ppMemory ) 
        {

        *ppMemory = ( TransmittedSize == MemorySize ) ? pStubMsg->Buffer :
                                                        (uchar *) NdrAllocate( pStubMsg, MemorySize );
        }

    if ( *ppMemory != pStubMsg->Buffer )
        {
        RpcpMemoryCopy( *ppMemory,
            pStubMsg->Buffer,
            TransmittedSize );
        }
    
    pStubMsg->Buffer += TransmittedSize;

    return;
}


void 
Ndr64NonConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine description :

    Unmarshalls a non conformant string.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Double pointer to the string should be unmarshalled.
    pFormat     - String's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{

    const NDR64_NON_CONFORMANT_STRING_FORMAT * pStringFormat = 
        (NDR64_NON_CONFORMANT_STRING_FORMAT*) pFormat;

    Ndr64pCommonStringUnmarshall( pStubMsg,
                                  ppMemory,
                                  &pStringFormat->Header,
                                  fMustAlloc,
                                  pStringFormat->TotalSize );


}


void 
Ndr64ConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine description :

    Unmarshalls a top level conformant string.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the string should be unmarshalled.
    pFormat     - String's format string description.
    fMustAlloc  - TRUE if the string must be allocated, FALSE otherwise.

Return :

    None.

--*/
{

    const NDR64_CONFORMANT_STRING_FORMAT * pStringFormat =
        (const NDR64_CONFORMANT_STRING_FORMAT*) pFormat;    
    const NDR64_SIZED_CONFORMANT_STRING_FORMAT *pSizedStringFormat =
        (const NDR64_SIZED_CONFORMANT_STRING_FORMAT*) pFormat;

    NDR64_WIRE_COUNT_TYPE    MaxCount;
    if ( !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );        
        MaxCount =  *((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else
        {
        MaxCount =  *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
        }

    NDR64_UINT32 AllocationSize = 
        Ndr64pConvertTo2GB( MaxCount * 
                            (NDR64_UINT64)pStringFormat->Header.ElementSize );

    if ( pStringFormat->Header.Flags.IsSized )
        {
        Ndr64pCheckCorrelation( pStubMsg,
                                MaxCount,
                                pSizedStringFormat->SizeDescription,
                                EXPR_MAXCOUNT );
        }
    
    return
    Ndr64pCommonStringUnmarshall( pStubMsg,
                                  ppMemory,
                                  &pStringFormat->Header,
                                  fMustAlloc,
                                  AllocationSize );
    
} 


void 
Ndr64FixedArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine Description :

    Unmarshalls a fixed array of any number of dimensions.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to the array to unmarshall.
    pFormat     - Array's format string description.
    fMustAlloc  - TRUE if the array must be allocated, FALSE otherwise.

Return :

    None.

--*/
{
    const NDR64_FIX_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_FIX_ARRAY_HEADER_FORMAT*) pFormat;
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );

    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment );

    uchar *pBufferStart = pStubMsg->Buffer;

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + pArrayFormat->TotalSize );

    pStubMsg->Buffer += pArrayFormat->TotalSize;

    if ( fMustAlloc )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, pArrayFormat->TotalSize );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }
    else if ( !*ppMemory )
        {
        *ppMemory = pBufferStart;
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }
    if ( pArrayFormat->Flags.HasPointerInfo )
        {
        
        Ndr64pPointerLayoutUnmarshall( pStubMsg,
                               pArrayFormat + 1,
                               0,
                               *ppMemory,
                               pBufferStart );
        }

    if ( *ppMemory != pBufferStart )
        {
        RpcpMemoryCopy( *ppMemory,
                        pBufferStart,
                        pArrayFormat->TotalSize );
        }
}


void 
Ndr64ConformantArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine Description :

    Unmarshalls a top level one dimensional conformant array.

    Used for FC64_CARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to array to be unmarshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    const NDR64_CONF_ARRAY_HEADER_FORMAT *pArrayFormat =
        (NDR64_CONF_ARRAY_HEADER_FORMAT*) pFormat;
        
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );

    NDR64_WIRE_COUNT_TYPE MaxCount;
    if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {        
        // Align the buffer for conformance marshalling.
        ALIGN(pStubMsg->Buffer,NDR64_WIRE_COUNT_ALIGN);
        MaxCount = *((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else 
        {
        MaxCount = *pStubMsg->ConformanceMark;
        }

    NDR64_UINT32 CopySize = 
        Ndr64pConvertTo2GB( MaxCount * 
                           (NDR64_UINT64)pArrayFormat->ElementSize );

    Ndr64pCheckCorrelation( pStubMsg,
                            MaxCount,
                            pArrayFormat->ConfDescriptor,
                            EXPR_MAXCOUNT );

    ALIGN( pStubMsg->Buffer, pArrayFormat->Alignment );
    uchar *pBufferStart =  pStubMsg->Buffer;
    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, CopySize);
    pStubMsg->Buffer    += CopySize;    // Unmarshall embedded pointers.

    if ( fMustAlloc )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, CopySize );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }
    else if ( !*ppMemory )
        {
        *ppMemory = pBufferStart;
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }

    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutUnmarshall( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)MaxCount,
                                       *ppMemory,
                                       pBufferStart );
        }

    if ( *ppMemory != pBufferStart )
        {
        RpcpMemoryCopy( *ppMemory,
                        pBufferStart,
                        CopySize );
        }
}


void 
Ndr64ConformantVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )          
/*++

Routine Description :

    Unmarshalls a top level one dimensional conformant varying array.

    Used for FC64_CVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to the array being unmarshalled.
    pFormat     - Array's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    const NDR64_CONF_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_CONF_VAR_ARRAY_HEADER_FORMAT*) pFormat;
    SAVE_CONTEXT<uchar> uFlagsSave(pStubMsg->uFlags);

    NDR64_WIRE_COUNT_TYPE MaxCount;
    if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        // Align the buffer for conformance unmarshalling.
        ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

        MaxCount = *((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);

        }
    else 
        {
        MaxCount = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
        }

    ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );
    NDR64_WIRE_COUNT_TYPE Offset = ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer)[0];
    NDR64_WIRE_COUNT_TYPE ActualCount = ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer)[1];
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_UINT32 AllocSize   = Ndr64pConvertTo2GB( MaxCount * 
                                      (NDR64_UINT64)pArrayFormat->ElementSize );
    NDR64_UINT32 CopySize    = Ndr64pConvertTo2GB( ActualCount *
                                      (NDR64_UINT64)pArrayFormat->ElementSize );

    if ( ( Offset != 0 ) ||
         ActualCount > MaxCount )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    Ndr64pCheckCorrelation( pStubMsg,
                            MaxCount,
                            pArrayFormat->ConfDescriptor,
                            EXPR_MAXCOUNT );

    Ndr64pCheckCorrelation( pStubMsg,
                            ActualCount,
                            pArrayFormat->VarDescriptor,
                            EXPR_ACTUALCOUNT );

    //
    // For a conformant varying array, we can't reuse the buffer
    // because it doesn't hold the total size of the array.

    if ( fMustAlloc || !*ppMemory )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, AllocSize );
        memset( *ppMemory, 0, AllocSize );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }

    ALIGN( pStubMsg->Buffer, pArrayFormat->Alignment );
    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, CopySize);
    
    uchar *pBufferStart =  pStubMsg->Buffer;
    pStubMsg->Buffer += CopySize;
    
    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutUnmarshall( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)ActualCount,
                                       *ppMemory,
                                       pBufferStart );
        }
    
     RpcpMemoryCopy( *ppMemory,
                     pBufferStart,
                     CopySize );
}


void 
Ndr64VaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine Description :

    Unmarshalls top level or embedded a one dimensional varying array.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Array being unmarshalled.
    pFormat     - Array's format string description.
    fMustAlloc  - Ignored.

--*/
{
    
    const NDR64_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_VAR_ARRAY_HEADER_FORMAT*) pFormat;

    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

    NDR64_WIRE_COUNT_TYPE Offset = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[0];
    NDR64_WIRE_COUNT_TYPE ActualCount = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[1];
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_UINT32 CopySize    
        = Ndr64pConvertTo2GB( ActualCount * 
                              (NDR64_UINT64)pArrayFormat->ElementSize );

    if ( ( Offset != 0 ) ||
         ( CopySize > pArrayFormat->TotalSize ) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    Ndr64pCheckCorrelation( pStubMsg,
                          ActualCount,
                          pArrayFormat->VarDescriptor,
                          EXPR_ACTUALCOUNT );

    if ( fMustAlloc || !*ppMemory )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, pArrayFormat->TotalSize );
        memset( *ppMemory, 0, pArrayFormat->TotalSize );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }

    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment );
    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, CopySize );
    uchar *pBufferStart = pStubMsg->Buffer;
    pStubMsg->Buffer += CopySize;

    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutUnmarshall( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)ActualCount,
                                       *ppMemory,
                                       pBufferStart );
        }

    RpcpMemoryCopy( *ppMemory,
                    pBufferStart,
                    CopySize );
}


void 
Ndr64ComplexArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine Description :

    Unmarshalls a top level complex array.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to the array being unmarshalled.
    pFormat     - Array's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    const NDR64_BOGUS_ARRAY_HEADER_FORMAT *pArrayFormat =
        (NDR64_BOGUS_ARRAY_HEADER_FORMAT *) pFormat;
        
    bool fSetPointerBufferMark = ! pStubMsg->PointerBufferMark;
    if ( fSetPointerBufferMark )
        {
        uchar *pBuffer = pStubMsg->Buffer;
        BOOL fOldIgnore = pStubMsg->IgnoreEmbeddedPointers;
        pStubMsg->IgnoreEmbeddedPointers = TRUE;
        pStubMsg->MemorySize = 0;


        Ndr64ComplexArrayMemorySize( 
            pStubMsg,
            pFormat );

        // make sure we haven't overflow for the flat part.
        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );    

        pStubMsg->PointerBufferMark = pStubMsg->Buffer;
        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;
        pStubMsg->Buffer = pBuffer;
        }

    BOOL                IsFixed = ( pArrayFormat->FormatCode == FC64_FIX_BOGUS_ARRAY ) ||
                                  ( pArrayFormat->FormatCode == FC64_FIX_FORCED_BOGUS_ARRAY );

    SAVE_CONTEXT<uchar> uFlagsSave(pStubMsg->uFlags);
    SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark );
    SAVE_CONTEXT<uchar*> VarianceMarkSave( pStubMsg->VarianceMark );

    PFORMAT_STRING      pElementFormat = (PFORMAT_STRING)pArrayFormat->Element;

    NDR64_WIRE_COUNT_TYPE   Elements = pArrayFormat->NumberElements;
    NDR64_WIRE_COUNT_TYPE   Count = Elements;
    NDR64_WIRE_COUNT_TYPE   Offset   = 0;

    if ( !IsFixed )
        {

        const NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT* pConfVarFormat=
             (NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT*)pFormat;

        //
        // Check for conformance description.
        //
        if ( pConfVarFormat->ConfDescription )
            {

            if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
                {
                //
                // Outer most dimension sets the conformance marker.
                //

                // Align the buffer for conformance marshalling.
                ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN);

                // Mark where the conformance count(s) will be marshalled.
                pStubMsg->ConformanceMark = pStubMsg->Buffer;

                // Increment past where the conformance will go.
                pStubMsg->Buffer += pArrayFormat->NumberDims * sizeof(NDR64_WIRE_COUNT_TYPE);

                NDR64_SET_CONF_MARK_VALID( pStubMsg->uFlags );

                }

            Elements = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
            pStubMsg->ConformanceMark += sizeof(NDR64_WIRE_COUNT_TYPE);

            Ndr64pCheckCorrelation( pStubMsg,
                                   Elements,
                                   pConfVarFormat->ConfDescription,
                                   EXPR_MAXCOUNT );

            Offset = 0;
            Count  = Elements;

            }

        //
        // Check for variance description.
        //
        if ( pConfVarFormat->VarDescription )
            {
            if ( ! NDR64_IS_VAR_MARK_VALID( pStubMsg->uFlags ) )
                {
                NDR64_UINT32 Dimensions;

                ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

                Dimensions = ( pArrayFormat->Flags.IsArrayofStrings ) ? ( pArrayFormat->NumberDims - 1) :
                                                                        ( pArrayFormat->NumberDims );

                pStubMsg->VarianceMark = pStubMsg->Buffer;

                pStubMsg->Buffer += Dimensions * sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

                if ( NDR64_IS_ARRAY_OR_STRING( *pElementFormat ) )
                    NDR64_SET_VAR_MARK_VALID( pStubMsg->uFlags );
                
                }
            else if ( !NDR64_IS_ARRAY_OR_STRING( *pElementFormat ) )
                NDR64_RESET_VAR_MARK_VALID( pStubMsg->uFlags );

            Offset = ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->VarianceMark)[0];
            Count  = ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->VarianceMark)[1];
            pStubMsg->VarianceMark += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

            Ndr64pCheckCorrelation( pStubMsg,
                                    Count,
                                    pConfVarFormat->VarDescription,
                                    EXPR_ACTUALCOUNT );

            Ndr64pCheckCorrelation( pStubMsg,
                                    Offset,
                                    pConfVarFormat->OffsetDescription,
                                    EXPR_OFFSET );

            }
        
        }

    NDR64_UINT32 ElementMemorySize =
        Ndr64pMemorySize( pStubMsg,
                          pElementFormat,
                          TRUE );

    NDR64_UINT32 ArraySize = Ndr64pConvertTo2GB( Elements *
                                                 (NDR64_UINT64)ElementMemorySize );
    Ndr64pConvertTo2GB( Count *
                        (NDR64_UINT64)ElementMemorySize );


    if ( fMustAlloc || ! *ppMemory )
        {
        *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) ArraySize );
        memset( *ppMemory, 0, ArraySize );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }

    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    uchar *pMemory = *ppMemory;

    pMemory += Ndr64pConvertTo2GB(Offset * 
                                  (NDR64_UINT64)ElementMemorySize);
    
    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment);

    for( ; Count--; )
        {
        
        Ndr64EmbeddedTypeUnmarshall( pStubMsg,
                                     &pMemory,
                                     pElementFormat );
        
        pMemory += ElementMemorySize;

        }

     if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer = pStubMsg->PointerBufferMark;
        pStubMsg->PointerBufferMark = 0;
        }

}


void 
Ndr64UnionUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine Description :

    Unmarshalls an encapsulated array.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the union should be unmarshalled.
    pFormat     - Union's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    const NDR64_UNION_ARM_SELECTOR* pArmSelector;
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );

    EXPR_VALUE          SwitchIs;
    uchar*              pArmMemory;

    switch(*(PFORMAT_STRING)pFormat)
    {
    case FC64_NON_ENCAPSULATED_UNION:
        {
        const NDR64_NON_ENCAPSULATED_UNION* pNonEncapUnionFormat =
            (const NDR64_NON_ENCAPSULATED_UNION*) pFormat;


        ALIGN(pStubMsg->Buffer, pNonEncapUnionFormat->Alignment);
        pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pNonEncapUnionFormat + 1);

        if ( fMustAlloc || ! *ppMemory )
            {
            *ppMemory = (uchar*)NdrAllocate( pStubMsg, pNonEncapUnionFormat->MemorySize );

            //
            // We must zero out all of the new memory in case there are pointers
            // in any of the arms.
            //
            MIDL_memset( *ppMemory, 0, pNonEncapUnionFormat->MemorySize );
            NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);

            }

        SwitchIs = Ndr64pSimpleTypeToExprValue( pNonEncapUnionFormat->SwitchType,
                                                pStubMsg->Buffer );

        pStubMsg->Buffer += NDR64_SIMPLE_TYPE_BUFSIZE( pNonEncapUnionFormat->SwitchType );
        
        Ndr64pCheckCorrelation( pStubMsg,
                                SwitchIs,
                                pNonEncapUnionFormat->Switch,
                                EXPR_SWITCHIS );

        pArmMemory = *ppMemory;

        break;
        }
    case FC64_ENCAPSULATED_UNION:
        {
        const NDR64_ENCAPSULATED_UNION* pEncapUnionFormat =
           (const NDR64_ENCAPSULATED_UNION*)pFormat;

        ALIGN(pStubMsg->Buffer, pEncapUnionFormat->Alignment);
        pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pEncapUnionFormat + 1);
        
        if ( fMustAlloc || ! *ppMemory )
             {
             *ppMemory = (uchar*)NdrAllocate( pStubMsg, pEncapUnionFormat->MemorySize );

             //
             // We must zero out all of the new memory in case there are pointers
             // in any of the arms.
             //
             MIDL_memset( *ppMemory, 0, pEncapUnionFormat->MemorySize );
             NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
             }

        SwitchIs = Ndr64pSimpleTypeToExprValue( pEncapUnionFormat->SwitchType,
                                                pStubMsg->Buffer );

        Ndr64SimpleTypeUnmarshall( pStubMsg,
                                   *ppMemory,
                                   pEncapUnionFormat->SwitchType );

        pArmMemory = *ppMemory + pEncapUnionFormat->MemoryOffset;

        break;
        }

        default:
            NDR_ASSERT("Bad union format\n", 0);
            return;
        }
    
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );


    ALIGN(pStubMsg->Buffer, pArmSelector->Alignment);

    PNDR64_FORMAT pArmFormat = 
        Ndr64pFindUnionArm( pStubMsg,
                            pArmSelector,
                            SwitchIs );

    // check we aren't EOB after unmarshalling arm selector
    // we won't corrupt memory as there is no in place unmarshall here.
    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );    


    if ( pArmFormat )
        {
        Ndr64EmbeddedTypeUnmarshall( pStubMsg,
                                     &pArmMemory,
                                     pArmFormat );
        }
}


void  
Ndr64XmitOrRepAsUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                /*fMustAlloc*/,
    bool                bIsEmbedded )
/*++

Routine Description :

    Unmarshalls a transmit as (or represent as)object.

    Means:  allocate the transmitted object,
            unmarshall transmitted object,
            translate the transmitted into presented
            free the transmitted.

    See mrshl.c for the description of the FC layout.

Arguments :

    pStubMsg    - a pointer to the stub message
    ppMemory    - pointer to the presented type where to put data
    pFormat     - format string description
    fMustAlloc  - allocate flag

Note.
    fMustAlloc is ignored as we always allocate outside of the buffer.

--*/
{
    unsigned char  *         pPresentedType = *ppMemory;

    const XMIT_ROUTINE_QUINTUPLE * pQuintuple = pStubMsg->StubDesc->aXmitQuintuple;
    
    NDR64_TRANSMIT_AS_FORMAT    *pTransFormat = 
        ( NDR64_TRANSMIT_AS_FORMAT *) pFormat;
    NDR_ASSERT( pTransFormat->FormatCode == FC64_TRANSMIT_AS || pTransFormat->FormatCode , "invalid format string for user marshal" );

    unsigned short QIndex = pTransFormat->RoutineIndex;
    unsigned long  PresentedTypeSize = pTransFormat->PresentedTypeMemorySize;

    if ( ! pPresentedType )
        {        
        pPresentedType = (uchar*)NdrAllocate( pStubMsg, (uint) PresentedTypeSize );
        MIDL_memset( pPresentedType, 0, (uint) PresentedTypeSize );
        }

    // Allocate the transmitted object outside of the buffer
    // and unmarshall into it

    if ( NDR64_IS_SIMPLE_TYPE( *(PFORMAT_STRING)pTransFormat->TransmittedType ))
        {
        __int64 SimpleTypeValueBuffer[2];
        unsigned char * pTransmittedType = (unsigned char *)SimpleTypeValueBuffer;
        
        Ndr64SimpleTypeUnmarshall( pStubMsg,
                                 pTransmittedType,
                                *(PFORMAT_STRING)pTransFormat->TransmittedType );
        
        // Translate from the transmitted type into the presented type.

        pStubMsg->pTransmitType = pTransmittedType;
        pStubMsg->pPresentedType = pPresentedType;

        pQuintuple[ QIndex ].pfnTranslateFromXmit( pStubMsg );

        *ppMemory = pStubMsg->pPresentedType;
        }
    else
        {

        // Save the current state of the memory list so that the temporary
        // memory allocated for the transmitted type can be easily removed
        // from the list.   This assumes that the memory allocated here 
        // will not have any linkes to other blocks of memory.   This is true
        // as long as full pointers are not used.  Fortunatly, full pointers
        // do not work correctly in the current code.
   
        void *pMemoryListSave = pStubMsg->pMemoryList;        

        unsigned char *pTransmittedType = NULL;  // asking the engine to allocate

        // In NDR64, Xmit/Rep cannot be a pointer or contain a pointer.
        // So we don't need to worry about the pointer queue here.

        if ( bIsEmbedded )
            {
            Ndr64EmbeddedTypeUnmarshall( pStubMsg,
                                         &pTransmittedType,
                                         pTransFormat->TransmittedType );
            }
        else
            {
            Ndr64TopLevelTypeUnmarshall( pStubMsg,
                                         &pTransmittedType,
                                         pTransFormat->TransmittedType,
                                         TRUE );
            }

        // Translate from the transmitted type into the presented type.
    
        pStubMsg->pTransmitType = pTransmittedType;
        pStubMsg->pPresentedType = pPresentedType;
    
        pQuintuple[ QIndex ].pfnTranslateFromXmit( pStubMsg );
    
        *ppMemory = pStubMsg->pPresentedType;

        // Free the transmitted object (it was allocated by the engine)
        // and its pointees. The call through the table frees the pointees
        // only (plus it'd free the object itself if it were a pointer).
        // As the transmitted type is not a pointer here, we need to free it
        // explicitely later.

        // Remove the memory that will be freed from the allocated memory
        // list by restoring the memory list pointer.
        // If an exception occures during one of these free routines, we 
        // are in trouble anyway.
        
        pStubMsg->pMemoryList = pMemoryListSave;        

        if ( bIsEmbedded )
            {
            Ndr64EmbeddedTypeFree( pStubMsg,
                                   pTransmittedType,
                                   pTransFormat->TransmittedType );
            }
        else
            {
            Ndr64ToplevelTypeFree( pStubMsg,
                                   pTransmittedType,
                                   pTransFormat->TransmittedType );
            }

        // The buffer reusage check.

        if ( pTransmittedType < pStubMsg->BufferStart  ||
             pTransmittedType > pStubMsg->BufferEnd )
            (*pStubMsg->pfnFree)( pTransmittedType );

        }
}

void 
Ndr64TopLevelXmitOrRepAsUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
{
    Ndr64XmitOrRepAsUnmarshall( pStubMsg,
                                ppMemory,
                                pFormat,
                                fMustAlloc,
                                false );
}

void 
Ndr64EmbeddedXmitOrRepAsUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
{
    Ndr64XmitOrRepAsUnmarshall( pStubMsg,
                                ppMemory,
                                pFormat,
                                fMustAlloc,
                                true );
}

void
Ndr64UserMarshallUnmarshallInternal(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    NDR64_USER_MARSHAL_FORMAT  *pUserFormat =
        ( NDR64_USER_MARSHAL_FORMAT *) pFormat;

    unsigned char * pUserBuffer = pStubMsg->Buffer;
    unsigned char * pUserBufferSaved = pUserBuffer;

    USER_MARSHAL_CB UserMarshalCB;
    Ndr64pInitUserMarshalCB( pStubMsg,
                           pUserFormat,
                           USER_MARSHAL_CB_UNMARSHALL, 
                           & UserMarshalCB );

    unsigned short QIndex = pUserFormat->RoutineIndex;
    const USER_MARSHAL_ROUTINE_QUADRUPLE * pQuadruple = (const USER_MARSHAL_ROUTINE_QUADRUPLE * )
                 (  ( NDR_PROC_CONTEXT *)pStubMsg->pContext )->pSyntaxInfo->aUserMarshalQuadruple;

    if ((pUserBufferSaved < (uchar *) pStubMsg->RpcMsg->Buffer) ||
        ((unsigned long) (pUserBufferSaved - (uchar *) pStubMsg->RpcMsg->Buffer) 
                                           > pStubMsg->RpcMsg->BufferLength)) 
        {
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        }

    pUserBuffer = pQuadruple[ QIndex ].pfnUnmarshall( (ulong*) &UserMarshalCB,
                                                      pUserBuffer,
                                                      pMemory );

    if ((pUserBufferSaved > pUserBuffer) || 
        ((unsigned long) (pUserBuffer - (uchar *) pStubMsg->RpcMsg->Buffer)
                                      > pStubMsg->RpcMsg->BufferLength )) 
        {
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        }

    // Step over the pointee.

    pStubMsg->Buffer = pUserBuffer;

}

void 
NDR64_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT::Dispatch(MIDL_STUB_MESSAGE *pStubMsg)
{
    
    Ndr64UserMarshallUnmarshallInternal( pStubMsg,
                                         pMemory,
                                         pFormat );
}

#if defined(DBG)
void 
NDR64_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR64_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
}
#endif

void
Ndr64UserMarshallPointeeUnmarshall( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{

    if ( !pStubMsg->pPointerQueueState ||
         !pStubMsg->pPointerQueueState->GetActiveQueue() )
        {
        POINTER_BUFFER_SWAP_CONTEXT SwapContext(pStubMsg);
        Ndr64UserMarshallUnmarshallInternal( 
            pStubMsg,
            pMemory,
            pFormat );
        return;
        }

    NDR64_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT*pElement = 
       new(pStubMsg->pPointerQueueState) 
           NDR64_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT(pMemory,
                                                         (PFORMAT_STRING)pFormat );
    pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );
}



void  
Ndr64UserMarshalUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc,
    bool                bIsEmbedded )
/*++

Routine Description :

    Unmarshals a user_marshal object.
    The layout is described in marshalling.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to pointer to the usr_marshall object to unmarshall.
    pFormat     - Object's format string description.

Return :

    None.

--*/
{
    NDR64_USER_MARSHAL_FORMAT  *pUserFormat =
        ( NDR64_USER_MARSHAL_FORMAT *) pFormat;

    NDR_ASSERT( pUserFormat->FormatCode == FC64_USER_MARSHAL, "invalid format string for user marshal" );

    // Align for the object or a pointer to it.

    ALIGN( pStubMsg->Buffer, pUserFormat->TransmittedTypeWireAlignment );

    // Take care of the pointer, if any.
    NDR64_PTR_WIRE_TYPE                     PointerMarker;
    if ( ( pUserFormat->Flags & USER_MARSHAL_UNIQUE)  ||
         (( pUserFormat->Flags & USER_MARSHAL_REF) && bIsEmbedded) )
        {
        PointerMarker = *((NDR64_PTR_WIRE_TYPE *)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);
        }

    // We always call user's routine to unmarshall the user object.

    // However, the top level object is allocated by the engine.
    // Thus, the behavior is exactly the same as for represent_as(),
    // with regard to the top level presented type.

    if ( *ppMemory == NULL )
        {
        // Allocate a presented type object first.

        uint MemSize = pUserFormat->UserTypeMemorySize;

        *ppMemory = (uchar *) NdrAllocate( pStubMsg, MemSize );

        MIDL_memset( *ppMemory, 0, MemSize );
        }

    if ( ( pUserFormat->Flags & USER_MARSHAL_UNIQUE)  &&  (0 == PointerMarker ))
       {
       // The user type is a unique pointer, and it is 0. So, we are done.

       return;
       }

    if ( pUserFormat->Flags & USER_MARSHAL_POINTER )
        {
        Ndr64UserMarshallPointeeUnmarshall( pStubMsg,
                                            *ppMemory,
                                            pFormat );
        return;
        }

    Ndr64UserMarshallUnmarshallInternal( pStubMsg,
                                         *ppMemory,
                                         pFormat );
}


void 
Ndr64TopLevelUserMarshalUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
{
    Ndr64UserMarshalUnmarshall( pStubMsg,
                                ppMemory,
                                pFormat,
                                fMustAlloc,
                                false );
}

void
Ndr64EmbeddedUserMarshalUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
{
    Ndr64UserMarshalUnmarshall( pStubMsg,
                                ppMemory,
                                pFormat,
                                fMustAlloc,
                                true );
}


void 
Ndr64ClientContextUnmarshall(
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_CCONTEXT *        pContextHandle,
    RPC_BINDING_HANDLE    BindHandle )
/*++

Routine Description :

    Unmarshalls a context handle on the client side.

Arguments :

    pStubMsg        - Pointer to stub message.
    pContextHandle  - Pointer to context handle to unmarshall.
    BindHandle      - The handle value used by the client for binding.

Return :

    None.

--*/
{
    // Note, this is a routine called directly from -Os stubs.
    // The routine called by interpreter is called Ndr64UnmarshallHandle
    // and can be found in hndl.c

    ALIGN(pStubMsg->Buffer,3);

    // All 20 bytes of the buffer are touched so a check is not needed here.
    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + CONTEXT_HANDLE_WIRE_SIZE );    

    NDRCContextUnmarshall( pContextHandle,
                           BindHandle,
                           pStubMsg->Buffer,
                           pStubMsg->RpcMsg->DataRepresentation );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;
}

NDR_SCONTEXT 
Ndr64ServerContextUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg )
/*++

Routine Description :

    Unmarshalls a context handle on the server side.

Arguments :

    pStubMsg    - Pointer to stub message.

Return :

    The unmarshalled context handle.

--*/
{
    // Note, this is a routine called directly from -Os stubs.
    // The routine called by interpreter is called Ndr64UnmarshallHandle
    // and can be found in hndl.c

    NDR_SCONTEXT    Context;

    ALIGN(pStubMsg->Buffer,3);

    // All 20 bytes of the buffer are touched so a check is not needed here.
    // we could corrupt memory if it's out of bound
    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + CONTEXT_HANDLE_WIRE_SIZE );    

    Context = NDRSContextUnmarshall2(pStubMsg->RpcMsg->Handle,
                                     pStubMsg->Buffer,
                                     pStubMsg->RpcMsg->DataRepresentation,
                                     RPC_CONTEXT_HANDLE_DEFAULT_GUARD,
                                     RPC_CONTEXT_HANDLE_DEFAULT_FLAGS );

    if ( ! Context )
        RpcRaiseException( RPC_X_SS_CONTEXT_MISMATCH );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;

    return Context;
}

NDR_SCONTEXT  
Ndr64ContextHandleInitialize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*
    This routine is to initialize a context handle with a new NT5 flavor.
    It is used in conjunction with Ndr64ContextHandleUnmarshal.
*/
{
    NDR_SCONTEXT    SContext;
    void *          pGuard = RPC_CONTEXT_HANDLE_DEFAULT_GUARD;
    DWORD           Flags  = RPC_CONTEXT_HANDLE_DEFAULT_FLAGS;
    NDR64_CONTEXT_HANDLE_FORMAT * pContextFormat;

    pContextFormat = ( NDR64_CONTEXT_HANDLE_FORMAT * )pFormat;
    NDR_ASSERT( pContextFormat->FormatCode == FC64_BIND_CONTEXT, "invalid format char " );

    // NT5 beta2 features: strict context handle, serialize and noserialize.

    if ( pContextFormat->ContextFlags & NDR_STRICT_CONTEXT_HANDLE )
        {
        pGuard = pStubMsg->StubDesc->RpcInterfaceInformation;
        pGuard = & ((PRPC_SERVER_INTERFACE)pGuard)->InterfaceId;
        }
    if ( pContextFormat->ContextFlags & NDR_CONTEXT_HANDLE_NOSERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_DONT_SERIALIZE;
        }
    else if ( pContextFormat->ContextFlags & NDR_CONTEXT_HANDLE_SERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_SERIALIZE;
        }

    SContext = NDRSContextUnmarshall2(
                    pStubMsg->RpcMsg->Handle,
                    (void *)0,  // buffer
                    pStubMsg->RpcMsg->DataRepresentation,
                    pGuard,
                    Flags );

    return SContext;
}

NDR_SCONTEXT 
Ndr64ServerContextNewUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*
    This routine to unmarshal a context handle with a new NT5 flavor.
    For the old style handles, we call an optimized routine
    Ndr64ServerContextUnmarshall below.
    Interpreter calls Ndr64UnmarshallHandle from hndl.c

      ppMemory - note, this is not a pointer to user's context handle but
                 a pointer to NDR_SCONTEXT pointer to the runtime internal object.
                 User's handle is a field of that object.
*/
{
    void *          pGuard = RPC_CONTEXT_HANDLE_DEFAULT_GUARD;
    DWORD           Flags  = RPC_CONTEXT_HANDLE_DEFAULT_FLAGS;

    NDR64_CONTEXT_HANDLE_FORMAT *pContextFormat = ( NDR64_CONTEXT_HANDLE_FORMAT * )pFormat;
    NDR_ASSERT( pContextFormat->FormatCode == FC64_BIND_CONTEXT, "invalid format char " );

    // Anti-attack defense for servers, NT5 beta3 feature.

    if ( pContextFormat->ContextFlags & NDR_CONTEXT_HANDLE_CANNOT_BE_NULL )
        {
        // Check the incoming context handle on the server.
        // Context handle wire layout: ulong with version (always 0), then a uuid.
        //
        if ( !pStubMsg->IsClient  &&  0 == memcmp( pStubMsg->Buffer + 4,
                                                   &GUID_NULL,
                                                   sizeof(GUID) ) )
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

    // NT5 beta2 features: strict context handle, serialize and noserialize.

    if ( pContextFormat->ContextFlags & NDR_STRICT_CONTEXT_HANDLE )
        {
        pGuard = pStubMsg->StubDesc->RpcInterfaceInformation;
        pGuard = & ((PRPC_SERVER_INTERFACE)pGuard)->InterfaceId;
        }
    if ( pContextFormat->ContextFlags & NDR_CONTEXT_HANDLE_NOSERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_DONT_SERIALIZE;
        }
    else if ( pContextFormat->ContextFlags & NDR_CONTEXT_HANDLE_SERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_SERIALIZE;
        }

    ALIGN( pStubMsg->Buffer, 0x3 );
    // All 20 bytes of the buffer are touched so a check is not needed here.

    NDR_SCONTEXT SContext = 
        NDRSContextUnmarshall2(
                    pStubMsg->RpcMsg->Handle,
                    pStubMsg->Buffer,
                    pStubMsg->RpcMsg->DataRepresentation,
                    pGuard,
                    Flags );

    if ( ! SContext )
        RpcRaiseException( RPC_X_SS_CONTEXT_MISMATCH );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;

    return SContext;
}

// define the jump table
#define NDR64_BEGIN_TABLE  \
PNDR64_UNMARSHALL_ROUTINE extern const Ndr64UnmarshallRoutinesTable[] = \
{                                                          

#define NDR64_TABLE_END    \
};                         

#define NDR64_ZERO_ENTRY   NULL
#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) ,NULL
#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number ) ,NULL

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,unmarshall                      

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, buffersize, memorysize) \
   ,Ndr64UDTSimpleTypeUnmarshall1   
   
#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64UnmarshallRoutinesTable)/sizeof(PNDR64_UNMARSHALL_ROUTINE) == 256 );

#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_ENTRY

#define NDR64_BEGIN_TABLE  \
PNDR64_UNMARSHALL_ROUTINE extern const Ndr64EmbeddedUnmarshallRoutinesTable[] = \
{

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,embeddedunmarshall
   
#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64EmbeddedUnmarshallRoutinesTable)/sizeof(PNDR64_UNMARSHALL_ROUTINE) == 256 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\relmrl.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1998 - 2000 Microsoft Corporation

Module Name :

    relmrl.c

Abstract :

    This file contains release of Marshaled Data (called before unmarshal).

Author :

    Yong Qu (yongqu@microsoft.com) Nov 1998

Revision History :

  ---------------------------------------------------------------------*/

#include "precomp.hxx"

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include "ndrole.h"
#include "rpcproxy.h"
#include "hndl.h"
#include "interp2.h"
#include "pipendr.h"
#include "expr.h"

#include <stddef.h>
#include <stdarg.h>


/* client side: we only care about the [in] part. 
   it's basically like unmarshal on the server side, just that
   we immediately free the buffer (virtual stack) after unmarshalling.
   The call it not necessary always OLE call: one side raw RPC and 
   the other side OLE call is possible: do we support this?

   mostly code from NdrStubCall2, remove irrelavant code. 
*/

#define IN_BUFFER           0
#define OUT_BUFFER          1

#define IsSameDir(dwFlags,paramflag) ((dwFlags == IN_BUFFER)? paramflag->IsIn :paramflag->IsOut)

HRESULT Ndr64pReleaseMarshalBuffer(
        RPC_MESSAGE *               pRpcMsg,
        PMIDL_SYNTAX_INFO           pSyntaxInfo, 
        unsigned long               ProcNum, 
        PMIDL_STUB_DESC             pStubDesc,
        DWORD                       dwFlags,
        BOOLEAN fServer )
{
    ushort		            StackSize;
    MIDL_STUB_MESSAGE       StubMsg;

    NDR64_PARAM_FORMAT *    Params;
    long                    NumberParams;

    long                    n;
    HRESULT                 hr = S_OK;

    uchar *             pBuffer;
    PFORMAT_STRING      pFormatTypes;
    long		        FormatOffset;
    PFORMAT_STRING	    pFormat;
    NDR_PROC_CONTEXT    ProcContext;
    NDR64_PROC_FLAGS    *   pNdr64Flags;
    NDR64_PROC_FORMAT   *   pHeader = NULL;
    NDR64_PARAM_FLAGS   *       pParamFlags;

    
    NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned at server" );

    pFormat      = NdrpGetProcString( pSyntaxInfo,
                                      XFER_SYNTAX_NDR64,
                                      ProcNum );

    Ndr64ServerInitialize(pRpcMsg,&StubMsg,pStubDesc);
    StubMsg.fHasExtensions  = 1;
    StubMsg.fHasNewCorrDesc = 1;
    pFormatTypes = pSyntaxInfo->TypeString;

    pHeader = (NDR64_PROC_FORMAT *) pFormat;
    pNdr64Flags = (NDR64_PROC_FLAGS *) & (pHeader->Flags );

    NumberParams = pHeader->NumberOfParams;

    if ( pNdr64Flags->UsesFullPtrPackage )
        StubMsg.FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );
    
    Params = (NDR64_PARAM_FORMAT *)( (char *) pFormat + sizeof( NDR64_PROC_FORMAT ) + pHeader->ExtensionSize );

    // Save the original buffer pointer to restore later.
    pBuffer = StubMsg.Buffer;

    // Get the type format string.
    RpcTryFinally
    {
    
        RpcTryExcept
        {
        //
        // Check if we need to do any walking .
        //

        NDR64_SET_WALKIP(StubMsg.uFlags);
                   
        for ( n = 0; n < NumberParams; n++ )
            {
            pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
            
            if ( ( dwFlags == IN_BUFFER ) &&
                 ( pParamFlags->IsPartialIgnore ) )
                {
                PMIDL_STUB_MESSAGE pStubMsg = &StubMsg;
                // Skip the boolean pointer in the buffer
                ALIGN( StubMsg.Buffer, NDR64_PTR_WIRE_ALIGN );
                StubMsg.Buffer += sizeof(NDR64_PTR_WIRE_TYPE);
                CHECK_EOB_RAISE_BSD( StubMsg.Buffer );
                continue;
                } 

            if ( ! IsSameDir(dwFlags,pParamFlags) )
                continue;
                    
            if ( pParamFlags->IsBasetype )
                {
                NDR64_FORMAT_CHAR type = *(PFORMAT_STRING)Params[n].Type;

                ALIGN( StubMsg.Buffer, NDR64_SIMPLE_TYPE_BUFALIGN( type ) );
                StubMsg.Buffer += NDR64_SIMPLE_TYPE_BUFSIZE( type );
                }
            else
                {
                //
                // Complex type or pointer to complex type.
                //   

                Ndr64TopLevelTypeMemorySize( &StubMsg,
                                             Params[n].Type );
                }
            
            }
        }
        RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        {
             hr = HRESULT_FROM_WIN32(RpcExceptionCode());
        }
        RpcEndExcept

    }
    RpcFinally
    {
        NdrFullPointerXlatFree( StubMsg.FullPtrXlatTables );
        
        StubMsg.Buffer = pBuffer;
    }
    RpcEndFinally
    
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\srvwrap.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    srvwrap.c

Abstract :

    This file contains the function to dispatch calls to stub worker. 

Author :

    Yong Qu     yongqu      Feb 2000        created
    
Revision History :

  ---------------------------------------------------------------------*/

#include "precomp.hxx"

#define CINTERFACE
#define USE_STUBLESS_PROXY

#include "ndrole.h"
#include "rpcproxy.h"
#include "interp2.h"

#include <stdarg.h>

extern long RPC_ENTRY
Ndr64StubWorker(
    IRpcStubBuffer *     pThis,
    IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE         pRpcMsg,
    MIDL_SERVER_INFO   * pServerInfo,
    const SERVER_ROUTINE *     DispatchTable,
    MIDL_SYNTAX_INFO *   pSyntaxInfo,  
    ulong *              pdwStubPhase
    );

RPCRTAPI
void RPC_ENTRY
NdrServerCallNdr64(
    PRPC_MESSAGE    pRpcMsg
    )
/*++

Routine Description :

    Server Interpreter entry point for regular RPC procs.

Arguments :

    pRpcMsg     - The RPC message.

Return :

    None.

--*/
{
    ulong dwStubPhase = STUB_UNMARSHAL;
    PRPC_SERVER_INTERFACE   pServerIfInfo;
    PMIDL_SERVER_INFO       pServerInfo;
    const SERVER_ROUTINE  * DispatchTable;
    NDR_PROC_CONTEXT        ProcContext;   
    MIDL_SYNTAX_INFO *      pSyntaxInfo;
    
    pServerIfInfo = (PRPC_SERVER_INTERFACE)pRpcMsg->RpcInterfaceInformation;
    pServerInfo = (PMIDL_SERVER_INFO)pServerIfInfo->InterpreterInfo;
    DispatchTable = pServerInfo->DispatchTable;
    pSyntaxInfo = &pServerInfo->pSyntaxInfo[0];

    NDR_ASSERT( XFER_SYNTAX_NDR64 == NdrpGetSyntaxType(&pSyntaxInfo->TransferSyntax),
                " invalid transfer syntax" );
                
    Ndr64StubWorker( 0,
                     0,
                     pRpcMsg,
                     pServerInfo,
                     DispatchTable,
                     pSyntaxInfo,
                     &dwStubPhase );
}

RPCRTAPI
void RPC_ENTRY
NdrServerCallAll(
    PRPC_MESSAGE    pRpcMsg
    )
{
    ulong dwStubPhase = STUB_UNMARSHAL;
    PRPC_SERVER_INTERFACE   pServerIfInfo;
    PMIDL_SERVER_INFO       pServerInfo;
    const SERVER_ROUTINE  * DispatchTable;
    NDR_PROC_CONTEXT        ProcContext;   
    MIDL_SYNTAX_INFO *      pSyntaxInfo;

    pServerIfInfo = (PRPC_SERVER_INTERFACE)pRpcMsg->RpcInterfaceInformation;
    pServerInfo = (PMIDL_SERVER_INFO)pServerIfInfo->InterpreterInfo;
    DispatchTable = pServerInfo->DispatchTable;
    // assuming the default transfer syntax is DCE, NDR64 is the second syntaxinfo.
    pSyntaxInfo = &pServerInfo->pSyntaxInfo[1];

    NDR_ASSERT( XFER_SYNTAX_NDR64 == NdrpGetSyntaxType(&pSyntaxInfo->TransferSyntax),
                " invalid transfer syntax" );
    
    Ndr64StubWorker( 0,
                     0,
                     pRpcMsg,
                     pServerInfo,
                     DispatchTable,
                     pSyntaxInfo,
                     &dwStubPhase );
    
}


long RPC_ENTRY
NdrStubCall3(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    ulong *                     pdwStubPhase
    )
{
    IUnknown *              pSrvObj;
    CInterfaceStubVtbl *    pStubVTable;
    PMIDL_SERVER_INFO       pServerInfo;
    const SERVER_ROUTINE  * DispatchTable;
    SYNTAX_TYPE             SyntaxType;
    long                    i;
    MIDL_SYNTAX_INFO *      pSyntaxInfo = NULL;

    if ( NULL == pRpcMsg->TransferSyntax ||
         NdrpGetSyntaxType( pRpcMsg->TransferSyntax ) == XFER_SYNTAX_DCE )
        return NdrStubCall2( pThis, pChannel, pRpcMsg, pdwStubPhase );
        
    pSrvObj = (IUnknown * )((CStdStubBuffer *)pThis)->pvServerObject;

    DispatchTable = (SERVER_ROUTINE *)pSrvObj->lpVtbl;

    pStubVTable = (CInterfaceStubVtbl *)
                  (*((uchar **)pThis) - sizeof(CInterfaceStubHeader));

    pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;

    for ( i = 0; i < (long)pServerInfo->nCount; i++ )
        {
        if ( NdrpGetSyntaxType( &pServerInfo->pSyntaxInfo[i].TransferSyntax ) == XFER_SYNTAX_NDR64 )
            {
            pSyntaxInfo = &pServerInfo->pSyntaxInfo[i];
            break;
            }
        }

    if ( NULL == pSyntaxInfo )
        return HRESULT_FROM_WIN32( RPC_S_UNSUPPORTED_TRANS_SYN );

    return 
    Ndr64StubWorker( pThis,
                     pChannel,
                     pRpcMsg,
                     pServerInfo,
                     DispatchTable,
                     pSyntaxInfo,
                     pdwStubPhase );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr64\srvcall.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    srvcall.c

Abstract :

    This file contains the single call Ndr64 routine for the server side.

Author :

    David Kays    dkays    October 1993.

Revision History :

    brucemc     11/15/93    Added struct by value support, corrected varargs
                            use.
    brucemc     12/20/93    Binding handle support.
    brucemc     12/22/93    Reworked argument accessing method.
    ryszardk    3/12/94     Handle optimization and fixes.

  ---------------------------------------------------------------------*/

#include "precomp.hxx"

#define CINTERFACE
#define USE_STUBLESS_PROXY

#include "ndrole.h"
#include "rpcproxy.h"

#include "hndl.h"
#include "interp2.h"
#include "pipendr.h"

#include <stdarg.h>


#pragma code_seg(".ndr64")


long RPC_ENTRY
Ndr64StubWorker(
    IRpcStubBuffer *     pThis,
    IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE         pRpcMsg,
    MIDL_SERVER_INFO   * pServerInfo,
    const SERVER_ROUTINE *     DispatchTable,
    MIDL_SYNTAX_INFO *   pSyntaxInfo,  
    ulong *              pdwStubPhase
    )
/*++

Routine Description :

    Server Interpreter entry point for object RPC procs.  Also called by
    Ndr64ServerCall, the entry point for regular RPC procs.

Arguments :

    pThis           - Object proc's 'this' pointer, 0 for non-object procs.
    pChannel        - Object proc's Channel Buffer, 0 for non-object procs.
    pRpcMsg         - The RPC message.
    pdwStubPhase    - Used to track the current interpreter's activity.

Return :

    Status of S_OK.

--*/
{

    PMIDL_STUB_DESC         pStubDesc;
    ushort                  ProcNum;

    long                    FormatOffset;
    PFORMAT_STRING          pFormat;
    PFORMAT_STRING          pFormatParam;

    ulong                   StackSize;

    MIDL_STUB_MESSAGE       StubMsg;

    uchar *                 pArg;
    uchar **                ppArg;

    NDR64_PROC_FLAGS    *   pNdr64Flags;
    long                    NumberParams;

    BOOL                    HasExplicitHandle;
    BOOL                    fBadStubDataException = FALSE;
    long                    n;

    boolean                 NotifyAppInvoked = FALSE;
    long                    ret;
    NDR_PROC_CONTEXT        ProcContext;
    NDR64_PROC_FORMAT   *   pHeader = NULL;
    NDR64_PARAM_FLAGS   *       pParamFlags;
    NDR64_BIND_AND_NOTIFY_EXTENSION * pHeaderExts = NULL;
    MIDL_STUB_MESSAGE *     pStubMsg = &StubMsg;    

    //
    // In the case of a context handle, the server side manager function has
    // to be called with NDRSContextValue(ctxthandle). But then we may need to
    // marshall the handle, so NDRSContextValue(ctxthandle) is put in the
    // argument buffer and the handle itself is stored in the following array.
    // When marshalling a context handle, we marshall from this array.
    //
    NDR_SCONTEXT            CtxtHndl[MAX_CONTEXT_HNDL_NUMBER];

    ProcNum = (ushort) pRpcMsg->ProcNum;

    NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned at server" );


    // setup SyntaxInfo of selected transfer syntax. 
    NdrServerSetupNDR64TransferSyntax( ProcNum, pSyntaxInfo, &ProcContext );
    StubMsg.pContext       = &ProcContext;
    
                                               
    pStubDesc = pServerInfo->pStubDesc;

    pFormat = ProcContext.pProcFormat;

    pHeader = (NDR64_PROC_FORMAT *) pFormat;
    pNdr64Flags = (NDR64_PROC_FLAGS *) & (pHeader->Flags );
    HasExplicitHandle = !NDR64MAPHANDLETYPE( NDR64GETHANDLETYPE ( pNdr64Flags ) );
    
    StackSize = pHeader->StackSize;

    //
    // Yes, do this here outside of our RpcTryFinally block.  If we
    // can't allocate the arg buffer there's nothing more to do, so
    // raise an exception and return control to the RPC runtime.
    //
    // Alloca throws an exception on an error.
    
    uchar *pArgBuffer = (uchar*)alloca(StackSize);
    ProcContext.StartofStack = pArgBuffer;

    //
    // Zero out the arg buffer.  We must do this so that parameters
    // are properly zeroed before we start unmarshalling.  If we catch
    // an exception before finishing the unmarshalling we can not leave
    // parameters in an unitialized state since we have to do a freeing
    // pass.
    //
    MIDL_memset( pArgBuffer,
                 0,
                 StackSize );

    if ( pNdr64Flags->HasOtherExtensions )
        pHeaderExts = (NDR64_BIND_AND_NOTIFY_EXTENSION *) (pFormat + sizeof( NDR64_PROC_FORMAT ) );

    if ( HasExplicitHandle )
    {
        //
        // For a handle_t parameter we must pass the handle field of
        // the RPC message to the server manager.
        //
        NDR_ASSERT( pHeaderExts, "NULL extension header" );
        if ( pHeaderExts->Binding.HandleType == FC64_BIND_PRIMITIVE )
        {
            pArg = pArgBuffer + pHeaderExts->Binding.StackOffset;

            if ( NDR64_IS_HANDLE_PTR( pHeaderExts->Binding.Flags ) )
                pArg = *((uchar **)pArg);

            *((handle_t *)pArg) = pRpcMsg->Handle;
        }

    }

    //
    // Get new interpreter info.
    //
    NumberParams = pHeader->NumberOfParams;

    NDR64_PARAM_FORMAT* Params = 
        (NDR64_PARAM_FORMAT*)ProcContext.Params;


    //
    // Wrap the unmarshalling, mgr call and marshalling in the try block of
    // a try-finally. Put the free phase in the associated finally block.
    //
    RpcTryFinally
    {
        
        //
        // If OLE, put pThis in first dword of stack.
        //
        if ( pThis )
        {
            *((void **)pArgBuffer) =
                (void *)((CStdStubBuffer *)pThis)->pvServerObject;
        }

        //
        // Initialize the Stub message.
        //
        if ( ! pChannel )
            {
            if ( ! pNdr64Flags->UsesPipes )
               {
                Ndr64ServerInitialize( pRpcMsg,
                                       &StubMsg,
                                       pStubDesc );
               }
            else
                Ndr64ServerInitializePartial( pRpcMsg,
                                            &StubMsg,
                                            pStubDesc,
                                            pHeader->ConstantClientBufferSize );
            }
        else
            {
            NDR_ASSERT( ! pNdr64Flags->UsesPipes, "DCOM pipe is not supported" );
            NdrStubInitialize( pRpcMsg,
                               &StubMsg,
                               pStubDesc,
                               pChannel );
            }   

        //
        // Set up for context handle management.
        //
        StubMsg.SavedContextHandles = CtxtHndl;
        memset( CtxtHndl, 0, sizeof(CtxtHndl) );

 
        pStubMsg->pCorrMemory = pArgBuffer;

        if ( pNdr64Flags->UsesFullPtrPackage )
            StubMsg.FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );

        //
        // Set StackTop AFTER the initialize call, since it zeros the field
        // out.
        //
        StubMsg.StackTop = pArgBuffer;

        if ( pNdr64Flags->UsesPipes )
            NdrpPipesInitialize64( & StubMsg,
                                   &ProcContext.AllocateContext,
                                   (PFORMAT_STRING) Params,
                                   (char*)pArgBuffer,
                                   NumberParams );

        //
        // We must make this check AFTER the call to ServerInitialize,
        // since that routine puts the stub descriptor alloc/dealloc routines
        // into the stub message.
        //
        if ( pNdr64Flags->UsesRpcSmPackage )
            NdrRpcSsEnableAllocate( &StubMsg );

        RpcTryExcept
        {

            // --------------------------------
            // Unmarshall all of our parameters.
            // --------------------------------
            NDR_ASSERT( ProcContext.StartofStack == pArgBuffer, "startofstack is not set" );
            Ndr64pServerUnMarshal( &StubMsg );    
                                    
            if ( pRpcMsg->BufferLength  <
                 (uint)(StubMsg.Buffer - (uchar *)pRpcMsg->Buffer) )
                {
                RpcRaiseException( RPC_X_BAD_STUB_DATA );
                }

            }

        RpcExcept( NdrServerUnmarshallExceptionFlag(GetExceptionInformation()) )
            {
            // Filter set in rpcndr.h to catch one of the following
            //     STATUS_ACCESS_VIOLATION
            //     STATUS_DATATYPE_MISALIGNMENT
            //     RPC_X_BAD_STUB_DATA

            NdrpFreeMemoryList( &StubMsg );

            fBadStubDataException = TRUE;
            if ( RPC_BAD_STUB_DATA_EXCEPTION_FILTER )
                RpcRaiseException( RPC_X_BAD_STUB_DATA );
            else
                RpcRaiseException( RpcExceptionCode() );
            }
        RpcEndExcept

        //
        // Do [out] initialization.
        //
        Ndr64pServerOutInit( pStubMsg );


        //
        // Unblock the first pipe; this needs to be after unmarshalling
        // because the buffer may need to be changed to the secondary one.
        // In the out only pipes case this happens immediately.
        //

        if ( pNdr64Flags->UsesPipes )
            NdrMarkNextActivePipe( ProcContext.pPipeDesc );

        //
        // OLE interfaces use pdwStubPhase in the exception filter.
        // See CStdStubBuffer_Invoke in rpcproxy.c.
        //
        *pdwStubPhase = STUB_CALL_SERVER;

        NotifyAppInvoked = TRUE;
        //
        // Check for a thunk.  Compiler does all the setup for us.
        //
        if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ProcNum] )
            {
            pServerInfo->ThunkTable[ProcNum]( &StubMsg );
            }
        else
            {
            //
            // Note that this ArgNum is not the number of arguments declared
            // in the function we called, but really the number of
            // REGISTER_TYPEs occupied by the arguments to a function.
            //
            long                ArgNum;
            MANAGER_FUNCTION    pFunc;
            REGISTER_TYPE           returnValue;

            if ( pRpcMsg->ManagerEpv )
                pFunc = ((MANAGER_FUNCTION *)pRpcMsg->ManagerEpv)[ProcNum];
            else
                pFunc = (MANAGER_FUNCTION) DispatchTable[ProcNum];

            ArgNum = (long) StackSize / sizeof(REGISTER_TYPE);
           
            //
            // The StackSize includes the size of the return. If we want
            // just the number of REGISTER_TYPES, then ArgNum must be reduced
            // by 1 when there is a return value AND the current ArgNum count
            // is greater than 0.
            //
            if ( ArgNum && pNdr64Flags->HasReturn && !pNdr64Flags->HasComplexReturn )
                ArgNum--;

            returnValue = Invoke( pFunc, 
                                  (REGISTER_TYPE *)pArgBuffer,
                          #if defined(_IA64_)
                                  pHeader->FloatDoubleMask,
                          #endif
                                  ArgNum);

            if( pNdr64Flags->HasReturn && !pNdr64Flags->HasComplexReturn )
                {
                    ((REGISTER_TYPE *)pArgBuffer)[ArgNum] = returnValue;
                    // Pass the app's return value to OLE channel
                    if ( pThis )
                        (*pfnDcomChannelSetHResult)( pRpcMsg, 
                                                     NULL,   // reserved
                                                     (HRESULT) returnValue );
                }
            }

        *pdwStubPhase = STUB_MARSHAL;

        if ( pNdr64Flags->UsesPipes )
            {
            NdrIsAppDoneWithPipes( ProcContext.pPipeDesc );
            StubMsg.BufferLength += pHeader->ConstantServerBufferSize;
            }
        else
            StubMsg.BufferLength = pHeader->ConstantServerBufferSize;

        if ( pNdr64Flags->ServerMustSize )
            {
            //
            // Buffer size pass.
            //
            Ndr64pSizing( pStubMsg,
                          FALSE );  // IsClient
           }

        if ( pNdr64Flags->UsesPipes && ProcContext.pPipeDesc->OutPipes )
            {
            NdrGetPartialBuffer( & StubMsg );
            StubMsg.RpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;
            }
        else
            {
            if ( ! pChannel )
                {
                Ndr64GetBuffer( &StubMsg,
                              StubMsg.BufferLength );
                }
            else
                NdrStubGetBuffer( pThis,
                                  pChannel,
                                  &StubMsg );
            }

        //
        // Marshall pass.
        //
        Ndr64pServerMarshal ( &StubMsg );
                      

        if ( pRpcMsg->BufferLength <
                 (ulong)(StubMsg.Buffer - (uchar *)pRpcMsg->Buffer) )
            {
            NDR_ASSERT( 0, "Ndr64StubWrok marshal: buffer overflow!" );
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
            }

        pRpcMsg->BufferLength = (ulong) ( StubMsg.Buffer - (uchar *) pRpcMsg->Buffer );

#if defined(DEBUG_WALKIP)
        if ( pChannel )
            {
            Ndr64pReleaseMarshalBuffer(
                StubMsg.RpcMsg,
                ProcContext.pSyntaxInfo,
                StubMsg.RpcMsg->ProcNum,
                StubMsg.StubDesc,
                1, //BUFFER_OUT
                true );
            }
#endif        

        }
    RpcFinally
        {
        // clean up context handles if exception is thrown in either marshalling or 
        // manager routine. 

        if ( RpcAbnormalTermination() && ! pChannel )
            {
            Ndr64pCleanupServerContextHandles( &StubMsg,
                                               NumberParams,
                                               Params,
                                               pArgBuffer,
                                               STUB_MARSHAL != *pdwStubPhase);
            }

        // If we died because of bad stub data, don't free the params here since they
        // were freed using a linked list of memory in the exception handler above.

        if ( ! fBadStubDataException  )
            {
            
            Ndr64pFreeParams( &StubMsg,
                            NumberParams,
                            Params,
                            pArgBuffer );
            }


        NdrpAllocaDestroy( &ProcContext.AllocateContext );

        //
        // Deferred frees.  Actually, this should only be necessary if you
        // had a pointer to enum16 in a *_is expression.
        //

        //
        // Free any full pointer resources.
        //
        NdrFullPointerXlatFree( StubMsg.FullPtrXlatTables );

        //
        // Disable rpcss allocate package if needed.
        //
        if ( pNdr64Flags->UsesRpcSmPackage )
            NdrRpcSsDisableAllocate( &StubMsg );

        if ( pNdr64Flags->HasNotify )
            {
            NDR_NOTIFY_ROUTINE     pfnNotify;

            // BUGBUG: tests need to be recompiled. 
            pfnNotify =  StubMsg.StubDesc->NotifyRoutineTable[ pHeaderExts->NotifyIndex ];

            ((NDR_NOTIFY2_ROUTINE)pfnNotify)(NotifyAppInvoked);
            }
        
        }
    RpcEndFinally

    return S_OK;
}


void
Ndr64pFreeParams(
    MIDL_STUB_MESSAGE       *       pStubMsg,
    long                            NumberParams,
    NDR64_PARAM_FORMAT      *       Params,
    uchar *                         pArgBuffer 
    )
/*++

Routine Description :

    Frees the memory associated with function parameters as required.

Arguments :

    pStubMsg     - Supplies a pointer to the stub message.
    NumberParams - Supplies the number of parameters for this procedure.
    Params       - Supplies a pointer to the parameter list for this function.
    pArgBuffer   - Supplies a pointer to the virtual stack.
    pParamFilter - Supplies a filter that is used to determine which functions
                   are to be considered.  This function should return TRUE if
                   the parameter should be considered.   If pParamFilter is NULL,
                   the default filter is used which is all parameters that have
                   MustFree set. 

Return :

    None.

--*/
{
    for ( long n = 0; n < NumberParams; n++ )
        {
        NDR64_PARAM_FLAGS   *pParamFlags = 
            ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
        
        if ( ! pParamFlags->MustFree )
            continue;

        uchar *pArg = pArgBuffer + Params[n].StackOffset;

        if ( ! pParamFlags->IsByValue )
            pArg = *((uchar **)pArg);

        if ( pArg )
            {
            pStubMsg->fDontCallFreeInst =
                    pParamFlags->IsDontCallFreeInst;

            Ndr64ToplevelTypeFree( pStubMsg,
                                   pArg,
                                   Params[n].Type );

            }

        //
        // We have to check if we need to free any simple ref pointer,
        // since we skipped it's Ndr64PointerFree call.  We also have
        // to explicitly free arrays and strings.  But make sure it's
        // non-null and not sitting in the buffer.
        //
        if ( pParamFlags->IsSimpleRef ||
             NDR64_IS_ARRAY_OR_STRING(*(PFORMAT_STRING)Params[n].Type) )
            {
            //
            // Don't free [out] params that we're allocated on the
            // interpreter's stack.
            //

            if ( pParamFlags->UseCache )
                continue;

            //
            // We have to make sure the array/string is non-null in case we
            // get an exception before finishing our unmarshalling.
            //
            if ( pArg &&
                 ( (pArg < pStubMsg->BufferStart) ||
                   (pArg > pStubMsg->BufferEnd) ) )
                (*pStubMsg->pfnFree)( pArg );
            }
        } // for
}



void
Ndr64pCleanupServerContextHandles(
    MIDL_STUB_MESSAGE * pStubMsg,
    long                NumberParams,
    NDR64_PARAM_FORMAT* Params,
    uchar *             pArgBuffer,
    BOOL                fManagerRoutineException
    )
/*++

Routine Description :

    Cleans up context handles that might have been dropped by the NDR engine between
    the return from the manager routine and the end of marshaling.

Arguments :

    pStubMsg     - Supplies a pointer to the stub message.
    NumberParams - Supplies the number of parameters for this procedure.
    Params       - Supplies a pointer to the parameter list for this function.
    pArgBuffer   - Supplies a pointer to the virtual stack.

Return :

    None.

--*/
{
    for ( long n = 0; n < NumberParams; n++ )
        {
        NDR64_PARAM_FLAGS   *pParamFlags = 
                                (NDR64_PARAM_FLAGS *) &( Params[n].Attributes );
        
        if ( ! pParamFlags->IsOut  ||  pParamFlags->IsPipe )
            continue;
    
        uchar *pArg = pArgBuffer + Params[n].StackOffset;
    
        if ( ! pParamFlags->IsByValue )
            pArg = *((uchar * UNALIGNED *)pArg);

        NDR64_FORMAT_CHAR FcType = *(PFORMAT_STRING)Params[n].Type;
    
        if ( FcType == FC64_BIND_CONTEXT )
            {
            // NDR64_CONTEXT_HANDLE_FORMAT is the same as PNDR_CONTEXT_HANDLE_ARG_DESC.

            NdrpEmergencyContextCleanup( pStubMsg,
                                         (PNDR_CONTEXT_HANDLE_ARG_DESC ) Params[n].Type,
                                         pArg,
                                         fManagerRoutineException );
            }

        } // for
    }
    
    
    
    void RPC_ENTRY 
    Ndr64pServerUnMarshal ( MIDL_STUB_MESSAGE *     pStubMsg )
    {
        NDR_PROC_CONTEXT    *       pContext = ( NDR_PROC_CONTEXT * )pStubMsg->pContext;
    
    //    if ( (ULONG_PTR)pStubMsg->Buffer & 15 )
    //        RpcRaiseException( RPC_X_INVALID_BUFFER );
    
        NDR64_PARAM_FORMAT  *Params = (NDR64_PARAM_FORMAT *)pContext->Params;
    
        CORRELATION_CONTEXT CorrCtxt( pStubMsg, pContext->StartofStack );
    
       //
        // ----------------------------------------------------------
        // Unmarshall Pass.
        // ----------------------------------------------------------
        //
    
        for ( ulong n = 0; n < pContext->NumberParams; n++ )
            {
            NDR64_PARAM_FLAGS   *pParamFlags = 
                ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
            
    
            if ( ! pParamFlags->IsIn  ||
                 pParamFlags->IsPipe )
                continue;
    
            if ( pParamFlags->IsPartialIgnore )
                {
                uchar *pArg = pContext->StartofStack + Params[n].StackOffset;
            ALIGN( pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );
            *(void**)pArg =  *(NDR64_PTR_WIRE_TYPE*)pStubMsg->Buffer ? (void*)1 : (void*)0;
            pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);
            continue;
            }
            
        uchar *pArg = pContext->StartofStack + Params[n].StackOffset;

        //
        // This is for returned basetypes and for pointers to
        // basetypes.
        //
        if ( pParamFlags->IsBasetype )
            {
            NDR64_FORMAT_CHAR type = *(PFORMAT_STRING)Params[n].Type;

            //
            // Check for a pointer to a basetype.  Set the arg pointer
            // at the correct buffer location and you're done.
            // Except darn int3264.
            //
            if ( pParamFlags->IsSimpleRef )
                {
                ALIGN( pStubMsg->Buffer, NDR64_SIMPLE_TYPE_BUFALIGN( type ) );

                *((uchar **)pArg) = pStubMsg->Buffer;

                pStubMsg->Buffer += NDR64_SIMPLE_TYPE_BUFSIZE( type );
                }
            else
                {
                Ndr64SimpleTypeUnmarshall(
                    pStubMsg,
                    pArg,
                    type );
                }

            continue;
            } // IsBasetype

        //
        // This is an initialization of [in] and [in,out] ref pointers
        // to pointers.  These can not be initialized to point into the
        // rpc buffer and we want to avoid doing a malloc of 4 bytes!
        // 32b: a ref pointer to any pointer, we allocate the pointee pointer.
        //
        if ( pParamFlags->UseCache )
            {                      
            *((void **)pArg) = NdrpAlloca( &pContext->AllocateContext, 8);

            // Triple indirection - cool!
            **((void ***)pArg) = 0;
            }
        uchar **ppArg = pParamFlags->IsByValue ? &pArg : (uchar **)pArg;
        

        pStubMsg->ReuseBuffer = pParamFlags->IsForceAllocate;

        Ndr64TopLevelTypeUnmarshall(pStubMsg,
                                    ppArg,
                                    Params[n].Type,
                                    pParamFlags->IsForceAllocate && 
                                        !pParamFlags->IsByValue );

        // force allocate is param attr: reset the flag after each parameter.
        pStubMsg->ReuseBuffer  = FALSE;     
        
        }

    if ( pStubMsg->pCorrInfo )
        Ndr64CorrelationPass( pStubMsg );
   
}


#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrexts\jitdump\jitdump.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    jitdump.h

Abstract:

    This file contains routines to dump typelib generated proxy information.

Author:

    Yong Qu (yongqu)     August 24 1999

Revision History:


--*/

#ifndef _JITDUMP_H_
#define _JITDUMP_H_

typedef
HRESULT (STDAPICALLTYPE * PFNCREATEPROXYFROMTYPEINFO)
(
    IN  ITypeInfo *         pTypeInfo,
    IN  IUnknown *          punkOuter,
    IN  REFIID              riid,
    OUT IRpcProxyBuffer **  ppProxy,
    OUT void **             ppv
);

typedef
HRESULT (STDAPICALLTYPE * PFNCREATESTUBFROMTYPEINFO)
(
    IN  ITypeInfo *         pTypeInfo,
    IN  REFIID              riid,
    IN  IUnknown *          punkServer,
    OUT IRpcStubBuffer **   ppStub
);

#include <ndrexts.hxx>

#endif // _JITDUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrexts\jitdump\jitdump.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    jitdump.cxx

Abstract:

    This file contains routines to dump typelib generated proxy information.


Author:

    Yong Qu (yongqu)     August 24 1999

Revision History:


--*/

#include <ole2.h>
#include <oleauto.h>
#include <oaidl.h>
#include <windows.h>
#include <malloc.h>
#include <stdio.h>
#include "jitdump.h"

// CreateStubFromTypeInfo is a private export. We have to LoadLibrary to
// retrieve it.
PFNCREATESTUBFROMTYPEINFO pfnCreateStubFromTypeInfo = NULL;

void PrintHelp()
{
    printf("usage: jitdump <tlbname> [{iid} [<procnum>]]\n");
    printf("Arguments:\n");
    printf("\t<tlbname> typelibrary filename.\n");
    printf("\t[{iid}] when presented, jitdump will dump all proc info of the interface \n");
    printf("\t[<procnum>] when presented, jitdump will dump only the specified proc info\n");
}

//+---------------------------------------------------------------------------
//
//  Function:   PrintStubInfo
//
//  Synopsis:   Create a proxy from given type library name and IID, then
//              dump the specified procedure information accordingly.
//              NdrpDumpStubProc is exported from ndrexts.dll. The debug
//              extension needs to be presented during runtime.
//              Dump all the methods if nProcNum is 0.
//
//  Returns:
//    S_OK if everything is fine.
//    error code if error occur somewhere.
//
//----------------------------------------------------------------------------


HRESULT PrintStubInfo(LPOLESTR wszFile, REFIID riid, unsigned long nProcNum)
{
    HRESULT hr;
    ITypeLib *pTypeLib = NULL;
    ITypeInfo *pTypeInfo = NULL;
    IRpcStubBuffer *pStub;

    hr = LoadTypeLib(wszFile,&pTypeLib);

    if (SUCCEEDED(hr))
    {
        hr = pTypeLib->GetTypeInfoOfGuid(riid,&pTypeInfo);
    }

    if (SUCCEEDED(hr))
    {
        hr = (*pfnCreateStubFromTypeInfo)(pTypeInfo,riid,NULL, &pStub);
    }

    if (SUCCEEDED(hr))
    {
        if (nProcNum > 0)
            NdrpDumpStubProc(pStub,nProcNum);
        else
            NdrpDumpStub(pStub);
            
        pStub->Release();
    }

    if (pTypeLib)
        pTypeLib->Release();

    return hr;
}

// dump all the interface defined in the tlb.
HRESULT PrintAllStubInfo(LPOLESTR wszFile)
{
    int nCount = 0;
    HRESULT hr = S_OK;
    ITypeLib *pTypeLib = NULL;
    ITypeInfo *pTypeInfo = NULL;
    IRpcStubBuffer *pStub = NULL;
    TYPEATTR       *pTypeAttr = NULL;
    TYPEKIND tkind;

    hr = LoadTypeLib(wszFile,&pTypeLib);

    if (SUCCEEDED(hr))
    {
        nCount = pTypeLib->GetTypeInfoCount();
    }

    for (int i = 0; ( i < nCount ) ; i++)
        {
        hr = pTypeLib->GetTypeInfoType(i,&tkind);

        if (FAILED(hr))
            break;

        // we need to process interface only.
        if (tkind == TKIND_INTERFACE || 
            tkind == TKIND_DISPATCH )
            {
            hr = pTypeLib->GetTypeInfo(i,&pTypeInfo);

            if (SUCCEEDED(hr))
                {
                hr = pTypeInfo->GetTypeAttr(&pTypeAttr);

                if (SUCCEEDED(hr))
                    {
                    hr = (*pfnCreateStubFromTypeInfo)(pTypeInfo,pTypeAttr->guid,NULL, &pStub);

                    // IDispatch, IUnknown etc. would show up here also. We'll continue without 
                    // dumping those interface.
                    if (SUCCEEDED(hr))
                        {
                        NdrpDumpStub(pStub);
                        pStub->Release();
                        }
                        
                    pTypeInfo->ReleaseTypeAttr(pTypeAttr);
                    }
                pTypeInfo->Release();
                }
            }
        }

    if (pTypeLib)
        pTypeLib->Release();

    return hr;

    
}

void __cdecl main(int argc, char *argv[])
{
    HRESULT  ret;
    GUID     riid;
    unsigned long    nProcNum,dwlen = 0;
    WCHAR           *wszGUID = NULL, *wszFile = NULL;
    char            *szTLB;

    if ( argc < 2  || argc > 4)
    {
        PrintHelp();
        return;
    }

    ret = CoInitialize(NULL);
    if (FAILED (ret) )
    {
        printf("CoInitialize failed 0x%x\n",ret);
        return;
    }
    
    // load rpcrt4!CreateStubFromTypeInfo. It's not in .lib file
    if (NULL == pfnCreateStubFromTypeInfo )
    {
        HMODULE hMod = LoadLibraryA("rpcrt4.dll");
        if (hMod)
        {
            pfnCreateStubFromTypeInfo = (PFNCREATESTUBFROMTYPEINFO)GetProcAddress(hMod,
                                        "CreateStubFromTypeInfo");
        }
        if (NULL == hMod || NULL == pfnCreateStubFromTypeInfo )
        {
            printf("can't load rpcrt4.dll\n");
            return;
        }
        
    }
    // covert the filename to LPOLESTR to be used in LoadTypeLib
    dwlen = ( strlen(argv[1]) + 1 ) * sizeof(OLECHAR) ;
    wszFile = (LPOLESTR)alloca( dwlen );
    memset( wszFile , 0 , dwlen );
    dwlen /= sizeof(OLECHAR);       // MultiByteTo wants a char count

    if ( !MultiByteToWideChar(CP_ACP, 0, argv[1], -1, wszFile, dwlen ) )
    {
        printf("Can't process iid, error is 0x%x \n", GetLastError() );
        return;
    }

    if ( argc == 2 )
    {
        // dump all interfaces if only tlb name is provided.
        ret = PrintAllStubInfo(wszFile);   
    }
    else
    {
        // convert iid string into real iid.
        dwlen = ( strlen(argv[2]) + 1 ) * sizeof(OLECHAR) ;
        wszGUID = (LPOLESTR)alloca( dwlen );
        memset( wszGUID , 0 , dwlen );
        dwlen /= sizeof(OLECHAR);

        if ( !MultiByteToWideChar(CP_ACP, 0, argv[2], -1, wszGUID, dwlen ) )
        {
            printf("Can't process iid, error is 0x%x \n", GetLastError() );
            return;
        }

        ret = IIDFromString(wszGUID, &riid );
        if ( FAILED (ret) )
        {
            printf("can't convert iid %S 0x%x\n",wszGUID,ret);
            PrintHelp();
            return;
        } 

        if ( argc == 3 )
            {
            ret = PrintStubInfo(wszFile,riid,0);
            }
        else
            {
            nProcNum = atol(argv[3]);

            ret = PrintStubInfo(wszFile,riid,nProcNum);
            }
    } 

    

    if ( ret != S_OK )
    {
        printf("failed to dump the proxy 0x%x \n",ret);
    }

    CoUninitialize();
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrexts\ndrexts\basicinf.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    basicinf.cxx

Abstract:


Author:

    Michael Zoran(mzoran)   August 25 1999

Revision History:

--*/

#include "ndrextsp.hxx"
#include "basicinf.hxx"

BASIC_INFO::BASIC_INFO() 
{
    Clear();
}

VOID BASIC_INFO::Clear()
{
    StubMessageIsAvailable = RpcMessageIsAvailable = FALSE;
    StubDescIsAvailable = RpcClientInterfaceIsAvailable =  ServerInfoIsAvailable = FALSE;
    ProcFormatAddressIsAvailable = FALSE;
}

VOID BASIC_INFO::GetInfoFromStubMessage(UINT64 Address)
{
    GetInfo(TRUE, Address);
}

VOID BASIC_INFO::GetInfoFromRpcMessage(UINT64 Address)
{
    GetInfo(FALSE, Address);
}

VOID BASIC_INFO::GetInfo(BOOL IsStubMsg, UINT64 Address) 
{
    Clear();

    if (IsStubMsg)
        {
        try 
           {
           StubMessageAddress = Address;
           ReadMemory(StubMessageAddress, &StubMessage);
           StubMessageIsAvailable = TRUE;
       
           StubDescAddress = (UINT64)StubMessage.StubDesc;
           ReadMemory(StubDescAddress, &StubDesc);
           StubDescIsAvailable = TRUE;
           
           InterfaceInformationAddress = (UINT64)StubDesc.RpcInterfaceInformation;
           ReadMemory(InterfaceInformationAddress, &RpcClientInterface);
           RpcClientInterfaceIsAvailable = TRUE;           
           
           ServerInfoAddress = (UINT64)RpcClientInterface.InterpreterInfo;
           ReadMemory(ServerInfoAddress, &MidlServerInfo);
           ServerInfoIsAvailable = TRUE;
           }
        catch(...)
           {
           }

        }

    if (!IsStubMsg)
        {
        RpcMessageAddress = Address;
        }
    else if (!StubMessageIsAvailable || !StubMessage.RpcMsg)
        {
        // Nothing more to do
        return;
        }
    else 
        {
        RpcMessageAddress = (UINT64)StubMessage.RpcMsg;
        }

    //try the RPC_MESSAGE chain
    try
       {
       
       ReadMemory(RpcMessageAddress, &RpcMessage);
       RpcMessageIsAvailable = TRUE;
       
       if (!RpcClientInterfaceIsAvailable)
           {
           InterfaceInformationAddress = (UINT64)RpcMessage.RpcInterfaceInformation;
           ReadMemory(InterfaceInformationAddress, &RpcClientInterface);
           RpcClientInterfaceIsAvailable = TRUE;

           ServerInfoAddress = (UINT64)RpcClientInterface.InterpreterInfo;
           ReadMemory(ServerInfoAddress, &MidlServerInfo);
           ServerInfoIsAvailable = TRUE;

           if (!StubDescIsAvailable)
               {
               StubDescAddress = (UINT64)MidlServerInfo.pStubDesc;
               ReadMemory(StubDescAddress, &StubDesc);
               StubDescIsAvailable = TRUE;               
               }
           }

       }
    catch(...)
       {
       }
    try 
        {
        if (RpcMessageIsAvailable && ServerInfoIsAvailable)
            {
            ProcFormatAddress = (UINT64)MidlServerInfo.ProcString;
            UINT64 FmtStringOffset = (UINT64)MidlServerInfo.FmtStringOffset;
            if (FmtStringOffset)
                {
                SHORT Offset;
                ReadMemory(FmtStringOffset + (sizeof(SHORT) * RpcMessage.ProcNum), &Offset);
                ProcFormatAddress += Offset;
                ProcFormatAddressIsAvailable = TRUE;
                }
            }
        
        }
    catch(...)
        {
        } 
        
}

VOID BASIC_INFO::PrintInfo(FORMATTED_STREAM_BUFFER & dout)
{
    ostringstream MidlBuffer;
    ostringstream StubMessageAddressTxt;
    if (StubMessageIsAvailable)
        {
        MidlBuffer << HexOut(StubMessage.Buffer);
        StubMessageAddressTxt << HexOut(StubMessageAddress);
        }
    else 
        {
                     //0x0000000000000000
        MidlBuffer << "NA                ";
                                //0x0000000000000000
        StubMessageAddressTxt << "NA                ";
        }

    ostringstream InterfaceGUID;
    ostringstream InterfaceAddressTxt;
    if (RpcClientInterfaceIsAvailable)
        {
        InterfaceGUID << RpcClientInterface.InterfaceId.SyntaxGUID;
        InterfaceAddressTxt << HexOut(InterfaceInformationAddress);
        }
    else
        {
                       //{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}
        InterfaceGUID << "NA                                   ";
                              //0x0000000000000000
        InterfaceAddressTxt << "NA                ";
        }

    ostringstream ProcNum;
    ostringstream Handle;
    ostringstream RpcBuffer;
    ostringstream RpcBufferLength;
    ostringstream RpcMessageAddressTxt;

    if (RpcMessageIsAvailable)
        {
        ProcNum << HexOut(RpcMessage.ProcNum);
        Handle << HexOut(RpcMessage.Handle);
        RpcBuffer << HexOut(RpcMessage.Buffer);
        RpcBufferLength << HexOut(RpcMessage.BufferLength);        
        RpcMessageAddressTxt << HexOut(RpcMessageAddress);
        }
    else 
        {
                  //0x00000000
        ProcNum << "NA        ";
                  //0x0000000000000000
        Handle <<  "NA                ";
                    //0x0000000000000000
        RpcBuffer << "NA                ";
                          //0x00000000
        RpcBufferLength << "NA        ";
                               //0x0000000000000000
        RpcMessageAddressTxt << "NA                ";
        }

    ostringstream StubDescAddressTxt;
    string NDRVersion;
    string MIDLVersion;
    ostringstream TypeFormat;

    if (StubDescIsAvailable)
        {
        ostringstream TempNDRVersion;
        TempNDRVersion << ((StubDesc.Version >> 16) & 0xFFFF) << '.'
                       << (StubDesc.Version && 0xFFFF);
        NDRVersion = TempNDRVersion.str();
        NDRVersion.resize(10, ' ');

        ostringstream TempMIDLVersion;
        TempMIDLVersion << ((StubDesc.MIDLVersion >> 24) & 0xFF) << '.' 
                        << ((StubDesc.MIDLVersion >> 16) & 0xFF) << '.'
                        << (StubDesc.MIDLVersion && 0xFFFF);
        MIDLVersion = TempMIDLVersion.str();
        MIDLVersion.resize(10, ' ');

        TypeFormat << HexOut(StubDesc.pFormatTypes);
        StubDescAddressTxt << HexOut(StubDescAddress);
        }
    else
        {
                    //0x00000000
        NDRVersion = "NA        ";
                    //0x00000000
        MIDLVersion= "NA        ";
                      //0x0000000000000000
        TypeFormat <<  "NA                ";
                             //0x0000000000000000
        StubDescAddressTxt << "NA                ";        
        }

    ostringstream ServerInfoAddressTxt;
    if (ServerInfoIsAvailable)
        {
        ServerInfoAddressTxt << HexOut(ServerInfoAddress);
        // Compute address of proc format string
        }
    else
        {
                               //0x0000000000000000
        ServerInfoAddressTxt << "NA                ";
        }

    ostringstream ProcFormat;
    if (ProcFormatAddressIsAvailable)
        {
        ProcFormat << HexOut(ProcFormatAddress);
        }
    else 
        {
                     //0x0000000000000000
        ProcFormat << "NA                ";
        }

    dout << "Interface: " << InterfaceGUID.str().c_str() 
         << " ProcNum: " << ProcNum.str().c_str() << '\n';

    dout << "Version(NDR):      " << NDRVersion.c_str() 
         << "         Version(MIDL):    " << MIDLVersion.c_str() << '\n';

    dout << "ProcFormat:        " << ProcFormat.str().c_str() 
         << " TypeFormat:       " << TypeFormat.str().c_str() << '\n';

    dout << "RpcBuffer:         " << RpcBuffer.str().c_str() 
         << " RpcBufferLength:  " << RpcBufferLength.str().c_str() << '\n';

    dout << "Handle:            " << Handle.str().c_str() 
         << " MIDLBuffer:       " << MidlBuffer.str().c_str() << '\n';

    dout << "MIDL_STUB_MESSAGE: " << StubMessageAddressTxt.str().c_str()
         << " RPC_MESSAGE:      " << RpcMessageAddressTxt.str().c_str() << '\n';

    dout << "MIDL_STUB_DESC:    " << StubDescAddressTxt.str().c_str() 
         << " MIDL_SERVER_INFO: " << ServerInfoAddressTxt.str().c_str() << '\n';

    dout << "RPC_CLIENT_INTERFACE/RPC_SERVER_INTERFACE: " << 
            InterfaceAddressTxt.str().c_str() << '\n';

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrexts\ndrexts\format.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    format.cxx

Abstract:

    This file contains format string printer debugger extension for RPC NDR.

Author:

    Mike Zoran  (mzoran)     Sepember 3, 1999

Revision History:

--*/

#include "ndrextsp.hxx"

char * FormatCharNames[] = 
{
    "FC_ZERO",
    "byte",
    "char",
    "small",
    "usmall",
    "wchar",
    "short",
    "ushort",
    "long",
    "ulong",
    "float",
    "hyper",
    "double",
    "enum16",
    "enum32",
    "ignore",
    "error_status_t",
    "ref ptr",
    "unique ptr",
    "object ptr",
    "full ptr",

    "FC_STRUCT",
    "FC_PSTRUCT",
    "FC_CSTRUCT",
    "FC_CPSTRUCT",
    "FC_CVSTRUCT",
    "FC_BOGUS_STRUCT",

    "FC_CARRAY",
    "FC_CVARRAY",
    "FC_SMFARRAY",
    "FC_LGFARRAY",
    "FC_SMVARRAY",
    "FC_LGVARRAY",
    "FC_BOGUS_ARRAY",       

    "FC_C_CSTRING",
    "FC_C_BSTRING",
    "FC_C_SSTRING",
    "FC_C_WSTRING",

    "FC_CSTRING",
    "FC_BSTRING",
    "FC_SSTRING",
    "FC_WSTRING",           

    "FC_ENCAPSULATED_UNION",
    "FC_NON_ENCAPSULATED_UNION",

    "FC_BYTE_COUNT_POINTER",

    "FC_TRANSMIT_AS",
    "FC_REPRESENT_AS",

    "FC_IP",

    "FC_BIND_CONTEXT",
    "FC_BIND_GENERIC",
    "FC_BIND_PRIMITIVE",
    "FC_AUTO_HANDLE",
    "FC_CALLBACK_HANDLE",
    "FC_PICKLE_HANDLE",

    "FC_POINTER",

    "FC_ALIGNM2",
    "FC_ALIGNM4",
    "FC_ALIGNM8",
    "FC_ALIGNB2",
    "FC_ALIGNB4",
    "FC_ALIGNB8",        

    "FC_STRUCTPAD1",
    "FC_STRUCTPAD2",
    "FC_STRUCTPAD3",
    "FC_STRUCTPAD4",
    "FC_STRUCTPAD5",
    "FC_STRUCTPAD6",
    "FC_STRUCTPAD7",

    "FC_STRING_SIZED",
    "FC_STRING_NO_SIZE",    

    "FC_NO_REPEAT",
    "FC_FIXED_REPEAT",
    "FC_VARIABLE_REPEAT",
    "FC_FIXED_OFFSET",
    "FC_VARIABLE_OFFSET",      

    "FC_PP",

    "FC_EMBEDDED_COMPLEX",

    "FC_IN_PARAM",
    "FC_IN_PARAM_BASETYPE",
    "FC_IN_PARAM_NO_FREE_INST",
    "FC_IN_OUT_PARAM",
    "FC_OUT_PARAM",
    "FC_RETURN_PARAM",         
    "FC_RETURN_PARAM_BASETYPE",

    "FC_DEREFERENCE",
    "FC_DIV_2",
    "FC_MULT_2",
    "FC_ADD_1",
    "FC_SUB_1",
    "FC_CALLBACK",

    "FC_CONSTANT_IID",

    "FC_END",
    "FC_PAD",

    // ** Gap before new format string types **

    "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", 
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", 
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", 
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", 
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", 
    "FC_RES",

    // ** Gap before new format string types end **

    // 
    // Post NT 3.5 format characters.
    //

    // Hard struct

    "FC_HARD_STRUCT",            // 0xb1

    "FC_TRANSMIT_AS_PTR",        // 0xb2
    "FC_REPRESENT_AS_PTR",       // 0xb3

    "FC_USER_MARSHAL",           // 0xb4

    "FC_PIPE",                   // 0xb5

    "FC_BLKHOLE",                // 0xb6

    "FC_RANGE",                   // 0xb7     NT 5 beta2 MIDL 3.3.110

    "FC_INT3264",                 // 0xb8     NT 5 beta2, MIDL64, 5.1.194+
    "FC_UINT3264",                // 0xb9     NT 5 beta2, MIDL64, 5.1.194+

    "FC_END_OF_UNIVERSE",         // 0xb5

    ""
};

FORMAT_STRING::FORMAT_STRING(UINT64 Addr) 
: Address(Addr)
    {
    
    }

VOID  FORMAT_STRING::Move(LONG Delta)
    {
    Address += Delta;
    }

VOID  FORMAT_STRING::GotoOffset()
    {
    UINT64 CurrentAddress = Address;
    SHORT Offset = GetSHORT();
    Address = CurrentAddress + Offset;
    }

UINT64 FORMAT_STRING::ComputeOffset()
    {
    UINT64 CurrentAddress = Address;
    SHORT Offset = GetSHORT();
    return CurrentAddress + Offset;
    }

UINT64 FORMAT_STRING::GetAddress()
    {
    return Address;
    }
UINT64 FORMAT_STRING::SetAddress(UINT64 Addr)
    {
    UINT64 Tmp = Address; 
    Address = Addr; 
    return Tmp;
    }

BOOL FORMAT_STRING::SkipCorrelationDesc( BOOL Robust )
    {
    ULONG Desc = GetULONG();
    if ( Robust )
        {
        Move(2);
        }
    return Desc != 0xFFFFFFFF;
    }

#define DEFINE_FORMAT_TYPE(type)                                                 \
    type FORMAT_STRING::Read##type##() {                                         \
        type Tmp;  ReadMemory(Address,&Tmp); return Tmp;                         \
    }                                                                            \
    type FORMAT_STRING::Get##type##() {                                          \
        type Tmp;  ReadMemory(Address,&Tmp); Address += sizeof(Tmp); return Tmp; \
    }                                                                            \
    VOID FORMAT_STRING::Inc##type##() {                                          \
        Address += sizeof(type);                                                 \
    }

DEFINE_FORMAT_TYPE(UCHAR)
DEFINE_FORMAT_TYPE(CHAR)
DEFINE_FORMAT_TYPE(USHORT)
DEFINE_FORMAT_TYPE(SHORT)
DEFINE_FORMAT_TYPE(ULONG)
DEFINE_FORMAT_TYPE(LONG)
DEFINE_FORMAT_TYPE(GUID)

PCHAR FORMAT_STRING::GetFormatCharName( UCHAR FC )
    {
    return (0 <= FC  &&  FC <= FC_END)
    ?  FormatCharNames[ FC ]
    :  "FC unknown" ;
    }

FORMAT_TYPE_QUEUE::FORMAT_TYPE_QUEUE() : Set(),
                                         Queue()
    {
    Clear();
    }

VOID FORMAT_TYPE_QUEUE::Clear()
    {
    Set.clear();
    while(!Queue.empty()) 
        Queue.pop();
    }

VOID FORMAT_TYPE_QUEUE::Add(UINT64 FormatAddress, UINT64 BaseAddress)
    {
    if (!Set.insert(FormatAddress).second)
        {
        // already hit this item
        return;
        }

    FORMAT_TYPE_QUEUE_ITEM Item = {FormatAddress, BaseAddress};
    Queue.push(Item);
    }

VOID FORMAT_TYPE_QUEUE::PrintTypes(FORMAT_PRINTER *pFormatPrinter)
    {
    while (!Queue.empty())
        {

        FORMAT_TYPE_QUEUE_ITEM Item = Queue.front();
        Queue.pop();

        UINT64 BackupFormatAddress = pFormatPrinter->FormatString.GetAddress();
        UINT64 BackupBaseAddress = pFormatPrinter->BaseAddress;
        pFormatPrinter->FormatString.SetAddress(Item.FormatAddress);
        pFormatPrinter->BaseAddress = Item.BaseAddress;

        pFormatPrinter->OutputType();
        pFormatPrinter->dout << '\n';

        pFormatPrinter->FormatString.SetAddress(BackupFormatAddress);
        pFormatPrinter->BaseAddress = BackupBaseAddress;

        }
    }

FORMAT_PRINTER::FORMAT_PRINTER(FORMATTED_STREAM_BUFFER & ds) : dout(ds), 
                                                               FormatString(0), 
                                                               Robust(FALSE)
    {
    
    }

// Os dumper
void FORMAT_PRINTER::PrintOsHeader(UINT64 ProcHeader)
    {
    ABORT("Printing the proc header is unavailable in Os mode.\n\n");
    }


void FORMAT_PRINTER::PrintOsParamList(UINT64 ParamList, UINT64 TypeInfo)
    {
    BaseAddress = ParamList;
    UINT64 Address = FormatString.SetAddress(ParamList);                              
    PrintOldStyleParamList(TypeInfo);
    FormatString.SetAddress(Address);
    }

void FORMAT_PRINTER::PrintOsProc(UINT64 ProcHeader, UINT64 TypeInfo)
    {
    PrintOsParamList(ProcHeader, TypeInfo);
    }

// Oi dumper
void FORMAT_PRINTER::PrintOiHeader(UINT64 ProcHeader)
    {
    BaseAddress = ProcHeader;
    UINT64 Address = FormatString.SetAddress(ProcHeader);
    PrintNewStyleProcHeader(FALSE, FALSE, 0);
    FormatString.SetAddress(Address);
    }

void FORMAT_PRINTER::PrintOiParamList(UINT64 Paramlist, UINT64 TypeInfo)
    {
    BaseAddress = Paramlist;
    UINT64 Address = FormatString.SetAddress(Paramlist);
    PrintOldStyleParamList(TypeInfo);
    FormatString.SetAddress(Address);
    }

void FORMAT_PRINTER::PrintOiProc(UINT64 ProcHeader, UINT64 TypeInfo)
    {
    BaseAddress = ProcHeader;
    UINT64 Address = FormatString.SetAddress(ProcHeader);
    PrintNewStyleProcHeader(FALSE, TRUE, TypeInfo);
    FormatString.SetAddress(Address);

    }

// Oif dumper
void FORMAT_PRINTER::PrintOifHeader(UINT64 ProcHeader)
    {
    BaseAddress = ProcHeader;
    UINT64 Address = FormatString.SetAddress(ProcHeader);
    PrintNewStyleProcHeader(TRUE, FALSE, 0);
    FormatString.SetAddress(Address);
    }

void FORMAT_PRINTER::PrintOifParamList(UINT64 ParamList, UINT64 TypeInfo)
    {
    ABORT("Printing the parameter list without the proc header\n" <<
          "is unavailable with the new style proc header.\n\n");
    }

void FORMAT_PRINTER::PrintOifProc(UINT64 ProcHeader, UINT64 TypeInfo)
    {
    BaseAddress = ProcHeader;
    UINT64 Address = FormatString.SetAddress(ProcHeader);
    PrintNewStyleProcHeader(TRUE, TRUE, TypeInfo);
    FormatString.SetAddress(Address);
    }

// Type printer 
void FORMAT_PRINTER::PrintTypeFormat(UINT64 TypeFormatString, BOOL IsRobust)
    {
    TypeSet.Clear();
    Robust = IsRobust;
    TypeSet.Add(TypeFormatString, TypeFormatString);
    TypeSet.PrintTypes(this);
    }

void FORMAT_PRINTER::PrintProcHeader(UINT64 ProcHeader, NDREXTS_STUBMODE_TYPE ContextStubMode)
    {
    switch ( ContextStubMode )
        {
        case OS:
            PrintOsHeader(ProcHeader);
            break;
        case OI:
            PrintOiHeader(ProcHeader);
            break;
        case OIC:
        case OICF:
        case OIF:
            PrintOifHeader(ProcHeader);
            break;
        default:
            ABORT("Corrupt stub mode.\n");
        }
    }

void FORMAT_PRINTER::PrintProcParamList(UINT64 ParamList, UINT64 TypeInfo, 
                                        NDREXTS_STUBMODE_TYPE ContextStubMode)
    {
    switch ( ContextStubMode )
        {
        case OS:
            PrintOsParamList(ParamList, TypeInfo);
            break;
        case OI:
            PrintOiParamList(ParamList, TypeInfo);
            break;
        case OIC:
        case OICF:
        case OIF:
            PrintOifParamList(ParamList, TypeInfo);
            break;
        default:
            ABORT("Corrupt stub mode.\n");
        }   
    }


void FORMAT_PRINTER::PrintProc(UINT64 ProcHeader, UINT64 TypeInfo, 
                               NDREXTS_STUBMODE_TYPE ContextStubMode)
    {
    switch ( ContextStubMode )
        {
        case OS:
            PrintOsProc(ProcHeader, TypeInfo);
            break;
        case OI:
            PrintOiProc(ProcHeader, TypeInfo);
            break;
        case OIC:
        case OICF:
        case OIF:
            PrintOifProc(ProcHeader, TypeInfo);
            break;
        default:
            ABORT("Corrupt stub mode.\n");
        }
    }


void FORMAT_PRINTER::PrintNewStyleProcHeader(BOOL IsOif, BOOL PrintParams, UINT64 TypeList)
    {

    dout << "Oi style header:\n";
    UCHAR HandleType = FormatString.GetUCHAR(); 
    dout << FormatString.GetFormatCharName(HandleType) << '\n';
    UCHAR OiFlags = FormatString.GetUCHAR();
    dout << "OiFlags:     " << HexOut(OiFlags) << '\n';
    {
        IndentLevel l(dout);
        if ( OiFlags & Oi_FULL_PTR_USED ) dout << "Oi_FULL_PTR_USED "; 
        if ( OiFlags & Oi_RPCSS_ALLOC_USED ) dout << "Oi_RPCSS_ALLOC_USED ";
        if ( OiFlags & Oi_OBJECT_PROC ) dout << "Oi_OBJECT_PROC ";
        if ( OiFlags & Oi_HAS_RPCFLAGS ) dout << "Oi_HAS_RPCFLAGS ";
        if ( OiFlags & Oi_IGNORE_OBJECT_EXCEPTION_HANDLING ) 
            {
            if ( OiFlags & Oi_OBJECT_PROC ) dout << "Oi_IGNORE_OBJECT_EXCEPTION_HANDLING ";
            else dout << "ENCODE_IS_USED ";
            } 
        if ( OiFlags & Oi_OBJ_USE_V2_INTERPRETER ) 
            {
            if ( OiFlags & Oi_OBJECT_PROC ) dout << "(Oi_OBJ_USE_V2_INTERPRETER|Oi_HAS_COMM_OR_FAULT) ";
            else dout << "(Oi_HAS_COMM_OR_FAULT|DECODE_IS_USED) ";
            }
        if ( OiFlags & Oi_USE_NEW_INIT_ROUTINES )  dout << "Oi_USE_NEW_INIT_ROUTINES ";
        dout << '\n';
    }

    if ( OiFlags & Oi_HAS_RPCFLAGS )
        {
        dout << "Rpc flags:   " << HexOut(FormatString.GetULONG()) << '\n';
        }   
    dout << "Proc number: " << HexOut(FormatString.GetUSHORT()) << "                    ";
    dout << "Stack size:  " << HexOut(FormatString.GetUSHORT()) << '\n';

    if ( HandleType==0 )
        {
        UCHAR HandleType = FormatString.GetUCHAR();
        switch ( HandleType )
            {
            case FC_BIND_PRIMITIVE:
                // Output the FC_BIND_PRIMITIVE
                dout << FormatString.GetFormatCharName(HandleType) << '\n';
                {
                    IndentLevel l(dout);
                    dout << "Flags:  " << HexOut(FormatString.GetUCHAR()) << '\n';
                    dout << "Offset: " << HexOut(FormatString.GetUSHORT()) << '\n';
                }
                break;
            case FC_BIND_GENERIC:
                {
                    // Output the FC_BIND_GENERIC
                    dout << FormatString.GetFormatCharName(HandleType) << '\n';
                    {
                        IndentLevel l(dout);
                        UCHAR FlagsAndSize = FormatString.GetUCHAR();
                        dout << "FlagsAndSize:               " << HexOut(FlagsAndSize) 
                        << " Flags: " << HexOut((UCHAR)(FlagsAndSize >> 8))
                        << " Size:  " << HexOut((UCHAR)(FlagsAndSize & 0xF)) << '\n';
                        dout << "Offset:                     " << HexOut(FormatString.GetUSHORT()) << '\n';
                        dout << "Binding routine pair index: " << HexOut(FormatString.GetUCHAR()) << '\n';
                        dout << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n';
                    }
                    break;
                }
            case FC_BIND_CONTEXT:
                // Output the FC_BIND_PRIMITIVE
                dout << FormatString.GetFormatCharName(HandleType) << '\n';
                {
                    IndentLevel l(dout);
                    dout << "Flags:                         " << HexOut(FormatString.GetUCHAR()) << '\n';
                    dout << "Offset:                        " << HexOut(FormatString.GetUSHORT()) << '\n';
                    dout << "Context rundown routine index: " << FormatString.GetUCHAR() << '\n';
                    dout << "Parameter number:              " << FormatString.GetUCHAR() << '\n';
                }
                break;
            default:
                dout << "Unknown handle type " << HexOut(HandleType) << '\n';
                break;
            }  
        }

    // Oif extensions
    if ( IsOif )
        {

        dout << "Oif extensions:\n";
        dout << "Constant client buffer size: " << HexOut(FormatString.GetUSHORT()) << "    ";
        dout << "Constant server buffer size: " << HexOut(FormatString.GetUSHORT()) << '\n';

        UCHAR InterpreterFlagsUCHAR = FormatString.GetUCHAR();
        PINTERPRETER_OPT_FLAGS InterpreterFlags = (PINTERPRETER_OPT_FLAGS)&InterpreterFlagsUCHAR;
        dout << "INTERPRETER_OPT_FLAGS: \n";
        {
            IndentLevel l(dout);
            if (InterpreterFlags->ServerMustSize) dout << "ServerMustSize ";
            if (InterpreterFlags->ClientMustSize) dout << "ClientMustSize ";
            if (InterpreterFlags->HasReturn) dout << "HasReturn ";
            if (InterpreterFlags->HasPipes) dout << "HasPipes ";
            if (InterpreterFlags->HasAsyncUuid) dout << "HasAsyncUuid ";
            if (InterpreterFlags->HasExtensions) dout << "HasExtensions ";
            if (InterpreterFlags->HasAsyncHandle) dout << "HasAsyncHandle ";
            dout << '\n';
            dout << "Unused:         " << HexOut(InterpreterFlags->Unused) << '\n';
        }

        UCHAR NumberOfParameters = FormatString.GetUCHAR();
        dout << "NumberOfParameters: " << HexOut(NumberOfParameters) << '\n';

        // NT 5.0 extensions
        if ( InterpreterFlags->HasExtensions )
            {

            dout << "NT5.0 extensions\n";
            UCHAR ExtensionVersion = FormatString.GetUCHAR();
            dout << "Extension Version: " << HexOut(ExtensionVersion) << '\n';

            UCHAR InterpreterFlags2UCHAR = FormatString.GetUCHAR();
            PINTERPRETER_OPT_FLAGS2 InterpreterFlags2 = (PINTERPRETER_OPT_FLAGS2)&InterpreterFlags2UCHAR;
            dout << "INTERPRETER_OPT_FLAGS2: \n";
            {
                IndentLevel l(dout);
                if (InterpreterFlags2->HasNewCorrDesc) 
                    {
                    dout << "HasNewCorrDesc ";
                    Robust = TRUE;
                    }
                if (InterpreterFlags2->ClientCorrCheck) dout << "ClientCorrCheck ";
                if (InterpreterFlags2->ServerCorrCheck) dout << "ServerCorrCheck ";
                if (InterpreterFlags2->HasNotify) dout << "HasNotify ";
                if (InterpreterFlags2->HasNotify2) dout << "HasNotify2 ";
                dout << '\n';
                dout << "Unused:          " << HexOut(InterpreterFlags2->Unused) << '\n';
            } 
            dout << "ClientCorrHint:    " << HexOut(FormatString.GetUSHORT()) << "              ";
            dout << "ServerCorrHint:    " << HexOut(FormatString.GetUSHORT()) << '\n';
            dout << "NotifyIndex:       " << HexOut(FormatString.GetUSHORT()) << "              ";
            if ( ExtensionVersion == 12 )
                {
                dout << "FloatDoubleMask:   " << HexOut(FormatString.GetULONG()) << '\n';
                }
            else 
                dout << '\n';

            }

        if ( PrintParams )
            {
            PrintNewSytleParamList(NumberOfParameters, TypeList);
            }

        }
    }

void FORMAT_PRINTER::PrintNewSytleParamList(UINT NumberOfParameters, UINT64 TypeList)
    {

    TypeSet.Clear();
    dout << '\n';
    dout << "Oif style parameter list( " << NumberOfParameters << " parameters )\n";
    UINT ParamNumber = 0;
    while ( NumberOfParameters-- )
        {
        dout << "Param:            " << HexOut(ParamNumber++) << '\n';
        USHORT ParamAttributesUSHORT = FormatString.GetUSHORT();
        PPARAM_ATTRIBUTES ParamAttributes = (PPARAM_ATTRIBUTES)&ParamAttributesUSHORT;
        dout << "Param attributes: \n";
        {
            IndentLevel l(dout);
            if (ParamAttributes->MustSize) dout << "MustSize ";
            if (ParamAttributes->MustFree) dout << "MustFree ";
            if (ParamAttributes->IsPipe) dout << "IsPipe ";
            if (ParamAttributes->IsIn) dout << "IsIn ";
            if (ParamAttributes->IsOut) dout << "IsOut ";
            if (ParamAttributes->IsReturn) dout << "IsReturn ";
            if (ParamAttributes->IsBasetype) dout << "IsBasetype ";
            if (ParamAttributes->IsByValue) dout << "IsByValue ";
            if (ParamAttributes->IsSimpleRef) dout << "IsSimpleRef ";
            if (ParamAttributes->IsDontCallFreeInst) dout << "IsDontCallFreeInst ";
            if (ParamAttributes->SaveForAsyncFinish) dout << "SaveForAsyncFinish ";
            if (ParamAttributes->IsPartialIgnore) dout << "IsPartialIgnore ";
            if (ParamAttributes->IsForceAllocate) dout << "IsForceAllocate ";
            dout << '\n';
            dout << "ServerAllocSize:  " << HexOut(ParamAttributes->ServerAllocSize) << "              ";
            dout << '\n';
        }
        dout << "Stack offset:     " << HexOut(FormatString.GetUSHORT()) << "               ";
        if ( ParamAttributes->IsBasetype )
            {
            dout << "TypeFormatChar:   " << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n';
            dout << "Unused:           " << HexOut(FormatString.GetUCHAR()) << '\n';
            }
        else
            {
            dout << '\n';
            ProcOutputTypeAtOffset(TypeList);
            }
        dout << '\n';
        }

    dout << '\n';
    dout << "Printing the set of types used.\n";
    TypeSet.PrintTypes(this);
    dout << "End of types.\n";
    dout << "\n";
    }

    

void FORMAT_PRINTER::PrintOldStyleParamList(UINT64 TypeListAddress)
    {

    TypeSet.Clear();

    UINT ParamNumber = 0;
    dout << "Os/Oi style parameter list\n";

    while ( 1 )
        {
        UCHAR Format = FormatString.ReadUCHAR();
        switch ( Format )
            {
            case FC_END:
                dout << "FC_END\n";
                goto Exit;
            case FC_IN_PARAM_BASETYPE:
                dout << "Param:      " << ParamNumber++ << '\n';
                dout << "FC_IN_PARAM_BASETYPE\n";
                OutputType();
                break;
            case FC_RETURN_PARAM_BASETYPE:
                dout << "Param:      " << ParamNumber++ << '\n';
                dout << "FC_RETURN_PARAM_BASETYPE\n";
                OutputType();
                break;
            default:
                dout << "Param:      " << ParamNumber++ << '\n'; 
                dout << FormatString.GetFormatCharName(Format) << '\n';
                dout << "Stack size: " << HexOut(FormatString.GetUCHAR()) << '\n';
                ProcOutputTypeAtOffset(TypeListAddress);         
            }
        dout << '\n';

        }
Exit:
    dout << '\n';
    dout << "Printing the set of types used.\n";
    TypeSet.PrintTypes(this);
    dout << "End of types.\n";

    }

void FORMAT_PRINTER::ProcOutputTypeAtOffset(UINT64 TypeList)
    {

    UINT64 Address = FormatString.GetAddress();
    SHORT Offset = FormatString.GetUSHORT();
    if ( !TypeList )
        {
        dout << "Type offset: " << HexOut(Offset) << '(' << Offset << ")\n";
        return;
        }

    if ( !Offset)
        {
        dout << "Type offset is 0, type info is not available!\n";         
        }

    UINT64 NewAddress = TypeList+Offset;
    UINT64 OldBaseAddress = BaseAddress;
    BaseAddress = TypeList;
    PrintOffsetComment("Type offset: ", Offset, NewAddress);
    TypeSet.Add(NewAddress, TypeList);
    BaseAddress = OldBaseAddress;    
    }

void FORMAT_PRINTER::OutputTypeAtOffset(char *Label, char *NoOffsetComment)
    {
    UINT64 Address = FormatString.GetAddress();
    SHORT Offset = FormatString.GetUSHORT();
    
    if ( !Offset )
        {
        dout << NoOffsetComment << '\n';
        return;
        }

    UINT64 NewAddress = Address+Offset;
    PrintOffsetComment(Label, Offset, NewAddress);
    
    TypeSet.Add(NewAddress, BaseAddress);

    }

void FORMAT_PRINTER::PrintFormatOffset()
    {
    ULONG Offset = FormatString.GetAddress() - BaseAddress;
    dout << HexOut(Offset) << '(' << Offset << ')' << ' ';
    }

VOID FORMAT_PRINTER::PrintOffsetComment(const char *pComment, SHORT Offset, UINT64 NewAddress)
{
    LONG NewRelAddress = NewAddress - BaseAddress;
    dout << pComment << HexOut(Offset) << '(' << Offset << ')' << " to "
                     << HexOut(NewRelAddress) << '(' << NewRelAddress << ')' << '\n';
}

#define DISPATCH_TYPE(type)         \
   case type:                       \
      HANDLE_##type ();             \
      break;

void FORMAT_PRINTER::OutputType()
    {

    UINT64 Address = FormatString.GetAddress();
    
    PrintFormatOffset();
    UCHAR FormatChar = FormatString.ReadUCHAR();
    switch ( FormatChar )
        {
        default:
            ABORT( "Unknown type " << HexOut(FormatChar) << ".\n" );
            break;

            DISPATCH_TYPE(FC_ZERO)
            DISPATCH_TYPE(FC_BYTE)                    
            DISPATCH_TYPE(FC_CHAR)                    
            DISPATCH_TYPE(FC_SMALL)                   
            DISPATCH_TYPE(FC_USMALL)                  
            DISPATCH_TYPE(FC_WCHAR)                   
            DISPATCH_TYPE(FC_SHORT)                   
            DISPATCH_TYPE(FC_USHORT)                  
            DISPATCH_TYPE(FC_LONG)                    
            DISPATCH_TYPE(FC_ULONG)                   
            DISPATCH_TYPE(FC_FLOAT)                   
            DISPATCH_TYPE(FC_HYPER)                  
            DISPATCH_TYPE(FC_DOUBLE)                  
            DISPATCH_TYPE(FC_ENUM16)                  
            DISPATCH_TYPE(FC_ENUM32)                  
            DISPATCH_TYPE(FC_IGNORE)                  
            DISPATCH_TYPE(FC_ERROR_STATUS_T)          
            DISPATCH_TYPE(FC_RP)                   
            DISPATCH_TYPE(FC_UP)                   
            DISPATCH_TYPE(FC_OP)                   
            DISPATCH_TYPE(FC_FP)                    
            DISPATCH_TYPE(FC_STRUCT)                  
            DISPATCH_TYPE(FC_PSTRUCT)               
            DISPATCH_TYPE(FC_CSTRUCT)                 
            DISPATCH_TYPE(FC_CPSTRUCT)               
            DISPATCH_TYPE(FC_CVSTRUCT)      
            DISPATCH_TYPE(FC_BOGUS_STRUCT)          
            DISPATCH_TYPE(FC_CARRAY)             
            DISPATCH_TYPE(FC_CVARRAY)             
            DISPATCH_TYPE(FC_SMFARRAY)            
            DISPATCH_TYPE(FC_LGFARRAY)         
            DISPATCH_TYPE(FC_SMVARRAY)            
            DISPATCH_TYPE(FC_LGVARRAY)            
            DISPATCH_TYPE(FC_BOGUS_ARRAY)       
            DISPATCH_TYPE(FC_C_CSTRING)                
            DISPATCH_TYPE(FC_C_SSTRING)           
            DISPATCH_TYPE(FC_C_WSTRING)            
            DISPATCH_TYPE(FC_CSTRING)                        
            DISPATCH_TYPE(FC_SSTRING)              
            DISPATCH_TYPE(FC_WSTRING)               
            DISPATCH_TYPE(FC_ENCAPSULATED_UNION)      
            DISPATCH_TYPE(FC_NON_ENCAPSULATED_UNION) 
            DISPATCH_TYPE(FC_BYTE_COUNT_POINTER)      
            DISPATCH_TYPE(FC_TRANSMIT_AS)            
            DISPATCH_TYPE(FC_REPRESENT_AS)            
            DISPATCH_TYPE(FC_IP)                     
            DISPATCH_TYPE(FC_BIND_CONTEXT)          
            DISPATCH_TYPE(FC_BIND_GENERIC)          
            DISPATCH_TYPE(FC_BIND_PRIMITIVE)       
            DISPATCH_TYPE(FC_AUTO_HANDLE)             
            DISPATCH_TYPE(FC_CALLBACK_HANDLE)           
            DISPATCH_TYPE(FC_UNUSED1)                       
            DISPATCH_TYPE(FC_ALIGNM2)               
            DISPATCH_TYPE(FC_ALIGNM4)               
            DISPATCH_TYPE(FC_ALIGNM8)               
            DISPATCH_TYPE(FC_UNUSED2)              
            DISPATCH_TYPE(FC_UNUSED3)             
            DISPATCH_TYPE(FC_UNUSED4)             
            DISPATCH_TYPE(FC_STRUCTPAD1)       
            DISPATCH_TYPE(FC_STRUCTPAD2)            
            DISPATCH_TYPE(FC_STRUCTPAD3)           
            DISPATCH_TYPE(FC_STRUCTPAD4)            
            DISPATCH_TYPE(FC_STRUCTPAD5)            
            DISPATCH_TYPE(FC_STRUCTPAD6)             
            DISPATCH_TYPE(FC_STRUCTPAD7)            
            DISPATCH_TYPE(FC_EMBEDDED_COMPLEX)        
            DISPATCH_TYPE(FC_END)                     
            DISPATCH_TYPE(FC_PAD)                                 
            DISPATCH_TYPE(FC_USER_MARSHAL)           
            DISPATCH_TYPE(FC_PIPE)                   
            DISPATCH_TYPE(FC_BLKHOLE)                 
            DISPATCH_TYPE(FC_RANGE)                       
            DISPATCH_TYPE(FC_INT3264)              
            DISPATCH_TYPE(FC_UINT3264)   
        }

    }

// Many types just need printing
#define PRINT_SIMPLE_TYPE(type)             \
void FORMAT_PRINTER::HANDLE_##type() { \
   dout << #type "\n";                      \
   FormatString.IncUCHAR();                 \
}                                           \

// Some types need redirecting to a common processing function
#define PRINT_REDIRECT_TYPE(type,func)      \
void FORMAT_PRINTER::HANDLE_##type() { \
   func();                                  \
}

PRINT_SIMPLE_TYPE(FC_ZERO)
PRINT_SIMPLE_TYPE(FC_BYTE)                    
PRINT_SIMPLE_TYPE(FC_CHAR)                    
PRINT_SIMPLE_TYPE(FC_SMALL)                   
PRINT_SIMPLE_TYPE(FC_USMALL)                  
PRINT_SIMPLE_TYPE(FC_WCHAR)                   
PRINT_SIMPLE_TYPE(FC_SHORT)                   
PRINT_SIMPLE_TYPE(FC_USHORT)                  
PRINT_SIMPLE_TYPE(FC_LONG)                    
PRINT_SIMPLE_TYPE(FC_ULONG)                   
PRINT_SIMPLE_TYPE(FC_FLOAT)                   
PRINT_SIMPLE_TYPE(FC_HYPER)                  
PRINT_SIMPLE_TYPE(FC_DOUBLE)                  
PRINT_SIMPLE_TYPE(FC_ENUM16)                  
PRINT_SIMPLE_TYPE(FC_ENUM32)                  
PRINT_SIMPLE_TYPE(FC_IGNORE)                  
PRINT_SIMPLE_TYPE(FC_ERROR_STATUS_T)

void FORMAT_PRINTER::PrintPointerType()
    {

    dout << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n';

    UCHAR Flags = FormatString.GetUCHAR();
    dout << "Flags: " << HexOut(Flags);
    if ( Flags & FC_ALLOCATE_ALL_NODES )
        {
        dout << " FC_ALLOCATE_ALL_NODES ";
        }
    if ( Flags & FC_DONT_FREE )
        {
        dout << " FC_DONT_FREE ";
        }
    if ( Flags & FC_ALLOCED_ON_STACK )
        {
        dout << " FC_ALLOCATED_ON_STACK ";
        }
    if ( Flags & FC_SIMPLE_POINTER )
        {
        dout << " FC_SIMPLE_POINTER ";
        }
    if ( Flags & FC_POINTER_DEREF )
        {
        dout << " FC_POINTER_DEREF ";
        }
    dout << '\n';

    if ( Flags & FC_SIMPLE_POINTER )
        {
        // Output the simple type
        OutputType();
        FormatString.IncUCHAR();
        }
    else
        {
        OutputTypeAtOffset("Offset to type: ", "Offset to type is 0, no type info.");
        }

    }

void FORMAT_PRINTER::PrintPointerInstance(void)
    {

    SHORT  OffsetInMemory = FormatString.GetSHORT();
    dout << "Offset to pointer in memory: " << HexOut(OffsetInMemory) 
    << '(' << OffsetInMemory << ")\n";

    SHORT  OffsetInBuffer = FormatString.GetSHORT();
    dout << "Offset to pointer in buffer: " << HexOut(OffsetInBuffer) 
    << '(' << OffsetInBuffer << ")\n";

    PrintPointerType();

    }

void FORMAT_PRINTER::PrintPointerRepeat(void)
    {

    UCHAR LayoutType = FormatString.GetUCHAR();
    dout << FormatString.GetFormatCharName(LayoutType) << '\n';

    //The next char should be FC_FIXED_OFFSET, FC_VARIABLE_OFFSET, or FC_PAD
    dout << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n';

    if ( FC_FIXED_REPEAT == LayoutType )
        {
        dout << "Iterations:         " << HexOut(FormatString.GetUCHAR()) << '\n';
        }

    dout << "Increment:          " << HexOut(FormatString.GetUSHORT()) << '\n';
    dout << "Offset to array:    " << HexOut(FormatString.GetUSHORT()) << '\n';

    USHORT NumberOfPointers = FormatString.GetUSHORT();
    dout << "Number of pointers: " << HexOut(NumberOfPointers) << '\n';

    while ( NumberOfPointers-- )
        {
        PrintPointerInstance();
        }

    }

void FORMAT_PRINTER::PrintPointerLayout()
    {

    UCHAR FcPP = FormatString.ReadUCHAR();
    if ( FC_PP != FcPP )
        {
        // This isn't a pointer layout so silently return
        return;
        }
    FormatString.IncUCHAR();
    dout << "FC_PP\n";

    //Output the FC_PAD
    OutputType();

    UCHAR LayoutType;
    while ( LayoutType = FormatString.GetUCHAR(), LayoutType != FC_END )
        {
        switch ( LayoutType )
            {
            case FC_NO_REPEAT:
                dout << "FC_NO_REPEAT\n";         
                // Output the FC_PAD
                OutputType();
                PrintPointerInstance();
                break;
            case FC_FIXED_REPEAT:
            case FC_VARIABLE_REPEAT:
                FormatString.SetAddress(FormatString.GetAddress() - sizeof(UCHAR));
                PrintPointerRepeat();
                break;
            default:
                dout << "Unknown pointer layout type " << HexOut(LayoutType) << '\n';
                return;
            }
        }

    }

void FORMAT_PRINTER::PrintCorrelationDescriptor()
    {

    UCHAR CorrelationType = FormatString.GetUCHAR();     

    dout << "Correlation descriptor:\n";
        {

        IndentLevel l(dout);

        dout << "Correlation type:     " << HexOut(CorrelationType);
        switch ( CorrelationType & 0xF0 )
            {
            case FC_NORMAL_CONFORMANCE:
                dout << "(FC_NORMAL_CONFORMANCE,";
                break;
            case FC_POINTER_CONFORMANCE:
                dout << "(FC_POINTER_CONFORMANCE,";
                break;
            case FC_TOP_LEVEL_CONFORMANCE:
                dout << "(FC_TOP_LEVEL_CONFORMANCE,";
                break;
            case FC_TOP_LEVEL_MULTID_CONFORMANCE:
                dout << "(FC_TOP_LEVEL_MULTID_CONFORMANCE,";
                break;
            case FC_CONSTANT_CONFORMANCE:
                dout << "(FC_CONSTANT_CONFORMANCE,";
                break;
            default:
                dout << "(Unknown,";
                break;
            }
        dout << FormatString.GetFormatCharName(CorrelationType & 0x0F) << ")\n";

        UCHAR CorrelationOperator = FormatString.GetUCHAR();     
        dout << "Correlation operator: " << HexOut(CorrelationOperator);
        switch ( CorrelationOperator )
            {
            case FC_DEREFERENCE:
                dout << "(FC_DEREFERENCE)\n";
                break;
            case FC_DIV_2:
                dout << "(FC_DIV_2)\n";
                break;
            case FC_MULT_2:
                dout << "(FC_MULT_2)\n";
                break;
            case FC_SUB_1:
                dout << "(FC_SUB_1)\n";
                break;
            case FC_ADD_1:
                dout << "(FC_ADD_1)\n";
                break;
            case FC_CALLBACK:
                dout << "(FC_CALLBACK)\n";
                break;
            case 0:
                dout << "(NONE)\n";
                break;
            default:
                dout << "(Unknown)\n";
                break;
            }

        SHORT Offset = FormatString.GetSHORT();
        dout << "Offset:               " << HexOut(Offset) << '(' << Offset << ")\n";

        if ( Robust )
            {

            USHORT FlagsAsUSHORT = FormatString.GetUSHORT();
            NDR_CORRELATION_FLAGS *pFlags = (NDR_CORRELATION_FLAGS*)&FlagsAsUSHORT;

            dout << "Robust flags: ";
            if ( pFlags->Early )
                {
                dout << " Early ";
                }
            if ( pFlags->Split )
                {
                dout << " Split ";
                }
            if ( pFlags->IsIidIs )
                {
                dout << " IsIidIs ";
                }
            if ( pFlags->DontCheck )
                {
                dout << " IsIidIs ";
                }
            dout << '\n';
            }
        
        }
    }


PRINT_REDIRECT_TYPE(FC_RP,PrintPointerType)                    
PRINT_REDIRECT_TYPE(FC_UP,PrintPointerType)                    
PRINT_REDIRECT_TYPE(FC_OP,PrintPointerType)                     
PRINT_REDIRECT_TYPE(FC_FP,PrintPointerType)

// Structs have a common code path
#define PRINT_STRUCT_TYPE(type,ha,hp,hbp)    \
void FORMAT_PRINTER::HANDLE_##type() {  \
   PrintStruct(ha,hp,hbp);                   \
}

void FORMAT_PRINTER::PrintStruct(BOOL bHasArray, BOOL bHasPointers, BOOL bHasBogusPointers)
    {

    

    dout << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n';
    dout << "Alignment:   " << HexOut(FormatString.GetUCHAR()) << "      ";
    dout << "Memory size: " << HexOut(FormatString.GetUSHORT()) << '\n';

    if ( bHasArray )
        {
        OutputTypeAtOffset("Offset to array description: ", "Offset is 0, no array.");
        }

    UINT64 PointerLayoutAddress = FormatString.GetAddress();

    if ( bHasBogusPointers )
        {
        UINT64 Address = FormatString.GetAddress();
        SHORT Offset = FormatString.GetSHORT();
        UINT64 NewAddress = Address + Offset;
        PrintOffsetComment("Offset to bogus pointer layout: ", Offset, NewAddress);
        PointerLayoutAddress = NewAddress;
        }
    if ( bHasPointers )
        {
        dout << "Structure pointer layout:\n";
        UINT64 CurrentAddress = FormatString.SetAddress(PointerLayoutAddress); 
        PrintPointerLayout();
        if ( bHasBogusPointers )
            {
            PointerLayoutAddress = FormatString.SetAddress(CurrentAddress);            
            }

        }

    dout << "Structure memory layout:\n";
    UCHAR Format;
    while ( Format = FormatString.ReadUCHAR(), Format != FC_END )
        {
        IndentLevel l(dout);
        if ( FC_POINTER == Format )
            {
            dout << "FC_POINTER\n";
            FormatString.IncUCHAR();
            UINT64 CurrentAddress = FormatString.SetAddress(PointerLayoutAddress);
            PrintPointerType();
            PointerLayoutAddress = FormatString.SetAddress(CurrentAddress);
            }
        else {
            OutputType();            
        }
        }
    // Output the FC_END
    OutputType();

    }

//                type             ha     hp     hbp
PRINT_STRUCT_TYPE(FC_STRUCT,       FALSE, FALSE, FALSE)                  
PRINT_STRUCT_TYPE(FC_PSTRUCT,      FALSE, TRUE,  FALSE)               
PRINT_STRUCT_TYPE(FC_CSTRUCT,      TRUE,  FALSE, FALSE)                 
PRINT_STRUCT_TYPE(FC_CPSTRUCT,     TRUE,  TRUE,  FALSE)               
PRINT_STRUCT_TYPE(FC_CVSTRUCT,     TRUE,  TRUE,  FALSE)
PRINT_STRUCT_TYPE(FC_BOGUS_STRUCT, TRUE,  FALSE, TRUE)


// Arrays have a common code path
#define PRINT_ARRAY_TYPE(type,ts2,ts4,ne2,ne4,esize,cd,vd)       \
void FORMAT_PRINTER::HANDLE_##type() {                      \
    PrintArray(ts2,ts4,ne2,ne4,esize,cd,vd);                     \
}

void FORMAT_PRINTER::PrintArray(BOOL HasTotalSize2,
                                BOOL HasTotalSize4,
                                BOOL HasNumberElements2,                   
                                BOOL HasNumberElements4,
                                BOOL HasElementSize,
                                BOOL HasConformanceDescription,
                                BOOL HasVarianceDescription
                               )
    {
    dout << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n'; 
    dout << "Alignment:       " << HexOut(FormatString.GetUCHAR()) << '\n';

    if ( HasTotalSize2 )
        {
        dout << "Total Size:      " << HexOut(FormatString.GetUSHORT()) << '\n';
        }

    if ( HasTotalSize4 )
        {
        dout << "Total Size:      " << HexOut(FormatString.GetULONG()) << '\n';
        }

    if ( HasNumberElements2 )
        {
        dout << "Number Elements: " << HexOut(FormatString.GetUSHORT()) << '\n';
        }

    if ( HasNumberElements4 )
        {
        dout << "Number Elements: " << HexOut(FormatString.GetULONG()) << '\n';
        }

    if ( HasElementSize )
        {
        dout << "Element Size:    " << HexOut(FormatString.GetUSHORT()) << '\n';
        }

    if ( HasConformanceDescription )
        {
        dout << "Array conformance descriptor:\n";
        PrintCorrelationDescriptor();
        }

    if ( HasVarianceDescription )
        {
        dout << "Array variance descriptor:\n";
        PrintCorrelationDescriptor();
        }

    dout << "Array pointer layout:\n";
    PrintPointerLayout();
    dout << "Element type:\n";
    OutputType();
    //Output the trailing FC_END
    OutputType();      
    }

//               type            ts2    ts4    ne2    ne4    esize  cd     vd
PRINT_ARRAY_TYPE(FC_CARRAY,      FALSE, FALSE, FALSE, FALSE, TRUE,  TRUE,  FALSE)             
PRINT_ARRAY_TYPE(FC_CVARRAY,     FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE)             
PRINT_ARRAY_TYPE(FC_SMFARRAY,    TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)
PRINT_ARRAY_TYPE(FC_LGFARRAY,    FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE)
PRINT_ARRAY_TYPE(FC_SMVARRAY,    TRUE,  FALSE, TRUE,  FALSE, TRUE,  FALSE, TRUE)
PRINT_ARRAY_TYPE(FC_LGVARRAY,    FALSE, TRUE,  FALSE, TRUE,  TRUE,  FALSE, TRUE)
PRINT_ARRAY_TYPE(FC_BOGUS_ARRAY, FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE,  TRUE)            

void FORMAT_PRINTER::PrintFixedString()
    {

    dout << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n';

    // Output the FC_PAD
    OutputType();

    dout << "String size: " << HexOut(FormatString.GetUSHORT()) << '\n';
    }

//DISPATCH_TYPE(FC_C_BSTRING)
PRINT_REDIRECT_TYPE(FC_CSTRING,PrintFixedString)
PRINT_REDIRECT_TYPE(FC_WSTRING,PrintFixedString)

void FORMAT_PRINTER::HANDLE_FC_C_SSTRING()
    {

    dout << "FC_C_SSTRING\n";
    FormatString.IncUCHAR();

    dout << "Element Size: " << FormatString.GetUCHAR() << '\n';
    dout << "Elements: " << FormatString.GetUSHORT() << '\n';
    }

void FORMAT_PRINTER::PrintCountedString()
    {

    dout << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n';    

    UCHAR PadChar = FormatString.GetUCHAR();
    if ( FC_PAD == PadChar )
        {
        dout << "FC_PAD\n";
        }
    else if ( FC_STRING_SIZED == PadChar )
        {
        dout << "FC_STRING_SIZED\n";
        PrintCorrelationDescriptor();
        }
    else
        {
        dout << "Unexpected char " << HexOut(PadChar) << '\n';
        }

    }

PRINT_REDIRECT_TYPE(FC_C_CSTRING,PrintCountedString)
PRINT_REDIRECT_TYPE(FC_C_WSTRING,PrintCountedString)            


//DISPATCH_TYPE(FC_BSTRING)            

void FORMAT_PRINTER::HANDLE_FC_SSTRING()
    {

    dout << "FC_C_SSTRING\n";
    FormatString.IncUCHAR();

    dout << "Element Size: " << FormatString.GetUCHAR() << '\n';
    dout << "Elements:     " << FormatString.GetUSHORT() << '\n';

    }

void FORMAT_PRINTER::PrintUnionArmOffsetToDescriptor()
    {
    
    SHORT OffsetToArmDescription = FormatString.ReadSHORT();
    
    dout << "Offset to arm description: " << HexOut(OffsetToArmDescription);
    if ( 0x8000 == (OffsetToArmDescription & 0xFF00) )
        {
        dout << " Simple type: " << 
        FormatString.GetFormatCharName((UCHAR)(OffsetToArmDescription & 0xFF)) << '\n';
        FormatString.IncSHORT();
        }
    else
        {
        dout << '\n';
        OutputTypeAtOffset(" Offset ", "Offset is 0, so arm is unused.");
        }    
    }

void FORMAT_PRINTER::PrintUnionArmSelector()
    {
    PrintFormatOffset();
    dout << "Union arm selector.\n";
    dout << "Memory size:  " << FormatString.GetUSHORT() << '\n';
    USHORT UnionArms = FormatString.GetUSHORT();

    USHORT ArmCounter;
    dout << "Union arms:   " << HexOut(UnionArms) 
    << " Alignment:   " << HexOut((USHORT)(UnionArms >> 12))
    << " ArmCounter:  " << HexOut(ArmCounter = (UnionArms & 0x0FFF)) << '\n';

    while ( ArmCounter-- )
        {
        ULONG ArmCaseValue = FormatString.GetULONG();
        dout << "ArmCaseValue: " << HexOut(ArmCaseValue) << ' ';

        PrintUnionArmOffsetToDescriptor(); 

        }
    dout << "Default arm\n";
    PrintUnionArmOffsetToDescriptor();

    }

void FORMAT_PRINTER::HANDLE_FC_ENCAPSULATED_UNION()
    {

    dout << "FC_ENCAPSULATED_UNION\n";
    FormatString.IncUCHAR();

    UCHAR SwitchType = FormatString.GetUCHAR();
    dout << "SwitchType:   " << HexOut(SwitchType) 
    << " MemoryInc:   " << HexOut((USHORT)(SwitchType & 0xF0)) 
    << " Actual Type: " << FormatString.GetFormatCharName(SwitchType & 0x0F) << '\n';

    PrintUnionArmSelector();

    }

void FORMAT_PRINTER::HANDLE_FC_NON_ENCAPSULATED_UNION()
    {

    dout << "FC_NON_ENCAPSULATED_UNION\n";
    FormatString.IncUCHAR();

    UCHAR SwitchType = FormatString.GetUCHAR();
    dout << "SwitchType:   " << HexOut(SwitchType) 
    << "(" << FormatString.GetFormatCharName(SwitchType) << ")\n";

    PrintCorrelationDescriptor();

    UINT64 CurrentAddress = FormatString.GetAddress();
    SHORT Offset = FormatString.GetSHORT();
    
        
    if ( Offset )
        {
        UINT64 NewAddress = CurrentAddress + Offset;
        PrintOffsetComment("Offset to union arms: ", Offset, NewAddress);
        FormatString.SetAddress(NewAddress);
        PrintUnionArmSelector();
        }
    else
        {
        dout << "Type offset is 0, type info is not available!\n";      
        }
    FormatString.SetAddress(CurrentAddress);
    FormatString.IncSHORT();

    }

void FORMAT_PRINTER::HANDLE_FC_BYTE_COUNT_POINTER()
    {

    dout << "FC_BYTE_COUNT_POINTER";
    FormatString.IncUCHAR();

    UCHAR SimpleType = FormatString.GetUCHAR();
    dout << "Simple Type:  " << FormatString.GetFormatCharName(SimpleType) << '\n';

    PrintCorrelationDescriptor();
    if ( FC_PAD == SimpleType )
        {
        dout << "Pointee description:\n";
        IndentLevel l(dout);
        OutputType();
        }
    }

void FORMAT_PRINTER::PrintTransmitAsRepresentAs()
    {

    dout << FormatString.GetFormatCharName(FormatString.GetUCHAR()) << '\n';

    UCHAR Flags = FormatString.GetUCHAR();

    dout << "Flags:                        " << HexOut(Flags) << '\n';
    {
        IndentLevel l(dout);
        if ( Flags & PRESENTED_TYPE_IS_ARRAY )
            {
            dout << " PRESENTED_TYPE_IS_ARRAY ";
            }
        if ( Flags & PRESENTED_TYPE_ALIGN_4 )
            {
            dout << " PRESENTED_TYPE_ALIGN_4 ";
            }
        if ( Flags & PRESENTED_TYPE_ALIGN_8 )
            {
            dout << " PRESENTED_TYPE_ALIGN_8 ";
            }
        dout << '\n';
    }

    dout << "Quintuple Index:              " << HexOut(FormatString.GetUSHORT()) << '\n';
    dout << "Presented type memory size:   " << HexOut(FormatString.GetUSHORT()) << '\n';
    dout << "Transmitted type buffer size: " << HexOut(FormatString.GetUSHORT()) << '\n';

    OutputTypeAtOffset("Offset to transmitted type: ", "Offset to tranmitted type is zero, no type selected.");

    }

PRINT_REDIRECT_TYPE(FC_TRANSMIT_AS, PrintTransmitAsRepresentAs)            
PRINT_REDIRECT_TYPE(FC_REPRESENT_AS, PrintTransmitAsRepresentAs)

void FORMAT_PRINTER::HANDLE_FC_IP()
    {

    dout << "FC_IP\n";
    FormatString.IncUCHAR();

    UCHAR SimpleType = FormatString.GetUCHAR();

    if ( FC_CONSTANT_IID == SimpleType )
        {
        dout << "FC_CONSTANT_IID\n";
        dout << "GUID:         " << FormatString.GetGUID() << '\n';
        }
    else if ( FC_PAD == SimpleType )
        {
        dout << "FC_PAD\n";
        PrintCorrelationDescriptor();
        }
    else
        {
        dout << "Unexpected char " << HexOut(SimpleType) << '\n';
        }

    }

PRINT_SIMPLE_TYPE(FC_BIND_CONTEXT)          
PRINT_SIMPLE_TYPE(FC_BIND_GENERIC)          
PRINT_SIMPLE_TYPE(FC_BIND_PRIMITIVE)       
PRINT_SIMPLE_TYPE(FC_AUTO_HANDLE)             
PRINT_SIMPLE_TYPE(FC_CALLBACK_HANDLE)           
PRINT_SIMPLE_TYPE(FC_UNUSED1)           

PRINT_SIMPLE_TYPE(FC_ALIGNM2)               
PRINT_SIMPLE_TYPE(FC_ALIGNM4)               
PRINT_SIMPLE_TYPE(FC_ALIGNM8)               
PRINT_SIMPLE_TYPE(FC_UNUSED2)              
PRINT_SIMPLE_TYPE(FC_UNUSED3)             
PRINT_SIMPLE_TYPE(FC_UNUSED4)             
PRINT_SIMPLE_TYPE(FC_STRUCTPAD1)       
PRINT_SIMPLE_TYPE(FC_STRUCTPAD2)            
PRINT_SIMPLE_TYPE(FC_STRUCTPAD3)           
PRINT_SIMPLE_TYPE(FC_STRUCTPAD4)            
PRINT_SIMPLE_TYPE(FC_STRUCTPAD5)            
PRINT_SIMPLE_TYPE(FC_STRUCTPAD6)             
PRINT_SIMPLE_TYPE(FC_STRUCTPAD7)

void FORMAT_PRINTER::HANDLE_FC_EMBEDDED_COMPLEX()
    {

    dout << "FC_EMBEDDED_COMPLEX\n";
    FormatString.IncUCHAR();
    {
       IndentLevel l(dout);
       dout << "Memory Pad:   " << HexOut(FormatString.GetUCHAR()) << '\n';
   
       OutputTypeAtOffset("Offset to embedded type: ", 
                          "Offset to embedded type is zero, no type selected.");    
    }

    }

PRINT_SIMPLE_TYPE(FC_END)                     
PRINT_SIMPLE_TYPE(FC_PAD)

void FORMAT_PRINTER::HANDLE_FC_USER_MARSHAL()
    {

    dout << "FC_USER_MARSHAL\n";
    FormatString.IncUCHAR();

    UCHAR Flags = FormatString.GetUCHAR();
    dout << "Flags:        " << HexOut(Flags) << '\n';
    {
        IndentLevel l(dout);
        if ( Flags & USER_MARSHAL_UNIQUE )
            {
            dout << " USER_MARSHAL_UNIQUE ";
            }
        if ( Flags & USER_MARSHAL_REF )
            {
            dout << " USER_MARSHAL_REF ";
            }
        if ( Flags & USER_MARSHAL_POINTER )
            {
            dout << " USER_MARSHAL_POINTER ";
            }
        if ( Flags & USER_MARSHAL_IID )
            {
            dout << " USER_MARSHAL_IID ";
            }
        dout << '\n';    
    }

    dout << "Quintuple Index:              " << HexOut(FormatString.GetUSHORT()) << '\n';
    dout << "User type memory size:        " << HexOut(FormatString.GetUSHORT()) << '\n';
    dout << "Transmitted type buffer size: " << HexOut(FormatString.GetUSHORT()) << '\n';

    OutputTypeAtOffset("Offset to transmitted type: ", 
                       "Offset to tranmitted type is zero, no type selected.");

    }

void FORMAT_PRINTER::HANDLE_FC_PIPE()
    {

    dout << "FC_PIPE\n";
    FormatString.IncUCHAR();


    UCHAR FlagsAndAlignment = FormatString.GetUCHAR();
    dout << "FlagsAndAlignment: " << HexOut(FlagsAndAlignment) << '\n';
    dout << "Flags:             \n";
    {
        IndentLevel l(dout);
        if ( FlagsAndAlignment & FC_BIG_PIPE )
            {
            dout << "FC_BIG_PIPE";
            }
        if ( FlagsAndAlignment & FC_OBJECT_PIPE )
            {
            dout << "FC_OBJECT_PIPE";
            }
        if ( FlagsAndAlignment & FC_PIPE_HAS_RANGE )
            {
            dout << "FC_PIPE_HAS_RANGE";
            }
        dout << '\n';
    }
    dout << "Alignment: " << HexOut((UCHAR)(FlagsAndAlignment & 0x0F)) << '\n';

    OutputTypeAtOffset("Offset to type: ", 
                       "Offset to tranmitted type is zero, no type for pipe!.");

    if ( FlagsAndAlignment & FC_BIG_PIPE )
        {
        dout << "Memory size:   " << HexOut(FormatString.GetULONG()) << '\n';
        dout << "Buffer size:   " << HexOut(FormatString.GetULONG()) << '\n';
        }
    else
        {
        dout << "Memory size:   " << HexOut(FormatString.GetUSHORT()) << '\n';
        dout << "Buffer size:   " << HexOut(FormatString.GetUSHORT()) << '\n';
        }
    if ( FlagsAndAlignment & FC_PIPE_HAS_RANGE )
        {
        dout << "Minimum size:  " << HexOut(FormatString.GetUSHORT()) << '\n';
        dout << "Maximum size:  " << HexOut(FormatString.GetUSHORT()) << '\n';
        }

    }

PRINT_SIMPLE_TYPE(FC_BLKHOLE) //Todo                

void FORMAT_PRINTER::HANDLE_FC_RANGE()
    {

    dout << "FC_RANGE\n";
    FormatString.IncUCHAR();

    UCHAR TypeAndFlags = FormatString.GetUCHAR();
    dout << "Type and flags: " << HexOut(TypeAndFlags)
    << " Flags: " << HexOut((UCHAR)(TypeAndFlags & 0xF0))
    << " Type:  " << FormatString.GetFormatCharName((UCHAR)(TypeAndFlags & 0x0F)) << '\n';

    dout << "Min value:      " << HexOut(FormatString.GetULONG()) << '\n';
    dout << "Max value:      " << HexOut(FormatString.GetULONG()) << '\n';

    }

PRINT_SIMPLE_TYPE(FC_INT3264)              
PRINT_SIMPLE_TYPE(FC_UINT3264)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrexts\ndrexts\globals.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    This file contains globals variable for RPC NDR debugger extensions.

Author:

    David Kays  (dkays)     August 1 1994

Revision History:


--*/


#define NDREXTS_GLOBALS
#include "ndrextsp.hxx"

#define NDR_GLOBAL_TABLES_ONLY

#include "..\ndr20\global.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrexts\ndrexts\bufout.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    bufout.cxx

Abstract:


Author:

    Mike Zoran  (mzoran)     September 3, 1999

Revision History:


--*/

#include "ndrextsp.hxx"

//
// BUFFER_PRINTER
//

BUFFER_SIMPLE_TYPE::BUFFER_SIMPLE_TYPE() : IsInt(TRUE),
                                           Precision(1),
                                           IntValue(0),
                                           FloatValue(0.0)
{}

void BUFFER_SIMPLE_TYPE::SetIntValue(INT64 x)
{
    IsInt = TRUE;
    IntValue = x;
}

void BUFFER_SIMPLE_TYPE::SetCHAR(CHAR x) 
{
   Precision = 1;
   SetIntValue(x);
}

void BUFFER_SIMPLE_TYPE::SetSHORT(SHORT x)
{
    Precision = sizeof(SHORT);
    SetIntValue(x);
}

void BUFFER_SIMPLE_TYPE::SetLONG(LONG x)
{
    Precision = sizeof(LONG);
    SetIntValue(x);
}

void BUFFER_SIMPLE_TYPE::SetINT64(INT64 x)
{
    Precision = sizeof(INT64);
    SetIntValue(x);
}

void BUFFER_SIMPLE_TYPE::SetDOUBLE(double x)
{
    IsInt = FALSE;
    FloatValue = x;
}

BOOL BUFFER_SIMPLE_TYPE::operator==(const BUFFER_SIMPLE_TYPE & x)
{
    
    if (IsInt && x.IsInt)
        return IntValue == x.IntValue;
    else if (!IsInt && !IsInt)
        return FloatValue == x.FloatValue;        
    
    double ThisValue = IsInt ? (double)IntValue : FloatValue;
    double OtherValue = IsInt ? (double)x.IntValue : x.FloatValue;
    return ThisValue == OtherValue;
}

BOOL BUFFER_SIMPLE_TYPE::operator==(INT64 x)
{   
    if (IsInt)
       return IntValue == x;

    return FloatValue==(double)x;
}

BOOL BUFFER_SIMPLE_TYPE::operator==(double x)
{
    if (!IsInt)
        return FloatValue == x;
  
    return (double)IntValue == x;      
}

ostream & BUFFER_SIMPLE_TYPE::Print(ostream & out)
{
    if (IsInt)
        {
        return out << HexOut(IntValue, Precision);
        }
    return out << HexOut(FloatValue);
}



//
// BUFFER
//


BUFFER::BUFFER(UINT64 Addr, ULONG Len) : BufferBegin(Addr),
BufferCurrent(Addr),
BufferEnd(Addr + Len),
BufferLength(Len)
    {
    
    }

VOID BUFFER::ValidateRange(LONG Delta)
    {
    if ( BufferCurrent < BufferBegin || BufferCurrent > BufferEnd )
        {
        ABORT("Current rpc buffer position is out of range.\n" <<
              "Current buffer pointer: " << HexOut((ULONG)BufferCurrent) <<
              " Buffer start: " << HexOut((ULONG)BufferBegin) <<
              " Buffer end: " << HexOut((ULONG)BufferEnd) << '\n');
        }
    if ( BufferCurrent+Delta < BufferBegin || BufferCurrent+Delta > BufferEnd )
        {
        ABORT("New rpc buffer position is out of range.\n" <<
              "New buffer pointer: " << HexOut((ULONG)(BufferCurrent+Delta)) <<
              " Buffer start: " << HexOut((ULONG)BufferBegin) <<
              " Buffer end: " << HexOut((ULONG)BufferEnd) << '\n');
        }
    }

VOID  BUFFER::Move(LONG Delta)
    {
    ValidateRange(Delta);
    BufferCurrent += Delta;
    }

UINT64 BUFFER::GetAddress()
    {
    return BufferCurrent;
    }

UINT64 BUFFER::SetAddress(UINT64 Addr)
    {

    ValidateRange(0);

    if ( Addr < BufferBegin || Addr > BufferEnd )
        {
        ABORT("New rpc buffer position is out of range.\n" <<
              "New buffer pointer: " << HexOut(Addr) <<
              " Buffer start: " << HexOut(BufferBegin) <<
              " Buffer end: " << HexOut(BufferEnd) << '\n');
        }

    swap( Addr, BufferCurrent );
    return Addr;
    }

VOID BUFFER::Align( UINT64 Mask )
    {

    ValidateRange(0);

    UINT64 NewAddress = (BufferCurrent + Mask) & ~Mask;
    SetAddress(NewAddress);

    }

#define DEFINE_BUFFER_TYPE(type)                                                 \
    type BUFFER::Read##type##() {                                                \
        ValidateRange(sizeof(type));                                             \
        type Tmp;  ReadMemory(BufferCurrent,&Tmp); return Tmp;                   \
    }                                                                            \
    type BUFFER::Get##type##() {                                                 \
        ValidateRange(sizeof(type));                                             \
        type Tmp;  ReadMemory(BufferCurrent,&Tmp); BufferCurrent += sizeof(Tmp); return Tmp; \
    }                                                                            \
    VOID BUFFER::Inc##type##() {                                                 \
        Move(sizeof(type));                                                      \
    }                                                                            \
    void BUFFER::Align##type##() {                                               \
        Align(sizeof(type) - 1);                                                 \
    }

DEFINE_BUFFER_TYPE(UCHAR)
DEFINE_BUFFER_TYPE(CHAR)
DEFINE_BUFFER_TYPE(USHORT)
DEFINE_BUFFER_TYPE(SHORT)
DEFINE_BUFFER_TYPE(ULONG)
DEFINE_BUFFER_TYPE(LONG)
DEFINE_BUFFER_TYPE(UINT64)
DEFINE_BUFFER_TYPE(INT64)
DEFINE_BUFFER_TYPE(FLOAT)
DEFINE_BUFFER_TYPE(DOUBLE)

GUID BUFFER::ReadGUID()
{
    GUID RetVal;
    Read(&RetVal, sizeof(GUID));
    return RetVal;
}

GUID BUFFER::GetGUID()
{
    GUID RetVal;
    Get(&RetVal, sizeof(GUID));
    return RetVal;

}

VOID BUFFER::IncGUID()
{
    Move(sizeof(GUID));
}

VOID BUFFER::AlignGUID()
{
    // GUIDs are ULONG aligned on the wire
    AlignULONG();
}

VOID BUFFER::AlignBUFFER_SIMPLE_TYPE(UCHAR FormatChar)
{
    Align( SIMPLE_TYPE_ALIGNMENT( FormatChar ) );
}

BUFFER_SIMPLE_TYPE BUFFER::ReadBUFFER_SIMPLE_TYPE(UCHAR FormatChar)
{
    BUFFER_SIMPLE_TYPE retval;

    switch ( FormatChar )
        {
        case FC_CHAR :
            retval.SetCHAR(ReadCHAR());
            break;
        
        case FC_BYTE :
        case FC_SMALL :
        case FC_USMALL :
            retval.SetCHAR(ReadUCHAR());
            break;

        case FC_ENUM16 :
        case FC_SHORT :
            retval.SetSHORT(ReadSHORT());
            break;

        case FC_WCHAR :
        case FC_USHORT :
            retval.SetSHORT(ReadUSHORT());
            break;

        case FC_INT3264:
        case FC_LONG :
        case FC_ENUM32 :
        case FC_ERROR_STATUS_T:
            retval.SetLONG(ReadLONG());
            break;

        case FC_UINT3264:
        case FC_ULONG :            
            retval.SetLONG(ReadULONG());
            break;
        
        case FC_HYPER :
            retval.SetINT64(ReadINT64());

        case FC_FLOAT :
            retval.SetDOUBLE(ReadFLOAT());
            break;

        case FC_DOUBLE :
            retval.SetDOUBLE(ReadDOUBLE());
            break;
        case FC_IGNORE :
            break;

        default :
            ABORT( "Bad format char.\n" );
            break;
        }

    return retval;
       
}

BUFFER_SIMPLE_TYPE BUFFER::GetBUFFER_SIMPLE_TYPE(UCHAR FormatChar)
{
    BUFFER_SIMPLE_TYPE retval = ReadBUFFER_SIMPLE_TYPE( FormatChar );
    IncBUFFER_SIMPLE_TYPE( FormatChar );
    return retval;
}

VOID BUFFER::IncBUFFER_SIMPLE_TYPE(UCHAR FormatChar)
{
    Move( SIMPLE_TYPE_BUFSIZE( FormatChar ) );
}


VOID BUFFER::Read(PVOID pOut, LONG Len)
    {
    ValidateRange(Len);
    ReadMemory((void*)BufferCurrent, pOut, Len);
    }

VOID BUFFER::Get(PVOID pOut, LONG Len)
    {
    Read(pOut, Len);
    Move(Len);
    }

ULONG BUFFER::GetCurrentOffset()
    {
    return BufferCurrent - BufferBegin;
    }

// FULL_PTR_TABLE

BOOL
FULL_PTR_TABLE::Add(UINT64 Address)
    {
    return s.insert(Address).second;
    }

VOID
FULL_PTR_TABLE::Clear()
    {
    s.clear();
    }

// POINTER

char * PointerNames[] =
{
    "Ref",
    "Unique",
    "Object",
    "Full"
};

ULONG POINTER::GlobalPtrId = 0;

POINTER::POINTER( FORMAT_STRING *pFormat, BUFFER *pBuffer, BUFFER_PRINTER *pBufferPrinter,
                  BOOL ArrayRef ) :
                  dout(pBufferPrinter->dout)
    {
    POINTER::pBufferPrinter = pBufferPrinter;
    PtrId = GlobalPtrId++;
    BufferAddress = pBuffer->GetAddress();
    FormatAddress = pFormat->GetAddress();
    PointerType = pFormat->GetUCHAR();
    PointerAttributes = pFormat->GetUCHAR();
    IsEmbedded = pBufferPrinter->IsEmbedded;
    POINTER::ArrayRef = ArrayRef;

    if ( ArrayRef )
        {
        if (FC_RP != PointerType || !IsEmbedded)
            {
            ABORT("Only refer ref pointer embedded in array can be ArrayRef.\n");
            }
        }

    switch ( PointerType )
        {
        case FC_IP:
            if ( FC_CONSTANT_IID == PointerAttributes )
                {
                IId = pFormat->GetGUID();
                }
            else
                {
                pFormat->SkipCorrelationDesc( pBufferPrinter->IsRobust );
                }
            break;

        case FC_BYTE_COUNT_POINTER:

            // BUG, BUG does not skip entire format string
            if ( FC_PAD == PointerAttributes )
                {
                pFormat->SkipCorrelationDesc( pBufferPrinter->IsRobust );
                PointeeFormatAddress = pFormat->GetAddress();
                }
            else
                {
                PointeeFormatAddress = pFormat->GetAddress() - 1;
                pFormat->SkipCorrelationDesc( pBufferPrinter->IsRobust );
                }

        default:
            if ( SIMPLE_POINTER(PointerAttributes) )
                {
                PointeeFormatAddress = pFormat->GetAddress();
                pFormat->IncUCHAR(); // Skip type format char
                pFormat->IncUCHAR(); // Skip pad.
                }
            else
                {
                PointeeFormatAddress = pFormat->ComputeOffset();
                }
        }
    }

VOID POINTER::SkipCommonPointerFormat( FORMAT_STRING *FormatString )
  {
  FormatString->IncUCHAR();
  FormatString->IncUCHAR();
  FormatString->IncSHORT();
  }

BOOL 
POINTER::HasWireRep()
  {
   return !ArrayRef && (FC_RP != PointerType || IsEmbedded);
  }

ULONG 
POINTER::GetWireRep(BUFFER *pBuffer) 
    {
    BUFFER TempBuffer = *pBuffer;
    pBuffer = &TempBuffer;

    if ( HasWireRep() )
        {
        pBuffer->SetAddress( BufferAddress);
        pBuffer->AlignULONG();
        return pBuffer->GetULONG(); 
        }
    return NULL;
    }

VOID 
POINTER::OutputPointer( ULONG WireRep ) 
    {
    dout << PointerNames[ PointerType - FC_RP ] << " pointer <id=" << PtrId << ">";

    if ( HasWireRep() )
        dout << " <wire ref=" << HexOut( WireRep ) << ">\n";

    else
        dout << "Pointer does not have a wire reprentation. \n";                   
    }

VOID 
POINTER::OutputPointee( ULONG WireRep, FULL_PTR_TABLE *pFullPointerList, 
                        BUFFER *pPointeeBuffer ) 
    {

    IndentLevel l(dout);

    if ( PointerType != FC_RP  && !WireRep )
        {
        dout << "Pointer is done: pointer <id=" << PtrId << ">.\n";
        return;
        }

    if ( FC_FP == PointerType && !pFullPointerList->Add( WireRep ) )
        {
        dout << "Pointer is done: pointer <id=" << PtrId << ">.\n";
        return;
        }

    dout << "Pointee of pointer <id=" << PtrId << ">.\n";

    if ( FC_IP == PointerType )
        {
        OutputInterfacePointer( pPointeeBuffer ); 
        }
    else
        {

        // Swap the embedded pointer list if we are not embedded
        POINTER_LIST NewEmbeddedPointerList;
        SWAP_SCOPE<POINTER_LIST*> swapscope1(& pBufferPrinter->EmbeddedPointerList, 
                                             & NewEmbeddedPointerList, TRUE );
        SWAP_SCOPE<BUFFER*> swapscope2( & pBufferPrinter->Buffer, 
                                        pPointeeBuffer );
        
        // Pointee is no longer embedded
        SWAP_SCOPE<BOOL> swapscope3( & pBufferPrinter->IsEmbedded, FALSE );
        SWAP_SCOPE<BOOL> swapscope4( & pBufferPrinter->IsConformantArrayDone, FALSE );
        SWAP_SCOPE<BOOL> swapscope5( & pBufferPrinter->IsStructEmbedded, FALSE );
        SWAP_SCOPE<BOOL> swapscope6( & pBufferPrinter->IsArrayEmbedded, FALSE );        
        SWAP_SCOPE<BUFFER*> swapscope7( & pBufferPrinter->ConformanceCountBuffer, NULL );

        IndentLevel l(dout);

        pBufferPrinter->OutputType( PointeeFormatAddress );
        }

    }

VOID
POINTER::OutputPointee() 
    {
    BUFFER WireBuffer = *pBufferPrinter->Buffer;
    WireBuffer.SetAddress( BufferAddress );
    ULONG WireRep = GetWireRep( &WireBuffer );

    OutputPointee( WireRep, &pBufferPrinter->FullPointerTable, 
                   pBufferPrinter->Buffer );  
    }

VOID
POINTER::OutputInterfacePointer(BUFFER * Buffer) 
    {
    GUID IGUID;
    ULONG Size, SizeAgain;

    // See where the GUID comes from.

    if ( FC_CONSTANT_IID == PointerAttributes )
        {
        dout << "Interface pointer with constant IID\n";
        }
    else
        {
        dout << "Interface pointer with variable IID\n";

        Buffer->AlignULONG();
        IGUID = Buffer->GetGUID();
        }
    {
        IndentLevel l(dout);
        dout << "GUID is " << IGUID << '\n';

        // Now the open array.

        // Read the conformant size for the open array.

        Buffer->AlignULONG();
        ULONG Size = Buffer->GetULONG();


        dout << "Data size is " << Size;

        // Skip the size field of the struct.

        SizeAgain = Buffer->GetULONG();

        if ( SizeAgain != Size )
            dout << " SizeAgain = " << SizeAgain << " ???" << '\n';

        if ( Size )
            {
            char *pBuffer = new char[ Size ];
            Buffer->Get( pBuffer, Size );

            for ( uint j = 0; j < Size; j++ )
                {
                if ( (j % 16) == 0 )
                    {
                    dout << '\n';
                    }
                dout << HexOut((unsigned char)pBuffer[j]);
                }
            delete[] pBuffer;
            }

        dout << '\n';
    }
    }

POINTER_LIST::POINTER_LIST() {}

POINTER_LIST::~POINTER_LIST()
    {
    Clear();
    }

BOOL POINTER_LIST::Add(UINT64 Address, POINTER *pPointer) 
    {
    //Only add to list if pointer has a wire rep.
    if (pPointer->HasWireRep())
        {
        BOOL bNew = m.insert(MAP_TYPE::value_type(Address,pPointer)).second;
        if ( !bNew )
           return bNew;
        
        }
    q.push_back( pPointer );

    return TRUE;
    }

BOOL POINTER_LIST::Lookup(UINT64 Address, POINTER ** ppPointer) 
    {
    MAP_TYPE::const_iterator i;
    i = m.find( Address );
    if ( m.end() == i )
        return FALSE;
    if (NULL != ppPointer)
        {
        *ppPointer = i->second;        
        }
    return TRUE;
    }

VOID POINTER_LIST::Clear()
    {
    m.clear();
    for ( LIST_TYPE::iterator i = q.begin(); i != q.end(); i++ )
        {
        delete (*i);
        }
    q.clear();
    }

VOID POINTER_LIST::OutputPointees()
    {
    for ( LIST_TYPE::iterator i = q.begin(); i != q.end(); i++ )
        {
        (*i)->OutputPointee();
        }
    }

//
// Buffer Printer
// 

BUFFER_PRINTER::BUFFER_PRINTER(
                              FORMATTED_STREAM_BUFFER & mydout,
                              UINT64 Buffer, 
                              ULONG BufferLength, 
                              UINT64 ProcInfo,
                              UINT64 TypeInfo ) : OriginalBuffer( Buffer, BufferLength ) ,
ProcFormatString( ProcInfo ), 
TypeFormatString( TypeInfo ),
dout(mydout)
    {
    
    }

VOID BUFFER_PRINTER::SetupWorkValues()
    {

    WorkBuffer = OriginalBuffer;
    Buffer = &WorkBuffer;
    ConformanceCountBuffer = NULL;
    VarianceBuffer = NULL;

    WorkProcFormatString = ProcFormatString;
    WorkTypeFormatString = TypeFormatString;
    FormatString = &WorkProcFormatString;

    FullPointerTable.Clear();
    OriginalEmbeddedPointerList.Clear();
    EmbeddedPointerList = &OriginalEmbeddedPointerList;
    IsEmbedded = IsRobust = FALSE;
    IsConformantArrayDone = IsStructEmbedded = IsArrayEmbedded = FALSE;
    }

#define DISPATCH_TYPE(type)         \
   case type:                       \
      HANDLE_##type ();             \
      break;


VOID
BUFFER_PRINTER::OutputType()
    {
    UCHAR FormatChar = FormatString->ReadUCHAR();
    switch ( FormatChar )
        {
        default:
            dout << "Unknown type " << HexOut(FormatChar) << " found at " 
            << HexOut(FormatString->GetAddress()) << ".\n";
            break;

            DISPATCH_TYPE(FC_ZERO)
            DISPATCH_TYPE(FC_BYTE)                    
            DISPATCH_TYPE(FC_CHAR)                    
            DISPATCH_TYPE(FC_SMALL)                   
            DISPATCH_TYPE(FC_USMALL)                  
            DISPATCH_TYPE(FC_WCHAR)                   
            DISPATCH_TYPE(FC_SHORT)                   
            DISPATCH_TYPE(FC_USHORT)                  
            DISPATCH_TYPE(FC_LONG)                    
            DISPATCH_TYPE(FC_ULONG)                   
            DISPATCH_TYPE(FC_FLOAT)                   
            DISPATCH_TYPE(FC_HYPER)                  
            DISPATCH_TYPE(FC_DOUBLE)                  
            DISPATCH_TYPE(FC_ENUM16)                  
            DISPATCH_TYPE(FC_ENUM32)                  
            DISPATCH_TYPE(FC_IGNORE)                  
            DISPATCH_TYPE(FC_ERROR_STATUS_T)          
            DISPATCH_TYPE(FC_RP)                   
            DISPATCH_TYPE(FC_UP)                   
            DISPATCH_TYPE(FC_OP)                   
            DISPATCH_TYPE(FC_FP)                    
            DISPATCH_TYPE(FC_STRUCT)                  
            DISPATCH_TYPE(FC_PSTRUCT)               
            DISPATCH_TYPE(FC_CSTRUCT)                 
            DISPATCH_TYPE(FC_CPSTRUCT)               
            DISPATCH_TYPE(FC_CVSTRUCT)      
            DISPATCH_TYPE(FC_BOGUS_STRUCT)          
            DISPATCH_TYPE(FC_CARRAY)             
            DISPATCH_TYPE(FC_CVARRAY)             
            DISPATCH_TYPE(FC_SMFARRAY)            
            DISPATCH_TYPE(FC_LGFARRAY)         
            DISPATCH_TYPE(FC_SMVARRAY)            
            DISPATCH_TYPE(FC_LGVARRAY)            
            DISPATCH_TYPE(FC_BOGUS_ARRAY)       
            DISPATCH_TYPE(FC_C_CSTRING)                
            DISPATCH_TYPE(FC_C_SSTRING)           
            DISPATCH_TYPE(FC_C_WSTRING)            
            DISPATCH_TYPE(FC_CSTRING)                        
            DISPATCH_TYPE(FC_SSTRING)              
            DISPATCH_TYPE(FC_WSTRING)               
            DISPATCH_TYPE(FC_ENCAPSULATED_UNION)      
            DISPATCH_TYPE(FC_NON_ENCAPSULATED_UNION) 
            DISPATCH_TYPE(FC_BYTE_COUNT_POINTER)      
            DISPATCH_TYPE(FC_TRANSMIT_AS)            
            DISPATCH_TYPE(FC_REPRESENT_AS)            
            DISPATCH_TYPE(FC_IP)                     
            DISPATCH_TYPE(FC_BIND_CONTEXT)          
            DISPATCH_TYPE(FC_BIND_GENERIC)          
            DISPATCH_TYPE(FC_BIND_PRIMITIVE)       
            DISPATCH_TYPE(FC_AUTO_HANDLE)             
            DISPATCH_TYPE(FC_CALLBACK_HANDLE)           
            DISPATCH_TYPE(FC_UNUSED1)                       
            DISPATCH_TYPE(FC_ALIGNM2)               
            DISPATCH_TYPE(FC_ALIGNM4)               
            DISPATCH_TYPE(FC_ALIGNM8)               
            DISPATCH_TYPE(FC_UNUSED2)              
            DISPATCH_TYPE(FC_UNUSED3)             
            DISPATCH_TYPE(FC_UNUSED4)             
            DISPATCH_TYPE(FC_STRUCTPAD1)       
            DISPATCH_TYPE(FC_STRUCTPAD2)            
            DISPATCH_TYPE(FC_STRUCTPAD3)           
            DISPATCH_TYPE(FC_STRUCTPAD4)            
            DISPATCH_TYPE(FC_STRUCTPAD5)            
            DISPATCH_TYPE(FC_STRUCTPAD6)             
            DISPATCH_TYPE(FC_STRUCTPAD7)            
            DISPATCH_TYPE(FC_EMBEDDED_COMPLEX)        
            DISPATCH_TYPE(FC_END)                     
            DISPATCH_TYPE(FC_PAD)                                 
            DISPATCH_TYPE(FC_USER_MARSHAL)           
            DISPATCH_TYPE(FC_PIPE)                   
            DISPATCH_TYPE(FC_BLKHOLE)                 
            DISPATCH_TYPE(FC_RANGE)                       
            DISPATCH_TYPE(FC_INT3264)              
            DISPATCH_TYPE(FC_UINT3264)   
        }

    }

// Some types need redirecting to a common processing function
#define PRINT_REDIRECT_TYPE(type,func)      \
void BUFFER_PRINTER::HANDLE_##type() {      \
   func();                                  \
}

#define PRINT_SIMPLE_TYPE(type)             \
void BUFFER_PRINTER::HANDLE_##type() {      \
   OutputSimpleType( FALSE, 0 );            \
}

#define IGNORE_TYPE(type)                   \
void BUFFER_PRINTER::HANDLE_##type() {      \
   FormatString->GetUCHAR();                \
   return;                                  \
}

#define TODO_TYPE(type)                     \
void BUFFER_PRINTER::HANDLE_##type() {      \
   FormatString->GetUCHAR();                \
   return;                                  \
}

PRINT_SIMPLE_TYPE(FC_ZERO)
PRINT_SIMPLE_TYPE(FC_BYTE)                    
PRINT_SIMPLE_TYPE(FC_CHAR)                    
PRINT_SIMPLE_TYPE(FC_SMALL)                   
PRINT_SIMPLE_TYPE(FC_USMALL)                  
PRINT_SIMPLE_TYPE(FC_WCHAR)                   
PRINT_SIMPLE_TYPE(FC_SHORT)                   
PRINT_SIMPLE_TYPE(FC_USHORT)                  
PRINT_SIMPLE_TYPE(FC_LONG)                    
PRINT_SIMPLE_TYPE(FC_ULONG)                   
PRINT_SIMPLE_TYPE(FC_FLOAT)                   
PRINT_SIMPLE_TYPE(FC_HYPER)                  
PRINT_SIMPLE_TYPE(FC_DOUBLE)                  
PRINT_SIMPLE_TYPE(FC_ENUM16)                  
PRINT_SIMPLE_TYPE(FC_ENUM32)                  
IGNORE_TYPE(FC_IGNORE)                  
PRINT_SIMPLE_TYPE(FC_ERROR_STATUS_T)

#define PRINT_POINTER_TYPE(type)            \
void BUFFER_PRINTER::HANDLE_##type() {      \
   OutputPointer(!IsEmbedded, FALSE);       \
}

PRINT_POINTER_TYPE(FC_RP)                   
PRINT_POINTER_TYPE(FC_UP)                   
PRINT_POINTER_TYPE(FC_OP)                   
PRINT_POINTER_TYPE(FC_FP)   

PRINT_REDIRECT_TYPE(FC_STRUCT,OutputStructure)   
PRINT_REDIRECT_TYPE(FC_PSTRUCT,OutputStructure)   
PRINT_REDIRECT_TYPE(FC_CSTRUCT,OutputStructure)   
PRINT_REDIRECT_TYPE(FC_CPSTRUCT,OutputStructure)   
PRINT_REDIRECT_TYPE(FC_CVSTRUCT,OutputStructure)   
PRINT_REDIRECT_TYPE(FC_BOGUS_STRUCT,OutputStructure)

PRINT_REDIRECT_TYPE(FC_CARRAY,OutputArray)          
PRINT_REDIRECT_TYPE(FC_CVARRAY,OutputArray)
PRINT_REDIRECT_TYPE(FC_SMFARRAY,OutputArray)
PRINT_REDIRECT_TYPE(FC_LGFARRAY,OutputArray)             
PRINT_REDIRECT_TYPE(FC_SMVARRAY,OutputArray)
PRINT_REDIRECT_TYPE(FC_LGVARRAY,OutputArray)
PRINT_REDIRECT_TYPE(FC_BOGUS_ARRAY,OutputArray)

PRINT_REDIRECT_TYPE(FC_C_CSTRING,OutputString)
PRINT_REDIRECT_TYPE(FC_C_SSTRING,OutputString)
PRINT_REDIRECT_TYPE(FC_C_WSTRING,OutputString)
PRINT_REDIRECT_TYPE(FC_CSTRING,OutputString)
PRINT_REDIRECT_TYPE(FC_SSTRING,OutputString)
PRINT_REDIRECT_TYPE(FC_WSTRING,OutputString)

PRINT_REDIRECT_TYPE(FC_ENCAPSULATED_UNION,OutputEncapsulatedUnion)                                                   
PRINT_REDIRECT_TYPE(FC_NON_ENCAPSULATED_UNION,OutputUnion)
PRINT_POINTER_TYPE(FC_BYTE_COUNT_POINTER)        
PRINT_REDIRECT_TYPE(FC_TRANSMIT_AS,OutputXmit)            
PRINT_REDIRECT_TYPE(FC_REPRESENT_AS,OutputXmit)   
PRINT_POINTER_TYPE(FC_IP)            

PRINT_REDIRECT_TYPE(FC_BIND_CONTEXT,OutputContextHandle)          
IGNORE_TYPE(FC_BIND_GENERIC)          
IGNORE_TYPE(FC_BIND_PRIMITIVE)       
IGNORE_TYPE(FC_AUTO_HANDLE)             
IGNORE_TYPE(FC_CALLBACK_HANDLE)           
IGNORE_TYPE(FC_UNUSED1)
IGNORE_TYPE(FC_ALIGNM2)               
IGNORE_TYPE(FC_ALIGNM4)               
IGNORE_TYPE(FC_ALIGNM8)               
IGNORE_TYPE(FC_UNUSED2)              
IGNORE_TYPE(FC_UNUSED3)             
IGNORE_TYPE(FC_UNUSED4)             
IGNORE_TYPE(FC_STRUCTPAD1)       
IGNORE_TYPE(FC_STRUCTPAD2)            
IGNORE_TYPE(FC_STRUCTPAD3)           
IGNORE_TYPE(FC_STRUCTPAD4)            
IGNORE_TYPE(FC_STRUCTPAD5)            
IGNORE_TYPE(FC_STRUCTPAD6)             
IGNORE_TYPE(FC_STRUCTPAD7)            
PRINT_REDIRECT_TYPE(FC_EMBEDDED_COMPLEX,OutputEmbeddedComplex)        
IGNORE_TYPE(FC_END)                     
IGNORE_TYPE(FC_PAD)                                 
PRINT_REDIRECT_TYPE(FC_USER_MARSHAL,OutputXmit)           
TODO_TYPE(FC_PIPE)                   
IGNORE_TYPE(FC_BLKHOLE)                 
PRINT_REDIRECT_TYPE(FC_RANGE,OutputRangedType)                       
PRINT_SIMPLE_TYPE(FC_INT3264)              
PRINT_SIMPLE_TYPE(FC_UINT3264)

VOID BUFFER_PRINTER::OutputType(UINT64 Address)
    {
    FORMAT_STRING *pBackupFormatString = FormatString;
    FORMAT_STRING NewFormatString;
    FormatString = &NewFormatString;

    FormatString->SetAddress( Address );
    OutputType();
    FormatString = pBackupFormatString;

    }

VOID BUFFER_PRINTER::OutputTypeFromOffset() 
    {
    FormatString->GotoOffset();
    OutputType();
    }

// Spaces needed for pretty printing.

char * FcTypeName[] =
{
    "FC_ZERO??",
    "byte    ",
    "char    ",
    "small   ",
    "usmall  ",
    "wchar   ",
    "short   ",
    "ushort  ",
    "long    ",
    "ulong   ",
    "float   ",
    "hyper   ",
    "double  ",
    "enum16  ",
    "enum32  ",
    "ignore  ",
    "err_st_t",
    "ref  ptr",
    "uniq ptr",
    "obj  ptr",
    "full ptr"
};

void
BUFFER_PRINTER::OutputSimpleType( BOOL IsArray, ULONG ArrayElements )
    {

    UCHAR FormatChar = FormatString->GetUCHAR();
    UINT64 BufferAddress = Buffer->GetAddress();

    UCHAR UseFormatChar = IS_SIMPLE_TYPE( FormatChar ) ? FormatChar : FC_ULONG;
    
    Buffer->AlignBUFFER_SIMPLE_TYPE( UseFormatChar );

    if (!IsArray)
        {
        ArrayElements = 1;
        }

    // BUG, BUG expand this to include multiple 
    // line widths.
    ULONG CharsPerLine = dout.GetAvailableColumns();
    

    if (0 == ArrayElements)
        {
        dout << "Array has 0 elements\n";
        }

    ULONG RemainingChars = CharsPerLine;
    

    for(ULONG i = 0; i < ArrayElements; i++)
        {

        BUFFER_SIMPLE_TYPE SimpleData = Buffer->ReadBUFFER_SIMPLE_TYPE( UseFormatChar );
        
        if ( SIMPLE_TYPE_BUFSIZE( UseFormatChar ) == sizeof(ULONG) )
            {
            // Check if the long is a pointer in a struct.
    
            POINTER *pPointer;
    
            if ( EmbeddedPointerList->Lookup(BufferAddress, &pPointer) )
                {
                ULONG WireRep = pPointer->GetWireRep( Buffer );
                Buffer->IncBUFFER_SIMPLE_TYPE( UseFormatChar );
                pPointer->OutputPointer( WireRep );
                return;
                }
            }
    
        Buffer->IncBUFFER_SIMPLE_TYPE( UseFormatChar );
    
        stringstream str;
        str << SimpleData; 

        ULONG RequiredChars = (ULONG)str.str().length() + 1;

        if (RemainingChars < RequiredChars)
            {
            // prepend a newline
            dout << '\n';
            RemainingChars = CharsPerLine;
            }

        RemainingChars -= RequiredChars;

        dout << str.str().c_str() << ' ';

        }

        dout << '\n';
    }

VOID
BUFFER_PRINTER::OutputRangedType()
    {

    UCHAR FormatChar = FormatString->GetUCHAR();
    UINT64 TypeAddress = FormatString->GetAddress();
    UCHAR SimpleType = FormatString->GetAddress();
    ULONG Min = FormatString->GetULONG();
    ULONG Max = FormatString->GetULONG();

    OutputType( TypeAddress );
    }

VOID 
BUFFER_PRINTER::OutputEmbeddedComplex()
    {

    UCHAR FormatChar = FormatString->GetUCHAR();
    UCHAR Pad = FormatString->GetUCHAR();
    UINT64 Address = FormatString->ComputeOffset();

    OutputType( Address );
    }

VOID
BUFFER_PRINTER::OutputString()
    {
    
    BUFFER_PRINTER_SAVE_CONTEXT SaveCtxt(this);
     
    StartEmbedded(&SaveCtxt, IsStructEmbedded, IsArrayEmbedded);

    UINT64 StringAddress = FormatString->GetAddress();

    UCHAR FormatType = FormatString->GetUCHAR();
    
    switch ( FormatType )
        {
        case FC_C_CSTRING :
        case FC_C_WSTRING :
        case FC_C_BSTRING :

            if ( FormatString->GetUCHAR() == FC_STRING_SIZED )
                {
                FormatString->IncUSHORT(); //skip string size
                }
            {
               SetupConformanceCountBuffer(&SaveCtxt, StringAddress);
               Elements = ConformanceCountBuffer->GetULONG();
            }

            break;

        case FC_CSTRING :
        case FC_WSTRING :
        case FC_BSTRING :
            FormatString->IncUCHAR(); // Skip FC_PAD
            Elements = FormatString->GetUSHORT(); // get size
            break;

        case FC_SSTRING :
        case FC_C_SSTRING :
            ABORT( "STRING::Output : Stringable struct, no way" );

        default :
            ABORT( "STRING::Output : Bad format type" ); 
        }

    Buffer->AlignULONG();
    Offset = Buffer->GetULONG();
    Length = Buffer->GetULONG();

    dout << "String of " << 
    (( FormatType == FC_C_WSTRING || FormatType == FC_WSTRING )
     ? "wchars"
     : "chars")
    << " (size=" << Elements << ", length=" << Length << ") :\n";

    {
        IndentLevel l(dout);
        char * CharString;
        BOOL fWChar = FALSE;

        if ( FormatType == FC_C_WSTRING || FormatType == FC_WSTRING )
            {
            CharString = (char *) new wchar_t[Length];
            Buffer->Get( (char *) CharString, Length*2 );
            fWChar = TRUE;
            }
        else
            {
            CharString = new char[Length];
            Buffer->Get( CharString, Length );
            }

        if ( Length < 60 )
            {
            if ( fWChar )
                {
                dout << '\"' << WCHAR_OUT((PWCHAR)CharString) << "\"\n";
                }
            else
                {
                dout << '\"' << (PCHAR)CharString << "\"\n";
                }
            }
        else
            {

            for ( long i = 0; i < Length; i++ )
                {
                if ( ( i % 40 ) == 0 )
                    {
                    dout << '\n';
                    }
                if ( fWChar )
                    {
                    dout << WCHAR_OUT(*((PWCHAR)CharString + i));
                    }
                dout << CharString[i];
                }
            dout << '\n';
            }
        delete[] CharString;
    }

    }

VOID
BUFFER_PRINTER::OutputContextHandle()
    {

    // Skip format string goo.
    UCHAR FormatChar = FormatString->GetUCHAR();
    UCHAR HandleFlags = FormatString->GetUCHAR();
    SHORT StackOffset = FormatString->GetSHORT();
    UCHAR RoutineIndex = FormatString->GetUCHAR();
    UCHAR Pad = FormatString->GetUCHAR();

    // A context handle is represented as a GUID on the wire.

    Buffer->AlignGUID();
    GUID Guid = Buffer->GetGUID();

    dout << "Context Handle: " << Guid << '\n'; 

    }

VOID
BUFFER_PRINTER::OutputXmit()
    {

    UCHAR FormatType = FormatString->GetUCHAR();

    switch ( FormatType )
        {
        case FC_USER_MARSHAL:
            dout << "User Marshal (transmitted type shown)\n";
            break;
        case FC_TRANSMIT_AS:
            dout << "Transmit As (transmitted type shown)\n";
            break;
        case FC_REPRESENT_AS:
            dout << "Represent As (transmitted type shown)\n";
            break;
        default:
            ABORT( "Xmit or UserM as expected, " <<
                   FormatString->GetFormatCharName( FormatType ) <<
                   '=' << HexOut( FormatType ) << " found.\n" );
            break;
        }

    FormatString->Move(7); // Skip to type offset

    //Output the transmitted type
    OutputTypeFromOffset( );

    }


VOID
BUFFER_PRINTER::OutputUnionArm()
    {
    UINT64 CurrentAddress = FormatString->GetAddress();
    SHORT Offset = FormatString->GetSHORT(); 
    IndentLevel l(dout);

    if ( (USHORT)Offset >> 8 == 0x80 )
        {
        OutputSimpleType(FALSE, 0);
        return;
        }

    OutputType(CurrentAddress + Offset );
    }

VOID
BUFFER_PRINTER::OutputUnionArms(BUFFER_SIMPLE_TYPE SwitchIs)
    {

    //
    // Get the union's arm descriptions.
    //
    FormatString->IncUSHORT(); //Memory size
    USHORT UnionArms = FormatString->GetUSHORT();

    ULONG Arms      = UnionArms & 0x0fff;
    ULONG Alignment = UnionArms >> 12;
    Buffer->Align( Alignment );

    BOOL ArmTaken = FALSE;

    for ( Arms; Arms > 0; Arms-- )
        {
        ULONG CaseValue = FormatString->GetULONG();

        if ( SwitchIs == (INT64)CaseValue )
            {
            dout << "Using arm with case value of " << HexOut(CaseValue) << ".\n";         
            OutputUnionArm();
            ArmTaken = TRUE;
            }
        else
            {
            FormatString->Move(2);
            }
        }

    // handle the default case
    if ( !ArmTaken )
        {
        dout << "Using default using arm.\n";
        OutputUnionArm();
        }
    else
        {
        FormatString->Move(2);
        }

    }

VOID
BUFFER_PRINTER::OutputUnion()
    {

    BUFFER_PRINTER_SAVE_CONTEXT SaveCtxt(this);
     
    StartEmbedded(&SaveCtxt, IsStructEmbedded, IsArrayEmbedded);

    BUFFER_SIMPLE_TYPE SwitchIs;
    UINT64 BufferOffset = Buffer->GetCurrentOffset();
    
    // Read the fixed part of the union's description.

    UCHAR FormatType = FormatString->GetUCHAR();
    UCHAR SwitchType = FormatString->GetUCHAR();
    FormatString->SkipCorrelationDesc(IsRobust);
    
    Buffer->AlignBUFFER_SIMPLE_TYPE( SwitchType );
    SwitchIs = Buffer->GetBUFFER_SIMPLE_TYPE( SwitchType );

    dout << "Non-encapsulated union (switch is == " << SwitchIs
    << " (" << FormatString->GetFormatCharName(SwitchType) 
    << "), bufoff = " << HexOut(BufferOffset) << ") : \n";

    UINT64 CurrentAddress = FormatString->GetAddress();
    FormatString->GotoOffset();
    
    OutputUnionArms( SwitchIs );

    FormatString->SetAddress(CurrentAddress);
    FormatString->IncSHORT();

    if ( !SaveCtxt.IsEmbedded )
        {
        // Output the pointees for this flat block
        dout << "Flat part of union is done, printing pointees.\n";
        dout << '\n';
        EmbeddedPointerList->OutputPointees();
        }


    dout << "Union is done.\n";

    }

VOID
BUFFER_PRINTER::OutputEncapsulatedUnion()
    {

    BUFFER_PRINTER_SAVE_CONTEXT SaveCtxt(this);
 
    StartEmbedded(&SaveCtxt, IsStructEmbedded, IsArrayEmbedded);
    BUFFER_SIMPLE_TYPE SwitchIs;
    UINT64 BufferOffset = Buffer->GetCurrentOffset();

    // Read the fixed part of the union's description.
    UCHAR FormatType = FormatString->GetUCHAR();
    UCHAR SwitchType = (FormatString->GetUCHAR() & 0x0f);

    Buffer->AlignBUFFER_SIMPLE_TYPE( SwitchType );
    SwitchIs = Buffer->GetBUFFER_SIMPLE_TYPE( SwitchType );

    dout << "Encapsulated union (switch is == " << SwitchIs
    << " (" << FormatString->GetFormatCharName(SwitchType) 
    << "), bufoff= " << HexOut(BufferOffset) << ") : \n";

    OutputUnionArms( SwitchIs );

    if ( !SaveCtxt.IsEmbedded )
        {
        // Output the pointees for this flat block
        dout << "Flat part of union is done, printing pointees.\n";
        dout << '\n';
        EmbeddedPointerList->OutputPointees();
        }

    dout << "Union is done.\n";
    }

VOID
BUFFER_PRINTER::OutputStructure()
    {

    BUFFER_PRINTER_SAVE_CONTEXT SaveCtxt(this);

    StartEmbedded(&SaveCtxt, TRUE, IsArrayEmbedded);

    if (!IsConformantArrayDone)
        {
        IsConformantArrayDone = FALSE;
        }
    
    UINT64 ArrayAddress;

    FORMAT_STRING BogusLayout;

    UINT64 BufferOffset = Buffer->GetCurrentOffset();    

    //
    // Read first four bytes of description.
    //
    UCHAR FormatType = FormatString->GetUCHAR();
    CHAR Alignment = FormatString->GetCHAR();
    USHORT MemSize = FormatString->GetUSHORT();

    UINT64 CurrentAddress = 0;
    SHORT ArrayOffset = 0;

    BOOL IsBogus = (FormatType == FC_BOGUS_STRUCT);

    // Get the conformant/varying array description.

    switch ( FormatType )
        {
        case FC_BOGUS_STRUCT:
        case FC_CSTRUCT:    
        case FC_CPSTRUCT:
        case FC_CVSTRUCT:
            CurrentAddress = FormatString->GetAddress();
            ArrayOffset = FormatString->GetUSHORT();
            if ( ArrayOffset )
                {
                ArrayAddress = CurrentAddress + ArrayOffset; 

                // Read the conformant size info into the buffer.
                
                SetupConformanceCountBuffer(&SaveCtxt, ArrayAddress);
                Elements = ConformanceCountBuffer->ReadULONG();
                }
            break;

        case FC_STRUCT:    
        case FC_PSTRUCT:
            break;

        default:
            ABORT( "BAD FC: a struct expected : " << FormatString->GetFormatCharName( FormatType ) << '\n');
            return;
        }

    Buffer->Align( Alignment );

    dout << "Structure (bufoff= " << HexOut(BufferOffset) << ") aligned at " 
    << HexOut(Alignment) << ", mem size " << HexOut(MemSize) << '\n';
    {
        IndentLevel l(dout);


        if ( FormatType != FC_STRUCT  &&
             FormatType != FC_CSTRUCT )
            {
            // Skip the pointer layout part.
            //
            // For the complex struct skip only the offset to the layout.
            // When non-bogus, create the pointee list to walk later.
            // Pointee for bogus would be added when outputting the flat part.

            if ( FormatType == FC_BOGUS_STRUCT )
                {
                BogusLayout.SetAddress(FormatString->ComputeOffset());
                }
            else
                {
                // Set the buffer offset mark to the beginning of the structure.

                if ( FC_CVSTRUCT == FormatType )
                    {

                    // In this case, the correct number of elements
                    // is the variance count, not the conformance count.

                    BUFFER TempBuffer = *Buffer;

                    // Move past block copyable part of structure
                    TempBuffer.Move(MemSize);

                    TempBuffer.AlignULONG();
                    ULONG TempOffset = TempBuffer.GetULONG();
                    ULONG TempActualCount = TempBuffer.GetULONG();

                    SWAP_SCOPE<ULONG> swapscope(&Elements, TempActualCount);
                    ProcessPointerLayout( Buffer );
                    }

                else 
                    {
                    ProcessPointerLayout( Buffer );             
                    }
                }
            }

        UCHAR MemberFormatType = FormatString->ReadUCHAR();

        while ( MemberFormatType != FC_END )
            {

            // Actual field to read from the buffer.

            if ( MemberFormatType == FC_POINTER )
                {
                AddPointer( &BogusLayout, TRUE );
                FormatString->Move(1);
                }
            else
                {
                OutputType( );
                }

            MemberFormatType = FormatString->ReadUCHAR();
            }
        
        // If this is an embedded bogus struct, the topmost 
        // bogus struct unmarshales the array.
        // BUT, a bogus struct can contain a bogus struct in which
        // case the conformant struct unmarshals the array.
        if ( ArrayOffset && 
             !IsConformantArrayDone &&
             ( !IsBogus || (IsBogus && !SaveCtxt.IsStructEmbedded) ) )
            {
            dout << "Tail array for structure.\n";
            OutputType( ArrayAddress );
            IsConformantArrayDone = TRUE;
            }
    }

    if ( !SaveCtxt.IsEmbedded )
        {
        // Output the pointees for this flat block
        dout << "Flat part of structure is done, printing pointees.\n";
        dout << '\n';
        EmbeddedPointerList->OutputPointees();
        }

    dout << "Structure is done\n";

    return;
    }

ULONG
BUFFER_PRINTER::GetArrayDimensions(UINT64 Address, BOOL CountStrings)
{
    FORMAT_STRING CurrentFormat(Address);
    ULONG    Dimensions;

    //
    // Only a complex array can have multiple dimensions.
    //
    if ( CurrentFormat.ReadUCHAR() != FC_BOGUS_ARRAY )
        return 1;

    Dimensions = 1;

    CurrentFormat.IncUCHAR(); //Skip type
    CurrentFormat.IncUCHAR(); //Skip Alignment
    CurrentFormat.IncUSHORT(); //Skip # elements.
    CurrentFormat.SkipCorrelationDesc( IsRobust );
    CurrentFormat.SkipCorrelationDesc( IsRobust );

    for ( ; CurrentFormat.ReadUCHAR() == FC_EMBEDDED_COMPLEX; )
        {
        CurrentFormat.Move(2);
        CurrentFormat.GotoOffset();

        //
        // Search for a fixed, complex, or string array.
        //
        switch ( CurrentFormat.ReadUCHAR() ) 
            {
            case FC_SMFARRAY :
                CurrentFormat.Move(4);
                break;

            case FC_LGFARRAY :
                CurrentFormat.Move(6);
                break;

            case FC_BOGUS_ARRAY :
                CurrentFormat.Move(12);
                CurrentFormat.SkipCorrelationDesc( IsRobust );
                CurrentFormat.SkipCorrelationDesc( IsRobust );
                break;

            case FC_CSTRING :
            case FC_BSTRING :
            case FC_WSTRING :
            case FC_SSTRING :
            case FC_C_CSTRING :
            case FC_C_BSTRING :
            case FC_C_WSTRING :
            case FC_C_SSTRING :

            //
            // Can't have any more dimensions after a string array.
            //
            return CountStrings ? Dimensions + 1 : Dimensions;

            default :
                return Dimensions;
            }

        Dimensions++;
        }

    //
    // Get here if you have only one dimension.
    //
    return Dimensions;
}

void
BUFFER_PRINTER::OutputArray()
    {

    BUFFER_PRINTER_SAVE_CONTEXT SaveCtxt(this);

    StartEmbedded(&SaveCtxt, IsStructEmbedded, TRUE); 

    ULONG TotalSize;
    BOOL HasConformance = FALSE;
    BOOL HasVariance = FALSE;
    BOOL HasPointerLayout = FALSE;

    UINT64 BufferOffset = Buffer->GetCurrentOffset();

    UINT64 ArrayAddress = FormatString->GetAddress();    

    UCHAR FormatType = FormatString->GetUCHAR();
    UCHAR Alignment = FormatString->GetUCHAR();

    switch ( FormatType )
        {
        
        case FC_SMFARRAY :
            TotalSize = FormatString->GetUSHORT();
            HasPointerLayout = TRUE;
            break;

        case FC_LGFARRAY :
            TotalSize = FormatString->GetULONG();
            HasPointerLayout = TRUE;
            break;

        case FC_CARRAY :
            FormatString->GetUSHORT(); //Element size
            FormatString->SkipCorrelationDesc(IsRobust);
            HasPointerLayout = TRUE;
            HasConformance = TRUE;
            break;

        case FC_CVARRAY :
            FormatString->GetUSHORT(); //Element size
            FormatString->SkipCorrelationDesc(IsRobust);
            FormatString->SkipCorrelationDesc(IsRobust);
            HasPointerLayout =TRUE;
            HasConformance = HasVariance = TRUE;
            break;

        case FC_SMVARRAY :
            FormatString->GetUSHORT(); //Total size
            Elements = FormatString->GetUSHORT(); //Number of elements
            FormatString->GetUSHORT(); //Element size
            FormatString->SkipCorrelationDesc(IsRobust);
            HasPointerLayout = TRUE;
            HasVariance = TRUE;
            break;

        case FC_LGVARRAY :
            FormatString->GetULONG(); //Total size
            Elements = FormatString->GetULONG(); //Number of elements
            FormatString->GetUSHORT(); //Element size
            FormatString->SkipCorrelationDesc(IsRobust);
            HasPointerLayout = TRUE;
            HasVariance = TRUE;
            break;

        case FC_BOGUS_ARRAY :
            {
            ULONG TempElements = FormatString->GetUSHORT();
            if (TempElements)
                {
                // This is a fixed size bogus array.
                Elements = TempElements;
                }
            HasConformance = FormatString->SkipCorrelationDesc(IsRobust);
            HasVariance    = FormatString->SkipCorrelationDesc(IsRobust);
            break;            
            }

        default :
            ABORT( "Unknown array type\n" );

        }

    if ( HasConformance )
        {
        SetupConformanceCountBuffer(&SaveCtxt, ArrayAddress);
        Elements = ConformanceCountBuffer->GetULONG();
        }

    if ( HasVariance )
        {
        SetupVarianceBuffer(&SaveCtxt, ArrayAddress);
        
        Buffer->AlignULONG();
        Offset = VarianceBuffer->GetULONG();
        Length = VarianceBuffer->GetULONG();
        }

    // Note that a fixed array can never have a variable repeat.
    if ( HasPointerLayout && ( FormatString->ReadUCHAR() == FC_PP ) )
        {
        BUFFER BufferMark = *Buffer;
        // Set elements to actual count for pointer layout processing if
        // the array is varying.
        SWAP_SCOPE<ULONG> swapscope( &Elements, Length , FC_CVARRAY == FormatType ||
                                                         FC_SMVARRAY == FormatType ||
                                                         FC_LGVARRAY == FormatType );
        ProcessPointerLayout( & BufferMark );
        }

    // Need to compute the number of elements for fixed arrays
    if ( FC_SMFARRAY == FormatType ||
         FC_LGFARRAY == FormatType )
        {

        FORMAT_STRING TempFormat = *FormatString;

        switch ( TempFormat.ReadUCHAR() )
            {
            case FC_EMBEDDED_COMPLEX :

                TempFormat.Move(2);
                TempFormat.GotoOffset();

                //
                // We must be at FC_STRUCT, FC_PSTRUCT, FC_SMFARRAY, or FC_LGFARRAY.
                // All these have the total size as a short at 2 bytes past the 
                // beginning of the description except for large fixed array.
                //
                { 

                    UCHAR FormatChar = TempFormat.ReadUCHAR();
                    TempFormat.Move(2);

                    if ( FormatChar != FC_LGFARRAY )
                        Elements = TotalSize / TempFormat.GetUSHORT();
                    else
                        Elements = TotalSize / TempFormat.GetULONG();                              
                    break;

                }

                //
                // Simple type (enum16 not possible).
                //
            default :
                Elements = TotalSize / SIMPLE_TYPE_MEMSIZE( TempFormat.GetUCHAR() );
                break;
            }

        }

    switch ( FormatType )
        {
        case FC_SMFARRAY :
        case FC_LGFARRAY :
            dout << "Fixed array (elements= " << Elements 
                 << ", bufoff= " << HexOut(BufferOffset) << ") : \n";
            break;
        case FC_CARRAY :
            dout << "Conformant array (elements= " << Elements 
                 << ", bufoff= " << HexOut(BufferOffset) << ") : \n";
            break;
        case FC_CVARRAY :
            dout << "Conf-var. array";
            dout << "    (size= " << Elements << ", offset= " << Offset << ", length= " 
            << Length << ", bufoff= " << HexOut(BufferOffset) << ") : \n";
            Elements = Length;
            break;
        case FC_SMVARRAY :
        case FC_LGVARRAY :
            dout << "Conf-var. array";
            dout << "    (size= " << Elements << ", offset= " << Offset << ", length= " 
            << Length << ", bufoff= " << HexOut(BufferOffset) << ") : \n";
            Elements = Length;
            break;
        case FC_BOGUS_ARRAY :
            dout << "Bogus array (elements= " << Elements 
                 << ", bufoff= " << HexOut(BufferOffset) << ") : \n";
            if ( HasConformance )
                dout << " Conf.";
            if ( HasVariance )
                dout <<" -Var.: offset = " << Offset << ", length = " << Length << ";";
            dout << " :\n";
            if ( HasVariance )
                Elements = Length;
            break;
        }

    if ( HasPointerLayout && ( FormatString->ReadUCHAR() == FC_PP ) )
        {
        
        ProcessPointerLayout( Buffer );
        
        }



    UCHAR ArrayType = FormatString->ReadUCHAR();
    
    ULONG ArrayElements = Elements; // Array element may change elements.

    if ( !ArrayElements )
        {
        dout << "Array has 0 elements.\n";
        }
    else 
        {
        // Arrays of reference pointers do not have a wire representation.
        // Complex array only.
        if (FC_RP == ArrayType)
            {
            dout << "Array of reference pointers(Pointers have no wire format).\n";
            for( ULONG i = 0; i < ArrayElements - 1; i++ ) {
               dout << "Array element " << i << ": ";
               FORMAT_STRING NewFormatString = *FormatString;
               AddArrayRefPointer(&NewFormatString, TRUE);
            }
            dout << "Array element " << i << ": ";
            AddArrayRefPointer(FormatString, TRUE);
            }
        
        // If the first element match a pointer, this is probably an array of
        // pointers.   Use the long format.

        else if ( IS_SIMPLE_TYPE(ArrayType) &&
                   !EmbeddedPointerList->Lookup(Buffer->GetAddress()))
            {
            OutputSimpleType( TRUE, ArrayElements );            
            }
        else
            {
            for (ULONG i = 0; i < ArrayElements - 1; i++)
                {
                dout << "Array element " << i << ": ";
                OutputType(FormatString->GetAddress());
                }
            dout << "Array element " << i << ": ";
            OutputType( );
            }
        }

    if ( ! SaveCtxt.IsEmbedded )
        {
        dout << "Flat part of array done, printing pointees.\n";
        dout << '\n';
        EmbeddedPointerList->OutputPointees();        
        }

    dout << "Array is done.\n";

    }



VOID
BUFFER_PRINTER::ProcessPointerLayout( BUFFER *pBufferMark )
/*--

RoutineDescription :

    Skips a pointer layout format string description.
    This is for the proper pointer layout (not for FC_BOGUS_STRUCT).
    Also, put the pointers to the pointer dictionary.

--*/
    {
    ULONG NumberPointers;

    UCHAR FormatPP = FormatString->ReadUCHAR();

    if ( FormatPP != FC_PP )
        {
        return;
        }
    
    FormatString->IncUCHAR();
    UCHAR FormatPAD = FormatString->GetUCHAR();

    for ( ;; )
        {

        UCHAR LayoutType = FormatString->GetUCHAR();
        UCHAR VariableRepeatType;
        ULONG Iterations = 1;
        switch ( LayoutType )
            {
            case FC_END :
                return;

            case FC_NO_REPEAT :
                {
                    FormatString->IncUCHAR(); // Skip FC_PAD
                    FormatString->IncSHORT(); //Skip offset to pointer in memory.
                    BUFFER BufferMark = *pBufferMark;
                    BufferMark.Move(FormatString->GetSHORT());
                    SWAP_SCOPE<BUFFER*> swapscope(&Buffer, &BufferMark);
                    AddPointer( FormatString, FALSE );
                    break;         
                }

            case FC_FIXED_REPEAT :
                FormatString->IncUCHAR();  //Skip FC_PAD
                Iterations = FormatString->GetUSHORT();
                goto REPEAT_COMMON;
                // fall through...

            case FC_VARIABLE_REPEAT :
                FormatString->GetUCHAR(); // Skip Repeat Type
                Iterations = Elements;

                REPEAT_COMMON:
                {

                    SHORT Increment = FormatString->GetSHORT();
                    // Skip offset to array since pointer offsets are
                    // relative to buffermark.
                    FormatString->IncSHORT();
                    NumberPointers = FormatString->GetUSHORT(); 

                    if ( Iterations )
                        {
                        // Add the pointers while we skip them.
                        
                        FORMAT_STRING WorkFormatString;

                        LONG Offset = 0;

                        do
                           {
                           WorkFormatString = *FormatString;
                           for ( ULONG i = NumberPointers; i > 0; i-- )
                               {
                               WorkFormatString.IncSHORT(); //Skip offset in memory
                               SHORT PtrOffset = WorkFormatString.       GetSHORT();
                               BUFFER BufferMark = *pBufferMark;
                               BufferMark.Move(Offset + PtrOffset);
                               SWAP_SCOPE<BUFFER*> swapscope(&Buffer, &BufferMark);
                               AddPointer( &WorkFormatString, FALSE );
                               }                        
                           
                           Offset += Increment;

                           } while (--Iterations);

                        *FormatString = WorkFormatString;
                        }
                    
                    else 
                        {
                        // Just skip the pointer list
                        for (UINT i = NumberPointers; i > 0; i-- )
                            {
                            FormatString->IncSHORT(); //Skip offset in memory
                            FormatString->IncSHORT(); //Skip pointer offset
                            POINTER::SkipCommonPointerFormat( FormatString );
                            }
                        }

                    break;         
                } 

            default :
                ABORT( "ProcessPointerLayout : unexpected FC: " << FormatString->GetFormatCharName(LayoutType) << '\n');
            }

        }

    return;
    }

VOID
BUFFER_PRINTER::AddArrayRefPointer( FORMAT_STRING *pFormat,
                                    BOOL PrintPointer) 
    {
    AddPointer( pFormat, PrintPointer, TRUE);
    }

VOID
BUFFER_PRINTER::AddPointer( FORMAT_STRING *pFormat,
                            BOOL PrintPointer,
                            BOOL ArrayRef
                            )
    {
    if (!ArrayRef)
        {
        Buffer->AlignULONG();        
        }
    POINTER *pPointer = new POINTER( pFormat, Buffer, this , ArrayRef);

    EmbeddedPointerList->Add( Buffer->GetAddress(), pPointer );

    if ( PrintPointer )
        {
        ULONG WireRep = 0;
        if (pPointer->HasWireRep())
           {       
           WireRep = pPointer->GetWireRep( Buffer );
           Buffer->IncULONG();        
           }
        pPointer->OutputPointer( WireRep );        
        }
    }

VOID
BUFFER_PRINTER::OutputPointer(BOOL OutputPointee, BOOL ArrayRef )
    {
    ULONG WireRep = 0;
    Buffer->AlignULONG();
    auto_ptr<POINTER> pPointer = 
        auto_ptr<POINTER>(new POINTER( FormatString, Buffer, this, ArrayRef ));
    UINT WireAddress = Buffer->GetAddress();
    if (pPointer->HasWireRep())
        {
        WireRep = pPointer->GetWireRep( Buffer );
        Buffer->IncULONG();        
        }
    pPointer->OutputPointer( WireRep );
    if ( OutputPointee )
        {
        pPointer->OutputPointee( WireRep, &FullPointerTable, Buffer );
        }
    else 
        {

        EmbeddedPointerList->Add( Buffer->GetAddress(), pPointer.release() );
        }
    }

VOID BUFFER_PRINTER::OutputProcPicklingHeader()
    {
    PROC_PICKLING_HEADER ProcHeader;
    Buffer->Get(&ProcHeader, sizeof(ProcHeader));
    
    dout << "Proc picking header:\n";
        {
        IndentLevel l(dout);
        Print(dout, ProcHeader, VerbosityLevel);
        dout << '\n';
        }
    }

VOID BUFFER_PRINTER::OutputTypePicklingHeader()
    {
    TYPE_PICKLING_HEADER TypeHeader;
    Buffer->Get(&TypeHeader, sizeof(TypeHeader));
    
    dout << "Type picking header:\n";
        {
        IndentLevel l(dout);
        Print(dout, TypeHeader, VerbosityLevel);
        dout << '\n';
        }
    }

VOID BUFFER_PRINTER::OutputBuffer(NDREXTS_STUBMODE_TYPE StubMode, 
                                  NDREXTS_DIRECTION_TYPE Direction, BOOL IsPickling )
    {

    switch ( StubMode )
        {
        case OS:
            OutputOsBuffer(Direction, IsPickling);
            break;
        case OI:
            OutputOIBuffer(Direction, IsPickling);
            break;
        case OIC:
        case OICF:
        case OIF:
            OutputOIFBuffer(Direction, IsPickling);
            break;
        default:
            ABORT("Corrupt stub mode.\n");
        }
    }

void BUFFER_PRINTER::SkipOiHeader()
    {

    UCHAR HandleType = FormatString->GetUCHAR();
    UCHAR OiFlags = FormatString->GetUCHAR();

    FormatString->Move(4); //Common part 
    if ( OiFlags & Oi_HAS_RPCFLAGS )
        {
        FormatString->Move(4); // Has rpc flags
        }
    if ( 0==HandleType )
        {
        HandleType = FormatString->GetUCHAR();
        switch ( HandleType )
            {
            case FC_BIND_PRIMITIVE:
                FormatString->Move(3);
                break;
            case FC_BIND_GENERIC:
                FormatString->Move(5);
                break;
            case FC_BIND_CONTEXT:
                FormatString->Move(5);
                break;
            default:
                ABORT("Unknown handle type, " << HexOut(HandleType) << "."); 
            }
        }
    }

void BUFFER_PRINTER::OutputOIBuffer(NDREXTS_DIRECTION_TYPE Direction, BOOL IsPickling )
    {

    SetupWorkValues();

    // Skip past the proc header and treat as an OS_PROCEDURE
    SkipOiHeader();
    OutputOsBufferInternal( Direction, IsPickling );
    }

void BUFFER_PRINTER::OutputParameters(UINT NumberOfParameters, BOOL IsIn, BOOL IsPipe)
    {

    UINT64 FormatStringAddressSave = FormatString->GetAddress();

    for ( UINT i = 0; i < NumberOfParameters; i++ )
        {
        USHORT ParamAttributes = FormatString->GetUSHORT();
        FormatString->IncUSHORT();
        PPARAM_ATTRIBUTES pParamAttributes = (PPARAM_ATTRIBUTES)&ParamAttributes;

        if ( (pParamAttributes->IsPipe == IsPipe) &&
             ((IsIn && pParamAttributes->IsIn) ||
              (!IsIn && (pParamAttributes->IsOut || pParamAttributes->IsReturn))) )
            {

            dout << "Param number " << i << ":\n";
            dout << "IsPipe: " << HexOut(pParamAttributes->IsPipe) << ' ';
            dout << "IsIn: " << HexOut(pParamAttributes->IsIn) << '\n';
            dout << "IsOut: " << HexOut(pParamAttributes->IsOut) << ' ';
            dout << "IsReturn: " << HexOut(pParamAttributes->IsReturn) << '\n';

            if ( pParamAttributes->IsBasetype )
                {
                OutputType();
                FormatString->Move(1);
                }
            else
                {
                SHORT Offset = FormatString->GetSHORT();
                FORMAT_STRING TypeFormat = WorkTypeFormatString;
                FormatString = &TypeFormat;
                FormatString->Move(Offset);
                OutputType( );
                FormatString = &WorkProcFormatString;
                }
            dout << '\n';
            }
        else
            {
            FormatString->IncUSHORT();
            }
        }

    FormatString->SetAddress(FormatStringAddressSave);
    }

void BUFFER_PRINTER::OutputOIFBuffer( NDREXTS_DIRECTION_TYPE Direction, BOOL IsPickling )
    {

    BOOL PrintInParameters = (Direction == IN_BUFFER_MODE);

    SetupWorkValues();

    SkipOiHeader();

    FormatString->Move(4);
    UCHAR InterpretorFlags = FormatString->GetUCHAR();
    PINTERPRETER_OPT_FLAGS pInterpretorFlags = (PINTERPRETER_OPT_FLAGS)&InterpretorFlags;
    UINT NumberOfParameters = FormatString->GetUCHAR();

    if ( pInterpretorFlags->HasExtensions )
        {
        UINT64 FormatAddressSave = FormatString->GetAddress();
        UINT ExtensionSize;
        if ( (ExtensionSize = FormatString->GetUCHAR()) >= 2 )
            {
            UCHAR InterpreterFlags2 = FormatString->GetUCHAR();
            PINTERPRETER_OPT_FLAGS2 pInterpreterFlags2 = (PINTERPRETER_OPT_FLAGS2)&InterpreterFlags2;
            IsRobust = pInterpreterFlags2->HasNewCorrDesc; 
            }
        FormatString->SetAddress(FormatAddressSave + ExtensionSize); 
        }

    if (IsPickling)
        {
        OutputProcPicklingHeader();        
        }

    dout << "Procedure has " << NumberOfParameters << " parameters.\n";


    if ( PrintInParameters )
        {
        //pipes are last in the in stream
        dout << "Non-pipe parameters:\n";
        OutputParameters(NumberOfParameters, PrintInParameters, FALSE);
        dout << "Pipe parameters:\n";
        OutputParameters(NumberOfParameters, PrintInParameters, TRUE);
        }
    else
        {
        //pipes are first in the out stream
        dout << "Pipe parameters:\n";
        OutputParameters(NumberOfParameters, PrintInParameters, TRUE);
        dout << "Non pipe parameters:\n";
        OutputParameters(NumberOfParameters, PrintInParameters, FALSE);
        }
    dout << "End of parameters.\n\n";
    }

void BUFFER_PRINTER::OutputOsBuffer( NDREXTS_DIRECTION_TYPE Direction, BOOL IsPickling )
    {
    SetupWorkValues();
    OutputOsBufferInternal( Direction, IsPickling );
    }

void BUFFER_PRINTER::OutputOsBufferInternal( NDREXTS_DIRECTION_TYPE Direction, BOOL IsPickling )
    {


    if (IsPickling)
        {
        OutputProcPicklingHeader();        
        }

    BOOL PrintInParameters = (Direction == IN_BUFFER_MODE);

    for ( UINT ParamNumber = 0; ; ParamNumber++)
        {

        uchar   FormatType;
        char    *ParamKind;

        UCHAR ParamDirection = FormatString->GetUCHAR();
        BOOL SkipParam;

        switch ( ParamDirection )
            {
            case FC_IN_PARAM :
            case FC_IN_PARAM_BASETYPE :
            case FC_IN_PARAM_NO_FREE_INST :
                ParamKind = "[in] only";
                SkipParam = !PrintInParameters;
                break;
            case FC_IN_OUT_PARAM :
                ParamKind = "[in,out]";
                SkipParam = FALSE;
                break;
            case FC_OUT_PARAM :
                ParamKind = "[out] only";
                SkipParam = PrintInParameters;
                break;
            case FC_RETURN_PARAM :
            case FC_RETURN_PARAM_BASETYPE :
                ParamKind = "the return value";
                SkipParam = PrintInParameters;
                break;
            case FC_END:
                dout << "End of parameters.\n\n";
                return;
            default :
                ABORT( "Aborting expected a parameter FC, found " << 
                       FormatString->GetFormatCharName( ParamDirection ) <<
                       HexOut(ParamDirection) << ".\n");
                break;
            }

        if ( SkipParam )
            {
            if ( ParamDirection == FC_IN_PARAM_BASETYPE || ParamDirection == FC_RETURN_PARAM_BASETYPE )
                {
                FormatString->Move(1); // Skip past simple type

                }
            else
                {
                FormatString->Move(3); // skip past stacksize and pad.
                }
            continue;
            }

        dout << "Parameter " << ParamNumber << " is " 
        << ParamKind << " \n\n";

        switch ( ParamDirection )
            {
            case FC_IN_PARAM_BASETYPE :
            case FC_RETURN_PARAM_BASETYPE :
                OutputType( );
                dout << '\n';
                break;

            default :
                FormatString->Move(1); //skip stacksize              
                SHORT Offset = FormatString->GetSHORT();
                FORMAT_STRING TypeFormat = WorkTypeFormatString;
                FormatString = &TypeFormat;
                FormatString->Move(Offset);
                OutputType( );
                FormatString = &WorkProcFormatString;
                dout << '\n';
                break;
            }

        }

    }

VOID 
BUFFER_PRINTER::OutputTypeBuffer( BOOL IsPickling, BOOL IsRobust )
{
   SetupWorkValues();
   BUFFER_PRINTER::IsRobust = IsRobust;

   if (IsPickling)
       {
       OutputTypePicklingHeader();
       }

   OutputType();
}

VOID
BUFFER_PRINTER::StartEmbedded(BUFFER_PRINTER_SAVE_CONTEXT *SaveCtxt, 
                              BOOL IsStructEmbedded, BOOL IsArrayEmbedded)
{
    if (!SaveCtxt->IsEmbedded)
        {
        EmbeddedPointerList = &SaveCtxt->NewEmbeddedPointerList;
        }
    IsEmbedded = TRUE;
    BUFFER_PRINTER::IsStructEmbedded = IsStructEmbedded;
    BUFFER_PRINTER::IsArrayEmbedded = IsArrayEmbedded;
}

VOID
BUFFER_PRINTER::SetupConformanceCountBuffer(BUFFER_PRINTER_SAVE_CONTEXT *SaveCtxt,
                                            UINT64 ArrayAddress)
{
    if (!ConformanceCountBuffer)
        {
        Buffer->AlignULONG();
        ConformanceCountBuffer = &SaveCtxt->NewConformanceCountBuffer;
        *ConformanceCountBuffer = *Buffer;
        ULONG Dimensions = GetArrayDimensions(ArrayAddress, TRUE);
        Buffer->Move(Dimensions * sizeof(ULONG));
        }
    else 
        {
        SaveCtxt->NewConformanceCountBuffer = *ConformanceCountBuffer;
        ConformanceCountBuffer = &SaveCtxt->NewConformanceCountBuffer;
        }
}

VOID
BUFFER_PRINTER::SetupVarianceBuffer(BUFFER_PRINTER_SAVE_CONTEXT *SaveCtxt,
                                    UINT64 ArrayAddress)
{

    if (!VarianceBuffer)
        {
        Buffer->AlignULONG();
        VarianceBuffer = &SaveCtxt->NewVarianceBuffer;        
        *VarianceBuffer = *Buffer;
        ULONG Dimensions = GetArrayDimensions(ArrayAddress, FALSE);
        Buffer->Move(Dimensions * sizeof(ULONG) * 2);
        }
    else 
        {
        SaveCtxt->NewVarianceBuffer = *VarianceBuffer;
        VarianceBuffer = &SaveCtxt->NewVarianceBuffer;
        }
}


BUFFER_PRINTER_SAVE_CONTEXT::BUFFER_PRINTER_SAVE_CONTEXT(BUFFER_PRINTER *pPrinter) :
    Buffer(pPrinter->Buffer),
    ConformanceCountBuffer(pPrinter->ConformanceCountBuffer),
    VarianceBuffer(pPrinter->VarianceBuffer),
    FormatString(pPrinter->FormatString),
    EmbeddedPointerList(pPrinter->EmbeddedPointerList),
    IsEmbedded(pPrinter->IsEmbedded),
    IsStructEmbedded(pPrinter->IsStructEmbedded),
    IsArrayEmbedded(pPrinter->IsArrayEmbedded)
{
    BUFFER_PRINTER_SAVE_CONTEXT::pPrinter = pPrinter;    
}

BUFFER_PRINTER_SAVE_CONTEXT::~BUFFER_PRINTER_SAVE_CONTEXT()
{
    
    pPrinter->Buffer = Buffer;
    pPrinter->ConformanceCountBuffer = ConformanceCountBuffer;
    pPrinter->VarianceBuffer = VarianceBuffer;
    pPrinter->FormatString = FormatString;
    pPrinter->EmbeddedPointerList = EmbeddedPointerList;
    pPrinter->IsEmbedded = IsEmbedded;
    pPrinter->IsStructEmbedded = IsStructEmbedded;
    pPrinter->IsArrayEmbedded = IsArrayEmbedded; 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrexts\ndrexts\ndrexts.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ndrexts.cxx

Abstract:

    This file contains ntsd debugger extensions for RPC NDR.

Author:

    Mike Zoran  (mzoran)     September 3, 1999

Revision History:

--*/
#define USE_STUBLESS_PROXY
#include "ndrextsp.hxx"
#include "orpcexts.h"
#include "basicinf.hxx"

// =======================================================================

//
// Project wide global variables
//

EXT_API_VERSION        ApiVersion = {
    VER_PRODUCTVERSION_W >> 8,
    VER_PRODUCTVERSION_W & 0xFF,
    EXT_API_VERSION_NUMBER,
    0
};

BOOL                    OldExtensions=TRUE;
BOOL                    ExtensionsInitialized=FALSE;
USHORT                  SavedMajorVersion=0;
USHORT                  SavedMinorVersion=0;
BOOL                    ChkTarget;            // is debuggee a CHK build?

// ntstatus to error name lookup
#include <ntstatus.dbg>

EXTERN_C HANDLE ProcessHandle = 0;
EXTERN_C BOOL fKD = 0;

// Settings

NDREXTS_STUBMODE_TYPE ContextStubMode = OICF;
NDREXTS_DIRECTION_TYPE ContextDirection = IN_BUFFER_MODE;
BOOL ContextPickling = FALSE;
BOOL ContextRobust = FALSE;
NDREXTS_VERBOSITY VerbosityLevel = MEDIUM;

// Printing

class DEBUGGER_STREAM_BUFFER : public FORMATTED_STREAM_BUFFER
   {
protected:
   virtual void SystemOutput(const char *p);
   virtual BOOL SystemPollCtrlC();
   } DbgOutStream; // Stream to output to the debugger.

void DEBUGGER_STREAM_BUFFER::SystemOutput(const char *p)
   {
       dprintf(p);
   }

BOOL DEBUGGER_STREAM_BUFFER::SystemPollCtrlC()
   {
   return ::PollCtrlC();
   }

FORMATTED_STREAM_BUFFER & dout = DbgOutStream;

//
// Project wide memory management
//

void * __cdecl ::operator new(size_t Bytes)
    {
    void *p = HeapAlloc(GetProcessHeap(), 0, Bytes);
    if ( !p )
        {
        throw bad_alloc();
        }
    return p;
    }

void __cdecl ::operator delete (void *p)
    {
    HeapFree(GetProcessHeap(),0,p);
    }

const char CExceptionText[] = "C Exception";

class SEHException : public exception
    {
    unsigned int ExceptionCode;

    const char *GenerateString(unsigned int Id)
        {
        int i = 0;
        while ( ntstatusSymbolicNames[i].SymbolicName )
            {
            if ( ntstatusSymbolicNames[i].MessageId == Id )
                {
                return ntstatusSymbolicNames[i].SymbolicName;
                }
            i++;
            }
        return CExceptionText;
        }
public:
    SEHException(unsigned int c) : exception(GenerateString(c)) ,ExceptionCode(c)
        {

        }
    virtual unsigned int GetExceptionCode(void)
        {
        return ExceptionCode;
        }
    };

void _cdecl SEHTranslator(unsigned int ExceptionCode, struct _EXCEPTION_POINTERS* ExceptionPointers)
    {
    throw SEHException(ExceptionCode);
    }




extern "C" {

    DllMain(
           HANDLE hModule,
           DWORD  dwReason,
           DWORD  dwReserved
           )
        {
        switch ( dwReason )
            {
            case DLL_THREAD_ATTACH:
                break;

            case DLL_THREAD_DETACH:
                break;

            case DLL_PROCESS_DETACH:
                break;

            case DLL_PROCESS_ATTACH:
                _set_se_translator(SEHTranslator);
                break;
            }

        return TRUE;
        }


    VOID
    WinDbgExtensionDllInit(
                          PWINDBG_EXTENSION_APIS lpExtensionApis,
                          USHORT MajorVersion,
                          USHORT MinorVersion
                          )
        {
        ExtensionApis = *lpExtensionApis;

        SavedMajorVersion = MajorVersion;
        SavedMinorVersion = MinorVersion;
        ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;

        OldExtensions = FALSE;
        ExtensionsInitialized = TRUE;

    fKD = 1;

    return;
}

    VOID
    CheckVersion(
                VOID
                )
        {

#if DBG
        char Kind[] = "Checked";
#else
        char Kind[] = "Free";
#endif

        char *VersionKind = (SavedMajorVersion==0x0f) ? "Free" : "Checked";
        if ( (SavedMajorVersion != 0x0c) || (SavedMinorVersion !=
            VER_PRODUCTBUILD) )
            {
            dout << '\n';
            dout << "*** Extension DLL(" << VER_PRODUCTBUILD << " " << Kind
            << ") does not match target system(" << SavedMinorVersion
            << " " << VersionKind << ") \n";
            dout << '\n';
            }
        }

    LPEXT_API_VERSION
    ExtensionApiVersion(
                       VOID
                       )
        {
        return &ApiVersion;
        }

} // extern "C"


ULONG
ReadProcessMemoryThunk(
                      ULONG_PTR  offset,
                      PVOID      lpBuffer,
                      ULONG      cb,
                      PULONG     lpcbBytesRead
                      )
    {
        SIZE_T RealBytesRead;
        ULONG rc = ReadProcessMemory(hCurrentProcess, (PVOID)offset, lpBuffer, cb, &RealBytesRead);
        *lpcbBytesRead = rc ? (ULONG)RealBytesRead : 0;
        return rc;
    }

ULONG
WriteProcessMemoryThunk(
                       ULONG_PTR  offset,
                       LPVOID     lpBuffer,
                       ULONG      cb,
                       PULONG     lpcbBytesWritten
                       )
    {
        SIZE_T RealBytesWritten;
        ULONG rc = WriteProcessMemory(hCurrentProcess, (PVOID)offset, lpBuffer, cb, &RealBytesWritten);
        *lpcbBytesWritten = rc ? (ULONG)RealBytesWritten : 0;
        return rc;
    }

typedef VOID (*PEXTENSION_API_ROUTINE)(VOID);

LPSTR lpArgumentString;

DWORD
ExtensionWrapRoutine(
                    IN LPVOID ExtensionRoutine
                    )
    {
    try
        {

        // Parse extension arguments.
        ExtensionArgumentString = lpArgumentString;
        ExtensionArgs.clear();
        if ( lpArgumentString )
            {
            size_t c = strlen(lpArgumentString) + 1;
            char *p = (char *)_alloca(c);
            const char seps[] = " \t\n";
            memcpy(p, lpArgumentString, c);
            p = strtok(p, seps);
            while ( p )
                {
                ExtensionArgs.push_back(string(p));
                p = strtok(NULL, seps);
                }

            }

        // Run the actual extension
        (*((PEXTENSION_API_ROUTINE)ExtensionRoutine))();
        }
    catch ( exception & e )
        {
        dout << '\n';
        dout << "An unexpected error occured.\n";
        dout << e.what() << '\n';
        }
    return 0;
    }

VOID
InitExtensionApi(IN HANDLE hCurrentProcess,
                 IN HANDLE hCurrentThread,
                 IN DWORD_PTR dwCurrentPc,
                 IN PWINDBG_EXTENSION_APIS lpExtensionsApis,
                 IN LPSTR lpArgumentString,
                 IN PEXTENSION_API_ROUTINE ExtensionRoutine
                )
    {

    // Initialize global variables for extension
    ::hCurrentProcess = ProcessHandle = hCurrentProcess;
    ::hCurrentThread = hCurrentThread;
    ::dwCurrentPc = dwCurrentPc;
    ::lpArgumentString = lpArgumentString;
    ::fKD = 1;

    //Windbg does not pass this, it uses WinDbgExtensionDllInit
    if (!ExtensionsInitialized)
        {
        if ( OldExtensions )
            {
            memset(&ExtensionApis, 0, sizeof(ExtensionApis));
            if ( sizeof(WINDBG_OLD_EXTENSION_APIS) == lpExtensionsApis->nSize )
                {
                memcpy(&ExtensionApis, lpExtensionsApis, lpExtensionsApis->nSize);
                ExtensionApis.lpReadProcessMemoryRoutine = ReadProcessMemoryThunk;
                ExtensionApis.lpWriteProcessMemoryRoutine = (PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE)WriteProcessMemoryThunk;
                }
            else if ( lpExtensionsApis->nSize >= sizeof(WINDBG_EXTENSION_APIS) )
                {
                memcpy(&ExtensionApis, lpExtensionsApis, sizeof(WINDBG_EXTENSION_APIS));
                }
            }
        else
           memcpy(&ExtensionApis, lpExtensionsApis, sizeof(WINDBG_EXTENSION_APIS));
        }


    ::Myprintf = ExtensionApis.lpOutputRoutine;


    ExtensionWrapRoutine(ExtensionRoutine);

    }


#define DECLARE_EXTAPI_STUB(apiname)                \
                                                    \
VOID                                                \
do##apiname(VOID);                                  \
                                                    \
extern "C"                                          \
VOID                                                \
apiname(IN HANDLE hCurrentProcess,                  \
        IN HANDLE hCurrentThread,                   \
        IN DWORD_PTR dwCurrentPc,                   \
        IN PWINDBG_EXTENSION_APIS lpExtensionApis,  \
        IN LPSTR lpArgumentString                   \
        )                                           \
{                                                   \
   InitExtensionApi(hCurrentProcess,                \
                    hCurrentThread,                 \
                    dwCurrentPc,                    \
                    lpExtensionApis,                \
                    lpArgumentString,               \
                    do##apiname);                   \
}                                                   \

#define DECLARE_EXTAPI(apiname)                     \
VOID                                                \
do##apiname(VOID)                                   \

// EXTENSION SETTINGS AND HELP
DECLARE_EXTAPI_STUB(help)
DECLARE_EXTAPI_STUB(version)
DECLARE_EXTAPI_STUB(settings)

// COMMON STRUCTURE PRINTERS
DECLARE_EXTAPI_STUB(cltinterface)
DECLARE_EXTAPI_STUB(rpcversion)
DECLARE_EXTAPI_STUB(syntaxid)
DECLARE_EXTAPI_STUB(srvinterface)
DECLARE_EXTAPI_STUB(stubdesc)
DECLARE_EXTAPI_STUB(stubmsg)

// FORMAT STRING PRINTERS
DECLARE_EXTAPI_STUB(procheader)
DECLARE_EXTAPI_STUB(procparamlist)
DECLARE_EXTAPI_STUB(proc)
DECLARE_EXTAPI_STUB(type)
DECLARE_EXTAPI_STUB(proxy)
DECLARE_EXTAPI_STUB(stub)
DECLARE_EXTAPI_STUB(proxyproc)
DECLARE_EXTAPI_STUB(stubproc)

// BUFFER PRINTERS
DECLARE_EXTAPI_STUB(procbuffer)
DECLARE_EXTAPI_STUB(typebuffer)
DECLARE_EXTAPI_STUB(pickleheader)

// MISC
DECLARE_EXTAPI_STUB(basicinfo)

// MISC TEST CODE
DECLARE_EXTAPI_STUB(testctrlc)

typedef VOID (*PSIMPLE_EXTAPI_ONE_NUMPARAM)(UINT64);
typedef VOID (*PPRINT_USAGE_ROUTINE)(VOID);

VOID ProcessSimpleExtapiOneNumParam(PSIMPLE_EXTAPI_ONE_NUMPARAM pDoRoutine,
                                    PPRINT_USAGE_ROUTINE pHelpRoutine)
    {
    size_t size = ExtensionArgs.size();
    if (size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0) {
       (*pHelpRoutine)();
       return;
    }
    if (size != 1) {
       dout << "Incorrect syntax.\n";
       (*pHelpRoutine)();
       return;
    }
    UINT64 NumberParam = GetExpression(ExtensionArgs.at(0).c_str());
    (*pDoRoutine)(NumberParam);
    }

#define DECLARE_SIMPLE_EXAPI_ONE_NUMPARAM_STUB(apiname,helproutine)    \
VOID do2##apiname(UINT64 Parameter);                                   \
VOID                                                                   \
do##apiname(VOID)                                                      \
{                                                                      \
    ProcessSimpleExtapiOneNumParam(do2##apiname,helproutine);          \
}                                                                      \
VOID                                                                   \
do2##apiname(UINT64 Parameter)                                         \

VOID ParseBasicInfo(BASIC_INFO *BasicInfo)
   {
   if (_strcmpi(ExtensionArgs.at(0).c_str(), "stubmsg") == 0)
       {
       UINT64 StubMessageAddress = GetExpression(ExtensionArgs.at(1).c_str());
       dout << "Detecting settings using MIDL_STUB_MESSAGE at " << HexOut(StubMessageAddress) << ".\n";
       BasicInfo->GetInfoFromStubMessage(StubMessageAddress);
       }
   else if (_strcmpi(ExtensionArgs.at(0).c_str(), "rpcmsg") == 0)
       {
       UINT64 RpcMessageAddress = GetExpression(ExtensionArgs.at(1).c_str());
       dout << "Detecting settings using RPC_MESSAGE at " << HexOut(RpcMessageAddress) << ".\n";
       BasicInfo->GetInfoFromRpcMessage(RpcMessageAddress);
       }
   else
       {
       ABORT("Structure type must be stubmsg or rpcmsg!\n")
       return;
       }
   }

DECLARE_EXTAPI(help)
    {

    dout <<
    "NDREXTS: NDR DEBUGGER EXTENSIONS.                                             \n"
    "                                                                              \n"
    "EXTENSION SETTINGS AND HELP:                                                  \n"
    "version                                 Version information.                  \n"
    "help                                    This message.                         \n"
    "settings                                Print extension settings.             \n"
    "settings <variable> <value>             Set extension settings.               \n"
    "                                                                              \n"
    "COMMON STRUCTURE PRINTERS:                                                    \n"
    "cltinterface <address>                  RPC_CLIENT_INTERFACE                  \n"
    "rpcversion <address>                    RPC_VERSION                           \n"
    "syntaxid <address>                      RPC_SYNTAX_IDENTIFIER                 \n"
    "srvinterface <address>                  RPC_SERVER_INTERFACE                  \n"
    "stubdesc <address>                      MIDL_STUB_DESC                        \n"
    "stubmsg <address>                       MIDL_STUB_MESSAGE                     \n"
    "                                                                              \n"
    "FORMAT STRING PRINTERS:                                                       \n"
    "proc <procaddr> <typeaddr>              Print the proc format.                \n"
    "proc (rpcmsg|stubmsg) <address>         Print the proc format.                \n"
    "procheader <address>                    Print the proc header.                \n"
    "procheader (rpcmsg|stubmsg) <address>   Print the proc header.                \n"
    "procparam <procaddr> <typeaddr>         Print the param list.                 \n"
    "proxy <ProxyAddr>                       Print OLE proxy information.          \n"
    "proxyproc <ProxyAddr> <ProcNum>         Print specified proxy procedure info. \n"
    "stub <StubAddr>                         Print OLE stub information.           \n"
    "stubproc <StubAddr> <ProcNum>           Print specified stub procedure info.  \n"
    "type <address>                          Print the type string.                \n"
    "                                                                              \n"
    "BUFFER PRINTERS:                                                              \n"
    "pickleheader <address>                  Print type or proc pickling header.   \n"
    "procbuffer <buf> <len> <proca> <typea>  Print the proc marshling buffer.      \n"
    "procbuffer (rpcmsg|stubmsg) <addres>    Print the proc marshling buffer.      \n"
    "typebuffer <buffer> <len> <typea>       Print a single type from buffer.      \n"
    "                                                                              \n"
    "MISC:                                                                         \n"
    "basicinfo (rpcmsg|stubmsg) <address>    Basic debugging info(use first).      \n"
    "Type commandname /? for more information.                                     \n"
    "                                                                              \n"
    ;

    }

DECLARE_EXTAPI(version)
    {
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    if ( !OldExtensions )
        {

        PCHAR BuildKind = SavedMajorVersion == 0x0c ? "Checked" : "Free";

        dout << DebuggerType << " NDR Extension dll for Build " << VER_PRODUCTBUILD
        << " debugging " << BuildKind << " Build " << SavedMinorVersion << '\n';
        }
    else
        {
        dout << DebuggerType << " NDR Extension dll for Build " << VER_PRODUCTBUILD
        << " debugging unknown Build \n";
        }

    }

//
// Settings management
//

void PrintSettingsUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.settings                                                             \n"
    "!ndrexts.settings <variable> <value>                                          \n"
    "                                                                              \n"
    "The first form displays the current settings. The second form sets the given  \n"
    "setting to the given value.                                                   \n"
    "                                                                              \n"
    "First form parameters:                                                        \n"
    "   None.                                                                      \n"
    "                                                                              \n"
    "Second form parameters:                                                       \n"
    "    variable:  The name of the variable to set.                               \n"
    "    value:     Value to set the variable to.                                  \n"
    "                                                                              \n"
    "The following variables are available:                                        \n"
    "   StubMode:  (OS | OI | OIC | OICF | OIF)                                    \n"
    "       Sets the MIDL mode that the stub was generated in.                     \n"
    "   Direction: (IN | OUT)                                                      \n"
    "       Sets the type of parameters in the RPC buffer.                         \n"
    "   Pickling:  (ON | OFF)                                                      \n"
    "       RPC buffer is a pickling buffer.                                       \n"
    "   Robust:    (ON | OFF)                                                      \n"
    "       Long correlation descriptors are used.   This is a default only and    \n"
    "       will be overridden if the extension can detect this.                   \n"
    "                                                                              \n"
    "   Verbosity: (LOW | MEDIUM | HIGH)                                           \n"
    "       Level of detail for output.                                            \n"
    "                                                                              \n";
    }

VOID DisplaySettings()
{

    dout << "Current NDREXTS settings:\n";

    dout << "Verbosity: ";
    switch ( VerbosityLevel )
        {
        case LOW:
            dout << "LOW\n";
            break;
        case MEDIUM:
            dout << "MEDIUM\n";
            break;
        case HIGH:
            dout << "HIGH\n";
            break;
        default:
            ABORT(" Corrupt verbosity level. \n" );
        }

    dout << "StubMode:  ";
    switch ( ContextStubMode )
        {
        case OS:
            dout << "OS\n";
            break;
        case OI:
            dout << "OI\n";
            break;
        case OIC:
            dout << "OIC\n";
            break;
        case OICF:
            dout << "OICF\n";
            break;
        case OIF:
            dout << "OIF\n";
            break;
        default:
            ABORT("Corrupt StubMode\n");
        }

    dout << "Direction: ";
    switch ( ContextDirection )
        {
        case IN_BUFFER_MODE:
            dout << "IN\n";
            break;
        case OUT_BUFFER_MODE:
            dout << "OUT\n";
            break;
        default:
            ABORT("Corrupt direction\n");
        }
    dout << "Pickling:  " << ( ContextPickling ? "ON" : "OFF" ) << '\n';
    dout << "Robust:    " << ( ContextRobust ? "ON" : "OFF" ) << '\n';
    dout << '\n';

}

VOID SetSetting(LPCSTR VariableName, LPCSTR Value )
{
    if ( _strcmpi(VariableName, "Verbosity") == 0 )
        {
        LPCSTR Level = Value;
        if ( _strcmpi( Level, "LOW" ) == 0 )
            {
            VerbosityLevel = LOW;
            }
        else if ( _strcmpi( Level, "MEDIUM" ) == 0 )
            {
            VerbosityLevel = MEDIUM;
            }
        else if ( _strcmpi( Level, "HIGH" ) == 0 )
            {
            VerbosityLevel = HIGH;
            }
        else
            {
            dout << Level << " is an invalid verbosity level.\n";
            PrintSettingsUsage();
            }
        }

    else if ( _strcmpi(VariableName, "StubMode") == 0 )
        {
        LPCSTR Mode = Value;
        if ( _strcmpi(Mode, "OS") == 0 )
            {
            ContextStubMode = OS;
            }
        else if ( _strcmpi(Mode, "OI") == 0 )
            {
            ContextStubMode = OI;
            }
        else if ( _strcmpi(Mode, "OIC") == 0 )
            {
            ContextStubMode = OIC;
            }
        else if ( _strcmpi(Mode, "OICF") == 0 )
            {
            ContextStubMode= OICF;
            }
        else if ( _strcmpi(Mode, "OIF") == 0 )
            {
            ContextStubMode = OIF;
            }
        else
            {
            dout << Mode << " is an invalid StubMode.\n";
            PrintSettingsUsage();
            return;
            }
        }

    else if ( _strcmpi(VariableName, "Direction") == 0 )
        {
        LPCSTR Direction = Value;
        if ( _strcmpi(Direction, "IN") == 0 )
            {
            ContextDirection = IN_BUFFER_MODE;
            }
        else if ( _strcmpi(Direction, "OUT") == 0 )
            {
            ContextDirection = OUT_BUFFER_MODE;
            }
        else
            {
            dout << Direction << " is an invalid direction.\n";
            PrintSettingsUsage();
            return;
            }
        }

    else if ( _strcmpi(VariableName, "Pickling") == 0 )
        {
        LPCSTR PicklingMode = Value;
        if ( _stricmp(PicklingMode,"ON") == 0 )
            {
            ContextPickling = TRUE;
            }
        else if ( _stricmp(PicklingMode,"OFF") == 0 )
           {
           ContextPickling = FALSE;
           }
        else
           {
           dout << PicklingMode << " must be either ON or OFF.\n";
           PrintSettingsUsage();
           }
        }
    else if ( _strcmpi(VariableName, "Robust") == 0 )
        {
        LPCSTR RobustMode = Value;
        if ( _stricmp(RobustMode,"ON") == 0 )
            {
            ContextRobust = TRUE;
            }
        else if ( _stricmp(RobustMode,"OFF") == 0 )
           {
           ContextRobust = FALSE;
           }
        else
           {
           dout << RobustMode << " must be either ON or OFF.\n";
           PrintSettingsUsage();
           }
        }
    else
        {
        dout << VariableName << " is an unknown variable name.\n";
        PrintSettingsUsage();
        return;
        }
}

DECLARE_EXTAPI(settings)
    {
    size_t size = ExtensionArgs.size();
    if ( size == 1 && (_strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0) )
        {
        PrintSettingsUsage();
        }
    else if ( size == 0 )
        {
        DisplaySettings();
        }
    else if ( size == 2 )
        {
        SetSetting( ExtensionArgs.at(0).c_str(), ExtensionArgs.at(1).c_str() );
        }
    else
        {
        dout << "Incorrect number of arguments!\n";
        PrintSettingsUsage();
        }
    }

//
// Basic structure dumpers
//

#define DECLARE_SIMPLE_STRUCT_PRINTER(apiname,structtype)              \
VOID Print##apiname##Usage(VOID)                                       \
    {                                                                  \
    dout <<                                                            \
    "Syntax:                                            \n"            \
    "!ndrexts." #apiname "<address>                     \n"            \
    "                                                   \n"            \
    "Prints a " #structtype " at address.               \n"            \
    "                                                   \n"            \
    "Parameters:                                        \n"            \
    "    Address: address of " #structtype " to print.  \n"            \
    "\n";                                                              \
    }                                                                  \
                                                                       \
VOID                                                                   \
do2##apiname(UINT64 Address)                                           \
{                                                                      \
    dout << "Printing " #structtype " at " << HexOut(Address) << '\n'; \
    structtype structdata;                                             \
    ReadMemory(Address, &structdata);                                  \
    IndentLevel l(dout);                                               \
    Print(dout, structdata, VerbosityLevel);                           \
    dout << '\n';                                                      \
}                                                                      \
                                                                       \
VOID                                                                   \
do##apiname(VOID)                                                      \
{                                                                      \
    ProcessSimpleExtapiOneNumParam(do2##apiname,Print##apiname##Usage);\
}                                                                      \
                                                                       \


DECLARE_SIMPLE_STRUCT_PRINTER(cltinterface,RPC_CLIENT_INTERFACE);
DECLARE_SIMPLE_STRUCT_PRINTER(rpcversion,RPC_VERSION);
DECLARE_SIMPLE_STRUCT_PRINTER(syntaxid,RPC_SYNTAX_IDENTIFIER);
DECLARE_SIMPLE_STRUCT_PRINTER(srvinterface,RPC_SERVER_INTERFACE);
DECLARE_SIMPLE_STRUCT_PRINTER(stubdesc,MIDL_STUB_DESC);
DECLARE_SIMPLE_STRUCT_PRINTER(stubmsg,MIDL_STUB_MESSAGE);

//
// Format string printing
//

void PrintProcHeaderUsage()
    {

    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.procheader <address>                                                 \n"
    "!ndrexts.procheader (rpcmsg|stubmsg) <address>                                \n"
    "                                                                              \n"
    "Prints the format string for the procedure header located at address.         \n"
    "The first form requires the address of the format string on the command line. \n"
    "The second format requires the address of the stubmsg or rpcmsg and an        \n"
    "attempt is made to automatically detect the procedure header.                 \n"
    "                                                                              \n"
    "First form parameters:                                                        \n"
    "    address: Address of the procedure header.                                 \n"
    "                                                                              \n"
    "Second form parameters:                                                       \n"
    "    (rpcmsg | stubmsg): Indicates if address is a stubmsg or rpcmsg.          \n"
    "    address: Address of the structure used for detection.                     \n"
    "                                                                              \n"
    "The following setting have an effect on this command:                         \n"
    "                                                                              \n"
    "    StubMode:     MIDL mode used to compile the stub.                         \n"
    "                                                                              \n";
    }

DECLARE_EXTAPI(procheader)
    {
    size_t size = ExtensionArgs.size();
    UINT64 ProcFormat;
    if ( size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0 )
        {
        PrintProcHeaderUsage();
        return;
        }
    else if (size == 2)
        {

        BASIC_INFO BasicInfo;

        try
           {
           ParseBasicInfo(&BasicInfo);
           }
        catch(exception e)
           {
           dout << e.what();
           PrintProcHeaderUsage();
           return;
           }

        if (!BasicInfo.ProcFormatAddressIsAvailable)
            {
            dout << "Unable to detect information!\n";
            return;
            }

        ProcFormat = BasicInfo.ProcFormatAddress;

        }
    else if ( size == 1 )
        {
        ProcFormat = GetExpression(ExtensionArgs.at(0).c_str());
        }
    else
        {
        dout << "Incorrect syntax.\n";
        PrintProcHeaderUsage();
        return;
        }

    dout << "Using proc format string at " << HexOut(ProcFormat) << ":\n";
    FORMAT_PRINTER FormatPrinter(dout);

    FormatPrinter.PrintProcHeader(ProcFormat, ContextStubMode);

    }

void PrintProcParamListUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.procparam <procaddress> <typeaddress>                                \n"
    "                                                                              \n"
    "Prints the parameter list at procaddress.                                     \n"
    "                                                                              \n"
    "Parameters:                                                                   \n"
    "    procaddress: Address of the parameter list.                               \n"
    "    typeaddress: Address of the type format array.                            \n"
    "                                                                              \n"
    "The following setting have an effect on this command:                         \n"
    "                                                                              \n"
    "    StubMode:     MIDL mode used to compile the stub.                         \n"
    "                                                                              \n";

    }

DECLARE_EXTAPI(procparamlist)
    {

    size_t size = ExtensionArgs.size();
    UINT64 ProcFormat, TypeFormat;
    if ( size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0 )
        {
        PrintProcParamListUsage();
        return;
        }

    if (size == 2)
        {
        ProcFormat = GetExpression(ExtensionArgs.at(0).c_str());
        TypeFormat = GetExpression(ExtensionArgs.at(1).c_str());
        }
    else {
        dout << "Incorrect syntax.\n";
        PrintProcParamListUsage();
        return;
        }

    dout << "Using proc format at " << HexOut(ProcFormat) << " and type format at "
    << HexOut(TypeFormat) << ":\n";
    FORMAT_PRINTER FormatPrinter(dout);

    FormatPrinter.PrintProcParamList(ProcFormat, TypeFormat, ContextStubMode);
    }

void PrintProcUsage()
    {

    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.proc <procaddress> <tpeaddress>                                      \n"
    "!ndrexts.proc (rpcmsg|stubmsg) <address>                                      \n"
    "                                                                              \n"
    "Prints the format string for the procedure located at address.                \n"
    "The first form requires the address of the format strings on the command line.\n"
    "The second format requires the address of the stubmsg or rpcmsg and an        \n"
    "attempt is made to automatically detect the proc format string and the type   \n"
    "format array.                                                                 \n"
    "                                                                              \n"
    "First form parameters:                                                        \n"
    "    procaddress: Address of the procedure format string.                      \n"
    "    typeaddress: Address of start of type format string array.                \n"
    "                                                                              \n"
    "Second form parameters:                                                       \n"
    "    (rpcmsg | stubmsg): Indicates if address is a stubmsg or rpcmsg.          \n"
    "    address: Address of the structure used for detection.                     \n"
    "                                                                              \n"
    "The following setting have an effect on this command:                         \n"
    "                                                                              \n"
    "    StubMode:     MIDL mode used to compile the stub.                         \n"
    "                                                                              \n";

    }

DECLARE_EXTAPI(proc)
    {

    size_t size = ExtensionArgs.size();
    UINT64 ProcFormat, TypeFormat;
    if ( size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0 )
        {
        PrintProcUsage();
        return;
        }

    if (size == 2)
        {
        try
           {
           BASIC_INFO BasicInfo;
           ParseBasicInfo(&BasicInfo);

           if (!BasicInfo.ProcFormatAddressIsAvailable || !BasicInfo.StubDescIsAvailable)
               {
               dout << "Unable to detect information!\n";
               return;
               }

           ProcFormat = BasicInfo.ProcFormatAddress;
           TypeFormat = (UINT64)BasicInfo.StubDesc.pFormatTypes;
           }
        catch(...)
           {
            ProcFormat = GetExpression(ExtensionArgs.at(0).c_str());
            TypeFormat = GetExpression(ExtensionArgs.at(1).c_str());
           }
        }
    else {
        dout << "Incorrect syntax.\n";
        PrintProcUsage();
        return;
        }

    dout << "Using proc format at " << HexOut(ProcFormat) << " and type format at "
    << HexOut(TypeFormat) << ":\n";
    FORMAT_PRINTER FormatPrinter(dout);

    FormatPrinter.PrintProc(ProcFormat, TypeFormat, ContextStubMode);

    }

void PrintTypeUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.type <typeaddress>                                                   \n"
    "                                                                              \n"
    "Prints the type format string at typeaddress.                                 \n"
    "                                                                              \n"
    "First form parameters:                                                        \n"
    "    typeaddres: Address of the type format string.                            \n"
    "                                                                              \n"
    "The following setting have an effect on this command:                         \n"
    "                                                                              \n"
    "    Robust:       ON if long correlation descriptors are used.                \n"
    "                                                                              \n";

    }

DECLARE_EXTAPI(type)
    {

    size_t size = ExtensionArgs.size();
    if ( size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0 )
        {
        PrintTypeUsage();
        return;
        }
    if ( size != 1 )
        {
        dout << "Incorrect syntax.\n";
        PrintTypeUsage();
        return;
        }

    UINT64 TypeFormat = GetExpression(ExtensionArgs.at(0).c_str());
    FORMAT_PRINTER FormatPrinter(dout);
    dout << "Using type format string at " << HexOut(TypeFormat) << ":\n";
    FormatPrinter.PrintTypeFormat(TypeFormat, ContextRobust);

    }

//
// Buffer printing
//

void PrintProcBufferUsage()
    {
    dout <<
    "Syntax:                                                                        \n"
    "!ndrexts.procbuffer <buffer> <len> <procaddr> <typeaddr>                       \n"
    "!ndrexts.procbuffer (rpcmsg|stubmsg) address                                   \n"
    "                                                                               \n"
    "Pretty prints a RPC buffer for a procedure call. If the second form is used,   \n"
    "the format strings and buffer settings are detected from the rpcmsg or stubmsg.\n"
    "                                                                               \n"
    "Parameters:                                                                    \n"
    "    buffer: address of the RPC buffer                                          \n"
    "    len: length of the RPC buffer                                              \n"
    "    procaddr: address of the procedure format string.                          \n"
    "    typeaddr: address of the start of type format string table.                \n"
    "                                                                               \n"
    "Second form parameters:                                                        \n"
    "    (rpcmsg | stubmsg): Indicates if address is a stubmsg or rpcmsg.           \n"
    "    address: Address of the structure used for detection.                      \n"
    "                                                                               \n"
    "The following setting have an effect on this command:                          \n"
    "                                                                               \n"
    "    StubMode:     MIDL mode used to compile the stub.                          \n"
    "    Direction:    Determines if the buffer contains IN or OUT parameters.      \n"
    "    Pickling:     ON if buffer is a procedure pickling buffer.                 \n"
    "                                                                               \n";

    }

DECLARE_EXTAPI(procbuffer)
    {
    size_t size = ExtensionArgs.size();
    UINT64 BufferAddress;
    ULONG BufferLength;
    UINT64 ProcAddress;
    UINT64 TypeAddress;

    if ( size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0 )
        {
        PrintProcBufferUsage();
        return;
        }

    if ( size == 2 )
        {

        BASIC_INFO BasicInfo;

        try
           {
           ParseBasicInfo(&BasicInfo);
           }
        catch(exception e)
           {
           dout << e.what();
           PrintProcBufferUsage();
           return;
           }

        if (!BasicInfo.RpcMessageIsAvailable || !BasicInfo.StubDescIsAvailable
            || !BasicInfo.ProcFormatAddressIsAvailable)
            {
            dout << "Unable to get settings.\n\n";
            return;
            }

        BufferAddress = (UINT64)BasicInfo.RpcMessage.Buffer;
        BufferLength = BasicInfo.RpcMessage.BufferLength;
        ProcAddress = BasicInfo.ProcFormatAddress;
        TypeAddress = (UINT64)BasicInfo.StubDesc.pFormatTypes;

        }
    else if (4 == size)
        {
        BufferAddress = GetExpression(ExtensionArgs.at(0).c_str());
        BufferLength = GetExpression(ExtensionArgs.at(1).c_str());
        ProcAddress = GetExpression(ExtensionArgs.at(2).c_str());
        TypeAddress = GetExpression(ExtensionArgs.at(3).c_str());
        }
    else
        {
        dout << "Incorrect syntax.\n";
        PrintProcBufferUsage();
        return;
        }

    BUFFER_PRINTER BufferPrinter( dout, BufferAddress, BufferLength,
                                  ProcAddress, TypeAddress );

    dout << "Printing proc buffer.\n";
    dout << "Buffer address: " << HexOut(BufferAddress) << ".\n";
    dout << "Buffer length: " << HexOut(BufferLength) << ".\n";
    dout << "Procedure format string: " << HexOut(ProcAddress) << ".\n";
    dout << "Type format table: " << HexOut(TypeAddress) << ".\n";
    dout << '\n';

    BufferPrinter.OutputBuffer(ContextStubMode,ContextDirection, ContextPickling);

    }

VOID PrintTypeBufferUsage()
    {
    dout <<
    "Syntax:                                                                        \n"
    "!ndrexts.typebuffer <buffer> <len> <typeaddr>                                  \n"
    "                                                                               \n"
    "Pretty prints a since type from an RPC buffer.                                 \n"
    "                                                                               \n"
    "Parameters:                                                                    \n"
    "    buffer: address of the start of the type in the RPC buffer.                \n"
    "    len: remaining length of the RPC buffer                                    \n"
    "    typeaddr: address of type format string for this type.                     \n"
    "                                                                               \n"
    "                                                                               \n"
    "The following setting have an effect on this command:                          \n"
    "                                                                               \n"
    "    Pickling:     ON if buffer is a type pickling buffer.                      \n"
    "    Robust:       ON if long correlation descriptors are used.                 \n"
    "                                                                               \n";
    }

DECLARE_EXTAPI(typebuffer)
    {

    size_t size = ExtensionArgs.size();

    if ( size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0 )
        {
        PrintProcBufferUsage();
        return;
        }
    if (size == 3)
        {
        UINT64 BufferAddress = GetExpression(ExtensionArgs.at(0).c_str());
        ULONG BufferLength = GetExpression(ExtensionArgs.at(1).c_str());
        UINT64 TypeAddress = GetExpression(ExtensionArgs.at(2).c_str());

        BUFFER_PRINTER BufferPrinter( dout, BufferAddress, BufferLength,
                              TypeAddress, TypeAddress );

        dout << "Printing type buffer.\n";
        dout << "Buffer address: " << HexOut(BufferAddress) << ".\n";
        dout << "Buffer length: " << HexOut(BufferLength) << ".\n";
        dout << "Type format string: " << HexOut(TypeAddress) << ".\n";
        dout << '\n';

        BufferPrinter.OutputTypeBuffer(ContextPickling, ContextRobust);

        }
    else
        {
        dout << "Incorrect syntax!\n";
        PrintTypeBufferUsage();
        return;
        }
    }

VOID PrintPickleHeaderUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.pickleheader <address>                                               \n"
    "                                                                              \n"
    "Prints the pickling header at address. Detects type or proc header.           \n"
    "                                                                              \n"
    "Parameters:                                                                   \n"
    "    Address: Address of the type or procedure pickling header.                \n"
    "                                                                              \n";
    }

DECLARE_SIMPLE_EXAPI_ONE_NUMPARAM_STUB(pickleheader,PrintPickleHeaderUsage)
    {
    UINT64 Address = Parameter;

    TYPE_PICKLING_HEADER TypeHeader;
    PROC_PICKLING_HEADER ProcHeader;

    ReadMemory(Address, &TypeHeader);

    // MS proc headers always have a (short)0xcccc filler where the type header size is.
    // MS type headers always have 8 for the size.
    if ((USHORT)0xCCCC == TypeHeader.HeaderSize)
        {
        dout << "Printing proc pickling header at " << HexOut(Address) << ".\n";
        ReadMemory(Address, &ProcHeader);
        IndentLevel l(dout);
        Print(dout, ProcHeader, VerbosityLevel);
        return;
        }

    if (sizeof(TypeHeader) == TypeHeader.HeaderSize)
        {
        dout << "Printing type pickling header at " << HexOut(Address) << ".\n";
        }
    else
        {
        dout << "Unsure what type of header this is.  Printing as a type header.\n";
        dout << "Address: " << HexOut(Address) << ".\n";
        }

    IndentLevel l(dout);
    Print(dout, TypeHeader, VerbosityLevel);
    dout << '\n';
    }

void PrintProxyUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.proxy <address>                                                      \n"
    "                                                                              \n"
    "Prints information about DCOM proxy located at address.                       \n"
    "                                                                              \n"
    "Parameters:                                                                   \n"
    "   Address:  This pointer for the proxy.                                      \n"
    "                                                                              \n";
    }

DECLARE_EXTAPI(proxy)
{
    size_t size = ExtensionArgs.size();
    if (size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0) {
       PrintProxyUsage();
    }
    if (size != 1) {
       Myprintf("Incorrect syntax.\n");
       PrintProxyUsage();
       return;
    }

    ULONG_PTR pAddr = GetExpression(ExtensionArgs.at(0).c_str());

    CNDRPROXY Proxy(pAddr,dout);
    Proxy.InitIfNecessary();
    Proxy.PrintProxy();

}

void PrintStubUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.stub <address>                                                       \n"
    "                                                                              \n"
    "Prints information about DCOM proxy located at address.                       \n"
    "                                                                              \n"
    "Parameters:                                                                   \n"
    "   Address:  Address of the stub.                                             \n"
    "                                                                              \n";
    }

DECLARE_EXTAPI(stub)
{
    size_t size = ExtensionArgs.size();
    if (size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0) {
       PrintStubUsage();
    }
    if (size != 1) {
       Myprintf("Incorrect syntax.\n");
       PrintStubUsage();
    }

    ULONG_PTR pAddr = GetExpression(ExtensionArgs.at(0).c_str());
    CNDRSTUB Stub(pAddr, dout);
    Stub.PrintStub();

}

void PrintProxyProcUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.proxyproc <address> <ProcNum>                                        \n"
    "                                                                              \n"
    "Prints the format string for the proc in the proxy.                           \n"
    "                                                                              \n"
    "Parameters:                                                                   \n"
    "   Address: Address of proxy.                                                 \n"
    "   ProcNum:  Proc number to dump information for.                             \n"
    "                                                                              \n";
    }

DECLARE_EXTAPI(proxyproc)
{
    size_t size = ExtensionArgs.size();
    if (size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0) {
       PrintProxyProcUsage();
    }
    if (size != 2) {
       dout << "Incorrect syntax.\n";
       PrintProxyProcUsage();
    }

    ULONG_PTR pAddr = GetExpression(ExtensionArgs.at(0).c_str());
    ULONG_PTR nProcNum = GetExpression(ExtensionArgs.at(1).c_str());

    CNDRPROXY Proxy(pAddr,dout);
    Proxy.PrintProc(nProcNum);

    return;
}

void PrintStubProcUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.stubproc <address> <ProcNum>                                         \n"
    "                                                                              \n"
    "Prints the format string for the stub in the proxy.                           \n"
    "                                                                              \n"
    "Parameters:                                                                   \n"
    "   Address:  Address of stub.                                                 \n"
    "   ProcNum:  Proc number to dump information for.                             \n"
    "                                                                              \n";
    }

DECLARE_EXTAPI(stubproc)
{
    size_t size = ExtensionArgs.size();
    if (size == 1 && _strcmpi(ExtensionArgs.at(0).c_str(), "/?") == 0) {
       PrintStubProcUsage();
    }
    if (size != 2) {
       dout << "Incorrect syntax.\n";
       PrintStubProcUsage();
    }

    ULONG_PTR pAddr = GetExpression(ExtensionArgs.at(0).c_str());
    ULONG_PTR nProcNum = GetExpression(ExtensionArgs.at(1).c_str());

    CNDRSTUB Stub(pAddr,dout);
    Stub.PrintProc(nProcNum);

    return;
}

//
// Misc
//

VOID PrintBasicInfoUsage()
    {
    dout <<
    "Syntax:                                                                       \n"
    "!ndrexts.basicinfo (rpcmsg|stubmsg) <address>                                 \n"
    "                                                                              \n"
    "Prints basic debugging information about the current call.                    \n"
    "Try this first when debugging a problem.                                      \n"
    "                                                                              \n"
    "Parameters:                                                                   \n"
    "    Address: Address of the RPC_MESSAGE or MIDL_STUB_MESSAGE.                 \n"
    "                                                                              \n";
    }

DECLARE_EXTAPI(basicinfo)
    {
    size_t size = ExtensionArgs.size();
    if ((1 == size) && (_strcmpi(ExtensionArgs.at(0).c_str(), "/?")==0) )
        {
        PrintBasicInfoUsage();
        return;
        }
    if ( size != 2 )
        {
        dout << "Wrong number of arguments!\n";
        PrintBasicInfoUsage();
        return;
        }

    BASIC_INFO BasicInfo;
    try
        {
        ParseBasicInfo(&BasicInfo);
        }
    catch(exception e)
        {
        dout << e.what();
        PrintBasicInfoUsage();
        }

    BasicInfo.PrintInfo(dout);
    }

DECLARE_EXTAPI(testctrlc)
    {
    ULONG i = 0;
    while(1)
        {
        dout << "This is my test " << i++ << ".\n";
        }
    }

//
//  C entry points
//


ULONG NoopCheckCtrlC() {
    return 0;
}

void NonNtsdInit()
{
    CHAR szBuffer[10];      // long enough to hold low/medium/high
    DWORD len;

    fKD = 0;
    hCurrentProcess = ProcessHandle = GetCurrentProcess();
    Myprintf = (PWINDBG_OUTPUT_ROUTINE)printf;
    memset(&ExtensionApis,0,sizeof(WINDBG_EXTENSION_APIS) );
    ExtensionApis.nSize = sizeof(WINDBG_EXTENSION_APIS);
    ExtensionApis.lpReadProcessMemoryRoutine = (PWINDBG_READ_PROCESS_MEMORY_ROUTINE)ReadProcessMemoryThunk;
    ExtensionApis.lpOutputRoutine = (PWINDBG_OUTPUT_ROUTINE)printf;
    ExtensionApis.lpCheckControlCRoutine = (PWINDBG_CHECK_CONTROL_C)NoopCheckCtrlC;

    len = GetEnvironmentVariable("NDR_VERBOSE",(LPTSTR)szBuffer,10);
    // invalid value, assuming endium
    if (len == 0 || len > 10 )
    {
        VerbosityLevel = MEDIUM;
    }
    else
    {
        if ( _strcmpi( szBuffer, "LOW" ) == 0 )
            {
            VerbosityLevel = LOW;
            }
        else if ( _strcmpi( szBuffer, "MEDIUM" ) == 0 )
            {
            VerbosityLevel = MEDIUM;
            }
        else if ( _strcmpi( szBuffer, "HIGH" ) == 0 )
            {
            VerbosityLevel = HIGH;
            }

    }
}

class STDOUT_STREAM_BUFFER : public FORMATTED_STREAM_BUFFER
   {
protected:
   virtual void SystemOutput(const char *p);
   virtual BOOL SystemPollCtrlC();
   } StdoutFormattedStream;; // Stream to output to stdout.

void STDOUT_STREAM_BUFFER::SystemOutput(const char *p)
   {
       printf(p);
   }

BOOL STDOUT_STREAM_BUFFER::SystemPollCtrlC()
   {
   return FALSE;
   }

FORMATTED_STREAM_BUFFER & conout = StdoutFormattedStream;

#define BEGIN_C_ENTRY                                 \
    NonNtsdInit();                                    \
    try {                                             \

#define END_C_ENTRY                                   \
    }                                                 \
    catch ( exception & e )                           \
        {                                             \
        conout << '\n';                               \
        conout << "An unexpected error occurred.\n";   \
        conout << e.what() << '\n';                   \
        }                                             \

EXTERN_C void STDAPICALLTYPE
NdrpDumpProxy(
              IN LPVOID pAddr)
{
    BEGIN_C_ENTRY;

    CNDRPROXY Proxy((ULONG_PTR)pAddr,conout);
    Proxy.PrintProxy();

    END_C_ENTRY;

}

EXTERN_C void STDAPICALLTYPE
NdrpDumpProxyProc(
                  IN LPVOID pAddr,
                  IN ULONG_PTR nProcNum)
{

    BEGIN_C_ENTRY;

    CNDRPROXY Proxy((ULONG_PTR)pAddr, conout);
    Proxy.PrintProc(nProcNum);

    END_C_ENTRY;
}


EXTERN_C void STDAPICALLTYPE
NdrpDumpStub(
              IN LPVOID pAddr)
{
    BEGIN_C_ENTRY;
    long nCount = 0;

    CNDRSTUB Stub((ULONG_PTR)pAddr,conout);

    if (HIGHVERBOSE)
        Stub.PrintStub();

    nCount = Stub.GetDispatchCount();
    // I don't care about IUnknown methods. Don't care about IDispatch for now
    for (int i = 3; i < nCount; i++)
        Stub.PrintProc(i);

    END_C_ENTRY;

}

EXTERN_C void STDAPICALLTYPE
NdrpDumpStubProc(
                  IN LPVOID pAddr,
                  IN ULONG_PTR nProcNum)
{

    BEGIN_C_ENTRY;

    CNDRSTUB Stub((ULONG_PTR)pAddr,conout);
    Stub.PrintProc(nProcNum);

    END_C_ENTRY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrexts\ndrexts\orpcexts.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    orpcexts.c

Abstract:

    This file contains ntsd debugger extensions for OPRC part of NDR. 

Author:

    Yong Qu, yongqu@microsoft.com, Aug 10th, 1999

Revision History:

--*/

#define USE_STUBLESS_PROXY
#include <stddef.h>
#include <limits.h>
#define CINTERFACE
#include <ndrole.h>
#include <rpcproxy.h>
#undef CINTERFACE
#include <ndrexts.hxx>
#include <wdbgexts.h>
#include "orpcexts.h"
#include "orpcprt.h"
#include "print.hxx"
EXTERN_C int fKD;
EXTERN_C HANDLE ProcessHandle;

EXTERN_C BOOL 
GetData(IN ULONG_PTR dwAddress,  IN LPVOID ptr, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    if (fKD == 0)
        {
        return ReadProcessMemory(ProcessHandle, (LPVOID) dwAddress, ptr, size, 0);
        }

    while( size > 0 )
        {
        count = MIN( size, 3000 );

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count )
            {
            if (NULL == type)
                {
                type = "unspecified" ;
                }
            return FALSE;
            }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG_PTR)ptr + count);
        }

    return TRUE;
}

CNDRPROXY::CNDRPROXY(ULONG_PTR pAddr, FORMATTED_STREAM_BUFFER &dout):
    CPRINTPROXY(dout),
    _dout(dout),
    _pAddr(pAddr),
    fInit(FALSE) 
{
       
}

HRESULT STDAPICALLTYPE
CNDRPROXY::InitIfNecessary()
{
    HRESULT hr = S_OK;
    BOOL                    Status;
    ULONG_PTR               pTemp;
    ULONG_PTR pAddr = _pAddr;

    if (fInit)
        return S_OK;

        pAddr -= offsetof(CStdProxyBuffer2,pProxyVtbl);

        Status = GetData(pAddr,
                         (void *)&_ProxyBuffer,
                         sizeof(CStdProxyBuffer2),
                         NULL);
    
        if ( ! Status )
            {
            PrintErrorMsg("CstdProxyBuffer: Could not read memory at",(LPVOID)pAddr,GetLastError());
            return GetLastError();
            }


        pTemp = (ULONG_PTR)_ProxyBuffer.pProxyVtbl;
        pTemp -= sizeof(CInterfaceProxyHeader);


        
        Status = GetData(pTemp,(LPVOID)&_ProxyHeader,sizeof(CInterfaceProxyHeader),NULL);
        if ( ! Status )
            {
            PrintErrorMsg("CInterfaceProxyHeader: Could not read memory at",(LPVOID)pTemp,GetLastError());
            return GetLastError();
            }

        
        Status = GetData((ULONG_PTR)_ProxyHeader.piid,(LPVOID)&_riid,sizeof(IID),NULL);
        if ( !Status )
            {
            PrintErrorMsg("CInterfaceProxyHeader->IID Could not read memory at",(LPVOID)_ProxyHeader.piid,GetLastError());
            return GetLastError();
            }


       
        Status = GetData((ULONG_PTR)_ProxyHeader.pStublessProxyInfo,(LPVOID)&_ProxyInfo,sizeof(MIDL_STUBLESS_PROXY_INFO),NULL);
        if ( !Status )
            {
            PrintErrorMsg("ProxyInfo Could not read memory at",(LPVOID)_ProxyHeader.pStublessProxyInfo,GetLastError());
            return GetLastError();
            }

        Status = GetData((ULONG_PTR)_ProxyInfo.pStubDesc,(LPVOID)&_StubDesc,sizeof(MIDL_STUB_DESC), NULL );
        if ( !Status )
            {
            PrintErrorMsg("stub desc Could not read memory at",(LPVOID)_ProxyInfo.pStubDesc,GetLastError());
            return GetLastError();
            }

            

    return S_OK;
}

CNDRSTUB::CNDRSTUB(ULONG_PTR pAddr, FORMATTED_STREAM_BUFFER &dout):
    CPRINTPROXY(dout),
    _dout(dout),
    _pAddr(pAddr),
    fInit(FALSE) 
{
       
}


HRESULT  STDAPICALLTYPE
CNDRSTUB::InitIfNecessary()
{
    if (fInit)
        return S_OK;
    BOOL Status;
    ULONG_PTR               pTemp, pAddr = _pAddr;


        pAddr -= offsetof(CStdStubBuffer2,lpVtbl);
        
        Status = GetData(pAddr,
                         (void *)&_StubBuffer,
                         sizeof(CStdStubBuffer2),
                         NULL);
    
        if ( ! Status )
            {
            PrintErrorMsg("CstdStubBuffer2: Could not read memory at",(LPVOID)pAddr,E_FAIL);
            return E_FAIL;
            }


        pTemp = (ULONG_PTR)_StubBuffer.lpVtbl;
        pTemp -= sizeof(CInterfaceStubHeader);


        
        Status = GetData(pTemp,(LPVOID)&_StubHeader,sizeof(CInterfaceStubHeader),NULL);
        if ( ! Status )
            {
            PrintErrorMsg("CInterfaceStubHeader: Could not read memory at",(LPVOID)pTemp,E_FAIL);
            return E_FAIL;
            }

        
        Status = GetData((ULONG_PTR)_StubHeader.piid,(LPVOID)&_riid,sizeof(IID),NULL);
        if ( !Status )
            {
            PrintErrorMsg("CInterfaceStubHeader->IID Could not read memory at",(LPVOID)_StubHeader.piid,E_FAIL);
            return E_FAIL;
            }



        
        Status = GetData((ULONG_PTR)_StubHeader.pServerInfo,(LPVOID)&_ServerInfo,sizeof(MIDL_SERVER_INFO),NULL);
        if ( !Status )
            {
            PrintErrorMsg("server info Could not read memory at",(LPVOID)_StubHeader.pServerInfo,E_FAIL);
            return E_FAIL;
            }


        Status = GetData((ULONG_PTR)_ServerInfo.pStubDesc,(LPVOID)&_StubDesc,sizeof(MIDL_STUB_DESC), NULL );
        if ( !Status )
            {
            PrintErrorMsg("stub desc Could not read memory at",(LPVOID)_ServerInfo.pStubDesc,E_FAIL);
            return E_FAIL;
            }

        fInit = TRUE;            
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrexts\ndrexts\ndrextsv.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    This file contains version info for RPC NDR debugger extensions.

Author:

    Mike Zoran  (mzoran)     September 3, 1999

Revision History:


--*/

#define  NdrVers  "0.80"


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrexts\ndrexts\orpcexts.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    orpcexts.h

Abstract:

    This file contains ntsd debugger extensions for OPRC part of NDR. 

Author:

    Yong Qu, yongqu@microsoft.com, Aug 10th, 1999

Revision History:

--*/

#ifndef _OPRCEXTS_H_

#define _ORPCEXTS_H_

#ifdef __cplusplus
extern "C" 
{
#endif
void ProcessProxyVtbl(ULONG_PTR);
void ProcessStubVtbl(ULONG_PTR);
BOOL GetData(IN ULONG_PTR dwAddress,  IN LPVOID ptr, IN ULONG size, IN PCSTR type );
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus

#include "print.hxx"

class CPRINTPROXY 
{
private:
    FORMATTED_STREAM_BUFFER &_dout;
public:
    CPRINTPROXY(FORMATTED_STREAM_BUFFER & dout);
    void PrintIID(LPSTR Msg, GUID * IID);
    void PrintPointer(LPSTR Msg, void *pAddr);
    void PrintErrorMsg(LPSTR ErrMsg, void * pAddr, long ErrCode);
    void PrintStubDesc(MIDL_STUB_DESC *pStubDesc);

};

class CNDRPROXY: public CPRINTPROXY
{
private:
    boolean                     fInit;
    ULONG_PTR                   _pAddr;
    CStdProxyBuffer2            _ProxyBuffer;
    CInterfaceProxyHeader       _ProxyHeader;   
    GUID                        _riid;
    MIDL_STUBLESS_PROXY_INFO    _ProxyInfo;
    MIDL_STUB_DESC              _StubDesc;
    FORMATTED_STREAM_BUFFER      &_dout;
    
public:
    CNDRPROXY(ULONG_PTR pAddr, FORMATTED_STREAM_BUFFER &dout); 
    HRESULT STDAPICALLTYPE InitIfNecessary();

    void PrintProxy();
    void PrintProxyBuffer();
    void PrintProxyInfo();
    void PrintProc(ULONG_PTR nProcNum) ;

};

class CNDRSTUB: public CPRINTPROXY
{
private:
    boolean                 fInit;
    ULONG_PTR               _pAddr;
    CStdStubBuffer2         _StubBuffer;
    GUID                    _riid;
    CInterfaceStubHeader    _StubHeader;
    MIDL_SERVER_INFO        _ServerInfo;
    MIDL_STUB_DESC          _StubDesc;
    FORMATTED_STREAM_BUFFER &_dout;
public:
    CNDRSTUB(ULONG_PTR pAddr, FORMATTED_STREAM_BUFFER & dout); 
    HRESULT STDAPICALLTYPE InitIfNecessary();

    void PrintStub();
    void PrintStubBuffer(CStdStubBuffer2 *pStubBuffer);
    void PrintServerInfo(MIDL_SERVER_INFO *pServerInfo);
    void PrintProc(ULONG_PTR nProcNum) ;
    long GetDispatchCount();

};

#endif

#define MIN(x, y) ((x) < (y)) ? x:y

#endif // _ORPCEXTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrexts\ndrexts\orpcprt.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    orpcprt.h

Abstract:

    This file contains ntsd debugger extensions for OPRC part of NDR. 

Author:

    Yong Qu, yongqu@microsoft.com, Aug 10th, 1999

Revision History:

--*/

#ifndef _OPRCPRT_H
#define _OPRCPRT_H

#if defined(__cplusplus)
extern "C" 
{
#endif
 int NdrpDumpProxyBuffer(CStdProxyBuffer2 *pThis);
 int PrintErrorMsg(LPSTR ErrMsg, void * Addr, long ErrCode);
 int NdrpDumpIID(LPSTR Msg,GUID * iid);
 int NdrpDumpProxyInfo(PMIDL_STUBLESS_PROXY_INFO pProxyInfo);
 int NdrpDumpPointer(LPSTR Msg, void * pAddr);
 int NdrpDumpStubBuffer(CStdStubBuffer *pThis);
 int NdrpDumpServerInfo(MIDL_SERVER_INFO *pServerInfo);
#if defined(__cplusplus)
}
#endif

#endif // _OPRCPRT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrexts\ndrexts\orpcprt.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    orpcexts.c

Abstract:

    This file contains ntsd debugger extensions for OPRC part of NDR. 

Author:

    Yong Qu, yongqu@microsoft.com, Aug 10th, 1999

Revision History:

--*/

#define USE_STUBLESS_PROXY
#include "ndrextsp.hxx"
#include <rpcproxy.h>
#include "orpcprt.h"
#include <orpcexts.h>

CPRINTPROXY::CPRINTPROXY(FORMATTED_STREAM_BUFFER & dout) :
    _dout(dout)
{

}

void CPRINTPROXY::PrintErrorMsg(LPSTR ErrMsg, void * Addr, long ErrCode)
{
    _dout << ErrMsg << " " << HexOut(Addr) << " " << ErrCode << "\n";
}

// ugly: can't display unicode string. 
void CPRINTPROXY::PrintIID(LPSTR Msg,GUID * riid)
{
   _dout << Msg << " " << *riid << "\n";
}


void CPRINTPROXY::PrintPointer(LPSTR Msg, void * pAddr)
{
    _dout << Msg << " " << HexOut(pAddr) << "\n";
}


void CPRINTPROXY::PrintStubDesc(MIDL_STUB_DESC *pStubDesc)
{
    
    _dout << "\nStub descriptor\n";
    Print(_dout, *pStubDesc, VerbosityLevel);
}




void CNDRPROXY::PrintProxy()
{

    if (SUCCEEDED( InitIfNecessary() ) )
        {
        PrintProxyBuffer();
        PrintPointer("\naddr. of proxy header: ", (LPVOID) ( (ULONG_PTR)_ProxyBuffer.pProxyVtbl - sizeof(CInterfaceProxyHeader) ) );
        PrintIID("ProxyHeader: IID",&_riid);
        PrintPointer("\naddr. of proxy info ", (LPVOID)_ProxyHeader.pStublessProxyInfo);
        PrintProxyInfo();

        PrintStubDesc(&_StubDesc);
        _dout << '\n';
        }
}


void CNDRPROXY::PrintProxyBuffer()
{
    _dout << "lpVtbl:          " << HexOut(_ProxyBuffer.lpVtbl) << ' ' <<
             "pProxyVtbl:      " << HexOut(_ProxyBuffer.pProxyVtbl) << '\n';
    _dout << "punkOut:         " << HexOut(_ProxyBuffer.punkOuter) << ' ' <<
             "BaseProxy:       " << HexOut(_ProxyBuffer.pBaseProxy) << '\n';
    _dout << "BaseProxyBuf:    " << HexOut(_ProxyBuffer.pBaseProxyBuffer) << ' ' <<
             "CallFactory:     " << HexOut(_ProxyBuffer.pPSFactory) << '\n';
}



void CNDRPROXY::PrintProxyInfo()
{
    _dout << "StubDesc:               " << HexOut(_ProxyInfo.pStubDesc) << '\n';
    _dout << "ProcFormatString:       " << HexOut((LPVOID)_ProxyInfo.ProcFormatString) << '\n';
    _dout << "FormatStringOffset:     " << HexOut((LPVOID)_ProxyInfo.FormatStringOffset) << '\n';
}

void CNDRPROXY::PrintProc(ULONG_PTR nProcNum)
{
    FORMAT_PRINTER FormatPrinter(_dout);
    unsigned short sOffset;

    // We don't care about IUnknow methods. 
    if (nProcNum < 3)
    {
        _dout << "Invalid proc number " << (LONG)nProcNum << '\n';
        return;
    }
    
    if ( SUCCEEDED(InitIfNecessary() ) )
        {
        if (GetData((ULONG_PTR) (_ProxyInfo.FormatStringOffset+ nProcNum ), 
                    (LPVOID)&sOffset,
                    sizeof(short),
                    NULL ) && (sOffset != -1 ))
           FormatPrinter.PrintProc((UINT64)( _ProxyInfo.ProcFormatString + sOffset),
                                (UINT64)_StubDesc.pFormatTypes, OICF);
    
        }

}


// don't print original address in low verbosity
void CNDRSTUB::PrintStub()
{
    if ( SUCCEEDED(InitIfNecessary() ) )
        {
        if (!LOWVERBOSE)
            PrintPointer("CStdStubBuffer2 @ ", (LPVOID)_pAddr);
        PrintStubBuffer(&_StubBuffer);

        if (!LOWVERBOSE)
            PrintPointer("\nstub header: ", (LPVOID)( _StubBuffer.lpVtbl - sizeof(CInterfaceStubHeader) ) );

        if (!LOWVERBOSE)
            PrintPointer("addr. of IID ", (LPVOID)_StubHeader.piid);

        PrintIID("CInterfaceStubHeader: IID",&_riid);

        if (!LOWVERBOSE)
            PrintPointer("addr. of server info ", (LPVOID)_StubHeader.pServerInfo);

        if (!LOWVERBOSE)
            PrintPointer("\nMIDL_SERVER_INFO @", (LPVOID)_StubHeader.pServerInfo );

        PrintServerInfo(&_ServerInfo);
        PrintPointer("dispatch count ",ULongToPtr(_StubHeader.DispatchTableCount));
        PrintPointer("Addr. of dispatch table ", (LPVOID)_StubHeader.pDispatchTable);

        PrintStubDesc(&_StubDesc);
        _dout << '\n';
        }

}

long CNDRSTUB::GetDispatchCount()
{
    if ( SUCCEEDED(InitIfNecessary() ) )
    {
        return _StubHeader.DispatchTableCount;
    }
    else
        return 0;
}


void CNDRSTUB::PrintStubBuffer(CStdStubBuffer2 *pThis)
{
    IID asyncIID;
    _dout << "formatvtbl:      " << HexOut(pThis->lpForwardingVtbl) << ' '
          << "pBaseStubBuffer: " << HexOut(pThis->pBaseStubBuffer) << '\n';
    _dout << "vtbl:            " << HexOut(pThis->lpVtbl) << ' '
          << "RefCount:        " << HexOut(pThis->RefCount) << '\n';
    _dout << "ServerObject:    " << HexOut(pThis->pvServerObject) << ' '
          << "CallFactory:     " << HexOut(pThis->pCallFactoryVtbl) << '\n';
    
    if (NULL == pThis->pAsyncIID)
        {
        PrintPointer("asyncIID", NULL);
        }
    else
        {
        if (! GetData((ULONG_PTR)pThis->pAsyncIID,&asyncIID,sizeof(IID), NULL ) )
            PrintErrorMsg("failed to retrive async IID",(LPVOID)pThis->pAsyncIID,E_FAIL);
        else
            PrintIID("asyncIID",&asyncIID);
        }

    _dout << "PSFactory:       " << HexOut(pThis->pPSFactory) << ' '
          << "RMBVtbl:         " << HexOut(pThis->pRMBVtbl) << '\n';
}


void CNDRSTUB::PrintServerInfo(MIDL_SERVER_INFO *pServerInfo)
{
    _dout << "StubDesc:        " << HexOut(pServerInfo->pStubDesc) << ' '
          << "DispatchTable:   " << HexOut(pServerInfo->DispatchTable) << '\n';
    _dout << "ProcString:      " << HexOut(pServerInfo->ProcString) << ' '
          << "offset table:    " << HexOut(pServerInfo->FmtStringOffset) << '\n';
}


void CNDRSTUB::PrintProc(ULONG_PTR nProcNum)
{
    FORMAT_PRINTER FormatPrinter(_dout);
    unsigned short sOffset;

    // We don't care about IUnknow methods. 
    if (nProcNum < 3)
    {
        Myprintf("Invalid proc number %d\n",nProcNum);
        return;
    }
    if ( SUCCEEDED(InitIfNecessary() ) )
        {
        if (GetData((ULONG_PTR) (_ServerInfo.FmtStringOffset + nProcNum ), 
                    (LPVOID)&sOffset,
                    sizeof(short),
                    NULL ) && (sOffset != -1 ) )  
            FormatPrinter.PrintProc((UINT64)( _ServerInfo.ProcString + sOffset),
                                (UINT64)_StubDesc.pFormatTypes, OICF);
    
        }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrlib\ccontext.cxx ===
/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1991

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

Description :

Provides RPC client side stub context management

History :

stevez  01-15-91        First bits into the bucket.

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <osfpcket.hxx>
#include <context.hxx>

// The NDR format of a context is a (GUID, long) instead of a pointer
// in the server address space due history.  Anyway, we just save this
// cookie, which is sent on the and mapped to and from a pointer
// on the server side.

const ULONG CONTEXT_MAGIC_VALUE = 0xFEDCBA98;

typedef struct _CCONTEXT {

    RPC_BINDING_HANDLE hRPC;    // binding handle assoicated with context

    unsigned long MagicValue;
    WIRE_CONTEXT NDR;

} CCONTEXT, *PCCONTEXT;


RPC_BINDING_HANDLE RPC_ENTRY
NDRCContextBinding (
    IN NDR_CCONTEXT CContext
    )
/*++

Routine Description:

    Given a client context handle, we need to extract the binding from it.
    If an addressing exception occurs, we need to return invalid handle
    rather than GP-fault.

Arguments:

    CContext - Supplies the client context handle.

Return Value:

    The binding handle associated with the supplied client context handle
    will be returned.  If the client context handle is invalid, then we
    raise the RPC_X_SS_CONTEXT_MISMATCH exception.

--*/
{
    __try
        {
        if ( ((CCONTEXT PAPI *) CContext)->MagicValue != CONTEXT_MAGIC_VALUE )
            {
            RpcRaiseException(RPC_X_SS_CONTEXT_MISMATCH);
            }
        }
    _except(    ( GetExceptionCode() == STATUS_ACCESS_VIOLATION )
              || ( GetExceptionCode() == STATUS_DATATYPE_MISALIGNMENT ) )
        {
        RpcRaiseException(RPC_X_SS_CONTEXT_MISMATCH);
        }

    return(((CCONTEXT PAPI *) CContext)->hRPC);
}


RPC_STATUS RPC_ENTRY
RpcSsGetContextBinding (
    IN void *ContextHandle,
    OUT RPC_BINDING_HANDLE PAPI * Binding
    )
{
    RPC_STATUS Status = RPC_S_OK;

    __try
        {
        if ( ((CCONTEXT PAPI *) ContextHandle)->MagicValue != CONTEXT_MAGIC_VALUE )
            {
            Status = RPC_S_INVALID_ARG;
            }
        else
            {
            *Binding = (((CCONTEXT PAPI *) ContextHandle)->hRPC);
            }
        }
    __except(    ( GetExceptionCode() == STATUS_ACCESS_VIOLATION )
              || ( GetExceptionCode() == STATUS_DATATYPE_MISALIGNMENT ) )
        {
        Status = RPC_S_INVALID_ARG;
        }

    return Status;
}



void RPC_ENTRY
NDRCContextMarshall (           // copy a context to a buffer
    IN  NDR_CCONTEXT hCC,           // context to marshell
    OUT void PAPI *pBuff            // buffer to marshell to
    )
    // Copy the interal representation of a context into a buffer
    //-----------------------------------------------------------------------//
{
#define hCContext ((CCONTEXT PAPI *) hCC)  // cast opaque pointer to internal

    THREAD *ThisThread;

    ThisThread = RpcpGetThreadPointer();
    ASSERT(ThisThread);

    ThisThread->SetLastSuccessfullyDestroyedContext(NULL);

    if (!hCContext)
        memset(pBuff, 0, cbNDRContext);
    else
        {

        // Check the magic value to see if this is a legit context
        __try
            {
            if ( ((CCONTEXT PAPI *) hCContext)->MagicValue != CONTEXT_MAGIC_VALUE )
                {
                RpcRaiseException(RPC_X_SS_CONTEXT_MISMATCH);
                }
            }
        __except(    ( GetExceptionCode() == STATUS_ACCESS_VIOLATION )
                  || ( GetExceptionCode() == STATUS_DATATYPE_MISALIGNMENT ) )
            {
            RpcRaiseException(RPC_X_SS_CONTEXT_MISMATCH);
            }

        memcpy(pBuff, &hCContext->NDR, sizeof(hCContext->NDR));
        }

#undef hCContext
}

long 
NDRCCopyContextHandle (
    IN void *SourceBinding,
    OUT void **DestinationBinding
    )

/*++

Routine Description:

    Duplicates a context handle by copying the binding handle and
    the context information.

Arguments:

    SourceBinding - the source handle
    DestinationBinding - the copied handle on success. Undefined on
        failure.

Return Value:

    RPC_S_OK for success. RPC_S_* for errors.

--*/
{
    CCONTEXT *ContextHandle = (CCONTEXT *)SourceBinding;
    CCONTEXT *NewContextHandle;
    RPC_BINDING_HANDLE OldBindingHandle;
    RPC_STATUS Status;

    Status = RpcSsGetContextBinding(ContextHandle, &OldBindingHandle);
    if (Status != RPC_S_OK)
        return Status;

    NewContextHandle = new CCONTEXT;
    if (NewContextHandle == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcpMemoryCopy(NewContextHandle, ContextHandle, sizeof(CCONTEXT));

    Status = RpcBindingCopy(OldBindingHandle, &NewContextHandle->hRPC);

    if (Status != RPC_S_OK)
        {
        delete NewContextHandle;
        return Status;
        }

    *DestinationBinding = NewContextHandle;

    return RPC_S_OK;
}


void
ByteSwapWireContext(
    IN WIRE_CONTEXT PAPI * WireContext,
    IN unsigned long PAPI * DataRepresentation
    )
/*++

Routine Description:

    If necessary, the wire context will be byte swapped in place.

Arguments:

    WireContext - Supplies the wire context be byte swapped and returns the
        resulting byte swapped context.

    DataRepresentation - Supplies the data representation of the supplied wire
        context.

--*/
{
    if ( (*DataRepresentation & NDR_LITTLE_ENDIAN)
                      != NDR_LOCAL_ENDIAN )
        {
        WireContext->ContextType = RpcpByteSwapLong(WireContext->ContextType);
        ByteSwapUuid((class RPC_UUID *)&WireContext->ContextUuid);
        }
}

void RPC_ENTRY
NDRCContextUnmarshall (         // process returned context
    OUT NDR_CCONTEXT PAPI *phCContext,// stub context to update
    IN  RPC_BINDING_HANDLE hRPC,            // binding handle to associate with
    IN  void PAPI *pBuff,           // pointer to NDR wire format
    IN  unsigned long DataRepresentation    // pointer to NDR data rep
    )
    // Update the users context handle from the servers NDR wire format.
    //-----------------------------------------------------------------------//
{
    PCCONTEXT hCC = (PCCONTEXT) *phCContext;
    THREAD *ThisThread;

    ThisThread = RpcpGetThreadPointer();
    ASSERT(ThisThread);

    ThisThread->SetLastSuccessfullyDestroyedContext(NULL);

    ByteSwapWireContext((WIRE_CONTEXT PAPI *) pBuff,
            (unsigned long PAPI *) &DataRepresentation);

    ASSERT( !RpcpCheckHeap() );

    // destory this context if the server returned none

    if (RpcpMemoryCompare(pBuff, &NullContext, cbNDRContext) == 0)
        {
        if (hCC)
            {
            if (hCC->hRPC)
                RpcBindingFree(&(hCC->hRPC));   // discard duplicated binding

            hCC->MagicValue = 0;
            I_RpcFree(hCC);
            }

        *phCContext = Nil;

        ThisThread->SetLastSuccessfullyDestroyedContext(hCC);

        return;
        }

    PCCONTEXT hCCtemp = 0;

    if (! hCC)                  // allocate new if none existed
        {
        hCCtemp = (PCCONTEXT) I_RpcAllocate(sizeof(CCONTEXT));

        if (hCCtemp == 0)
           {
           RpcRaiseException(RPC_S_OUT_OF_MEMORY);
           }

        hCCtemp->MagicValue = CONTEXT_MAGIC_VALUE;
        }
    else if (RpcpMemoryCompare(&hCC->NDR, pBuff, sizeof(hCC->NDR)) == 0)
        {
        // the returned context is the same as the app's context.

        return;
        }


    RPC_BINDING_HANDLE hBindtemp ;

    if( I_RpcBindingCopy(hRPC, &hBindtemp) != RPC_S_OK )
        {
        ASSERT( !RpcpCheckHeap() );
        I_RpcFree( hCCtemp );
        RpcRaiseException(RPC_S_OUT_OF_MEMORY);
        }

    if ( hCCtemp )
        hCC = hCCtemp;
    else
        RpcBindingFree(&(hCC->hRPC));

    memcpy(&hCC->NDR, pBuff, sizeof(hCC->NDR));
    hCC->hRPC = hBindtemp;

    ASSERT( !RpcpCheckHeap() );

    *phCContext = (NDR_CCONTEXT)hCC;
}


void RPC_ENTRY
RpcSsDestroyClientContext (
    IN OUT void PAPI * PAPI * ContextHandle
    )
/*++

Routine Description:

    A client application will use this routine to destroy a context handle
    which it no longer needs.  This will work without having to contact the
    server.

Arguments:

    ContextHandle - Supplies the context handle to be destroyed.  It will
        be set to zero before this routine returns.

Exceptions:

    If the context handle is invalid, then the RPC_X_SS_CONTEXT_MISMATCH
    exception will be raised.

--*/
{
    RPC_BINDING_HANDLE BindingHandle;
    RPC_STATUS RpcStatus;
    THREAD *ThisThread;
    PVOID OldLastSuccessfullyDestroyedContext;

    ThisThread = RpcpGetThreadPointer();
    if (ThisThread)
        {
        OldLastSuccessfullyDestroyedContext = ThisThread->GetLastSuccessfullyDestroyedContext();
        ThisThread->SetLastSuccessfullyDestroyedContext(NULL);

        if (OldLastSuccessfullyDestroyedContext && (*ContextHandle == OldLastSuccessfullyDestroyedContext))
            return;
        }

    BindingHandle = NDRCContextBinding(*ContextHandle);

    RpcStatus = RpcBindingFree(&BindingHandle);

    PCCONTEXT hCC = (PCCONTEXT) *ContextHandle;
    hCC->MagicValue = 0;

    I_RpcFree(*ContextHandle);
    *ContextHandle = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrlib\charconv.cxx ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    charconv.cxx

Abstract:

    Single byte character conversion routines.

Author:

    Donna Liu (DonnaLi) ??-???-19??

Environment:

    This code should execute in all environments supported by RPC
    (DOS, Win 3.X, and Win/NT as well as OS2).

Comments:

    The EBCDIC to ASCII data conversion will not be tested until we
    interoperate with some system which speaks EBCDIC.

Revision history:

    ... (long...)

    Dov Harel   04-24-1992  Added char_array_from_ndr.
    Dov Harel   04-24-1992  Fixed both _from_ndr to do EBCDIC => ASCII
                            conversion.  Changed the ebcdic_to_ascii
                            table to "unsigned char" array type.
    Donna Liu   07-23-1992  Added LowerIndex parameter to
                            <basetype>_array_from_ndr routines
    Dov Harel   08-19-1992  Added RpcpMemoryCopy ([_f]memcpy)
                            to ..._array_from_ndr routines

--*/

#include <string.h>
#include <sysinc.h>
#include <rpc.h>
#include <rpcdcep.h>
#include <rpcndr.h>
#include <ndrlibp.h>

// Note this is the conversion from IBM 1047 EBCDIC codeset to ANSI 1252 code page.
//
// Also please see a comment in endian.c regarding disputable mapping involving
// EBCDIC 0x15->0x0a and 0x25->0x85.
//
unsigned char ebcdic_to_ascii[] =
    {
    0x00, 0x01, 0x02, 0x03, 0x9c, 0x09, 0x86, 0x7f, 
    0x97, 0x8d, 0x8e, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 

    0x10, 0x11, 0x12, 0x13, 0x9d, 0x0a, 0x08, 0x87, 
    0x18, 0x19, 0x92, 0x8f, 0x1c, 0x1d, 0x1e, 0x1f, 

    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x17, 0x1b, 
    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x05, 0x06, 0x07, 

    0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, 
    0x98, 0x99, 0x9a, 0x9b, 0x14, 0x15, 0x9e, 0x1a, 
                                            
    0x20, 0xa0, 0xe2, 0xe4, 0xe0, 0xe1, 0xe3, 0xe5, 
    0xe7, 0xf1, 0xa2, 0x2e, 0x3c, 0x28, 0x2b, 0x7c, 

    0x26, 0xe9, 0xea, 0xeb, 0xe8, 0xed, 0xee, 0xef, 
    0xec, 0xdf, 0x21, 0x24, 0x2a, 0x29, 0x3b, 0x5e, 

    0x2d, 0x2f, 0xc2, 0xc4, 0xc0, 0xc1, 0xc3, 0xc5, 
    0xc7, 0xd1, 0xa6, 0x2c, 0x25, 0x5f, 0x3e, 0x3f, 

    0xf8, 0xc9, 0xca, 0xcb, 0xc8, 0xcd, 0xce, 0xcf, 
    0xcc, 0x60, 0x3a, 0x23, 0x40, 0x27, 0x3d, 0x22, 

    0xd8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
    0x68, 0x69, 0xab, 0xbb, 0xf0, 0xfd, 0xfe, 0xb1, 

    0xb0, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 
    0x71, 0x72, 0xaa, 0xba, 0xe6, 0xb8, 0xc6, 0xa4, 

    0xb5, 0x7e, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 
    0x79, 0x7a, 0xa1, 0xbf, 0xd0, 0x5b, 0xde, 0xae, 

    0xac, 0xa3, 0xa5, 0xb7, 0xa9, 0xa7, 0xb6, 0xbc, 
    0xbd, 0xbe, 0xdd, 0xa8, 0xaf, 0x5d, 0xb4, 0xd7, 

    0x7b, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
    0x48, 0x49, 0xad, 0xf4, 0xf6, 0xf2, 0xf3, 0xf5, 

    0x7d, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 
    0x51, 0x52, 0xb9, 0xfb, 0xfc, 0xf9, 0xfa, 0xff, 

    0x5c, 0xf7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 
    0x59, 0x5a, 0xb2, 0xd4, 0xd6, 0xd2, 0xd3, 0xd5, 

    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
    0x38, 0x39, 0xb3, 0xdb, 0xdc, 0xd9, 0xda, 0x9f  
    
    };

#if !defined(DOS) || defined(WIN)
//
// Due to the DOS NDR1/NDR2 split, this function is now defined for DOS
// in ndr20\dos
//
size_t RPC_ENTRY
MIDL_wchar_strlen (
    IN wchar_t      s[]
    )

{
    size_t i = 0;

    while (s[i] != (wchar_t)0)
        {
        ++i;
        }

    return i;
}
#endif

void RPC_ENTRY
MIDL_wchar_strcpy (
    OUT void *      t,
    IN wchar_t *    s
    )
{
    while ( *(*(wchar_t **)&t)++ = *s++ )
        ;
}

void RPC_ENTRY
char_from_ndr (
    IN OUT PRPC_MESSAGE SourceMessage,
    OUT unsigned char * Target
    )

/*++

Routine Description:

    Unmarshall a single char from an RPC message buffer into
    the target (*Target).  This routine:

    o   Unmarshalls the char (as unsigned char); performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the unmarshalled char.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the char to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the char which was just unmarshalled.

    Target - A pointer to the char to unmarshall the data into.

Return Values:

    None.

--*/

{
    if ( (SourceMessage->DataRepresentation & NDR_CHAR_REP_MASK) ==
          NDR_EBCDIC_CHAR )
        {
        //
        // The sender is an EBCDIC system.  To convert to ASCII:
        // retrieve *(SourceMessage->Buffer) as an unsigned char, and use
        // that value to index into the ebcdic_to_ascii table.
        //

        *Target = ebcdic_to_ascii[*(unsigned char *)SourceMessage->Buffer];
        }
    else
        {
        //
        // The sender is an ASCII system.  To unmarshall, just
        // copy an unsigned character from the buffer to the Target.
        //

        *Target = *(unsigned char *)SourceMessage->Buffer;
        }
    //
    // Advance the buffer pointer before returning
    //

    (*(unsigned char**)&SourceMessage->Buffer)++;
}

//
// end char_from_ndr
//

void RPC_ENTRY
char_array_from_ndr (
    IN OUT PRPC_MESSAGE SourceMessage,
    IN unsigned long    LowerIndex,
    IN unsigned long    UpperIndex,
    OUT unsigned char   Target[]
    )

/*++

Routine Description:

    Unmarshall an array of chars from an RPC message buffer into
    the range Target[LowerIndex] .. Target[UpperIndex-1] of the
    target array of shorts (Target[]).  This routine:

    o   Unmarshalls MemberCount chars; performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the last unmarshalled char.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the first char to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the last char which was just unmarshalled.

    LowerIndex - Lower index into the target array.

    UpperIndex - Upper bound index into the target array.

    Target - An array of chars to unmarshall the data into.

Return Values:

    None.

--*/

{

    register unsigned char * MsgBuffer = (unsigned char *)SourceMessage->Buffer;
    unsigned int Index;
    int byteCount = (int)(UpperIndex - LowerIndex);

    if ( (SourceMessage->DataRepresentation & NDR_CHAR_REP_MASK) ==
          NDR_EBCDIC_CHAR )
        {

        for (Index = (int)LowerIndex; Index < UpperIndex; Index++)
            {

            //
            // The sender is an EBCDIC system.  To convert to ASCII:
            // retrieve *(SourceMessage->Buffer) as an unsigned char, and use
            // that value to Index into the ebcdic_to_ascii table.
            //

            Target[Index] =
                ebcdic_to_ascii[ MsgBuffer[(Index-LowerIndex)] ];

            }
        }
    else
        {

        RpcpMemoryCopy(
            &Target[LowerIndex],
            MsgBuffer,
            byteCount
            );

        /* Replaced by RpcpMemoryCopy:

        for (Index = LowerIndex; Index < UpperIndex; Index++)
            {

            //
            // The sender is an ASCII system.  To unmarshall, just
            // copy an unsigned character from the buffer to the Target.
            //

            Target[Index] = MsgBuffer[(Index-LowerIndex)];
            }
        */

        }
    //
    // Advance the buffer pointer before returning
    //

    *(unsigned char **)&SourceMessage->Buffer += byteCount;
}

//
// end char_array_from_ndr
//

/*

//
// Changed name to ..._bytecount.  Not currently used.
//

int MIDL_wchar_bytecount (
    unsigned char   s[]
    )

{
    int i = 0;

    while (s[2*i] || s[2*i+1]) ++i;

    return i;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrexts\ndrexts\print.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    print.cxx

Abstract:

    This file contains a print wrapper for ndr debug extensions.

Author:

    Mike Zoran (mzoran)     September 3, 1999

Revision History:

--*/


#include <ndrextsp.hxx>

const char INDENT_CHAR = ' ';
const char INDENT_MAX_CHAR = '+';
const ULONG INDENT_LIMIT = 30;
const ULONG INDENT_STEP = 1;
const ULONG NUMBER_COLUMNS = 75;

FORMATTED_STREAM_BUFFER::FORMATTED_STREAM_BUFFER() :
   IndentBuffer(NULL)
   {
   IndentLevel = 0;
   IndentPrinted = FALSE;
   IndentBuffer = new char[INDENT_LIMIT+1];
   memset(IndentBuffer, INDENT_CHAR, INDENT_LIMIT-1);
   IndentBuffer[INDENT_LIMIT-1] = INDENT_MAX_CHAR;
   IndentBuffer[INDENT_LIMIT] = '\0';
   OldIndentChar = INDENT_CHAR;
   OldIndentCharLocation = 0;
   }

FORMATTED_STREAM_BUFFER::~FORMATTED_STREAM_BUFFER()
   {
   if (IndentBuffer)
       {
       delete[] IndentBuffer;
       IndentBuffer = NULL;
       }
   }

FORMATTED_STREAM_BUFFER::_Myt& FORMATTED_STREAM_BUFFER::operator<<(const char * X)
{
    FormatOutput(X);
    return *this;
}


#define DEFINE_PRINT_TYPE_OPERATOR(type)                                            \
FORMATTED_STREAM_BUFFER::_Myt& FORMATTED_STREAM_BUFFER::operator<<(type X)          \
{                                                                                   \
     ostringstream str;                                                             \
     str << X;                                                                      \
     FormatOutput(str.str().c_str());                                               \
     return *this;                                                                  \
}                                                                      

DEFINE_PRINT_TYPE_OPERATOR(char);
DEFINE_PRINT_TYPE_OPERATOR(unsigned char);
DEFINE_PRINT_TYPE_OPERATOR(bool);
DEFINE_PRINT_TYPE_OPERATOR(short);
DEFINE_PRINT_TYPE_OPERATOR(unsigned short);
DEFINE_PRINT_TYPE_OPERATOR(int);
DEFINE_PRINT_TYPE_OPERATOR(unsigned int);
DEFINE_PRINT_TYPE_OPERATOR(long);
DEFINE_PRINT_TYPE_OPERATOR(unsigned long);
DEFINE_PRINT_TYPE_OPERATOR(float);
DEFINE_PRINT_TYPE_OPERATOR(double);
DEFINE_PRINT_TYPE_OPERATOR(long double);
DEFINE_PRINT_TYPE_OPERATOR(void const *);

VOID FORMATTED_STREAM_BUFFER::FormatOutput(const char *p)
    {
        
    char TempBuffer[80];

    PollCtrlC(TRUE);

    const char *p1 = p;
    const char *p2 = p;

    while(1)
        {
        SIZE_T StrSize;

        // This is an empty chunk

        if ( '\0' == *p1 )
            {
            break;
            }

        while( ( ( StrSize = (p2 - p1 + 1 ) ) < 79 ) &&
               ( '\0' != *p2 ) && 
               ( '\n' != *p2 ) ) 
            {
            p2++;
            }

        memcpy( TempBuffer, p1, StrSize );
        TempBuffer[ StrSize ] = '\0';

        if ( IndentLevel && !IndentPrinted )
            {
            SystemOutput(IndentBuffer);
            }
        // Need to print indent next time if ending char is a '\n';
        IndentPrinted = (*p2 != '\n');

        SystemOutput( TempBuffer );

        // This was the last chunk
        if ('\0' == *p2)
            {
            break;
            }

        // Setup for next chunk

        p1 = p2 = ( p2 + 1 );

        }

    }


ULONG FORMATTED_STREAM_BUFFER::SetIndentLevel(ULONG NewIndentLevel)
    {
    ULONG OldIndentLevel = IndentLevel;
    // restore character on top of \0
    IndentBuffer[OldIndentCharLocation] = OldIndentChar;
    IndentLevel = NewIndentLevel;
    // backup char at new \0
    OldIndentCharLocation = min(IndentLevel, INDENT_LIMIT);
    OldIndentChar = IndentBuffer[OldIndentCharLocation];
    // set new terminator
    IndentBuffer[IndentLevel] = '\0';
    return OldIndentLevel;
    }

ULONG FORMATTED_STREAM_BUFFER::GetIndentLevel() const 
    {
    return IndentLevel;
    }

ULONG FORMATTED_STREAM_BUFFER::IncIndentLevel(void)
    {
    return SetIndentLevel(IndentLevel + INDENT_STEP);
    }


ULONG FORMATTED_STREAM_BUFFER::DecIndentLevel(void)
    {
    ULONG NewIndentLevel = (IndentLevel <= INDENT_STEP) ? 0 : (IndentLevel - INDENT_STEP);
    return SetIndentLevel(NewIndentLevel); 
    }

ULONG FORMATTED_STREAM_BUFFER::GetAvailableColumns()
    {
    return NUMBER_COLUMNS - IndentLevel;
    }

BOOL FORMATTED_STREAM_BUFFER::PollCtrlC(BOOL ThrowException) 
{
    BOOL CtrlCPressed = SystemPollCtrlC();
    if (CtrlCPressed)
        {
        ABORT("CTRL-C pressed.\n");
        }
    return CtrlCPressed;
}

IndentLevel::IndentLevel(FORMATTED_STREAM_BUFFER & NewStream) : Stream(NewStream)
    {
    Stream.IncIndentLevel();
    }

IndentLevel::~IndentLevel()
    {
    Stream.DecIndentLevel();
    }

ostream & operator<<(ostream & out, Printable & obj)
    {
    return obj.Print(out);
    }
    
inline char NibbleToHexChar(unsigned char x) 
{
    return ( x >= 0xA ) ? ( 'A' + x - 0xA ) : '0' + x;
}

void HexOut::SetValue(_int64 val, unsigned int Precision)
    {
    if (Precision > 16 || Precision < 1)
        {
        ABORT("Invalid precision of " << Precision << " passed to HexOut.\n" );
        return;
        }

    str << "0x";
    while(Precision--) 
        {
        unsigned int workbyte = val >> (8 * Precision);
        unsigned char uppernibble = ( workbyte >> 4 ) & 0xF;
        unsigned char lowernibble = workbyte & 0xF;
        char upperchar = NibbleToHexChar(uppernibble);
        char lowerchar = NibbleToHexChar(lowernibble);
        str << upperchar << lowerchar;
        }    
    }

HexOut::HexOut(unsigned char x)
    {
    SetValue(x, 1);
    }
    
HexOut::HexOut(char x)
    {
    SetValue(x,1);
    }
    
HexOut::HexOut(unsigned short x)
    {
    SetValue(x, 2);
    }
    
HexOut::HexOut(short x)
    {
    SetValue(x, 2);
    }
    
HexOut::HexOut(unsigned int x)
    {
    SetValue(x, sizeof(x));
    }

HexOut::HexOut(int x)
    {
    SetValue(x, sizeof(x));
    }

HexOut::HexOut(unsigned long x)
    {
    SetValue(x, 4);
    }
    
HexOut::HexOut(long x)
    {
    SetValue(x, 4);
    }
    
HexOut::HexOut(const void *x)
    {
    SetValue((_int64)x, 8);
    }
    
HexOut::HexOut(unsigned _int64 x)
    {
    SetValue(x, 8);
    }

HexOut::HexOut(_int64 x)
    {
    SetValue(x, 8);
    }

HexOut::HexOut(_int64 x, int Precision)
    {
    SetValue(x, Precision);
    }

HexOut::HexOut(double x)
    {
    // For now, output as a int64
    _int64 TempValue = *(_int64 *)&x;
    SetValue(TempValue, 8); 
    }

ostream & HexOut::Print(ostream & out)
    {
    return out << str.str().c_str();
    }

WCHAR_OUT::WCHAR_OUT(WCHAR x) : ansitext(NULL)
{
    WCHAR TempBuffer[2];
    TempBuffer[1] = L'\0';
    TempBuffer[0] = x;
    FillAnsiText(TempBuffer);
}

WCHAR_OUT::WCHAR_OUT(PWCHAR x) : ansitext(NULL)
{
    FillAnsiText(x);
}

WCHAR_OUT::~WCHAR_OUT()
{
    if (ansitext)
        {
        delete[] ansitext;        
        }
}

ostream & WCHAR_OUT::Print(ostream & out) 
{
    return out << ansitext;
}

VOID WCHAR_OUT::FillAnsiText(PWCHAR x)
{
    int ret = WideCharToMultiByte(CP_ACP, 0, x, -1, NULL, 0, NULL, NULL);
    if (0 == ret)
        {
        ABORT("Unable to convert unicode to ansi.\n");
        }
    
    ansitext = new char[ret];
    ret = WideCharToMultiByte(CP_ACP, 0, x, -1, ansitext, ret, NULL, NULL);
    if (0 == ret)
        {
        delete[] ansitext;
        ansitext = NULL;
        ABORT("Unable to convert unicode to ansi.\n");
        }
}

ostream & operator<<(ostream & out, const GUID & Guid)
    {    
    const int GUIDSize = sizeof("{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" + 1);
    WCHAR GUIDBuffer[GUIDSize];
    int ret = StringFromGUID2(Guid, GUIDBuffer, GUIDSize);
    if (0 == ret )
        {
        ABORT("Error printing GUID.\n");
        }
    return out << WCHAR_OUT(GUIDBuffer);
    }

FORMATTED_STREAM_BUFFER & operator<<(FORMATTED_STREAM_BUFFER & out, Printable & obj)
    {
    ostringstream str;
    str << obj;
    out << str.str().c_str();
    return out;
    }

FORMATTED_STREAM_BUFFER & operator<<(FORMATTED_STREAM_BUFFER & out, const GUID & Guid)
    {
    ostringstream str;
    str << Guid;
    out << str.str().c_str();
    return out;
    }

//
//  Basic RPC structure printers(FORMATTED_STREAM_BUFFER version only)
//

VOID Print(FORMATTED_STREAM_BUFFER &out, RPC_VERSION & Version, NDREXTS_VERBOSITY VerbosityLevel)
{
    out << "MajorVersion: " << HexOut(Version.MajorVersion) << "    ";
    out << "MinorVersion: " << HexOut(Version.MinorVersion) << '\n';
}

VOID Print(FORMATTED_STREAM_BUFFER &out, RPC_SYNTAX_IDENTIFIER & Syntax, NDREXTS_VERBOSITY VerbosityLevel)
{
    out << "GUID:          " << Syntax.SyntaxGUID << '\n';
    out << "SyntaxVersion: " << '\n';
    IndentLevel l(out);
        Print(out, Syntax.SyntaxVersion, VerbosityLevel);
}

VOID Print(FORMATTED_STREAM_BUFFER & out, RPC_SERVER_INTERFACE & SrvInterface, NDREXTS_VERBOSITY VerbosityLevel) 
{
    out << "Length:                  " << HexOut(SrvInterface.Length) << '\n';
    out << "InterfaceId:             \n";
    {
       IndentLevel l(out);
       Print(out, SrvInterface.InterfaceId, VerbosityLevel);
    }
    out << "TransferSyntax:          \n"; 
    {
       IndentLevel l(out);
       Print(out, SrvInterface.TransferSyntax, VerbosityLevel);
    }
    out << "DispatchTable:           " << HexOut(SrvInterface.DispatchTable) << '\n';    
    out << "RpcProtseqEndpointCount: " << HexOut(SrvInterface.RpcProtseqEndpointCount) << '\n';
    out << "DefaultManagerEpv:       " << HexOut(SrvInterface.RpcProtseqEndpoint) << '\n';    
    out << "Flags:                   " << HexOut(SrvInterface.Flags) << '\n';    
    out << "InterpreterInfo:         " << HexOut(SrvInterface.DefaultManagerEpv) << '\n';
}

VOID Print(FORMATTED_STREAM_BUFFER & out, RPC_CLIENT_INTERFACE & CltInterface, NDREXTS_VERBOSITY VerbosityLevel) 
{
    out << "Length:                  \n" << HexOut(CltInterface.Length);
    out << "InterfaceId:             \n";
    {
       IndentLevel l(out);
       Print(out, CltInterface.InterfaceId, VerbosityLevel);
    }
    out << "TransferSyntax:          \n"; 
    {
       IndentLevel l(out);
       Print(out, CltInterface.TransferSyntax, VerbosityLevel);
    }
    out << "DispatchTable:           " << HexOut(CltInterface.DispatchTable) << '\n';
    out << "RpcProtseqEndpointCount: " << HexOut(CltInterface.RpcProtseqEndpointCount) << '\n';
    out << "RpcProtseqEndpoint:      " << HexOut(CltInterface.RpcProtseqEndpoint) << '\n';

    out << "InterpreterInfo:         " << HexOut(CltInterface.InterpreterInfo) << '\n';
    out << "Flags:                   " << HexOut(CltInterface.Flags) << '\n';
}

VOID Print(FORMATTED_STREAM_BUFFER & out, MIDL_STUB_DESC & StubDesc, NDREXTS_VERBOSITY VerbosityLevel)
{

    out << "RpcInterfaceInformation:     " << HexOut(StubDesc.RpcInterfaceInformation) << '\n';    
    out << "pfnAllocate:                 " << HexOut(StubDesc.pfnAllocate) << '\n';
    out << "pfnFree:                     " << HexOut(StubDesc.pfnFree) << '\n';
    //out << "IMPLICIT_HANDLE_INFO:        " << HexOut(StubDesc.pAutoHandle) << '\n';
    
    out << "apfnNdrRundownRoutines:      " << HexOut(StubDesc.apfnNdrRundownRoutines) << '\n';
    out << "aGenericBindingRoutinePairs: " << HexOut(StubDesc.aGenericBindingRoutinePairs) << '\n';
    out << "apfnExprEval:                " << HexOut(StubDesc.apfnExprEval) << '\n';
    out << "aXmitQuintuple:              " << HexOut(StubDesc.aXmitQuintuple) << '\n';    
    out << "pFormatTypes:                " << HexOut(StubDesc.pFormatTypes) << '\n';
    out << "fCheckBounds:                " << (StubDesc.fCheckBounds ? "YES " : "NO  ") << '\n';
    out << "Version(NDR):                " << ((StubDesc.Version >> 16) & 0xFFFF) << '.'
                                           << (StubDesc.Version && 0xFFFF) << '\n';
    out << "MIDLVersion:                 " << ((StubDesc.MIDLVersion >> 24) & 0xFF) << '.' 
                                           << ((StubDesc.MIDLVersion >> 16) & 0xFF) << '.'
                                           << (StubDesc.MIDLVersion && 0xFFFF) << '\n';   
    out << "pMallocFreeStruct:           " << HexOut(StubDesc.pMallocFreeStruct) << '\n';    
    out << "CommFaultOffsets:            " << HexOut(StubDesc.CommFaultOffsets) << '\n';
    out << "aUserMarshalQuadruple:       " << HexOut(StubDesc.aUserMarshalQuadruple) << '\n';
    out << "NotifyRoutineTable:          " << HexOut(StubDesc.NotifyRoutineTable) << '\n';
    out << "mFlags:                      " << HexOut(StubDesc.mFlags) << '\n';
    
    if (HIGHVERBOSE)
        {
        out << "Reserved5:                   " << HexOut(StubDesc.Reserved5) << '\n';
        }
}

VOID Print(FORMATTED_STREAM_BUFFER & out, MIDL_STUB_MESSAGE & StubMsg, NDREXTS_VERBOSITY VerbosityLevel)
{

    out << "RpcMsg:                 " << HexOut(StubMsg.RpcMsg) << '\n';
    out << "Buffer:                 " << HexOut(StubMsg.Buffer) << '\n';
    out << "BufferStart:            " << HexOut(StubMsg.BufferStart) << '\n';   
    out << "BufferEnd:              " << HexOut(StubMsg.BufferEnd) << '\n';
    out << "BufferMark:             " << HexOut(StubMsg.BufferMark) << '\n';
    out << "BufferLength:           " << HexOut(StubMsg.BufferLength) << '\n';    
    out << "MemorySize:             " << HexOut(StubMsg.MemorySize) << '\n';
    out << "Memory:                 " << HexOut(StubMsg.Memory) << '\n';

    out << "IsClient:           " << (StubMsg.IsClient ? "YES " : "NO  ");
    out << "ReuseBuffer:        " << (StubMsg.ReuseBuffer ? "YES " : "NO ") << '\n';
    
    if (HIGHVERBOSE)
        {
        out << "pAllocAllNodesContext:  " << HexOut(StubMsg.pAllocAllNodesContext) << '\n';
        out << "IgnoreEmbeddedPointers: " << (StubMsg.IgnoreEmbeddedPointers ? " YES " : "NO  ") << '\n';
        out << "fBufferValid:           " << (StubMsg.fBufferValid ? "YES " : "NO  ") << '\n';
        out << "PointerBufferMark:      " << HexOut(StubMsg.PointerBufferMark) << '\n';        
        }

    out << "uFlags:                 " << HexOut(StubMsg.uFlags) << '\n';

    out << "MaxCount: " << HexOut(StubMsg.MaxCount) << "    ";
    out << "Offset:   " << HexOut(StubMsg.Offset) << "    ";
    out << "ActualCount: " << HexOut(StubMsg.ActualCount) << '\n';   
    
    out << "pfnAllocate:            " << HexOut(StubMsg.pfnAllocate) << '\n';
    out << "pfnFree:                " << HexOut(StubMsg.pfnFree) << '\n';
    out << "StackTop:               " << HexOut(StubMsg.StackTop) << '\n';
    
    if (HIGHVERBOSE)
        {
        out << "pPresentedType:         " << HexOut(StubMsg.pPresentedType) << '\n';
        out << "pTransmitType:          " << HexOut(StubMsg.pTransmitType) << '\n';        
        }

    out << "SavedHandle:            " << HexOut(StubMsg.SavedHandle) << '\n';
    out << "StubDesc:               " << HexOut(StubMsg.StubDesc) << '\n';
    
    if (HIGHVERBOSE)
        {
        out << "FullPtrXlatTables:      " << HexOut(StubMsg.FullPtrXlatTables) << '\n';
        out << "FullPtrRefId:           " << HexOut(StubMsg.FullPtrRefId) << '\n';        
        }
    
    out << "fInDontFree:        " << (StubMsg.fInDontFree ? "YES " : "NO  ");
    out << "fDontCallFreeInst:  " << (StubMsg.fDontCallFreeInst ? "YES " : "NO  ") << '\n';

    out << "fInOnlyParam:       " << (StubMsg.fInOnlyParam ? "YES " : "NO  ");
    out << "fHasReturn:         " << (StubMsg.fHasReturn ? "YES " : "NO  ") << '\n';
    
    out << "fHasNewCorrDesc:    " << (StubMsg.fHasNewCorrDesc ? "YES " : "NO  ") << '\n';          
    
    if (HIGHVERBOSE)
        {
        out << "fUnused:                " << HexOut(StubMsg.fUnused) << '\n';        
        }

    if (HIGHVERBOSE)
        {
        out << "dwDestContext:          " << HexOut(StubMsg.dwDestContext) << '\n';
        out << "pvDestContext:          " << HexOut(StubMsg.pvDestContext) << '\n';
        out << "SavedContextHandles:    " << HexOut(StubMsg.SavedContextHandles) << '\n';
        out << "ParamNumber:            " << HexOut(StubMsg.ParamNumber) << '\n';
        out << "pRpcChannelBuffer:      " << HexOut(StubMsg.pRpcChannelBuffer) << '\n';
        out << "pArrayInfo:             " << HexOut(StubMsg.pArrayInfo) << '\n';
        out << "SizePtrCountArray:      " << HexOut(StubMsg.SizePtrCountArray) << '\n';
        out << "SizePtrOffsetArray:     " << HexOut(StubMsg.SizePtrOffsetArray) << '\n';
        out << "SizePtrLengthArray:     " << HexOut(StubMsg.SizePtrLengthArray) << '\n';
        out << "pArgQueue:              " << HexOut(StubMsg.pArgQueue) << '\n';
        }

    out << "dwStubPhase:            " << HexOut(StubMsg.dwStubPhase) << '\n';
    out << "pAsyncMsg:              " << HexOut(StubMsg.pAsyncMsg) << '\n';
    
    if (HIGHVERBOSE)
        {
        out << "pCorrInfo:              " << HexOut(StubMsg.pCorrInfo) << '\n';
        out << "pCorrMemory:            " << HexOut(StubMsg.pCorrMemory) << '\n';
        out << "pMemoryList:            " << HexOut(StubMsg.pMemoryList) << '\n';
//        out << "w2kReserved[0]:         " << HexOut(StubMsg.w2kReserved[0]) << '\n';
//        out << "w2kReserved[1]:         " << HexOut(StubMsg.w2kReserved[1]) << '\n';
//        out << "w2kReserved[2]:         " << HexOut(StubMsg.w2kReserved[2]) << '\n';
//        out << "w2kReserved[3]:         " << HexOut(StubMsg.w2kReserved[3]) << '\n';
//        out << "w2kReserved[4]:         " << HexOut(StubMsg.w2kReserved[4]) << '\n';
        }
}

VOID Print(FORMATTED_STREAM_BUFFER & out, PROC_PICKLING_HEADER & ProcHeader, NDREXTS_VERBOSITY VerbosityLevel)
{
    out << "HeaderVersion:                  " << HexOut(ProcHeader.HeaderVersion) << '\n';
    out << "HeaderDataRepresentation:       " << HexOut(ProcHeader.HeaderDataRepresentation) << '\n';
    out << "Filler1:                        " << HexOut(ProcHeader.Filler1) << '\n';
    out << "Transfer Syntax:                " << '\n';
    {
       IndentLevel l1(out);
       Print(out, ProcHeader.TransferSyntax, VerbosityLevel);
    }
    out << "InterfaceId:                    " << '\n';
    {
       IndentLevel l2(out);
       Print(out, ProcHeader.InterfaceId, VerbosityLevel);
    }
    out << "ProcNum:                        " << HexOut(ProcHeader.ProcNum) << '\n';
    out << "DataByteOrdering:               " << HexOut(ProcHeader.DataByteOrdering) << '\n';
    out << "DataCharRepresentation:         " << HexOut(ProcHeader.DataCharRepresentation) << '\n';
    out << "DataFlatingPointRepresentation: " << HexOut(ProcHeader.DataFloatingPointRepresentation) << '\n';
    out << "Filler2:                        " << HexOut(ProcHeader.BufferSize) << '\n';
}

VOID Print(FORMATTED_STREAM_BUFFER & out, TYPE_PICKLING_HEADER & TypeHeader, NDREXTS_VERBOSITY VerbosityLevel)
{
    out << "HeaderVersion:      " << HexOut(TypeHeader.HeaderVersion) << '\n';
    out << "DataRepresentation: " << HexOut(TypeHeader.DataRepresentation) << '\n';
    out << "HeaderSize:         " << HexOut(TypeHeader.HeaderSize) << '\n';
    out << "Filler:             " << HexOut(TypeHeader.Filler) << '\n';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrlib\floatc.cxx ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    floatc.cxx

Abstract:

    Float and double conversion routines.

Author:

    Dov Harel (DovH) 23-Apr-1992

Environment:

    This code should execute in all environments supported by RPC
    (DOS, Win 3.X, and Win/NT as well as OS2).

Comments:

    This file was completely rewritten to incorporate DCE floating
    point conversion.  Currently the only supported DCE interoperation
    is with DEC system.  The vax conversion routines used
    (cvt_vax_f_to_ieee_single, and cvt_vax_g_to_ieee_double)
    were supplied by Digital, and are used for full compatibility with
    DCE RPC.  (See name.map for Digital files used).

    Also added floating point array conversion routines.

Revision history:

    Donna Liu   07-23-1992  Added LowerIndex parameter to
                            <basetype>_array_from_ndr routines
    Dov Harel   08-19-1992  Added RpcpMemoryCopy ([_f]memcpy)
                            to ..._array_from_ndr routines
    Dov Harel   08-25-1992  Added byte swapping for IEEE big endian
                            machines (such as HP).

--*/

#include <sysinc.h>
#include <rpc.h>
#include <rpcdcep.h>
#include <rpcndr.h>
#include <..\..\ndr20\cvt.h>
#include <ndrlibp.h>

//
// For longs assume the following 32-bit word layout:
//
//  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
// +---------------+---------------+---------------+---------------+
// |      A        |       B       |       C       |       D       |
// +---------------+---------------+---------------+---------------+
//
//
// Masks defined for long byte swapping:
//

#define MASK_AB__        (unsigned long)0XFFFF0000L
#define MASK___CD        (unsigned long)0X0000FFFFL
#define MASK_A_C_        (unsigned long)0XFF00FF00L
#define MASK__B_D        (unsigned long)0X00FF00FFL

//
//  #define NDR_CHAR_REP_MASK               (unsigned long)0X0000000FL
//  #define NDR_INT_REP_MASK                (unsigned long)0X000000F0L
//  #define NDR_FLOAT_REP_MASK              (unsigned long)0X0000FF00L
//
//  #define NDR_LITTLE_ENDIAN               (unsigned long)0X00000010L
//  #define NDR_BIG_ENDIAN                  (unsigned long)0X00000000L
//
//  #define NDR_IEEE_FLOAT                  (unsigned long)0X00000000L
//  #define NDR_VAX_FLOAT                   (unsigned long)0X00000100L
//
//  #define NDR_ASCII_CHAR                  (unsigned long)0X00000000L
//  #define NDR_EBCDIC_CHAR                 (unsigned long)0X00000001L
//
//  #define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000010L
//

#define NDR_FLOAT_INT_MASK                  (unsigned long)0X0000FFF0L

#define NDR_BIG_IEEE_REP                    (unsigned long)0X00000000L
#define NDR_LITTLE_IEEE_REP                 (unsigned long)0X00000010L

void RPC_ENTRY
NdrpLongByteSwap(
    IN void PAPI * Source,
    OUT void PAPI * Target
    )

/*++

Routine Description:

    Assuming both Source and Target point to aligned unsigned longs,
    move the bytes of *Source into *Target in reverse oreder.  The value
    of (*Target) following the call is the bate swapped value of
    (*Source).

Arguments:

    Source - A pointer to an aligned unsigned long.

    Target - A pointer to the long to swap the *Source bytes into.

Return Values:

    None.

--*/

{

    //
    // Swap bytes:
    //
    // First apply the transformation: ABCD => BADC
    //

    *(unsigned long *)Target =
        (*(unsigned long *)Source & MASK_A_C_) >> 8 |
        (*(unsigned long *)Source & MASK__B_D) << 8 ;

    //
    // Now swap the left and right halves of the Target long word
    // achieving full swap: BADC => DCBA
    //

    *(unsigned long *)Target =
        (*(unsigned long *)Target & MASK_AB__) >> 16 |
        (*(unsigned long *)Target & MASK___CD) << 16 ;

}

//
// end NdrpLongByteSwap
//

/*

//
// Relevant definitions from cvt.h (Digital):
//

typedef unsigned char CVT_BYTE;
typedef CVT_BYTE *CVT_BYTE_PTR;

typedef CVT_BYTE CVT_VAX_F[4];
typedef CVT_BYTE CVT_VAX_D[8];
typedef CVT_BYTE CVT_VAX_G[8];

typedef CVT_BYTE CVT_IEEE_SINGLE[4];
typedef CVT_BYTE CVT_IEEE_DOUBLE[8];

//
// Relevant definitions from vaxout.c
// (previous floating point conversion test):
//

CVT_VAX_F inputf;
CVT_IEEE_SINGLE outputf;
CVT_VAX_G inputg;
CVT_IEEE_DOUBLE outputg;

cvt_vax_f_to_ieee_single( inputf, 0, outputf );
cvt_vax_g_to_ieee_double( inputg, 0, outputg );

*/


void RPC_ENTRY
float_from_ndr (
    IN OUT PRPC_MESSAGE SourceMessage,
    OUT void * Target
    )

/*++

Routine Description:

    Unmarshall a float from an RPC message buffer into the target
    (*Target).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 4) boundary.
    o   Unmarshalls the float; performs data conversion if necessary
        (only VAX and IEEE Big Endian conversion currently supported).
    o   Advances the buffer pointer to the address immediately
        following the unmarshalled float.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the float to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the float which was just unmarshalled.

    Target - A pointer to the float to unmarshall the data into.
        A (void*) pointer is used, so that the runtime library code
        is not loaded, unless the application code actually uses
        floating point.

Return Values:

    None.

--*/

{
    unsigned char PAPI * F_Input =
        (unsigned char *)SourceMessage->Buffer;

    unsigned char PAPI * F_Output = (unsigned char PAPI *)Target;
    // CVT_IEEE_SINGLE F_Output = (unsigned char PAPI *)Target;

    unsigned long SenderDataRepresentation;

    //
    // Align F_Input to next (0 mod 4) address
    //

    *(unsigned long *)&F_Input += 3;
    *(unsigned long *)&F_Input &= 0XFFFFFFFCL;

    if ( ( (SenderDataRepresentation = SourceMessage->DataRepresentation) &
           NDR_FLOAT_INT_MASK ) == NDR_LITTLE_IEEE_REP )
        //
        // Robust check for little endian IEEE (local data representation)
        //

        {
        *(unsigned long *)Target = *(unsigned long*)F_Input;
        }

    else if ( (SenderDataRepresentation & NDR_FLOAT_REP_MASK) ==
              NDR_VAX_FLOAT )
        {
        cvt_vax_f_to_ieee_single(F_Input, 0, F_Output);
        }

    else if ( (SenderDataRepresentation & NDR_FLOAT_INT_MASK) ==
              NDR_BIG_IEEE_REP )
        //
        // Big endian IEEE sender:
        //

        {
        NdrpLongByteSwap(F_Input, F_Output);
        }

    else
        {
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

    //
    // Advance the buffer pointer before returning:
    //

    SourceMessage->Buffer = F_Input + 4;
}

//
// end float_from_ndr
//

void RPC_ENTRY
float_array_from_ndr (
    IN OUT PRPC_MESSAGE SourceMessage,
    IN unsigned long    LowerIndex,
    IN unsigned long    UpperIndex,
    OUT void *          Target
    )

/*++

Routine Description:

    Unmarshall an array of floats from an RPC message buffer into
    the range Target[LowerIndex] .. Target[UpperIndex-1] of the
    target array of floats (Target[]).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 4) boundary,
    o   Unmarshalls MemberCount floats; performs data
        conversion if necessary (Currently VAX format only), and
    o   Advances the buffer pointer to the address immediately
        following the last unmarshalled float.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the first float to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the last float which was just unmarshalled.

    LowerIndex - Lower index into the target array.

    UpperIndex - Upper bound index into the target array.

    Target - A pointer to an array of floats to unmarshall the data into.
        A (void*) pointer is used, so that the runtime library code
        is not loaded, unless the application code actually uses
        floating point.

Return Values:

    None.

--*/

{
    unsigned char PAPI * F_Input =
        (unsigned char PAPI *)SourceMessage->Buffer;

    unsigned char PAPI * F_Output = (unsigned char PAPI *)Target;

    register unsigned int Index;
    unsigned long SenderDataRepresentation;

    //
    // Align F_Input to next (0 mod 4) address
    //

    *(unsigned long *)&F_Input += 3;
    *(unsigned long *)&F_Input &= 0XFFFFFFFCL;

    if ( ( (SenderDataRepresentation = SourceMessage->DataRepresentation) &
           NDR_FLOAT_INT_MASK ) == NDR_LITTLE_IEEE_REP )
        //
        // Robust check for little endian IEEE (local data representation)
        //
        {

        int byteCount = 4*(int)(UpperIndex - LowerIndex);

        RpcpMemoryCopy(
            F_Output,
            F_Input,
            byteCount
            );
        //
        // Update SourceMessage->Buffer
        //

        SourceMessage->Buffer = (void PAPI *)(F_Input + byteCount);

        /* Replaced by RpcpMemoryCopy:

        for (Index = LowerIndex; Index < UpperIndex; Index++)
            {
            ((unsigned long *)F_Output)[Index] =
                *(unsigned long *)F_Input;

            F_Input += 4;

            }
        //
        // Advance the buffer pointer before returning:
        //

        SourceMessage->Buffer = F_Input;
        */

        }

    else if ( (SenderDataRepresentation & NDR_FLOAT_REP_MASK) ==
          NDR_VAX_FLOAT )
        {
        F_Output += 4 * LowerIndex;
        for (Index = (int)LowerIndex; Index < UpperIndex; Index++)
            {
            cvt_vax_f_to_ieee_single(F_Input, 0, F_Output);

            F_Input += 4;
            F_Output += 4;
            }
        //
        // Advance the buffer pointer before returning:
        //

        SourceMessage->Buffer = F_Input;
        }

    else if ( (SenderDataRepresentation & NDR_FLOAT_INT_MASK) ==
              NDR_BIG_IEEE_REP )
        //
        // Big endian IEEE sender:
        //

        {
        F_Output += 4 * LowerIndex;
        for (Index = (int)LowerIndex; Index < UpperIndex; Index++)
            {
            NdrpLongByteSwap(F_Input, F_Output);

            F_Input += 4;
            F_Output += 4;
            }
        //
        // Advance the buffer pointer before returning:
        //

        SourceMessage->Buffer = F_Input;
        }

    else
        {
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

}

//
// end float_array_from_ndr
//

void RPC_ENTRY
double_from_ndr (
    IN OUT PRPC_MESSAGE SourceMessage,
    OUT void * Target
    )

/*++

Routine Description:

    Unmarshall a double from an RPC message buffer into the target
    (*Target).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 8) boundary.
    o   Unmarshalls the double; performs data conversion if necessary
        (only VAX conversion currently supported).
    o   Advances the buffer pointer to the address immediately
        following the unmarshalled double.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the double to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the double which was just unmarshalled.

    Target - A pointer to the double to unmarshall the data into.
        A (void*) pointer is used, so that the runtime library code
        is not loaded, unless the application code actually uses
        floating point.

Return Values:

    None.

--*/

{
    unsigned char PAPI * D_Input =
        (unsigned char PAPI *)SourceMessage->Buffer;

    unsigned char PAPI * D_Output = (unsigned char PAPI *)Target;

    unsigned long SenderDataRepresentation;

    //
    // Align D_Input to next (0 mod 8) address
    //

    *(unsigned long *)&D_Input += 7;
    *(unsigned long *)&D_Input &= 0XFFFFFFF8L;

    if ( ( (SenderDataRepresentation = SourceMessage->DataRepresentation) &
           NDR_FLOAT_INT_MASK ) == NDR_LITTLE_IEEE_REP )
        //
        // Robust check for little endian IEEE (local data representation)
        //
        {
        ((unsigned long *)Target)[0] = ((unsigned long*)D_Input)[0];
        ((unsigned long *)Target)[1] = ((unsigned long*)D_Input)[1];
        }

    else if ( (SourceMessage->DataRepresentation & NDR_FLOAT_REP_MASK) ==
          NDR_VAX_FLOAT )
        {
        cvt_vax_g_to_ieee_double(D_Input, 0, D_Output);
        }

    else if ( (SenderDataRepresentation & NDR_FLOAT_INT_MASK) ==
              NDR_BIG_IEEE_REP )
        //
        // Big endian IEEE sender:
        //

        {
        //
        // Swap the low half of D_Input into the high half of D_Output
        //
        NdrpLongByteSwap(
            &((unsigned long*)D_Input)[0],
            &((unsigned long *)Target)[1]
            );

        //
        // Swap the high half of D_Input into the low half of D_Output
        //
        NdrpLongByteSwap(
            &((unsigned long*)D_Input)[1],
            &((unsigned long *)Target)[0]
            );
        }

    else
        {
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

    //
    // Advance the buffer pointer before returning:
    //

    SourceMessage->Buffer = D_Input + 8;
}

//
// end double_from_ndr
//

void RPC_ENTRY
double_array_from_ndr (
    IN OUT PRPC_MESSAGE SourceMessage,
    IN unsigned long    LowerIndex,
    IN unsigned long    UpperIndex,
    OUT void *          Target
    )

/*++

Routine Description:

    Unmarshall an array of doubles from an RPC message buffer into
    the range Target[LowerIndex] .. Target[UpperIndex-1] of the
    target array of (Target[]).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 8) boundary,
    o   Unmarshalls MemberCount doubles; performs data
        conversion if necessary (Currently VAX format only), and
    o   Advances the buffer pointer to the address immediately
        following the last unmarshalled double.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the first double to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the last double which was just unmarshalled.

    LowerIndex - Lower index into the target array.

    UpperIndex - Upper bound index into the target array.

    Target - A pointer to an array of doubles to unmarshall the data into.
        A (void*) pointer is used, so that the runtime library code
        is not loaded, unless the application code actually uses
        floating point.

Return Values:

    None.

--*/

{
    unsigned char PAPI * D_Input =
        (unsigned char PAPI *)SourceMessage->Buffer;

    unsigned char PAPI * D_Output = (unsigned char PAPI *)Target;

    register unsigned int Index;
    unsigned long SenderDataRepresentation;

    //
    // Align D_Input to next (0 mod 8) address
    //

    *(unsigned long *)&D_Input += 7;
    *(unsigned long *)&D_Input &= 0XFFFFFFF8L;

    if ( ( (SenderDataRepresentation = SourceMessage->DataRepresentation) &
           NDR_FLOAT_INT_MASK ) == NDR_LITTLE_IEEE_REP )
        //
        // Robust check for little endian IEEE (local data representation)
        //
        {

        int byteCount = 8*(int)(UpperIndex - LowerIndex);

        RpcpMemoryCopy(
            D_Output,
            D_Input,
            byteCount
            );
        //
        // Update SourceMessage->Buffer
        //

        SourceMessage->Buffer = (void PAPI *)(D_Input + byteCount);

        /* Replaced by RpcpMemoryCopy:

        for (Index = LowerIndex; Index < UpperIndex; Index++)
            {
            ((unsigned long *)D_Output)[(Index * 2)] =
                *(unsigned long *)D_Input;

            D_Input += 4;

            ((unsigned long *)D_Output)[(Index * 2 + 1)] =
                *((unsigned long *)D_Input) ;

            D_Input += 4;
            }
        //
        // Advance the buffer pointer before returning:
        //

        SourceMessage->Buffer = D_Input;
        */

        }

    else if ( (SourceMessage->DataRepresentation & NDR_FLOAT_REP_MASK) ==
          NDR_VAX_FLOAT )
        {
        for (Index = (int)LowerIndex; Index < UpperIndex; Index++)
            {
            cvt_vax_g_to_ieee_double(D_Input, 0, D_Output);

            D_Input += 8;
            D_Output += 8;
            }
        //
        // Advance the buffer pointer before returning:
        //

        SourceMessage->Buffer = D_Input;
        }

    else if ( (SenderDataRepresentation & NDR_FLOAT_INT_MASK) ==
              NDR_BIG_IEEE_REP )
        //
        // Big endian IEEE sender:
        //

        {
        for (Index = (int)LowerIndex; Index < UpperIndex; Index++)
            {
            NdrpLongByteSwap(
                &((unsigned long PAPI *)D_Input)[0],
                &((unsigned long PAPI *)D_Output)[1]
                );

            NdrpLongByteSwap(
                &((unsigned long PAPI *)D_Input)[1],
                &((unsigned long PAPI *)D_Output)[0]
                );

            D_Input += 8;
            D_Output += 8;
            }
        //
        // Advance the buffer pointer before returning:
        //

        SourceMessage->Buffer = D_Input;
        }

    else
        {
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

}

//
// end double_array_from_ndr
//

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrlib\help.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#ifdef WIN32

#include <memory.h>

void
NDRcopy (
    void *pDest,
    void *pSrc,
    int cb
    )
{
    memcpy(pDest, pSrc, cb);
}

#else // WIN32

void * memcpy(void far *, void far *, int);
#pragma intrinsic(memcpy)

void pascal NDRopy(void far *pDest, void far *pSrc, int cb)
{
    memcpy(pDest, pSrc, cb);
}

#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrlib\dataconv.cxx ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    dataconv.cxx

Abstract:

    This file contains routines used by the RPC stubs to assist in marshalling
    and unmarshalling data to and from an RPC message buffer.  Each routine
    receives as a parameter a format string which drives its actions.  The
    valid characters for the format string are :
      c - charater
      b - byte
      w - wide charater or short
      l - long
      f - float
      d - double
      s1, s2, sb - string of chars, wide chars, or bytes
      z - byte string
      )2, )4, )8,
      (2, (4, (8,
      1, 2, 4, 8 - various alignment directives

    For more details consult the Network Computing Architecture documentation
   on Network Data Representation.

Author:

    Donna Liu (donnali) 09-Nov-1990

Revision History:

    26-Feb-1992     donnali

        Moved toward NT coding style.

    09-Jul-1993     DKays

        Made wholesale source level optimizations for speed and size.

--*/

#include <sysinc.h>
#include <rpc.h>
#include <rpcndr.h>
#include <ndrlibp.h>

//
// alignment macros
//

#define  ALIGN(buffer,increment) \
            (((ULONG_PTR)buffer + increment) & ~ increment)

#define  ALIGN2(buffer) \
            (((ULONG_PTR)buffer + 1) & ~1)

#define  ALIGN4(buffer) \
            (((ULONG_PTR)buffer + 3) & ~3)

#define  ALIGN8(buffer) \
            (((ULONG_PTR)buffer + 7) & ~7)

// local routines
static unsigned long NdrStrlenStrcpy ( char *, char * );
static unsigned long NdrWStrlenStrcpy ( wchar_t *, wchar_t * );


void RPC_ENTRY
data_from_ndr (
   PRPC_MESSAGE   source,
   void *         target,
   char *         format,
   unsigned char  MscPak)
/*++

Routine Description:

    This routine copies data from the runtime buffer.

Arguments:

    source - RPC message structure passed from the runtime to the stub.

    target - Buffer to receive the unmarshalled data.

    format - Format of the data.

    MscPak - Packing level.

--*/
{
   unsigned long  valid_lower;
   unsigned long  valid_total;
    register char   *pSource;
    register char   *pTarget;
    unsigned long   pack2, pack4, pack8;
    unsigned long pack, align;

    // pre-compute the possible alignment masks
    if ( MscPak )
        MscPak--;
    pack2 = MscPak & 0x1;
    pack4 = MscPak & 0x3;
    pack8 = MscPak & 0x7;

    pSource = (char *) source->Buffer;

   if ((source->DataRepresentation & (unsigned long)0X0000FFFF) ==
      NDR_LOCAL_DATA_REPRESENTATION)
        {

        pTarget = (char *) target;

      for (;;)
            {
         switch ( *format++ )
                {
            case 'b' :
            case 'c' :
               *((char *)pTarget) = *((char *)pSource);
                    pTarget += 1;
                    pSource += 1;
               break;
            case 'w' :
               pSource = (char *) ALIGN2(pSource);
               pTarget = (char *) ALIGN(pTarget,pack2);

               *((short *)pTarget) = *((short *)pSource);
                    pTarget += 2;
                    pSource += 2;
               break;
            case 'l' :
            case 'f' :
               pSource = (char *) ALIGN4(pSource);
               pTarget = (char *) ALIGN(pTarget,pack4);

               *((long *)pTarget) = *((long *)pSource);
                    pTarget += 4;
                    pSource += 4;
               break;
            case 'h' :
            case 'd' :
               pSource = (char *) ALIGN8(pSource);
               pTarget = (char *) ALIGN(pTarget,pack8);

#if defined(DOS) || defined(WIN)
               *((DWORD *) pTarget) = *((DWORD *) &pSource);
               *(((DWORD *) pTarget) + 1) = *(((DWORD *) &pSource) + 1);
#else
               *((__int64 *)pTarget) = *((__int64 *)pSource);
#endif
                    pTarget += 8;
                    pSource += 8;
               break;
            case 's' :
               pSource = (char *) ALIGN4(pSource);

               valid_lower = *((long *)pSource);
                    pSource += 4;
               valid_total = *((long *)pSource);
                    pSource += 4;

               // double the valid_total if this is a wide char string
               if ( *format++ == '2' )
                        valid_total <<= 1;

               RpcpMemoryCopy(pTarget,
                           pSource,
                           valid_total);
                    pTarget += valid_total;
                    pSource += valid_total;
               break;
            case 'z' :
               pSource = (char *) ALIGN4(pSource);

               valid_total = *((long *)pSource);
                    pSource += 4;

               *((int *)pTarget - 1) = (int) valid_total;

               // double the valid_total if this is a wide char string
               if ( *format++ == '2' )
                        valid_total <<= 1;

               RpcpMemoryCopy(pTarget,
                           pSource,
                           valid_total);
                    pTarget += valid_total;
                    pSource += valid_total;
               break;
            case 'p' :
               pSource = (char *) ALIGN4(pSource);
               pTarget = (char *) ALIGN(pTarget,pack4);

                    pTarget += 4;
                    pSource += 4;
               break;
            case '(' :
               // *format == '2', '4', or '8'; align = 1, 3, or 7
               align = *format - '0' - 1;
               pSource = (char *) ALIGN(pSource,align);
            case ')' :
               switch ( *format++ )
                        {
                  case '8' :
                     pack = pack8;
                     break;
                  case '4' :
                     pack = pack4;
                     break;
                  case '2' :
                     pack = pack2;
                     break;
                  default :
                     continue;
                   }
               pTarget = (char *) ALIGN(pTarget,pack);
               break;
            case '8' :
               pSource = (char *) ALIGN8(pSource);
               break;
            case '4' :
               pSource = (char *) ALIGN4(pSource);
               break;
            case '2' :
               pSource = (char *) ALIGN2(pSource);
               break;
            case '1' :
               break;
            default :
                    source->Buffer = pSource;
               return;
                } // switch
            } // for
        } // if
   else
        {
      for (;;)
            {
         switch ( *format++ )
                {
            case 'b' :
               *((char *)target) = *((char *)source->Buffer);
                    source->Buffer = (void *)((ULONG_PTR)source->Buffer + 1);
                    target = (void *)((ULONG_PTR)target + 1);
               break;
            case 'c' :
               char_from_ndr(source,(unsigned char *)target);
                    target = (void *)((ULONG_PTR)target + 1);
               break;
            case 'w' :
               target = (void *) ALIGN(target,pack2);
               short_from_ndr(source,(unsigned short *)target);
                    target = (void *)((ULONG_PTR)target + 2);
               break;
            case 'l' :
               target = (void *) ALIGN(target,pack4);
               long_from_ndr(source,(unsigned long *)target);
                    target = (void *)((ULONG_PTR)target + 4);
               break;
            case 'f' :
               target = (void *) ALIGN(target,pack4);
               float_from_ndr(source, target);
                    target = (void *)((ULONG_PTR)target + 4);
               break;
            case 'd' :
               target = (void *) ALIGN(target,pack8);
               double_from_ndr(source, target);
                    target = (void *)((ULONG_PTR)target + 8);
               break;
            case 'h' :
               target = (void *) ALIGN(target,pack8);
               hyper_from_ndr(source, (hyper *)target);
                    target = (void *)((ULONG_PTR)target + 8);
               break;
            case 's' :
               long_from_ndr(source, &valid_lower);
               long_from_ndr(source, &valid_total);
               switch ( *format++ )
                  {
                  case '2' :
                     short_array_from_ndr (source,
                                      0,
                                      valid_total,
                                      (unsigned short *)target);
                            valid_total <<= 1;
                     break;
                  case '1' :
                     char_array_from_ndr (source,
                                     0,
                                     valid_total,
                                     (unsigned char *)target);
                     break;
                  case 'b' :
                     byte_array_from_ndr(source,
                                    0,
                                    valid_total,
                                    target);
                     break;
                  default :
                     continue;
                  }
                    target = (void *)((ULONG_PTR)target + valid_total);
               break;
            case 'z' :
               long_from_ndr(source, &valid_total);

               *((int *)target - 1) = (int) valid_total;

               switch ( *format++ )
                  {
                  case '2' :
                     short_array_from_ndr(source,
                                     0,
                                     valid_total,
                                     (unsigned short *)target);
                     valid_total <<= 1;
                     break;
                  case '1' :
                     byte_array_from_ndr(source,
                                    0,
                                    valid_total,
                                    target);
                     break;
                  }
                    target = (void *)((ULONG_PTR)target + valid_total);
               break;
            case 'p' :
               source->Buffer = (void *) ALIGN4(source->Buffer);
               target = (void *) ALIGN(target,pack4);
               source->Buffer = (void *)((ULONG_PTR)source->Buffer + 4);
                    target = (void *)((ULONG_PTR)target + 4);
               break;
            case '(' :
               // *format == '2', '4', or '8'; align = 1, 3, or 7
               align = *format - '0' - 1;
               pSource = (char *) ALIGN(pSource,align);
            case ')' :
               switch (*format++)
                  {
                  case '8' :
                     pack = pack8;
                     break;
                  case '4' :
                     pack = pack4;
                     break;
                  case '2' :
                     pack = pack2;
                     break;
                  default :
                     continue;
                  }
               target = (void *) ALIGN(target,pack);
               break;
            case '8' :
               source->Buffer = (void *)ALIGN8(source->Buffer);
               break;
            case '4' :
               source->Buffer = (void *)ALIGN4(source->Buffer);
               break;
            case '2' :
               source->Buffer = (void *)ALIGN2(source->Buffer);
               break;
                case '1' :
                    break;
            default :
               return;
            } // switch
         } // for
      } // else
}


void RPC_ENTRY
data_into_ndr (
   void *         source,
   PRPC_MESSAGE   target,
   char *         format,
   unsigned char  MscPak)
/*++

Routine Description:

    This routine copies data into the runtime buffer.

Arguments:

    source - Buffer of data to be marshalled into the RPC message.

    target - RPC message structure to be passed to the runtime.

    format - Format of the data.

    MscPak - Packing level.

--*/
{
   unsigned long  valid_total;
    register char   *pSource;
    register char   *pTarget;
    unsigned long   pack2, pack4, pack8;
    unsigned long increment;
    unsigned long pack, align;

    pSource = (char *)source;
    pTarget = (char *)target->Buffer;

    // pre-compute the possible alignment masks
    if ( MscPak )
        MscPak--;
    pack2 = MscPak & 0x1;
    pack4 = MscPak & 0x3;
    pack8 = MscPak & 0x7;

   for (;;)
      {
      switch (*format++)
         {
         case 'b' :
         case 'c' :
            *((char *)pTarget) = *((char *)pSource);
                pTarget += 1;
                pSource += 1;
            break;
         case 'w' :
            pTarget = (char *) ALIGN2(pTarget);
            pSource = (char *) ALIGN(pSource,pack2);

            *((short *)pTarget) = *((short *)pSource);
                pTarget += 2;
                pSource += 2;
            break;
         case 'l' :
         case 'f' :
            pTarget = (char *) ALIGN4(pTarget);
            pSource = (char *) ALIGN(pSource,pack4);

            *((long *)pTarget) = *((long *)pSource);
                pTarget += 4;
                pSource += 4;
            break;
         case 'h' :
         case 'd' :
            pTarget = (char *) ALIGN8(pTarget);
            pSource = (char *) ALIGN(pSource,pack8);

#if defined(DOS) || defined(WIN)
               *((DWORD *) pTarget) = *((DWORD *) &pSource);
               *(((DWORD *) pTarget) + 1) = *(((DWORD *) &pSource) + 1);
#else
               *((__int64 *)pTarget) = *((__int64 *)pSource);
#endif
                pTarget += 8;
                pSource += 8;
            break;
         case 's' :
                pTarget = (char *) ALIGN4(pTarget);

                switch (*format++)
                    {
                    case '2' :
                        valid_total = NdrWStrlenStrcpy((wchar_t *)(pTarget + 8),
                                          (wchar_t *)pSource);
                        increment = valid_total << 1;
                        break;
                    case '1' :
                        valid_total = NdrStrlenStrcpy(pTarget + 8,pSource);
                        increment = valid_total;
                        break;
                    default :
                        continue;
                    }

                *((long *)pTarget) = 0;      // offset
                pTarget += 4;
                *((long *)pTarget) = valid_total;  // count
                pTarget += 4;

                pTarget += increment;
                pSource += increment;
                break;
         case 'z' :
            valid_total = (long) *((int *)pSource - 1);

                pTarget = (char *) ALIGN4(pTarget);

                *((long *)pTarget) = valid_total;
                pTarget += 4;

            if ( *format++ == '2' )
               valid_total <<= 1;

                RpcpMemoryCopy(pTarget,
                        pSource,
                        valid_total);
                pTarget += valid_total;
                pSource += valid_total;
            break;
         case 'p' :
            pTarget = (char *) ALIGN4(pTarget);
            pSource = (char *) ALIGN(pSource,pack4);

                pTarget += 4;
                pSource += 4;
            break;
         case '(' :
            // *format == '2', '4', or '8'; align = 1, 3, or 7
            align = *format - '0' - 1;
            pTarget = (char *) ALIGN(pTarget,align);
         case ')' :
            switch (*format++)
               {
               case '8' :
                  pack = pack8;
                  break;
               case '4' :
                  pack = pack4;
                  break;
               case '2' :
                  pack = pack2;
                  break;
               default :
                  continue;
               }
            pSource = (char *) ALIGN(pSource,pack);
            break;
         case '8' :
            pTarget = (char *) ALIGN8(pTarget);
            break;
         case '4' :
            pTarget = (char *) ALIGN4(pTarget);
            break;
         case '2' :
            pTarget = (char *) ALIGN2(pTarget);
            break;
            case '1' :
                break;
         default :
                target->Buffer = pTarget;
            return;
         } // switch
      } // for
}


void RPC_ENTRY
tree_into_ndr (
   void *         source,
   PRPC_MESSAGE   target,
   char *         format,
   unsigned char  MscPak)
/*++

Routine Description:

    This routine copies data into the runtime buffer.

Arguments:

    source - Buffer of data to be marshalled into the RPC message.

    target - RPC message structure to be passed to the runtime.

    format - Format of the data.

    MscPak - Packing level.

--*/
{
   unsigned long  valid_total;
    register char   *pSource;
    register char   *pTarget;
    unsigned long   pack2, pack4, pack8;
    unsigned long increment;

    pSource = (char *)source;
    pTarget = (char *)target->Buffer;

    // pre-compute the possible alignment masks
    if ( MscPak )
        MscPak--;
    pack2 = MscPak & 0x1;
    pack4 = MscPak & 0x3;
    pack8 = MscPak & 0x7;

   for (;;)
      {
      switch (*format++)
         {
         case 'b' :
         case 'c' :
            pSource += 1;
            break;
         case 'w' :
            pSource = (char *) ALIGN(pSource,pack2);
            pSource += 2;
            break;
         case 'l' :
         case 'f' :
            pSource = (char *) ALIGN(pSource,pack4);
            pSource += 4;
            break;
         case 'h' :
         case 'd' :
            pSource = (char *) ALIGN(pSource,pack8);
            pSource += 8;
            break;
         case 's' :
            pSource = (char *) ALIGN(pSource,pack4);

                if ( ! *(void **)pSource )
                    {
                    pSource += 4;
                    format++;
                    break;
                    }

            pTarget = (char *) ALIGN4(pTarget);

                switch (*format++)
                    {
                    case '2' :
                        valid_total = NdrWStrlenStrcpy((wchar_t *)(pTarget+12),
                                          *(wchar_t **)pSource);
                        increment = valid_total << 1;
                        break;
                    case '1' :
                        valid_total = NdrStrlenStrcpy(pTarget + 12,
                                         *(char **)pSource);
                        increment = valid_total;
                        break;
                    default :
                        continue;
                    }

                *((long *)pTarget) = valid_total;  // max count
                pTarget += 4;
                *((long *)pTarget) = 0;      // offset
                pTarget += 4;
                *((long *)pTarget) = valid_total;  // actual count
                pTarget += 4;

                pSource += 4;
                pTarget += increment;
                break;
         case 'z' :
            pSource = (char *) ALIGN(pSource,pack4);

                if ( ! *(void **)pSource )
                    {
                    pSource += 4;
                    break;
                    }

            valid_total = (long) *(*(int **)pSource - 1);

            pTarget = (char *) ALIGN4(pTarget);

                *((long *)pTarget) = valid_total;  // max count
                pTarget += 4;
                *((long *)pTarget) = valid_total;  // actual count
                pTarget += 4;

            if ( *format++ == '2' )
               valid_total <<= 1;

                RpcpMemoryCopy(pTarget,
                        *(char **)pSource,
                        valid_total);
                pSource += 4;
                pTarget += valid_total;
            break;
         case '(' :
         case ')' :
            switch (*format++)
               {
               case '8' :
                  pSource = (char *) ALIGN(pSource,pack8);
                  break;
               case '4' :
                  pSource = (char *) ALIGN(pSource,pack4);
                  break;
               case '2' :
                  pSource = (char *) ALIGN(pSource,pack2);
                  break;
               default :
                  break;
               }
            break;
         case '8' :
         case '4' :
         case '2' :
         case '1' :
            break;
         default :
                target->Buffer = pTarget;
            return;
         } // switch
      } // for
}


void RPC_ENTRY
data_size_ndr (
   void *         source,
   PRPC_MESSAGE   target,
   char *         format,
   unsigned char  MscPak)
/*++

Routine Description:

    This routine calculates the size of the runtime buffer.

Arguments:

    source - Buffer of data to be marshalled into the RPC message.

    target - RPC message structure to be passed to the runtime.

    format - Format of the data.

    MscPak - Packing level.

--*/
{
   unsigned long         valid_total;
    register char          *pSource;
    register unsigned long targetLength;
    unsigned long        pack2, pack4, pack8;
    unsigned long       pack, align;

    pSource = (char *)source;
    targetLength = target->BufferLength;

    // pre-compute the possible alignment masks
    if ( MscPak )
        MscPak--;
    pack2 = MscPak & 0x1;
    pack4 = MscPak & 0x3;
    pack8 = MscPak & 0x7;

   for (;;)
      {
      switch (*format++)
         {
         case 'b' :
         case 'c' :
            targetLength += 1;
            break;
         case 'w' :
            targetLength = (unsigned long) ALIGN2(targetLength);
            pSource = (char *) ALIGN(pSource,pack2);

            targetLength += 2;
            pSource += 2;
            break;
         case 'l' :
         case 'f' :
            targetLength = (unsigned long) ALIGN4(targetLength);
            pSource = (char *) ALIGN(pSource,pack4);

            targetLength += 4;
            pSource += 4;
            break;
         case 'h' :
         case 'd' :
            targetLength = (unsigned long) ALIGN8(targetLength);
            pSource = (char *) ALIGN(pSource,pack8);

            targetLength += 8;
            pSource += 8;
            break;
         case 's' :
            switch (*format++)
               {
               case '2' :
                  valid_total = MIDL_wchar_strlen((wchar_t *)pSource) + 1;
                        valid_total <<= 1;
                  break;
               case '1' :
                  valid_total = strlen(pSource) + 1;
                  break;
               default :
                  continue;
               }

            targetLength = (unsigned long) ALIGN4(targetLength);

            // add string length plus two longs (for offset and count)
            targetLength += 8 + valid_total;
            break;
         case 'z' :
            targetLength = (unsigned long) ALIGN4(targetLength);

            valid_total = (long) *((int *)pSource - 1);
            if ( *format++ == '2' )
               valid_total <<= 1;

            // add byte string length plus one long (for count)
            targetLength += 4 + valid_total;
            break;
         case 'p' :
            targetLength = (unsigned long) ALIGN4(targetLength);
            pSource = (char *) ALIGN(pSource,pack4);

            target->Buffer = (void *)((ULONG_PTR)target->Buffer + 4);
            pSource += 4;
            break;
         case '(' :
            // *format == '2', '4', or '8'; align = 1, 3, or 7
            align = *format - '0' - 1;
            targetLength = (unsigned long) ALIGN(targetLength,align);
         case ')' :
            switch (*format++)
               {
               case '8' :
                  pack = pack8;
                  break;
               case '4' :
                  pack = pack4;
                  break;
               case '2' :
                  pack = pack2;
                  break;
               default :
                  continue;
               }
            pSource = (char *) ALIGN(pSource,pack);
            break;
         case '8' :
            targetLength = (unsigned long) ALIGN8(targetLength);
            break;
         case '4' :
            targetLength = (unsigned long) ALIGN4(targetLength);
            break;
         case '2' :
            targetLength = (unsigned long) ALIGN2(targetLength);
            break;
         case '1' :
            break;
         default :
                target->BufferLength = targetLength;
            return;
         } // switch
      } // for
}


void RPC_ENTRY
tree_size_ndr (
   void *         source,
   PRPC_MESSAGE   target,
   char *         format,
   unsigned char  MscPak)
/*++

Routine Description:

    This routine calculates the size of the runtime buffer.

Arguments:

    source - Buffer of data to be marshalled into the RPC message.

    target - RPC message structure to be passed to the runtime.

    format - Format of the data.

    MscPak - Packing level.

--*/
{
    unsigned long          valid_total;
    register char          *pSource;
    unsigned long          pack2, pack4, pack8;

    pSource = (char *)source;

    // pre-compute the possible alignment masks
    if ( MscPak )
        MscPak--;
    pack2 = MscPak & 0x1;
    pack4 = MscPak & 0x3;
    pack8 = MscPak & 0x7;

    for (;;)
        {
        switch (*format++)
            {
            case 'b' :
            case 'c' :
                pSource += 1;
                break;
            case 'w' :
            pSource = (char *) ALIGN(pSource,pack2);
                pSource += 2;
                break;
            case 'l' :
            case 'f' :
            pSource = (char *) ALIGN(pSource,pack4);
                pSource += 4;
                break;
         case 'h' :
            case 'd' :
            pSource = (char *) ALIGN(pSource,pack8);
                pSource += 8;
                break;
            case 's' :
            pSource = (char *) ALIGN(pSource,pack4);

                if ( ! *(void __RPC_FAR * __RPC_FAR *)pSource )
                    {
                    pSource += 4;
                    format++;
                    break;
                    }

                switch (*format++)
                    {
                    case '2' :
                        valid_total = MIDL_wchar_strlen(
                                   *(wchar_t __RPC_FAR * __RPC_FAR *)pSource)+1;
                        valid_total <<= 1;
                        break;
                    case '1' :
                        valid_total =
                            strlen (*(char __RPC_FAR * __RPC_FAR *)pSource) + 1;
                        break;
                    default :
                        continue;
                    }

            target->BufferLength = (unsigned int)
                              ALIGN4(target->BufferLength);

            // add string length plus 3 longs (max count, offset, and
            // actual count)
                target->BufferLength += 12 + valid_total;
                pSource += 4;
                break;
         case 'z' :
            pSource = (char *) ALIGN(pSource,pack4);

                if ( ! *(void __RPC_FAR * __RPC_FAR *)pSource )
                    {
                    pSource += 4;
                    break;
                    }

            valid_total = (long) *(*(int **)pSource - 1);
            if ( *format++ == '2' )
               valid_total <<= 1;

            target->BufferLength = (unsigned int)
                              ALIGN4(target->BufferLength);

            // add string length plus 2 longs (max count and actual count)
                target->BufferLength += 8 + valid_total;
                pSource += 4;
            break;
            case '(' :
            case ')' :
                switch (*format++)
                    {
                    case '8' :
                  pSource = (char *) ALIGN(pSource,pack8);
                        break;
                    case '4' :
                  pSource = (char *) ALIGN(pSource,pack4);
                        break;
                    case '2' :
                  pSource = (char *) ALIGN(pSource,pack2);
                        break;
                    default :
                        break;
                    }
                break;
            case '8' :
            case '4' :
            case '2' :
            case '1' :
                break;
            default :
                return;
            }
        }
}


void RPC_ENTRY
tree_peek_ndr (
   PRPC_MESSAGE      source,
   unsigned char **  buffer,
   char *            format,
   unsigned char     MscPak)
/*++

Routine Description:

    This routine peeks the runtime buffer.

Arguments:

    source - RPC message structure passed from the runtime to the stubs.

    target - Buffer to receive the unmarshalled data.

    format - Format of the data.

    MscPak - Packing level.

--*/
{
    unsigned long           valid_total;
    register unsigned char  *pBuffer;
    unsigned long           pack8;
    int                     IsString;

    pBuffer = *buffer;

    // pre-compute the possible alignment masks
    if ( MscPak )
        MscPak--;
    pack8 = MscPak & 0x7;

    IsString = (*format == 's' || *format == 'z');

    for (;;)
        {
        switch (*format++)
            {
            case 'b' :
            case 'c' :
                pBuffer += 1;
                break;
            case 'w' :
            pBuffer = (unsigned char *) ALIGN2(pBuffer);
                pBuffer += 2;
                break;
            case 'l' :
            case 'f' :
            pBuffer = (unsigned char *) ALIGN4(pBuffer);
                pBuffer += 4;
                break;
         case 'h' :
            case 'd' :
            pBuffer = (unsigned char *) ALIGN8(pBuffer);
                pBuffer += 8;
                break;
            case 's' :
                if ( ! IsString )
                    {
               pBuffer = (unsigned char *) ALIGN4(pBuffer);
                    if ( ! *(long *)pBuffer )
                        {
                        pBuffer += 4;
                        format++;
                        break;
                        }
                    pBuffer += 4;
                    long_from_ndr (source, &valid_total);  // max count (ignore)
                    }

                long_from_ndr (source, &valid_total); // offset (ignore)
                long_from_ndr (source, &valid_total); // actual count

            // if it's a wide char string
                if ( *format++ == '2' )
                    {
               // wide char string must be aligned on at least a
               // short boundary
                    if ( ! MscPak )
                        pack8 = 0x1;
                    valid_total <<= 1;
                    }

            source->BufferLength = (unsigned int)
                              ALIGN(source->BufferLength,pack8);

                *((unsigned long *)pBuffer - 1) = source->BufferLength;
                source->BufferLength += valid_total;
                source->Buffer = (void *)((ULONG_PTR)source->Buffer + valid_total);
                break;
         case 'z' :
                if ( ! IsString )
                    {
               pBuffer = (unsigned char *) ALIGN4(pBuffer);
                    if ( ! *(long *)pBuffer )
                        {
                        pBuffer += 4;
                  format++;
                        break;
                        }
                    pBuffer += 4;
                    long_from_ndr (source, &valid_total);  // max count (ignore)
                    }

                long_from_ndr (source, &valid_total); // actual count

            // if it's a wide byte string
                if ( *format++ == '2' )
                    {
               // wide byte string must be aligned on at least a
               // short boundary
                    if ( ! MscPak )
                        pack8 = 0x1;
                    valid_total <<= 1;
                    }

            source->BufferLength = (unsigned int)
                              ALIGN(source->BufferLength,pack8);

                *((unsigned long *)pBuffer - 1) = source->BufferLength;
                source->BufferLength += valid_total;
                source->Buffer = (void *)((ULONG_PTR)source->Buffer + valid_total);
            break;
            case '(' :
                switch (*format++)
                    {
                    case '8' :
                  pBuffer = (unsigned char *) ALIGN8(pBuffer);
                        break;
                    case '4' :
                  pBuffer = (unsigned char *) ALIGN4(pBuffer);
                        break;
                    case '2' :
                  pBuffer = (unsigned char *) ALIGN2(pBuffer);
                        break;
                    default :
                        break;
                    }
                break;
            case ')' :
                format++;
                break;
            case '8' :
            pBuffer = (unsigned char *) ALIGN8(pBuffer);
                break;
            case '4' :
            pBuffer = (unsigned char *) ALIGN4(pBuffer);
                break;
            case '2' :
            pBuffer = (unsigned char *) ALIGN2(pBuffer);
                break;
            case '1' :
                break;
            default :
            *buffer = pBuffer;
                return;
            }
        }
}

static unsigned long NdrStrlenStrcpy ( char *pTarget,
                              char *pSource )
{
    register unsigned int count;

    for ( count = 1; *pTarget++ = *pSource++; count++ )
      ;

   return count;
}

static unsigned long NdrWStrlenStrcpy ( wchar_t *pTarget,
                              wchar_t *pSource )
{
    register unsigned int count;

    for ( count = 1; *pTarget++ = *pSource++; count++ )
      ;

   return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrlib\ndrlibp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ndrlibp.h

Abstract:

    Private header file for ndrlib

Author:

    Mike Zoran (mzoran) 09-Nov-1990

Revision History:

--*/

#if defined(__cplusplus)
extern "C" {
#endif

/****************************************************************************
    Ndr Library helper function prototypes for MIDL 1.0 ndr functions.
 ****************************************************************************/

RPCRTAPI
void
RPC_ENTRY
NDRcopy (
    IN void __RPC_FAR *pTarget,
    IN void __RPC_FAR *pSource,
    IN unsigned int size
    );

RPCRTAPI
size_t
RPC_ENTRY
MIDL_wchar_strlen (
    IN wchar_t __RPC_FAR *   s
    );

RPCRTAPI
void
RPC_ENTRY
MIDL_wchar_strcpy (
    OUT void __RPC_FAR *     t,
    IN wchar_t __RPC_FAR *   s
    );

RPCRTAPI
void
RPC_ENTRY
char_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT unsigned char __RPC_FAR *                 Target
    );

RPCRTAPI
void
RPC_ENTRY
char_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned char __RPC_FAR *                 Target
    );

RPCRTAPI
void
RPC_ENTRY
short_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT unsigned short __RPC_FAR *                target
    );

RPCRTAPI
void
RPC_ENTRY
short_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned short __RPC_FAR *                Target
    );

RPCRTAPI
void
RPC_ENTRY
short_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT unsigned short __RPC_FAR *                target,
    IN unsigned long                              format
    );

RPCRTAPI
void
RPC_ENTRY
long_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT unsigned long __RPC_FAR *                 target
    );

RPCRTAPI
void
RPC_ENTRY
long_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned long __RPC_FAR *                 Target
    );

RPCRTAPI
void
RPC_ENTRY
long_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT unsigned long __RPC_FAR *                 target,
    IN unsigned long                              format
    );

RPCRTAPI
void
RPC_ENTRY
enum_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT unsigned int __RPC_FAR *                  Target
    );

RPCRTAPI
void
RPC_ENTRY
float_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
float_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
double_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
double_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
hyper_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT    hyper __RPC_FAR *                      target
    );

RPCRTAPI
void
RPC_ENTRY
hyper_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT          hyper __RPC_FAR *                Target
    );

RPCRTAPI
void
RPC_ENTRY
hyper_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT             hyper __RPC_FAR *             target,
    IN   unsigned   long                          format
    );

RPCRTAPI
void
RPC_ENTRY
data_from_ndr (
    PRPC_MESSAGE                                  source,
    void __RPC_FAR *                              target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
data_into_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
tree_into_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
data_size_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
tree_size_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
tree_peek_ndr (
    PRPC_MESSAGE                                  source,
    unsigned char __RPC_FAR * __RPC_FAR *         buffer,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
midl_allocate (
    size_t      size
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrlib\ctxcoll.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    CtxColl.cxx

Abstract:

    Implementation of ConTeXt handle COLLection.

Author:

    Kamen Moutafov    [KamenM]

Revision History:

    KamenM      Sep 2000    Created

Notes:

--*/

#include <precomp.hxx>
#include <context.hxx>
#include <SWMR.hxx>
#include <SContext.hxx>
#include <CtxColl.hxx>

ServerContextHandle *
ContextCollection::Find (
    IN WIRE_CONTEXT *WireContext
    )
/*++

Routine Description:

    Finds the server context handle corresponding to the given wire context

Arguments:

    WireContext - the context representation as it arrived on the wire

Return Value:
    The context handle that was found.
    NULL if no matching context handle was found. EEInfo will be added in 
        this case

Notes:
    As a perf optimization, if we search more than 25 elements in the list,
    and find an element, we move it to the front of the list to speed up
    subsequent searches
--*/
{
    LIST_ENTRY *CurrentListEntry;
    ServerContextHandle *CurrentContextHandle;
    int SearchedElements = 0;

    CollectionMutex.VerifyOwned();

    CurrentListEntry = ListHead.Flink;
    while (CurrentListEntry != &ListHead)
        {
        CurrentContextHandle = CONTAINING_RECORD(CurrentListEntry, ServerContextHandle, ContextChain);
        if (RpcpMemoryCompare(&CurrentContextHandle->WireContext, WireContext, sizeof(WIRE_CONTEXT)) == 0)
            {
            if (SearchedElements > 25)
                {
                RpcpfRemoveEntryList(CurrentListEntry);
                RpcpfInsertHeadList(&ListHead, CurrentListEntry);
                }
            return CurrentContextHandle;
            }

        CurrentListEntry = CurrentListEntry->Flink;
        SearchedElements ++;
        }

    return NULL;
}

RPC_STATUS
ContextCollection::AllocateContextCollection (
    OUT ContextCollection **NewColl
    )
/*++

Routine Description:

    Static function that allocates a new context collection.

Arguments:

    NewCol - a placeholder for the new connection. If the function
    fails this parameter is undefined. On success, it contains
    the new collection.

Return Value:
    RPC_S_OK for success or other codes for error.
--*/
{
    ContextCollection *NewCollection;
    RPC_STATUS RpcStatus = RPC_S_OK;

#if defined(SCONTEXT_UNIT_TESTS)
    // once in a great while, fail this
    if ((GetRandomLong() % 9999) == 0)
        return RPC_S_OUT_OF_MEMORY;
#endif

    NewCollection = new ContextCollection(&RpcStatus);
    if (NewCollection == NULL)
        {
        return RPC_S_OUT_OF_MEMORY;
        }
    else if (RpcStatus != RPC_S_OK)
        {
        delete NewCollection;
        return RpcStatus;
        }

    *NewColl = NewCollection;
    return RPC_S_OK;
}

RPC_STATUS
NDRSContextInitializeCollection (
    IN ContextCollection **ContextCollectionPlaceholder
    )
/*++

Routine Description:

    Static function that can initialize the context collection of an
    association in a thread safe manner.

Arguments:

    ContextCollectionPlaceholder - a pointer to the pointer to the context
    collection.

Return Value:
    RPC_S_OK for success or other codes for error.
--*/
{
    ContextCollection *NewCollection;
    ContextCollection *OldCollection;
    RPC_STATUS RpcStatus = RPC_S_OK;

    ASSERT(ContextCollectionPlaceholder);

    RpcStatus = ContextCollection::AllocateContextCollection(&NewCollection);
    if (RpcStatus != RPC_S_OK)
        {
        return RpcStatus;
        }

    OldCollection = (ContextCollection *)
        InterlockedCompareExchangePointer((PVOID *)ContextCollectionPlaceholder,
        NewCollection,
        NULL);

    if (OldCollection != NULL)
        {
        delete NewCollection;
        }

    return RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrlib\intconv.cxx ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    intconv.c

Abstract:

    Short and long conversion routines.

Author:

    Dov Harel (DovH) 21-Apr-1992

Environment:

    This code should execute in all environments supported by RPC
    (DOS, Win 3.X, and Win/NT as well as OS2).

Comments:

    Split charconv.cxx into

        charconv.cxx    -   Character related conversion.
        intconv.cxx     -   Integral type conversion.
        dataconv.cxx    -   Interpretation style converstion.

Revision history:

    Donna Liu    07-23-1992  Added LowerIndex parameter to
                            <basetype>_array_from_ndr routines
    Dov Harel    08-19-1992  Added RpcpMemoryCopy ([_f]memcpy)
                            to ..._array_from_ndr routines
    Ryszard Kott 06-15-1993 Added hyper support

--*/

#include <sysinc.h>
#include <rpc.h>
#include <rpcdcep.h>
#include <rpcndr.h>
#include <ndrlibp.h>

//
//  Definitions from rpcndr.h
//
//  Network Computing Architecture (NCA) definition:
//
//  Network Data Representation: (NDR) Label format:
//  An unsigned long (32 bits) with the following layout:
//
//  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
// +---------------+---------------+---------------+-------+-------+
// |   Reserved    |   Reserved    |Floating point | Int   | Char  |
// |               |               |Representation | Rep.  | Rep.  |
// +---------------+---------------+---------------+-------+-------+
//
//  Where
//
//      Reserved:
//
//          Must be zero (0) for NCA 1.5 and NCA 2.0.
//
//      Floating point Representation is:
//
//          0 - IEEE
//          1 - VAX
//          2 - Cray
//          3 - IBM
//
//      Int Rep. is Integer Representation:
//
//          0 - Big Endian
//          1 - Little Endian
//
//      Char Rep. is Character Representation:
//
//          0 - ASCII
//          1 - EBCDIC
//
//  #define NDR_CHAR_REP_MASK               (unsigned long)0X0000000FL
//  #define NDR_INT_REP_MASK                (unsigned long)0X000000F0L
//  #define NDR_FLOAT_REP_MASK              (unsigned long)0X0000FF00L
//
//  #define NDR_LITTLE_ENDIAN               (unsigned long)0X00000010L
//  #define NDR_BIG_ENDIAN                  (unsigned long)0X00000000L
//
//  #define NDR_IEEE_FLOAT                  (unsigned long)0X00000000L
//  #define NDR_VAX_FLOAT                   (unsigned long)0X00000100L
//
//  #define NDR_ASCII_CHAR                  (unsigned long)0X00000000L
//  #define NDR_EBCDIC_CHAR                 (unsigned long)0X00000001L
//
//  #define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000010L
//

//
//  For shorts assume the following 16-bit word layout:
//
//  1 1 1 1 1 1
//  5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
// +---------------+---------------+
// |       A       |       B       |
// +---------------+---------------+
//
// For longs assume the following 32-bit word layout:
//
//  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
// +---------------+---------------+---------------+---------------+
// |      A        |       B       |       C       |       D       |
// +---------------+---------------+---------------+---------------+
//

void RPC_ENTRY
short_from_ndr(
    IN OUT PRPC_MESSAGE SourceMessage,
    OUT unsigned short * Target
    )

/*++

Routine Description:

    Unmarshall a short from an RPC message buffer into the target
    (*Target).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 2) boundary,
    o   Unmarshalls the short (as unsigned short); performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the unmarshalled short.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the short to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the short which was just unmarshalled.

    Target - A pointer to the short to unmarshall the data into.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer =
        (unsigned char *)SourceMessage->Buffer;

    aBuffer++;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~1);

    if ( (SourceMessage->DataRepresentation & NDR_INT_REP_MASK) ==
          NDR_BIG_ENDIAN )
        {
        *(unsigned short *)Target = RtlUshortByteSwap(*(unsigned short *)aBuffer);
        }
    else
        {
        *(short *)Target = *((short *)aBuffer);
        }

    //
    // Update SourceMessage->Buffer before returning:
    //

    SourceMessage->Buffer = aBuffer + 2;
}

//
// end short_from_ndr
//

void RPC_ENTRY
short_array_from_ndr(
    IN OUT PRPC_MESSAGE SourceMessage,
    IN unsigned long    LowerIndex,
    IN unsigned long    UpperIndex,
    OUT unsigned short *Target
    )

/*++

Routine Description:

    Unmarshall an array of shorts from an RPC message buffer into
    the range Target[LowerIndex] .. Target[UpperIndex-1] of the
    target array of shorts (Target[]).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 2) boundary,
    o   Unmarshalls MemberCount shorts; performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the last unmarshalled short.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the first short to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the last short which was just unmarshalled.

    LowerIndex - Lower index into the target array.

    UpperIndex - Upper bound index into the target array.

    Target - An array of shorts to unmarshall the data into.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer =
        (unsigned char *)SourceMessage->Buffer;
    register unsigned int index;

    aBuffer++;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~1);

    if ( (SourceMessage->DataRepresentation & NDR_INT_REP_MASK) ==
          NDR_BIG_ENDIAN )
        {
        //
        // Big Endian Sender
        //

        for (index = (int)LowerIndex; index < UpperIndex; index++)
            {
            
            Target[index] = RtlUshortByteSwap(*(unsigned short *)aBuffer);
            aBuffer += 2;

            }
        //
        // Update SourceMessage->Buffer
        //

        SourceMessage->Buffer = (void PAPI *)aBuffer;

        }
    else
        {

        int byteCount = 2*(int)(UpperIndex - LowerIndex);

        RpcpMemoryCopy(
            &Target[LowerIndex],
            aBuffer,
            byteCount
            );
        //
        // Update SourceMessage->Buffer
        //

        SourceMessage->Buffer = (void PAPI *)(aBuffer + byteCount);
        
        }
}

//
// end short_array_from_ndr
//

void RPC_ENTRY
short_from_ndr_temp (
    IN OUT unsigned char ** source,
    OUT unsigned short *    target,
    IN unsigned long        format
    )
{

/*++

Routine Description:

    Unmarshall a short from a given buffer into the target
    (*target).  This routine:

    o   Aligns the *source pointer to the next (0 mod 2) boundary,
    o   Unmarshalls a short (as unsigned short); performs data
        conversion if necessary, and
    o   Advances the *source pointer to the address immediately
        following the unmarshalled short.

Arguments:

    source - A pointer to a pointer to a buffer

        IN - *source points to the address just prior to
            the short to be unmarshalled.
        OUT - *source points to the address just following
            the short which was just unmarshalled.

    target - A pointer to the short to unmarshall the data into.

    format - The sender data representation.

Return Values:

    None.

--*/

    register unsigned char PAPI * aBuffer = *source;

    aBuffer++;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~1);

    if ( (format & NDR_INT_REP_MASK) == NDR_BIG_ENDIAN )
        {
        *(unsigned short *)target = RtlUshortByteSwap(*(unsigned short *)aBuffer);
        }
    else
        {
        *(short *)target = *((short *)aBuffer);
        }

    //
    // Update *source (== aBuffer) before returning:
    //

    *source = aBuffer + 2;
}

//
// end short_from_ndr_temp
//

void RPC_ENTRY
long_from_ndr(
    IN OUT PRPC_MESSAGE SourceMessage,
    OUT unsigned long * Target
    )

/*++

Routine Description:

    Unmarshall a long from an RPC message buffer into the target
    (*Target).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 4) boundary,
    o   Unmarshalls the long (as unsigned long); performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the unmarshalled long.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the short to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the short which was just unmarshalled.

    Target - A pointer to the long to unmarshall the data into.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer =
        (unsigned char *)SourceMessage->Buffer;

    aBuffer = aBuffer + 3;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~3);

    if ( (SourceMessage->DataRepresentation & NDR_INT_REP_MASK) ==
          NDR_BIG_ENDIAN )
        {
        *(unsigned long *)Target = RtlUlongByteSwap(*(unsigned long *)aBuffer);
        }
    else
        {
        *(long *)Target = (*(long *)aBuffer);
        }

    //
    // Update SourceMessage->Buffer before returning:
    //

    SourceMessage->Buffer = aBuffer + 4;
}

//
// end long_from_ndr
//

void RPC_ENTRY
long_array_from_ndr(
    IN OUT PRPC_MESSAGE SourceMessage,
    IN unsigned long    LowerIndex,
    IN unsigned long    UpperIndex,
    OUT unsigned long * Target
    )

/*++

Routine Description:

    Unmarshall an array of longs from an RPC message buffer into
    the range Target[LowerIndex] .. Target[UpperIndex-1] of the
    target array of longs (Target[]).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 4) boundary,
    o   Unmarshalls MemberCount longs; performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the last unmarshalled long.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the first long to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the last long which was just unmarshalled.

    LowerIndex - Lower index into the target array.

    UpperIndex - Upper bound index into the target array.

    Target - An array of longs to unmarshall the data into.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer =
        (unsigned char *)SourceMessage->Buffer;
    register unsigned int index;

    aBuffer = (unsigned char *)aBuffer + 3;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~3);

    if ( (SourceMessage->DataRepresentation & NDR_INT_REP_MASK) ==
          NDR_BIG_ENDIAN )
        {
        for (index = (int)LowerIndex; index < UpperIndex; index++)
            {
            Target[index] = RtlUlongByteSwap(*(unsigned long *)aBuffer);
            aBuffer += 4;
            }

        //
        // Update SourceMessage->Buffer
        //

        SourceMessage->Buffer = (void PAPI *)aBuffer;

        }
    else
        {

        int byteCount = 4*(int)(UpperIndex - LowerIndex);

        RpcpMemoryCopy(
            &Target[LowerIndex],
            aBuffer,
            byteCount
            );
        //
        // Update SourceMessage->Buffer
        //

        SourceMessage->Buffer = (void PAPI *)(aBuffer + byteCount);
        
        }
}

//
// end long_array_from_ndr
//

void RPC_ENTRY
long_from_ndr_temp (
    IN OUT unsigned char ** source,
    OUT unsigned long *     target,
    IN unsigned long        format
    )

/*++

Routine Description:

    Unmarshall a long from a given buffer into the target
    (*target).  This routine:

    o   Aligns the *source pointer to the next (0 mod 2) boundary,
    o   Unmarshalls a long (as unsigned long); performs data
        conversion if necessary, and
    o   Advances the *source pointer to the address immediately
        following the unmarshalled long.

Arguments:

    source - A pointer to a pointer to a buffer

        IN - *source points to the address just prior to
            the long to be unmarshalled.
        OUT - *source points to the address just following
            the long which was just unmarshalled.

    target - A pointer to the long to unmarshall the data into.

    format - The sender data representation.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer = *source;

    aBuffer = (unsigned char *)aBuffer + 3;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~3);

    if ( (format & NDR_INT_REP_MASK) == NDR_BIG_ENDIAN )
        {
        *(unsigned long *)target = RtlUlongByteSwap(*(unsigned long *)aBuffer);
        }
    else
        {
        *(long *)target = (*(long *)aBuffer);
        }

    //
    // Update SourceMessage->Buffer before returning:
    //

    *source = aBuffer + 4;
}

//
// end long_from_ndr_temp
//

void RPC_ENTRY
enum_from_ndr(
    IN OUT PRPC_MESSAGE SourceMessage,
    OUT unsigned int * Target
    )

/*++

Routine Description:

    Unmarshall an int from an RPC message buffer into the target
    (*Target).  Note: this is based on the assumption, valid in all
    C compilers we currently support, that "enum" is treated as an
    "int" by the compiler.

    This routine:

    o   Aligns the buffer pointer to the next (0 mod 2) boundary,
    o   Unmarshalls the int (as unsigned int); performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the unmarshalled int.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the int to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the int which was just unmarshalled.

    Target - A pointer to the int to unmarshall the data into.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer =
        (unsigned char *)SourceMessage->Buffer;

    aBuffer++;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~1);

    //
    // Zeroe *Target to be on the safe side later for 32-bit
    // int systems!
    //

    *Target = 0;

    if ( (SourceMessage->DataRepresentation & NDR_INT_REP_MASK) ==
          NDR_BIG_ENDIAN )
        {
        *(unsigned short *)Target = RtlUshortByteSwap(*(unsigned short *)aBuffer);
        }
    else
        {
        // The following code will copy two bytes from the wire
        // to the two low order bytes of (*Target) independently of
        // the size of int.
        //

        *(short *)Target = *((short *)aBuffer);
        }

    //
    // Update SourceMessage->Buffer before returning:
    //

    SourceMessage->Buffer = aBuffer + 2;
}

//
// end enum_from_ndr
//

void RPC_ENTRY
hyper_from_ndr(
    IN OUT PRPC_MESSAGE SourceMessage,
//    OUT unsigned hyper * Target
    OUT           hyper * Target
    )

/*++

Routine Description:

    Unmarshall a hyper from an RPC message buffer into the target
    (*Target).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 8) boundary,
    o   Unmarshalls the hyper (as unsigned hyper); performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the unmarshalled hyper.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the hyper to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the hyper which was just unmarshalled.

    Target - A pointer to the hyper to unmarshall the data into.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer =
        (unsigned char *)SourceMessage->Buffer;

    aBuffer = aBuffer + 7;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~7);

    if ( (SourceMessage->DataRepresentation & NDR_INT_REP_MASK) ==
          NDR_BIG_ENDIAN )
        {
        *Target = RtlUlonglongByteSwap(*(unsigned hyper *)aBuffer);
        }
    else
        {
        *Target = *(hyper *)aBuffer;
        }

    //
    // Update SourceMessage->Buffer before returning:
    //

    SourceMessage->Buffer = aBuffer + 8;
}

//
// end hyper_from_ndr
//

#if 0

void RPC_ENTRY
hyper_array_from_ndr(
    IN OUT PRPC_MESSAGE SourceMessage,
    IN unsigned long    LowerIndex,
    IN unsigned long    UpperIndex,
//    OUT unsigned hyper  Target[]
    OUT         hyper * Target
    )

/*++

Routine Description:

    Unmarshall an array of hypers from an RPC message buffer into
    the range Target[LowerIndex] .. Target[UpperIndex-1] of the
    target array of hypers (Target[]).  This routine:

    o   Aligns the buffer pointer to the next (0 mod 8) boundary,
    o   Unmarshalls MemberCount hypers; performs data
        conversion if necessary, and
    o   Advances the buffer pointer to the address immediately
        following the last unmarshalled hyper.

Arguments:

    SourceMessage - A pointer to an RPC_MESSAGE.

        IN - SourceMessage->Buffer points to the address just prior to
            the first hyper to be unmarshalled.
        OUT - SourceMessage->Buffer points to the address just following
            the last hyper which was just unmarshalled.

    LowerIndex - Lower index into the target array.

    UpperIndex - Upper bound index into the target array.

    Target - An array of hypers to unmarshall the data into.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer =
        (unsigned char *)SourceMessage->Buffer;
    register unsigned int index;

    aBuffer = (unsigned char *)aBuffer + 7;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~7);

    if ( (SourceMessage->DataRepresentation & NDR_INT_REP_MASK) ==
          NDR_BIG_ENDIAN )
        {
        for (index = (int)LowerIndex; index < UpperIndex; index++)
            {

            //.. We are doing ABCDEFGH -> HGFEDCBA
            //.. We start with ABCD going as DCBA into second word of Target

            //
            // Swap bytes:
            //
            // First apply the transformation: ABCD => BADC
            //

            *(unsigned long *)Target =
                (*(unsigned long *)aBuffer & MASK_A_C_) >> 8 |
                (*(unsigned long *)aBuffer & MASK__B_D) << 8 ;

            //
            // Now swap the left and right halves of the Target long word
            // achieving full swap: BADC => DCBA
            //
            //.. Put it into second word, without changing Target pointer yet.

            *((unsigned long *)Target + 1) =
                (*(unsigned long *)Target & MASK_AB__) >> 16 |
                (*(unsigned long *)Target & MASK___CD) << 16 ;

            //.. What's left is EFGH going into first word at Target
            //.. Compiler can't do this: ((long *)aBuffer)++;

            aBuffer += 4;

            // Swap bytes:
            //
            // First apply the transformation: EFGH => FEHG
            //

            *(unsigned long *)Target =
                (*(unsigned long *)aBuffer & MASK_A_C_) >> 8 |
                (*(unsigned long *)aBuffer & MASK__B_D) << 8 ;

            //
            // Now swap the left and right halves of the Target long word
            // achieving full swap: FEHG => HGFE
            //
            //.. Put it into first word, at the Target pointer

            *(unsigned long *)Target =
                (*(unsigned long *)Target & MASK_AB__) >> 16 |
                (*(unsigned long *)Target & MASK___CD) << 16 ;

            //.. Loop, advance pointers.

            Target++;
            aBuffer += 4;           //.. ((long *)aBuffer)++;
            }

        //
        // Update SourceMessage->Buffer
        //

        SourceMessage->Buffer = (void PAPI *)aBuffer;

        }
    else
        {

        int byteCount = 8*(int)(UpperIndex - LowerIndex);

        RpcpMemoryCopy(
            &Target[LowerIndex],
            aBuffer,
            byteCount
            );
        //
        // Update SourceMessage->Buffer
        //

        SourceMessage->Buffer = (void PAPI *)(aBuffer + byteCount);

        }
}

//
// end long_array_from_ndr
//

void RPC_ENTRY
hyper_from_ndr_temp (
    IN OUT unsigned char ** source,
//    OUT unsigned hyper *    Target,
    OUT           hyper *    Target,
    IN unsigned long        format
    )

/*++

Routine Description:

    Unmarshall a hyper from a given buffer into the target
    (*target).  This routine:

    o   Aligns the *source pointer to the next (0 mod 2) boundary,
    o   Unmarshalls a hyper (as unsigned hyper); performs data
        conversion if necessary, and
    o   Advances the *source pointer to the address immediately
        following the unmarshalled hyper.

Arguments:

    source - A pointer to a pointer to a buffer

        IN - *source points to the address just prior to
            the hyper to be unmarshalled.
        OUT - *source points to the address just following
            the hyper which was just unmarshalled.

    Target - A pointer to the hyper to unmarshall the data into.

    format - The sender data representation.

Return Values:

    None.

--*/

{
    register unsigned char PAPI * aBuffer = *source;

    aBuffer = (unsigned char *)aBuffer + 3;
    aBuffer = (unsigned char *)((ULONG_PTR) aBuffer & ~3);

    if ( (format & NDR_INT_REP_MASK) == NDR_BIG_ENDIAN )
        {

        //.. We are doing ABCDEFGH -> HGFEDCBA
        //.. We start with ABCD going as DCBA into second word of Target

        //
        // Swap bytes:
        //
        // First apply the transformation: ABCD => BADC
        //

        *(unsigned long *)Target =
            (*(unsigned long *)aBuffer & MASK_A_C_) >> 8 |
            (*(unsigned long *)aBuffer & MASK__B_D) << 8 ;

        //
        // Now swap the left and right halves of the Target long word
        // achieving full swap: BADC => DCBA
        //
        //.. and put it into second word, without changing Target pointer

        *((unsigned long *)Target + 1) =
            (*(unsigned long *)Target & MASK_AB__) >> 16 |
            (*(unsigned long *)Target & MASK___CD) << 16 ;

        //.. What's left is EFGH going into first word at Target
        //.. Compiler can't do this: ((long *)aBuffer)++;

        aBuffer += 4;

        // Swap bytes:
        //
        // First apply the transformation: EFGH => FEHG
        //

        *(unsigned long *)Target =
            (*(unsigned long *)aBuffer & MASK_A_C_) >> 8 |
            (*(unsigned long *)aBuffer & MASK__B_D) << 8 ;

        //
        // Now swap the left and right halves of the Target long word
        // achieving full swap: FEHG => HGFE
        //
        //.. Put it into the first word, at the original Target pointer.

        *(unsigned long *)Target =
            (*(unsigned long *)Target & MASK_AB__) >> 16 |
            (*(unsigned long *)Target & MASK___CD) << 16 ;

        }
    else
        {
        //.. Copy hyper as two longs, don't change Target pointer.
        //.. Advance aBuffer by a long though to get the same as from above.
        //.. Compiler can't do this: ((long *)aBuffer)++;

        *(unsigned long *)Target = (*(unsigned long *)aBuffer);
        aBuffer += 4;
        *((unsigned long *)Target + 1) = (*(unsigned long *)aBuffer);
        }

    //
    // Update SourceMessage->Buffer before returning:
    //

    *source = aBuffer + 4;
}

//
// end hyper_from_ndr_temp
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrlib\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1989


Revision History:

!ENDIF

TARGETNAME=RpcNdrp
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=..;..\..\runtime\mtrt;..\..\runtime\rtifs\$(O)

C_DEFINES=$(RPCENV) -D_RPCRT4_

MSC_WARNING_LEVEL=/WX /W3

SOURCES=             \
        ..\ccontext.cxx \
        ..\CtxColl.cxx  \
        ..\scontext.cxx

# Need to use this method since build will not 
# allow ifdefs for sources

i386_SOURCES=             \
             ..\charconv.cxx \
             ..\dataconv.cxx \
             ..\intconv.cxx  \
             ..\floatc.cxx   \
             ..\help.c

ALPHA_SOURCES=$(i386_SOURCES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrlib\daytona\makefile.inc ===
# Copyright (c) 1993-1999 Microsoft Corporation

!ifndef LIB386
LIB386=\rpc\import\c700\bin\lib
!endif

..\linklist.cxx : ..\..\runtime\mtrt\linklist.cxx
    copy ..\..\runtime\mtrt\linklist.cxx ..

..\..\runtime\lib\i386\ndromf.lib: $(386_OBJECTS)
	@-del $*.lib 2> nul
	$(LIB386) $*.lib $(?: =+);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrlib\scontext.cxx ===
/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
           Copyright(c) Microsoft Corp., 1991-2001

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

Description :

Provides RPC server side context handle management

History :

stevez  01-15-91    First bits into the bucket.
Kamen Moutafov [kamenm] Sep 2000    Threw away all of Steve's bits and 
                                    buckets, and rewrote it to fix or pave 
                                    the road for the fixing of the following
                                    design bugs:
                                    - non-serialized context handles are
                                    unusable, and mixing serialized and
                                    non-serialized doesn't work
                                    - stealing context handles
                                    - gradual rundown of context handles
                                    - poor scalability of the context handle
                                    code (high cost of individual context
                                    handles) and contention on the context
                                    list

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <context.hxx>
#include <SContext.hxx>
#include <HndlSvr.hxx>
#include <CtxColl.hxx>
#include <OSFPcket.hxx>

#ifdef SCONTEXT_UNIT_TESTS
#define CODE_COVERAGE_CHECK     ASSERT(_NOT_COVERED_)

inline ServerContextHandle *
AllocateServerContextHandle (
    IN void *CtxGuard
    )
{
    if ((GetRandomLong() % 9999) == 0)
        return NULL;

    return new ServerContextHandle(CtxGuard);
}

#ifdef GENERATE_STATUS_FAILURE
#undef GENERATE_STATUS_FAILURE
#endif // GENERATE_STATUS_FAILURE

#define GENERATE_STATUS_FAILURE(s)  \
    if ((GetRandomLong() % 9999) == 0) \
        s = RPC_S_OUT_OF_MEMORY;

#define GENERATE_ADD_TO_COLLECTION_FAILURE(scall, ctx, status) \
    if ((GetRandomLong() % 9999) == 0) \
        { \
        scall->RemoveFromActiveContextHandles(ctx); \
        status = RPC_S_OUT_OF_MEMORY; \
        } \

#define GENERATE_LOCK_FAILURE(ctx, th, wcptr, status) \
    if ((GetRandomLong() % 9999) == 0) \
        { \
        ctx->Lock.Unlock(wcptr); \
        th->FreeWaiterCache(wcptr); \
        status = RPC_S_OUT_OF_MEMORY; \
        } \

#else
#define CODE_COVERAGE_CHECK

inline ServerContextHandle *
AllocateServerContextHandle (
    IN void *CtxGuard
    )
{
    return new ServerContextHandle(CtxGuard);
}
    
#define GENERATE_STATUS_FAILURE(s)
#define GENERATE_ADD_TO_COLLECTION_FAILURE(scall, ctx, status)
#define GENERATE_LOCK_FAILURE(ctx, th, wcptr, status)

#endif

WIRE_CONTEXT NullContext; // all zeros

// per process variable defining what is the synchronization mode
// for new context handles that don't have NDR level default
unsigned int DontSerializeContext = 0;


inline BOOL
DoesContextHandleNeedExclusiveLock (
    IN unsigned long Flags
    )
/*++

Routine Description:

    Determines if a context handle needs exclusive lock or
    shared lock.

Arguments:

    Flags - the flags given to the runtime by NDR.

Return Value:
    non-zero if the context handle needs exclusive lock. FALSE
    otherwise. There is no failure for this function.

--*/
{
    // make sure exactly one flag is set
    ASSERT((Flags & RPC_CONTEXT_HANDLE_FLAGS) != RPC_CONTEXT_HANDLE_FLAGS);

    switch (Flags & RPC_CONTEXT_HANDLE_FLAGS)
        {
        case RPC_CONTEXT_HANDLE_SERIALIZE:
            // serialize is Exclusive
            return TRUE;

        case RPC_CONTEXT_HANDLE_DONT_SERIALIZE:
            // non-serialized is Shared
            return FALSE;
        }

    return (DontSerializeContext == 0);
}

inline ContextCollection *
GetContextCollection (
    IN RPC_BINDING_HANDLE BindingHandle
    )
/*++

Routine Description:

    Gets the context collection from the call object and
    throws exception if this fails

Arguments:

    BindingHandle - the scall

Return Value:
    The collection. If getting the collection fails, an
    exception is thrown

--*/
{
    RPC_STATUS RpcStatus;
    ContextCollection *CtxCollection;

    RpcStatus = ((SCALL *)BindingHandle)->GetAssociationContextCollection(&CtxCollection);
    if (RpcStatus != RPC_S_OK)
        {
        RpcpRaiseException(RpcStatus);
        }

    return CtxCollection;
}

void
DestroyContextCollection (
    IN ContextCollection *CtxCollection
    )
/*++

Routine Description:

    Destroys all context handles in the collection, regardless
    of guard value. The context handles are rundown before destruction in
    case they aren't used. If they are, the rundown needed flag is set

Arguments:

    CtxCollection - the collection of context handles.

--*/
{
    DestroyContextHandlesForGuard((PVOID)CtxCollection,
        TRUE,   // Rundown context handle
        NULL    // nuke all contexts, regardless of guard value
        );

    delete CtxCollection;
}

void
NDRSRundownContextHandle (
    IN ServerContextHandle *ContextHandle
    )
/*++

Routine Description:
    Runs down a context handle by calling the user's rundown routine

Arguments:
    ContextHandle - the context handle

Notes:
    This routine will only touch the UserRunDown and UserContext members
    of Context. This allows caller to make up ServerContextHandles on the fly
    and just fill in those two members.
--*/

{
    // Only contexts which have a rundown and
    // are valid are cleaned up.
    if ((ContextHandle->UserRunDown != NULL) 
        && ContextHandle->UserContext)
        {
        RpcTryExcept
            {
            (*ContextHandle->UserRunDown)(ContextHandle->UserContext);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
#if DBG
            DbgPrint("Routine %p threw an exception %lu (0x%08lX) - this is illegal\n", ContextHandle->UserRunDown, RpcExceptionCode(), RpcExceptionCode());
            ASSERT(!"The rundown routine is not allowed to throw exceptions")
#endif
            }
        RpcEndExcept
        }
}

void
DestroyContextHandlesForGuard (     
    IN PVOID CtxCollectionPtr,
    IN BOOL RundownContextHandle,
    IN void *CtxGuard OPTIONAL
    ) 
/*++

Routine Description:
    Each context handle in this association with the specified
    guard *and* a zero refcount will be cleaned up in a way 
    determined by RundownContextHandle (see comment for 
    RundownContextHandle below)

Arguments:
    Context - the context for the association
    RundownContextHandle - if non-zero, rundown the context handle
        If zero, just cleanup the runtime part and the app will
        cleanup its part
    CtxGuard - the guard for which to cleanup context handles. If
        NULL, all context handles will be cleaned.

Notes:
    Access to a context handle with lifetime refcount only is implicitly
    synchronized as this function will be called from two places -
    the association rundown, and RpcServerUnregisterIfEx. In the
    former case all connections are gone, and nobody can come
    and start using the context handle. In the second, the interface
    is unregistered, and again nobody can come and start using the
    context handle. Therefore each context handle with lifetime refcount only
    (and for the specified guard) is synrchronized. This is not
    true however for the list itself. In the association rundown
    case some context handles may be used asynchronously for parked
    calls, and we need to synchronize access to the list.
    If this is called from RpcServerUnregisterIfEx, then all context
    handles must have zero refcount as before unregistering the
    interface we must have waited for all calls to complete.
--*/
{
    ContextCollection *CtxCollection = (ContextCollection *)CtxCollectionPtr;
    LIST_ENTRY *NextListEntry;
    ServerContextHandle *CurrentContextHandle;

    // N.B. It may seem like there is a race condition here b/n the two
    // callers of this function - RpcServerUnregisterIfEx & the destructor
    // of the association, as they can be called independently, and start
    // partying on the same list. However, the RpcServerUnregisterIfEx
    // branch will either take the association mutex, or will add a
    // refcount on the association, so that the association can
    // never be destroyed while this function is called by the
    // RpcServerUnregisterIfEx branch, and it is implicitly
    // synchronized as far as destruction is concerned. We still
    // need to synchronize access to the list

    CtxCollection->Lock();

    // for each user created context for this assoication, check
    // whether it fits our criteria for destruction, and if yes,
    // destroy it. This is an abnormal case, so we don't care about
    // performance
    NextListEntry = NULL;
    while ((CurrentContextHandle = CtxCollection->GetNext(&NextListEntry)) != NULL)
        {
        // if we were asked to clean up for a specific context
        // guard, check whether there is a match
        if (CtxGuard && (CtxGuard != CurrentContextHandle->CtxGuard))
            {
            // there is no match - move on to the next
            continue;
            }

        // NextListEntry is valid even after destruction of the current
        // context handle - we don't need to worry about that
        CtxCollection->Remove(CurrentContextHandle);


        ASSERT((CurrentContextHandle->Flags & ServerContextHandle::ContextRemovedFromCollectionMask) == 0);
        CurrentContextHandle->Flags |= ServerContextHandle::ContextRemovedFromCollectionMask
            | ServerContextHandle::ContextNeedsRundown;

        // remove the lifetime reference. If the refcount drops to 0, we can 
        // do the cleanup.
        if (CurrentContextHandle->RemoveReference() == 0)
            {
            if (RundownContextHandle)
                {
                NDRSRundownContextHandle(CurrentContextHandle);
                }

            delete CurrentContextHandle;
            }

        // N.B. Don't touch the CurrentContextHandle below this. We have released
        // our refcount
#if DBG
        // enforce it on checked
        CurrentContextHandle = NULL;
#endif
        }

    CtxCollection->Unlock();
}

void
FinishUsingContextHandle (
    IN SCALL *CallObject,
    IN ServerContextHandle *ContextHandle,
    IN BOOL fUserDeletedContext
    )
/*++

Routine Description:

    Perform functions commonly needed when execution returns
    from the server manager routine - if the context is in
    the list of active context handles, unlock it and remove it.
    Decrease the refcount, and if 0, remove the context from
    the collection, and if rundown as asked for, fire the rundown.

Arguments:

    CallObject - the server-side call object (the scall)
    ContextHandle - the context handle
    fUserDeletedContext - non-zero if the user has deleted the context handle
        (i.e. set UserContext to NULL)
--*/
{
    ServerContextHandle *RemovedContextHandle;
    ContextCollection *CtxCollection = NULL;
    long LocalRefCount;
    RPC_STATUS RpcStatus;
    SWMRWaiter *WaiterCache;
    THREAD *Thread;
    BOOL fRemoveLifeTimeReference;

    RemovedContextHandle = CallObject->RemoveFromActiveContextHandles(ContextHandle);

    if (fUserDeletedContext)
        {
        RpcStatus = CallObject->GetAssociationContextCollection(&CtxCollection);
        // the getting of the collection must succeed here, as we have already
        // created it, and we're simply getting it
        ASSERT(RpcStatus == RPC_S_OK);

        fRemoveLifeTimeReference = FALSE;
        CtxCollection->Lock();
        // if the context is still in the collection, remove it and take 
        // down the lifetime reference
        if ((ContextHandle->Flags & ServerContextHandle::ContextRemovedFromCollectionMask) == 0)
            {
            ContextHandle->Flags |= ServerContextHandle::ContextRemovedFromCollectionMask;
            fRemoveLifeTimeReference = TRUE;
            CtxCollection->Remove(ContextHandle);
            }
        CtxCollection->Unlock();

        // do it outside the lock
        if (fRemoveLifeTimeReference)
            {
            LocalRefCount = ContextHandle->RemoveReference();
            ASSERT(LocalRefCount);
            }
        }

    // if we were able to extract it from the list of active context handles, it must
    // have been active, and thus needs unlocking
    if (RemovedContextHandle)
        {
        WaiterCache = NULL;
        ContextHandle->Lock.Unlock(&WaiterCache);
        Thread = ThreadSelf();
        if (Thread)
            {
            Thread->FreeWaiterCache(&WaiterCache);
            }
        else
            {
            SWMRLock::FreeWaiterCache(&WaiterCache);
            }
        }

    LocalRefCount = ContextHandle->RemoveReference();
    if (LocalRefCount == 0)
        {
        // if we were asked to rundown by the rundown code, do it. 
        if (ContextHandle->Flags & ServerContextHandle::ContextNeedsRundownMask)
            {
            NDRSRundownContextHandle(ContextHandle);
            }

        ASSERT (ContextHandle->Flags & ServerContextHandle::ContextRemovedFromCollectionMask);

        delete ContextHandle;
        }
}

ServerContextHandle *
FindAndAddRefContextHandle (
    IN ContextCollection *CtxCollection,
    IN WIRE_CONTEXT *WireContext,
    IN PVOID CtxGuard,
    OUT BOOL *ContextHandleNewlyCreated
    )
/*++

Routine Description:

    Attempts to find the context handle for the given wire buffer,
    and if found, add a refcount to it, and return it.

Arguments:

    CtxCollection - the context handle collection.
    WireContext - the on-the-wire representation of the context
    CtxGuard - the context guard - if NULL, then any context handle
        matches. If non-NULL, the context handle that matches the
        wire context must have the same context guard in order for it
        to be considered a match.
    ContextHandleNewlyCreated - a pointer to a boolean variable that
        will be set to non-zero if the context handle had the newly 
        created flag set, or to FALSE if it didn't. If the return value
        is NULL, this is undefined.

Return Value:
    The found context handle. NULL if no matching context handle was 
    found.

Notes: 
    The newly created flag is always taken down regardless of other 
    paremeters.

--*/
{
    ServerContextHandle *ContextHandle;
    BOOL LocalContextHandleNewlyCreated = FALSE;

    CtxCollection->Lock();

    ContextHandle = CtxCollection->Find(WireContext);

    // if we have found a context handle, and is from the same interface, or
    // we don't care from what interface it is, get it
    if (ContextHandle
        && (
            (ContextHandle->CtxGuard == CtxGuard)
            ||
            (CtxGuard == NULL)
           )
       )
        {
        ASSERT(ContextHandle->ReferenceCount);
        // the only two flags that can be possibly set here are ContextAllocState and/or
        // ContextNewlyCreated. ContextAllocState *must* be ContextCompletedAlloc.
        // ASSERT that
        ASSERT(ContextHandle->Flags & ServerContextHandle::ContextAllocState);
        ASSERT((ContextHandle->Flags & 
               ~(ServerContextHandle::ContextAllocState | ServerContextHandle::ContextNewlyCreatedMask))
                == 0);
        ContextHandle->AddReference();
        if (ContextHandle->Flags & ServerContextHandle::ContextNewlyCreatedMask)
            {
            LocalContextHandleNewlyCreated = TRUE;
            }
        // take down the ContextNewlyCreated flag. Since we know that the only other
        // flag that can be set at this point is ContextNewlyCreated, a simple assignment
        // is sufficient
        ContextHandle->Flags = ServerContextHandle::ContextCompletedAlloc;
        }
    else
        {
        ContextHandle = NULL;
        }

    CtxCollection->Unlock();

    *ContextHandleNewlyCreated = LocalContextHandleNewlyCreated;
    return ContextHandle;
}

void
NDRSContextHandlePostDispatchProcessing (
    IN SCALL *SCall,
    ServerContextHandle *CtxHandle
    )
/*++

Routine Description:

    Performs post dispatch processing needed for in only context
    handles. If the context handle was NULL on input, just delete
    it. Else, finish using it.

Arguments:

    BindingHandle - the server-side binding handle (the scall)
    CtxHandle - the context handle
--*/
{
    if ((CtxHandle->Flags & ServerContextHandle::ContextAllocState) == ServerContextHandle::ContextPendingAlloc)
        {
        CODE_COVERAGE_CHECK;
        // [in] only context handle that didn't get set
        delete CtxHandle;
        }
    else
        {
        FinishUsingContextHandle(SCall, 
            CtxHandle, 
            FALSE   // fUserDeletedContextHandle
            );
        }
}


void
NDRSContextEmergencyCleanup (
    IN RPC_BINDING_HANDLE BindingHandle,
    IN OUT NDR_SCONTEXT hContext,
    IN NDR_RUNDOWN UserRunDownIn,
    IN PVOID UserContext,
    IN BOOL ManagerRoutineException)
/*++

Routine Description:

    Perform emergency cleanup if the manager routine throws an exception,
    or marshalling fails, or an async call is aborted. In the process,
    if the context handle was actively used, it must finish using it.

Arguments:

    BindingHandle - the server-side binding handle (the scall)
    hContext - the hContext created during unmarshalling.
    UserRunDownIn - if hContext is non-NULL, the user rundown from
        there will be used. This parameter will be used only if
        hContext is NULL.
    UserContext - the user context returned from the user. This will be
        set only in case 9 (see below). For all other cases, it will be 0
    ManagerRoutineException - non-zero if the exception was thrown
        from the manager routine.

Notes:
    Here's the functionality matrix for this function:

NDR will not call runtime in cases 1, 4 and 8

                      User C  Exc Handle         Clea-  Run-   Finish  Further use of 
N   Unm   Mar From:   tx(To:) ept Type    hCtx   nup    down   UsingCH context handle on the client:
--  ----  --- -----   ------- --- ------  ----   -----  -----  ------  -----------------------------
1   N     NA  NA      NA      NA  NA      NA     N      N      N       *As if the call was never made
2a  Y     N   NULL    NA      Y   NA      !NULL  Y      N      N       *As if the call was never made
2b  Y     N   !NULL   NA      Y   NA      !NULL  N      N      Y       *As if the call was never made
4   Y     Y   Any     NULL    N   Any     Any    N      N      N       *New context on the server
5a  Y     Y   NULL    !NULL   N   Any     Marker Y      Y      N       *As if the call was never made
5b  Y     Y   !NULL   !NULL   N   Any     Marker N      N      N       *To: value on the server
6a  Y     N   NULL    NULL    N   !ret    !NULL  Y      N      N       *As if the call was never made
6b  Y     N   !NULL   NULL    N   !ret    !NULL  Y      N      Y       *Invalid context from the server
7a  Y     N   NULL    !NULL   N   !ret    !NULL  Y      Y      N       *As if the call was never made
7b  Y     N   !NULL   !NULL   N   !ret    !NULL  N      N      Y       To: value on the server
8   Y     N   NA      NULL    N   ret     NULL   N      N      N       *NA (i.e. no retval)
9   Y     N   NA      !NULL   N   ret     NULL   N      Y      N       *NA (i.e. no retval)

    N.B. This routine throws exceptions on failure. Only datagram context handles have failure
    paths (aside from claiming critical section failures)
--*/
{
    ServerContextHandle *ContextHandle = (ServerContextHandle *)hContext;
    ContextCollection *CtxCollection;
    SCALL *SCall = (SCALL *)BindingHandle;
    BOOL ContextHandleNewlyCreated;
    DictionaryCursor cursor;
    PVOID Buffer;

    ASSERT(SCall->Type(SCALL_TYPE));

    LogEvent(SU_EXCEPT, EV_DELETE, ContextHandle, UserContext, ManagerRoutineException, 1, 0);

    // N.B. The following code doesn't make sense unless you have gone
    // through the notes in the comments. Please, read the notes before you
    // read this code
    if (ManagerRoutineException)
        {
        ASSERT(ContextHandle != NULL);

        // Cases 2a, 2b
        // Detect case 2a and cleanup runtime stuff for it
        if ((ContextHandle->Flags & ServerContextHandle::ContextAllocState) == ServerContextHandle::ContextPendingAlloc)
            {
            // case 2a started with NULL context handle - no need to call
            // FinishUsingContextHandle
            delete ContextHandle;
            }
        else
            {
            // case 2b - we started with a non-NULL context handle - we need to finish
            // using it
            FinishUsingContextHandle(SCall,
                ContextHandle,
                FALSE       // fUserDeletedContext
                );
            }
        }
    else if (ContextHandle == NULL)
        {
        ServerContextHandle TempItem(NULL);

        // Case 9
        // This must be a return value context handle, which the user has set to !NULL,
        // but we encountered marshalling problems before marshalling it. In this
        // case, simply rundown the user context.

        CODE_COVERAGE_CHECK;
        ASSERT(UserRunDownIn);
        ASSERT(UserContext);

        // create a temp context we can use for rundowns
        TempItem.UserRunDown = UserRunDownIn;
        TempItem.UserContext = UserContext;

        NDRSRundownContextHandle(&TempItem);
        }
    else if (ContextHandle == CONTEXT_HANDLE_AFTER_MARSHAL_MARKER)
        {
        // Cases 5a, 5b.
        // The context handle has been marshalled. Since we have released
        // all reference to the context handle, we cannot touch it. We need
        // to go back and search for the context handle again. It may have
        // been deleted either through a rundown, or by an attacker guessing
        // the context handle. Either way we want to handle it gracefully
        // Once we find the context handle (and get a lock on it), we need
        // to check if it has been used in the meantime, and if not, we
        // can proceed with the cleanup. If yes, just ignore it.

        CtxCollection = GetContextCollection(BindingHandle);
        // this must succeed as we have already obtained the collection once
        // during umarshalling
        ASSERT(CtxCollection);

        // in case 5b, we won't find anything, since we don't put buffers in
        // the collection. In this case, the loop will exit, and we'll be fine
        SCall->ActiveContextHandles.Reset(cursor);
        while ((Buffer = SCall->ActiveContextHandles.Next(cursor)) != 0)
            {
            // if this is not a buffer
            if (((ULONG_PTR)Buffer & SCALL::DictionaryEntryIsBuffer) == 0)
                {
                CODE_COVERAGE_CHECK;
                continue;
                }

            Buffer = (PVOID)((ULONG_PTR)Buffer & (~(SCALL::DictionaryEntryIsBuffer)));

            ContextHandle = FindAndAddRefContextHandle(CtxCollection,
                (WIRE_CONTEXT *)Buffer,
                NULL,    // CtxGuard
                &ContextHandleNewlyCreated
                );

            if (ContextHandle)
                {
                if (ContextHandleNewlyCreated)
                    {
                    // Case 5a
                    // this context handle was newly created - it cannot be used
                    // by anybody, and it cannot be in the active calls collection
                    // Therefore, it is safe to set the flag without holding the
                    // lock and to call FinishUsingContextHandle, which will decrement
                    // the ref count and will rundown & cleanup the context handle
                    ContextHandle->Flags |= ServerContextHandle::ContextNeedsRundown;
                    FinishUsingContextHandle(SCall,
                        ContextHandle,
                        TRUE    // fUserDeletedContext
                        );
                    }
                else
                    {
                    CODE_COVERAGE_CHECK;
                    // somebody managed to use the context handle - just finish off using it
                    FinishUsingContextHandle(SCall,
                        ContextHandle,
                        FALSE       // fUserDeletedContext
                        );
                    }
                }
            }
        }
    else if ((ContextHandle->Flags & ServerContextHandle::ContextAllocState) == ServerContextHandle::ContextPendingAlloc)
        {
        // Cases 6a, 7a

        UserContext = ContextHandle->UserContext;

        if (UserContext)
            {
            // if we're in case 7a
            NDRSRundownContextHandle(ContextHandle);
            }

        // cases 6a, 7a
        delete ContextHandle;
        }
    else if (UserContext == NULL)
        {
        // Case 6b
        // this is the case where we have transition from !NULL to NULL
        // and marshalling hasn't passed yet
        ASSERT((ContextHandle->Flags & ServerContextHandle::ContextAllocState) == ServerContextHandle::ContextCompletedAlloc);

        FinishUsingContextHandle(SCall,
            ContextHandle,
            TRUE       // fUserDeletedContext
            );
        }
    else
        {
        UserContext = ContextHandle->UserContext;

        // Cases 7b
        ASSERT(UserContext != NULL);
        ASSERT((ContextHandle->Flags & ServerContextHandle::ContextAllocState) == ServerContextHandle::ContextCompletedAlloc);

        // the context handle was actively used - finish using it
        FinishUsingContextHandle(SCall,
            ContextHandle,
            FALSE       // fUserDeletedContext
            );
        }
}


void
ByteSwapWireContext(
    IN WIRE_CONTEXT *WireContext,
    IN unsigned char *DataRepresentation
    )
/*++

Routine Description:

    If necessary, the wire context will be byte swapped in place.

Arguments:

    WireContext - Supplies the wire context be byte swapped and returns the
        resulting byte swapped context.

    DataRepresentation - Supplies the data representation of the supplied wire
        context.

Notes:
    The wire context is guaranteed only 4 byte alignment.
--*/
{
    if (   ( DataConvertEndian(DataRepresentation) != 0 )
        && ( WireContext != 0 ) )
        {
        WireContext->ContextType = RpcpByteSwapLong(WireContext->ContextType);
        ByteSwapUuid((class RPC_UUID *)&WireContext->ContextUuid);
        }
}


NDR_SCONTEXT RPC_ENTRY
NDRSContextUnmarshall (     
    IN void *pBuff,         
    IN unsigned long DataRepresentation 
    )
{
    return(NDRSContextUnmarshall2(I_RpcGetCurrentCallHandle(),
                                  pBuff,
                                  DataRepresentation,
                                  RPC_CONTEXT_HANDLE_DEFAULT_GUARD, 
                                  RPC_CONTEXT_HANDLE_DEFAULT_FLAGS));
}

NDR_SCONTEXT RPC_ENTRY
NDRSContextUnmarshallEx(
    IN RPC_BINDING_HANDLE BindingHandle,
    IN void *pBuff,         
    IN unsigned long DataRepresentation
    )
{
    return(NDRSContextUnmarshall2(BindingHandle,
                                  pBuff,
                                  DataRepresentation,
                                  RPC_CONTEXT_HANDLE_DEFAULT_GUARD, 
                                  RPC_CONTEXT_HANDLE_DEFAULT_FLAGS));
}

// make sure the public structure and our private ones agree on where is the user context
C_ASSERT(FIELD_OFFSET(ServerContextHandle, UserContext) == ((LONG)(LONG_PTR)&(((NDR_SCONTEXT)0)->userContext)));



NDR_SCONTEXT RPC_ENTRY
NDRSContextUnmarshall2 (
    IN RPC_BINDING_HANDLE BindingHandle,
    IN void *pBuff,         
    IN unsigned long DataRepresentation,
    IN void *CtxGuard, 
    IN unsigned long Flags
    ) 
/*++

Routine Description:
    Translate a NDR context to a handle
    The stub calls this routine to lookup a NDR wire format context into
    a context handle that can be used with the other context functions
    provided for the stubs use.

Arguments:

    BindingHandle - the server side binding handle (scall)
    pBuff - pointer to the on-the-wire represenation of the context handle
    DataRepresentation - specifies the NDR data representation
    CtxGuard - non-NULL and interface unique id for strict context handles. NULL
        for non-strict context handles
    Flags - the flags for this operation.

Return Value:
    A handle usable by NDR. Failures are reported by throwing exceptions.
--*/

{
    ServerContextHandle *ContextHandle;
    ServerContextHandle *TempContextHandle;
    ContextCollection *CtxCollection;
    WIRE_CONTEXT *WireContext;
    THREAD * Thread;
    RPC_STATUS RpcStatus;
    BOOL fFound;
    SCALL *SCall;
    SWMRWaiter *WaiterCache;
    BOOL Ignore;

    ByteSwapWireContext((WIRE_CONTEXT *) pBuff,
                        (unsigned char *) &DataRepresentation);

    // even if we don't put it in the collection, make sure that
    // we call this function to force creating the collection
    // if it isn't there. If it fails, it will throw an exception
    CtxCollection = GetContextCollection(BindingHandle);

    WireContext = (WIRE_CONTEXT *)pBuff;
    if (!WireContext || WireContext->IsNullContext())
        {
        // Allocate a new context
        ContextHandle = AllocateServerContextHandle(CtxGuard);
        if (ContextHandle == NULL)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                RPC_S_OUT_OF_MEMORY,
                EEInfoDLNDRSContextUnmarshall2_30,
                sizeof(ServerContextHandle));

            RpcRaiseException(RPC_S_OUT_OF_MEMORY);
            }

#if DBG
        if (CtxGuard == RPC_CONTEXT_HANDLE_DEFAULT_GUARD)
            RpcpInterfaceForCallDoesNotUseStrict(BindingHandle);
#endif

        // we don't put it in the active context handle list, because
        // non of the APIs work on newly created context handles.
        // We don't put it in the context collection either, allowing
        // us to put it on unmarshalling only if it is non-zero.
        }
    else
        {
        ContextHandle = FindAndAddRefContextHandle(CtxCollection,
            WireContext,
            CtxGuard,
            &Ignore     // ContextHandleNewlyCreated
            );

        if (!ContextHandle)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                RPC_X_SS_CONTEXT_MISMATCH,
                EEInfoDLNDRSContextUnmarshall2_10,
                WireContext->GetDebugULongLong1(),
                WireContext->GetDebugULongLong2()
                );
            RpcpRaiseException(RPC_X_SS_CONTEXT_MISMATCH);
            }

        SCall = (SCALL *)BindingHandle;
        RpcStatus = SCall->AddToActiveContextHandles(ContextHandle);
        GENERATE_ADD_TO_COLLECTION_FAILURE(SCall, ContextHandle, RpcStatus)
        if (RpcStatus != RPC_S_OK)
            {
            // remove the refcount and kill if it is the last one
            // Since this is not in the collection, no unlock
            // attempt will be made
            FinishUsingContextHandle(SCall, 
                ContextHandle, 
                FALSE       // fUserDeletedContext
                );

            RpcpErrorAddRecord(EEInfoGCRuntime, 
                RpcStatus,
                EEInfoDLNDRSContextUnmarshall2_50);

            RpcpRaiseException(RpcStatus);
            }

        Thread = RpcpGetThreadPointer();
        ASSERT(Thread);

        // here it must have been found. Find out what mode do we want this locked
        // in.
        if (DoesContextHandleNeedExclusiveLock(Flags))
            {
            Thread->GetWaiterCache(&WaiterCache, SCall, swmrwtWriter);
            RpcStatus = ContextHandle->Lock.LockExclusive(&WaiterCache);
            }
        else
            {
            Thread->GetWaiterCache(&WaiterCache, SCall, swmrwtReader);
            RpcStatus = ContextHandle->Lock.LockShared(&WaiterCache);
            }

        // in rare cases the lock operation may yield a cached waiter.
        // Make sure we handle it
        Thread->FreeWaiterCache(&WaiterCache);

        GENERATE_LOCK_FAILURE(ContextHandle, Thread, &WaiterCache, RpcStatus)

        if (RpcStatus != RPC_S_OK)
            {
            // first, we need to remove the context handle from the active calls
            // collection. This is necessary so that when we finish using it, it
            // doesn't attempt to unlock the handle (which it will attempt if the
            // handle is in the active contexts collection).
            TempContextHandle = SCall->RemoveFromActiveContextHandles(ContextHandle);
            ASSERT(TempContextHandle);

            FinishUsingContextHandle(SCall, 
                ContextHandle, 
                FALSE       // fUserDeletedContext
                );

            RpcpErrorAddRecord(EEInfoGCRuntime, 
                RpcStatus,
                EEInfoDLNDRSContextUnmarshall2_40);

            RpcpRaiseException(RpcStatus);
            }

        // did we pick a deleted context? Since we have a refcount, it can't go away
        // but it may very well have been marked deleted while we were waiting to get a lock
        // on the context handle. Check, and bail out if this is the case. This can
        // happen either if we encountered a rundown while waiting for the context
        // handle lock, or if an exclusive user before us deleted the context handle
        if (ContextHandle->Flags & ServerContextHandle::ContextRemovedFromCollection)
            {
            CODE_COVERAGE_CHECK;
            // since the context handle is in the active contexts collection,
            // this code will unlock it
            FinishUsingContextHandle(SCall, 
                ContextHandle, 
                FALSE       // fUserDeletedContext
                );

            RpcpErrorAddRecord(EEInfoGCRuntime, 
                RPC_X_SS_CONTEXT_MISMATCH,
                EEInfoDLNDRSContextUnmarshall2_20,
                WireContext->GetDebugULongLong1(),
                WireContext->GetDebugULongLong2()
                );
            RpcpRaiseException(RPC_X_SS_CONTEXT_MISMATCH);
            }
        }

    return ((NDR_SCONTEXT) ContextHandle);
}


void RPC_ENTRY
NDRSContextMarshallEx (      
    IN RPC_BINDING_HANDLE BindingHandle,
    IN OUT NDR_SCONTEXT hContext,   
    OUT void *pBuffer,   
    IN NDR_RUNDOWN userRunDownIn    
    )
{
    NDRSContextMarshall2(BindingHandle,
                         hContext,
                         pBuffer,
                         userRunDownIn,
                         RPC_CONTEXT_HANDLE_DEFAULT_GUARD, 
                         RPC_CONTEXT_HANDLE_DEFAULT_FLAGS);
}

void RPC_ENTRY
NDRSContextMarshall (      
    IN OUT NDR_SCONTEXT hContext,   
    OUT void *pBuff,        
    IN NDR_RUNDOWN userRunDownIn    
    )
{
    NDRSContextMarshall2(I_RpcGetCurrentCallHandle(),
                         hContext,
                         pBuff,
                         userRunDownIn,
                         RPC_CONTEXT_HANDLE_DEFAULT_GUARD, 
                         RPC_CONTEXT_HANDLE_DEFAULT_FLAGS);
}


void RPC_ENTRY
NDRSContextMarshall2(
    IN RPC_BINDING_HANDLE BindingHandle,
    IN OUT NDR_SCONTEXT hContext,   
    OUT void *pBuff,        
    IN NDR_RUNDOWN UserRunDownIn,
    IN void *CtxGuard, 
    IN unsigned long
    )
/*++

Routine Description:
    Marshall the context handle. If set to NULL, it will be destroyed.

Arguments:

    BindingHandle - the server side binding handle (the scall)
    hContext - the NDR handle of the context handle
    pBuff - buffer to marshell to
    UserRunDownIn - user function to be called when the rundown occurs
    CtxGuard - the magic id used to differentiate contexts created on
        different interfaces

--*/
{
    RPC_STATUS RpcStatus;
    ServerContextHandle *ContextHandle = (ServerContextHandle *)hContext;
    ContextCollection *CtxCollection;
    SCALL *SCall;
    BOOL fUserDeletedContextHandle;
    WIRE_CONTEXT *WireContext;

    SCall = (SCALL *)BindingHandle;

    // 0 for the flags is ContextPendingAlloc. If this is a new context, it 
    // cannot have ContextNeedsRundown, because it's not in the collection. 
    // It cannot have ContextRemovedFromCollection for the same reason. 
    // Therefore, testing for 0 is sufficient to determine if this is a new 
    // context
    if (ContextHandle->Flags == 0)
        {
        if (ContextHandle->UserContext == NULL)
            {
            // NULL to NULL - just delete the context handle
            ContextHandle->WireContext.CopyToBuffer(pBuff);
            delete ContextHandle;
            }
        else
            {
            // the context handle was just created - initialize the members that 
            // weren't initialized before and insert it in the list
            ContextHandle->Flags = ServerContextHandle::ContextNewlyCreated
                | ServerContextHandle::ContextCompletedAlloc;
            // UserContext was already set by NDR
            ContextHandle->UserRunDown = UserRunDownIn;
            ASSERT(CtxGuard == ContextHandle->CtxGuard);

            // create the UUID
            RpcStatus = UuidCreateSequential((UUID *)&ContextHandle->WireContext.ContextUuid);

            GENERATE_STATUS_FAILURE(RpcStatus);

            if (RpcStatus == RPC_S_OK)
                {
                RpcStatus = SCall->AddToActiveContextHandles(
                    (ServerContextHandle *) ((ULONG_PTR) pBuff | SCALL::DictionaryEntryIsBuffer));
                GENERATE_ADD_TO_COLLECTION_FAILURE(SCall, (ServerContextHandle *)((ULONG_PTR) pBuff & SCALL::DictionaryEntryIsBuffer), RpcStatus);
                }

            if ((RpcStatus != RPC_S_OK)
                && (RpcStatus != RPC_S_UUID_LOCAL_ONLY))
                {
                // run down the context handle
                NDRSRundownContextHandle(ContextHandle);
                // in a sense, marshalling failed
                delete ContextHandle;

                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RpcStatus,
                    EEInfoDLNDRSContextMarshall2_10);
                RpcpRaiseException(RpcStatus);
                }

            ContextHandle->WireContext.CopyToBuffer(pBuff);

            CtxCollection = GetContextCollection(BindingHandle);
            // the context collection must have been created during
            // marshalling. This cannot fail here
            ASSERT(CtxCollection);
            CtxCollection->Lock();
            CtxCollection->Add(ContextHandle);
            CtxCollection->Unlock();
            }

        return;
        }

    fUserDeletedContextHandle = (ContextHandle->UserContext == NULL);

    if (fUserDeletedContextHandle)
        {
        WireContext = (WIRE_CONTEXT *)pBuff;
        WireContext->SetToNull();
        }
    else
        {
        ContextHandle->WireContext.CopyToBuffer(pBuff);
        }

    FinishUsingContextHandle(SCall, ContextHandle, fUserDeletedContextHandle);
}


void RPC_ENTRY
I_RpcSsDontSerializeContext (
    void
    )
/*++

Routine Description:

    By default, context handles are serialized at the server.  One customer
    who doesn't like that is the spooler. They make use of a single context 
    handle by two threads at a time.  This API is used to turn off serializing 
    access to context handles for the process. It has been superseded by
    shared/exclusive access to the context, and must not be used anymore.

--*/
{
    DontSerializeContext = 1;
}

ServerContextHandle *
NDRSConvertUserContextToContextHandle (
    IN SCALL *SCall,
    IN PVOID UserContext
    )
/*++

Routine Description:

    Finds the context handle corresponding to the specified
        UserContext and returns it.

Arguments:

    SCall - the server side call object (the SCall)

    UserContext - the user context as given to the user by NDR. For
        in/out parameters, this will be a pointer to the UserContext
        field in the ServerContextHandle. For in parameters, this will
        be a value equal to the UserContext field in the 
        ServerContextHandle. We don't know what type of context handle
        is this, so we have to search both, giving precedence to in/out
        as they are more precise.

Return Value:

    NULL if the UserContext couldn't be matched to any context handle.
        The context handle pointer otherwise.

--*/
{
    DictionaryCursor cursor;
    ServerContextHandle *CurrentCtxHandle = NULL;
    ServerContextHandle *UserContextMatchingCtxHandle = NULL;

    if (SCall->InvalidHandle(SCALL_TYPE))
        return (NULL);

    SCall->ActiveContextHandles.Reset(cursor);
    while ((CurrentCtxHandle = SCall->ActiveContextHandles.Next(cursor)) != 0)
        {
        // make sure this is not a buffer pointer for some reason
        ASSERT (((ULONG_PTR)CurrentCtxHandle & SCALL::DictionaryEntryIsBuffer) == 0);
        
        if (&CurrentCtxHandle->UserContext == UserContext)
            {
            return CurrentCtxHandle;
            }

        if (CurrentCtxHandle->UserContext == UserContext)
            {
            UserContextMatchingCtxHandle = CurrentCtxHandle;
            }
        }

    // if we didn't find anything, this will be NULL and this is what we will
    // return
    return UserContextMatchingCtxHandle;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSsContextLockExclusive (
    IN RPC_BINDING_HANDLE ServerBindingHandle,
    IN PVOID UserContext
    )
/*++

Routine Description:

    Lock the specified context for exclusive use.

Arguments:

    ServerBindingHandle - the server side binding handle (the SCall)

    UserContext - the user context as given to the user by NDR. For
        in/out parameters, this will be a pointer to the UserContext
        field in the ServerContextHandle. For in parameters, this will
        be a value equal to the UserContext field in the 
        ServerContextHandle. We don't know what type of context handle
        is this, so we have to search both, giving precedence to in/out
        as they are more precise.

Return Value:

    RPC_S_OK, ERROR_INVALID_HANDLE if the ServerBindingHandle or the
    UserContext are invalid, a Win32 error if the locking failed,
    or ERROR_MORE_WRITES if two readers attempted to upgrade to Exclusive
    and one was evicted from its read lock (see the comment in 
    SWMR::ConvertToExclusive)

--*/
{
    ServerContextHandle *ContextHandle;
    SCALL *SCall = (SCALL *)ServerBindingHandle;
    SWMRWaiter *WaiterCache;
    THREAD *ThisThread;
    RPC_STATUS RpcStatus;

    if (SCall == NULL)
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        // if there is still no context, it will be handled by
        // NDRSConvertUserContextToContextHandle below.
        }

    ContextHandle = NDRSConvertUserContextToContextHandle(SCall,
        UserContext);

    if (ContextHandle == NULL)
        return ERROR_INVALID_HANDLE;

    // try to get a waiter for the locking
    ThisThread = ThreadSelf();
    if (ThisThread == NULL)
        return RPC_S_OUT_OF_MEMORY;

    WaiterCache = NULL;

    // we cannot allocate a waiter from the thread,
    // because by definition we already have a lock, and
    // the waiter for this lock may come from the thread.
    // Since the thread tends to overwrite the previous
    // waiter on recursive allocation, we don't want to
    // do that.

    RpcStatus = ContextHandle->Lock.ConvertToExclusive(&WaiterCache);

    // if a waiter was produced, store it. Conversion
    // operations can produce spurious waiters because of
    // race conditions
    ThisThread->FreeWaiterCache(&WaiterCache);

    return RpcStatus;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSsContextLockShared (
    IN RPC_BINDING_HANDLE ServerBindingHandle,
    IN PVOID UserContext
    )
/*++

Routine Description:

    Lock the specified context for shared use.

Arguments:

    ServerBindingHandle - the server side binding handle (the SCall)

    UserContext - the user context as given to the user by NDR. For
        in/out parameters, this will be a pointer to the UserContext
        field in the ServerContextHandle. For in parameters, this will
        be a value equal to the UserContext field in the 
        ServerContextHandle. We don't know what type of context handle
        is this, so we have to search both, giving precedence to in/out
        as they are more precise.

Return Value:

    RPC_S_OK, ERROR_INVALID_HANDLE if the ServerBindingHandle or the
    UserContext are invalid, a Win32 error if the locking failed

--*/
{
    ServerContextHandle *ContextHandle;
    SCALL *SCall = (SCALL *)ServerBindingHandle;
    SWMRWaiter *WaiterCache;
    THREAD *ThisThread;
    RPC_STATUS RpcStatus;

    if (SCall == NULL)
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        // if there is still no context, it will be handled by
        // NDRSConvertUserContextToContextHandle below.
        }

    ContextHandle = NDRSConvertUserContextToContextHandle(SCall,
        UserContext);

    if (ContextHandle == NULL)
        return ERROR_INVALID_HANDLE;

    // try to get a waiter for the locking
    ThisThread = ThreadSelf();
    if (ThisThread == NULL)
        return RPC_S_OUT_OF_MEMORY;

    WaiterCache = NULL;
    // we cannot allocate a waiter from the thread,
    // because by definition we already have a lock, and
    // the waiter for this lock may come from the thread.
    // Since the thread tends to overwrite the previous
    // waiter on recursive allocation, we don't want to
    // do that.

    RpcStatus = ContextHandle->Lock.ConvertToShared(&WaiterCache, 
        TRUE    // fSyncCacheUsed
        );

    // if a waiter was produced, store it. Conversion
    // operations can produce spurious waiters because of
    // race conditions
    ThisThread->FreeWaiterCache(&WaiterCache);

    return RpcStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrmem\makefile.inc ===
# Copyright (c) 1993-1999 Microsoft Corporation

!ifndef LIB386
LIB386=\rpc\import\c700\bin\lib
!endif

..\runtime\lib\i386\ndromf.lib: $(386_OBJECTS)
	@-del $*.lib 2> nul
	$(LIB386) $*.lib $(?: =+);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrmem\ndrmem.cxx ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    dataconv.cxx

Abstract:

    This module contains interpreter style routines that copy data
    into the buffer, copy data from the buffer, peek the buffer,
    and calcualte the size of the buffer.

Author:

    Donna Liu (donnali) 09-Nov-1990

Revision History:

    26-Feb-1992     donnali

        Moved toward NT coding style.

--*/


#include <string.h>
#include <sysinc.h>
#include <rpc.h>
#include <rpcdcep.h>
#include <rpcndr.h>

extern "C" {
void __RPC_FAR * __RPC_API MIDL_user_allocate (size_t);
}

void PAPI * RPC_ENTRY
midl_allocate (
	size_t 	size)
{
	void PAPI * p;

	p = MIDL_user_allocate (size);
	if (!p) RpcRaiseException (RPC_X_NO_MEMORY);
	return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrmem\linklist.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       linklist.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
		   Copyright(c) Microsoft Corp., 1990

		  RPC Runtime - Written by Steven Zeck


	This file contains the class implementation of linked list.
-------------------------------------------------------------------- */


#include <precomp.hxx>
#include <linklist.hxx>


// ** LinkItem class implementations ** //

void LinkItem::Remove (		// delete an LinkList from a list *^
LinkList& pLLHead		// pointer to Head to Remove
 // Removal of a Linked List item is easy with doubly linked lists.
)/*-----------------------------------------------------------------------*/
{
    ASSERT(this && (void *)&pLLHead);

    if (!pLIPrev)
	pLLHead.pLIHead = pLINext;	// LI at head of list

    else
	pLIPrev->pLINext = pLINext;

    if (!pLINext)
	pLLHead.pLITail = pLIPrev;	// LI at tail of list

    else
	pLINext->pLIPrev = pLIPrev;

    pLLHead.Assert();
}


// ** LinkList class implementations ** //

void LinkList::Add (			// Add a new node at the head of a list
LinkItem *pLInew			// allocated Item to Add

 // Add the newly allocated item to the front of the linked list.
)/*-----------------------------------------------------------------------*/
{
    if ( this == 0 )
        {
        return;
        }

    this->Assert();

    pLInew->pLINext = pLIHead;		// old head is now Next
    pLInew->pLIPrev = Nil;
    pLIHead = pLInew;			// new is now Head

    if (!pLITail)			// handle empty list

	pLITail = pLInew;
    else {
	ASSERT(pLInew->pLINext);
	pLInew->pLINext->pLIPrev = pLInew;	// old head points back to new
    }
}

void LinkList::Append (			// Append a new node at the end of a list
LinkItem *pLInew			// allocated Item to Add

)/*-----------------------------------------------------------------------*/
{
    if ( this == 0 )
        {
        return;
        }

    this->Assert();

    // empty lists are just like Add

    if (!pLITail) {
	this->Add(pLInew);
	return;
    }

    pLInew->pLINext = Nil;		// new points back to old tail
    pLInew->pLIPrev = pLITail;

    pLITail->pLINext = pLInew;		// old tail points forward to new
    pLITail = pLInew;			// tail is now new
}

#ifdef LDEBUG

void LinkList::Assert(		// check consistency of the class

 // First check the boundary conditions for the linked list root,
 // then walk the list checking the backward/forward pointers.	Finial
 // invoke the virtural function to check the contents of each item.
)/*-----------------------------------------------------------------------*/
{
    if (!pLIHead)		// empty list
	ASSERT(!pLITail);

    if (!pLITail)
	ASSERT(!pLIHead);

    for (LinkItem *pLI = pLIHead; pLI; pLI = pLI->pLINext) {

	// tail should point to end of list

	if (pLI->pLINext == Nil)
	    ASSERT(pLITail == pLI);

	// first in chain, should have NIL back pointer

	if (pLI->pLIPrev == Nil)
	    ASSERT(pLIHead == pLI);

	// check back pointer of next Item points here

	if (pLI->pLINext)
	    ASSERT(pLI->pLINext->pLIPrev == pLI);

	pLI->Assert();		// check any derived data
    }

}

void LinkItem::Assert(

)/*-----------------------------------------------------------------------*/
{
    return;	// base class has no additional members, so return
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndrmem\rpcproxy.c ===
#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__)
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File: rpcproxy.c
//
//  Contents: 	Contains runtime functions for interface proxies and stubs.
//
//	Functions:	
//				DllGetClassObject
//              DllCanUnloadNow
//				MIDL_user_allocate
//				MIDL_user_free
//				NdrGetProxyBuffer
//				NdrGetProxyIID
//				NdrProxyInitialize
//				NdrProxyGetBuffer
//				NdrProxySendReceive
//				NdrProxyFreeBuffer
//				NdrProxyErrorHandler
//				NdrStubInitialize
//				NdrStubGetBuffer
//
//	Classes:	CStdProxyBuffer
//				CStdPSFactoryBuffer
//				CStdStubBuffer
//
//
//
//--------------------------------------------------------------------------
#include <rpcproxy.h>
#include <assert.h>

//+-------------------------------------------------------------------------
//
//  Global data
//
//--------------------------------------------------------------------------
long DllRefCount = 0;

IPSFactoryBufferVtbl CStdPSFactoryBufferVtbl = {
	CStdPSFactoryBuffer_QueryInterface,
	CStdPSFactoryBuffer_AddRef,
	CStdPSFactoryBuffer_Release,
	CStdPSFactoryBuffer_CreateProxy,
	CStdPSFactoryBuffer_CreateStub };

CStdPSFactoryBuffer gPSFactoryBuffer = {
	&CStdPSFactoryBufferVtbl,
	0 };

IRpcProxyBufferVtbl CStdProxyBufferVtbl = {
	CStdProxyBuffer_QueryInterface,
	CStdProxyBuffer_AddRef,
	CStdProxyBuffer_Release,
	CStdProxyBuffer_Connect,
	CStdProxyBuffer_Disconnect };

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard implementation of entrypoint required by binder.
//
//  Arguments:  [rclsid]    -- class id to find
//      [riid]      -- interface to return
//      [ppv]       -- output pointer
//
//  Returns:    E_UNEXPECTED if class not found
//      Otherwise, whatever is returned by the class's QI
//
//  Algorithm:  Searches the linked list for the required class.
//
//  Notes:
//
//--------------------------------------------------------------------------
 HRESULT STDAPICALLTYPE DllGetClassObject (
    REFCLSID rclsid,
    REFIID riid,
    LPVOID FAR* ppv )
{
    HRESULT hr = E_UNEXPECTED;

	assert(rclsid);
	assert(riid);
	assert(ppv);

	*ppv = 0;
	if(memcmp(rclsid, &CLSID_PSFactoryBuffer, sizeof(IID)) == 0)
	    hr = gPSFactoryBuffer.lpVtbl->QueryInterface((IPSFactoryBuffer *)&gPSFactoryBuffer, riid, ppv);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard entrypoint required by binder
//
//  Returns:    S_OK if DLL reference count is zero
//      		S_FALSE otherwise
//
//--------------------------------------------------------------------------
 HRESULT STDAPICALLTYPE DllCanUnloadNow ()
{
	HRESULT hr;

    if(DllRefCount == 0)
		hr = S_OK;
	else
		hr = S_FALSE;

	return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStdPSFactoryBuffer_QueryInterface, public
//
//  Synopsis:   Query for an interface on the class factory.
//
//  Derivation: IUnknown
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE 
CStdPSFactoryBuffer_QueryInterface (
	IPSFactoryBuffer *pThis,
    REFIID iid,
    void **ppv )
{
    HRESULT hr = E_NOINTERFACE;

	assert(pThis);
	assert(iid);
	assert(ppv);

    *ppv = 0;
    if ((memcmp(iid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(iid, &IID_IPSFactoryBuffer, sizeof(IID)) == 0))
    {
        *ppv = pThis;
		pThis->lpVtbl->AddRef(pThis);
	    hr = S_OK;
    }

    return hr;
}
//+-------------------------------------------------------------------------
//
//  Method:     CStdPSFactoryBuffer_AddRef, public
//
//  Synopsis:   Increment DLL reference counts
//
//  Derivation: IUnknown
//
//	Notes: We have a single instance of the CStdPSFactoryBuffer.
//
//--------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE 
CStdPSFactoryBuffer_AddRef(
	IPSFactoryBuffer *this)
{
	assert(this);

    InterlockedIncrement(&((CStdPSFactoryBuffer *)this)->RefCount);
   	InterlockedIncrement(&DllRefCount);
	return (unsigned long) ((CStdPSFactoryBuffer *)this)->RefCount;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStdPSFactoryBuffer_Release, public
//
//  Synopsis:   Decrement DLL reference count
//
//  Derivation: IUnknown
//
//--------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CStdPSFactoryBuffer_Release(
	IPSFactoryBuffer *this)
{
	long t;
	unsigned long count;
    
	assert(this);

    t = InterlockedDecrement(&((CStdPSFactoryBuffer *)this)->RefCount);
    InterlockedDecrement(&DllRefCount);

	if(t == 0)
		count = 0;
	else
		count = (unsigned long) ((CStdPSFactoryBuffer *)this)->RefCount;

    return count;
}


//+-------------------------------------------------------------------------
//
//  Method:     CStdPSFactoryBuffer_CreateProxy, public
//
//  Synopsis:   Create a proxy for the specified interface.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE 
CStdPSFactoryBuffer_CreateProxy
(
    IPSFactoryBuffer *this,
    IUnknown *punkOuter,
    REFIID riid,
    IRpcProxyBuffer **ppProxy,
    void **ppv
)
{
    HRESULT hr = E_OUTOFMEMORY;
	const IID *pIID;
	CStdProxyBuffer *pProxyBuffer = 0;
	int i, j;

	assert(this);
	assert(riid);
	assert(ppProxy);
	assert(ppv);

	*ppProxy = 0;
	*ppv = 0;

	//Search the list of proxy files.
	for(i = 0; 
		pProxyFileList[i] && !pProxyBuffer;
		i++)
	{
		//Search the interface proxies in the proxy buffer
		for(j = 0;
			((CStdProxyBuffer *)pProxyFileList[i]->pProxyBuffer)->aProxyVtbl[j] && !pProxyBuffer;
			j++)
		{
			pIID = NdrGetProxyIID(&((CStdProxyBuffer *)pProxyFileList[i]->pProxyBuffer)->aProxyVtbl[j]);
			assert(pIID);
			
			if(memcmp(riid, pIID, sizeof(IID)) == 0)
			{
				//We found the interface!
       			//Allocate memory for the new proxy buffer.
				pProxyBuffer = (CStdProxyBuffer *) CoTaskMemAlloc(pProxyFileList[i]->ProxyBufferSize);
				
				if(pProxyBuffer)
				{
					//Initialize the new proxy buffer.
					memcpy(pProxyBuffer, pProxyFileList[i]->pProxyBuffer, pProxyFileList[i]->ProxyBufferSize);
					pProxyBuffer->punkOuter = punkOuter;

   					//Increment the DLL reference count.
   					InterlockedIncrement(&DllRefCount);
				   	
					*ppProxy = (IRpcProxyBuffer *) pProxyBuffer;
					*ppv = &pProxyBuffer->aProxyVtbl[j];
					hr = S_OK;
				}
			}
		}
	}

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStdPSFactoryBuffer_CreateStub, public
//
//  Synopsis:   Create a stub for the specified interface.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE 
CStdPSFactoryBuffer_CreateStub
(
    IPSFactoryBuffer *this,
    REFIID riid,
    IUnknown *punkServer,
    IRpcStubBuffer **ppStub
)
{
    HRESULT hr = E_OUTOFMEMORY;
	const IID *pIID;
	CStdStubBuffer *pStubBuffer = 0;
	int i, j;

	assert(this);
	assert(riid);
	assert(ppStub);

	*ppStub = 0;

	//Search the list of proxy files.
	for(i = 0; 
		pProxyFileList[i] && !pStubBuffer;
		i++)
	{
		//Search the interface stubs in the stub buffer
		for(j = 0;
			((CStdStubBuffer *)pProxyFileList[i]->pStubBuffer)->aInterfaceStub[j].lpVtbl && !pStubBuffer;
			j++)
		{
			pIID = NdrGetStubIID(&((CStdStubBuffer *)pProxyFileList[i]->pStubBuffer)->aInterfaceStub[j].lpVtbl);
			assert(pIID);
			
			if(memcmp(riid, pIID, sizeof(IID)) == 0)
			{
				//We found the interface!
       			//Allocate memory for the new proxy buffer.
				pStubBuffer = (CStdStubBuffer *) CoTaskMemAlloc(pProxyFileList[i]->StubBufferSize);

				if(pStubBuffer)
				{
					//Initialize the new stub buffer.
					memcpy(pStubBuffer, pProxyFileList[i]->pStubBuffer, pProxyFileList[i]->StubBufferSize);

					if(punkServer)
					{
						punkServer->lpVtbl->AddRef(punkServer);
						pStubBuffer->punkObject = punkServer;
						hr = punkServer->lpVtbl->QueryInterface(punkServer, riid, &pStubBuffer->aInterfaceStub[j].pvServerObject);
					}
					else
						hr = S_OK;

					if(FAILED(hr))
						CoTaskMemFree(pStubBuffer);
					else
					{
						*ppStub = (IRpcStubBuffer *) &pStubBuffer->aInterfaceStub[j].lpVtbl;

	   					//Increment the DLL reference count.
   						InterlockedIncrement(&DllRefCount);
					}

				}
			}
		}
	}

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Method:     CStdProxyBuffer_QueryInterface, public
//
//  Synopsis:   Query for an interface on the proxy.  This provides access
//              to both internal and external interfaces.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_QueryInterface(IRpcProxyBuffer *pThis, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
	CStdProxyBuffer *pProxyBuffer = (CStdProxyBuffer *) pThis;
	void *pInterfaceProxy = 0;
	int j;
	const IID *pIID;

	assert(pThis);
	assert(riid);
	assert(ppv);

	*ppv = 0;

    if((memcmp(riid, &IID_IUnknown, sizeof(IID)) == 0) ||
		(memcmp(riid, &IID_IRpcProxyBuffer, sizeof(IID)) == 0))    
    {
        //This is an internal interface. Increment the internal reference count.
		InterlockedIncrement( &((CStdProxyBuffer *)pThis)->RefCount);
        *ppv = pThis;
        hr = S_OK;
    }

		//Search the interface proxies in the proxy buffer
		for(j = 0;
			pProxyBuffer->aProxyVtbl[j] && !pInterfaceProxy;
			j++)
		{
			pIID = NdrGetProxyIID(&pProxyBuffer->aProxyVtbl[j]);
			assert(pIID);
			
			if(memcmp(riid, pIID, sizeof(IID)) == 0)
			{
				//We found the interface!
				pInterfaceProxy = &pProxyBuffer->aProxyVtbl[j];

				//Increment the reference count.
				if(pProxyBuffer->punkOuter)
				{
					pProxyBuffer->punkOuter->lpVtbl->AddRef(pProxyBuffer->punkOuter);
				}
				else
				{
					InterlockedIncrement(&pProxyBuffer->RefCount);
				}

				*ppv = pInterfaceProxy;
				hr = S_OK;
			}
		}

    return hr;
};

//+-------------------------------------------------------------------------
//
//  Method:     CStdProxyBuffer_AddRef, public
//
//  Synopsis:   Increment reference count.
//
//--------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CStdProxyBuffer_AddRef(IRpcProxyBuffer *pThis)
{
	InterlockedIncrement(&((CStdProxyBuffer *)pThis)->RefCount);
    return (ULONG) ((CStdProxyBuffer *)pThis)->RefCount;
};

//+-------------------------------------------------------------------------
//
//  Method:     CStdProxyBuffer_Release, public
//
//  Synopsis:   Decrement reference count.
//
//--------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE 
CStdProxyBuffer_Release(IRpcProxyBuffer *pThis)
{
	long RefCount;
	unsigned long count;

	assert(pThis);
	
	RefCount = InterlockedDecrement(&((CStdProxyBuffer *)pThis)->RefCount);
	assert(RefCount >= 0);

	if(RefCount == 0)
	{
		count = 0;
		
		//Decrement the DLL reference count.
		InterlockedDecrement(&DllRefCount);

		//Free the memory
		MIDL_user_free(pThis);
	}
	else 
		count = (unsigned long) ((CStdProxyBuffer *)pThis)->RefCount;

	return count;
};

//+-------------------------------------------------------------------------
//
//  Method:     CStdProxyBuffer_Connect, public
//
//  Synopsis:   Connect the proxy to the channel.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_Connect(IRpcProxyBuffer *pThis, IRpcChannelBuffer *pChannel)
{
	HRESULT hr = E_UNEXPECTED;

	assert(pThis);
		
	pThis->lpVtbl->Disconnect(pThis);
	if(pChannel)
		hr = pChannel->lpVtbl->QueryInterface(pChannel, &IID_IRpcChannelBuffer, &((CStdProxyBuffer *)pThis)->pChannel);

    return hr;
};

//+-------------------------------------------------------------------------
//
//  Method:     CStdProxyBuffer_Disconnect, public
//
//  Synopsis:   Disconnect the proxy from the channel.
//
//  Derivation: IRpcProxyBuffer
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE
CStdProxyBuffer_Disconnect(IRpcProxyBuffer *pThis)
{
	assert(pThis);

	if(((CStdProxyBuffer *)pThis)->pChannel)
	{
		((CStdProxyBuffer *)pThis)->pChannel->lpVtbl->Release(((CStdProxyBuffer *)pThis)->pChannel);
		((CStdProxyBuffer *)pThis)->pChannel = 0;
	}
};


//+-------------------------------------------------------------------------
//
//  Method:     CStdStubBuffer_QueryInterface, public
//
//  Synopsis:   Query for an interface on the stub buffer.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE 
CStdStubBuffer_QueryInterface(IRpcStubBuffer *pThis, REFIID riid, void **ppvObject)
{
    HRESULT hr = E_NOINTERFACE;

	assert(pThis);
	assert(riid);
	assert(ppvObject);

    *ppvObject = 0;
    if ((memcmp(riid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(riid, &IID_IRpcStubBuffer, sizeof(IID)) == 0))
    {
        *ppvObject = (IRpcStubBuffer *) pThis;
		pThis->lpVtbl->AddRef(pThis);
	    hr = S_OK;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStdStubBuffer_AddRef, public
//
//  Synopsis:   Increment reference count.
//
//--------------------------------------------------------------------------
ULONG 	STDMETHODCALLTYPE 
CStdStubBuffer_AddRef(IRpcStubBuffer *pThis)
{
	CStdStubBuffer *pStubBuffer;

	assert(pThis);
	
	pStubBuffer = NdrGetStubBuffer(pThis);
	assert(pStubBuffer);

	InterlockedIncrement(&pStubBuffer->RefCount);
    return (ULONG) pStubBuffer->RefCount;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStdStubBuffer_Release, public
//
//  Synopsis:   Decrement reference count.
//
//--------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE 
CStdStubBuffer_Release(IRpcStubBuffer *pThis)
{
	long RefCount;
	unsigned long count;
	CStdStubBuffer *pStubBuffer;

	assert(pThis);

	pStubBuffer = NdrGetStubBuffer(pThis);
	assert(pStubBuffer);
	
	RefCount = InterlockedDecrement(&pStubBuffer->RefCount);
	assert(RefCount >= 0);

	if(RefCount == 0)
	{
		count = 0;
		
		//Decrement the DLL reference count.
		InterlockedDecrement(&DllRefCount);

		//Free the stub buffer
		MIDL_user_free(pStubBuffer);
	}
	else 
		count = (unsigned long) pStubBuffer->RefCount;

	return count;
}

HRESULT STDMETHODCALLTYPE 
CStdStubBuffer_Connect(IRpcStubBuffer *pThis, IUnknown *pUnkServer)
{
	HRESULT hr = E_UNEXPECTED;
	CStdStubBuffer *pStubBuffer;

	assert(pThis);

	pStubBuffer = NdrGetStubBuffer(pThis);
	assert(pStubBuffer);

	pThis->lpVtbl->Disconnect(pThis);

	if(pUnkServer)
	{
		hr = pUnkServer->lpVtbl->QueryInterface(pUnkServer, &IID_IUnknown, &pStubBuffer->punkObject);
	}

	return hr;
}

void STDMETHODCALLTYPE 
CStdStubBuffer_Disconnect(IRpcStubBuffer *pThis)
{
	CStdStubBuffer *pStubBuffer;
	long temp;
	int j;
	IUnknown *punkObject;

	assert(pThis);

	pStubBuffer = NdrGetStubBuffer(pThis);
	assert(pStubBuffer);

	punkObject = pStubBuffer->punkObject;

	//Free the interface pointers held by the stub buffer
	if(punkObject)
	{
		for(j = 0;
			pStubBuffer->aInterfaceStub[j].lpVtbl;
			j++)
		{
			temp = InterlockedExchange((long *) &pStubBuffer->aInterfaceStub[j].pvServerObject, 0);
		
			if(temp)
				punkObject->lpVtbl->Release(punkObject);
		}
		temp = InterlockedExchange((long *) &pStubBuffer->punkObject, 0);

		if(temp)
			punkObject->lpVtbl->Release(punkObject);
	}
}

HRESULT STDMETHODCALLTYPE 
CStdStubBuffer_Invoke(
	IRpcStubBuffer *pThis,
	RPCOLEMESSAGE *prpcmsg,
	IRpcChannelBuffer *pRpcChannelBuffer)
{
	HRESULT hr = S_OK;
	unsigned char **ppTemp;
	unsigned char *pTemp;
	CInterfaceStubVtbl *pStubVtbl;
	CInterfaceStub *pInterfaceStub;
	DWORD dwExceptionCode;

	assert(pThis);
	assert(prpcmsg);
	assert(pRpcChannelBuffer);

	pInterfaceStub = (CInterfaceStub *) pThis;

	//Get a pointer to the stub vtbl.
	ppTemp = (unsigned char **) pThis;
	pTemp = *ppTemp;
	pTemp -= sizeof(CInterfaceStubHeader);
	pStubVtbl = (CInterfaceStubVtbl *) pTemp;

	__try
	{	
		//Check the data rep

		//Check if we are connected to the server object.
		if(pInterfaceStub->pvServerObject == 0)
		{
			CStdStubBuffer *pStubBuffer = NdrGetStubBuffer(pThis);

			assert(pStubBuffer);

			if(pStubBuffer->punkObject)
			{
				const IID *piid = NdrGetStubIID(pThis);

				assert(piid);

				hr = pStubBuffer->punkObject->lpVtbl->QueryInterface(pStubBuffer->punkObject, piid, &pInterfaceStub->pvServerObject);
				if(FAILED(hr))
				{
					SetLastError(hr);
					RpcRaiseException(RPC_E_FAULT);
				}
			}
			else
			{
				//We are not connected to the server object.
				SetLastError((unsigned long) CO_E_OBJNOTCONNECTED);
				RpcRaiseException(RPC_E_FAULT);
			}
		}

		//Check if procnum is valid.
		if(prpcmsg->iMethod >= pStubVtbl->header.DispatchTableCount)
			RpcRaiseException(RPC_S_PROCNUM_OUT_OF_RANGE);

		(*pStubVtbl->header.pDispatchTable[prpcmsg->iMethod])(
			pRpcChannelBuffer, 
			(PRPC_MESSAGE) prpcmsg, 
			pInterfaceStub->pvServerObject);
	}
	except(EXCEPTION_EXECUTE_HANDLER)
	{
		dwExceptionCode = GetExceptionCode();

		switch(dwExceptionCode)
		{
		case RPC_E_FAULT:
			hr = GetLastError();
			break;
		case RPC_E_SERVERFAULT:
			//Pass the server's exception to the channel.
			dwExceptionCode = GetLastError();
			RpcRaiseException(dwExceptionCode);
			break;
		default:
			//Assume this is a win32 error code.
			hr = HRESULT_FROM_WIN32(dwExceptionCode);
			break;
		}
	}

	return hr;
}

IRpcStubBuffer * STDMETHODCALLTYPE 
CStdStubBuffer_IsIIDSupported(IRpcStubBuffer *pThis, REFIID riid)
{
	int j;
	CStdStubBuffer *pStubBuffer;
	IRpcStubBuffer *pInterfaceStub = 0;
	const IID *pIID;

	assert(pThis);
	assert(riid);
	
	pStubBuffer = NdrGetStubBuffer(pThis);
	assert(pStubBuffer);

	//Search the interface stubs in the stub buffer
	for(j = 0;
		pStubBuffer->aInterfaceStub[j].lpVtbl && !pInterfaceStub;
		j++)
	{
		pIID = NdrGetStubIID(&pStubBuffer->aInterfaceStub[j].lpVtbl);
		assert(pIID);
			
		if(memcmp(riid, pIID, sizeof(IID)) == 0)
		{
			//We found the interface!
			if(pStubBuffer->aInterfaceStub[j].pvServerObject == 0)
			{
				//Check if the server object supports the interface.
				if(pStubBuffer->punkObject)
				{
					pStubBuffer->punkObject->lpVtbl->QueryInterface(
						pStubBuffer->punkObject, 
						riid, 
						&pStubBuffer->aInterfaceStub[j].pvServerObject);
				}
			}

			if(pStubBuffer->aInterfaceStub[j].pvServerObject)
			{
				pInterfaceStub = (IRpcStubBuffer *)&pStubBuffer->aInterfaceStub[j].lpVtbl;
				pInterfaceStub->lpVtbl->AddRef(pInterfaceStub);
			}
		}
	}

	return pInterfaceStub;
}

ULONG 	STDMETHODCALLTYPE 
CStdStubBuffer_CountRefs(IRpcStubBuffer *pThis)
{
	ULONG count = 0;
	int j;
	CStdStubBuffer *pStubBuffer;

	assert(pThis);
	
	pStubBuffer = NdrGetStubBuffer(pThis);
	assert(pStubBuffer);

	if(pStubBuffer->punkObject != 0)
		count++;

	//Search the interface stubs in the stub buffer
	for(j = 0;
		pStubBuffer->aInterfaceStub[j].lpVtbl;
		j++)
	{
		//We found the interface!
		if(pStubBuffer->aInterfaceStub[j].pvServerObject != 0)
			count++;
	}

	return count;
}

HRESULT STDMETHODCALLTYPE 
CStdStubBuffer_DebugServerQueryInterface(IRpcStubBuffer *pThis, void **ppv)
{
	HRESULT hr = E_UNEXPECTED;

	assert(pThis);
	assert(ppv);

	*ppv = ((CInterfaceStub *)pThis)->pvServerObject;
	if(*ppv)
		hr = S_OK;

	return hr;
}

void STDMETHODCALLTYPE 
CStdStubBuffer_DebugServerRelease(IRpcStubBuffer *pthis, void *pv)
{
}

//+-------------------------------------------------------------------------
//
//  Method:     IUnknown_QueryInterface_Proxy
//
//  Synopsis:   Implementation of QueryInterface for interface proxy.
//
//--------------------------------------------------------------------------
HRESULT __stdcall 
IUnknown_QueryInterface_Proxy(
	IUnknown *pThis,
	REFIID riid, 
	void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
	CStdProxyBuffer *pProxyBuffer = NdrGetProxyBuffer(pThis);

	assert(pProxyBuffer);

	hr = pProxyBuffer->punkOuter->lpVtbl->QueryInterface(pProxyBuffer->punkOuter, riid, ppv);

    return hr;
};

//+-------------------------------------------------------------------------
//
//  Method:     IUnknown_AddRef_Proxy
//
//  Synopsis:   Implementation of AddRef for interface proxy.
//
//--------------------------------------------------------------------------
ULONG __stdcall 
IUnknown_AddRef_Proxy(IUnknown *pThis)
{
	CStdProxyBuffer *pProxyBuffer = NdrGetProxyBuffer(pThis);
	ULONG count;


	count = pProxyBuffer->punkOuter->lpVtbl->AddRef(pProxyBuffer->punkOuter);

    return count;
};

//+-------------------------------------------------------------------------
//
//  Method:     IUnknown_Release_Proxy
//
//  Synopsis:   Implementation of Release for interface proxy.
//
//--------------------------------------------------------------------------
ULONG __stdcall 
IUnknown_Release_Proxy(IUnknown *pThis)
{
	CStdProxyBuffer *pProxyBuffer = NdrGetProxyBuffer(pThis);
	ULONG count;

	count = pProxyBuffer->punkOuter->lpVtbl->Release(pProxyBuffer->punkOuter);

    return count;
};

void __RPC_STUB
IUnknown_QueryInterface_Stub(
    IRpcChannelBuffer * _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    void * _pvServerObject )
{
}

void __RPC_STUB
IUnknown_AddRef_Stub(
    IRpcChannelBuffer * _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    void * _pvServerObject )
{
}

void __RPC_STUB
IUnknown_Release_Stub(
    IRpcChannelBuffer * _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    void * _pvServerObject )
{
}

//+-------------------------------------------------------------------------
//
//  Function:	MIDL_user_allocate
//
//  Synopsis:   Allocate memory via OLE task allocator.
//
//--------------------------------------------------------------------------
void * __stdcall MIDL_user_allocate(size_t size)
{
	void *pMemory;
	
	pMemory = CoTaskMemAlloc(size);

	if(0 == pMemory)
	{
		SetLastError((unsigned long) E_OUTOFMEMORY);
		RpcRaiseException(RPC_E_FAULT);
	}

	return pMemory;
}

//+-------------------------------------------------------------------------
//
//  Function:	MIDL_user_free
//
//  Synopsis:   Free memory using OLE task allocator.
//
//--------------------------------------------------------------------------
void __stdcall MIDL_user_free(void *pMemory)
{
	CoTaskMemFree(pMemory);
}

#endif // !defined(__RPC_DOS__) && !defined(__RPC_WIN16__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\common\command.c ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    Command.c

Abstract:

    Command line parse for RPC perf tests.

Author:

    Mario Goertzel (mariogo)   29-Mar-1994

Revision History:

--*/

#include <rpcperf.h>

char         *Endpoint     = 0;
char         *Protseq      = "ncacn_np";
char         *NetworkAddr  = 0;
unsigned long Iterations   = 1000;
unsigned long Interval     = 15; // seconds 
unsigned int  MinThreads   = 3;
char         *AuthnLevelStr= "none";
unsigned long AuthnLevel   = RPC_C_AUTHN_LEVEL_NONE;
long          Options[7];
char         *LogFileName  = 0;
unsigned int  OutputLevel  = 1;  // 1 - normal, 2 - trace, 3 - debug, other - invalid.
int           AppendOnly   = 0;
RPC_NOTIFICATION_TYPES NotificationType = RpcNotificationTypeEvent;
unsigned long ulSecurityPackage;
char         *ServerPrincipalName = NULL;

extern char  *USAGE;  // defined by each test, maybe NULL.

const char   *STANDARD_USAGE = "Standard Test Options:"
                               "           -e <endpoint>\n"
                               "           -s <server addr>\n"
                               "           -t <protseq>\n"
                               "           -i <# iterations>\n"
                               "           -l <log filename>\n"
                               "           -m <# min threads>\n"
                               "           -n <test options>\n"
                               "           -a <authn level>\n"
                               "           -r # - report results interval (scale tests)\n"
                               "           -y - turn on yielding in win16"
                               "           -v 1 - verbose outout"
                               "           -v 2 - trace output"
                               "           -w(e)vent|(a)pc|(n)one|(h)wnd|(c)allback\n"
                               "           -p appends to existing log (don't delete old one)\n"
                               "           -u <security_package_id>\n"
                               "           -N <server_principal_name>\n"
                               ;

void ParseArgv(int argc, char **argv)
{
    int fMissingParm = 0;
    char *Name = *argv;
    char option;
    int  options_count;

    for(options_count = 0; options_count < 7; options_count++)
        Options[options_count] = -1;

    options_count = 0;

    argc--;
    argv++;
    while(argc)
        {
        if (**argv != '/' &&
            **argv != '-')
            {
            printf("Invalid switch: %s\n", *argv);
            argc--;
            argv++;
            }
        else
            {
            option = argv[0][1];
            argc--;
            argv++;

            // Most switches require a second command line arg.
            if (argc < 1)
                fMissingParm = 1;

            switch(option)
                {
                case 'e':
                    Endpoint = *argv;
                    argc--;
                    argv++;
                    break;
                case 't':
                    Protseq = *argv;
                    argc--;
                    argv++;
                    break;
                case 's':
                    NetworkAddr = *argv;
                    argc--;
                    argv++;
                    break;
                case 'i':
                    Iterations = atoi(*argv);
                    argc--;
                    argv++;
                    if (Iterations == 0)
                        Iterations = 1000;
                    break;
                case 'm':
                    MinThreads = atoi(*argv);
                    argc--;
                    argv++;
                    if (MinThreads == 0)
                        MinThreads = 1;
                    break;
                case 'a':
                    AuthnLevelStr = *argv;
                    argc--;
                    argv++;
                    break;
                case 'N':
                    ServerPrincipalName = *argv;
                    argc--;
                    argv++;
                    break;
                case 'n':
                    if (options_count < 7)
                        {
                        Options[options_count] = atoi(*argv);
                        options_count++;
                        }
                    else
                        printf("Maximum of seven -n switchs, extra ignored.\n");
                    argc--;
                    argv++;
                    break;
                case 'r':
                    Interval = atoi(*argv);
                    argc--;
                    argv++;
                    break;
                case 'u':
                    ulSecurityPackage = atoi(*argv);
                    argc--;
                    argv++;
                    break;
                case 'l':
                    LogFileName = *argv;
                    argc--;
                    argv++;
                    break;
                case 'v':
                    OutputLevel = atoi(*argv);
                    argc--;
                    argv++;
                    break;
                case 'w':
                    switch(**argv)
                        {
                        case 'e':
                            NotificationType = RpcNotificationTypeEvent;
                            break;

                        case 'a':
                            NotificationType = RpcNotificationTypeApc;
                            break;

                        case 'n':
                            NotificationType = RpcNotificationTypeNone;
                            break;

                        case 'h':
                            NotificationType = RpcNotificationTypeHwnd;
                            break;

                        case 'c':
                            NotificationType = RpcNotificationTypeCallback;
                            break;

                        default:
                            printf("Invalid wait method: '%c'.\n", *argv);
                            return;

                        }
                    argc--;
                    argv++;
                    break;
#ifdef __RPC_WIN16__
                case 'y':
                    RpcWinSetYieldInfo(0, FALSE, 0, 0);
                    fMissingParm = 0;
                    break;
#endif
                case 'p':
                    AppendOnly = TRUE;
                    fMissingParm = 0;
                    break;

                default:
                    fMissingParm = 0;
                    printf("Usage: %s: %s\n", Name, (USAGE == 0)?STANDARD_USAGE:USAGE);
                    exit(0);
                    break;
                }

            if (fMissingParm)
                {
                printf("Invalid switch %s, missing required parameter\n", *argv);
                }
            }
        } // while argc

    // determine the security level
    if (strcmp("none", AuthnLevelStr) == 0)
        AuthnLevel = RPC_C_AUTHN_LEVEL_NONE;
    else if (strcmp("connect", AuthnLevelStr) == 0)
        AuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
    else if (strcmp("call", AuthnLevelStr) == 0)
        AuthnLevel = RPC_C_AUTHN_LEVEL_CALL;
    else if (strcmp("pkt", AuthnLevelStr) == 0)
        AuthnLevel = RPC_C_AUTHN_LEVEL_PKT;
    else if (strcmp("integrity", AuthnLevelStr) == 0)
        AuthnLevel = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
    else if (strcmp("privacy", AuthnLevelStr) == 0)
        AuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
    else
        {
        printf("%s is NOT a valid authentication level, default is NONE\n", AuthnLevelStr);
        }
#if 0
    printf("Config: %s:%s[%s]\n"
           "Iterations: %d\n"
           "Server threads %d\n"
           "Options: %d %d %d\n",
           Protseq, NetworkAddr, Endpoint, Iterations, MinThreads,
           Options[0], Options[1], Options[2]);
#endif

#ifdef WIN32
    printf("Process ID: %d\n", GetCurrentProcessId());
#else
#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\common\sources.inc ===
!IF 0

Copyright (c) 1994  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Revision History:

!ENDIF

TARGETNAME=rpcperf
TARGETTYPE=LIBRARY
TARGETPATH=..\..\lib

INCLUDES=..;..\..\inc

SOURCES=             \
        ..\io.c         \
        ..\command.c    \
        ..\system.c     \
	..\async.c

C_DEFINES=$(RPCENV)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\common\async.c ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    Async.c

Abstract:

    Some common routines for the Async tests.

Author:

    Kamen Moutafov (kamenm)   20-Apr-1998

Revision History:

--*/

#include <rpcperf.h>

unsigned int RPC_ENTRY WindowProc(IN void * hWnd, IN unsigned int Message,
                        IN unsigned int wParam, IN unsigned long lParam)
{
    LRESULT Res = 0;
    if (Message == PERF_TEST_NOTIFY)
        {
        // no-op
        }
    else
        {
        Res = DefWindowProc((HWND)hWnd, Message, wParam, lParam);
        }
    return (unsigned int)Res;
}

void RunMessageLoop(HWND hWnd)
{
    MSG msg;
    UINT nTimerID = 1;
    SetTimer(hWnd, nTimerID, 5000, NULL);

    // run the message loop
    while (GetMessage(&msg, 0, 0, 0))
        {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }

    KillTimer(hWnd, nTimerID);
}

void PumpMessage(void)
{
    MSG msg;

    GetMessage(&msg, NULL, 0, 0);
    TranslateMessage(&msg);
    DispatchMessage(&msg);
}

HWND CreateSTAWindow(char *lpszWinName)
{
    HWND hWnd;
    WNDCLASSA wc;
    DWORD dwCurProcessId;
    char WNDCLASSNAME[100];

    dwCurProcessId = GetCurrentProcessId();

    wsprintfA(WNDCLASSNAME, "Windows WMSG BVT %lx", dwCurProcessId);

    if (GetClassInfoA(GetModuleHandle(NULL), WNDCLASSNAME, &wc) == FALSE)
    {
        DWORD dwError;
        dwError = GetLastError();

        wc.style = 0;
        wc.lpfnWndProc = (WNDPROC) WindowProc;
        wc.cbWndExtra = 4;
        wc.cbClsExtra = 0;
        wc.hInstance = GetModuleHandle(NULL);
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = NULL;
        wc.lpszMenuName = NULL;
        wc.lpszClassName = WNDCLASSNAME;

        if (RegisterClassA(&wc) == 0)
        {
            return (NULL);
        }
    }

    // Create hidden window to receive RPC messages
    hWnd = CreateWindowExA(WS_EX_NOPARENTNOTIFY,
                           WNDCLASSNAME,
                           "temp",
                           WS_OVERLAPPEDWINDOW | WS_CHILD | WS_POPUP,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           GetDesktopWindow(),
                           (HMENU)NULL,
                           GetModuleHandle(NULL),
                           (LPVOID)0);

    SetWindowLongPtr(hWnd, GWLP_USERDATA, (long)GetCurrentThreadId());
    SetWindowTextA(hWnd, lpszWinName);
    return (hWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\common\io.c ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    io.c

Abstract:

    Input/Output functions for RPC development performance tests.

Author:

    Mario Goertzel (mariogo)   29-Mar-1994

Revision History:

--*/

#include <rpcperf.h>
#include <stdarg.h>

void PauseForUser(char *string)
{
    char buffer[80];

    printf("%s\n<return to continue>\n", string);
    fflush(stdout);
    gets(buffer);
    return;
}

static FILE *LogFile = 0;
static char buffer[1024];

void DumpCommon(char *Format, va_list Marker)
{
    // Are we logging to a file?
    if (LogFileName)
        {

        // Have we opened to log file yet?
        if (!LogFile)
            {
            if (AppendOnly)
                LogFile = fopen(LogFileName, "a");
            else
                LogFile = fopen(LogFileName, "w");

            if (!LogFile)
                {
                fprintf(stderr, "Unable to open log file: %s\n", LogFileName);
                exit(-1);
                }
            }

        vfprintf(LogFile, Format, Marker);
        fflush(LogFile);
        }

#ifndef WIN
    vfprintf(stdout, Format, Marker);
#else
    {
    // Hack for Windows STDIO emulator
    char buffer[256];

    vsprintf(buffer, Format, Marker);

    #undef printf
    printf(buffer);
    }
#endif
}

void Dump(char *Format, ...)
{
    va_list Marker;

    va_start(Marker, Format);

    DumpCommon(Format, Marker);

    va_end(Marker);
}

void Verbose(char *Format, ...)
{
    if (OutputLevel > 1)
        {
        va_list Marker;

        va_start(Marker, Format);

        DumpCommon(Format, Marker);

        va_end(Marker);
        }
}

void Trace(char *Format, ...)
{
    if (OutputLevel > 2)
        {
        va_list Marker;

        va_start(Marker, Format);

        DumpCommon(Format, Marker);

        va_end(Marker);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\common\system.c ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    system.c

Abstract:

    System functionality used by the RPC development performance tests.

Author:

    Mario Goertzel (mariogo)   29-Mar-1994

Revision History:

--*/

#include<rpcperf.h>

#ifndef WIN32
#include<time.h>
#include<malloc.h>
#endif

#ifdef WIN32
void FlushProcessWorkingSet()
{
    SetProcessWorkingSetSize(GetCurrentProcess(), ~0UL, ~0UL);
    return;
}
#endif

#ifdef WIN32
LARGE_INTEGER _StartTime;
#else
clock_t _StartTime;
#endif

void StartTime(void)
{
#ifdef WIN32
    QueryPerformanceCounter(&_StartTime);
#else
    _StartTime = clock();
#endif

    return;
}

void EndTime(char *string)
{
    unsigned long mseconds;

    mseconds = FinishTiming();

    printf("Time %s:   %d.%03d\n",
           string,
           mseconds / 1000,
           mseconds % 1000);
    return;
}

// Returns milliseconds since last call to StartTime();

unsigned long FinishTiming()
{
#ifdef WIN32
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liFreq;

    QueryPerformanceCounter(&liDiff);

    liDiff.QuadPart -= _StartTime.QuadPart;

    (void)QueryPerformanceFrequency(&liFreq);

    return (ULONG)(liDiff.QuadPart / (liFreq.QuadPart / 1000));
#else
    unsigned long Diff = clock() - _StartTime;
    if (Diff)
        return( ( (Diff / CLOCKS_PER_SEC) * 1000 ) +
                ( ( (Diff % CLOCKS_PER_SEC) * 1000) / CLOCKS_PER_SEC) );
    else
        return(0);
#endif
}

#ifndef MAC

int TlsIndex = 0;

HANDLE ProcessHeap = 0;

typedef struct tagThreadAllocatorStorage
{
    size_t CachedSize;
    PVOID CachedBlock;
    BOOLEAN BlockAvailable;
} ThreadAllocatorStorage;

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t size)
{
    ThreadAllocatorStorage *ThreadLocalStorage = (ThreadAllocatorStorage *) TlsGetValue(TlsIndex);
    if (ThreadLocalStorage != NULL)
        {
        if (ThreadLocalStorage->BlockAvailable)
            {
            if (size <= ThreadLocalStorage->CachedSize)
                {
                // found a block in the cache - use it
                ThreadLocalStorage->BlockAvailable = FALSE;
                return ThreadLocalStorage->CachedBlock;
                }
            else
                {
                // free the old block, and fall through to allocate the new block
                RtlFreeHeap(ProcessHeap, 0, ThreadLocalStorage->CachedBlock);
                memset(ThreadLocalStorage, 0, sizeof(ThreadAllocatorStorage));
                }
            }
        }
    else
        {
        ThreadLocalStorage = (ThreadAllocatorStorage *) HeapAlloc(ProcessHeap, 0, sizeof(ThreadAllocatorStorage));
        memset(ThreadLocalStorage, 0, sizeof(ThreadAllocatorStorage));
        TlsSetValue(TlsIndex, ThreadLocalStorage);
        }
    ThreadLocalStorage->CachedBlock = HeapAlloc(ProcessHeap, 0, size);
    ThreadLocalStorage->CachedSize = size;
    ThreadLocalStorage->BlockAvailable = FALSE;
    return ThreadLocalStorage->CachedBlock;
}

void __RPC_USER MIDL_user_free(void __RPC_FAR * p)
{
    ThreadAllocatorStorage *ThreadLocalStorage = (ThreadAllocatorStorage *) TlsGetValue(TlsIndex);
    if (ThreadLocalStorage->BlockAvailable)
        {
        // free the old block, and store the new one
        RtlFreeHeap(ProcessHeap, 0, ThreadLocalStorage->CachedBlock);
        ThreadLocalStorage->CachedBlock = p;
        ThreadLocalStorage->CachedSize = RtlSizeHeap(ProcessHeap, 0, p);
        ThreadLocalStorage->BlockAvailable = TRUE;
        return;
        }
    else if (ThreadLocalStorage->CachedBlock != p)
        {
        // the block is not available, but it is different
        // don't free the old block, but replace it in the cache with the new
        ThreadLocalStorage->CachedBlock = p;
        ThreadLocalStorage->CachedSize = RtlSizeHeap(ProcessHeap, 0, p);
        ThreadLocalStorage->BlockAvailable = TRUE;
        return;
        }
    else
        {
        // the block in the cache is not available, and it is the same as this one
        // just update the cache
        ThreadLocalStorage->BlockAvailable = TRUE;
        return;
        }
}

#endif

void ApiError(char *string, unsigned long status)
{
    printf("%s failed - %lu (%08lX)\n", string, status, status);
    exit((int)status);
}

void InitAllocator(void)
{
    ProcessHeap = GetProcessHeap();

    TlsIndex = TlsAlloc();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\context\context.c ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    context.c

Abstract:

    Performance test comparing different methods of context switching
    on NT.  The tests process-to-process and thread-to-thread context
    switching.  This code acts as both a client and a server.

Author:

    Mario Goertzel (mariogo)   30-Mar-1994

Revision History:

--*/

#include <rpcperf.h>

static const char *REQUEST_EVENT  = "Context Switch Perf Request Event";
static const char *REQUEST_EVENT2 = "Context Switch Perf Request Event #2";
static const char *REPLY_EVENT    = "Context Switch Perf Reply Event";
static const char *EVENT_PAIR     = "\\RPC Control\\Perf Test: EventPair";

const char *USAGE="-n type -n case\n"
               "    Types:\n"
               "     1: Client and server (thread-to-thread context switches)\n"
               "     2: Server side of test (process-to-process)\n"
               "     3: Client side of test (process-to-process)\n"
               "    Cases:\n"
               "     1: Use NT eventpairs\n"
               "     2: Use NT eventpairs (two step client)\n"
               "     3: Use SetEvent/WaitForSingleObject\n"
               "     4: Use SetEvent/WaitForSingleObject with timeout\n"
               "     5: Use SetEvent/WaitForMultipleObjects\n"
               "     6: Use SetEvent/WaitForMultipleObjects with timeout\n"
               "     7: Use SignalObjectAndWait on events\n"
               "     8: Use SignalObjectAndWait on events w/ timeout\n"
               ;


//
// The Server function is the server of the test.  The client
// maybe in the process, or another process, nobody knows...
//

ULONG Server(ULONG arg)
{
    ULONG status;
    ULONG i;

    switch(Options[1])
        {
        case 1:
        case 2:
            {
            // NT event pairs

            OBJECT_ATTRIBUTES oaEventPair;
            ANSI_STRING       ansiEventPairName;
            UNICODE_STRING    unicodeEventPairName;
            HANDLE            hEventPair;

            RtlInitAnsiString(&ansiEventPairName, EVENT_PAIR);
            
            RtlAnsiStringToUnicodeString(&unicodeEventPairName,
                                         &ansiEventPairName,
                                         TRUE);
            
            InitializeObjectAttributes(&oaEventPair,
                                       &unicodeEventPairName,
                                       OBJ_CASE_INSENSITIVE,
                                       0,
                                       0);
            
            status = NtCreateEventPair(&hEventPair,
                                       EVENT_PAIR_ALL_ACCESS,
                                       &oaEventPair);
            
            if (!NT_SUCCESS(status))
                {
                printf("NtCreateEventPair failed -- %8lX\n", status);
                return 1;
                }

            for(;;)
                {
                status = NtSetLowWaitHighEventPair(hEventPair);
                if (!NT_SUCCESS(status))
                    {
                    printf("NtSetLowWaitHighEventPair failed - %08lX\n",
                           status);
                    return(1);
                    }
                }
            break;
            }
        case 3:
        case 4:
            {
            // Win32 events (w/ or w/o a timeout)

            ULONG timeout = (Options[1] == 3)?INFINITE:2000;
            HANDLE hEvent1, hEvent2;

            hEvent1 = CreateEvent(0,
                                  FALSE,
                                  FALSE,
                                  REQUEST_EVENT);

            hEvent2 = CreateEvent(0,
                                  FALSE,
                                  FALSE,
                                  REPLY_EVENT);

            if ( (hEvent1 == 0) || (hEvent2 == 0))
                {
                printf("CreateEvent failed - %08x\n", GetLastError());
                exit(1);
                }
            for(;;)
                {

                // Wait for clients request

                status = WaitForSingleObject(hEvent1, timeout);

                if (status != WAIT_OBJECT_0)
                    {
                    printf("Server WaitForSingleObject failed -- %08x\n", GetLastError());
                    return 1;
                    }

                // Reply

                status = SetEvent(hEvent2);

                if (status == 0)
                    {
                    printf("SetEvent failed - %08x\n", GetLastError());
                    exit(1);
                    }
                }
            CloseHandle(hEvent1);
            CloseHandle(hEvent2);
            break;
            }

        case 5:
        case 6:
            {
            // WaitForMultipleObjects/SetEvent w/ and w/o timeouts.

            ULONG timeout = (Options[1] == 5)?INFINITE:2000;
            ULONG  cCount = 2;
            HANDLE ahEvents[2];
            HANDLE hReplyEvent;

            ahEvents[0] = CreateEvent(0,
                                      FALSE,
                                      FALSE,
                                      REQUEST_EVENT);

            ahEvents[1] = CreateEvent(0,
                                      FALSE,
                                      FALSE,
                                      REQUEST_EVENT2);

            hReplyEvent =  CreateEvent(0,
                                      FALSE,
                                      FALSE,
                                      REPLY_EVENT);

            if ( (ahEvents[0] == 0) || (ahEvents[1] == 0) || (hReplyEvent == 0))
                {
                printf("CreateEvent failed - %08x\n", GetLastError());
                exit(1);
                }
            for(;;)
                {

                // Wait for clients request

                status = WaitForMultipleObjects(cCount, ahEvents, FALSE, timeout);

                if (status != WAIT_OBJECT_0)
                    {
                    printf("Server WaitForMultpleObjects failed -- %08x\n", GetLastError());
                    return 1;
                    }

                // Reply

                status = SetEvent(hReplyEvent);

                if (status == 0)
                    {
                    printf("SetEvent failed - %08x\n", GetLastError());
                    exit(1);
                    }
                }
            CloseHandle(ahEvents[0]);
            CloseHandle(ahEvents[1]);
            CloseHandle(hReplyEvent);
            break;
            }

        case 7:
        case 8:
            {
            ULONG timeout = (Options[1] == 7)?INFINITE:2000;
            HANDLE hEvent1, hEvent2;

            hEvent1 = CreateEvent(0,
                                  FALSE,
                                  FALSE,
                                  REQUEST_EVENT);

            hEvent2 = CreateEvent(0,
                                  FALSE,
                                  FALSE,
                                  REPLY_EVENT);

            if ( (hEvent1 == 0) || (hEvent2 == 0))
                {
                printf("CreateEvent failed - %08x\n", GetLastError());
                exit(1);
                }

            status = WaitForSingleObject(hEvent1, INFINITE);
            if (status != WAIT_OBJECT_0)
                {
                printf("Server WaitForSingleObject failed == %08x\n", GetLastError());
                }

            for(;;)
                {

                // Wait for clients request

                status = SignalObjectAndWait(hEvent2, hEvent1, timeout, FALSE);

                if (status != WAIT_OBJECT_0)
                    {
                    printf("Server SignalObjectAndWait failed -- %08x\n", GetLastError());
                    return 1;
                    }
                }
            CloseHandle(hEvent1);
            CloseHandle(hEvent2);
            break;
            }

        }
    return 0;
}

int __cdecl
main(int argc, char **argv)
{
    ULONG i;
    HANDLE hServer;
    ULONG status;


    ParseArgv(argc, argv);

    if ( (Options[0] < 0)
         || (Options[0] > 3)
         || (Options[1] < 0)
         || (Options[1] > 8) )
        {
        printf("Usage: %s : %s\n",
               argv[0],
               USAGE);

        return 1;
        }

    if (Options[0] == 2)
        {
        // Server only - run server.
        return Server(0);
        }

    if (Options[0] == 1)
        {
        // Both client and server, start server thread

        hServer = CreateThread(0,
                               0,
                               (LPTHREAD_START_ROUTINE)Server,
                               0,
                               0,
                               &i);
        if (hServer == 0)
            {
            printf("Create thread failed - %08x\n", GetLastError());
            return 1;
            }

        Sleep(500);  // Let the server startup
        }

    // Run client side

    switch(Options[1])
        {
        case 1:
        case 2:
            {
            // NT event pairs

            OBJECT_ATTRIBUTES oaEventPair;
            ANSI_STRING       ansiEventPairName;
            UNICODE_STRING    unicodeEventPairName;
            HANDLE            hEventPair;
            char *            string =(Options[1]==1)?"eventpair":"eventpair (client set and wait)";

            RtlInitAnsiString(&ansiEventPairName, EVENT_PAIR);
            
            RtlAnsiStringToUnicodeString(&unicodeEventPairName,
                                         &ansiEventPairName,
                                         TRUE);
            
            
            InitializeObjectAttributes(&oaEventPair,
                                       &unicodeEventPairName,
                                       OBJ_CASE_INSENSITIVE,
                                       0,
                                       0);
            
            status = NtOpenEventPair(&hEventPair,
                                     EVENT_PAIR_ALL_ACCESS,
                                     &oaEventPair);
            
            if (!NT_SUCCESS(status))
                {
                printf("NtOpenEventPair failed -- %8lX\n", status);
                return 1;
                }

            StartTime();
            if (Options[1] == 1)
                {
                for(i = 0; i < Iterations; i++)
                    {
                    NtSetHighWaitLowEventPair(hEventPair);
                    }
                }
            else
                {
                for(i = 0; i < Iterations; i++)
                    {
                    NtSetHighEventPair(hEventPair);
                    NtWaitLowEventPair(hEventPair);
                    }
                }
            EndTime(string);

            break;
            }
        case 3:
        case 4:
        case 5:
        case 6:
            {
            // Win32 events (w/ or w/o a timeout, WSO, WMO)

            ULONG timeout;
            char *string;
            HANDLE hEvent1, hEvent2;

            if ( (Options[1] == 4) || Options[1] == 6)
                timeout = 2000;
            else
                timeout = INFINITE;

            switch(Options[1])
                {
                case 3:
                    string = "SetEvent/WaitForSingleObject";
                    break;
                case 4:
                    string = "SetEvent/WaitForSingleObject with timeout";
                    break;
                case 5:
                    string = "SetEvent/WaitForMultpleObjects";
                    break;
                case 6:
                    string = "SetEvent/WaitForMultipleObjects with timeout";
                    break;
                }


            hEvent1 = CreateEvent(0,
                                  FALSE,
                                  FALSE,
                                  REQUEST_EVENT);

            hEvent2 = CreateEvent(0,
                                  FALSE,
                                  FALSE,
                                  REPLY_EVENT);

            if ( (hEvent1 == 0) || (hEvent2 == 0))
                {
                printf("CreateEvent failed - %08x\n", GetLastError());
                return 1;
                }

            StartTime();
            for(i = 0; i < Iterations; i++)
                {

                status = SetEvent(hEvent1);

                if (status == 0)
                    {
                    printf("SetEvent failed - %08x\n", GetLastError());
                    return 1;
                    }

                status = WaitForSingleObject(hEvent2, timeout);

                if (status != WAIT_OBJECT_0)
                    {
                    printf("WaitForSingleObejct failed -- %08x\n", GetLastError());
                    return 1;
                    }
                }
            EndTime(string);

            CloseHandle(hEvent1);
            CloseHandle(hEvent2);
            break;
            }

        case 7:
        case 8:
            {
            // Win32 events (w/ or w/o a timeout) and SignalObjectAndWait()

            ULONG timeout;
            char *string;
            HANDLE hEvent1, hEvent2;

            if ( (Options[1] == 8) )
                timeout = 2000;
            else
                timeout = INFINITE;

            switch(Options[1])
                {
                case 7:
                    string = "SignalObjectAndWait";
                    break;
                case 8:
                    string = "SignalObjectAndWait with timeout";
                    break;
                }


            hEvent1 = CreateEvent(0,
                                  FALSE,
                                  FALSE,
                                  REQUEST_EVENT);

            hEvent2 = CreateEvent(0,
                                  FALSE,
                                  FALSE,
                                  REPLY_EVENT);

            if ( (hEvent1 == 0) || (hEvent2 == 0))
                {
                printf("CreateEvent failed - %08x\n", GetLastError());
                return 1;
                }

            StartTime();
            for(i = 0; i < Iterations; i++)
                {
                status = SignalObjectAndWait(hEvent1, hEvent2, timeout, FALSE);

                if (status != WAIT_OBJECT_0)
                    {
                    printf("SignalObjectAndWait failed -- %08x\n", GetLastError());
                    return 1;
                    }
                }
            EndTime(string);

            CloseHandle(hEvent1);
            CloseHandle(hEvent2);
            break;
            }

        }   

    // Blow off the server thread.

    return 0; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\datatran\dtcommon.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999
    
Module Name:
    DTCommon.h

Abstract:
    Common stuff for the Data Tranfer tests

Author:
    Brian Wong (t-bwong)    27-Mar-96

Revision History:

--*/

#ifndef _DTCOMMON_H
#define _DTCOMMON_H

extern const char *szFormatCantOpenTempFile;
extern const char *szFormatCantOpenServFile;

void PrintSysErrorStringA (DWORD dwWinErrCode);

BOOL CreateTempFile (LPCTSTR pszPath,
                     LPCTSTR pszPrefix,
                     DWORD   ulLength,
                     LPTSTR  pszFileName);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\datatran\dtcommon.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999
    
Module Name:
    DTCommon.c

Abstract:
    Common stuff for the Data Tranfer tests

Author:
    Brian Wong (t-bwong)    27-Mar-96

Revision History:

--*/

#include <rpcperf.h>
#include "DTCommon.h"

//
//  Strings
//
const char *szFormatCantOpenTempFile="%s: cannot open %s.\n";
const char *szFormatCantOpenServFile="%s: cannot open file on server.\n";

//---------------------------------------------------------
void PrintSysErrorStringA (DWORD dwWinErrCode)
/*++
Routine Description:
    Given a Win32 error code, print a string
    that describes the error condition.

Arguments:
    dwWinErrCode -  the error code.

Return Value:
    NONE
--*/
{
    const DWORD ulBufLength = 255;
    char        szErrorString[256];

    //
    //  Use the Win32 API FormatMessage().
    //
    if (0 != FormatMessageA (FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             dwWinErrCode,
                             MAKELANGID (LANG_NEUTRAL, SUBLANG_NEUTRAL),
                             szErrorString,
                             ulBufLength,
                             NULL))
        {
        printf(szErrorString);
        }

    return;
}

//---------------------------------------------------------
BOOL CreateTempFile (LPCTSTR pszPath,        //  [in]
                     LPCTSTR pszPrefix,      //  [in]
                     DWORD   ulLength,       //  [in]
                     LPTSTR  pszFileName)    //  [out]
/*++
Routine Description:
    Creates a temporary file.

Arguments:
    pszPath     - the system temp path is used of NULL
    pszPrefix   - the prefix for the temporary file
    ulLength    - the length of the file is set to this value
    pszFileName - where to store the name of the temporary file

Return Value:
    TRUE if successful, FALSE otherwise
--*/
{
    static const char  *szFuncName = "CreateTempFile";
    TCHAR               pTempPath[MAX_PATH];
    HANDLE              hFile;

    //
    //  Use the Win32 API GetTempPath() if a path is not provide.
    //
    if (NULL == pszPath)
        GetTempPath (MAX_PATH, pTempPath);

    //
    //  Note: GetTempFileName() also creates the file.
    //
    if (0 == GetTempFileName ((NULL == pszPath ? pTempPath : pszPath),
                              pszPrefix,
                              0,
                              pszFileName))
        {
        printf("%s: GetTempFileName failed.  %s\n",
               szFuncName);
        PrintSysErrorStringA(GetLastError());
        return FALSE;
        }

    //
    //  If ulLength != 0, we set the temp file to the specified length.
    //
    if (ulLength != 0)
        {
        //
        //  Open the file for writing.
        //
        hFile = CreateFile (pszFileName,
                            GENERIC_WRITE,
                            0,
                            (LPSECURITY_ATTRIBUTES) NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            (HANDLE) NULL
                           );

        if (hFile == INVALID_HANDLE_VALUE)
            {
            printf(szFormatCantOpenTempFile,
                   szFuncName,
                   pszFileName);
            PrintSysErrorStringA(GetLastError());

            DeleteFile(pszFileName);
            return FALSE;
            }

        //
        //  If SEND_BLANKS is defined, then we don't do any pre-initializing
        //  of the files transferred.  Otherwise, we fill the file up with
        //  stuff.  (See below.)
        //
        #ifdef SEND_BLANKS
            if (Length != SetFilePointer (hFile, ulLength, NULL, FILE_BEGIN))
                {
                DWORD dwErrCode = GetLastError();
                printf("%s: %ld.\n",
                       szFuncName,
                       dwErrCode);
                PrintSysErrorStringA(dwErrCode);

                CloseHandle (hFile);
                DeleteFile (pszFileName);

                return FALSE;
                }
            SetEndOfFile(hFile);
        #else   //  ! defined (SEND_BLANKS)
            //
            //  Here we fill the file up with 8-byte blocks of the form
            //  "#######<blank>", where ####### is a descending number
            //  indicating the number of bytes till EOF.  If the length
            //  is not a multiple of 8, then the file is padded with $'s
            //
            {
            long    i;
            DWORD   dwBytesWritten;
            char    pTempString[9];

            for (i = ulLength; i >= 8; i -= 8)
                {
                sprintf(pTempString, "%7ld ",i);
                WriteFile (hFile, pTempString, 8, &dwBytesWritten, NULL);
                }
            if (i > 0)
                {
                WriteFile (hFile, "$$$$$$$", i, &dwBytesWritten, NULL);
                }
            }
        #endif  //  SEND_BLANKS

        CloseHandle(hFile);
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\datatran\client\client.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Client.c

Abstract:

    Client side of Data Transfer test.

Author:

    Brian Wong (t-bwong)   10-Mar-1996

Revision History:

--*/

#include <rpcperf.h>
#include <assert.h>
#include <WinINet.h>

#include <DataTran.h>
#include <DTCommon.h>

//
//  Uncomment this for debugging (to make sure files are sent
//  properly).  Note that under normal circumstances, only
//  the receiver retains the temp file - if A creates a temp
//  file to sends it to B (ie B gets a copy of the file), then after the
//  transfer A deletes its temp file while B keeps its copy.
//
//  If DELETE_TEMP_FILES is defined, then B will also delete its copy
//  of the temp file.
//
#define DELETE_TEMP_FILES

/////////////////////////////////////////////////////////////////////

#ifdef MAC
extern void _cdecl PrintToConsole(const char *lpszFormat, ...) ;
extern unsigned long ulSecurityPackage ;
#else
#define PrintToConsole printf
unsigned long ulSecurityPackage = RPC_C_AUTHN_WINNT ;
#endif

// Usage

const char *USAGE = "-n <threads> -a <authnlevel> -s <server> -t <protseq>\n"
                    "Server controls iterations, test cases, and compiles the results.\n"
                    "AuthnLevel: none, connect, call, pkt, integrity, privacy.\n"
                    "Default threads=1, authnlevel=none\n";

#define CHECK_RET(status, string) if (status)\
        {  PrintToConsole("%s failed -- %lu (0x%08X)\n", string,\
                      (unsigned long)status, (unsigned long)status);\
        return (status); }

static HINTERNET hInternet = NULL;

//
//  Note:   ulBufferSize should be greater than the largest chunk size used.
//
const unsigned long ulBufferSize = 512*1024L;

/////////////////////////////////////////////////////////////////////

RPC_STATUS DoRpcBindingSetAuthInfo(handle_t Binding)
{
    if (AuthnLevel != RPC_C_AUTHN_LEVEL_NONE)
        return RpcBindingSetAuthInfo(Binding,
                                     NULL,
                                     AuthnLevel,
                                     ulSecurityPackage,
                                     NULL,
                                     RPC_C_AUTHZ_NONE);
    else
        return(RPC_S_OK);
}

/********************************************************************
 *                       Test wrappers
 ********************************************************************/

//===================================================================
//  Regular RPC
//===================================================================
unsigned long Do_S_to_C_NBytes (handle_t __RPC_FAR * b,
                                long i,
                                unsigned long Length,
                                unsigned long ChunkSize,
                                char __RPC_FAR *p)
/*++
Routine Description:
    Do_S_to_C_NBytes

Arguments:
    b           - Binding Handle
    i           - number of iterations
    Length      - Length of data to transfer in bytes
    ChunkSize   - Size of the chunks in which data is to be transfered
    Buffer      - the buffer allocated for this Worker thread

Return Value:
   The time it took to perform the test.
--*/
{
    unsigned long   n;
    unsigned long   Time = 0;

    //
    //  Division by zero is evil, make sure this doesn't happen.
    //
    assert( (Length == 0) || (ChunkSize != 0));

    while (i--)
        {
        n = Length;         //  Reset length to send.

        StartTime();        //  Start the timer for this iteration.

        //
        //  Send in complete chunks.
        //
        for (; n > ChunkSize; n -= ChunkSize)
            {
            S_to_C_Buffer(*b, ChunkSize, p);
            }
        //
        //  Send last bit that doesn't fit into a chunk.
        //
        S_to_C_Buffer(*b, n, p);

        Time += FinishTiming();     //  Update total time elapsed.
        }

    return Time;
}

//---------------------------------------------------------
unsigned long Do_C_to_S_NBytes (handle_t __RPC_FAR * b,
                                long i,
                                unsigned long Length,
                                unsigned long ChunkSize,
                                char __RPC_FAR *p)
{
    char __RPC_FAR *pCur;
    unsigned long   n;
    unsigned long   Time = 0;

    assert( (Length == 0) || (ChunkSize != 0));

    StartTime();

    while(i--)
        {
        n = Length;
        pCur = p;

        StartTime();

        for (; n > ChunkSize; n -= ChunkSize, pCur+=ChunkSize)
            {
            C_to_S_Buffer(*b, ChunkSize, pCur);
            }
        C_to_S_Buffer(*b, n, pCur);

        Time += FinishTiming();
        }

    return Time;
}

//---------------------------------------------------------
unsigned long Do_S_to_C_NBytesWithFile (handle_t __RPC_FAR * b,
                                        long i,
                                        unsigned long Length,
                                        unsigned long ChunkSize,
                                        char __RPC_FAR *p)
/*++
Routine Description:
    Get a stream of bytes from the Server and save it to a file.
--*/
{
    static const char  *szFuncName = "Do_S_to_C_NBytesWithFile";
    TCHAR               pFileName[MAX_PATH];
    unsigned long       Time = 0;

    HANDLE              hFile = INVALID_HANDLE_VALUE;
    DT_FILE_HANDLE      hRemoteContext;

    assert( (Length == 0) || (ChunkSize != 0));

    //
    //  Create a temporary file to transfer
    //
    if (FALSE == CreateTempFile (NULL, TEXT("FCR"), 0, pFileName))
        return 0;

    //
    //  Open the temporary file.
    //
    hFile = CreateFile ((LPCTSTR) pFileName,
                        GENERIC_WRITE,
                        0,
                        (LPSECURITY_ATTRIBUTES) NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL
                       );
    if (hFile == INVALID_HANDLE_VALUE)
        {
        printf(szFormatCantOpenTempFile,
               szFuncName,
               pFileName);
        PrintSysErrorStringA(GetLastError());
        return 0;
        }

    //
    //  Get the server to prepare a file to send us.
    //
    if (0 == (hRemoteContext = RemoteOpen(*b, Length)))
        {
        printf(szFormatCantOpenServFile, szFuncName);

        CloseHandle (hFile);
        DeleteFile (pFileName);

        return 0;
        }

    //
    //  The Actual Test
    //
        {
        DWORD   dwBytesRead;
        DWORD   dwBytesWritten;
    
        while(i--)
            {
            SetFilePointer (hFile, 0, NULL, FILE_BEGIN);
            RemoteResetFile (hRemoteContext);

            StartTime();
            do
                {
                //
                //  Assume that the transfer is finished when we receive zero bytes.
                //
                if (0 == (dwBytesRead = S_to_C_BufferWithFile(*b,
                                                              hRemoteContext,
                                                              ChunkSize,
                                                              p)))
                    {
                    break;
                    }

                WriteFile(hFile, p, dwBytesRead, &dwBytesWritten, NULL);
                } while (dwBytesRead == ChunkSize);

            Time += FinishTiming();
            }
        }

    //
    //  Clean Up
    //
    RemoteClose(&hRemoteContext, TRUE); //  Close and delete remote file
    CloseHandle(hFile);                 //  Close local temp file

#ifdef DELETE_TEMP_FILES
    DeleteFile (pFileName);
#endif

    return (Time);
}

//---------------------------------------------------------
unsigned long Do_C_to_S_NBytesWithFile (handle_t __RPC_FAR * b,
                                        long i,
                                        unsigned long Length,
                                        unsigned long ChunkSize,
                                        char __RPC_FAR *p)
/*++
Routine Description:
    Create a temporary file of size Length, then send it to the server.
--*/
{
    static const char  *szFuncName = "Do_C_to_S_NBytesWithFile";
    TCHAR               pFileName[MAX_PATH];
    unsigned long       Time = 0;

    HANDLE              hFile = INVALID_HANDLE_VALUE;
    DT_FILE_HANDLE      hRemoteContext;

    assert( (Length == 0) || (ChunkSize != 0));

    //
    //  Create a temporary file to send.
    //
    if (FALSE == CreateTempFile (NULL, TEXT("FCS"), Length, pFileName))
        return 0;

    //
    //  Open that temp file.
    //
    hFile = CreateFile ((LPCTSTR) pFileName,
                        GENERIC_READ,
                        0,
                        (LPSECURITY_ATTRIBUTES) NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        {
        printf(szFormatCantOpenTempFile,
               szFuncName,
               pFileName);
        PrintSysErrorStringA(GetLastError());
        return 0;
        }

    //
    //  Open a temp file on the server to receive our data.
    //
    if (0 == (hRemoteContext = RemoteOpen (*b, 0)))
        {
        printf(szFormatCantOpenServFile, szFuncName);
        DeleteFile (pFileName);
        return 0;
        }

    //
    //  The Actual Test
    //
        {
        DWORD   dwBytesRead;
    
        while(i--)
            {
            SetFilePointer (hFile, 0, NULL, FILE_BEGIN);
            RemoteResetFile (hRemoteContext);

            StartTime();
            for(;;)
                {
                //
                //  If ReadFile fails we keep trying.
                //  This could go on forever, though.
                //
                if (FALSE == ReadFile (hFile, p, ChunkSize, &dwBytesRead, NULL))
                    {
                    printf("%s: ReadFile failed.\n", szFuncName);
                    PrintSysErrorStringA(GetLastError());
                    continue;
                    }

                if (0 == dwBytesRead)
                    break;

                C_to_S_BufferWithFile (*b, hRemoteContext, dwBytesRead, p);
                }

            Time += FinishTiming ();
            }
        }

    //
    //  Clean Up
    //
#ifdef DELETE_TEMP_FILES
    RemoteClose (&hRemoteContext, TRUE);    //  Close and Delete remote file.
#else
    RemoteClose (&hRemoteContext, FALSE);   //  Close Remote File but don't delete it.
#endif

    CloseHandle (hFile);    //  Close local file.
    DeleteFile (pFileName); //  Delete local file.

    return (Time);
}


//===================================================================
//  RPC PIPES
//===================================================================

typedef struct
{
    unsigned long   BufferSize;
    char __RPC_FAR *pBuffer;

    unsigned long   nBytesToGo;
}PIPE_STATE, *P_PIPE_STATE;

typedef struct
{
    unsigned long   BufferSize;
    char __RPC_FAR  *pBuffer;

    HANDLE  hFile;
} FILE_PIPE_STATE;

//---------------------------------------------------------
void PipeAlloc (PIPE_STATE     *state,
                unsigned long   RequestedSize,
                unsigned char **buf,
                unsigned long  *ActualSize)
{
    *buf = state->pBuffer;

    *ActualSize = (RequestedSize < state->BufferSize ?
                   RequestedSize :
                   state->BufferSize);
}

//---------------------------------------------------------
void PipePull (PIPE_STATE      *state,
               unsigned char   *pBuffer,
               unsigned long    BufferSize,
               unsigned long   *ActualSizePulled)
{
    if (state->nBytesToGo > BufferSize)
        {
        *ActualSizePulled = BufferSize;
        state->nBytesToGo -= BufferSize;
        }
    else
        {
        *ActualSizePulled = state->nBytesToGo;
        state->nBytesToGo = 0;
        }
}

//---------------------------------------------------------
void PipePush (PIPE_STATE      *state,
               unsigned char   *pBuffer,
               unsigned long    BufferSize)
{
    state->nBytesToGo -= BufferSize;
}

//---------------------------------------------------------
void FilePipePull (FILE_PIPE_STATE *state,
                   unsigned char   *pBuffer,
                   unsigned long    BufferSize,
                   unsigned long   *ActualSizePulled)
{
    ReadFile (state->hFile,
              pBuffer,
              BufferSize,
              ActualSizePulled,
              NULL);
}

//---------------------------------------------------------
void FilePipePush (FILE_PIPE_STATE *state,
                   unsigned char   *pBuffer,
                   unsigned long    BufferSize)
{
    DWORD dwBytesWritten;

    if (BufferSize != 0)
        {
        WriteFile (state->hFile,
                   pBuffer,
                   BufferSize,
                   &dwBytesWritten,
                   NULL);
        }
}

//---------------------------------------------------------
unsigned long Do_S_to_C_Pipe (handle_t __RPC_FAR * b,
                              long i,
                              unsigned long Length,
                              unsigned long ChunkSize,
                              char __RPC_FAR *p)
{
    const static char  *szFuncName = "Do_S_to_C_Pipe";
    PIPE_STATE          State;
    UCHAR_PIPE          ThePipe;
    unsigned long       Time = 0;

    DT_MEM_HANDLE       hRemoteMem;

    assert( (Length == 0) || (ChunkSize != 0));

    //
    //  Allocate a buffer on the server
    //  This is done so that each server thread will have its own buffer
    //  without forcing a memory allocation on every RPC call.
    //
    if (NULL == (hRemoteMem = RemoteAllocate (*b, ChunkSize)))
        {
        printf("%s: RemoteAllocate failed.\n", szFuncName);
        return 0;
        }

    State.pBuffer = p;          //  Use the thread's buffer as the buffer.
    State.BufferSize = ChunkSize;

    ThePipe.state = (char __RPC_FAR *) &State;
    ThePipe.alloc = (void __RPC_FAR *) PipeAlloc;
    ThePipe.push  = (void __RPC_FAR *) PipePush;

    //
    //  The Actual Test
    //
    while (i--)
        {
        State.nBytesToGo = Length;      //  Reset the pipe's state.

        StartTime();
        S_to_C_Pipe (*b, ThePipe, Length, hRemoteMem);
        Time += FinishTiming();
        }

    //
    //  Clean Up
    //
    RemoteFree(&hRemoteMem);

    return Time;
}

//---------------------------------------------------------
unsigned long Do_C_to_S_Pipe(handle_t __RPC_FAR * b,
                             long i,
                             unsigned long Length,
                             unsigned long ChunkSize,
                             char __RPC_FAR *p)
{
    const static char  *szFuncName = "Do_C_to_S_Pipe";
    PIPE_STATE          State;
    UCHAR_PIPE          ThePipe;
    unsigned long       Time = 0;

    DT_MEM_HANDLE       hRemoteMem;

    assert( (Length == 0) || (ChunkSize != 0));

    //
    //  Allocate a buffer on the server.
    //  This is done so that each server thread will have its own buffer
    //  without forcing a memory allocation on every RPC call.
    //
    if (NULL == (hRemoteMem = RemoteAllocate (*b, ChunkSize)))
        {
        printf("%s: RemoteAllocate failed.\n", szFuncName);
        return 0;
        }

    State.pBuffer = p;          //  Use the thread's buffer as the buffer.
    State.BufferSize = ChunkSize;

    ThePipe.state = (char __RPC_FAR *) &State;
    ThePipe.alloc = (void __RPC_FAR *) PipeAlloc;
    ThePipe.pull  = (void __RPC_FAR *) PipePull;

    //
    //  The Actual Test
    //
    while (i--)
        {
        State.nBytesToGo = Length;

        StartTime();
        C_to_S_Pipe (*b, ThePipe, hRemoteMem);
        Time += FinishTiming();
        }

    //
    //  Clean up
    //
    RemoteFree(&hRemoteMem);

    return Time;
}

//---------------------------------------------------------
unsigned long Do_S_to_C_PipeWithFile(handle_t __RPC_FAR * b,
                                     long i,
                                     unsigned long Length,
                                     unsigned long ChunkSize,
                                     char __RPC_FAR *p)
/*++
Routine Description:
    Receives a file from server via a pipe
--*/
{
    static const char  *szFuncName = "Do_S_to_C_PipeWithFile";
    FILE_PIPE_STATE     State;
    UCHAR_PIPE          ThePipe;
    TCHAR               pFileName[MAX_PATH];
    unsigned long       Time = 0;

    HANDLE              hFile;
    DT_MEM_HANDLE       hRemoteMem;
    DT_FILE_HANDLE      hRemoteFile;

    assert( (Length == 0) || (ChunkSize != 0));

    //
    //  Create a temporary file.
    //
    if (FALSE == CreateTempFile (NULL, TEXT("FCR"), 0, pFileName))
        return 0;

    //
    //  Open that temp file.
    //
    hFile = CreateFile ((LPCTSTR) pFileName,
                        GENERIC_WRITE,
                        0,
                        (LPSECURITY_ATTRIBUTES) NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        {
        printf(szFormatCantOpenTempFile,
               szFuncName,
               pFileName);
        PrintSysErrorStringA(GetLastError());
        return 0;
        }

    //
    //  Allocate a buffer on the server
    //  This is done so that each server thread will have its own buffer
    //  without forcing a memory allocation on every RPC call.
    //
    if (NULL == (hRemoteMem = RemoteAllocate (*b, ChunkSize)))
        {
        printf("%s: RemoteAllocate failed.\n", szFuncName);

        CloseHandle (hFile);
        DeleteFile (pFileName);

        return 0;
        }

    //
    //  Get the server to prepare a file to send us.
    //
    if (0 == (hRemoteFile = RemoteOpen(*b, Length)))
        {
        printf(szFormatCantOpenServFile, szFuncName);

        RemoteFree(&hRemoteMem);
        CloseHandle(hFile);
        DeleteFile(pFileName);

        return 0;
        }

    State.pBuffer = p;          //  Use the thread's buffer as the buffer
    State.BufferSize = ChunkSize;
    State.hFile = hFile;

    ThePipe.state = (char __RPC_FAR *) &State;
    ThePipe.alloc = (void __RPC_FAR *) PipeAlloc;
    ThePipe.push  = (void __RPC_FAR *) FilePipePush;

    //
    //  The Actual Test
    //
    while (i--)
        {
        SetFilePointer (State.hFile, 0, NULL, FILE_BEGIN);
        RemoteResetFile (hRemoteFile);

        StartTime();
        S_to_C_PipeWithFile (*b, ThePipe, hRemoteFile, hRemoteMem);
        Time += FinishTiming();
        }

    //
    //  Clean Up
    //
    RemoteClose (&hRemoteFile, TRUE);
    RemoteFree (&hRemoteMem);
    CloseHandle (hFile);

#ifdef DELETE_TEMP_FILES
    DeleteFile (pFileName);
#endif

    return Time;
}

//---------------------------------------------------------
unsigned long Do_C_to_S_PipeWithFile (handle_t __RPC_FAR * b,
                                      long i,
                                      unsigned long Length,
                                      unsigned long ChunkSize,
                                      char __RPC_FAR *p)
/*++
Routine Description:
    Sends a file to server via a pipe
--*/
{
    static const char  *szFuncName = "Do_C_to_S_PipeWithFile";
    FILE_PIPE_STATE     State;
    UCHAR_PIPE          ThePipe;
    TCHAR               pFileName[MAX_PATH];
    unsigned long       Time = 0;

    HANDLE              hFile;
    DT_MEM_HANDLE       hRemoteMem;
    DT_FILE_HANDLE      hRemoteFile;

    assert( (Length == 0) || (ChunkSize != 0));

    //
    //  Create a temporary file to send.
    //
    if (FALSE == CreateTempFile (NULL, TEXT("FCS"), Length, pFileName))
        return 0;

    //
    //  Open that temp file.
    //
    hFile = CreateFile ((LPCTSTR) pFileName,
                        GENERIC_READ,
                        0,
                        (LPSECURITY_ATTRIBUTES) NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        {
        printf(szFormatCantOpenTempFile,
               szFuncName,
               pFileName);
        PrintSysErrorStringA(GetLastError());
        return 0;
        }

    //
    //  Allocate a buffer on the server
    //  This is done so that each server thread will have its own buffer
    //  without forcing a memory allocation on every RPC call.
    //
    if (NULL == (hRemoteMem = RemoteAllocate (*b, ChunkSize)))
        {
        printf("%s: RemoteAllocate failed.\n", szFuncName);

        CloseHandle (hFile);
        DeleteFile (pFileName);

        return 0;
        }

    //
    //  Open a temporary file on server to receive our data
    //
    if (0 == (hRemoteFile = RemoteOpen(*b, 0)))
        {
        printf(szFormatCantOpenServFile, szFuncName);

        RemoteFree (&hRemoteMem);
        CloseHandle (hFile);
        DeleteFile (pFileName);

        return 0;
        }

    State.pBuffer = p;          //  Use the thread's buffer as the buffer
    State.BufferSize = ChunkSize;
    State.hFile = hFile;

    ThePipe.state = (char __RPC_FAR *) &State;
    ThePipe.alloc = (void __RPC_FAR *) PipeAlloc;
    ThePipe.pull  = (void __RPC_FAR *) FilePipePull;

    //
    //  The Actual Test
    //
    while (i--)
        {
        SetFilePointer (State.hFile, 0, NULL, FILE_BEGIN);
        RemoteResetFile (hRemoteFile);

        StartTime();
        C_to_S_PipeWithFile (*b, ThePipe, hRemoteFile, hRemoteMem);
        Time += FinishTiming();
        }

    //
    //  Clean up
    //
#ifdef DELETE_TEMP_FILES
    RemoteClose (&hRemoteFile, TRUE);    //  Close and Delete remote file.
#else
    RemoteClose (&hRemoteFile, FALSE);   //  Close Remote File but don't delete it.
#endif
    RemoteFree (&hRemoteMem);
    CloseHandle (hFile);
    DeleteFile (pFileName);

    return Time;
}

//===================================================================
//  Internet APIs
//===================================================================
static void PrintInternetError (LPCSTR lpszStr)
{
    unsigned long   ulBufLength = 255;
    char            szErrorString[256];
    DWORD           ulErrorCode;
    DWORD           ulWinErrCode;

    ulWinErrCode = GetLastError();

    printf("%s: %ld:", lpszStr, ulWinErrCode);
    PrintSysErrorStringA(ulWinErrCode);

    if (TRUE == InternetGetLastResponseInfoA ((DWORD __RPC_FAR *) &ulErrorCode,
                                              (char __RPC_FAR *) szErrorString,
                                              (unsigned long __RPC_FAR *) &ulBufLength))
        {
        assert (NULL != szErrorString);

        printf(" %s", szErrorString);
        }
}

//---------------------------------------------------------
static BOOL InternetCommonSetup (LPCSTR                 szCallerId,     //  [in]
                                 BOOL                   f_Ftp,          //  [in]
                                 BOOL                   f_StoC,         //  [in]
                                 handle_t __RPC_FAR    *b,              //  [in]
                                 unsigned long          ulLength,       //  [in]
                                 HINTERNET             *phINetSession,  //  [out]
                                 DT_FILE_HANDLE        *phRemoteFile,   //  [out]
                                 LPTSTR                 szFtpFilePath   //  [out]
                                )
/*++
Routine Description:
    Performs several common setup functions in FTP tests

Arguments:
    szCallerId      - a string that identifies the invoker for display
                      in error messages

    f_Ftp           - indicates whether to perform setup for an FTP test.
                      TRUE indicates FTP

    f_StoC          - indicates whether to set up a file for a Server-to-Client
                      or a Client-to-Server transfer.  TRUE indicates the former.

    b               - the binding handle

    ulLength        - specifies the length of the file

    phFtpSession    - where to store the handle for an FTP session

    phRemoteFile    - where to store the handle for the server's file

    szFtpFilePath   - the path to the file on the FTP server

Return Value:
    TRUE if successful,
    FALSE if otherwise
--*/
{
    TCHAR   szServerName[81];

    //
    //  Get Server's machine name.
    //
    GetServerName (*b, 80, szServerName);

    //
    //  Open an Internet session.
    //
    *phINetSession = InternetConnect (hInternet,
                                      szServerName,
                                      0,            //  Default Port
                                      NULL,         //  Anonymous
                                      NULL,         //  Default Password
                                      (TRUE == f_Ftp ?
                                       INTERNET_SERVICE_FTP :
                                       INTERNET_SERVICE_HTTP),
                                      0,
                                      0);
    if (NULL == *phINetSession)
        {
        PrintInternetError (szCallerId);
        return FALSE;
        }

    //
    //  Get the server to set up a file that we can get.
    //  Or get a filename from the server so we can send
    //  data to it if ulLength is zero.
    //
    if (TRUE == f_Ftp)
        {
        if (NULL == (*phRemoteFile = RemoteCreateFtpFile (*b,
                                                          (boolean)f_StoC,
                                                          ulLength,
                                                          MAX_PATH,
                                                          szFtpFilePath)))
            {
            printf(szFormatCantOpenServFile, szCallerId);

            InternetCloseHandle (*phINetSession);

            return FALSE;
            }
        }
    else
        {
        if (NULL == (*phRemoteFile = RemoteCreateHttpFile (*b,
                                                           (boolean)f_StoC,
                                                           ulLength,
                                                           MAX_PATH,
                                                           szFtpFilePath)))
            {
            printf(szFormatCantOpenServFile, szCallerId);

            InternetCloseHandle (*phINetSession);

            return FALSE;
            }
        }

    return TRUE;
}

//---------------------------------------------------------
unsigned long Do_S_to_C_FtpWithFile (handle_t __RPC_FAR * b,
                                     long i,
                                     unsigned long Length,
                                     unsigned long ChunkSize,
                                     char __RPC_FAR *p)
/*++
Routine Description:
    Get a file from the server's FTP directory.  The server
    must have the FTP root directory set or the test will
    fail.
--*/
{
    const static char  *szFuncName = "Do_S_to_C_FtpWithFile";
    TCHAR               pFileName[MAX_PATH];
    TCHAR               szFtpFilePath[MAX_PATH];
    unsigned long       Time=0;

    HINTERNET           hFtpSession;
    DT_FILE_HANDLE      hRemoteFile;

    assert( (Length == 0) || (ChunkSize != 0));

    //
    //  Create a temporary file.
    //
    if (FALSE == CreateTempFile (NULL, TEXT("FCR"), 0, pFileName))
        return 0;

    //
    //  Common setup for Internet API tests...
    //
    if (FALSE == InternetCommonSetup (szFuncName,
                                      TRUE,             //  FTP setup
                                      TRUE,             //  S_to_C
                                      b,
                                      Length,
                                      &hFtpSession,
                                      &hRemoteFile,
                                      szFtpFilePath))
        {
        DeleteFile (pFileName);
        return 0;
        }

    //
    //  The Actual Test
    //
    StartTime();
    while (i--)
        {
        if (FALSE == FtpGetFile (hFtpSession,
                                 szFtpFilePath,
                                 pFileName,
                                 FALSE,
                                 FILE_ATTRIBUTE_NORMAL,
                                 FTP_TRANSFER_TYPE_BINARY,
                                 0))
            {
            PrintInternetError (szFuncName);

            RemoteClose (&hRemoteFile, TRUE);
            InternetCloseHandle (hFtpSession);

            return 0;
            }
        }
    Time = FinishTiming();

    RemoteClose (&hRemoteFile, TRUE);
    InternetCloseHandle (hFtpSession);

#ifdef DELETE_TEMP_FILES
    DeleteFile (pFileName);
#endif

    return Time;
}

//---------------------------------------------------------
unsigned long Do_C_to_S_FtpWithFile (handle_t __RPC_FAR * b,
                                     long i,
                                     unsigned long Length,
                                     unsigned long ChunkSize,
                                     char __RPC_FAR *p)
{
    const static char  *szFuncName = "Do_C_to_S_FtpWithFile";
    TCHAR               pFileName[MAX_PATH];
    TCHAR               szFtpFilePath[MAX_PATH];
    unsigned long       Time=0;

    HINTERNET           hFtpSession;
    DT_FILE_HANDLE      hRemoteFile;

    assert( (Length == 0) || (ChunkSize != 0));

    //
    //  Create a temporary file.
    //
    if (FALSE == CreateTempFile (NULL, TEXT("FCS"), Length, pFileName))
        return 0;

    //
    //  Common setup for Internet API tests...
    //
    if (FALSE == InternetCommonSetup (szFuncName,
                                      TRUE,             //  FTP setup
                                      FALSE,            //  C_to_S
                                      b,
                                      0,
                                      &hFtpSession,
                                      &hRemoteFile,
                                      szFtpFilePath))
        {
        DeleteFile(pFileName);
        return 0;
        }

    //
    //  The Actual Test
    //
    while (i--)
        {
        StartTime();
        if (FALSE == FtpPutFile (hFtpSession,
                                 pFileName,
                                 szFtpFilePath,
                                 FTP_TRANSFER_TYPE_BINARY,
                                 0))
            {
            PrintInternetError (szFuncName);

            RemoteClose (&hRemoteFile, TRUE);
            InternetCloseHandle (hFtpSession);
            DeleteFile (pFileName);

            return 0;
            }
        Time += FinishTiming();
        }

#ifdef DELETE_TEMP_FILES
    RemoteClose (&hRemoteFile, TRUE);    //  Close and Delete remote file.
#else
    RemoteClose (&hRemoteFile, FALSE);   //  Close Remote File but don't delete it.
#endif

    InternetCloseHandle (hFtpSession);
    DeleteFile (pFileName);

    return Time;
}

//---------------------------------------------------------
unsigned long Do_S_to_C_Ftp1(handle_t __RPC_FAR * b,
                             long i,
                             unsigned long Length,
                             unsigned long ChunkSize,
                             char __RPC_FAR *p)
{
    const static char  *szFuncName = "Do_S_to_C_Ftp1";
    TCHAR               szFtpFilePath[MAX_PATH];
    unsigned long       Time=0;

    HINTERNET           hFtpSession;
    DT_FILE_HANDLE      hRemoteFile;

    //
    //  Common setup for Internet API tests...
    //
    if (FALSE == InternetCommonSetup (szFuncName,
                                      TRUE,             //  FTP setup
                                      TRUE,             //  S_to_C
                                      b,
                                      Length,
                                      &hFtpSession,
                                      &hRemoteFile,
                                      szFtpFilePath))
        {
        return 0;
        }

    //
    //  The Actual Test
    //
        {
        HINTERNET       hFtpFile;
        DWORD           nBytesRead;

        while (i--)
            {
            //
            //  Open file on the server to read from.
            //
            hFtpFile = FtpOpenFile (hFtpSession,
                                    szFtpFilePath,
                                    GENERIC_READ,
                                    FTP_TRANSFER_TYPE_BINARY,
                                    0);
            if (NULL == hFtpFile)
                {
                PrintInternetError (szFuncName);

                RemoteClose (&hRemoteFile, TRUE);
                InternetCloseHandle (hFtpSession);

                return 0;
                }

            StartTime();

            //
            //  Transfer the file!
            //
            do
                {
                if (FALSE == InternetReadFile (hFtpFile,
                                               p,
                                               ChunkSize,
                                               &nBytesRead))
                    {
                    PrintInternetError (szFuncName);

                    InternetCloseHandle (hFtpFile);
                    RemoteClose (&hRemoteFile, TRUE);
                    InternetCloseHandle (hFtpSession);

                    return 0;
                    }
                } while (0 != nBytesRead);

            Time += FinishTiming();

            InternetCloseHandle (hFtpFile);
            }
        }

    RemoteClose (&hRemoteFile, TRUE);
    InternetCloseHandle (hFtpSession);

    return Time;
}

//---------------------------------------------------------
unsigned long Do_C_to_S_Ftp1(handle_t __RPC_FAR * b,
                             long i,
                             unsigned long Length,
                             unsigned long ChunkSize,
                             char __RPC_FAR *p)
{
    const static char  *szFuncName = "Do_C_to_S_Ftp1";
    TCHAR               szFtpFilePath[MAX_PATH];
    unsigned long       Time=0;

    HINTERNET           hFtpSession;
    DT_FILE_HANDLE      hRemoteFile;

    assert( (Length == 0) || (ChunkSize != 0));

    //
    //  Common setup for Internet API tests...
    //
    if (FALSE == InternetCommonSetup (szFuncName,
                                      TRUE,             //  FTP setup
                                      FALSE,            //  C_to_S
                                      b,
                                      0,
                                      &hFtpSession,
                                      &hRemoteFile,
                                      szFtpFilePath))
        {
        return 0;
        }

    //
    //  The Actual Test
    //
        {
        DWORD           dwBytesWritten;
        DWORD           dwBytesRead;
        HINTERNET       hFtpFile;
        unsigned int    n;

        while (i--)
            {
            //
            //  Open a file on server to write to.
            //
            hFtpFile = FtpOpenFile (hFtpSession,
                                    szFtpFilePath,
                                    GENERIC_WRITE,
                                    FTP_TRANSFER_TYPE_BINARY,
                                    0);
            if (NULL == hFtpFile)
                {
                PrintInternetError (szFuncName);

                RemoteClose (&hRemoteFile, TRUE);
                InternetCloseHandle (hFtpSession);

                return 0;
                }

            n = Length;

            StartTime();

            //
            //  Transfer in complete chunks
            //
            for (; n > ChunkSize; n -= ChunkSize)
                {
                if (FALSE == InternetWriteFile (hFtpFile,
                                                p,
                                                ChunkSize,
                                                &dwBytesWritten))
                    {
                    PrintInternetError (szFuncName);

                    InternetCloseHandle (hFtpFile);
                    RemoteClose (&hRemoteFile, TRUE);
                    InternetCloseHandle (hFtpSession);

                    return 0;
                    }
                }
            //
            //  Transfer the last bit that doesn't fill a chunk
            //
            if (FALSE == InternetWriteFile (hFtpFile,
                                            p,
                                            n,
                                            &dwBytesWritten))
                {
                PrintInternetError (szFuncName);

                InternetCloseHandle (hFtpFile);
                RemoteClose (&hRemoteFile, TRUE);
                InternetCloseHandle (hFtpSession);

                return 0;
                }

            Time += FinishTiming();

            InternetCloseHandle (hFtpFile);
            }
        }

    RemoteClose (&hRemoteFile, FALSE);
    InternetCloseHandle (hFtpSession);

    return Time;
}

//---------------------------------------------------------
unsigned long Do_S_to_C_Ftp1WithFile(handle_t __RPC_FAR * b,
                                     long i,
                                     unsigned long Length,
                                     unsigned long ChunkSize,
                                     char __RPC_FAR *p)
{
    const static char  *szFuncName = "Do_S_to_C_Ftp1WithFile";
    TCHAR               pFileName[MAX_PATH];
    TCHAR               szFtpFilePath[MAX_PATH];
    unsigned long       Time = 0;

    HANDLE          hFile;
    HINTERNET       hFtpSession;
    DT_FILE_HANDLE  hRemoteFile;

    assert( (Length == 0) || (ChunkSize != 0));

    //
    //  Create a temporary file.
    //
    if (FALSE == CreateTempFile (NULL, TEXT("FCR"), 0, pFileName))
        return 0;

    //
    //  Open the temporary file.
    //
    hFile = CreateFile ((LPCTSTR) pFileName,
                        GENERIC_WRITE,
                        0,
                        (LPSECURITY_ATTRIBUTES) NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL
                       );
    if (hFile == INVALID_HANDLE_VALUE)
        {
        printf(szFormatCantOpenTempFile,
               szFuncName,
               pFileName);
        PrintSysErrorStringA(GetLastError());
        return 0;
        }

    //
    //  Common setup for Internet API tests...
    //
    if (FALSE == InternetCommonSetup (szFuncName,
                                      TRUE,             //  FTP setup
                                      TRUE,             //  S_to_C
                                      b,
                                      Length,
                                      &hFtpSession,
                                      &hRemoteFile,
                                      szFtpFilePath))
        {
        CloseHandle(hFile);
        DeleteFile(pFileName);
        return 0;
        }

    //
    //  The Actual Test
    //
        {
        DWORD           dwBytesWritten;
        DWORD           dwBytesRead;
        HINTERNET       hFtpFile;

        while (i--)
            {
            //
            //  Open the remote file.
            //
            hFtpFile = FtpOpenFile (hFtpSession,
                                    szFtpFilePath,
                                    GENERIC_READ,
                                    FTP_TRANSFER_TYPE_BINARY,
                                    0);
            if (NULL == hFtpFile)
                {
                PrintInternetError (szFuncName);

                RemoteClose (&hRemoteFile, TRUE);
                InternetCloseHandle (hFtpSession);
                CloseHandle(hFile);
                DeleteFile(pFileName);

                return 0;
                }

            //
            //  Reset the local file.
            //
            SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

            StartTime();
            for (;;)
                {
            //
            //  Transfer in complete chunks
            //
                if (FALSE == InternetReadFile (hFtpFile,
                                               p,
                                               ChunkSize,
                                               &dwBytesRead))
                    {
                    PrintInternetError (szFuncName);

                    InternetCloseHandle (hFtpFile);
                    RemoteClose (&hRemoteFile, TRUE);
                    InternetCloseHandle (hFtpSession);
                    CloseHandle(hFile);

                    return 0;
                    }

                //
                //  Return value == TRUE and dwBytesRead == 0 means EOF
                //
                if (0 == dwBytesRead)
                    break;

                WriteFile(hFile, p, dwBytesRead, &dwBytesWritten, NULL);
                }

            Time += FinishTiming();

            //
            //  Close and re-open the file after each write.
            //
            InternetCloseHandle (hFtpFile);
            }
        }

    RemoteClose (&hRemoteFile, TRUE);
    InternetCloseHandle (hFtpSession);
    CloseHandle(hFile);

#ifdef DELETE_TEMP_FILES
    DeleteFile (pFileName);
#endif

    return Time;
}

//---------------------------------------------------------
unsigned long Do_C_to_S_Ftp1WithFile(handle_t __RPC_FAR * b,
                                     long i,
                                     unsigned long Length,
                                     unsigned long ChunkSize,
                                     char __RPC_FAR *p)
{
    static const char  *szFuncName="Do_C_to_S_Ftp1WithFile";
    HINTERNET           hFtpSession;
    HANDLE              hFile;
    TCHAR               pFileName[MAX_PATH];
    unsigned long       Time=0;

    DT_FILE_HANDLE  hRemoteFile;
    char            szFtpFilePath[MAX_PATH];

    assert( (Length == 0) || (ChunkSize != 0));

    //
    //  Create a temporary file.
    //
    if (FALSE == CreateTempFile (NULL, "FCS", Length, pFileName))
        return 0;

    //
    //  Open the temporary file.
    //
    hFile = CreateFile ((LPTSTR) pFileName,
                        GENERIC_READ,
                        0,
                        (LPSECURITY_ATTRIBUTES) NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL
                       );
    if (hFile == INVALID_HANDLE_VALUE)
        {
        printf(szFormatCantOpenTempFile,
               szFuncName,
               pFileName);
        PrintSysErrorStringA(GetLastError());
        DeleteFile(pFileName);
        return 0;
        }

    //
    //  Common setup for Internet API tests...
    //
    if (FALSE == InternetCommonSetup (szFuncName,
                                      TRUE,             //  FTP setup
                                      FALSE,            //  C_to_S
                                      b,
                                      0,
                                      &hFtpSession,
                                      &hRemoteFile,
                                      szFtpFilePath))
        {
        CloseHandle(hFile);
        DeleteFile(pFileName);
        return 0;
        }

    //
    //  The Actual Test
    //
        {
        DWORD           dwBytesWritten;
        DWORD           dwBytesRead;
        HINTERNET       hFtpFile;

        while (i--)
            {
            //
            //  Open the remote file.
            //
            hFtpFile = FtpOpenFile (hFtpSession,
                                    szFtpFilePath,
                                    GENERIC_WRITE,
                                    FTP_TRANSFER_TYPE_BINARY,
                                    0);
            if (NULL == hFtpFile)
                {
                PrintInternetError (szFuncName);

                RemoteClose (&hRemoteFile, TRUE);
                InternetCloseHandle (hFtpSession);
                CloseHandle(hFile);
                DeleteFile(pFileName);

                return 0;
                }

            SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

            StartTime();
            for (;;)
                {
                if (FALSE == ReadFile(hFile, p, ChunkSize, &dwBytesRead, NULL))
                    {
                    printf("%s: ReadFile failed.\n", szFuncName);
                    continue;
                    }

                //
                //  Return value == TRUE and dwBytesRead == 0 means EOF
                //
                if (0 == dwBytesRead)
                    break;

                if (FALSE == InternetWriteFile (hFtpFile,
                                                p,
                                                dwBytesRead,
                                                &dwBytesWritten))
                    {
                    PrintInternetError (szFuncName);

                    InternetCloseHandle (hFtpFile);
                    RemoteClose (&hRemoteFile, FALSE);
                    CloseHandle(hFile);
                    InternetCloseHandle (hFtpSession);

                    return 0;
                    }
                }

            Time += FinishTiming();

            //
            //  Close and re-open the file after each write.
            //
            InternetCloseHandle (hFtpFile);
            }
        }

#ifdef DELETE_TEMP_FILES
    RemoteClose (&hRemoteFile, TRUE);    //  Close and Delete remote file.
#else
    RemoteClose (&hRemoteFile, FALSE);   //  Close Remote File but don't delete it.
#endif

    InternetCloseHandle (hFtpSession);

    CloseHandle(hFile);
    DeleteFile(pFileName);

    return Time;
}

//---------------------------------------------------------
//  We want to accept all types of files, even binary.
static LPCTSTR lpszAcceptTypes[] = {TEXT("*"),0};

//---------------------------------------------------------
unsigned long Do_S_to_C_Http(handle_t __RPC_FAR * b,
                             long i,
                             unsigned long Length,
                             unsigned long ChunkSize,
                             char __RPC_FAR *p)
{
    static const char  *szFuncName = "Do_S_to_C_Http";
    TCHAR               szHttpFilePath[MAX_PATH];
    unsigned long       Time=0;

    HINTERNET       hHttpSession;
    DT_FILE_HANDLE  hRemoteFile;

    assert( (Length == 0) || (ChunkSize != 0));

    //
    //  Common setup for Internet API tests...
    //
    if (FALSE == InternetCommonSetup (szFuncName,
                                      FALSE,            //  HTTP setup
                                      TRUE,             //  S_to_C
                                      b,
                                      Length,
                                      &hHttpSession,
                                      &hRemoteFile,
                                      szHttpFilePath))
        {
        return 0;
        }

    //
    //  The Actual Test
    //
        {
        HINTERNET       hHttpFile;
        DWORD           nBytesRead;

        while (i--)
            {
            //
            //  Open file on the server to read from.
            //
            hHttpFile = HttpOpenRequest (hHttpSession,
                                         TEXT("GET"),
                                         szHttpFilePath,
                                         HTTP_VERSION,
                                         NULL,
                                         lpszAcceptTypes,
                                         INTERNET_FLAG_RELOAD,
                                         0);
            if (NULL == hHttpFile)
                {
                PrintInternetError (szFuncName);

                RemoteClose (&hRemoteFile, TRUE);
                InternetCloseHandle (hHttpSession);

                return 0;
                }

            if (FALSE == HttpSendRequest (hHttpFile,
                                          NULL,
                                          0,
                                          NULL,
                                          0))
                {
                PrintInternetError (szFuncName);

                InternetCloseHandle (hHttpFile);
                RemoteClose (&hRemoteFile, TRUE);
                InternetCloseHandle (hHttpSession);

                return 0;
                }

            StartTime();

            //
            //  Transfer the file!
            //
            do
                {
                if (FALSE == InternetReadFile (hHttpFile,
                                               p,
                                               ChunkSize,
                                               &nBytesRead))
                    {
                    PrintInternetError (szFuncName);

                    InternetCloseHandle (hHttpFile);
                    RemoteClose (&hRemoteFile, TRUE);
                    InternetCloseHandle (hHttpSession);

                    return 0;
                    }
                } while (0 != nBytesRead);

            Time += FinishTiming();

            InternetCloseHandle (hHttpFile);
            }
        }

    RemoteClose (&hRemoteFile, TRUE);
    InternetCloseHandle (hHttpSession);

    return Time;
}
//---------------------------------------------------------
unsigned long Do_C_to_S_Http(handle_t __RPC_FAR * b,
                             long i,
                             unsigned long Length,
                             unsigned long ChunkSize,
                             char __RPC_FAR *p)
{
    static const char  *szFuncName="Do_C_to_S_HttpWithFile";
    HINTERNET           hHttpSession;
    unsigned long       Time=0;

    DT_FILE_HANDLE  hRemoteFile;
    char            szHttpFilePath[MAX_PATH];

    assert( (Length == 0) || (ChunkSize != 0));

    //
    //  Common setup for Internet API tests...
    //
    if (FALSE == InternetCommonSetup (szFuncName,
                                      FALSE,            //  HTTP setup
                                      FALSE,            //  C_to_S
                                      b,
                                      0,
                                      &hHttpSession,
                                      &hRemoteFile,
                                      szHttpFilePath))
        {
        return 0;
        }

    //
    //  The Actual Test
    //
        {
        DWORD           dwBytesWritten;
        DWORD           dwBytesRead;
        unsigned int    n;
        HINTERNET       hHttpFile;

        while (i--)
            {
            //
            //  Open the remote file.
            //
            hHttpFile = HttpOpenRequest (hHttpSession,
                                         TEXT("PUT"),
                                         szHttpFilePath,
                                         HTTP_VERSION,
                                         NULL,
                                         lpszAcceptTypes,
                                         INTERNET_FLAG_RELOAD,
                                         0);
            if (NULL == hHttpFile)
                {
                PrintInternetError (szFuncName);

                RemoteClose (&hRemoteFile, TRUE);
                InternetCloseHandle (hHttpSession);

                return 0;
                }

            if (FALSE == HttpSendRequest (hHttpFile,
                                          NULL,
                                          0,
                                          NULL,
                                          0))
                {
                PrintInternetError (szFuncName);

                InternetCloseHandle (hHttpFile);
                RemoteClose (&hRemoteFile, TRUE);
                InternetCloseHandle (hHttpSession);

                return 0;
                }

            StartTime();
            //
            //  Transfer in complete chunks
            //
            for (n = Length; n > ChunkSize; n -= ChunkSize)
                {
                if (FALSE == InternetWriteFile (hHttpFile,
                                                p,
                                                ChunkSize,
                                                &dwBytesWritten))
                    {
                    PrintInternetError (szFuncName);

                    InternetCloseHandle (hHttpFile);
                    RemoteClose (&hRemoteFile, FALSE);
                    InternetCloseHandle (hHttpSession);

                    return 0;
                    }
                }
            //
            //  Transfer the last bit that doesn't fill a chunk
            //
            if (FALSE == InternetWriteFile (hHttpFile,
                                            p,
                                            n,
                                            &dwBytesWritten))
                {
                PrintInternetError (szFuncName);

                InternetCloseHandle (hHttpFile);
                RemoteClose (&hRemoteFile, FALSE);
                InternetCloseHandle (hHttpSession);

                return 0;
                }

            Time += FinishTiming();

            //
            //  Close and re-open the file after each write.
            //
            InternetCloseHandle (hHttpFile);
            }
        }

#ifdef DELETE_TEMP_FILES
    RemoteClose (&hRemoteFile, TRUE);    //  Close and Delete remote file.
#else
    RemoteClose (&hRemoteFile, FALSE);   //  Close Remote File but don't delete it.
#endif

    InternetCloseHandle (hHttpSession);

    return Time;
}

//---------------------------------------------------------
unsigned long Do_S_to_C_HttpWithFile(handle_t __RPC_FAR * b,
                                     long i,
                                     unsigned long Length,
                                     unsigned long ChunkSize,
                                     char __RPC_FAR *p)
/*++
Routine Description:
    Grabs a file from the server using HTTP
--*/
{
    static const char  *szFuncName = "Do_S_to_C_HttpWithFile";
    TCHAR           pFileName[MAX_PATH];
    TCHAR           szHttpFilePath[MAX_PATH];
    unsigned long   Time=0;

    HANDLE          hFile;
    HINTERNET       hHttpSession;
    DT_FILE_HANDLE  hRemoteFile;

    assert( (Length == 0) || (ChunkSize != 0));

    //
    //  Create a temporary file.
    //
    if (FALSE == CreateTempFile (NULL, TEXT("FCR"), 0, pFileName))
        return 0;

    //
    //  Open the temporary file.
    //
    hFile = CreateFile ((LPCTSTR) pFileName,
                        GENERIC_WRITE,
                        0,
                        (LPSECURITY_ATTRIBUTES) NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL
                       );
    if (hFile == INVALID_HANDLE_VALUE)
        {
        printf(szFormatCantOpenTempFile,
               szFuncName,
               pFileName);
        PrintSysErrorStringA(GetLastError());
        return 0;
        }

    //
    //  Common setup for Internet API tests...
    //
    if (FALSE == InternetCommonSetup (szFuncName,
                                      FALSE,            //  HTTP setup
                                      TRUE,             //  S_to_C
                                      b,
                                      Length,
                                      &hHttpSession,
                                      &hRemoteFile,
                                      szHttpFilePath))
        {
        CloseHandle(hFile);
        DeleteFile(pFileName);
        return 0;
        }

    //
    //  The Actual Test
    //
        {
        DWORD           dwBytesWritten;
        DWORD           dwBytesRead;
        HINTERNET       hHttpFile;

        while (i--)
            {
            hHttpFile = HttpOpenRequest (hHttpSession,
                                         TEXT("GET"),
                                         szHttpFilePath,
                                         HTTP_VERSION,
                                         NULL,
                                         lpszAcceptTypes,
                                         INTERNET_FLAG_RELOAD,
                                         0);
            if (NULL == hHttpFile)
                {
                PrintInternetError (szFuncName);

                RemoteClose (&hRemoteFile, TRUE);
                InternetCloseHandle (hHttpSession);
                CloseHandle(hFile);
                DeleteFile(pFileName);

                return 0;
                }

            if (FALSE == HttpSendRequest (hHttpFile,
                                          NULL,
                                          0,
                                          NULL,
                                          0))
                {
                PrintInternetError (szFuncName);

                InternetCloseHandle (hHttpFile);
                RemoteClose (&hRemoteFile, TRUE);
                InternetCloseHandle (hHttpSession);

                return 0;
                }

            //
            //  Reset the local file.
            //
            SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

            StartTime();
            for (;;)
                {
                if (FALSE == InternetReadFile (hHttpFile,
                                               p,
                                               ChunkSize,
                                               &dwBytesRead))
                    {
                    PrintInternetError (szFuncName);

                    InternetCloseHandle (hHttpFile);
                    RemoteClose (&hRemoteFile, TRUE);
                    InternetCloseHandle (hHttpSession);
                    CloseHandle(hFile);

                    return 0;
                    }

                //
                //  Return value == TRUE and dwBytesRead == 0 means EOF
                //
                if (0 == dwBytesRead)
                    break;

                WriteFile(hFile, p, dwBytesRead, &dwBytesWritten, NULL);
                }

            Time += FinishTiming();

            //
            //  Close and re-open the file after each write.
            //
            InternetCloseHandle (hHttpFile);
            }
        }

    RemoteClose (&hRemoteFile, TRUE);
    InternetCloseHandle (hHttpSession);
    CloseHandle(hFile);

#ifdef DELETE_TEMP_FILES
    DeleteFile (pFileName);
#endif

    return Time;
}

//---------------------------------------------------------
unsigned long Do_C_to_S_HttpWithFile(handle_t __RPC_FAR * b,
                                     long i,
                                     unsigned long Length,
                                     unsigned long ChunkSize,
                                     char __RPC_FAR *p)
{
    static const char  *szFuncName="Do_C_to_S_HttpWithFile";
    HINTERNET           hHttpSession;
    HANDLE              hFile;
    TCHAR               pFileName[MAX_PATH];
    unsigned long       Time=0;

    DT_FILE_HANDLE  hRemoteFile;
    char            szHttpFilePath[MAX_PATH];

    assert( (Length == 0) || (ChunkSize != 0));

    //
    //  Create a temporary file.
    //
    if (FALSE == CreateTempFile (NULL, "FCS", Length, pFileName))
        return 0;

    //
    //  Open the temporary file.
    //
    hFile = CreateFile ((LPTSTR) pFileName,
                        GENERIC_READ,
                        0,
                        (LPSECURITY_ATTRIBUTES) NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL
                       );
    if (hFile == INVALID_HANDLE_VALUE)
        {
        printf(szFormatCantOpenTempFile,
               szFuncName,
               pFileName);
        PrintSysErrorStringA(GetLastError());
        DeleteFile(pFileName);
        return 0;
        }

    //
    //  Common setup for Internet API tests...
    //
    if (FALSE == InternetCommonSetup (szFuncName,
                                      FALSE,            //  HTTP setup
                                      FALSE,            //  C_to_S
                                      b,
                                      0,
                                      &hHttpSession,
                                      &hRemoteFile,
                                      szHttpFilePath))
        {
        CloseHandle(hFile);
        DeleteFile(pFileName);
        return 0;
        }

    //
    //  The Actual Test
    //
        {
        DWORD           dwBytesWritten;
        DWORD           dwBytesRead;
        HINTERNET       hHttpFile;

        while (i--)
            {
            //
            //  Open the remote file.
            //
            hHttpFile = HttpOpenRequest (hHttpSession,
                                         TEXT("PUT"),
                                         szHttpFilePath,
                                         HTTP_VERSION,
                                         NULL,
                                         lpszAcceptTypes,
                                         INTERNET_FLAG_RELOAD,
                                         0);
            if (NULL == hHttpFile)
                {
                PrintInternetError (szFuncName);

                RemoteClose (&hRemoteFile, TRUE);
                InternetCloseHandle (hHttpSession);
                CloseHandle(hFile);
                DeleteFile(pFileName);

                return 0;
                }

            if (FALSE == HttpSendRequest (hHttpFile,
                                          NULL,
                                          0,
                                          NULL,
                                          0))
                {
                PrintInternetError (szFuncName);

                InternetCloseHandle (hHttpFile);
                RemoteClose (&hRemoteFile, TRUE);
                InternetCloseHandle (hHttpSession);

                return 0;
                }

            //
            //  Reset the local file.
            //
            SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

            StartTime();
            for (;;)
                {
                if (FALSE == ReadFile(hFile, p, ChunkSize, &dwBytesRead, NULL))
                    {
                    printf("%s: ReadFile failed.\n", szFuncName);
                    continue;
                    }

                //
                //  Return value == TRUE and dwBytesRead == 0 means EOF
                //
                if (0 == dwBytesRead)
                    break;

                if (FALSE == InternetWriteFile (hHttpFile,
                                                p,
                                                dwBytesRead,
                                                &dwBytesWritten))
                    {
                    PrintInternetError (szFuncName);

                    InternetCloseHandle (hHttpFile);
                    RemoteClose (&hRemoteFile, FALSE);
                    CloseHandle(hFile);
                    InternetCloseHandle (hHttpSession);

                    return 0;
                    }
                }

            Time += FinishTiming();

            //
            //  Close and re-open the file after each write.
            //
            InternetCloseHandle (hHttpFile);
            }
        }

#ifdef DELETE_TEMP_FILES
    RemoteClose (&hRemoteFile, TRUE);    //  Close and Delete remote file.
#else
    RemoteClose (&hRemoteFile, FALSE);   //  Close Remote File but don't delete it.
#endif

    InternetCloseHandle (hHttpSession);

    CloseHandle(hFile);
    DeleteFile(pFileName);

    return Time;
}

/////////////////////////////////////////////////////////////////////

static const unsigned long (*TestTable[TEST_MAX])(handle_t __RPC_FAR *,long,long,long, char __RPC_FAR *) =
    {
    Do_S_to_C_NBytes,
    Do_C_to_S_NBytes,
    Do_S_to_C_Pipe,
    Do_C_to_S_Pipe,
    Do_S_to_C_Ftp1,
    Do_C_to_S_Ftp1,
    Do_S_to_C_Http,
    Do_C_to_S_Http,
    Do_S_to_C_NBytesWithFile,
    Do_C_to_S_NBytesWithFile,
    Do_S_to_C_PipeWithFile,
    Do_C_to_S_PipeWithFile,
    Do_S_to_C_FtpWithFile,
    Do_C_to_S_FtpWithFile,
    Do_S_to_C_Ftp1WithFile,
    Do_C_to_S_Ftp1WithFile,
    Do_S_to_C_HttpWithFile,
    Do_C_to_S_HttpWithFile
    };


//---------------------------------------------------------
//
// Worker calls the correct tests.  Maybe multithreaded on NT
//

unsigned long Worker(unsigned long l)
{
    unsigned long   status;
    unsigned long   lTest;
    long            lIterations, lClientId;
    unsigned long   lTime;
    long            lLength, lChunkSize;
    char __RPC_FAR *pBuffer;
    char __RPC_FAR *stringBinding;
    handle_t        binding;
    unsigned int    i;

    pBuffer = MIDL_user_allocate(ulBufferSize);
    if (pBuffer == 0)
        {
        PrintToConsole("Out of memory!");
        return 1;
        }

    for (i = 0; i< ulBufferSize;i++)
        {
        pBuffer[i] = (char) (i&0xff);
        }

    status = RpcStringBindingCompose(0,
                                     Protseq,
                                     NetworkAddr,
                                     Endpoint,
                                     0,
                                     &stringBinding);
    CHECK_RET(status, "RpcStringBindingCompose");

    status = RpcBindingFromStringBinding(stringBinding, &binding);
    CHECK_RET(status, "RpcBindingFromStringBinding");

    status = DoRpcBindingSetAuthInfo(binding);
    CHECK_RET(status, "RpcBindingSetAuthInfo");

    RpcStringFree(&stringBinding);

    RpcTryExcept
    {
        status = BeginTest(binding, &lClientId);
    }
    RpcExcept(1)
    {
        PrintToConsole("First call failed %ld (%08lx)\n",
               (unsigned long)RpcExceptionCode(),
               (unsigned long)RpcExceptionCode());
        goto Cleanup;
    }
    RpcEndExcept

    if (status == PERF_TOO_MANY_CLIENTS)
        {
        PrintToConsole("Too many clients, I'm exiting\n");
        goto Cleanup ;
        }
    CHECK_RET(status, "ClientConnect");

    PrintToConsole("Client %ld connected\n", lClientId);

    do
        {
        status = NextTest(binding, &lTest, &lIterations, &lLength, &lChunkSize);

        if (status == PERF_TESTS_DONE)
            {
            goto Cleanup;
            }

        CHECK_RET(status, "NextTest");

        PrintToConsole("(%4ld iterations of case %2ld, Length: %7ld, Chunk: %7ld: ",
                       lIterations,
                       lTest,
                       lLength,
                       lChunkSize);

        RpcTryExcept
            {

            lTime = ( (TestTable[lTest])(&binding, lIterations, lLength, lChunkSize, pBuffer));

            PrintToConsole("% 5ld mseconds)\n", lTime);

            status = EndTest(binding, lTime);

            CHECK_RET(status, "EndTest");

            }
        RpcExcept(1)
            {
            PrintToConsole("\nTest case %ld raised exception %lu (0x%08lX)\n",
                           lTest,
                           (unsigned long)RpcExceptionCode(),
                           (unsigned long)RpcExceptionCode());
            status = RpcExceptionCode();
            }
        RpcEndExcept

        }
    while(status == 0);

Cleanup:
    RpcBindingFree(&binding) ; //BUGBUG
    return status;
}


//---------------------------------------------------------
//
// The Win32 main starts worker threads, otherwise we just call the worker.
//

#ifdef WIN32
int __cdecl
main (int argc, char **argv)
{
    char option;
    unsigned long status, i;
    HANDLE *pClientThreads;

    ParseArgv(argc, argv);

    PrintToConsole("Authentication Level is: %s\n", AuthnLevelStr);

    if (Options[0] < 0)
        Options[0] = 1;

    pClientThreads = MIDL_user_allocate(sizeof(HANDLE) * Options[0]);

    //
    //  Setup for the use of the WinINet functions
    //
    hInternet = InternetOpen ("Data Transfer Test",
                              LOCAL_INTERNET_ACCESS,
                              NULL,
                              0,
                              (DWORD) 0);

    for(i = 0; i < (unsigned long)Options[0]; i++)
        {
        pClientThreads[i] = CreateThread(0,
                                         0,
                                         (LPTHREAD_START_ROUTINE)Worker,
                                         0,
                                         0,
                                         &status);
        if (pClientThreads[i] == 0)
            ApiError("CreateThread", GetLastError());
        }


    status = WaitForMultipleObjects(Options[0],
                                    pClientThreads,
                                    TRUE,  // Wait for all client threads
                                    INFINITE);
    if (status == WAIT_FAILED)
        {
        ApiError("WaitForMultipleObjects", GetLastError());
        }

    if (NULL != hInternet)
        {
        InternetCloseHandle (hInternet);
        }

    PrintToConsole("TEST DONE\n");
    return(0);
}
#else  // !WIN32
#ifdef WIN 
#define main c_main

// We need the following to force the linker to load WinMain from the
// Windows STDIO library
extern int PASCAL WinMain(HANDLE, HANDLE, LPSTR, int);
static int (PASCAL *wm_ptr)(HANDLE, HANDLE, LPSTR, int) = WinMain;

#endif

#ifndef MAC
#ifndef FAR
#define FAR __far
#endif
#else
#define FAR
#define main c_main
#endif

int main (int argc, char FAR * FAR * argv)
{
#ifndef MAC
    ParseArgv(argc, argv);
#endif
    Worker(0);

    PrintToConsole("TEST DONE\n");

    return(0);
}
#endif // NTENV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\datatran\server\server.c ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    Server.c

Abstract:

    Server side of RPC runtime performance test.

Author:

    Mario Goertzel (mariogo)   31-Mar-1994

Revision History:

--*/

#include <rpcperf.h>
#include <assert.h>

#include <DataTran.h>
#include <DTCommon.h>

// Usage
const char *USAGE =
           "[-i iterations] [-l logfile] [-n Clients] [-n MinThreads]\n"
           "\t\t[-c ChunkSize] [-z size] [-d FtpRoot] [-w WwwRoot] [-n case] *\n"
           "      Clients    - default 1\n"
           "      MinThreads - default 3\n"
           "      FtpRoot    - root directory for ftp\n"
           "                   required for FTP tests\n"
           "      WwwRoot    - root diretory for Http\n"
           "                   required for HTTP tests\n"
           "      Size       - default 50k,100k,200k,400k\n"
           "      ChunkSize  - default 4000,8192,32768\n"
           "      filename   - you may specify a file to transfer (not implemented yet)\n\n"
           "      Cases, you may specify up to five, default is all:\n"
           "        0: Write using RPC\n"
           "        1: Read  using RPC\n"
           "        2: Write using RPC Pipes\n"
           "        3: Read  using RPC Pipes\n"
           "        4: Write using FTP (InternetReadFile)\n"
           "        5: Read  using FTP (InternetWriteFile)\n"
           "        6: Write using HTTP Get\n"
           "        7: Read  using HTTP Put\n"
           "        8: Write using RPC with File I/O\n"
           "        9: Read  using RPC with File I/O\n"
           "       10: Write using RPC Pipes with File I/O\n"
           "       11: Read  using RPC Pipes with File I/O\n"
           "       12: Write using FTP\n"
           "       13: Read  using FTP\n"
           "       14: Write using FTP (InternetReadFile)  with File I/O\n"
           "       15: Read  using FTP (InternetWriteFile) with File I/O\n"
           "       16: Write using HTTP Get with File I/O\n"
           "       17: Read  using HTTP Put\n"
           "\n"
           "        Note: Results are milliseconds/call/client\n"
           ;


//
// Globals making it easier.
//

int  CurrentChunkIndex;
int  CurrentTotalIndex;
int  CurrentCase;
char TestCases[TEST_MAX];


char *pFtpRoot = NULL;      //  Root Directory used for FTP
char *pWwwRoot = NULL;      //  Root Directory used for HTTP

//
//  If this is non-NULL, then use this file instead of creating
//  temporary ones.  Not implemented...
//
char *pFileName = 0;

long            CurrentIter;
unsigned long  *Results;

long Clients, ActiveClients, ClientsLeft;

CRITICAL_SECTION CritSec;
HANDLE GoEvent   = 0;
HANDLE DoneEvent = 0;

char *TestNames[TEST_MAX] =
    {
    "S to C RPC          : %9ld / %7ld",
    "C to S RPC          : %9ld / %7ld",
    "S to C Pipes        : %9ld / %7ld",
    "C to S Pipes        : %9ld / %7ld",
    "S to C FTP1         : %9ld / %7ld",
    "C to S FTP1         : %9ld / %7ld",
    "S to C HTTP         : %9ld / %7ld",
    "C to S HTTP         : %9ld / %7ld",
    "S to C RPC   w/File : %9ld / %7ld",
    "C to S RPC   w/File : %9ld / %7ld",
    "S to C Pipes w/File : %9ld / %7ld",
    "C to S Pipes w/File : %9ld / %7ld",
    "S to C FTP   w/File : %9ld / %7ld",
    "C to S FTP   w/File : %9ld / %7ld",
    "S to C FTP1  w/File : %9ld / %7ld",
    "C to S FTP1  w/File : %9ld / %7ld",
    "S to C HTTP  w/File : %9ld / %7ld",
    "C to S HTTP  w/File : %9ld / %7ld"
    };

//
//  These arrays are NULL terminated.  Don't let the last entry get used!
//
unsigned long ChunkSizes[10] = {4000, 8192, 32*1024L, 0, 0, 0, 0, 0, 0, 0};
unsigned long TotalSizes[10] = {50L*1024L, 100L*1024L, 200L*1024L, 400L*1024L, 0,
                                0, 0, 0, 0, 0};


///////////////////////////////////////////////////////////////////////////////
/*++
    FUNCTION:    DTParseArgv
    DESCRIPTION: Parses arguments
--*/
static void DTParseArgv(int argc, char **argv)
{
    int fMissingParm = 0;
    char *Name = *argv;
    char option;
    int  options_count;

    int  totalsize_count = 0;
    int  chunksize_count = 0;

    for(options_count = 0; options_count < 7; options_count++)
        Options[options_count] = -1;

    options_count = 0;

    argc--;
    argv++;
    while(argc)
        {
        if (**argv != '/' &&
            **argv != '-')
            {
            printf("Invalid switch: %s\n", *argv);
            argc--;
            argv++;
            }
        else
            {
            option = argv[0][1];
            argc--;
            argv++;

            // Most switches require a second command line arg.
            if (argc < 1)
                fMissingParm = 1;

            switch(option)
                {
                case 'e':
                    Endpoint = *argv;
                    argc--;
                    argv++;
                    break;
                case 't':
                    Protseq = *argv;
                    argc--;
                    argv++;
                    break;
                case 's':
                    NetworkAddr = *argv;
                    argc--;
                    argv++;
                    break;
                case 'i':
                    Iterations = atoi(*argv);
                    argc--;
                    argv++;
                    if (Iterations == 0)
                        Iterations = 10;
                    break;
                case 'm':
                    MinThreads = atoi(*argv);
                    argc--;
                    argv++;
                    if (MinThreads == 0)
                        MinThreads = 1;
                    break;
                case 'a':
                    AuthnLevelStr = *argv;
                    argc--;
                    argv++;
                    break;
                case 'n':
                    if (options_count < 7)
                        {
                        Options[options_count] = atoi(*argv);
                        options_count++;
                        }
                    else
                        printf("Maximum of seven -n switchs, extra ignored.\n");
                    argc--;
                    argv++;
                    break;
                case 'l':
                    LogFileName = *argv;
                    argc--;
                    argv++;
                    break;
#ifdef __RPC_WIN16__
                case 'y':
                    RpcWinSetYieldInfo(0, FALSE, 0, 0);
                    fMissingParm = 0;
                    break;
#endif

                case 'z':
                    if (totalsize_count < 9)
                        {
                        TotalSizes[totalsize_count++] = atol(*argv);
                        TotalSizes[totalsize_count] = 0;
                        }
                    else printf("Maximum of 9 -z switches, extra ignored.\n");
                    argc--;
                    argv++;
                    break;
                case 'c':
                    if (chunksize_count < 9)
                        {
                        ChunkSizes[chunksize_count++] = atoi(*argv);
                        ChunkSizes[chunksize_count] = 0;
                        }
                    else printf("Maximum of 9 -c switches, extra ignored.\n");
                    argc--;
                    argv++;
                    break;
                case 'd':
                    pFtpRoot = *argv;
                    argc--;
                    argv++;
                    break;
                case 'w':
                    pWwwRoot = *argv;
                    argc--;
                    argv++;
                    break;

                default:
                    fMissingParm = 0;
                    printf("Usage: %s: %s\n", Name, USAGE);
                    exit(0);
                    break;
                }

            if (fMissingParm)
                {
                printf("Invalid switch %s, missing required parameter\n", *argv);
                }
            }
        } // while argc

    // determine the security level
    if (strcmp("none", AuthnLevelStr) == 0)
        AuthnLevel = RPC_C_AUTHN_LEVEL_NONE;
    else if (strcmp("connect", AuthnLevelStr) == 0)
        AuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
    else if (strcmp("call", AuthnLevelStr) == 0)
        AuthnLevel = RPC_C_AUTHN_LEVEL_CALL;
    else if (strcmp("pkt", AuthnLevelStr) == 0)
        AuthnLevel = RPC_C_AUTHN_LEVEL_PKT;
    else if (strcmp("integrity", AuthnLevelStr) == 0)
        AuthnLevel = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
    else if (strcmp("privacy", AuthnLevelStr) == 0)
        AuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
    else
        {
        printf("%s is NOT a valid authentication level, default is NONE\n", AuthnLevelStr);
        }
#if 0
    printf("Config: %s:%s[%s]\n"
           "Iterations: %d\n"
           "Server threads %d\n"
           "Options: %d %d %d\n",
           Protseq, NetworkAddr, Endpoint, Iterations, MinThreads,
           Options[0], Options[1], Options[2]);
#endif

#ifdef WIN32
    printf("Process ID: %d\n", GetCurrentProcessId());
#else
#endif

    return;
}

/////////////////////////////////////////////////////////////////////
// Figure out what we're testing and start listening.
// 

int __cdecl
main (int argc, char **argv)
{
    unsigned int MinThreads;
    unsigned long i, status;
    RPC_BINDING_VECTOR *pBindingVector;

    DTParseArgv(argc, argv);

    MinThreads = 3;
    ClientsLeft = Clients = 1;
    ActiveClients = 0;
    Iterations = 1;

    if (Options[0] > 0) ClientsLeft = Clients = Options[0];     //  Clients

    Results = MIDL_user_allocate(4 * Clients);

    if (Options[1] > 0) MinThreads = Options[1];                //  MinThreads

    if (Options[2] < 0)
        {
        memset(TestCases, 1, TEST_MAX);     //  Default: Run all tests

        //
        //  HTTP PUT doesn't work.  Don't do these tests by default.
        //
        TestCases[RECV_BUFFER_HTTP] = 0;
        TestCases[RECV_FILE_HTTP] = 0;

        //
        //  Don't do internet tests if the
        //  -d or the -w switches aren't set appropriately
        //
        if (NULL == pFtpRoot)
            {
            TestCases[SEND_BUFFER_FTP1] = 0;
            TestCases[RECV_BUFFER_FTP1] = 0;
            TestCases[SEND_FILE_FTP] = 0;
            TestCases[RECV_FILE_FTP] = 0;
            TestCases[SEND_FILE_FTP1] = 0;
            TestCases[RECV_FILE_FTP1] = 0;
            }
        if (NULL == pWwwRoot)
            {
            TestCases[SEND_BUFFER_HTTP] = 0;
            TestCases[RECV_BUFFER_HTTP] = 0;
            TestCases[SEND_FILE_HTTP] = 0;
            TestCases[RECV_FILE_HTTP] = 0;
            }
        }
    else                                    //  else run specified tests
        {
        memset(TestCases, 0, TEST_MAX);
        for(i = 2; i < 7; i++)
            {
            if ( (Options[i] < 0) || (Options[i] >= TEST_MAX) ) break;
            TestCases[Options[i]] = 1;
            }
        }

    //
    //  See make sure that there are tests to run
    //  and set CurrentCase to the first one.
    //
    CurrentCase = 0;
    for(i = 0; i < TEST_MAX; i++)
        {
        if (TestCases[i])
            {
            CurrentCase = i;
            break;
            }
        }

    if ( (pFileName == 0) && (i == TEST_MAX))
        {
        printf("No test cases selected!\n");
        return 1;
        }
    if (ChunkSizes[0] == 0)
        {
        printf("Chunk Size must be non-zero.\n");
        return 1;
        }
    if ( (pFileName == 0) && (TotalSizes[0] == 0))
        {
        printf("Total Size must be non-zero.\n");
        return 1;
        }

    CurrentIter = Iterations;
    if (CurrentIter == 0) CurrentIter = 1;

    CurrentChunkIndex = 0;
    CurrentTotalIndex = 0;

    InitializeCriticalSection(&CritSec);

    GoEvent = CreateEvent(0,
                          TRUE,
                          FALSE,
                          0);

    DoneEvent = CreateEvent(0,
                            TRUE,
                            FALSE,
                            0);

    //
    // Actually start the server
    //

    printf("FTP Directory: %s\n", (0 == pFtpRoot ? "<NONE>": pFtpRoot));
    printf("WWW Directory: %s\n", (0 == pWwwRoot ? "<NONE>": pWwwRoot));

    if (Endpoint)
        {
        status = RpcServerUseProtseqEp(Protseq, 100, Endpoint, 0);
        CHECK_STATUS(status, "RpcServerUseProtseqEp");
        }
    else
        {
        char *string_binding;

        status = RpcServerUseProtseq(Protseq, 100, 0);
        CHECK_STATUS(status, "RpcServerUseProtseqEp");

        status = RpcServerInqBindings(&pBindingVector);
        CHECK_STATUS(status, "RpcServerInqBindings");

        status = RpcEpRegister(DataTranPerf_v1_0_s_ifspec,
                               pBindingVector,
                               0,
                               0);
        CHECK_STATUS(status, "RpcEpRegister");

        status = RpcBindingToStringBinding(pBindingVector->BindingH[0],
                                           &string_binding);
        CHECK_STATUS(status, "RpcBindingToStringBinding");

        status = RpcStringBindingParse(string_binding,
                                       0, 0, 0, &Endpoint, 0);

        CHECK_STATUS(status, "RpcStringBindingParse");
        printf("Listening to %s:[%s]\n\n", Protseq, Endpoint);
        }

    status = RpcServerRegisterIf(DataTranPerf_v1_0_s_ifspec,0,0);
    CHECK_STATUS(status, "RpcServerRegisterIf");

    status = RpcServerRegisterAuthInfo(NULL,
                                       RPC_C_AUTHN_WINNT,
                                       NULL,
                                       NULL);
    CHECK_STATUS(status, "RpcServerRegisterAuthInfo");

    printf("Base Iterations: %d, Clients %d, MinThreads %d\n",
           Iterations,
           Clients,
           MinThreads);

    printf("Server listening\n");

    status = RpcServerListen(MinThreads, 100, 0);
    CHECK_STATUS(status, "RpcServerListen");

    printf("This doesn't stop listening..hmm\n");
}

/********************************************************************
 *  Control APIs that the client(s) call to sync on test cases, iterations
 *  and to report results.
 ********************************************************************/

error_status_t
BeginTest(handle_t b,
          long *ClientId)
{
    long status = 0;
    EnterCriticalSection(&CritSec);

    if (ActiveClients < Clients)
        {
        ActiveClients++;
        *ClientId = ActiveClients;
        }
    else
        {
        status = PERF_TOO_MANY_CLIENTS;
        }
    LeaveCriticalSection(&CritSec);

    return status;
}

//---------------------------------------------------------
error_status_t
NextTest(handle_t b,
         TEST_TYPE *Test,
         long *Iters,
         long *Length,
         long *ChunkSize)
{
    long wait   = 1;
    long done   = 0;
    int i;

    EnterCriticalSection(&CritSec);

    *Test = CurrentCase;
    *Iters = CurrentIter;
    *ChunkSize = ChunkSizes[CurrentChunkIndex];
    *Length = TotalSizes[CurrentTotalIndex];

    ClientsLeft--;

    if (CurrentCase == TEST_MAX)
        {
        done = 1;
        }

    if (ClientsLeft == 0)
        {
        //
        // Let all the waiting clients go
        //
        wait = 0;
        ResetEvent(DoneEvent);
        SetEvent(GoEvent);
        }

    LeaveCriticalSection(&CritSec);

    if (wait)
        {
        WaitForSingleObject(GoEvent, INFINITE);
        }

    if (done)
        {

        if (ClientsLeft == 0)
            {
            // I'm the last client, sleep and then reset for
            // a new set of clients.  Sleep avoids a race (usually).

            Sleep(1000);

            //
            //  Reset CurrentCase
            //
            for(i = 0; i < TEST_MAX; i++)
                {
                if (TestCases[i])
                    {
                    CurrentCase = i;
                    break;
                    }
                }

            CurrentIter = Iterations;
            if (CurrentIter == 0) CurrentIter = 1;

            ActiveClients = 0;
            ClientsLeft   = Clients;

            ResetEvent(GoEvent);
            ResetEvent(DoneEvent);
            }

        return PERF_TESTS_DONE;
        }

    return 0;
}

//---------------------------------------------------------
error_status_t
EndTest(handle_t b,
        unsigned long mseconds)
{
    long status, i;
    long wait = 1;
    char szTempString[80];

    EnterCriticalSection(&CritSec);

    Results[ClientsLeft] = mseconds;

    ClientsLeft++;

    if (ClientsLeft == Clients)
        {
        // All clients have finished

        // Report results

        if (pFileName == 0)
            {
            sprintf(szTempString,
                    TestNames[CurrentCase],
                    TotalSizes[CurrentTotalIndex],
                    ChunkSizes[CurrentChunkIndex]),
            printf("| % 3d | %-40s | % 4d |",
                   CurrentCase,
                   szTempString,
                   CurrentIter
                   );
            }
        else
            {
            printf("Liar!  The filename option ain't implemented yet");
            exit(0);
            }

        for(i = 0; i < Clients; i++)
            printf(" % 7d.%03d |",
                   Results[i] / CurrentIter,
                   Results[i] % CurrentIter * 1000 / CurrentIter
                   );

        printf("\n");

        //
        //  Find next case...
        //
        for(i = CurrentCase + 1; i < TEST_MAX; i++)
            if (TestCases[i])
                {
                CurrentCase = i;
                break;
                }
        if (i == TEST_MAX)
            {
            if (ChunkSizes[++CurrentChunkIndex] == 0)
                {
                CurrentChunkIndex = 0;
    
                if (TotalSizes[++CurrentTotalIndex] == 0)
                    {
                    //
                    //  This tells NextTest that we're done.
                    //
                    CurrentCase = TEST_MAX;

                    printf("TEST DONE\n");
                    }
                }
            if (TEST_MAX != CurrentCase)
                {
                int i;
                //
                //  Go back to the first case.
                //
                for(i = 0; i < TEST_MAX; i++)
                    {
                    if (TestCases[i])
                        {
                        CurrentCase = i;
                        break;
                        }
                    }
                }
            }

        CurrentIter = Iterations;
        if (CurrentIter == 0) CurrentIter = 1;

        //
        // We're setup for the next test (or to finish) let the clients go.
        //

        wait = 0;
        ResetEvent(GoEvent);
        SetEvent(DoneEvent);

        }
    LeaveCriticalSection(&CritSec);

    if (wait)
        WaitForSingleObject(DoneEvent, INFINITE);

    return 0;
}

//---------------------------------------------------------
//
// For fixed endpoint and re-bind test case
//
unsigned char *GetFixedEp(handle_t h)
{
    char *r;

    r = malloc(strlen(Endpoint) + 1);
    strcpy(r, Endpoint);
    return (unsigned char *)r;
}

void GetServerName (handle_t b,
                    unsigned long int BufferSize,
                    unsigned char *szServer)
{
    if (FALSE == GetComputerName (szServer, &BufferSize))
        {
        *szServer = 0;
        }
}


//===================================================================
//  File Context Stuff
//===================================================================
typedef struct
{
    HANDLE  hFile;
    TCHAR   FileName[MAX_PATH];
} DT_S_FILE_HANDLE;

//---------------------------------------------------------
DT_FILE_HANDLE RemoteOpen (handle_t b, unsigned long ulLength)
/*++
    FUNCTION:    RemoteOpen
    DESCRIPTION: Opens a temporary file and return a handle to client
--*/
{
    DT_S_FILE_HANDLE   *pFileContext = NULL;

    pFileContext = (DT_S_FILE_HANDLE *)MIDL_user_allocate(sizeof(DT_S_FILE_HANDLE));
    if (pFileContext == NULL)
        {
        printf("RemoteOpen: Out of memory!\n");
        return (DT_FILE_HANDLE) NULL;
        }

    //
    //  If Length is zero, the file is opened for receive from the client.
    //  So we use the prefix FSR (Server Receive); otherwise we use FSS.
    //
    CreateTempFile (NULL,
                    (0 == ulLength ? TEXT("FSR") : TEXT("FSS")),
                    ulLength,
                    (LPTSTR) pFileContext->FileName);

    pFileContext->hFile = CreateFile ((LPTSTR) pFileContext->FileName,
                                      (ulLength == 0 ? GENERIC_WRITE : GENERIC_READ),
                                      0,
                                      (LPSECURITY_ATTRIBUTES) NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      (HANDLE) NULL);

    if (pFileContext->hFile  == INVALID_HANDLE_VALUE)
        {
        printf("RemoteOpen: Cannot create temp file!\n");
        MIDL_user_free (pFileContext);
        return (DT_FILE_HANDLE) NULL;
        }

    return ((DT_FILE_HANDLE) pFileContext);
}

//---------------------------------------------------------
DT_FILE_HANDLE RemoteCreateFtpFile (handle_t        Binding,
                                    boolean         f_StoC,
                                    unsigned long   ulLength,
                                    unsigned long   ulBufferSize,
                                    unsigned char  *szRemotePath)
{
    DT_S_FILE_HANDLE   *pFileContext = NULL;
    unsigned long       iTheFileName;

    //
    //  Is the FTP Root directory specified?
    //
    if (NULL == pFtpRoot)
        {
        printf("RemoteCreateFtpFile: FTP Root Path not set.\n");
        return (DT_FILE_HANDLE) NULL;
        }

    //
    //  Allocate memory for the context handle
    //
    pFileContext = (DT_S_FILE_HANDLE *)MIDL_user_allocate(sizeof(DT_S_FILE_HANDLE));
    if (pFileContext == NULL)
        {
        printf("RemoteCreateFtpFile: Out of memory!\n");
        return (DT_FILE_HANDLE) NULL;
        }
    //
    //  This file is dealt with by the FTP server, so we don't need a handle to it.
    //  However, we need the file name so we can delete it later.
    //
    pFileContext->hFile = INVALID_HANDLE_VALUE;
    //
    //  Create a temp file to be sent to the client
    //
    if (FALSE == CreateTempFile (pFtpRoot,
                                 (TRUE == f_StoC ? TEXT("FSS") : TEXT("FSR")),
                                 (TRUE == f_StoC ? ulLength : 0),
                                 pFileContext->FileName))
        {
        MIDL_user_free (pFileContext);
        return (DT_FILE_HANDLE) NULL;
        }

    //
    //  We want to tell the client the actual filename only - no path.
    //
    for (iTheFileName = lstrlen (pFileContext->FileName)-1;
         iTheFileName>=0;
         iTheFileName--)
        {
        if (pFileContext->FileName[iTheFileName] == (TCHAR)'\\')
            {
            break;
            }
        }

    if ((ulBufferSize + iTheFileName ) < (unsigned long)lstrlen (pFileContext->FileName))
        {
        printf("RemoteCreateFtpFile: Buffer Size too small to hold path.\n");
        MIDL_user_free (pFileContext);
        return ((DT_FILE_HANDLE) NULL);
        }
    lstrcpy (szRemotePath, &(pFileContext->FileName[iTheFileName]));

    return ((DT_FILE_HANDLE) pFileContext);
}
//---------------------------------------------------------
DT_FILE_HANDLE RemoteCreateHttpFile (handle_t       Binding,
                                     boolean        f_StoC,
                                     unsigned long  ulLength,
                                     unsigned long  ulBufferSize,
                                     unsigned char *szRemotePath)
{
    DT_S_FILE_HANDLE   *pFileContext = NULL;
    unsigned long       iTheFileName;

    //
    //  Is the FTP Root directory specified?
    //
    if (NULL == pWwwRoot)
        {
        printf("RemoteCreateHttpFile: WWW Root Path not set.\n");
        return (DT_FILE_HANDLE) NULL;
        }

    //
    //  Allocate memory for the context handle
    //
    pFileContext = (DT_S_FILE_HANDLE *)MIDL_user_allocate(sizeof(DT_S_FILE_HANDLE));
    if (pFileContext == NULL)
        {
        printf("RemoteCreateHttpFile: Out of memory!\n");
        return (DT_FILE_HANDLE) NULL;
        }
    //
    //  This file is dealt with by the HTTP server, so we don't need a handle to it.
    //  However, we need the file name so we can delete it later.
    //
    pFileContext->hFile = INVALID_HANDLE_VALUE;
    //
    //  Create a temp file to be sent to the client
    //
    if (FALSE == CreateTempFile (pWwwRoot,
                                 (TRUE == f_StoC ? TEXT("FSS") : TEXT("FSR")),
                                 (TRUE == f_StoC ? ulLength : 0),
                                 pFileContext->FileName))
        {
        MIDL_user_free (pFileContext);
        return (DT_FILE_HANDLE) NULL;
        }

    //
    //  We want to tell the client the actual filename only - no path.
    //
    for (iTheFileName = lstrlen (pFileContext->FileName)-1;
         iTheFileName>=0;
         iTheFileName--)
        {
        if (pFileContext->FileName[iTheFileName] == (TCHAR)'\\')
            {
            break;
            }
        }

    if ((ulBufferSize + iTheFileName ) < (unsigned long)lstrlen (pFileContext->FileName))
        {
        printf("RemoteCreateHttpFile: Buffer Size too small to hold path.\n");
        MIDL_user_free (pFileContext);
        return ((DT_FILE_HANDLE) NULL);
        }
    lstrcpy (szRemotePath, &(pFileContext->FileName[iTheFileName]));
    if ((TCHAR)'\\' == szRemotePath[0])
        {
        szRemotePath[0] = (TCHAR)'/';
        }

    return ((DT_FILE_HANDLE) pFileContext);
}

//---------------------------------------------------------
void RemoteResetFile (DT_FILE_HANDLE phContext)
{
    assert (NULL != phContext);

    if (INVALID_HANDLE_VALUE != ((DT_S_FILE_HANDLE *)phContext)->hFile)
        {
        SetFilePointer (((DT_S_FILE_HANDLE *)phContext)->hFile,
                        0,
                        NULL,
                        FILE_BEGIN);
        }
}

//---------------------------------------------------------
void __RPC_USER DT_FILE_HANDLE_rundown(DT_FILE_HANDLE phContext)
{
    if (phContext)
        {
        if (((DT_S_FILE_HANDLE *)phContext)->hFile != INVALID_HANDLE_VALUE)
            CloseHandle(((DT_S_FILE_HANDLE *)phContext)->hFile);
        MIDL_user_free (phContext);
        }
}

//---------------------------------------------------------
void RemoteClose (DT_FILE_HANDLE *pp, boolean fDelete)
{
    assert ( (NULL != *pp) &&
             (NULL != **(DT_S_FILE_HANDLE **)pp)
           );

    if (INVALID_HANDLE_VALUE != (*(DT_S_FILE_HANDLE **)pp)->hFile)
        {
        CloseHandle((*(DT_S_FILE_HANDLE **)pp)->hFile);
        }

    if (TRUE == fDelete)
        {
        DeleteFile((*(DT_S_FILE_HANDLE **)pp)->FileName);
        }

    MIDL_user_free(*pp);
    *pp = NULL;
}

//===================================================================
//  Memory Handle stuff
//      - Each thread that uses the pipes tests will need a buffer
//      to push or pull data.  This is achieved through this memory
//      context handle.
//===================================================================
typedef struct
{
    unsigned char __RPC_FAR *pPtr;
    unsigned long ulLength;
} DT_S_MEM_HANDLE;

//---------------------------------------------------------
DT_MEM_HANDLE RemoteAllocate (handle_t h, unsigned long ulLength)
{
    DT_S_MEM_HANDLE *pMemContext = NULL;

    pMemContext = (DT_S_MEM_HANDLE *)MIDL_user_allocate(sizeof(DT_S_MEM_HANDLE));
    if (pMemContext == NULL)
        {
        printf("RemoteAllocate: Out of memory!\n");
        return (DT_FILE_HANDLE) NULL;
        }

    pMemContext->pPtr = (unsigned char __RPC_FAR *)MIDL_user_allocate(ulLength);
    if (pMemContext->pPtr == NULL)
        {
        printf("RemoteAllocate: Out of memory!\n");
        MIDL_user_free (pMemContext);
        return (DT_FILE_HANDLE) NULL;
        }

    pMemContext->ulLength = ulLength;

    return (DT_MEM_HANDLE) pMemContext;
}

//---------------------------------------------------------
void __RPC_USER DT_MEM_HANDLE_rundown(DT_MEM_HANDLE phContext)
{
    printf("DT_MEM_HANDLE_rundown Entered\n");
    if (phContext)
        {
        if (((DT_S_MEM_HANDLE *)phContext)->pPtr != NULL)
            MIDL_user_free(((DT_S_MEM_HANDLE *)phContext)->pPtr);
        MIDL_user_free (phContext);
        }
    printf("DT_MEM_HANDLE_rundown Exited\n");
}

//---------------------------------------------------------
void RemoteFree (DT_MEM_HANDLE *pMemContext)
{
    assert( ((*(DT_S_MEM_HANDLE **)pMemContext) != NULL) &&
            ((*(DT_S_MEM_HANDLE **)pMemContext)->pPtr != NULL)
          );

    //
    //  Free the block of memory
    //
    MIDL_user_free ((*(DT_S_MEM_HANDLE **)pMemContext)->pPtr);
    (*(DT_S_MEM_HANDLE **)pMemContext)->pPtr = NULL;

    //
    //  Then free the handle itself!
    //
    MIDL_user_free (*pMemContext);
    *pMemContext = (DT_MEM_HANDLE) NULL;
}

//===================================================================
//  Regular RPCs
//===================================================================

void C_to_S_Buffer (handle_t h, unsigned long int BufferSize, byte Buffer[])
{
    return;
}

//---------------------------------------------------------
void S_to_C_Buffer (handle_t h, unsigned long int BufferSize, byte Buffer[])
{
    return;
}

//---------------------------------------------------------
void C_to_S_BufferWithFile (handle_t h,
                            DT_FILE_HANDLE pContext,
                            unsigned long int BufferSize,
                            byte Buffer[])
{
    long dwBytesWritten;

    WriteFile(((DT_S_FILE_HANDLE *)pContext)->hFile,
              Buffer,
              BufferSize,
              &dwBytesWritten,
              NULL);
}

//---------------------------------------------------------
long S_to_C_BufferWithFile (handle_t h,
                            DT_FILE_HANDLE pContext,
                            unsigned long int BufferSize,
                            byte Buffer[])
{
    unsigned long dwBytesRead;

    ReadFile(((DT_S_FILE_HANDLE *)pContext)->hFile,
             Buffer,
             BufferSize,
             &dwBytesRead,
             NULL);

    return dwBytesRead;
}

//===================================================================
//  RPC Pipes
//===================================================================

void S_to_C_Pipe(handle_t       h,
                 UCHAR_PIPE     ThePipe,
                 unsigned long  ulLength,
                 DT_MEM_HANDLE  pMemHandle)
{
    unsigned long dwBytesSent;

    while (ulLength >= ((DT_S_MEM_HANDLE *)pMemHandle)->ulLength)
        {
        (ThePipe.push) (ThePipe.state,
                        ((DT_S_MEM_HANDLE *)pMemHandle)->pPtr,
                        ((DT_S_MEM_HANDLE *)pMemHandle)->ulLength);

        ulLength -= ((DT_S_MEM_HANDLE *)pMemHandle)->ulLength;
        }
    if (ulLength != 0)
        {
        (ThePipe.push) (ThePipe.state,
                        ((DT_S_MEM_HANDLE *)pMemHandle)->pPtr,
                        ulLength);
        }
    (ThePipe.push) (ThePipe.state,
                    ((DT_S_MEM_HANDLE *)pMemHandle)->pPtr,
                    0);
}

//---------------------------------------------------------
void C_to_S_Pipe (handle_t      h,
                  UCHAR_PIPE    ThePipe,
                  DT_MEM_HANDLE pMemHandle)
{
    unsigned long nBytesReceived;

    for(;;)
        {
        (ThePipe.pull) (ThePipe.state,
                        ((DT_S_MEM_HANDLE *)pMemHandle)->pPtr,
                        ((DT_S_MEM_HANDLE *)pMemHandle)->ulLength,
                        &nBytesReceived);

        if (nBytesReceived == 0) break;
        }
}

//---------------------------------------------------------
void S_to_C_PipeWithFile (handle_t          h,
                          UCHAR_PIPE        ThePipe,
                          DT_FILE_HANDLE    pContext,
                          DT_MEM_HANDLE     pMemHandle)
{
    unsigned long dwBytesRead;

    for(;;)
        {
        ReadFile(((DT_S_FILE_HANDLE *)pContext)->hFile,
                 ((DT_S_MEM_HANDLE *)pMemHandle)->pPtr,
                 ((DT_S_MEM_HANDLE *)pMemHandle)->ulLength,
                 &dwBytesRead,
                 NULL);

        (ThePipe.push) (ThePipe.state,
                        ((DT_S_MEM_HANDLE *)pMemHandle)->pPtr,
                        dwBytesRead);

        if (dwBytesRead == 0) break;
        }
}

//---------------------------------------------------------
void C_to_S_PipeWithFile (handle_t          h,
                          UCHAR_PIPE        ThePipe,
                          DT_FILE_HANDLE    pContext,
                          DT_MEM_HANDLE     pMemHandle)
{
    unsigned long nBytesReceived;
    unsigned long dwBytesWritten;

    for(;;)
        {
        (ThePipe.pull) (ThePipe.state,
                        ((DT_S_MEM_HANDLE *)pMemHandle)->pPtr,
                        ((DT_S_MEM_HANDLE *)pMemHandle)->ulLength,
                        &nBytesReceived);

        if (nBytesReceived == 0) break;

        WriteFile(((DT_S_FILE_HANDLE *)pContext)->hFile,
                  ((DT_S_MEM_HANDLE *)pMemHandle)->pPtr,
                  nBytesReceived,
                  &dwBytesWritten,
                  NULL);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\inc\rpcperf.h ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    rpcperf.h

Abstract:

    Header file shared by performance tests.  It is also used
    as a pre-compiled header on NT.

Author:

    Mario Goertzel (mariogo)   01-Apr-1994

Revision History:

--*/


#ifdef WIN32
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#endif

#ifdef WIN
#include <windows.h>
#endif

#include <rpc.h>
#include <stdio.h>
#include <stdlib.h>

#pragma hdrstop

// Common functions shared by RPC development performance tests

extern char         *Endpoint;
extern char         *Protseq;
extern char         *NetworkAddr;
extern unsigned long Iterations;
extern unsigned long Interval;
extern unsigned int  MinThreads;
extern char         *AuthnLevelStr;
extern unsigned long AuthnLevel;
extern long          Options[7];
extern char         *LogFileName;
extern unsigned int  OutputLevel;
extern int           AppendOnly;
extern RPC_NOTIFICATION_TYPES NotificationType;
extern char         *ServerPrincipalName;
extern int          TlsIndex;

extern void ParseArgv(int, char **);
extern void PauseForUser(char *);
extern void FlushProcessWorkingSet();
extern void StartTime();
extern unsigned long FinishTiming();
extern void EndTime(char *);
extern void ApiError(char *, unsigned long);
extern void Dump(char *,...);
extern void Verbose(char *, ...);
extern void Trace(char *,...);

#define printf Dump
#define dbgprintf Trace

#define CHECK_STATUS(status, string) if (status) {                       \
        printf("%s failed - %d (%08x)\n", (string), (status), (status)); \
        exit(1);                                                         \
        } else dbgprintf("%s okay\n", (string));

#define PERF_TEST_NOTIFY        (WM_USER + 101)
#define WMSG_RPCMSG     (WM_USER + 'w'+'m'+'s'+'g')
#define WMSG_SCAVENGE   (WMSG_RPCMSG + 1)

void RunMessageLoop(HWND hWnd);
void PumpMessage(void);
HWND CreateSTAWindow(char *lpszWinName);

void InitAllocator(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\lpc\lpctest.h ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    lpctest.h

Abstract:

    Shared include file for LPC performance test.

Author:

    Mario Goertzel (mariogo)   30-Mar-1994

Revision History:

--*/

#ifndef _LPC_HEADER
#define _LPC_HEADER

#define DEFAULT_PORT_DIR  "\\RPC Control\\"
#define DEFAULT_PORT_NAME "Default Port"

#define MAX_CLIENTS  16

#define PERF_BIND                    1
#define PERF_REQUEST                 2
#define PERF_REPLY                   3
#define PERF_SHARED_REQUEST          4
#define PERF_SHARED_REPLY            5
#define PERF_READ_CLIENT_BUFFER      6
#define PERF_READ_SERVER_BUFFER      7

typedef struct
{
    PORT_MESSAGE Lpc;
    unsigned long MsgType;
} LPC_PERF_COMMON;

typedef struct
{
    LPC_PERF_COMMON;
    char Buffer[PORT_MAXIMUM_MESSAGE_LENGTH - sizeof(LPC_PERF_COMMON)];
} LPC_PERF_PACKET;

typedef struct
{
    LPC_PERF_COMMON;
    PORT_DATA_INFORMATION;
} LPC_PERF_BUFFER;

typedef struct
{
    LPC_PERF_COMMON;
} LPC_PERF_SHARED;

typedef struct
{
    LPC_PERF_COMMON;
    unsigned long   BufferLengthIn;
    unsigned long   BufferLengthOut;
} LPC_PERF_BIND;

typedef union
{
    PORT_MESSAGE Lpc;
    LPC_PERF_COMMON Common;
    LPC_PERF_PACKET Packet;
    LPC_PERF_BUFFER Buffer;
    LPC_PERF_SHARED Shared;
    LPC_PERF_BIND   Bind;
} LPC_PERF_MESSAGE;

#endif /* _LPC_HEADER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\local\local.c ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    local.c

Abstract:

    RPC performance to measure system/processor/memory overhead.
    memcpy, string operations, memory allocation, kernel traps

Author:

    Mario Goertzel (mariogo)   30-Mar-1994

Revision History:

--*/

#include<rpcperf.h>

#define REGISTRY_ROOT_KEY   HKEY_LOCAL_MACHINE
static char * RPC_UUID_PERSISTENT_DATA="Software\\Description\\Microsoft\\Rpc\\3.1\\RpcUuidPersistentData";
static char * PREV_CLOCK_SEQUENCE="PreviousClockSequence";
static char * PREV_TIME_ALLOCATED="PreviousTimeAllocated";

const char *USAGE="-n case -i iterations\n"
                  "           -n 1     - Memory copy\n"
                  "           -n 2     - String copy\n"
                  "           -n 3     - String length\n"
                  "           -n 4     - Allocate/free memory\n"
                  "           -n 5     - Kernel traps (set and reset event)\n"
                  "           -n 6     - GetTickCount\n"
                  "           -n 7     - Open & Query Registry\n"
                  "           -n 8     - Query Registry\n"
                  "           -n 9     - Open & Update Registry\n"
                  "           -n 10    - Update Registry\n";

int __cdecl
main(int argc, char **argv)
{
    unsigned int i;
    int size;
    unsigned long seconds, mseconds;
    char *buffer;
    char *buffer2;
    HANDLE event;
    HANDLE heap;
    long status;

    ParseArgv(argc, argv);

    if (Options[0] == -1)
        {
        puts(USAGE);
        exit(1);
        }

    if (Options[0] < 4 && Options[0] > 0)
        {
        if ((Options[1] < 0) || (Options[2] < 0) || (Options[2] < Options[1]))
            {
            printf("Case %d requires -n start -n end_size switches\n",
                   Options[0]);
            exit(1);
            }
        buffer = RtlAllocateHeap(RtlProcessHeap(),0,Options[2]);
        buffer2 = RtlAllocateHeap(RtlProcessHeap(),0,Options[2]);

        // For string tests
        for(i = 0; i < (unsigned long)Options[1]; i++)
            buffer[i] = 'M';

        printf("Start size, end size: %d, %d\n", Options[1], Options[2]);
        }


    switch (Options[0])
        {
        case 1:
            // Memory copy test
            size = Options[1];
            while(size < Options[2])
                {
                printf("Size: % 6d : ", size);
                StartTime();
                for(i = 0; i < Iterations; i++)
                    memcpy(buffer,buffer2,size);
                EndTime("for memcpy");
                size *= 2;
                }

            break;

        case 2:
            // String copy test
            size = Options[1];
            while(size < Options[2])
                {
                printf("Lenght: % 6d : ", size);
                for(i = 0; i < (unsigned long)size-1; i++)
                    buffer[i] = 'A';
                buffer[size-1] = '\0';

                StartTime();
                for(i = 0; i < Iterations; i++)
                    strcpy(buffer2, buffer);
                EndTime("for strcpy");
                size *= 2;
                }

            break;

        case 3:
            // String len test
            size = Options[1];
            while(size < Options[2])
                {
                printf("Lenght: % 6d : ", size);
                for(i = 0; i < (unsigned long)size-1; i++)
                    buffer[i] = 'A';
                buffer[size-1] = '\0';

                StartTime();
                for(i = 0; i < Iterations; i++)
                    strlen(buffer);
                EndTime("for strlen");
                size *= 2;
                }

            break;

        case 4:
            // Allocate/Free tests
            if (Options[1] == -1)
                {
                printf("Memory test requires an addition -n switch for block size\n");
                exit(1);
                }
            printf("Block size: %d\n", Options[1]);
            heap = RtlProcessHeap();

            StartTime();
            for(i = 0; i < Iterations; i++)
                {
                buffer = RtlAllocateHeap(heap,0,Options[1]);
                RtlFreeHeap(heap, 0, buffer);
                }
            EndTime("for Rtl{Alloc,Free}Heap");

            StartTime();
            for(i = 0; i < Iterations; i++)
                {
                buffer = malloc(Options[1]);
                free(buffer);
                }
            EndTime("for Malloc/Free");

            StartTime();
            for(i = 0; i < Iterations; i++)
                {
                buffer = LocalAlloc(0, Options[1]);
                LocalFree(buffer);
                }
            EndTime("for Local{Alloc/Free} (0)");

            StartTime();
            for(i = 0; i < Iterations; i++)
                {
                buffer = LocalAlloc(LPTR, Options[1]);
                LocalFree(buffer);
                }
            EndTime("for Local{Alloc/Free} (LPTR)");

            break;

        case 5:
            // Kernel traps
            event = CreateEvent(0, FALSE, FALSE, 0);
            CHECK_STATUS(event == 0, "CreateEvent");

            StartTime();
            for(i = 0; i < Iterations; i++)
                SetEvent(event);
            EndTime("for SetEvent");

            StartTime();
            for(i = 0; i < Iterations; i++)
                ResetEvent(event);
            EndTime("for ResetEvent");

            break;

        case 6:
            // GetTickCount
            StartTime();
            for(i = 0; i < Iterations; i++)
                GetTickCount();
            EndTime("for GetTickCount");

            break;

        case 7:
            {
            // Open and Query Registry
            HKEY Key;
            DWORD BufLen = 30;
            char String[30];

            StartTime();
            for (i = 0; i < Iterations; i++)
                {
                status =
                RegOpenKey(REGISTRY_ROOT_KEY,
                           RPC_UUID_PERSISTENT_DATA,
                           &Key);

                if (status)
                    printf("RegOpenKey returned %d\n", status);

                status =
                RegQueryValue(Key,
                              PREV_CLOCK_SEQUENCE,
                              String,
                              &BufLen);
                if (status)
                    printf("RegQueryValue returned %d\n", status);

                RegCloseKey(Key);
                }
            EndTime("for opening and querying a registry key");
            }

            break;

        case 8:
            {
            // Query Registry
            HKEY Key;
            DWORD BufLen = 30;
            char String[30];

            status =
            RegOpenKey(REGISTRY_ROOT_KEY,
                       RPC_UUID_PERSISTENT_DATA,
                       &Key);

            if (status)
                printf("RegOpenKey returned %d\n", status);

            StartTime();
            for (i = 0; i < Iterations; i++)
                {
                status =
                RegQueryValue(Key,
                              PREV_CLOCK_SEQUENCE,
                              String,
                              &BufLen);

                if (status)
                    printf("RegQueryValue returned %d\n", status);

                }
            EndTime("for querying a registry key");
            RegCloseKey(Key);
            }

            break;

        case 9:
            {
            // Create and update.
            HKEY Key;
            DWORD BufLen;
            static const char String[] = "24682468";

            StartTime();
            for (i = 0; i < Iterations; i++)
                {
                status =
                RegCreateKey(REGISTRY_ROOT_KEY,
                             RPC_UUID_PERSISTENT_DATA,
                             &Key);

                if (status)
                    printf("RegOpenKey returned %d\n", status);

                status =
                RegSetValue(Key,
                            PREV_CLOCK_SEQUENCE,
                            REG_SZ,
                            String,
                            strlen(String)+1);

                if (status)
                    printf("RegSetValue returned %d\n", status);

                RegCloseKey(Key);
                }
            EndTime("for creating and updateing a registry key.");
            }

            break;

        case 10:
            {
            // Update Registry
            HKEY Key;
            DWORD BufLen;
            static const char String[] = "24682468";

            status =
            RegCreateKey(REGISTRY_ROOT_KEY,
                         RPC_UUID_PERSISTENT_DATA,
                         &Key);
            if (status)
                printf("RegOpenKey returned %d\n", status);

            StartTime();
            for (i = 0; i < Iterations; i++)
                {
                status =
                RegSetValue(Key,
                            PREV_CLOCK_SEQUENCE,
                            REG_SZ,
                            String,
                            strlen(String)+1);

                if (status)
                    printf("RegSetValue returned %d\n", status);

                }
            EndTime("for updating a registry key.");
            RegCloseKey(Key);
            }

            break;
        }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\lpc\client\client.c ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    client.c

Abstract:

    NT LPC performance test used to compare with RLRPC performance.
    Currently limited to message I/O only, it won't do large I/O.

Author:

    Mario Goertzel (mariogo)   29-Mar-1994

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpcperf.h>
#include <lpctest.h>

const char *USAGE = "-n test_case -n in_size -n out_size\n"
                    "   Cases:\n"
                    "     1: data as part of message, max ~240 byte sizes\n"
		    "     2: read/write data from client address space, sizes unlimited\n";

#define MAX(a,b) ((a)>(b))?(a):(b)

int __cdecl
main(int argc, char **argv)
{
    ULONG i;
    HANDLE portServer;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    ANSI_STRING    ansiPortName;
    UNICODE_STRING unicodePortName;
    char pszPortName[100];
    NTSTATUS status;
    LPC_PERF_MESSAGE *pMessage, *pReplyMessage;
    char *BigBuffer;
    unsigned long ConnectInfoSize = sizeof(LPC_PERF_BIND)-sizeof(PORT_MESSAGE);
    ULONG RequestSize, ReplySize;

    ParseArgv(argc, argv);

    RequestSize = Options[1];
    ReplySize   = Options[2];

    if ( (Options[0] < 0)
        || (Options[0] > 2)
        || (RequestSize < 0)
        || (ReplySize < 0) )
        {
        printf("%s: Usage:\n",
	       USAGE,
               argv[0]
              );
        return 1;
        }

    /* Create Port */

    strcpy(pszPortName, DEFAULT_PORT_DIR);
    strcat(pszPortName, DEFAULT_PORT_NAME);

    RtlInitAnsiString(&ansiPortName, pszPortName);

    RtlAnsiStringToUnicodeString(&unicodePortName,
                                 &ansiPortName,
                                 TRUE);

    BigBuffer =     malloc(MAX(RequestSize,ReplySize));
    pMessage =      malloc(sizeof(LPC_PERF_MESSAGE));
    pReplyMessage = malloc(sizeof(LPC_PERF_MESSAGE));

    if (pMessage == 0
        || pReplyMessage == 0
        || BigBuffer == 0)
        {
        printf("Error: Malloc failed\n");
        return 1;
        }

    SecurityQos.EffectiveOnly = TRUE;
    SecurityQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQos.ImpersonationLevel = SecurityImpersonation;

    SecurityQos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);

    pMessage->Bind.MsgType = PERF_BIND;
    pMessage->Bind.BufferLengthIn = RequestSize;
    pMessage->Bind.BufferLengthOut = ReplySize;

    status =
    NtConnectPort(&portServer,
                  &unicodePortName,
                  &SecurityQos,
                  0,               // No attributes
                  0,
                  0,
                  ((char *)pMessage + sizeof(PORT_MESSAGE)),
                  &ConnectInfoSize);

    CHECK_STATUS(status, "NtConnectPort");

    printf("Connected to server\n");

    switch(Options[0])
        {
        case 1:
            pMessage->Lpc.u1.s1.TotalLength = (USHORT)RequestSize + sizeof(LPC_PERF_COMMON);
            pMessage->Lpc.u1.s1.DataLength  = (USHORT)RequestSize;
            pMessage->Lpc.u2.ZeroInit = 0;
            pMessage->Packet.MsgType = PERF_REQUEST;
            pMessage->Packet.Buffer[0] = 'G';
            break;

        case 2:
            pMessage->Lpc.u1.s1.TotalLength = sizeof(LPC_PERF_BUFFER);
            pMessage->Lpc.u1.s1.DataLength  = sizeof(LPC_PERF_BUFFER) -
                                              sizeof(PORT_MESSAGE);
            pMessage->Lpc.u2.ZeroInit = 0;
            pMessage->Lpc.u2.s2.DataInfoOffset = sizeof(LPC_PERF_COMMON);
            pMessage->Buffer.MsgType = PERF_READ_CLIENT_BUFFER;
            pMessage->Buffer.CountDataEntries = 1;
            pMessage->Buffer.DataEntries[0].Base = (void *)BigBuffer;
            pMessage->Buffer.DataEntries[0].Size = MAX(RequestSize,ReplySize);
            break;

        default:
            printf("Invalid Test Type: %ld\n", Options[0]);
            return 1;
        }

    StartTime();

    for(i = 0 ; i < Iterations ; i++)
        {
        status =
        NtRequestWaitReplyPort(portServer,
                               (PPORT_MESSAGE)pMessage,
                               (PPORT_MESSAGE)pReplyMessage
                               );
        if (!NT_SUCCESS(status))
            {
            printf("NtRequestWaitReplyPort failed - %8lX\n",
                   status);
            return status;
            }

        switch(pReplyMessage->Common.MsgType)
            {
            case PERF_REPLY:
                break;
            case PERF_SHARED_REPLY:
                break;
            case PERF_READ_SERVER_BUFFER:
                //
                // The server has already done everything!
                //
                break;
            default:
                {
                printf("Invalid reply message type: %ld\n",
                        pReplyMessage->Common.MsgType);
                i = Iterations;
                }
            }
        }

    EndTime("for LPC calls");

    pMessage->Common.MsgType    = PERF_REQUEST;
    pMessage->Packet.Buffer[0]  = 'X';
    pMessage->Lpc.u1.s1.TotalLength = 1 + sizeof(LPC_PERF_COMMON);
    pMessage->Lpc.u1.s1.DataLength  = 1 + sizeof(LPC_PERF_COMMON) - sizeof(PORT_MESSAGE);
    pMessage->Lpc.u2.ZeroInit       = 0;

    printf("Sending shutdown\n");

    status =
    NtRequestWaitReplyPort(portServer,
                  (PPORT_MESSAGE)pMessage,
                  (PPORT_MESSAGE)pReplyMessage
                  );

    CHECK_STATUS(status, "NtRequestWaitRequestPort");

    if (pReplyMessage->Packet.Buffer[0] != 'Z')
        {
        printf("Server failed to shutdown normally\n");
        }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\postmsg\pmsgtest.h ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    pmsgtest.h

Abstract:

    Header shared be post message client and server.

Author:

    Mario Goertzel (mariogo)   31-Mar-1994

Revision History:

--*/

#ifndef _MSG_HEADER
#define _MSG_HEADER

#define MSG_PERF_MESSAGE  WM_USER
#define MSG_PERF_MESSAGE2 (WM_USER+1)
#define MSG_PERF_MESSAGE3 (WM_USER+2)

#define CLASS "MainWClass"
#define TITLE "WMSG Server"

#define REQUEST_EVENT "MSG Test Request Event"
#define REPLY_EVENT "MSG Test Reply Event"
#define WORKER_EVENT "MSG Test Worker Event"

#endif /* _MSG_HEADER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\lpc\server\server.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       server.c
//
//--------------------------------------------------------------------------

/*++

  LPC Performance Test Server

  Copyright (C) 1993 Microsoft Corp

  Mario Goertzel


  Date     Name       Comments
  2/26/93  MarioGo    Created


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpcperf.h>
#include <lpctest.h>

const char *USAGE = "-n worker-threads (clients), default 1.\n"
                    "All other options are set by the individual clients.";

static HANDLE portPerf = 0;

long Worker (long *plThreadNumber)
{
    HANDLE portClient = 0;
    LPC_PERF_MESSAGE *pMessage, *pReplyMessage;
    int lTestNumber = 1;
    int status;
    BOOLEAN fExit = 0;
    unsigned long RequestSize, ReplySize;
    char *BigBuffer;
    SIZE_T Bytes;

    pMessage = malloc(sizeof(LPC_PERF_MESSAGE));
    pReplyMessage = 0;

    if (pMessage == 0)
        {
        printf("Error: Thread %ld - malloc failed\n", *plThreadNumber);
        return -1;
        }

    for(;;)
        {
        status =
            NtReplyWaitReceivePort(
//                portPerf,
                (portClient != 0) ? portClient : portPerf,
                0,
                (PPORT_MESSAGE)pReplyMessage,
                (PPORT_MESSAGE)pMessage
                );

        pReplyMessage = pMessage;

        if (!NT_SUCCESS(status))
            {
            printf("NtReplyWaitReceivePort failed - %ld:%8lX\n",
                *plThreadNumber, status);
            return -1;
            }

        if (pMessage->Lpc.u2.s2.Type == LPC_CONNECTION_REQUEST)
            {
            RequestSize = pMessage->Bind.BufferLengthIn;
            ReplySize   = pMessage->Bind.BufferLengthOut;
            BigBuffer   = malloc((RequestSize>ReplySize)?RequestSize:ReplySize);

            printf("New Client Connection: %ld %ld\n", RequestSize, ReplySize);

            if (BigBuffer == 0)
                {
                printf("Malloc failed\n");
                return -1;
                }

            status =
            NtAcceptConnectPort(&portClient,
                                0,
                                (PPORT_MESSAGE)pMessage,
                                TRUE,         // I accept the charges operator
                                0,
                                0);

            if (!NT_SUCCESS(status))
                {
                printf("NtAcceptConnectPort failed - %ld:%8lX\n",
                       *plThreadNumber, status);
                return -1;
                }

            status =
            NtCompleteConnectPort(portClient);

            if (!NT_SUCCESS(status))
                {
                printf("NtCompleteConnectPort failed - %ld:%8lX\n",
                       *plThreadNumber, status);
                return -1;
                }
            pReplyMessage = 0;
            }
        else
        if (pMessage->Lpc.u2.s2.Type == LPC_PORT_CLOSED)
            {
                printf("Client disconnected.\n");
                portClient = 0;
                pReplyMessage = 0;
                free(BigBuffer);
            }
        else
            {
#if 0
            printf("Request: %ld %ld\n", pMessage->Lpc.u2.s2.Type,
                   pMessage->Common.MsgType);
#endif

            switch(pMessage->Common.MsgType)
                {
                case PERF_REQUEST:
                    {
                    pMessage->Common.MsgType = PERF_REPLY;

                    if (pMessage->Packet.Buffer[0] == 'X')
                        {
                        printf("Shutdown received.\n");
                        pMessage->Packet.Buffer[0] = 'Z';
                        }

                    break;
                    }

                case PERF_SHARED_REQUEST:
                    {

                    break;
                    }

                case PERF_READ_CLIENT_BUFFER:
                    {

                    status =
                    NtReadRequestData(portClient,
                                      (PPORT_MESSAGE)pMessage,
                                      0,
                                      BigBuffer,
                                      RequestSize,
                                      &Bytes);

                    if (!NT_SUCCESS(status))
                        {
                        printf("NtReadRequestData failed - %ld:%8lX\n",
                               *plThreadNumber, status);
                        return -1;
                        }

                    status =
                    NtWriteRequestData(portClient,
                                       (PPORT_MESSAGE)pMessage,
                                       0,
                                       BigBuffer,
                                       ReplySize,
                                       &Bytes);

                    if (!NT_SUCCESS(status))
                        {
                        printf("NtWriteRequestData failed - %ld:%8lX\n",
                               *plThreadNumber, status);
                        return -1;
                        }

                    pReplyMessage->Buffer.MsgType = PERF_READ_SERVER_BUFFER;

                    break;
                    }

                default:
                    {
                    printf("Invalid message: %ld\n", pMessage->Common.MsgType);
                    break;
                    }
                } /* Perf Message Type */
            } /* Lpc Message Type */
        } /* Message loop */

    return -1;
}

int __cdecl
main(int argc, char **argv)
{
    int i;
    HANDLE WorkerThreads[32];
    OBJECT_ATTRIBUTES oaPort;
    ANSI_STRING    ansiPortName;
    UNICODE_STRING unicodePortName;
    char pszPortName[100];
    NTSTATUS status;
    ULONG lTemp, lClients;

    /* Create Port */

    ParseArgv(argc, argv);

    strcpy(pszPortName, DEFAULT_PORT_DIR);
    strcat(pszPortName, DEFAULT_PORT_NAME);

    RtlInitAnsiString(&ansiPortName, pszPortName);

    RtlAnsiStringToUnicodeString(&unicodePortName,
                                 &ansiPortName,
                                 TRUE);


    InitializeObjectAttributes(&oaPort,
                               &unicodePortName,
                               OBJ_CASE_INSENSITIVE,
                               0,
                               0);

    status =
    NtCreatePort(&portPerf,
                 &oaPort,
                 sizeof(LPC_PERF_BIND),
                 PORT_MAXIMUM_MESSAGE_LENGTH,
                 0);

    CHECK_STATUS(status, "NtCreatePort");

    /* Spawn threads to listen to the port */

    lClients = Options[0];
    if (lClients < 0 || lClients > 32) lClients = 1;
    printf("Starting %d worker threads\n", lClients);

    for(i = 0; i < (signed)lClients ; i++)
        {
        WorkerThreads[i] = CreateThread(0,
                                        0,
                                        (LPTHREAD_START_ROUTINE)Worker,
                                        &i,
                                        0,
                                        &lTemp);

        if (WorkerThreads[i] == 0)
            {
            printf("Error: CreateThread failed - %ld:%8xd\n",
                   i, status);
            return -1;
            }

        }

    printf("LPC Perf Server Ready...\n");

    /* Wait for all the threads to finish */

    status =
    WaitForMultipleObjects(lClients,
                           WorkerThreads,
                           TRUE,
                           INFINITE);

    /* The Workers shouldn't quit...hmmm */

    printf("Workers have all gone home..\n");

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\postmsg\client\client.c ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    client.c

Abstract:

    Client of post message performance test.

Author:

    Mario Goertzel (mariogo)   31-Mar-1994

Revision History:

--*/

#include <rpcperf.h>
#include <pmsgtest.h>

const char *USAGE ="-n case -n size -i iterations\n"
               "     Cases:\n"
               "       1: Oneway PostMessage/GetMessage (in process)\n"
               "       2: Oneway PostMessage/GetMessage (process to process)\n"
               "       3: Oneway PostMessage/MsgWaitForMultipleObjects (in process)\n"
               "       4: Oneway PostMessage/MsgWaitForMultipleObjects (process to process)\n"
               "       5: SendMessage/GetMessage (in process)\n"
               "       6: SendMessage/GetMessage (process to process)\n"
               "       7: Post/GetMessage and WSO (in process)\n"
               "       8: Post/GetMessage and WSO (process to process)\n"
               "       9: PostMessage/MsgWMO and WSO (in process)\n"
               "      10: PostMessage/MsgWMO and WSO (process to process)\n"
               "      11: SetEvent/MsgWMO and WSO (in process)\n"
               "      12: SetEvent/MsgWMO and WSO (process to process)\n"
               "      13: PostMessage (WM_COPYDATA of size) and WSO\n";

int __cdecl
main(int argc, char **argv)
{
    HWND   hwndServer;
    HANDLE hReplyEvent;
    HANDLE hRequestEvent;
    ULONG  i;
    ULONG  lTestCase;
    ULONG  lSize;
    char  *string;
    ULONG  Status;

    ParseArgv(argc, argv);

    if ( (Options[0] < 0) || (Options[0] > 13) )
        {
        printf("Usage: %s : %s\n",
               argv[0],
               USAGE);
        return 1;
        }

    lTestCase = Options[0];


    lSize = Options[1];
    if (lSize < 1) lSize = 100;

    switch(lTestCase)
        {
        case 1:
            string = "PostMessage/GetMessage (oneway, in-process)";
            break;
        case 2:
            string = "PostMessage/GetMessage (oneway, out-of-process)";
            break;
        case 3:
            string = "PostMessage/MsgWaitForMultipleObjects (oneway, in-process)";
            break;
        case 4:
            string = "PostMessage/MsgWaitForMultipleObjects (oneway, out-of-process)";
            break;
        case 5:
            string = "SendMessage/GetMessage (in-process)";
            break;
        case 6:
            string = "SendMessage/GetMessage (out-of-process)";
            break;
        case 7:
            string = "PostMessage/GetMessage (in-process)";
            break;
        case 8:
            string = "PostMessage/GetMessage (out-of-process)";
            break;
        case 9:
            string = "PostMessage/MsgWaitForMultipleObjects (in-process)";
            break;
        case 10:
            string = "PostMessage/MsgWaitForMultipleObjects (out-of-process)";
            break;
        case 11:
            string = "SetEvent/MsgWaitForMultipleObjects (in-process)";
            break;
        case 12:
            string = "SetEvent/MsgWaitForMultipleObjects (out-of-process)";
            break;
        case 13:
            string = "PostMessage (WM_COPYDATA) WSO reply";
            break;

        }   

    hwndServer = FindWindow(CLASS, TITLE);
    if (hwndServer == 0)
        ApiError("FindWindow", GetLastError());

    hReplyEvent = OpenEvent(EVENT_ALL_ACCESS,
                            FALSE,
                            REPLY_EVENT);

    if (hReplyEvent == 0)
        ApiError("OpenEvent", GetLastError());

    hRequestEvent = OpenEvent(EVENT_ALL_ACCESS,
                              FALSE,
                              REQUEST_EVENT);

    if (hRequestEvent == 0)
        ApiError("OpenEvent", GetLastError());


    switch(lTestCase)
        {
        case 1:
        case 3:
        case 5:
        case 7:
        case 9:
        case 11:
            {
            
            StartTime();

            if ( (PostMessage(hwndServer, MSG_PERF_MESSAGE,
                              lTestCase, Iterations)) == FALSE)
               {
               ApiError("PostMessage", GetLastError());
               }

            // The server process completes the whole test

            if (WaitForSingleObject(hReplyEvent, INFINITE) != STATUS_WAIT_0)
                {
                ApiError("WaitForSingleObject", GetLastError());
                }

            break;
            }

        case 2:
        case 4:
        case 8:
        case 10:
            {
            // Oneway and twoway PostMessages.

            StartTime();

            for(i = Iterations; i; i--)
                {

                if ( (PostMessage(hwndServer, MSG_PERF_MESSAGE,
                                  lTestCase, i)) == FALSE)
                    {
                    ApiError("PostMessage", GetLastError());
                    }

                if (lTestCase > 4)
                    {

                    // Twoway tests wait for reply event

                    if (WaitForSingleObject(hReplyEvent, INFINITE) !=
                        STATUS_WAIT_0)
                        {
                        ApiError("WaitForSingleObject", GetLastError());
                        }
                    }

                }

            // Wait for all the messages to be processed

            if (lTestCase <= 4)
                {
                if (WaitForSingleObject(hReplyEvent, INFINITE)
                    != STATUS_WAIT_0)
                    {
                    ApiError("WaitForSingleObject", GetLastError());
                    }
                }

            break;
            }

        case 6:
            {
            // SendMessage()

            StartTime();

            for(i = Iterations; i; i--)
                {

                if ( (SendMessage(hwndServer, MSG_PERF_MESSAGE,
                                  lTestCase, i)) != 69)
                   {
                   ApiError("SendMessage", GetLastError());
                   }

                }

            // No need to wait for all the messages to be processed

            break;
            }

        case 12:
            {
            // SetEvent/MsgWaitForMultipleObjects

            PostMessage(hwndServer, MSG_PERF_MESSAGE, lTestCase, 0);

            Sleep(100);

            StartTime();
            for(i = Iterations; i; i--)
                {
                SetEvent(hRequestEvent);
                WaitForSingleObject(hReplyEvent, INFINITE);
                }

            break;
            }

        case 13:
            {
            // PostMessage (WM_COPYDATA) and SetEvent reply

            COPYDATASTRUCT Data;

            Data.dwData = 5055;
            Data.cbData = lSize;
            Data.lpData = malloc(lSize);

            ASSERT(0);
            // This doesn't build for Win64. I don't think this test
            // is relevant, so I'll just comment it out to make it build

            /*
            StartTime();
            for(i = Iterations; i; i--)
                {
                Status =
                SendMessage(hwndServer,
                            WM_COPYDATA,
                            hwndServer,
                            (long)&Data);

                if (Status == FALSE)
                    ASSERT(0);

                }
                */
            }
        }

    EndTime(string);

    if (PostMessage(hwndServer, WM_DESTROY, 0, 0) == FALSE)
        ApiError("PostMessage", GetLastError());

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\client\client.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       client.c
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: client.c
//
// Description: This file contains the source code for IPC performance.
//              This module is written using win32 API calls, and will
//              generate a console server app.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////

#include "rawcom.h"
#include "client.h"


/************************************************************************/
// Global variables
/************************************************************************/

struct client	Clients[MAXCLIENTS];
HANDLE 			Threads[MAXCLIENTS];
HANDLE			EventHandle;
PCHAR			ServerName=NULL;		
USHORT			ThreadError=0;
BOOLEAN			Failure = FALSE;
USHORT			NClients = 1;		// number of clients
USHORT			MachineNumber = 1;	// This client Number
USHORT			IPCType  = NP;		// Ipc Type to be used
ULONG			SendSize = 32;
ULONG			NumSends =  1;
ULONG			RecvSize = 32;
ULONG			NumRecvs =  1;
ULONG			Iterations = 100;	// number of Iterations
DWORD           Timeout;
CHAR			Xport[9];		// Xport type name
CHAR			TestCmd = 'P';

// function pointers for redirecting calls according to Xport types
NTSTATUS 	(* IPC_Initialize)();	
NTSTATUS 	(* IPC_PerClientInit)();	
NTSTATUS 	(* IPC_Connect_To_Server)();	
NTSTATUS 	(* IPC_Disconnect_From_Server)();	
NTSTATUS 	(* IPC_Cleanup)();	
NTSTATUS 	(* IPC_Allocate_Memory)();	
NTSTATUS 	(* IPC_DoHandshake)();	
NTSTATUS 	(* IPC_ReadFromIPC)();	
NTSTATUS 	(* IPC_WriteToIPC)();	
NTSTATUS 	(* IPC_XactIO)();	
NTSTATUS 	(* IPC_Deallocate_Memory)();	
NTSTATUS 	(* IPC_ThreadCleanUp)();	

// Later all of this should move under an union

// Globals for NamedPipe
/*
OBJECT_ATTRIBUTES objectAttributes;
UNICODE_STRING	  unicodePipeName;
*/
LPCSTR            pipeName;
ULONG		      Quotas     = 32768;			            // read/write quota
ULONG		      PipeType   = PIPE_TYPE_MESSAGE;           // pipe type
ULONG		      PipeMode   = PIPE_READMODE_MESSAGE;       // read mode
ULONG		      BlockorNot = PIPE_NOWAIT;                 // non blocking

// Globals for NetBIOS
USHORT		LanaCount   = 1;		
USHORT		LanaBase    = 0;		
UCHAR		NameNumber  = 1;		
CHAR		LocalName[NCBNAMSZ];
CHAR		RemoteName[NCBNAMSZ];


// GLobals for Sockets
PCHAR	HostName;
int	AddrFly;

// For XNS socket support
CHAR	Remote_Net_Number[4];	// NetNumber
CHAR	Remote_Node_Number[6];	// Card address

/************************************************************************/
void __cdecl main (
    IN USHORT argc,
    IN PSZ argv[],
    IN PSZ envp[]
    )

{
    NTSTATUS 		mstatus;
    // DWORD       	Timeout;
    USHORT		    Cindex = 0; // client index


    OutputDebugString("Raw network client has started!\n");

    // initialize the Client & Server name
    mstatus = Parse_Cmd_Line(argc, argv);
    if (!NT_SUCCESS(mstatus)) {
        exit(1);
    }

    // Based on the xport type setup all the function pointers
    Setup_Function_Pointers();

    // do IPC dependent Initializing
    mstatus = IPC_Initialize(NClients, ServerName, CLI);
    if (!NT_SUCCESS(mstatus)) {
        exit(1);
    }

    // Now create worker threads to execute test scenarios
    // Create an event to synchronize all the client threads
    EventHandle = CreateEvent(NULL,  // EventobjectAttributes,
		                      TRUE,  // manual reset event
		                      FALSE, // initial state of the event is non-signalled
                              NULL); // no name given to the event

    if (!EventHandle) {
        printf ("Failed to create an event err=%lx\n",mstatus);
	    Cleanup();
        exit(1);
    }

    printf("Creating %s Client threads..", Xport);

    for (Cindex = 0; Cindex < NClients; Cindex++) {
        // do appropriate per client initialization
        mstatus = IPC_PerClientInit(Cindex, CLI);
        // set up parameters for other client threads

	    Clients[Cindex].c_client_num          = Cindex;	  // client number
	    Clients[Cindex].c_reqbuf.Iterations   = Iterations;
	    Clients[Cindex].c_reqbuf.SendSize     = SendSize;
	    Clients[Cindex].c_reqbuf.RecvSize     = RecvSize;
	    Clients[Cindex].c_reqbuf.NumSends     = NumSends;
    	Clients[Cindex].c_reqbuf.NumRecvs     = NumRecvs;
    	Clients[Cindex].c_reqbuf.TestCmd      = TestCmd;
    	Clients[Cindex].c_reqbuf.ClientNumber = Cindex;

	    // use win32 API instead of NT native so that NetBIOS works fine
        Clients[Cindex].c_hThHandle = CreateThread(
				NULL,
				0,
				(LPTHREAD_START_ROUTINE)&CliService,
	            (PUSHORT)&(Clients[Cindex].c_client_num),
				0,
				(LPDWORD)&(Clients[Cindex].c_ThClientID));
	    Threads[Cindex] = Clients[Cindex].c_hThHandle;
	    printf("%d..",Cindex+1);
    }
    // printf("\n");

    // First delay the main thread to let worker threads to get ready
    mstatus = Delay_Trigger_Wait();

    if (!NT_SUCCESS(mstatus)) {
        printf ("Failed in Delay_Trigger_Wait: err=%lx\n",mstatus);
        Cleanup();
    }

    // If any error then interprete it otherwise display results
    if (ThreadError) {
        printf("Client Error=%d\n",ThreadError);
    }
    else {
        //  display results for all the clients
        Display_Results();
    }

    // now do the cleanup. i.e.  clear all memory and close all handles
    IPC_Cleanup();

    Cleanup();
    exit(0);
} // main

/************************************************************************/
NTSTATUS
Delay_Trigger_Wait(VOID)
{
    NTSTATUS 	dstatus;
    DWORD       Timeout = 1000;

    dstatus = SleepEx( Timeout,     // 10 ms delay
	                   TRUE );      // alertable

    if (!NT_SUCCESS(dstatus)) {
        printf ("Failed on Delayed execution err=%lx\n",dstatus);
	    return(dstatus);
    }

    dstatus = PulseEvent(EventHandle);

    if (!NT_SUCCESS(dstatus)) {
        printf ("Failed to Pulse an event err=%lx\n",dstatus);
	    return(dstatus);
    }
    // then signals all the waiting threads to  resume I/O to namedpipe
    // by sending a pulse event


    dstatus = Wait_For_Client_Threads();
    if (!NT_SUCCESS(dstatus)) {
        printf ("Failed on wait err=%lx\n",dstatus);
        return(dstatus);
    }

    // printf("wait done. now do the cleanup work\n");
    return(dstatus);
}
/************************************************************************/
VOID
CliService(	// provide Client service
  IN  PUSHORT pTindex
)

{

    NTSTATUS 		tstatus;
    USHORT	    	tCindex;
    //IO_STATUS_BLOCK ioStatusBlock;
    USHORT		    error           = 0;
    //UCHAR		    Retcode;
    ULONG	    	Iterations;
    ULONG	    	SendLen;
    ULONG	    	RecvLen;

    DWORD   	    StartTime;
    DWORD           StopTime;
    DWORD           Duration;
    BOOLEAN	    	First           = FALSE;


    tCindex  = *pTindex;
    ThreadError = 0;  // No error so far
    Failure = FALSE;

    MyDbgPrint("CLI: Connecting to Server\n");
    tstatus = IPC_Connect_To_Server(tCindex); // First connect to the server

    ThreadError = 1;
    FAIL_CHECK_EXIT(PERFCLI, "Connect to Srv", tstatus);

    // now open the sync event and wait on it till set by the main thread
    tstatus = WaitForSingleObjectEx(EventHandle, INFINITE, TRUE);

    ThreadError = 2;
    FAIL_CHECK_EXIT(PERFCLI, "Wait for Event", tstatus);


    MyDbgPrint("CLI: Doing Handshake \n");

    // Do the handshake before the actual test run. This will send a request
    // packet to the server with test details
    tstatus = IPC_DoHandshake(tCindex, CLI);

    ThreadError = 3;
    FAIL_CHECK_EXIT(PERFCLI, "Do Handshake ", tstatus);

    // Allocate memory required for recv and send buffers
    tstatus = IPC_Allocate_Memory(tCindex);

    ThreadError = 4;
    FAIL_CHECK_EXIT(PERFCLI, "Allocate Memory ", tstatus);

    // Now we are ready to run all the tests

    Iterations = Clients[tCindex].c_reqbuf.Iterations;

    StartTime = GetCurrentTime();
    while (Iterations--) {

        if (Clients[tCindex].c_reqbuf.TestCmd == 'P') {
            // Client first sends X messages and Receives Y messages.
            tstatus = IPC_WriteToIPC(tCindex, &SendLen, CLI);

            ThreadError = 5;
            FAIL_CHECK(PERFCLI, "Write to IPC", tstatus);

            // Check for send length here

            tstatus = IPC_ReadFromIPC(tCindex, &RecvLen, CLI);

            ThreadError = 6;
            FAIL_CHECK(PERFCLI, "Receive from IPC", tstatus);

            // Check for Receive length and data integrity here
        }
        else { // for 'U' or 'T' tests do transaction type I/O
               // Note that First is not used by the client
            tstatus = IPC_XactIO(tCindex, &SendLen, &RecvLen, CLI,First);

            ThreadError = 65;
            FAIL_CHECK(PERFCLI, "Xact from IPC", tstatus);
        }


    }

    StopTime = GetCurrentTime();
    Duration = StopTime - StartTime;
    Clients[tCindex].c_Duration   = Duration; // in msecs

    // Deallocate all the memory

    tstatus = IPC_Deallocate_Memory(tCindex);

    if (!ThreadError) {ThreadError = 7;}
    FAIL_CHECK_EXIT(PERFCLI, "Deallocate Memory ", tstatus);

    // Disconnect from server
    tstatus = IPC_Disconnect_From_Server(tCindex);

    if (!ThreadError) {
        ThreadError = 8;
    }
    FAIL_CHECK_EXIT(PERFCLI, "Disconnect from Server ", tstatus);

    // Clear all flags so that we can print results
    if (!Failure) { ThreadError = 0; }
    // based on error return status
    TerminateThread(GetCurrentThread(), STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine is responsible for displaying results for all the client
    thread. It displays both per client and total throughput.
--*/

VOID
Display_Results(VOID)
{

    USHORT	Cindex       = 0;
    ULONG	TotTps       = 0L;
    ULONG	TotSendThrpt = 0L;
    ULONG	TotRecvThrpt = 0L;
    ULONG	CliThrput    = 0L;
    ULONG	Remainder    = 0L;
    ULONG	BytesSent    = 0L;
    ULONG	BytesRcvd    = 0L;

    BytesSent = (Clients[Cindex].c_reqbuf.SendSize) *
		        (Clients[Cindex].c_reqbuf.NumSends) *
       		    (Clients[Cindex].c_reqbuf.Iterations);

    BytesRcvd = (Clients[Cindex].c_reqbuf.RecvSize) *
	            (Clients[Cindex].c_reqbuf.NumRecvs) *
   	            (Clients[Cindex].c_reqbuf.Iterations);

    printf("Total: Trans: %ld  Send: %lu Bytes  Receive: %lu Bytes\n",
	          (Clients[Cindex].c_reqbuf.NumSends *
		      Clients[Cindex].c_reqbuf.Iterations),
              BytesSent,
              BytesRcvd);

    // Display all the results
    for (Cindex = 0; Cindex < NClients; Cindex++) {

        if (!(Clients[Cindex].c_Duration)) {
	        Clients[Cindex].c_Duration++;
        }

        // First put the TPS number
        // Get total TPS
        CliThrput  = (Clients[Cindex].c_reqbuf.NumSends * 1000) *
                     (Clients[Cindex].c_reqbuf.Iterations);

        CliThrput /= Clients[Cindex].c_Duration;

        TotTps += CliThrput;

        printf("Cli:%d Dura: %ld ms Throughput: %ld TPS ",
		         Cindex,
                 Clients[Cindex].c_Duration,
                 CliThrput);

        // Now put the BPS number
        // First get Send BPS numbers

        CliThrput= BytesSent / (Clients[Cindex].c_Duration);

        // now calculate the remainder and get first three digits
        Remainder = BytesSent -  (Clients[Cindex].c_Duration * CliThrput);
        Remainder = (Remainder*1000)/Clients[Cindex].c_Duration;
        CliThrput = (CliThrput * 1000) + Remainder;	// duration was in msec

        TotSendThrpt += CliThrput;

        printf(" Send: %ld BPS ",
                 CliThrput);

        // First get Receive BPS numbers
        CliThrput = BytesRcvd / (Clients[Cindex].c_Duration);

        // now calculate the remainder and get first three digits
        Remainder = BytesRcvd -  (Clients[Cindex].c_Duration * CliThrput);
        Remainder = (Remainder*1000)/Clients[Cindex].c_Duration;
        CliThrput = (CliThrput * 1000) + Remainder;	// duration was in msec

        TotRecvThrpt += CliThrput;

        printf(" RecvThrpt: %ld BPS; \n", CliThrput );
    }
    printf("--------------------------------------------------------\n");
    printf("Total Throughput: %ld TPS ",TotTps);
    printf(" Send-BPS: %ld BPS ",TotSendThrpt);
    printf(" Recv-BPS: %ld BPS\n",TotRecvThrpt);

}
/************************************************************************/

NTSTATUS
Parse_Cmd_Line(USHORT argc, CHAR *argv[])
{

	USHORT	 i;
	CHAR	 *s;
	NTSTATUS pstatus = 0L;
        BOOLEAN	 doingok = TRUE;

	if (argc > 12) {
	    printf("Too many arguments \n");
	    pstatus = -1L;
	}

	strncpy(Xport, NamePipe, 8);

	for (i=1; (doingok)  && (i< argc); i++) {

		s = argv[i];

		if ((*s == '/') && ((*(s+2) == ':') || (*(s+3) == ':') ))
		{
			s++;

			switch(*s) {
			case 'a' :	// Net number for XNS:SPX
			case 'A' :
                RtlCopyMemory( Remote_Net_Number,
				               get_network_number((PCHAR)s+2),
				               4);

                if (Remote_Net_Number[0] == 'X') {
                    printf("incorrect net number: ");
                    printf(" e.g. /a:11223344 (8 hex) \n");

				    Usage(argv[0]);
				    pstatus = -1L;
                }
				break;

			case 'b' :
			case 'B' :
				LanaBase = (USHORT)atoi(s+2);
				break;

			case 'c' : // number of clients
			case 'C' :
				NClients = (USHORT)atoi(s+2);
				break;

			case 'l' :
			case 'L' :
				LanaCount = (USHORT)atoi(s+2);
				break;

			case 'm' :
			case 'M' :
				MachineNumber = (USHORT)atoi(s+2);
				break;

			case 'i' : // iterations
			case 'I' :
				Iterations = (USHORT)atoi(s+2);
				break;

			case 'n' : // number of Sends/Recvs
			case 'N' :
                switch(*(s+1)) {
                    case 'r':
                    case 'R':
				        NumRecvs = (USHORT)atoi(s+3);
				        break;

                    case 's':
                    case 'S':
				        NumSends = (USHORT)atoi(s+3);
				        break;

                    default:
                        doingok = FALSE;
                }
         