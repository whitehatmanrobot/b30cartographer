g = (LPBYTE)pmcast + pmcast->dwMessageOffset;

	DPF(4,"multicast server routing from player id = %d to group id = %d\n",
		pmcast->idPlayerFrom,pmcast->idGroupTo);
	
	// the embedded message is the size of the total message - the size of the ask4mcast header
	dwMessageSize = dwBufferSize - pmcast->dwMessageOffset;
    hr = GetMessageCommand(this, (LPBYTE)pmsg, dwMessageSize, &dwCommand, &dwVersion);
	ASSERT(SUCCEEDED(hr)); // this should not fail

	if (DPSP_MSG_PLAYERMESSAGE == dwCommand)	
	{
		// need to drop the locks here - send expects to be able to go into pending
		// mode...
		LEAVE_DPLAY();
		
		// call send - it will push the bits through the wire for us
		hr = DP_Send((LPDIRECTPLAY)this->pInterfaces,pmcast->idPlayerFrom,
			pmcast->idGroupTo,dwSendFlags,pmsg,dwMessageSize);
		
		ENTER_DPLAY();
	}
	else // it's a system message
	{
		LPBYTE pbForward;
		DWORD dwForwardSize;

		// multicast system messages must be signed in a secure session
		if (SECURE_SERVER(this))
		{
			if (!(dwSendFlags & DPSEND_SIGNED))
			{
				DPF_ERR("Warning! unsecure multicast message arrived - dropping message");
				return DPERR_GENERIC;
			}
		}

		pPlayerFrom = PlayerFromID(this,pmcast->idPlayerFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerFrom)) 
		{
			DPF(0,"bad player from id = %d\n",pmcast->idPlayerFrom);
			return DPERR_INVALIDPLAYER;
		}
		pGroupTo = GroupFromID(this,pmcast->idGroupTo);
		if (!VALID_DPLAY_GROUP(pGroupTo)) 
		{
			DPF(0,"bad groupto id = %d\n",pmcast->idGroupTo);
			return DPERR_INVALIDGROUP;
		}
    
		if (DPSP_MSG_CREATEPLAYER == dwCommand)
		{
			// this is a SUPER-HACK!
			// but, it's the only way to get the pvSPHeader through to unpack player without
			// gutting dplay.
			// this makes sure player gets created locally w/ correct header
			// below, this createplayer message will come back to our sysplayer, who
			// will find the player already in the list, and ignore it. sigh. 
			// but, it works...andyco 4/11/97.
			UnpackPlayerAndGroupList(this,(LPBYTE) pmsg + 
				((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwCreateOffset,1,0,pvSPHeader);
		}
		
		// sp header?
		if (this->dwSPHeaderSize)
		{
			// need to add space at the beginning for sp header		
			dwForwardSize = dwMessageSize + this->dwSPHeaderSize;
			pbForward = DPMEM_ALLOC(dwForwardSize);
			if (!pbForward)
			{
				DPF_ERR("could not send multicast - out of memory");
				return DPERR_OUTOFMEMORY;	
			}	 
			memcpy(pbForward + this->dwSPHeaderSize,(LPBYTE)pmsg,dwMessageSize);
			
			// put us in "multicast" mode.  when this message comes back to our sp, it will 
			// come in as if it were generated locally.  so, in this mode we know we need 
			// to process the message
			this->dwFlags |= DPLAYI_DPLAY_HANDLEMULTICAST;
			hr = SendGroupMessage(this,pPlayerFrom,pGroupTo,dwSendFlags|DPSEND_ASYNC,pbForward,dwForwardSize,FALSE);
			this->dwFlags &= ~DPLAYI_DPLAY_HANDLEMULTICAST;
						
			DPMEM_FREE(pbForward);
		}
		else 
		{
			// no need for header - send out received message
			hr = SendGroupMessage(this,pPlayerFrom,pGroupTo,dwSendFlags|DPSEND_ASYNC,pmsg,dwMessageSize,FALSE);
		}
		
	} // fPlayerMessage
		
	if (FAILED(hr))
	{
		DPF(0,"multicast server - could not route from player id = %d to group id = %d hr = 0x%08lx\n",
			pmcast->idPlayerFrom,pmcast->idGroupTo,hr);
	}
	
	return hr;	
	
} // DoMulticast

//
// put a session lost message in players message q 
// called by HandleSessionLost
HRESULT QSessionLost(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer)
{
	LPMESSAGENODE pmsn; // we'll add this node to iplay's list of nodes		
	LPDPMSG_GENERIC pmsg;	
	
	// alloc the messagenode 
	pmsn = DPMEM_ALLOC(sizeof(MESSAGENODE));
	if (!pmsn)
	{
		DPF_ERR("could not alloc space for session lost message node");
		return E_OUTOFMEMORY;
	}
	// alloc the actual message	
	pmsg = DPMEM_ALLOC(sizeof(DPMSG_GENERIC));
	if (!pmsg)
	{
		DPF_ERR("could not alloc space for session lost message");
		return E_OUTOFMEMORY;
	}

	// set up the message	
	pmsg->dwType = DPSYS_SESSIONLOST;

	// set up the messagenode
	pmsn->idTo = pPlayer->dwID; 
	pmsn->pMessage = pmsg;
	pmsn->dwMessageSize = sizeof(DPMSG_GENERIC);

	this->nMessages++;

	// stick this bad news on the front of the list
	pmsn->pNextMessage = this->pMessageList;
	this->pMessageList = pmsn;
	if(!this->pLastMessage){
		this->pLastMessage=pmsn;
	}
	
	ASSERT(pPlayer);

	// if player has event, trigger it
	if (pPlayer->hEvent) 
	{
		DPF(9,"triggering player event");
		SetEvent(pPlayer->hEvent);		
	}

	return DP_OK;
		
}  // QSessionLost

// 
// we got either a DPSP_MSG_YOUAREDEAD off the wire, 
// or a DPERR_SESSIONLOST from a send or reply
// put a session lost message in all local players q's, print a useful
// debug message
//
HRESULT HandleSessionLost(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_PLAYER pPlayer, pNextPlayer;
	LPDPLAYI_GROUP	pGroup, pNextGroup;
	HRESULT hr;

	if (!this->lpsdDesc)
	{
		DPF_ERR("handlesession lost - no session");
		return DP_OK;
	}
	
	DPF(0,"\n\n");
	DPF(0," DPLAY SESSION HAS BEEN LOST.  ALL ATTEMPTS TO SEND TO REMOTE PLAYERS");
	DPF(0," WILL FAIL.  THIS CAN BE CAUSED BY E.G. MODEM DROPPING, OR NETWORK CONNECTION");
	DPF(0," TIMING OUT.  HAVE A NICE DAY\n\n");
	
	this->dwFlags |= DPLAYI_DPLAY_SESSIONLOST;
	
	pPlayer = this->pPlayers;
	while (pPlayer)
	{
		if ((pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) && 
			!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{
			hr = QSessionLost(this,pPlayer);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
		}
		
		pPlayer = pPlayer->pNextPlayer;
	}

	// Now walk the list of players and delete all of the remote players
	pPlayer = this->pPlayers;
	while(pPlayer)
	{
		// Save the next player
		pNextPlayer = pPlayer->pNextPlayer;

		// If the player is a non-system player & they are remote, delete them
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) && 
			!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{
			NukeNameTableItem(this, pPlayer);
		}

		// Move to the next player
		pPlayer = pNextPlayer;
	}

	// Now walk the list of groups and delete all of the remote groups
	pGroup = this->pGroups;
	while(pGroup)
	{
		// Save the next group
		pNextGroup = pGroup->pNextGroup;

		// If the group is remote, delete it
		if (!(pGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			NukeNameTableItem(this, (LPDPLAYI_PLAYER)pGroup);
		}

		// Move to the next group
		pGroup = pNextGroup;
	}

	// Now walk the list of players and delete all of the remote system players
	pPlayer = this->pPlayers;
	while(pPlayer)
	{
		// Save the next player
		pNextPlayer = pPlayer->pNextPlayer;

		// Now delete the remaining remote system players
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			NukeNameTableItem(this, pPlayer);
		}

		// Move to the next player
		pPlayer = pNextPlayer;
	}

	return DP_OK;

} // HandleSessionLost	

// figure out how many groupws w/ shortucts there are in the nametable
DWORD CountShortcuts(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_GROUP pGroup = this->pGroups;
	LPDPLAYI_SUBGROUP pSubgroup;
	BOOL bShortcut;
	DWORD count = 0;  // # of groups w/ subgroups
	 	
	while (pGroup)
	{
		bShortcut = FALSE;
		pSubgroup = pGroup->pSubgroups;
		
		while (pSubgroup && !bShortcut)
		{
			if (pSubgroup->dwFlags & DPGROUP_SHORTCUT)
			{
				// got one ! go onto next group...
				bShortcut = TRUE;
				count++;
			}
			else
			{
				pSubgroup = pSubgroup->pNextSubgroup;				
			}
		} // pSubgroup
		
		pGroup = pGroup->pNextGroup;
	} // pGroup
	
	DPF(3,"found %d groups w/ shortcuts in nametable",count);
	return count;
	
} // CountShortcuts

/*
 **  NS_HandleEnumPlayers	   
 *
 *  CALLED BY: handlmessage
 *
 *  PARAMETERS:  pvSPHeader - header from SP
 *				dpidFrom - security id from requestor
 *				dwVersion - version of requestor
 *
 *  DESCRIPTION:  checks security if necessary. if dwVersion >= DX5, and it's 
 *					not client server, superpacs nametable, else it just packs nametable
 *					and sends it to requestor.
 *
 */
HRESULT NS_HandleEnumPlayers(LPDPLAYI_DPLAY this,LPVOID pvSPHeader,DPID dpidFrom,DWORD dwVersion)
{
    HRESULT hr=DP_OK;
    MSG_ENUMPLAYERSREPLY epm;
    LPBYTE pBuffer=NULL,pBufferIndex;
	DWORD dwMessageSize;
    BOOL fSuperPac;
	UINT nNameLength,nPasswordLength;
	
	if (dwVersion >= DPSP_MSG_DX5VERSION && !CLIENT_SERVER(this)) fSuperPac = TRUE;
	else fSuperPac = FALSE;
	
	ASSERT(this);
	ASSERT(this->lpsdDesc);
	ASSERT(this->pSysPlayer);
	
	// call pack w/ null buffer to figure out how big
	if (fSuperPac)
	{
		hr =  SuperPackPlayerAndGroupList( this, NULL,&dwMessageSize) ;
	}
	else 
	{
		hr =  PackPlayerAndGroupList( this, NULL,&dwMessageSize) ;
	}
    if (FAILED(hr)) 
    {
    	ASSERT(FALSE);
		return hr;
    }

	// session name goes w/ nametable
	nNameLength =  WSTRLEN_BYTES(this->lpsdDesc->lpszSessionName);
#ifdef SEND_PASSWORD	
	// todo - Sohail - need to encrypt this message before we can send
	// password.  for now, we just don't send it
	nPasswordLength =  WSTRLEN_BYTES(this->lpsdDesc->lpszPassword);
#else 
	nPasswordLength =  0;	
#endif 
	
	// message size + blob size + session name
	dwMessageSize += GET_MESSAGE_SIZE(this,MSG_ENUMPLAYERSREPLY) + sizeof(DPSESSIONDESC2) 
		+ nNameLength + nPasswordLength;

	DPF(2,"sending nametable - total size = %d\n",dwMessageSize);

    pBuffer = DPMEM_ALLOC(dwMessageSize);
    if (!pBuffer) 
    {
    	DPF_ERR("could not send player list - out of memory");
        return E_OUTOFMEMORY;
    }

    // epm is the message we want the sp to send
	SET_MESSAGE_HDR(&epm);

	if (fSuperPac)
	{
		SET_MESSAGE_COMMAND(&epm,DPSP_MSG_SUPERENUMPLAYERSREPLY);		
		epm.nShortcuts = CountShortcuts(this);
	}
	else 
	{
		SET_MESSAGE_COMMAND(&epm,DPSP_MSG_ENUMPLAYERSREPLY);
	}

	if (CLIENT_SERVER(this))
	{
		// pack will only give out app server + sysplayer
		if (this->pServerPlayer) epm.nPlayers =  2;  // nameserver + server player
		else epm.nPlayers =  1; // nameserver only
		epm.nGroups = 0;
	}
	else 
	{
	    epm.nPlayers =  this->nPlayers;
		epm.nGroups = this->nGroups;
		// if we have a sysgroup, we don't send that one...
		if (this->pSysGroup)
		{
			epm.nGroups--;
		}
	}		
	
	// put the session desc offset on
	epm.dwDescOffset = sizeof(MSG_ENUMPLAYERSREPLY);
	// name offsets
	if (nNameLength) epm.dwNameOffset = sizeof(MSG_ENUMPLAYERSREPLY) + sizeof(DPSESSIONDESC2);
	else epm.dwNameOffset = 0;
	// password offsets
	if (nPasswordLength) epm.dwPasswordOffset = sizeof(MSG_ENUMPLAYERSREPLY) 
		+ sizeof(DPSESSIONDESC2) + nNameLength;
	else epm.dwPasswordOffset = 0;

	// the packed structures follow the session name
	epm.dwPackedOffset = sizeof(MSG_ENUMPLAYERSREPLY) + sizeof(DPSESSIONDESC2) 
		+ nNameLength + nPasswordLength;

    // copy the fixed message into  the buffer
    memcpy(pBuffer + this->dwSPHeaderSize,(LPBYTE)&epm,sizeof(MSG_ENUMPLAYERSREPLY));

	// now, pack up the variable size stuff
	pBufferIndex = (LPBYTE)pBuffer + this->dwSPHeaderSize + sizeof(MSG_ENUMPLAYERSREPLY);
	
	// put the session desc on
	memcpy(pBufferIndex,this->lpsdDesc,sizeof(DPSESSIONDESC2));

	// set string pointers to NULL - they must be set at client
	((LPDPSESSIONDESC2)pBufferIndex)->lpszPassword = NULL;
	((LPDPSESSIONDESC2)pBufferIndex)->lpszSessionName = NULL;

	pBufferIndex += sizeof(DPSESSIONDESC2);
	
	// next, name
	if (nNameLength) 
	{
		memcpy(pBufferIndex,this->lpsdDesc->lpszSessionName,nNameLength);
		pBufferIndex += nNameLength;
	}

	// next, password
	if (nPasswordLength) 
	{
		memcpy(pBufferIndex,this->lpsdDesc->lpszPassword,nPasswordLength);
		pBufferIndex += nPasswordLength;
	}

	// pack the players behind the password
	if (fSuperPac)
	{
		hr = SuperPackPlayerAndGroupList( this, pBufferIndex ,&dwMessageSize) ;
	}
	else 
	{
		hr = PackPlayerAndGroupList( this, pBufferIndex, &dwMessageSize) ;
	}			
	if (FAILED(hr)) 
	{
		ASSERT(FALSE);
		DPMEM_FREE(pBuffer);
		return hr;
	}

    // if session is secure, use send
    if (this->lpsdDesc && (this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
    {
        LPDPLAYI_PLAYER pPlayerTo;

		pPlayerTo = PlayerFromID(this,dpidFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerTo)) 
		{
			DPF_ERR("bad player id!!");
            ASSERT(FALSE);  // should never happen because we just verified the sig
			return DPERR_INVALIDPLAYER;
		}
        hr = SendDPMessage(this,this->pSysPlayer,pPlayerTo,pBuffer,dwMessageSize,DPSEND_SYSMESS,FALSE);
    }
    else
    {
    	hr = DoReply(this,pBuffer,dwMessageSize,pvSPHeader,dwVersion);
    }

	DPMEM_FREE(pBuffer);
    return hr;

} // handle enum players

// sends an error response to an addforward message
HRESULT NS_SendAddForwardReply(LPDPLAYI_DPLAY this, HRESULT hResult, LPVOID pvSPHeader, DPID dpidFrom, DWORD dwVersion)
{
    HRESULT hr;
    DWORD dwBufferSize;
    LPBYTE pSendBuffer;
    LPMSG_ADDFORWARDREPLY pReply;

    // 
    // Calculate buffer size needed for response
    //
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_ADDFORWARDREPLY);
    //
    // Allocate memory for the buffer
    //
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
        DPF_ERR("could not allocate memory for response - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    pReply = (LPMSG_ADDFORWARDREPLY) (pSendBuffer + this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pReply);
    SET_MESSAGE_COMMAND(pReply, DPSP_MSG_ADDFORWARDREPLY);
    pReply->hResult = hResult;

	if (dpidFrom)
	{
        LPDPLAYI_PLAYER pPlayerTo;

		pPlayerTo = PlayerFromID(this,dpidFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerTo)) 
		{
			DPF_ERR("bad player id!!");
			return DPERR_INVALIDPLAYER;
		}
        hr = SendDPMessage(this,this->pSysPlayer,pPlayerTo,pSendBuffer,dwBufferSize,
            DPSEND_SYSMESS,FALSE);
	}
	else
	{
		hr = DoReply(this, pSendBuffer, dwBufferSize, pvSPHeader, dwVersion);
	}

    //
    // Free up the buffer
    //
    DPMEM_FREE(pSendBuffer);

    return hr;
} // NS_SendAddForwardReply

// this function verifies if the client can join the session
// also verifies TickCount on session, some work here is for interop with previous beta versions of DX6
HRESULT NS_IsOKToJoin(LPDPLAYI_DPLAY this, LPBYTE pReceiveBuffer, DWORD dwBufferSize, DWORD dwJoinerVersion)
{
	DWORD *pTickCount;
	BOOL  fCheckTickCount=TRUE;

    // if session has a password and it is not a zero-length string
    if ((this->lpsdDesc->lpszPassword) &&
		(WSTRLEN(this->lpsdDesc->lpszPassword) > 1))
    {
        LPWSTR lpszPassword;

		DPF(5,"Verifying Password\n");

        if (!((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPasswordOffset)
        {
            DPF(0, "nameserver denying access - no password specified");
            return DPERR_INVALIDPASSWORD;
        }

        // point to the password in the message
        lpszPassword = (LPWSTR) (pReceiveBuffer + ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPasswordOffset);

        // match passwords
        if (WSTRCMP(this->lpsdDesc->lpszPassword, lpszPassword))
        {
            DPF(0, "nameserver denying access - password doesn't match");
            return DPERR_INVALIDPASSWORD;
	    }
	    // tick count after password
	    pTickCount=(PUINT)(lpszPassword+WSTRLEN(lpszPassword));

		DPF(5,"pPassword = %x, pTickCount= %x\n",lpszPassword, pTickCount);
	    
    } else {
    	// expect NULL password followed by TickCount
    	if(((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPasswordOffset){
	    	pTickCount=(PUINT)(pReceiveBuffer + dwBufferSize - 4);
			DPF(5,"Didn't verify password, pTickCount= %x\n", pTickCount);
	    } else {
	    	fCheckTickCount=FALSE;
	    }

    }

	if(fCheckTickCount && dwJoinerVersion >= DPSP_MSG_DX6VERSION){
		// only verify DX6 or later and only if the buffer is big enough to have the tickcount.
		if(pReceiveBuffer+dwBufferSize >= (PUCHAR)(pTickCount+1)){
			if(this->lpsdDesc->dwReserved1 != *pTickCount){
				DPF(0,"Client trying to join old session, returning DPERR_NONEWPLAYERS\n");
				return DPERR_NONEWPLAYERS;
			}
		}
	}

    // verify permissions based on player flags
    if (this->lpsdDesc->dwFlags & DPSESSION_JOINDISABLED)
    {
	    DPF(0,"nameserver denying access - session is not allowing join");
	    return DPERR_NONEWPLAYERS;
    }

    if (this->lpsdDesc->dwMaxPlayers && 
        (this->lpsdDesc->dwCurrentPlayers >= this->lpsdDesc->dwMaxPlayers))
    {
        DPF(0,"nameserver denying access - session maxed out");
        return DPERR_NONEWPLAYERS;
    }

    return DP_OK;

} // IsOKToJoin

HRESULT FreeAddForwardNode(LPDPLAYI_DPLAY this, LPADDFORWARDNODE pnodeFind)
{
	BOOL bFound = FALSE;
	LPADDFORWARDNODE pnodeSearch = this->pAddForwardList,pnodePrev = NULL;
	
	// first, find the node
	while (pnodeSearch && !bFound)
	{
		if (pnodeSearch == pnodeFind) bFound = TRUE;
		else 
		{
			pnodePrev = pnodeSearch;
			pnodeSearch = pnodeSearch->pNextNode;
		}
	}
	
	if (!bFound)	
	{
		ASSERT(bFound); // false!
		// BUMMER! this is badbadbad
		return E_FAIL; // good ol' E_FAIL
	}
	
	// remove node from list
	if (pnodePrev) 
	{
		// remove from middle
		pnodePrev->pNextNode = pnodeSearch->pNextNode; 
	}
	else
	{
		// remove from head
		ASSERT(this->pAddForwardList == pnodeSearch);
		this->pAddForwardList = this->pAddForwardList->pNextNode;
	} 
	
	// free up the node
	if (VALID_SPHEADER(pnodeSearch->pvSPHeader)) DPMEM_FREE(pnodeSearch->pvSPHeader);
	DPMEM_FREE(pnodeSearch);
	
	return DP_OK;
		
} // FreeAddForwardNode

BOOL IsAddForwardNodeOnList(LPDPLAYI_DPLAY this, LPADDFORWARDNODE pnodeFind)
{
	LPADDFORWARDNODE pnodeSearch = this->pAddForwardList;
	
	while(pnodeSearch){
		if(pnodeSearch == pnodeFind){
			return TRUE;
		}
		pnodeSearch=pnodeSearch->pNextNode;
	}
	return FALSE;
}

// start up an async add forward
HRESULT NS_DoAsyncAddForward(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,LPVOID pvSPHeader,
	 DPID dpidFrom,DWORD dwVersion)
{
	HRESULT hr;
	LPADDFORWARDNODE pnode;
	DWORD dwTimeout; // how long we wait before giving up on ack's
	DWORD dwPlayerID;
	
	pnode = DPMEM_ALLOC(sizeof(ADDFORWARDNODE));
	if (!pnode)
	{
		DPF_ERR("could not start async add forward - out of memory!!");
		return DPERR_OUTOFMEMORY;
	}
	
	// store the spheader for when we eventually send the nametable
	if (this->dwSPHeaderSize)
	{
		pnode->pvSPHeader = DPMEM_ALLOC(this->dwSPHeaderSize);
		if (!pnode->pvSPHeader)
		{
			DPF_ERR("could not start async add forward - out of memory!!");
			DPMEM_FREE(pnode);
			return DPERR_OUTOFMEMORY;
		}
		if (pvSPHeader)
		{
			memcpy(pnode->pvSPHeader,pvSPHeader,this->dwSPHeaderSize);
		}
	}
				
	// stick new node on the front of the list
	pnode->pNextNode = this->pAddForwardList;
	this->pAddForwardList = pnode;

	dwPlayerID=pPlayer->dwID;
	
	pnode->dwIDSysPlayer = pPlayer->dwIDSysPlayer;
	pnode->dpidFrom = dpidFrom;
	pnode->dwVersion = dwVersion;

	if(pPlayer->dwIDSysPlayer == dwPlayerID){
		DPF(6,"Player x%x doesn't have nametable, sends will fail idFrom=%x.\n",pPlayer->dwID, dpidFrom);
		pPlayer->dwFlags |= DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE;
	}	
	
	hr = SendAsyncAddForward(this,pPlayer,pnode);
	if (FAILED(hr))	
	{
		ASSERT(FALSE);
	}

	// pnode could be invalid (may have already got ACKs and cleared it out),
	// so we need to make sure it is still in the nodelist (i.e. valid).

	if(!IsAddForwardNodeOnList(this,pnode)){
		goto EXIT;
	}
	
	// if we don't need any ack's, send the nametable...
	if (0 == pnode->nAcksReq)
	{
		pPlayer=PlayerFromID(this,dwPlayerID);
		if(pPlayer->dwIDSysPlayer == dwPlayerID){
			pPlayer->dwFlags &= ~(DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE);
		}	
		
	    hr = NS_HandleEnumPlayers(this, pnode->pvSPHeader, pnode->dpidFrom,pnode->dwVersion);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
		
		hr = FreeAddForwardNode(this,pnode);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	else 
	{
		// get the worker thread to keep on eye on this node.  so, if a client doesn't ack, eventually
		// we give up and just send the new client the nametable...

		// we multiply GetDefaultTimeout * the number of req's we sent, since we have to wait
		// for a reply from each of them 
		dwTimeout = DP_NAMETABLE_SCALE * GetDefaultTimeout(this,TRUE);
		if(dwTimeout > 15000){
			dwTimeout = 15000;
		}
		DPF(3,"waiting for add forward.  nAcksReq = %d, timeout = %d\n",pnode->nAcksReq,dwTimeout);
		// after this tick count, we give up + send the nametable
		pnode->dwGiveUpTickCount = GetTickCount() + dwTimeout; 

		// StartDPlayThread will either start the thread, or signal it
		// that something new is afoot
		StartDPlayThread(this,FALSE);
	}
	
EXIT:			
	return DP_OK;
	
} // NS_DoAsyncAddForward

// a player is going to join the game.  they want the name server to tell the world they exist
// so they will be able to process any messages that occur between when we package the nametable
// and they receive it
HRESULT NS_HandleAddForwardRequest(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,DWORD dwBufferSize,
	LPVOID pvSPHeader, DPID dpidFrom)
{
	HRESULT hr;
    DWORD dwVersion;
    LPMSG_PLAYERMGMTMESSAGE pmsg = (LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer;
	LPDPLAYI_PLAYER pPlayer = NULL; // our version of new player
	DPID id;
		
    dwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReceiveBuffer);

    if (dwVersion >= DPSP_MSG_DX5VERSION)
    {
        // verify client can join the session
        hr = NS_IsOKToJoin(this, pReceiveBuffer, dwBufferSize, dwVersion);
        if (FAILED(hr))
        {
        	if (this->dwPlayerReservations > 0)
        		this->dwPlayerReservations--;
			goto ERROR_EXIT;
        }
    } // dwVersion 


	// reset the command to create player 
	SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_CREATEPLAYER);

	// get the new player out of the message  - note we can't let sendsystemmessage do this
	// for us, since we can't get the correct sp header if we do it that way
	UnpackPlayerAndGroupList(this,pReceiveBuffer + 
		((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwCreateOffset,1,0,pvSPHeader);

	// tell the world about the new player		
	// note - we can't just forward the message we received, since the player would be "homed" wrong
	// instead, we pack up our version of the player, which has the correct net address set
	// and send that to the world
	id = ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID;
	pPlayer = PlayerFromID(this,id);
	if (!VALID_DPLAY_PLAYER(pPlayer))
	{
		ASSERT(FALSE);
		hr = E_FAIL;
		goto ERROR_EXIT;
	}

	// if all clients in the game can handle the async addforward, do that
	// 
	if (this->dwMinVersion >= DPSP_MSG_ASYNCADDFORWARD)
	{
		hr = NS_DoAsyncAddForward(this,pPlayer,pvSPHeader,dpidFrom, dwVersion);
		if (FAILED(hr))
		{
			goto ERROR_EXIT;
		}
	}
	else
	{
		// else we have to do it the old way
		// there is a race condition which could cause simultaneous joins bugs...
		hr = SendCreateMessage( this, pPlayer,TRUE, NULL);	
		if (FAILED(hr))
		{
			goto ERROR_EXIT;
		}
		
	    // from DPSP_MSG_AUTONAMETABLE onwards, nameserver will automatically respond with the nametable if client
	    // is dx5 or greater
	    if (dwVersion >= DPSP_MSG_AUTONAMETABLE)
	    {
	        hr = NS_HandleEnumPlayers(this, pvSPHeader, dpidFrom,dwVersion);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
	    }
		
	}

	return DP_OK;

ERROR_EXIT:

	DPF_ERRVAL("could not process add forward - hr = 0x%08lx\n",hr);

    hr = NS_SendAddForwardReply(this,hr,pvSPHeader,dpidFrom, dwVersion);
    if (FAILED(hr))
    {
       // if this happens, client won't get a response and will timeout
	    DPF(0, "Couldn't send access denied message: hr = 0x%08x", hr);
    }

    // remove id from nametable
    if(pPlayer){
    	NukeNameTableItem(this, pPlayer);
    } else {
	    hr = FreeNameTableEntry(this, ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID);
	}    
    if (FAILED(hr))
    {
	    DPF(0, "Couldn't delete nametable entry for %d: hr = 0x%08x",
            ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID, hr);
    }
	
	return hr;
	
} // NS_HandleAddForwardRequest

// we got an addforward from the nameserver.  send an ack, then unpack the player
HRESULT  SP_HandleAddForward(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,
	LPVOID pvSPHeader,DPID dpidFrom, DWORD dwVersion)
{
    HRESULT hr;
    DWORD dwBufferSize;
    LPBYTE pSendBuffer;
	LPMSG_ADDFORWARDACK pAck;
	LPMSG_PLAYERMGMTMESSAGE pmsg = (LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer;

    DPF(2,"got add forward announcment for id = %d",pmsg->dwPlayerID); 
	
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_ADDFORWARDACK);
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
        DPF_ERR("could not allocate memory for addforward ack - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    pAck = (LPMSG_ADDFORWARDACK) (pSendBuffer + this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pAck);
    SET_MESSAGE_COMMAND(pAck, DPSP_MSG_ADDFORWARDACK);
    pAck->dwID = pmsg->dwPlayerID;

	if (dpidFrom)
	{
        LPDPLAYI_PLAYER pPlayerTo;

		pPlayerTo = PlayerFromID(this,dpidFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerTo)) 
		{
			DPF_ERR("bad player id!!");
			return DPERR_INVALIDPLAYER;
		}
        hr = SendDPMessage(this,this->pSysPlayer,pPlayerTo,pSendBuffer,dwBufferSize,
            DPSEND_GUARANTEED | DPSEND_ASYNC,FALSE);
	}
	else
	{
		hr = DoReply(this, pSendBuffer, dwBufferSize, pvSPHeader,dwVersion);
	}
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}

    //
    // Free up the buffer
    //
    DPMEM_FREE(pSendBuffer);

	// finally, unpack the new player by resetting DPMSG_ADDFORWARD to DPMSG_CREATEPLAYER
	// and calling handleplayermgmt
    SET_MESSAGE_COMMAND(pmsg, DPSP_MSG_CREATEPLAYER);
	hr = SP_HandlePlayerMgmt(this->pSysPlayer,pReceiveBuffer,dwBufferSize,pvSPHeader);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
	
	return DP_OK;
	
} // SP_HandleAddForward

// we got an ack for one of our addforwad's
HRESULT NS_HandleAddForwardACK(LPDPLAYI_DPLAY this,LPMSG_ADDFORWARDACK pAck)
{
	HRESULT hr;
	BOOL bFound = FALSE;
	LPADDFORWARDNODE pnode = this->pAddForwardList;
	LPDPLAYI_PLAYER pPlayer;
	
	// first, find the node
	while (pnode && !bFound)
	{
		if (pnode->dwIDSysPlayer == pAck->dwID) bFound = TRUE;
		else pnode = pnode->pNextNode;
	}
	
	if (!bFound)	
	{
		// it's possible we gave up waiting on this ack, and just sent the nametable.
		return DP_OK;
	}

	// bump the ack count
	pnode->nAcksRecv++;

    DPF(2,"got add forward ack # %d of %d required for player id = %d",pnode->nAcksRecv,pnode->nAcksReq,pAck->dwID); 
	
	if (pnode->nAcksRecv != pnode->nAcksReq) return DP_OK;
	
	// else, we got 'em all!!
	// send the nametable, and free up the node
	pPlayer=PlayerFromID(this, pnode->dwIDSysPlayer);
	if(pPlayer){
		pPlayer->dwFlags &= ~(DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE);
	}
    hr = NS_HandleEnumPlayers(this, pnode->pvSPHeader, pnode->dpidFrom,pnode->dwVersion);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}

	hr = FreeAddForwardNode(this,pnode);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
	
	return DP_OK;	
		
	
} // NS_HandleAddForwardACK

HRESULT NS_HandleEnumSessions(LPDPLAYI_DPLAY this,LPVOID pvSPHeader,LPBYTE pReceiveBuffer, DWORD dwSendFlags)
{
    HRESULT hr;
    LPMSG_ENUMSESSIONSREPLY perm; 
    LPMSG_ENUMSESSIONS pEnumRequest = (LPMSG_ENUMSESSIONS)pReceiveBuffer;
    DWORD dwMessageSize;
	LPBYTE pIndex;
	UINT nNameLength;
	LPBYTE pBuffer;
    DWORD dwVersion;
    LPWSTR lpszPassword;

	ASSERT(this);
	ASSERT(this->lpsdDesc);
    ASSERT(pReceiveBuffer);

	// check if they specified a guid
	if (!IsEqualGUID(&(pEnumRequest->guidApplication),&GUID_NULL))  // did they specify a guid?
	{
		// if they specified one, and it doesn't match, bail
		if (!IsEqualGUID(&(pEnumRequest->guidApplication),&(this->lpsdDesc->guidApplication))) 
		{
            DPF(2, "nameserver not responding - guid doesn't match");
			return FALSE;
		}
	}

    dwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReceiveBuffer);

	// make sure the password on the received buffer matches our password
	// only check if they have a password, and it's not just the null terminator
    if ((this->lpsdDesc->lpszPassword) &&
		(WSTRLEN(this->lpsdDesc->lpszPassword) > 1))
    {
        //
        // we verify the password, if client is DX3 or 
        // client is DX5 or later, but didn't request passworded sessions or
        // session is private 
        // 
        if ((DPSP_MSG_DX3VERSION == dwVersion) || 
            !(pEnumRequest->dwFlags & DPENUMSESSIONS_PASSWORDREQUIRED) || 
            (this->lpsdDesc->dwFlags & DPSESSION_PRIVATE)) 
        {   
	        // if no password is specified
            if (0 == pEnumRequest->dwPasswordOffset)
            {
                DPF(2, "nameserver not responding - no password specified");
                return FALSE;
            }

            // point to the password in the request
            lpszPassword = (LPWSTR)((LPBYTE)pEnumRequest + pEnumRequest->dwPasswordOffset);

            // if password doesn't match
	        if (WSTRCMP(this->lpsdDesc->lpszPassword, lpszPassword))
            {
                DPF(2, "nameserver not responding - password doesn't match");
                return FALSE;
	        }
        }
    }

    // if DPENUMSESSIONS_ALL flag is specified ignore the following checks.
    // look for the flags only if the client is DX5 or greater
    if ((dwVersion >= DPSP_MSG_DX5VERSION) && !(pEnumRequest->dwFlags & DPENUMSESSIONS_ALL))
    {
	    // don't reply if session is maxed out
	    if ((this->lpsdDesc->dwMaxPlayers) && 
            (this->lpsdDesc->dwCurrentPlayers + this->dwPlayerReservations >= this->lpsdDesc->dwMaxPlayers))
        {
            DPF(2, "nameserver not responding - session maxed out");
            return FALSE;
	    }
	    
	    // don't reply if session is not allowing new players
	    if (this->lpsdDesc->dwFlags & DPSESSION_NEWPLAYERSDISABLED)
        {
            DPF(2, "nameserver not responding - not allowing new players");
            return FALSE;
        }
	    
        // don't reply if if session is not allowing join
        if (this->lpsdDesc->dwFlags & DPSESSION_JOINDISABLED)
        {
            DPF(2, "nameserver not responding - not allowing join");
            return FALSE;
        }
    }

	if (dwVersion < DPSP_MSG_DX6VERSION)
	{
		// if we're running the protocol, do not respond to pre-DX6 people
		if (this->lpsdDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL)
		{
            DPF(2, "nameserver not responding - protocol prevents < DX6");
            return FALSE;
		}
	}
	
    // now send the enumsessions reply
	nNameLength =  WSTRLEN_BYTES(this->lpsdDesc->lpszSessionName);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_ENUMSESSIONSREPLY);
	dwMessageSize +=  nNameLength ;

	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return E_OUTOFMEMORY;
	}

	// pmsg follows sp blob
	perm = (LPMSG_ENUMSESSIONSREPLY)(pBuffer + this->dwSPHeaderSize);

	// perm is the buffer we want the sp to send
	SET_MESSAGE_HDR(perm);
    SET_MESSAGE_COMMAND(perm,DPSP_MSG_ENUMSESSIONSREPLY);

    // if we receive an unsecure enumsessions request and the session is secure
    // we respond with only the public information in the session desc
    if ((this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER) && 
        !(dwSendFlags & DPSEND_SIGNED))
    {
        perm->dpDesc.dwSize = this->lpsdDesc->dwSize;
        perm->dpDesc.dwFlags = DPSESSION_SECURESERVER;
        perm->dpDesc.guidInstance = this->lpsdDesc->guidInstance;
        perm->dpDesc.guidApplication = this->lpsdDesc->guidApplication;
        perm->dpDesc.dwReserved1 = this->lpsdDesc->dwReserved1;
    }
    else
    {
        // ok to send the entire session desc
        perm->dpDesc =  *(this->lpsdDesc);
    }

	// pack strings on end
	pIndex = (LPBYTE)perm+sizeof(MSG_ENUMSESSIONSREPLY);
	if (nNameLength) 
	{
		memcpy(pIndex,this->lpsdDesc->lpszSessionName,nNameLength);
		perm->dwNameOffset = sizeof(MSG_ENUMSESSIONSREPLY);
	}

	// set string pointers to NULL - they must be set at client
	perm->dpDesc.lpszPassword = NULL;
	perm->dpDesc.lpszSessionName = NULL;

	hr = DoReply(this,pBuffer,dwMessageSize,pvSPHeader,dwVersion);

	DPMEM_FREE(pBuffer);

    return hr;

} // NS_HandleEnumSessions



HRESULT NS_SendIDRequestErrorReply(LPDPLAYI_DPLAY this, LPVOID pvSPHeader,
		HRESULT hrError, DWORD dwVersion)
{
	LPBYTE					pBuffer = NULL;
	LPMSG_PLAYERIDREPLY		prm = NULL;
	DWORD					dwMessageSize;
	HRESULT					hr;


	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERIDREPLY);

    // allocate memory for the message
	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return DPERR_OUTOFMEMORY;
	}

	// Setup the header
	prm = (LPMSG_PLAYERIDREPLY)(pBuffer + this->dwSPHeaderSize);
    SET_MESSAGE_HDR(prm);
    SET_MESSAGE_COMMAND(prm, DPSP_MSG_REQUESTPLAYERREPLY);
	prm->hr = hrError;

	// Send the reply
	hr = DoReply(this, pBuffer, dwMessageSize, pvSPHeader, dwVersion);

	// Free the buffer
	DPMEM_FREE(pBuffer);

	return hr;

} // NS_SendIDRequestErrorReply



HRESULT NS_HandleRequestPlayerID(LPDPLAYI_DPLAY this,LPVOID pvSPHeader,DWORD dwCommand, DWORD dwFlags, 
                                 BOOL fCheckPlayerFlags, DWORD dwVersion)
{
    HRESULT hr = DP_OK;
 	DWORD dwMessageSize, dwSSPIProviderSize=0, dwCAPIProviderSize=0, dwID=0;
	LPBYTE pBuffer;
    BOOL fSendSecurityDesc=FALSE;
    LPMSG_PLAYERIDREPLY prm;

	ASSERT(this);
	ASSERT(this->lpsdDesc);

	// if it's a player id, check dwmax players
	if (DPSP_MSG_REQUESTPLAYERID == dwCommand)
	{
        if (fCheckPlayerFlags)
        {
            // verify permissions based on player flags
            if ((this->lpsdDesc->dwFlags & DPSESSION_NEWPLAYERSDISABLED) ||
                ((dwFlags & DPLAYI_PLAYER_SYSPLAYER) &&
                 (this->lpsdDesc->dwFlags & DPSESSION_JOINDISABLED)))
            {
			    DPF(1,"not giving out new id - session is not allowing new players");
				
				// If the client is DX6 or greater, we want to send an
				// error back to them.  If it's pre-DX6, we will just fail
				// and let the client timeout so we preserve backward compatibility
				if(dwVersion >= DPSP_MSG_DX6VERSION)
				{
					hr = NS_SendIDRequestErrorReply(this, pvSPHeader, DPERR_CANTCREATEPLAYER, dwVersion);
				}
			    return hr;
            }
        }

		// a-josbor: be sure to count reservations, too!
        if (this->lpsdDesc->dwMaxPlayers && 
            (this->lpsdDesc->dwCurrentPlayers + this->dwPlayerReservations >= this->lpsdDesc->dwMaxPlayers))
		{
			DPF(1,"not giving out new id - too many players");

			// If the client is DX6 or greater, we want to send an
			// error back to them.  If it's pre-DX6, we will just fail
			// and let the client timeout so we preserve backward compatibility
			if(dwVersion >= DPSP_MSG_DX6VERSION)
			{
				hr = NS_SendIDRequestErrorReply(this, pvSPHeader, DPERR_CANTCREATEPLAYER, dwVersion);
			}
			return hr;
		}
	}

    // if session is secure and request is for system player id, send security package name
    if ((this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER) && (dwFlags & DPLAYI_PLAYER_SYSPLAYER))
    {
        fSendSecurityDesc = TRUE;
    }

    if (fSendSecurityDesc)
    {
	    // message size + blob size
	    dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERIDREPLY);
        dwSSPIProviderSize = WSTRLEN_BYTES(this->pSecurityDesc->lpszSSPIProvider);
        dwCAPIProviderSize = WSTRLEN_BYTES(this->pSecurityDesc->lpszCAPIProvider);
        dwMessageSize += dwSSPIProviderSize + dwCAPIProviderSize;
    }
    else
    {
	    // message size + blob size
	    dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERIDREPLY);
    }

    // allocate memory for the message
	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return E_OUTOFMEMORY;
	}

    // get a new id
    hr = NS_AllocNameTableEntry(this,&dwID);
	if (FAILED(hr)) 
	{
		DPF_ERR("namesrvr- could not alloc new player id");
		DPMEM_FREE(pBuffer);
		return hr;
	}

    // prm is the buffer we want the sp to send
	prm = (LPMSG_PLAYERIDREPLY)(pBuffer + this->dwSPHeaderSize);
    SET_MESSAGE_HDR(prm);
    SET_MESSAGE_COMMAND(prm,DPSP_MSG_REQUESTPLAYERREPLY);
    prm->dwID = dwID;

    // setup the message
    if (fSendSecurityDesc)
    {
		// copy the current security descrption into the message buffer
		memcpy(&prm->dpSecDesc, this->pSecurityDesc, sizeof(DPSECURITYDESC));

		// setup offsets to provider strings
		if (this->pSecurityDesc->lpszSSPIProvider)
		{
	        prm->dwSSPIProviderOffset = sizeof(MSG_PLAYERIDREPLY);
		    // copy strings at the end of the message
            memcpy((LPBYTE)prm+prm->dwSSPIProviderOffset, 
                this->pSecurityDesc->lpszSSPIProvider, dwSSPIProviderSize);
		}
	
		if (this->pSecurityDesc->lpszCAPIProvider)
		{
			prm->dwCAPIProviderOffset = sizeof(MSG_PLAYERIDREPLY) + dwSSPIProviderSize;
            memcpy((LPBYTE)prm+prm->dwCAPIProviderOffset, 
                this->pSecurityDesc->lpszCAPIProvider, dwCAPIProviderSize);
		}

    }

	hr = DoReply(this,pBuffer,dwMessageSize,pvSPHeader,dwVersion);

//	a-josbor: we successfully handed out a player id. Increment the reservation count now
//	to avoid letting too many players in under race conditions
	if (!FAILED(hr))
	{
		this->dwPlayerReservations++;
		this->dwLastReservationTime = GetTickCount();
	}
	
	DPMEM_FREE(pBuffer);
    return hr;

}// NS_HandleRequestPlayerID


#undef DPF_MODNAME
#define DPF_MODNAME	"TransferGroupsToNameServer"

// a system player has been deleted
// make any groups owned by that system player be owned by the nameserver
HRESULT TransferGroupsToNameServer(LPDPLAYI_DPLAY this,DPID idSysPlayer)
{
	LPDPLAYI_GROUP lpGroup;

	if (!this->pNameServer)	return E_FAIL;
	
	lpGroup = this->pGroups;
	
	while (lpGroup)
	{
		if (lpGroup->dwIDSysPlayer == idSysPlayer)
		{
			ASSERT(this->pNameServer);

			// idSysPlayer is history
			// make group owned by name server
			DPF(2,"transferring ownership of group id = %d from sysplayer id = %d to nameserver id = %d\n",
				lpGroup->dwID,idSysPlayer,this->pNameServer->dwID);
				
			lpGroup->dwIDSysPlayer = this->pNameServer->dwID;
		}
		lpGroup = lpGroup->pNextGroup;
	}

	return DP_OK;
	
} // TransferGroupsToNameServer

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_HandlePlayerMgmt"

// we got a system message off the wire
// put a message in the q fo all local players 
HRESULT  DistributeSystemMessage(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize)
{
	HRESULT hr;
	LPDPLAYI_PLAYER	pPlayer;
	
	pPlayer = this->pPlayers; 
	
	while (pPlayer)
	{
		// only distribute it to local non-system players
		if ((pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) && 
			!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{
			hr = HandlePlayerMessage(pPlayer,pReceiveBuffer,dwMessageSize,FALSE,0);
			if (FAILED(hr))
			{
				DPF_ERRVAL("could not handle player system message hr = 0x%08lx\n",hr);
			}
		}
		pPlayer = pPlayer->pNextPlayer;
	}
	
	return DP_OK;
			
} // DistributeSystemMessage

// tell pvSPHeader to go away
void SendDiePiggy(LPDPLAYI_DPLAY this,LPVOID pvSPHeader)
{
	LPMSG_SYSMESSAGE pmsg;
	LPBYTE pBuffer;
	DWORD dwMessageSize;
	
    dwMessageSize = GET_MESSAGE_SIZE(this,MSG_SYSMESSAGE);
    pBuffer = DPMEM_ALLOC(dwMessageSize);
    if (!pBuffer) 
    {
	    DPF_ERR("could not send die piggy - out of memory");
	    return;
    }

    // pmsg follows sp blob
    pmsg = (LPMSG_SYSMESSAGE)(pBuffer + this->dwSPHeaderSize);

    // build a message to send to the sp
    SET_MESSAGE_HDR(pmsg);
    SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_DIEPIGGY);
	
	DoReply(this,pBuffer,dwMessageSize,pvSPHeader,0);
	
	return ;
	
} // SendDiePiggy

/*
 ** SP_HandlePlayerMgmt
 *
 *  CALLED BY:	DPlay_HandleSPMessage
 *
 *  PARAMETERS:
 *				pPlayer - player that received the message (sysplayer)
 *				pReceiveBuffer - message that was received
 *
 *  DESCRIPTION:
 *				our sysplayer got a state changed message off the wire. process it,
 *				and tell all local players
 *
 *  RETURNS: corresponding idirectplay hr
 *
 */

HRESULT SP_HandlePlayerMgmt(LPDPLAYI_PLAYER pPlayer,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader) 
{
    HRESULT hr = DP_OK;
	LPDPLAYI_DPLAY this;
	LPMSG_PLAYERMGMTMESSAGE pmsg;
	DWORD dwCmd;
	BOOL bDistribute = TRUE; // when deleting a player or group, we need to
							// build the player message b4 it's gone.  this flag
							// tells us not to do it twice
			 
	if (!pPlayer)
	{
		DPF_ERR("got system message, but don't have a system player ACK ACK ACK");

#ifdef DIE_PIG
		DPF_ERRVAL("sending DIE PIGGY.  sayonara sucker pvSPHeader = 0x%08lx",pvSPHeader);
		SendDiePiggy(gpObjectList,pvSPHeader);
		DEBUG_BREAK();
#endif 		

		ASSERT(FALSE);
		return E_FAIL;
	}
	
	if(!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)){
		DPF(0,"Player %x is a sysplayer that is going away, rejecting system message\n",pPlayer);
		return E_FAIL;
	}
	
	this = pPlayer->lpDP;

	pmsg = (LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer;
	dwCmd = GET_MESSAGE_COMMAND(pmsg);

	// if it's remote or we're not handling a multicast, we don't need to process the message
	if ((DPSP_HEADER_LOCALMSG != pvSPHeader) || (this->dwFlags & DPLAYI_DPLAY_HANDLEMULTICAST))
	{
		// We want the default hresult to be DPERR_GENERIC so that we don't send
		// the message unless the processing is successful.
		hr = DPERR_GENERIC;
		
		switch (dwCmd)
		{
			case DPSP_MSG_DELETEPLAYER: 
			{
				BOOL bNameSrvr=FALSE; // used to indicate name srvr going away 
				BOOL bSysPlayer=FALSE; // set to TRUE if we're nuking a system player
				LPDPLAYI_PLAYER pDeletedPlayer;
				DPID idSysPlayer;  // the id of the deleted system player

				DPF(4, "Got DPSP_MSG_DELETEPLAYER for %d.", pmsg->dwPlayerID);
				
				pDeletedPlayer = PlayerFromID(this,pmsg->dwPlayerID);
		        if (!VALID_DPLAY_PLAYER(pDeletedPlayer)) 
		        {
					DPF_ERR("bad player id!!");
//					ASSERT(FALSE);
					return DPERR_INVALIDPARAMS; // bail!
		        }				

				#define DPLAYI_PLAYER_LOCALAPPSERVER (DPLAYI_PLAYER_APPSERVER|DPLAYI_PLAYER_PLAYERLOCAL)
				// seems like a remote is trying to delete the app server.
				if((pDeletedPlayer->dwFlags & DPLAYI_PLAYER_LOCALAPPSERVER)==DPLAYI_PLAYER_LOCALAPPSERVER)
				{
					DPF_ERR("remote trying to delete local appserver player, not allowed!!!!\n");
					return DPERR_INVALIDPARAMS;
				}
				#undef DPLAYI_PLAYER_LOCALAPPSERVER

				if (DPLAYI_PLAYER_SYSPLAYER & pDeletedPlayer->dwFlags) 
				{
					// if it's the name srvr, we want to deal w/ it after we delete
					// it from the table
					if (DPLAYI_PLAYER_NAMESRVR & pDeletedPlayer->dwFlags) bNameSrvr = TRUE;
					bSysPlayer = TRUE;				
					idSysPlayer = pDeletedPlayer->dwID; // we may need this below to take ownership of its groups		
				}
				
				// need to distribute player system messages now, b4 player is nuked				
				hr = DistributeSystemMessage(this,pReceiveBuffer,dwMessageSize);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
				}
				bDistribute = FALSE;
				
				hr = InternalDestroyPlayer(this,pDeletedPlayer,FALSE,TRUE);	
				if (FAILED(hr))
				{
					ASSERT(FALSE);
				}
				
				// if a sysplayer was nuked, and there was no DX3 in the game, we can reassign
				// the sysplayers group to the current name server.  if there is dx3 in the game,
				// we don't know the id of the new name server yet
				if (bSysPlayer & !(this->dwFlags & DPLAYI_DPLAY_DX3INGAME) )
				{
					TransferGroupsToNameServer(this,idSysPlayer);
				}

				
				break;
			} // case dpsp_msg_deleteplayer

			case DPSP_MSG_CREATEPLAYER:
			{
				LPDPLAYI_PLAYER pPlayer;
				
				// Need to set the hresult to DP_OK so we send the message
				hr = DP_OK;

				// make sure player's not already in our nametable
				// this will happen e.g. on an addforward
				pPlayer = PlayerFromID(this,pmsg->dwPlayerID);
				if (!VALID_DPLAY_PLAYER(pPlayer))
				{
					// get the new player out of the message 
					hr = UnpackPlayerAndGroupList(this,pReceiveBuffer + 
						((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwCreateOffset,1,0,pvSPHeader);

					// if this is the nameserver, clear the nonameserver flag
					pPlayer = PlayerFromID(this,pmsg->dwPlayerID);
					if(VALID_DPLAY_PLAYER(pPlayer) && pPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR){
						this->dwFlags &= ~DPLAYI_DPLAY_NONAMESERVER;
					}
					
				}
				break;
			}
				
			case DPSP_MSG_DELETEGROUP:
			{
				LPDPLAYI_GROUP pGroup;
				
		        pGroup = GroupFromID(this,pmsg->dwGroupID);
		        if (!VALID_DPLAY_GROUP(pGroup)) 
		        {
					DPF_ERR("could not delete group - invalid group id");
		            return DPERR_INVALIDGROUP;
		        }
				
				// need to distribute player system messages now, b4 player is nuked				
				hr = DistributeSystemMessage(this,pReceiveBuffer,dwMessageSize);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
				}
				bDistribute = FALSE;

				hr = InternalDestroyGroup(this,pGroup,FALSE);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
				}

				break;
			}

			case DPSP_MSG_CREATEGROUP: 
			{
				// get the new group out of the message 
				hr = UnpackPlayerAndGroupList(this,pReceiveBuffer +
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwCreateOffset,0,1,pvSPHeader);
				break;
			}

			case DPSP_MSG_ADDPLAYERTOGROUP:
				hr = InternalAddPlayerToGroup((IDirectPlay *)this->pInterfaces,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwGroupID,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwPlayerID,FALSE);
				break;
			
			case DPSP_MSG_DELETEPLAYERFROMGROUP:
				hr = InternalDeletePlayerFromGroup((IDirectPlay *)this->pInterfaces,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwGroupID,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwPlayerID,FALSE);
				break;
			
			case DPSP_MSG_PLAYERDATACHANGED: 
			case DPSP_MSG_GROUPDATACHANGED:
			case DPSP_MSG_PLAYERNAMECHANGED:
			case DPSP_MSG_GROUPNAMECHANGED:

				hr = SP_HandleDataChanged(this,pReceiveBuffer);
				break;
			
			case DPSP_MSG_SESSIONDESCCHANGED:

				hr = SP_HandleSessionDescChanged(this,pReceiveBuffer);
				break;

			case DPSP_MSG_ADDSHORTCUTTOGROUP:
				hr = InternalAddGroupToGroup((IDirectPlay *)this->pInterfaces,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwGroupID,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwPlayerID,DPGROUP_SHORTCUT,FALSE);
				break;

			case DPSP_MSG_DELETEGROUPFROMGROUP:
				hr = InternalDeleteGroupFromGroup((IDirectPlay *)this->pInterfaces,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwGroupID,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwPlayerID,FALSE);
				break;
			
#ifdef DPLAY_VOICE_SUPPORT
			case DPSP_MSG_VOICEOPEN:
				hr = InternalOpenVoice((IDirectPlay *)this->pInterfaces, 
					((LPMSG_VOICE)pmsg)->dwIDFrom,
					((LPMSG_VOICE)pmsg)->dwIDTo, 0, FALSE);
				break;
				
			case DPSP_MSG_VOICECLOSE:
				hr = InternalCloseVoice( this,FALSE );
				break;
#endif
				
			default:
				ASSERT(FALSE);
				DPF(0,"SP_Playermess: received unrecognized message - msg = %d\n",dwCmd);
		} // switch
	} // DPSP_HEADER_LOCALMSG

	// dplay has processed the system message - tell all local players about it
	if (bDistribute && SUCCEEDED(hr))
	{
		hr = DistributeSystemMessage(this,pReceiveBuffer,dwMessageSize);		
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	return DP_OK;
} // SP_HandlePlayerMgmt

// construct player or group flags
DWORD GetPlayerFlags(LPDPLAYI_PLAYER pPlayer)
{
	DWORD	dwFlags;

	dwFlags = 0;

	// player is a server player
	if (pPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER)
	{
		dwFlags |= DPPLAYER_SERVERPLAYER;
	}

	// player is a spectator
	if (pPlayer->dwFlags & DPLAYI_PLAYER_SPECTATOR)
	{
		dwFlags |= DPPLAYER_SPECTATOR;
	}

	// player or group was created locally
	if (pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
	{
		dwFlags |= DPPLAYER_LOCAL;
	}

	// group is a staging area
	if (pPlayer->dwFlags & DPLAYI_GROUP_STAGINGAREA)
	{
		dwFlags |= DPGROUP_STAGINGAREA;
	}

	// group is hidden
	if (pPlayer->dwFlags & DPLAYI_GROUP_HIDDEN)
	{
		dwFlags |= DPGROUP_HIDDEN;
	}

	return (dwFlags);
} // GetPlayerFlags

#undef DPF_MODNAME
#define DPF_MODNAME	"MESSAGE BUILDER"

/*
 ** BuildAddMessage
 *
 *  CALLED BY: BuildPlayerSystemMessage
 *
 *  PARAMETERS:
 *		pPlayerSrc - the player that received this message
 *		pReceiveBuffer - the message that was received
 *		ppMessageBuffer - buffer going out to the user
 *		pdwMessagesize - size of ppMessageBuffer
 *		fPlayer - is this an addplayer or addgroup.  
 *
 *  DESCRIPTION: builds a player system message. converts dplay internal 
 *		message format to user readable format (see dplay.h). called before 
 *		putting a message in the apps message queue.
 *
 *  RETURNS: DP_OK, ppMessagebuffer,pdwMessagesize, or E_OUTOFMEMORY
 *
 */

HRESULT BuildAddMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize,BOOL fPlayer)
{
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	LPDPLAYI_PLAYER pPlayer; // the player being created
	LPDPLAYI_GROUP pGroup; // used to verify group
	DPMSG_CREATEPLAYERORGROUP dpmsg; // the message being built
	LPBYTE pBufferIndex; 
	UINT iShortStrLen,iLongStrLen; // strlength, in bytes
	
	memset(&dpmsg,0,sizeof(dpmsg));

	if (fPlayer)
	{
	    pPlayer = PlayerFromID(this,
	    	((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID);
	    if (!VALID_DPLAY_PLAYER(pPlayer)) 
	    {
			// this happens (e.g. player gets deleted between when sysplayer sends addplayermessage
			// and we receive it)
	    	return DPERR_INVALIDPARAMS;
	    }
		dpmsg.dwPlayerType = DPPLAYERTYPE_PLAYER;
	}
	else 
	{
		pGroup = GroupFromID(this,
			((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID);
	    if (!VALID_DPLAY_GROUP(pGroup)) 
	    {
			// this happens (e.g. player gets deleted between when sysplayer sends addplayermessage
			// and we receive it)
	    	return DPERR_INVALIDPARAMS;
	    }
		// cast to pPlayer since we only care about common fields
		pPlayer = (LPDPLAYI_PLAYER)pGroup;
		dpmsg.dwPlayerType = DPPLAYERTYPE_GROUP;
	}

	ASSERT(pPlayer);

	// don't generate player message if it's a sysplayer
	// not really an error, but we use this to make sure user doesn't 
	// see messages they shouldn't get...
	if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) return E_FAIL;

	// make sure user doesn't get self - create message
	if (pPlayer->dwID == pPlayerSrc->dwID) return E_FAIL; 
	
	// build the message
	dpmsg.dwType = DPSYS_CREATEPLAYERORGROUP;
	dpmsg.dpId = pPlayer->dwID;
	dpmsg.dwCurrentPlayers = this->lpsdDesc->dwCurrentPlayers;
	dpmsg.dwDataSize = pPlayer->dwPlayerDataSize;
	dpmsg.dpnName.dwSize = sizeof(DPNAME);
	dpmsg.dpIdParent = pPlayer->dwIDParent;
	dpmsg.dwFlags = GetPlayerFlags(pPlayer);
	iShortStrLen =  WSTRLEN_BYTES(pPlayer->lpszShortName) ;
	iLongStrLen =  WSTRLEN_BYTES(pPlayer->lpszLongName) ;

	// alloc the user message
	*pdwMessageSize = sizeof(DPMSG_CREATEPLAYERORGROUP) + iShortStrLen + iLongStrLen +
		pPlayer->dwPlayerDataSize;

	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}
	
	// now , build the buffer

	// copy the strings into the buffer. set the pointers in the name
	// struct to point at the strings
	pBufferIndex = (LPBYTE) *ppMessageBuffer + sizeof(dpmsg);
	if (iShortStrLen)
	{
		memcpy(pBufferIndex,pPlayer->lpszShortName,iShortStrLen);
		// set pointer to point at string in buffer
		dpmsg.dpnName.lpszShortName = (WCHAR *)pBufferIndex;
		pBufferIndex += iShortStrLen;
	}
	else 
	{
		dpmsg.dpnName.lpszShortName = (WCHAR *)NULL;
	}

	// long string
	if (iLongStrLen)
	{
		memcpy(pBufferIndex,pPlayer->lpszLongName,iLongStrLen);
		// set pointer to point at string in buffer
		dpmsg.dpnName.lpszLongName = (WCHAR *)pBufferIndex;
		pBufferIndex += iLongStrLen;
	}
	else 
	{
		dpmsg.dpnName.lpszLongName = (WCHAR *)NULL;
	}

	// copy the player blob into the buffer. set the blob pointer
	if (pPlayer->dwPlayerDataSize)
	{
		memcpy(pBufferIndex,pPlayer->pvPlayerData,pPlayer->dwPlayerDataSize);
		dpmsg.lpData = pBufferIndex;
	}
	else 
	{
		dpmsg.lpData = NULL;
	}

	// copy over the message portion
	memcpy(*ppMessageBuffer,&dpmsg,sizeof(dpmsg));

	// all done...
	return DP_OK;

} // BuildAddMessage

// see BuildAddMessage comments
HRESULT BuildDeleteMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize,BOOL fPlayer)
{
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	DPMSG_DESTROYPLAYERORGROUP dpmsg;
	LPDPLAYI_PLAYER pPlayer;
	LPBYTE pBufferIndex; 
	UINT iShortStrLen,iLongStrLen; // strlength, in bytes

	if (fPlayer) 
	{
		dpmsg.dpId = ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID;		
		// don't send to self...
		// a-josbor- in order to support the NAMESERVER being able to delete
		//	any player, we must allow the delete message to be delivered to
		//	"self"
	//	if (dpmsg.dpId == pPlayerSrc->dwID) return E_FAIL;

        pPlayer = PlayerFromID(this,dpmsg.dpId);
        if (!VALID_DPLAY_PLAYER(pPlayer)) 
        {
		
			// e.g. we've gotten two deletes. this can happen e.g.
			// w/ keep alive threads on two systems simultaneously
			// detecting someone's gone
        	return DPERR_INVALIDPARAMS;
        }

		if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
		{
			// not really an error, just don't tell users about
			// sysplayer stuff
			return E_FAIL;
		}

		dpmsg.dwPlayerType = DPPLAYERTYPE_PLAYER;
	} // fPlayer
	else 
	{	
		LPDPLAYI_GROUP pGroup;

		// group
		dpmsg.dpId = ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwGroupID;
		dpmsg.dwPlayerType = DPPLAYERTYPE_GROUP;	
		
		pGroup = GroupFromID(this,dpmsg.dpId);
        if (!VALID_DPLAY_GROUP(pGroup)) 
        {
			// should never happen
			ASSERT(FALSE);		
        	return DPERR_INVALIDPARAMS;
        }
		// cast to player for what we need
		pPlayer = (LPDPLAYI_PLAYER)pGroup;
	}

	dpmsg.dwFlags = GetPlayerFlags(pPlayer);
	dpmsg.dpIdParent = pPlayer->dwIDParent;
	dpmsg.dwType = DPSYS_DESTROYPLAYERORGROUP;
	dpmsg.dpnName.dwSize = sizeof(DPNAME);
	dpmsg.dpnName.dwFlags = 0;
	iShortStrLen =  WSTRLEN_BYTES(pPlayer->lpszShortName);
	iLongStrLen =  WSTRLEN_BYTES(pPlayer->lpszLongName);
	
	// calc message size
	*pdwMessageSize = sizeof(DPMSG_DESTROYPLAYERORGROUP)
						+ pPlayer->dwPlayerLocalDataSize
						+ pPlayer->dwPlayerDataSize
						+ iShortStrLen + iLongStrLen;
	
	// alloc the user message
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	pBufferIndex = (LPBYTE)(*ppMessageBuffer) + sizeof(dpmsg);

	// copy the local player data
	dpmsg.dwLocalDataSize = pPlayer->dwPlayerLocalDataSize;
	if (dpmsg.dwLocalDataSize)
	{
		dpmsg.lpLocalData = pBufferIndex;
		memcpy(dpmsg.lpLocalData,pPlayer->pvPlayerLocalData,pPlayer->dwPlayerLocalDataSize);
		pBufferIndex += dpmsg.dwLocalDataSize;
	}
	else 
	{
		dpmsg.lpLocalData = NULL;
	}
	
	// copy the Player data
	dpmsg.dwRemoteDataSize = pPlayer->dwPlayerDataSize;
	if (dpmsg.dwRemoteDataSize)
	{
		dpmsg.lpRemoteData = pBufferIndex;
		memcpy(dpmsg.lpRemoteData,pPlayer->pvPlayerData,pPlayer->dwPlayerDataSize);
		pBufferIndex += dpmsg.dwRemoteDataSize;
	}
	else 
	{
		dpmsg.lpRemoteData = NULL;
	}

	// copy the strings into the buffer. set the pointers in the name
	// struct to point at the strings
	if (iShortStrLen)
	{
		memcpy(pBufferIndex,pPlayer->lpszShortName,iShortStrLen);
		// set pointer to point at string in buffer
		dpmsg.dpnName.lpszShortName = (WCHAR *)pBufferIndex;
		pBufferIndex += iShortStrLen;
	}
	else 
	{
		dpmsg.dpnName.lpszShortName = (WCHAR *)NULL;
	}

	// long string
	if (iLongStrLen)
	{
		memcpy(pBufferIndex,pPlayer->lpszLongName,iLongStrLen);
		// set pointer to point at string in buffer
		dpmsg.dpnName.lpszLongName = (WCHAR *)pBufferIndex;
		pBufferIndex += iLongStrLen;
	}
	else 
	{
		dpmsg.dpnName.lpszLongName = (WCHAR *)NULL;
	}
	
	// put the sys message into the buffer
	memcpy(*ppMessageBuffer,&dpmsg,sizeof(dpmsg));
	return DP_OK;

} // BuildDeleteMessage	

// see BuildAddPlayerMessage comments
// fAdd - True - add to group, false, delete from group
HRESULT BuildPlayerGroupMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize,DWORD dwType)
{
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	DPMSG_GROUPADD dpmsg; // add or delete mesage

	dpmsg.dpIdPlayer = ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID;
	dpmsg.dpIdGroup = ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwGroupID;	

	// set up dpmsg
	dpmsg.dwType = dwType;

	*pdwMessageSize = sizeof(dpmsg);
	
	// alloc the user message
	*ppMessageBuffer = NULL;
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}
	
	memcpy(*ppMessageBuffer,&dpmsg,*pdwMessageSize);
	return DP_OK;

	
} // BuildPlayerGroupMessage

// see BuildAddMessage comments
HRESULT BuildDataChanged(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize,BOOL fPlayer)
{
	DPMSG_SETPLAYERORGROUPDATA msg;
	LPVOID pvData;
	DWORD dwDataSize;
	DWORD dwID;
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	
	if (this->lpsdDesc->dwFlags & DPSESSION_NODATAMESSAGES) return E_FAIL;
	
	// see who it's from
	dwID = ((LPMSG_PLAYERDATA)pReceiveBuffer)->dwPlayerID;

	// find the data + size
	pvData = pReceiveBuffer + ((LPMSG_PLAYERDATA)pReceiveBuffer)->dwDataOffset;
	dwDataSize = ((LPMSG_PLAYERDATA)pReceiveBuffer)->dwDataSize;

	// alloc the user message
	*pdwMessageSize = sizeof(msg) + dwDataSize;
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	msg.dwType = DPSYS_SETPLAYERORGROUPDATA;
	if (fPlayer) 
	{
		msg.dwPlayerType = DPPLAYERTYPE_PLAYER;
	}
	else 
	{
		msg.dwPlayerType = DPPLAYERTYPE_GROUP;
	}

	msg.dpId = dwID;
	msg.dwDataSize = dwDataSize;
	if (dwDataSize) msg.lpData = (LPBYTE)*ppMessageBuffer + sizeof(msg);
	else msg.lpData = (LPBYTE)NULL;

	// copy the message
	memcpy(*ppMessageBuffer,&msg,sizeof(msg));
	// copy the data
	if (dwDataSize)
	{
		memcpy((LPBYTE)*ppMessageBuffer + sizeof(msg),pvData,dwDataSize);
	}

	return DP_OK;
} // BuildDataChanged

// see BuildAddMessage comments
HRESULT BuildNameChanged(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize,BOOL fPlayer)
{
	DPMSG_SETPLAYERORGROUPNAME msg;
	UINT nShortLength,nLongLength;
	LPWSTR pszShortName,pszLongName;
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	
	if (this->lpsdDesc->dwFlags & DPSESSION_NODATAMESSAGES) return E_FAIL;

	msg.dpId = ((LPMSG_PLAYERNAME)pReceiveBuffer)->dwPlayerID;

	msg.dpnName.dwSize = sizeof(msg.dpnName);
	msg.dwType = DPSYS_SETPLAYERORGROUPNAME;

	if (fPlayer) 
	{
		msg.dwPlayerType = DPPLAYERTYPE_PLAYER;
	}
	else 
	{
		msg.dwPlayerType = DPPLAYERTYPE_GROUP;
	}

	if (((LPMSG_PLAYERNAME)pReceiveBuffer)->dwShortOffset)
	{
		pszShortName = (LPWSTR)(pReceiveBuffer + ((LPMSG_PLAYERNAME)pReceiveBuffer)->dwShortOffset);
		nShortLength = WSTRLEN_BYTES(pszShortName);		
	}
	else 
	{
		nShortLength = 0;
		pszShortName = (LPWSTR)NULL;
	}
	
	if (((LPMSG_PLAYERNAME)pReceiveBuffer)->dwLongOffset)
	{
		pszLongName = (LPWSTR)(pReceiveBuffer + ((LPMSG_PLAYERNAME)pReceiveBuffer)->dwLongOffset);
		nLongLength = WSTRLEN_BYTES(pszLongName);				
	}
	else 
	{
		nLongLength = 0;
		pszLongName = (LPWSTR)NULL;
	}

	
	*pdwMessageSize = sizeof(msg) + nShortLength + nLongLength;
	
	// alloc the user message
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	// copy the strings into the buffer, behind where msg will go
	// short name follows message
	if (nShortLength)
	{
		memcpy(*ppMessageBuffer + sizeof(msg),pszShortName,nShortLength);
		msg.dpnName.lpszShortName = (LPWSTR)((LPBYTE)*ppMessageBuffer + sizeof(msg));
	} 
	else 
	{
		msg.dpnName.lpszShortName = (LPWSTR)NULL;
	}
	// long name follows short name
	if (nLongLength)
	{
		memcpy(*ppMessageBuffer + sizeof(msg) + nShortLength,pszLongName,nLongLength);

		msg.dpnName.lpszLongName = (LPWSTR)( (LPBYTE)*ppMessageBuffer + sizeof(msg)
			+ nShortLength);
	} 
	else 
	{
		msg.dpnName.lpszLongName = (LPWSTR)NULL;
	}

	// now, copy over the message
	memcpy(*ppMessageBuffer,&msg,sizeof(msg));

	return DP_OK;

} // BuildNameChanged

// see BuildAddMessage comments
HRESULT BuildNameServerMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize)
{
	DPMSG_GENERIC msg;

	*pdwMessageSize = sizeof(msg);
	
	// alloc the user message
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	msg.dwType = DPSYS_HOST;

	// copy the message
	memcpy(*ppMessageBuffer,&msg,sizeof(msg));

	return DP_OK;

} // BuildNameServerMessage

// see BuildAddMessage comments
HRESULT BuildSessionDescMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize)
{
	DPMSG_SETSESSIONDESC msg;
	UINT nPasswordLength,nSessionNameLength;
	LPWSTR pszSessionName,pszPassword;
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	
	if (this->lpsdDesc->dwFlags & DPSESSION_NODATAMESSAGES) return E_FAIL;

	if (((LPMSG_SESSIONDESC)pReceiveBuffer)->dwSessionNameOffset)
	{
		pszSessionName = (LPWSTR)(pReceiveBuffer + ((LPMSG_SESSIONDESC)pReceiveBuffer)->dwSessionNameOffset);
		nSessionNameLength = WSTRLEN_BYTES(pszSessionName);		
	}
	else 
	{
		nSessionNameLength = 0;
		pszSessionName = (LPWSTR)NULL;
	}
	
	if (((LPMSG_SESSIONDESC)pReceiveBuffer)->dwPasswordOffset)
	{
		pszPassword = (LPWSTR)(pReceiveBuffer + ((LPMSG_SESSIONDESC)pReceiveBuffer)->dwPasswordOffset);
		nPasswordLength = WSTRLEN_BYTES(pszPassword);				
	}
	else 
	{
		nPasswordLength = 0;
		pszPassword = (LPWSTR)NULL;
	}
	
	*pdwMessageSize = sizeof(msg) + nSessionNameLength + nPasswordLength;
	
	// alloc the user message
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

    // prepare the message 

	msg.dwType = DPSYS_SETSESSIONDESC;
    // copy the session desc 
    memcpy(&(msg.dpDesc), &((LPMSG_SESSIONDESC)pReceiveBuffer)->dpDesc, sizeof(DPSESSIONDESC2));

	// copy the strings into the buffer, behind where msg will go
	// session name follows message
	if (nSessionNameLength)
	{
		memcpy(*ppMessageBuffer + sizeof(msg),pszSessionName,nSessionNameLength);
		msg.dpDesc.lpszSessionName = (LPWSTR)((LPBYTE)*ppMessageBuffer + sizeof(msg));
	} 
	else 
	{
		msg.dpDesc.lpszSessionName = (LPWSTR)NULL;
	}
	// password follows session name
	if (nPasswordLength)
	{
		memcpy(*ppMessageBuffer + sizeof(msg) + nSessionNameLength,pszPassword,nPasswordLength);
		msg.dpDesc.lpszPassword = (LPWSTR)( (LPBYTE)*ppMessageBuffer + sizeof(msg)
			+ nSessionNameLength);
	} 
	else 
	{
		msg.dpDesc.lpszPassword = (LPWSTR)NULL;
	}

	// now, copy over the message
	memcpy(*ppMessageBuffer,&msg,sizeof(msg));

	return DP_OK;

} // BuildSessionDescMessage

// see BuildAddMessage comments
HRESULT BuildSecureSystemMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize, DWORD dwSendFlags)
{	
    LPDPMSG_SECUREMESSAGE pSecureMessage;
    LPMSG_PLAYERMESSAGE pPlayerMessage=(LPMSG_PLAYERMESSAGE)pReceiveBuffer;
    DWORD dwPlayerMessageSize;
    LPDPLAYI_DPLAY this;

    ASSERT(pdwMessageSize);
    ASSERT(ppMessageBuffer);

    this = pPlayerSrc->lpDP;

	// naked?
	if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
	{
		// not naked
		// if we're not naked, player to == player from is not allowed
		if (pPlayerSrc->dwID == pPlayerMessage->idFrom)		
		{
			DPF(7,"not delivering message w/ to == from");
			return DPERR_GENERIC;
		}
		// subtract off the size of the to and from
		*pdwMessageSize -=  sizeof(MSG_PLAYERMESSAGE); // size of user data
	}

    // Remember the player message size so we can copy the correct portion of the 
    // player message from the receive buffer.
    dwPlayerMessageSize = *pdwMessageSize;

    // allocate memory for entire player message + secure msg struct
	*pdwMessageSize += sizeof(DPMSG_SECUREMESSAGE);
	
	// alloc memory for the user message
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return DPERR_OUTOFMEMORY;
	}

    // use the buffer as a secure message
    pSecureMessage = (LPDPMSG_SECUREMESSAGE)*ppMessageBuffer;

    // fill the message type
    pSecureMessage->dwType = DPSYS_SECUREMESSAGE;
    // fill the flags
    if (dwSendFlags & DPSEND_SIGNED)
    {
        pSecureMessage->dwFlags |= DPSEND_SIGNED;
    }
    if (dwSendFlags & DPSEND_ENCRYPTED)
    {
        pSecureMessage->dwFlags |= DPSEND_ENCRYPTED;
    }
    // fill the player from id
    pSecureMessage->dpIdFrom = ((LPMSG_PLAYERMESSAGE)pReceiveBuffer)->idFrom;
    // point to the actual player-player message
    pSecureMessage->lpData = (LPBYTE)pSecureMessage+sizeof(DPMSG_SECUREMESSAGE);
    // fill the message size
    pSecureMessage->dwDataSize = dwPlayerMessageSize;
    // copy the message
	if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
	{
		// not naked
		// copy message without ids
		memcpy(pSecureMessage->lpData,pReceiveBuffer+sizeof(MSG_PLAYERMESSAGE),
            dwPlayerMessageSize);
	}
	else 
	{
		// copy naked message into pMessageBuffer
		memcpy(pSecureMessage->lpData,pReceiveBuffer,dwPlayerMessageSize);
	}	

	return DP_OK;

} // BuildSecureSystemMessage

// see BuildAddMessage comments
HRESULT BuildStartSessionMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize)
{
	LPDPMSG_STARTSESSION	lpmsg;
	LPMSG_STARTSESSION		lpmsgIn = (LPMSG_STARTSESSION)pReceiveBuffer;
	DWORD					dwConnSize;
	DWORD					dwSize;
	LPBYTE					lpByte = NULL, lpByte2 = NULL;
	LPDPLCONNECTION			lpConn = NULL;
	LPDPSESSIONDESC2		lpsd = NULL;


	// calc the size
	dwConnSize = *pdwMessageSize - sizeof(DPSP_MSG_STARTSESSION);
	dwSize = sizeof(DPMSG_STARTSESSION) + dwConnSize;
	
	*pdwMessageSize = dwSize;
	
	// alloc the user message
	lpmsg = DPMEM_ALLOC(dwSize);
	if (!lpmsg) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	lpmsg->dwType = DPSYS_STARTSESSION;

	// copy the message
	lpByte = (LPBYTE)lpmsg + sizeof(DPMSG_STARTSESSION);
	lpByte2 = (LPBYTE)lpmsgIn + lpmsgIn->dwConnOffset;
	memcpy(lpByte, lpByte2, dwConnSize);

	// fix the DPLCONNECTION pointer
	lpmsg->lpConn = lpConn = (LPDPLCONNECTION)lpByte;

	// Stick the dplay object's pointer in one of the reserved
	// fields in the SessionDesc so we can forward lobby messages back
	// to the server on that object.  NOTE: The following code relies on the
	// packing code for the DPLCONNECTION structure to remain unchanged.  If
	// the packing changes, this offset calculation may not work correctly.
	lpsd = (LPDPSESSIONDESC2)((LPBYTE)lpConn + (DWORD_PTR)lpConn->lpSessionDesc);
	lpsd->dwReserved1 = (DWORD_PTR)(pPlayerSrc->lpDP);
	lpsd->dwReserved2 = pPlayerSrc->dwID;

	*ppMessageBuffer = (LPBYTE)lpmsg;

	return DP_OK;

} // BuildStartSessionMessage

// see BuildAddMessage comments
HRESULT BuildChatMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize)
{
	LPDPMSG_CHAT		lpmsg;
	LPMSG_CHAT			lpmsgIn = (LPMSG_CHAT)pReceiveBuffer;
	DWORD				dwStringSize, dwSize;
	LPWSTR				lpwszMessageIn = NULL, lpwszMessage = NULL;
	LPDPLAYI_PLAYER		lpPlayer = NULL;
	LPDPLAYI_GROUP		lpGroup = NULL;
	

	// If from == to, then fail building this message because we
	// don't want to send a chat message to ourself.  Normally, the
	// DistributeGroupMessage function would catch this, but since
	// this is a system message, it won't because idFrom will be zero
	if(lpmsgIn->dwIDFrom == pPlayerSrc->dwID)
		return DPERR_GENERIC;

	// calc the size of the message
	lpwszMessageIn = (LPWSTR)((LPBYTE)lpmsgIn + lpmsgIn->dwMessageOffset);
	dwStringSize = WSTRLEN_BYTES(lpwszMessageIn);
	dwSize = sizeof(DPMSG_CHAT) + sizeof(DPCHAT) + dwStringSize;
	
	*pdwMessageSize = dwSize;
	
	// alloc the user message
	lpmsg = DPMEM_ALLOC(dwSize);
	if (!lpmsg) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	lpmsg->dwType = DPSYS_CHAT;
	lpmsg->idFromPlayer = lpmsgIn->dwIDFrom;
	lpmsg->lpChat = (LPDPCHAT)((LPBYTE)lpmsg + sizeof(DPMSG_CHAT));
	lpmsg->lpChat->dwSize = sizeof(DPCHAT);
	lpmsg->lpChat->dwFlags = lpmsgIn->dwFlags;

	// Determine if the message was sent to a group or a player and
	// set the appropriate idToXXXXX field in the message
	if(lpmsgIn->dwIDTo != DPID_ALLPLAYERS)
	{
		lpPlayer = PlayerFromID(pPlayerSrc->lpDP, lpmsgIn->dwIDTo);
		if(VALID_DPLAY_PLAYER(lpPlayer))
		{
			lpmsg->idToPlayer = lpmsgIn->dwIDTo;
		}
		else
		{
			lpGroup = GroupFromID(pPlayerSrc->lpDP, lpmsgIn->dwIDTo);
			if(VALID_DPLAY_GROUP(lpGroup))
			{
				lpmsg->idToGroup = lpmsgIn->dwIDTo;
			}
			else
			{
				DPF_ERRVAL("Received chat message for unknown player or group, ID = %lu", lpmsgIn->dwIDTo);
				ASSERT(FALSE);
				// I guess we'll treat it as a broadcast message
			}
		}
	}

	// copy the message
	lpwszMessage = (LPWSTR)((LPBYTE)lpmsg + sizeof(DPMSG_CHAT)
					+ sizeof(DPCHAT));
	memcpy(lpwszMessage, lpwszMessageIn, dwStringSize);

	// fix the DPCHAT string pointer
	lpmsg->lpChat->lpszMessage = lpwszMessage;

	*ppMessageBuffer = (LPBYTE)lpmsg;

	return DP_OK;

} // BuildChatMessage

// see BuildAddMessage comments
HRESULT BuildGroupOwnerChangedMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize)
{
	LPDPMSG_SETGROUPOWNER		lpmsg = NULL;
	LPMSG_GROUPOWNERCHANGED		lpmsgIn = (LPMSG_GROUPOWNERCHANGED)pReceiveBuffer;
	

	
	// alloc the user message
	lpmsg = DPMEM_ALLOC(sizeof(DPMSG_SETGROUPOWNER));
	if (!lpmsg) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	lpmsg->dwType = DPSYS_SETGROUPOWNER;
	lpmsg->idGroup = lpmsgIn->dwIDGroup;
	lpmsg->idNewOwner = lpmsgIn->dwIDNewOwner;
	lpmsg->idOldOwner = lpmsgIn->dwIDOldOwner;

	// Set the output pointers
	*pdwMessageSize = sizeof(DPMSG_SETGROUPOWNER);
	*ppMessageBuffer = (LPBYTE)lpmsg;

	return DP_OK;

} // BuildGroupOwnerChangedMessage

#ifdef DPLAY_VOICE_SUPPORT
// see BuildAddMessage comments
HRESULT BuildVoiceMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize,BOOL fOpen)
{
	LPDPMSG_VOICE				lpmsg = NULL;
	LPMSG_VOICE					lpmsgIn = (LPMSG_VOICE)pReceiveBuffer;
	
	// alloc the user message
	lpmsg = DPMEM_ALLOC(sizeof(DPMSG_VOICE));
	if (!lpmsg) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	if (fOpen)	lpmsg->dwType = DPSYS_VOICEOPEN;
	else lpmsg->dwType = DPSYS_VOICECLOSE;
	
	lpmsg->idToPlayer = lpmsgIn->dwIDTo;
	lpmsg->idFromPlayer = lpmsgIn->dwIDFrom;

	// Set the output pointers
	*pdwMessageSize = sizeof(DPMSG_VOICE);
	*ppMessageBuffer = (LPBYTE)lpmsg;

	return DP_OK;

} // BuildVoiceMessage
#endif

// sets up a dplay system message suitable for passing back to a player
/*
 ** BuildPlayerSystemMessage
 *
 *  CALLED BY:	HandlePlayerMessage
 *
 *  PARAMETERS:
 *				pPlayer	- the player that received the message
 *				pReceiveBuffer - the buffer that came off the wire
 *				ppMessageBuffer - the destination for the built message (return)
 *				pdwMessageSize - the size of the built message (return)
 *
 *  DESCRIPTION:
 *				Builds a system message (from dplay.h) corresponding to dplays
 *				internal message (from dpmess.h)
 *
 *  RETURNS: the BuildXXX rval
 *
 */
HRESULT BuildPlayerSystemMessage(LPDPLAYI_PLAYER pPlayer,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer, DWORD * pdwMessageSize) 
{
	DWORD dwCmd;
	HRESULT hr = DP_OK;

	dwCmd  = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pReceiveBuffer);

	switch (dwCmd)
	{
		case DPSP_MSG_PLAYERDATACHANGED: 
			hr = BuildDataChanged(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,TRUE);
			break;

		case DPSP_MSG_GROUPDATACHANGED:
			hr = BuildDataChanged(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,FALSE);
			break;
			
		case DPSP_MSG_PLAYERNAMECHANGED:
			hr = BuildNameChanged(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,TRUE);
			break;

		case DPSP_MSG_GROUPNAMECHANGED:
			hr = BuildNameChanged(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,FALSE);
			break;

		case DPSP_MSG_CREATEPLAYER: 
			hr = BuildAddMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,TRUE);
			break;

		case DPSP_MSG_CREATEGROUP: 
			hr = BuildAddMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,FALSE);
			break;			

		case DPSP_MSG_DELETEPLAYER:
			hr = BuildDeleteMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,TRUE);
			break;


		case DPSP_MSG_DELETEGROUP:
			hr = BuildDeleteMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,FALSE);
			
			break;

		case DPSP_MSG_ADDPLAYERTOGROUP:
			hr = BuildPlayerGroupMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,DPSYS_ADDPLAYERTOGROUP);
			break;

		case DPSP_MSG_DELETEPLAYERFROMGROUP:			
			hr = BuildPlayerGroupMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,DPSYS_DELETEPLAYERFROMGROUP);
			break;

		case DPSP_MSG_NAMESERVER:
			hr = BuildNameServerMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize);
			break;

        case DPSP_MSG_SESSIONDESCCHANGED:
            hr = BuildSessionDescMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
                    pdwMessageSize);
            break;

		case DPSP_MSG_ADDSHORTCUTTOGROUP:
			hr = BuildPlayerGroupMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,DPSYS_ADDGROUPTOGROUP);
			break;
			
		case DPSP_MSG_DELETEGROUPFROMGROUP:
			hr = BuildPlayerGroupMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,DPSYS_DELETEGROUPFROMGROUP);
			break;
			
		case DPSP_MSG_STARTSESSION:
			hr = BuildStartSessionMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize);
			break;
			
		case DPSP_MSG_CHAT:
			hr = BuildChatMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize);
			break;

		case DPSP_MSG_GROUPOWNERCHANGED:
			hr = BuildGroupOwnerChangedMessage(pPlayer,pReceiveBuffer,
					ppMessageBuffer,pdwMessageSize);
			break;

#ifdef DPLAY_VOICE_SUPPORT
		case DPSP_MSG_VOICEOPEN	:
			hr = BuildVoiceMessage(pPlayer,pReceiveBuffer,
					ppMessageBuffer,pdwMessageSize,TRUE);
			break;
			
		case DPSP_MSG_VOICECLOSE:
			hr = BuildVoiceMessage(pPlayer,pReceiveBuffer,
					ppMessageBuffer,pdwMessageSize,FALSE);
			break;
#endif
		
		default:
			ASSERT(FALSE);
			DPF_ERR("BUILD MESS: received unrecognized message");
			return E_UNEXPECTED;

	}
	return hr;	
} // BuildPlayerSystemMessage

#undef DPF_MODNAME
#define DPF_MODNAME	"DP_HANDLER"

// this function forwards a player message to the destination player indicated in the message
HRESULT NS_ForwardPlayerMessage(LPDPLAYI_DPLAY this, LPBYTE pReceiveBuffer, DWORD dwMessageSize,
        DWORD dwSendFlags)
{
    HRESULT hr;
    LPMSG_PLAYERMESSAGE pPlayerMsg = (LPMSG_PLAYERMESSAGE) pReceiveBuffer;
    LPBYTE pMsg;

    ASSERT(pPlayerMsg);

    // extract the message
    pMsg = (LPBYTE)pPlayerMsg + sizeof(MSG_PLAYERMESSAGE);
    dwMessageSize -= sizeof(MSG_PLAYERMESSAGE);

	DPF(7,"Forwarding player message from id %d to id %d",pPlayerMsg->idFrom, pPlayerMsg->idTo);

	if (dwSendFlags & DPSEND_GUARANTEED)
	{
		// Put us in pending mode, so messages don't get delivered out of 
		// order. A message coming off the wire can get the dplay lock in the
		// window between the time we drop it and DP_Send takes the lock.
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
	}

    LEAVE_DPLAY();

	// call send - it will push the bits through the wire for us
	hr = DP_Send((LPDIRECTPLAY)this->pInterfaces,pPlayerMsg->idFrom,
		pPlayerMsg->idTo, dwSendFlags, pMsg,dwMessageSize);

    ENTER_DPLAY();

    return hr;
} // NS_ForwardPlayerMessage

// a player has received a message. this can be either 1. a system message
// (e.g. new player announcment) or 2. a player-player message
// we package it up in the public dplay format, and put it on the message q
// fPlayerMessage is TRUE if it's player-player
HRESULT HandlePlayerMessage(LPDPLAYI_PLAYER pPlayer,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize,BOOL fPlayerMessage, DWORD dwSendFlags) 
{
	HRESULT hr=DP_OK;
	LPDPLAYI_DPLAY this;
	LPMESSAGENODE pmsn=NULL; // we'll add this node to iplay's list of nodes
	LPMSG_PLAYERMESSAGE pmsg; // message cast from received buffer
	LPBYTE pMessageBuffer=NULL; // buffer we copy message into for storage

	this = pPlayer->lpDP;

    // in a secure session, player messages are routed through the server
    // so forward the message to the appropriate destination player
    if (SECURE_SERVER(this) && IAM_NAMESERVER(this))
    {
        // forward all remote player messages
        if (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
        {
			// currently we don't have a way of knowing if a received message was sent reliably.
			// but since we know that all secure messages are sent guaranteed, we can forward
			// this message reliably.
			dwSendFlags |= DPSEND_GUARANTEED;

            hr = NS_ForwardPlayerMessage(this, pReceiveBuffer, dwMessageSize, dwSendFlags);
            return hr;
        }
    }

	// alloc a message node
	pmsn = DPMEM_ALLOC(sizeof(MESSAGENODE));
    if (!pmsn) 
    {
    	DPF_ERR("could not handle player message - out of memory");
        return E_OUTOFMEMORY;
    }

	pmsg = (LPMSG_PLAYERMESSAGE)pReceiveBuffer;

	if (fPlayerMessage)
    {   // its a player - player message
		
        if (dwSendFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED))
        {
    	    // it's a secure message - convert it to the dplay system message format
		    hr = BuildSecureSystemMessage(pPlayer,pReceiveBuffer,&pMessageBuffer,&dwMessageSize,dwSendFlags);
		    if (FAILED(hr)) 
		    {
			    // its ok to fail this.  we fail when trying to distribute sysplayer
			    // announcments to players.
			    DPMEM_FREE(pmsn);
			    return DP_OK;
		    }            
		    pmsn->idFrom = 0; // system message

			DPF(5,"PlayerID %d received secure player message (Flags=0x%08x) from playerID %d size = %d\n",pPlayer->dwID,
						dwSendFlags, pmsg->idFrom,dwMessageSize);
        }
        else // unsecure player-player message
        {
		    // naked?
		    if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
		    {
			    // not naked
			    // if we're not naked, player to == player from is not allowed
			    if (pPlayer->dwID == pmsg->idFrom)		
			    {
				    DPF(7,"not delivering message w/ to == from");
				    DPMEM_FREE(pmsn);
				    return E_FAIL;
			    }
			    // subtract off the size of the to and from
			    dwMessageSize -=  sizeof(MSG_PLAYERMESSAGE); // size of user data
		    }

		    // need to make a copy of the off the wire message
		    pMessageBuffer = DPMEM_ALLOC(dwMessageSize);
	        if (!pMessageBuffer) 
	        {
	    	    DPF_ERR("could not handle player message - out of memory");
			    DPMEM_FREE(pmsn);
	            return E_OUTOFMEMORY;
	        }

		    if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
		    {
			    // not naked
			    // copy message into pMessageBuffer
			    memcpy(pMessageBuffer,pReceiveBuffer+sizeof(MSG_PLAYERMESSAGE),dwMessageSize);
		    }
		    else 
		    {
			    // copy naked message into pMessageBuffer
			    memcpy(pMessageBuffer,pReceiveBuffer,dwMessageSize);
		    }	

		    if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
		    {
			    pmsn->idFrom = pmsg->idFrom;						
		    }
		    else 
		    {
			    pmsn->idFrom = DPID_UNKNOWN;
		    }

#if 0
			DPF(5,"Player ID %d received player mess from player ID  %d size = %d - %s,%s\n",pPlayer->dwID,
						pmsg->idFrom,dwMessageSize,pMessageBuffer,pMessageBuffer+strlen(pMessageBuffer));
#endif						
			DPF(5,"Player ID %d received player mess from player ID  %d size = %d - \n",pPlayer->dwID,
						pmsg->idFrom,dwMessageSize);

        } // DPSEND_SIGNED || DPSEND_ENCRYPTED
	}
	else 
	{
    	// it's a system message - convert it to the dplay system message format
		hr = BuildPlayerSystemMessage(pPlayer,pReceiveBuffer,&pMessageBuffer,&dwMessageSize);
		if (FAILED(hr)) 
		{
			// its ok to fail this.  we fail when trying to distribute sysplayer
			// announcments to players.
			DPMEM_FREE(pmsn);
			return DP_OK;
		}
		pmsn->idFrom = 0;
	}

	DPF(7,"Putting message in apps queue");

	pmsn->idTo = pPlayer->dwID; 		
	pmsn->pNextMessage = NULL;
	pmsn->pMessage = pMessageBuffer;
	pmsn->dwMessageSize = dwMessageSize;

	if (!pmsn->pMessage)
	{
		ASSERT(FALSE);
		DPMEM_FREE(pmsn); // ack ! this should never fail!
		return E_FAIL;
	}

	this->nMessages++;

	// find last node on list, and stick pmsn behind it

	if(this->pLastMessage){
		this->pLastMessage->pNextMessage=pmsn;
		this->pLastMessage=pmsn;
	} else {
		this->pMessageList = pmsn;
		this->pLastMessage = pmsn;
	}

	// if player has event, trigger it
	if (pPlayer->hEvent) 
	{
		DPF(9,"triggering player event");
		SetEvent(pPlayer->hEvent);		
	}

	// all done...
	return hr;
} // HandlePlayerMessage

// we got a message addressed to a group.
// distribute it to all local players in that group
HRESULT DistributeGroupMessage(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP pGroupTo,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize,BOOL fPlayerMessage,DWORD dwSendFlags)
{
	LPDPLAYI_GROUPNODE pGroupnode;
	UINT nPlayers;
	HRESULT hr;

	ASSERT(this->pSysPlayer);

	// how many players are we looking for
	pGroupnode = FindPlayerInGroupList(pGroupTo->pSysPlayerGroupnodes,this->pSysPlayer->dwID);
	if (!pGroupnode)
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}
	nPlayers = pGroupnode->nPlayers;

	// walk the list of groupnodes, looking for nPlayers local players to give
	// the message to
	pGroupnode = pGroupTo->pGroupnodes;
	while ((nPlayers > 0) && (pGroupnode))
	{
		if (pGroupnode->pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
		{
			hr =  HandlePlayerMessage(pGroupnode->pPlayer,pReceiveBuffer,dwMessageSize,fPlayerMessage,dwSendFlags);
			nPlayers--;
		} // local
		
		pGroupnode = pGroupnode->pNextGroupnode;
	} // while
	
	ASSERT(0 == nPlayers);
	return DP_OK;
	
} // DistributeGroupMessage


// called by HandleEnumSessionsReply returns TRUE if pDesc1 and pDesc2
// are the same session
BOOL IsEqualSessionDesc(LPDPSESSIONDESC2 pDesc1,LPDPSESSIONDESC2 pDesc2) 
{
	if (IsEqualGUID(&(pDesc1->guidInstance),&(pDesc2->guidInstance)))
		return TRUE;

	return FALSE;
} // IsEqualSessionDesc

// this client called enum sessions.  the sp got a reply, we add that 
// to the list of known sessions
HRESULT HandleEnumSessionsReply(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,LPVOID pvSPHeader) 
{
    LPMSG_ENUMSESSIONSREPLY pem;
	LPSESSIONLIST pNewNode=NULL, pExistingNode=NULL;
	LPWSTR lpsz;

	pem = (LPMSG_ENUMSESSIONSREPLY) pReceiveBuffer;

	// alloc a new session node
	pNewNode = DPMEM_ALLOC(sizeof(SESSIONLIST));
    if (!pNewNode) 
    {
    	DPF_ERR("could not enum reply - out of memory");
        return E_OUTOFMEMORY;
    }

	// copy the description from the receive buffer to the session node
	memcpy(&(pNewNode->dpDesc),&(pem->dpDesc),sizeof(DPSESSIONDESC2));

    // remember the version of the message
    pNewNode->dwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReceiveBuffer);

    // remember the sp header for the session
	if ((this->dwSPHeaderSize) && (pvSPHeader))
	{
		// store the blob
		pNewNode->pvSPMessageData = DPMEM_ALLOC(this->dwSPHeaderSize);
		if (!pNewNode->pvSPMessageData)
		{
            DPMEM_FREE(pNewNode);
			DPF_ERR("could not alloc sp blob");
			return E_OUTOFMEMORY;
		}

		// copy the last this->dwSPHeaderSize bytes off the end of the buffer
		memcpy(pNewNode->pvSPMessageData,pvSPHeader,this->dwSPHeaderSize);
	}

	// unpack strings
	if (pem->dwNameOffset)
	{
		GetString(&lpsz,(WCHAR *)(pReceiveBuffer + pem->dwNameOffset));
		pNewNode->dpDesc.lpszSessionName = lpsz;
	}

	// see if this session is in the list
	pExistingNode = this->pSessionList;
	while (pExistingNode)
	{
		if ( IsEqualSessionDesc(&(pExistingNode->dpDesc),&(pem->dpDesc)))
		{
			// it's in the list already, so just update the node
            break;
		}
		pExistingNode = pExistingNode->pNextSession;
	}

    if (!pExistingNode)
    {
	    // put the new session list on the front of the list
	    pNewNode->pNextSession = this->pSessionList;
	    this->pSessionList = pNewNode;
		// timestamp it
		pNewNode->dwLastReply = GetTickCount();
    }
    else
    {
		// HACKHACK -- myronth -- 3/12/97
		// If the lobby owns this object, don't copy in the new address
		// because it is bogus.  We can remove this if/else after AndyCo
		// gets rid of the global session list.
		if(!IS_LOBBY_OWNED(this))
		{
			// preserve link to the next node in the session list
			pNewNode->pNextSession = pExistingNode->pNextSession;

			// cleanup old strings
			if (pExistingNode->dpDesc.lpszSessionName)
			{
				DPMEM_FREE(pExistingNode->dpDesc.lpszSessionName);
			}

			// cleanup old sp header
			if (pExistingNode->pvSPMessageData)
			{
				DPMEM_FREE(pExistingNode->pvSPMessageData);
			}

			// update the existing node
			memcpy(pExistingNode, pNewNode, sizeof(SESSIONLIST));
		}
		else
		{
			// Free the new SessionName string
			if(pNewNode->dpDesc.lpszSessionName)
				DPMEM_FREE(pNewNode->dpDesc.lpszSessionName);
		}
		// ENDHACKHACK!!!! -- myronth

		// timestamp it
		pExistingNode->dwLastReply = GetTickCount();
		
        // get rid of the new node
        DPMEM_FREE(pNewNode);
    }

	return DP_OK;

} // HandleEnumSessionsReply


// either the player name or player data has changed
// extract the params from the message, and call idirectplay to handle it
HRESULT SP_HandleDataChanged(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer)
{
	HRESULT hr = DP_OK;
	DWORD dwCmd;
	BOOL fPlayer = FALSE;
	DWORD dwID;

	dwID = ((LPMSG_PLAYERDATA)pReceiveBuffer)->dwPlayerID;	
	
	dwCmd = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pReceiveBuffer);
	
	switch (dwCmd)
	{
		case DPSP_MSG_PLAYERDATACHANGED: 
			fPlayer=TRUE;
			// fall through
		case DPSP_MSG_GROUPDATACHANGED:
		{
			LPVOID pvData;
			DWORD  dwDataSize;

			dwDataSize = ((LPMSG_PLAYERDATA)pReceiveBuffer)->dwDataSize;
			pvData = pReceiveBuffer + ((LPMSG_PLAYERDATA)pReceiveBuffer)->dwDataOffset;
			// get dplay to set the data
			hr = InternalSetData((IDirectPlay *)this->pInterfaces,dwID,pvData,dwDataSize,
					0,fPlayer,FALSE);
			if (FAILED(hr))
			{
				DPF(0, "InternalSetData returned error! hr = 0x%08x", hr);
			}
					
			break;
		}
		
		case DPSP_MSG_PLAYERNAMECHANGED:
			fPlayer = TRUE;
		case DPSP_MSG_GROUPNAMECHANGED:
		{
			DPNAME PlayerName;
			LPWSTR pszShortName,pszLongName;
			
			PlayerName.dwSize = sizeof(DPNAME);

			if (((LPMSG_PLAYERNAME)pReceiveBuffer)->dwShortOffset)
			{
				pszShortName = (LPWSTR)(pReceiveBuffer + ((LPMSG_PLAYERNAME)pReceiveBuffer)->dwShortOffset);
			}
			else 
			{
				pszShortName = (LPWSTR)NULL;
			}
			
			if (((LPMSG_PLAYERNAME)pReceiveBuffer)->dwLongOffset)
			{
				pszLongName = (LPWSTR)(pReceiveBuffer + ((LPMSG_PLAYERNAME)pReceiveBuffer)->dwLongOffset);
			}
			else 
			{
				pszLongName = (LPWSTR)NULL;
			}

			PlayerName.lpszShortName = pszShortName;
			PlayerName.lpszLongName = pszLongName;			
			
			// get dplay to set the name
			hr = InternalSetName((IDirectPlay *)this->pInterfaces,dwID,&PlayerName,
				fPlayer,0,FALSE);
			if (FAILED(hr))
			{
				DPF(0, "InternalSetname returned error! hr = 0x%08x", hr);
			}

			break;
			
		}
					
		default:
			ASSERT(FALSE);			
			break;

	}

	return hr;

}  // HandlePlayerData

// session desc has changed
// extract the params from the message, and call idirectplay to handle it
HRESULT SP_HandleSessionDescChanged(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer)
{
	HRESULT hr = DP_OK;
	DWORD dwCmd;
    LPDPSESSIONDESC2 lpsdDesc;

    dwCmd = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pReceiveBuffer);
	
    if (DPSP_MSG_SESSIONDESCCHANGED != dwCmd)
    {
        ASSERT(FALSE);
    }

    // fix up pointers in session desc on buffer to point to the strings 
    // on the buffer
    lpsdDesc = (LPDPSESSIONDESC2)(&((LPMSG_SESSIONDESC)pReceiveBuffer)->dpDesc);

    if (((LPMSG_SESSIONDESC)pReceiveBuffer)->dwSessionNameOffset)
	{
		lpsdDesc->lpszSessionName = (LPWSTR)(pReceiveBuffer + ((LPMSG_SESSIONDESC)pReceiveBuffer)->dwSessionNameOffset);
	}
	else 
	{
		lpsdDesc->lpszSessionName = (LPWSTR)NULL;
	}
	
	if (((LPMSG_SESSIONDESC)pReceiveBuffer)->dwPasswordOffset)
	{
		lpsdDesc->lpszPassword = (LPWSTR)(pReceiveBuffer + ((LPMSG_SESSIONDESC)pReceiveBuffer)->dwPasswordOffset);
	}
	else 
	{
		lpsdDesc->lpszPassword = (LPWSTR)NULL;
	}
		
	// get dplay to set the session desc
	hr = InternalSetSessionDesc((IDirectPlay *)this->pInterfaces,lpsdDesc, 0, FALSE);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}

	return hr;

}  // HandleSessionDescChanged


HRESULT HandleChatMessage(LPDPLAYI_DPLAY this, LPBYTE pReceiveBuffer,
			DWORD dwMessageSize)
{
	LPMSG_CHAT			lpmsg = (LPMSG_CHAT)pReceiveBuffer;
	BOOL				bToGroup = FALSE; // message is to a group	?
	DWORD				dwIDFrom, dwIDTo;
	LPDPLAYI_PLAYER		pPlayer;
	LPDPLAYI_GROUP		pGroup;
	HRESULT				hr;
	

	// make sure it's from a valid player					
	dwIDFrom = lpmsg->dwIDFrom;
	pPlayer = PlayerFromID(this,dwIDFrom);
	if (!VALID_DPLAY_PLAYER(pPlayer)) 
	{
		DPF_ERR("-------received player message FROM invalid player id!!");
		return DPERR_INVALIDPLAYER;
	}

	// see who the message is for
	dwIDTo = lpmsg->dwIDTo;
	pPlayer = PlayerFromID(this,dwIDTo);
	if (!VALID_DPLAY_PLAYER(pPlayer)) 
	{
		// see if it's to a group
		pGroup = GroupFromID(this,dwIDTo);
		if (!VALID_DPLAY_GROUP(pGroup))
		{
			DPF_ERR("got message for bad player / group");
			return DPERR_INVALIDPLAYER;
		}
		bToGroup = TRUE;
		pPlayer = (LPDPLAYI_PLAYER)pGroup;
	}

	if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)	
	{
		// ignore it					
	}
	else 
	{
		if (bToGroup)
		{
			// Send the message to the group
			hr = DistributeGroupMessage(this,(LPDPLAYI_GROUP)pPlayer,pReceiveBuffer,
					dwMessageSize, FALSE, 0);						
		} 
		else 
		{
			// Send the message directly to the player
			hr = HandlePlayerMessage(pPlayer,pReceiveBuffer,dwMessageSize,
					FALSE, 0);
		}
	}

	return hr;

}  // HandleChatMessage


// we got a message w/ no to / from data
// pick the 1st local non-sysplayer off the player list, 
// to deliver it to
LPDPLAYI_PLAYER GetRandomLocalPlayer(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_PLAYER pPlayer;
	BOOL bFound=FALSE;
	
	pPlayer = this->pPlayers;
	
	while (pPlayer && !bFound)
	{
		if ((pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) && 
			!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{
			bFound = TRUE;
			DPF(4,"found local player id = %d to deliver naked message to",pPlayer->dwID);
		}
		else 
		{
			pPlayer = pPlayer->pNextPlayer;
		}
	}
	
	if (!bFound)
	{
		pPlayer = NULL;
		DPF(1,"no local player found to take delivery of naked message");
	}
	
	return pPlayer;		
} // GetRandomLocalPlayer

/*
 ** PutOnPendingList
 *
 *  CALLED BY: DP_SP_HandleMessage
 *
 *  PARAMETERS:
 *		this - pointer to dplay object
 *		dwCommand - message type
 *
 *  DESCRIPTION:
 *		Determines if specified message needs to be put on the pending list.
 *
 *  RETURNS: TRUE if message belongs on the pending list, FALSE otherwise.
 *
 */
BOOL PutOnPendingList(LPDPLAYI_DPLAY this, DWORD dwCommand)
{
      switch (dwCommand) {

        // let addforwardreply through - we might have been denied access
        case DPSP_MSG_ADDFORWARDREPLY:
    	// let DPSP_MSG_ENUMPLAYERSREPLY through - we need this to get out of pending mode...
        case DPSP_MSG_ENUMPLAYERSREPLY:
    	// let packets through also - they may be packetized enumplayersreplys
        case DPSP_MSG_PACKET:
        // let packet data through, if they need to pend they will pend when assembled.
		case DPSP_MSG_PACKET2_DATA:
		// let ACKs through for PACKET2 Data otherwise our send won't complete.
		case DPSP_MSG_PACKET2_ACK:
		//  another version of enumplayersreply
		case DPSP_MSG_SUPERENUMPLAYERSREPLY:
            return FALSE;
			
        // put all other messages on the pending list
        default:
            return TRUE;
        }
}  // PutOnPendingList

#undef DPF_MODNAME
#define DPF_MODNAME	"GetMessageCommand"

/*
 ** GetMessageCommand
 *
 *  CALLED BY: DP_SP_HandleMessage
 *
 *  PARAMETERS:
 *		this - pointer to dplay object
 *		pReceiveBuffer - buffer received off wire
 *		dwMessageSize - size of buffer
 *		pdwCommand - pointer to dwCommand to be filled in by this function
 *      pdwVersion - pointer to dwVersion to be filled in by this function
 *
 *  DESCRIPTION:
 *
 *		Extracts the command and version information from the incoming message
 *
 *
 *  RETURNS: DP_OK, DPERR_INVALIDPARAMS, DPERR_UNSUPPORTED
 *
 */

HRESULT GetMessageCommand(LPDPLAYI_DPLAY this, LPVOID pReceiveBuffer, DWORD dwMessageSize, 
    LPDWORD pdwCommand, LPDWORD pdwVersion)
{
    ASSERT(pdwCommand && pdwVersion);

    // initialize in case we fail
    *pdwCommand = *pdwVersion = 0;

    // extract command
	if ( (dwMessageSize < sizeof(DWORD)) || IS_PLAYER_MESSAGE(pReceiveBuffer))
	{
		*pdwCommand = DPSP_MSG_PLAYERMESSAGE;
	}
	else 
	{
		if (dwMessageSize < sizeof(MSG_SYSMESSAGE))
		{
			DPF(0,"message size too small - %d bytes\n",dwMessageSize);
			return DPERR_INVALIDPARAMS;
		}
		
	    *pdwCommand = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pReceiveBuffer);
		*pdwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReceiveBuffer);
		if (*pdwVersion < 1)
		{
			// version 1 is where we implemented on the wire versioning and extensibility
			// any pre version 1 (EUBETA 1 and prior of dplay3) bits are out of luck
			DPF_ERR("Encountered unsupported version of DirectPlay - not responding");
			return DPERR_UNSUPPORTED;
		}
	}

    return DP_OK;
} // GetMessageCommand

#ifdef DEBUG
void ValidateDplay(LPDPLAYI_DPLAY gpThisList)
{
	LPDPLAYI_PLAYER pPlayer,pPlayerCheck;
	LPDPLAYI_GROUP pGroup,pGroupCheck;
	LPDPLAYI_DPLAY this = gpThisList;
	
	while (this)
	{
		pPlayer = this->pPlayers;
		while (pPlayer)
		{
			pPlayerCheck = PlayerFromID(this,pPlayer->dwID);
			if (!VALID_DPLAY_PLAYER(pPlayerCheck))
			{
				DPF_ERR("found invalid player in player list");
				ASSERT(FALSE);
			}
			pPlayer = pPlayer->pNextPlayer;
		}

		pGroup = this->pGroups;
		while (pGroup)
		{
			pGroupCheck = GroupFromID(this,pGroup->dwID);
			if (!VALID_DPLAY_GROUP(pGroupCheck))
			{
				DPF_ERR("found invalid group in group list");			
				ASSERT(FALSE);
			}
			pGroup = pGroup->pNextGroup;
		}

		this = this->pNextObject;
	} // this

} // ValidateDplay
#endif // DEBUG

#undef DPF_MODNAME
#define DPF_MODNAME	"InternalHandleMessage"


//	a-josbor: a little routine for updating chatter count
VOID UpdateChatterCount(LPDPLAYI_DPLAY this, DPID dwIDFrom)
{
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_PLAYER pSysPlayer;
		
	pPlayer = PlayerFromID(this,dwIDFrom);
	if (VALID_DPLAY_PLAYER(pPlayer) && !(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)) 
	{
		// get the sys player for this player.  It's the only
		//	one who gets pinged
		pSysPlayer = PlayerFromID(this, pPlayer->dwIDSysPlayer);
		if (VALID_DPLAY_PLAYER(pSysPlayer))
		{
			pSysPlayer->dwChatterCount++;
			DPF(9,"++Chatter for Player %d == %d\n", pPlayer->dwIDSysPlayer, pSysPlayer->dwChatterCount);
		}
	}
}
/*
 ** InternalHandleMessage
 *
 *  CALLED BY: DP_SP_HandleMessage and other internal dplay functions.
 *
 *  PARAMETERS:
 *		pISP - direct play int pointer
 *		pReceiveBuffer - buffer received off wire
 *		dwMessageSize - size of buffer
 *		pvSPHeader - sp's message header.  assumed to be this->dwSPHeaderSize bytes.
 *      dwSendFlags - flags that were passed to SP_Send (e.g. DPSEND_ENCRYPTED).  used
 *					by security code to process messages that are delivered locally w/o
 *					needing to route them through the nameserver
 *
 *  DESCRIPTION:
 *
 *		This function routes a message to the appropriate handler.
 *
 *
 *  RETURNS: handler return
 *
 */

HRESULT DPAPI InternalHandleMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader, DWORD dwSendFlags)
{
    HRESULT hr=DP_OK;
    DWORD dwCommand;
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP pGroup;
	DWORD dwIDTo,dwIDFrom; 
	LPDPLAYI_DPLAY this;
	DWORD dwVersion; // version of the message we received
    DPID dpidFrom=0;
	
    ENTER_DPLAY();
	
#ifdef DEBUG	
	// make sure dplay is a happy place
	ValidateDplay(gpObjectList);
#endif // DEBUG
	
	// make sure we don't get hosed by SP
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
	        LEAVE_DPLAY();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		
		// see if dplay is closed?
		if (this->dwFlags & DPLAYI_DPLAY_CLOSED)
		{
            LEAVE_DPLAY();
 			DPF(5,"dplay closed - ignoring messages");
            return DP_OK;
		}

		if (!VALID_STRING_PTR(pReceiveBuffer,dwMessageSize)) 
		{
            LEAVE_DPLAY();
 			DPF_ERR("sp passed invalid buffer!");
            return DPERR_INVALIDPARAMS;
		}

		if ((DPSP_HEADER_LOCALMSG != pvSPHeader) && 
            (pvSPHeader) && (!VALID_STRING_PTR(pvSPHeader,this->dwSPHeaderSize)))
		{
            LEAVE_DPLAY();
 			DPF_ERR("sp passed invalid header!");
            return DPERR_INVALIDPARAMS;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }

    // Get the command and version information from the message
    hr = GetMessageCommand(this, pReceiveBuffer, dwMessageSize, &dwCommand, &dwVersion);
    if (FAILED(hr))
    {
        LEAVE_DPLAY();
        return hr;
    }

    // if it is a secure message
    if ((DPSP_MSG_SIGNED == dwCommand))
    {
        LPMSG_SECURE pSecureMsg = (LPMSG_SECURE)pReceiveBuffer;

        // Verify the secure message:
        // if signed, verify the signature
        // if encrypted, decrypt the message in place
        hr = VerifyMessage(this, pReceiveBuffer, dwMessageSize);
        if (FAILED(hr))
        {
            DPF(0,"Secure message verification failed - dropping message: hr=0x%08x",hr);
            LEAVE_DPLAY();
            return DP_OK;
        }

        // Message was OK
        if (DPSP_MSG_SIGNED == dwCommand) 
        {
            dwSendFlags |= DPSEND_SIGNED;
        }

		if (pSecureMsg->dwFlags & DPSECURE_ENCRYPTEDBYCAPI)
        {
            dwSendFlags |= DPSEND_ENCRYPTED;
        }

        dpidFrom = pSecureMsg->dwIDFrom;

        // point to the embedded message (excluding the sp header)
        pReceiveBuffer = (LPBYTE)pSecureMsg+ pSecureMsg->dwDataOffset + this->dwSPHeaderSize;
        dwMessageSize = pSecureMsg->dwDataSize - this->dwSPHeaderSize;
        // Get the command and version information for this message
        hr = GetMessageCommand(this, pReceiveBuffer, dwMessageSize, &dwCommand, &dwVersion);
        if (FAILED(hr))
        {
            LEAVE_DPLAY();
            return hr;
        }
    }

    // regulate messages, if session is secure
    if (SECURE_SERVER(this))
    {
        if (dwSendFlags & DPSEND_PENDING)
        {
			// message is from the pending queue

			ASSERT(this->dwFlags & DPLAYI_DPLAY_EXECUTINGPENDING);
			// safe to process...
        }
        else
        {
            // message just came off the wire

			// make sure it is ok to process this message
            if ((DPSP_HEADER_LOCALMSG != pvSPHeader) &&
                !(dwSendFlags & (DPSEND_SIGNED|DPSEND_ENCRYPTED)) &&
                !PermitMessage(dwCommand,dwVersion))
            {
                // no
                DPF(1,"ignoring unsigned message dwCommand=%d dwVersion=%d",dwCommand,dwVersion);
                LEAVE_DPLAY();
                return DP_OK;
            }
        }
    }

    // If we are in pending mode (waiting for the nametable or waiting for a guaranteed 
    // send to complete), allow only certain messages to be processed immediately - all 
    // others go on the pending list
	if ((this->dwFlags & DPLAYI_DPLAY_PENDING) && !(dwSendFlags & DPSEND_PENDING))
    {
        if (PutOnPendingList(this, dwCommand))
	    {
	    	if(this->pProtocol){
		    	// Before we pend this command we need to tell the protocol if a player
		    	// has been deleted.  We want to stop any ongoing sends now.
		    	if(dwCommand == DPSP_MSG_DELETEPLAYER){
		    		LPMSG_PLAYERMGMTMESSAGE pmsg=(LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer;
		    		if(PlayerFromID(this,pmsg->dwPlayerID))
		    		{
			    		ProtocolPreNotifyDeletePlayer(this, pmsg->dwPlayerID);
			    	} else {
			    		DPF(1,"pending deleteplayer message for id %x, not valid player\n",pmsg->dwPlayerID);
			    	}
		    	}
	    	}
	    	// Pend the command.
			dwSendFlags |= DPSEND_PENDING;
			DPF(7,"Pushing message [%d] on the pending queue",dwCommand);
		    hr =  PushPendingCommand(this,pReceiveBuffer,dwMessageSize,pvSPHeader,dwSendFlags);
		    LEAVE_DPLAY();
		    return hr;
	    }
    }
	
	// if we reach here pending stuff is done, so clear the flag
	dwSendFlags &= ~DPSEND_PENDING;

	// update the perfdata
	if (this->pPerfData)
	{
		this->pPerfData->nReceiveBPS += dwMessageSize;
		this->pPerfData->nReceivePPS++;
	}
	
	DPF(8,"handler - received command %d, version %d\n",dwCommand,dwVersion);


	// a-josbor: unfortunately, not all messages have a dwFrom field,
	//	so we need to case out all the ones that do, and increment
	//	the chatter count for the sending player.  NOTE! this means
	//	that you should add this call to any new message types that
	//	come along and have a dwFrom field.
    switch (dwCommand)											 
    {
		// these messages should only go to namesrvr
        case DPSP_MSG_ENUMSESSIONS:															
                
                if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & 
                	DPLAYI_PLAYER_NAMESRVR)) 
				{
					DPF(1,"namesrvr - got enumsessions request");
					hr = NS_HandleEnumSessions(this,pvSPHeader,pReceiveBuffer,dwSendFlags);
				}
	                
                break;
        
        case DPSP_MSG_ENUMPLAYER:

                if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & 
                	DPLAYI_PLAYER_NAMESRVR))
				{
					DPF(1,"namesrvr - got enumplayers request from system version %d",dwVersion);
					hr = NS_HandleEnumPlayers(this,pvSPHeader,dpidFrom,dwVersion);
                }

                break;

	   	case DPSP_MSG_REQUESTGROUPID:
        case DPSP_MSG_REQUESTPLAYERID: 
				
				if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & 
					DPLAYI_PLAYER_NAMESRVR))
				{
                    DWORD dwFlags=0;
                    BOOL fCheckPlayerFlags = FALSE;

					DPF(1,"namesrvr - got newplayerid request");

                    // look for flags if version is later than DX3
                    if (DPSP_MSG_DX3VERSION != dwVersion)
                    {
                        dwFlags = ((LPMSG_REQUESTPLAYERID)pReceiveBuffer)->dwFlags;
                        fCheckPlayerFlags = TRUE;
                    }
					hr = NS_HandleRequestPlayerID(this,pvSPHeader,dwCommand, dwFlags, 
                        fCheckPlayerFlags,dwVersion);
				}
				
				break;

		case DPSP_MSG_ADDFORWARDREQUEST:

				if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & 
					DPLAYI_PLAYER_NAMESRVR))
				{
					DPF(1,"namesrvr - got forward add player request");
					hr = NS_HandleAddForwardRequest(this,pReceiveBuffer,dwMessageSize,pvSPHeader,dpidFrom);
				}
				else 
				{
					ASSERT(FALSE); // only namesrvr should get this!
				}
				
				break;

		// handle reply from nameserver
		case DPSP_MSG_ENUMSESSIONSREPLY :

				DPF(1,"got enumsessions reply");
				hr = HandleEnumSessionsReply(this,pReceiveBuffer,pvSPHeader);

				break;

		case DPSP_MSG_SUPERENUMPLAYERSREPLY:				
		case DPSP_MSG_ENUMPLAYERSREPLY:
		case DPSP_MSG_REQUESTPLAYERREPLY: 
        case DPSP_MSG_ADDFORWARDREPLY:

				hr = HandleReply(this, pReceiveBuffer, dwMessageSize, dwCommand, pvSPHeader);
                break;

#ifdef DPLAY_VOICE_SUPPORT

		case DPSP_MSG_VOICEOPEN:
		case DPSP_MSG_VOICECLOSE:
			// a-josbor: update the chatter count
			dwIDFrom = ((LPMSG_PING)pReceiveBuffer)->dwIDFrom;
			UpdateChatterCount(this, dwIDFrom);
			break;
			
#endif // DPLAY_VOICE_SUPPORT		
		

		case DPSP_MSG_PLAYERDATACHANGED: 
		case DPSP_MSG_GROUPDATACHANGED:
		case DPSP_MSG_PLAYERNAMECHANGED:
		case DPSP_MSG_GROUPNAMECHANGED:
		case DPSP_MSG_SESSIONDESCCHANGED:		
		case DPSP_MSG_CREATEPLAYER:
		case DPSP_MSG_DELETEPLAYER:
		case DPSP_MSG_ADDPLAYERTOGROUP:
 		case DPSP_MSG_DELETEPLAYERFROMGROUP:
		case DPSP_MSG_CREATEGROUP:
		case DPSP_MSG_DELETEGROUP:
		case DPSP_MSG_NAMESERVER:
		case DPSP_MSG_ADDSHORTCUTTOGROUP:
		case DPSP_MSG_DELETEGROUPFROMGROUP:

				if (!this->lpsdDesc)
				{
					DPF(4,"received player mgmt message - no session open - ignoring");
					break;
				}
								
				hr =  SP_HandlePlayerMgmt(this->pSysPlayer,pReceiveBuffer,dwMessageSize,pvSPHeader);
				break;

		case DPSP_MSG_PLAYERWRAPPER:

				DPF(2,"got wrapped player message...");
				
				// strip off the wrapper
			   	pReceiveBuffer += sizeof(MSG_SYSMESSAGE);
				dwMessageSize -= sizeof(MSG_SYSMESSAGE);
				// fall through...
				
		case DPSP_MSG_PLAYERMESSAGE:
			{
				BOOL bToGroup = FALSE; // message is to a group	?
				
				if (!this->lpsdDesc)
				{
					DPF_ERR("player - player message thrown away - session closed");
					break;
				}

				
				if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
				{
					// a-josbor: increment our chatter count
					// note, we can only do this if we have a from id
					dwIDFrom = ((LPMSG_PLAYERMESSAGE)pReceiveBuffer)->idFrom;

					// make sure it's from a valid player					
					pPlayer = PlayerFromID(this,dwIDFrom);
			        if (!VALID_DPLAY_PLAYER(pPlayer)) 
			        {
						DPF(0,"----received player message FROM invalid player id = %d!!",dwIDFrom);
						break;
			        }
			        
					UpdateChatterCount(this, dwIDFrom);

					// see who the message is for
					dwIDTo = ((LPMSG_PLAYERMESSAGE)pReceiveBuffer)->idTo;
					pPlayer = PlayerFromID(this,dwIDTo);
			        if (!VALID_DPLAY_PLAYER(pPlayer)) 
			        {
			        	// see if it's to a group
						pGroup = GroupFromID(this,dwIDTo);
						if (!VALID_DPLAY_GROUP(pGroup))
						{
							DPF(0,"----received player message TO invalid id = %d!!",dwIDFrom);
							break;
						}
						bToGroup = TRUE;
						pPlayer = (LPDPLAYI_PLAYER)pGroup;
					}
				}
				else 
				{	// message is raw

					if (dwSendFlags & DPSEND_SIGNED)
					{
						ASSERT(FALSE);
						DPF_ERR("A signed player message arrived raw - dropping message");
						hr = DPERR_UNSUPPORTED;
						break;
					}

					pPlayer = GetRandomLocalPlayer(this);
			        if (!VALID_DPLAY_PLAYER(pPlayer)) 
			        {
						DPF_ERR("could not find local player to deliver naked message to");
						break;
			        }
				}
				if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)	
				{
					// ignore it					
				}
				else 
				{
					if (bToGroup)
					{
						hr = DistributeGroupMessage(this,(LPDPLAYI_GROUP)pPlayer,pReceiveBuffer,
							dwMessageSize,TRUE,dwSendFlags);						
					} 
					else 
					{
						hr = HandlePlayerMessage(pPlayer,pReceiveBuffer,dwMessageSize,
							TRUE,dwSendFlags);
					}
				}
			
			}  // DPSP_MSG_PLAYERMESSAGE:

			break;
				
		case DPSP_MSG_PACKET:

				if (!this->lpsdDesc)
				{
					DPF_ERR("packet thrown away - session closed");
					break;
				}
		
				hr = HandlePacket(this,pReceiveBuffer,dwMessageSize,pvSPHeader);
				DPF(4,"handler - received packet");
				break;

		case DPSP_MSG_PACKET2_DATA:
		case DPSP_MSG_PACKET2_ACK:
				hr = HandlePacket(this,pReceiveBuffer,dwMessageSize,pvSPHeader);
				DPF(4,"handler - received packet");
				break;
	
		case DPSP_MSG_PING:
		case DPSP_MSG_PINGREPLY:
	
				if (!this->lpsdDesc)
				{
					DPF_ERR("ping thrown away - session closed");
					break;
				}

				// a-josbor: update our chatter count
				dwIDFrom = ((LPMSG_PING)pReceiveBuffer)->dwIDFrom;
				UpdateChatterCount(this, dwIDFrom);

				hr = HandlePing(this,pReceiveBuffer,pvSPHeader);
				break;
				
		case DPSP_MSG_YOUAREDEAD:
				
				// as of DX5a, this message is no longer being sent.  there was
				// a race condition that could cause all players in the session 
				// to be disconnected.  
				DPF_ERR("UH OH, SOMEONE IN THE GAME THINKS I'M DEAD");
			
				// BUGBUG: should we do this regardless of whether we think
				// we're the host (consider if the game has become fragmented...)
				if (!IAM_NAMESERVER(this))hr = HandleSessionLost(this);
			
				break;

            // @@@@@@@@@@@@@@@@@@@@@@@@ SECURITY @@@@@@@@@@@@@@@@@@@@@@
            //
            // Client side messages
            //
        case DPSP_MSG_CHALLENGE:
            this->LoginState = DPLOGIN_PROGRESS;
			// this will set the appropriate event so the blocked
			// thread (see dpsecure.c) can process reply
			hr = HandleAuthenticationReply(pReceiveBuffer,dwMessageSize);
			// we just return here, since we dropped the dplay lock 
			// to allow the async reply to be processed
			return hr;
            break;

        case DPSP_MSG_ACCESSGRANTED:
            //
            // Receive server's OK on our authentication request
            //
            this->LoginState = DPLOGIN_ACCESSGRANTED;
			// this will set the appropriate event so the blocked
			// thread (see dpsecure.c) can process reply
			hr = HandleAuthenticationReply(pReceiveBuffer,dwMessageSize);
			// we just return here, since we dropped the dplay lock 
			// to allow the async reply to be processed
			return hr;
            break;

        case DPSP_MSG_LOGONDENIED:
            this->LoginState = DPLOGIN_LOGONDENIED;
			// this will set the appropriate event so the blocked
			// thread (see dpsecure.c) can process reply
			hr = HandleAuthenticationReply(pReceiveBuffer,dwMessageSize);
			// we just return here, since we dropped the dplay lock 
			// to allow the async reply to be processed
			return hr;
            break;

        case DPSP_MSG_AUTHERROR:
            this->LoginState = DPLOGIN_ERROR;
			// this will set the appropriate event so the blocked
			// thread (see dpsecure.c) can process reply
			hr = HandleAuthenticationReply(pReceiveBuffer,dwMessageSize);
			// we just return here, since we dropped the dplay lock 
			// to allow the async reply to be processed 
			return hr;
            break;

		case DPSP_MSG_KEYEXCHANGEREPLY:
            this->LoginState = DPLOGIN_KEYEXCHANGE;
			// this will set the appropriate event so the blocked
			// thread (see dpsecure.c) can process reply
			hr = HandleAuthenticationReply(pReceiveBuffer,dwMessageSize);
			// we just return here, since we dropped the dplay lock 
			// to allow the async reply to be processed
            return hr;
			break;

            //
            // Server side messages
            //
        case DPSP_MSG_NEGOTIATE:
            hr = SendAuthenticationResponse(this, (LPMSG_AUTHENTICATION)pReceiveBuffer, pvSPHeader);
            break;

        case DPSP_MSG_CHALLENGERESPONSE:
            hr = SendAuthenticationResponse (this, (LPMSG_AUTHENTICATION)pReceiveBuffer, pvSPHeader);
            break;

		case DPSP_MSG_KEYEXCHANGE:
			hr = SendKeyExchangeReply(this, (LPMSG_KEYEXCHANGE)pReceiveBuffer, dpidFrom, pvSPHeader);
			break;

        // @@@@@@@@@@@@@@@@@@@@@@@@ END SECURITY @@@@@@@@@@@@@@@@@@@@@@
		
		case DPSP_MSG_ASK4MULTICASTGUARANTEED:
			dwSendFlags |= DPSEND_GUARANTEED;

			// a-josbor: update our chatter count
			dwIDFrom = ((LPMSG_ASK4MULTICAST)pReceiveBuffer)->idPlayerFrom;
			UpdateChatterCount(this, dwIDFrom);

			hr = DoMulticast(this,(LPMSG_ASK4MULTICAST)pReceiveBuffer,dwMessageSize,pvSPHeader,dwSendFlags);
			break;
		
		case DPSP_MSG_ASK4MULTICAST:

			// a-josbor: update our chatter count
			dwIDFrom = ((LPMSG_ASK4MULTICAST)pReceiveBuffer)->idPlayerFrom;
			UpdateChatterCount(this, dwIDFrom);

			hr = DoMulticast(this,(LPMSG_ASK4MULTICAST)pReceiveBuffer,dwMessageSize,pvSPHeader,dwSendFlags);
			break;
			
		case DPSP_MSG_CHAT:

			// a-josbor: update our chatter count
			dwIDFrom = ((LPMSG_CHAT)pReceiveBuffer)->dwIDFrom;
			UpdateChatterCount(this, dwIDFrom);

			hr = HandleChatMessage(this, pReceiveBuffer, dwMessageSize);
			if(FAILED(hr))
			{
				ASSERT(FALSE);
			}
			break;

		case DPSP_MSG_DIEPIGGY:
		
			DPF_ERR("  THIS IS ONE DEAD PIGGY.  CALL ANDYCO x62693 ");
#ifdef DIE_PIG			
			DEBUG_BREAK();
#endif 
			
			break;
			
		case DPSP_MSG_ADDFORWARD:
			if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & 
				DPLAYI_PLAYER_NAMESRVR))
			{
				DPF(1, "Hey! I got an ADDFORWARD, but I'm the NameServer!  Something's wrong...");
			}

			hr = SP_HandleAddForward(this,pReceiveBuffer,pvSPHeader,dpidFrom,dwVersion);
			if(FAILED(hr))
			{
				ASSERT(FALSE);
			}

			break;
			
		case DPSP_MSG_ADDFORWARDACK:
			hr = NS_HandleAddForwardACK(this,(LPMSG_ADDFORWARDACK)pReceiveBuffer);
			if(FAILED(hr))
			{
				ASSERT(FALSE);
			}

			break;

		case DPSP_MSG_IAMNAMESERVER:
			hr = NS_HandleIAmNameServer(this, (LPMSG_IAMNAMESERVER)pReceiveBuffer, pvSPHeader);
			if(FAILED(hr))
			{
				ASSERT(FALSE);
			}

			break;

        default:																   
                DPF(1,"received unrecognized command - %d\n",dwCommand);
                break;
    }
	
    LEAVE_DPLAY();
	// always return DP_OK here, since the sp shouldn't be handling our internal
	// errors
    return DP_OK;

} // InternalHandleMessage


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_HandleMessage"

/*
 ** DP_SP_HandleMessage
 *
 *  CALLED BY: service provider
 *
 *  PARAMETERS:
 *		pISP - direct play int pointer
 *		pReceiveBuffer - buffer received off wire
 *		dwMessageSize - size of buffer
 *		pvSPHeader - sp's message header.  assumed to be this->dwSPHeaderSize bytes.
 *
 *  DESCRIPTION:
 *
 *		when an sp receives a message, it calls this fn. this is where dplay receives data.
 *
 *
 *  RETURNS: return code from InternalHandleMessage.
 *
 */

HRESULT DPAPI DP_SP_HandleMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;

    ENTER_DPLAY();
	
	// make sure we don't get hosed by SP
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
	        LEAVE_DPLAY();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }

	// if we're closing, don't handle any messages.  Fail silently
	if (this->dwFlags & DPLAYI_DPLAY_CLOSED)
	{
		DPF(8,"In HandleMessage after call to Close.  Ignoring...");
		LEAVE_DPLAY();
		return DP_OK;
	}
		
	if(this->pProtocol){
		LEAVE_DPLAY();
		// Protocol might want this, check, returns DPERR_NOTHANDLED if not wanted.
		hr=DP_SP_ProtocolHandleMessage(pISP, pReceiveBuffer, dwMessageSize, pvSPHeader);
	} else {
		// no protocol, force InternalHandleMessage.
		hr=DPERR_NOTHANDLED;
		LEAVE_DPLAY();
	}

	if(hr==DPERR_NOTHANDLED){
		// Protocol didn't consume the receive, tell regular handler.
		hr=InternalHandleMessage(pISP, pReceiveBuffer, dwMessageSize, pvSPHeader, 0);
	}
	
	return hr;

} // DP_SP_HandleMessage

/*
 ** DP_SP_HandleNonProtocolMessage
 *
 *  CALLED BY: service provider
 *
 *  PARAMETERS:
 *		pISP - direct play int pointer
 *		pReceiveBuffer - buffer received off wire
 *		dwMessageSize - size of buffer
 *		pvSPHeader - sp's message header.  assumed to be this->dwSPHeaderSize bytes.
 *
 *  DESCRIPTION:
 *
 *		We are sending a message to ourselves, so don't let the protocol crack it.
 *
 *
 *  RETURNS: return code from InternalHandleMessage.
 *
 */

HRESULT DPAPI DP_SP_HandleNonProtocolMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader)
{
	return InternalHandleMessage(pISP, pReceiveBuffer, dwMessageSize, pvSPHeader, 0);

} // DP_SP_HandleNonProtocolMessage

//BUGBUG: speed up with a last pointer, and use in all paths...
VOID QueueMessageNodeOnReceiveList(LPDPLAYI_DPLAY this, LPMESSAGENODE pmsn, LPDPLAYI_PLAYER pPlayer)
{
	this->nMessages++;

	pmsn->pNextMessage=NULL;

	// find last node on list, and stick pmsn behind it

	if(this->pLastMessage){
		this->pLastMessage->pNextMessage=pmsn;
		this->pLastMessage=pmsn;
	} else {
		this->pMessageList = pmsn;
		this->pLastMessage = pmsn;
	}
	
	// if player has event, trigger it-- BUGBUG:need refcount on player!
	if (pPlayer->hEvent) 
	{
		DPF(9,"triggering player event");
		SetEvent(pPlayer->hEvent);		
	}
}

VOID QueueSendCompletion(LPDPLAYI_DPLAY this, PSENDPARMS psp)
{

	psp->msn.pMessage = (LPVOID)&psp->dwType;
	psp->msn.dwMessageSize = sizeof(DPMSG_SENDCOMPLETE);
	psp->msn.idFrom = DPID_SYSMSG;
	psp->msn.idTo = psp->idFrom;
	psp->dwType=DPSYS_SENDCOMPLETE;
	QueueMessageNodeOnReceiveList(this, &psp->msn, psp->pPlayerFrom);
}

/*
 ** DP_SP_SendComplete
 *
 *  CALLED BY: service provider
 *
 *  PARAMETERS:
 *		pISP             - direct play int pointer
 *      lpDPContext      - context we gave for the send
 *      CompletionStatus - status of the send
 *
 *  DESCRIPTION:
 *
 *		When an asynchronous message is completely sent, the SP calls us back to notify us.
 *
 *
 *  RETURNS: none.
 *
 */

VOID DPAPI DP_SP_SendComplete(IDirectPlaySP * pISP, LPVOID lpDPContext, HRESULT CompletionStatus)
{
	PSENDPARMS psp;

	LPDPLAYI_DPLAY this;

    ENTER_DPLAY();

	this = DPLAY_FROM_INT(pISP);

	psp=pspFromContext(this, lpDPContext,FALSE); 	
									//		|
									// Completion has a refcount, don't need another.

	ASSERT(psp);

	if(psp) {

		EnterCriticalSection(&psp->cs);
		
		psp->nComplete++;
		
		// Status set to DP_OK in Send call, if we get a different status, update it.
		// Note, the last non-ok status is the one returned.
		// Group sends are always ok unless out of memory!
		if((CompletionStatus != DP_OK) && ((!psp->pGroupTo)||(psp->pGroupTo && CompletionStatus==DPERR_NOMEMORY)) ){
			psp->hr=CompletionStatus;
		}
		
		LeaveCriticalSection(&psp->cs);
		
		pspDecRef(this, psp); // if ref hits zero, posts completion to application.

	} else {
		DPF(0,"ERROR:completion of already reassigned context?\n");
		ASSERT(0);
	}
	
	LEAVE_DPLAY();
	
	return;
} // DP_SP_HandleMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplaysvr\dplaysvr.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplaysvr.c
 *  Content: 	dplay winsock shared .exe - allows multiple apps to share
 *				a single winsock port
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/10/97		andyco	created it from ddhelp
 *	 29-jan-98	sohailm	added support for stream enum sessions
 *
 ***************************************************************************/

#ifdef WINNT
    #ifdef DBG
        #undef DEBUG
        #define DEBUG
    #endif
#endif

#include <windows.h>
#include "dplaysvr.h"
#include "newdpf.h"
#include "memalloc.h"
#include "dphelp.h"

HANDLE 				hInstApp;
BOOL		   		bNoCallbacks;
CRITICAL_SECTION    gcsCritSection;	// the crit section we take in winmain
                                	// this is a global so dphelp can take it before
                                	// forwarding enum requests that come in on its
                                	// receive thread (manbugs 3907)
int					gnCSCount;		// dplaysvr lock count

/*
 * Externs
 */
extern RECEIVELIST 	gReceiveList;
extern FDS			gReadfds;


// we watch every dplay process so when it exits we
// make sure it cleaned up...
typedef struct _PROCESSDATA
{
    struct _PROCESSDATA		*link;
    DWORD			pid;
} PROCESSDATA, *LPPROCESSDATA;

LPPROCESSDATA		lpProcessList; 	// list of all processes that are registered
									// with us

/*
 * ThreadProc
 *
 * Open a process and wait for it to terminate
 */
DWORD WINAPI ThreadProc( LPVOID *pdata )
{
    HANDLE		hproc;
    DWORD		rc;
    LPPROCESSDATA	ppd;
    LPPROCESSDATA	curr;
    LPPROCESSDATA	prev;
    PROCESSDATA		pd;
	DPHELPDATA		hd;
	
    ppd = (LPPROCESSDATA) pdata;

    /*
     * get a handle to the process that attached to DDRAW
     */
    DPF( 2, "Watchdog thread started for pid %08lx", ppd->pid );

    hproc = OpenProcess( PROCESS_QUERY_INFORMATION | SYNCHRONIZE,
                            FALSE, ppd->pid );
    if( hproc == NULL )
    {
        DPF( 1, "OpenProcess for %08lx failed!", ppd->pid );
        ExitThread( 0 );
    }

    /*
     * wait for process to die
     */
    rc = WaitForSingleObject( hproc, INFINITE );
    if( rc == WAIT_FAILED )
    {
        DPF( 1, "Wait for process %08lx failed", ppd->pid );
        CloseHandle( hproc );
        ExitThread( 0 );
    }

    /*
     * remove process from the list of watched processes
     */
    ENTER_DPLAYSVR();
    pd = *ppd;
    curr = lpProcessList;
    prev = NULL;
    while( curr != NULL )
    {
        if( curr == ppd )
        {
            if( prev == NULL )
            {
                lpProcessList = curr->link;
            }
            else
            {
                prev->link = curr->link;
            }
            DPF( 2, "PID %08lx removed from list", ppd->pid );
            MemFree( curr );
            break;
        }
        prev = curr;
        curr = curr->link;
    }

    if( bNoCallbacks )
    {
		DPF( 1, "No callbacks allowed: leaving thread early" );
		LEAVE_DPLAYSVR();
		CloseHandle( hproc );
		ExitThread( 0 );
    }


	// clean up!

	memset(&hd,0,sizeof(hd));
	hd.pid = pd.pid;
	DPlayHelp_DeleteServer(&hd,TRUE);
	
    LEAVE_DPLAYSVR();
    CloseHandle( hproc );

    ExitThread( 0 );
	
	return 0;

} /* ThreadProc */

/*
 * MainWndProc
 */
LONG_PTR __stdcall MainWndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    switch(message)
    {
        case WM_ENDSESSION:
            /*
             * shoot ourselves in the head
             */
            if( lParam == FALSE )
            {
                DPF( 3, "WM_ENDSESSION" );
                ENTER_DPLAYSVR();
                DPF( 1, "Setting NO CALLBACKS" );
                bNoCallbacks = TRUE;
                LEAVE_DPLAYSVR();
            }
            else
            {
                DPF( 3, "User logging off" );
            }

            break;

    }

    return DefWindowProc(hWnd, message, wParam, lParam);
} /* MainWndProc */

/*
 * WindowThreadProc
 */
void WindowThreadProc( LPVOID pdata )
{
    static char szClassName[] = "DPlayHelpWndClass";
    WNDCLASS 	cls;
    MSG		msg;
    HWND	hwnd;

    /*
     * build class and create window
     */
    cls.lpszClassName  = szClassName;
    cls.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
    cls.hInstance      = hInstApp;
    cls.hIcon          = NULL;
    cls.hCursor        = NULL;
    cls.lpszMenuName   = NULL;
    cls.style          = 0;
    cls.lpfnWndProc    = (WNDPROC)MainWndProc;
    cls.cbWndExtra     = 0;
    cls.cbClsExtra     = 0;

    if( !RegisterClass( &cls ) )
    {
        DPF( 1, "RegisterClass FAILED!" );
        ExitThread( 0 );
    }

    hwnd = CreateWindow( szClassName, szClassName,
            WS_POPUP, 0, 0, 0, 0, NULL, NULL, hInstApp, NULL);

    if( hwnd == NULL )
    {
        DPF( 1, "No monitor window!" );
        ExitThread( 0 );
    }

    /*
     * pump the messages
     */
    while( GetMessage( &msg, NULL, 0, 0 ) )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }
    DPF( 1, "Exiting WindowThreadProc" );
    ExitThread( 1 );

} /* WindowThreadProc */

//
// called by by DPlayHelp_AddServer when we get a new process attached.
// we wait for the process to go away, and then make sure it cleaned
// all its registered servers up.
//
void WatchNewPid(LPDPHELPDATA phd)
{
    LPPROCESSDATA	ppd;
    BOOL		found;
    DWORD		tid;

    DPF( 1, "watching new pid" );

    ENTER_DPLAYSVR();
	
    ppd = lpProcessList;
    found = FALSE;
    while( ppd != NULL )
    {
        if( ppd->pid == phd->pid )
        {
            DPF( 2, "Have thread for process %08lx already", phd->pid );
			found = TRUE;
            break;
        }
        ppd = ppd->link;
    }

    /*
     * couldn't find anyone waiting on this process, so create
     * a brand spanking new thread
     */
    if( !found )
    {
        DPF( 2, "Allocating new thread for process %08lx",phd->pid );
        ppd = MemAlloc( sizeof( PROCESSDATA ) );
        if( ppd != NULL )
        {
            HANDLE	h;

            ppd->link = lpProcessList;
            lpProcessList = ppd;
            ppd->pid = phd->pid;
            h = CreateThread(NULL,
                         0,
                         (LPTHREAD_START_ROUTINE) ThreadProc,
                         (LPVOID)ppd,
                         0,
                         (LPDWORD)&tid);
            if( h != NULL )
            {
                DPF( 2, "Thread %08lx created",tid);
                CloseHandle( h );
            }
            else
            {
                #ifdef DEBUG
                    DPF( 0, "COULD NOT CREATE HELPER THREAD FOR PID %08lx", phd->pid );
                    DebugBreak(); //_asm int 3;
                #endif
            }
        }
        else
        {
            #ifdef DEBUG
                DPF( 0, "OUT OF MEMORY CREATING HELPER THREAD FOR PID %08lx", phd->pid );
                DebugBreak(); //_asm int 3;
            #endif
        }
    }
    LEAVE_DPLAYSVR();
	
} // WatchNewPid

typedef DWORD (WINAPI *PFNREGISTERSERVICE)(DWORD,DWORD);
// nt's winbase.h doesn't have these constants - we need them
// so we can compile.  taken from \proj\dev\inc\winbase.h
#ifndef RSP_UNREGISTER_SERVICE
#define RSP_UNREGISTER_SERVICE  0x00000000
#endif
#ifndef RSP_SIMPLE_SERVICE
#define RSP_SIMPLE_SERVICE      0x00000001
#endif

// on Win95, we want to call RegisterServiceProcess
// but, it's not available on NT, so we can't import it directly
// here we try to find it dynamically in kernel32.  if we find it,
// we call it, otherwise we assume we're on NT and it's not avaible
void MakeMeService()
{
	HANDLE hLib;
	PFNREGISTERSERVICE pfnRegisterServiceProcess;
	
    hLib = LoadLibrary("kernel32.dll");
	if (!hLib)
	{
		// wacky!
		DPF(1,"could not load library kernel32 to register service proc");
		return;
	}
	
	pfnRegisterServiceProcess = (PFNREGISTERSERVICE)GetProcAddress(hLib,"RegisterServiceProcess");
	if (!pfnRegisterServiceProcess)
	{
		// this is expected on NT
		DPF(3,"could not register service process - expected on NT");
		FreeLibrary(hLib);
		return ;
	}
	
    pfnRegisterServiceProcess( 0, RSP_SIMPLE_SERVICE );
	FreeLibrary(hLib);
	
	return ;
} // MakeMeService	

// on Win95, we want to call RegisterServiceProcess to Unregister
// (see MakeMeService)
void StopServiceProcess()
{
	HANDLE hLib;
	PFNREGISTERSERVICE pfnRegisterServiceProcess;
	
    hLib = LoadLibrary("kernel32.dll");
	if (!hLib)
	{
		// wacky!
		DPF(1,"could not load library kernel32 to register service proc");
		return;
	}
	
	pfnRegisterServiceProcess = (PFNREGISTERSERVICE)GetProcAddress(hLib,"RegisterServiceProcess");
	if (!pfnRegisterServiceProcess)
	{
		// this is expected on NT
		DPF(3,"could not unregister service process - not avail - not tragic");
		FreeLibrary(hLib);
		return ;
	}
	
	// unregistered!
    pfnRegisterServiceProcess( 0, RSP_UNREGISTER_SERVICE );
	FreeLibrary(hLib);
	
	return ;

} // StopServiceProcess

/*
 * WinMain
 */
int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
                        LPSTR lpCmdLine, int nCmdShow)
{
    DWORD		tid;
    DWORD		rc;
    HANDLE		hstartevent;
    HANDLE		hstartupevent;
    HANDLE		hmutex;
    HANDLE		hackevent;
    LPDPHELPDATA	phd;
    HANDLE		hsharedmem;
    HANDLE		h;
    char		szSystemDir[1024];

    /*
     * Set our working directory to the system directory.
     * This prevents us from holding network connections open
     * forever if the first DirectDraw app that we run is across
     * a network connection.
     */
    GetSystemDirectory(szSystemDir, sizeof(szSystemDir));
    SetCurrentDirectory(szSystemDir);

	// try to register ourselves as a service so user can't see us
	// in task list
	MakeMeService();

#if 0	

// andyco - not sure if we need this...

    /*
     * We must guarantee that DPHELP unloads after the last ddraw app,
     * since ctrl-alt-del may have happened while an app held the ddraw
     * lock, and DPHELP needs to clean up orphaned cheap ddraw mutex
     * locks.
     */
    if ( ! SetProcessShutdownParameters(0x100,SHUTDOWN_NORETRY) )
    {
        DPF(0,"dplaysvr could not set itself to shutdown last!");
    }

#endif


    hInstApp = hInstance;

    /*
     * create startup event
     */
    hstartupevent = CreateEvent( NULL, TRUE, FALSE, DPHELP_STARTUP_EVENT_NAME );

    DPFINIT();
    DPF( 2, "*** dplaysvr STARTED, PID=%08lx ***", GetCurrentProcessId() );

    if( !MemInit() )
    {
        DPF( 1, "Could not init memory manager" );
        return 0;
    }

    /*
     * create shared memory area
     */
    hsharedmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
    		PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
            DPHELP_SHARED_NAME );
    if( hsharedmem == NULL )
    {
        DPF( 1, "Could not create file mapping!" );
        return 0;
    }

    /*
     * create mutex for people who want to use the shared memory area
     */
    hmutex = CreateMutex( NULL, FALSE, DPHELP_MUTEX_NAME );
    if( hmutex == NULL )
    {
        DPF( 1, "Could not create mutex " DPHELP_MUTEX_NAME );
        CloseHandle( hsharedmem );
        return 0;
    }

    /*
     * create events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_EVENT_NAME );
    if( hstartevent == NULL )
    {
        DPF( 1, "Could not create event " DPHELP_EVENT_NAME );
        CloseHandle( hmutex );
        CloseHandle( hsharedmem );
        return 0;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_ACK_EVENT_NAME );
    if( hackevent == NULL )
    {
        DPF( 1, "Could not create event " DPHELP_ACK_EVENT_NAME );
        CloseHandle( hmutex );
        CloseHandle( hsharedmem );
        CloseHandle( hstartevent );
        return 0;
    }

    /*
     * Create window so we can get messages
     */
    h = CreateThread(NULL,
                 0,
                 (LPTHREAD_START_ROUTINE) WindowThreadProc,
                 NULL,
                 0,
                 (LPDWORD)&tid );
    if( h == NULL )
    {
        DPF( 1, "Create of WindowThreadProc FAILED!" );
        CloseHandle( hackevent );
        CloseHandle( hmutex );
        CloseHandle( hsharedmem );
        CloseHandle( hstartevent );
        return 0;
    }
    CloseHandle( h );

    /*
     * serialize access to us
     */
    INIT_DPLAYSVR_CSECT();

    /*
     * let invoker and anyone else who comes along know we exist
     */
    SetEvent( hstartupevent );

    /*
     * loop forever, processing requests
     */
    while( 1 )
    {
        /*
         * wait to be notified of a request
         */
        DPF( 1, "Waiting for next request" );
        rc = WaitForSingleObject( hstartevent, INFINITE );
        if( rc == WAIT_FAILED )
        {
            DPF( 1, "Wait FAILED!!!" );
            continue;
        }

        ENTER_DPLAYSVR();
        phd = (LPDPHELPDATA) MapViewOfFile( hsharedmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
        if( phd == NULL )
        {
            DPF( 1, "Could not create view of file!" );
            LEAVE_DPLAYSVR();
            continue;
        }

        /*
         * find out what we need to do
         */
        switch( phd->req )
        {
        case DPHELPREQ_SUICIDE:
            DPF( 1, "DPHELPREQ_SUICIDE" );

			DPlayHelp_FreeServerList();
			
            SetEvent( hackevent );
            CloseHandle( hmutex );
            UnmapViewOfFile( phd );
            CloseHandle( hsharedmem );
            CloseHandle( hstartevent );
            if (gReceiveList.pConnection)
            {
            	MemFree(gReceiveList.pConnection);
            }
            if (gReadfds.pfdbigset)
            {
            	MemFree(gReadfds.pfdbigset);
            }
            FINI_DPLAYSVR_CSECT();

            #ifdef DEBUG
            	MemState();
            #endif
            DPF( 3, "Good Night Gracie" );
            TerminateProcess( GetCurrentProcess(), 0 );
            break;

		case DPHELPREQ_RETURNHELPERPID:

		    DPF( 2, "DDHELPREQ_RETURNHELPERPID" );
		    phd->pid = GetCurrentProcessId();
	    	break;
			

        case DPHELPREQ_DPLAYADDSERVER:

		    DPF( 2, "DPHELPREQ_DPLAYADDSERVER" );
            phd->hr = DPlayHelp_AddServer(phd);
            break;

        case DPHELPREQ_DPLAYDELETESERVER:

		    DPF( 2, "DPHELPREQ_DPLAYDELETESERVER" );
            DPlayHelp_DeleteServer(phd,FALSE);
            break;

        default:
            DPF( 1, "helper - Unknown Request???" );
            break;
        }

        /*
         * let caller know we've got the news
         */
        UnmapViewOfFile( phd );
        SetEvent( hackevent );
        LEAVE_DPLAYSVR();
    }
	
	StopServiceProcess();

} /* WinMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplaysvr\dplaysvr.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplaysvr.h
 *  Content: 	dplay winsock shared .exe - allows multiple apps to share 
 *				a single winsock port
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/10/97		andyco	created it from ddhelp 
 *	1/29/98		sohailm	added macros for critical section
 *
 ***************************************************************************/
#ifndef __DPLAYSVR_INCLUDED__
#define __DPLAYSVR_INCLUDED__

// need this for hresult
#include "ole2.h"

// crit section
extern CRITICAL_SECTION gcsCritSection;	// defined in dphelp.c
#define INIT_DPLAYSVR_CSECT() InitializeCriticalSection(&gcsCritSection);
#define FINI_DPLAYSVR_CSECT() DeleteCriticalSection(&gcsCritSection);

#ifdef DEBUG
extern int gnCSCount; // count of dplaysvr lock
#define ENTER_DPLAYSVR() EnterCriticalSection(&gcsCritSection),gnCSCount++;
#define LEAVE_DPLAYSVR() gnCSCount--;ASSERT(gnCSCount>=0);LeaveCriticalSection(&gcsCritSection);
#else 
#define ENTER_DPLAYSVR() EnterCriticalSection(&gcsCritSection);
#define LEAVE_DPLAYSVR() LeaveCriticalSection(&gcsCritSection);
#endif

/*
 * named objects
 */
#define DPHELP_EVENT_NAME			"__DPHelpEvent__"
#define DPHELP_ACK_EVENT_NAME		"__DPHelpAckEvent__"
#define DPHELP_STARTUP_EVENT_NAME	"__DPHelpStartupEvent__"
#define DPHELP_SHARED_NAME			"__DPHelpShared__"
#define DPHELP_MUTEX_NAME			"__DPHelpMutex__"

/*
 * requests 
 */
#define DPHELPREQ_SUICIDE			1
#define DPHELPREQ_DPLAYADDSERVER	2
#define DPHELPREQ_DPLAYDELETESERVER	3
#define DPHELPREQ_RETURNHELPERPID 	4

/*
 * communication data
 */
typedef struct DPHELPDATA
{
    int			req;
    DWORD		pid;
	USHORT		port;
    HRESULT		hr;
} DPHELPDATA, *LPDPHELPDATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplaysvr\dphelp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dphelp.c
 *  Content:    allows the dplay winsock sp's to all share a single
 *      	server socket
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   18-jul-96  andyco  initial implementation
 *   25-jul-96	andyco	ddhelp now watches dplay procs so it can remove
 *						them from our list when they go away
 *   3-sep-96	andyco	don't get stale ip's - pick up a default ip whenever
 *						we add a servernode. bug 3716.
 *   2-oct-96	andyco	propagated from \orange\ddhelp.2 to \mustard\ddhelp
 *   3-oct-96	andyco	made the winmain crit section "cs" a global so we can take
 *						it in dphelps receive thread before forwarding requests
 *   21-jan-97	kipo	use LoadLibrary on "wsock32.dll" instead of statically
 *						linking to it so DDHELP will still run even when Winsock
 *						is not around. This lets DDRAW and DSOUND work. Fixes
 *						bug #68596.
 *	 15-feb-97	andyco	moved from ddhelp to the project formerly known as
 *						ddhelp (playhelp? dplayhlp? dplay.exe? dphost?)  Allowed
 *						one process to host mulitple sessions
 *	 29-jan-98	sohailm	added support for stream enum sessions
 *
 ***************************************************************************/
/*============================================================================
*                                                                             
*  Why this file exists :                                                     
*                                                                             
*   when you want to find a dplay game, you send a message to a well      
*   known port (an enumrequest).                                          
*                                                                             
*   if a game is being hosted on that system, it will listen on that      
*   port, and respond to the message.                                     
*                                                                             
*   BUT, only one process can listen on a given socket.                  
*                                                                             
*   So, we let ddhelp.exe listen on that socket, and forward enumrequests 
*   to all games registered as being hosted on this system.
*	
*   see also : \%MANROOT%\dplay\wsock\dpsp.h
*                                                                             
*****************************************************************************/

// todo - should we return error codes on AddServer xproc to our caller?

#include "dphelp.h"

#undef DPF_MODNAME
#define DPF_MODNAME "DPHELP"

/*
 *  GLOBALS
 */ 
SOCKET gsDatagramListener = INVALID_SOCKET; // we listen for datagrams on this socket
SOCKET gsForwardSocket = INVALID_SOCKET;
SOCKET gsStreamListener;					// we listen for tcp connections on this socket
LPSPNODE gNodeList;
BOOL gbInit;
HANDLE ghDatagramReceiveThread,ghStreamReceiveThread;
BOOL gbReceiveShutdown;						// receive thread will exit when TRUE

// pointers to Winsock routines returned from GetProcAddress
cb_accept			g_accept;
cb_bind				g_bind;
cb_closesocket		g_closesocket;
cb_gethostbyname	g_gethostbyname;
cb_gethostname		g_gethostname;
cb_getpeername		g_getpeername;
cb_getsockname		g_getsockname;
cb_inet_ntoa		g_inet_ntoa;
cb_recvfrom			g_recvfrom;
cb_recv				g_recv;
cb_select			g_select;
cb_send				g_send;
cb_sendto			g_sendto;
cb_setsockopt		g_setsockopt;
cb_shutdown			g_shutdown;
cb_socket			g_socket;
cb_WSAFDIsSet		g_WSAFDIsSet;
cb_WSAGetLastError	g_WSAGetLastError;
cb_WSAStartup		g_WSAStartup;
cb_listen			g_listen;
cb_htons			g_htons;

#ifdef DEBUG

#undef DPF_MODNAME
#define DPF_MODNAME	"DebugPrintAddr"

// helper function called from DEBUGPRINTADDR macro
void DebugPrintAddr(UINT nLevel,LPSTR pStr,SOCKADDR * psockaddr)
{
    SOCKADDR_IN * pin = (SOCKADDR_IN *)psockaddr;

     DPF(nLevel,"%s af = AF_INET : address =  %s : port = %d\n",pStr,
     	g_inet_ntoa(pin->sin_addr),g_htons(pin->sin_port));

} // DebugPrintAddr

#undef DPF_MODNAME
#define DPF_MODNAME	"DebugPrintSocket"

void DebugPrintSocket(UINT level,LPSTR pStr,SOCKET * pSock) 
{
	SOCKADDR sockaddr;
	int addrlen=sizeof(sockaddr);

	g_getsockname(*pSock,&sockaddr,&addrlen);
	DEBUGPRINTADDR(level,pStr,&sockaddr);
	
}

#endif // debug

// this is called every time we add a new server node to our list...
HRESULT GetDefaultHostAddr(DWORD * puHostAddr)
{

//	a-josbor: we used to get the first interface and use that, but WebTV taught
//		us that that can be dangerous.  So we just use the loopback address.
//		It's guaranteed to be there.  Or so they say...

    *puHostAddr = 0x0100007f;	// loopback	127.0.0.1 (<bleeping> little-endian)
	
    return DP_OK;
	
} // GetDefaultHostAddr

// the functions DPlayHelp_xxx are called from dphelp.c

//
// add a new node to our list of servers which want to have enum 
// requests forwarded to them...
HRESULT DPlayHelp_AddServer(LPDPHELPDATA phd)
{
    LPSPNODE pNode;
    BOOL bFoundIt=FALSE;
    HRESULT hr;
	
    if (!gbInit) 
    {
		hr = DPlayHelp_Init();
		if (FAILED(hr))
		{
			DPF_ERR("dphelp : could not init wsock ! not adding server");
			return (hr);
		}
    }

    // see if we're already watching this process
	// if we are, we won't start a watcher thread (below)
    pNode = gNodeList;

    // search the list 
    while (pNode && !bFoundIt)
    {
		if (pNode->pid == phd->pid) bFoundIt = TRUE;
		pNode = pNode->pNextNode;
    }

	//
	// now, build a new server node
    pNode = MemAlloc(sizeof(SPNODE));
    if (!pNode)
    {
        DPF_ERR("could not add new server node OUT OF MEMORY");
        return (DPERR_OUTOFMEMORY);
    }
    
    pNode->pid = phd->pid;
    // build the sockaddr
    // dwReserved1 of the phd is the port that the server is listening on
    pNode->sockaddr.sin_family =  AF_INET;
    
    // find the default ip to use w/ this host
    hr = GetDefaultHostAddr(&(pNode->sockaddr.sin_addr.s_addr));
	if (FAILED(hr))
    {
        DPF_ERR("could not get host IP address");
		MemFree(pNode);
        return (DPERR_UNAVAILABLE);
    }
    
    pNode->sockaddr.sin_port = phd->port;

    DPF(5,"dphelp :: adding new server node : pid = %d, port = %d\n",phd->pid,g_htons(phd->port));

    // link our new node onto the beginning of the list
    pNode->pNextNode = gNodeList;
    gNodeList = pNode;

	// see if we need to start our watcher thread    
    if (!bFoundIt)
    {
		//
	    // set up a thread to keep on eye on this process.
	    // we'll let the thread notify us when the process goes away
	    WatchNewPid(phd);
    }

    return (DP_OK);

} // DPlayHelp_AddServer

//
// delete the server node from proc pid from our list
// called by "ThreadProc" from DPHELP.c when the process that
// goes away, or from the client side when a session goes away.
//
// if bFreeAll is TRUE, we delete all server nodes for process
// phd->pid.  otherwise, we just delete the first server node whose
// port matches phd->port
//
BOOL FAR PASCAL DPlayHelp_DeleteServer(LPDPHELPDATA phd,BOOL bFreeAll)
{
    BOOL bFoundIt = FALSE;
    LPSPNODE pNode,pNodePrev,pNodeNext;

    pNode = gNodeList;
    pNodePrev = NULL;
	pNodeNext = NULL;
	
    // search the whole list
    while (pNode && !bFoundIt)
    {
		// if we have the right pid, and it's either FreeAll or the right port - cruise it!
		if ((pNode->pid == phd->pid) &&  (bFreeAll || (pNode->sockaddr.sin_port == phd->port)) )
		{
		    // remove it from the list
		    if (pNodePrev) pNodePrev->pNextNode = pNode->pNextNode;
		    else gNodeList = pNode->pNextNode;
			
		    if (bFreeAll) 
		    {
				// pick up the next one b4 we free pNode
				pNodeNext = pNode->pNextNode;
		    }
			else 
			{
				// mark us as done
				bFoundIt = TRUE;
				pNodeNext = NULL;
			}

		    DPF(5,"dphelp :: deleting server node : pid = %d\n",pNode->pid);
		    // free up the node
		    MemFree(pNode);

			pNode = pNodeNext;
			// pNodePrev doesn't change here...
		}
		else 
		{
		    // just get the next one
		    pNodePrev = pNode;
		    pNode = pNode->pNextNode;
		}
    }


    return FALSE;

} // DPlayHelp_DeleteServer 

//
// poke an ip addr into a message blob 
// code stolen from \orange\dplay\wsock\winsock.c
void IP_SetAddr(LPVOID pmsg,SOCKADDR_IN * paddrSrc)
{
    LPSOCKADDR_IN  paddrDest; // tempo variable, makes casting less ugly
    LPMESSAGEHEADER phead;

    phead = (LPMESSAGEHEADER)pmsg;

    paddrDest = (SOCKADDR_IN *)&(phead->sockaddr);
    // poke the new ip addr into the message header
    paddrDest->sin_addr.s_addr = paddrSrc->sin_addr.s_addr;

    return;
	
} // IP_SetAddr

//
// we get a message.  presumably its an enumrequest. forward it to all registered clients.
// we "home" the message (store the received ip addr w/ it) here, 'cause otherwise the clients
// would all think it came from us.  we change the token to srvr_token so the clients know it
// came from us (so they don't home it again)
void HandleIncomingMessage(LPBYTE pBuffer,DWORD dwBufferSize,SOCKADDR_IN * psockaddr)
{
    LPSPNODE pNode = gNodeList;
    UINT addrlen = sizeof(SOCKADDR_IN);
    UINT err;
	
    ASSERT(VALID_SP_MESSAGE(pBuffer));

    // reset the old token
    *( (DWORD *)pBuffer) &= ~TOKEN_MASK;
    // set the new token
    *( (DWORD *)pBuffer) |= HELPER_TOKEN;

    // home it
    IP_SetAddr((LPVOID)pBuffer,psockaddr);
    
    // now, forward the message to all registered servers
    while (pNode)
    {
		DEBUGPRINTADDR(7,"dplay helper  :: forwarding enum request to",(SOCKADDR *)&(pNode->sockaddr));
		// send out the enum message
        err = g_sendto(gsForwardSocket,pBuffer,dwBufferSize,0,(LPSOCKADDR)&(pNode->sockaddr),
    		addrlen);
        if (SOCKET_ERROR == err) 
        {
    	    err = g_WSAGetLastError();
	    	DPF(0,"dphelp : send failed err = %d\n",err);
        }

        pNode = pNode->pNextNode;
    }

    return ;

} // HandleIncomingMessage

//
// BUF_SIZE is our initial guess at a receive buffer size
// if we get an enum request bigger than this, we'll realloc our
// buffer, and receive successfully if they send again
// (the only way this could happen is if they have password > ~ 1000
// bytes).
#define BUF_SIZE 1024

//
// listen on our socket for enum requests
DWORD WINAPI ListenThreadProc(LPVOID pvUnused)
{
    UINT err;
    LPBYTE pBuffer=NULL;
    INT addrlen=sizeof(SOCKADDR);
    SOCKADDR sockaddr; // the from address
    DWORD dwBufSize = BUF_SIZE;

    DPF(2,"dphelp :: starting udp listen thread ");

    pBuffer = MemAlloc(BUF_SIZE);
    if (!pBuffer)
    {
        DPF_ERR("could not alloc dgram receive buffer");
        ExitThread(0);
        return 0;
    }
    while (1)
    {
        err = g_recvfrom(gsDatagramListener,pBuffer,dwBufSize,0,&sockaddr,&addrlen);
        if (SOCKET_ERROR == err) 
        {
            err = g_WSAGetLastError();
            if (WSAEMSGSIZE == err)
            {
                LPBYTE pNewBuffer;

                // buffer too small!
                dwBufSize *= 2;

	    	    DPF(9,"\n udp recv thread - resizing buffer newsize = %d\n",dwBufSize);
                pNewBuffer = MemReAlloc(pBuffer,dwBufSize);
                if (!pNewBuffer)
                {
                    DPF_ERR("could not realloc dgram receive buffer");
                    goto ERROR_EXIT;
                }
                pBuffer = pNewBuffer;
                // we can't do anything with this message, since it was truncated...
            } // WSAEMSGSIZE
            else 
            {
		#ifdef DEBUG
            	if (WSAEINTR != err) 
		        {
				    // WSAEINTR is what winsock uses to break a blocking socket out of 
				    // its wait.  it means someone killed this socket.
				    // if it's not that, then it's a real error.
		            DPF(0,"\n udp recv error - err = %d socket = %d",err,(DWORD)gsDatagramListener);
            	}
				else
				{
				    DPF(9,"\n udp recv error - err = %d socket = %d",err,(DWORD)gsDatagramListener);				
				}
		#endif // DEBUG 

                // we bail on errors other than WSAEMSGSIZE
                goto ERROR_EXIT;
            }
        } // SOCKET_ERROR
        else if ((err >= sizeof(DWORD)) &&  VALID_SP_MESSAGE(pBuffer))
        {
            // now, if we succeeded, err is the # of bytes read
	    	DEBUGPRINTADDR(9,"dplay helper  :: received enum request from ",(SOCKADDR *)&sockaddr);
		    // take the dplay lock so no one messes w/ our list of registered serves while we're 
		    // trying to send to them...
    	    ENTER_DPLAYSVR();
	    
            HandleIncomingMessage(pBuffer,err,(SOCKADDR_IN *)&sockaddr);
	    
		    // give up the lock
    	    LEAVE_DPLAYSVR();
        }
        else 
        {
            ASSERT(FALSE);
            // ?
        }
    } // 1

ERROR_EXIT:
    DPF(2,"UDP Listen thread exiting");
    if (pBuffer) MemFree(pBuffer);
    // all done
    ExitThread(0);
    return 0;

} // UDPListenThreadProc

// startup winsock and find the default ip addr for this machine
HRESULT  StartupIP()
{
    UINT err;
    WSADATA wsaData;
	HINSTANCE hWinsock;

	// load winsock library
    hWinsock = LoadLibrary("wsock32.dll");
	if (!hWinsock) 
	{
		DPF(0,"Could not load wsock32.dll\n");
		goto LOADLIBRARYFAILED;
	}

	// get pointers to the entry points we need

    g_accept = (cb_accept) GetProcAddress(hWinsock, "accept");
	if (!g_accept)
		goto GETPROCADDRESSFAILED;

    g_bind = (cb_bind) GetProcAddress(hWinsock, "bind");
	if (!g_bind)
		goto GETPROCADDRESSFAILED;
		
    g_closesocket = (cb_closesocket) GetProcAddress(hWinsock, "closesocket");
	if (!g_closesocket)
		goto GETPROCADDRESSFAILED;

    g_gethostbyname = (cb_gethostbyname) GetProcAddress(hWinsock, "gethostbyname");
	if (!g_gethostbyname)
		goto GETPROCADDRESSFAILED;
		
    g_gethostname = (cb_gethostname) GetProcAddress(hWinsock, "gethostname");
	if (!g_gethostname)
		goto GETPROCADDRESSFAILED;

    g_getpeername = (cb_getpeername) GetProcAddress(hWinsock, "getpeername");
	if (!g_getpeername)
		goto GETPROCADDRESSFAILED;

    g_getsockname = (cb_getsockname) GetProcAddress(hWinsock, "getsockname");
	if (!g_getsockname)
		goto GETPROCADDRESSFAILED;

    g_htons = (cb_htons) GetProcAddress(hWinsock, "htons");
	if (!g_htons)
		goto GETPROCADDRESSFAILED;
		
    g_inet_ntoa = (cb_inet_ntoa) GetProcAddress(hWinsock, "inet_ntoa");
	if (!g_inet_ntoa)
		goto GETPROCADDRESSFAILED;

    g_listen = (cb_listen) GetProcAddress(hWinsock, "listen");
	if (!g_listen)
		goto GETPROCADDRESSFAILED;
		
    g_recv = (cb_recv) GetProcAddress(hWinsock, "recv");
	if (!g_recv)
		goto GETPROCADDRESSFAILED;

    g_recvfrom = (cb_recvfrom) GetProcAddress(hWinsock, "recvfrom");
	if (!g_recvfrom)
		goto GETPROCADDRESSFAILED;

    g_select = (cb_select) GetProcAddress(hWinsock, "select");
	if (!g_select)
		goto GETPROCADDRESSFAILED;

    g_send = (cb_send) GetProcAddress(hWinsock, "send");
	if (!g_send)
		goto GETPROCADDRESSFAILED;

    g_sendto = (cb_sendto) GetProcAddress(hWinsock, "sendto");
	if (!g_sendto)
		goto GETPROCADDRESSFAILED;

    g_setsockopt = (cb_setsockopt) GetProcAddress(hWinsock, "setsockopt");
	if (!g_setsockopt)
		goto GETPROCADDRESSFAILED;

    g_shutdown = (cb_shutdown) GetProcAddress(hWinsock, "shutdown");
	if (!g_shutdown)
		goto GETPROCADDRESSFAILED;

    g_socket = (cb_socket) GetProcAddress(hWinsock, "socket");
	if (!g_socket)
		goto GETPROCADDRESSFAILED;

    g_WSAFDIsSet = (cb_WSAFDIsSet) GetProcAddress(hWinsock, "__WSAFDIsSet");
	if (!g_WSAFDIsSet)
		goto GETPROCADDRESSFAILED;
		
	g_WSAGetLastError = (cb_WSAGetLastError) GetProcAddress(hWinsock, "WSAGetLastError");
	if (!g_WSAGetLastError)
		goto GETPROCADDRESSFAILED;

    g_WSAStartup = (cb_WSAStartup) GetProcAddress(hWinsock, "WSAStartup");
	if (!g_WSAStartup)
		goto GETPROCADDRESSFAILED;

	// start up sockets, asking for version 1.1
    err = g_WSAStartup(MAKEWORD(1,1), &wsaData);
    if (err) 
    {
        DPF(0,"dphelp :: could not start winsock err = %d\n",err);
        goto WSASTARTUPFAILED;
    }
    DPF(3,"dphelp :: started up winsock succesfully");

    return DP_OK;

GETPROCADDRESSFAILED:
	DPF(0,"Could not find required Winsock entry point");
WSASTARTUPFAILED:
	FreeLibrary(hWinsock);
LOADLIBRARYFAILED:
	return DPERR_UNAVAILABLE;
} // StartupIP

// helper function to create the socket we listen on
HRESULT GetSocket(SOCKET * psock,DWORD type,PORT port,BOOL bBroadcast,BOOL bListen)
{
    SOCKADDR_IN sockaddr;
    UINT err;
    SOCKET sNew;

    sNew = g_socket( AF_INET, type, 0);
    if (INVALID_SOCKET == sNew) 
    {
        goto ERROR_EXIT;
    }

    // set up the sockaddr to bind to
    sockaddr.sin_family         = PF_INET;
    sockaddr.sin_addr.s_addr    = INADDR_ANY;
    sockaddr.sin_port           = port;

    // do the bind
    if( SOCKET_ERROR == g_bind( sNew, (LPSOCKADDR)&sockaddr, sizeof(sockaddr) ) )
    {
        goto ERROR_EXIT;
    }

    if (bBroadcast)
    {
		BOOL bTrue = TRUE;

        if( SOCKET_ERROR == g_setsockopt( sNew,SOL_SOCKET,SO_BROADCAST,(char FAR *)&bTrue,
	    	sizeof(bTrue) ) )
		{
            err = g_WSAGetLastError();
		    DPF(0," dphelp - create - could not set broadcast err = %d\n",err);
		    // not really tragic, since for AF_INET it's not required to set broadcast 
		    // b4 receiving w/ MS winsock...
		}
    }

    if (bListen)
    {
	    LINGER Linger;
	    
	    // set up socket w/ max listening connections
	    err = g_listen(sNew,LISTEN_BACKLOG);
	    if (SOCKET_ERROR == err) 
	    {
	        err = g_WSAGetLastError();
	        DPF(0,"init listen socket / listen error - err = %d\n",err);
	        goto ERROR_EXIT;
	    }

		// set for hard disconnect
		Linger.l_onoff=1;
		Linger.l_linger=0;
	    
	    if( SOCKET_ERROR == g_setsockopt( sNew,SOL_SOCKET,SO_LINGER,
			(char FAR *)&Linger,sizeof(Linger) ) )
	    {
	        err = g_WSAGetLastError();
			DPF(0,"Failed to set linger option on the socket = %d\n",err);
	    }    
    }

    // success!
    *psock = sNew;
    return DP_OK;

ERROR_EXIT:
    // clean up and bail
    err = g_WSAGetLastError();
    DPF(0,"dphelp - could not get helper socket :: err = %d\n",err);
    if (INVALID_SOCKET != sNew)
    {
        g_closesocket(sNew);
    } 
    return E_FAIL;

}   // GetSocket

void CloseSocket(SOCKET * psSocket)
{
    UINT err;

    if (INVALID_SOCKET != *psSocket)
    {
    	if (SOCKET_ERROR == g_closesocket(*psSocket)) 
    	{
            err = g_WSAGetLastError();
    	    DPF(1,"dphelp : killsocket - socket close err = %d\n",err);
		}
	
		*psSocket = INVALID_SOCKET;
    }
    
    return ;

} // CloseSocket

HRESULT DPlayHelp_Init()
{
    DWORD dwThreadID;
    HRESULT hr;

    // start winsock, and get the default ip addr for this system
    hr = StartupIP();
    if (FAILED(hr))
    {
        return hr; // StartupIP will have printed an error
    }

    // get the listen socket
    hr = GetSocket(&gsDatagramListener,SOCK_DGRAM,SERVER_DGRAM_PORT,TRUE,FALSE);
    if (FAILED(hr))
    {
        goto ERROR_EXIT; // GetSocket will have printed an error
    }

    // get the forward socket
    hr = GetSocket(&gsForwardSocket,SOCK_DGRAM,0,FALSE,FALSE);
    if (FAILED(hr))
    {
        goto ERROR_EXIT; // GetSocket will have printed an error
    }

    // get us a enum sessions stream listener
	hr = GetSocket(&gsStreamListener,SOCK_STREAM,SERVER_STREAM_PORT,FALSE,TRUE);
    if (FAILED(hr))
    {
        goto ERROR_EXIT; // GetSocket will have printed an error
    }
	

    ghDatagramReceiveThread = CreateThread(NULL,0,ListenThreadProc,NULL,0,&dwThreadID);
    if (!ghDatagramReceiveThread)
    {
        DPF_ERR("could not create udp listen thread");
		hr = E_FAIL;
        goto ERROR_EXIT; // GetSocket will have printed an error
    }

    ghStreamReceiveThread = CreateThread(NULL,0,StreamReceiveThreadProc,NULL,0,&dwThreadID);
    if (!ghStreamReceiveThread)
    {
        DPF_ERR("could not create tcp listen thread");
		hr = E_FAIL;
        goto ERROR_EXIT; // GetSocket will have printed an error
    }
    

    DPF(5,"DPLAYHELP : init succeeded");
    gbInit = TRUE;
    return DP_OK;

ERROR_EXIT:
    CloseSocket(&gsDatagramListener);
    CloseSocket(&gsForwardSocket);
    CloseSocket(&gsStreamListener);

    return hr;

} // DPlayHelp_Init 

void DPlayHelp_FreeServerList()
{
    LPSPNODE pNodeKill,pNodeNext;

    pNodeNext = gNodeList;

    // search the whole list
    while (pNodeNext)
    {
		// kill this node
		pNodeKill = pNodeNext;
		// but first, remember what's next
		pNodeNext = pNodeKill->pNextNode;
		// free up the node
		MemFree(pNodeKill);
    }
	
    CloseSocket(&gsDatagramListener);
    CloseSocket(&gsForwardSocket);

	// close stream receive
	RemoveSocketFromList(gsStreamListener);
	gbReceiveShutdown = TRUE;
	
	// drop the lock so the threads can exit - they might be waiting on
	// the lock for cleanup
	LEAVE_DPLAYSVR();
		
    // wait for the threads to go away
   	if (ghDatagramReceiveThread) 
   		WaitForSingleObject(ghDatagramReceiveThread, INFINITE);
    if (ghStreamReceiveThread) 
    	WaitForSingleObject(ghStreamReceiveThread, INFINITE);
    
    ENTER_DPLAYSVR();
    
    if (ghDatagramReceiveThread)
    {
    	DPF(5,"datagram receive thread exited!");
	    CloseHandle(ghDatagramReceiveThread);
	    ghDatagramReceiveThread = NULL;
    }
    if (ghStreamReceiveThread)
    {
	    DPF(5,"stream receive thread exited!");
	    CloseHandle(ghStreamReceiveThread);
	    ghStreamReceiveThread = NULL;
    }


    return ;
    
} // DPlayHelp_FreeServerList



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplaysvr\dphelp.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dphelp.h
 *  Content:	header for dphelp.c
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   16-jul-96	andyco	initial implementation
 *   25-jul-96	andyco	added watchnewpid
 *	 23-jan-97	kipo	prototypes for winsock calls
 *	 15-feb-97	andyco	moved from ddhelp to the project formerly known as
 *						ddhelp (playhelp? dplayhlp? dplay.exe? dphost?)  Allowed
 *						one process to host mulitple sessions
 *	 29-jan-98	sohailm	added support for stream enum sessions
 *
 ***************************************************************************/

#ifndef __DPHELP_INCLUDED__
#define __DPHELP_INCLUDED__

#include "windows.h"
#include "dplaysvr.h"
#include "newdpf.h"
#include "winsock.h"
// we include dpsp.h since we'll be poking bits (sockaddr's)
// into dpsp's header
#include "dpsp.h"

// backlog for listen() api.  no constant in winsock, so we ask for the moon
#define LISTEN_BACKLOG 	60

typedef struct _SPNODE * LPSPNODE;

typedef struct _SPNODE
{
	SOCKADDR_IN sockaddr;  // socket addr of server
	DWORD pid;
	LPSPNODE  pNextNode;
} SPNODE;

// protos

// from dphelp.c
extern HRESULT DPlayHelp_AddServer(LPDPHELPDATA phd);
extern BOOL FAR PASCAL DPlayHelp_DeleteServer(LPDPHELPDATA phd,BOOL fFreeAll);
extern HRESULT DPlayHelp_Init();
extern void DPlayHelp_FreeServerList();
extern DWORD WINAPI StreamAcceptThreadProc(LPVOID pvCast);
extern DWORD WINAPI StreamReceiveThreadProc(LPVOID pvCast);
extern void HandleIncomingMessage(LPBYTE pBuffer,DWORD dwBufferSize,SOCKADDR_IN * psockaddr);

// from help.c
extern void WatchNewPid(LPDPHELPDATA phd);

// from reliable.c
void RemoveSocketFromList(SOCKET socket);


//prototypes for winsock calls
typedef int (PASCAL FAR * cb_accept)(SOCKET s, struct sockaddr FAR * addr, int FAR * addrlen);
extern cb_accept	g_accept;

typedef int (PASCAL FAR * cb_bind)(SOCKET s, const struct sockaddr FAR *addr, int namelen);
extern	cb_bind	g_bind;

typedef int (PASCAL FAR * cb_closesocket)(SOCKET s);
extern	cb_closesocket	g_closesocket;

typedef struct hostent FAR * (PASCAL FAR * cb_gethostbyname)(const char FAR * name);
extern	cb_gethostbyname	g_gethostbyname;

typedef int (PASCAL FAR * cb_gethostname)(char FAR * name, int namelen);
extern	cb_gethostname	g_gethostname;

typedef int (PASCAL FAR * cb_getpeername)(SOCKET s, struct sockaddr FAR * name, int FAR * namelen);
extern	cb_getpeername	g_getpeername;

typedef int (PASCAL FAR * cb_getsockname)(SOCKET s, struct sockaddr FAR * name, int FAR * namelen);
extern	cb_getsockname	g_getsockname;

typedef u_short (PASCAL FAR * cb_htons)(u_short hostshort);
extern	cb_htons		g_htons;

typedef char FAR * (PASCAL FAR * cb_inet_ntoa)(struct in_addr in);
extern	cb_inet_ntoa	g_inet_ntoa;

typedef int (PASCAL FAR * cb_listen)(
    SOCKET s,
    int backlog
    );
extern cb_listen		g_listen;

typedef int (PASCAL FAR * cb_recv)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags
    );
extern cb_recv		g_recv;

typedef int (PASCAL FAR * cb_recvfrom)(SOCKET s, char FAR * buf, int len, int flags,
                         struct sockaddr FAR *from, int FAR * fromlen);
extern	cb_recvfrom	g_recvfrom;

typedef SOCKET (PASCAL FAR * cb_select)(
    int nfds,
    fd_set FAR * readfds,
    fd_set FAR * writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR * timeout
    );
extern cb_select	g_select;

typedef int (PASCAL FAR * cb_send)(SOCKET s, const char FAR * buf, int len, int flags);
extern	cb_send		g_send;

typedef int (PASCAL FAR * cb_sendto)(SOCKET s, const char FAR * buf, int len, int flags,
                       const struct sockaddr FAR *to, int tolen);
extern	cb_sendto	g_sendto;

typedef int (PASCAL FAR * cb_setsockopt)(SOCKET s, int level, int optname,
                           const char FAR * optval, int optlen);
extern	cb_setsockopt	g_setsockopt;

typedef int (PASCAL FAR * cb_shutdown)(SOCKET s, int how);
extern cb_shutdown	g_shutdown;

typedef SOCKET (PASCAL FAR * cb_socket)(int af, int type, int protocol);
extern	cb_socket	g_socket;

typedef int (PASCAL FAR * cb_WSAFDIsSet)(SOCKET, fd_set FAR *);
extern 	cb_WSAFDIsSet	g_WSAFDIsSet;

typedef int (PASCAL FAR * cb_WSAGetLastError)(void);
extern	cb_WSAGetLastError	g_WSAGetLastError;

typedef int (PASCAL FAR * cb_WSAStartup)(WORD wVersionRequired, LPWSADATA lpWSAData);
extern	cb_WSAStartup	g_WSAStartup;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplaysvr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dpwsock.rc
//
#define IDD_DIALOG1                     101
#define IDD_SELECTSERVER                101
#define IDC_EDIT1                       1000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplaysvr\killsvr.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       killsvr.c
 *  Content:	kill dplay.exe
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   24-jun-95	craige	kill all attached processes
 *	 2-feb-97	andyco	ported for dplaysvr.exe
 *	 7-jul-97	kipo	added non-console support
 *
 ***************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include "dplaysvr.h"

// only do printf's when built as a console app

#ifdef NOCONSOLE
#pragma warning(disable:4002)
#define printf()
#endif

/*
 * sendRequest
 *
 * communicate a request to DPHELP
 */
static BOOL sendRequest( LPDPHELPDATA req_phd )
{
    LPDPHELPDATA	phd;
    HANDLE		hmem;
    HANDLE		hmutex;
    HANDLE		hackevent;
    HANDLE		hstartevent;
    BOOL		rc;

    /*
     * get events start/ack events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_EVENT_NAME );
    printf( "hstartevent = %08lx\n", hstartevent );
    if( hstartevent == NULL )
    {
        return FALSE;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_ACK_EVENT_NAME );
    printf( "hackevent = %08lx\n", hackevent );
    if( hackevent == NULL )
    {
        CloseHandle( hstartevent );
        return FALSE;
    }

    /*
     * create shared memory area
     */
    hmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
    		PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
                DPHELP_SHARED_NAME );
    printf( "hmem = %08lx\n", hmem );
    if( hmem == NULL )
    {
        printf( "Could not create file mapping!\n" );
        CloseHandle( hstartevent );
        CloseHandle( hackevent );
        return FALSE;
    }
    phd = (LPDPHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
    printf( "phd = %08lx\n", phd );
    if( phd == NULL )
    {
        printf( "Could not create view of file!\n" );
        CloseHandle( hmem );
        CloseHandle( hstartevent );
        CloseHandle( hackevent );
        return FALSE;
    }

    /*
     * wait for access to the shared memory
     */
    hmutex = OpenMutex( SYNCHRONIZE, FALSE, DPHELP_MUTEX_NAME );
    printf( "hmutex = %08lx\n", hmutex );
    if( hmutex == NULL )
    {
        printf( "Could not create mutex!\n" );
        CloseHandle( hmem );
        CloseHandle( hstartevent );
        CloseHandle( hackevent );
        return FALSE;
    }
    WaitForSingleObject( hmutex, INFINITE );

    /*
     * wake up DPHELP with our request
     */
    memcpy( phd, req_phd, sizeof( DPHELPDATA ) );
    printf( "waking up DPHELP\n" );
    if( SetEvent( hstartevent ) )
    {
        printf( "Waiting for response\n" );
        WaitForSingleObject( hackevent, INFINITE );
        memcpy( req_phd, phd, sizeof( DPHELPDATA ) );
        rc = TRUE;
        printf( "got response\n" );
    }
    else
    {
        printf( "Could not signal event to notify dplay.exe\n" );
        rc = FALSE;
    }

    /*
     * done with things
     */
    ReleaseMutex( hmutex );
    CloseHandle( hstartevent );
    CloseHandle( hackevent );
    CloseHandle( hmutex );
    CloseHandle( hmem );
    return rc;

} /* sendRequest */


// if the main entry point is called "WinMain" we will be built
// as a windows app
#ifdef NOCONSOLE

int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
				   LPSTR lpCmdLine, int nCmdShow)

#else

// if the main entry point is called "main" we will be built
// as a console app

int main( int argc, char *argv[] )

#endif
{
    HANDLE	h;
    DPHELPDATA	hd;

    h = OpenEvent( SYNCHRONIZE, FALSE, DPHELP_STARTUP_EVENT_NAME );
    if( h == NULL )
    {
        printf( "Helper not running\n" );
        return 0;
    }

    printf( "*** SUICIDE ***\n" );
    hd.req = DPHELPREQ_SUICIDE;
    sendRequest( &hd );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\bilink.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.C

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/
#include <windows.h>
#include "newdpf.h"
#include <dplaypr.h>
#include "bilink.h"
#include "mydebug.h"

// Note: serialization of access to BILINK structures must 
//       take place in the calling code.  Operations are
//       not intrinsically atomic.

#ifdef DEBUG
int FindObject(
    BILINK *link,
    BILINK *list
    )
{
    BILINK *p = list->next;
    while(p != link && p != list)
        p= p->next;
    return (p==link);
}
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    )
/*=========================================================================
 *  Description:
 *      Insert an object after a specified object in the doubly linked list.
 *      The after object could be the Head BILINK for adding to the head of a
 *      queue.
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,after)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = after->next;
    in->prev = after;
    after->next->prev = in;
    after->next = in;
}

void InsertBefore(
     BILINK *in,
     BILINK *before
    )
/*=========================================================================
 *  Description:
 * Inserts an  object before a specified object in the doubly linked list.
 * The before object could be the Head BILINK for adding to the end
 * of the queue
 * CALLED WITH INTERRUPTS_OFF
 *
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,before)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = before;
    in->prev = before->prev;
    before->prev->next = in;
    before->prev = in;
}

void Delete(
     BILINK *p
)
/*=========================================================================
 *  Description:
 *
 * Delete a  object from a doubly linked list. Make sure it IS on a list!
 * CALLED WITH INTERRUPTS OFF (must be atomic).
 *
 *  Returns:
 *
 */
{
    ASSERT(p && p->prev && p->next);
    if(!p && p->prev && p->next){
    	DEBUG_BREAK();
    }
    ASSERT(p->prev->next == p && p->next->prev == p);
    if(!(p->prev->next == p && p->next->prev == p)){
    	DEBUG_BREAK();
    }
    p->next->prev = p->prev;
    p->prev->next = p->next;
    // p->next = p->prev = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\bilink.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.H

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/// BILINK.H

#ifndef _BILINK_

#define _BILINK_

#if !defined(offsetof)
	#define offsetof(type, field) ((int)(&((type *)0)->field))
#endif	

typedef struct BILINK {
    struct BILINK *next;
    struct BILINK *prev;
} BILINK;

/* XLATOFF */

#define EMPTY_BILINK(_pBilink) ((_pBilink)->next==(_pBilink))

#ifdef DEBUG
    #define ASSERT_EMPTY_BILINK(_b) ASSERT((_b)->next==(_b))
#else
    #define ASSERT_EMPTY_BILINK(_b)
#endif

// This only works for BILINKS that are the first item in a structure.
#define BilinkToList( _pBilink ) \
	(_pBilink)->prev->next=NULL;

#define InitBilink( _pBilink ) \
    (_pBilink)->prev=(_pBilink)->next=(_pBilink);

#ifdef DEBUG

int FindObject(
    BILINK *link,
    BILINK *list
    );
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    );

void InsertBefore(
     BILINK *in,
     BILINK *before
    );

void Delete(
     BILINK *p
);

/* XLATON */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplaysvr\daytona\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\memalloc.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplaysvr\reliable.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       reliable.c
 *  Content:    stream communication related routines
 *  History:
 *   Date   	By  	Reason
 *   ====   	==  	======
 *   01-29-98  	sohailm	initial implementation
 *   02-15-98  a-peterz	Remove unused SetMessageHeader
 *
 ***************************************************************************/
#include "dphelp.h"

/*
 * Globals
 */
FDS	gReadfds;							// fd set to receive data
RECEIVELIST gReceiveList;				// list of connections + listener

/*
 * Externs
 */
extern SOCKET gsStreamListener;			// we listen for tcp connections on this socket
extern gbReceiveShutdown;				// receive thread will exit when TRUE
extern LPSPNODE gNodeList;

#undef DPF_MODNAME
#define DPF_MODNAME	"MakeBufferSpace"

// make sure the buffer is big enough to fit the message size
HRESULT MakeBufferSpace(LPBYTE * ppBuffer,LPDWORD pdwBufferSize,DWORD dwMessageSize)
{
	HRESULT hr = DP_OK;

	ASSERT(ppBuffer);
	ASSERT(pdwBufferSize);
		    
	ENTER_DPLAYSVR();
	
	if (!*ppBuffer)
	{
		DPF(9, "Allocating space for message of size %d", dwMessageSize);

		// need to alloc receive buffer?
		*ppBuffer = MemAlloc(dwMessageSize);
        if (!*ppBuffer)
        {
        	DPF_ERR("could not alloc stream receive buffer - out of memory");        
            hr = E_OUTOFMEMORY;
            goto CLEANUP_EXIT;
        }
		*pdwBufferSize = dwMessageSize;
	}
	// make sure receive buffer can hold data
	else if (dwMessageSize > *pdwBufferSize) 
	{
		LPVOID pvTemp;

		DPF(9, "ReAllocating space for message of size %d", dwMessageSize);

		// realloc buffer to hold data
		pvTemp = MemReAlloc(*ppBuffer,dwMessageSize);
		if (!pvTemp)
		{
        	DPF_ERR("could not realloc stream receive buffer - out of memory");
            hr = E_OUTOFMEMORY;
            goto CLEANUP_EXIT;
		}
		*ppBuffer = pvTemp;
		*pdwBufferSize = dwMessageSize;
	}

    // fall through
    
CLEANUP_EXIT: 
    
	LEAVE_DPLAYSVR();
    return hr;    
    
}  // MakeBufferSpace

#undef DPF_MODNAME
#define DPF_MODNAME	"AddSocketToReceiveList"

HRESULT AddSocketToReceiveList(SOCKET sSocket)
{
    UINT i = 0;
    UINT err, iNewSlot;
	BOOL bFoundSlot = FALSE;
    HRESULT hr = DP_OK;
    INT addrlen=sizeof(SOCKADDR);
	LPCONNECTION pNewConnection;
    
    ENTER_DPLAYSVR();
	
    // look for an empty slot 
    while ( (i < gReceiveList.nConnections) && !bFoundSlot)
    {
    	if (INVALID_SOCKET == gReceiveList.pConnection[i].socket)
    	{
    		bFoundSlot = TRUE;			
			iNewSlot = i;
    	}
        else 
        {
        	i++;
        }
    }
    
    if (!bFoundSlot)
    {
		DWORD dwCurrentSize,dwNewSize;
		
		// allocate space for list of connections
		dwCurrentSize = gReceiveList.nConnections * sizeof(CONNECTION);
		dwNewSize = dwCurrentSize +  INITIAL_RECEIVELIST_SIZE * sizeof(CONNECTION);		
		hr =  MakeBufferSpace((LPBYTE *)&(gReceiveList.pConnection),&dwCurrentSize,dwNewSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}		
		ASSERT(dwCurrentSize == dwNewSize);
		
        // set all the new entries to INVALID
        for (i = gReceiveList.nConnections + 1; 
        	i < gReceiveList.nConnections + INITIAL_RECEIVELIST_SIZE; i++ )
        {
        	gReceiveList.pConnection[i].socket = INVALID_SOCKET;
        }
        
        // store the new socket in the 1st new spot
		iNewSlot = gReceiveList.nConnections;

        // allocate space for an fd set (fd_count + fd_array)
		if (gReceiveList.nConnections)
		{
	        dwCurrentSize = sizeof(u_int) + gReceiveList.nConnections * sizeof(SOCKET);
	        dwNewSize =	dwCurrentSize + INITIAL_RECEIVELIST_SIZE * sizeof(SOCKET);
		}
		else
		{
			dwCurrentSize = 0;
			dwNewSize = sizeof(u_int) + INITIAL_RECEIVELIST_SIZE * sizeof(SOCKET);
		}
		hr =  MakeBufferSpace((LPBYTE *)&(gReadfds.pfdbigset),&dwCurrentSize,dwNewSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}		
		ASSERT(dwCurrentSize == dwNewSize);
		
        // update the # of connections
        gReceiveList.nConnections += INITIAL_RECEIVELIST_SIZE; 
		// update the fd_array buffer size
		gReadfds.dwArraySize = gReceiveList.nConnections;
        
    } // !bFoundSlot

	// Initialize new connection 
	pNewConnection = &(gReceiveList.pConnection[iNewSlot]);
    pNewConnection->socket = sSocket;
	// allocate a default receive buffer
	pNewConnection->pDefaultBuffer = MemAlloc(DEFAULT_RECEIVE_BUFFERSIZE);
	if (NULL == pNewConnection->pDefaultBuffer)
	{
        DPF_ERR("could not alloc default receive buffer - out of memory");        
		hr = E_OUTOFMEMORY;
		goto CLEANUP_EXIT;
	}
	// receive buffer initially points to our default buffer
	pNewConnection->pBuffer = pNewConnection->pDefaultBuffer;
	// remember the address we are connected to
	err = g_getpeername(pNewConnection->socket, &(pNewConnection->sockAddr), &addrlen);
	if (SOCKET_ERROR == err) 
	{
		err = g_WSAGetLastError();
		DPF(1,"could not getpeername err = %d\n",err);
	}

	DPF(9, "Added new socket at index %d", iNewSlot);

CLEANUP_EXIT:
    
	LEAVE_DPLAYSVR();
    return hr;
    
}  // AddSocketToReceiveList

#undef DPF_MODNAME
#define DPF_MODNAME	"KillSocket"

HRESULT KillSocket(SOCKET sSocket,BOOL fStream,BOOL fHard)
{
	UINT err;

    if (INVALID_SOCKET == sSocket) 
    {
		return E_FAIL;
    }

	if (!fStream)
    {
        if (SOCKET_ERROR == g_closesocket(sSocket)) 
        {
	        err = g_WSAGetLastError();
			DPF(0,"killsocket - dgram close err = %d\n",err);
			return E_FAIL;
        }
    }
	else 
	{
		LINGER Linger;

	   	if (fHard)
		{
			Linger.l_onoff=TRUE; // turn linger on
			Linger.l_linger=0; // nice small time out

		    if( SOCKET_ERROR == g_setsockopt( sSocket,SOL_SOCKET,SO_LINGER,(char FAR *)&Linger,
		                    sizeof(Linger) ) )
		    {
		        err = g_WSAGetLastError();
				DPF(0,"killsocket - stream setopt err = %d\n",err);
		    }
		}			
		if (SOCKET_ERROR == g_shutdown(sSocket,2)) 
		{
			// this may well fail, if e.g. no one is using this socket right now...
			// the error would be wsaenotconn 
	        err = g_WSAGetLastError();
			DPF(5,"killsocket - stream shutdown err = %d\n",err);
		}
        if (SOCKET_ERROR == g_closesocket(sSocket)) 
        {
	        err = g_WSAGetLastError();
			DPF(0,"killsocket - stream close err = %d\n",err);
			return E_FAIL;
        }
    }

	return DP_OK;
	
}// KillSocket

void FreeConnection(LPCONNECTION pConnection)
{
	DEBUGPRINTSOCK(5,"Freeing connection - ",&pConnection->socket);

	KillSocket(pConnection->socket,TRUE,FALSE);

	if (pConnection->pBuffer && (pConnection->pBuffer != pConnection->pDefaultBuffer)) 
	{
		MemFree(pConnection->pBuffer);
		pConnection->pBuffer = NULL;
	}
	if (pConnection->pDefaultBuffer) 
	{
		MemFree(pConnection->pDefaultBuffer);
		pConnection->pDefaultBuffer = NULL;
	}

	// initialize connection 
    pConnection->socket = INVALID_SOCKET; // this tells us if connection is valid
	pConnection->dwCurMessageSize = 0;
	pConnection->dwTotalMessageSize = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME	"RemoveSocketFromList"

void RemoveSocketFromList(SOCKET socket)
{
    UINT i = 0;
	BOOL bFound = FALSE;

    ENTER_DPLAYSVR();
    
    // look for the corresponding connection
    while ( (i < gReceiveList.nConnections) && !bFound)
    {
    	if (gReceiveList.pConnection[i].socket == socket)
    	{
    		bFound = TRUE;
			FreeConnection(&gReceiveList.pConnection[i]);
    	}
        else 
        {
        	i++;
        }
    } // while
    
    LEAVE_DPLAYSVR();
	
	return ;	
}


#undef DPF_MODNAME
#define DPF_MODNAME	"EmptyConnectionList"

void EmptyConnectionList(void)
{
	UINT i;
	
	DPF(5, "Emptying connection list");
	
	ENTER_DPLAYSVR();
	
	for (i=0;i<gReceiveList.nConnections ;i++ )
	{
		if (INVALID_SOCKET != gReceiveList.pConnection[i].socket)
		{
			FreeConnection(&(gReceiveList.pConnection[i]));
		}
	}
	
	LEAVE_DPLAYSVR();
	
	return ;
	
}  // EmptyConnectionList

#undef DPF_MODNAME
#define DPF_MODNAME	"StreamReceive"

/*
 ** StreamReceive
 *
 *  CALLED BY: StreamReceiveThreadProc
 *
 *  PARAMETERS:
 *		sSocket - socket to receive on
 *		ppBuffer - buffer to receive into - alloc'ed / realloc'ed  as necessary
 *		pdwBuffersize - size of pBuffer
 *
 *  DESCRIPTION:
 *		take the bytes out of sSocket until no more bytes
 *
 *  RETURNS: E_FAIL on sockerr, or DP_OK. 
 *
 */
HRESULT StreamReceive(LPCONNECTION pConnection)
{
	HRESULT hr = DP_OK;
    UINT err;
    DWORD dwBytesReceived=0;
	DWORD dwMessageSize;
	LPBYTE pReceiveBuffer=NULL;
	DWORD dwReceiveBufferSize;
	
	// is it a new message ?
	if (pConnection->dwCurMessageSize == 0)
	{
		// receive the header first
		pConnection->dwTotalMessageSize = SPMESSAGEHEADERLEN;
	}

	// continue receiving message
	pReceiveBuffer = pConnection->pBuffer + pConnection->dwCurMessageSize;
	dwReceiveBufferSize = pConnection->dwTotalMessageSize - pConnection->dwCurMessageSize;

	DPF(9,"Attempting to receive %d bytes", dwReceiveBufferSize);

   	DEBUGPRINTSOCK(9,">>> receiving data on socket - ",&pConnection->socket);

	// receive data from socket 
	// note - make exactly one call to recv after select otherwise we'll hang
	dwBytesReceived = g_recv(pConnection->socket, (LPBYTE)pReceiveBuffer, dwReceiveBufferSize, 0);

   	DEBUGPRINTSOCK(9,"<<< received data on socket - ",&pConnection->socket);

	DPF(5, "received %d bytes", dwBytesReceived);

	if (0 == dwBytesReceived)
	{
		// remote side has shutdown connection gracefully
		hr = DP_OK;
		DPF(5,"Remote side has shutdown connection gracefully");
		goto CLEANUP_EXIT;
	}
	else if (SOCKET_ERROR == dwBytesReceived)
	{
		err = g_WSAGetLastError();
		DPF(0,"STREAMRECEIVEE: receive error - err = %d",err);
		hr = E_UNEXPECTED;            
		goto CLEANUP_EXIT;
	}

	// we have received this much message so far
	pConnection->dwCurMessageSize += dwBytesReceived;

	if (pConnection->dwCurMessageSize == SPMESSAGEHEADERLEN)
	{
		// we just completed receiving message header

		if (VALID_DPLAYSVR_MESSAGE(pConnection->pDefaultBuffer))
		{
			 dwMessageSize = SP_MESSAGE_SIZE(pConnection->pDefaultBuffer); // total message size			
		}
		else 
		{
			DPF(2,"got invalid message");
			ASSERT(FALSE);
			hr = E_UNEXPECTED;
			goto CLEANUP_EXIT;
		}

		// prepare to receive the rest of the message (after token)
		if (dwMessageSize)
		{
			pConnection->dwTotalMessageSize = dwMessageSize;

			// which buffer to receive message in ?
			if (dwMessageSize > DEFAULT_RECEIVE_BUFFERSIZE)
			{
				ASSERT(pConnection->pBuffer == pConnection->pDefaultBuffer);
				// get a new buffer to fit the message
				pConnection->pBuffer = MemAlloc(dwMessageSize);
				if (!pConnection->pBuffer)
				{
					DPF(0,"Failed to allocate receive buffer for message - out of memory");
					goto CLEANUP_EXIT;
				}
				// copy header into new message buffer
				memcpy(pConnection->pBuffer, pConnection->pDefaultBuffer, SPMESSAGEHEADERLEN);
			}
		}
	}

	// did we receive a complete message ?
	if (pConnection->dwCurMessageSize == pConnection->dwTotalMessageSize)
	{
		// received a complete message - process it

		if (TOKEN == SP_MESSAGE_TOKEN(pConnection->pBuffer))
		{						
	    	DEBUGPRINTADDR(9,"dplay helper  :: received reliable enum request from ",(SOCKADDR *)&pConnection->sockAddr);
		    // take the dplay lock so no one messes w/ our list of registered serves while we're 
		    // trying to send to them...
    	    ENTER_DPLAYSVR();
	    
            HandleIncomingMessage(pConnection->pBuffer, pConnection->dwTotalMessageSize,
				(SOCKADDR_IN *)&pConnection->sockAddr);
	    
		    // give up the lock
    	    LEAVE_DPLAYSVR();
		}
			
		// cleanup up new receive buffer if any
		if (pConnection->dwTotalMessageSize > DEFAULT_RECEIVE_BUFFERSIZE)
		{
			DPF(9, "Releasing receive buffer of size %d", pConnection->dwTotalMessageSize);
			if (pConnection->pBuffer) MemFree(pConnection->pBuffer);
		}			
		// initialize message information
		pConnection->dwCurMessageSize = 0;
		pConnection->dwTotalMessageSize = 0;
		pConnection->pBuffer = pConnection->pDefaultBuffer;
	}

	// all done
	return DP_OK;	
	
CLEANUP_EXIT:

	RemoveSocketFromList(pConnection->socket);
	return hr;
	 	
} // StreamReceive

#undef DPF_MODNAME
#define DPF_MODNAME	"StreamReceiveThreadProc"

// watch our list of sockets, waiting for one to have data to be received, or to be closed
DWORD WINAPI StreamReceiveThreadProc(LPVOID pvCast)
{
	HRESULT hr;
	INT_PTR rval;
	UINT i = 0;
    UINT err;
    DWORD dwBufferSize = 0;    
	UINT nSelected;
    SOCKADDR sockaddr; // socket we receive from
    INT addrlen=sizeof(sockaddr);
	SOCKET sSocket;

	// add listener socket to receive list
	// listener socket should be the first socket in the receive list
	hr = AddSocketToReceiveList(gsStreamListener);
	if (FAILED(hr))
	{
		DPF(0, "Failed to add TCP listener to receive list");
		return hr;
	}
	
    while (1)
    {
		ENTER_DPLAYSVR();

		ASSERT(gReadfds.pfdbigset);
		
    	// add all sockets in our recv list to readfds
		FD_ZERO(gReadfds.pfdbigset);
		nSelected = 0;
		for (i=0;i < gReceiveList.nConnections ; i++)
		{
        	if (INVALID_SOCKET != gReceiveList.pConnection[i].socket)
        	{
		        FD_BIG_SET(gReceiveList.pConnection[i].socket,&gReadfds);
				nSelected++;
        	}
		}

		LEAVE_DPLAYSVR();

		if (0 == nSelected)		
		{
			if (gbReceiveShutdown)
			{
				DPF(2,"stream receive thread proc detected shutdown - bailing");
				goto CLEANUP_EXIT;
			}
			// we should have at least one?
			DPF_ERR("No sockets in receive list - missing listener socket? bailing!");
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}
		
		// now, we wait for something to happen w/ our socket set
		rval = g_select(0,(fd_set *)(gReadfds.pfdbigset),NULL,NULL,NULL);
        if (SOCKET_ERROR == rval)
        {
 	      	err = g_WSAGetLastError();
	    	if (WSAEINTR != err) 
	        {
			    // WSAEINTR is what winsock uses to break a blocking socket out of 
			    // its wait.  it means someone killed this socket.
			    // if it's not that, then it's a real error.
	            DPF(0,"\n select error = %d socket - trying again",err);
	    	}
			else
			{
			    DPF(9,"\n select error = %d socket - trying again",err);				
			}
            rval = 0;
        }

		// shut 'em down?
        if (gbReceiveShutdown)
        {
        	DPF(2,"receive thread proc detected bShutdown - bailing");
            goto CLEANUP_EXIT;
        }
        
    	DPF(5,"receive thread proc - events on %d sockets",rval);
		i = 0;
		
		ENTER_DPLAYSVR();
		
        while (rval>0)
        {
	        // walk the receive list, dealing w/ all new sockets
			if (i >= gReceiveList.nConnections)
			{
				ASSERT(FALSE); // should never happen
				rval = 0; // just to be safe, reset
			}
            
            if (gReceiveList.pConnection[i].socket != INVALID_SOCKET)
            {
            	// see if it's in the set
                if (g_WSAFDIsSet(gReceiveList.pConnection[i].socket,(fd_set *)gReadfds.pfdbigset))
                {
                	if (0==i)
                	// we got a new connection
                	{
					    // accept any incoming connection
					    sSocket = g_accept(gReceiveList.pConnection[i].socket,&sockaddr,&addrlen);
					    if (INVALID_SOCKET == sSocket) 
					    {
					        err = g_WSAGetLastError();
				            DPF(0,"\n stream accept error - err = %d socket = %d BAILING",err,(DWORD)sSocket);
				            DPF(0, "\n !!! stream accept thread is going away - won't get reliable enum sessions anymore !!!");
				            ASSERT(FALSE);
				            LEAVE_DPLAYSVR();
							goto CLEANUP_EXIT;
					    }
					    DEBUGPRINTADDR(5,"stream - accepted connection from",&sockaddr);
		
						// add the new socket to our receive list
						hr = AddSocketToReceiveList(sSocket);
						if (FAILED(hr))
						{
							ASSERT(FALSE);
						}			
                	}
                	else
                	// socket has new data
                	{
						DPF(9, "Receiving on socket %d from ReceiveList", i);

    	            	// got one! this socket has something going on...
						hr = StreamReceive(&(gReceiveList.pConnection[i]));
            	        if (FAILED(hr))
                	    {
							DPF(1,"Stream Receive failed - hr = 0x%08lx\n",hr);
                    	}
                	}
                    rval--; // one less to hunt for
                } // IS_SET
            } // != INVALID_SOCKET

            i++;
                
   		} // while rval
		
		LEAVE_DPLAYSVR();
		
	} // while 1

CLEANUP_EXIT:

	EmptyConnectionList();
	DPF(5, "Stream receive thread exiting");
	    
    return 0;
    
} // ReceiveThreadProc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\buffer.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    BUFFER.H

Abstract:

	HEADER for buffers.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/30/97  aarono  Original
   2/17/98  aarono  changed memdesc to be len,ptr from ptr,len to align with sendex data.

--*/

#ifndef _BUFFER_H_
#define _BUFFER_H_
//
// Buffer is a descriptor for a chunk of data.
//

#include "bilink.h"

typedef struct _BUFFER {
	union {
		struct _BUFFER *pNext;		// Next buffer in chain
		BILINK BuffList;
	};	
	PUCHAR 		   pData;		// Data area of buffer
	UINT   		   len;         // length of data area
	DWORD          dwFlags;     // info about the data area
	PUCHAR         pCmdData;    // pointer past header to command data - used in receive path.
	DWORD          sequence;    // absolute sequence number
} BUFFER, *PBUFFER;

#define BFLAG_PROTOCOL		0x00000001	/* This buffer is for protocol information */
#define BFLAG_DOUBLE    	0x00000002	/* This buffer is a double buffer buffer   */
#define BFLAG_PROTHEADER	0x00000004  /* Room for the protocol header is at the head of the packet */
#define BFLAG_FRAME         0x00000008  /* From Frame allocator */

// PROTHEADER flag will only occur with packets that have the DOUBLE flag set 
// and only when the provider does not support multi-buffer sends and the 
// entire message and protocol header will fit in one media frame. - actually pretty often.

typedef struct _MEMDESC {
	UINT 	len;
	PUCHAR 	pData;
} MEMDESC, *PMEMDESC;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\bufmgr.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    BUFMGR.H

Abstract:

	Buffer Descriptor and Memory Manager for ARPD

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/13/97  aarono  Original

--*/

#ifndef _BUFMGR_H_
#define _BUFMGR_H_

#include "buffer.h"
#include "bufpool.h"

typedef struct _DoubleBuffer{
	union {
		BUFFER Buffer;
		struct {
			struct _DoubleBuffer *pNext;
			PVOID PAD;
			PCHAR pData;
			UINT  len;		    // length of data area used
			DWORD dwFlags;      // Packet flags, ownership and type of packet.
		};	
	};
	UINT  totlen;       // total length of data area
	UINT  tLastUsed;	// last tick count this was used
	CHAR  data[1];		// variable length data
} DOUBLEBUFFER, *PDOUBLEBUFFER;

	
VOID InitBufferManager(VOID);
VOID FiniBuffermanager(VOID);

PBUFFER GetDoubleBufferAndCopy(PMEMDESC, UINT);
VOID    FreeDoubleBuffer(PBUFFER);
PBUFFER BuildBufferChain(PMEMDESC, UINT);

VOID    FreeBufferChainAndMemory(PBUFFER); //works for either type
UINT    BufferChainTotalSize(PBUFFER);

#define GBF_ALLOC_MEM 0x00000001

// Don't pool more than 64K per channel.
#define MAX_CHANNEL_DATA 	65536
// Don't hold more than 3 free buffers per channel.
#define MAX_CHANNEL_BUFFERS 3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\dplaysvr\sources.inc ===
TARGETNAME=dplaysvr
TARGETTYPE=PROGRAM

TARGETPATH=obj

TARGETLIBS=$(SDK_LIB_PATH)\WINMM.LIB\
         $(SDK_LIB_PATH)\kernel32.lib \
         $(SDK_LIB_PATH)\user32.lib \
         $(SDK_LIB_PATH)\advapi32.lib \
         $(SDK_LIB_PATH)\comdlg32.lib \
         $(SDK_LIB_PATH)\gdi32.lib

UMTYPE=windows
UMENTRY=winmain

INCLUDES=..\..\..\inc; \
    ..\; \
    ..\..\wsock;\
    ..\..\..\misc;\
    ..\..\dplay;\
    ..\..\common; \
    ..\..\..\dplobby\dplobby; \
    ..\..\nmvoice

SOURCES= \
    ..\dplaysvr.c \
    ..\dphelp.c \
    ..\reliable.c \
    ..\dplaysvr.rc \
    memalloc.c \
    newdpf.c

NTTARGETFILE0=MISC

C_DEFINES=$(C_DEFINES) -DNO_DPF_HWND -DMSBUILD -DNEW_DPF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\command.h ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

	COMMAND.H

Abstract:


Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   3/14/97 aarono  Original

--*/

#ifndef _COMMAND_H_

#define _COMMAND_H_

#define REQUEST_PARAMS PPROTOCOL pProtocol, DPID idFrom, DPID idTo, PCMDINFO pCmdInfo, PBUFFER pSrcBuffer
#define MAX_COMMAND 0x06

typedef UINT (*COMMAND_HANDLER)(REQUEST_PARAMS);

UINT AssertMe(REQUEST_PARAMS);
UINT Ping(REQUEST_PARAMS);
UINT PingResp(REQUEST_PARAMS);
UINT GetTime(REQUEST_PARAMS);
UINT GetTimeResp(REQUEST_PARAMS);
UINT SetTime(REQUEST_PARAMS);
UINT SetTimeResp(REQUEST_PARAMS);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPlayProtocol"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\arpd.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ARPD.H

Abstract:

	Include file for Another Reliable Protocol internal, CPP version

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original

--*/

#ifndef _ARPD_H_
#define _ARPD_H_

typedef VOID (*PSEND_CALLBACK)(PVOID Context,UINT Status);

typedef struct _ASYNCSENDINFO {
	UINT            Reserved[4];
	HANDLE 			hEvent;			// Event to signal on send complete.
	PSEND_CALLBACK	SendCallBack;   // Callback to call on send complete.
	PVOID           CallBackContext;// Context for callback.
	PUINT			pStatus;        // place to put status on completion.
} ASYNCSENDINFO, *PASYNCSENDINFO;

#define SEND_STATUS_QUEUED			0x00000001
#define SEND_STATUS_TRANSMITTING	0x00000002
#define SEND_STATUS_FAILURE  		0x80000003
#define SEND_STATUS_SUCCESS			0x80000004

#endif //_ARPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\bufpool.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    BUFPOOL.H

Abstract:

	Header for buffer pool manager

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/30/97  aarono  Original

--*/

#ifndef _BUFPOOL_H_
#define _BUFPOOL_H_

#include <windows.h>
#include "buffer.h"

#define BUFFER_POOL_SIZE 16

//
// Buffer pools are allocated but only freed when the object is destroyed.
//

typedef struct _BUFFER_POOL {
	struct _BUFFER_POOL *pNext;
	BUFFER              Buffers[BUFFER_POOL_SIZE];
} BUFFER_POOL, *PBUFFER_POOL;


PBUFFER GetBuffer(VOID);
VOID FreeBuffer(PBUFFER);

VOID InitBufferPool(VOID);
VOID FiniBufferPool(VOID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\arpstruc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ARPSTRUC.H

Abstract:

	Structure definitions for the ARP protocol implementation

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/27/97  aarono  Original
   2/18/98  aarono  Added more fields to SEND for SendEx support
   6/6/98   aarono  Turn on throttling and windowing

--*/

#ifndef _ARPSTRUC_H_
#define _ARPSTRUC_H_

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include "arpd.h"
#include "bufpool.h"
#include "bilink.h"
#include "mydebug.h"
//#include "threads.h"

#define VOL volatile
//
// Information about sent packets, tracked for operational statistics.
//

#define SENDSTAT_SIGN SIGNATURE('S','T','A','T')

typedef struct PROTOCOL *PPROTOCOL;

typedef struct _SENDSTAT {
#ifdef SIGN
	UINT				Signature;		// Signature for SIGN
#endif
	union {
		BILINK	StatList;		// linked on Send and later SESSION.
		struct _SENDSTAT *pNext;
	};	
	UINT    messageid;   
	UINT    sequence;		// sequence number
	UINT    serial;			// serial number
	UINT    tSent;			// tick time when this packet instance sent.
	UINT    LocalBytesSent;     // number of bytes sent on session at send time.
	UINT    RemoteBytesReceived;// last remote byte report at send time.
	UINT    tRemoteBytesReceived; // remote timestamp when received.
	UINT    bResetBias;
} SENDSTAT, *PSENDSTAT;

#define SEND_SIGN SIGNATURE('S','E','N','D')

typedef enum _TRANSMITSTATE {
	Start=0,			// Never sent a packet.
	Sending=1,			// Thread to send is running and xmitting.
	Throttled=2,		// Waiting for send bandwidth.
	WaitingForAck=3,	// Timer running, listening for ACKs.
	WaitingForId=4,   	// Waiting for a Send Id.
	ReadyToSend=5,		// Have stuff to xmit, waiting for thread.
	TimedOut=6,       	// Retry timed out.
	Cancelled=7,        // User cancelled send.
	UserTimeOut=8,		// Didn't try to send until too late.
	Done=9				// Finished sending, singalled sender.
	
} TRANSMITSTATE;

struct _SESSION;

// this Send is an ACK or NACK (OR'ed into SEND.dwFlags)
#define 	ASEND_PROTOCOL 	0x80000000

#pragma pack(push,1)

typedef struct _SEND{

#ifdef SIGN
	UINT		     Signature;		    // Signature for SIGN
#endif
	CRITICAL_SECTION SendLock;          // Lock for Send Structure
VOL	UINT             RefCount;          // @#$%!
	
VOL	TRANSMITSTATE    SendState;			// State of this message's transmission.

	// Lists and Links...
	
	union {
		struct _SEND *pNext;			// linking on free pool
		BILINK		   SendQ;			// linking on session send queue
	};
	BILINK         m_GSendQ;			// Global Priority Queue
	BILINK         TimeoutList;			// List of sends waiting for timeout (workaround MMTIMER cancel bug).
	struct _SESSION *pSession;          // pointer to SESSIONion(gets a ref)

	PPROTOCOL      pProtocol;           // pointer to Protocol instance that created us.

	// Send Information
	
	DPID           idFrom;
	DPID           idTo;
	WORD           wIdTo;				// index in table
	WORD           wIdFrom;             // index in table
	UINT		   dwFlags;             // Send Flags (include reliable)
	PBUFFER		   pMessage;			// Buffer chain describing message.
	UINT           MessageSize;			// Total size of the message.
	UINT           FrameDataLen;        // Data area of each frame.
	UINT           nFrames;			    // Number of frames for this message.

	UINT           Priority;            // Send Priority.

	// User cancel and complete info
	DWORD          dwMsgID;             // message id given to user, for use in cancel.
	LPVOID         lpvUserMsgID;		// user's own identifier for this send.
	BOOL           bSendEx;             // called through SendEx.

	// Vars for reliability
	BOOL           fSendSmall;
VOL BOOL       	   fUpdate;             // update to NS,NR NACKMask made by receive.
	UINT		   messageid;			// Message ID number.
	UINT           serial;              // serial number.
VOL	UINT		   OpenWindow;          // Number of sends we are trying to get outstanding
VOL	UINT           NS;		        	// Sequence Sent.
VOL	UINT           NR;					// Sequence ACKED.
	UINT           SendSEQMSK; 			// Mask to use. - BUGBUG: determine speed at start
VOL	UINT           NACKMask;            // Bit pattern of NACKed frames.
	

	// These are the values at NR - updated by ACKs
VOL	UINT		   SendOffset;			// Current offset we are sending.
VOL	PBUFFER        pCurrentBuffer;  	// Current buffer being sent.
VOL	UINT           CurrentBufferOffset; // Offset in the current buffer of next packet.

	// info to update link characteristics when ACKs come in.
	
	BILINK         StatList;			// Info for packets already sent.
	DWORD          BytesThisSend;		// number of bytes being sent in the current packet.

	// Operational Characteristics

VOL	UINT_PTR       uRetryTimer;         
    UINT           TimerUnique;

	UINT           RetryCount;          // Number of times we retransmitted.
	UINT           WindowSize;          // Maximum Window Size.
	UINT           SAKInterval;         // interval (frames) at which a SAK is required.
	UINT           SAKCountDown;		// countdown to 0 from interval.
	UINT           tLastACK;            // Time we last got an ACK.

	UINT           dwSendTime;			// time we were called in send.
	UINT           dwTimeOut;			// timeout time.

	//BUGBUG:
	UINT           PacketSize;          // Size of packets to send.
	UINT           FrameSize;           // Size of Frames for this send.

	// Completion Vars
	HANDLE         hEvent;              // Event to wait on for internal send.
	UINT           Status;              // Send Completion Status.

	PASYNCSENDINFO pAsyncInfo;          // ptr to Info for completing Async send(NULL=>internal send)
	ASYNCSENDINFO  AsyncInfo;           // actual info (copied at send call).

	DWORD		   tScheduled;			// the time we scheduled the retry;
	DWORD          tRetryScheduled;     // expected retry timer run time.
VOL	BOOL           bCleaningUp;			// we are on the queue but don't take a ref pls.
} SEND, *PSEND;

#pragma pack(pop)

#define RECEIVE_SIGN SIGNATURE('R','C','V','_')


// Receive buffers are in reverse receive order.  When they have all
// been received, they are then put in proper order.
typedef struct _RECEIVE {
#ifdef SIGN
	UINT		    Signature;		// Signature for SIGN
#endif
	union {
		BILINK          pReceiveQ;
		struct _RECEIVE *      pNext;
	};	
	BILINK		    RcvBuffList;     // List of receive buffers that make up the message.

	CRITICAL_SECTION ReceiveLock;

	struct _SESSION *pSession;

VOL	BOOL            fBusy;		// Someone is moving this receive.
	BOOL            fReliable;		// Whether this is a reliable receive.
VOL	BOOL            fEOM;           // Whether we received the EOM bit.

	UINT            command;      
	
	UINT			messageid;
VOL	UINT			MessageSize;

VOL	UINT            iNR;			// Absolute index of first receiving packet (reliable only).
VOL	UINT            NR;				// Last in sequence packet received.
VOL	UINT            NS;				// Highest packet number received.
VOL	UINT            RCVMask;		// bitmask of received packets (NR relative)

	PUCHAR          pSPHeader;
	UCHAR           SPHeader[0];

} RECEIVE, *PRECEIVE;

#pragma pack(push,1)

typedef struct _CMDINFO {
	WORD        wIdTo;		// index
	WORD        wIdFrom;	// index
	DPID        idTo;		// actual DPID
	DPID        idFrom;		// actual DPID
	
	UINT        bytes;      // read from ACK.
	DWORD       tRemoteACK; // remote time remote ACKed/NACKed
	
	UINT        tReceived;  // timeGetTime() when received.
	UINT        command;
	UINT        IDMSK;
	USHORT      SEQMSK;
	USHORT      messageid;
	USHORT      sequence;
	UCHAR       serial;
	UCHAR		flags;
	PVOID       pSPHeader;  // used to issue a reply.
} CMDINFO, *PCMDINFO;

#pragma pack(pop)

//BUGBUG: when a SESSIONion hasn't been used in a long time and contains no pending sends/receives,
//        age it out.

#define SESSION_SIGN SIGNATURE('S','E','S','S')

// since we now have a full byte for messagid and sequenne in the small headers, 
// we no longer have an advantage for full headers until we apply the new
// bitmask package, then we must transit to large frame for windows > 127 messages.

#define MAX_SMALL_CSENDS 	 29UL			// Maximum Concurrent Sends when using small frame headers
#define MAX_LARGE_CSENDS	 29UL			// Maxinum Concurrent Sends when using large frame headers (could make larger except for mask bits)
#define MAX_SMALL_DG_CSENDS  16UL			// Maximum concurrent datagrams when using small frame     
#define MAX_LARGE_DG_CSENDS  16UL           // Maximum Concurrent datagrams when using large frames.
#define MAX_SMALL_WINDOW     24UL
#define MAX_LARGE_WINDOW     24UL

typedef enum _SESSION_STATE {
	Open,				// When created and Inited.
	Closing,			// Don't accept new receives/sends.
	Closed				// gone.
} SESSION_STATE;

#define SERVERPLAYER_INDEX 0xFFFE

#define SESSION_THROTTLED			0x00000001		// session throttle is on.
#define SESSION_UNTHROTTLED         0x00000002		// unthrottle is deffered to avoid confusing GetMessageQueue.

/////////////////////////////////////////////////////////////////
//
//	Transition Matrix for Throttle Adjust
// 
//  Initial State	Event:
//					No Drops	1 Drop		>1 Drop
//
//  Start			+ Start		- Meta      -- Start
//								
//  Meta			+ Meta      - Stable    -- Meta
//
//  Stable          + Stable    - Stable    -- Meta
//
//
//  Engagement of Backlog Throttle goes to MetaStable State.
///////////////////////////////////////////////////////////////////

#define METASTABLE_GROWTH_RATE      4
#define METASTABLE_ADJUST_SMALL_ERR	12
#define METASTABLE_ADJUST_LARGE_ERR 25

#define START_GROWTH_RATE      50
#define START_ADJUST_SMALL_ERR 25
#define START_ADJUST_LARGE_ERR 50

#define STABLE_GROWTH_RATE      2
#define STABLE_ADJUST_SMALL_ERR 12
#define STABLE_ADJUST_LARGE_ERR 25

typedef enum _ThrottleAdjustState
{
	Begin=0,		// At start, double until drop or backlog
	MetaStable=1,	// Meta stable, large deltas for drops
	Stable=2		// Stable, small deltas for drops
} eThrottleAdjust;

typedef struct _SESSION {
	PPROTOCOL        pProtocol;			    // back ptr to object.

#ifdef SIGN
	UINT		  	 Signature;			    // Signature for SIGN
#endif

	// Identification

	CRITICAL_SECTION SessionLock;           // Lock for the SESSIONion.
VOL	UINT             RefCount;			    // RefCount for the SESSION.
VOL	SESSION_STATE    eState;
	HANDLE           hClosingEvent;         // Delete waits on this during close.
	
	DPID			 dpid;					// The remote direct play id for this session.
	UINT             iSession;              // index in the session table
	UINT             iSysPlayer;            // index in session table of sys player.
											// BUGBUG: if iSysPlayer != iSession, then rest of struct not req'd.

	BILINK			 SendQ;					// Priority order sendQ;
	BOOL             fFastLink;				// set True when link > 50K/sec, set False when less than 10K/sec.
	BOOL             fSendSmall;            // Whether we are sending small reliable frames.
	BOOL             fSendSmallDG;          // Whether we are sending small datagram frames.

	BOOL             fReceiveSmall;
	BOOL             fReceiveSmallDG;
											
	UINT			 MaxPacketSize;			// Largest packet allowed on the media.

	// Operating parameters -- Send

	// Common
	
	UINT             MaxCSends;				// maximum number of concurrent sends
	UINT             MaxCDGSends;           // maximum number of concurrent datagram sends

	// Reliable

	UINT			 FirstMsg;				// First message number being transmitted
	UINT			 LastMsg;				// Last message number being transmitted
	UINT             OutMsgMask;            // relative to FirstMsg, unacked messages

	UINT             nWaitingForMessageid;  // number of sends on queue that can't start sending because they don't have an id.

	// DataGram


	UINT             DGFirstMsg;             // First message number being transmitted
	UINT             DGLastMsg;              // Last message number being transmitted
	UINT             DGOutMsgMask;           // relative to FirstMsg, not-fully sent messages.

	UINT             nWaitingForDGMessageid; // number of sends on queue that can't start sending because they don't have an id.

	// Send stats are tracked seperately since sends may
	// no longer be around when completions come in.
	
	//BILINK           OldStatList;		
	

	// Operating parameters -- Receive

	// DataGram Receive.
	BILINK           pDGReceiveQ;            // queue of ongoing datagram receives

	// Reliable Receive.
	BILINK	         pRlyReceiveQ;			 // queue of ongoing reliable receives
	BILINK           pRlyWaitingQ;           // Queue of out of order reliable receives waiting.
											 // only used when PROTOCOL_NO_ORDER not set.
	UINT             FirstRlyReceive;
	UINT             LastRlyReceive;
	UINT             InMsgMask;              // mask of fully received receives, relative to FirstRlyReceive
 

	// Operational characteristics - MUST BE DWORD ALIGNED!!! - this is because we read and write them
	//                               without a lock and assume the reads and writes are atomic (not in combination)

	UINT             WindowSize;            // Max outstanding packets on a send - reliable
	UINT             DGWindowSize;          // Max outstanding packets on a send - datagram
	
	UINT             MaxRetry;				// Usual max retries before dropping.
	UINT             MinDropTime;			// Min time to retry before dropping.
	UINT             MaxDropTime;			// After this time always drop.

	UINT             LocalBytesReceived;    // Total Data Bytes received (including retries).
VOL	UINT             RemoteBytesReceived;   // Last value from remote.
VOL	DWORD            tRemoteBytesReceived;  // Remote time last value received.

	UINT			 LongestLatency;		// longest observed latency (msec)
	UINT             ShortestLatency;		// shortest observed latency(msec)
	UINT             LastLatency;           // last observed latency (msec)
	
	UINT             FpAverageLatency;		// average latency          (msec 24.8) (128 samples)
	UINT             FpLocalAverageLatency;	// Local average latency    (msec 24.8) (16 samples)

	UINT             FpAvgDeviation;        // average deviation of latency. (msec 24.8) (128 samples)
	UINT             FpLocalAvgDeviation;   // average deviation of latency. (msec 24.8) (16 samples)

	UINT             Bandwidth;				// latest observed bandwidth (bps)
	UINT			 HighestBandwidth;      // highest observed bandwidth (bps)

	// we will use changes in the remote ACK delta to isolate latency in the send direction.
	UINT             RemAvgACKDelta;		// average clock delta between our send time (local time) and remote ACK time (remote time).
	UINT             RemAvgACKDeltaResidue;
	UINT             RemAvgACKBias;			// This value is used to pull the clock delta into a safe range (not near 0 or -1)
											// that won't risk hitting the wraparound when doing calculations

	// Throttle statistics
	DWORD			 dwFlags;               // Session Flags - currently just "throttle on/off"(MUST STAY THIS WAY)
	UINT			 SendRateThrottle;	    // current rate (bps) at which we are throttling.
	DWORD            bhitThrottle;          // we hit a throttle
	DWORD            tNextSend;				// when we are allowed to send again.
	DWORD            tNextSendResidue;		// residual from calculating next send time
	DWORD_PTR		 uUnThrottle;
	DWORD            UnThrottleUnique;
	DWORD            FpAvgUnThrottleTime;   // (24.8) how late Unthrottle usually called. (throttle when send is this far ahead)
											// last 16 samples, start at 5 ms.

	DWORD            tLastSAK;				// last time we asked for an ACK

	CRITICAL_SECTION SessionStatLock;        // [locks this section ------------------------------------------- ]
	BILINK           DGStatList;             // [Send Statistics for Datagrams (for reliable they are on Sends) ]
	DWORD            BytesSent;				 // [Total Bytes Sent to this target                                ]
	DWORD			 BytesLost;				 // [Total Bytes Lost on the link.							 		]
	DWORD            bResetBias;             // [Counts down to reset latency bias								]
											 // [---------------------------------------------------------------]

	eThrottleAdjust  ThrottleState;			// ZEROINIT puts in Start
	DWORD            GrowCount;				// number of times we grew in this state
	DWORD            ShrinkCount;			// number of times we shrank in this state
	DWORD            tLastThrottleAdjust;   // remember when we last throttled to avoid overthrottling.
} SESSION, *PSESSION;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\macros.h ===
#define Lock(_a) EnterCriticalSection(_a)
#define Unlock(_a) LeaveCriticalSection(_a)
#define CreateSem(_Initial)	CreateSemaphoreA(NULL,(_Initial),-1,NULL) 
#define DestroySem(_hSem)   CloseHandle((_hSem))
#define Wait(_A) 			WaitForSingleObject((_A),0xFFFFFFFF)
#define Signal(_A) 			ReleaseSemaphore((_A), 1, NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\arpdint.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ARPDINT.H

Abstract:

	Include file for Another Reliable Protocol internal.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
   2/16/98 aarono  Don't patch for Protocol, DPLAY now calls direct.
   6/6/98  aarono  Turn on throttling and windowing

--*/

#ifndef _ARPDINT_H_

#define _ARPDINT_H_

#include <dplay.h>
#include "arpd.h"
#include "bilink.h"
#include "arpstruc.h"
#include "protocol.h"
#include "bufmgr.h"
#include "handles.h"

// Macros for converting too and from 24.8 fixed point.
#define Fp(_x) ((_x)<<8)
#define unFp(_x)((_x)>>8)

typedef enum _PROTOCOL_State {
	Initializing=1,
	Running,
	ShuttingDown,
	ShutDown
} PROTOCOL_State;

#define MAX_THREADS 16

typedef struct PROTOCOL {
		//
		// Service Provider info - at top so DPLAY can access easily through protocol ptr.
		//
		IDirectPlaySP   * m_lpISP;      	       	 	//  used by SP to call back into DirectPlay 

		DWORD             m_dwSPMaxFrame;
		DWORD             m_dwSPMaxGuaranteed;
		DWORD             m_dwSPHeaderSize;
		CRITICAL_SECTION  m_SPLock;						// lock calls to SP on our own, avoids deadlocks.

		//
		// Protocol Info
		//
		
		UINT 	  	  	  m_cRef;		// Refcount.
		CRITICAL_SECTION  m_ObjLock;	// lock for this object.
		PROTOCOL_State    m_eState;		// State of object

		LPDPLAYI_DPLAY    m_lpDPlay;	// backpointer to DPLAY object.

		// Handle Table
		VOLLPMYHANDLETABLE lpHandleTable;
		CRITICAL_SECTION   csHandleTable;

		// Cached DPLAY info.
		DWORD             m_dwIDKey;    // to unlock DPID's
		
		//
		// Threads
		//
		HANDLE            m_hSendThread[MAX_THREADS];	// send thread handles (0->nSendThreads)
		DWORD             m_dwSendThreadId[MAX_THREADS];// send thread ids (0->nSendThreads)
		UINT              m_nSendThreads;				// number of send threads.
		HANDLE            m_hSendEvent;                 // kick send until nothing to send.

		//
		// Multi-media timer capabilities
		//
		TIMECAPS          m_timecaps;					// {.wPeriodMin .wPeriodMax (ms)}

		//
	    // SESSIONion Handles
	    //
		CRITICAL_SECTION  m_SessionLock;
		UINT              m_nSessions;
		UINT              m_SessionListSize;
		PSESSION          (*m_pSessions)[];
		PSESSION          m_pServerPlayerSession;		// Short circuit to index 0xFFFE
		
		//
		// Priority Queue
		//
		DWORD             m_dwBytesPending;
		DWORD             m_dwMessagesPending;
		CRITICAL_SECTION  m_SendQLock;         			// Locks the Priority Queue.
		BILINK            m_GSendQ;						// Packet Queue in priority order.
		BOOL              m_bRescanQueue;               // Used for force GetNextMessageToSend to restart

		
		CRITICAL_SECTION  m_RcvQLock;           		// All completed receives lock. (locks on SESSION too).
		BILINK            m_GlobalRcvQ;					// All receives queued here, (also on each session).


		//
		// Receive Descriptor Management - per instance because of SPHeader length.
		//
		
		PRECEIVE 		 pRcvDescPool;
		UINT             nRcvDescsAllocated;	// Number Allocated
		UINT             nRcvDescsInUse;		// Number currently in use
		UINT             nMaxRcvDescsInUse;     // Maximum number in use since last TICK.

		CRITICAL_SECTION RcvDescLock;
		
		LONG fInRcvDescTick;					

} PROTOCOL, *PPROTOCOL;

// PROTOCOL.C
HRESULT WINAPI ProtocolSend(LPDPSP_SENDDATA pSendData);
HRESULT WINAPI ProtocolCreatePlayer(LPDPSP_CREATEPLAYERDATA pCreatePlayerData);
HRESULT WINAPI ProtocolDeletePlayer(LPDPSP_DELETEPLAYERDATA pDeletePlayerData);
HRESULT WINAPI ProtocolGetCaps(LPDPSP_GETCAPSDATA pGetCapsData);
HRESULT WINAPI ProtocolShutdown(void);
HRESULT WINAPI ProtocolShutdownEx(LPDPSP_SHUTDOWNDATA pShutdownData);

//
// SENDPOOL.CPP
//
VOID  InitSendDescs(VOID);
VOID  FiniSendDescs(VOID);
PSEND GetSendDesc(VOID);
VOID  ReleaseSendDesc(PSEND pSend);

//
// STATPOOL.CPP
//
VOID InitSendStats(VOID);
VOID FiniSendStats(VOID);
PSENDSTAT GetSendStat(VOID);
VOID ReleaseSendStat(PSENDSTAT pSendStat);

//
// RCVPOOL.CPP
//
VOID InitRcvDescs(PPROTOCOL pProtocol);
VOID FiniRcvDescs(PPROTOCOL pProtocol);
PRECEIVE GetRcvDesc(PPROTOCOL pProtocol);
VOID ReleaseRcvDesc(PPROTOCOL pProtocol, PRECEIVE pReceive);

// FRAMEBUF.CPP BUGBUG: smarter manager
VOID InitFrameBuffers(VOID);
VOID FiniFrameBuffers(VOID);
VOID FreeFrameBuffer(PBUFFER pBuffer);
PBUFFER GetFrameBuffer(UINT MaxFrame);
VOID ReleaseFrameBufferMemory(PUCHAR pFrame);

// SEND.C
VOID UpdateSendTime(PSESSION pSession, DWORD Len, DWORD tm, BOOL fAbsolute);
HRESULT SendHandler(PPROTOCOL pProt);
VOID BuildHeader(PSEND pSend, pPacket1 pFrame, UINT shift, DWORD tm);
ULONG WINAPI SendThread(LPVOID pProt);
INT IncSendRef(PSEND pSend);
INT DecSendRef(PPROTOCOL pProt, PSEND pSend);
BOOL AdvanceSend(PSEND pSend, UINT FrameDataLen);
VOID CancelRetryTimer(PSEND pSend);
VOID DoSendCompletion(PSEND pSend, INT Status);

HRESULT Send(
	PPROTOCOL      pProtocol,
	DPID           idFrom, 
	DPID           idTo, 
	DWORD          dwSendFlags, 
	LPVOID         pBuffers,
	DWORD          dwBufferCount, 
	DWORD          dwSendPri,
	DWORD          dwTimeOut,
	LPVOID         lpvUserID,
	LPDWORD        lpdwMsgID,
	BOOL           bSendEx,		// called from SendEx.
	PASYNCSENDINFO pAsyncInfo
	);
	
HRESULT ISend(
	PPROTOCOL pProtocol,
	PSESSION pSession, 
	PSEND    pSend
	);

HRESULT QueueSendOnSession(
	PPROTOCOL pProtocol, PSESSION pSession, PSEND pSend
);

UINT CopyDataToFrame(
	PUCHAR  pFrameData, 
	UINT    FrameDataLen,
	PSEND   pSend,
	UINT    nAhead);

ULONG WINAPI SendThread(LPVOID pProt);
HRESULT ReliableSend(PPROTOCOL pProtocol, PSEND pSend);
BOOL AdvanceSend(PSEND pSend, UINT AckedLen);
HRESULT DGSend(PPROTOCOL pProtocol, PSEND  pSend);
BOOL DGCompleteSend(PSEND pSend);
HRESULT SystemSend(PPROTOCOL pProtocol, PSEND  pSend);
PSEND GetNextMessageToSend(PPROTOCOL pProtocol);
VOID TimeOutSession(PSESSION pSession);
INT AddSendRef(PSEND pSend, UINT count);

extern CRITICAL_SECTION g_SendTimeoutListLock;
extern BILINK g_BilinkSendTimeoutList;

//RECEIVE.C
UINT CommandReceive(PPROTOCOL pProt, CMDINFO *pCmdInfo, PBUFFER pBuffer);
VOID ProtocolReceive(PPROTOCOL pProtocol, WORD idFrom, WORD idTo, PBUFFER pRcvBuffer, LPVOID pvSPHeader);
VOID FreeReceive(PPROTOCOL pProtocol, PRECEIVE pReceive);
VOID InternalSendComplete(PVOID Context, UINT Status);

//SESSION.C
LPDPLAYI_PLAYER pPlayerFromId(PPROTOCOL pProtocol, DPID idPlayer);
HRESULT	CreateNewSession(PPROTOCOL pProtocol, DPID idPlayer);
PSESSION GetSession(PPROTOCOL pProtocol, DPID idPlayer);
PSESSION GetSysSession(PPROTOCOL pProtocol, DPID idPlayer);
PSESSION GetSysSessionByIndex(PPROTOCOL pProtocol, DWORD index);
DPID GetDPIDByIndex(PPROTOCOL pProtocol, DWORD index);
WORD GetIndexByDPID(PPROTOCOL pProtocol, DPID dpid);
INT DecSessionRef(PSESSION pSession);

//BUFGMGR.C
VOID InitBufferManager(VOID);
VOID FiniBufferManager(VOID);
UINT MemDescTotalSize(PMEMDESC pMemDesc, UINT nDesc);
PDOUBLEBUFFER GetDoubleBuffer(UINT nBytes);
PBUFFER GetDoubleBufferAndCopy(PMEMDESC pMemDesc, UINT nDesc);
VOID FreeDoubleBuffer(PBUFFER pBuffer);
PBUFFER BuildBufferChain(PMEMDESC pMemDesc, UINT nDesc);
VOID FreeBufferChain(PBUFFER pBuffer);
VOID FreeBufferChainAndMemory(PBUFFER pBuffer);
UINT BufferChainTotalSize(PBUFFER pBuffer);

//STATS.C
VOID InitSessionStats(PSESSION pSession);
VOID UpdateSessionStats(PSESSION pSession, PSENDSTAT pStat, PCMDINFO pCmdInfo, BOOL fBadDrop);
VOID UpdateSessionSendStats(PSESSION pSession, PSEND pSend, PCMDINFO pCmdInfo, BOOL fBadDrop);


#define SAR_FAIL 0
#define SAR_ACK  1
#define SAR_NACK 2
UINT SendAppropriateResponse(PPROTOCOL pProt, PSESSION pSession, CMDINFO *pCmdInfo, PRECEIVE pReceive);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\mydebug.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mydebug.c
 *  Content:	debugging printf - stolen from direct draw.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	  Reason
 *   ====	==	  ======
 *         aarono splurp.
 *  6/6/98 aarono Debug support for link statistics
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "newdpf.h"
#include "mydebug.h"
#include "bilink.h"
#include <stdarg.h>

#ifdef DEBUG

typedef struct _MEM_BLOCK {
	union {
		BILINK Bilink;
		struct _FB {
			struct _MEM_BLOCK *pNext;
			struct _MEM_BLOCK *pPrev;
		} FB;
	};	
	UINT len;
	UINT tmAlloc;
	CHAR data[4];
} MEM_BLOCK, *PMEM_BLOCK;

LONG TotalMem = 0;

struct _MEMLIST {
	union{
		BILINK Bilink;
		struct _FB FB;
	};
} MemList={(BILINK *)&MemList,(BILINK *)&MemList};

UINT nInit=0xFFFFFFFF;
CRITICAL_SECTION MEM_CS;

VOID My_GlobalAllocInit()
{
	if(!InterlockedIncrement(&nInit)){
		InitializeCriticalSection(&MEM_CS);
	}
}

VOID My_GlobalAllocDeInit()
{
	if(InterlockedDecrement(&nInit)&0x80000000){
		DeleteCriticalSection(&MEM_CS);
	}
}

HGLOBAL
My_GlobalAlloc(
    UINT uFlags,
    DWORD dwBytes
    )
{
	PMEM_BLOCK pMem;

	UINT lTotalMem;

	pMem=(PMEM_BLOCK)GlobalAlloc(uFlags,dwBytes+sizeof(MEM_BLOCK)-4);
	pMem->len=dwBytes;
	pMem->tmAlloc=GetTickCount();
	
	EnterCriticalSection(&MEM_CS);
	InsertAfter(&pMem->Bilink, &MemList.Bilink);
	TotalMem+=dwBytes;
	lTotalMem=TotalMem;
	LeaveCriticalSection(&MEM_CS);

	DPF(9,"GlobalAlloc: Allocated %d TotalMem %d\n",dwBytes, lTotalMem);
	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_USER2=lTotalMem;
		DbgWriteStats(&InWS);
	}

	return((HGLOBAL)&pMem->data[0]);
}

HGLOBAL
My_GlobalFree(
    HGLOBAL hMem
    )
{
	PUCHAR pData=(PUCHAR)(hMem);
	PMEM_BLOCK pMem;
	UINT lTotalMem;
	UINT dwBytes;

	pMem=CONTAINING_RECORD(pData, MEM_BLOCK, data);
	EnterCriticalSection(&MEM_CS);
	Delete(&pMem->Bilink);
	TotalMem-=pMem->len;
	dwBytes=pMem->len;
	lTotalMem=TotalMem;
	LeaveCriticalSection(&MEM_CS);
	DPF(9,"GlobalFree: Freed %d TotalMem %d\n",dwBytes,lTotalMem);
	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_USER2=lTotalMem;
		DbgWriteStats(&InWS);
	}
	return GlobalFree(pMem);
}

#endif /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\mydebug.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mydebug.h
 ***************************************************************************/
#ifndef __MYDEBUG_H__
#define __MYDEBUG_H__


#ifdef DEBUG
HGLOBAL
My_GlobalAlloc(
    UINT uFlags,
    DWORD dwBytes
    );

HGLOBAL
My_GlobalFree(
    HGLOBAL hMem
    );
#else 
#define My_GlobalAlloc(_a,_b) GlobalAlloc(_a,_b)
#define My_GlobalFree(_a) GlobalFree(_a)
#endif


#define SIGNATURE(a,b,c,d) (UINT)(a+(b<<8)+(c<<16)+(d<<24))

#ifdef DEBUG
	#define SIGN 1
	#define ASSERT_NACKMask(_a) \
	if(pSend->OpenWindow && ((_a)->NACKMask & (0xFFFFFFFF-((1<<(((_a)->OpenWindow)))-1)) ) ){ \
		DPF(0,"pSend %x OpenWindow %d NACKMask %x",pSend,pSend->OpenWindow, pSend->NACKMask);\
		DEBUG_BREAK(); \
	} else if (!(_a)->OpenWindow && (_a)->NACKMask){ \
		DPF(0,"pSend %x OpenWindow %d NACKMask %x",pSend,pSend->OpenWindow, pSend->NACKMask);\
		DEBUG_BREAK(); \
	} 
#else
	#define ASSERT_NACKMask(_a)
#endif

#ifdef SIGN
	#define SET_SIGN(a,b) ((a)->Signature=(b))
	#define UNSIGN(a) ((a)|=0x20202020);
//	#define ASSERT_SIGN(a,b) ASSERT((((UINT)(a)->Signature))==((UINT)(b)))
	#define ASSERT_SIGN(a,b) if(!((((UINT)(a)->Signature))==((UINT)(b))))DEBUG_BREAK();


#else
	#define UNSIGN(a)
	#define SET_SIGN(a,b)
	#define ASSERT_SIGN(a,b)
#endif

#ifdef DEBUG
	#if !defined(ASSERT)
		#define ASSERT DDASSERT
	#endif
#endif

#endif /* __MYDEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\handles.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    HANDLES.C

Abstract:

	Handle Manager

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   2/16/98 aarono  Original
   6/6/98  aarono  debug support, use My_GlobalAlloc


--*/

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"
#include "handles.h"

VOLLPMYHANDLETABLE InitHandleTable(UINT nSize, CRITICAL_SECTION *pcs, UINT nUserGrowSize)
{
	LPMYHANDLETABLE lpTable;
	UINT nGrowSize;
	UINT i;

	if(nUserGrowSize){
		nGrowSize=nUserGrowSize;
	} else {
		nGrowSize=MYHANDLE_DEFAULT_GROWSIZE;
	}

	lpTable=(LPMYHANDLETABLE)My_GlobalAlloc(GPTR, sizeof(MYHANDLETABLE)+(sizeof(MYHANDLE)*nSize));

	if(lpTable){
		if(pcs){
			InitializeCriticalSection(pcs);
		}
	
		lpTable->nUnique=UNIQUE_ADD;
		lpTable->nTableSize=nSize;
		lpTable->nTableGrowSize=nGrowSize;

		lpTable->iNext=0;
		for(i=0;i < nGrowSize-1; i++){
			lpTable->Table[i].iNext=i+1;
		}
		lpTable->Table[nGrowSize-1].iNext = LIST_END;
	}

	return lpTable;
}

VOID FiniHandleTable(LPMYHANDLETABLE lpTable, CRITICAL_SECTION *pcs)
{
	My_GlobalFree(lpTable);
	if(pcs){
		DeleteCriticalSection(pcs);
	}	
}

DWORD AllocHandleTableEntry(LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, LPVOID lpv)
{
	#define lpTable (*lplpTable)

	UINT i;
	LPMYHANDLETABLE lpNewTable;

	if(pcs){
		EnterCriticalSection(pcs);
	}

	if(lpTable->iNext==LIST_END){
		// grow the table.
		lpNewTable=(LPMYHANDLETABLE)My_GlobalAlloc(GPTR, sizeof(MYHANDLETABLE)+
					((lpTable->nTableGrowSize+lpTable->nTableSize)*sizeof(MYHANDLE)));

		if(!lpNewTable){
			return 0;
		}
		memcpy(lpNewTable, lpTable, (lpTable->nTableSize*sizeof(MYHANDLE))+sizeof(MYHANDLETABLE));

		lpNewTable->iNext=lpNewTable->nTableSize;
		lpNewTable->nTableSize=lpNewTable->nTableSize+lpNewTable->nTableGrowSize;

		for(i=lpNewTable->iNext ; i < lpNewTable->nTableSize-1 ; i++){
			lpNewTable->Table[i].iNext=i+1;
		}
		lpNewTable->Table[lpNewTable->nTableSize-1].iNext = LIST_END;
		
		*lplpTable=lpNewTable;
	}

	i=lpTable->iNext;
	lpTable->iNext=lpTable->Table[i].iNext;

	// increment uniqueness, never zero.
	do {
		lpTable->nUnique += UNIQUE_ADD;
	} while (!lpTable->nUnique);

	lpTable->Table[i].nUnique=lpTable->nUnique;
	lpTable->Table[i].lpv=lpv;

	if(pcs) {
		LeaveCriticalSection(pcs);
	}

	ASSERT((i+lpTable->Table[i].nUnique & CONTEXT_INDEX_MASK) == i);

	return i+lpTable->Table[i].nUnique;	

	#undef lpTable
}

LPVOID ReadHandleTableEntry( LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, UINT handle)
{
	#define lpTable (*lplpTable)

	UINT i;
	UINT nUnique;
	LPVOID lpv;

	if(handle){

		if(pcs){
			EnterCriticalSection(pcs);
		}	

		i = handle & CONTEXT_INDEX_MASK;
		nUnique = handle - i;

		if(i < lpTable->nTableSize && nUnique == lpTable->Table[i].nUnique){
			lpv = lpTable->Table[i].lpv;
		} else {
			lpv = NULL;
		}
		
		if(pcs){
			LeaveCriticalSection(pcs);
		}	
		
	} else {
	
		lpv=NULL;

	}

	return lpv;

	#undef lpTable
}

HRESULT FreeHandleTableEntry(LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, UINT handle)
{
	#define lpTable (*lplpTable)

	HRESULT hr=DP_OK;
	UINT i;
	UINT nUnique;

	if(handle){

		if(pcs){
			EnterCriticalSection(pcs);
		}	

		i = handle & CONTEXT_INDEX_MASK;
		nUnique = handle - i;

		if(i < lpTable->nTableSize && nUnique == lpTable->Table[i].nUnique){
			lpTable->Table[i].iNext = lpTable->iNext;
			lpTable->iNext=i;
		} else {
			hr = DPERR_GENERIC;
			DPF(0,"FreeHandleTableEntry, ERROR, TRIED TO FREE INVALID HANDLE %x",handle);
			ASSERT(0);
		}

		if(pcs){
			LeaveCriticalSection(pcs);
		}	

	} else {
		hr=DPERR_GENERIC;
	}
	return hr;

	#undef lpTable
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\bufpool.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    BUFPOOL.C

Abstract:

	Manages a pool of BUFFER descriptors (BUFFERS)
	16 at a time are allocated.  They are not freed until
	shutdown.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/27/97  aarono  Original

--*/

#include <windows.h>
#include "newdpf.h"
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "bufpool.h"
#include "macros.h"
#include "mydebug.h"

CRITICAL_SECTION BufferPoolLock;
PBUFFER_POOL pBufferPoolList;
PBUFFER      pBufferFreeList;

VOID InitBufferPool(VOID)
{
	pBufferPoolList=NULL;
	pBufferFreeList=NULL;
	InitializeCriticalSection(&BufferPoolLock);
}

VOID FiniBufferPool(VOID)
{
	PBUFFER_POOL pNextBufPool;
	while(pBufferPoolList){
		pNextBufPool=pBufferPoolList->pNext;
		My_GlobalFree(pBufferPoolList);
		pBufferPoolList=pNextBufPool;
	}
	DeleteCriticalSection(&BufferPoolLock);
}

PBUFFER GetBuffer(VOID)
{
	PBUFFER 	 pBuffer=NULL;
	PBUFFER_POOL pBufferPool;
	UINT i;

Top:
	//BUGBUG: out of interest track allocated/free buffers.
	if(pBufferPoolList){
	
		Lock(&BufferPoolLock);
		
		if(pBufferFreeList){
			pBuffer=pBufferFreeList;
			pBufferFreeList=pBuffer->pNext;
		} 
		
		Unlock(&BufferPoolLock);
		
		if(pBuffer){
			return pBuffer;
		}	
	} 
	
	pBufferPool=(PBUFFER_POOL)My_GlobalAlloc(GMEM_FIXED, sizeof(BUFFER_POOL));
	
	if(pBufferPool){

		// link the buffers into a chain.
		for(i=0;i<BUFFER_POOL_SIZE-1;i++){
			pBufferPool->Buffers[i].pNext=&pBufferPool->Buffers[i+1];
		}
		
		Lock(&BufferPoolLock);

		// link the pool on the pool list.
		pBufferPool->pNext=pBufferPoolList;
		pBufferPoolList=pBufferPool;

		// link the buffers on the buffer list.
		pBufferPool->Buffers[BUFFER_POOL_SIZE-1].pNext=pBufferFreeList;
		pBufferFreeList=&pBufferPool->Buffers[0];
		
		Unlock(&BufferPoolLock);
		
		goto Top;
		
	} else {
		ASSERT(0); //TRACE ALL PATHS
	
		return NULL;
		
	}
}

VOID FreeBuffer(PBUFFER pBuffer)
{
	Lock(&BufferPoolLock);
	pBuffer->pNext=pBufferFreeList;
	pBufferFreeList=pBuffer;
	Unlock(&BufferPoolLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\bufmgr.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    BUFMGR.C

Abstract:

	Buffer Descriptor and Memory Manager

Author:

	Aaron Ogus (aarono)

Environment:
	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/13/97  aarono  Original

--*/

#include <windows.h>
#include "newdpf.h"
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "arpdint.h"
#include "bufmgr.h"
#include "mydebug.h"
#include "macros.h"
		
CRITICAL_SECTION DoubleBufferListLock;
PDOUBLEBUFFER	 pDoubleBufferList;
UINT   			 nDoubleBuffers;
UINT			 cbDoubleBuffers;

VOID InitBufferManager(VOID)
{
	pDoubleBufferList=NULL;
	nDoubleBuffers=0;
	cbDoubleBuffers=0;
	InitializeCriticalSection(&DoubleBufferListLock);
}

VOID FiniBufferManager(VOID)
{
	PDOUBLEBUFFER pDoubleBuffer = pDoubleBufferList;
	
	while(pDoubleBuffer){
		pDoubleBufferList=pDoubleBuffer->pNext;
		My_GlobalFree(pDoubleBuffer);
		pDoubleBuffer=pDoubleBufferList;
	}

	DeleteCriticalSection(&DoubleBufferListLock);
}

UINT MemDescTotalSize(PMEMDESC pMemDesc, UINT nDesc)
{
	UINT i;
	UINT cbTotalSize=0;

	for(i=0 ; i < nDesc ; i++){
		cbTotalSize+=pMemDesc->len;
		pMemDesc++;
	}
	
	return cbTotalSize;
}

// Actually get the memory block or allocate it.
PDOUBLEBUFFER GetDoubleBuffer(UINT TotalMessageSize)
{
	PDOUBLEBUFFER pDoubleBuffer=NULL;
	// First Check the FreeList for a buffer of the appropriate size.

	if(nDoubleBuffers && (cbDoubleBuffers >= TotalMessageSize)){
	
		PDOUBLEBUFFER pPrevBuffer, pCurrentBuffer;
		UINT nAllowedWaste=TotalMessageSize >> 2;
		
		Lock(&DoubleBufferListLock);

			// Search for best fit packet.  Cannot be more than 25% larger
			// than the actual required size.
			pPrevBuffer = (PDOUBLEBUFFER)&pDoubleBufferList;
			pCurrentBuffer = pPrevBuffer->pNext;
			
			while(pCurrentBuffer){
			
				if(pCurrentBuffer->totlen >= TotalMessageSize){
				
					if(pCurrentBuffer->totlen-TotalMessageSize < nAllowedWaste){
						// We have a winner, relink list over this buffer.
						pPrevBuffer->pNext = pCurrentBuffer->pNext;
						pDoubleBuffer = pCurrentBuffer;
						nDoubleBuffers--;
						cbDoubleBuffers-=pCurrentBuffer->totlen;
						break;
					}
					
				}
				pPrevBuffer = pCurrentBuffer;
				pCurrentBuffer = pCurrentBuffer->pNext; 
			}
		
		Unlock(&DoubleBufferListLock);
	}

	if(!pDoubleBuffer){
		// No Buffer Found on the FreeList, so allocate one.
		pDoubleBuffer=(PDOUBLEBUFFER)My_GlobalAlloc(GMEM_FIXED,TotalMessageSize+sizeof(DOUBLEBUFFER));
		
 		if(!pDoubleBuffer){
 			// couldn't allocate... out of memory.
 			DPF(0,"COULDN'T ALLOCATE DOUBLE BUFFER TO INDICATE RECEIVE, SIZE: %x\n",TotalMessageSize+sizeof(DOUBLEBUFFER));
 			ASSERT(0);
 			goto exit;
 		}
 		pDoubleBuffer->totlen = TotalMessageSize;
		pDoubleBuffer->dwFlags=BFLAG_DOUBLE; // double buffer buffer.
//	pDoubleBuffer->tLastUsed=GetTickCount(); only relevant when put back on list... throw this out??
	}
	
	pDoubleBuffer->pNext =  NULL;
	pDoubleBuffer->pData  = (PCHAR)&pDoubleBuffer->data;
	pDoubleBuffer->len	  = TotalMessageSize;
	
exit:
	return pDoubleBuffer;
}
/*++

	Double Buffer Management strategy.

	When the system needs to allocate buffers locally, it does it on a per
	channel basis.  A buffer of exactly the requested size is allocated and
	used to buffer the data.   When the buffer is done with, it is put on 
	the DoubleBufferList which caches the last few allocations.  Since
	most clients tend to use the same size packet over and over, this saves
	the time it takes to call GlobalAlloc and My_GlobalFree for every send.

	Aging out entries:  Every 15 seconds, a timer goes off and the system
	checks the age of each buffer on the DoubleBufferList.  Any entry 
	that has not been used in the last 15 seconds is actually freed.

	There is also a cap on the size of allocations allowed for the entire
	free list.  It never exceeds 64K.  If it does, oldest entries are 
	thrown out until the free list is less than 64K.

--*/

PBUFFER GetDoubleBufferAndCopy(PMEMDESC pMemDesc, UINT nDesc)
{
	
	UINT i;
	UINT TotalMessageSize;
	UINT WriteOffset;
	PDOUBLEBUFFER pDoubleBuffer=NULL;

	// Calculate the total size of the buffer
	TotalMessageSize=MemDescTotalSize(pMemDesc, nDesc);

	pDoubleBuffer=GetDoubleBuffer(TotalMessageSize);

	if(!pDoubleBuffer){
		goto exit;
	}

	// Scatter Gather Copy to Contiguous Local Buffer
	WriteOffset=0;
	
	for(i=0 ; i < nDesc ; i++){
		memcpy(&pDoubleBuffer->data[WriteOffset], pMemDesc->pData, pMemDesc->len);
		WriteOffset+=pMemDesc->len;
		pMemDesc++;
	}

exit:
	return (PBUFFER)pDoubleBuffer;
	
}

VOID FreeDoubleBuffer(PBUFFER pBuffer)
{
	PDOUBLEBUFFER pDoubleBuffer=(PDOUBLEBUFFER) pBuffer;
	PDOUBLEBUFFER pBufferWalker, pLargestBuffer;

	//
	// Put the local buffer on the free list.
	//
	
	pDoubleBuffer->tLastUsed = GetTickCount();
	
	Lock(&DoubleBufferListLock);

	pDoubleBuffer->pNext  = pDoubleBufferList;
	pDoubleBufferList 	  = pDoubleBuffer;
	cbDoubleBuffers      += pDoubleBuffer->totlen;
	nDoubleBuffers++;

	Unlock(&DoubleBufferListLock);


	//
	// If the free list is too large, trim it
	//

	while(cbDoubleBuffers > MAX_CHANNEL_DATA || nDoubleBuffers > MAX_CHANNEL_BUFFERS){

		Lock(&DoubleBufferListLock);

		if(cbDoubleBuffers > MAX_CHANNEL_DATA || nDoubleBuffers > MAX_CHANNEL_BUFFERS){

			//
			// Free the largest buffer.
			//

			pLargestBuffer=pDoubleBufferList;
			pBufferWalker=pLargestBuffer->pNext;

			// Find the largest buffer.
			while(pBufferWalker){
				if(pBufferWalker->totlen > pLargestBuffer->totlen){
					pLargestBuffer=pBufferWalker;
				}
				pBufferWalker=pBufferWalker->pNext;
			}

			//
			// Remove the largest buffer from the list
			//

			// Find previous element - sneaky, since ptr first in struct, 
			// take addr of list head.

			pBufferWalker=(PDOUBLEBUFFER)&pDoubleBufferList;
			while(pBufferWalker->pNext != pLargestBuffer){
				pBufferWalker=pBufferWalker->pNext;
			}

			// link over the largest buffer
			pBufferWalker->pNext=pLargestBuffer->pNext;

			// update object buffer information
			cbDoubleBuffers -= pLargestBuffer->totlen;
			nDoubleBuffers--;
			
			DPF(9,"Freeing Double Buffer Memory %x\n",pLargestBuffer->totlen);
			
			Unlock(&DoubleBufferListLock);

			My_GlobalFree(pLargestBuffer);

		}	else {
		
			Unlock(&DoubleBufferListLock);

		}
			
	}

	DPF(9,"Total Free Double Buffer Memory %x\n",cbDoubleBuffers);

}

PBUFFER BuildBufferChain(PMEMDESC pMemDesc, UINT nDesc)
{
	UINT i;
	PBUFFER pBuffer=NULL,pLastBuffer=NULL;

	ASSERT(nDesc);

	if(!nDesc){
		goto exit;
	}
	
	// walk backward through the array, allocating and linking
	// the buffers.

	i=nDesc;

	while(i){
		i--;
		
		// skip 0 length buffers 
		//if(pMemDesc[i].len){
			
			pBuffer=GetBuffer();
			
			if(!pBuffer){
				goto err_exit;
			}
			
			pBuffer->pNext   = pLastBuffer;
			pBuffer->pData   = pMemDesc[i].pData;
			pBuffer->len     = pMemDesc[i].len;
			pBuffer->dwFlags = 0;
			pLastBuffer      = pBuffer;
		//} 
	}


	// return the head of the chain to the caller

exit:
	return pBuffer;

err_exit: 
	// Couldn't allocate enough buffers, free the ones we did alloc
	// and then fail.
	while(pLastBuffer){
		pBuffer=pLastBuffer->pNext;
		FreeBuffer(pLastBuffer);
		pLastBuffer=pBuffer;
	}
	ASSERT(pBuffer==NULL);
	goto exit;
}


VOID FreeBufferChainAndMemory(PBUFFER pBuffer)
{
	PBUFFER pNext;
	while(pBuffer){
		pNext=pBuffer->pNext;
		if(pBuffer->dwFlags & BFLAG_DOUBLE){
			FreeDoubleBuffer(pBuffer);
		} else if(pBuffer->dwFlags & BFLAG_FRAME){	
			FreeFrameBuffer(pBuffer);
		} else {
			FreeBuffer(pBuffer);
		}	
		pBuffer=pNext;
	}	
}

UINT BufferChainTotalSize(PBUFFER pBuffer)
{

	UINT nTotalLen;
	
	ASSERT(pBuffer);
	
	if(!pBuffer){
		return 0;
	}
	
	nTotalLen=0;
	
	do{
		nTotalLen+=pBuffer->len;
		pBuffer=pBuffer->pNext;
	} while (pBuffer);

	return nTotalLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\rcvpool.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    RCVPOOL.CPP

Abstract:

	Manages pool of send descriptors.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original

--*/

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"

//
// Receive Descriptor Management.
//

VOID InitRcvDescs(PPROTOCOL this)
{
	this->pRcvDescPool=NULL;
	this->nRcvDescsAllocated=0;
	this->nRcvDescsInUse=0;
	this->nMaxRcvDescsInUse=0;
	this->fInRcvDescTick=FALSE;
	InitializeCriticalSection(&this->RcvDescLock);
}

VOID FiniRcvDescs(PPROTOCOL this)
{
	PRECEIVE pReceive;
	
	ASSERT(this->nRcvDescsInUse==0);
	
	while(this->pRcvDescPool){
		pReceive=this->pRcvDescPool;
		ASSERT_SIGN(pReceive, RECEIVE_SIGN);
		this->pRcvDescPool=this->pRcvDescPool->pNext;
		DeleteCriticalSection(&pReceive->ReceiveLock);
		My_GlobalFree(pReceive);
		this->nRcvDescsAllocated--;
	}
	
	ASSERT(this->nRcvDescsAllocated==0);
	
	DeleteCriticalSection(&this->RcvDescLock);
}

PRECEIVE GetRcvDesc(PPROTOCOL this)
{
	PRECEIVE pReceive;

	Lock(&this->RcvDescLock);

	if(!this->pRcvDescPool){
	
		Unlock(&this->RcvDescLock);
		pReceive=(PRECEIVE)My_GlobalAlloc(GMEM_FIXED, sizeof(RECEIVE)+this->m_dwSPHeaderSize);
		if(pReceive){
			SET_SIGN(pReceive,RECEIVE_SIGN);			
			InitializeCriticalSection(&pReceive->ReceiveLock);
			InitBilink(&pReceive->RcvBuffList);
		}
		Lock(&this->RcvDescLock);
		if(pReceive){
			this->nRcvDescsAllocated++;
		}
	} else {
		pReceive=this->pRcvDescPool;
		ASSERT_SIGN(pReceive, RECEIVE_SIGN);
		this->pRcvDescPool=this->pRcvDescPool->pNext;
		
	}

	if(pReceive){
		this->nRcvDescsInUse++;
		if( this->nRcvDescsInUse > this->nMaxRcvDescsInUse ){
			this->nMaxRcvDescsInUse = this->nRcvDescsInUse;
		}
	}

	ASSERT(this->nRcvDescsAllocated >= this->nRcvDescsInUse);

	Unlock(&this->RcvDescLock);

	return pReceive;
}

VOID ReleaseRcvDesc(PPROTOCOL this, PRECEIVE pReceive)
{
	Lock(&this->RcvDescLock);
	this->nRcvDescsInUse--;
	ASSERT(!(this->nRcvDescsInUse&0x80000000));
	pReceive->pNext=this->pRcvDescPool;
	this->pRcvDescPool=pReceive;
	Unlock(&this->RcvDescLock);

}


#if 0
// few enough of these, that we can just let virtual memory handle it. - switched off
VOID RcvDescTick(PPROTOCOL this)
{
	PRECEIVE pReceive;
#ifdef DEBUG
	LONG fLast; 
#endif
	// Adjusts Number of allocated buffers to 
	// highwater mark over the last ticks.
	// Call once per delta t (around a minute).
	DEBUG_BREAK(); //TRACE all paths.

	if(!InterlockedExchange(&this->fInRcvDescTick, 1)){
	
		Lock(&this->RcvDescLock);
		
		while((this->nRcvDescsAllocated > this->nMaxRcvDescsInUse) && this->pRcvDescPool){
		
			pReceive=this->pRcvDescPool;
			ASSERT_SIGN(pReceive,RECEIVE_SIGN);
			this->pRcvDescPool=this->pRcvDescPool->pNext;
			Unlock(&this->RcvDescLock);
			DeleteCriticalSection(&pReceive->ReceiveLock);
			My_GlobalFree(pReceive);
			Lock(&this->RcvDescLock);
			this->nRcvDescsAllocated--;
			
		}
		this->nMaxRcvDescsInUse=this->nRcvDescsInUse;

		ASSERT(this->nMaxRcvDescsInUse <= this->nRcvDescsAllocated);
		
		Unlock(&this->RcvDescLock);
#ifdef DEBUG
		fLast=
#endif
		InterlockedExchange(&this->fInRcvDescTick, 0);
#ifdef DEBUG
		ASSERT(fLast==1);
#endif
	}	
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\framebuf.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    FRAMEBUF.CPP

Abstract:

	Manages Memory for Send/Receive Frames.
	BUGBUG: when you have time do an intelligent implementation,
	for now this is just a frame cache.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
   6/6/98  aarono  More debug checks, shrink pool.

--*/

#include <windows.h>
#include "newdpf.h"
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "bufmgr.h"
#include "macros.h"

#define MAX_FRAMES_ON_LIST 16
#define MIN_FRAMES_ON_LIST 8

typedef struct _frame 
{
	BILINK Bilink;
	UINT len;
	UCHAR data[0];
} FRAME, *PFRAME;	

BILINK FrameList;
UINT   nFramesOnList=0;
UINT   TotalFrameMemory=0;
CRITICAL_SECTION FrameLock;

#ifdef DEBUG
void DebugChkFrameList()
{
	BILINK *pBilink;
	PFRAME  pFrameWalker;

	DWORD	count=0;
	DWORD	totalsize=0;
	DWORD   fBreak=FALSE;

	Lock(&FrameLock);

	pBilink=FrameList.next;
	while(pBilink != &FrameList){
		pFrameWalker=CONTAINING_RECORD(pBilink,FRAME,Bilink);
		pBilink=pBilink->next;
		count++;
		totalsize+=pFrameWalker->len;
	}

	if(totalsize != TotalFrameMemory){
		DPF(0, "Total Frame Memory says %d but I count %d\n",TotalFrameMemory, totalsize);
		fBreak=TRUE;
	}

	if(count != nFramesOnList){
		DPF(0, "nFramesOnList %d but I count %d\n",nFramesOnList, count);
		fBreak=TRUE;
	}
	if(fBreak){
		DEBUG_BREAK();
	}
	
	Unlock(&FrameLock);
}
#else
#define DebugChkFrameList()
#endif

VOID InitFrameBuffers(VOID)
{
	InitBilink(&FrameList);
	InitializeCriticalSection(&FrameLock);
	nFramesOnList=0;
	TotalFrameMemory=0;
}

VOID FiniFrameBuffers(VOID)
{
	BILINK *pBilink;
	PFRAME  pFrame;
	
	Lock(&FrameLock);

	while(!EMPTY_BILINK(&FrameList)){
		pBilink=FrameList.next;
		pFrame=CONTAINING_RECORD(pBilink,FRAME,Bilink);
		Delete(pBilink);
		My_GlobalFree(pFrame);
	}

	nFramesOnList=0;
	TotalFrameMemory=0;
	
	Unlock(&FrameLock);
	DeleteCriticalSection(&FrameLock);
}

VOID ReleaseFrameBufferMemory(PUCHAR pFrameData)
{
	PFRAME  pFrame;
	BILINK  FramesToFree;
	BILINK *pBilink;
	
	Lock(&FrameLock);

	DebugChkFrameList();

	InitBilink(&FramesToFree);

	pFrame=CONTAINING_RECORD(pFrameData,FRAME,data);

	InsertAfter(&pFrame->Bilink, &FrameList);
	nFramesOnList++;
	TotalFrameMemory+=pFrame->len;

	if(nFramesOnList > MAX_FRAMES_ON_LIST){
		while(nFramesOnList > MIN_FRAMES_ON_LIST){
			pBilink=FrameList.next;
			pFrame=CONTAINING_RECORD(pBilink,FRAME,Bilink);
			nFramesOnList--;
			TotalFrameMemory-=pFrame->len;
			Delete(pBilink);
			DebugChkFrameList();
			InsertAfter(pBilink, &FramesToFree);
		}
	}
	
	DebugChkFrameList();
	ASSERT(nFramesOnList);

	Unlock(&FrameLock);

	// Drop lock before freeing, to make more effecient.

	while(!EMPTY_BILINK(&FramesToFree)){
		pBilink=FramesToFree.next;
		pFrame=CONTAINING_RECORD(pBilink,FRAME,Bilink);
		Delete(pBilink);
		My_GlobalFree(pFrame);
	}

	DebugChkFrameList();

}

PBUFFER GetFrameBuffer(UINT FrameLen)
{
	PBUFFER pBuffer;
	PFRAME  pFrame;
	MEMDESC memdesc;

	BILINK  *pBilinkWalker;
	PFRAME  pFrameBest=NULL, pFrameWalker;
	UINT    difference=FrameLen;

	DPF(9,"==>GetFrameBuffer Len %d\n",FrameLen);

	Lock(&FrameLock);
	
	if(!EMPTY_BILINK(&FrameList)){
		ASSERT(nFramesOnList);

		pBilinkWalker=FrameList.next;
		
		while(pBilinkWalker != &FrameList){
			pFrameWalker=CONTAINING_RECORD(pBilinkWalker, FRAME, Bilink);
			if(pFrameWalker->len >= FrameLen){
				if(FrameLen-pFrameWalker->len < difference){
					difference=FrameLen-pFrameWalker->len;
					pFrameBest=pFrameWalker;
					if(!difference){
						break;
					}
				}
			}
			pBilinkWalker=pBilinkWalker->next;
		}

		if(!pFrameBest){
			goto alloc_new_frame;
		} else {
			pFrame=pFrameBest;
		}

		DebugChkFrameList();

		Delete(&pFrame->Bilink);
		nFramesOnList--;
		TotalFrameMemory-=pFrame->len;

		DebugChkFrameList();

		Unlock(&FrameLock);
		
	} else {
	
alloc_new_frame:	
		Unlock(&FrameLock);
		pFrame=(PFRAME)My_GlobalAlloc(GMEM_FIXED,FrameLen+sizeof(FRAME));
		if(!pFrame){
			return NULL;
		}
		pFrame->len=FrameLen;
	}

	memdesc.pData=&pFrame->data[0];
	memdesc.len=pFrame->len;
	
	pBuffer=BuildBufferChain((&memdesc),1);

	if(!pBuffer){
		ReleaseFrameBufferMemory(pFrame->data);
		DPF(9,"<==GetFrameBuffer FAILED returning %x\n",pBuffer);
	} else {
		pBuffer->dwFlags |= BFLAG_FRAME;
		DPF(9,"<==GetFrameBuffer %x, len %d\n",pBuffer, pFrame->len);
	}	

	DebugChkFrameList();
	
	return pBuffer;
}

// Release the buffer, put the memory back on the frame buffer list.
VOID FreeFrameBuffer(PBUFFER pBuffer)
{
	ASSERT(pBuffer->dwFlags & BFLAG_FRAME);
	ReleaseFrameBufferMemory(pBuffer->pData);
	FreeBuffer(pBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\handles.h ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    HANDLES.H

Abstract:

	Handle Table

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   2/16/98 aarono  Original

--*/

#ifndef _MYHANDLE_H_
#define _MYHANDLE_H_

#define LIST_END 0xFFFFFFFF

#define MYHANDLE_DEFAULT_GROWSIZE 16

#define N_UNIQUE_BITS 16
#define UNIQUE_ADD (1<<(32-N_UNIQUE_BITS))
#define CONTEXT_INDEX_MASK (UNIQUE_ADD-1)
#define CONTEXT_UNIQUE_MASK (0xFFFFFFFF-CONTEXT_INDEX_MASK)

typedef struct _myhandle {
	LPVOID lpv;
	union {
		UINT nUnique;
		UINT iNext;
	};	
} MYHANDLE, *LPMYHANDLE;

typedef struct _myhandletable {
	UINT	nUnique;
	UINT    nTableSize;
	UINT    nTableGrowSize;
	UINT    iNext;
	MYHANDLE Table[0];
} MYHANDLETABLE, *LPMYHANDLETABLE;

typedef volatile LPMYHANDLETABLE VOLLPMYHANDLETABLE, *LPVOLLPMYHANDLETABLE;

extern VOLLPMYHANDLETABLE InitHandleTable(UINT nSize, CRITICAL_SECTION *pcs, UINT nGrowSize);
extern VOID FiniHandleTable(LPMYHANDLETABLE lpTable, CRITICAL_SECTION *pcs);

extern DWORD AllocHandleTableEntry(LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, LPVOID lpv);
extern LPVOID ReadHandleTableEntry(LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, UINT handle);
extern HRESULT FreeHandleTableEntry(LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, UINT handle);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\mytimer.h ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    MYTIMER.H

Abstract:

	Include For
	Handle adjusting timer resolution for throttling and do thread pool

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   6/04/98 aarono  Original

--*/

typedef void CALLBACK MYTIMERCALLBACK (UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2);

typedef enum _TimerState {
	NotInUse,
	WaitingForTimeout,
	QueuedForThread,
	InCallBack,
	End
} eTimerState;

typedef struct _MyTimer {
	BILINK	Bilink;
	eTimerState TimerState;
	DWORD	TimeOut;
	DWORD_PTR Context;
	MYTIMERCALLBACK *CallBack;
	DWORD   Unique;
} MYTIMER, *PMYTIMER;

DWORD_PTR SetMyTimer(DWORD dwTimeOut, DWORD TimerRes, MYTIMERCALLBACK TimerCallBack, DWORD_PTR UserContext, PUINT pUnique);
HRESULT InitTimerWorkaround();
VOID FiniTimerWorkaround();
HRESULT CancelMyTimer(DWORD_PTR pTimer, DWORD Unique);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\protocol.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Protocol.c

Abstract:

	Another Reliable Protocol (on DirectPlay)

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
  05/11/97 aarono  convert from C++ COM object to 'C' library
   2/03/98 aarono  fixed ProtocolGetCaps for RAW
   2/18/98 aarono  changed InitProtocol to work later in connect process
                   added new API handlers SendEx, GetMessageQueue, stub Cancel
   2/18/98 aarono  added Cancel support
   2/19/98 aarono  don't hook Shutdown anymore, dplay calls us
   				   explicitly on DP_OPEN (InitProtocol) DP_CLOSE (FiniProtocol)
   2/20/98 aarono  B#18827 not pulling cancelled sends from Q properly
   3/5/98  aarono  B#18962 allow non-reliable enumsessions reply when using protocol
		   this avoids a bug where a remote on an invalid IPX net enums us
		   and we get bogged down with RIPing in the response path.  Actually hangs
		   the machine and sometimes crashes IPX.
   6/6/98  aarono  Turn on throttling and windowing

Notes:
	All direct calls from DPLAY to the PROTOCOL occur in this file.

--*/

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "handles.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"
#include "mytimer.h"

/*
	Protocol Object Life:
	=====================

	The protocol object is allocated on the DPLAY interface immediately after
	the call to SPInit. The protocol block is allocated and tacked onto the
	DPLAY interface.  If the object is not allocated, the protocol pointer
	will be NULL.

	When the SP shutdown handler is called, the protocol object is released,
	first making sure that all other structures off of the protocol have
	been freed and all memory pools have been freed.

	SESSION Life:
	=============
	Sessions are the structures that support the connection of a pair of
	PLAYERS.  For each target playerid there is a SESSION structure.
	SESSIONS are accessed by converting playerids into indices into a
	session array, valid sessions are filled in, invalid or not yet seen
	ones are NULL.  A session is allocated for every call to the SP
	CreatePlayer routine.  When a DeletePlayer is received, the session
	is freed.  There are races to create players and delete players so
	the session state is tracked.  If the session is not in the OPEN
	state, mesages for the session are ABORTED/IGNORED(?).  When the
	player is being removed, there may be stragling receives, these
	are rejected.  Any packet received for a non-existent session is
	dropped.  When a session is being closed, all pending sends are
	first completed.

	SEND Life:
	==========

		STATISTICS Life:
		================

	RECEIVE Life:
	=============


	How we hook in:
	===============

	Receive:
	--------
	HandlePacket in the ISP table has been replaced by the protocol's
	ProtocolHandlePacket routine.  Each call to HandlePacket comes along
	with a pISP, from which we derive the pProtocol.  If no pProtocol exits
	on the object, then we just call the old HandlePacket routine, otherwise
	we examine the packet and do our thing depending on what type of message
	it is and/or negotiated session parameters.

	Send/CreatePlayer/DeletePlayer/Shutdown:
	----------------------------------------
	If we install:
	We replace the interface pointers to these SP callbacks with our own and
	remember the existing ones.  When we are called we do our processing and
	then call the handler in the SP.  In the case of Send, we may not even
	call because we need to packetize the message.

	We also replace the packet size information in the SPData structure so that
	directplay's packetize and send code won't try to break up messages before
	we get them.  System messages that we don't handle hopefully don't exceed
	the actual maximum frame size, else they will fail on a non-reliable
	transport.
	
*/

#ifdef DEBUG
extern VOID My_GlobalAllocInit();
extern VOID My_GlobalAllocDeInit();
#endif

//
// Global pools should only be inited once, this counts opens.
// No lock req'd since calls to spinit serialized in DirectPlay itself.
//
UINT nInitCount = 0;

/*=============================================================================

	InitProtocol - initialize the protocol block and hook into the send path.

    Description:

    	After each SP is initialized (in SPInit) this routine is called to
    	hook the SP callbacks for the protocol.  Also the protocol information
    	for this instance of the protocol is allocated and initialized.

    Parameters:

		LPSPINITDATA pInitData - initialization block that was passed to the
			 					 SP.  We use it to hook in.

    Return Values:

		DP_OK         - successfully hooked in.
		                pProtocol on DIRECTPLAY object points to protocol obj.
		DPERR_GENERIC - didn't hook in.  Also pProtocol in the DIRECTPLAY
		                object will be NULL.

-----------------------------------------------------------------------------*/

HRESULT WINAPI InitProtocol(DPLAYI_DPLAY *lpDPlay)
{
	PPROTOCOL    pProtocol;
	HRESULT      hr;

	#define TABLE_INIT_SIZE 16
	#define TABLE_GROW_SIZE 16

	#ifdef DEBUG
	My_GlobalAllocInit();
	#endif

	// Allocate the protocol block;
	pProtocol=My_GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,sizeof(PROTOCOL));

	if(!pProtocol){
		hr=DPERR_NOMEMORY;
		goto exit;
	}

	//
	// Initialize protocol variables.
	//

	pProtocol->m_lpDPlay=lpDPlay;

	pProtocol->m_lpISP=lpDPlay->pISP;
	
	pProtocol->m_dwSPHeaderSize=lpDPlay->dwSPHeaderSize;
	
	pProtocol->m_nSendThreads=0;						// we support any number of send threads!
	pProtocol->m_eState=Initializing;                   // we are initing
	
	InitializeCriticalSection(&pProtocol->m_ObjLock);
	InitializeCriticalSection(&pProtocol->m_SPLock);

	// Session lookup by ID list.
	InitializeCriticalSection(&pProtocol->m_SessionLock);
	pProtocol->m_SessionListSize=0;
	pProtocol->m_pSessions=NULL;

	// GLOBAL SENDQ
	InitializeCriticalSection(&pProtocol->m_SendQLock);
	InitBilink(&pProtocol->m_GSendQ);

	//
	// Get Multi-Media Timer Information.
    //
	
	if( timeGetDevCaps(&pProtocol->m_timecaps,sizeof(TIMECAPS)) != TIMERR_NOERROR ){
		// make em up
		ASSERT(0);
		pProtocol->m_timecaps.wPeriodMin=5;
		pProtocol->m_timecaps.wPeriodMax=10000000;
	}

	// Send Thread Triggers - waits for Sends, DataGram IDs or Reliable IDs.
	
	pProtocol->m_hSendEvent=CreateEventA(NULL, FALSE, FALSE, NULL);
	
	if(!pProtocol->m_hSendEvent){
		ASSERT(0); //TRACE all paths.
		hr=DPERR_NOMEMORY;
		goto exit1;
	}


	// Various descriptor pools.
	// These can't fail.
	if(!nInitCount){
		InitializeCriticalSection(&g_SendTimeoutListLock);
		InitBilink(&g_BilinkSendTimeoutList);
		// only allocated once per process.
		InitSendDescs();
		InitSendStats();
		InitFrameBuffers();
		InitBufferManager();
		InitBufferPool();
	}

	InitRcvDescs(pProtocol);

	nInitCount++;

	//
	// Get the datagram frame size from the SP
	//

	{
	        DPCAPS    	     Caps;
		    DPSP_GETCAPSDATA GetCapsData;

			memset(&Caps,0,sizeof(DPCAPS));

			Caps.dwMaxBufferSize = 0;
			Caps.dwSize          = sizeof(DPCAPS);
			GetCapsData.dwFlags  = 0;
			GetCapsData.lpCaps   = &Caps;
			GetCapsData.idPlayer = 0;
			GetCapsData.lpISP    = lpDPlay->pISP;
			CALLSP(lpDPlay->pcbSPCallbacks->GetCaps, &GetCapsData);
			pProtocol->m_dwSPMaxFrame=GetCapsData.lpCaps->dwMaxBufferSize;

			if(pProtocol->m_dwSPMaxFrame > 1400){
				// Necessary since UDP reports huge capacity even though no receiver can
				// successfully receive a datagram of that size without throttle.
				pProtocol->m_dwSPMaxFrame = 1400;
			}

			GetCapsData.dwFlags = DPCAPS_GUARANTEED;
			
			hr=CALLSP(lpDPlay->pcbSPCallbacks->GetCaps, &GetCapsData);

			if(hr==DP_OK){
				pProtocol->m_dwSPMaxGuaranteed=GetCapsData.lpCaps->dwMaxBufferSize;
			}	
			if(!pProtocol->m_dwSPMaxGuaranteed){
				pProtocol->m_dwSPMaxGuaranteed=pProtocol->m_dwSPMaxFrame;
			}
	}

	Lock(&pProtocol->m_ObjLock);

	//
	// Spin up the send thread
	//
	pProtocol->m_nSendThreads++;
	
	// Need for serialization starts here...
	pProtocol->m_hSendThread[0]=CreateThread( NULL,
									      4000,
									      SendThread,
							              (LPVOID)pProtocol,
							              0,
							              &pProtocol->m_dwSendThreadId[0]);
	if(!pProtocol->m_hSendThread[0]){
		ASSERT(0); //TRACE all paths.
		hr=DPERR_NOMEMORY;
		goto exit4;
	}


	pProtocol->lpHandleTable=InitHandleTable(TABLE_INIT_SIZE,&pProtocol->csHandleTable,TABLE_GROW_SIZE);

	if(!pProtocol->lpHandleTable){
		goto exit5;
	}

	pProtocol->m_eState=Running;

	Unlock(&pProtocol->m_ObjLock);
	hr=DP_OK;
	
exit:
	if(hr==DP_OK){
		lpDPlay->pProtocol=(LPPROTOCOL_PART)pProtocol;
	} else {
		lpDPlay->pProtocol=NULL;
	}
	return hr;

//exit6: if more init written, may need this.
//	FiniHandleTable(pProtocol->lpHandleTable, &pProtocol->csHandleTable);
	

exit5:
	pProtocol->m_eState=ShuttingDown;
	SetEvent(pProtocol->m_hSendEvent);
	Unlock(&pProtocol->m_ObjLock);
	
	while(pProtocol->m_nSendThreads){
		// wait for the send thread to shut off.
		Sleep(0);
	}
	CloseHandle(pProtocol->m_hSendThread[0]);
	
	Lock(&pProtocol->m_ObjLock);
	
exit4:
	Unlock(&pProtocol->m_ObjLock);

//exit3:
	FiniRcvDescs(pProtocol);

	nInitCount--;
	if(!nInitCount){
		DeleteCriticalSection(&g_SendTimeoutListLock);
		FiniBufferPool();
		FiniBufferManager();
		FiniFrameBuffers();
		FiniSendStats();
		FiniSendDescs();
	}	
	
//exit2:
	CloseHandle(pProtocol->m_hSendEvent);
exit1:	
	DeleteCriticalSection(&pProtocol->m_SPLock);
	DeleteCriticalSection(&pProtocol->m_ObjLock);
	DeleteCriticalSection(&pProtocol->m_SessionLock);
	DeleteCriticalSection(&pProtocol->m_SendQLock);
	My_GlobalFree(pProtocol);
	goto exit;

	#undef TABLE_INIT_SIZE
	#undef TABLE_GROW_SIZE

	
}

/*=============================================================================

	FiniProtocol -
	
    Description:

    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

VOID WINAPI FiniProtocol(PPROTOCOL pProtocol)
{
	DWORD tmKill;
	//
	// Kill the send thread.
	//

	DPF(1,"==>ProtShutdown\n");

	Lock(&pProtocol->m_ObjLock);
	pProtocol->m_eState=ShuttingDown;
	SetEvent(pProtocol->m_hSendEvent);
	while(pProtocol->m_nSendThreads){
		// wait for the send thread to shut off.
		Unlock(&pProtocol->m_ObjLock);
		Sleep(0);
		Lock(&pProtocol->m_ObjLock);
	}
	Unlock(&pProtocol->m_ObjLock);
	
	CloseHandle(pProtocol->m_hSendThread[0]);

	DPF(1,"SHUTDOWN: Protocol Send Thread ShutDown, waiting for sessions\n");

	tmKill=timeGetTime()+60000;

	Lock(&pProtocol->m_SessionLock);
	while(pProtocol->m_nSessions && (((INT)(tmKill-timeGetTime())) > 0)){
		Unlock(&pProtocol->m_SessionLock);
		//BUGBUG: race.  when m_nSessions dereffed, there
		//        is a race for the protocol to be freed.
		Sleep(0);
		Lock(&pProtocol->m_SessionLock);
	}
	DPF(1,"SHUTDOWN: Sessions All Gone Freeing other objects.\n");
	
	//
	// Free the SESSION table
	//
	if(pProtocol->m_pSessions){
		My_GlobalFree(pProtocol->m_pSessions);
		pProtocol->m_pSessions=0;
	}	
	Unlock(&pProtocol->m_SessionLock);

	DeleteCriticalSection(&pProtocol->m_SendQLock);
	DeleteCriticalSection(&pProtocol->m_SessionLock);
	DeleteCriticalSection(&pProtocol->m_SPLock);
	DeleteCriticalSection(&pProtocol->m_ObjLock);

	CloseHandle(pProtocol->m_hSendEvent);

	FiniRcvDescs(pProtocol);
	
	nInitCount--;
	if(!nInitCount){
		// Last one out, turn off the lights...
		DeleteCriticalSection(&g_SendTimeoutListLock);
		FiniBufferPool();
		FiniBufferManager();
		FiniFrameBuffers();
		FiniSendStats();
		FiniSendDescs();
	}

	FiniHandleTable(pProtocol->lpHandleTable, &pProtocol->csHandleTable);
	
	My_GlobalFree(pProtocol);
	
	#ifdef DEBUG
		My_GlobalAllocDeInit();
	#endif
}


/*=============================================================================

	ProtocolCreatePlayer - Called by DPlay when SP needs to be notified of new
		                   player creation.

    Description:

		Creates a session for the id.  BUGBUG: if local, don't need this?
		Also notifies the SP.

    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolCreatePlayer(LPDPSP_CREATEPLAYERDATA pCreatePlayerData)
{
	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	HRESULT      hr=DP_OK;


	lpDPlay=((DPLAYI_DPLAY_INT *)pCreatePlayerData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);
	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);
	pProtocol->m_dwIDKey=(DWORD)lpDPlay->lpsdDesc->dwReserved1;

	// Creates the session and gets one refcount.
	hr=CreateNewSession(pProtocol, pCreatePlayerData->idPlayer);

	if(hr==DP_OK){
		
		// Chain the call to the real provider.
		Lock(&pProtocol->m_SPLock);
		if(lpDPlay->pcbSPCallbacks->CreatePlayer){
			hr=CALLSP(lpDPlay->pcbSPCallbacks->CreatePlayer,pCreatePlayerData);
		}
		Unlock(&pProtocol->m_SPLock);

		if(hr!=DP_OK){
			PSESSION pSession;
			pSession=GetSession(pProtocol,pCreatePlayerData->idPlayer); //adds a ref
			if(pSession){
				DecSessionRef(pSession); // unGetSession
				DecSessionRef(pSession); // blow it away, noone could access yet.
			}	
		}

	}
	return hr;

}

/*=============================================================================

	ProtocolPreNotifyDeletePlayer

	Called to tell us a DELETEPLAYER message was enqueued for a particular
	player.  We need to drop the player NOW!

	We don't notify the SP, that will happen when we are called in
	ProtocolDeletePlayer later when the pending queue is processed.
	
    Description:

		Dereference the session for the player.

    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolPreNotifyDeletePlayer(LPDPLAYI_DPLAY this, DPID idPlayer)
{
	PPROTOCOL    pProtocol;
	PSESSION     pSession;
	HRESULT      hr=DP_OK;

	pProtocol=(PPROTOCOL)this->pProtocol;
	ASSERT(pProtocol);

	pSession=GetSession(pProtocol,idPlayer);

	DPF(9,"==>Protocol Prenotify Delete Player %x, pSession %x\n",idPlayer, pSession);

	if(pSession){

		pSession->hClosingEvent=0;
#if 0	
		//BUGBUG: if you even think about putting this back, also do it in ProtocolDeletePlayer
		hClosingEvent=pSession->hClosingEvent=CreateEventA(NULL,FALSE,FALSE,NULL);

		if(hClosingEvent){
			ResetEvent(hClosingEvent);
		}
#endif		

		Lock(&pProtocol->m_SendQLock);
		Lock(&pSession->SessionLock);

		switch(pSession->eState)
		{	
			case Open:
				TimeOutSession(pSession);
				Unlock(&pSession->SessionLock);
				Unlock(&pProtocol->m_SendQLock);
				DecSessionRef(pSession); // balance GetSession
				DecSessionRef(pSession); // balance Creation - may destroy session, and signal event
				break;
				
			case Closing:
			case Closed:
				Unlock(&pSession->SessionLock);
				Unlock(&pProtocol->m_SendQLock);
				DecSessionRef(pSession); // balance GetSession
				break;
		}

#if 0
		if(hClosingEvent){
		//	Wait(hClosingEvent);
			CloseHandle(hClosingEvent);
		} else {
			DPF(0,"ProtocolPreNotifyDeletePlayer: couldn't get close event handle--not waiting...\n");
			ASSERT(0);			
		}
#endif		

	} else {
		DPF(0,"ProtocolPreNotifyDeletePlayer: couldn't find session for playerid %x\n",idPlayer);
		ASSERT(0);
	}

	DPF(9,"<==Protocol Prenotify DeletePlayer, hr=%x\n",hr);

	return hr;
}

/*=============================================================================

	ProtocolDeletePlayer - Called by DPlay when SP needs to be notified of
		                   player deletion.

    Description:

		Dereference the session for the player.  Then notifies the SP.

    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolDeletePlayer(LPDPSP_DELETEPLAYERDATA pDeletePlayerData)
{

	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	PSESSION     pSession;
	HRESULT      hr=DP_OK;
	//HANDLE       hClosingEvent;

	lpDPlay=((DPLAYI_DPLAY_INT *)pDeletePlayerData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);
	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	pSession=GetSession(pProtocol,pDeletePlayerData->idPlayer);

	DPF(9,"==>Protocol Delete Player %x, pSession %x\n",pDeletePlayerData->idPlayer, pSession);

	if(pSession){

		pSession->hClosingEvent=0;
		
	#if 0	
		//BUGBUG: if you even think about putting this back, also do it in ProtocolPreNotifyDeletePlayer

		hClosingEvent=pSession->hClosingEvent=CreateEventA(NULL,FALSE,FALSE,NULL);

		if(hClosingEvent){
			ResetEvent(hClosingEvent);
		}
	#endif	

		Lock(&pProtocol->m_SendQLock);
		Lock(&pSession->SessionLock);
		
		switch(pSession->eState)
		{	
			case Open:
				TimeOutSession(pSession);
				Unlock(&pSession->SessionLock);
				Unlock(&pProtocol->m_SendQLock);
				DecSessionRef(pSession); // balance GetSession
				DecSessionRef(pSession); // balance Creation - may destroy session, and signal event
				break;
				
			case Closing:
			case Closed:
				Unlock(&pSession->SessionLock);
				Unlock(&pProtocol->m_SendQLock);
				DecSessionRef(pSession); // balance GetSession
				break;
		}

	#if 0
		if(hClosingEvent){
		//	Wait(hClosingEvent);
			CloseHandle(hClosingEvent);
		} else {
			DPF(0,"ProtocolDeletePlayer: couldn't get close event handle--not waiting...\n");
			ASSERT(0);			
		}
	#endif	

	} else {
		DPF(0,"ProtocolDeletePlayer: couldn't find session for playerid %x, ok if ProtocolPreNotifyDeletPlayer ran.\n",pDeletePlayerData->idPlayer);
	}

	DPF(9,"Protocol, deleted player id %x\n",pDeletePlayerData->idPlayer);

	DPF(9,"<==ProtocolDeletePlayer, hr=%x\n",hr);

	return hr;
}

/*=============================================================================

	ProtocolSendEx -
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolSendEx(LPDPSP_SENDEXDATA pSendData)
{
	DPSP_SENDDATA sd;
	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	HRESULT      hr=DP_OK;
	DWORD        dwCommand;
	
	PUCHAR pBuffer;

	lpDPlay=((DPLAYI_DPLAY_INT *)pSendData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);

	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	ASSERT(lpDPlay->dwFlags & DPLAYI_PROTOCOL);

	if(pSendData->lpSendBuffers->len >= 8){
		pBuffer=pSendData->lpSendBuffers->pData;

		if((*((DWORD *)pBuffer)) == SIGNATURE('p','l','a','y')){
		
			dwCommand=GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pBuffer);

			switch(dwCommand){
				case DPSP_MSG_PACKET2_DATA:
				case DPSP_MSG_PACKET2_ACK:
				case DPSP_MSG_PACKET:
					goto send_non_protocol_message;
					break;
		
				default:
					break;
			}
		}
		
	}


	// BUGBUG, make Send take the SENDEXDATA struct only.
	hr=Send(pProtocol,
			pSendData->idPlayerFrom,
			pSendData->idPlayerTo,
		 	pSendData->dwFlags,
			pSendData->lpSendBuffers,
		 	pSendData->cBuffers,
		 	pSendData->dwPriority,
		 	pSendData->dwTimeout,
		 	pSendData->lpDPContext,
		 	pSendData->lpdwSPMsgID,
		 	TRUE,
			NULL);  // forces us to be called back in InternalSendComplete, if Send is ASYNC.

	return hr;
	
send_non_protocol_message:

	ENTER_DPLAY();
	
	Lock(&pProtocol->m_SPLock);
	
	if(lpDPlay->pcbSPCallbacks->SendEx){
		hr=CALLSP(lpDPlay->pcbSPCallbacks->SendEx,pSendData);	
	} else {
		hr=ConvertSendExDataToSendData(lpDPlay, pSendData, &sd);
		if(hr==DP_OK){
			hr=CALLSP(lpDPlay->pcbSPCallbacks->Send, &sd);
			MsgFree(NULL, sd.lpMessage);
		}
	}
	
	Unlock(&pProtocol->m_SPLock);
	
	LEAVE_DPLAY();

	return hr;

}

/*=============================================================================

	ProtocolGetMessageQueue -
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolGetMessageQueue(LPDPSP_GETMESSAGEQUEUEDATA pGetMessageQueueData)
{
	#define pData pGetMessageQueueData
	
	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	PSESSION     pSession;
	HRESULT      hr=DP_OK;

	BILINK *pBilink;
	PSEND pSend;

	DWORD dwNumMsgs;
	DWORD dwNumBytes;

	lpDPlay=((DPLAYI_DPLAY_INT *)pData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);

	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	dwNumMsgs=0;
	dwNumBytes=0;

	if(!pData->idTo && !pData->idFrom){
		// just wants totals, I know that!
		EnterCriticalSection(&pProtocol->m_SendQLock);
		dwNumMsgs  = pProtocol->m_dwMessagesPending;
		dwNumBytes = pProtocol->m_dwBytesPending;
		LeaveCriticalSection(&pProtocol->m_SendQLock);

	} else if(pData->idTo){

		// Given idTo, walk that target's sendQ

		pSession=GetSysSession(pProtocol,pData->idTo);

		if(!pSession) {
			DPF(0,"GetMessageQueue: NO SESSION for idTo %x, returning INVALIDPLAYER\n",pData->idTo);
			hr=DPERR_INVALIDPLAYER;
			goto exit;
		}
		
		EnterCriticalSection(&pSession->SessionLock);

		pBilink=pSession->SendQ.next;

		while(pBilink != &pSession->SendQ){
			pSend=CONTAINING_RECORD(pBilink, SEND, SendQ);
			pBilink=pBilink->next;

			if((pSend->idTo==pData->idTo) && (!pData->idFrom || (pSend->idFrom == pData->idFrom))){
				dwNumBytes += pSend->MessageSize;
				dwNumMsgs += 1;
			}

		}

		LeaveCriticalSection(&pSession->SessionLock);
		
		DecSessionRef(pSession);

	} else {
		ASSERT(pData->idFrom);
		// Geting Queue for a from id, this is most costly
		EnterCriticalSection(&pProtocol->m_SendQLock);
		
		pBilink=pProtocol->m_GSendQ.next;

		while(pBilink != &pProtocol->m_GSendQ){
			pSend=CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
			pBilink=pBilink->next;

			if(pData->idFrom == pSend->idFrom){
				if(!pData->idTo || pData->idTo==pSend->idTo){
					dwNumBytes += pSend->MessageSize;
					dwNumMsgs += 1;
				}
			}
		}
			
		LeaveCriticalSection(&pProtocol->m_SendQLock);
	}

	if(pData->lpdwNumMsgs){
		*pData->lpdwNumMsgs=dwNumMsgs;
	}

	if(pData->lpdwNumBytes){
		*pData->lpdwNumBytes=dwNumBytes;
	}
	
exit:
	return hr;
	
	#undef pData
}


/*=============================================================================

	ProtocolCancel -
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolCancel(LPDPSP_CANCELDATA pCancelData)
{
	#define pData pCancelData
	
	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	HRESULT      hr=DP_OK;
	DWORD        nCancelled=0;
	BILINK       *pBilink;
	BOOL         bCancel;
	UINT         i;
	UINT         j;
	DWORD        dwContext;
	PSEND        pSend;

	lpDPlay=((DPLAYI_DPLAY_INT *)pData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);

	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	EnterCriticalSection(&pProtocol->m_SendQLock);

	if(pData->dwFlags) {

		// either cancelpriority or cancel all, either way we
		// need to scan...
	
		pBilink=pProtocol->m_GSendQ.next;

		while(pBilink!=&pProtocol->m_GSendQ){

			pSend=CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
			pBilink=pBilink->next;

			bCancel=FALSE;

			Lock(&pSend->SendLock);

			switch(pSend->SendState){
			
				case Start:
				case WaitingForId:
					if(pData->dwFlags & DPCANCELSEND_PRIORITY) {
						// Cancel sends in priority range.
						if((pSend->Priority <= pData->dwMaxPriority) &&
						   (pSend->Priority >= pData->dwMinPriority)){
						   	bCancel=TRUE;
						}
					} else if(pData->dwFlags & DPCANCELSEND_ALL) {
						// Cancel all sends that can be.
						bCancel=TRUE;
					} else {
						ASSERT(0); // Invalid flags, should never happen
					}

					if(bCancel){
						if(pSend->SendState == WaitingForId){
							if(pSend->dwFlags & DPSEND_GUARANTEED){
								InterlockedDecrement(&pSend->pSession->nWaitingForMessageid);
							} else {
								InterlockedDecrement(&pSend->pSession->nWaitingForDGMessageid);
							}
						}
						nCancelled+=1;
						pSend->SendState=Cancelled;
					}
				break;	
				
				default:
					DPF(5,"Couldn't cancel send %x in State %d, already sending...\n",pSend,pSend->SendState);
			}

			Unlock(&pSend->SendLock);
		}	

	} else {
		// No flags, therefore we have a list to cancel so lookup
		// each send and cancel rather than scanning as above.

		// Run through the list, find the sends and lock em 1st, if we find one that doesn't lookup,
		// or one not in the start state, then we bail.  We then unlock them all.

		for(i=0;i<pData->cSPMsgID;i++){

			dwContext=(DWORD)((DWORD_PTR)((*pData->lprglpvSPMsgID)[i]));
			
			pSend=(PSEND)ReadHandleTableEntry(&pProtocol->lpHandleTable, &pProtocol->csHandleTable, dwContext);
			
			if(pSend){
				Lock(&pSend->SendLock);
				if(pSend->SendState != Start && pSend->SendState != WaitingForId){
					Unlock(&pSend->SendLock);
					hr=DPERR_CANCELFAILED;
					break;
				}
			} else {
				hr=DPERR_CANCELFAILED;
				break;
			}

		}

		if(hr==DPERR_CANCELFAILED) {
			// release all the locks.
			for(j=0;j<i;j++){
				dwContext=(DWORD)((DWORD_PTR)((*pData->lprglpvSPMsgID)[j]));
				pSend=(PSEND)ReadHandleTableEntry(&pProtocol->lpHandleTable, &pProtocol->csHandleTable, dwContext);
				ASSERT(pSend);
				Unlock(&pSend->SendLock);
			}
		} else {
			// mark the sends cancelled and release all the locks.
			for(i=0;i<pData->cSPMsgID;i++){
				dwContext=(DWORD)((DWORD_PTR)((*pData->lprglpvSPMsgID)[i]));
				pSend=(PSEND)ReadHandleTableEntry(&pProtocol->lpHandleTable, &pProtocol->csHandleTable, dwContext);
				ASSERT(pSend);
				if(pSend->SendState == WaitingForId){
					if(pSend->dwFlags & DPSEND_GUARANTEED){
						InterlockedDecrement(&pSend->pSession->nWaitingForMessageid);
					} else {
						InterlockedDecrement(&pSend->pSession->nWaitingForDGMessageid);
					}
				}
				pSend->SendState=Cancelled;
				nCancelled+=1;
				Unlock(&pSend->SendLock);
			}
		}
	}
	
	LeaveCriticalSection(&pProtocol->m_SendQLock);
	
	SetEvent(pProtocol->m_hSendEvent);
	return hr;
	
	#undef pData
}

/*=============================================================================

	ProtocolSend - Send A message synchronously.
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/
DWORD bForceDGAsync=FALSE;

HRESULT WINAPI ProtocolSend(LPDPSP_SENDDATA pSendData)
{

	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	HRESULT      hr=DP_OK;
	DWORD        dwCommand;
	DWORD		 dwPriority;
	DWORD		 dwFlags;
	
	PUCHAR pBuffer;

	MEMDESC memdesc;

	lpDPlay=((DPLAYI_DPLAY_INT *)pSendData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);

	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);
	pBuffer=&(((PUCHAR)(pSendData->lpMessage))[pProtocol->m_dwSPHeaderSize]);

	if((*((DWORD *)pBuffer)) == SIGNATURE('p','l','a','y')){
	
		dwCommand=GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pBuffer);

		switch(dwCommand){
			case DPSP_MSG_PACKET2_DATA:
			case DPSP_MSG_PACKET2_ACK:
			case DPSP_MSG_ENUMSESSIONSREPLY:
			case DPSP_MSG_PACKET:
				goto send_non_protocol_message;
				break;
				
			default:
				break;
		}
	}

	memdesc.pData=((PUCHAR)pSendData->lpMessage)+pProtocol->m_dwSPHeaderSize;
	memdesc.len  =pSendData->dwMessageSize-pProtocol->m_dwSPHeaderSize;

	if(pSendData->dwFlags & DPSEND_HIGHPRIORITY){
		pSendData->dwFlags &= ~(DPSEND_HIGHPRIORITY);
		dwPriority=0xFFFFFFFE;
	} else {
		dwPriority=1000;
	}

	dwFlags = pSendData->dwFlags;
	if(bForceDGAsync && !(dwFlags&DPSEND_GUARANTEE)){
		// for testing old apps with protocol make datagram sends
		// async so that the application doesn't block.
		dwFlags |= DPSEND_ASYNC;
	}


	hr=Send(pProtocol,
			pSendData->idPlayerFrom,
			pSendData->idPlayerTo,
		 	dwFlags,
			&memdesc,
		 	1,
		 	dwPriority,
		 	0,
		 	NULL,
		 	NULL,
		 	FALSE,
			NULL);

	return hr;
	
send_non_protocol_message:
	if((*((DWORD *)pBuffer)) == SIGNATURE('p','l','a','y')){
		DPF(9,"Send Message %d Ver %d\n", pBuffer[4]+(pBuffer[5]<<8),pBuffer[6]+(pBuffer[7]<<8));
	}

	ENTER_DPLAY();
	Lock(&pProtocol->m_SPLock);
	hr=CALLSP(lpDPlay->pcbSPCallbacks->Send,pSendData);	
	Unlock(&pProtocol->m_SPLock);
	LEAVE_DPLAY();

	return hr;

}

/*=============================================================================

	GetPlayerLatency - Get Latency for a player
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

DWORD GetPlayerLatency(LPDPLAYI_DPLAY lpDPlay, DPID idPlayer)
{
	PPROTOCOL    pProtocol;
	PSESSION     pSession;
	DWORD        dwLatency=0;	// default, means I don't know latency

	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	pSession=GetSession(pProtocol,idPlayer);

	DPF(9,"==>Protocol GetPlayer Latency %x, pSession %x\n",idPlayer, pSession);

	if(pSession){

		Lock(&pSession->SessionLock);

		// Protocol Latency is round trip in 24.8 fixed point,
		// we net round trip latency divided by 2, so shift right 9.
		dwLatency=(pSession->FpLocalAverageLatency)>>(9);

		Unlock(&pSession->SessionLock);
	
		DecSessionRef(pSession); // balance GetSession

	}
	DPF(9,"<==Protocol GetPlayerLatency, returning dwLat=%x\n",dwLatency);

	return dwLatency;
}

/*=============================================================================

	ProtocolGetCaps - Get Service Provider Capabilities
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolGetCaps(LPDPSP_GETCAPSDATA pGetCapsData)
{
	#define ALL_PROTOCOLCAPS	(DPCAPS_SENDPRIORITYSUPPORTED | \
								 DPCAPS_ASYNCSUPPORTED        | \
								 DPCAPS_SENDTIMEOUTSUPPORTED  | \
								 DPCAPS_ASYNCCANCELSUPPORTED  )

	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	HRESULT      hr=DP_OK;

	lpDPlay=((DPLAYI_DPLAY_INT *)pGetCapsData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);
	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	// Chain the call to the real provider.
	Lock(&pProtocol->m_SPLock);
	if(lpDPlay->pcbSPCallbacks->GetCaps){
		hr=CALLSP(lpDPlay->pcbSPCallbacks->GetCaps,pGetCapsData);
	}
	Unlock(&pProtocol->m_SPLock);

	// if it fails, this doesn't hurt
	if(lpDPlay->dwFlags & DPLAYI_DPLAY_PROTOCOL)
	{
	    // 1 megabyte is lots (says Jamie Osborne)
		pGetCapsData->lpCaps->dwMaxBufferSize=0x100000;
		pGetCapsData->lpCaps->dwFlags |= ALL_PROTOCOLCAPS;
	}
	
	if(pGetCapsData->idPlayer && !pGetCapsData->lpCaps->dwLatency){
		// SP refused to guess at latency, so use ours.
		pGetCapsData->lpCaps->dwLatency=GetPlayerLatency(lpDPlay, pGetCapsData->idPlayer);
	}
	
	return hr;
	
	#undef ALL_PROTOCOLCAPS
}

DWORD ExtractProtocolIds(PUCHAR pInBuffer, PUINT pdwIdFrom, PUINT pdwIdTo)
{
	PCHAR pBuffer=pInBuffer;
	DWORD dwIdFrom=0;
	DWORD dwIdTo=0;


	dwIdFrom=*pBuffer&0x7F;
	if(*pBuffer&0x80){
		pBuffer++;
		dwIdFrom=dwIdFrom+((*pBuffer&0x7F)<<7);
		if(*pBuffer&0x80){
			pBuffer++;
			dwIdFrom=dwIdFrom+((*pBuffer&0x7F)<<14);
			if(dwIdFrom > 0xFFFF || *pBuffer&0x80){
				DPF(0,"INVALID FROM ID  %x IN MESSAGE, REJECTING PACKET\n",dwIdFrom);
				return 0;
			}
		}
	}

	if(dwIdFrom==0xFFFF){
		dwIdFrom=0x70;
	}
	
	pBuffer++;
	
	dwIdTo=*pBuffer&0x7F;
	if(*pBuffer&0x80){
		pBuffer++;
		dwIdTo=dwIdTo+((*pBuffer&0x7F)<<7);
		if(*pBuffer&0x80){
			pBuffer++;
			dwIdTo=dwIdTo+((*pBuffer&0x7F)<<14);
			if(dwIdTo > 0xFFFF || *pBuffer&0x80){
				DPF(0,"INVALID TO ID  %x IN MESSAGE, REJECTING PACKET\n",dwIdTo);
				return 0;
			}
		}
	}

	*pdwIdFrom=dwIdFrom;
	*pdwIdTo=dwIdTo;

	pBuffer++;
	
//	DPF(9, "In ExtractProtocolIds: from %x became %x\n", *(DWORD *)pInBuffer, dwIdFrom);

	return (DWORD)(pBuffer-pInBuffer);
}

/*=============================================================================

	DP_SP_ProtocolHandleMessage - Packet handler for Dplay protocol
	
	
    Description:

		All messages go through here when the protocol is active.  If the
		message is not a protocol message, this routine doesn't process
		it and returns DPERR_NOTHANDLED to let other layers (probably
		PacketizeAndSend) process it.
	

    Parameters:

		IDirectPlaySP * pISP  - pointer to pISP interface
		LPBYTE pReceiveBuffer - a single buffer of data
		DWORD dwMessageSize   - length of the buffer
		LPVOID pvSPHeader     - pointer to SP's header used in Reply

    Return Values:

	Notes:

		We don't worry about re-entering DP_SP_HandleMessage since
		we are calling only when a receive has completed and we are in the
		callback from the SP to directplay, so effectively the SP is
		serializing receives for us.

		The receive code is actually written to be re-entrant, so if we
		ever decide to allow concurrent receive processing the protocol
		can handle it.

		Protocol messages start with 'P','L','A','Y','0xFF' when not RAW.


		DPLAY gets handleMessage first, and hands off to protocol if active.
-----------------------------------------------------------------------------*/


HRESULT DPAPI DP_SP_ProtocolHandleMessage(
	IDirectPlaySP * pISP,
	LPBYTE pReceiveBuffer,
	DWORD dwMessageSize,
	LPVOID pvSPHeader)
{
	DPLAYI_DPLAY *lpDPlay;
	DWORD dwIdFrom, dwIdTo;
	PBUFFER pRcvBuffer;
	PPROTOCOL pProtocol;
	
	lpDPlay=DPLAY_FROM_INT(pISP);
	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;

	if(pProtocol->m_lpDPlay->dwFlags & DPLAYI_DPLAY_PROTOCOL){

		// Running in RAW mode there is no dplay header on protocol
		// messages.  If we see one with a header or we don't receive
		// a message large enough to be a protocol message we punt it.
	
		if(dwMessageSize >= 4 &&
		  (*((DWORD *)pReceiveBuffer)) == SIGNATURE('p','l','a','y'))
		{
			// Got a system message.
		  	goto handle_non_protocol_message;
		}
		
		if( dwMessageSize < 6 ){
			goto handle_non_protocol_message;
		}

	} else {
		// this can happen when shutting down.
		DPF(0,"Protocol still up, but no bits set, not handling receive (must be shutting down?)");
		goto handle_non_protocol_message;
	}
	
	// Hey, this must be ours...

	Lock(&pProtocol->m_ObjLock);
	if(pProtocol->m_eState==Running){	// just a sanity check, we don't depend on it after dropping lock.

		DWORD idLen;
	
		Unlock(&pProtocol->m_ObjLock);

		idLen = ExtractProtocolIds(pReceiveBuffer,&dwIdFrom,&dwIdTo);

		if(!idLen){
			goto handle_non_protocol_message;
		}

		pRcvBuffer=GetFrameBuffer(dwMessageSize-idLen);
		pRcvBuffer->len=dwMessageSize-idLen;
		memcpy(pRcvBuffer->pData, pReceiveBuffer+idLen,pRcvBuffer->len);

		DPF(9,"DP_SP_ProtocolHandleMessage	From %x	To %x\n",dwIdFrom,dwIdTo);

		ENTER_DPLAY();

		ProtocolReceive((PPROTOCOL)lpDPlay->pProtocol, (WORD)dwIdFrom, (WORD)dwIdTo, pRcvBuffer,pvSPHeader);

		LEAVE_DPLAY();
	} else {
		Unlock(&pProtocol->m_ObjLock);
	}

	return DP_OK;
	
handle_non_protocol_message:
	return DPERR_NOTHANDLED;
}

// DP_SP_ProtocolSendComplete is the callback handler for all completions since there is no other
// way to wrap the completion. When the protocol is not present, this just calls the DPLAY handler
// immediately.

VOID DPAPI DP_SP_ProtocolSendComplete(
	IDirectPlaySP * pISP,
	LPVOID          lpvContext,
	HRESULT         CompletionStatus)
{
	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL pProtocol;

	lpDPlay=DPLAY_FROM_INT(pISP);

	if(lpDPlay->pProtocol){

		// BUGBUG: when SP SendEx is used, we have to patch and xlate here.
		// for now, this should never happen.

		DEBUG_BREAK(); // Shouldn't get here yet.
		
		pProtocol=(PPROTOCOL)lpDPlay->pProtocol;

		DP_SP_SendComplete(pISP, lpvContext, CompletionStatus);

	} else {

		DP_SP_SendComplete(pISP, lpvContext, CompletionStatus);
	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\protocol.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    PROTOCOL.H

Abstract:

	Another Reliable Protocol - CPP implementation

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
   2/11/97 aarono  Removed channel from header, now rides in body of 1st packet.
   					 								along with the length field.
   3/12/97 aarono  channel is gone, not relevant to transport protocol, can be
                   prepended to messages that want it.  Length field is gone,
                   not required.
   6/6/98  aarono  Turn on throttling and windowing - fix some definitions
--*/

#ifndef _PROTOCOL_H_
#define _PROTOCOL_H_

#pragma pack(push,1)

typedef unsigned char  byte;
typedef unsigned short word;
typedef unsigned int   dword;

//
// ARP - Another Reliable Protocol - Packet Definitions
//

// Terminology
//
// message - an arbitrary sized chunk of data
// to be sent from one computer to a another over
// the available media.
//
// packet - a piece of a message broken down
// for the media, including protocol information
// to allow the message to be reconstructed at
// the other end.
//
// frame - an instance of a packet.
//
// Assumptions:
//
// All values on the wire are little endian.
//
// This protocol allows packets to arrive out of
// order but is optimized for the in-order case.
//

#define EXT 0x80    /* EXTENSION BIT            */
#define BIG 0x40    /* BIG HEADERS (FAST MEDIA) */
#define CMD 0x20    /* COMMAND FRAME            */
#define STA 0x10
#define EOM	0x08	/* END OF MESSAGE           */
#define SAK 0x04    /* SEND ME AN ACK           */
#define ACK 0x02    /* ACKNOWLEDGE FRAME        */
#define RLY 0x01    /* RELIABLE FRAME           */

// Shifts used in small extended fields.

#define nNACK_MSK   0x60
#define nNACK_SHIFT 5
#define CMD_MSK     0x1F

#define IDMSK  (pCmdInfo->IDMSK)
#define SEQMSK (pCmdInfo->SEQMSK)

// Note: abort packets contain serial numbers but no sequence numbers.
//       the nACK field can be used to abort many messages at the same
//       time. (using ABORT2 or ABORT3).  Also just the messageid is 
//       provided in the abort case.

typedef struct _Packet1 {	// simple small -I- frame
	byte	flags;
	byte    messageid;
	byte	sequence;
	byte    serial;
	byte    data[0];
} Packet1, *pPacket1;

typedef struct _Packet2 {   // simple large -I- frame
	byte	flags;
	word    messageid;
	word 	sequence;
	byte	serial;
	byte    data[0];
} Packet2, *pPacket2;	

typedef	struct {
	byte     flag1;     // header flags
	byte     flag2;     // extended flags for small hdr/command for lrg
	byte     flag3;     // nNACK for large hdr.
	byte     pad;		// make it a dword.
} FLAGS, *pFLAGS;

// different frame components that may be part of any
// frame.  type 1 - small frames, type 2 - large frames

//
// ACKNOWLEDGE information
//

typedef struct _ACK1 {
	byte    messageid;
	byte	sequence;
	byte 	serial;
	dword   bytes;		// bytes received from remote
	dword   time;		// time when bytes received was this value
} ACK1, *pACK1;

typedef struct _ACK2 {
	word    messageid;
	word    sequence;
	byte    serial;
	dword   bytes;		// bytes received from remote
	dword   time;		// remote time when bytes receive was this value
} ACK2, *pACK2;	

//
// ABORT
//

typedef struct _ABT1 {
	byte    messageid;
	byte	sequence;
} ABT1, *pABT1;	

typedef struct _ABT2 {
	word	messageid;
	word	sequence;
} ABT2, *pABT2;

//
// MISSING packet information
//

typedef struct _NACK1 {
	byte    messageid;
	byte	sequence;
	dword	bytes;		// bytes received from remote
	dword   time;		// remote time when bytes received was this value
	byte    mask[0];
} NACK1, *pNACK1;

typedef struct _NACK2 {
	word	messageid;
	word	sequence;
	dword   bytes;		// bytes received from remote
	dword   time;		// remote time when bytes received was this value
	byte    mask[0];
} NACK2, *pNACK2;

//
// COMMAND information (including -I- frames)
//

typedef struct _CMD1 {
	byte    messageid;
	byte	sequence;
	byte	serial;
	byte	data[0];
} CMD1, *pCMD1;

typedef struct _CMD2 {
	word	messageid;
	word	sequence;
	byte    serial;
	byte	data[0];
} CMD2, *pCMD2;

#pragma pack(pop)

#endif

/*==============================================================================
                       Protocol Operational description
                       ================================

    Characteristics:
    ----------------
    
	The ARP protocol provides for reliable and non-reliable packet delivery
	over an existing non-reliable (datagram) protocol.  It is assumed that
	packet length information and addressing information is carried by the
	datagram protocol and these fields are therefore ambiguous and excluded
	from ARP.

	ARP is optimized to provide a minimum of overhead in the case of low
	bandwidth links. The overhead per-packet is 3 bytes.

	ARP's default command is the delivery of I frames.  This avoids the need
	for a command field in the protocol header for the most common frame type.

	ARP does segmentation and reassembly on large datagram messages.  This
	allows for datagram delivery of messages larger than 1 packet.

	ARP does a hybrid of windowing with selective NACK of missing packets,
	allowing optimal operation on both good and weak links, regardless
	of latency.

	ARP assigns each frame a serial number that is used in the ACK responses.
	This allows the protocol to keep up to date latency information as well
	as recognize which packet is being responded to in a retry situation. 
	The serial number allows the protocol to adjust timeouts reliably.

	ARP allows multiple messages to be sent concurrently.  Having multiple 
	messages prevents the system from blocking on retry from a single packet 
	transmission failure.  It also allows better use of available bandwidth
	since the protocol does not wait for the ACK from one message before 
	sending the next.

	{FUTURE: What about packet sub-allocation?  Bandwidth allocation?}
	

	Header Description:
	-------------------

	Flags:

	+-----+-----+-----+-----+-----+-----+-----+-----+
	| EXT | BIG | CMD | STA | EOM | SAK | ACK | RLY |  
	+-----+-----+-----+-----+-----+-----+-----+-----+

	Extended Flags:

	Small:

	+-----+-----+-----+-----+-----+-----+-----+-----+
	| EXT |   nNACK   |         COMMAND             |
	+-----+-----+-----+-----+-----+-----+-----+-----+


	Big:

	+-----+-----------------------------------------+
	| EXT |              COMMAND                    | (only if CMD & BIG set)
	+-----+-----------------------------------------+
	| EXT |               nNACK                     |
	+-----+-----------------------------------------+

	Flags:

	STA   - start of a message.
	EOM   - this bit is set when the packet is the last packet of a message
	ACK   - used to signify that this is an ACK packet, otherwise a COMMAND
		    - if nACK != 0, the ACK is informative only. i.e - tells client
		      last ACKed frame that instigated the nACK to update latency
		      information.  An ACK without nACK indicates all frames up
		      to the ACK frame were successfully received.  Any bit set
		      in the nACK mask indicates a missing frame, any 0 bit indicates
		      a frame that was successfully received.
	SAK   - when this bit is set, the receiver must send an ACK packet
	        for this packet.
	RLY   - indicates that this message is being delivered reliably.
	BIG   - when this bit is set, the packets are in large format TYPE 3.
	CMD   - command frame.  When this bit is set, the packet contains a 
	        command.  If there is no COMMAND field it is an I frame.
	EXT   - when the BIG bit is not set, indicates extended flags are present.

	Extended Flags:

	nNACK - if non-zero indicates presence of nNACK byte masks.  The NACK 
			field consists of a sequence number followed by nNACK byte masks.  
			Each bit in the mask represents a packet after the packet specified
			in the sequence number.  The packet in the sequence number is also
			being NACKed.
	
	Command:

	The command field is used to specify protocol subcommands.  The following
	are defined.  Commands larger than 15 require BIG packets.  Commands that
	require responses include the response in the ACK packet.  All protocol
	commands are unreliable.  Each command has its own messageid sequence and
	serial.  This means commands can be of arbitrary length.  The Response
	to a command is also a command.

	0000  0 - Default           - I Frame or ACK/NACK (nACK != 0)
	0001  1 - ABORT
	0010  2 - Ping              - send packet back to sender.
	0011  3 - Ping Response     - a message being returned.
	0100  4 - GetTime           - Get the tick count.
	0101  5 - Get Time Response - Response to the Get Time request.
	0110  6 - SetTime           - Set the tick count.
	0111  7 - Set Time Response - Response to the Set Time request.

	Rule for processing EXT bits.  If a byte in the flags has the high
	bit set, there is one more byte.  Ignore any bits beyond what you know
	how to process.

	Sample Packets:
	===============

	Time setting algorithm?

	Bandwidth Calculations?

	Scheduling?

	Window Size?

	Interpacket wait?

	Send Queue Management?

	Command for selective NACK.

	RLY bit separates 2 streams - reliable/datagram.  For piggyback
	ACK this means reliable piggyback ACKs are only on reliable streams
	and datagram piggyback ACKs are only on non-reliable streams.

==============================================================================*/
#ifdef __DPMESS_INCLUDED__
#define MAX_SEND_HEADER (sizeof(Packet2)+sizeof(MSG_PROTOCOL))
// leave space for a 128 bit NACK message, this is the maximum window we ever allow
#define MAX_SYS_HEADER (sizeof(NACK2)+(128/8)+sizeof(MSG_PROTOCOL))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\receive.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

	RECEIVE.C

Abstract:

	Receive Handler and Receive Thread.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
  02/18/98 aarono  Added support for SendEx
   6/6/98  aarono  Turn on throttling and windowing
   6/10/98 aarono  Allow out of order receives when requested by application
   4/15/99 aarono  Take a Send reference in NACK and ACK handlers
--*/

#include <windows.h>
#include "newdpf.h"
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "protocol.h"
#include "macros.h"
#include "command.h"

// Note: WaitForMultipleObjects has a bug where it restarts the wait in
//       the middle of the list and can run off the end.  We put an extra
//       entry at the end of the object list to deal with this and when
//       we get an invalid_handle error, we just re-wait.

// First object is an event that is signalled when 
// the wait list needs to be changed.


// Receive List Semantics.  The Receive thread 

VOID ProcessACK(PPROTOCOL pProtocol, PCMDINFO pCmdInfo);
VOID ProcessNACK(PPROTOCOL pProtocol, PCMDINFO pCmdInfo, PUCHAR pNACKmask, UINT nNACK);
VOID ProcessAbort(PPROTOCOL pProtocol, DPID idFrom, DPID idTo, pABT1 pABT, BOOL fBig);
VOID SendACK(PPROTOCOL pProtocol, PSESSION pSession, PCMDINFO pCmdInfo);


// Function table for received commands.
UINT (*ProtocolFn[MAX_COMMAND+1])(REQUEST_PARAMS)={
	AssertMe,                                       // 0x00  
	Ping,                               // 0x01  
	PingResp,                                                       // 0x02
	GetTime,                            // 0x03  
	GetTimeResp,                                            // 0x04
	SetTime,                            // 0x05 
	SetTimeResp                                                     // 0x06
};


VOID FreeReceiveBuffers(PRECEIVE pReceive)
{
	BILINK *pBilink;
	PBUFFER pBuffer;
	pBilink=pReceive->RcvBuffList.next;
	while(pBilink != &pReceive->RcvBuffList){
		pBuffer=CONTAINING_RECORD(pBilink, BUFFER, BuffList);
		pBilink=pBilink->next;
		FreeFrameBuffer(pBuffer);
	}
}

VOID CopyReceiveBuffers(PRECEIVE pReceive,PVOID pBuffers,UINT nBuffers)
{
	#define MemDesc(_i) (*(((PMEMDESC)pBuffers)+(_i)))

	PBUFFER  pBuffer;

	UINT    BytesToCopy;
	
	UINT    BuffLen;
	UINT    BuffOffset;

	UINT    mdlen;
	UINT    mdoffset;

	UINT    i=0;

	PUCHAR  src;
	PUCHAR  dest;
	UINT    len;

	BytesToCopy=pReceive->MessageSize;

	pBuffer=(PBUFFER)pReceive->RcvBuffList.next;
	BuffLen=(UINT)(pBuffer->len-(pBuffer->pCmdData-pBuffer->pData));
	BuffOffset=0;
	
	mdlen=MemDesc(0).len;
	mdoffset=0;

	while(BytesToCopy){
		if(!mdlen){
			i++;
			mdlen=MemDesc(i).len;
			mdoffset=0;
			ASSERT(i<nBuffers);
		}
		if(!BuffLen){
			pBuffer=pBuffer->pNext;
			ASSERT(pBuffer);
			BuffLen=(UINT)(pBuffer->len-(pBuffer->pCmdData-pBuffer->pData));
			BuffOffset=0;
		}
		
		src=&pBuffer->pCmdData[BuffOffset];
		dest=&(MemDesc(i).pData[mdoffset]);

		if(BuffLen > mdlen){
			len=mdlen;
			BuffOffset+=len;
		} else {
			len=BuffLen;
			mdoffset+=len;
		}

		DPF(9,"CopyReceiveBuffers src,dest,len: %x %x %x\n",dest,src,len);

		memcpy(dest,src,len);

		BuffLen-=len;
		mdlen-=len;
		BytesToCopy-=len;
	}
	
	#undef MemDesc  
}

HRESULT _inline ParseHeader(
	FLAGS *pflags, 
	PUCHAR pData,
	UINT * pCommand, 
	UINT *piEOF, 
	UINT *piEOA, 
	UINT *piEON, 
	UINT *pnNACK)
{

	if(pflags->flag1 & BIG){
		// big frame
		if(pflags->flag1 & CMD){
			// big command frame 
			if(pflags->flag1 & EXT){
				// big command frame with explicit command
				*pCommand=pflags->flag2 & ~EXT;
				if(pflags->flag2 & EXT){
					// big command frame with explicit command and NACK
					*pnNACK=pflags->flag3 & ~EXT;
					*piEOF=3;
				} else {
					// big command frame with explicit command, no NACK
					*pnNACK=0;
					*piEOF=2;
				}
			} else {
				// big -I- frame, no NACK
				*pCommand=0;
				*pnNACK=0;
				*piEOF=1;
			}
			
		} else {
			// big supervisory (non-command) frame
			if(pflags->flag1 & EXT){
				// big supervisory frame with nNACK
				*pnNACK=pflags->flag2 & ~EXT;
				ASSERT(*pnNACK);
				*piEOF=2;
			} else {
				// big supervisory frame with no-nNACK
				*pnNACK=0;
				*piEOF=1;
			}
		}
	} else {
		// small frame
		if(pflags->flag1 & CMD){
			// small command frame
			if(pflags->flag1 & EXT){
				// small command frame (with NACK?) and explicit command
				DPF(0,"ERROR PARSING FRAME, NOT RECOGNIZED, ABORTING DECODE\n");
				return DPERR_ABORTED;
				
				*pCommand = pflags->flag2 & CMD_MSK;
				*pnNACK   = (pflags->flag2 & nNACK_MSK) >> nNACK_SHIFT;
				*piEOF = 2;
			} else {
				// small -I- frame, no NACK
				*pCommand = 0;
				*pnNACK = 0;
				*piEOF = 1;
			}
		} else {
			// small supervisory (non-command) frame
			if(pflags->flag1 & EXT){
				*pnNACK   = (pflags->flag2 & nNACK_MSK) >> nNACK_SHIFT;
				*piEOF = 2;
			} else {
				*pnNACK=0;
				*piEOF=1;
			}
		}
	}

	while(pData[(*piEOF)-1]&EXT){
		// Skip past any flags extensions we don't understand.
		// small command frame (with NACK?) and explicit command
		DPF(0,"ERROR PARSING FRAME, NOT RECOGNIZED, ABORTING DECODE\n");
		return DPERR_ABORTED;
		
		(*piEOF)++;
	}
	
	*piEOA=*piEOF;

	// Update any ACK information.
	if((pflags->flag1 & ACK)){ 
		if((pflags->flag1 & BIG)){
			// LARGE ACK
			*piEOA+=sizeof(ACK2);
		} else {
			// SMALL ACK
			*piEOA+=sizeof(ACK1);
		}
	} 

	*piEON = *piEOA;
	
	// Update any NACK information.
	
	if(*pnNACK){
		if((pflags->flag1 & BIG)){
			*piEON+=sizeof(NACK2);
		}else{
			*piEON+=sizeof(NACK1);
		}
		*piEON+=*pnNACK;
	}

	return DP_OK;
}

/*=============================================================================

	ProtocolReceive - Receive handler for protocol, called when we've
					  verified the message is a protocol message and
					  we've been able to allocate receive space for the
					  message
	
    Description:

		Cracks the protocol header on the message and fills in a CMDINFO
		structure to describe the protocol information in the frame.  Then
		dispatches the message along with the CMDINFO to the appropriate
		handler.

		A packet may have ACK or NACK information in the header and still
		be a command packet.  We do ACK/NACK processing first, then we
		do command processing.

		This routine will dispatch to

		ProcessACK
		ProcessNACK
		CommandReceive

    Parameters:     

		idFrom	  - index in player table of sending player
		idTo      - "                      " receiving player
		pBuffer   - a buffer we own with a copy of the message
		pSPHeader - if present can be used to issue a reply without an id.

    Return Values:

		None.

	Notes:
-----------------------------------------------------------------------------*/

VOID ProtocolReceive(PPROTOCOL pProtocol, WORD idFrom, WORD idTo, PBUFFER pBuffer, PVOID pSPHeader)
{
	#define pFrame      ((pPacket1)(pBuffer->pData))
	#define pBigFrame   ((pPacket2)(pBuffer->pData))

	#define pACK        ((pACK1)(&pData[iEOF]))
	#define pBigACK     ((pACK2)(&pData[iEOF]))

	#define pABT        ((pABT1)(&pData[iEOF]))
	#define pBigABT     ((pABT2)(&pData[iEOF]))

	#define pNACK       ((pNACK1)(&pData[iEOA]))
	#define pBigNACK    ((pNACK2)(&pData[iEOA]))

	#define pCMD        ((pCMD1)(&pData[iEON]))
	#define pBigCMD     ((pCMD2)(&pData[iEON]))

	PUCHAR   pData;

	FLAGS    flags;
	
	UINT     command;   // the command if a command frame.
	UINT     nNACK;     // if this is a NACK frame, sizeof bitfield
	UINT     iEOF;      // index past end of flags
	UINT     iEOA;      // index past end of any ACK or ABT information
	UINT     iEON;      // index past end of any NACK information
	UINT     rc=0;

	PUCHAR   pNACKmask;

	HRESULT  hr;

	CMDINFO  CmdInfo;
	PCMDINFO pCmdInfo=&CmdInfo;

	CmdInfo.tReceived=timeGetTime();

	pData=pBuffer->pData;
	memcpy(&flags,pData,sizeof(flags));

	hr=ParseHeader(&flags, pData, &command, &iEOF, &iEOA, &iEON, &nNACK);

	if(hr==DPERR_ABORTED){
		goto exit;
	}

	// Get the DPLAY id's for the indicies

	CmdInfo.idFrom  = GetDPIDByIndex(pProtocol, idFrom);
	if(CmdInfo.idFrom == 0xFFFFFFFF){
		DPF(1,"Rejecting packet with invalid From Id\n",idFrom);
		goto exit;
	}
	CmdInfo.idTo    = GetDPIDByIndex(pProtocol, idTo);
	if(CmdInfo.idTo == 0xFFFFFFFF){
		DPF(1,"Rejecting packet with invalid To Id\n");
		goto exit;
	}

	DPF(9,"Protocol Receive idFrom %x idTo %x\n",CmdInfo.idFrom,CmdInfo.idTo);

	
	CmdInfo.wIdFrom = idFrom;
	CmdInfo.wIdTo   = idTo;
	CmdInfo.flags   = flags.flag1;
	CmdInfo.pSPHeader = pSPHeader;

	// determine masks to use for this size frame
	if(flags.flag1 & BIG){
		IDMSK     = 0xFFFF;
		SEQMSK    = 0xFFFF;
	} else {
		IDMSK     = 0xFF;
		SEQMSK    = 0xFF;
	}

	if((flags.flag1 & ACK))
	{
		// Process the ACK field (could be piggyback).
		if(flags.flag1 & BIG){
			pCmdInfo->messageid = pBigACK->messageid;
			pCmdInfo->sequence  = pBigACK->sequence;
			pCmdInfo->serial    = pBigACK->serial;
			pCmdInfo->bytes     = pBigACK->bytes;
			pCmdInfo->tRemoteACK= pBigACK->time;
		} else {
			pCmdInfo->messageid = pACK->messageid;
			pCmdInfo->sequence  = pACK->sequence;
			pCmdInfo->serial    = pACK->serial;
			pCmdInfo->bytes     = pACK->bytes;
			pCmdInfo->tRemoteACK= pACK->time;
		}       
		DPF(9,"ACK: msgid: %d seq %d serial %d\n",CmdInfo.messageid, CmdInfo.sequence, CmdInfo.serial);
		if(CmdInfo.serial==150){
			// this is a little excessive for retries, break out so we can debug this.
			DPF(0,"ProtocolReceive: WHOOPS, 150 retries is a little excessive\n");
			ASSERT(0);
		}	
		ProcessACK(pProtocol, &CmdInfo);
	}

	if(nNACK){
		if(flags.flag1 & BIG){
			CmdInfo.messageid = pBigNACK->messageid;
			CmdInfo.sequence  = pBigNACK->sequence;
			CmdInfo.bytes     = pBigNACK->bytes;
			CmdInfo.tRemoteACK= pBigNACK->time;
			pNACKmask         = pBigNACK->mask;
		} else {
			CmdInfo.messageid = pNACK->messageid;
			CmdInfo.sequence  = pNACK->sequence;
			CmdInfo.bytes     = pNACK->bytes;
			CmdInfo.tRemoteACK= pNACK->time;
			pNACKmask         = pNACK->mask;
		}
		DPF(9,"NACK: msgid: %d seq %d\n",CmdInfo.messageid, CmdInfo.sequence);
		ProcessNACK(pProtocol, &CmdInfo, pNACKmask, nNACK);
	}

#ifdef DEBUG
	if((flags.flag1 & ACK) || nNACK)
	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_RemBytesReceived=CmdInfo.bytes;
		DbgWriteStats(&InWS);
	}
#endif

	if((flags.flag1 & CMD)){

		CmdInfo.command = command;
		
		if((flags.flag1 & BIG)){
			CmdInfo.messageid= pBigCMD->messageid;
			CmdInfo.sequence = pBigCMD->sequence;
			CmdInfo.serial   = pBigCMD->serial;
			pBuffer->pCmdData = pData+iEON+5;//(+5 for messageid(2), sequence(2), serial(1))
		} else {
			CmdInfo.messageid= pCMD->messageid;
			CmdInfo.sequence = pCMD->sequence;
			CmdInfo.serial   = pCMD->serial;
			pBuffer->pCmdData = pData+iEON+3;//(+3 for byte messageid,seq,serial)
		}

		rc=CommandReceive(pProtocol, &CmdInfo, pBuffer);
	}

	if(!rc){
exit:
		FreeFrameBuffer(pBuffer);
	}
	return;
	
	#undef pNACK   
	#undef pBigNACK

	#undef pCMD   
	#undef pBigCMD

	#undef pABT
	#undef pBigABT

	#undef pACK
	#undef pBigACK

	#undef pBigFrame
	#undef pFrame
}

VOID FreeReceive(PPROTOCOL pProtocol, PRECEIVE pReceive)
{
	DPF(9,"Freeing Receive %x\n",pReceive);
	FreeReceiveBuffers(pReceive);
	ReleaseRcvDesc(pProtocol, pReceive);
}

#ifdef DEBUG
VOID DebugScanForMessageId(BILINK *pBilink, UINT messageid)
{
	BILINK *pBilinkWalker;
	PRECEIVE pReceive;
	
	pBilinkWalker=pBilink->next;
	while(pBilinkWalker!=pBilink){
		pReceive=CONTAINING_RECORD(pBilinkWalker,RECEIVE,pReceiveQ);
		if(pReceive->messageid==messageid){
			DPF(0,"ERROR: MESSAGEID x%x already exists in pReceive %x\n",pReceive);
			DEBUG_BREAK();
		}
		pBilinkWalker=pBilinkWalker->next;
	}
}
#else
#define DebugScanForMessageId(_a,_b)
#endif

#ifdef DEBUG
VOID DbgCheckReceiveStart(PSESSION pSession,PRECEIVE pReceive,PBUFFER pBuffer)
{
	BILINK *pBilink;
	PBUFFER pBuffWalker;
	
	pBilink=pReceive->RcvBuffList.next;

	while(pBilink != &pReceive->RcvBuffList){
		pBuffWalker=CONTAINING_RECORD(pBilink, BUFFER, BuffList);
		pBilink=pBilink->next;
		
			if(pBuffWalker->sequence==1){
				break;
			}
	}

	if( ((pBuffer->len-(pBuffer->pCmdData-pBuffer->pData)) != (pBuffWalker->len-(pBuffWalker->pCmdData-pBuffWalker->pData))) ||

	   (memcmp(pBuffWalker->pCmdData, 
	   		   pBuffer->pCmdData, 
	   		   (UINT32)(pBuffer->len-(pBuffer->pCmdData-pBuffer->pData)))) )
	{
		DPF(0,"Different retry start buffer, pSession %x, pReceive %x, pBufferOnList %x, pBuffer %x\n",pSession,pReceive,pBuffWalker,pBuffer);
		DEBUG_BREAK();
	}
	// compare the buffers
}

#else
#define DbgCheckReceiveStart
#endif

// If a receive is returned, it is locked on behalf of the caller.
/*=============================================================================

	GetReceive - for a received data message find the receive structure
	             or create one.  If this message is a retry of a completed
	             message, send an extra ACK.

    Description:

    Parameters:     
    	pProtocol
    	pSession
    	pCmdInfo

    Return Values:
    	PRECEIVE - pointer to receive for this frame

	
	Notes:
-----------------------------------------------------------------------------*/
PRECEIVE GetReceive(PPROTOCOL pProtocol, PSESSION pSession, PCMDINFO pCmdInfo, PBUFFER pBuffer)
{
	#define flags pCmdInfo->flags

	BOOL fFoundReceive=FALSE;

	BILINK *pBiHead, *pBilink;
	PRECEIVE pReceive=NULL,pReceiveWalker;

	DPF(9,"==>GetReceive pSession %x\n",pSession);

	Lock(&pSession->SessionLock);

	// Scan the queue on the SESSION for a RECEIVE with this messageid.

	if(flags & RLY){
		pBiHead = &pSession->pRlyReceiveQ;
		if(!pSession->fReceiveSmall){
			IDMSK = 0xFFFF;
		}
	} else {
		pBiHead = &pSession->pDGReceiveQ;
		if(!pSession->fReceiveSmallDG){
			IDMSK = 0xFFFF;
		}
	}
	
	pBilink = pBiHead->next;

	while(pBilink != pBiHead){

		pReceive=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		ASSERT_SIGN(pReceive, RECEIVE_SIGN);
		pBilink=pBilink->next;

		if(pReceive->messageid==pCmdInfo->messageid){

			Lock(&pReceive->ReceiveLock);
		
			if(!pReceive->fBusy){
			
				ASSERT(pReceive->command   == pCmdInfo->command);
				ASSERT(pReceive->fReliable == (flags & RLY));
				
				fFoundReceive=TRUE;
				break;
				
			} else {

				Unlock(&pReceive->ReceiveLock);
				// its moving, so its done.  Ignore.
				// there is probably a racing ACK already so ignore is fine.
				DPF(9,"GetReceive: Receive %x for messageid x%x is completing already, so ignoring receive\n",pReceive,pReceive->messageid);
				ASSERT(0);
				pReceive=NULL;
				goto exit;
			}
		}
	}

	if(!fFoundReceive){
		DPF(9,"GetReceive: Didn't find a receive for messageid x%x\n",pCmdInfo->messageid);
		pReceive=NULL;
	} else {
		DPF(9,"GetReceive: Found receive %x for messageid x%x\n",pReceive, pCmdInfo->messageid);
	}

	if(pReceive && ( flags & STA )){
		// Should get blown away below - this is the start frame, but we already got it
		DPF(9,"GetReceive: Got start for receive %x messageid x%x we already have going\n",pReceive, pCmdInfo->messageid);
		DbgCheckReceiveStart(pSession,pReceive,pBuffer);
		Unlock(&pReceive->ReceiveLock);
		pReceive=NULL;
		goto ACK_EXIT;
	}
	
	if(!pReceive){
		if(flags & RLY){
			UINT MsgIdDelta;
			DWORD bit;
			
			MsgIdDelta=(pCmdInfo->messageid - pSession->FirstRlyReceive)&IDMSK;
			bit=MsgIdDelta-1;

			if((bit > MAX_LARGE_CSENDS) || (pSession->InMsgMask & (1<<bit))){
				DPF(9,"GetReceive: dropping extraneous rexmit data\n");
				if(flags & EOM|SAK) {
					// RE-ACK the message.
					DPF(9,"GetReceive: Sending extra ACK anyway\n");
					goto ACK_EXIT;
				}
				goto exit; // Drop it, this is for an old message.
			} else {

//			if( (MsgIdDelta==0) || 
//				((pSession->fReceiveSmall)?(MsgIdDelta > MAX_SMALL_CSENDS):(MsgIdDelta > MAX_LARGE_CSENDS))){
//				DPF(5,"GetReceive: dropping extraneous rexmit data\n");
//				if(flags & EOM|SAK) {
//					// RE-ACK the message.
//					DPF(5,"GetReceive: Sending extra ACK anyway\n");
//					goto ACK_EXIT;
//				}
//				goto exit; // Drop it, this is for an old message.
//			} else {
				if(flags & STA){
					if(pSession->LastRlyReceive==pCmdInfo->messageid){
						DPF(9,"RECEIVE: dropping resend for messageid x%x, but ACKING\n",pCmdInfo->messageid);
						// RE-ACK the message.
						goto ACK_EXIT;
					}      

					if(((pSession->LastRlyReceive-pSession->FirstRlyReceive)&IDMSK)<MsgIdDelta){
						pSession->LastRlyReceive=pCmdInfo->messageid;
						DPF(9,"GetReceive: New messageid x%x FirstRcv %x LastRcv %x\n",pCmdInfo->messageid,pSession->FirstRlyReceive,pSession->LastRlyReceive);
						#ifdef DEBUG
						if(!pSession->fReceiveSmall){
							if(((pSession->LastRlyReceive-pSession->FirstRlyReceive) & 0xFFFF) > MAX_LARGE_CSENDS){
								ASSERT(0);
							}
						} else {
							if(((pSession->LastRlyReceive-pSession->FirstRlyReceive) & 0x0FF) > MAX_SMALL_CSENDS){
								ASSERT(0);
							}
						}
						#endif

					}
				}
			}
		} else {
		
			// Nonreliable, blow away any messages outside the window.
			// also blow away any residual messages with same number if we are a START.
			pBiHead = &pSession->pDGReceiveQ;
			pBilink = pBiHead->next;
			while( pBilink != pBiHead ){
			
				pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
				ASSERT_SIGN(pReceiveWalker, RECEIVE_SIGN);
				pBilink=pBilink->next;

				if(!pReceiveWalker->fBusy && 
						( (((pCmdInfo->messageid - pReceiveWalker->messageid) & IDMSK ) > ((pSession->fReceiveSmallDG)?(MAX_SMALL_DG_CSENDS):(MAX_LARGE_DG_CSENDS))) ||
						  ((flags&STA) && pCmdInfo->messageid==pReceiveWalker->messageid) 
						)
					){

					Lock(&pReceiveWalker->ReceiveLock);
					if(!pReceiveWalker->fBusy){
						DPF(9,"GetReceive: Got Id %d Throwing Out old Datagram Receive id %d\n",pCmdInfo->messageid,pReceiveWalker->messageid);
						Delete(&pReceiveWalker->pReceiveQ);
						Unlock(&pReceiveWalker->ReceiveLock);
						FreeReceive(pProtocol,pReceiveWalker);
					} else {
						ASSERT(0);
						DPF(0,"GetReceive: Got Id %d Couldn't throw out DG id %d\n",pCmdInfo->messageid,pReceiveWalker->messageid);
						Unlock(&pReceiveWalker->ReceiveLock);
					}
				}       
			}       
		}
		
		// Allocate a receive structure
		if(flags & STA){
			pReceive=GetRcvDesc(pProtocol);
			DPF(9,"allocated new receive %x messageid x%x\n",pReceive,pCmdInfo->messageid);
			if(!pReceive){
				// no memory, drop it.
				ASSERT(0);
				DPF(0,"RECEIVE: no memory! dropping packet\n");
				goto exit;
			}

			pReceive->pSession    = pSession;
			pReceive->fBusy       = FALSE;
			pReceive->fReliable   = flags&RLY;
			pReceive->fEOM        = FALSE;
			pReceive->command     = pCmdInfo->command;
			pReceive->messageid   = pCmdInfo->messageid;
			pReceive->iNR         = 0;
			pReceive->NR          = 0; 
			pReceive->NS          = 0;
			pReceive->RCVMask     = 0;
			pReceive->MessageSize = 0;
			InitBilink(&pReceive->RcvBuffList);
			Lock(&pReceive->ReceiveLock);
			
		
			if(flags & RLY){
				// Set bit in incoming receive mask;
				DebugScanForMessageId(&pSession->pRlyReceiveQ, pCmdInfo->messageid);
				InsertAfter(&pReceive->pReceiveQ,&pSession->pRlyReceiveQ);
			} else {
				DebugScanForMessageId(&pSession->pDGReceiveQ, pCmdInfo->messageid);
				InsertAfter(&pReceive->pReceiveQ,&pSession->pDGReceiveQ);
			}       
			// Save the SP header for indications
			if(pCmdInfo->pSPHeader){
				pReceive->pSPHeader=&pReceive->SPHeader[0];
				memcpy(pReceive->pSPHeader, pCmdInfo->pSPHeader, pProtocol->m_dwSPHeaderSize);
			} else {
				pReceive->pSPHeader=NULL;
			}
		}       
	}

exit:   
	Unlock(&pSession->SessionLock);

unlocked_exit:  
	DPF(9,"<==GetReceive pSession %x pReceive %x\n",pSession, pReceive);

	return pReceive;

	#undef flags

ACK_EXIT:
	Unlock(&pSession->SessionLock);
	SendACK(pProtocol,pSession,pCmdInfo);
	goto unlocked_exit;
}

VOID PutBufferOnReceive(PRECEIVE pReceive, PBUFFER pBuffer)
{
	BILINK *pBilink;
	PBUFFER pBuffWalker;
	
	pBilink=pReceive->RcvBuffList.prev;

	while(pBilink != &pReceive->RcvBuffList){
		pBuffWalker=CONTAINING_RECORD(pBilink, BUFFER, BuffList);
		#ifdef DEBUG
			if(pBuffWalker->sequence==pBuffer->sequence){
				DPF(0,"already have sequence queued?\n");
				DEBUG_BREAK();
				break;
			}
		#endif
		if(pBuffWalker->sequence < pBuffer->sequence){
			break;
		}
		pBilink=pBilink->prev;
	}
	
	InsertAfter(&pBuffer->BuffList, pBilink);
}

// Chains receives that must be also be completed on this Receive
VOID ChainReceiveFromQueue(PSESSION pSession, PRECEIVE pReceive, UINT messageid)
{
	BOOL bFound=FALSE;
	BILINK *pBilink;
	PRECEIVE pReceiveWalker;

	DPF(9,"==>ChainReceiveFromQueue on pReceive %x, chain messageid x%x\n",pReceive,messageid);

	ASSERT(messageid!=pReceive->messageid);
	ASSERT(!EMPTY_BILINK(&pSession->pRlyWaitingQ));

	pBilink=pSession->pRlyWaitingQ.next;

	while(pBilink != &pSession->pRlyWaitingQ){
		pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		if(pReceiveWalker->messageid==messageid){
			bFound=TRUE;
			break;
		}
		pBilink=pBilink->next;
	}

	if(bFound){
		// store in order on pReceive->pReceiveQ
		Delete(&pReceiveWalker->pReceiveQ);
		InsertBefore(&pReceiveWalker->pReceiveQ,&pReceive->pReceiveQ);
		DPF(9,"<==ChainReceiveFromQueue: Chained pReceiveWalker %x messageid x%x on pReceive %x\n",pReceiveWalker, pReceiveWalker->messageid, pReceive);
	} else {
#ifdef DEBUG
		DPF(9,"<==ChainReceiveFromQueue, messageid x%x NOT FOUND!!!, Maybe out of order receive\n",messageid);
		if(!(pSession->pProtocol->m_lpDPlay->dwFlags & DPLAYI_DPLAY_PROTOCOLNOORDER)){
			DPF(0,"<==ChainReceiveFromQueue, messageid x%x NOT FOUND!!!, NOT ALLOWED with PRESERVE ORDER\n",messageid);
			DEBUG_BREAK();
		}
#endif	
	}

}

VOID BlowAwayOldReceives(PSESSION pSession, DWORD messageid, DWORD MASK)
{
	BOOL fFoundReceive=FALSE;

	BILINK *pBiHead, *pBilink;
	PRECEIVE pReceive=NULL;

	pBiHead = &pSession->pRlyReceiveQ;
	pBilink = pBiHead->next;

	while(pBilink != pBiHead){

		pReceive=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		ASSERT_SIGN(pReceive, RECEIVE_SIGN);
		pBilink=pBilink->next;

		if((int)((pReceive->messageid-messageid)&MASK) <= 0){

			Lock(&pReceive->ReceiveLock);

			if(!pReceive->fBusy){

				DPF(8,"Blowing away duplicate receive %x id\n",pReceive, pReceive->messageid);
			
				Delete(&pReceive->pReceiveQ);
				Unlock(&pReceive->ReceiveLock);
				FreeReceive(pSession->pProtocol, pReceive);
				
			} else {
				DPF(0,"Huston, we have a problem pSession %x, pReceive %x, messageid %d\n",pSession,pReceive,messageid);
				DEBUG_BREAK();
				Unlock(&pReceive->ReceiveLock);
			}
		}
	}
}


// called with receive lock held, SESSIONion lock unheld, 
// returns with receivelock unheld, but receive not on any lists.
// 0xFFFFFFFF means receive was bogus and blown away
UINT DeQueueReceive(PSESSION pSession, PRECEIVE pReceive, PCMDINFO pCmdInfo)
{
	UINT bit;
	UINT nComplete=0;

	DPF(9,"==>DQReceive pReceive %x, messageid x%x\n",pReceive, pReceive->messageid);

		pReceive->fBusy=TRUE;
		Unlock(&pReceive->ReceiveLock);
		
	Lock(&pSession->SessionLock);
		Lock(&pReceive->ReceiveLock);

			// Pull off of receive Q
			Delete(&pReceive->pReceiveQ);
			InitBilink(&pReceive->pReceiveQ); // so we can chain on here.
			pReceive->fBusy=FALSE;

			bit=((pReceive->messageid-pSession->FirstRlyReceive)&IDMSK)-1;

			if(bit >= MAX_LARGE_CSENDS){
				// Duplicate receive, blow it away
				Unlock(&pReceive->ReceiveLock);
				FreeReceive(pSession->pProtocol,pReceive);
				Unlock(&pSession->SessionLock);
				return 0xFFFFFFFF;
			}

			#ifdef DEBUG
				if(pSession->InMsgMask > (UINT)((1<<((pSession->LastRlyReceive-pSession->FirstRlyReceive)&IDMSK))-1)){
					DPF(0,"Bad InMsgMask %x pSession %x\n", pSession->InMsgMask, pSession);
					DEBUG_BREAK();
				}
			#endif	

			pSession->InMsgMask |= 1<<bit;

			while(pSession->InMsgMask&1){
				nComplete++;
				pSession->FirstRlyReceive=(pSession->FirstRlyReceive+1)&IDMSK;
				BlowAwayOldReceives(pSession, pSession->FirstRlyReceive,IDMSK);
				if(nComplete > 1){
					// Chain extra receives to be indicated on this receive.
					ChainReceiveFromQueue(pSession, pReceive,pSession->FirstRlyReceive);
				}
				pSession->InMsgMask>>=1;
			}

			#ifdef DEBUG
				DPF(9,"DQ: FirstRcv %x LastRcv %x\n",pSession->FirstRlyReceive,pSession->LastRlyReceive);
				if((pSession->LastRlyReceive-pSession->FirstRlyReceive & IDMSK) > MAX_LARGE_CSENDS){
					DEBUG_BREAK();
				}
			#endif	
			
		Unlock(&pReceive->ReceiveLock);
	Unlock(&pSession->SessionLock);

	DPF(9,"<==DQReceive pReceive %x nComplete %d\n",pReceive,nComplete);
	
	return nComplete;
}

// called with receive lock held, SESSIONion lock unheld, 
// returns with receivelock unheld, but receive not on any lists.
VOID DGDeQueueReceive(PSESSION pSession, PRECEIVE pReceive)
{
		pReceive->fBusy=TRUE;
		Unlock(&pReceive->ReceiveLock);
	Lock(&pSession->SessionLock);
		Lock(&pReceive->ReceiveLock);
			// Pull off of receive Q
			Delete(&pReceive->pReceiveQ);
			InitBilink(&pReceive->pReceiveQ);
			pReceive->fBusy=FALSE;
		Unlock(&pReceive->ReceiveLock);
	Unlock(&pSession->SessionLock);
}

#ifdef DEBUG
VOID CheckWaitingQ(PSESSION pSession, PRECEIVE pReceive, PCMDINFO pCmdInfo)
{
	BILINK *pBilink;
	PRECEIVE pReceiveWalker;
	UINT     iReceiveWalker; 
	UINT     iReceive;  // our index based on FirstRlyReceive 

	DPF(9,"==>Check WaitingQ\n");

	Lock(&pSession->SessionLock);

	iReceive=(pReceive->messageid-pSession->FirstRlyReceive)&IDMSK;
	
	pBilink=pSession->pRlyWaitingQ.next;

	while(pBilink != &pSession->pRlyWaitingQ){
		pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		iReceiveWalker=(pReceiveWalker->messageid-pSession->FirstRlyReceive)&IDMSK;
		
		if((int)iReceiveWalker < 0){
			DEBUG_BREAK();
		}
		
		if(iReceiveWalker == iReceive){
			DPF(9,"Found Duplicate Receive index %d on WaitingQ %x pSession %x\n",iReceiveWalker, &pSession->pRlyWaitingQ, pSession);
			// found our insert point.
			break;
		}
		pBilink=pBilink->next;
	}
	
	Unlock(&pSession->SessionLock);
	DPF(9,"<==CheckWaitingQ\n");
	
}
#else
#define CheckWaitingQ
#endif

#ifdef DEBUG
VOID DUMPBYTES(PCHAR pBytes, DWORD nBytes)
{
	CHAR Target[16];
	INT i;

	i=0;
	while(nBytes){
	
		memset(Target,0,16);

		if(nBytes > 16){
			memcpy(Target,pBytes+i*16,16);
			nBytes-=16;
		} else {
			memcpy(Target,pBytes+i*16,nBytes);
			nBytes=0;
		}

		DPF(9,"%04x:  %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x\n", i*16,
		Target[0],Target[1],Target[2],Target[3],Target[4],Target[5],Target[6],Target[7],
		Target[8],Target[9],Target[10],Target[11],Target[12],Target[13],Target[14],Target[15]); 
		
		i++;
	}	

}
#else
#define DUMPBYTES(a,b)
#endif

// Out of order reliable message, queue it up on the session.
VOID QueueReceive(PPROTOCOL pProtocol, PSESSION pSession, PRECEIVE pReceive, PCMDINFO pCmdInfo)
{
	BILINK *pBilink;
	PRECEIVE pReceiveWalker;
	UINT     iReceiveWalker; 
	UINT     iReceive;  // our index based on FirstRlyReceive 

	DPF(9,"==>QueueReceive Out of order pReceive %x messageid x%x\n",pReceive,pReceive->messageid);

	Lock(&pSession->SessionLock);
	// Don't need the receive lock since receive already dequeued.

	// insert the receive into the pRlyWaitingQ, in order - 
	// based pSession->FirstRlyReceive IDMSK
	// list is ordered left to right, scan from end for our slot.

	CheckWaitingQ(pSession, pReceive, pCmdInfo);

	iReceive=(pReceive->messageid-pSession->FirstRlyReceive)&IDMSK;
	
	pBilink=pSession->pRlyWaitingQ.prev;

	while(pBilink != &pSession->pRlyWaitingQ){
		pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		iReceiveWalker=(pReceiveWalker->messageid-pSession->FirstRlyReceive)&IDMSK;
		
		if((int)iReceiveWalker < 0){
			DEBUG_BREAK();
		}
		
		if(iReceiveWalker < iReceive){
			// found our insert point.
			break;
		}
		pBilink=pBilink->prev;
	}
	
	// insert in the list.

	InsertAfter(&pReceive->pReceiveQ,pBilink);
	
	Unlock(&pSession->SessionLock);
	DPF(9,"<==QueueReceive Out of order pReceive\n");
}

VOID IndicateReceive(PPROTOCOL pProtocol, PSESSION pSession, PRECEIVE pReceive, UINT nToIndicate)
{
	PDOUBLEBUFFER pDoubleBuffer;
	MEMDESC memdesc;

	BILINK *pBilink, *pBilinkAnchor;
	PRECEIVE pReceiveWalker;

	DPF(9,"==>IndicateReceive pReceive %x nToIndicate %d\n",pReceive,nToIndicate);

	pBilink=pBilinkAnchor=&pReceive->pReceiveQ;
	
	do{
		pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);

		// Assemble the message into one frame (if it isn't already)

		if(pReceiveWalker->iNR==1){
			// one frame.
			BILINK *pBilink;
			PBUFFER pBuffer;
			
			pBilink=pReceiveWalker->RcvBuffList.next;
			
			pBuffer=CONTAINING_RECORD(pBilink, BUFFER, BuffList);
			LEAVE_DPLAY();
			DPF(9,"Single Indicating pReceive %x messageid x%x\n",pReceiveWalker, pReceiveWalker->messageid);
			DUMPBYTES(pBuffer->pCmdData, min((UINT32)(pBuffer->len-(pBuffer->pCmdData-pBuffer->pData)),48));
			InternalHandleMessage(pProtocol->m_lpISP,
								pBuffer->pCmdData,
								(ULONG32)(pBuffer->len-(pBuffer->pCmdData-pBuffer->pData)),
								pReceiveWalker->pSPHeader,0);
			ENTER_DPLAY();                                  
								
		} else {

			// multiple frames, copy to a contiguous chunk.
			
			pDoubleBuffer=GetDoubleBuffer(pReceiveWalker->MessageSize);
			if(pDoubleBuffer){

				memdesc.pData=pDoubleBuffer->pData;
				memdesc.len=pDoubleBuffer->len;

				CopyReceiveBuffers(pReceiveWalker,&memdesc,1);

				LEAVE_DPLAY();
				DPF(9,"Multi Indicating pReceive %x messageid x%x\n",pReceiveWalker, pReceiveWalker->messageid);
				
				DUMPBYTES(memdesc.pData, min(memdesc.len,48));
				
				InternalHandleMessage(pProtocol->m_lpISP,
									memdesc.pData,
									memdesc.len,
									pReceiveWalker->pSPHeader,0);
				ENTER_DPLAY();

				FreeDoubleBuffer((PBUFFER)pDoubleBuffer);
			} else {
				DPF(0,"NO MEMORY, MESSAGE DROPPED!\n");
				ASSERT(0);
			}
		}

		pBilink=pBilink->next;
		FreeReceive(pProtocol, pReceiveWalker);
		
	} while (pBilink != pBilinkAnchor);
	
	DPF(9,"<==IndicateReceive\n");
}

// called with receive lock held, must release
int ReliableAccept(PPROTOCOL pProtocol, PSESSION pSession, PRECEIVE pReceive, PCMDINFO pCmdInfo, PBUFFER pBuffer)
{
	int rc=0,rc2;

	UINT sequence;
	UINT bit;
	UINT bitmask;
	UINT nToIndicate;
	
	// if its moving, we already have all the data, so drop this.(BUGBUG: maybe ACK again?)
	if(!pReceive->fBusy){
		
		bit=(pCmdInfo->sequence-pReceive->NR-1 ) & SEQMSK;

		if(bit < 32){

			// Calculate absolute sequence number of this packet.
			pBuffer->sequence = sequence = (bit+1) + pReceive->iNR;
			
			bitmask=1<<bit;

			if((pReceive->RCVMask & bitmask)){
			
				rc=FALSE; // already got this one - reject.
				
			} else {

				// Accept it.

				PutBufferOnReceive(pReceive,pBuffer);
				pReceive->MessageSize+=(UINT)((pBuffer->pData+pBuffer->len)-pBuffer->pCmdData);

				pReceive->RCVMask |= bitmask;

				if( ((pReceive->NS-pReceive->NR)&SEQMSK) <= bit){
					pReceive->NS=(pReceive->NR+bit+1)&SEQMSK;
				}
				
				// update NR based on set received bits.
				while(pReceive->RCVMask & 1){
					pReceive->RCVMask >>= 1;
					pReceive->iNR++;
					pReceive->NR=(pReceive->NR+1)&SEQMSK;
				}

				DPF(9,"Reliable ACCEPT: pReceive %x messageid %x iNR %8x NR %2x, NS %2x RCVMask %8x, SEQMSK %2x\n",pReceive, pReceive->messageid, pReceive->iNR, pReceive->NR,pReceive->NS,pReceive->RCVMask,SEQMSK);

				rc=TRUE; // packet accepted.
			}       
			
		} else {
			DPF(9,"Reliable ACCEPT: Rejecting Packet Seq %x, NR %x, SEQMSK %x\n",pCmdInfo->sequence, pReceive->NR, SEQMSK);
		}

		if(pCmdInfo->flags & (SAK|EOM)) {
			//ACKrc=SendAppropriateResponse, check code, if ACK on EOM, then POST receive.
			rc2=SendAppropriateResponse(pProtocol, pSession, pCmdInfo, pReceive); 
			
			if(pCmdInfo->flags & EOM){
				if(rc2==SAR_ACK){
					goto ReceiveDone;
				} else {
					pReceive->fEOM=TRUE;    
				}
			} else if(pReceive->fEOM){
				if(!pReceive->RCVMask){
					goto ReceiveDone;
				}
			}
		}
	} else  {
		ASSERT(0);
	}

	Unlock(&pReceive->ReceiveLock);
	return rc;


ReceiveDone:
	DPF(9,"++>ReceiveDone\n");
	if(nToIndicate=DeQueueReceive(pSession, pReceive, pCmdInfo)){   // unlocks pReceive->ReceiveLock
		if(nToIndicate != 0xFFFFFFFF){
			IndicateReceive(pProtocol, pSession, pReceive, nToIndicate);                    
		}	
	} else if(pProtocol->m_lpDPlay->dwFlags & DPLAYI_DPLAY_PROTOCOLNOORDER){
		// Out of order receives are OK
		IndicateReceive(pProtocol, pSession, pReceive, 1);
	} else {
		QueueReceive(pProtocol,pSession,pReceive, pCmdInfo);
	}
	DPF(9,"<--ReceiveDone\n");
	return rc;
}

// Returns highest order byte in n with set bits.
UINT SetBytes(UINT n)
{
	UINT nr;
	if(n==(n&0xFFFF)){
		if(n==(n&0xFF)){
			 nr=1;
		} else {
			 nr=2;
		}
	} else {
		if(n==(n&0xFFFFFF)){
			nr=3;
		} else {
			nr=4;
		}
	}
	return nr;
}

VOID InternalSendComplete(PVOID Context, UINT Status)
{
	PSEND pSend=(PSEND)Context;

	if(pSend->dwFlags & ASEND_PROTOCOL){
		// nothing to do?
	} else if(pSend->bSendEx){
		// send completion if required
		if(pSend->dwFlags & DPSEND_ASYNC){
			DP_SP_SendComplete(pSend->pProtocol->m_lpISP, pSend->lpvUserMsgID, Status);
		}
	}
}

// Used by internal routines for sending.
VOID FillInAndSendBuffer(
	PPROTOCOL pProtocol, 
	PSESSION pSession,
	PSEND pSend,
	PBUFFER pBuffer,
	PCMDINFO pCmdInfo)
{
	pSend->pMessage                 = pBuffer;
	pSend->MessageSize              = pBuffer->len;
	
	pSend->pSession                 = pSession;
	pSend->SendOffset               = 0;
	pSend->pCurrentBuffer           = pBuffer;
	pSend->CurrentBufferOffset      = 0;

	pSend->RefCount             	= 0;
	pSend->pProtocol                = pProtocol;
	pSend->dwMsgID                  = 0;
	pSend->bSendEx                  = FALSE;

//	pSend->BytesThisSend            = 0;

	// Internal sends MUST be highest pri - else can deadlock head to head.
	pSend->Priority                         = 0xFFFFFFFF; 
	pSend->dwFlags                          = ASEND_PROTOCOL;
	pSend->dwTimeOut                        = 0;
	pSend->pAsyncInfo                       = 0;
	pSend->AsyncInfo.hEvent     			= 0;
	pSend->AsyncInfo.SendCallBack			= InternalSendComplete;
	pSend->AsyncInfo.CallBackContext		= pSend;
	pSend->AsyncInfo.pStatus   				= &pSend->Status;
	pSend->SendState                        = Start;
	pSend->RetryCount                       = 0;
	pSend->PacketSize                       = pSession->MaxPacketSize; 

	pSend->NR                               = 0;
	pSend->NS                   			= 0;

	pSend->idFrom                           = pCmdInfo->idTo;
	pSend->idTo                             = pCmdInfo->idFrom;
	pSend->wIdTo							= pCmdInfo->wIdFrom;

	pSend->serial               			= 0;

	ISend(pProtocol,pSession,pSend);
}       


UINT WrapBuffer(PPROTOCOL pProtocol, PCMDINFO pCmdInfo, PBUFFER pBuffer)
{
	PUCHAR pMessage,pMessageStart;
	DWORD dwWrapSize=0;
	DWORD dwIdTo=0;
	DWORD dwIdFrom=0;

	pMessageStart = &pBuffer->pData[pProtocol->m_dwSPHeaderSize];
	pMessage      = pMessageStart;
	dwIdFrom      = pCmdInfo->wIdTo;
	dwIdTo        = pCmdInfo->wIdFrom;
	
	if(dwIdFrom==0x70){ // avoid looking like a system message 'play'
		dwIdFrom=0xFFFF;
	}

	if(dwIdFrom){
		while(dwIdFrom){
			*pMessage=(UCHAR)(dwIdFrom & 0x7F);
			dwIdFrom >>= 7;
			if(dwIdFrom){
				*pMessage|=0x80;
			}
			pMessage++;
		}
	} else {
		*(pMessage++)=0;
	}

	if(dwIdTo){
		
		while(dwIdTo){
			*pMessage=(UCHAR)(dwIdTo & 0x7F);
			dwIdTo >>= 7;
			if(dwIdTo){
				*pMessage|=0x80;
			}
			pMessage++;
		}
	} else {
		*(pMessage++)=0;
	}
	
	return (UINT)(pMessage-pMessageStart);
}       

UINT SendAppropriateResponse(PPROTOCOL pProtocol, PSESSION pSession, PCMDINFO pCmdInfo, PRECEIVE pReceive)
{
	#define pBigACK ((pACK2)pACK)
	#define pBigNACK ((pNACK2)pNACK)

	UINT rc=SAR_FAIL;

	PSEND pSend;

	PBUFFER pBuffer;

	pFLAGS pFlags;
	pACK1  pACK;
	pNACK1 pNACK;

	UINT   RCVMask;

	UINT   WrapSize;

	// BUGBUG: piggyback ACK on pending send if available.

	pSend=GetSendDesc();

	if(!pSend){
		goto exit1;
	}
	
	pBuffer = GetFrameBuffer(pProtocol->m_dwSPHeaderSize+MAX_SYS_HEADER);
	
	if(!pBuffer){
		goto exit2;     // out of memory, bail
	}       

	WrapSize  = pProtocol->m_dwSPHeaderSize;
	WrapSize += WrapBuffer(pProtocol, pCmdInfo, pBuffer);

	pFlags=(pFLAGS)&pBuffer->pData[WrapSize];

	// See if we need to ACK or NACK.
	if(pReceive->RCVMask){
		UINT nNACK=SetBytes(pReceive->RCVMask);
		rc=SAR_NACK;
		// Send a NACK  
		if(pCmdInfo->flags & BIG){
			// BIG HEADER FORMAT NACK
			pNACK=(pNACK1)(&pFlags->flag3);
			pFlags->flag1 = EXT|BIG|RLY;
			pFlags->flag2 = (byte)nNACK;
			pBigNACK->sequence = (word)pReceive->NR;
			pBigNACK->messageid = (word)pReceive->messageid;
			pBigNACK->time = pCmdInfo->tReceived;
			pBigNACK->bytes = pSession->LocalBytesReceived;
			RCVMask=pReceive->RCVMask;
			memcpy(&pBigNACK->mask, &RCVMask, nNACK);
			pBuffer->len=WrapSize+2+sizeof(NACK2)+nNACK; //2 for flags
		} else {
			// SMALL HEADER FORMAT NACK
			pNACK=(pNACK1)(&pFlags->flag3);
			pFlags->flag1 = EXT|RLY;
			ASSERT(nNACK < 4);
			ASSERT(pReceive->NR < 32);
			pFlags->flag2 = nNACK << nNACK_SHIFT;
			pNACK->messageid=(byte)pReceive->messageid;
			pNACK->sequence=(byte)pReceive->NR;
			pNACK->time = pCmdInfo->tReceived;
			pNACK->bytes = pSession->LocalBytesReceived;
			RCVMask=pReceive->RCVMask;
			memcpy(&pNACK->mask, &RCVMask, nNACK);
			pBuffer->len=WrapSize+2+sizeof(NACK1)+nNACK; // 2 for flags
			DPF(9,"RcvMask %x Send Appropriate response nNACK=%d\n",pReceive->RCVMask,nNACK);
		}
	} else {
		// Send an ACK
		rc=SAR_ACK;
		pACK    = (pACK1)(&pFlags->flag2);

		if(pCmdInfo->flags & BIG){
			// Big packet
			pFlags->flag1     = ACK|BIG;
			pBigACK->messageid= (word)pReceive->messageid;
			pBigACK->sequence = pCmdInfo->sequence;
			pBigACK->serial   = pCmdInfo->serial;
			pBigACK->time     = pCmdInfo->tReceived;
			pBigACK->bytes    = pSession->LocalBytesReceived;
			pBuffer->len      = sizeof(ACK2)+1+WrapSize;
		} else {
			// Small packet
			pFlags->flag1   = ACK;
			pACK->messageid = (byte)pReceive->messageid;
			pACK->sequence  = (UCHAR)pCmdInfo->sequence;
			pACK->serial    = pCmdInfo->serial;
			pACK->time      = pCmdInfo->tReceived;
			pACK->bytes     = pSession->LocalBytesReceived;
			pBuffer->len    = sizeof(ACK1)+1+WrapSize;
			DPF(9,"RcvMask %x Send Appropriate response ACK seq=%x\n",pReceive->RCVMask,pACK->sequence);
		}
	}
	
	pFlags->flag1 |= (pCmdInfo->flags & RLY);

	FillInAndSendBuffer(pProtocol,pSession,pSend,pBuffer,pCmdInfo);

exit1:
	return rc;

exit2:
	ReleaseSendDesc(pSend);
	return rc;

#undef pBigACK
#undef pBigNACK
}

// ACKs CmdInfo packet.
VOID SendACK(PPROTOCOL pProtocol, PSESSION pSession, PCMDINFO pCmdInfo)
{
	#define pBigACK ((pACK2)pACK)

	PSEND pSend;

	PBUFFER pBuffer;

	pFLAGS pFlags;
	pACK1 pACK;

	UINT WrapSize;

	// BUGBUG: piggyback ACK on pending send if available.

	pSend=GetSendDesc();

	if(!pSend){
		goto exit1;
	}
	
	// allocation here is bigger than necessary but should 
	// recyle ACK/NACK buffers.
	pBuffer = GetFrameBuffer(pProtocol->m_dwSPHeaderSize+MAX_SYS_HEADER);
	
	if(!pBuffer){
		goto exit2;     // out of memory, bail
	}       

	WrapSize  = pProtocol->m_dwSPHeaderSize;
	WrapSize += WrapBuffer(pProtocol, pCmdInfo, pBuffer);

	pFlags=(pFLAGS)&pBuffer->pData[WrapSize];

	pACK    = (pACK1)(&pFlags->flag2);

	if(pCmdInfo->flags & BIG){
		// Big packet
		pFlags->flag1     = ACK|BIG;
		pBigACK->sequence = pCmdInfo->sequence;
		pBigACK->serial   = pCmdInfo->serial;
		pBigACK->messageid= pCmdInfo->messageid;
		pBigACK->bytes    = pSession->LocalBytesReceived;
		pBigACK->time     = pCmdInfo->tReceived;
		pBuffer->len    = sizeof(ACK2)+1+WrapSize;
	} else {
		// Small packet
		pFlags->flag1   = ACK;
		pACK->messageid = (UCHAR)pCmdInfo->messageid;
		pACK->sequence  = (UCHAR)pCmdInfo->sequence;
		pACK->serial    = pCmdInfo->serial;
		pACK->bytes     = pSession->LocalBytesReceived;
		pACK->time      = pCmdInfo->tReceived;
		pBuffer->len    = sizeof(ACK1)+1+WrapSize;
		DPF(9,"Send Extra ACK seq=%x, serial=%x\n",pACK->sequence,pACK->serial);
	}

	pFlags->flag1 |= (pCmdInfo->flags & RLY);
	
	FillInAndSendBuffer(pProtocol,pSession,pSend,pBuffer,pCmdInfo);
	
exit1:
	return;

exit2:
	ReleaseSendDesc(pSend);
	return;
}

// Called with receive lock.  Returns without lock.
UINT DGAccept(PPROTOCOL pProtocol, PSESSION pSession, PRECEIVE pReceive, PCMDINFO pCmdInfo, PBUFFER pBuffer)
{
	
	ASSERT(!pReceive->fBusy);
	//if(!pReceive->fBusy){

		// Allows datagram receive to start on any serial.
		if(pCmdInfo->flags & STA){
			pReceive->NR=pCmdInfo->serial;
		}
	
		if(pReceive->NR == pCmdInfo->serial){

			pReceive->iNR++;        //really unnecessary, but interesting.

			pReceive->NR = (pReceive->NR+1) & SEQMSK;

			// Add the buffer to the receive buffer list.
			InsertBefore(&pBuffer->BuffList, &pReceive->RcvBuffList);
			pReceive->MessageSize+=(UINT)((pBuffer->pData+pBuffer->len)-pBuffer->pCmdData);

			if(pCmdInfo->flags & EOM){
				DGDeQueueReceive(pSession, pReceive); //unlock's receive.
				IndicateReceive(pProtocol, pSession, pReceive,1);                       
			} else {
				Unlock(&pReceive->ReceiveLock);
			}

			return TRUE; // ate the buffer.
			
		} else {
			// Throw this puppy out.
			ASSERT(!pReceive->fBusy);
			DGDeQueueReceive(pSession, pReceive);
			FreeReceive(pProtocol, pReceive);
		}

	//}
	return FALSE;
}

UINT CommandReceive(PPROTOCOL pProtocol, PCMDINFO pCmdInfo, PBUFFER pBuffer)
{
	#define flags pCmdInfo->flags
	PSESSION      pSession;
	UINT          rc=0;             // by default, buffer not accepted.
	PRECEIVE      pReceive;

	pSession=GetSysSessionByIndex(pProtocol, pCmdInfo->wIdFrom);

	if(!pSession) {
		DPF(9,"CommandReceive: Throwing out receive for gone session\n");
		goto drop_exit;
	}
	
	if(flags & BIG){
		if(flags & RLY) {
			pSession->fReceiveSmall=FALSE;
		} else {
			pSession->fReceiveSmallDG=FALSE;
		}
	}

	// See if this receive is already ongoing - if found, it is locked.
	pReceive=GetReceive(pProtocol, pSession, pCmdInfo, pBuffer);

	if(pCmdInfo->command==0){
		pSession->LocalBytesReceived+=pBuffer->len;
	}

	if(!(flags & RLY)){
		if(flags & (SAK|EOM)) {
			SendACK(pProtocol, pSession, pCmdInfo);
		}
	}

	if(pReceive){
		if(flags & RLY){
			// unlocks receive when done.
			rc=ReliableAccept(pProtocol, pSession, pReceive, pCmdInfo, pBuffer);
		} else {
			rc=DGAccept(pProtocol, pSession, pReceive, pCmdInfo, pBuffer);
		}
	}


	DecSessionRef(pSession);
	
drop_exit:
	return rc;

	#undef flags
}


BOOL CompleteSend(PSESSION pSession, PSEND pSend, PCMDINFO pCmdInfo)
{
	UINT bit;
	UINT MsgMask;

	pSend->SendState=Done;

	if(pCmdInfo->flags & BIG){
		MsgMask = 0xFFFF;
	} else {
		MsgMask = 0xFF;
	}       

	DPF(9,"CompleteSend, pSession %x pSend %x\n",pSession,pSend);

	//
	// Update Session information for completion of this send.
	//
	
	bit = ((pCmdInfo->messageid-pSession->FirstMsg) & MsgMask)-1;

	// clear the message mask bit for the completed send.
	if(pSession->OutMsgMask & 1<<bit){
		pSession->OutMsgMask &= ~(1<<bit);
	} else {
		Unlock(&pSession->SessionLock);
		return TRUE;
	}

	// slide the first message count forward for each low
	// bit clear in Message mask.
	while(pSession->LastMsg-pSession->FirstMsg){
		if(!(pSession->OutMsgMask & 1)){
			pSession->FirstMsg=(pSession->FirstMsg+1)&MsgMask;
			pSession->OutMsgMask >>= 1;
			if(pSession->nWaitingForMessageid){
				pSession->pProtocol->m_bRescanQueue=TRUE;
				DPF(9,"Signalling reliable ID Sem, nWaitingForMessageid was %d\n",pSession->nWaitingForMessageid);
				SetEvent(pSession->pProtocol->m_hSendEvent);
			}       
		} else {
			break;
		}
	}
	
	//
	// Return the Send to the pool and complete the waiting client.
	//

	Unlock(&pSession->SessionLock);
	
	ASSERT(pSend->RefCount);

	// Send completed, do completion
	DoSendCompletion(pSend, DP_OK);

	DecSendRef(pSession->pProtocol, pSend); // for completion.

	return TRUE;
}

// called with session lock held
VOID ProcessDGACK(PSESSION pSession, PCMDINFO pCmdInfo)
{
	BILINK *pBilink;
	PSENDSTAT pStatWalker,pStat=NULL;

	Lock(&pSession->SessionStatLock);
	
	pBilink=pSession->DGStatList.next;
	
	while(pBilink != &pSession->DGStatList){
		pStatWalker=CONTAINING_RECORD(pBilink, SENDSTAT, StatList);
		if((pStatWalker->messageid == pCmdInfo->messageid) && 	// correct messageid
		   (pStatWalker->sequence  == pCmdInfo->sequence)       // correct sequence
		   // don't check serial, since datagrams are always serial 0, never retried.
		  )
		{  
			pStat=pStatWalker;
			break;
		}
		pBilink=pBilink->next;
	}


	if(pStat){
	
		UpdateSessionStats(pSession,pStat,pCmdInfo,FALSE);

		// Unlink All Previous SENDSTATS;
		pStat->StatList.next->prev=&pSession->DGStatList;
		pSession->DGStatList.next=pStat->StatList.next;

		// Put the SENDSTATS back in the pool.
		while(pBilink != &pSession->DGStatList){
			pStatWalker=CONTAINING_RECORD(pBilink, SENDSTAT, StatList);
			pBilink=pBilink->prev;
			ReleaseSendStat(pStatWalker);
		}

	}	
	
	Unlock(&pSession->SessionStatLock);

}

// update a send's information for an ACK.
// called with SESSIONion lock held.
// now always drops the sessionlock
BOOL ProcessReliableACK(PSESSION pSession, PCMDINFO pCmdInfo)
{
	PSEND pSend=NULL, pSendWalker;
	BILINK *pBilink;
	UINT nFrame;
	UINT nAdvance;

	Unlock(&pSession->SessionLock);
	Lock(&pSession->pProtocol->m_SendQLock);
	Lock(&pSession->SessionLock);
	
	pBilink=pSession->SendQ.next;
	
	while(pBilink != &pSession->SendQ){
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, SendQ);
		if((pSendWalker->messageid == pCmdInfo->messageid) && 	// correct messageid
		   (!(pSendWalker->dwFlags & ASEND_PROTOCOL)) &&		// not and internal message
		   (pSendWalker->dwFlags & DPSEND_GUARANTEED)){         // guaranteed
			pSend=pSendWalker;
			break;
		}
		pBilink=pBilink->next;
	}

	// need a reference to avoid processing a send as 
	// it is being recycled for another send.
	if(pSend){
		if(!AddSendRef(pSend,1)){
			pSend=NULL;
		}
	}

	Unlock(&pSession->pProtocol->m_SendQLock);
	// SessionLock still held.

	if(pSend){

		Lock(&pSend->SendLock);

		UpdateSessionSendStats(pSession,pSend,pCmdInfo,FALSE);

		// we need to make sure this send isn't already finished.
		switch(pSend->SendState){
		
			case    Sending:
			case 	Throttled:
			case	WaitingForAck:
			case	WaitingForId:
			case 	ReadyToSend:
				break;

			case Start:		// shouldn't be getting an ACK for a send in the start state.
			case TimedOut:
			case Cancelled:
			case UserTimeOut:
			case Done:
				// this send is already done, don't do processing on it.
				DPF(4,"PRACK:Not processing ACK on send in State (B#22359 avoided)%x\n",pSend->SendState);
				Unlock(&pSend->SendLock);
				Unlock(&pSession->SessionLock);
				DecSendRef(pSession->pProtocol,pSend); // balances AddSendRef in this fn
				return TRUE; // SessionLock dropped
				break;
				
			default:
				break;
		}

		pSend->fUpdate=TRUE;

		nFrame=(pCmdInfo->sequence-pSend->NR)&pSend->SendSEQMSK;
		
		if(nFrame > (pSend->NS - pSend->NR)){
			// Out of range.
			DPF(9,"ReliableACK:Got out of range ACK, SQMSK=%x NS=%d NR=%d ACK=%d\n",pSend->SendSEQMSK,pSend->NS&pSend->SendSEQMSK, pSend->NR&pSend->SendSEQMSK, (pSend->NR+nFrame)&pSend->SendSEQMSK);
			Unlock(&pSend->SendLock);
			Unlock(&pSession->SessionLock);
			DecSendRef(pSession->pProtocol,pSend);
			return TRUE; // SessionLock dropped
		}

		CancelRetryTimer(pSend);

		DPF(9,"ProcessReliableACK (before): pSend->NR %x pSend->OpenWindow %x, pSend->NACKMask %x\n",pSend->NR, pSend->OpenWindow, pSend->NACKMask);

		pSend->NR=(pSend->NR+nFrame);
		pSend->OpenWindow -= nFrame;
		pSend->NACKMask >>= nFrame;
		ASSERT_NACKMask(pSend);
		AdvanceSend(pSend,pSend->FrameDataLen*nFrame); // can put us past on the last frame, but that's ok.

		DPF(9,"ProcessReliableACK: Send->nFrames %2x NR %2x NS %2x nFrame %2x NACKMask %x\n",pSend->nFrames,pSend->NR, pSend->NS, nFrame, pSend->NACKMask);

		if(pSend->NR==pSend->nFrames){
			// LAST ACK, we're done!
			pSend->SendState=Done;
			Unlock(&pSend->SendLock);
			// SessionLock still held
			CompleteSend(pSession, pSend, pCmdInfo);// drops SessionLock
			DecSendRef(pSession->pProtocol,pSend);
			return TRUE;
		} else {
			// set new "NACK bits" for extra window opening
			if(pSend->NR+pSend->OpenWindow+nFrame > pSend->nFrames){
				nAdvance=pSend->nFrames-(pSend->NR+pSend->OpenWindow);
				DPF(9,"A nAdvance %d\n",nAdvance);
			} else {
				nAdvance=nFrame;
				DPF(9,"B nAdvance %d\n",nAdvance);
			}
			pSend->NACKMask |= ((1<<nAdvance)-1)<<pSend->OpenWindow;
			pSend->OpenWindow += nAdvance;
			DPF(9,"pSend->NACKMask=%x\n",pSend->NACKMask);
			ASSERT_NACKMask(pSend);
		}

		switch(pSend->SendState){

			case Start:
				DPF(1,"ERROR, ACK ON UNSTARTED SEND!\n");
				ASSERT(0);
				break;

			case Done:
				DPF(1,"ERROR, ACK ON DONE SEND!\n");
				ASSERT(0);
				break;
				
			case WaitingForAck:
				pSend->SendState=ReadyToSend;
				SetEvent(pSession->pProtocol->m_hSendEvent);
				break;

			case ReadyToSend:
			case Sending:
			case Throttled:
			default:
				break;
		}

		Unlock(&pSend->SendLock);
	} else {        
		DPF(9,"ProcessReliableACK: dup ACK ignoring\n");
	}
	Unlock(&pSession->SessionLock);
	
	if(pSend){
		DecSendRef(pSession->pProtocol, pSend);
	}	
	return TRUE; // SessionLock dropped
}

//called with session lock held, always drops lock.
BOOL ProcessReliableNACK(PSESSION pSession, PCMDINFO pCmdInfo,PUCHAR pNACKmask, UINT nNACK)
{
	UINT NACKmask=0;
	UINT NACKshift=0;

	PSEND pSend=NULL, pSendWalker;
	BILINK *pBilink;
	UINT nFrame;
	UINT nAdvance;
	UINT nAdvanceShift;

	DWORD nDropped=0;

	DPF(9,"==>ProcessReliableNACK\n");

	Unlock(&pSession->SessionLock);
	Lock(&pSession->pProtocol->m_SendQLock);
	Lock(&pSession->SessionLock);

	pBilink=pSession->SendQ.next;
	
	while(pBilink != &pSession->SendQ){
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, SendQ);
		if(pSendWalker->dwFlags & DPSEND_GUARANTEE && 
		   pSendWalker->messageid == pCmdInfo->messageid){
			pSend=pSendWalker;
			break;
		}
		pBilink=pBilink->next;
	}

	// need a reference to avoid processing a send as 
	// it is being recycled for another send.
	if(pSend){
		if(!AddSendRef(pSend,1)){
			pSend=NULL;
		}
	}	
	
	Unlock(&pSession->pProtocol->m_SendQLock);
	// SessionLock still held.

	if(pSend){

		Lock(&pSend->SendLock);

		UpdateSessionSendStats(pSession,pSend,pCmdInfo,FALSE);

		// we need to make sure this send isn't already finished.
		switch(pSend->SendState){
		
			case    Sending:
			case 	Throttled:
			case	WaitingForAck:
			case	WaitingForId:
			case 	ReadyToSend:
				break;

			case Start:		// shouldn't be getting an ACK for a send in the start state.
			case TimedOut:
			case Cancelled:
			case UserTimeOut:
			case Done:
				// this send is already done, don't do processing on it.
				DPF(4,"PRNACK:Not processing NACK on send in State (B#22359 avoided)%x\n",pSend->SendState);
				Unlock(&pSend->SendLock);
				Unlock(&pSession->SessionLock);
				DecSendRef(pSession->pProtocol,pSend); // balances AddSendRef in this fn
				return TRUE; // SessionLock dropped
				break;
				
			default:
				break;
		}

		DPF(9,"Reliable NACK for Send %x, pCmdInfo %x\n",pSend, pCmdInfo);
		
		pSend->fUpdate=TRUE;
		// Do regular NR updates (BUGBUG: fold with process reliable ACK)
		nFrame=(pCmdInfo->sequence-pSend->NR) & pSend->SendSEQMSK;
		
		if(nFrame > (pSend->NS - pSend->NR)){
			// Out of range.
			DPF(9,"ReliableNACK:Got out of range NACK, SQMSK=%x NS=%d NR=%d ACK=%d\n",pSend->SendSEQMSK,pSend->NS&pSend->SendSEQMSK, pSend->NR&pSend->SendSEQMSK, (pSend->NR+nFrame)&pSend->SendSEQMSK);
			Unlock(&pSend->SendLock);
			Unlock(&pSession->SessionLock);
			DecSendRef(pSession->pProtocol,pSend);
			return TRUE;
		}

		CancelRetryTimer(pSend);

		DPF(9,"NACK0: pSend->NACKMask %x, OpenWindow %d\n",pSend->NACKMask, pSend->OpenWindow);

		pSend->NR=(pSend->NR+nFrame);
		pSend->OpenWindow -= nFrame;
		pSend->NACKMask >>= nFrame;
		ASSERT_NACKMask(pSend);
		AdvanceSend(pSend,pSend->FrameDataLen*nFrame);

		DPF(9,"ProcessReliableNACK: Send->nFrames %2x NR %2x NS %2x nFrame %2x NACKMask %x\n",pSend->nFrames,pSend->NR, pSend->NS, nFrame, pSend->NACKMask);

		ASSERT(pSend->NR != pSend->nFrames);
		// set new "NACK bits" for extra window opening
		if(pSend->NR+pSend->OpenWindow+nFrame > pSend->nFrames){
			nAdvance=pSend->nFrames-(pSend->NR+pSend->OpenWindow);
			DPF(9, "NACK: 1 nAdvance %d\n",nAdvance);
		} else {
			nAdvance=nFrame;
			DPF(9, "NACK: 2 nAdvance %d\n",nAdvance);
		}
		pSend->NACKMask |= ((1<<nAdvance)-1)<<pSend->OpenWindow;

		DPF(9, "NACK Mask %x\n",pSend->NACKMask);
		pSend->OpenWindow += nAdvance;
		ASSERT_NACKMask(pSend);


		while(nNACK--){
			NACKmask |= (*(pNACKmask++))<<NACKshift;
			NACKshift+=8;
		}

		DPF(9,"NACKmask in NACK %x\n",NACKmask);

		// set the NACK mask.
		nAdvanceShift=0;
		while(NACKmask){
			if(NACKmask&1){
				// set bits are ACKs.
				pSend->NACKMask&=~(1<<nAdvanceShift);
			} else {
				// clear bits are NACKs.
				pSend->NACKMask|=1<<nAdvanceShift;
				nDropped++;
			}
			NACKmask >>= 1;
			nAdvanceShift++;
		}
		DPF(9,"ProcessReliableNACK: pSend->NACKMask=%x\n",pSend->NACKMask);
		ASSERT_NACKMask(pSend);

		UpdateSessionSendStats(pSession,pSend,pCmdInfo, ((nDropped > 1) ? TRUE:FALSE) );
	
		switch(pSend->SendState){

			case Start:
				DPF(5,"ERROR, NACK ON UNSTARTED SEND!\n");
				ASSERT(0);
				break;

			case Done:
				DPF(5,"ERROR, NACK ON DONE SEND!\n");
				ASSERT(0);
				break;
				
			case WaitingForAck:
				pSend->SendState=ReadyToSend;
				SetEvent(pSession->pProtocol->m_hSendEvent);
				break;

			case ReadyToSend:
			case Sending:
			case Throttled:
			default:
				break;
		}
		Unlock(&pSend->SendLock);
	} else {
		// BUGBUG: reliable NACK for send we aren't doing? Ignore or send abort?
		DPF(0,"Reliable NACK for send we aren't doing? Ignore?\n");
	}

	Unlock(&pSession->SessionLock);
	
	if(pSend){
		DecSendRef(pSession->pProtocol,pSend);
	}
	return TRUE;
	
	#undef pBigNACK
}

VOID ProcessACK(PPROTOCOL pProtocol, PCMDINFO pCmdInfo)
{
	PSESSION      pSession;
	UINT          rc=0;             // by default, buffer not accepted.
	BOOL          fUnlockedSession=FALSE;

	// Find the Send for this ACK.

	DPF(9,"ProcessACK\n");

	pSession=GetSysSessionByIndex(pProtocol,pCmdInfo->wIdFrom);

	if(!pSession) {
		goto exit;
	}
	
	Lock(&pSession->SessionLock);

	// Find the message with the id, make sure its the same type of send.
	if(pCmdInfo->flags & RLY){
		if(pCmdInfo->flags & BIG){
			//BUGBUG: if messageid, FirstMsg and LastMsg are SHORT, no masking req'd
			if((pCmdInfo->messageid==pSession->FirstMsg)||((pCmdInfo->messageid-pSession->FirstMsg)&0xFFFF) > ((pSession->LastMsg-pSession->FirstMsg)&0xFFFF)){
				DPF(9,"Ignoring out of range ACK\n");
				goto exit1;
			}
		} else {
			if((pCmdInfo->messageid==pSession->FirstMsg)||((pCmdInfo->messageid-pSession->FirstMsg)&0xFF) > ((pSession->LastMsg-pSession->FirstMsg)&0xFF)){
				// out of range, ignore
				DPF(9,"Ignoring out of range ACK\n");
				goto exit1;
			} 
		}
		ProcessReliableACK(pSession,pCmdInfo); //now always unlocks session.
		fUnlockedSession=TRUE;
	} else {
		ProcessDGACK(pSession,pCmdInfo);
	}

exit1:  
	if(!fUnlockedSession){  
		Unlock(&pSession->SessionLock);
	}
	
	DecSessionRef(pSession);

exit:
	return;

	#undef pBigACK
}

VOID ProcessNACK(PPROTOCOL pProtocol, PCMDINFO pCmdInfo, PUCHAR pNACKmask, UINT nNACK)
{
	#define pBigNACK ((pNACK2)pNACK)

	PSESSION      pSession;

	pSession=GetSysSessionByIndex(pProtocol, pCmdInfo->wIdFrom);

	if(!pSession) {
		ASSERT(0);
		goto exit;
	}

	Lock(&pSession->SessionLock);

	if(pCmdInfo->flags & RLY){
		ProcessReliableNACK(pSession,pCmdInfo,pNACKmask, nNACK); // drops SessionLock
	} else {
		Unlock(&pSession->SessionLock);
		DPF(0,"FATAL: non-reliable NACK???\n");
		ASSERT(0);
	}

	DecSessionRef(pSession);
	
exit:
	return;
}


UINT AssertMe(REQUEST_PARAMS)
{
	DEBUG_BREAK();
	return TRUE;
}

UINT Ping(REQUEST_PARAMS){return TRUE;}
UINT PingResp(REQUEST_PARAMS){return TRUE;}
UINT GetTime(REQUEST_PARAMS){return TRUE;}
UINT GetTimeResp(REQUEST_PARAMS){return TRUE;}
UINT SetTime(REQUEST_PARAMS){return TRUE;}
UINT SetTimeResp(REQUEST_PARAMS){return TRUE;}

VOID ProcessAbort(PPROTOCOL pProtocol, DPID idFrom, DPID idTo, pABT1 pABT, BOOL fBig){}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\psession.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    SESSION.C

Abstract:

	Management of the session structures

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
   6/6/98  aarono  Turn on throttling and windowing

--*/

#include <windows.h>
#include "newdpf.h"
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"
#include "mytimer.h"

/*=============================================================================

  Note on Session Locking and reference counting:
  ===============================================

  Sessions have a refcount that controls their existence.  When the refcount
  is non-zero, the session continues to exist.  When the refcount hits zero,
  the session is destroyed.
	
  On creation, the refcount for a session is set to 1.  Sessions are created
  when DirectPlay calls ProtocolCreatePlayer.  The session state is set to 
  Running during creation.  Each Session created also creates a reference
  count on the Protocol object.  This is so that the protocol does not
  shut down before all Sessions have been closed.

  When DirectPlay calls ProtocolDeletePlayer, the session's state is set
  to Closing and the reference count is reduced by one.  We then must wait
  until the session has been destroyed before we return from 
  ProtocolDeletePlayer, otherwise, the id may be recycled before we have
  freed up the slot in the session.

  Sends do NOT create references on the Session.  When a send thread starts
  referencing a Send, it creates a reference on the session the send is
  on.  When the send thread is no longer referencing the send, it deletes
  its' reference on the session.  When the reference count on the session
  is 0, it is safe to complete all pending sends with an error and free
  their resources. 

  Receives do NOT create references on the Session.  When the protocol's
  receive handler is called, a reference to the Session is created on 
  behalf of the receive thread.  When the receive thread is done processing,
  the reference is removed.  This prevents the Session from going away
  while a receive thread is processing.  When the reference count on the
  session is 0, it is safe to throw out all pending receives.  Ideally an
  ABORT message of some kind should be sent to the transmitter, but this
  is optional since it should time-out the transaction.

  If the reference count on the session hits 0, the session must be shut
  down and freed.  All pending sends are completed with an error.  All
  pending receives are thrown out and cleaned up.  All pending stats are
  thrown out.


	Session States:
    ===============
	Open     - set at creation.
	
	Closing  - set when we receive a call to ProtocolDeletePlayer.
	           No new receives or sends are accepted in closing state.
	           
	Closed   - Refcount is 0, we are now freeing everything.

-----------------------------------------------------------------------------*/

/*=============================================================================

	pPlayerFromId()

    Description:

    Parameters:     

    Return Values:

-----------------------------------------------------------------------------*/

LPDPLAYI_PLAYER pPlayerFromId(PPROTOCOL pProtocol, DPID idPlayer)
{
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_DPLAY lpDPlay;
	UINT index;

	lpDPlay=pProtocol->m_lpDPlay;

	if(idPlayer == DPID_SERVERPLAYER){
		pPlayer = lpDPlay->pServerPlayer;
	} else {
		index   = ((idPlayer ^ pProtocol->m_dwIDKey)&INDEX_MASK);
		ASSERT(index < 65535);
		pPlayer = (LPDPLAYI_PLAYER)(lpDPlay->pNameTable[index].dwItem);	
	}
	return pPlayer;
}

/*=============================================================================

	CreateNewSession

    Description:

    Parameters:     


    Return Values:



-----------------------------------------------------------------------------*/
HRESULT	CreateNewSession(PPROTOCOL pProtocol, DPID idPlayer)
{
	DWORD        dwUnmangledID;
	DWORD        iPlayer;
	DWORD        iSysPlayer;

	UINT         i;

	HRESULT      hr=DPERR_NOMEMORY;

	PSESSION     (*pSessionsNew)[];
	PSESSION     pSession;

	LPDPLAYI_PLAYER pPlayer;

	if(idPlayer != DPID_SERVERPLAYER) {

		// Convert the ID to an integer
		dwUnmangledID = idPlayer ^ pProtocol->m_dwIDKey;
	    iPlayer = dwUnmangledID & INDEX_MASK; 

		pPlayer=(LPDPLAYI_PLAYER)(pProtocol->m_lpDPlay->pNameTable[iPlayer].dwItem);
		ASSERT(pPlayer);

		// Note: System players are always created before non-system players.
		dwUnmangledID = pPlayer->dwIDSysPlayer ^ pProtocol->m_dwIDKey;
		iSysPlayer = dwUnmangledID & INDEX_MASK;

#ifdef DEBUG
		if(iSysPlayer==iPlayer){
			DPF(9,"PROTOCOL: CREATING SYSTEM PLAYER\n");
		}
#endif	

		DPF(9,"PROTOCOL: Creating Player id x%x %dd iPlayer %d iSysPlayer %d\n",idPlayer, idPlayer, iPlayer, iSysPlayer);

		if(iPlayer >= 0xFFFF){
			// use 0xFFFF to map messages starting in 'play' to 'pl'0xFFFF
			// so we can't have a real player at this iPlayer.
			DPF(0,"PROTOCOL: not allowing creation of player iPlayer %x\n",iPlayer);
			goto exit;
		}

		Lock(&pProtocol->m_SessionLock);

		//
		// Adjust session list size (if necessary).
		//
		if(pProtocol->m_SessionListSize <= iPlayer){
			// not long enough, reallocate - go over 16 to avoid thrashing on every one.
			pSessionsNew=My_GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,(iPlayer+16)*sizeof(PSESSION));
			if(pSessionsNew){
				// Copy the old entries to the new list.
				if(pProtocol->m_pSessions){
					for(i=0;i<pProtocol->m_SessionListSize;i++){
						(*pSessionsNew)[i]=(*pProtocol->m_pSessions)[i];
					}
					// Free the old list.
					My_GlobalFree(pProtocol->m_pSessions);
				}
				// Put the new list in its place.
				pProtocol->m_pSessions=pSessionsNew;
				pProtocol->m_SessionListSize=iPlayer+16;
				DPF(9,"PROTOCOL: Grew sessionlist to %d entries\n",pProtocol->m_SessionListSize);
			}
		}

		// Allocate a session

		pSession=(PSESSION)My_GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(SESSION));

		if(!pSession){
			goto exit2;
		}

		(*pProtocol->m_pSessions)[iPlayer]=pSession;
	
	} else {
		// SERVERPLAYER

		pPlayer = pPlayerFromId(pProtocol,idPlayer);
		iPlayer = SERVERPLAYER_INDEX;
		
		Lock(&pProtocol->m_SessionLock);
		
		pSession=(PSESSION)My_GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(SESSION));

		if(!pSession){
			goto exit2;
		}
		
		ASSERT(!pProtocol->m_pServerPlayerSession);
		pProtocol->m_pServerPlayerSession=pSession;

		ASSERT(pPlayer->dwIDSysPlayer != DPID_SERVERPLAYER);

		// Note: System players are always created before non-system players.
		dwUnmangledID = pPlayer->dwIDSysPlayer ^ pProtocol->m_dwIDKey;
		iSysPlayer = dwUnmangledID & INDEX_MASK;

		DPF(8,"PROTOCOL:CreatePlayer: Creating SERVERPLAYER: pPlayer %x iPlayer %x iSysPlayer %x\n",pPlayer,iPlayer,iSysPlayer);
	}
	
	pProtocol->m_nSessions++;
	
	//
	// Session structure initialization
	//

	SET_SIGN(pSession, SESSION_SIGN);
	
	pSession->pProtocol=pProtocol;

	InitializeCriticalSection(&pSession->SessionLock);
	pSession->RefCount=1; // One Ref for creation.
	pSession->eState=Open;
	
	// Initialize the SendQ
	InitBilink(&pSession->SendQ);
	
	pSession->dpid=idPlayer;
	pSession->iSession=iPlayer;
	pSession->iSysPlayer=iSysPlayer;

	InitializeCriticalSection(&pSession->SessionStatLock);
	InitBilink(&pSession->DGStatList);
	pSession->DGFirstMsg = 0;
	pSession->DGLastMsg = 0;
	pSession->DGOutMsgMask = 0;
	pSession->nWaitingForDGMessageid=0;
	
	pSession->FirstMsg = 0;
	pSession->LastMsg  = 0;
	pSession->OutMsgMask = 0;
	pSession->nWaitingForMessageid=0;

	// we start the connection using small headers, if we see we can
	// get better perf with a large header during operation, then we
	// switch to the large header.
	pSession->MaxCSends     = 1;/*MAX_SMALL_CSENDS	- initial values adjusted after 1st ACK*/ 
	pSession->MaxCDGSends   = 1;/*MAX_SMALL_DG_CSENDS*/
	pSession->WindowSize	= 1;/*MAX_SMALL_WINDOW*/
	pSession->DGWindowSize  = 1;/*MAX_SMALL_WINDOW*/
	pSession->fFastLink     = FALSE; // start assuming slow link.
	pSession->fSendSmall    = TRUE; 
	pSession->fSendSmallDG  = TRUE;
	pSession->fReceiveSmall = TRUE;
	pSession->fReceiveSmallDG = TRUE;

#if 0
	// use this code to START with large packet headers
	pSession->MaxCSends		= MAX_LARGE_CSENDS;
	pSession->MaxCDGSends   = MAX_LARGE_DG_CSENDS;
	pSession->WindowSize	= MAX_LARGE_WINDOW;
	pSession->DGWindowSize  = MAX_LARGE_WINDOW;
	pSession->fSendSmall    = FALSE;
	pSession->fSendSmallDG  = FALSE;
#endif

	pSession->MaxPacketSize = pProtocol->m_dwSPMaxFrame; 
	

	pSession->FirstRlyReceive=pSession->LastRlyReceive=0;
	pSession->InMsgMask = 0;
	
	InitBilink(&pSession->pRlyReceiveQ);
	InitBilink(&pSession->pDGReceiveQ);
	InitBilink(&pSession->pRlyWaitingQ);

	InitSessionStats(pSession);

	pSession->SendRateThrottle = 28800;
	pSession->FpAvgUnThrottleTime = Fp(1); // assume 1 ms to schedule unthrottle (first guess)
	pSession->tNextSend=pSession->tLastSAK=timeGetTime();
	
	Unlock(&pProtocol->m_SessionLock);

	hr=DP_OK;

exit:
	return hr;

exit2:
	hr=DPERR_OUTOFMEMORY;
	return hr;
}

/*=============================================================================

    GetDPIDIndex - lookup a session based on the Index
    
    Description:

    Parameters:     

		DWORD index	- Find the dpid for this index

    Return Values:

		DPID - dpid of the index

-----------------------------------------------------------------------------*/


DPID GetDPIDByIndex(PPROTOCOL pProtocol, DWORD index)
{
	PSESSION pSession;
	DPID     dpid;

	Lock(&pProtocol->m_SessionLock);

	if(index == SERVERPLAYER_INDEX){
		dpid=DPID_SERVERPLAYER;
	} else if(index < pProtocol->m_SessionListSize && 
	         (pSession=(*pProtocol->m_pSessions)[index]))
	{
		Lock(&pSession->SessionLock);
		dpid=pSession->dpid;
		Unlock(&pSession->SessionLock);
	} else {
		dpid=0xFFFFFFFF;
		DPF(1,"GetDPIDByIndex, no id at index %d player may me gone or not yet created locally.\n",index);
	}
	
	Unlock(&pProtocol->m_SessionLock);
	return dpid;
}

WORD GetIndexByDPID(PPROTOCOL pProtocol, DPID dpid)
{
	DWORD dwUnmangledID;
	if(dpid == DPID_SERVERPLAYER){
		return SERVERPLAYER_INDEX;
	}
	dwUnmangledID = dpid ^ pProtocol->m_dwIDKey;
    return (WORD)(dwUnmangledID & INDEX_MASK); 
    
}
/*=============================================================================

    GetSysSessionByIndex - lookup a session based on the Index
    
    Description:

    Parameters:     

		DWORD index	- Find the session for this index

    Return Values:

    	NULL - if the SESSION is not found, 
    	else	   pointer to the Session.

	Notes:

		Adds a reference to the SESSION.  When done with the session pointer
		the caller must call DecSessionRef.

-----------------------------------------------------------------------------*/


PSESSION GetSysSessionByIndex(PPROTOCOL pProtocol, DWORD index)
{
	PSESSION pSession;
	
	Lock(&pProtocol->m_SessionLock);

	DPF(9,"==>GetSysSessionByIndex at index x%x\n", index);

	if( (index < pProtocol->m_SessionListSize) || (index == SERVERPLAYER_INDEX) ){

		// ptr to session at requested index.
		if(index == SERVERPLAYER_INDEX){
			pSession = pProtocol->m_pServerPlayerSession;
		} else {
			pSession = (*pProtocol->m_pSessions)[index];
		}	

		if(pSession){
			// ptr to system session for session at requested index.
			pSession=(*pProtocol->m_pSessions)[pSession->iSysPlayer];
			if(pSession){
				Lock(&pSession->SessionLock);
				if(pSession->eState==Open){
					pSession->RefCount++;
					Unlock(&pSession->SessionLock);
				} else {
					// Session is closing or closed, don't give ptr.
					Unlock(&pSession->SessionLock);
					pSession=NULL;
				}
			} 
		}
	} else {
		pSession=NULL;
	}

	DPF(9,"<===GetSysSessbyIndex pSession %x\n",pSession);
	
	Unlock(&pProtocol->m_SessionLock);
	return pSession;
}

/*=============================================================================

    GetSysSession - lookup a the system session of a session based on the DPID
    
    Description:

    Parameters:     

		DPID idPlayer	- Find the session for this player.

    Return Values:

    	NULL - if the SESSION is not found, or the DPID has been re-cycled.
    	else	   pointer to the Session.

	Notes:

		Adds a reference to the SESSION.  When done with the session pointer
		the caller must call DecSessionRef.

-----------------------------------------------------------------------------*/


PSESSION GetSysSession(PPROTOCOL pProtocol, DPID idPlayer)
{
	PSESSION pSession;
	DWORD    dwUnmangledID;
	DWORD    index;
	
	Lock(&pProtocol->m_SessionLock);

	if(idPlayer != DPID_SERVERPLAYER){
		dwUnmangledID = idPlayer ^ pProtocol->m_dwIDKey;
	    index = dwUnmangledID & INDEX_MASK; 
		pSession=(*pProtocol->m_pSessions)[index];
	} else {
		pSession=pProtocol->m_pServerPlayerSession;
	}

	if(pSession){

		if(pSession->dpid == idPlayer){
			pSession=(*pProtocol->m_pSessions)[pSession->iSysPlayer];
			if(pSession){
				Lock(&pSession->SessionLock);
				if(pSession->eState == Open){
					pSession->RefCount++;
					Unlock(&pSession->SessionLock);
				} else {
					// Closing, don't return value
					Unlock(&pSession->SessionLock);
					pSession=NULL;
				}
			} else {
				DPF(0,"GetSysSession: Looking on Session, Who's SysSession is gone!\n");
				ASSERT(0);
			}
			
		} else {
			//BUGBUG: break out here!
			DPF(1,"PROTOCOL: got dplay id that has been recycled (%x), now (%x)?\n",idPlayer,pSession->dpid);
			ASSERT(0);
			pSession=NULL;
		}
	}
	
	Unlock(&pProtocol->m_SessionLock);
	return pSession;
}

/*=============================================================================

    GetSession - lookup a session based on the DPID
    
    Description:

    Parameters:     

		DPID idPlayer	- Find the session for this player.

    Return Values:

    	NULL - if the SESSION is not found, or the DPID has been re-cycled.
    	else	   pointer to the Session.

	Notes:

		Adds a reference to the SESSION.  When done with the session pointer
		the caller must call DecSessionRef.

-----------------------------------------------------------------------------*/


PSESSION GetSession(PPROTOCOL pProtocol, DPID idPlayer)
{
	PSESSION pSession;
	DWORD    dwUnmangledID;
	DWORD    index;
	
	Lock(&pProtocol->m_SessionLock);

	if(idPlayer != DPID_SERVERPLAYER){
		dwUnmangledID = idPlayer ^ pProtocol->m_dwIDKey;
	    index = dwUnmangledID & INDEX_MASK; 
		pSession=(*pProtocol->m_pSessions)[index];
	} else {
		pSession=pProtocol->m_pServerPlayerSession;
	}

	if(pSession){

		if(pSession->dpid == idPlayer){
			Lock(&pSession->SessionLock);
			pSession->RefCount++;
			Unlock(&pSession->SessionLock);
		} else {
			//BUGBUG: break out here!
			DPF(1,"PROTOCOL: got dplay id that has been recycled (%x), now (%x)?\n",idPlayer,pSession->dpid);
			ASSERT(0);
			pSession=NULL;
		}
	}
	
	Unlock(&pProtocol->m_SessionLock);
	return pSession;
}

VOID ThrowOutReceiveQ(PPROTOCOL pProtocol, BILINK *pHead)
{
	PRECEIVE pReceiveWalker;
	BILINK *pBilink;
	
	pBilink = pHead->next;
	while( pBilink != pHead ){
		pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		ASSERT_SIGN(pReceiveWalker, RECEIVE_SIGN);
		ASSERT(!pReceiveWalker->fBusy);
		pBilink=pBilink->next;
		Lock(&pReceiveWalker->ReceiveLock);
		if(!pReceiveWalker->fBusy){
			Delete(&pReceiveWalker->pReceiveQ);
			Unlock(&pReceiveWalker->ReceiveLock);
			DPF(8,"Throwing Out Receive %x from Q %x\n",pReceiveWalker, pHead);
			FreeReceive(pProtocol,pReceiveWalker);
		} else {
			Unlock(&pReceiveWalker->ReceiveLock); 
		}	
	}	
}

/*=============================================================================

    DecSessionRef
    
    Description:

    Parameters:     

    Return Values:

-----------------------------------------------------------------------------*/

INT DecSessionRef(PSESSION pSession)
{
	PPROTOCOL pProtocol;
	INT count;

	PSEND pSendWalker;
	BILINK *pBilink;

	if(!pSession){
		return 0;
	}

	Lock(&pSession->SessionLock);
	count = --pSession->RefCount;
	Unlock(&pSession->SessionLock);

	if(!count){

		// No more references!  Blow it away.
		DPF(9,"DecSessionRef:(firstchance) pSession %x, count=%d, Session Closed, called from %x \n",pSession,count,_ReturnAddress());
	
		pProtocol=pSession->pProtocol;

		Lock(&pProtocol->m_SessionLock);
		Lock(&pSession->SessionLock);
		
		if(!pSession->RefCount){
			// Remove any referece to the session from the protocol.
			if(pSession->iSession != SERVERPLAYER_INDEX){
				(*pProtocol->m_pSessions)[pSession->iSession]=NULL;
			} else {
				pProtocol->m_pServerPlayerSession=NULL;
			}
			pProtocol->m_nSessions--;
		} else {
			count=pSession->RefCount;
		}	

		Unlock(&pSession->SessionLock);
		Unlock(&pProtocol->m_SessionLock);

		// Session is floating free and we own it.  No one can reference
		// so we can safely blow it all away, don't need to lock during
		// these ops since no-one can reference any more...

		if(!count){

			DPF(9,"DecSessionRef(second chance): pSession %x, count=%d, Session Closed, called from %x \n",pSession,count,_ReturnAddress());
			//DEBUG_BREAK();
			pSession->eState=Closed;

			if(pSession->uUnThrottle){
				//timeKillEvent(pSession->uUnThrottle);
				CancelMyTimer(pSession->uUnThrottle, pSession->UnThrottleUnique);
			}

			// Free up Datagram send statistics.
			DeleteCriticalSection(&pSession->SessionStatLock);
			pBilink=pSession->DGStatList.next;
			while(pBilink != & pSession->DGStatList){
				PSENDSTAT pStat = CONTAINING_RECORD(pBilink, SENDSTAT, StatList);
				pBilink=pBilink->next;
				ReleaseSendStat(pStat);
			}
			
			// Complete pending sends.
			pBilink=pSession->SendQ.next;
			while(pBilink!=&pSession->SendQ){
				pSendWalker=CONTAINING_RECORD(pBilink, SEND, SendQ);
				pBilink=pBilink->next;
				
				CancelRetryTimer(pSendWalker);
				DoSendCompletion(pSendWalker, DPERR_CONNECTIONLOST);
				DecSendRef(pProtocol, pSendWalker);
					
			}
			
			//
			// throw out pending receives.
			//

			ThrowOutReceiveQ(pProtocol, &pSession->pDGReceiveQ);
			ThrowOutReceiveQ(pProtocol, &pSession->pRlyReceiveQ);
			ThrowOutReceiveQ(pProtocol, &pSession->pRlyWaitingQ);
			
			//
			// Free the session
			//
			if(pSession->hClosingEvent){
				DPF(5,"DecSessionRef: pSession %x Told Protocol DeletePlayer to continue\n",pSession);
				SetEvent(pSession->hClosingEvent);
			}
			UNSIGN(pSession->Signature);
			DeleteCriticalSection(&pSession->SessionLock);
			My_GlobalFree(pSession);
		}
		
	} else {
		DPF(9,"DecSessionRef: pSession %x count %d, called from %x\n",pSession, count, _ReturnAddress());
	}
	
	return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\send.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    SEND.C

Abstract:

	Send Handler and Send Thread.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
   2/18/98 aarono  added support for SendEx
   2/18/98 aarono  added support for Cancel
   2/20/98 aarono  B#18827 not pulling Cancelled sends off queue
   3/09/98 aarono  documented workaround for mmTimers on Win95, removed dead code.
   3/29/98 aarono  fixed locking for ReliableSend
   3/30/98 aarono  make sure erroring sends moved to Done state to avoid reprocess.
   4/14/98 a-peterz B#18340 DPSEND_NOCOPY subsumes DPSEND_NOBUFFERCOPY
   5/18/98 aarono  fixed SendEx with scatter gather
   6/6/98  aarono  Turn on throttling and windowing

--*/

#include <windows.h>
#include "newdpf.h"
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"
#include "mytimer.h"

BOOL DGCompleteSend(PSEND pSend);

// a-josbor: for debuggin purposes only
extern DWORD ExtractProtocolIds(PUCHAR pInBuffer, PUINT pdwIdFrom, PUINT pdwIdTo);

INT AddSendRef(PSEND pSend, UINT count)
{
	INT newcount;
	Lock(&pSend->SendLock);
	Lock(&g_SendTimeoutListLock);
	if(pSend->bCleaningUp){
		DPF(1,"WARNING: ADDSENDREF tried to add reference to cleaning up send\n");
		newcount=0;
		goto exit;
	}
	if(!pSend->RefCount){
		// Anyone calling addsend ref requires a reference on the session
		Unlock(&g_SendTimeoutListLock);
		Unlock(&pSend->SendLock);
		
		Lock(&pSend->pSession->pProtocol->m_SessionLock);
		Lock(&pSend->pSession->SessionLock);
		Lock(&pSend->SendLock);
		Lock(&g_SendTimeoutListLock);
		InterlockedIncrement((PLONG)&pSend->pSession->RefCount);
		Unlock(&pSend->pSession->SessionLock);
		Unlock(&pSend->pSession->pProtocol->m_SessionLock);
		
	}       
	newcount = pSend->RefCount+count;
	pSend->RefCount = newcount;
	
exit:	
	Unlock(&g_SendTimeoutListLock);
	Unlock(&pSend->SendLock);
	return newcount;
}

// Critical Section must not be held when this is called, unless there
// is a reference for holding the critical section (ie. will not hit 0).
INT DecSendRef(PPROTOCOL pProtocol, PSEND pSend)
{
	INT      count;
	PSESSION pSession;
	
	Lock(&pSend->SendLock);
	
	count=InterlockedDecrement((PLONG)&pSend->RefCount);//count is zero if result of dec is zero, otw nonzero but not actual count.

	if(!count){
		pSession=pSend->pSession;
		pSend->bCleaningUp=TRUE;
		
		Unlock(&pSend->SendLock);
		// pull the Send off of the global queue and the session queue
		Lock(&pProtocol->m_SendQLock);
		Lock(&pSession->SessionLock);
		Lock(&pSend->SendLock);
		Lock(&g_SendTimeoutListLock);
		
		if(!pSend->RefCount){
			Delete(&pSend->TimeoutList);
			Delete(&pSend->m_GSendQ);
			Delete(&pSend->SendQ);
		} else {
			count=pSend->RefCount;
		}

		Unlock(&g_SendTimeoutListLock);
		Unlock(&pSend->SendLock);
		Unlock(&pSession->SessionLock);
		Unlock(&pProtocol->m_SendQLock);
		
		if(!count){
			DecSessionRef(pSession);

			DPF(9,"DecSendRef: pSession %x pSend %x Freeing Send, called from %x\n",pSession, pSend, _ReturnAddress());

			FreeHandleTableEntry(&pProtocol->lpHandleTable,&pProtocol->csHandleTable,pSend->dwMsgID);
			// Free the message buffer(s) (including memory if WE allocated it).
			FreeBufferChainAndMemory(pSend->pMessage);
			// BUGBUG:move any Stats we want to keep to the session.
			// free the send.(handles the stats for now).
			ReleaseSendDesc(pSend);
		}       
	} else {
		DPF(9,"DecSendRef: pSession %x pSend %x count %d, called from %x\n",pSend->pSession, pSend, count,_ReturnAddress());
		if(count&0x80000000){
			DEBUG_BREAK();
		}
		Unlock(&pSend->SendLock);
	}
	return count;
}

// SFLAGS_DOUBLEBUFFER - if the send is ASYNCHRONOUS, make a copy of the data
/*=============================================================================

    Send - Send a message to a client.
    
    Description:

	    Used by the client to send a message to another directplay client
	    or server.  

    Parameters:     

		ARPDID  idFrom        - who is sending this message
		ARPDID  idTo          - target
		DWORD   dwSendFlags   - specifies buffer ownership, priority, reliable
		LPVOID  pBuffers      - Array of buffer and lengths
		DWORD   dwBufferCount - number of entries in array
		PASYNCINFO pAsyncInfo - If specified, call is asynchronous

		typedef struct _ASYNCSENDINFO {
			UINT            Private[4];
			HANDLE          hEvent;
			PSEND_CALLBACK  SendCallBack;
			PVOID           CallBackContext;
			UINT            Status;
		} ASYNCSENDINFO, *PASYNCSENDINFO;

		hEvent              - event to signal when send completes.
		SendCallBack    - routine to call when send completes.
		CallBackContext - context passed to SendCallBack.
		Status          - send completion status.

    Return Values:

		DP_OK - no problem
		DPERR_INVALIDPARAMS


-----------------------------------------------------------------------------*/
HRESULT Send(
	PPROTOCOL      pProtocol,
	DPID           idFrom, 
	DPID           idTo, 
	DWORD          dwSendFlags, 
	LPVOID         pBuffers,
	DWORD          dwBufferCount, 
	DWORD          dwSendPri,
	DWORD          dwTimeOut,
	LPVOID         lpvUserMsgID,
	LPDWORD        lpdwMsgID,
	BOOL           bSendEx,
	PASYNCSENDINFO pAsyncInfo
)
{
	HRESULT hr=DP_OK;

	PSESSION    pSession;
	PBUFFER     pSendBufferChain;
	PSEND       pSend;

	pSession=GetSysSession(pProtocol,idTo);

	if(!pSession) {
		DPF(4,"NO SESSION for idTo %x, returning SESSIONLOST\n",idTo);
		hr=DPERR_CONNECTIONLOST;
		goto exit2;
	}

	pSend=GetSendDesc();
	
	if(!pSend){
		ASSERT(0); //TRACE all paths.
		hr=DPERR_OUTOFMEMORY;
		goto exit;
	}

	pSend->pProtocol=pProtocol;

	// fails by returning 0 in which case cancel won't be available for this send.
	pSend->dwMsgID=AllocHandleTableEntry(&pProtocol->lpHandleTable, &pProtocol->csHandleTable, pSend);

	if(lpdwMsgID){
		*lpdwMsgID=pSend->dwMsgID;
	}

	pSend->lpvUserMsgID = lpvUserMsgID;
	pSend->bSendEx = bSendEx;

	// if pAsyncInfo is provided, the call is asynchronous.
	// if dwFlags DPSEND_ASYNC is set, the call is async.
	// if the call is asynchronous and double buffering is
	// required, we must make a copy of the data.

	if((pAsyncInfo||(dwSendFlags & DPSEND_ASYNC)) && (!(dwSendFlags & DPSEND_NOCOPY))){
		// Need to copy the memory
		pSendBufferChain=GetDoubleBufferAndCopy((PMEMDESC)pBuffers,dwBufferCount);
		// BUGBUG: if the provider requires contiguous buffers, we should
		//         break this down into packet allocations, and chain them
		//         on the send immediately.  Using the packet chain to indicate
		//         to ISend routine that the message is already broken down.
	} else {
		// Build a send buffer chain for the described buffers.
		pSendBufferChain=BuildBufferChain((PMEMDESC)pBuffers,dwBufferCount);            
	}
	
	if(!pSendBufferChain){
		ASSERT(0); //TRACE all paths.
		return DPERR_OUTOFMEMORY;
	}
	
	pSend->pSession            = pSession;     //!!! when this is dropped, deref the connection
	
	pSend->pMessage            = pSendBufferChain;
	pSend->MessageSize         = BufferChainTotalSize(pSendBufferChain);
	pSend->SendOffset          = 0;
	pSend->pCurrentBuffer      = pSend->pMessage;
	pSend->CurrentBufferOffset = 0;
	
	pSend->Priority            = dwSendPri;
	pSend->dwFlags             = dwSendFlags;
	
	if(pAsyncInfo){
		pSend->pAsyncInfo       = &pSend->AsyncInfo;
		pSend->AsyncInfo        = *pAsyncInfo; //copy Async info from client.
	} else {
		pSend->pAsyncInfo               = NULL;
		if(pSend->dwFlags & DPSEND_ASYNC){
			pSend->AsyncInfo.hEvent         = 0;
			pSend->AsyncInfo.SendCallBack   = InternalSendComplete;
			pSend->AsyncInfo.CallBackContext= pSend;
			pSend->AsyncInfo.pStatus        = &pSend->Status;
		}       
	}

	pSend->SendState            = Start;
	pSend->RetryCount           = 0;
	pSend->PacketSize           = pSession->MaxPacketSize;

	pSend->fUpdate              = FALSE;
	pSend->NR                   = 0;
	pSend->NS                   = 0;
	//pSend->SendSEQMSK			= // filled in on the fly.
	pSend->WindowSize           = pSession->WindowSize;
	pSend->SAKInterval			= (pSend->WindowSize+1)/2;
	pSend->SAKCountDown         = pSend->SAKInterval;

	pSend->uRetryTimer          = 0;
	
	pSend->idFrom               = idFrom;
	pSend->idTo                 = idTo;

	pSend->wIdFrom              = GetIndexByDPID(pProtocol, idFrom);
	pSend->wIdTo                = (WORD)pSession->iSession;
	pSend->RefCount             = 0;                        // if provider does async send counts references.

	pSend->serial               = 0;

	pSend->tLastACK             = timeGetTime();
	pSend->dwSendTime           = pSend->tLastACK;
	pSend->dwTimeOut            = dwTimeOut;

	pSend->BytesThisSend        = 0;

	pSend->messageid            = -1;  // avoid matching this send in ACK/NACK handlers
	pSend->bCleaningUp          = FALSE;

	hr=ISend(pProtocol,pSession, pSend);

exit:
	DecSessionRef(pSession);
	
exit2:
	return hr;

}

/*================================================================================
	Send Completion information matrix:
	===================================

											(pSend->dwFlags & ASEND_PROTOCOL)
							                               |
							Sync            Async   Internal (Async)
							--------------  -----   --------------------
	pSend->pAsyncInfo       0               user    0
	pSend->AI.SendCallback  0               user    InternalSendComplete
	pSend->AI.hEvent        pSend->hEvent   user    0
	pSend->AI.pStatus       &pSend->Status  user    &pSend->Status
	
 ---------------------------------------------------------------------------*/

HRESULT ISend(
	PPROTOCOL pProtocol,
	PSESSION pSession, 
	PSEND    pSend
	)
{
	HRESULT hr=DP_OK;

	DWORD_PTR fAsync;
	BOOL    fCallDirect=FALSE;

	fAsync=(DWORD_PTR)(pSend->pAsyncInfo);

	if(!fAsync && !(pSend->dwFlags & (ASEND_PROTOCOL|DPSEND_ASYNC))) {
		//Synchronous call, and not a protocol generated packet
		pSend->AsyncInfo.SendCallBack=NULL;
		//AsyncInfo.CallbackContext=0; //not required.
		pSend->AsyncInfo.hEvent=pSend->hEvent;
		pSend->AsyncInfo.pStatus=&pSend->Status;
		ResetEvent(pSend->hEvent);
	}

	// don't need to check if ref added here since the send isn't on a list yet.
	AddSendRef(pSend,2); // 1 for ISend, 1 for completion.

	DPF(9,"ISend: ==>Q\n");
	hr=QueueSendOnSession(pProtocol,pSession,pSend);
	DPF(9,"ISend: <==Q\n");

	if(hr==DP_OK){

		if(!fAsync && !(pSend->dwFlags & (ASEND_PROTOCOL|DPSEND_ASYNC))){
			// Synchronous call, and not internal, we need 
			// to wait until the send has completed.
			if(!(pSend->dwFlags & DPSEND_GUARANTEED)){
				// Non-guaranteed, need to drop dplay lock, in 
				// guaranteed case, dplay already dropped it for us.
				LEAVE_DPLAY();
			}
			
			DPF(9,"ISend: Wait==> %x\n",pSend->hEvent);
			Wait(pSend->hEvent);
			
			if(!(pSend->dwFlags & DPSEND_GUARANTEED)){
				ENTER_DPLAY();
			}

			DPF(9,"ISend: <== WAIT\n");
			hr=pSend->Status;
		} else {
			hr=DPERR_PENDING;
		}

	} else {
		DecSendRef(pProtocol, pSend); //not going to complete a send that didn't enqueue.
	}
	
	DecSendRef(pProtocol,pSend);

	return hr;
}


HRESULT QueueSendOnSession(
	PPROTOCOL pProtocol, PSESSION pSession, PSEND pSend
)
{
	BILINK *pBilink;                // walks the links scanning priority    
	BILINK *pPriQLink;      // runs links in the global priority queue.
	PSEND   pSendWalker;    // pointer to send structure
	BOOL    fFront;         // if we put this at the front of the CON SendQ
	BOOL    fSignalQ=TRUE;  // whether to signal the sendQ

	// BUGBUG: locking global and connection queues concurrently,
	//         -> this better be fast!
	ASSERT_SIGN(pSend, SEND_SIGN);
	
	Lock(&pProtocol->m_SendQLock);
	Lock(&pSession->SessionLock);
	Lock(&pSend->SendLock);

	if(pSession->eState != Open){
		Unlock(&pSend->SendLock);
		Unlock(&pSession->SessionLock);
		Unlock(&pProtocol->m_SendQLock);
		return DPERR_CONNECTIONLOST;
	}

	if(!(pSend->dwFlags & ASEND_PROTOCOL)){
		pProtocol->m_dwBytesPending += pSend->MessageSize;
		pProtocol->m_dwMessagesPending += 1;
	}	

	// Put on Connection SendQ

	// First Check if we are highest priority.
	pBilink = pSession->SendQ.next;
	pSendWalker=CONTAINING_RECORD(pBilink, SEND, SendQ);
	if(pBilink == &pSession->SendQ || pSendWalker->Priority < pSend->Priority)
	{
		InsertAfter(&pSend->SendQ,&pSession->SendQ);
		fFront=TRUE;
		
	} else {

		// Scan backwards through the SendQ until we find a Send with a higher
		// or equal priority and insert ourselves afterwards.  This is optimized
		// for the same pri send case.
	
		pBilink = pSession->SendQ.prev;

		while(TRUE /*pBilink != &pSend->SendQ*/){
		
			pSendWalker = CONTAINING_RECORD(pBilink, SEND, SendQ);
			
			ASSERT_SIGN(pSendWalker, SEND_SIGN);

			if(pSend->Priority <= pSendWalker->Priority){
				InsertAfter(&pSend->SendQ, &pSendWalker->SendQ);
				fFront=FALSE;
				break;
			}
			pBilink=pBilink->prev;
		}
		
		ASSERT(pBilink != &pSend->SendQ);
	}

	//
	// Put on Global SendQ
	//

	if(!fFront){
		// We queued it not at the front, therefore there are already
		// entries in the Global Queue and we need to be inserted 
		// after the entry that we are behind, so start scanning the
		// global queue backwards from the packet ahead of us in the
		// Connection Queue until we find a lower priority packet

		// get pointer into previous packet in queue.
		pBilink=pSend->SendQ.prev;
		// get pointer to the PriorityQ record of the previous packet.
		pPriQLink = &(CONTAINING_RECORD(pBilink, SEND, SendQ))->m_GSendQ;

		while(pPriQLink != &pProtocol->m_GSendQ){
			pSendWalker = CONTAINING_RECORD(pPriQLink, SEND, m_GSendQ);
			
			ASSERT_SIGN(pSendWalker, SEND_SIGN);

			if(pSendWalker->Priority < pSend->Priority){
				InsertBefore(&pSend->m_GSendQ, &pSendWalker->m_GSendQ);
				break;
			}
			pPriQLink=pPriQLink->next;
		}
		if(pPriQLink==&pProtocol->m_GSendQ){
			// put at the end of the list.
			InsertBefore(&pSend->m_GSendQ, &pProtocol->m_GSendQ);
		}
		
	} else {
		// There was no-one in front of us on the connection.  So
		// we look at the head of the global queue first and then scan 
		// from the back.

		pBilink = pProtocol->m_GSendQ.next;
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
		
		if(pBilink == &pProtocol->m_GSendQ ||  pSend->Priority > pSendWalker->Priority)
		{
			InsertAfter(&pSend->m_GSendQ,&pProtocol->m_GSendQ);
		} else {
			// Scan backwards through the m_GSendQ until we find a Send with a higher
			// or equal priority and insert ourselves afterwards.  This is optimized
			// for the same pri send case.
			
			pBilink = pProtocol->m_GSendQ.prev;

			while(TRUE){
				pSendWalker = CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
				
				ASSERT_SIGN(pSendWalker, SEND_SIGN);
				
				if(pSend->Priority <= pSendWalker->Priority){
					InsertAfter(&pSend->m_GSendQ, &pSendWalker->m_GSendQ);
					break;
				}
				pBilink=pBilink->prev;
			}
			
			ASSERT(pBilink != &pProtocol->m_GSendQ);
		}
		
	}

	// Fixup send state if we are blocking other sends on the session.

	if(pSend->dwFlags & DPSEND_GUARANTEED){
		if(pSession->nWaitingForMessageid){
			pSend->SendState=WaitingForId;
			pSession->nWaitingForMessageid++;
			fSignalQ=FALSE;
		}
	} else {
		if(pSession->nWaitingForDGMessageid){
			pSend->SendState=WaitingForId;
			pSession->nWaitingForDGMessageid++;
			fSignalQ=FALSE;
		}       
	}


#ifdef DEBUG
	DPF(9,"SessionQ:");
	pBilink=pSession->SendQ.next;
	while(pBilink!=&pSession->SendQ){
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, SendQ);
		ASSERT_SIGN(pSendWalker,SEND_SIGN);
		DPF(9,"Send %x pSession %x Pri %x State %d\n",pSendWalker,pSendWalker->pSession,pSendWalker->Priority,pSendWalker->SendState);
		pBilink=pBilink->next;
	}
	DPF(9,"GlobalQ:");
	pBilink=pProtocol->m_GSendQ.next;
	while(pBilink!=&pProtocol->m_GSendQ){
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
		ASSERT_SIGN(pSendWalker,SEND_SIGN);
		DPF(9,"Send %x pSession %x Pri %x State %d\n",pSendWalker,pSendWalker->pSession,pSendWalker->Priority,pSendWalker->SendState);
		pBilink=pBilink->next;
	}
#endif

	Unlock(&pSend->SendLock);
	Unlock(&pSession->SessionLock);
	Unlock(&pProtocol->m_SendQLock);

	if(fSignalQ){
		// tell send thread to process.
		SetEvent(pProtocol->m_hSendEvent);
	}       

	return DP_OK;
}

/*=============================================================================

	CopyDataToFrame
     
    Description:

		Copies data for a frame from the Send to the frame's data area. 

    Parameters:     

		pFrameData              - pointer to data area
		FrameDataSize   - Size of the Frame Data area
		pSend                   - send from which to get data
		nAhead          - number of frames ahead of NR to get data for.
		
    Return Values:

		Number of bytes copied.


	Notes: 

		Send must be locked across this call.
		
-----------------------------------------------------------------------------*/

UINT CopyDataToFrame(
	PUCHAR  pFrameData, 
	UINT    FrameDataLen,
	PSEND   pSend,
	UINT    nAhead)
{
	UINT    BytesToAdvance, BytesToCopy;
	UINT    FrameOffset=0;
	PUCHAR  dest,src;
	UINT    len;
	UINT    totlen=0;

	UINT    SendOffset;
	PBUFFER pSrcBuffer;
	UINT    CurrentBufferOffset;

	BytesToAdvance      = nAhead*FrameDataLen;
	SendOffset          = pSend->SendOffset;
	pSrcBuffer          = pSend->pCurrentBuffer;
	CurrentBufferOffset = pSend->CurrentBufferOffset;

	//
	// Run ahead to the buffer we start getting data from
	//

	while(BytesToAdvance){

		len = pSrcBuffer->len - CurrentBufferOffset;

		if(len > BytesToAdvance){
			CurrentBufferOffset += BytesToAdvance;
			SendOffset+=BytesToAdvance;
			BytesToAdvance=0;
		} else {
			pSrcBuffer=pSrcBuffer->pNext;
			CurrentBufferOffset = 0;
			BytesToAdvance-=len;
			SendOffset+=len;
		}
	}

	//
	// Copy the data for the Send into the frame
	//

	BytesToCopy = pSend->MessageSize - SendOffset;

	if(BytesToCopy > FrameDataLen){
		BytesToCopy=FrameDataLen;
	}

	while(BytesToCopy){

		ASSERT(pSrcBuffer);
		
		dest= pFrameData        + FrameOffset;
		src = pSrcBuffer->pData + CurrentBufferOffset;
		len = pSrcBuffer->len   - CurrentBufferOffset;

		if(len > BytesToCopy){
			len=BytesToCopy;
			CurrentBufferOffset+=len;//BUGBUG: not used after, don't need.
		} else {
			pSrcBuffer = pSrcBuffer->pNext;
			CurrentBufferOffset = 0;
		}

		BytesToCopy -= len;
		FrameOffset += len;
		totlen+=len;
		
		memcpy(dest,src,len);
	}
	
	return totlen;
}

// NOTE: ONLY 1 SEND THREAD ALLOWED.
ULONG WINAPI SendThread(LPVOID pProt)
{
	PPROTOCOL pProtocol=((PPROTOCOL)pProt);
	UINT  SendRc;

	while(TRUE){

		WaitForSingleObject(pProtocol->m_hSendEvent, INFINITE);

		Lock(&pProtocol->m_ObjLock);
		
		if(pProtocol->m_eState==ShuttingDown){
			pProtocol->m_nSendThreads--;
			Unlock(&pProtocol->m_ObjLock);
			ExitThread(0);
		}

		Unlock(&pProtocol->m_ObjLock);

		do {
			SendRc=SendHandler(pProtocol);
		} while (SendRc!=DPERR_NOMESSAGES);

	}
	return TRUE;
}


// Called with SendLock held.
VOID CancelRetryTimer(PSEND pSend)
{
//	UINT mmError;
	UINT retrycount=0;
	UINT_PTR uRetryTimer;
	UINT Unique;
	
	
	if(pSend->uRetryTimer){
		DPF(9,"Canceling Timer %x\n",pSend->uRetryTimer);

		// Delete it from the list first so we don't deadlock trying to kill it.
		Lock(&g_SendTimeoutListLock);

		uRetryTimer=pSend->uRetryTimer;
		Unique=pSend->TimerUnique;
		pSend->uRetryTimer=0;
	
		if(!EMPTY_BILINK(&pSend->TimeoutList)){
			Delete(&pSend->TimeoutList);
			InitBilink(&pSend->TimeoutList); // avoids DecSendRef having to know state of bilink.
			Unlock(&g_SendTimeoutListLock);

			CancelMyTimer(uRetryTimer, Unique);

		} else {
		
			Unlock(&g_SendTimeoutListLock);
		}
		
	} else {
		DPF(9,"CancelRetryTimer:No timer to cancel.\n");
	}
}

// Workaround for Win95 mmTimers:
// ==============================
//
// We cannot use a reference count for the timeouts as a result of the following Win95 bug:
//
// The cancelling of mmTimers is non-deterministic.  That is, when calling cancel, you cannot
// tell from the return code whether the timer ran, was cancelled or is still going to run.  
// Since we use the Send as the context for timeout, we cannot dereference it until we make 
// sure it is still valid, since code that cancelled the send and timer may have already freed 
// the send memory.  We place the sends being timed out on a list and scan the list for the
// send before we use it.  If we don't find the send on the list, we ignore the timeout.
//
// Also note, this workaround is not very expensive.  The linked list is in the order timeouts
// were scheduled, so generally if the links are approximately the same speed, timeouts will
// be similiar so the context being checked should be near the beginning of the list.


CRITICAL_SECTION g_SendTimeoutListLock;
BILINK g_BilinkSendTimeoutList;

void CALLBACK RetryTimerExpiry( UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2 )
{
	PSEND pSend=(PSEND)(dwUser), pSendWalker;
	UINT  tWaiting;
	BILINK *pBilink;
	UINT    bFound=FALSE;

	DPF(9,"RetryTimerExpiry: %x, expecting %x, pSend %x\n",uID, pSend->uRetryTimer, pSend);

	tWaiting=timeGetTime();

	// Scan the list of waiting sends to see if this one is still waiting for a timeout.
	Lock(&g_SendTimeoutListLock);

	pBilink=g_BilinkSendTimeoutList.next;

	while(pBilink!=&g_BilinkSendTimeoutList){
	
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, TimeoutList);
		pBilink=pBilink->next;
		
		if(pSendWalker == pSend){
			if(pSend->uRetryTimer==uID){
				Delete(&pSend->TimeoutList);
				InitBilink(&pSend->TimeoutList); // avoids DecSendRef having to know state of bilink.
				Unlock(&g_SendTimeoutListLock);
				// it is ok to call AddSendRef here without the sessionlock because
				// there is no way we could be adding the session reference.  If
				// the refcount is 0, it can only mean the send is already cleaning up
				// and we won't try to take the session locks so there is no lock
				// ordering problem.
				bFound=AddSendRef(pSend,1); // note bFound set to Refcount on send
				goto skip_unlock;
			}       
		}
	}
	
	Unlock(&g_SendTimeoutListLock);

skip_unlock:
	if(bFound){

		if(pSend->tRetryScheduled - pSend->tScheduled > 500){
			DWORD tm=timeGetTime();
			if(tm - pSend->tScheduled < 100 ){
				DPF(9,"RETRY TIMER EXPIRY IS WAY TOO EARLY, EXPECTED AT %x ACTUALLY AT %x\n",pSend->tRetryScheduled, tm);
				DEBUG_BREAK();
			}
		}
	
		DPF(9,"RetryTimerExpiry: Waiting For Send Lock...\n");

		Lock(&pSend->SendLock);

		DPF(9,"RetryTimerExpiry: Got SendLock\n");

		if(pSend->uRetryTimer==uID){ // check again, may be cancelled.
		
			pSend->uRetryTimer=0;

			switch(pSend->SendState)
			{
				case Start:             
				case Sending:   
					ASSERT(0);
				case Done:
					break;
					
				case WaitingForAck:

					pSend->RetryCount++;
					tWaiting-=pSend->tLastACK;

#ifdef DEBUG
					{
						static int retries;
						IN_WRITESTATS InWS;
						memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
					 	InWS.stat_USER1=((retries++)%20)+1;
						DbgWriteStats(&InWS);
					}
#endif

					if(tWaiting > pSend->pSession->MaxDropTime ||
					   (pSend->RetryCount > pSend->pSession->MaxRetry && tWaiting > pSend->pSession->MinDropTime)
					  )
					{
						DPF(8,"Send %x Timed Out, tWaiting: %d RetryCount: %d\n",pSend,tWaiting,pSend->RetryCount);
						pSend->SendState=TimedOut;
					} else {
						DPF(9,"Timer expired, retrying send %x RetryCount= %d\n",pSend,pSend->RetryCount);
						//pSend->NACKMask|=(1<<(pSend->NS-pSend->NR))-1;
						pSend->NACKMask |= 1; // just retry 1 frame.
						ASSERT_NACKMask(pSend);
						pSend->SendState=ReadyToSend;
					}       
					SetEvent(pSend->pSession->pProtocol->m_hSendEvent);
					break;
					
				case Throttled: 
					break;
				
				case ReadyToSend:
				default:
					break;

			}
		} 
		
		Unlock(&pSend->SendLock);
		DecSendRef(pSend->pSession->pProtocol, pSend);
	}       
}

VOID StartRetryTimer(PSEND pSend)
{
	UINT FptLatency;
	UINT tLatencyLong;
	UINT FptDev;
	UINT tRetry;

	FptLatency=max(pSend->pSession->FpLocalAverageLatency,pSend->pSession->LastLatency);
	FptDev=pSend->pSession->FpLocalAvgDeviation;
	tRetry=unFp(FptLatency+3*FptDev);//Latency +3 average deviations

	tLatencyLong=unFp(pSend->pSession->FpAverageLatency);

	// Sometimes stddev of latency gets badly skewed by the serial driver
	// taking a long time to complete locally, avoid setting retry time
	// too high by limiting to 2x the long latency average.
	if(tLatencyLong > 100 && tRetry > 2*max(tLatencyLong,unFp(FptLatency))){
		tRetry = 2*tLatencyLong;
	}

	if(pSend->RetryCount > 3){
		if(pSend->pSession->RemoteBytesReceived==0){
			// haven't spoken to remote yet, may be waiting for nametable, so back down hard.
			tRetry=5000;
		} else if (tRetry < 1000){
			// taking a lot of retries to get response, back down.
			tRetry=1000;
		}
	}

	if(tRetry < 50){
		tRetry=50;
	}
	
	ASSERT(tRetry);

	if(tRetry > 30000){
		DPF(0,"RETRY TIMER REQUESTING %d seconds?\n",tRetry);
	}
	
	if(!pSend->uRetryTimer){

		Lock(&g_SendTimeoutListLock);

		DPF(9,"Setting Retry Timer of %d ms\n", tRetry);

		pSend->uRetryTimer=SetMyTimer((tRetry)?(tRetry):1,(tRetry>>2)+1,RetryTimerExpiry,(ULONG_PTR) pSend,&pSend->TimerUnique);
		
		if(pSend->uRetryTimer){
			pSend->tScheduled = timeGetTime();
			pSend->tRetryScheduled = pSend->tScheduled+tRetry;
			InsertBefore(&pSend->TimeoutList, &g_BilinkSendTimeoutList);
		} else {
			DPF(0,"Start Retry Timer failed to schedule a timer with tRetry=%d for pSend %x\n",tRetry,pSend);
			DEBUG_BREAK();
		}
		
		DPF(9,"Started Retry Timer %x\n",pSend->uRetryTimer);                                                            

		Unlock(&g_SendTimeoutListLock);
										 
		if(!pSend->uRetryTimer){
			ASSERT(0);
		}
		
	} else {
		ASSERT(0);
	}

}

// Called with all necessary locks held.
VOID TimeOutSession(PSESSION pSession)
{
	PSEND pSend;
	BILINK *pBilink;
	UINT nSignalsRequired=0;

	// Mark Session Timed out.
	pSession->eState=Closing;
	// Mark all sends Timed out.
	pBilink=pSession->SendQ.next;

	while(pBilink != &pSession->SendQ){
	
		pSend=CONTAINING_RECORD(pBilink, SEND, SendQ);
		pBilink=pBilink->next;

		DPF(9,"TimeOutSession: Force Timing Out Send %x, State %d\n",pSend, pSend->SendState);

		switch(pSend->SendState){
		
			case Start:
			case Throttled:
			case ReadyToSend:
				DPF(9,"TimeOutSession: Moving to TimedOut, should be safe\n");
				pSend->SendState=TimedOut;
				nSignalsRequired += 1;
				break;
				
			case Sending:
				//BUGBUG: can we even get here?  If we can 
				// the send will reset the retry count and tLastACK.
				DPF(9,"TimeOutSession: ALLOWING TimeOut to cancel.(could take 15 secs)\n");
				pSend->RetryCount=pSession->MaxRetry;
				pSend->tLastACK=timeGetTime()-pSession->MinDropTime;
				break;

			case WaitingForAck:
				DPF(9,"TimeOutSession: Canceling timer and making TimedOut\n");
				CancelRetryTimer(pSend);
				pSend->SendState = TimedOut;
				nSignalsRequired += 1;
				break;
				
			case WaitingForId:
				// Note, this means we can get signals for ids that aren't used.
				DPF(9,"TimeOutSession: Timing Out Send Waiting for ID, GetNextMessageToSend may fail, this is OK\n");
				pSend->SendState=TimedOut;
				if(pSend->dwFlags & DPSEND_GUARANTEED){
					InterlockedDecrement(&pSession->nWaitingForMessageid);
				} else {
					InterlockedDecrement(&pSession->nWaitingForDGMessageid);
				}
				nSignalsRequired += 1;
				break;
				
			case TimedOut:
			case Done:
				DPF(9,"TimeOutSession: Send already done or timed out, doesn't need our help\n");
				break;
				
			default:
				DPF(0,"TimeOutSession, pSession %x found Send %x in Wierd State %d\n",pSession,pSend,pSend->SendState);
				ASSERT(0);
				break;
		} /* switch */

	} /* while */

	// Create enough signals to process timed out sends.
	DPF(9,"Signalling SendQ %d items to process\n",nSignalsRequired);
	SetEvent(pSession->pProtocol->m_hSendEvent);
}

UINT WrapSend(PPROTOCOL pProtocol, PSEND pSend, PBUFFER pBuffer)
{
	PUCHAR pMessage,pMessageStart;
	DWORD dwWrapSize=0;
	DWORD dwIdTo=0;
	DWORD dwIdFrom=0;

	pMessageStart = &pBuffer->pData[pProtocol->m_dwSPHeaderSize];
	pMessage      = pMessageStart;
	dwIdFrom      = pSend->wIdFrom;
	dwIdTo        = pSend->wIdTo;
	
	if(dwIdFrom==0x70){ // avoid looking like a system message 'play'
		dwIdFrom=0xFFFF;
	}

	if(dwIdFrom){
		while(dwIdFrom){
			*pMessage=(UCHAR)(dwIdFrom & 0x7F);
			dwIdFrom >>= 7;
			if(dwIdFrom){
				*pMessage|=0x80;
			}
			pMessage++;
		}
	} else {
		*(pMessage++)=0;
	}

	if(dwIdTo){
		while(dwIdTo){
			*pMessage=(UCHAR)(dwIdTo & 0x7F);
			dwIdTo >>= 7;
			if(dwIdTo){
				*pMessage|=0x80;
			}
			pMessage++;
		}
	} else {
		*(pMessage++)=0;
	}

#if 0	// a-josbor: for debugging only.  I left it in in case we ever needed it again
	ExtractProtocolIds(pMessageStart, &dwIdFrom, &dwIdTo);
	ASSERT(dwIdFrom == pSend->wIdFrom);
	ASSERT(dwIdTo == pSend->wIdTo);
#endif

	return (UINT)(pMessage-pMessageStart);
}       

#define DROP 0

#if DROP
// 1 for send, 0 for drop.

char droparray[]= {
	1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0};

UINT dropindex=0;
#endif

VOID CALLBACK UnThrottle(UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2)
{
	PSESSION pSession=(PSESSION)dwUser;
	UINT tMissedBy;		// how long we missed the throttle by.
	DWORD tm;

	Lock(&pSession->SessionLock);

	tm=timeGetTime();
	tMissedBy = tm-pSession->tNextSend;

	if( (int)tMissedBy > 0){
		pSession->FpAvgUnThrottleTime -= pSession->FpAvgUnThrottleTime >> 4;
		pSession->FpAvgUnThrottleTime += (Fp(tMissedBy) >> 4);
		DPF(9,"Missed by: %d ms Avg Unthrottle Miss %d.%d ms\n", tMissedBy, pSession->FpAvgUnThrottleTime >> 8, (((pSession->FpAvgUnThrottleTime&0xFF)*100)/256) );
		
	}
	
	pSession->uUnThrottle=0;
	pSession->dwFlags |= SESSION_UNTHROTTLED; 
	pSession->pProtocol->m_bRescanQueue=TRUE;	// tell send routine to restart scan.
	DPF(9,"Unthrottling Session %x at %d\n",pSession, timeGetTime());
	Unlock(&pSession->SessionLock);
	SetEvent(pSession->pProtocol->m_hSendEvent);
	DecSessionRef(pSession);
}

VOID Throttle( PSESSION pSession, DWORD tm )
{
	DWORD tmDelta;
	Lock(&pSession->SessionLock);
		pSession->bhitThrottle=TRUE;
		pSession->dwFlags |= SESSION_THROTTLED;
		tmDelta = pSession->tNextSend - tm;
		if((INT)tmDelta < 0){
			tmDelta=1;
		}
		DPF(9,"Throttling pSession %x for %d ms (until %d)\n",pSession, tmDelta,pSession->tNextSend);
		pSession->RefCount++;
		pSession->uUnThrottle = SetMyTimer(tmDelta, (tmDelta>>2)?(tmDelta>>2):1, UnThrottle, (DWORD_PTR)pSession, &pSession->UnThrottleUnique);
		if(!pSession->uUnThrottle){
			DPF(0,"UH OH failed to schedule unthrottle event\n");
			DEBUG_BREAK();
		}
	Unlock(&pSession->SessionLock);
#ifdef DEBUG
	{
		static int throttlecounter;
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_USER4=((throttlecounter++)%20)+1;
		DbgWriteStats(&InWS);
	}
#endif
}	

// Given the current time, the bandwidth we are throttling to and the length of the packet we are sending,
// calculate the next time we are allowed to send.  Also keep a residue from this calculation so that
// we don't wind up using excessive bandwidth due to rounding, the residue from the last calculation is
// used in this calculation.

// Absolute flag means set the next send time relative to tm regardless

VOID UpdateSendTime(PSESSION pSession, DWORD Len, DWORD tm, BOOL fAbsolute)
{
	#define SendRate 		pSession->SendRateThrottle
	#define Residue   		pSession->tNextSendResidue
	#define tNext           pSession->tNextSend
	
	DWORD tFrame;		// amount of time this frame will take on the wire.


	tFrame = (Len+Residue)*1000 / SendRate;	// rate is bps, but want to calc bpms, so (Len+Residue)*1000
	
	Residue = (Len+Residue) - (tFrame * SendRate)/1000 ;	
	
	ASSERT(!(Residue&0x80000000)); 	// residue better be +ve

	if(fAbsolute || (INT)(tNext - tm) < 0){
		// tNext is less than tm, so calc based on tm.
		tNext = tm+tFrame;
	} else {
		// tNext is greater than tm, so add more wait.
		tNext = tNext+tFrame;
	}

	DPF(8,"UpdateSendTime time %d, tFrame %d, Residue %d, tNext %d",tm,tFrame,Residue,tNext);


	#undef SendRate
	#undef Residue
	#undef tNext
}			

//CHAR Drop[]={0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,1,0,0};
//DWORD DropSize = sizeof(Drop);
//DWORD iDrop=0;

// AO - added contraint, 1 send thread per session.  Since this is not enforced by GetNextMessageToSend
// 5-21-98  we are effectively restricted to 1 send thread for the protocol.  We can fix this by adding
//      a sending state on the session and having GetNextMessageToSend skip sending sessions.
HRESULT ReliableSend(PPROTOCOL pProtocol, PSEND pSend)
{
	#define pBigFrame ((pPacket2)(pFrame))

	HRESULT  hr;
	PBUFFER  pBuffer;

	pPacket1  pFrame;
	PUCHAR   pFrameData;
	UINT     FrameDataLen;
	UINT     FrameTotalLen;
	UINT     MaxFrameLen;
	UINT     FrameHeaderLen;

	UINT     nFramesOutstanding;
	UINT     nFramesToSend;
	UINT     msk;
	UINT     shift;

	UINT     WrapSize;
	UINT     DPWrapSize;      // DirectPlay wrapping only. ([[DPLAY 0xFF]|],From,To)
	DWORD    tm=0;			  // The time, 0 if we haven't retrieved it yet.
	DWORD    tmExit=0;
	BOOL     bExitEarly=FALSE;

	DPSP_SENDDATA SendData;
	
	//
	// Sending algorithm is designed to handle NACKs only (there
	// is no special case for sending data the first time).  So
	// We send by making it look like the frames we want to send
	// have been NACKed.  Every frame we send, we clear the NACK
	// bit for.  If an actual NACK comes in, the bit is set.
	// When an ACK comes in, we shift the NACK and ACK masks
	// nACK-NR and if applicable, set new NACK bits.
	//

	Lock(&pSend->SendLock);

	if(pSend->SendState == Done){
		goto unlock_exit;
	}       


	nFramesOutstanding=(pSend->NS-pSend->NR);

	if( nFramesOutstanding < pSend->WindowSize){

		// Set NACK bits up to WindowSize (unless over nFrames);
		
		nFramesToSend=pSend->WindowSize-nFramesOutstanding;

		if(nFramesToSend > pSend->nFrames-pSend->NS){
			nFramesToSend=pSend->nFrames-pSend->NS;
		}

		pSend->NACKMask |= ((1<<nFramesToSend)-1)<<nFramesOutstanding;
		pSend->OpenWindow = nFramesOutstanding + nFramesToSend;
		DPF(9,"Send: pSend->NACKMask %x, OpenWindow %d\n",pSend->NACKMask, pSend->OpenWindow);
		
	}

	tmExit=timeGetTime()+1000; // always blow out of here in 1 second max.
	
Reload:
	msk=1;
	shift=0;
	
	MaxFrameLen=pSend->FrameSize;

	while(pSend->NACKMask){
	
		ASSERT_NACKMask(pSend);
		
		tm=timeGetTime();		// Getting the time is relatively expensive, so we do it once here and pass it around.

		if(((INT)tm - (INT)tmExit) > 0){
			DPF(0,"Breaking Out of Send Loop due to expiry of timer\n");
			bExitEarly=TRUE;
			break;
		}
		
		if((tm+unFp(pSend->pSession->FpAvgUnThrottleTime)-pSend->pSession->tNextSend) & 0x80000000){
			// we're still too early to do the next send, so throttled this session.
			goto throttle_exit;
		}


		if(pSend->NACKMask & msk){

			pBuffer=GetFrameBuffer(MaxFrameLen+pProtocol->m_dwSPHeaderSize+MAX_SEND_HEADER);
			
			if(!pBuffer){
    			pSend->SendState=ReadyToSend;
	    		SetEvent(pSend->pSession->pProtocol->m_hSendEvent); // keep the queue rolling.
				hr=DPERR_PENDING;
				goto exit;
			}

			WrapSize=pProtocol->m_dwSPHeaderSize;              // leave space for SP header.
			DPWrapSize=WrapSend(pProtocol, pSend, pBuffer); // fill in out address wrapping
			WrapSize+=DPWrapSize;

			pFrame=(pPacket1)&pBuffer->pData[WrapSize];    // protocol header after wrapping
			
			if(pSend->fSendSmall){
				pFrameData=&pFrame->data[0];
				FrameHeaderLen=(UINT)(pFrameData-(PUCHAR)pFrame);
			} else {
				pFrameData=&pBigFrame->data[0];
				FrameHeaderLen=(UINT)(pFrameData-(PUCHAR)pFrame);
			}

			// For calculating nFrames, we assumed MAX_SEND_HEADER, subtract out the unused portion
			// so we don't put to much data in the frame and mess up the accounting.
			pBuffer->len-=(MAX_SEND_HEADER-(FrameHeaderLen+DPWrapSize)); 

			FrameHeaderLen += WrapSize;     // now include wrapping and SPheader space.
			
			FrameDataLen=CopyDataToFrame(pFrameData, pBuffer->len-FrameHeaderLen, pSend, shift);

			if(!pSend->FrameDataLen){
				pSend->FrameDataLen=FrameDataLen;
			}       
			
			FrameTotalLen=FrameDataLen+FrameHeaderLen;

			pSend->BytesThisSend=FrameTotalLen-WrapSize; //only counting payload

			// Do that protocol thing
			BuildHeader(pSend,pFrame,shift,tm);

			// we know we don't have to check here since we have a reference
			// from finding the send to work on ON the send queue.  So it
			// can't go away til we return from this function.
			hr=AddSendRef(pSend,1);
			ASSERT(hr);
			
			if(pSend->NR+shift >= pSend->NS){
				pSend->NS = pSend->NR+shift+1;
			}       
			pSend->NACKMask &= ~msk;
			
			DPF(9,"S %2x %2x %2x\n",pBuffer->pData[0], pBuffer->pData[1], pBuffer->pData[2]);

			// Update the next time we are allowed to send.
			UpdateSendTime(pSend->pSession, pSend->BytesThisSend, tm, FALSE);

			Unlock(&pSend->SendLock);

			ASSERT(!(FrameTotalLen &0xFFFF0000));

			
			// Send this puppy...

			SendData.dwFlags        = pSend->dwFlags & ~DPSEND_GUARANTEED;
			SendData.idPlayerTo     = pSend->idTo;
			SendData.idPlayerFrom   = pSend->idFrom;
			SendData.lpMessage      = pBuffer->pData;
			SendData.dwMessageSize  = FrameTotalLen;
			SendData.bSystemMessage = 0;
			SendData.lpISP          = pProtocol->m_lpISP;

			ENTER_DPLAY();

			Lock(&pProtocol->m_SPLock);

		//	if(!(Drop[(iDrop++)%DropSize])){//BUGBUG: DEBUG ONLY!

				hr=CALLSP(pProtocol->m_lpDPlay->pcbSPCallbacks->Send,&SendData); 
		//	}

			Unlock(&pProtocol->m_SPLock);

			LEAVE_DPLAY();
			
			if(hr!=DPERR_PENDING){
				if(!DecSendRef(pProtocol, pSend)){
					ASSERT(0);
					hr=DPERR_PENDING;
					goto exit;
				}
				FreeFrameBuffer(pBuffer);
			}

			Lock(&pSend->SendLock);
		
		} /* endif (pSend->NACKMask & msk) */

		if(pSend->fUpdate){
			pSend->fUpdate=FALSE;
			goto Reload;
		}

		// Check if we are past windowsize, if so roll back the mask
		// Also if there are earlier bits to ACK.
		if((msk<<=1UL) >= (1UL<<pSend->WindowSize)){
			msk=1;
			shift=0;
		} else {
			shift++;
		}
		

	} /* end while (pSend->NACKMask) */

	if(pSend->SendState != Done){

		if(bExitEarly){
			pSend->SendState=ReadyToSend;
			SetEvent(pSend->pSession->pProtocol->m_hSendEvent); // keep the queue rolling.
		} else {
			pSend->SendState=WaitingForAck;
			StartRetryTimer(pSend);
		}	
	}       

unlock_exit:
	Unlock(&pSend->SendLock);

	hr=DPERR_PENDING; // Reliable sends are completed by the ACK.


	
exit:
	return hr;

throttle_exit:

	hr=DPERR_PENDING;
	
	pSend->SendState=Throttled;
	Unlock(&pSend->SendLock);

	Throttle(pSend->pSession, tm);

	return hr;
	
	#undef pBigFrame        
}

// TRUE, didn't reach end, FALSE, no more to send.
BOOL AdvanceSend(PSEND pSend, UINT AckedLen)
{
	BOOL rc=TRUE;

	// quick short circuit for small messages.
	if(AckedLen+pSend->SendOffset==pSend->MessageSize){
		rc=FALSE;
		goto exit;
	}
	
	if(pSend->SendOffset+AckedLen > pSend->MessageSize){
		AckedLen=pSend->MessageSize-pSend->SendOffset;
	}
		
	pSend->SendOffset+=AckedLen;
	
	while(AckedLen){
		if(pSend->pCurrentBuffer->len-pSend->CurrentBufferOffset >= AckedLen){
			pSend->CurrentBufferOffset+=AckedLen;
			rc=TRUE;
			break;
		} else {
			AckedLen -= (pSend->pCurrentBuffer->len-pSend->CurrentBufferOffset);
			pSend->pCurrentBuffer=pSend->pCurrentBuffer->pNext;
			pSend->CurrentBufferOffset=0;
			rc=FALSE;
		}
	}

exit:
	return rc;
}

HRESULT DGSend(PPROTOCOL pProtocol, PSEND  pSend)
{
	#define pBigFrame ((pPacket2)(pFrame))
	
	PBUFFER  pBuffer;

	pPacket1 pFrame;
	PUCHAR   pFrameData;
	UINT     FrameDataLen;
	UINT     FrameHeaderLen;
	UINT     FrameTotalLen;
	UINT     MaxFrameLen;

	UINT     nFramesToSend;

	UINT     WrapSize;
	UINT     DPWrapSize;      // DirectPlay wrapping only. ([[DPLAY 0xFF]|],From,To)

	DPSP_SENDDATA SendData;

	DWORD    tm;
	HRESULT  hr;
	
	Lock(&pSend->SendLock);

	nFramesToSend=pSend->nFrames-pSend->NR;

	MaxFrameLen=pSend->FrameSize;

	while(nFramesToSend){

		tm=timeGetTime();		// Getting the time is relatively expensive, so we do it once here and pass it around.
		
		if((tm+unFp(pSend->pSession->FpAvgUnThrottleTime)-pSend->pSession->tNextSend) & 0x80000000){
			// we're still too early to do the next send, so throttled this session.
			goto throttle_exit;
		}

		pBuffer=GetFrameBuffer(MaxFrameLen+pProtocol->m_dwSPHeaderSize+MAX_SEND_HEADER);
		
		if(!pBuffer){
			hr=DPERR_PENDING;
			goto exit;
		}

		WrapSize=pProtocol->m_dwSPHeaderSize;              // leave space for SP header.
		DPWrapSize=WrapSend(pProtocol, pSend, pBuffer); // fill in out address wrapping
		WrapSize+=DPWrapSize;

		pFrame=(pPacket1)&pBuffer->pData[WrapSize];    // protocol header after wrapping
		
		if(pSend->fSendSmall){
			pFrameData=&pFrame->data[0];
			FrameHeaderLen=(UINT)(pFrameData-(PUCHAR)pFrame);
		} else {
			pFrameData=&pBigFrame->data[0];
			FrameHeaderLen=(UINT)(pFrameData-(PUCHAR)pFrame);
		}

		// For calculating nFrames, we assumed MAX_SEND_HEADER, subtract out the unused portion
		// so we don't put to much data in the frame and mess up the accounting.
		pBuffer->len-=(MAX_SEND_HEADER-(FrameHeaderLen+DPWrapSize)); 

		FrameHeaderLen += WrapSize;     // now include wrapping and SPheader space.

		FrameDataLen=CopyDataToFrame(pFrameData, pBuffer->len-FrameHeaderLen, pSend, 0);

		FrameTotalLen=FrameDataLen+FrameHeaderLen;
		
		pSend->BytesThisSend=FrameTotalLen-WrapSize; //only counting payload
		
		// Do that protocol thing
		BuildHeader(pSend,pFrame,0,tm);

		//AddSendRef(pSend,1); //already locked, so just add one.
		ASSERT(pSend->RefCount); //verifies ++ below is ok.
		InterlockedIncrement((PLONG)&pSend->RefCount);  

		UpdateSendTime(pSend->pSession,pSend->BytesThisSend,tm,FALSE);
		
		Unlock(&pSend->SendLock);

		// Send this puppy...
		ASSERT(!(pSend->dwFlags & DPSEND_GUARANTEED));
		SendData.dwFlags        = pSend->dwFlags;
		SendData.idPlayerTo     = pSend->idTo;
		SendData.idPlayerFrom   = pSend->idFrom;
		SendData.lpMessage      = pBuffer->pData;
		SendData.dwMessageSize  = FrameTotalLen;
		SendData.bSystemMessage = 0;
		SendData.lpISP          = pProtocol->m_lpISP;

		ENTER_DPLAY();
		
		Lock(&pProtocol->m_SPLock);

		hr=CALLSP(pProtocol->m_lpDPlay->pcbSPCallbacks->Send,&SendData); 

		Unlock(&pProtocol->m_SPLock);

		LEAVE_DPLAY();
		
		if(hr!=DPERR_PENDING){
			if(!DecSendRef(pProtocol,pSend)){
				// No async send support in Dplay at lower edge,
				// so we should never get here!
				ASSERT(0);
			}
			FreeFrameBuffer(pBuffer);
		}
		
		Lock(&pSend->SendLock);
		
		nFramesToSend--;
		
		AdvanceSend(pSend,FrameDataLen);
		pSend->NR++;
		pSend->NS++;
	}
	
	Unlock(&pSend->SendLock);

	DGCompleteSend(pSend); 

	hr=DPERR_PENDING;  // everything was sent, but already completed by DGCompleteSend

exit:
	return hr;

throttle_exit:
	hr=DPERR_PENDING;

	pSend->SendState=Throttled;
	Unlock(&pSend->SendLock);

	Throttle(pSend->pSession, tm);

	return hr;
	#undef pBigFrame        
}

BOOL DGCompleteSend(PSEND pSend)
{
	UINT bit;
	UINT MsgMask;
	PSESSION pSession;
	
	pSend->SendState=Done;
	pSession=pSend->pSession;

	Lock(&pSession->SessionLock);

	if(!pSend->fSendSmall){
		MsgMask = 0xFFFF;
	} else {
		MsgMask =0xFF;
	}       

	DPF(9,"CompleteSend\n");

	//
	// Update Session information for completion of this send.
	//
	
	bit = ((pSend->messageid-pSession->DGFirstMsg) & MsgMask)-1;

	// clear the message mask bit for the completed send.
	if(pSession->DGOutMsgMask & 1<<bit){
		pSession->DGOutMsgMask &= ~(1<<bit);
	} else {
		return FALSE;
	}
	
	// slide the first message count forward for each low
	// bit clear in Message mask.
	while(pSession->DGLastMsg-pSession->DGFirstMsg){
		if(!(pSession->DGOutMsgMask & 1)){
			pSession->DGFirstMsg=(pSession->DGFirstMsg+1)&MsgMask;
			pSession->DGOutMsgMask >>= 1;
			if(pSession->nWaitingForDGMessageid){
				pSession->pProtocol->m_bRescanQueue=TRUE;
				SetEvent(pSession->pProtocol->m_hSendEvent);
			}       
		} else {
			break;
		}
	}
	
	//
	// Return the Send to the pool and complete the waiting client.
	//

	Unlock(&pSession->SessionLock);
	
	ASSERT(pSend->RefCount);
	
	// Send completed, do completion

	DoSendCompletion(pSend, DP_OK);

	DecSendRef(pSession->pProtocol, pSend); // for completion.

	return TRUE;
}


// Send a fully formatted System packet (ACK, nACK, etc..)
HRESULT SystemSend(PPROTOCOL pProtocol, PSEND  pSend)
{
	PBUFFER  pBuffer;
	DPSP_SENDDATA SendData;
	HRESULT  hr;
	PSESSION pSession;

	pBuffer=pSend->pMessage;

	DPF(9,"System Send pBuffer %x pData %x len %d, idTo %x \n",pBuffer, pBuffer->pData, pBuffer->len, pSend->idTo);
	

	pSession=GetSysSessionByIndex(pProtocol, pSend->wIdTo); // adds a ref on session.
															//      |
	if(!pSession){											//      |
		goto exit;											//      |
	}														//      |
															//      |
	SendData.idPlayerTo     = pSession->dpid;				//		|
	DecSessionRef(pSession); 								// <----+  frees ref here.
	
	// Send this puppy...
	SendData.dwFlags        = 0;
	SendData.idPlayerFrom   = pSend->idFrom;
	SendData.lpMessage      = pBuffer->pData;
	SendData.dwMessageSize  = pBuffer->len;
	SendData.bSystemMessage = 0;
	SendData.lpISP          = pProtocol->m_lpISP;

	ENTER_DPLAY();
	Lock(&pProtocol->m_SPLock);

	hr=CALLSP(pProtocol->m_lpDPlay->pcbSPCallbacks->Send,&SendData); 

	Unlock(&pProtocol->m_SPLock);

	LEAVE_DPLAY();

#ifdef DEBUG
	if(hr!=DP_OK){
		DPF(0,"UNSUCCESSFUL SEND in SYSTEM SEND, hr=%x\n",hr);
	}
#endif
exit:
	return hr;
	
	#undef pBigFrame        
}

VOID DoSendCompletion(PSEND pSend, INT Status)
{
	#ifdef DEBUG
	if(Status != DP_OK){
		DPF(8,"Send Error pSend %x, Status %x\n",pSend,Status);
	}
	#endif
	if(!(pSend->dwFlags & ASEND_PROTOCOL)){
		EnterCriticalSection(&pSend->pProtocol->m_SendQLock);
		pSend->pProtocol->m_dwBytesPending -= pSend->MessageSize;
		pSend->pProtocol->m_dwMessagesPending -= 1;
		LeaveCriticalSection(&pSend->pProtocol->m_SendQLock);
	}	

	if(pSend->pAsyncInfo){
		// ASYNC_SEND
		if(pSend->AsyncInfo.pStatus){
			(*pSend->AsyncInfo.pStatus)=Status;
		}       
		if(pSend->AsyncInfo.SendCallBack){
			(*pSend->AsyncInfo.SendCallBack)(pSend->AsyncInfo.CallBackContext,Status);
		}
		if(pSend->AsyncInfo.hEvent){
			DPF(9,"ASYNC_SENDCOMPLETE: Signalling Event %x\n",pSend->AsyncInfo.hEvent);
			SetEvent(pSend->AsyncInfo.hEvent);
		}
	} else if (!(pSend->dwFlags&(ASEND_PROTOCOL|DPSEND_ASYNC))){
		// SYNC_SEND
		if(pSend->AsyncInfo.pStatus){
			(*pSend->AsyncInfo.pStatus)=Status;
		}       
		if(pSend->AsyncInfo.hEvent){
			DPF(9,"SYNC_SENDCOMPLETE: Signalling Event %x\n",pSend->AsyncInfo.hEvent);
			SetEvent(pSend->AsyncInfo.hEvent);
		}
	} else {
		// PROTOCOL INTERNAL ASYNC SEND
		if(pSend->AsyncInfo.pStatus){
			(*pSend->AsyncInfo.pStatus)=Status;
		}       
		if(pSend->AsyncInfo.SendCallBack){
			(*pSend->AsyncInfo.SendCallBack)(pSend->AsyncInfo.CallBackContext,Status);
		}
	}
}

/*=============================================================================

	SendHandler - Send the next message that needs to send packets.
    
    Description:

	Finds a message on the send queue that needs to send packets and deserves
	to use some bandwidth, either because it is highest priority or because
	all the higher priority messages are waiting for ACKs.  Then sends as many
	packets as possible before hitting the throttling limit.

	Returns when the throttle limit is hit, or all packets for this send have
	been sent.

    Parameters:     

		pARPD pObj - pointer to the ARPD object to send packets on.

    Return Values:


-----------------------------------------------------------------------------*/
HRESULT SendHandler(PPROTOCOL pProtocol)
{

	PSEND pSend;    
	HRESULT  hr=DP_OK;
	PSESSION pSession;

	// adds ref to send and session if found
	pSend=GetNextMessageToSend(pProtocol); 

	if(!pSend){
		goto nothing_to_send;
	}

    //DPF(4,"==>Send\n");

	switch(pSend->pSession->eState){

		case Open:
			
			switch(pSend->SendState){
			
				case Done:              // Send handlers must deal with Done.
					DPF(9,"Calling SendHandler for Done Send--should just return\n");
				case Sending:
					//
					// Send as many frames as we can given the window size.
					//

					// Send handlers dump packets on the wire, if they expect
					// to be completed later, they return PENDING in which case
					// their completion handlers must do the cleanup.  If they
					// return OK, it means everything for this send is done and
					// we do the cleanup.
				
					if(pSend->dwFlags & ASEND_PROTOCOL){
						hr=SystemSend(pProtocol, pSend);
					} else if(pSend->dwFlags & DPSEND_GUARANTEE){
						hr=ReliableSend(pProtocol, pSend);
					} else {
						hr=DGSend(pProtocol, pSend);
					}
					break;
					
				case TimedOut:
					hr=DPERR_CONNECTIONLOST;
					pSend->SendState=Done;
					break;

				case Cancelled:
					hr=DPERR_USERCANCEL;
					pSend->SendState=Done;
					break;

				case UserTimeOut:
					hr=DPERR_TIMEOUT;
					pSend->SendState=Done;
					break;

				default:        
					DPF(0,"SendHandler: Invalid pSend %x SendState: %d\n",pSend,pSend->SendState);
					ASSERT(0);
			}               
			break;

		case Closing:
			switch(pSend->SendState){
				case TimedOut:
					DPF(8,"Returning CONNECTIONLOST on timed out message %x\n",DPERR_CONNECTIONLOST);
					hr=DPERR_CONNECTIONLOST;
					break;
					
				default:	
					DPF(8,"Send for session in Closing State, returning %x\n",DPERR_INVALIDPLAYER);
					hr=DPERR_INVALIDPLAYER;
					break;
			}		
			pSend->SendState=Done;
			break;
			
		case Closed:
			DPF(8,"Send for session in Closed State, returning %x",DPERR_INVALIDPLAYER);
			hr=DPERR_INVALIDPLAYER;
			pSend->SendState=Done;
			break;
	}               

    //DPF(4,"<==Send Leaving,rc=%x\n",hr);

	if( hr != DPERR_PENDING ){
		Lock(&pSend->SendLock);
		ASSERT(pSend->RefCount);
		
		//
		// Send completed, do completion
		//
		DoSendCompletion(pSend, hr);

		Unlock(&pSend->SendLock);
		DecSendRef(pProtocol, pSend);   // for completion
	} 

	pSession=pSend->pSession;
	DecSendRef(pProtocol,pSend); // Balances GetNextMessageToSend
	DecSessionRef(pSession); // Balances GetNextMessageToSend
	return hr;

nothing_to_send:
	return DPERR_NOMESSAGES;
}

/*=============================================================================

	Build Header - fill in the frame header for a packet to be sent.
    
    Description:

	Enough space is left in the frame to go on the wire (pFrame) to fit the
	message header.  One of two types of headers is built, depending on the
	value of the fSendSmall field of the packet.  If fSendSmall is TRUE, a compact 
	header is built, this lowers overhead on slow media.  If fSendSmall is FALSE
	a larger header that can support larger windows is built.  The header
	is filled into the front of pFrame.

    Parameters:     

		pARPD pObj - pointer to the ARPD object to send packets on.

    Return Values:


-----------------------------------------------------------------------------*/

VOID BuildHeader(PSEND pSend,pPacket1 pFrame, UINT shift, DWORD tm)
{
	#define pBigFrame ((pPacket2)(pFrame))

	PSENDSTAT pStat=NULL;
	UINT      seq;

	UINT      bitEOM,bitSTA,bitSAK=0;
	DWORD     BytesSent;
	DWORD	  RemoteBytesReceived;
	DWORD     tRemoteBytesReceived;
	DWORD     bResetBias=FALSE;

	// on first frame of a message, set the start bit (STA).
	if(pSend->NR+shift==0){
		bitSTA=STA;
	} else {
		bitSTA=0;
	}

	// on the last frome of a message set the end of message bit (EOM)
	if(pSend->nFrames==pSend->NR+shift+1){
		bitEOM=EOM;
	} else {
		bitEOM=0;
	}

	// if we haven't set EOM and we haven't requested an ACK in 1/4 the
	// round trip latency, set the SAK bit, to ensure we have at least 
	// 2 ACK's in flight for feedback to the send throttle control system.
	// Don't create extra ACKs if round trip is less than 100 ms.
	if(!bitEOM || !(pSend->dwFlags & DPSEND_GUARANTEED)){
		DWORD tmDeltaSAK = tm-pSend->pSession->tLastSAK;
		if(((int)tmDeltaSAK > 50 ) &&
	       (tmDeltaSAK > (unFp(pSend->pSession->FpLocalAverageLatency)>>2))
	      )
		{
			bitSAK=SAK;
		} 
	}

	// If we re-transmitted we need to send a SAK
	// despite the SAK countdown.
	if((!bitSAK) &&
	   (pSend->dwFlags & DPSEND_GUARANTEED) &&
	   ((pSend->NACKMask & (pSend->NACKMask-1)) == 0) &&
	   (bitEOM==0)
	  )
	{
		bitSAK=SAK;
	}

	if(!(--pSend->SAKCountDown)){
		bitSAK=SAK;
	}

	if(bitSAK|bitEOM){
		pSend->pSession->tLastSAK = tm;
		pSend->SAKCountDown=pSend->SAKInterval;
		pStat=GetSendStat();
	}	
	
	if(pSend->fSendSmall){

		pFrame->flags=CMD|bitEOM|bitSTA|bitSAK;
		
		seq=(pSend->NR+shift+1) & pSend->SendSEQMSK;
		pFrame->messageid = (byte)pSend->messageid;
		pFrame->sequence  = (byte)seq;
		pFrame->serial    = (byte)(pSend->serial++);

		if(pStat){
			pStat->serial=pFrame->serial;
		}
		
	} else {
	
		pBigFrame->flags=CMD|BIG|bitEOM|bitSTA|bitSAK;
		
		seq=((pSend->NR+shift+1) & pSend->SendSEQMSK);
		pBigFrame->messageid = (word)pSend->messageid;
		pBigFrame->sequence  = (word)seq;
		pBigFrame->serial    = (byte)pSend->serial++;                           

		if(pStat){
			pStat->serial=pBigFrame->serial;
		}
		
	}

	if(pSend->dwFlags & DPSEND_GUARANTEE){
		pFrame->flags |= RLY;
	}

	// count the number of bytes we have sent.
	Lock(&pSend->pSession->SessionStatLock);
	pSend->pSession->BytesSent+=pSend->BytesThisSend;
	BytesSent=pSend->pSession->BytesSent;
	RemoteBytesReceived=pSend->pSession->RemoteBytesReceived;
	tRemoteBytesReceived=pSend->pSession->tRemoteBytesReceived;
	if(pStat && pSend->pSession->bResetBias &&
	   ((--pSend->pSession->bResetBias) == 0))
	{
		bResetBias=TRUE;			
	}
	Unlock(&pSend->pSession->SessionStatLock);

	if(pStat){
		pStat->sequence=seq;
		pStat->messageid=pSend->messageid;
		pStat->tSent=tm;
		pStat->LocalBytesSent=BytesSent;
		pStat->RemoteBytesReceived=RemoteBytesReceived;
		pStat->tRemoteBytesReceived=tRemoteBytesReceived;
		pStat->bResetBias=bResetBias;
		if(pSend->dwFlags & DPSEND_GUARANTEED){
			InsertBefore(&pStat->StatList,&pSend->StatList);
		} else {
			Lock(&pSend->pSession->SessionStatLock);
			InsertBefore(&pStat->StatList,&pSend->pSession->DGStatList);
			Unlock(&pSend->pSession->SessionStatLock);
		}
	}

	
	#undef pBigFrame
}

#if 0
// release sends waiting for an id.
VOID UnWaitSends(PSESSION pSession, DWORD fReliable)
{
	BILINK *pBilink;
	PSEND pSendWalker;

	pBilink=pSession->SendQ.next;

	while(pBilink != &pSession->SendQ){
		pSendWalker=CONTAINING_RECORD(pBilink,SEND,SendQ);
		pBilink=pBilink->next;
		if(pSendWalker->SendState==WaitingForId){
			if(fReliable){
				if(pSendWalker->dwFlags & DPSEND_GUARANTEED){
					pSendWalker->SendState=Start;
				}
			} else {
				if(!(pSendWalker->dwFlags & DPSEND_GUARANTEED)){
					pSendWalker->SendState=Start;
				}
			}
		
		}
	}
	if(fReliable){
		pSession->nWaitingForMessageid=0;
	} else {
		pSession->nWaitingForDGMessageid=0;
	}
}
#endif

// Check if a datagram send can be started, if it can update teh
// Session and the Send.
BOOL StartDatagramSend(PSESSION pSession, PSEND pSend, UINT MsgIdMask)
{
	BOOL bFoundSend;
	UINT bit;
//	BOOL bTransition=FALSE;

	if((pSession->DGLastMsg-pSession->DGFirstMsg < pSession->MaxCDGSends)){
	
		bFoundSend=TRUE;

		if(pSend->SendState==WaitingForId){
			InterlockedDecrement(&pSession->nWaitingForDGMessageid);
		}
		
		bit=(pSession->DGLastMsg-pSession->DGFirstMsg)&MsgIdMask;
		ASSERT(bit<30);
		pSession->DGOutMsgMask |= 1<<bit;
		pSession->DGLastMsg =(pSession->DGLastMsg+1)&MsgIdMask;
		
		pSend->messageid  =pSession->DGLastMsg;
		pSend->FrameSize  =pSession->MaxPacketSize-MAX_SEND_HEADER;

		// Calculate number of frames required for this send.
		pSend->nFrames    =(pSend->MessageSize/pSend->FrameSize);
		if(pSend->FrameSize*pSend->nFrames < pSend->MessageSize || !pSend->nFrames){
			pSend->nFrames++;
		}
		pSend->NR=0;
		pSend->FrameDataLen=0;//BUGBUG: hack
		pSend->fSendSmall=pSession->fSendSmallDG;
		if(pSend->fSendSmall){
			pSend->SendSEQMSK = 0xFF;
		} else {
			pSend->SendSEQMSK = 0xFFFF;
		}
	} else {
#if 0
		if(pSession->fSendSmallDG && pSession->DGFirstMsg < 0xFF-MAX_SMALL_CSENDS) {
			// Ran out of IDs, Transition to Large headers.
			DPF(9,"OUT OF IDS, DATAGRAMS GOING TO LARGE FRAMES\n");
			pSession->MaxCDGSends   = MAX_LARGE_DG_CSENDS;
			pSession->DGWindowSize  = MAX_LARGE_WINDOW;
			pSession->fSendSmallDG  = FALSE;
			bTransition=TRUE;
		}
#endif
		bFoundSend=FALSE;
		
		if(pSend->SendState==Start){
			InterlockedIncrement(&pSession->nWaitingForDGMessageid);
			DPF(9,"StartDatagramSend: No Id's Avail: nWaitingForDGMessageid %x\n",pSession->nWaitingForDGMessageid);
			pSend->SendState=WaitingForId;
#if 0			
			if(bTransition){
				UnWaitSends(pSession,FALSE);
				SetEvent(pSession->pProtocol->m_hSendEvent);
			}
#endif			
		} else {
			DPF(9,"Couldn't start datagram send on pSend %x State %d pSession %x\n",pSend,pSend->SendState,pSession);
			if(pSend->SendState!=WaitingForId){
				ASSERT(0);
			}
		}

	}

	return bFoundSend;
}


BOOL StartReliableSend(PSESSION pSession, PSEND pSend, UINT MsgIdMask)
{
	BOOL bFoundSend;
	UINT bit;
//	BOOL bTransition=FALSE;

	ASSERT(pSend->dwFlags & DPSEND_GUARANTEED);

	if((pSession->LastMsg-pSession->FirstMsg & MsgIdMask) < pSession->MaxCSends){

		DPF(9,"StartReliableSend: FirstMsg: x%x LastMsg: x%x\n",pSession->FirstMsg, pSession->LastMsg);
	
		bFoundSend=TRUE;

		if(pSend->SendState==WaitingForId){
			InterlockedDecrement(&pSession->nWaitingForMessageid);
		}
		
		bit=(pSession->LastMsg-pSession->FirstMsg)&MsgIdMask;
		#ifdef DEBUG
		if(!(bit<pSession->MaxCSends)){
			DEBUG_BREAK();
		}
		#endif
		pSession->OutMsgMask |= 1<<bit;
		pSession->LastMsg =(pSession->LastMsg+1)&MsgIdMask;

		DPF(9,"StartReliableSend: pSend %x assigning id x%x\n",pSend,pSession->LastMsg);
		
		pSend->messageid  =pSession->LastMsg;
		pSend->FrameSize  =pSession->MaxPacketSize-MAX_SEND_HEADER;

		// Calculate number of frames required for this send.
		pSend->nFrames    =(pSend->MessageSize/pSend->FrameSize);
		if(pSend->FrameSize*pSend->nFrames < pSend->MessageSize || !pSend->nFrames){
			pSend->nFrames++;
		}
		pSend->NR=0;
		pSend->FrameDataLen=0;//BUGBUG: hack
		pSend->fSendSmall=pSession->fSendSmall;
		if(pSend->fSendSmall){
			pSend->SendSEQMSK = 0xFF;
		} else {
			pSend->SendSEQMSK = 0xFFFF;
		}

	} else {
#if 0	
		if (pSession->fSendSmall && pSession->FirstMsg < 0xFF-MAX_SMALL_CSENDS){
			// Ran out of IDs, Transition to Large headers - but only if we aren't going
			// to confuse the wrapping code.
			DPF(8,"OUT OF IDS, RELIABLE SENDS GOING TO LARGE FRAMES\n");
			pSession->MaxCSends		= MAX_LARGE_CSENDS;
			pSession->WindowSize    = MAX_LARGE_WINDOW;
			pSession->fSendSmall    = FALSE;
			bTransition = TRUE;
		}
#endif
		bFoundSend=FALSE;
		
		if(pSend->SendState==Start){
			bFoundSend=FALSE;
			// Reliable, waiting for id.
			InterlockedIncrement(&pSession->nWaitingForMessageid);
			pSend->SendState=WaitingForId;
			DPF(9,"StartReliableSend: No Id's Avail: nWaitingForMessageid %x\n",pSession->nWaitingForMessageid);
#if 0			
			if(bTransition){
				UnWaitSends(pSession,TRUE);
				SetEvent(pSession->pProtocol->m_hSendEvent);
			}
#endif			
		} else {
			bFoundSend=FALSE;
			DPF(9,"Couldn't start reliable send on pSend %x State %d pSession %x\n",pSend,pSend->SendState,pSession);
			if(pSend->SendState!=WaitingForId){
				ASSERT(0);
			}
		}
	}
	
	return bFoundSend;
}


BOOL CheckUserTimeOut(PSEND pSend)
{
	if(pSend->dwTimeOut){
		if((timeGetTime()-pSend->dwSendTime) > pSend->dwTimeOut){
			pSend->SendState=UserTimeOut;
			return TRUE;
		} 
	}	
	return FALSE;
}
/*=============================================================================

	GetNextMessageToSend
    
    Description:

	Scans the send queue for a message that is the current priority and
	is in the ready to send state or throttled state (we shouldn't even
	get here unless the throttle was removed.)  If we find such a message
	we return a pointer to the caller.

	Adds a reference to the Send and the Session.

    Parameters:     

		PPROTOCOOL pProtocol - pointer to the PROTOCOL object to send packets on.

    Return Values:
	
		NULL  - no message should be sent.
		PSEND - message to send.

-----------------------------------------------------------------------------*/

PSEND GetNextMessageToSend(PPROTOCOL pProtocol)
{
	PSEND    pSend;
	BILINK  *pBilink;
	UINT     CurrentSendPri;
	BOOL     bFoundSend; 
	PSESSION pSession;

	UINT     MsgIdMask;

	Lock(&pProtocol->m_SendQLock);

	DPF(9,"==>GetNextMessageToSend\n");

Top:

	bFoundSend = FALSE;
	pProtocol->m_bRescanQueue=FALSE;
	
	if(EMPTY_BILINK(&pProtocol->m_GSendQ)){
		Unlock(&pProtocol->m_SendQLock);
		DPF(9,"GetNextMessageToSend: called with nothing in queue, heading for the door.\n");
		goto exit;
	}

	pBilink        = pProtocol->m_GSendQ.next;
	pSend          = CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
	CurrentSendPri = pSend->Priority;

	while(pBilink != &pProtocol->m_GSendQ){

		pSession=pSend->pSession;
		ASSERT_SIGN(pSession, SESSION_SIGN);
		Lock(&pSession->SessionLock);

		if(pProtocol->m_bRescanQueue){
			DPF(9,"RESCAN of QUEUE FORCED IN GETNEXTMESSAGETOSEND\n");
			Unlock(&pSession->SessionLock);
			goto Top;
		}

		if(pSession->dwFlags & SESSION_UNTHROTTLED){
			// unthrottle happened, so rewind.
			DPF(9,"Unthrottling Session %x\n",pSession);
			pSession->dwFlags &= ~(SESSION_THROTTLED|SESSION_UNTHROTTLED);
		}

		Lock(&pSend->SendLock);
		
		switch(pSession->eState){

			case Open:

				if((pSend->dwFlags & DPSEND_GUARANTEE)?(pSession->fSendSmall):(pSession->fSendSmallDG)){
					MsgIdMask = 0xFF;
				} else {
					MsgIdMask = 0xFFFF;
				}

	
				if(!(pSend->dwFlags & ASEND_PROTOCOL) && (pSession->dwFlags & SESSION_THROTTLED)){
					// don't do sends on a throttled session, unless they are internal sends.
					break;
				}

				switch(pSend->SendState){

				
					case Start:
					case WaitingForId:

						DPF(9,"Found Send in State %d, try Going to Sending State\n",pSend->SendState);
						// Just starting, need an id.

						if(!(pSend->dwFlags & ASEND_PROTOCOL) && CheckUserTimeOut(pSend)){
							if(pSend->SendState==WaitingForId){
								if(pSend->dwFlags&DPSEND_GUARANTEED){
									InterlockedDecrement(&pSession->nWaitingForMessageid);
								} else {
									InterlockedDecrement(&pSession->nWaitingForDGMessageid);
								}
							}
							bFoundSend=TRUE;
							break;
						}
							
						if(pSend->dwFlags&ASEND_PROTOCOL){
						
							DPF(9,"System Send in Start State, Going to Sending State\n");
							bFoundSend=TRUE;
							pSend->SendState=Sending;
							break;
							
						} else if(!(pSend->dwFlags&DPSEND_GUARANTEED)) {        

							//check_datagram: 
							bFoundSend=StartDatagramSend(pSession,pSend, MsgIdMask);

						} else {

							// NOT DataGram, .: reliable...
							//check_reliable: 
							bFoundSend=StartReliableSend(pSession,pSend, MsgIdMask);
							#ifdef DEBUG
								if(bFoundSend){
									BILINK *pBiSendWalker=pSend->SendQ.prev;
									PSEND pSendWalker;
									while(pBiSendWalker != &pSession->SendQ){
										pSendWalker=CONTAINING_RECORD(pBiSendWalker,SEND,SendQ);
										pBiSendWalker=pBiSendWalker->prev;
										if((pSendWalker->SendState==Start || pSendWalker->SendState==WaitingForId)&& 
											pSendWalker->dwFlags&DPSEND_GUARANTEED && 
											!(pSendWalker->dwFlags&ASEND_PROTOCOL) && 
											pSendWalker->Priority >= pSend->Priority){
											DPF(0,"Send %x got id %x but Send %x still in state %x on Session %x\n",pSend,pSend->messageid,pSendWalker,pSendWalker->SendState,pSession);
											DEBUG_BREAK();
										}
									}
								}
							#endif
						}
						if(bFoundSend){
							if(pSession->dwFlags & SESSION_THROTTLED)
							{
								pSend->SendState=Throttled;
								bFoundSend=FALSE;
							} else {
								pSend->SendState=Sending;
							}	
						}
						break;


					case ReadyToSend:
					
						DPF(9,"Found Send in ReadyToSend State, going to Sending State\n");
						bFoundSend=TRUE;
						if(pSession->dwFlags & SESSION_THROTTLED)
						{
							pSend->SendState=Throttled;
							bFoundSend=FALSE;
						} else {
							pSend->SendState=Sending;
						}	
						break;

						
					case Throttled:
					
						ASSERT(!(pSession->dwFlags & SESSION_THROTTLED));
						DPF(9,"Found Send in Throttled State, unthrottling going to Sending State\n");
						bFoundSend=TRUE;
						pSend->SendState=Sending;
						if(pSession->dwFlags & SESSION_THROTTLED)
						{
							pSend->SendState=Throttled;
							bFoundSend=FALSE;
						} else {
							pSend->SendState=Sending;
						}	
						break;


					case TimedOut:
					
						DPF(9,"Found TimedOut Send.\n");
						TimeOutSession(pSession);
						bFoundSend=TRUE;
						break;


					case Cancelled:
					
						bFoundSend=TRUE;
						break;


					default:        
						ASSERT(pSend->SendState <= Done);
						break;
				} /* end switch(SendState) */
				break;

			default:
				switch(pSend->SendState){
					case Sending:
					case WaitingForAck:
					case Done:
						DPF(9,"GetNextMessageToSend: Session %x was in state %d ,pSend %x SendState %d, leaving...\n",pSession, pSession->eState, pSend, pSend->SendState);
						//bFoundSend=FALSE;
						break;
						
					default:
						DPF(9,"GetNextMessageToSend: Session %x was in state %d ,returning pSend %x SendState %d\n",pSession, pSession->eState, pSend, pSend->SendState);
						bFoundSend=TRUE;
						break;
				}
				break;
				
		} /* end switch pSession->eState */     
				
		if(bFoundSend){
			if(AddSendRef(pSend,1)){
				pSession->RefCount++;
			} else {
				bFoundSend=FALSE;
			}
		} 

		Unlock(&pSend->SendLock);
			
		Unlock(&pSession->SessionLock);

		if(bFoundSend){
			if(pSend->NS==0){
				pSend->tLastACK=timeGetTime();
			}	
			break;
		} 

		pBilink=pBilink->next;
		pSend=CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
		
	} /* end while (pBilink != &pProtocol->m_GSendQ) */

	Unlock(&pProtocol->m_SendQLock);
	
exit:
    if(bFoundSend){
    	DPF(9,"<==GetNextMessageToSend %x\n",pSend);
    	return pSend;
    } else {
    	DPF(9,"<==GetNextMessageToSend NULL\n");
    	return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=w32

#SYNCHRONIZE_BLOCK=1

TARGETNAME=protocol
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=..\..\..\dplay\dplay;\
		..\; \
		..\..\..\dplay\common;\
		..\..\..\misc; \
		..\..\..\dplobby\dplobby; \

#SYNCHRONIZE_DRAIN=1

C_DEFINES=$(C_DEFINES) -DWINVER=0x0400

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

C_DEFINES=$(C_DEFINES) -D_NO_COM -DUNICODE -D_UNICODE -DNEW_DPF -DSECURITY_WIN32


NTPROFILEINPUT=yes


SOURCES= \
		..\HANDLES.C     \
        ..\PROTOCOL.C    \
        ..\PSESSION.C    \
        ..\SEND.C        \
        ..\RECEIVE.C     \
        ..\STATS.C       \
        ..\BUFMGR.C      \
        ..\FRAMEBUF.C    \
        ..\SENDPOOL.C    \
        ..\BUFPOOL.C     \
        ..\RCVPOOL.C     \
        ..\STATPOOL.C    \
        ..\BILINK.C      \
		..\TIMER.C       \
        ..\MYDEBUG.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\sendpool.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    SENDPOOL.C

Abstract:

	Manages pool of send descriptors.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original

--*/

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"

//
// Send Descriptor Management.
//

PSEND 			 pSendDescPool=NULL;
UINT             nSendDescsAllocated=0;	// Number Allocated
UINT             nSendDescsInUse=0;		// Number currently in use
UINT             nMaxSendDescsInUse=0;  // Maximum number in use since last TICK.

CRITICAL_SECTION SendDescLock;

VOID InitSendDescs(VOID)
{
	InitializeCriticalSection(&SendDescLock);
}

VOID FiniSendDescs(VOID)
{
	PSEND pSend;
	
	ASSERT(nSendDescsInUse==0);
	
	while(pSendDescPool){
		pSend=pSendDescPool;
		ASSERT_SIGN(pSend, SEND_SIGN);
		pSendDescPool=pSendDescPool->pNext;
		CloseHandle(pSend->hEvent);
		DeleteCriticalSection(&pSend->SendLock);
		My_GlobalFree(pSend);
		nSendDescsAllocated--;
	}
	
	ASSERT(nSendDescsAllocated==0);
	
	DeleteCriticalSection(&SendDescLock);
}

PSEND GetSendDesc(VOID)
{
	PSEND pSend;

	Lock(&SendDescLock);
	
	if(!pSendDescPool){
	
		Unlock(&SendDescLock);
		pSend=(PSEND)My_GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(SEND));
		if(pSend){
			if(!(pSend->hEvent=CreateEventA(NULL, FALSE, FALSE, NULL))){
				My_GlobalFree(pSend);
				goto exit;
			}
			InitBilink(&pSend->StatList);
			InitializeCriticalSection(&pSend->SendLock);
		}
		Lock(&SendDescLock);
		if(pSend){
			SET_SIGN(pSend,SEND_SIGN);			
			nSendDescsAllocated++;
		}
	} else {
	
		pSend=pSendDescPool;
		ASSERT_SIGN(pSend, SEND_SIGN);
		pSendDescPool=pSendDescPool->pNext;
		
	}

	if(pSend){
		InitBilink(&pSend->TimeoutList);
		InitBilink(&pSend->m_GSendQ);
		InitBilink(&pSend->SendQ);
		nSendDescsInUse++;
		if( nSendDescsInUse > nMaxSendDescsInUse ){
			nMaxSendDescsInUse = nSendDescsInUse;
		}
	}

	ASSERT(nSendDescsAllocated >= nSendDescsInUse);

	Unlock(&SendDescLock);
	pSend->NACKMask=0;
	pSend->bCleaningUp=FALSE;

exit:	
	return pSend;
}

VOID ReleaseSendDesc(PSEND pSend)
{
	PSENDSTAT pStat;
	BILINK *pBilink;

	// Dump extra statistics.
	while(!EMPTY_BILINK(&pSend->StatList)){
		//BUGBUG: move stats to end.
		pBilink=pSend->StatList.next;
		pStat=CONTAINING_RECORD(pBilink, SENDSTAT, StatList);
		Delete(pBilink);
		ReleaseSendStat(pStat);
	}

	Lock(&SendDescLock);
	nSendDescsInUse--;
	ASSERT(!(nSendDescsInUse&0x80000000));
	pSend->pNext=pSendDescPool;
	pSendDescPool=pSend;
	Unlock(&SendDescLock);

}


#if 0
// let virtual memory handle this. - switched out.
LONG fInSendDescTick=0;

VOID SendDescTick(VOID)
{
	PSEND pSend;
#ifdef DEBUG
	LONG fLast; 
#endif
	// Adjusts Number of allocated buffers to 
	// highwater mark over the last ticks.
	// Call once per delta t (around a minute).
	DEBUG_BREAK(); //TRACE all paths.

	if(!InterlockedExchange(&fInSendDescTick, 1)){
	
		Lock(&SendDescLock);
		
		while((nSendDescsAllocated > nMaxSendDescsInUse) && pSendDescPool){
		
			pSend=pSendDescPool;
			ASSERT_SIGN(pSend,SEND_SIGN);
			pSendDescPool=pSendDescPool->pNext;
			
			Unlock(&SendDescLock);
			CloseHandle(pSend->hEvent);
			DeleteCriticalSection(&pSend->SendLock);
			My_GlobalFree(pSend);
			Lock(&SendDescLock);
			nSendDescsAllocated--;
			
		}
		nMaxSendDescsInUse=nSendDescsInUse;

		ASSERT(nMaxSendDescsInUse <= nSendDescsAllocated);
		
		Unlock(&SendDescLock);
#ifdef DEBUG
		fLast=
#endif
		InterlockedExchange(&fInSendDescTick, 0);
#ifdef DEBUG
		ASSERT(fLast==1);
#endif
	}	
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\serial\bilink.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.H

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/// BILINK.H

#ifndef _BILINK_

#define _BILINK_

#if !defined(offsetof)
	#define offsetof(type, field) ((int)(&((type *)0)->field))
#endif	

typedef struct BILINK {
    struct BILINK *next;
    struct BILINK *prev;
} BILINK;

/* XLATOFF */

#define EMPTY_BILINK(_pBilink) ((_pBilink)->next==(_pBilink))

#ifdef DEBUG
    #define ASSERT_EMPTY_BILINK(_b) ASSERT((_b)->next==(_b))
#else
    #define ASSERT_EMPTY_BILINK(_b)
#endif

// This only works for BILINKS that are the first item in a structure.
#define BilinkToList( _pBilink ) \
	(_pBilink)->prev->next=NULL;

#define InitBilink( _pBilink ) \
    (_pBilink)->prev=(_pBilink)->next=(_pBilink);

#ifdef DEBUG

int FindObject(
    BILINK *link,
    BILINK *list
    );
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    );

void InsertBefore(
     BILINK *in,
     BILINK *before
    );

void Delete(
     BILINK *p
);

/* XLATON */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\serial\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPSERIAL"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\statpool.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    STATPOOL.CPP

Abstract:

	Maintains pool of Stat structures.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/30/97  aarono  Original

--*/

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"


PSENDSTAT		 pSendStatPool=NULL;
UINT             nSendStatsAllocated=0;	// Number Allocated
UINT             nSendStatsInUse=0;		    // Number currently in use
UINT             nMaxSendStatsInUse=0;      // Maximum number in use since last TICK.

CRITICAL_SECTION SendStatLock;

VOID InitSendStats(VOID)
{
	InitializeCriticalSection(&SendStatLock);
}

VOID FiniSendStats(VOID)
{
	PSENDSTAT pSendStat;
	
	ASSERT(nSendStatsInUse==0);
	
	while(pSendStatPool){
		pSendStat=pSendStatPool;
		ASSERT_SIGN(pSendStat, SENDSTAT_SIGN);
		pSendStatPool=pSendStatPool->pNext;
		My_GlobalFree(pSendStat);
		nSendStatsAllocated--;
	}
	
	ASSERT(nSendStatsAllocated==0);
	
	DeleteCriticalSection(&SendStatLock);
}

PSENDSTAT GetSendStat(VOID)
{
	PSENDSTAT pSendStat;

	Lock(&SendStatLock);
	
	if(!pSendStatPool){
	
		Unlock(&SendStatLock);
		pSendStat=(PSENDSTAT)My_GlobalAlloc(GMEM_FIXED, sizeof(SENDSTAT));
		Lock(&SendStatLock);
		if(pSendStat){
			SET_SIGN(pSendStat,SENDSTAT_SIGN);			
			nSendStatsAllocated++;
		}
	} else {
		pSendStat=pSendStatPool;
		ASSERT_SIGN(pSendStat, SENDSTAT_SIGN);
		pSendStatPool=pSendStatPool->pNext;
		
	}

	if(pSendStat){
		nSendStatsInUse++;
		if( nSendStatsInUse > nMaxSendStatsInUse ){
			nMaxSendStatsInUse = nSendStatsInUse;
		}
	}

	ASSERT(nSendStatsAllocated >= nSendStatsInUse);

	Unlock(&SendStatLock);

	return pSendStat;
}

VOID ReleaseSendStat(PSENDSTAT pSendStat)
{
	Lock(&SendStatLock);
	nSendStatsInUse--;
	ASSERT(!(nSendStatsInUse&0x80000000));
	pSendStat->pNext=pSendStatPool;
	pSendStatPool=pSendStat;
	Unlock(&SendStatLock);

}

#if 0
// let virtual memory handle this.
LONG fInSendStatTick=0;

VOID SendStatTick(VOID)
{
	PSENDSTAT pSendStat;
#ifdef DEBUG
	LONG fLast; 
#endif
	// Adjusts Number of allocated buffers to 
	// highwater mark over the last ticks.
	// Call once per delta t (around a minute).
	DEBUG_BREAK(); //TRACE all paths.

	if(!InterlockedExchange(&fInSendStatTick, 1)){
	
		Lock(&SendStatLock);
		
		while((nSendStatsAllocated > nMaxSendStatsInUse) && pSendStatPool){
		
			pSendStat=pSendStatPool;
			ASSERT_SIGN(pSendStat,SENDSTAT_SIGN);
			pSendStatPool=pSendStatPool->pNext;
			
			Unlock(&SendStatLock);
			My_GlobalFree(pSendStat);
			Lock(&SendStatLock);
			nSendStatsAllocated--;
			
		}
		nMaxSendStatsInUse=nSendStatsInUse;

		ASSERT(nMaxSendStatsInUse <= nSendStatsAllocated);
		
		Unlock(&SendStatLock);
#ifdef DEBUG
		fLast=
#endif
		InterlockedExchange(&fInSendStatTick, 0);
#ifdef DEBUG
		ASSERT(fLast==1);
#endif
	}	
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\stats.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

	STATS.C

Abstract:

	Session Statistics routines

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   7/30/97 aarono  Original
   6/6/98  aarono  Turn on throttling and windowing

--*/

#include <windows.h>
#include "newdpf.h"
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "protocol.h"
#include "macros.h"
#include "command.h"

#define STARTING_LONG_LATENCY 			1  /*  1  ms (intentionally low so first sample fills)      */
#define STARTING_SHORT_LATENCY 		15000  /* 15 seconds (intentionally high so first sample fills) */
#define STARTING_AVERAGE_LATENCY 	 2000  /*  2 seconds (good start for internet) */
#define STARTING_AVERAGE_DEVIATION      0  

#define STARTING_MAXRETRY                16  /* Maximum number of retries */
#define STARTING_MINDROPTIME          15000  /* Minimum time to retry before dropping connection (ms) */
#define STARTING_MAXDROPTIME          60000  /* Maximum time to retry before dropping connection (ms) */

#define STARTING_BANDWIDTH          (28800/10) /* 28 kbps modem */

#define LATENCY_SHORT_BITS				4
#define LATENCY_LONG_BITS               7

#define STAT_LOCAL_LATENCY_SAMPLES 		2^(LATENCY_SHORT_BITS) /* 2^4 */
#define STAT_LONG_LATENCY_SAMPLES       2^(LATENCY_LONG_BITS)  /* 2^7 */

#define TARGET_CLOCK_OFFSET 		10000000


#define Fp(_x) ((_x)<<8)
#define unFp(_x)((_x)>>8)

// Latency Averages and deviation averages are stored as fixed point 24.8

VOID InitSessionStats(PSESSION pSession)
{
	pSession->ShortestLatency     = STARTING_SHORT_LATENCY;
	pSession->LongestLatency      = STARTING_LONG_LATENCY;
	
	pSession->FpAverageLatency      = 1000;
	pSession->FpLocalAverageLatency = 1000;

	pSession->FpLocalAvgDeviation   = 300;
	pSession->FpAvgDeviation        = 300;

	pSession->Bandwidth = 28800/10;
	pSession->HighestBandwidth=28800/10;
	
	pSession->MaxRetry    = STARTING_MAXRETRY;
	pSession->MinDropTime = STARTING_MINDROPTIME;
	pSession->MaxDropTime = STARTING_MAXDROPTIME;
}


// called with SESSIONLOCK.
VOID UpdateSessionStats(PSESSION pSession, PSENDSTAT pStat, PCMDINFO pCmdInfo, BOOL fBadDrop)
{
	DWORD tLatency;
	DWORD nBytesReceived;
	DWORD tDeviation;
	DWORD BytesLost=0;
	DWORD BackLog=0;

	DWORD fThrottleAdjusted=FALSE;

	DWORD tRemoteDelta; // change in time on remote from last received ACK until this was ACKed.
	
	DWORD tBiasedDelta; // a biased difference in local and remote clocks.
	INT   tDelta; // the unbiased difference (signed)
	static DWORD cBiasReset;

	
	// Get the statistics information we need.
	tLatency = pCmdInfo->tReceived-pStat->tSent;

	ASSERT((int)tLatency >= 0);
	if(!tLatency){
		DPF(8,"0ms observed latency, using 1ms\n");
		tLatency=1;
	}	

	Lock(&pSession->SessionStatLock);
	
		// Calculates the number of bytes received at remote since this send was done.
		pSession->RemoteBytesReceived = pCmdInfo->bytes;
		pSession->tRemoteBytesReceived = pCmdInfo->tRemoteACK;
		nBytesReceived = pSession->RemoteBytesReceived - pStat->RemoteBytesReceived;

		BytesLost = pStat->LocalBytesSent-(pSession->RemoteBytesReceived+pSession->BytesLost);

		if((int)BytesLost >= 0){
		
			pSession->BytesLost += BytesLost;

			// Note, Backlog may be as little as 1/2 this value.
			BackLog = pSession->BytesSent -( pSession->RemoteBytesReceived + pSession->BytesLost );

			if((int)BackLog < 0){
				DPF(8,"Hmmm, upside down backlog?\n");
				DPF(8,"pSession->BytesSent             %d\n",pSession->BytesSent);
				DPF(8,"pSession->RemoteBytesReceived   %d\n",pSession->RemoteBytesReceived); 
				DPF(8,"pSession->BytesLost             %d\n",pSession->BytesLost);
				DPF(8,"Calculated BackLog              %d\n",BackLog);
				BackLog=0;
			}
			
		} else if((int)BytesLost < 0){
			// Can be caused by out of order receives
			DPF(1,"Out of order remote receive lots of these may affect throttling...\n");
			DPF(8,"Hmmm, upside down byte counting?\n"); 
			DPF(8,"pStat->LocalBytesSent           %d\n",pStat->LocalBytesSent);
			DPF(8,"pSession->RemoteBytesReceived   %d\n",pSession->RemoteBytesReceived); 
			DPF(8,"pSession->BytesLost             %d\n",pSession->BytesLost);
			DPF(8,"Calculated Bytes Lost           %d\n",BytesLost);
			BytesLost=0;
			// fixup lost count.
			pSession->BytesLost=pSession->RemoteBytesReceived-pStat->LocalBytesSent;
		}

	Unlock(&pSession->SessionStatLock);

	if(pSession->MaxCSends==1){
	
		DWORD Bias;
		
		// 1st ACK, adjust windows to normal operation.
		pSession->MaxCSends     = MAX_SMALL_CSENDS;	 
		pSession->MaxCDGSends   = MAX_SMALL_DG_CSENDS;
		pSession->WindowSize	= MAX_SMALL_WINDOW;
		pSession->DGWindowSize  = MAX_SMALL_WINDOW;

		pSession->FpAverageLatency      = 2*tLatency; // start high to avoid overthrottle
		pSession->FpLocalAverageLatency = 2*tLatency;

		pSession->FpLocalAvgDeviation   = 1+tLatency/3;
		pSession->FpAvgDeviation        = 1+tLatency/3;



		Bias = pCmdInfo->tRemoteACK - pStat->tSent;

		if(Bias > TARGET_CLOCK_OFFSET){
			Bias = -1*(Bias-TARGET_CLOCK_OFFSET);
		} else {
			Bias = TARGET_CLOCK_OFFSET - Bias;
		}

		pSession->RemAvgACKBias = Bias;
		
		pSession->RemAvgACKDelta = (pCmdInfo->tRemoteACK - pStat->tSent)+pSession->RemAvgACKBias;

		ASSERT(pSession->RemAvgACKDelta == TARGET_CLOCK_OFFSET);
	}

	//
	// Calculate shift in outbound latency.
	//
	tBiasedDelta = (pCmdInfo->tRemoteACK - pStat->tSent)+pSession->RemAvgACKBias;
	tDelta = tBiasedDelta-TARGET_CLOCK_OFFSET;

	if(tDelta < 0 || pStat->bResetBias || tDelta > (int)tLatency){
		DWORD Bias;

		// Either clock drift or lower server load shows latency down, so reset baseline.
		
		Bias = pCmdInfo->tRemoteACK - pStat->tSent;

		if(Bias > TARGET_CLOCK_OFFSET){
			Bias = -1*(Bias-TARGET_CLOCK_OFFSET);
		} else {
			Bias = TARGET_CLOCK_OFFSET - Bias;
		}
		cBiasReset++;

		pSession->RemAvgACKBias = Bias;
		tBiasedDelta = (pCmdInfo->tRemoteACK - pStat->tSent)+pSession->RemAvgACKBias;
		tDelta = tBiasedDelta-TARGET_CLOCK_OFFSET;
	}

	pSession->RemAvgACKDelta -= pSession->RemAvgACKDelta >> 7; // -1/128th
	pSession->RemAvgACKDelta += tBiasedDelta >> 7;			   // +1/128th of new value 

	// keep the residue so we don't creep down due to rounding error.
	pSession->RemAvgACKDeltaResidue += tBiasedDelta & 0x7f;
	if(pSession->RemAvgACKDeltaResidue>>7){
		pSession->RemAvgACKDelta += pSession->RemAvgACKDeltaResidue>>7;
		pSession->RemAvgACKDeltaResidue &= 0x7f;
	}


	DPF(8,"tRemoteACK %d tSent %d Bias %d tBiasedDelta %d tDelta %d\n", pCmdInfo->tRemoteACK, pStat->tSent, 
		pSession->RemAvgACKBias, tBiasedDelta, tDelta);
	
	
	//
	// Update latency statistics
	//
	
	ASSERT(!(nBytesReceived & 0x80000000)); // received in interval +ve
	ASSERT(!(tLatency & 0x80000000));       // latency is +ve

	if(tLatency < pSession->ShortestLatency){
		pSession->ShortestLatency=tLatency;
		DPF(8,"Shortest Latency %d ms\n",tLatency);
	}

	if(tLatency > pSession->LongestLatency){
		pSession->LongestLatency=tLatency;
		DPF(8,"Longest Latency %d ms\n", tLatency);
	}

	pSession->LastLatency=tLatency;

	// Throw out 1/16 of local latency and add in the new statistic.
	// Note we only use local latency for retry calculations.

	if(pSession->FpLocalAverageLatency){
		if(Fp(tLatency) > pSession->FpAverageLatency){
			pSession->FpLocalAverageLatency -= (pSession->FpLocalAverageLatency >> LATENCY_SHORT_BITS);
			pSession->FpLocalAverageLatency += (tLatency << (8-LATENCY_SHORT_BITS));
		} else {
			// Ratched down when we get a latency that is below average, so we can better
			// detect backlog due to latency.
			pSession->FpLocalAverageLatency = Fp(tLatency);
		}
	} else {
		// this only happens once at startup.
		pSession->FpLocalAverageLatency = Fp(tLatency);
		pSession->FpAverageLatency = Fp(tLatency);
	}

	if(Fp(tLatency) > pSession->FpAverageLatency){

		// Thow out 1/128 of average latency and add in the new statistic.
		pSession->FpAverageLatency -= (pSession->FpAverageLatency >> LATENCY_LONG_BITS);
		pSession->FpAverageLatency += (tLatency << (8-LATENCY_LONG_BITS));

	} else {
		// Ratched down when we get a latency that is below average, so we can better
		// detect backlog due to latency.
		pSession->FpAverageLatency = Fp(tLatency);
	}
	
	tDeviation=unFp(pSession->FpLocalAverageLatency)-tLatency;
	if((int)tDeviation < 0){
		tDeviation = 0-tDeviation;
	}

	pSession->FpLocalAvgDeviation -= (pSession->FpLocalAvgDeviation >> LATENCY_SHORT_BITS);
	pSession->FpLocalAvgDeviation += (tDeviation << (8-LATENCY_SHORT_BITS));

	pSession->FpAvgDeviation -= (pSession->FpAvgDeviation >> LATENCY_LONG_BITS);
	pSession->FpAvgDeviation += (tDeviation << (8-LATENCY_LONG_BITS));


	DPF(8,"Got ACK, tLat: %d Avg: %d.%d Dev:  %d AvgDev: %d.%d \n",
			tLatency, pSession->FpLocalAverageLatency >> 8, ((pSession->FpLocalAverageLatency&0xFF)*100)/256,
			tDeviation, pSession->FpLocalAvgDeviation >> 8, ((pSession->FpLocalAvgDeviation&0xFF)*100)/256);


	//
	// Do Bandwidth calculations
	//
	
   	tRemoteDelta= pCmdInfo->tRemoteACK - pStat->tRemoteBytesReceived;
   	if(!tRemoteDelta){
   		tRemoteDelta=1;
   	}

	if(pStat->tRemoteBytesReceived){
		pSession->Bandwidth = (1000*nBytesReceived)/(tRemoteDelta);
		// could adjust throttle here if Bandwidth is higher, but this
		// might pimp high speed links. (BUGBUG:).
	} else {
		// backup calculation, not as good.  Only used early in the link
		// before we have received an ACK from the remote prior to issuing
		// a send.
		pSession->Bandwidth = (2000*nBytesReceived)/tLatency;	// 2000, not 1000 since tLatency is round trip.
	}	
	if(pSession->Bandwidth > pSession->HighestBandwidth){
		pSession->HighestBandwidth = pSession->Bandwidth;
	}


	DPF(8,"tRemoteDelta %d Remote bytes Received %d\n",tRemoteDelta,nBytesReceived);

	// Adjust sending...
	
	if ( BackLog && pSession->Bandwidth)
	{

		DWORD tAvgLat;
		DWORD tBackLog;
		DWORD ExcessBackLog; // amount of backlog (bytes) we need to clear before hitting avg latency again.
		DWORD tLatCheck;
		DWORD AvgLat133; // 133% of local average latency (tolerance for slow links)
		DWORD AvgLat200; // 200% of local average latency (tolerance for fast links)


		if(pSession->fFastLink){
			tAvgLat=unFp(pSession->FpAverageLatency);
			tLatCheck = (tAvgLat*3)/2;
			AvgLat133 = max(100,3*unFp(pSession->FpAvgDeviation)+(unFp(pSession->FpAverageLatency)*4)/3); // don't throttle <100ms lat
			AvgLat200 = max(100,3*unFp(pSession->FpAvgDeviation)+unFp(pSession->FpAverageLatency)*2);
		} else {
			tAvgLat=unFp(pSession->FpLocalAverageLatency);
			tLatCheck = (tAvgLat*3)/2;
			AvgLat133 = max(100,3*unFp(pSession->FpLocalAvgDeviation)+(unFp(pSession->FpLocalAverageLatency)*4)/3); // don't throttle <100ms lat
			AvgLat200 = max(100,3*unFp(pSession->FpLocalAvgDeviation)+unFp(pSession->FpLocalAverageLatency)*2);
		}
		
		if(tLatCheck < AvgLat133){
			tLatCheck = AvgLat133; 
		}

		if(tLatency > tLatCheck){
			// check link speed
			if(pSession->fFastLink){
				if(pSession->Bandwidth <= 10000){
					pSession->fFastLink=FALSE;
				}
			} else {
				if(pSession->Bandwidth >= 25000){
					pSession->fFastLink=TRUE;
				}
			}
		}

		if(pSession->fFastLink && tLatCheck < AvgLat200){
			tLatCheck=AvgLat200;
		}

		DPF(8,"tLat %d, tLatCheck %d, tDelta %d, tLat/3 %d\n",tLatency,tLatCheck,tDelta,tLatency/3); 
		DPF(8,"pSession->ShortestLatency %d, Shortest+MaxPacketTime %d\n",pSession->ShortestLatency,
			pSession->ShortestLatency+(pSession->MaxPacketSize*1000)/pSession->Bandwidth);

		
		if((tLatency > tLatCheck && tDelta > (int)(tLatency/3)) ||
		    ((!pSession->fFastLink)&&
		     (tLatency > pSession->ShortestLatency+((pSession->MaxPacketSize*2000)/pSession->Bandwidth))
		    )
		  )
		{
				
			#ifdef DEBUG
			if(pSession->SendRateThrottle){
				DPF(8,"BackLog %d, SendRate %d BackLog ms %d, tLatency %d tAvgLat %d Used Bandwidth %d tBacklog %d \n",
						BackLog,
						pSession->SendRateThrottle, 
						(BackLog*1000 / pSession->SendRateThrottle),
						tLatency, 
						tAvgLat, 
						pSession->Bandwidth,
						((BackLog*1000) / pSession->Bandwidth)
						);
			}	
			#endif

			tBackLog = (BackLog * 1000)/pSession->Bandwidth;
			
			if(tBackLog > 4*tLatency){
				DPF(8,"1: tBackLog %d was >> tLatency %d, using 4*tLatency instead\n",tBackLog,tLatency);
				tBackLog=4*tLatency; //never wait more than 4 latency periods
			}
			if(tBackLog > 8000){
				DPF(8,"Disalowing backlog > 8 seconds, using 8 instead\n");
				tBackLog=8000;
			}

			// if the backlog is greater than the bandwidth*latency, then we need to slow down our sending.
			// don't slow down due to backlog until we are over 100ms on way latency (200 round trip)
		
			if((tBackLog > 200) && (tBackLog > tAvgLat)){
			
				BOOL fWait=TRUE;

				// at max we cut send rate in 1/2.

				if(pSession->SendRateThrottle/2 > pSession->Bandwidth){
					DPF(8,"Asked for too aggresive throttle adjust %d, going from %d to %d\n",pSession->Bandwidth,pSession->SendRateThrottle,pSession->SendRateThrottle/2);
					pSession->SendRateThrottle /= 2;
					// Recheck if we are really backlogged at the new rate
					tBackLog = (BackLog * 1000)/pSession->SendRateThrottle;
					if(tBackLog > tLatency){
						DPF(8,"2: tBackLog %d was > tLatency %d, using tLatency instead\n",tBackLog,tLatency);
						tBackLog=tLatency;// never wait more than last latency period
					}
				} else {
					// set new throttle rate and current observed bandwidth (+5% to avoid overthrottle)
					pSession->SendRateThrottle=pSession->Bandwidth+pSession->Bandwidth/16;
				}

				// don't adjust for a while.
				pSession->bhitThrottle=FALSE;
				pSession->tLastThrottleAdjust = pCmdInfo->tReceived;

				if(fWait && (tBackLog > tAvgLat)){
				
					ExcessBackLog = ((tBackLog-tAvgLat)*pSession->Bandwidth)/1000;
					
					DPF(8,"Throttling back due to BACKLOG, excess = %d\n",ExcessBackLog);

					#ifdef DEBUG
					if(tBackLog-tAvgLat > 30000){
						DPF(5,"WARNING: BACKLOG THROTTLE %d ms seems kinda large\n",tBackLog-tAvgLat);
					}
					#endif

					// wait until backlog is down to avg latency before sending again
					Lock(&pSession->SessionStatLock);
					pSession->bResetBias = 2; // could be in the middle of a send, so count down from 2.
					Unlock(&pSession->SessionStatLock);
					UpdateSendTime(pSession,ExcessBackLog,timeGetTime(),TRUE);
				} else {
					DPF(8,"Not throttling due to BACKLOG because of smaller adjustment\n");
				}
				
			} else {
				DPF(8,"NOT Throttling back due to BACKLOG\n");
				
			}
		}		

	} else if(tDelta > (int)tLatency) {
		// tDelta is bogus due to clock drift, force throttle so we can correct.
		Lock(&pSession->SessionStatLock);
		pSession->bResetBias=2;
		Unlock(&pSession->SessionStatLock);
		pSession->tNextSend=timeGetTime()+2*tLatency;
		DPF(8,"tDelta %d > tLatency %d, need to correct for clock drift, time %d set next send time to %d\n", tDelta, tLatency,timeGetTime(),pSession->tNextSend);
	}	



	//
	// Adjust Throttle if not already adjusted.
	//
	
	if((pSession->ThrottleState==Begin) || 
	   (pCmdInfo->tReceived-pSession->tLastThrottleAdjust) > (1+1*pSession->fFastLink)*unFp(pSession->FpLocalAverageLatency) )
	{
		if(!fThrottleAdjusted){
			DPF(8,"Current Send Rate %d\n", pSession->SendRateThrottle);
			if(!BytesLost && pSession->bhitThrottle){
				pSession->bhitThrottle=FALSE;
				pSession->tLastThrottleAdjust = pCmdInfo->tReceived;
				// Good Send, push up send rate if we hit throttle.
				switch(pSession->ThrottleState){
					case Begin:
						pSession->SendRateThrottle = (pSession->SendRateThrottle*(100+START_GROWTH_RATE))/100;
						pSession->GrowCount++;
						pSession->ShrinkCount=0;
						break;
						
					case MetaStable:
						pSession->SendRateThrottle = (pSession->SendRateThrottle*(100+METASTABLE_GROWTH_RATE))/100;
						pSession->GrowCount++;
						pSession->ShrinkCount=0;
						break;
						
					case Stable:
						pSession->SendRateThrottle = (pSession->SendRateThrottle*(100+STABLE_GROWTH_RATE))/100;
						pSession->GrowCount++;
						pSession->ShrinkCount=0;
						if(pSession->GrowCount > (UINT)(20+60*pSession->fFastLink)){
							pSession->ThrottleState = MetaStable;
							pSession->GrowCount=0;
						}
						break;
					default:	
						DPF(0,"Session in wierd ThrottleState %d\n",pSession->ThrottleState);
						break;
				}	
				DPF(8,"Successful Send Adjusted Throttle, SendRate %d\n",pSession->SendRateThrottle);
			} else if(BytesLost){
				// Figure out how much we dropped
				if(fBadDrop || (BytesLost > pSession->pProtocol->m_dwSPMaxFrame)){
					// Very bad send, back off
					pSession->tLastThrottleAdjust = pCmdInfo->tReceived;
					switch(pSession->ThrottleState){
						case Begin:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-START_ADJUST_LARGE_ERR))/100;
							pSession->GrowCount=0;
							pSession->ShrinkCount++;
							break;
						case MetaStable:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-METASTABLE_ADJUST_LARGE_ERR))/100;
							pSession->GrowCount=0;
							pSession->ShrinkCount++;
							break;
						case Stable:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-STABLE_ADJUST_LARGE_ERR))/100;
							pSession->ShrinkCount++;
							if(pSession->ShrinkCount > 1){
								pSession->ShrinkCount=0;
								pSession->GrowCount=0;
								pSession->ThrottleState=MetaStable;
							}
							break;
						default:
							DPF(0,"Session in wierd ThrottleState %d\n",pSession->ThrottleState);
							break;
					}	
					DPF(8,"VERY BAD SEND Adjusted Throttle, SendRate %d\n",pSession->SendRateThrottle);
				} else {
					// Bad send, back off a bit
					pSession->tLastThrottleAdjust = pCmdInfo->tReceived;
					switch(pSession->ThrottleState){
						case Begin:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-START_ADJUST_SMALL_ERR))/100;
							pSession->GrowCount=0;
							pSession->ShrinkCount=0;
							pSession->ThrottleState = MetaStable;
							break;
						case MetaStable:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-METASTABLE_ADJUST_SMALL_ERR))/100;
							pSession->ShrinkCount++;
							pSession->GrowCount=0;
							break;
						case Stable:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-STABLE_ADJUST_SMALL_ERR))/100;
							pSession->ShrinkCount++;
							pSession->GrowCount=0;
							if(pSession->ShrinkCount > 2){
								pSession->ShrinkCount=0;
								pSession->ThrottleState = MetaStable;
							}	
							break;
						default:
							DPF(0,"Session in wierd ThrottleState %d\n",pSession->ThrottleState);
							break;
					}
					DPF(8,"BAD SEND Adjusted Throttle, SendRate %d\n",pSession->SendRateThrottle);
				} /* if (BadDrop... ) */
				
			} /* if (BytesLost ...) */
			
		}/*if (ThrottleAdjusted) */

	}

	if(!BytesLost && pSession->Bandwidth && pSession->SendRateThrottle < pSession->Bandwidth){
		DPF(8,"Avoid goofyness, throttle was %d, setting to observed bandwidth %d\n",pSession->SendRateThrottle,pSession->Bandwidth);
		pSession->SendRateThrottle=pSession->Bandwidth;
	}
	if(pSession->SendRateThrottle < 100){
		DPF(8,"WARNING: SendRateThrottle %d below 100, keeping at 100 to avoid starvation\n",pSession->SendRateThrottle);
		pSession->SendRateThrottle=100;
	}

#ifdef DEBUG
	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));

	   	InWS.stat_ThrottleRate = pSession->SendRateThrottle;
		InWS.stat_BytesSent	   = pSession->BytesSent;
		InWS.stat_BackLog      = BackLog;      
	 	InWS.stat_BytesLost    = pSession->BytesLost;
	 	//InWS.stat_RemBytesReceived;
		InWS.stat_Latency = tLatency;
		InWS.stat_MinLatency=pSession->ShortestLatency;
		InWS.stat_AvgLatency=unFp(pSession->FpLocalAverageLatency);
		InWS.stat_AvgDevLatency=unFp(pSession->FpLocalAvgDeviation);
		//InWS.stat_USER1=
		//InWS.stat_USER2=
		//InWS.stat_USER3=
		InWS.stat_USER5 = tDelta;
		InWS.stat_USER6 = cBiasReset;
	
		DbgWriteStats(&InWS);
	}
#endif
	
	DPF(8,"Bandwidth %d, Highest %d\n",pSession->Bandwidth, pSession->HighestBandwidth);
	
}

// Called with SessionLock and SendLock
// Statistics are stored on the send in send order on a BILINK.
// most recent sends are at the end of the list.  We scan from
// the end of the list to the beginning until we find the SENDSTAT
// that records the sequence and serial we got ACKED.  We then 
// update our statistics and throw out all SENDSTATs
// before this entry.
VOID UpdateSessionSendStats(PSESSION pSession, PSEND pSend, PCMDINFO pCmdInfo, BOOL fBadDrop)
{
	PSENDSTAT pStatWalker,pStat=NULL;
	BILINK    *pStatBilink;

	pSend->tLastACK=pCmdInfo->tReceived;
	pSend->RetryCount=0;
	// Find the last STAT for this ACK.
	pStatBilink=pSend->StatList.prev;

	while(pStatBilink != &pSend->StatList){
		pStatWalker=CONTAINING_RECORD(pStatBilink, SENDSTAT, StatList);
		if(pStatWalker->serial==pCmdInfo->serial &&
			pStatWalker->sequence==pCmdInfo->sequence)
		{
			ASSERT(pStatWalker->messageid==pSend->messageid);
			ASSERT(pSend->messageid==pCmdInfo->messageid);
			pStat=pStatWalker;
			break;
		}
		pStatBilink=pStatBilink->prev;
	}

	if(pStat){
		UpdateSessionStats(pSession,pStat,pCmdInfo,fBadDrop);

		// Unlink All Previous SENDSTATS;
		pStat->StatList.next->prev=&pSend->StatList;
		pSend->StatList.next=pStat->StatList.next;

		// Put the SENDSTATS back in the pool.
		while(pStatBilink != &pSend->StatList){
			pStatWalker=CONTAINING_RECORD(pStatBilink, SENDSTAT, StatList);
			pStatBilink=pStatBilink->prev;
			ReleaseSendStat(pStatWalker);
		}

	}	

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\protocol\timer.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    TIMER.C

Abstract:

	Handle adjusting timer resolution for throttling and do thread pool

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   6/04/98 aarono  Original

--*/

#include <windows.h>
#include "newdpf.h"
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"
#include "mytimer.h"


#define DEFAULT_TIME_RESOLUTION 20	/* ms */
#define MIN_TIMER_THREADS	1
#define MAX_TIMER_THREADS 5


VOID QueueTimeout(PMYTIMER pTimer);
DWORD WINAPI TimerWorkerThread(LPVOID foo);


// Timer Resolution adjustments;
DWORD dwOldPeriod=DEFAULT_TIME_RESOLUTION; 
DWORD dwCurrentPeriod=DEFAULT_TIME_RESOLUTION;
DWORD dwPeriodInUse=DEFAULT_TIME_RESOLUTION;


BILINK MyTimerList={&MyTimerList, &MyTimerList};
CRITICAL_SECTION MyTimerListLock;

LPFPOOL pTimerPool=NULL;
DWORD uWorkaroundTimerID;

DWORD twInitCount=0;	//number of times init called, only inits on 0->1, deinit on 1->0

DWORD Unique=0;


CRITICAL_SECTION ThreadListLock;		// locks ALL this stuff.

BILINK ThreadList={&ThreadList,&ThreadList};	// ThreadPool grabs work from here.

DWORD nThreads=0;		// number of running threads.
DWORD ActiveReq=0;		// number of requests being processed.
DWORD PeakReqs=0;
DWORD bShutDown=FALSE;
DWORD bAlreadyCleanedUp=FALSE;
DWORD KillCount=0;
DWORD ExtraSignals=0;

HANDLE hWorkToDoSem;
HANDLE hShutDownPeriodicTimer;

DWORD_PTR uAdjustResTimer=0;
DWORD AdjustResUnique=0;

DWORD_PTR uAdjustThreadsTimer=0;
DWORD AdjustThreadsUnique=0;

// Sometimes scheduled retry timers don't run.  This runs every 10 seconds to catch
// timers that should have been expired.
void CALLBACK PeriodicTimer (UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2)
{
	DWORD  time;
	PMYTIMER  pTimerWalker;
	BILINK *pBilink;
	DWORD dwReleaseCount=0;
	DWORD slowcount=0;

	if(bShutDown){
		if(!InterlockedExchange(&bAlreadyCleanedUp,1)){
			while(nThreads && slowcount < (60000/50)){	// don't wait more than 60 seconds.
				slowcount++;
				Sleep(50);
			}
			if(!nThreads){ // better to leak than to crash.
				DeleteCriticalSection(&MyTimerListLock);
				DeleteCriticalSection(&ThreadListLock);
			}	
			timeKillEvent(uID);
			ASSERT(hShutDownPeriodicTimer);
			SetEvent(hShutDownPeriodicTimer);
		}	
		return;
	}

	time=timeGetTime()+(dwCurrentPeriod/2);
		
	Lock(&MyTimerListLock);
	Lock(&ThreadListLock);

	pBilink=MyTimerList.next;

	while(pBilink!=&MyTimerList){
	
		pTimerWalker=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
		pBilink=pBilink->next;

		if(((INT)(time-pTimerWalker->TimeOut) > 0)){
			Delete(&pTimerWalker->Bilink);
			InsertBefore(&pTimerWalker->Bilink, &ThreadList);
			pTimerWalker->TimerState=QueuedForThread;
			dwReleaseCount++;
		} else {
			break;
		}

	}

	ActiveReq += dwReleaseCount;
	if(ActiveReq > PeakReqs){
		PeakReqs=ActiveReq;
	}
	
	ReleaseSemaphore(hWorkToDoSem,dwReleaseCount,NULL);

	Unlock(&ThreadListLock);
	Unlock(&MyTimerListLock);

}

#define min(a,b)            (((a) < (b)) ? (a) : (b))

VOID CALLBACK AdjustTimerResolution(UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2)
{
	DWORD dwWantPeriod;

	dwWantPeriod=min(dwCurrentPeriod,dwOldPeriod);
	dwOldPeriod=dwCurrentPeriod;
	dwCurrentPeriod=DEFAULT_TIME_RESOLUTION;
	
	if(dwPeriodInUse != dwWantPeriod){
		dwPeriodInUse=dwWantPeriod;
		timeKillEvent(uWorkaroundTimerID);
		uWorkaroundTimerID=timeSetEvent(dwPeriodInUse, dwPeriodInUse, PeriodicTimer, 0, TIME_PERIODIC); 
	}
	uAdjustResTimer=SetMyTimer(1000,500,AdjustTimerResolution,0,&AdjustResUnique);
}

VOID CALLBACK AdjustThreads(UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2)
{
	Lock(&ThreadListLock);
	if((PeakReqs < nThreads) && nThreads){
		KillCount=nThreads-PeakReqs;
		ReleaseSemaphore(hWorkToDoSem, KillCount, NULL);
	}
	PeakReqs=0;
	Unlock(&ThreadListLock);
	
	uAdjustThreadsTimer=SetMyTimer(60000,500,AdjustThreads,0,&AdjustThreadsUnique);
}

VOID SetTimerResolution(UINT msResolution)
{

	if(!msResolution || msResolution >= 20){
		return;
	}

	if(msResolution < dwCurrentPeriod){
		dwCurrentPeriod=msResolution;
	}
	
}

DWORD_PTR SetMyTimer(DWORD dwTimeOut, DWORD TimerRes, MYTIMERCALLBACK TimerCallBack, DWORD_PTR UserContext, PUINT pUnique)
{

	BILINK *pBilink;
	PMYTIMER pMyTimerWalker,pTimer;
	DWORD time;
	BOOL bInserted=FALSE;

	pTimer=pTimerPool->Get(pTimerPool);
	
	if(!pTimer){
		*pUnique=0;
		return 0;
	}

	pTimer->CallBack=TimerCallBack;
	pTimer->Context=UserContext;

	SetTimerResolution(TimerRes);
	
	Lock(&MyTimerListLock);
	
		++Unique;
		if(Unique==0){
			++Unique;
		}
		*pUnique=Unique;

		pTimer->Unique=Unique;
	
		time=timeGetTime();
		pTimer->TimeOut=time+dwTimeOut;
		pTimer->TimerState=WaitingForTimeout;
	

		// Insert this guy in the list by timeout time.
		pBilink=MyTimerList.prev;
		while(pBilink != &MyTimerList){
			pMyTimerWalker=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
			pBilink=pBilink->prev;
			
			if((int)(pTimer->TimeOut-pMyTimerWalker->TimeOut) > 0 ){
				InsertAfter(&pTimer->Bilink, &pMyTimerWalker->Bilink);
				bInserted=TRUE;
				break;
			}
		}

		if(!bInserted){
			InsertAfter(&pTimer->Bilink, &MyTimerList);
		}
	
	Unlock(&MyTimerListLock);

	return (DWORD_PTR)pTimer;
}


HRESULT CancelMyTimer(DWORD_PTR dwTimer, DWORD Unique)
{
	PMYTIMER pTimer=(PMYTIMER)dwTimer;
	HRESULT hr=DPERR_GENERIC;
	
	Lock(&MyTimerListLock);
	Lock(&ThreadListLock);

	if(pTimer->Unique == Unique){
		switch(pTimer->TimerState){
			case WaitingForTimeout:
				Delete(&pTimer->Bilink);
				pTimer->TimerState=End;
				pTimer->Unique=0;
				pTimerPool->Release(pTimerPool, pTimer);
				hr=DP_OK;
				break;

			case QueuedForThread:
				Delete(&pTimer->Bilink);
				pTimer->TimerState=End;
				pTimer->Unique=0;
				pTimerPool->Release(pTimerPool, pTimer);
				if(ActiveReq)ActiveReq--;
				ExtraSignals++;
				hr=DP_OK;
				break;

			default:
				break;
		}
	}

	Unlock(&ThreadListLock);
	Unlock(&MyTimerListLock);
	return hr;
}

HRESULT InitTimerWorkaround()
{
	DWORD dwJunk;
	HANDLE hWorker=NULL;

	if(twInitCount++){//DPLAY LOCK HELD DURING CALL
		return DP_OK;
	}
	
    pTimerPool=NULL;
    nThreads=0;		// number of running threads.
    ActiveReq=0;		// number of requests being processed.
    PeakReqs=0;
    bShutDown=FALSE;
    KillCount=0;
	ExtraSignals=0;
	bAlreadyCleanedUp=FALSE;
	hWorkToDoSem=0;
	hShutDownPeriodicTimer=0;
	uAdjustResTimer=0;
	uAdjustThreadsTimer=0;
	uWorkaroundTimerID=0;

	hWorkToDoSem=CreateSemaphoreA(NULL,0,65535,NULL);
	hShutDownPeriodicTimer=CreateEventA(NULL,FALSE,FALSE,NULL);

	InitializeCriticalSection(&MyTimerListLock);
	InitializeCriticalSection(&ThreadListLock);

	pTimerPool=FPM_Init(sizeof(MYTIMER),NULL,NULL,NULL);
	
	
	if(!hWorkToDoSem || !pTimerPool || !hShutDownPeriodicTimer){
		FiniTimerWorkaround();
		return DPERR_OUTOFMEMORY;
	}

	uWorkaroundTimerID=timeSetEvent(DEFAULT_TIME_RESOLUTION, DEFAULT_TIME_RESOLUTION, PeriodicTimer, 0, TIME_PERIODIC); 

	if(!uWorkaroundTimerID){
		FiniTimerWorkaround();
		return DPERR_OUTOFMEMORY;
	}

	nThreads=1;
	hWorker=CreateThread(NULL,4096, TimerWorkerThread, NULL, 0, &dwJunk);
	if(!hWorker){
		nThreads=0;
		FiniTimerWorkaround();
		return DPERR_OUTOFMEMORY;
	}
	CloseHandle(hWorker);

	uAdjustResTimer=SetMyTimer(1000,500,AdjustTimerResolution,0,&AdjustResUnique);
	uAdjustThreadsTimer=SetMyTimer(60000,500,AdjustThreads,0,&AdjustThreadsUnique);
	
	
	return DP_OK;

}

VOID FiniTimerWorkaround()
{
	UINT slowcount=0;
	BILINK *pBilink;
	PMYTIMER pTimer;

	if(--twInitCount){ //DPLAY LOCK HELD DURING CALL
		return;
	}

	if(uAdjustResTimer){
		CancelMyTimer(uAdjustResTimer, AdjustResUnique);
	}
	if(uAdjustThreadsTimer){
		CancelMyTimer(uAdjustThreadsTimer, AdjustThreadsUnique);
	}	
	//ASSERT_EMPTY_BILINK(&MyTimerList);
	//ASSERT_EMPTY_BILINK(&ThreadList);
	bShutDown=TRUE;
	ReleaseSemaphore(hWorkToDoSem,10000,NULL);
	while(nThreads && slowcount < (60000/50)){	// don't wait more than 60 seconds.
		slowcount++;
		Sleep(50);
	}
	
	if(uWorkaroundTimerID){
		if(hShutDownPeriodicTimer){
			WaitForSingleObject(hShutDownPeriodicTimer,INFINITE);
		}	
	} else {
		DeleteCriticalSection(&MyTimerListLock);
		DeleteCriticalSection(&ThreadListLock);
	}	

	if(hShutDownPeriodicTimer){
		CloseHandle(hShutDownPeriodicTimer);
	}

	CloseHandle(hWorkToDoSem);

	while(!EMPTY_BILINK(&MyTimerList)){
		pBilink=MyTimerList.next;
		pTimer=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
		pTimer->Unique=0;
		pTimer->TimerState=End;
		Delete(&pTimer->Bilink);
		pTimerPool->Release(pTimerPool, pTimer);
	}

	while(!EMPTY_BILINK(&MyTimerList)){
		pBilink=ThreadList.next;
		pTimer=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
		pTimer->Unique=0;
		pTimer->TimerState=End;
		Delete(&pTimer->Bilink);
		pTimerPool->Release(pTimerPool, pTimer);
	}
	
	if(pTimerPool){
		pTimerPool->Fini(pTimerPool,FALSE);
		pTimerPool=NULL;
	}
}


DWORD WINAPI TimerWorkerThread(LPVOID foo)
{
	BILINK *pBilink;
	PMYTIMER pTimer;
	HANDLE hNewThread;
	DWORD dwJunk;
	
	while (1){
	
		WaitForSingleObject(hWorkToDoSem, INFINITE);

		Lock(&ThreadListLock);

			if(bShutDown || (KillCount && nThreads > 1)){
				nThreads--;
				if(KillCount && !bShutDown){
					KillCount--;
				}	
				Unlock(&ThreadListLock);
				break;	
			}

			if(ExtraSignals){
				ExtraSignals--;
				Unlock(&ThreadListLock);
				continue;
			}

			if(KillCount){
				KillCount--;
				Unlock(&ThreadListLock);
				continue;
			}

			if(ActiveReq > nThreads && nThreads < MAX_TIMER_THREADS){
				nThreads++;
				hNewThread=CreateThread(NULL,4096, TimerWorkerThread, NULL, 0, &dwJunk);
				if(hNewThread){
					CloseHandle(hNewThread);
				} else {
					nThreads--;
				}
			}

			
			pBilink=ThreadList.next;

			if(pBilink == &ThreadList) {
				Unlock(&ThreadListLock);
				continue;
			};
			
			Delete(pBilink);	// pull off the list.
			
			pTimer=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);

			// Call a callback

			pTimer->TimerState=InCallBack;
		
		Unlock(&ThreadListLock);
		
		(pTimer->CallBack)((UINT_PTR)pTimer, 0, pTimer->Context, 0, 0);

		pTimer->Unique=0;
		pTimer->TimerState=End;
		pTimerPool->Release(pTimerPool, pTimer);

		Lock(&ThreadListLock);
			
		if(ActiveReq)ActiveReq--;

		Unlock(&ThreadListLock);
	}	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\serial\bilink.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.C

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/
#include <windows.h>
#include <dpf.h>
#include "bilink.h"

// Note: serialization of access to BILINK structures must 
//       take place in the calling code.  Operations are
//       not intrinsically atomic.

#ifdef DEBUG
int FindObject(
    BILINK *link,
    BILINK *list
    )
{
    BILINK *p = list->next;
    while(p != link && p != list)
        p= p->next;
    return (p==link);
}
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    )
/*=========================================================================
 *  Description:
 *      Insert an object after a specified object in the doubly linked list.
 *      The after object could be the Head BILINK for adding to the head of a
 *      queue.
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,after)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = after->next;
    in->prev = after;
    after->next->prev = in;
    after->next = in;
}

void InsertBefore(
     BILINK *in,
     BILINK *before
    )
/*=========================================================================
 *  Description:
 * Inserts an  object before a specified object in the doubly linked list.
 * The before object could be the Head BILINK for adding to the end
 * of the queue
 * CALLED WITH INTERRUPTS_OFF
 *
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,before)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = before;
    in->prev = before->prev;
    before->prev->next = in;
    before->prev = in;
}

void Delete(
     BILINK *p
)
/*=========================================================================
 *  Description:
 *
 * Delete a  object from a doubly linked list. Make sure it IS on a list!
 * CALLED WITH INTERRUPTS OFF (must be atomic).
 *
 *  Returns:
 *
 */
{
    p->next->prev = p->prev;
    p->prev->next = p->next;
    // p->next = p->prev = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\serial\comport.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       comport.c
 *  Content:	Routines for COM port I/O
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  4/10/96	kipo	created it
 *  4/12/96 kipo	use GlobalAllocPtr to create memory
 *  4/15/96 kipo	added msinternal
 *	5/22/96	kipo	added support for RTSDTR flow control
 *	6/10/96	kipo	added modem support
 *	6/22/96	kipo	added support for EnumConnectionData(); added methods
 *					to NewComPort().
 *  7/13/96	kipo	added GetComPortAddress()
 *  8/15/96	kipo	added CRC
 *  8/16/96	kipo	loop on WriteFile to send large buffers
 *  8/19/96	kipo	update thread interface
 *  1/06/97 kipo	updated for objects
 *  2/18/97 kipo	allow multiple instances of service provider
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/23/97 kipo	added support return status codes
 * 11/24/97 kipo	better error messages
 *  1/30/98 kipo	added hTerminateThreadEvent to fix bugs #15220 & #15228
 *@@END_MSINTERNAL
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>

#include "comport.h"
#include "dpf.h"

// constants

#define READTIMEOUT			5000		// ms to wait before read times out
#define WRITETIMEOUT		5000		// ms to wait before write times out
#define WRITETOTALTIMEOUT	5000		// total ms to wait before write times out
#define IOBUFFERSIZE		4096		// size of read/write buffers in bytes

// prototypes

static HRESULT		SetupComPort(LPDPCOMPORT globals, HANDLE hCom);
static HRESULT		ShutdownComPort(LPDPCOMPORT globals);
static DWORD		ReadComPort(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD nMaxLength);
static DWORD		WriteComPort(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD dwBytesToWrite, BOOLEAN bQueueOnReenter);
static HRESULT		GetComPortBaudRate(LPDPCOMPORT globals, LPDWORD lpdwBaudRate);
static HANDLE		GetComPortHandle(LPDPCOMPORT globals);

static DWORD WINAPI	IOThread(LPVOID lpvParam1);

/*
 * NewComPort
 *
 * Creates a com port object of the given size. The readRoutine is called whenever
 * a byte is received in the input thread.
 */

HRESULT NewComPort(DWORD dwObjectSize,
				   LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
				   LPDPCOMPORT *lplpObject)
{
	LPDPCOMPORT		globals;
	DWORD			dwError;

	// allocate space for base object and our globals
	globals =(LPDPCOMPORT) GlobalAllocPtr(GHND, dwObjectSize);
	if (globals == NULL)
	{
		dwError = GetLastError();
		return (HRESULT_FROM_WIN32(dwError));
	}

	// store read routine pointer and IDirectPlaySP pointer
	globals->lpReadRoutine = lpReadRoutine;
	globals->lpDPlay = lpDPlay;

	// fill in base methods
	globals->Dispose = NULL;
	globals->Connect = NULL;
	globals->Disconnect = NULL;
	globals->Setup = SetupComPort;
	globals->Shutdown = ShutdownComPort;
	globals->Read = ReadComPort;
	globals->Write = WriteComPort;
	globals->GetBaudRate = GetComPortBaudRate;
	globals->GetHandle = GetComPortHandle;
	globals->GetAddress = NULL;
	globals->GetAddressChoices = NULL;

	// return base object
	*lplpObject = globals;

	return (DP_OK);
}

/*
 * SetupComPort
 *
 * Sets up the COM port for overlapped I/O with a read thread.
 */

static HRESULT SetupComPort(LPDPCOMPORT globals, HANDLE hCom)
{
	COMMTIMEOUTS	timoutInfo;
	DWORD			dwError;

	// store com port handle
	globals->hCom = hCom;
	
	// wake up read thread when a byte arrives
	SetCommMask(globals->hCom, EV_RXCHAR);

	// setup read/write buffer for I/O
	SetupComm(globals->hCom, IOBUFFERSIZE, IOBUFFERSIZE);

	// set time outs
	timoutInfo.ReadIntervalTimeout = MAXDWORD;
	timoutInfo.ReadTotalTimeoutMultiplier = 0;
	timoutInfo.ReadTotalTimeoutConstant = 0;
	timoutInfo.WriteTotalTimeoutMultiplier = 0;
	timoutInfo.WriteTotalTimeoutConstant = WRITETOTALTIMEOUT;

	if (!SetCommTimeouts(globals->hCom, &timoutInfo))
		goto Failure;

	// create I/O event used for overlapped read

	ZeroMemory(&globals->readOverlapped, sizeof(OVERLAPPED));
	globals->readOverlapped.hEvent = CreateEvent(	NULL,	// no security
													TRUE,	// explicit reset req
													FALSE,	// initial event reset
													NULL );	// no name
	if (globals->readOverlapped.hEvent == NULL)
		goto Failure;

	// create I/O event used for overlapped write

	ZeroMemory(&globals->writeOverlapped, sizeof(OVERLAPPED));
	globals->writeOverlapped.hEvent = CreateEvent(	NULL,	// no security
													TRUE,	// explicit reset req
													FALSE,	// initial event reset
													NULL );	// no name
	if (globals->writeOverlapped.hEvent == NULL)
		goto Failure;

	// create event used to signal I/O thread to exit

	globals->hTerminateThreadEvent = CreateEvent(	NULL,	// no security
													TRUE,	// explicit reset req
													FALSE,	// initial event reset
													NULL );	// no name
	if (globals->hTerminateThreadEvent == NULL)
		goto Failure;

	// Init vars for pending queue
	InitializeCriticalSection(&globals->csWriting);
	InitBilink(&globals->PendingSends);
	globals->bWriting=FALSE;

	// create read thread

	globals->hIOThread = CreateThread(
								NULL,			// default security
								0,				// default stack size
								IOThread,		// pointer to thread routine
								globals,		// argument for thread
								0,				// start it right away
								&globals->IOThreadID);
	if (globals->hIOThread == NULL)
		goto Failure;

	// adjust thread priority to be higher than normal or the serial port will
	// back up and the game will slow down or lose messages.

	SetThreadPriority(globals->hIOThread, THREAD_PRIORITY_ABOVE_NORMAL);
	ResumeThread(globals->hIOThread);

	// assert DTR

	EscapeCommFunction(globals->hCom, SETDTR);

	return (DP_OK);

Failure:
	dwError = GetLastError();
	ShutdownComPort(globals);

	return (HRESULT_FROM_WIN32(dwError));
}

/*
 * ShutdownComPort
 *
 * Stop's all I/O on COM port and releases allocated resources.
 */

static HRESULT ShutdownComPort(LPDPCOMPORT globals)
{
	if (globals->hIOThread)
	{
		// the thread will wake up if we disable event notifications using
		// SetCommMask. Need to set the hTerminateThread event before doing
		// this so the thread will know to exit

		SetEvent(globals->hTerminateThreadEvent);
		SetCommMask(globals->hCom, 0);
		WaitForSingleObject(globals->hIOThread, INFINITE);

        CloseHandle (globals->hIOThread);
		globals->hIOThread = NULL;

		// purge any outstanding reads/writes

		EscapeCommFunction(globals->hCom, CLRDTR);
		PurgeComm(globals->hCom, PURGE_TXABORT | PURGE_RXABORT |
								 PURGE_TXCLEAR | PURGE_RXCLEAR );
	}

	if (globals->hTerminateThreadEvent)
	{
		CloseHandle(globals->hTerminateThreadEvent);
		globals->hTerminateThreadEvent = NULL;
	}

	if (globals->readOverlapped.hEvent)
	{
		CloseHandle(globals->readOverlapped.hEvent);
		globals->readOverlapped.hEvent = NULL;
	}

	if (globals->writeOverlapped.hEvent)
	{
		CloseHandle(globals->writeOverlapped.hEvent);
		globals->writeOverlapped.hEvent = NULL;
	}

	// the com port is shut down
	globals->hCom = NULL;

	// Free resources for pending queue
	DeleteCriticalSection(&globals->csWriting);

	return (DP_OK);
}

/*
 * ReadComPort
 *
 * Read bytes from COM port. Will block until all bytes have been read.
 */

static DWORD ReadComPort(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD nMaxLength)
{
	COMSTAT		ComStat;
	DWORD		dwErrorFlags, dwLength, dwError;

	ClearCommError(globals->hCom, &dwErrorFlags, &ComStat);

	dwLength = min(nMaxLength, ComStat.cbInQue);
	if (dwLength == 0)
		return (0);

	if (ReadFile(globals->hCom, lpvBuffer, dwLength, &dwLength, &globals->readOverlapped))
		return (dwLength);

	// deal with error
	dwError = GetLastError();
	if (dwError != ERROR_IO_PENDING)
	{
		DPF(0, "Error reading from com port: 0x%8X", dwError);
		return (0);
	}

	// wait for this transmission to complete

	if (WaitForSingleObject(globals->readOverlapped.hEvent, READTIMEOUT) != WAIT_OBJECT_0)
	{
		DPF(0, "Timed out reading com port after waiting %d ms", READTIMEOUT);
		return (0);
	}

	GetOverlappedResult(globals->hCom, &globals->readOverlapped, &dwLength, FALSE);
	globals->readOverlapped.Offset += dwLength;

   return (dwLength);
}

/*
 * WriteComPort
 *
 * Write bytes to COM port. Will block until all bytes have been written.
 */

static DWORD WriteComPort(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD dwBytesToWrite, BOOLEAN bQueueOnReenter)
{
	DWORD	dwLength;
	DWORD	dwBytesWritten;
	LPBYTE	lpData;
	DWORD	dwError;

	EnterCriticalSection(&globals->csWriting);
	
	if(!globals->bWriting || !bQueueOnReenter){
		globals->bWriting=TRUE;
		LeaveCriticalSection(&globals->csWriting);

		lpData = lpvBuffer;
		dwBytesWritten = 0;
		while (dwBytesWritten < dwBytesToWrite)
		{
			dwLength = dwBytesToWrite - dwBytesWritten;
			if (WriteFile(globals->hCom, lpData, dwLength, &dwLength, &globals->writeOverlapped))
			{
				dwBytesWritten += dwLength;
				globals->bWriting = FALSE;
				return (dwBytesWritten);
			}

			dwError = GetLastError();
			if (dwError != ERROR_IO_PENDING)
			{
				DPF(0, "Error writing to com port: 0x%8X", dwError);
				globals->bWriting = FALSE;
				return (dwBytesWritten);
			}

	 		// wait for this transmission to complete

			if (WaitForSingleObject(globals->writeOverlapped.hEvent, WRITETIMEOUT) != WAIT_OBJECT_0)
			{
				DPF(0, "Timed out writing to com port after waiting %d ms", WRITETIMEOUT);
				globals->bWriting = FALSE;
				return (dwBytesWritten);
			}

			if (GetOverlappedResult(globals->hCom, &globals->writeOverlapped, &dwLength, TRUE) == 0)
			{
				dwError = GetLastError();
				DPF(0, "Error writing to com port: 0x%8X", dwError);
				/*
				// BUGBUG:  a-josbor: this probably should return, but I'm unwilling to make the change so close to ship...
				globals->bWriting = FALSE;
				return (dwBytesWritten);
				*/
			}
			globals->writeOverlapped.Offset += dwLength;

			lpData += dwLength;
			dwBytesWritten += dwLength;
		}

		if(bQueueOnReenter){ // don't drain queue recurrsively.
			// Drain any pending sends.
			EnterCriticalSection(&globals->csWriting);
			while(!EMPTY_BILINK(&globals->PendingSends)){
			
				LPPENDING_SEND lpPendingSend;
				
				lpPendingSend=CONTAINING_RECORD(globals->PendingSends.next,PENDING_SEND,Bilink);
				Delete(&lpPendingSend->Bilink);
				
				LeaveCriticalSection(&globals->csWriting);
				WriteComPort(globals,lpPendingSend->Data,lpPendingSend->dwBytesToWrite,FALSE);
				GlobalFreePtr(lpPendingSend);
				EnterCriticalSection(&globals->csWriting);	
			}
			globals->bWriting=FALSE;
			LeaveCriticalSection(&globals->csWriting);
		}
		
	} else {
	
		LPPENDING_SEND lpPendingSend;
		
		// we are in the middle of writing, so copy this to the pending queue and it will get
		// sent after the current write.
		
		lpPendingSend = (LPPENDING_SEND) GlobalAllocPtr(GHND, dwBytesToWrite+sizeof(PENDING_SEND));
		if(lpPendingSend){
			memcpy(lpPendingSend->Data,lpvBuffer,dwBytesToWrite);
			lpPendingSend->dwBytesToWrite=dwBytesToWrite;
			InsertBefore(&lpPendingSend->Bilink, &globals->PendingSends);

		}
		LeaveCriticalSection(&globals->csWriting);
		dwBytesWritten=dwBytesToWrite;
	}
	
	return (dwBytesWritten);
}

/*
 * GetComPortBaudRate
 *
 * Get baud rate of com port.
 */

static HRESULT GetComPortBaudRate(LPDPCOMPORT globals, LPDWORD lpdwBaudRate)
{
	DCB			dcb;
	DWORD		dwError;

	ZeroMemory(&dcb, sizeof(DCB));
	dcb.DCBlength = sizeof(DCB);

	if (!GetCommState(globals->hCom, &dcb))
		goto Failure;

	*lpdwBaudRate = dcb.BaudRate;

	return (DP_OK);

Failure:	
	dwError = GetLastError();

	return (HRESULT_FROM_WIN32(dwError));
}

/*
 * GetComPortHandle
 *
 * Get handle of com port.
 */

static HANDLE GetComPortHandle(LPDPCOMPORT globals)
{
	return (globals->hCom);
}

/*
 * IOThread
 *
 * Thread to wait for events from COM port. Will call the read routine if an byte
 * is received.
 */

DWORD WINAPI IOThread(LPVOID lpvParam1)
{
	LPDPCOMPORT	globals = (LPDPCOMPORT) lpvParam1;
	DWORD		dwTransfer, dwEvtMask;
	OVERLAPPED	os;
	HANDLE		events[3];
	DWORD		dwResult;

	// create I/O event used for overlapped read

	ZeroMemory(&os, sizeof(OVERLAPPED));
	os.hEvent = CreateEvent(NULL,	// no security
							TRUE,	// explicit reset req
							FALSE,	// initial event reset
							NULL );	// no name
	if (os.hEvent == NULL)
		goto CreateEventFailed;

	if (!SetCommMask(globals->hCom, EV_RXCHAR))
		goto SetComMaskFailed;

	// events to use when waiting for overlapped I/O to complete
	events[0] = globals->hTerminateThreadEvent;
	events[1] = os.hEvent;
	events[2] = (HANDLE) -1;		// work around Win95 bugs in WaitForMultipleObjects

	// spin until this event is signaled during Close.

	while (WaitForSingleObject(globals->hTerminateThreadEvent, 0) == WAIT_TIMEOUT)
	{
		dwEvtMask = 0;

		// wait for COM port event
		if (!WaitCommEvent(globals->hCom, &dwEvtMask, &os))
		{
			if (GetLastError() == ERROR_IO_PENDING)
			{
				// wait for overlapped I/O to complete or the terminating event
				// to be set. This lets us terminate this thread even if the I/O
				// never completes, which fixes a bug on NT 4.0

				dwResult = WaitForMultipleObjects(2, events, FALSE, INFINITE);
				
				// terminating event was set
				if (dwResult == WAIT_OBJECT_0)
				{
					break;		// exit the thread
				}

				// I/O completed
				else if (dwResult == (WAIT_OBJECT_0 + 1))
				{
					GetOverlappedResult(globals->hCom, &os, &dwTransfer, TRUE);
					os.Offset += dwTransfer;
				}
			}
		}

		// was a read event
		if (dwEvtMask & EV_RXCHAR)
		{
			if (globals->lpReadRoutine)
				globals->lpReadRoutine(globals->lpDPlay);	// call read routine
		}
	}

SetComMaskFailed:
	CloseHandle(os.hEvent);

CreateEventFailed:
	ExitThread(0);

	return (0);
}

/*
  Name   : "CRC-32"
   Width  : 32
   Poly   : 04C11DB7
   Init   : FFFFFFFF
   RefIn  : True
   RefOut : True
   XorOut : FFFFFFFF
   Check  : CBF43926

  This is supposedly what Ethernet uses
*/

#if 0
#define WIDTH		32
#define POLY		0x04C11DB7
#define INITVALUE	0xFFFFFFFF
#define REFIN		TRUE
#define XOROUT		0xFFFFFFFF
#define CHECK		0xCBF43926
#define WIDMASK		0xFFFFFFFF		// value is (2^WIDTH)-1
#endif

/*
  Name   : "CRC-16"
   Width  : 16
   Poly   : 8005
   Init   : 0000
   RefIn  : True
   RefOut : True
   XorOut : 0000
   Check  : BB3D
*/

#if 1
#define WIDTH		16
#define POLY		0x8005
#define INITVALUE	0
#define REFIN		TRUE
#define XOROUT		0
#define CHECK		0xBB3D
#define WIDMASK		0x0000FFFF		// value is (2^WIDTH)-1
#endif

#define BITMASK(X) (1L << (X))

DWORD crc_normal(LPBYTE blk_adr, DWORD blk_len, DWORD crctable[])
{
	DWORD	crc = INITVALUE;

	while (blk_len--)
		crc = crctable[((crc>>24) ^ *blk_adr++) & 0xFFL] ^ (crc << 8);

	return (crc ^ XOROUT);
}

DWORD crc_reflected(LPBYTE blk_adr, DWORD blk_len, DWORD crctable[])
{
	DWORD	crc = INITVALUE;

	while (blk_len--)
		crc = crctable[(crc ^ *blk_adr++) & 0xFFL] ^ (crc >> 8);

	return (crc ^ XOROUT);
}

DWORD reflect(DWORD v, int b)
/* Returns the value v with the bottom b [0,32] bits reflected. */
/* Example: reflect(0x3e23L,3) == 0x3e26                        */
{
	int		i;
	DWORD	t = v;

	for (i = 0; i < b; i++)
	{
		if (t & 1L)
			v |=  BITMASK((b-1)-i);
		else
			v &= ~BITMASK((b-1)-i);
		t >>= 1;
	}
	return v;
}

DWORD cm_tab (int index)
{
	int   i;
	DWORD r;
	DWORD topbit = (DWORD) BITMASK(WIDTH-1);
	DWORD inbyte = (DWORD) index;

	if (REFIN)
		inbyte = reflect(inbyte, 8);

	r = inbyte << (WIDTH-8);
	for (i = 0; i < 8; i++)
	{
		if (r & topbit)
			r = (r << 1) ^ POLY;
		else
			r <<= 1;
	}

	if (REFIN)
		r = reflect(r, WIDTH);

	return (r & WIDMASK);
}

void generate_table(DWORD dwTable[])
{
	int	i;

	for (i = 0; i < 256; i++)
	{
		dwTable[i] = cm_tab(i);
	}
}

// todo - make this a static table
DWORD	gCRCTable[256];
BOOL	gTableCreated = FALSE;

DWORD GenerateCRC(LPVOID pBuffer, DWORD dwBufferSize)
{
	if (!gTableCreated)
	{
		generate_table(gCRCTable);
		gTableCreated = TRUE;
	}

	return (crc_reflected(pBuffer, dwBufferSize, gCRCTable));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\serial\dial.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dial.c
 *  Content:	Header for TAPI  routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  6/10/96	kipo	created it
 *	7/08/96 kipo	added support for new dialogs
 *	8/10/96 kipo	added support for dialing location
 *	3/04/97 kipo	close com port handle when deallocating call; use string
 *					table for modem strings; updated debug output.
 *	3/24/97 kipo	added support for specifying which modem to use
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/07/97 kipo	added support for modem choice list
 * 11/25/97 kipo	set TAPI_CURRENT_VERSION to 1.4 so the NT build won't
 *					use NT-only features (15209)
 *  5/07/98 a-peterz Track call errors in DPDIAL
 *@@END_MSINTERNAL
 ***************************************************************************/

// need to add this line so that NT builds won't define Tapi 2.0 by default,
// which causes it to link with ANSI versions of Tapi functions that are not
// available on Win 95, causing LoadLibrary to fail.

#define TAPI_CURRENT_VERSION 0x00010004

#include "tapi.h"
#include "comport.h"

#define TAPIVERSION			0x00010003	// TAPI version to require
#define LINEDROPTIMEOUT		5000		// ms to wait for call to drop
#define SUCCESS				0
#define MAXSTRINGSIZE		400

// DPDIAL.dwCallError values
enum { CALL_OK, CALL_LINEERROR, CALL_DISCONNECTED, CALL_CLOSED };

typedef LONG	LINERESULT;

typedef struct {
	HLINEAPP		hLineApp;			// handle to line application
	HLINE			hLine;				// handle to the line device
	HCALL			hCall;				// handle to the call
	HANDLE			hComm;				// handle to com port
	LPDPCOMPORT		lpComPort;			// pointer to com port object
	DWORD			dwAPIVersion;       // api version
	DWORD			dwNumLines;			// number of line devices supported by the service provider
	DWORD           dwLineID;			// line id of open line
	DWORD_PTR   	dwCallState;		// current call state of session
	DWORD			dwAsyncID;			// id of pending async operation
	DWORD			dwCallError;		// last error
} DPDIAL, *LPDPDIAL;

extern LINERESULT dialInitialize(HINSTANCE hInst, LPTSTR szAppName, LPDPCOMPORT lpComPort, LPDPDIAL *storage);
extern LINERESULT dialShutdown(LPDPDIAL globals);
extern LINERESULT dialLineOpen(LPDPDIAL globals, DWORD dwLine);
extern LINERESULT dialLineClose(LPDPDIAL globals);
extern LINERESULT dialMakeCall(LPDPDIAL globals, LPTSTR szDestination);
extern LINERESULT dialDropCall(LPDPDIAL globals);
extern LINERESULT dialDeallocCall(LPDPDIAL globals);
extern BOOL		  dialIsConnected(LPDPDIAL globals);
extern LINERESULT dialGetBaudRate(LPDPDIAL globals, LPDWORD lpdwBaudRate);
extern LRESULT	  dialGetDeviceIDFromName(LPDPDIAL globals, LPCSTR szTargetName, DWORD *lpdwDeviceID);
extern LINERESULT dialGetModemList(LPDPDIAL globals, BOOL bAnsi, LPVOID *lplpData, LPDWORD lpdwDataSize);
extern void		  dialFillModemComboBox(LPDPDIAL globals, HWND hwndDlg, int item, DWORD dwDefaultDevice);
extern void		  dialFillLocationComboBox(LPDPDIAL globals, HWND hwndDlg, int item, DWORD dwDefaultLocation);
extern LINERESULT dialTranslateDialog(LPDPDIAL globals, HWND hWnd,
							   DWORD dwDeviceID, LPTSTR szPhoneNumber);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\serial\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:	Main entry point for the DLL.
 *  History:
 *@@BEGIN_MSINTERNAL
 *   Date	By	Reason
 *   ====	==	======
 *  4/10/96	kipo	created it
 *  4/15/96 kipo	added msinternal
 *  6/18/96 kipo	changed ghInstance to be an HINSTANCE
 *@@END_MSINTERNAL
 ***************************************************************************/

#include <windows.h>

#include "dpf.h"

DWORD		gdwRefCount = 0;		// no. of attached processes
HINSTANCE	ghInstance = NULL;		// instance of our DLL

/*
 * DllMain
 *
 * Main entry point for DLL.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"

BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
	switch( dwReason )
	{
	case DLL_PROCESS_ATTACH:

		DisableThreadLibraryCalls( hmod );
		DPFINIT(); // bugbug : dpfinit for every proc?

		DPF( 0, "====> ENTER: DLLMAIN(%08lx): Process Attach: %08lx, tid=%08lx", DllMain,
				GetCurrentProcessId(), GetCurrentThreadId() );
			
		// initialize memory
		if( gdwRefCount == 0 )
		{
			DPF(0,"dllmain - starting up!");

			// do one-time initializations

			// save the instance
			ghInstance = hmod;
		}

		gdwRefCount++;
		break;

	case DLL_PROCESS_DETACH:

		DPF( 2, "====> ENTER: DLLMAIN(%08lx): Process Detach %08lx, tid=%08lx",
			DllMain, GetCurrentProcessId(), GetCurrentThreadId() );
		
		gdwRefCount--;        
		if (gdwRefCount == 0) 
		{
			DPF(0,"dllmain - going away!");
		} 
		break;

	default:
		break;
	}

    return TRUE;

} // DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\serial\comport.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       comport.h
 *  Content:	Routines for COM port I/O
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  4/10/96	kipo	created it
 *  4/15/96 kipo	added msinternal
 *	5/22/96	kipo	added support for RTSDTR flow control
 *	6/10/96	kipo	added modem support
 *	6/22/96	kipo	added support for EnumConnectionData().
 *  7/13/96	kipo	added GetComPortAddress()
 *  8/15/96	kipo	added CRC
 *  1/06/97 kipo	updated for objects
 *  2/11/97 kipo	pass player flags to GetAddress()
 *  2/18/97 kipo	allow multiple instances of service provider
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/07/97 kipo	added support for modem choice list
 *  5/23/97 kipo	added support return status codes
 *  1/30/98 kipo	added hTerminateThreadEvent to fix bugs #15220 & #15228
 ***************************************************************************/

#ifndef __COMPORT_INCLUDED__
#define __COMPORT_INCLUDED__

#include <windows.h>
#include <windowsx.h>
#include <objbase.h>

#include "dplay.h"
#include "dplaysp.h"
#include "bilink.h"

typedef struct _DPCOMPORT DPCOMPORT;
typedef			DPCOMPORT *LPDPCOMPORT;

typedef HRESULT (*LPDISPOSECOMPORT)(LPDPCOMPORT globals);
typedef HRESULT (*LPCONNECTCOMPORT)(LPDPCOMPORT globals, BOOL bWaitForConnection, BOOL bReturnStatus);
typedef HRESULT (*LPDISCONNECTCOMPORT)(LPDPCOMPORT globals);
typedef HRESULT (*LPSETUPCOMPORT)(LPDPCOMPORT globals, HANDLE hCom);
typedef HRESULT (*LPSHUTDOWNCOMPORT)(LPDPCOMPORT globals);
typedef DWORD	(*LPREADCOMPORT)(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD nMaxLength);
typedef DWORD	(*LPWRITECOMPORT)(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD dwLength, BOOLEAN bQueueOnReenter);
typedef HRESULT (*LPGETCOMPORTBAUDRATE)(LPDPCOMPORT globals, LPDWORD lpdwBaudRate);
typedef HANDLE  (*LPGETCOMPORTHANDLE)(LPDPCOMPORT globals);
typedef HRESULT (*LPGETCOMPORTADDRESS)(LPDPCOMPORT globals, DWORD dwPlayerFlags, LPVOID lpAddress, LPDWORD lpdwAddressSize);
typedef HRESULT (*LPGETCOMPORTADDRESSCHOICES)(LPDPCOMPORT globals, LPVOID lpAddress, LPDWORD lpdwAddressSize);

typedef void (*LPREADROUTINE)(LPDIRECTPLAYSP);

// struct used for pending sends.
typedef struct _PENDING_SEND {
	BILINK Bilink;
	DWORD  dwBytesToWrite;
	UCHAR  Data[0];
} PENDING_SEND, *LPPENDING_SEND;

struct _DPCOMPORT {
	// com port globals
	HANDLE					hCom;			// handle to comm object

	HANDLE					hIOThread;		// handle to read thread
	DWORD					IOThreadID;		// ID of read thread
	HANDLE					hTerminateThreadEvent; // signalled to terminate the thread

	OVERLAPPED				readOverlapped;	// overlapped sections for asynch I/O
	OVERLAPPED				writeOverlapped;
	LPREADROUTINE			lpReadRoutine;	// routine to call when read is ready
	LPDIRECTPLAYSP			lpDPlay;		// pointer to IDirectPlaySP needed to call back into DPlay

	// need to queue sends if we are in the middle of writing and drain queue when done writing.
	CRITICAL_SECTION        csWriting;		// locks pending list and bWriting
	BILINK                  PendingSends;   // bilink list of pending sends
	BOOL                    bWriting;		// guards re-entry to WriteComPort()

	// com port methods
	LPDISPOSECOMPORT		Dispose;		// dispose
	LPCONNECTCOMPORT		Connect;		// connect
	LPDISCONNECTCOMPORT		Disconnect;		// disconnect
	LPSETUPCOMPORT			Setup;			// setup com port
	LPSHUTDOWNCOMPORT		Shutdown;		// shutdown com port
	LPREADCOMPORT			Read;			// read
	LPWRITECOMPORT			Write;			// write
	LPGETCOMPORTBAUDRATE	GetBaudRate;	// get baud rate
	LPGETCOMPORTHANDLE		GetHandle;		// get com port handle
	LPGETCOMPORTADDRESS		GetAddress;		// get address
	LPGETCOMPORTADDRESSCHOICES GetAddressChoices; // get address choices
};

extern HRESULT NewComPort(DWORD dwObjectSize,
						  LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
						  LPDPCOMPORT *lplpObject);
extern HRESULT NewModem(LPVOID lpConnectionData, DWORD dwConnectionDataSize,
						LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
						LPDPCOMPORT *storage);
extern HRESULT NewSerial(LPVOID lpConnectionData, DWORD dwConnectionDataSize,
						 LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
						 LPDPCOMPORT *storage);

extern DWORD GenerateCRC(LPVOID pBuffer, DWORD dwBufferSize);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\serial\dpserial.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpserial.c
 *  Content:	Implementation of serial port service provider
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *	4/10/96	kipo	created it
 *	4/12/96 kipo	updated for new interfaces
 *	4/15/96 kipo	added msinternal
 *	5/22/96	kipo	updated for new interfaces
 *	6/10/96	kipo	updated for new interfaces
 *	6/10/96	kipo	added modem support
 *	6/18/96 kipo	use guid to choose serial/modem connection
 *	6/20/96 kipo	updated for new interfaces
 *	6/21/96 kipo	Bug #2078. Changed modem service provider GUID so it's not the
 *					same as the DPlay 1.0 GUID, so games that are checking won't
 *					put up their loopy modem-specific UI.
 *	6/21/96	kipo	updated for latest interfaces; return error if message size is too big.
 *	6/22/96	kipo	updated for latest interfaces; use connection data; return version
 *	6/23/96	kipo	updated for latest service provider interfaces.
 *	6/24/96	kipo	divide baud rate by 100 to conform to DPlay 1.0 usage.
 *	6/25/96	kipo	added WINAPI prototypes and updated for DPADDRESS
 *  7/13/96	kipo	added support for GetAddress() method.
 *  7/13/96	kipo	don't print as many errors for invalid messages.
 *  8/10/96	kipo	return DPERR_SESSIONLOST on write failures
 *	8/13/96 kipo	added CRC
 *	8/21/96 kipo	return a value for dwHeaderLength in caps 
 *	9/07/96	kip		changed latency and timeout values
 *  1/06/97 kipo	updated for objects
 *  2/11/97 kipo	pass player flags to GetAddress()
 *  2/11/97 kipo	SPInit was needlessly clearing the dwFlags field of the
 *					callback table.
 *  2/18/97 kipo	allow multiple instances of service provider
 *	3/04/97 kipo	updated debug output; make sure we linke with dplayx.dll
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/07/97 kipo	added support for modem choice list
 *  5/23/97 kipo	added support return status codes
 *  5/15/98 a-peterz When Write fails, return DPERR_NOCONNECTION (#23745)
 ***************************************************************************/

#define INITGUID
#include <windows.h>
#include <windowsx.h>

#include <objbase.h>
#include <initguid.h>

#include "dpf.h"
#include "dplaysp.h"
#include "comport.h"

// macros

#ifdef DEBUG
	#define DPF_ERRVAL(a, b)  DPF( 0, DPF_MODNAME ": " a, b );
#else
	#define DPF_ERRVAL(a, b)
#endif

// constants

#define SPMINORVERSION      0x0000				// service provider-specific version number
#define VERSIONNUMBER		(DPSP_MAJORVERSION | SPMINORVERSION) // version number for service provider

#define MESSAGETOKEN		0x2BAD				// token to signify start of message
#define MESSAGEHEADERLEN	sizeof(MESSAGEHEADER) // size of message header
#define MESSAGEMAXSIZEINT	0x0000FFFF			// maximum size of an internal message
#define MESSAGEMAXSIZEEXT	(MESSAGEMAXSIZEINT - MESSAGEHEADERLEN)	// maximum size of an external message

typedef enum {
	NEWMESSAGESTATE = 0,						// start reading a new message
	READHEADERSTATE,							// read the message header
	READDATASTATE,								// read the message data
	SKIPDATASTATE								// skip the message data
} MESSAGESTATE;

// structures

// message header
typedef struct {
	WORD	wToken;								// message token
	WORD	wMessageSize;						// length of message
	WORD	wMessageCRC;						// CRC checksum value for message body
	WORD	wHeaderCRC;							// CRC checksum value for header
} MESSAGEHEADER, *LPMESSAGEHEADER;

// service provider context
typedef struct {
	LPDPCOMPORT		lpComPort;					// pointer to com port data structure
	MESSAGESTATE	msReadState;				// current read state
	BYTE			lpReadHeader[MESSAGEHEADERLEN];	// buffer for message header
	LPBYTE			lpReadBuffer;				// buffer for message data
	DWORD			dwReadBufferSize;			// size of message buffer in bytes
	DWORD			dwReadCount;				// no. bytes read into message buffer
	DWORD			dwReadTotal;				// no. total bytes to read into message buffer
	DWORD			dwSkipCount;				// no. bytes skipped to find message header
	LPDIRECTPLAYSP	lpDPlay;					// pointer to IDirectPlaySP needed to call back into DPlay
} SPCONTEXT, *LPSPCONTEXT;

// {0F1D6860-88D9-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPSERIAL_GUID,						// GUID for serial service provider
0xf1d6860, 0x88d9, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {44EAA760-CB68-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPMODEM_GUID,						// GUID for modem service provider
0x44eaa760, 0xcb68, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * GetSPContext
 *
 * Get service provider context from DirectPlay.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"GetSPContext"

LPSPCONTEXT GetSPContext(LPDIRECTPLAYSP lpDPlay)
{
	LPSPCONTEXT	lpContext = NULL;
	DWORD		dwContextSize = 0;
	HRESULT		hr;

	// no dplay interface?
	if (lpDPlay == NULL)
	{
		DPF_ERR("DPlaySP interface is NULL!");
		goto FAILURE;
	}

	// get pointer to context from DPlay
	hr = lpDPlay->lpVtbl->GetSPData(lpDPlay, &lpContext, &dwContextSize, DPGET_LOCAL);
	if FAILED(hr)
	{
		DPF_ERRVAL("could not get context: 0x%08X", hr);
		goto FAILURE;
	}

	// make sure size is correct
	if (dwContextSize != sizeof(SPCONTEXT))
	{
		DPF_ERR("invalid context size!");
		goto FAILURE;
	}

	return (lpContext);

FAILURE:
	return (NULL);
}

/*
 * SetupMessageHeader
 *
 * Initialize the service provider-specific header put
 * in front of every message.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SetupMessageHeader"

HRESULT SetupMessageHeader(LPVOID pvMessage, DWORD dwMessageSize)
{
	LPMESSAGEHEADER	pMessageHeader = (LPMESSAGEHEADER) pvMessage;

	// make sure message will fit in header
	if (dwMessageSize > MESSAGEMAXSIZEINT)
		return (DPERR_SENDTOOBIG);

	// set message header
	pMessageHeader->wToken = (WORD) MESSAGETOKEN;

	// set message size
	pMessageHeader->wMessageSize = (WORD) dwMessageSize;

	// generate CRC for message body
	pMessageHeader->wMessageCRC = (WORD) GenerateCRC(((LPBYTE) pvMessage) + MESSAGEHEADERLEN,
										dwMessageSize - MESSAGEHEADERLEN);

	// generate CRC for message header
	pMessageHeader->wHeaderCRC = (WORD) GenerateCRC(pvMessage, MESSAGEHEADERLEN - sizeof(pMessageHeader->wHeaderCRC));

	return (DP_OK);
}

/*
 * GetMessageLength
 *
 * Check for valid message header and return length of message.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"GetMessageLength"

DWORD GetMessageLength(LPBYTE header)
{
	LPMESSAGEHEADER	pMessageHeader = (LPMESSAGEHEADER) header;
	DWORD			byteCount;

	// check for token we put in front of every message
	if (pMessageHeader->wToken != MESSAGETOKEN)
		goto FAILURE;

	// check CRC for message header
	if (pMessageHeader->wHeaderCRC != (WORD) GenerateCRC(header, MESSAGEHEADERLEN - sizeof(pMessageHeader->wHeaderCRC)))
		goto FAILURE;

	// get length of message
	byteCount = pMessageHeader->wMessageSize;
	if (byteCount <= MESSAGEHEADERLEN)
	{
		DPF_ERRVAL("bad message size: %d", byteCount);
		goto FAILURE;
	}

	return (byteCount);

FAILURE:
	return (0);
}

/*
 * SetupToReadMessage
 *
 * Create/resize buffer to fit length of message and initialize header.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SetupToReadMessage"

BOOL SetupToReadMessage(LPSPCONTEXT lpContext)
{
	// no buffer, so create one
	if (lpContext->lpReadBuffer == NULL)
	{
		lpContext->lpReadBuffer = GlobalAllocPtr(GHND, lpContext->dwReadTotal);
		if (lpContext->lpReadBuffer == NULL)
		{
			DPF_ERRVAL("could not create message buffer: %d", GetLastError());
			goto FAILURE;
		}
		lpContext->dwReadBufferSize = lpContext->dwReadTotal;
	}

	// existing buffer not big enough, so resize
	else if (lpContext->dwReadBufferSize < lpContext->dwReadTotal)
	{
		HANDLE	h;
		h = GlobalReAllocPtr(lpContext->lpReadBuffer, lpContext->dwReadTotal, 0);
		if (h == NULL)
		{
			DPF_ERRVAL("could not reallocate message buffer: %d", GetLastError());
			goto FAILURE;
		}
		lpContext->lpReadBuffer = h;
		lpContext->dwReadBufferSize = lpContext->dwReadTotal;
	}

	// copy message header to buffer
	CopyMemory(lpContext->lpReadBuffer, lpContext->lpReadHeader, lpContext->dwReadCount);

	return (TRUE);

FAILURE:
	return (FALSE);
}

/*
 * ReadRoutine
 *
 * Read bytes from COM port using a state machine to assemble a message.
 * When message is assembled, call back to DirectPlay to deliver it.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"ReadRoutine"

void ReadRoutine(LPDIRECTPLAYSP	lpDPlay)
{
	LPSPCONTEXT	lpContext;
	DWORD		byteCount;
	    
	// get service provider context
	lpContext = GetSPContext(lpDPlay);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		return;
	}

	while (1)
	{
		switch (lpContext->msReadState)
		{
		// start reading a new message
		case NEWMESSAGESTATE:
			lpContext->dwReadCount = 0;
			lpContext->dwReadTotal = MESSAGEHEADERLEN;
			lpContext->msReadState = READHEADERSTATE;
			lpContext->dwSkipCount = 0;
			break;

		// read message header
		case READHEADERSTATE:
			byteCount = lpContext->lpComPort->Read(lpContext->lpComPort,
									&lpContext->lpReadHeader[lpContext->dwReadCount],
									lpContext->dwReadTotal - lpContext->dwReadCount);
			if (byteCount == 0)
				return;

			lpContext->dwReadCount += byteCount;
			if (lpContext->dwReadCount == lpContext->dwReadTotal) // got enough for a header
			{
				lpContext->dwReadTotal = GetMessageLength(lpContext->lpReadHeader);	// see if it's real
				if (lpContext->dwReadTotal)
				{
					if (lpContext->dwSkipCount)
						DPF_ERRVAL("%d bytes skipped", lpContext->dwSkipCount);

					if (SetupToReadMessage(lpContext))	// prepare to read message
						lpContext->msReadState = READDATASTATE;
					else
						lpContext->msReadState = SKIPDATASTATE;
				}
				else									// bad message header - reset
				{
					DWORD	i;

					if (lpContext->dwSkipCount == 0)
						DPF_ERR("invalid message header - skipping bytes");		

					lpContext->dwReadCount = MESSAGEHEADERLEN - 1; // throw away first byte and try again
					lpContext->dwReadTotal = MESSAGEHEADERLEN;
					lpContext->dwSkipCount += 1;

					for (i = 0; i < lpContext->dwReadCount; i++)	// shuffle down one byte
						lpContext->lpReadHeader[i] = lpContext->lpReadHeader[i + 1];
				}
			}
			break;

		// read message data
		case READDATASTATE:
			byteCount = lpContext->lpComPort->Read(lpContext->lpComPort,
									&lpContext->lpReadBuffer[lpContext->dwReadCount],
									lpContext->dwReadTotal - lpContext->dwReadCount);
			if (byteCount == 0)
				return;

			lpContext->dwReadCount += byteCount;
			if (lpContext->dwReadCount == lpContext->dwReadTotal)	// have read entire message
			{
				LPMESSAGEHEADER		pMessageHeader;

				// check for CRC errors
				pMessageHeader = (LPMESSAGEHEADER) lpContext->lpReadBuffer;
				if (pMessageHeader->wMessageCRC != (WORD) GenerateCRC(lpContext->lpReadBuffer + MESSAGEHEADERLEN, lpContext->dwReadTotal - MESSAGEHEADERLEN))
				{
					DPF_ERR("Message dropped - CRC did not match!");
				}
				else
				{
					DPF(5, "%d byte message received", lpContext->dwReadTotal);

					// deliver message to DirectPlay
					lpContext->lpDPlay->lpVtbl->HandleMessage(lpContext->lpDPlay,		// DirectPlay instance
										  lpContext->lpReadBuffer + MESSAGEHEADERLEN,	// pointer to message data
										  lpContext->dwReadTotal - MESSAGEHEADERLEN,	// length of message data
										  NULL);										// pointer to header (unused here)
				}
				lpContext->msReadState = NEWMESSAGESTATE;		// go read next message
			}
			break;

		// skip message data
		case SKIPDATASTATE:
			DPF_ERR("Skipping data!");
			while (lpContext->lpComPort->Read(lpContext->lpComPort, &lpContext->lpReadHeader[0], 1))	// spin until entire message discarded
			{
				lpContext->dwReadCount += 1;
				if (lpContext->dwReadCount == lpContext->dwReadTotal)
				{
					lpContext->msReadState = NEWMESSAGESTATE;
					break;
				}
			}
			break;

		default:
			DPF_ERRVAL("bad read state: %d", lpContext->msReadState);
			break;
		}
	}
}

/*
 * SP_EnumSessions
 *
 * Broadcast a message to the network.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_EnumSessions"

HRESULT WINAPI SP_EnumSessions(LPDPSP_ENUMSESSIONSDATA ped) 
{
	LPSPCONTEXT	lpContext;
	DWORD		byteCount;
	HRESULT		hr;

	DPF(5,"entering SP_EnumSessions");
    
	// get service provider context
	lpContext = GetSPContext(ped->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	// make connection
	hr = lpContext->lpComPort->Connect(lpContext->lpComPort, FALSE, ped->bReturnStatus);
	if FAILED(hr)
	{
		if (hr != DPERR_CONNECTING)
			DPF_ERRVAL("error making connection: 0x%08X", hr);
		goto FAILURE;
	}

	// see if connection has been lost
   	if (lpContext->lpComPort->GetHandle(lpContext->lpComPort) == NULL)
	{
		DPF_ERR("connection lost!");
		hr = DPERR_SESSIONLOST;
		goto FAILURE;
	}

	// setup the message
	hr = SetupMessageHeader(ped->lpMessage, ped->dwMessageSize);
	if FAILED(hr)
	{
		DPF_ERR("message too large!");
		goto FAILURE;
	}

	// send message
	byteCount = lpContext->lpComPort->Write(lpContext->lpComPort, ped->lpMessage, ped->dwMessageSize, TRUE);
	if (byteCount != ped->dwMessageSize)
	{
		DPF(0, "error writing message: %d requested, %d actual", ped->dwMessageSize, byteCount);
		hr = DPERR_CONNECTIONLOST;
		goto FAILURE;
	}

	DPF(5, "%d byte enum sessions message sent", byteCount);

	return (DP_OK);

FAILURE:
	return (hr);

} // EnumSessions

/*
 * SP_Send
 *
 * Send a message to a particular player or group.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_Send"

HRESULT WINAPI SP_Send(LPDPSP_SENDDATA psd)
{
	LPSPCONTEXT	lpContext;
	DWORD		byteCount;
	HRESULT		hr;

	DPF(5,"entering SP_Send");

	// get service provider context
	lpContext = GetSPContext(psd->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	// see if connection has been lost
   	if (lpContext->lpComPort->GetHandle(lpContext->lpComPort) == NULL)
	{
		DPF_ERR("connection lost!");
		hr = DPERR_SESSIONLOST;
		goto FAILURE;
	}

	// setup the message
	hr = SetupMessageHeader(psd->lpMessage, psd->dwMessageSize);
	if FAILED(hr)
	{
		DPF_ERR("message too large!");
		goto FAILURE;
	}

	// send message
	byteCount = lpContext->lpComPort->Write(lpContext->lpComPort, psd->lpMessage, psd->dwMessageSize, TRUE);
	if (byteCount != psd->dwMessageSize)
	{
		DPF(0, "error writing message: %d requested, %d actual", psd->dwMessageSize, byteCount);
		hr = DPERR_CONNECTIONLOST;
		goto FAILURE;
	}

	DPF(5, "%d byte message sent", byteCount);

    return (DP_OK);

FAILURE:
	return (hr);

} // Send

/*
 * SP_Reply
 *
 * Send a reply to a message.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_Reply"

HRESULT WINAPI SP_Reply(LPDPSP_REPLYDATA prd)
{
	LPSPCONTEXT	lpContext;
	DWORD		byteCount;
	HRESULT		hr;

	DPF(5,"entering Reply");
    
	// get service provider context
	lpContext = GetSPContext(prd->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	// see if connection has been lost
	if (lpContext->lpComPort->GetHandle(lpContext->lpComPort) == NULL)
	{
		DPF_ERR("connection lost!");
		hr = DPERR_SESSIONLOST;
		goto FAILURE;
	}
	
	// setup the message
	hr = SetupMessageHeader(prd->lpMessage, prd->dwMessageSize);
	if FAILED(hr)
	{
		DPF_ERR("message too large!");
		goto FAILURE;
	}

	// send message
	byteCount = lpContext->lpComPort->Write(lpContext->lpComPort, prd->lpMessage, prd->dwMessageSize, TRUE);
	if (byteCount != prd->dwMessageSize)
	{
		DPF(0, "error writing message: %d requested, %d actual", prd->dwMessageSize, byteCount);
		hr = DPERR_CONNECTIONLOST;
		goto FAILURE;
	}

	DPF(5, "%d byte reply message sent", byteCount);

    return (DP_OK);

FAILURE:
	return (hr);

} // Reply

/*
 * SP_Open
 *
 * Open the service provider.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_Open"

HRESULT WINAPI SP_Open(LPDPSP_OPENDATA pod) 
{
	LPSPCONTEXT	lpContext;
	HRESULT		hr;

	DPF(5,"entering Open");
    
	// get service provider context
	lpContext = GetSPContext(pod->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	// make connection
	hr = lpContext->lpComPort->Connect(lpContext->lpComPort, pod->bCreate, pod->bReturnStatus);
	if FAILED(hr)
	{
		DPF_ERRVAL("error making connection: 0x%08X", hr);
		goto FAILURE;
	}

	return (DP_OK);

FAILURE:
	return (hr);

} // Open

/*
 * SP_GetCaps
 *
 * Return capabilities of service provider.
 *
 * Only the fields that matter to this service provider have
 * to be set here, since all the fields are preset to
 * default values.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_GetCaps"

HRESULT WINAPI SP_GetCaps(LPDPSP_GETCAPSDATA pcd) 
{
	LPSPCONTEXT	lpContext;
	LPDPCAPS	lpCaps;
	HRESULT		hr;
    
	DPF(5,"entering GetCaps");

	// get service provider context
	lpContext = GetSPContext(pcd->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	// make sure caps buffer is large enough
	lpCaps = pcd->lpCaps;
	if (lpCaps->dwSize < sizeof(DPCAPS))
	{
		DPF_ERR("caps buffer too small");
		hr = DPERR_BUFFERTOOSMALL;
		goto FAILURE;
	}

	// don't zero out caps as DPlay has pre-initialized some default caps for us
	lpCaps->dwSize = sizeof(DPCAPS);
	lpCaps->dwMaxBufferSize = MESSAGEMAXSIZEEXT;	// return maximum external message size
	lpCaps->dwHeaderLength = MESSAGEHEADERLEN;		// return size of message header
	lpCaps->dwFlags = 0;							// have DPlay do the keep-alives
	lpCaps->dwLatency = 250;						// todo - base these on baud rate ACK!!!
	lpCaps->dwTimeout = 2500; 
	
	// if we have connected we can get the baud rate
	if (lpContext->lpComPort->GetHandle(lpContext->lpComPort))
	{
		DWORD	dwBaudRate;

		// try to get baud rate
		hr = lpContext->lpComPort->GetBaudRate(lpContext->lpComPort, &dwBaudRate);
		if SUCCEEDED(hr)
		{
			lpCaps->dwHundredBaud = dwBaudRate / 100;	// return baud rate in hundreds of baud
		}
	}

	return (DP_OK);

FAILURE:
	return (hr);

} // GetCaps

/*
 * SP_GetAddress
 *
 * Return network address of a given player.
 *
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_GetAddress"

HRESULT WINAPI SP_GetAddress(LPDPSP_GETADDRESSDATA pga) 
{
	LPSPCONTEXT	lpContext;
	HRESULT		hr;
    
	DPF(5,"entering GetAddress");

	// get service provider context
	lpContext = GetSPContext(pga->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	hr = lpContext->lpComPort->GetAddress(lpContext->lpComPort, pga->dwFlags, pga->lpAddress, pga->lpdwAddressSize);

FAILURE:
	return (hr);

} // GetAddress

/*
 * SP_GetAddressChoices
 *
 * Return address choices for this service provider
 *
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_GetAddressChoices"

HRESULT WINAPI SP_GetAddressChoices(LPDPSP_GETADDRESSCHOICESDATA pga) 
{
	LPSPCONTEXT	lpContext;
	HRESULT		hr;
    
	DPF(5,"entering GetAddressChoices");

	// get service provider context
	lpContext = GetSPContext(pga->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	hr = lpContext->lpComPort->GetAddressChoices(lpContext->lpComPort, pga->lpAddress, pga->lpdwAddressSize);

FAILURE:
	return (hr);

} // GetAddressChoices

/*
 * SP_Shutdown
 *
 * Turn off all I/O on service provider and release all allocated
 * memory and resources.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_Shutdown"

HRESULT WINAPI SP_ShutdownEx(LPDPSP_SHUTDOWNDATA psd) 
{
	LPSPCONTEXT	lpContext;
	HRESULT		hr;

	DPF(5,"entering Shutdown");
    
	// get service provider context
	lpContext = GetSPContext(psd->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	if (lpContext->lpComPort)
	{
		lpContext->lpComPort->Dispose(lpContext->lpComPort);
		lpContext->lpComPort = NULL;
	}

	if (lpContext->lpReadBuffer)
	{
		GlobalFreePtr(lpContext->lpReadBuffer);
		lpContext->lpReadBuffer = NULL;
	}

	lpContext->lpDPlay = NULL;

	// OK to release DPLAYX.DLL
	gdwDPlaySPRefCount++;

    return (DP_OK);

FAILURE:
	return (hr);

} // Shutdown

/*
 * SPInit
 *
 * This is the main entry point for the service provider. This should be
 * the only entry point exported from the DLL.
 *
 * Allocate any needed resources and return the supported callbacks.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SPInit"

HRESULT WINAPI SPInit(LPSPINITDATA pid) 
{
	SPCONTEXT			context;
	LPSPCONTEXT			lpContext;
	LPDPSP_SPCALLBACKS	lpcbTable;
	HRESULT				hr;

	DPF(5,"entering SPInit");

	// check to make sure table is big enough
	lpcbTable = pid->lpCB;
	if (lpcbTable->dwSize < sizeof(DPSP_SPCALLBACKS))		// table not big enough
	{
		DPF_ERR("callback table too small");
		hr = DPERR_BUFFERTOOSMALL;
		goto FAILURE;
	}

	// initialize context
	ZeroMemory(&context, sizeof(SPCONTEXT));
	lpContext = &context;
	lpContext->msReadState = NEWMESSAGESTATE;
	lpContext->lpDPlay = pid->lpISP;					// save pointer to IDPlaySP so we can pass it back later

	// check for correct GUID
	if (IsEqualGUID(pid->lpGuid, &DPSERIAL_GUID))
	{
		hr = NewSerial(pid->lpAddress, pid->dwAddressSize,
					   lpContext->lpDPlay, ReadRoutine,
					   &lpContext->lpComPort);
	}
	else if (IsEqualGUID(pid->lpGuid, &DPMODEM_GUID))
	{
		hr = NewModem(pid->lpAddress, pid->dwAddressSize,
					  lpContext->lpDPlay, ReadRoutine,
					  &lpContext->lpComPort);
	}
	else
	{
		DPF_ERR("unknown service provider GUID");
		hr = DPERR_INVALIDPARAM;
	}

	if FAILED(hr)
	{
		DPF_ERRVAL("error opening com port: 0x%08X", hr);
		goto FAILURE;
	}

	// return size of header we need on every message so
	// DirectPlay will leave room for it.
 	pid->dwSPHeaderSize = MESSAGEHEADERLEN;

	// return version number so DirectPlay will treat us with respect
	pid->dwSPVersion = VERSIONNUMBER;

	// set up callbacks
    lpcbTable->dwSize = sizeof(DPSP_SPCALLBACKS);			// MUST set the return size of the table
    lpcbTable->Send = SP_Send;
    lpcbTable->EnumSessions = SP_EnumSessions;
    lpcbTable->Reply = SP_Reply;
	lpcbTable->GetCaps = SP_GetCaps;
	lpcbTable->GetAddress = SP_GetAddress;
	lpcbTable->GetAddressChoices = SP_GetAddressChoices;
    lpcbTable->Open = SP_Open;
	lpcbTable->ShutdownEx = SP_ShutdownEx;

	// save context with DPlay so we can get it later
	hr = lpContext->lpDPlay->lpVtbl->SetSPData(lpContext->lpDPlay, lpContext, sizeof(SPCONTEXT), DPSET_LOCAL);
	if FAILED(hr)
	{
		DPF_ERRVAL("could not store context: 0x%08X", hr);
		goto FAILURE;
	}

	// make sure DPLAYX.DLL sticks around
	gdwDPlaySPRefCount++;

	return (DP_OK);

FAILURE:
	return (hr);

} // SPInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\serial\dial.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dial.c
 *  Content:	Wrappers for TAPI routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  6/10/96	kipo	created it
 *  6/22/96	kipo	close com port when disconnected; allow checking for
 *					valid TAPI lines during NewComPort().
 *	7/08/96 kipo	added support for new dialogs
 *	8/10/96 kipo	added support for dialing location
 *  1/06/97 kipo	updated for objects
 *  1/24/97 kipo	bug #5400: Compaq Presario was overwriting the dev caps
 *					buffer, causing a crash. Fixed to allocated a larger
 *					buffer with some slop as a workaround.
 *	3/04/97 kipo	close com port handle when deallocating call; use string
 *					table for modem strings; updated debug output.
 *	3/24/97 kipo	added support for specifying which modem to use
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/07/97 kipo	added support for modem choice list
 *  5/23/97 kipo	added support return status codes
 *  4/21/98 a-peterz #22920 Handle LINE_CLOSE message
 *  5/07/98 a-peterz #15251 Track call errors in DPDIAL
 * 10/13/99	johnkan	#413516 - Mismatch between modem dialog selection and TAPI device ID
 *@@END_MSINTERNAL
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>

#include "dputils.h"
#include "macros.h"
#include "dial.h"

void FAR PASCAL LineCallBackProc(DWORD hDevice, DWORD dwMessage, DWORD_PTR dwInstance,
								 DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3);
void		ProcessConnectedState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege);
void		ProcessDisconnectedState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege);
void		ProcessIdleState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege);
void		ProcessOfferingState(LPDPDIAL globals, HCALL hCall, DWORD dwCallPrivilege);
void		ProcessReplyMessage(LPDPDIAL globals, DWORD asyncID, LINERESULT lResult);
LINERESULT dialGetDevCaps(LPDPDIAL globals, DWORD dwLine, DWORD dwAPIVersion, LPLINEDEVCAPS	*lpDevCapsRet);
LINERESULT dialGetCommHandle(LPDPDIAL globals);
LINERESULT dialCloseCommHandle(LPDPDIAL globals);
LINERESULT dialTranslateAddress(LPDPDIAL globals, DWORD dwDeviceID, DWORD dwAPIVersion,
								LPCSTR lpszDialAddress,
								LPLINETRANSLATEOUTPUT *lpLineTranslateOutputRet);
LPSTR		GetLineErrStr(LONG err);
LPSTR		GetCallStateStr(DWORD callState);
LPSTR		GetLineMsgStr(DWORD msg);

#ifdef DEBUG
extern LONG lineError(LONG err, LPSTR modName, DWORD lineNum);
#define LINEERROR(err)	(lineError(err, DPF_MODNAME, __LINE__))
#else
#define LINEERROR(err)	(err)
#endif

/* dial initialize */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialInitialize"

LINERESULT dialInitialize(HINSTANCE hInst, LPTSTR szAppName,
						  LPDPCOMPORT lpComPort, LPDPDIAL *storage)
{
	LPDPDIAL		globals;
	LINERESULT		lResult;				/* Stores return code from TAPI calls */

	// create globals
	globals =(LPDPDIAL) GlobalAllocPtr(GHND, sizeof(DPDIAL));
	FAILWITHACTION(globals == NULL, lResult = LINEERR_NOMEM, Failure);

	DPF(3, "lineInitialize");
	DPF(3, ">  hInstance: %08X", hInst);
	DPF(3, ">  szAppName: %s", szAppName);

	// init the line
	lResult = lineInitialize(&globals->hLineApp,
							 hInst,
							 LineCallBackProc,
							 szAppName,
							 &globals->dwNumLines);
	FAILIF(LINEERROR(lResult), Failure);

	DPF(3, "<   hLineApp: %08X", globals->hLineApp);
	DPF(3, "< dwNumLines: %d", globals->dwNumLines);

	// no lines available
	FAILWITHACTION(globals->dwNumLines == 0, lResult = LINEERR_NODEVICE, Failure);

	// store pointer to com port object
	globals->lpComPort = lpComPort;

	*storage = globals;
	return (SUCCESS);

Failure:
	dialShutdown(globals);

	return (lResult);
}

/* dial shutdown */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialShutdown"

LINERESULT dialShutdown(LPDPDIAL globals)
{
	LINERESULT	lResult;

	if (globals == NULL)
		return (SUCCESS);

	if (globals->hLineApp)
	{
		dialDropCall(globals);
		dialDeallocCall(globals);
		dialLineClose(globals);

		DPF(3, "lineShutdown");
		DPF(3, ">   hLineApp: %08X", globals->hLineApp);

		lResult = lineShutdown(globals->hLineApp);
		LINEERROR(lResult);
	}

	GlobalFreePtr(globals);

	return (SUCCESS);
}

/* dialLineOpen - wrapper for lineOpen */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialLineOpen"

LINERESULT dialLineOpen(LPDPDIAL globals, DWORD dwLine)
{
	LINEEXTENSIONID lineExtensionID;		// Will be set to 0 to indicate no known extensions
    LPLINEDEVCAPS	lpLineDevCaps = NULL;
	LINERESULT		lResult;

	// fail if line is already open
	FAILWITHACTION(globals->hLine != 0, lResult = LINEERR_INVALLINEHANDLE, Failure);

	/* negotiate API version for each line */
	lResult = lineNegotiateAPIVersion(globals->hLineApp, dwLine,
					TAPIVERSION, TAPIVERSION,
					&globals->dwAPIVersion, &lineExtensionID);
	FAILIF(LINEERROR(lResult), Failure);

	lResult = dialGetDevCaps(globals, dwLine, globals->dwAPIVersion, &lpLineDevCaps);
	FAILIF(LINEERROR(lResult), Failure);

	/* check for supported media mode.  If not datamodem, continue to next line */
	FAILWITHACTION(!(lpLineDevCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM),
					lResult = LINEERR_NODEVICE, Failure);

	DPF(3, "lineOpen");
	DPF(3, ">   hLineApp: %08X", globals->hLineApp);
	DPF(3, "> dwDeviceID: %d", dwLine);

	// reset error tracking
	globals->dwCallError = CALL_OK;

	/* open the line that supports data modems */
	lResult = lineOpen( globals->hLineApp, dwLine, &globals->hLine,
						globals->dwAPIVersion, 0L,
						(DWORD_PTR) globals,
						LINECALLPRIVILEGE_OWNER, LINEMEDIAMODE_DATAMODEM,
						NULL);
	FAILIF(LINEERROR(lResult), Failure);

	DPF(3, "<      hLine: %08X", globals->hLine);

	/* if we are here then we found a compatible line */
	globals->dwLineID = dwLine;
	globals->dwCallState = LINECALLSTATE_IDLE;	// line is now idle and ready to make/receive calls
	lResult = SUCCESS;

Failure:
	if (lpLineDevCaps)
		GlobalFreePtr(lpLineDevCaps);
	return (lResult);
}

/* dialLineClose - wrapper for lineClose */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialLineClose"

LINERESULT dialLineClose(LPDPDIAL globals)
{
	LINERESULT	lResult;

	// fail if line is already closed
	FAILWITHACTION(globals->hLine == 0, lResult = LINEERR_INVALLINEHANDLE, Failure);

	DPF(3, "lineClose");
	DPF(3, ">      hLine: %08X", globals->hLine);

	lResult = lineClose(globals->hLine);
	LINEERROR(lResult);

	globals->hLine = 0;

Failure:
	return (lResult);
}

/* dialMakeCall - wrapper for lineMakeCall */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialMakeCall"

LINERESULT dialMakeCall(LPDPDIAL globals, LPTSTR szDestination)
{
	LINECALLPARAMS			callparams;
	LINERESULT				lResult;

	// fail if line not open or if call is already open
	FAILWITHACTION(globals->hLine == 0, lResult = LINEERR_INVALLINEHANDLE, Failure);
	FAILWITHACTION(globals->hCall != 0, lResult = LINEERR_INVALCALLHANDLE, Failure);

	// set call parameters
	ZeroMemory(&callparams, sizeof(LINECALLPARAMS));
	callparams.dwBearerMode = LINEBEARERMODE_VOICE;
	callparams.dwMediaMode = LINEMEDIAMODE_DATAMODEM;
	callparams.dwTotalSize = sizeof(LINECALLPARAMS);

	DPF(3, "lineMakeCall");
	DPF(3, ">      hLine: %08X", globals->hLine);
	DPF(3, "> szDestAddr: \"%s\"", szDestination);

	lResult = lineMakeCall(globals->hLine, &globals->hCall, szDestination, 0, &callparams);

	// lResult will be > 0 if call is asynchronous
	FAILWITHACTION(lResult < 0, LINEERROR(lResult), Failure);
	FAILMSG(lResult == 0);

	DPF(3, "<      hCall: %08X", globals->hCall);
	DPF(3, "<  dwAsyncID: %d", lResult);

	globals->dwAsyncID = lResult;			// store async ID
	lResult = SUCCESS;

Failure:
	return (lResult);
}

/* dialDropCall - wrapper for lineDrop */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialDropCall"

LINERESULT dialDropCall(LPDPDIAL globals)
{
	MSG			msg;
	DWORD		dwStopTicks;
	LINERESULT	lResult;

	// fail if line not open or if call not open
	FAILWITHACTION(globals->hLine == 0, lResult = LINEERR_INVALLINEHANDLE, Failure);
	FAILWITHACTION(globals->hCall == 0, lResult = LINEERR_INVALCALLHANDLE, Failure);

	DPF(3, "lineDrop");
	DPF(3, ">      hCall: %08X", globals->hCall);

	lResult = lineDrop(globals->hCall, NULL, 0);

	// lResult will be > 0 if call is asynchronous
	FAILWITHACTION(lResult < 0, LINEERROR(lResult), Failure);
	FAILMSG(lResult == 0);

	DPF(3, "<  dwAsyncID: %d", lResult);

	globals->dwAsyncID = lResult;			// store async ID

	// wait for call to get dropped
	dwStopTicks = GetTickCount() + LINEDROPTIMEOUT;
	while (GetTickCount() < dwStopTicks)
	{
		// see if reply has occured and we are idle
		if ((globals->dwAsyncID == 0) &&
			(globals->dwCallState == LINECALLSTATE_IDLE))
		{
			break;
		}

		// give TAPI a chance to call our callback
        if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
		{
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
	}

	lResult = SUCCESS;

Failure:
	return (lResult);
}

/* dialDeallocCall - wrapper for lineDeallocCall */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialDeallocCall"

LINERESULT dialDeallocCall(LPDPDIAL globals)
{
	LINERESULT	lResult;

	// fail if line not open or if call not open
	FAILWITHACTION(globals->hLine == 0, lResult = LINEERR_INVALLINEHANDLE, Failure);
	FAILWITHACTION(globals->hCall == 0, lResult = LINEERR_INVALCALLHANDLE, Failure);

	// close the com port
	dialCloseCommHandle(globals);

	DPF(3, "lineDeallocateCall");
	DPF(3, ">      hCall: %08X", globals->hCall);

	lResult = lineDeallocateCall(globals->hCall);
	LINEERROR(lResult);

	globals->hCall = 0;

Failure:
	return (lResult);
}

/* dialIsConnected- returns TRUE if call is connected */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialIsConnected"

BOOL dialIsConnected(LPDPDIAL globals)
{
	// connected if we have a call handle and the state is connected
	if ((globals->hCall) &&
		(globals->dwCallState == LINECALLSTATE_CONNECTED))
		return (TRUE);
	else
		return (FALSE);
}

/* callback function */

#undef DPF_MODNAME
#define DPF_MODNAME	"LineCallBackProc"

void FAR PASCAL LineCallBackProc(DWORD hDevice, DWORD dwMessage, DWORD_PTR dwInstance,
								 DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3)
{
	LPDPDIAL	globals = (LPDPDIAL) dwInstance;

	DPF(3, "Line message: %s", GetLineMsgStr(dwMessage));

    switch (dwMessage)
	{
	case LINE_LINEDEVSTATE:
		break;

	case LINE_CALLSTATE:

		globals->dwCallState = dwParam1;

		DPF(3, "  call state: %s", GetCallStateStr((DWORD)globals->dwCallState));

		switch (globals->dwCallState)
		{
		case LINECALLSTATE_OFFERING:
			ProcessOfferingState(globals, (HCALL) hDevice, (DWORD)dwParam3);
			break;

		case LINECALLSTATE_CONNECTED:
			ProcessConnectedState(globals, (HCALL) hDevice, (DWORD)dwParam2, (DWORD)dwParam3);
			break;

		case LINECALLSTATE_DISCONNECTED:
			ProcessDisconnectedState(globals, (HCALL) hDevice, (DWORD)dwParam2, (DWORD)dwParam3);
			break;

		case LINECALLSTATE_IDLE:
			ProcessIdleState(globals, (HCALL) hDevice, (DWORD)dwParam2, (DWORD)dwParam3);
			break;

		case LINECALLSTATE_BUSY:
			break;
		}
		break;

	case LINE_REPLY:
		ProcessReplyMessage(globals, (DWORD)dwParam1, (LINERESULT) dwParam2);
		break;

	/* other messages that can be processed */
	case LINE_CLOSE:
		// the line has shut itself down
		globals->hLine = 0;
		globals->dwCallError = CALL_CLOSED;
		break;
	case LINE_ADDRESSSTATE:
		break;
	case LINE_CALLINFO:
		break;
	case LINE_DEVSPECIFIC:
		break;
	case LINE_DEVSPECIFICFEATURE:
		break;
	case LINE_GATHERDIGITS:
		break;
	case LINE_GENERATE:
		break;
	case LINE_MONITORDIGITS:
		break;
	case LINE_MONITORMEDIA:
		break;
	case LINE_MONITORTONE:
		break;
	} /* switch */

} /* LineCallBackProc */

/* ProcessOfferingState - handler for LINECALLSTATE_OFFERING state */

#undef DPF_MODNAME
#define DPF_MODNAME	"ProcessOfferingState"

void ProcessOfferingState(LPDPDIAL globals, HCALL hCall, DWORD dwCallPrivilege)
{
	LINERESULT	lResult;

	DDASSERT(hCall);
	DDASSERT(globals->hCall == 0);
	DDASSERT(globals->dwAsyncID == 0);

	DPF(3, "       hCall: %08X", hCall);
	DPF(3, "   privilege: %08X", (DWORD)dwCallPrivilege);

	// fail if we don't own the call
	FAILIF(dwCallPrivilege != LINECALLPRIVILEGE_OWNER, Failure);

	// answer the call
	lResult = lineAnswer(hCall, NULL, 0);

	// lResult will be > 0 if call is asynchronous
	FAILWITHACTION(lResult < 0, LINEERROR(lResult), Failure);
	FAILMSG(lResult == 0);

	globals->hCall = hCall;					// store call handle
	globals->dwAsyncID = lResult;			// store async ID

Failure:
	return;
}

/* ProcessConnectedState - handler for LINECALLSTATE_CONNECTED state */

#undef DPF_MODNAME
#define DPF_MODNAME	"ProcessConnectedState"

void ProcessConnectedState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege)
{
	LINERESULT		lResult;
	HRESULT			hr;

	DDASSERT(hCall);
	DDASSERT(globals->hCall);
	DDASSERT(globals->hCall == hCall);

	DPF(3, "       hCall: %08X", hCall);
	DPF(3, "   privilege: %08X", dwCallPrivilege);
	DPF(3, "      detail: %08X", dwCallStateDetail);

	// get the id of the COM device connected to the modem
	// NOTE: once we get the handle, it is our responsibility to close it
	lResult = dialGetCommHandle(globals);
	FAILIF(LINEERROR(lResult), Failure);

	DPF(3, "    hComPort: %08X", globals->hComm);

	// setup com port
	hr = globals->lpComPort->Setup(globals->lpComPort, globals->hComm);
	FAILIF(FAILED(hr), Failure);		

	{
		DWORD	dwBaudRate;

		lResult = dialGetBaudRate(globals, &dwBaudRate);
	}

Failure:
	return;
}

/* ProcessDisconnectedState - handler for LINECALLSTATE_DISCONNECTED state */

#undef DPF_MODNAME
#define DPF_MODNAME	"ProcessDisconnectedState"

void ProcessDisconnectedState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege)
{
	LINERESULT		lResult;

	DDASSERT(hCall);
	DDASSERT(globals->hCall);
	DDASSERT(globals->hCall == hCall);

	DPF(3, "       hCall: %08X", hCall);
	DPF(3, "   privilege: %08X", dwCallPrivilege);
	DPF(3, "      detail: %08X", dwCallStateDetail);

	// record error
	globals->dwCallError = CALL_DISCONNECTED;

	// shutdown com port and deallocate call handle
	lResult = dialDeallocCall(globals);
	FAILMSG(LINEERROR(lResult));
}

/* ProcessIdleState - handler for LINECALLSTATE_IDLE state */

#undef DPF_MODNAME
#define DPF_MODNAME	"ProcessIdleState"

void ProcessIdleState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege)
{
	DDASSERT(hCall);

	DPF(3, "       hCall: %08X", hCall);
	DPF(3, "   privilege: %08X", dwCallPrivilege);
	DPF(3, "      detail: %08X", dwCallStateDetail);
}

/* ProcessReplyMessage - handler for LINE_REPLY message */

#undef DPF_MODNAME
#define DPF_MODNAME	"ProcessReplyMessage"

void ProcessReplyMessage(LPDPDIAL globals, DWORD dwAsyncID, LINERESULT lResult)
{
	DDASSERT(dwAsyncID);
	DDASSERT(globals->dwAsyncID);
	DDASSERT(globals->dwAsyncID == dwAsyncID);

	DPF(3, "   dwAsyncID: %d", dwAsyncID);
	DPF(3, "       error: %d", lResult);

	// check for an error
	if (LINEERROR(lResult))
		globals->dwCallError = CALL_LINEERROR;


	// reset field so we know reply happened
	globals->dwAsyncID = 0;
}

/* dialGetDevCaps - wrapper for lineGetDevCaps */

/*	Bug #5400 -

	My trusty Compaq Presario returns two line devices. The second device says it
	needs 555 bytes for dev caps, but when you give it a pointer to a 555-byte block
	it actually writes 559 (!) bytes into the buffer! Whoah, Bessy!

	This makes Windows very unhappy in strange and magical ways.

	The fix is to start with a very large buffer (1024 bytes?) like all the samples do
	and then leave some slop in subsequent reallocs, which should hopefully clean up
	after these messy critters.
*/

#define DEVCAPSINITIALSIZE	1024		// size of first alloc
#define DEVCAPSSLOP			100			// extra space that loser service providers can party on

#undef DPF_MODNAME
#define DPF_MODNAME	"dialGetDevCaps"

LINERESULT dialGetDevCaps(LPDPDIAL globals, DWORD dwLine, DWORD dwAPIVersion, LPLINEDEVCAPS	*lpDevCapsRet)
{
	LPLINEDEVCAPS	lpDevCaps;
	LINERESULT		lResult;
	LPVOID			lpTemp;

	// create a buffer for dev caps
	lpDevCaps = (LPLINEDEVCAPS) GlobalAllocPtr(GHND, DEVCAPSINITIALSIZE + DEVCAPSSLOP);
	FAILWITHACTION(lpDevCaps == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);
	lpDevCaps->dwTotalSize = DEVCAPSINITIALSIZE;

	while (TRUE)
	{
		// get device caps
		lResult = lineGetDevCaps(globals->hLineApp, dwLine,
								 dwAPIVersion, 0, lpDevCaps);

		if (lResult == SUCCESS)
		{
			// make sure there is enough space
			if (lpDevCaps->dwNeededSize <= lpDevCaps->dwTotalSize)
				break;		// there is enough space, so exit
		}
		else if (lResult != LINEERR_STRUCTURETOOSMALL)
		{
			LINEERROR(lResult);
			goto Failure;
		}

		// reallocate buffer if not big enough */

		lpTemp = GlobalReAllocPtr(lpDevCaps, lpDevCaps->dwNeededSize + DEVCAPSSLOP, 0);
		FAILWITHACTION(lpTemp == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);

		lpDevCaps = lpTemp;
		lpDevCaps->dwTotalSize = lpDevCaps->dwNeededSize;
	}

	*lpDevCapsRet = lpDevCaps;
	return (SUCCESS);

Failure:
	if (lpDevCaps)
		GlobalFreePtr(lpDevCaps);
	return (lResult);
}

/* dialGetCallInfo - wrapper for lineGetCallInfo */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialGetCallInfo"

LINERESULT dialGetCallInfo(LPDPDIAL globals, LPLINECALLINFO *lpCallInfoRet)
{
	LPLINECALLINFO	lpCallInfo;
	LINERESULT		lResult;
	LPVOID			lpTemp;

	// create a buffer for call info
	lpCallInfo = (LPLINECALLINFO) GlobalAllocPtr(GHND, sizeof(LINECALLINFO));
	FAILWITHACTION(lpCallInfo == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);
	lpCallInfo->dwTotalSize = sizeof(LINECALLINFO);

	while (TRUE)
	{
		// get device info
		lResult = lineGetCallInfo(globals->hCall, lpCallInfo);

		if (lResult == SUCCESS)
		{
			// make sure there is enough space
			if (lpCallInfo->dwNeededSize <= lpCallInfo->dwTotalSize)
				break;		// there is enough space, so exit
		}
		else if (lResult != LINEERR_STRUCTURETOOSMALL)
		{
			LINEERROR(lResult);
			goto Failure;
		}

		// reallocate buffer if not big enough */

		lpTemp = GlobalReAllocPtr(lpCallInfo, lpCallInfo->dwNeededSize, 0);
		FAILWITHACTION(lpTemp == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);

		lpCallInfo = lpTemp;
		lpCallInfo->dwTotalSize = lpCallInfo->dwNeededSize;
	}

	*lpCallInfoRet = lpCallInfo;
	return (SUCCESS);

Failure:
	if (lpCallInfo)
		GlobalFreePtr(lpCallInfo);
	return (lResult);
}

/* dialGetBaudRate - get baud rate of current connecton */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialGetBaudRate"

LINERESULT dialGetBaudRate(LPDPDIAL globals, LPDWORD lpdwBaudRate)
{
	LPLINECALLINFO	lpCallInfo;
	LINERESULT		lResult;

	lResult = dialGetCallInfo(globals, &lpCallInfo);
	if LINEERROR(lResult)
		return (lResult);

	*lpdwBaudRate = lpCallInfo->dwRate;

	GlobalFreePtr(lpCallInfo);

	return (SUCCESS);
}

/* dialGetTranslateCaps - wrapper for lineGetTranslateCaps */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialGetTranslateCaps"

LINERESULT dialGetTranslateCaps(LPDPDIAL globals, DWORD dwAPIVersion, LPLINETRANSLATECAPS *lpTranslateCapsRet)
{
	LPLINETRANSLATECAPS	lpTranslateCaps;
	LPVOID				lpTemp;
	LINERESULT			lResult;

	// create a buffer for translate caps
	lpTranslateCaps = (LPLINETRANSLATECAPS) GlobalAllocPtr(GHND, sizeof(LINETRANSLATECAPS));
	FAILWITHACTION(lpTranslateCaps == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);
	lpTranslateCaps->dwTotalSize = sizeof(LINETRANSLATECAPS);

	while (TRUE)
	{
		// get translate caps
		lResult = lineGetTranslateCaps(globals->hLineApp, dwAPIVersion, lpTranslateCaps);

		if (lResult == SUCCESS)
		{
			// make sure there is enough space
			if (lpTranslateCaps->dwNeededSize <= lpTranslateCaps->dwTotalSize)
				break;		// there is enough space, so exit
		}
		else if (lResult != LINEERR_STRUCTURETOOSMALL)
		{
			LINEERROR(lResult);
			goto Failure;
		}

		// reallocate buffer if not big enough */

		lpTemp = GlobalReAllocPtr(lpTranslateCaps, lpTranslateCaps->dwNeededSize, 0);
		FAILWITHACTION(lpTemp == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);

		lpTranslateCaps = lpTemp;
		lpTranslateCaps->dwTotalSize = lpTranslateCaps->dwNeededSize;
	}

	*lpTranslateCapsRet = lpTranslateCaps;
	return (SUCCESS);

Failure:
	if (lpTranslateCaps)
		GlobalFreePtr(lpTranslateCaps);
	return (lResult);
}

/* dialGetCommHandle - wrapper for lineGetID */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialGetCommHandle"

/* structure returned by Unimodem which contains device handle and name */
typedef struct {
	HANDLE			hComm;
	CHAR			szDeviceName[1];
} COMMID, *LPCOMMID;

LINERESULT dialGetCommHandle(LPDPDIAL globals)
{
	LPCOMMID	lpCommID;
	VARSTRING	*vs, *temp;
	LINERESULT	lResult;

    vs = (VARSTRING *) GlobalAllocPtr(GHND, sizeof(VARSTRING));
	FAILWITHACTION(vs == NULL, lResult = LINEERR_NOMEM, Failure);

    vs->dwTotalSize = sizeof(VARSTRING);
    vs->dwStringFormat = STRINGFORMAT_BINARY;

	while (TRUE)
	{
		// get line ID
		lResult = lineGetID(0, 0L, globals->hCall, LINECALLSELECT_CALL, vs, "comm/datamodem");

		if (lResult == SUCCESS)
		{
			// make sure there is enough space
			if (vs->dwNeededSize <= vs->dwTotalSize)
				break;		// there is enough space, so exit
		}
		else if (lResult != LINEERR_STRUCTURETOOSMALL)
		{
			LINEERROR(lResult);
			goto Failure;
		}

		// reallocate buffer if not big enough */

		temp = GlobalReAllocPtr(vs, vs->dwNeededSize, 0);
		FAILWITHACTION(temp == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);

		vs = temp;
		vs->dwTotalSize = vs->dwNeededSize;
	}

    lpCommID = (LPCOMMID) ((LPSTR)vs + vs->dwStringOffset);
//    lstrcpy(globals->szDeviceName, cid->szDeviceName);
	globals->hComm = lpCommID->hComm;

Failure:
	if (vs)
		GlobalFreePtr(vs);
	return (lResult);
}

/*	dialCloseCommHandle - make sure com port is closed */

/*	NOTE: As per the docs for the "comm/datamodem" device class,
	the handle to the com port returned by lineGetID() MUST be explictly
	closed using CloseHandle() or you will not be able to to open this
	line again!
*/

#undef DPF_MODNAME
#define DPF_MODNAME	"dialCloseCommHandle"

LINERESULT dialCloseCommHandle(LPDPDIAL globals)
{
	HANDLE	hCom;

	// make sure the com port globals are available
	if (globals->lpComPort)
	{
			// get handle to com port
			hCom = globals->lpComPort->GetHandle(globals->lpComPort);

			// make sure its closed down
			if (hCom)
			{
				globals->lpComPort->Shutdown(globals->lpComPort);
				CloseHandle(hCom);
			}
	}

	return (SUCCESS);
}

/* dialTranslateAddress - wrapper for lineTranslateAddress */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialTranslateAddress"

LINERESULT dialTranslateAddress(LPDPDIAL globals, DWORD dwDeviceID, DWORD dwAPIVersion,
								LPCSTR lpszDialAddress,
								LPLINETRANSLATEOUTPUT *lpLineTranslateOutputRet)
{
	LPLINETRANSLATEOUTPUT	lpLineTranslateOutput;
	LPVOID					lpTemp;
	LINERESULT				lResult;

	// create a buffer for translate caps
	lpLineTranslateOutput = (LPLINETRANSLATEOUTPUT) GlobalAllocPtr(GHND, sizeof(LINETRANSLATEOUTPUT));
	FAILWITHACTION(lpLineTranslateOutput == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);
	lpLineTranslateOutput->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

	while (TRUE)
	{
		// translate address
		lResult = lineTranslateAddress(globals->hLineApp, dwDeviceID, dwAPIVersion,
									   lpszDialAddress, 0, LINETRANSLATEOPTION_CANCELCALLWAITING,
									   lpLineTranslateOutput);

		if (lResult == SUCCESS)
		{
			// make sure there is enough space
			if (lpLineTranslateOutput->dwNeededSize <= lpLineTranslateOutput->dwTotalSize)
				break;		// there is enough space, so exit
		}
		else if (lResult != LINEERR_STRUCTURETOOSMALL)
		{
			LINEERROR(lResult);
			goto Failure;
		}

		// reallocate buffer if not big enough */

		lpTemp = GlobalReAllocPtr(lpLineTranslateOutput, lpLineTranslateOutput->dwNeededSize, 0);
		FAILWITHACTION(lpTemp == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);

		lpLineTranslateOutput = lpTemp;
		lpLineTranslateOutput->dwTotalSize = lpLineTranslateOutput->dwNeededSize;
	}

	*lpLineTranslateOutputRet = lpLineTranslateOutput;
	return (SUCCESS);

Failure:
	if (lpLineTranslateOutput)
		GlobalFreePtr(lpLineTranslateOutput);
	return (lResult);
}

LINERESULT dialTranslateDialog(LPDPDIAL globals, HWND hWnd,
							   DWORD dwDeviceID, LPTSTR szPhoneNumber)
{
	LINERESULT	lResult;

	lResult = lineTranslateDialog(globals->hLineApp, dwDeviceID,
		TAPIVERSION, hWnd, szPhoneNumber);

	return (lResult);
}

//
//  FUNCTION: void dialFillModemComboBox(HWND)
//
//  PURPOSE: Fills the modem control with the available line devices.
//
//  PARAMETERS:
//    hwndDlg - handle to the current "Dial" dialog
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//    This function enumerates through all the TAPI line devices and
//    queries each for the device name.  The device name is then put into
//    the 'TAPI Line' control.  These device names are kept in order rather
//    than sorted.  This allows "Dial" to know which device ID the user
//    selected just by the knowing the index of the selected string.
//
//    There are default values if there isn't a device name, if there is
//    an error on the device, or if the device name is an empty string.
//    The device name is also checked to make sure it is null terminated.
//
//    Note that a Legacy API Version is negotiated.  Since the fields in
//    the LINEDEVCAPS structure that we are interested in haven't moved, we
//    can negotiate a lower API Version than this sample is designed for
//    and still be able to access the necessary structure members.
//
//    The first line that is usable by TapiComm is selected as the 'default'
//    line.  Also note that if there was a previously selected line, this
//    remains the default line.  This would likely only occur if this
//    function is called after the dialog has initialized once; for example,
//    if a new line is added.
//
//

LINERESULT dialGetModemName(LPDPDIAL globals, DWORD dwDeviceID,
						 LPSTR lpszModemName, DWORD dwModemNameSize)
{
    LPLINEDEVCAPS	lpLineDevCaps = NULL;
    LPSTR			lpszLineName;
	LINEEXTENSIONID lineExtensionID;	// Will be set to 0 to indicate no known extensions
	DWORD			dwAPIVersion;       // api version
	DWORD			dwStrSize;
	LINERESULT		lResult;

	/* negotiate API version for each line */
	lResult = lineNegotiateAPIVersion(globals->hLineApp, dwDeviceID,
					TAPIVERSION, TAPIVERSION,
					&dwAPIVersion, &lineExtensionID);
	if LINEERROR(lResult)
		goto FAILURE;

	lResult = dialGetDevCaps(globals, dwDeviceID, dwAPIVersion, &lpLineDevCaps);
	if LINEERROR(lResult)
		goto FAILURE;

    if ((lpLineDevCaps->dwLineNameSize) &&
        (lpLineDevCaps->dwLineNameOffset) &&
        (lpLineDevCaps->dwStringFormat == STRINGFORMAT_ASCII))
    {
        // This is the name of the device.
        lpszLineName = ((char *) lpLineDevCaps) + lpLineDevCaps->dwLineNameOffset;

        if (lpszLineName[0] != '\0')
        {
			// Reverse indented to make this fit

			// Make sure the device name is null terminated.
			if (lpszLineName[lpLineDevCaps->dwLineNameSize -1] != '\0')
			{
				// If the device name is not null terminated, null
				// terminate it.  Yes, this looses the end character.
				// Its a bug in the service provider.
				lpszLineName[lpLineDevCaps->dwLineNameSize-1] = '\0';
				DPF(0, "Device name for device 0x%lx is not null terminated.", dwDeviceID);
			}
        }
        else // Line name started with a NULL.
		{
			lResult = LINEERR_OPERATIONFAILED;
            goto FAILURE;
		}
    }
    else  // DevCaps doesn't have a valid line name.  Unnamed.
	{
		lResult = LINEERR_OPERATIONFAILED;
        goto FAILURE;
	}

	// return modem name (make sure it fits)
	dwStrSize = strlen(lpszLineName) + 1;
	if (dwStrSize <= dwModemNameSize)
		CopyMemory(lpszModemName, lpszLineName, dwStrSize);
	else
	{
		CopyMemory(lpszModemName, lpszLineName, dwModemNameSize - 1);
		lpszModemName[dwModemNameSize - 1] = '\0';
	}

FAILURE:
	if (lpLineDevCaps)
		GlobalFreePtr(lpLineDevCaps);

	return (lResult);
}

LINERESULT dialGetModemList(LPDPDIAL globals, BOOL bAnsi, LPVOID *lplpData, LPDWORD lpdwDataSize)
{
    DWORD			dwDeviceID;
	CHAR			szModemName[MAXSTRINGSIZE];
	LPBYTE			lpData;
	DWORD			dwDataSize, dwStrBytes, dwStrLen;
	LINERESULT		lResult;

	// make space for all possible strings plus terminating null
	lpData = (LPBYTE) GlobalAllocPtr(GHND, globals->dwNumLines * MAXSTRINGSIZE * sizeof(WCHAR) + sizeof(WCHAR));
	FAILWITHACTION(lpData == NULL, lResult = LINEERR_NOMEM, Failure);

	dwDataSize = 0;
    for (dwDeviceID = 0; dwDeviceID < globals->dwNumLines; dwDeviceID ++)
    {
		lResult = dialGetModemName(globals, dwDeviceID, szModemName, MAXSTRINGSIZE);
		if LINEERROR(lResult)
			continue;

		if (bAnsi)
		{
			dwStrBytes = (lstrlen(szModemName) + 1) * sizeof(CHAR);
			memcpy(lpData + dwDataSize, szModemName, dwStrBytes);
		}
		else
		{
			// NOTE: AnsiToWide returns the character count INCLUDING the terminating null character
			dwStrLen = AnsiToWide((LPWSTR) (lpData + dwDataSize), szModemName, MAXSTRINGSIZE * sizeof(WCHAR));
			dwStrBytes = dwStrLen * sizeof(WCHAR);
		}

		dwDataSize += dwStrBytes;
	}

	// put a null at end of list to terminate it
	if (bAnsi)
	{
		*(lpData + dwDataSize) = 0;
		dwDataSize += sizeof(CHAR);
	}
	else
	{
		*((LPWSTR) (lpData + dwDataSize)) = 0;
		dwDataSize += sizeof(WCHAR);
	}

	// return buffer pointer and size
	*lplpData = lpData;
	*lpdwDataSize = dwDataSize;

	return (SUCCESS);

Failure:
	return (lResult);
}

void dialFillModemComboBox(LPDPDIAL globals, HWND hwndDlg, int item, DWORD dwDefaultDevice)
{
    DWORD			dwDeviceID;
	CHAR			szModemName[MAXSTRINGSIZE];
	LINERESULT		lResult;


	for (dwDeviceID = 0; dwDeviceID < globals->dwNumLines; dwDeviceID ++)
    {
		//
		// Attempt to get the modem name.  If this fails, don't add the modem
		// to the dialog.
		//
		lResult = dialGetModemName(globals, dwDeviceID, szModemName, MAXSTRINGSIZE);
		if ( LINEERROR(lResult) == FALSE )
		{
			//
			// This line appears to be usable, put the device name into the
			// dialog control and associate the TAPI modem ID with it
			//
			lResult = (DWORD) SendDlgItemMessage(hwndDlg, item,
				CB_ADDSTRING, 0, (LPARAM) szModemName);

			if ( lResult != CB_ERRSPACE )
			{
				DWORD_PTR	TempReturn;


				//
				// We've managed to get this entry into the control, make sure
				// we associate the proper TAPI modem ID with this item.  This
				// should never fail.
				//
				TempReturn = SendDlgItemMessage( hwndDlg, item, CB_SETITEMDATA, lResult, dwDeviceID );
				DDASSERT( TempReturn != CB_ERR );

				// If this line is usable and we don't have a default initial
				// line yet, make this the initial line.
				if (dwDefaultDevice == MAXDWORD)
					dwDefaultDevice = lResult;
			}
		}
	}

    if (dwDefaultDevice == MAXDWORD)
        dwDefaultDevice = 0;

    // Set the initial default line
    SendDlgItemMessage(hwndDlg, item,
        CB_SETCURSEL, dwDefaultDevice, 0);
}

LRESULT dialGetDeviceIDFromName(LPDPDIAL globals, LPCSTR szTargetName, DWORD *lpdwDeviceID)
{
    DWORD			dwDeviceID;
	CHAR			szModemName[MAXSTRINGSIZE];
	LINERESULT		lResult;

    for (dwDeviceID = 0; dwDeviceID < globals->dwNumLines; dwDeviceID ++)
    {
		lResult = dialGetModemName(globals, dwDeviceID, szModemName, MAXSTRINGSIZE);
		if LINEERROR(lResult)
			continue;

		if (strcmp(szModemName, szTargetName) == 0)
		{
			*lpdwDeviceID = dwDeviceID;
			return (SUCCESS);
		}
	}

	return (LINEERR_OPERATIONFAILED);
}

//
//  FUNCTION: void dialFillLocationComboBox(HWND)
//
//  PURPOSE: Fills the control with the available calling from locations.
//
//  PARAMETERS:
//    hwndDlg - handle to the current "Dial" dialog
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//

void dialFillLocationComboBox(LPDPDIAL globals, HWND hwndDlg, int item, DWORD dwDefaultLocation)
{
    LPLINETRANSLATECAPS	lpTranslateCaps = NULL;
	LPLINELOCATIONENTRY lpLocationEntry;
	DWORD				dwCounter;
	LONG				index;
	LINERESULT			lResult;

	// get translate caps
	lResult = dialGetTranslateCaps(globals, TAPIVERSION, &lpTranslateCaps);
	if LINEERROR(lResult)
		return;

    // Find the location information in the TRANSLATECAPS
    lpLocationEntry = (LPLINELOCATIONENTRY)
        (((LPBYTE) lpTranslateCaps) + lpTranslateCaps->dwLocationListOffset);

    // First empty the combobox
    SendDlgItemMessage(hwndDlg, item, CB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0);

    // enumerate all the locations
    for (dwCounter = 0; dwCounter < lpTranslateCaps->dwNumLocations; dwCounter++)
    {
        // Put each one into the combobox
        index = (DWORD)SendDlgItemMessage(hwndDlg, item,
						CB_ADDSTRING,
						(WPARAM) 0,
						(LPARAM) (((LPBYTE) lpTranslateCaps) +
						lpLocationEntry[dwCounter].dwLocationNameOffset));

        // Is this location the 'current' location?
        if (lpLocationEntry[dwCounter].dwPermanentLocationID ==
            lpTranslateCaps->dwCurrentLocationID)
        {
            // Set this to be the active location.
            SendDlgItemMessage(hwndDlg, item, CB_SETCURSEL, (WPARAM) index, (LPARAM) 0);
        }
    }

	if (lpTranslateCaps)
		GlobalFreePtr(lpTranslateCaps);
}


char	gTempStr[200];

LONG lineError(LONG err, LPSTR modName, DWORD lineNum)
{
	if (err)
		DPF(0, "TAPI line error in %s at line %d : %s", modName, lineNum, GetLineErrStr(err));

	return (err);
}

LPSTR GetCallStateStr(DWORD callState)
{
	switch (callState)
	{
	case LINECALLSTATE_IDLE: return ("LINECALLSTATE_IDLE");
	case LINECALLSTATE_OFFERING: return ("LINECALLSTATE_OFFERING");
	case LINECALLSTATE_ACCEPTED: return ("LINECALLSTATE_ACCEPTED");
	case LINECALLSTATE_DIALTONE: return ("LINECALLSTATE_DIALTONE");
	case LINECALLSTATE_DIALING: return ("LINECALLSTATE_DIALING");
	case LINECALLSTATE_RINGBACK: return ("LINECALLSTATE_RINGBACK");
	case LINECALLSTATE_BUSY: return ("LINECALLSTATE_BUSY");
	case LINECALLSTATE_SPECIALINFO: return ("LINECALLSTATE_SPECIALINFO");
	case LINECALLSTATE_CONNECTED: return ("LINECALLSTATE_CONNECTED");
	case LINECALLSTATE_PROCEEDING: return ("LINECALLSTATE_PROCEEDING");
	case LINECALLSTATE_ONHOLD: return ("LINECALLSTATE_ONHOLD");
	case LINECALLSTATE_CONFERENCED: return ("LINECALLSTATE_CONFERENCED");
	case LINECALLSTATE_ONHOLDPENDCONF: return ("LINECALLSTATE_ONHOLDPENDCONF");
	case LINECALLSTATE_ONHOLDPENDTRANSFER: return ("LINECALLSTATE_ONHOLDPENDTRANSFER");
	case LINECALLSTATE_DISCONNECTED: return ("LINECALLSTATE_DISCONNECTED");
	case LINECALLSTATE_UNKNOWN: return ("LINECALLSTATE_UNKNOWN");
	}

	wsprintf(gTempStr, "UNKNOWN CALL STATE = %lu", callState);
	return (gTempStr);
}

LPSTR GetLineMsgStr(DWORD msg)
{
	switch (msg)
	{
	case LINE_ADDRESSSTATE: return ("LINE_ADDRESSSTATE");
	case LINE_CALLINFO: return ("LINE_CALLINFO");
	case LINE_CALLSTATE: return ("LINE_CALLSTATE");
	case LINE_CLOSE: return ("LINE_CLOSE");
	case LINE_DEVSPECIFIC: return ("LINE_DEVSPECIFIC");
	case LINE_DEVSPECIFICFEATURE: return ("LINE_DEVSPECIFICFEATURE");
	case LINE_GATHERDIGITS: return ("LINE_GATHERDIGITS");
	case LINE_GENERATE: return ("LINE_GENERATE");
	case LINE_LINEDEVSTATE: return ("LINE_LINEDEVSTATE");
	case LINE_MONITORDIGITS: return ("LINE_MONITORDIGITS");
	case LINE_MONITORMEDIA: return ("LINE_MONITORMEDIA");
	case LINE_MONITORTONE: return ("LINE_MONITORTONE");
	case LINE_REPLY: return ("LINE_REPLY");
	case LINE_REQUEST: return ("LINE_REQUEST");
	}

	wsprintf(gTempStr, "UNKNOWN LINE MESSAGE = %lu", msg);
	return (gTempStr);
}


LPSTR GetLineErrStr(LONG err)
{
	switch (err)
	{
	case LINEERR_ADDRESSBLOCKED: return ("LINEERR_ADDRESSBLOCKED");
	case LINEERR_ALLOCATED: return ("LINEERR_ALLOCATED");
	case LINEERR_BADDEVICEID: return ("LINEERR_BADDEVICEID");
	case LINEERR_BEARERMODEUNAVAIL: return ("LINEERR_BEARERMODEUNAVAIL");
	case LINEERR_CALLUNAVAIL: return ("LINEERR_CALLUNAVAIL");
	case LINEERR_COMPLETIONOVERRUN: return ("LINEERR_COMPLETIONOVERRUN");
	case LINEERR_CONFERENCEFULL: return ("LINEERR_CONFERENCEFULL");
	case LINEERR_DIALBILLING: return ("LINEERR_DIALBILLING");
	case LINEERR_DIALQUIET: return ("LINEERR_DIALQUIET");
	case LINEERR_DIALDIALTONE: return ("LINEERR_DIALDIALTONE");
	case LINEERR_DIALPROMPT: return ("LINEERR_DIALPROMPT");
	case LINEERR_INCOMPATIBLEAPIVERSION: return ("LINEERR_INCOMPATIBLEAPIVERSION");
	case LINEERR_INCOMPATIBLEEXTVERSION: return ("LINEERR_INCOMPATIBLEEXTVERSION");
	case LINEERR_INIFILECORRUPT: return ("LINEERR_INIFILECORRUPT");
	case LINEERR_INUSE: return ("LINEERR_INUSE");
	case LINEERR_INVALADDRESS: return ("LINEERR_INVALADDRESS");
	case LINEERR_INVALADDRESSID: return ("LINEERR_INVALADDRESSID");
	case LINEERR_INVALADDRESSMODE: return ("LINEERR_INVALADDRESSMODE");
	case LINEERR_INVALADDRESSSTATE: return ("LINEERR_INVALADDRESSSTATE");
	case LINEERR_INVALAPPHANDLE: return ("LINEERR_INVALAPPHANDLE");
	case LINEERR_INVALAPPNAME: return ("LINEERR_INVALAPPNAME");
	case LINEERR_INVALBEARERMODE: return ("LINEERR_INVALBEARERMODE");
	case LINEERR_INVALCALLCOMPLMODE: return ("LINEERR_INVALCALLCOMPLMODE");
	case LINEERR_INVALCALLHANDLE: return ("LINEERR_INVALCALLHANDLE");
	case LINEERR_INVALCALLPARAMS: return ("LINEERR_INVALCALLPARAMS");
	case LINEERR_INVALCALLPRIVILEGE: return ("LINEERR_INVALCALLPRIVILEGE");
	case LINEERR_INVALCALLSELECT: return ("LINEERR_INVALCALLSELECT");
	case LINEERR_INVALCALLSTATE: return ("LINEERR_INVALCALLSTATE");
	case LINEERR_INVALCALLSTATELIST: return ("LINEERR_INVALCALLSTATELIST");
	case LINEERR_INVALCARD: return ("LINEERR_INVALCARD");
	case LINEERR_INVALCOMPLETIONID: return ("LINEERR_INVALCOMPLETIONID");
	case LINEERR_INVALCONFCALLHANDLE: return ("LINEERR_INVALCONFCALLHANDLE");
	case LINEERR_INVALCONSULTCALLHANDLE: return ("LINEERR_INVALCONSULTCALLHANDLE");
	case LINEERR_INVALCOUNTRYCODE: return ("LINEERR_INVALCOUNTRYCODE");
	case LINEERR_INVALDEVICECLASS: return ("LINEERR_INVALDEVICECLASS");
	case LINEERR_INVALDIGITLIST: return ("LINEERR_INVALDIGITLIST");
	case LINEERR_INVALDIGITMODE: return ("LINEERR_INVALDIGITMODE");
	case LINEERR_INVALDIGITS: return ("LINEERR_INVALDIGITS");
	case LINEERR_INVALFEATURE: return ("LINEERR_INVALFEATURE");
	case LINEERR_INVALGROUPID: return ("LINEERR_INVALGROUPID");
	case LINEERR_INVALLINEHANDLE: return ("LINEERR_INVALLINEHANDLE");
	case LINEERR_INVALLINESTATE: return ("LINEERR_INVALLINESTATE");
	case LINEERR_INVALLOCATION: return ("LINEERR_INVALLOCATION");
	case LINEERR_INVALMEDIALIST: return ("LINEERR_INVALMEDIALIST");
	case LINEERR_INVALMEDIAMODE: return ("LINEERR_INVALMEDIAMODE");
	case LINEERR_INVALMESSAGEID: return ("LINEERR_INVALMESSAGEID");
	case LINEERR_INVALPARAM: return ("LINEERR_INVALPARAM");
	case LINEERR_INVALPARKMODE: return ("LINEERR_INVALPARKMODE");
	case LINEERR_INVALPOINTER: return ("LINEERR_INVALPOINTER");
	case LINEERR_INVALPRIVSELECT: return ("LINEERR_INVALPRIVSELECT");
	case LINEERR_INVALRATE: return ("LINEERR_INVALRATE");
	case LINEERR_INVALREQUESTMODE: return ("LINEERR_INVALREQUESTMODE");
	case LINEERR_INVALTERMINALID: return ("LINEERR_INVALTERMINALID");
	case LINEERR_INVALTERMINALMODE: return ("LINEERR_INVALTERMINALMODE");
	case LINEERR_INVALTIMEOUT: return ("LINEERR_INVALTIMEOUT");
	case LINEERR_INVALTONE: return ("LINEERR_INVALTONE");
	case LINEERR_INVALTONELIST: return ("LINEERR_INVALTONELIST");
	case LINEERR_INVALTONEMODE: return ("LINEERR_INVALTONEMODE");
	case LINEERR_INVALTRANSFERMODE: return ("LINEERR_INVALTRANSFERMODE");
	case LINEERR_LINEMAPPERFAILED: return ("LINEERR_LINEMAPPERFAILED");
	case LINEERR_NOCONFERENCE: return ("LINEERR_NOCONFERENCE");
	case LINEERR_NODEVICE: return ("LINEERR_NODEVICE");
	case LINEERR_NODRIVER: return ("LINEERR_NODRIVER");
	case LINEERR_NOMEM: return ("LINEERR_NOMEM");
	case LINEERR_NOMULTIPLEINSTANCE: return ("LINEERR_NOMULTIPLEINSTANCE");
	case LINEERR_NOREQUEST: return ("LINEERR_NOREQUEST");
	case LINEERR_NOTOWNER: return ("LINEERR_NOTOWNER");
	case LINEERR_NOTREGISTERED: return ("LINEERR_NOTREGISTERED");
	case LINEERR_OPERATIONFAILED: return ("LINEERR_OPERATIONFAILED");
	case LINEERR_OPERATIONUNAVAIL: return ("LINEERR_OPERATIONUNAVAIL");
	case LINEERR_RATEUNAVAIL: return ("LINEERR_RATEUNAVAIL");
	case LINEERR_REINIT: return ("LINEERR_REINIT");
	case LINEERR_RESOURCEUNAVAIL: return ("LINEERR_RESOURCEUNAVAIL");
	case LINEERR_STRUCTURETOOSMALL: return ("LINEERR_STRUCTURETOOSMALL");
	case LINEERR_TARGETNOTFOUND: return ("LINEERR_TARGETNOTFOUND");
	case LINEERR_TARGETSELF: return ("LINEERR_TARGETSELF");
	case LINEERR_UNINITIALIZED: return ("LINEERR_UNINITIALIZED");
	case LINEERR_USERUSERINFOTOOBIG: return ("LINEERR_USERUSERINFOTOOBIG");
	}

	wsprintf(gTempStr, "UNKNOWN LINE ERROR = %ld", err);
	return (gTempStr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\serial\macros.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       macros.c
 *  Content:	debugging macros
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  6/10/96	kipo	created it
 *@@END_MSINTERNAL
 ***************************************************************************/

#include "dpf.h"

#define FAILMSG(condition) \
	if ((condition)) { \
		DPF(0, DPF_MODNAME " line %d : Failed because " #condition "", __LINE__); \
	}

#define FAILERR(err, label) \
	if ((err)) { \
		DPF(0, DPF_MODNAME " line %d : Error = %d", __LINE__, (err)); \
		goto label; \
	}

#define FAILIF(condition, label) \
	if ((condition)) { \
		DPF(0, DPF_MODNAME " line %d : Failed because " #condition "", __LINE__); \
		goto label; \
	}

#define FAILWITHACTION(condition, action, label) \
	if ((condition)) { \
		DPF(0, DPF_MODNAME " line %d : Failed because " #condition "", __LINE__); \
		{ action; } \
		goto label; \
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\bilink.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.C

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/
#include <windows.h>
#include "dpsp.h"
#include <dpf.h>
#include "bilink.h"

// Note: serialization of access to BILINK structures must 
//       take place in the calling code.  Operations are
//       not intrinsically atomic.

#ifdef DEBUG
int FindObject(
    BILINK *link,
    BILINK *list
    )
{
    BILINK *p = list->next;
    while(p != link && p != list)
        p= p->next;
    return (p==link);
}
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    )
/*=========================================================================
 *  Description:
 *      Insert an object after a specified object in the doubly linked list.
 *      The after object could be the Head BILINK for adding to the head of a
 *      queue.
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,after)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = after->next;
    in->prev = after;
    after->next->prev = in;
    after->next = in;
}

void InsertBefore(
     BILINK *in,
     BILINK *before
    )
/*=========================================================================
 *  Description:
 * Inserts an  object before a specified object in the doubly linked list.
 * The before object could be the Head BILINK for adding to the end
 * of the queue
 * CALLED WITH INTERRUPTS_OFF
 *
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,before)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = before;
    in->prev = before->prev;
    before->prev->next = in;
    before->prev = in;
}

void Delete(
     BILINK *p
)
/*=========================================================================
 *  Description:
 *
 * Delete a  object from a doubly linked list. Make sure it IS on a list!
 * CALLED WITH INTERRUPTS OFF (must be atomic).
 *
 *  Returns:
 *
 */
{
    ASSERT(p && p->prev && p->next);
    ASSERT(p->prev->next == p && p->next->prev == p);
    p->next->prev = p->prev;
    p->prev->next = p->next;
    // p->next = p->prev = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\bilink.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.H

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/// BILINK.H

#ifndef _BILINK_

#define _BILINK_

#if !defined(offsetof)
	#define offsetof(type, field) ((int)(&((type *)0)->field))
#endif	

typedef struct BILINK {
    struct BILINK *next;
    struct BILINK *prev;
} BILINK;

/* XLATOFF */

#define EMPTY_BILINK(_pBilink) ((_pBilink)->next==(_pBilink))

#ifdef DEBUG
    #define ASSERT_EMPTY_BILINK(_b) ASSERT((_b)->next==(_b))
#else
    #define ASSERT_EMPTY_BILINK(_b)
#endif

// This only works for BILINKS that are the first item in a structure.
#define BilinkToList( _pBilink ) \
	(_pBilink)->prev->next=NULL;

#define InitBilink( _pBilink ) \
    (_pBilink)->prev=(_pBilink)->next=(_pBilink);

#ifdef DEBUG

int FindObject(
    BILINK *link,
    BILINK *list
    );
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    );

void InsertBefore(
     BILINK *in,
     BILINK *before
    );

void Delete(
     BILINK *p
);

/* XLATON */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPWSOCK"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\serial\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dpserial.rc
//
#define IDS_COM1                        1
#define IDS_COM2                        2
#define IDS_COM3                        3
#define IDS_COM4                        4
#define IDS_BAUD1                       16
#define IDS_BAUD2                       17
#define IDS_BAUD3                       18
#define IDS_BAUD4                       19
#define IDS_BAUD5                       20
#define IDS_BAUD6                       21
#define IDS_BAUD7                       22
#define IDS_BAUD8                       23
#define IDS_BAUD9                       24
#define IDS_BAUD10                      25
#define IDS_BAUD11                      26
#define IDS_BAUD12                      27
#define IDS_BAUD13                      28
#define IDS_BAUD14                      29
#define IDS_BAUD15                      30
#define IDS_STOPBIT1                    32
#define IDS_STOPBIT2                    33
#define IDS_STOPBIT3                    34
#define IDS_PARITY1                     35
#define IDS_PARITY2                     36
#define IDS_PARITY3                     37
#define IDS_PARITY4                     38
#define IDS_FLOW1                       39
#define IDS_FLOW2                       40
#define IDS_FLOW3                       41
#define IDS_FLOW4                       42
#define IDS_FLOW5                       43
#define IDS_COULDNOTOPENLINE            44
#define IDS_WAITINGFORCONNECTION        45
#define IDS_DIALING                     46
#define IDS_COULDNOTDIAL                47
#define IDD_MODEM_DIAL                  101
#define IDD_MODEM_STATUS                102
#define IDD_MODEMDIALOG                 103
#define IDD_SETTINGSDIALOG              300
#define IDD_MODEM_ANSWER                301
#define IDI_MODEM                       701
#define IDC_BAUDRATE                    1000
#define IDC_NUMBEREDIT                  1000
#define IDC_STOPBITS                    1001
#define IDC_PARITY                      1002
#define IDC_COMPORT                     1003
#define IDC_FLOW                        1009
#define IDC_NUMBER                      1009
#define IDC_DIALPROPERTIES              1010
#define IDC_DIALINGFROM                 1012
#define IDC_MODEM                       1013
#define IDC_CONFIGUREMODEM              1014
#define IDC_STATUS                      1017

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\serial\modem.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       modem.c
 *  Content:	Routines for modem I/O
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  6/10/96	kipo	created it
 *  6/22/96	kipo	added support for EnumConnectionData(); dim "OK" button
 *					until user types at least one character.
 *	6/25/96	kipo	updated for DPADDRESS
 *	7/08/96 kipo	added support for new dialogs
 *  7/13/96	kipo	added GetModemAddress()
 *	7/16/96	kipo	changed address types to be GUIDs instead of 4CC
 *	8/10/96 kipo	added support for dialing location
 *	8/15/96 kipo	commented out support for dialing location
 *  9/04/96 dereks  fixed focus in dial/answer dialogs
 *  1/06/97 kipo	updated for objects
 *  2/11/97 kipo	pass player flags to GetAddress()
 *  2/18/97 kipo	allow multiple instances of service provider
 *	3/04/97 kipo	close com port handle when deallocating call; use string
 *					table for modem strings; updated debug output.
 *	3/17/97 kipo	added support for Unicode phone numbers
 *	3/24/97 kipo	added support for specifying which modem to use
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/07/97 kipo	added support for modem choice list
 *  5/23/97 kipo	added support return status codes
 *  5/25/97 kipo	use DPERR_CONNECTING error to return status; set focus
 *					on cancel button in status window
 *  6/03/97 kipo	really make the cancel button work with return
 *  2/01/98 kipo	Display an error string in status dialog if line goes
 *					idle while dialing. Fixes bug #15251
 *  5/08/98 a-peterz #15251 - Better error state detection
 * 10/13/99	johnkan	#413516 - Mismatch between modem dialog selection and TAPI device ID
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>

#include "dplaysp.h"
#include "dputils.h"
#include "dial.h"
#include "dpf.h"
#include "resource.h"

// constants

enum {
	PHONENUMBERSIZE = 200,				// size of phone number string
	MODEMNAMESIZE = 200,				// size of modem name string
	TEMPSTRINGSIZE = 300,				// size of temporary strings
	MODEMTIMEOUT = 30 * 1000,			// milliseconds to wait for phone to connect
	MODEMSLEEPTIME = 50,				// milliseconds to sleep while waiting for modem
	TIMERINTERVAL = 100,
	MAXPHONENUMBERS = 10
};

// bit masks used to select connection actions
enum {
	DIALCALL		= (0 << 0),			// make a call
	ANSWERCALL		= (1 << 0),			// answer a call

	NOSETTINGS		= (0 << 1),			// no phone settings are set
	HAVESETTINGS	= (1 << 1),			// phone settings are set

	STATUSDIALOG	= (0 << 2),			// show a connection status dialog
	RETURNSTATUS	= (1 << 2)			// return status to app
};

#define MRU_SP_KEY			L"Modem Connection For DirectPlay"
#define MRU_NUMBER_KEY		L"Phone Number"

// structures

// modem object
typedef struct {
	DPCOMPORT	comPort;				// base object globals
	LPDPDIAL	lpDial;					// dialing globals
	BOOL		bHaveSettings;			// set to TRUE if we have settings
	BOOL		bAnswering;				// set to TRUE if we are answering
	DWORD		dwDeviceID;				// device id to use
	DWORD		dwLocation;				// location to use
	TCHAR		szPhoneNumber[PHONENUMBERSIZE];	// phone number to use
} DPMODEM, *LPDPMODEM;

// globals

// this is defined in dllmain.c
extern HINSTANCE		ghInstance;

// this is defined in dpserial.c
extern GUID				DPMODEM_GUID;

// prototypes

static HRESULT			DisposeModem(LPDPCOMPORT baseObject);
static HRESULT			ConnectModem(LPDPCOMPORT baseObject, BOOL bWaitForConnection, BOOL bReturnStatus);
static HRESULT			DisconnectModem(LPDPCOMPORT baseObject);
static HRESULT			GetModemBaudRate(LPDPCOMPORT baseObject, LPDWORD lpdwBaudRate);
static HRESULT			GetModemAddress(LPDPCOMPORT baseObject, DWORD dwPlayerFlags,
										LPVOID lpAddress, LPDWORD lpdwAddressSize);

static BOOL FAR PASCAL	EnumAddressData(REFGUID lpguidDataType, DWORD dwDataSize,
										LPCVOID lpData, LPVOID lpContext);
static HRESULT			GetModemAddressChoices(LPDPCOMPORT baseObject,
								LPVOID lpAddress, LPDWORD lpdwAddressSize);
static BOOL FAR PASCAL	EnumMRUPhoneNumbers(LPCVOID lpData, DWORD dwDataSize, LPVOID lpContext);
static void				UpdateButtons(HWND hWnd);

BOOL					DoDialSetup(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals);
BOOL					DoDial(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals);
BOOL					DoAnswerSetup(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals);
BOOL					DoAnswer(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals);
HRESULT					DoDialStatus(LPDPMODEM globals);
HRESULT					DoAnswerStatus(LPDPMODEM globals);

/*
 * NewModem
 *
 * Create new modem object. Open TAPI and verify there are lines available.
 */

HRESULT NewModem(LPVOID lpConnectionData, DWORD dwConnectionDataSize,
				 LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
				 LPDPCOMPORT *storage)
{
	LPDPCOMPORT baseObject;
	LPDPMODEM	globals;
	LINERESULT	lResult;
	HRESULT		hr;

	// create base object with enough space for our globals
	hr = NewComPort(sizeof(DPMODEM), lpDPlay, lpReadRoutine, &baseObject);
	if FAILED(hr)
		return (hr);

	// fill in methods we implement
	baseObject->Dispose = DisposeModem;
	baseObject->Connect = ConnectModem;
	baseObject->Disconnect = DisconnectModem;
	baseObject->GetBaudRate = GetModemBaudRate;
	baseObject->GetAddress = GetModemAddress;
	baseObject->GetAddressChoices = GetModemAddressChoices;

	globals = (LPDPMODEM) baseObject;

	// initialize TAPI
	lResult = dialInitialize(ghInstance, TEXT("TapiSP"), (LPDPCOMPORT) globals, &globals->lpDial);
	if (lResult)
	{
		hr = DPERR_UNAVAILABLE;
		goto Failure;
	}

	// check for valid connection data
	if (lpConnectionData)
	{
		baseObject->lpDPlay->lpVtbl->EnumAddress(baseObject->lpDPlay, EnumAddressData,
									lpConnectionData, dwConnectionDataSize,
									globals);
	}

	// return object pointer
	*storage = baseObject;

	return (DP_OK);

Failure:
	DisposeModem(baseObject);

	return (hr);
}

/*
 * EnumConnectionData
 *
 * Search for valid connection data
 */

static BOOL FAR PASCAL EnumAddressData(REFGUID lpguidDataType, DWORD dwDataSize,
							LPCVOID lpData, LPVOID lpContext)
{
	LPDPMODEM	globals = (LPDPMODEM) lpContext;
	CHAR		szModemName[MODEMNAMESIZE];

	// this is an ANSI phone number
	if ((IsEqualGUID(lpguidDataType, &DPAID_Phone)) &&
		(dwDataSize) )
	{
		// make sure there is room (for terminating null too)
		if (dwDataSize > (PHONENUMBERSIZE - 1))
			dwDataSize = (PHONENUMBERSIZE - 1);
		CopyMemory(globals->szPhoneNumber, lpData, dwDataSize);

		globals->bHaveSettings = TRUE;		// we have a phone number
	}

	// this is an UNICODE phone number
	else if ((IsEqualGUID(lpguidDataType, &DPAID_PhoneW)) &&
			 (dwDataSize) )
	{
		if (WideToAnsi(globals->szPhoneNumber, (LPWSTR) lpData, PHONENUMBERSIZE))
			globals->bHaveSettings = TRUE;	// we have a phone number
	}

	// this is an ANSI modem name
	else if ((IsEqualGUID(lpguidDataType, &DPAID_Modem)) &&
			 (dwDataSize) )
	{
		// search modem list for this name
		if (dialGetDeviceIDFromName(globals->lpDial, lpData, &globals->dwDeviceID) == SUCCESS)
			globals->bHaveSettings = TRUE;	// can answer the phone
	}

	// this is a UNICODE modem name
	else if ((IsEqualGUID(lpguidDataType, &DPAID_ModemW)) &&
			 (dwDataSize) )
	{
		// search modem list for this name
		if (WideToAnsi(szModemName, (LPWSTR) lpData, MODEMNAMESIZE))
		{
			if (dialGetDeviceIDFromName(globals->lpDial, szModemName, &globals->dwDeviceID) == SUCCESS)
				globals->bHaveSettings = TRUE;	// we have a phone number
		}
	}

	return (TRUE);
}

/*
 * DisposeModem
 *
 * Dispose modem object.
 */

static HRESULT DisposeModem(LPDPCOMPORT baseObject)
{
	LPDPMODEM	globals = (LPDPMODEM) baseObject;
	LPDPDIAL	lpDial = globals->lpDial;
	LINERESULT	lResult;

	// shut down modem
	if (lpDial)
		lResult = dialShutdown(lpDial);

	// free object
	GlobalFreePtr((HGLOBAL) baseObject);

	return (DP_OK);
}

/*
 * ConnectModem
 *
 * Dial number based on user settings.
 */

static HRESULT ConnectModem(LPDPCOMPORT baseObject,
							BOOL bWaitForConnection, BOOL bReturnStatus)
{
	LPDPMODEM	globals = (LPDPMODEM) baseObject;
	LPDPDIAL	lpDial = globals->lpDial;
	DWORD		dwFeatures;
	BOOL		bResult;
	HRESULT		hr;

	// dial object has not been created?
	if (lpDial == NULL)
		return (DPERR_INVALIDPARAM);

	// are we already connected?
	if (dialIsConnected(lpDial))
		return (DP_OK);

	// remember if we are answering or not
	globals->bAnswering = bWaitForConnection;

	dwFeatures = 0;

	if (globals->bAnswering)
		dwFeatures |= ANSWERCALL;

	if (globals->bHaveSettings)
		dwFeatures |= HAVESETTINGS;

	if (bReturnStatus)
		dwFeatures |= RETURNSTATUS;

	hr = DP_OK;

	switch (dwFeatures)
	{
		case (STATUSDIALOG | NOSETTINGS   | DIALCALL):

			bResult = DoDialSetup(ghInstance, GetForegroundWindow(), globals);
			if (!bResult)
				goto FAILURE;

			globals->bHaveSettings = TRUE;
			break;

		case (STATUSDIALOG | NOSETTINGS   | ANSWERCALL):

			bResult = DoAnswerSetup(ghInstance, GetForegroundWindow(), globals);
			if (!bResult)
				goto FAILURE;

			globals->bHaveSettings = TRUE;
			break;

		case (STATUSDIALOG | HAVESETTINGS | DIALCALL):

			bResult = DoDial(ghInstance, GetForegroundWindow(), globals);
			if (!bResult)
				goto FAILURE;
			break;

		case (STATUSDIALOG | HAVESETTINGS | ANSWERCALL):

			bResult = DoAnswer(ghInstance, GetForegroundWindow(), globals);
			if (!bResult)
				goto FAILURE;
			break;

		case (RETURNSTATUS   | NOSETTINGS   | DIALCALL):
		case (RETURNSTATUS   | NOSETTINGS   | ANSWERCALL):

			DPF(0, "Invalid flags - no phone number or modem specified");
			hr = DPERR_INVALIDPARAM;
			break;

		case (RETURNSTATUS   | HAVESETTINGS | DIALCALL):

			hr = DoDialStatus(globals);
			break;

		case (RETURNSTATUS   | HAVESETTINGS | ANSWERCALL):

			hr = DoAnswerStatus(globals);
			break;
	}

	return (hr);

FAILURE:
	DisconnectModem(baseObject);

	return (DPERR_USERCANCEL);
}

/*
 * DisconnectModem
 *
 * Hang up any call in progress.
 */

static HRESULT DisconnectModem(LPDPCOMPORT baseObject)
{
	LPDPMODEM	globals = (LPDPMODEM) baseObject;
	LPDPDIAL	lpDial = globals->lpDial;

	// dial object has not been created?
	if (lpDial == NULL)
		return (DPERR_INVALIDPARAM);

	// disconnect the call
	dialDropCall(lpDial);
	dialDeallocCall(lpDial);
	dialLineClose(lpDial);

	return (DP_OK);
}

/*
 * GetModemAddress
 *
 * Return current modem address if available.
 */

static HRESULT GetModemAddress(LPDPCOMPORT baseObject, DWORD dwPlayerFlags,
							   LPVOID lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPMODEM					globals = (LPDPMODEM) baseObject;
	LPDPDIAL					lpDial = globals->lpDial;
	WCHAR						szPhoneNumberW[PHONENUMBERSIZE];
	DPCOMPOUNDADDRESSELEMENT	addressElements[3];
	HRESULT						hr;

	// no settings?
	if (!globals->bHaveSettings)
		return (DPERR_UNAVAILABLE);

	// dial object has not been created?
	if (lpDial == NULL)
		return (DPERR_UNAVAILABLE);

	// not connected?
	if (!dialIsConnected(lpDial))
		return (DPERR_UNAVAILABLE);

	// if we answered there is no way for us to know a phone number
	if (globals->bAnswering)
		return (DPERR_UNAVAILABLE);

	// we can't know the phone number of local players, only remote players
	if (dwPlayerFlags & DPLAYI_PLAYER_PLAYERLOCAL)
		return (DPERR_UNAVAILABLE);

	// get UNICODE version of phone number
	if (!AnsiToWide(szPhoneNumberW, globals->szPhoneNumber, PHONENUMBERSIZE))
		return (DPERR_GENERIC);

	// service provider chunk
	addressElements[0].guidDataType = DPAID_ServiceProvider;
	addressElements[0].dwDataSize = sizeof(GUID);
	addressElements[0].lpData = &DPMODEM_GUID;

	// ANSI phone number
	addressElements[1].guidDataType = DPAID_Phone;
	addressElements[1].dwDataSize = lstrlen(globals->szPhoneNumber) + 1;
	addressElements[1].lpData = globals->szPhoneNumber;

	// UNICODE phone number
	addressElements[2].guidDataType = DPAID_PhoneW;
	addressElements[2].dwDataSize = (lstrlen(globals->szPhoneNumber) + 1) * sizeof(WCHAR);
	addressElements[2].lpData = szPhoneNumberW;

	// create the address
	hr = baseObject->lpDPlay->lpVtbl->CreateCompoundAddress(baseObject->lpDPlay,
						addressElements, 3,
						lpAddress, lpdwAddressSize);
	return (hr);
}

/*
 * GetModemAddressChoices
 *
 * Return modem address choices
 */

static HRESULT GetModemAddressChoices(LPDPCOMPORT baseObject,
					LPVOID lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPMODEM					globals = (LPDPMODEM) baseObject;
	LPDPDIAL					lpDial = globals->lpDial;
	DPCOMPOUNDADDRESSELEMENT	addressElements[3];
	LINERESULT					lResult;
	HRESULT						hr;

	// dial object has not been created?
	if (lpDial == NULL)
		return (DPERR_UNAVAILABLE);

	ZeroMemory(addressElements, sizeof(addressElements));

	// service provider chunk
	addressElements[0].guidDataType = DPAID_ServiceProvider;
	addressElements[0].dwDataSize = sizeof(GUID);
	addressElements[0].lpData = &DPMODEM_GUID;

	// get ANSI modem name list
	addressElements[1].guidDataType = DPAID_Modem;
	lResult = dialGetModemList(lpDial, TRUE,
					&addressElements[1].lpData,
					&addressElements[1].dwDataSize);
	if (lResult)
	{
		hr = DPERR_OUTOFMEMORY;
		goto Failure;
	}

	// Unicode modem name list
	addressElements[2].guidDataType = DPAID_ModemW;
	lResult = dialGetModemList(lpDial, FALSE,
					&addressElements[2].lpData,
					&addressElements[2].dwDataSize);
	if (lResult)
	{
		hr = DPERR_OUTOFMEMORY;
		goto Failure;
	}

	// create the address
	hr = baseObject->lpDPlay->lpVtbl->CreateCompoundAddress(baseObject->lpDPlay,
						addressElements, 3,
						lpAddress, lpdwAddressSize);

Failure:
	if (addressElements[1].lpData)
		GlobalFreePtr(addressElements[1].lpData);
	if (addressElements[2].lpData)
		GlobalFreePtr(addressElements[2].lpData);

	return (hr);

}

/*
 * GetModemBaudRate
 *
 * Get baud rate of modem connnection.
 */

static HRESULT GetModemBaudRate(LPDPCOMPORT baseObject, LPDWORD lpdwBaudRate)
{
	LPDPMODEM	globals = (LPDPMODEM) baseObject;
	LPDPDIAL	lpDial = globals->lpDial;
	LINERESULT	lResult;

	lResult = dialGetBaudRate(lpDial, lpdwBaudRate);

	if (lResult == SUCCESS)
		return (DP_OK);
	else
		return (DPERR_UNAVAILABLE);
}

// Local prototypes
INT_PTR CALLBACK DialSetupWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AnswerSetupWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ModemStatusWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

void ChangeDialingProperties(HWND hWnd, LPDPDIAL lpDial);
void ConfigureModem(HWND hWnd);
void CenterWindow(HWND, HWND);


// ---------------------------------------------------------------------------
// DoDialSetup
// ---------------------------------------------------------------------------
// Description:             Gets modem setup information from the user.
// Arguments:
//  HINSTANCE               [in] Instance handle to load resources from.
//  HWND                    [in] Parent window handle.
//  LPDPMODEM				[in] modem globals
// Returns:
//  BOOL                    TRUE on success.
BOOL DoDialSetup(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals)
{
	INT_PTR	iResult;

    iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MODEM_DIAL), hWndParent, DialSetupWndProc, (LPARAM) globals);
	return (iResult > 0);
}


// ---------------------------------------------------------------------------
// DialSetupWndProc
// ---------------------------------------------------------------------------
// Description:             Message callback function for dial setup dialog.
// Arguments:
//  HWND                    [in] Dialog window handle.
//  UINT                    [in] Window message identifier.
//  WPARAM                  [in] Depends on message.
//  LPARAM                  [in] Depends on message.
// Returns:
//  BOOL                    TRUE if message was processed internally.
INT_PTR CALLBACK DialSetupWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPDPMODEM	globals = (LPDPMODEM) GetWindowLongPtr(hWnd, DWLP_USER);

    switch(uMsg)
    {
        case WM_INITDIALOG:
			// modem info pointer passed in lParam
			globals = (LPDPMODEM) lParam;

             // save the globals with the window
			SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR)globals);

			// Center over the parent window
            CenterWindow(hWnd, GetParent(hWnd));

/*			gDPlay->lpVtbl->EnumMRUEntries(gDPlay,
								MRU_SP_KEY, MRU_NUMBER_KEY,
								EnumMRUPhoneNumbers, (LPVOID) hWnd);
*/
			if (lstrlen(globals->szPhoneNumber))
				SetDlgItemText(hWnd, IDC_NUMBER, globals->szPhoneNumber);
/*			else
				SendDlgItemMessage(hWnd,
									IDC_NUMBER,
									CB_SETCURSEL,
									(WPARAM) 0,
									(LPARAM) 0);
*/
/*			SendDlgItemMessage(hWnd,
							   IDC_NUMBER,
							   CB_SETCURSEL,
							   (WPARAM) 0,
							   (LPARAM) 0);
*/
            // initialize the modem selection combo box
			dialFillModemComboBox(globals->lpDial, hWnd, IDC_MODEM, globals->dwDeviceID);

			// initialize location combo box
//			dialFillLocationComboBox(lpModemInfo->lpDial, hWnd, IDC_DIALINGFROM, gModemSettings.dwLocation);
			UpdateButtons(hWnd);

            // Set focus so Derek won't have a cow
            SetFocus(GetDlgItem(hWnd, IDC_NUMBER));

            break;

        case WM_DESTROY:
            // Return failure
            EndDialog(hWnd, FALSE);

            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_NUMBER:
					switch (HIWORD(wParam))
					{
					case EN_CHANGE:
//					case CBN_EDITCHANGE:
						UpdateButtons(hWnd);
						break;
					}
                    break;
/*
                case IDC_DIALPROPERTIES:

					ChangeDialingProperties(hWnd, lpModemInfo->lpDial);
					dialFillLocationComboBox(lpModemInfo->lpDial, hWnd, IDC_DIALINGFROM, gModemSettings.dwLocation);

                    break;
*/
                case IDC_CONFIGUREMODEM:

					ConfigureModem(hWnd);

                    break;

				case IDOK:
				{
					DWORD	dwModemSelection;


                    // Gather dialing info

					// Get phone number
					GetDlgItemText(hWnd, IDC_NUMBER, globals->szPhoneNumber, PHONENUMBERSIZE);

					//
					// get current modem selection and then get the assoicated
					// TAPI modem ID
					//
					dwModemSelection = (DWORD)SendDlgItemMessage(hWnd,
													IDC_MODEM,
													CB_GETCURSEL,
													(WPARAM) 0,
													(LPARAM) 0);
					DDASSERT( dwModemSelection != CB_ERR );

					globals->dwDeviceID = (DWORD)SendDlgItemMessage(hWnd,
													IDC_MODEM,
													CB_GETITEMDATA,
													(WPARAM) dwModemSelection,
													(LPARAM) 0);
					DDASSERT( globals->dwDeviceID != CB_ERR );

/*					if (lstrlen(gModemSettings.szPhoneNumber))
					{
						gDPlay->lpVtbl->AddMRUEntry(gDPlay,
											MRU_SP_KEY, MRU_NUMBER_KEY,
											gModemSettings.szPhoneNumber, lstrlen(gModemSettings.szPhoneNumber),
											MAXPHONENUMBERS);
					}
*/
                    // Dial...
					if (DoDial(ghInstance, hWnd, globals))
	                    EndDialog(hWnd, TRUE);

					break;
				}

                case IDCANCEL:
                    // Return failure
                    EndDialog(hWnd, FALSE);

                    break;
            }

            break;
    }

    // Allow for default processing
    return FALSE;
}

// ---------------------------------------------------------------------------
// DoDial
// ---------------------------------------------------------------------------
// Description:             Dials the modem
// Arguments:
//  HINSTANCE               [in] Instance handle to load resources from.
//  HWND                    [in] Parent window handle.
//  LPDPMODEM				[in] modem globals
// Returns:
//  BOOL                    TRUE on success.
BOOL DoDial(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals)
{
	INT_PTR	iResult;

    iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MODEM_STATUS), hWndParent, ModemStatusWndProc, (LPARAM) globals);
	return (iResult > 0);
}

// ---------------------------------------------------------------------------
// DoAnswerSetup
// ---------------------------------------------------------------------------
// Description:             Gets modem setup information from the user.
// Arguments:
//  HINSTANCE               [in] Instance handle to load resources from.
//  HWND                    [in] Parent window handle.
//  LPDPMODEM				[in] modem globals
// Returns:
//  BOOL                    TRUE on success.
BOOL DoAnswerSetup(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals)
{
	INT_PTR	iResult;

	iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MODEM_ANSWER), hWndParent, AnswerSetupWndProc, (LPARAM) globals);
	return (iResult > 0);
}

// ---------------------------------------------------------------------------
// AnswerSetupWndProc
// ---------------------------------------------------------------------------
// Description:             Message callback function for modem setup dialog.
// Arguments:
//  HWND                    [in] Dialog window handle.
//  UINT                    [in] Window message identifier.
//  WPARAM                  [in] Depends on message.
//  LPARAM                  [in] Depends on message.
// Returns:
//  BOOL                    TRUE if message was processed internally.
INT_PTR CALLBACK AnswerSetupWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPDPMODEM	globals = (LPDPMODEM) GetWindowLongPtr(hWnd, DWLP_USER);

    switch(uMsg)
    {
		case WM_INITDIALOG:
			// modem info pointer passed in lParam
			globals = (LPDPMODEM) lParam;

             // save the globals with the window
			SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR) globals);

            // Center over the parent window
            CenterWindow(hWnd, GetParent(hWnd));

            // Initialize the modem selection combo box
			dialFillModemComboBox(globals->lpDial, hWnd, IDC_MODEM, globals->dwDeviceID);

            // Set focus so Derek won't have a cow
            SetFocus(GetDlgItem(hWnd, IDC_MODEM));

            break;

        case WM_DESTROY:
            // Return failure
            EndDialog(hWnd, FALSE);

            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_CONFIGUREMODEM:
					ConfigureModem(hWnd);

                    break;

				case IDOK:
				{
					DWORD	dwModemSelection;


					//
					// Get the current selection and then the associated TAPI
					// modem ID.
					//
					dwModemSelection = (DWORD)SendDlgItemMessage(hWnd,
													IDC_MODEM,
													CB_GETCURSEL,
													(WPARAM) 0,
													(LPARAM) 0);

					globals->dwDeviceID = (DWORD)SendDlgItemMessage(hWnd,
													IDC_MODEM,
													CB_GETITEMDATA,
													(WPARAM) dwModemSelection,
													(LPARAM) 0);

                    // Answer...
					if (DoAnswer(ghInstance, hWnd, globals))
	                    EndDialog(hWnd, TRUE);

                    break;
				}

                case IDCANCEL:
                    // Return failure
                    EndDialog(hWnd, FALSE);

                    break;
            }

            break;
    }

    // Allow for default processing
    return FALSE;
}


// ---------------------------------------------------------------------------
// DoAnswer
// ---------------------------------------------------------------------------
// Description:             Answers the modem
// Arguments:
//  HINSTANCE               [in] Instance handle to load resources from.
//  HWND                    [in] Parent window handle.
//  LPDPMODEM				[in] modem globals
// Returns:
//  BOOL                    TRUE on success.
BOOL DoAnswer(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals)
{
	INT_PTR	iResult;

    iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MODEM_STATUS), hWndParent, ModemStatusWndProc, (LPARAM) globals);
	return (iResult > 0);
}

// ---------------------------------------------------------------------------
// ModemStatusWndProc
// ---------------------------------------------------------------------------
// Description:             Message callback function for dial setup dialog.
// Arguments:
//  HWND                    [in] Dialog window handle.
//  UINT                    [in] Window message identifier.
//  WPARAM                  [in] Depends on message.
//  LPARAM                  [in] Depends on message.
// Returns:
//  BOOL                    TRUE if message was processed internally.
INT_PTR CALLBACK ModemStatusWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPDPMODEM		globals = (LPDPMODEM) GetWindowLongPtr(hWnd, DWLP_USER);
	static UINT_PTR	uTimer = 0; /* timer identifier */
	LINERESULT		lResult;
	TCHAR			szStr[TEMPSTRINGSIZE];	// temp string
	TCHAR			szTableStr[TEMPSTRINGSIZE];	// temp string

    switch(uMsg)
    {
        case WM_INITDIALOG:
			// modem info pointer passed in lParam
			globals = (LPDPMODEM) lParam;

             // save the globals with the window
			SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR) globals);

            // Center over the parent window
            CenterWindow(hWnd, GetParent(hWnd));

			// Set focus so Allen won't have a cow
            SetFocus(GetDlgItem(hWnd, IDCANCEL));

			// make sure line is closed
			if (globals->lpDial->hLine)
				dialLineClose(globals->lpDial);

			// open a line
			lResult = dialLineOpen(globals->lpDial, globals->dwDeviceID);
			if (lResult)
			{
				// line would not open, so show an error
				if (LoadString(ghInstance, IDS_COULDNOTOPENLINE, szStr, sizeof(szStr)))
					SetDlgItemText(hWnd, IDC_STATUS, szStr);
				break;
			}

			if (globals->bAnswering)
			{
				// already have settings, so just exit
				if (globals->bHaveSettings)
					EndDialog(hWnd, TRUE);

				// display "please wait" string
				if (LoadString(ghInstance, IDS_WAITINGFORCONNECTION, szStr, sizeof(szStr)))
					SetDlgItemText(hWnd, IDC_STATUS, szStr);
			}
			else
			{
				if (LoadString(ghInstance, IDS_DIALING, szTableStr, sizeof(szTableStr)))
				{
					wsprintf(szStr, szTableStr, globals->szPhoneNumber);
					SetDlgItemText(hWnd, IDC_STATUS, szStr);
				}

				// dial phone number
				lResult = dialMakeCall(globals->lpDial, globals->szPhoneNumber);
				if (lResult < 0)
				{
					// could not dial call, so show an error
					if (LoadString(ghInstance, IDS_COULDNOTDIAL, szStr, sizeof(szStr)))
						SetDlgItemText(hWnd, IDC_STATUS, szStr);
					break;
				}

				// reset to zero so that we don't get a false no connection below
				globals->lpDial->dwCallState = 0;
			}

			uTimer = SetTimer(hWnd, 1, TIMERINTERVAL, NULL);
			break;

		case WM_TIMER:

			if (dialIsConnected(globals->lpDial))
			{
				if (uTimer)
				{
					KillTimer(hWnd, uTimer);
					uTimer = 0;
				}

				// give the other side some time to set up
				Sleep(500);

	            EndDialog(hWnd, TRUE);
			}

			// see if line has failed
			else if (globals->lpDial->dwCallError != CALL_OK)
			{
				// show an error
				if (LoadString(ghInstance,
							   globals->bAnswering ? IDS_COULDNOTOPENLINE : IDS_COULDNOTDIAL,
							   szStr, sizeof(szStr)))
					SetDlgItemText(hWnd, IDC_STATUS, szStr);
			}
			break;

        case WM_DESTROY:
			if (uTimer)
			{
				KillTimer(hWnd, uTimer);
				uTimer = 0;
			}
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
					// disconnect the call
					dialDropCall(globals->lpDial);
					dialDeallocCall(globals->lpDial);
					dialLineClose(globals->lpDial);

					// Return failure
					EndDialog(hWnd, FALSE);
                    break;
            }
            break;
    }

    // Allow for default processing
    return FALSE;
}

HRESULT DoDialStatus(LPDPMODEM globals)
{
	LINERESULT		lResult;


	// see if line had an error or went idle
	if ((globals->lpDial->dwCallError != CALL_OK) ||
		((globals->lpDial->hLine) &&
		 (globals->lpDial->dwCallState == LINECALLSTATE_IDLE)))
	{
		DPF(3, "DoDialStatus error recovery");
		// some errors don't close the line so we will
		if (globals->lpDial->hLine)
			dialLineClose(globals->lpDial);
		// reset the error state
		globals->lpDial->dwCallError = CALL_OK;
		return (DPERR_NOCONNECTION);
	}

	// line is not open
	if (!globals->lpDial->hLine)
	{
		lResult = dialLineOpen(globals->lpDial, globals->dwDeviceID);
		if (lResult)
			return (DPERR_NOCONNECTION);

		lResult = dialMakeCall(globals->lpDial, globals->szPhoneNumber);
		if (lResult < 0)
		{
			dialLineClose(globals->lpDial);
			return (DPERR_NOCONNECTION);
		}

		// reset to zero so that we don't get a false "no connection" before we dial
		globals->lpDial->dwCallState = 0;
	}

	// if we got here then call is in progress
	return (DPERR_CONNECTING);
}

HRESULT DoAnswerStatus(LPDPMODEM globals)
{
	LINERESULT		lResult;

	// see if line had an error
	if (globals->lpDial->dwCallError != CALL_OK)
	{
		// some errors don't close the line so we will
		if (globals->lpDial->hLine)
			dialLineClose(globals->lpDial);
		// reset the error state
		globals->lpDial->dwCallError = CALL_OK;
		return (DPERR_NOCONNECTION);
	}

	// open a line
	if (!globals->lpDial->hLine)
	{
		lResult = dialLineOpen(globals->lpDial, globals->dwDeviceID);
		if (lResult)
			return (DPERR_NOCONNECTION);
	}

	// if we got here then we are ready to answer a call
	return (DP_OK);
}

static BOOL FAR PASCAL EnumMRUPhoneNumbers(LPCVOID lpData, DWORD dwDataSize, LPVOID lpContext)
{
	HWND	hWnd = (HWND) lpContext;

	SendDlgItemMessage(hWnd,
						IDC_NUMBER,
						CB_ADDSTRING,
						(WPARAM) 0,
						(LPARAM) lpData);
	return (TRUE);
}

static void UpdateButtons(HWND hWnd)
{
	LONG_PTR	len;

	// see how much text has been typed into number edit
    len = SendDlgItemMessage(hWnd,
							IDC_NUMBER,
							WM_GETTEXTLENGTH,
							(WPARAM) 0,
							(LPARAM) 0);

	// only enable "Connect" button if text has been entered
	EnableWindow(GetDlgItem(hWnd, IDOK), (len == 0) ? FALSE : TRUE);
}

void ChangeDialingProperties(HWND hWnd, LPDPDIAL lpDial)
{
	TCHAR		szPhoneNumber[PHONENUMBERSIZE];
	DWORD		dwModemSelection;
	DWORD		dwDeviceID;
	LINERESULT	lResult;



	dwModemSelection = (DWORD)SendDlgItemMessage(hWnd,
								IDC_MODEM,
								CB_GETCURSEL,
								(WPARAM) 0,
								(LPARAM) 0);
	DDASSERT( dwModemSelection != CB_ERR );

	dwDeviceID = (DWORD)SendDlgItemMessage(hWnd,
								IDC_MODEM,
								CB_GETITEMDATA,
								(WPARAM) dwModemSelection,
								(LPARAM) 0);
	DDASSERT( dwDeviceID != CB_ERR );
	if (dwDeviceID == CB_ERR)
		return;

	GetDlgItemText(hWnd, IDC_NUMBER, szPhoneNumber, PHONENUMBERSIZE);

	lResult = dialTranslateDialog(lpDial, hWnd, dwDeviceID, szPhoneNumber);
}

void ConfigureModem(HWND hWnd)
{
	DWORD		dwDeviceID;
	DWORD		dwModemSelection;
	LINERESULT	lResult;


	//
	// get the current modem selection and then get the associated TAPI modem ID
	//
	dwModemSelection = (DWORD)SendDlgItemMessage(hWnd,
								IDC_MODEM,
								CB_GETCURSEL,
								(WPARAM) 0,
								(LPARAM) 0);
	DDASSERT( dwModemSelection != CB_ERR );

	dwDeviceID = (DWORD)SendDlgItemMessage(hWnd,
								IDC_MODEM,
								CB_GETITEMDATA,
								(WPARAM) dwModemSelection,
								(LPARAM) 0);
	DDASSERT( dwDeviceID != CB_ERR );
	if (dwDeviceID != CB_ERR)
		lResult = lineConfigDialog(dwDeviceID, hWnd, "comm/datamodem");
}

// ---------------------------------------------------------------------------
// CenterWidow
// ---------------------------------------------------------------------------
// Description:             Centers one window over another.
// Arguments:
//  HWND                    [in] Window handle.
//  HWND                    [in] Parent window handle.  NULL centers the
//                               window over the desktop.
// Returns:
//  void
void CenterWindow(HWND hWnd, HWND hWndParent)
{
    RECT                    rcWindow, rcParent;
    int                     x, y;

    // Get child window rect
    GetWindowRect(hWnd,  &rcWindow);

    // Get parent window rect
//    if(!hWndParent || !IsWindow(hWndParent))
    {
        hWndParent = GetDesktopWindow();
    }

    GetWindowRect(hWndParent, &rcParent);

    // Calculate XY coordinates
    x = ((rcParent.right - rcParent.left) - (rcWindow.right - rcWindow.left)) / 2;
    y = ((rcParent.bottom - rcParent.top) - (rcWindow.bottom - rcWindow.top)) / 2;

    // Center the window
    SetWindowPos(hWnd, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\serial\serial.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       serial.c
 *  Content:	Routines for serial I/O
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  6/10/96	kipo	created it
 *  6/22/96	kipo	added support for EnumConnectionData()
 *	6/25/96	kipo	updated for DPADDRESS
 *  7/13/96	kipo	added GetSerialAddress()
 *	7/16/96	kipo	changed address types to be GUIDs instead of 4CC
 *	8/21/96	kipo	move comport address into dplobby.h
 *  1/06/97 kipo	updated for objects
 *  2/11/97 kipo	pass player flags to GetAddress()
 *  2/18/97 kipo	allow multiple instances of service provider
 *	3/17/97 kipo	deal with errors returned by DialogBoxParam()
 *  5/07/97 kipo	added support for modem choice list
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>

#include "dplaysp.h"
#include "comport.h"
#include "resource.h"

// constants

typedef enum {
	ASCII_XON = 0x11,
	ASCII_XOFF = 0x13
};

// serial object
typedef struct {
	DPCOMPORT			comPort;		// base object globals
	BOOL				bHaveSettings;	// set to TRUE after settings dialog has been displayed
	DPCOMPORTADDRESS	settings;		// settings to use
} DPSERIAL, *LPDPSERIAL;

// dialog choices for serial port settings

static DWORD	gComPorts[] =		{ 1, 2, 3, 4 };

static DWORD	gBaudRates[] =		{ CBR_110, CBR_300, CBR_600, CBR_1200, CBR_2400,
									  CBR_4800, CBR_9600, CBR_14400, CBR_19200, CBR_38400,
									  CBR_56000, CBR_57600, CBR_115200, CBR_128000, CBR_256000 };

static DWORD	gStopBits[] =		{ ONESTOPBIT, ONE5STOPBITS, TWOSTOPBITS };

static DWORD	gParities[] =		{ NOPARITY, EVENPARITY, ODDPARITY, MARKPARITY };

static DWORD	gFlowControls[] =	{ DPCPA_NOFLOW, DPCPA_XONXOFFFLOW, DPCPA_RTSFLOW, DPCPA_DTRFLOW, DPCPA_RTSDTRFLOW };

// globals

// this is defined in dllmain.c
extern HINSTANCE		ghInstance;

// this is defined in dpserial.c
extern GUID				DPSERIAL_GUID;

// prototypes

static HRESULT			DisposeSerial(LPDPCOMPORT baseObject);
static HRESULT			ConnectSerial(LPDPCOMPORT baseObject, BOOL bWaitForConnection, BOOL bReturnStatus);
static HRESULT			DisconnectSerial(LPDPCOMPORT baseObject);
static HRESULT			GetSerialAddress(LPDPCOMPORT baseObject, DWORD dwPlayerFlags,
										 LPVOID lpAddress, LPDWORD lpdwAddressSize);
static HRESULT			GetSerialAddressChoices(LPDPCOMPORT baseObject,
									     LPVOID lpAddress, LPDWORD lpdwAddressSize);

static BOOL				SetupConnection(HANDLE hCom, LPDPCOMPORTADDRESS portSettings);
static BOOL FAR PASCAL	EnumAddressData(REFGUID lpguidDataType, DWORD dwDataSize,
										LPCVOID lpData, LPVOID lpContext);
static BOOL				GetSerialSettings(HINSTANCE hInstance, HWND hWndParent, LPDPSERIAL globals);
static UINT_PTR CALLBACK SettingsDialog(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
static void				InitDialog(HWND hDlg, LPDPCOMPORTADDRESS settings);
static void				GetSettingsFromDialog(HWND hDlg, LPDPCOMPORTADDRESS settings);
static int				ValueToIndex(LPDWORD buf, int bufLen, DWORD value);
static void				FillComboBox(HWND hDlg, int dlgItem, int startStr, int stopStr);

/*
 * NewSerial
 *
 * Create new serial port object.
 */
HRESULT NewSerial(LPVOID lpConnectionData, DWORD dwConnectionDataSize,
				  LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
				  LPDPCOMPORT *storage)
{
	LPDPCOMPORT baseObject;
	LPDPSERIAL	globals;
	HRESULT		hr;

	// create base object with enough space for our globals
	hr = NewComPort(sizeof(DPSERIAL), lpDPlay, lpReadRoutine, &baseObject);
	if FAILED(hr)
		return (hr);

	// fill in methods we implement
	baseObject->Dispose = DisposeSerial;
	baseObject->Connect = ConnectSerial;
	baseObject->Disconnect = DisconnectSerial;
	baseObject->GetAddress = GetSerialAddress;
	baseObject->GetAddressChoices = GetSerialAddressChoices;

	// setup default settings
	globals = (LPDPSERIAL) baseObject;
	globals->settings.dwComPort = 1;					// COM port to use (1-4)
	globals->settings.dwBaudRate = CBR_57600;			// baud rate (100-256k)
	globals->settings.dwStopBits = ONESTOPBIT;			// no. stop bits (1-2)
	globals->settings.dwParity = NOPARITY;				// parity (none, odd, even, mark)
	globals->settings.dwFlowControl = DPCPA_RTSDTRFLOW;	// flow control (none, xon/xoff, rts, dtr)

	// check for valid connection data
	if (lpConnectionData)
	{
		baseObject->lpDPlay->lpVtbl->EnumAddress(baseObject->lpDPlay, EnumAddressData, 
									lpConnectionData, dwConnectionDataSize,
									globals);
	}

	// return object pointer
	*storage = baseObject;

	return (DP_OK);
}

/*
 * EnumConnectionData
 *
 * Search for valid connection data
 */

static BOOL FAR PASCAL EnumAddressData(REFGUID lpguidDataType, DWORD dwDataSize,
							LPCVOID lpData, LPVOID lpContext)
{
	LPDPSERIAL			globals = (LPDPSERIAL) lpContext;
	LPDPCOMPORTADDRESS	settings = (LPDPCOMPORTADDRESS) lpData;

	// this is a com port chunk
	if ( IsEqualGUID(lpguidDataType, &DPAID_ComPort) &&
		 (dwDataSize == sizeof(DPCOMPORTADDRESS)) )
	{
		// make sure it's valid!
		if ((ValueToIndex(gComPorts, sizeof(gComPorts), settings->dwComPort) >= 0) &&
			(ValueToIndex(gBaudRates, sizeof(gBaudRates), settings->dwBaudRate) >= 0) &&
			(ValueToIndex(gStopBits, sizeof(gStopBits), settings->dwStopBits) >= 0) &&
			(ValueToIndex(gParities, sizeof(gParities), settings->dwParity) >= 0) &&
			(ValueToIndex(gFlowControls, sizeof(gFlowControls), settings->dwFlowControl) >= 0))
		{
			globals->settings = *settings;		// copy the data
			globals->bHaveSettings = TRUE;		// we have valid settings
		}
	}

	return (TRUE);
}

/*
 * DisposeSerial
 *
 * Dispose serial port object.
 */

static HRESULT DisposeSerial(LPDPCOMPORT baseObject)
{
	LPDPSERIAL	globals = (LPDPSERIAL) baseObject;

	// make sure we are disconnected
	DisconnectSerial(baseObject);

	// free object
	GlobalFreePtr((HGLOBAL) baseObject);

	return (DP_OK);
}

/*
 * ConnectSerial
 *
 * Open serial port and configure based on user settings.
 */

static HRESULT ConnectSerial(LPDPCOMPORT baseObject,
							 BOOL bWaitForConnection, BOOL bReturnStatus)
{
	LPDPSERIAL	globals = (LPDPSERIAL) baseObject;
	HANDLE		hCom;
	TCHAR		portName[10];
	HRESULT		hr;

	// see if com port is already connected
	hCom = baseObject->GetHandle(baseObject);
	if (hCom)
		return (DP_OK);

	// ask user for settings if we have not already
	if (!globals->bHaveSettings)
	{
		if (!GetSerialSettings(ghInstance, GetForegroundWindow(), globals))
		{
			hr = DPERR_USERCANCEL;
			goto Failure;
		}

		globals->bHaveSettings = TRUE;
	}

	// open specified com port
	CopyMemory(portName, "COM0", 5);
	portName[3] += (BYTE) globals->settings.dwComPort;

	hCom = CreateFile(	portName,
						GENERIC_READ | GENERIC_WRITE,
						0,    /* comm devices must be opened w/exclusive-access */
						NULL, /* no security attrs */
						OPEN_EXISTING, /* comm devices must use OPEN_EXISTING */
						FILE_ATTRIBUTE_NORMAL | 
						FILE_FLAG_OVERLAPPED, // overlapped I/O
						NULL  /* hTemplate must be NULL for comm devices */
						);

	if (hCom == INVALID_HANDLE_VALUE)
	{
		hCom = NULL;
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Failure;
	}

	// configure com port to proper settings
	if (!SetupConnection(hCom, &globals->settings))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Failure;
	}

	// setup com port
	hr = baseObject->Setup(baseObject, hCom);
	if FAILED(hr)
		goto Failure;

	return (DP_OK);

Failure:
	if (hCom)
		CloseHandle(hCom);

	return (hr);
}

/*
 * DisconnectSerial
 *
 * Close serial port.
 */

static HRESULT DisconnectSerial(LPDPCOMPORT baseObject)
{
	HANDLE		hCom;
	HRESULT		hr;

	hCom = baseObject->GetHandle(baseObject);

	// com port is already disconnected
	if (hCom == NULL)
		return (DP_OK);

	// shut down com port
	hr = baseObject->Shutdown(baseObject);

	// close com port
	CloseHandle(hCom);

	return (hr);
}

/*
 * SetupConnection
 *
 * Configure serial port with specified settings.
 */

static BOOL SetupConnection(HANDLE hCom, LPDPCOMPORTADDRESS portSettings)
{
	DCB		dcb;

	dcb.DCBlength = sizeof(DCB);
	if (!GetCommState(hCom, &dcb))
		return (FALSE);

	// setup various port settings

	dcb.fBinary = TRUE;
	dcb.BaudRate = portSettings->dwBaudRate;
	dcb.ByteSize = 8;
	dcb.StopBits = (BYTE) portSettings->dwStopBits;

	dcb.Parity = (BYTE) portSettings->dwParity;
	if (portSettings->dwParity == NOPARITY)
		dcb.fParity = FALSE;
	else
		dcb.fParity = TRUE;

	// setup hardware flow control

	if ((portSettings->dwFlowControl == DPCPA_DTRFLOW) ||
		(portSettings->dwFlowControl == DPCPA_RTSDTRFLOW))
	{
		dcb.fOutxDsrFlow = TRUE;
		dcb.fDtrControl = DTR_CONTROL_HANDSHAKE;
	}
	else
	{
		dcb.fOutxDsrFlow = FALSE;
		dcb.fDtrControl = DTR_CONTROL_ENABLE;
	}

	if ((portSettings->dwFlowControl == DPCPA_RTSFLOW) ||
		(portSettings->dwFlowControl == DPCPA_RTSDTRFLOW))
	{
		dcb.fOutxCtsFlow = TRUE;
		dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
	}
	else
	{
		dcb.fOutxCtsFlow = FALSE;
		dcb.fRtsControl = RTS_CONTROL_ENABLE;
	}

	// setup software flow control

	if (portSettings->dwFlowControl == DPCPA_XONXOFFFLOW)
	{
		dcb.fInX = TRUE;
		dcb.fOutX = TRUE;
	}
	else
	{
		dcb.fInX = FALSE;
		dcb.fOutX = FALSE;
	}

	dcb.XonChar = ASCII_XON;
	dcb.XoffChar = ASCII_XOFF;
	dcb.XonLim = 100;
	dcb.XoffLim = 100;

	if (!SetCommState( hCom, &dcb ))
	   return (FALSE);

	return (TRUE);
}

/*
 * GetSerialAddress
 *
 * Return current serial port info if available.
 */

static HRESULT GetSerialAddress(LPDPCOMPORT baseObject, DWORD dwPlayerFlags,
								LPVOID lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPSERIAL	globals = (LPDPSERIAL) baseObject;
	HRESULT		hResult;

	// no settings yet
	if (!globals->bHaveSettings)
		return (DPERR_UNAVAILABLE);

	hResult = baseObject->lpDPlay->lpVtbl->CreateAddress(baseObject->lpDPlay,
						&DPSERIAL_GUID, &DPAID_ComPort,
						&globals->settings, sizeof(DPCOMPORTADDRESS),
						lpAddress, lpdwAddressSize);

	return (hResult);
}

/*
 * GetSerialAddressChoices
 *
 * Return current serial address choices
 */

static HRESULT GetSerialAddressChoices(LPDPCOMPORT baseObject,
									   LPVOID lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPSERIAL	globals = (LPDPSERIAL) baseObject;

	// currently the serial provider does not support any choices
	return (E_NOTIMPL);
}

/*
 * GetComPortSettings
 *
 * Displays a dialog to gather and return the COM port settings.
 */

static BOOL GetSerialSettings(HINSTANCE hInstance, HWND hWndParent, LPDPSERIAL globals)
{
	INT_PTR	iResult;

    iResult = (INT_PTR)DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_SETTINGSDIALOG), hWndParent, SettingsDialog, (LPARAM) globals);
	return (iResult > 0);
}

/*
 * SettingsDialog
 *
 * The dialog callback routine to display and edit the COM port settings.
 */

static UINT_PTR CALLBACK SettingsDialog(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	LPDPSERIAL			globals = (LPDPSERIAL) GetWindowLongPtr(hDlg, DWLP_USER);
	HWND				hWndCtl;
	BOOL				msgHandled = FALSE;
    
	switch (msg)
	{
	case WM_INITDIALOG:
		// serial info pointer passed in lParam
		globals = (LPDPSERIAL) lParam;

         // save the globals with the window
		SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) globals);

		hWndCtl = GetDlgItem(hDlg, IDC_COMPORT);

		// make sure our dialog item is there
		if (hWndCtl == NULL)
		{
			EndDialog(hDlg, FALSE);
			msgHandled = TRUE;
		}
		else
		{
			InitDialog(hDlg, &globals->settings);	// setup our dialog
			SetFocus(hWndCtl);				// focus on com port combo box
			msgHandled = FALSE;				// keep windows from setting input focus for us
		}
		break;

    case WM_COMMAND:

		if (HIWORD(wParam) == 0)
		{
			switch (LOWORD(wParam))
			{
			case IDOK:						// return settings
				GetSettingsFromDialog(hDlg, &globals->settings);
				EndDialog(hDlg, TRUE);
				msgHandled = TRUE;
 				break;

			case IDCANCEL:					// cancel
				EndDialog(hDlg, FALSE);
				msgHandled = TRUE;
 				break;
			}
		}
		break;
    }

    return (msgHandled);
}

/*
 * InitDialog
 *
 * Initialize the dialog controls to display the given COM port settings.
 */

static void InitDialog(HWND hDlg, LPDPCOMPORTADDRESS settings)
{
	// fill dialog combo boxes with items from string table
	FillComboBox(hDlg, IDC_COMPORT, IDS_COM1, IDS_COM4);
	FillComboBox(hDlg, IDC_BAUDRATE, IDS_BAUD1, IDS_BAUD15);
	FillComboBox(hDlg, IDC_STOPBITS, IDS_STOPBIT1, IDS_STOPBIT3);
	FillComboBox(hDlg, IDC_PARITY, IDS_PARITY1, IDS_PARITY4);
	FillComboBox(hDlg, IDC_FLOW, IDS_FLOW1, IDS_FLOW5);

	// select default values in combo boxes
	SendDlgItemMessage(hDlg, IDC_COMPORT, CB_SETCURSEL,
					   ValueToIndex(gComPorts, sizeof(gComPorts), settings->dwComPort), 0);
	SendDlgItemMessage(hDlg, IDC_BAUDRATE, CB_SETCURSEL,
					   ValueToIndex(gBaudRates, sizeof(gBaudRates), settings->dwBaudRate), 0);
	SendDlgItemMessage(hDlg, IDC_STOPBITS, CB_SETCURSEL,
					   ValueToIndex(gStopBits, sizeof(gStopBits), settings->dwStopBits), 0);
	SendDlgItemMessage(hDlg, IDC_PARITY, CB_SETCURSEL,
					   ValueToIndex(gParities, sizeof(gParities), settings->dwParity), 0);
	SendDlgItemMessage(hDlg, IDC_FLOW, CB_SETCURSEL,
					   ValueToIndex(gFlowControls, sizeof(gFlowControls), settings->dwFlowControl), 0);
}

/*
 * GetSettingsFromDialog
 *
 * Get the COM port settings from the dialog controls.
 */

static void GetSettingsFromDialog(HWND hDlg, LPDPCOMPORTADDRESS settings)
{
	INT_PTR		index;

	index = SendDlgItemMessage(hDlg, IDC_COMPORT, CB_GETCURSEL, 0, 0);
	if (index == CB_ERR)
		return;

	settings->dwComPort = gComPorts[index];

	index = SendDlgItemMessage(hDlg, IDC_BAUDRATE, CB_GETCURSEL, 0, 0);
	if (index == CB_ERR)
		return;

	settings->dwBaudRate = gBaudRates[index];

	index = SendDlgItemMessage(hDlg, IDC_STOPBITS, CB_GETCURSEL, 0, 0);
	if (index == CB_ERR)
		return;

	settings->dwStopBits = gStopBits[index];

	index = SendDlgItemMessage(hDlg, IDC_PARITY, CB_GETCURSEL, 0, 0);
	if (index == CB_ERR)
		return;

	settings->dwParity = gParities[index];

	index = SendDlgItemMessage(hDlg, IDC_FLOW, CB_GETCURSEL, 0, 0);
	if (index == CB_ERR)
		return;

	settings->dwFlowControl = gFlowControls[index];
}

/*
 * FillComboBox
 *
 * Add the specified strings to the combo box.
 */

#define MAXSTRINGSIZE	200

static void FillComboBox(HWND hDlg, int dlgItem, int startStr, int stopStr)
{
	int		i;
	TCHAR	str[MAXSTRINGSIZE];

	for (i = startStr; i <= stopStr; i++)
	{
		if (LoadString(ghInstance, i, str, MAXSTRINGSIZE))
			SendDlgItemMessage(hDlg, dlgItem, CB_ADDSTRING, (WPARAM) 0, (LPARAM) str);
	}
}

/*
 * ValueToIndex
 *
 * Convert a settings value to a combo box selection index.
 */

static int ValueToIndex(LPDWORD buf, int bufLen, DWORD value)
{
	int		i;

	bufLen /= sizeof(DWORD);
	for (i = 0; i < bufLen; i++)
		if (buf[i] == value)
			return (i);

	return (-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\fpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fpm.h
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97  aarono    Original
 ***************************************************************************/

#ifndef _FPM_H_
#define _FPM_H_

typedef struct FPOOL *PFPOOL, *LPFPOOL;

typedef BOOL (*FN_BLOCKINITALLOC)(void * pvItem);
typedef VOID (*FN_BLOCKINIT)(void * pvItem);
typedef VOID (*FN_BLOCKFINI)(void *pvItem);

LPFPOOL FPM_Init(
	unsigned int size,						// size of blocks in pool
	FN_BLOCKINITALLOC fnBlockInitAlloc,     // fn called for each new alloc
	FN_BLOCKINIT      fnBlockInit,          // fn called each time block used
	FN_BLOCKFINI      fnBlockFini           // fn called before releasing mem
	);

typedef void * (*FPM_GET)(LPFPOOL pPool);
typedef void   (*FPM_RELEASE)(LPFPOOL pPool, void *pvItem);
typedef void   (*FPM_SCALE)(LPFPOOL pPool);
typedef void   (*FPM_FINI)(LPFPOOL pPool, int bFORCE);

typedef struct FPOOL {
	// external
	FPM_GET		Get;
	FPM_RELEASE Release;
	FPM_SCALE   Scale;
	FPM_FINI    Fini;
	
	// internal
	FN_BLOCKINITALLOC fnBlockInitAlloc;
	FN_BLOCKINIT      fnBlockInit;
	FN_BLOCKFINI      fnBlockFini;
	
	int    cbItemSize;
	void * pPool;
	int    nAllocated;
	int    nInUse;
	int    nMaxInUse;
	int    bInScale;
	
	CRITICAL_SECTION cs;
	
} FPOOL, *LPFPOOL, *PFPOOL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\serial\daytona\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\dputils.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\serial\sources.inc ===
MAJORCOMP=windows
MINORCOMP=GDI
UMTYPE=windows

TARGETNAME=dpmodemx
TARGETTYPE=DYNLINK

INCLUDES=..\..\..\inc; \
	 ..\..\..\misc; \
	..\; \
	 ..\..\dplay; \
	 ..\..\..\dplobby\dplobby; \
	 ..\..\common; \
	 $(BASEDIR)\public\sdk\inc\mfc42;

TARGETPATH=obj

TARGETLIBS=$(SDK_LIB_PATH)\libc.lib    \
	   $(SDK_LIB_PATH)\user32.lib    \
	   $(SDK_LIB_PATH)\kernel32.lib  \
	   $(SDK_LIB_PATH)\tapi32.lib \
	   $(SDK_LIB_PATH)\winmm.lib \
	   $(SDK_LIB_PATH)\dplayx.lib

DLLENTRY=DllMain

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

C_DEFINES=$(C_DEFINES) -DUSE_CRITSECTS -DWIN16_SEPARATE -DNEW_DPF

LINKER_FLAGS=-SECTION:share,RWS

#LINKLIBS= \

SOURCES= \
	..\dllmain.c \
	..\dpserial.c \
	..\comport.c \
	..\serial.c \
	..\modem.c \
	..\dial.c \
	..\bilink.c \
	..\dpserial.rc \
	newdpf.c \
	dputils.c


DLLDEF=..\dpserial.def

NTTARGETFILE0=MISC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\handler.c ===
#include "dpsp.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"HandleMessage"

// this function is called with dpws lock taken
HRESULT HandleServerMessage(LPGLOBALDATA pgd, SOCKET sSocket, LPBYTE pBuffer, DWORD dwSize)
{
	LPMSG_GENERIC pMessage = (LPMSG_GENERIC) pBuffer;
	DWORD dwType;
	DWORD dwVersion;
	HRESULT hr=DP_OK;

	ASSERT(pMessage);
	
	dwType = GET_MESSAGE_COMMAND(pMessage);
	dwVersion = GET_MESSAGE_VERSION(pMessage);
	
	switch (dwType) {
			
	default:
		DPF(0,"dpwsock received unrecognized message of type 0x%08x\n",dwType);
		break;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\helpcli.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       helpcli.h
 *  Content:	header file for dplay helper interface
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/15/97		andyco	created from w95help.h
 *
 ***************************************************************************/
#ifndef __HELPCLI_INCLUDED__
#define __HELPCLI_INCLUDED__
#include "windows.h"
#include "dplaysvr.h"
#include "dpf.h"

#ifdef __cplusplus
extern "C" {
#endif

extern BOOL CreateHelperProcess( LPDWORD ppid );
extern BOOL WaitForHelperStartup( void );
extern HRESULT HelperAddDPlayServer(USHORT port);
extern BOOL HelperDeleteDPlayServer(USHORT port);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dpwsock.rc
//
#define IDD_DIALOG1                     101
#define IDD_SELECTSERVER                101
#define IDC_EDIT1                       1000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:	dpwsock.dll initialization
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   2/1	andyco	created it
 ***************************************************************************/
//#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "dpf.h"
#include "dpsp.h"
#include "memalloc.h"

DWORD dwRefCnt=0;// the # of attached processes
BOOL bFirstTime;

#undef DPF_MODNAME
#define DPF_MODNAME "dpwsock sp dllmain"

HANDLE ghInstance; // save this for our dialog box

/*
 * DllMain
 */
BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{

    switch( dwReason )
    {
	
	case DLL_PROCESS_ATTACH:
	
	    DisableThreadLibraryCalls( hmod );
	    DPFINIT(); // bugbug : dpfinit for every proc?

	    DPF( 0, "====> ENTER: DLLMAIN(%08lx): Process Attach: %08lx, tid=%08lx", DllMain,
	            GetCurrentProcessId(), GetCurrentThreadId() );
	    	
	    /*
	     * initialize memory
	     */
	    if( dwRefCnt == 0 )
	    {
			INIT_DPSP_CSECT();	
			
	        if( !MemInit() )
	        {
		        DPF( 0, "LEAVING, COULD NOT MemInit" );
		        return FALSE;
	        }

			// save the instance
			ghInstance = hmod;
			
	    }

    	dwRefCnt++;

        break;

    case DLL_PROCESS_DETACH:

	    DPF( 2, "====> ENTER: DLLMAIN(%08lx): Process Detach %08lx, tid=%08lx",
	        DllMain, GetCurrentProcessId(), GetCurrentThreadId() );
	    
	    dwRefCnt--;        
      	if (0==dwRefCnt) 
       	{
	
			DPF(0,"DPWSOCK - dllmain - going away!");

		    #ifdef DEBUG
	    	    MemState();
		    #endif // debug
	    
	        MemFini(); 
			
			FINI_DPSP_CSECT();
       	} 
	    break;

    default:
        break;
    }

    return TRUE;

} /* DllMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\dpsp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsp.c
 *  Content:	sample direct play service provider, based on winsock
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  1/96		andyco	created it
 *  2/8/96		andyco	steam + dgram model, including name server support
 *	2/15/96		andyco	added reliable receive.  added send (udp + stream). 
 *						added macros for dwReserved to clean up, (and provide
 *						means for reducing # dwords reserved per player)
 *	3/13/96		andyco	relaible send + receive for all players. MW2
 *	3/16/96		andyco	shutdown method - code cleanup - shared stream receive, etc.
 *	3/19/96		andyco	new message macros (IS_VALID, GET_MESSAGE_SIZE). see dpmess.h
 *	4/3/96		andyco	moved start up / shut down winsock code here from dllmain 
 *	4/10/96		andyco	added spplayerdata
 *	4/12/96		andyco	got rid of dpmess.h! use DPlay_ instead of message macros
 *	4/18/96		andyco	added multihomed support, started ipx
 *	4/23/96		andyco	ipx support.  ipx only - no spx.  spx doesn't support
 *						graceful disconnect (winsock bug?) so we don't know
 *						when it's safe to closesocket.
 *	4/25/96		andyco	messages now have blobs (sockaddr's) instead of dwReserveds  
 *	5/31/96		andyco	all non-system players share a socket (gsStream and 
 *						gsDGramSocket).
 *	6/9/96		andyco	ouch.  dplayi_player + group are gone!
 *	6/19/96		andyco	sp sets own header!
 *	6/22/96		andyco	no more stashing goodies in sessiondesc.  tossed cookies.
 *	6/23/96		kipo	updated for latest service provider interfaces.
 *	6/25/96		kipo	added WINAPI prototypes and updated for DPADDRESS;
 *						added version.
 *	7/11/96		andyco	reset gsEnumSocket to INVALID_SOCKET if spInit fails
 *						#2348.  added sp_getaddress.
 *	7/18/96		andyco	added dphelp for server socket
 *	7/16/96		kipo	changed address types to be GUIDs instead of 4CC
 *  8/1/96		andyco	fixed up caps.  dplay allocs sp data, not us.  
 *  8/9/96		andyco	throw DPCAPS_GUARANTEEDOPTIMIZED for AF_INET
 *	8/12/96		andyco	changed failure check on inithelper
 *	8/15/96		andyco	added sp local data + clean up on thread terminate
 *	8/30/96		andyco	clean it up b4 you shut it down! added globaldata.
 *	9/1/96		andyco	right said thread!  if you spin it, they won't block.
 *						bagosockets.
 * 	9/4/96		andyco	kill threads at shutdown only. add all threads to
 *						threadlist. don't add thread to list if it's already
 *						done.
 *	11/11/96	andyco	check for NULL header or data when creating
 *						non-local players (support game server). Memset our 
 *						sockaddr to 0 before calling getserveraddress.
 *	12/18/96	andyco	de-threading - use a fixed # of prealloced threads.
 *						cruised the enum socket / thread - use the system
 *						socket / thread instead
 *	1/15/97		andyco	return actual hr on open failure (bug 5197) instead of
 *						just DP_OK.  also, allow system messages to go in the 
 *						socket cache. 
 *	1/17/97		andyco	workaround for nt bug 68093 - recvfrom returns buffer size
 *						instead of WSAEMSGSIZE
 *	1/23/97		kipo	return an error code from StartDPHelp() so Open() returns
 *						an error if you cannot host a session.
 *	1/24/97		andyco	handle incoming message when receive thread isn't running yet
 *	2/7/97		andyco  store globals w/ IDirectPlaySP, so we can have > 1 SP per DLL.
 *	2/10/97		andyco	remove sockets from receive list if we get an error when receiving 
 *						on them.  this keeps us from going into a spin on select(...).
 *	2/15/97		andyco	wait on accept thread b4 receive thread.  pass port to 
 *						helperdeletedplayserver.
 *	3/04/97		kipo	external definition of gdwDPlaySPRefCount now in dplaysp.h
 *	3/18/97		andyco	create socket at spinit to verify support for requested
 *						address family
 *	3/18/97		kipo	GetServerAddress() now returns an error so that we can
 *						return DPERR_USERCANCEL from the EnumSessions dialog
 *	3/25/97		andyco	tweaked shutdown code to send message to streamreceivethreadproc
 *						to exit, rather than nuking the control socket which
 *						would sometimes hang.
 *	4/11/97		andyco	make sure it's really the control socket @ init
 *	5/12/97		kipo	return DPERR_UNAVAILABLE if SP could not be opened (i.e. if
 *						IPX not installed) to be compatible with the modem SP; added
 *						support for Unicode IP address strings.
 *	5/18/97		andyco	close threads + sockets at close.  this way, we don't hold
 *						sockets across sessions.
 *	6/11/97		andyco	changed reply thread proc to flush q when waking up
 *	6/18/97		andyco	check for bogus reply headers, just to be safe
 *	6/19/97		myronth	Fixed handle leak (#10059)
 *	6/20/97		andyco	check for bogus IPX install by looking for sa_nodenum
 *						of all 0's at SPInit.  raid 9625.
 *	7/11/97		andyco	added async reply thread and ws2 support
 *	7/30/97		andyco	call wsastartup w/ version 1.1 if app has already 
 *						called it.
 *   8/4/97		andyco	added support for DPSEND_ASYNC (no return status) so 
 *						we can make addforward async
 *	8/25/97		sohailm updated stream receive logic to avoid congestion (bug #10952)
 *	9/05/97		kipo	Fixed memphis bug #43655 to deal with getsockopt failing
 *	12/5/97		andyco	voice support
 *	01/5/98		sohailm	fd set now grows dynamically - allows for any number of clients (#15244).
 *	01/14/98	sohailm	don't look for Winsock2.0 on non-nt platforms for IPX (#15253)
 *	1/20/98		myronth	#ifdef'd out voice support
 *	1/21/98    a-PeterZ	Fix #15242 SP_GetAddress supports local players
 *	1/27/98		sohailm	added Firewall support.
 *	1/30/98		sohailm	bug fix for 17731
 *	2/09/98    a-PeterZ	Fix #17737 ReceiveList Memory Leak
 *  2/13/98     aarono  added async support
 *  2/13/98     aarono  made IPX return proper header size
 *	2/16/98    a-PeterZ	Fix #15342 Detect no local connection in SP_EnumSessions and SP_Open
 *	2/18/98    a-peterz Comment byte order mess-up with SERVER_xxx_PORT constants
 *  2/24/98     aarono  Bug#18646 fix startup/close race crashing stress.
 *  3/3/98      aarono  Bug#19188 remove accept thread 
 *  3/30/98     aarono  changed KillSocket on StreamAccept socket to closesocket
 *  4/6/98      aarono  mapped WSAECONNRESET to DPERR_CONNECTIONLOST
 *  4/23/98     aarono  workaround Winsock shutdown bug.
 *                       The workaround for DPLAY would be to close all accepted sockets first 
 * 						 and only then listening socket. (VadimE)
 *  6/19/98     aarono  map WSAENETRESET and WSAENOTCONN to DPERR_CONNECTIONLOST too.
 *                      required since we now turn on keepalives on reliable
 *                      connections.
 * 12/15/98     aarono  Fix Async Enum.
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *
 ***************************************************************************/

/***************************************************************************
*  summary -                                                                
* 	+ SPInit is the entry point called by dplay. SP fills in callbacks,		
* 		does any other init stuff there.                                    
* 	+ All dplay callbacks start with SP_                                    
*                                                                           
*****************************************************************************/

// todo - need a meaningful mapping from socket errors to hresults

// todo - figure out when to pop a message box to the user for tragic errors

#define INITGUID

#ifdef BIGMESSAGEDEFENSE

#include <dplobby.h>

// a-josbor: this terrible, terrible hack is brought to you by the elmer build system
#ifndef MAXMSGSIZEGUIDDEFINED

// {F5D09980-F0C4-11d1-8326-006097B01411}
DEFINE_GUID(DPAID_MaxMessageSize, 
0xf5d09980, 0xf0c4, 0x11d1, 0x83, 0x26, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

#endif

#endif /* BIGMESSAGEDEFENSE */

#include "dpsp.h"
#include "fpm.h"
#include <initguid.h>
#include "helpcli.h"

/*			*/
/*  globals	*/
/*			*/
WSADATA gwsaData; // from wsastartup
HINSTANCE hWS2; // dynaload the ws2_32.dll, so if it's not installed (e.g. win 95 gold)
				// we still load

// stuff for ddhelp
DWORD dwHelperPid; // for ddhelp
HANDLE hModule;  // for ddhelp

CRITICAL_SECTION gcsDPSPCritSection;
#ifdef DEBUG
int gCSCount;
#endif

#ifdef DPLAY_VOICE_SUPPORT
BOOL gbVoiceInit = FALSE; // set to TRUE if we have nm voice init'ed
BOOL gbVoiceOpen = FALSE; // set to TRUE if we have a call open
#endif // DPLAY_VOICE_SUPPORT


#undef DPF_MODNAME
#define DPF_MODNAME	"DEBUGPRINTSOCKADDR"

#ifdef DEBUG
void DebugPrintAddr(UINT nLevel,LPSTR pStr,SOCKADDR * psockaddr)
{
	switch (psockaddr->sa_family)
	{
		case AF_INET: 
		{
			SOCKADDR_IN * pin;
			pin = (SOCKADDR_IN *)psockaddr;
			DPF(nLevel,"%s af = AF_INET : address =  %s : port = %d\n",pStr,
				inet_ntoa(pin->sin_addr),ntohs(pin->sin_port));
			break;
			
		}
		case AF_IPX: 
		{
			SOCKADDR_IPX * pipx;
			pipx = (SOCKADDR_IPX *)psockaddr;
			DPF(nLevel,"%s AF = AF_IPX : sa_socket = %d : sa_nodenum = %d,%d,%d,%d,%d,%d",
					pStr,pipx->sa_socket,pipx->sa_nodenum[0],pipx->sa_nodenum[1],
					pipx->sa_nodenum[2],pipx->sa_nodenum[3],pipx->sa_nodenum[4],
					pipx->sa_nodenum[5]);
			break;
			
		}

		default:
			ASSERT(FALSE);
			break;
	}

} // DebugPrintAddr

void DebugPrintSocket(UINT level,LPSTR pStr,SOCKET * pSock) 
{
	SOCKADDR sockaddr;
	int addrlen=sizeof(sockaddr);

	getsockname(*pSock,&sockaddr,&addrlen);
	DEBUGPRINTADDR(level,pStr,&sockaddr);
	
}
#endif // debug


#undef DPF_MODNAME
#define DPF_MODNAME	"GetHostAddr"

// Helper function to retrieve host IP Address(es).
// System owns structure returned.
PHOSTENT GetHostAddr(void)
{
	char pHostName[HOST_NAME_LENGTH];
	PHOSTENT phostent;
	UINT err;

	if (0 != gethostname(pHostName, HOST_NAME_LENGTH)) 
	{
		err = WSAGetLastError();
		DPF(0,"could not get host name - err = %d\n",err);
		return NULL;
	}
	
	phostent = gethostbyname(pHostName);
	if (NULL == phostent) 
	{
		err = WSAGetLastError();
		DPF(0,"could not get address for '%s' - err = %d\n", pHostName, err);
		return NULL;
	}

	return phostent;
} // GetHostAddr

#undef DPF_MODNAME
#define DPF_MODNAME	"DatagramListenThread"

void SetMessageHeader(LPDWORD pdwMsg,DWORD dwSize, DWORD dwToken)
{

	if (dwSize > SPMAXMESSAGELEN)
	{
		ASSERT(FALSE);
	}

	*pdwMsg = dwSize | dwToken;	

	return ;

}// SetMessageHeader

#undef DPF_MODNAME
#define DPF_MODNAME	"DatagramReceiveThread"

// our initial guess at the size of the dgram receive buffer.
// any messages bigger than this will be truncated BUT when we 
// receive a too big message, we double the buffer size (winsock
// won't tell us exactly how big the message was, so we guess).
// a-josbor: I thought 1024 was really stingy, so I bumped this up to 16K
#define BUF_SIZE 0x4000
DWORD WINAPI DgramListenThreadProc(LPVOID pvCast)
{
    UINT err;
	LPBYTE pBuffer;
    INT addrlen=sizeof(SOCKADDR);
    SOCKADDR sockaddr; // the from address
	DWORD dwBufSize = BUF_SIZE;
	IDirectPlaySP * pISP = (IDirectPlaySP *)pvCast;
	LPGLOBALDATA pgd;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	SOCKET sSocket;
	HRESULT hr;
	
    DPF(2,"starting udp listen thread ");

	// get the global data
	hr =pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		ExitThread(0);
		return 0;
	}
	
	// use the dgram socket
	sSocket = pgd->sSystemDGramSocket;
	
	ENTER_DPSP();
	
	pBuffer = MemAlloc(BUF_SIZE);
	
	LEAVE_DPSP();
	
	if (!pBuffer)
	{
		DPF_ERR("could not alloc dgram receive buffer");
		ExitThread(0);
		return 0;
	}
	
    while (1)
    {
        err = recvfrom(sSocket,pBuffer,dwBufSize,0,&sockaddr,&addrlen);
        if ( (SOCKET_ERROR == err)  || (dwBufSize == err))
        {
		
			if (dwBufSize == err)
			{
				// this works around NT bug 68093
				err = WSAEMSGSIZE;
			}
			else 
			{
	            err = WSAGetLastError();				
			}
	        
			DPF(2,"\n udp recv error - err = %d socket = %d",err,(DWORD)sSocket);
			
			if (WSAEMSGSIZE == err)
			{
				// buffer too small!
				dwBufSize *= 2;
				
				ENTER_DPSP();
				
				pBuffer = MemReAlloc(pBuffer,dwBufSize);
				
				LEAVE_DPSP();
				
				if (!pBuffer)
				{
					DPF_ERR("could not realloc dgram receive buffer");
					ExitThread(0);
					return 0;
				}
				// we don't pass dplay this message, since it was truncated...
			}
			else 
			{
				// bail on other errors
				goto ERROR_EXIT;
			}
        }
        else if ( (err >= sizeof(DWORD)) &&  (VALID_DPWS_MESSAGE(pBuffer)) )
        {
		
			DEBUGPRINTADDR(9,"received udp message from : ",&sockaddr);
			if (VALID_SP_MESSAGE(pBuffer))
			{
				// it came from another dplay (not from our dplay helper)
				// if it came from our helper, we've already poked the ip addr
				// into the message body
				switch (pgd->AddressFamily)
				{
					case AF_IPX:
						IPX_SetNodenum((LPVOID)pBuffer,(SOCKADDR_IPX *)&sockaddr);
						break;
					case AF_INET:
						IP_SetAddr((LPVOID)pBuffer,(SOCKADDR_IN *)&sockaddr);
						break;
					default:
						ASSERT(FALSE);
						break;
				}
				
			}

			// pass message to dplays handler
            pISP->lpVtbl->HandleMessage(pISP,pBuffer + sizeof(MESSAGEHEADER),
            	err -  sizeof(MESSAGEHEADER), pBuffer);
    	}
		else 
		{
			DEBUGPRINTADDR(9,"received udp message from : ",&sockaddr);		
			// it must be just a raw send...
            pISP->lpVtbl->HandleMessage(pISP,pBuffer,err,NULL);
		}
    }

ERROR_EXIT:
	DPF(2,"UDP Listen thread exiting");
	
	ENTER_DPSP();
	
	if (pBuffer) MemFree(pBuffer);
	
	LEAVE_DPSP();

    // all done
    ExitThread(0);
    return 0;

} // UDPListenThreadProc

#undef DPF_MODNAME
#define DPF_MODNAME	"StreamListenThread"

// make sure the buffer is big enough to fit the message size
HRESULT MakeBufferSpace(LPBYTE * ppBuffer,LPDWORD pdwBufferSize,DWORD dwMessageSize)
{
	HRESULT hr = DP_OK;

	ASSERT(ppBuffer);
	ASSERT(pdwBufferSize);
		    
	ENTER_DPSP();
	
	if (!*ppBuffer)
	{
		DPF(9, "Allocating space for message of size %d", dwMessageSize);

		// need to alloc receive buffer?
		*ppBuffer = MemAlloc(dwMessageSize);
        if (!*ppBuffer)
        {
        	DPF_ERR("could not alloc stream receive buffer - out of memory");        
            hr = E_OUTOFMEMORY;
            goto CLEANUP_EXIT;
        }
		*pdwBufferSize = dwMessageSize;
	}
	// make sure receive buffer can hold data
	else if (dwMessageSize > *pdwBufferSize) 
	{
		LPVOID pvTemp;

		DPF(9, "ReAllocating space for message of size %d", dwMessageSize);

		// realloc buffer to hold data
		pvTemp = MemReAlloc(*ppBuffer,dwMessageSize);
		if (!pvTemp)
		{
        	DPF_ERR("could not realloc stream receive buffer - out of memory");
            hr = E_OUTOFMEMORY;
            goto CLEANUP_EXIT;
		}
		*ppBuffer = pvTemp;
		*pdwBufferSize = dwMessageSize;
	}

    // fall through
    
CLEANUP_EXIT: 
    
	LEAVE_DPSP();
    return hr;    
    
}  // MakeBufferSpace

// is this sockaddr local to this machine?
BOOL IsLocalIP(SOCKADDR_IN sockaddr)
{
	PHOSTENT phostent;
	IN_ADDR hostaddr;
	HRESULT hr = DP_OK;
	int i;

	phostent = GetHostAddr();
	if (NULL == phostent) 
	{
		return FALSE;
	}

	i=0;
	while (phostent->h_addr_list[i])
	{
		memcpy(&hostaddr,phostent->h_addr_list[i],sizeof(hostaddr));
		if (hostaddr.s_addr == sockaddr.sin_addr.s_addr )
		{
			return TRUE;
		}
		i++;
	}

	return FALSE;
}  // IsLocalIP

// adds socket to our send list
HRESULT AddSocketToBag(LPGLOBALDATA pgd, SOCKET socket, DPID dpid, SOCKADDR *psockaddr, DWORD dwFlags)
{
	UINT i=0;
	BOOL bFound = FALSE;
	BOOL bTrue = TRUE;
	HRESULT hr=DP_OK;
		
	ASSERT(psockaddr);

	ENTER_DPSP();

	// see if we can find an empty slot
	i=0;
	while (( i < pgd->nSocketsInBag) && !bFound)
	{
		if (INVALID_SOCKET == pgd->BagOSockets[i].sSocket) bFound = TRUE;
		else i++;
	}
	if (!bFound)	
	{
		// no space. bummer
		DPF(5,"no space in bag o' sockets. slowness ensues");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	DPF(5,"adding new socket to bag for id = %d, slot = %d",dpid,i);
	DEBUGPRINTSOCK(7, "Adding socket to bag - ",&socket);
	
	pgd->BagOSockets[i].dwPlayerID = dpid;	
	pgd->BagOSockets[i].sSocket = socket;
	pgd->BagOSockets[i].sockaddr = *psockaddr;
	pgd->BagOSockets[i].dwFlags = dwFlags;

	// fall through

CLEANUP_EXIT:
	LEAVE_DPSP();
	return hr;
}

void FreeConnection(LPCONNECTION pConnection)
{
	if (pConnection->pBuffer && (pConnection->pBuffer != pConnection->pDefaultBuffer)) 
	{
		MemFree(pConnection->pBuffer);
		pConnection->pBuffer = NULL;
	}
	if (pConnection->pDefaultBuffer) 
	{
		MemFree(pConnection->pDefaultBuffer);
		pConnection->pDefaultBuffer = NULL;
	}

	// initialize connection 
    pConnection->socket = INVALID_SOCKET; // this tells us if connection is valid
	pConnection->dwCurMessageSize = 0;
	pConnection->dwTotalMessageSize = 0;
	pConnection->dwFlags = 0;
}


HRESULT AddSocketToReceiveList(LPGLOBALDATA pgd,SOCKET sSocket,DWORD dwFlags)
{
    UINT i = 0;
    UINT err, iNewSlot;
	BOOL bFoundSlot = FALSE;
    HRESULT hr = DP_OK;
    INT addrlen=sizeof(SOCKADDR);
	LPCONNECTION pNewConnection=NULL;
	DWORD dwCurrentSize,dwNewSize;
    
    ENTER_DPSP();
	
    // look for an empty slot 
    while ( (i < pgd->ReceiveList.nConnections) && !bFoundSlot)
    {
    	if (INVALID_SOCKET == pgd->ReceiveList.pConnection[i].socket)
    	{
    		bFoundSlot = TRUE;			
			iNewSlot = i;
    	}
        else 
        {
        	i++;
        }
    }
    
    if (!bFoundSlot)
    {		
		// allocate space for list of connections
		dwCurrentSize = pgd->ReceiveList.nConnections * sizeof(CONNECTION);
		dwNewSize = dwCurrentSize +  INITIAL_RECEIVELIST_SIZE * sizeof(CONNECTION);		
		hr =  MakeBufferSpace((LPBYTE *)&(pgd->ReceiveList.pConnection),&dwCurrentSize,dwNewSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			goto ERROR_EXIT;
		}		
		ASSERT(dwCurrentSize == dwNewSize);
		
        // set all the new entries to INVALID
        for (i = pgd->ReceiveList.nConnections + 1; 
        	i < pgd->ReceiveList.nConnections + INITIAL_RECEIVELIST_SIZE; i++ )
        {
        	pgd->ReceiveList.pConnection[i].socket = INVALID_SOCKET;
        }
        
        // store the new socket in the 1st new spot
		iNewSlot = pgd->ReceiveList.nConnections;

        // allocate space for an fd set (fd_count + fd_array)
		if (pgd->ReceiveList.nConnections)
		{
	        dwCurrentSize = sizeof(u_int) + pgd->ReceiveList.nConnections * sizeof(SOCKET);
	        dwNewSize =	dwCurrentSize + INITIAL_RECEIVELIST_SIZE * sizeof(SOCKET);
		}
		else
		{
			dwCurrentSize = 0;
			dwNewSize = sizeof(u_int) + INITIAL_RECEIVELIST_SIZE * sizeof(SOCKET);
		}
		hr =  MakeBufferSpace((LPBYTE *)&(pgd->readfds.pfdbigset),&dwCurrentSize,dwNewSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			goto ERROR_EXIT;
		}		
		ASSERT(dwCurrentSize == dwNewSize);
		
        // update the # of connections
        pgd->ReceiveList.nConnections += INITIAL_RECEIVELIST_SIZE; 
		// update the fd_array buffer size
		pgd->readfds.dwArraySize = pgd->ReceiveList.nConnections;
        
    } // !bFoundSlot

	// we have a space holder for a connection when we get here
	
	// Initialize new connection 
	pNewConnection = &(pgd->ReceiveList.pConnection[iNewSlot]);
    pNewConnection->socket = sSocket;
    pNewConnection->dwFlags = dwFlags;

	if(dwFlags != SP_STREAM_ACCEPT){

		// allocate a default receive buffer if don't have one already
	    if (!pNewConnection->pDefaultBuffer)
	    {
	    	pNewConnection->pDefaultBuffer = MemAlloc(DEFAULT_RECEIVE_BUFFERSIZE);
	    	if (!pNewConnection->pDefaultBuffer)
			{
				hr = DPERR_OUTOFMEMORY;
			    DPF_ERR("could not alloc default receive buffer - out of memory");        
				goto ERROR_EXIT;
			}
	    }
	    
		// receive buffer initially points to our default buffer
		pNewConnection->pBuffer = pNewConnection->pDefaultBuffer;
		
		// remember the address we are connected to
		err = getpeername(pNewConnection->socket, &(pNewConnection->sockAddr), &addrlen);
		if (SOCKET_ERROR == err) 
		{
			err = WSAGetLastError();
			DPF(1,"could not getpeername err = %d\n",err);
		}

		DEBUGPRINTADDR(9, "Socket is connected to address - ",&(pNewConnection->sockAddr));

	}
	
	LEAVE_DPSP();

	DPF(5, "Added new socket at index %d", iNewSlot);


	// success
	return DP_OK;

	// not a fall through
	
ERROR_EXIT:

	if (pNewConnection)
	{
		KillSocket(pNewConnection->socket,TRUE,FALSE);
		FreeConnection(pNewConnection);
	}
	LEAVE_DPSP();
    return hr;
    
}  // AddSocketToReceiveList

// updates the player associated with a socket in the send list
void UpdateSocketPlayerID(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, DPID dpidPlayer)
{
	UINT i=0;
	IN_ADDR *pIPCurrent, *pIPFind;
	BOOL bFound = FALSE;

	ASSERT(pSockAddr);

	DEBUGPRINTADDR(9, "Updating player id for socket connected to - ",pSockAddr);

	ENTER_DPSP();

	while (!bFound && (i < pgd->nSocketsInBag))
    {
		pIPCurrent = &(((SOCKADDR_IN *)&pgd->BagOSockets[i].sockaddr)->sin_addr);
		pIPFind = &(((SOCKADDR_IN *)pSockAddr)->sin_addr);

		// todo - we are only comparing the IP here, need to look at the complete socket address
		if ((INVALID_SOCKET != pgd->BagOSockets[i].sSocket) && 
			!memcmp(pIPCurrent, pIPFind, sizeof(IN_ADDR)))
    	{			
			bFound = TRUE;
			// update the player id
			pgd->BagOSockets[i].dwPlayerID = dpidPlayer;
    	}

    	i++;
    }

    LEAVE_DPSP();

    return;
}

BOOL FindSocketInReceiveList(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, SOCKET * psSocket)
{
	UINT i=0;
	IN_ADDR *pIPCurrent, *pIPFind;
	BOOL bFound = FALSE;

	ASSERT(psSocket);

	ENTER_DPSP();

	while (!bFound && (i < pgd->ReceiveList.nConnections))
    {
		pIPCurrent = &(((SOCKADDR_IN *)&pgd->ReceiveList.pConnection[i].sockAddr)->sin_addr);
		pIPFind = &(((SOCKADDR_IN *)pSockAddr)->sin_addr);

		// todo - we are only comparing the IP here, need to look at the complete socket address
		if ((INVALID_SOCKET != pgd->ReceiveList.pConnection[i].socket) && 
			!memcmp(pIPCurrent, pIPFind, sizeof(IN_ADDR)))
    	{
			*psSocket = pgd->ReceiveList.pConnection[i].socket;
			bFound = TRUE;
    	}

    	i++;
    }

    LEAVE_DPSP();
    
	return bFound;
}

BOOL FindSocketInBag(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, SOCKET * psSocket, LPDPID lpdpidPlayer)
{
	UINT i=0;
	IN_ADDR *pIPCurrent, *pIPFind;
	BOOL bFound = FALSE;

	ASSERT(psSocket);
	ASSERT(lpdpidPlayer);

	ENTER_DPSP();
	

	while (!bFound && (i < pgd->nSocketsInBag))
    {
		pIPCurrent = &(((SOCKADDR_IN *)&pgd->BagOSockets[i].sockaddr)->sin_addr);
		pIPFind = &(((SOCKADDR_IN *)pSockAddr)->sin_addr);

		if ((INVALID_SOCKET != pgd->BagOSockets[i].sSocket) &&
			!memcmp(pIPCurrent, pIPFind, sizeof(IN_ADDR)))
		{
			*psSocket = pgd->BagOSockets[i].sSocket;
			*lpdpidPlayer = pgd->BagOSockets[i].dwPlayerID;

			DPF(9, "Found socket in send list for id %d", *lpdpidPlayer);
			bFound = TRUE;
    	}

    	i++;
    }

    LEAVE_DPSP();
    
	return bFound;
}

void RemoveSocketFromBag(LPGLOBALDATA pgd, SOCKET socket)
{
	BOOL bFound = FALSE;
	UINT i=0;
	
	ENTER_DPSP();

    // look for the socket
    while (!bFound && (i < pgd->nSocketsInBag))
    {
    	if (socket == pgd->BagOSockets[i].sSocket)
    	{
			pgd->BagOSockets[i].sSocket = INVALID_SOCKET;
			bFound = TRUE;
    	}
        else 
        {
        	i++;
        }
    } // while

	LEAVE_DPSP();
}

void RemoveSocketFromReceiveList(LPGLOBALDATA pgd, SOCKET socket)
{
    UINT i = 0;
	BOOL bFound = FALSE;
	SOCKET sSocket=INVALID_SOCKET;
	DWORD dwSocketFlags=0;

    ENTER_DPSP();
    
    // look for the corresponding connection
    while ( !bFound && (i < pgd->ReceiveList.nConnections))
    {
    	if (socket == pgd->ReceiveList.pConnection[i].socket)
    	{
			DEBUGPRINTSOCK(9, "Removing socket from receive list - ", &socket);
			socket = pgd->ReceiveList.pConnection[i].socket;			
			dwSocketFlags = pgd->ReceiveList.pConnection[i].dwFlags;
			FreeConnection(&pgd->ReceiveList.pConnection[i]);
			bFound = TRUE;
    	}
        else 
        {
        	i++;
        }
    } // while
    
    LEAVE_DPSP();
	
	if (bFound)
	{
		KillSocket(socket, TRUE, FALSE);
		if (dwSocketFlags & SP_CONNECTION_FULLDUPLEX)
			RemoveSocketFromBag(pgd,sSocket);
	}

	return ;	
	
} //RemoveSocketFromReceiveList

HRESULT HandleSPMessage(IDirectPlaySP *pISP, LPGLOBALDATA pgd, LPCONNECTION pConnection)
{
	HRESULT hr;
	
	switch (SP_MESSAGE_TOKEN(pConnection->pBuffer)) 
	{		
		// VALID_SP_MESSAGE
		case TOKEN:
		{
			if (SPMESSAGEHEADERLEN == pConnection->dwTotalMessageSize)
			{
	    		// if we get a message w/ 0 size, it means we've accepted a connection
				// and need to add the new socket to our recv list...
				// basically, it's a no-op for the receive loop
				return DP_OK;
			}
			
			// now, we've read all the bits
			// store the address we received from w/ the message
			// todo - don't store address if it's a player - player message
			switch (pgd->AddressFamily)
			{
				case AF_INET:
					if (pgd->dwFlags & DPSP_OUTBOUNDONLY)
					{
						((LPMESSAGEHEADER)pConnection->pBuffer)->sockaddr = pConnection->sockAddr;
					}
					else
					{
						IP_SetAddr((LPVOID)pConnection->pBuffer,(SOCKADDR_IN *)&pConnection->sockAddr);
					}
					break;
				case AF_IPX:
					IPX_SetNodenum((LPVOID)pConnection->pBuffer,(SOCKADDR_IPX *)&pConnection->sockAddr);
					break;
				default:
					ASSERT(FALSE);
					break;
			}
			
			// pass message to dplays handler
			// need to drop the lock here...
			ASSERT( 1 == gCSCount);
			
			DPF(9, "received a complete message - handing it off to dplay");

			LEAVE_DPSP();
			
			// received a complete message - hand it off to dplay
			pISP->lpVtbl->HandleMessage(pISP, pConnection->pBuffer + sizeof(MESSAGEHEADER),
	        		pConnection->dwTotalMessageSize - sizeof(MESSAGEHEADER),pConnection->pBuffer);
			
			ENTER_DPSP();

		} 
		break;
		
 		// VALID_SERVER_MESSAGE
 		case SERVER_TOKEN:
		{
			HandleServerMessage(pgd, pConnection->socket, pConnection->pBuffer + sizeof(MESSAGEHEADER), 
	        		pConnection->dwTotalMessageSize - sizeof(MESSAGEHEADER));
	        		
		}
		break;

		// if we get this token, the sender wants us to reuse the connection
		// so put it in the send list
		case REUSE_TOKEN:
		{
			DEBUGPRINTSOCK(9, "Received reuse message on - ", &pConnection->socket);

			// we only allow reusing connections in client/server mode at this time.
			// peer-peer can't work without making inbound connections
			if (pgd->dwSessionFlags & DPSESSION_CLIENTSERVER)
			{
				DEBUGPRINTSOCK(9, "Reusing connection - ", &pConnection->socket);

				hr = AddSocketToBag(pgd, pConnection->socket, 0, &pConnection->sockAddr, 
									SP_CONNECTION_FULLDUPLEX);
				if (FAILED(hr))
				{
					DEBUGPRINTSOCK(0, "Failed to reuse connection - ",&pConnection->socket);
					return hr;
				}
			}
			else
			{
				DPF(2, "Not accepting reuse request in peer-peer");
				return E_FAIL;

			}
		}
		break;

		default:
		{
			DPF(0, "Received a message with invalid token - 0x%08x",SP_MESSAGE_TOKEN(pConnection->pBuffer));
		}
		break;
	
	} // switch

	return DP_OK;
	
} // HandleSPMessage

/*
 ** StreamReceive
 *
 *  CALLED BY: StreamReceiveThreadProc
 *
 *  PARAMETERS:
 *		sSocket - socket to receive on
 *		ppBuffer - buffer to receive into - alloc'ed / realloc'ed  as necessary
 *		pdwBuffersize - size of pBuffer
 *
 *  DESCRIPTION:
 *		take the bytes out of sSocket until no more bytes
 *
 *  RETURNS: E_FAIL on sockerr, or DP_OK. 
 *
 */
HRESULT StreamReceive(IDirectPlaySP * pISP,LPGLOBALDATA pgd, LPCONNECTION pConnection)
{
	HRESULT hr = DP_OK;
    UINT err;
    DWORD dwBytesReceived=0;
	DWORD dwMessageSize = 0;
	LPBYTE pReceiveBuffer=NULL;
	DWORD dwReceiveBufferSize;
	
	// is it a new message ?
	if (pConnection->dwCurMessageSize == 0)
	{
		// make sure we have a buffer to recive data in
		if (!pConnection->pDefaultBuffer)
		{
			DEBUGPRINTADDR(0, "No buffer to receive data - removing connection to - ",&pConnection->sockAddr);
			goto CLEANUP_EXIT;
		}
		// receive the header first
		pConnection->dwTotalMessageSize = SPMESSAGEHEADERLEN;
	}

	// continue receiving message
	pReceiveBuffer = pConnection->pBuffer + pConnection->dwCurMessageSize;
	dwReceiveBufferSize = pConnection->dwTotalMessageSize - pConnection->dwCurMessageSize;

	DPF(9,"Attempting to receive %d bytes", dwReceiveBufferSize);

   	DEBUGPRINTSOCK(9,">>> receiving data on socket - ",&pConnection->socket);

	// receive data from socket 
	// note - make exactly one call to recv after select otherwise we'll hang
	dwBytesReceived = recv(pConnection->socket, (LPBYTE)pReceiveBuffer, dwReceiveBufferSize, 0);

	if (0 == dwBytesReceived)
	{
		// remote side has shutdown connection gracefully
	   	DEBUGPRINTSOCK(9,"<<< received data on socket - ",&pConnection->socket);
		hr = DP_OK;
		DEBUGPRINTSOCK(5,"Remote side has shutdown connection gracefully - ",&pConnection->socket);
		goto CLEANUP_EXIT;
	}
	else if (SOCKET_ERROR == dwBytesReceived)
	{
		err = WSAGetLastError();

   		DEBUGPRINTSOCK(9,"<<< received data on socket - ",&pConnection->socket);
		DPF(0,"STREAMRECEIVEE: receive error - err = %d",err);
		hr = E_UNEXPECTED;            
		goto CLEANUP_EXIT;
	}

	DPF(5, "received %d bytes", dwBytesReceived);
	
	// we have received this much message so far
	pConnection->dwCurMessageSize += dwBytesReceived;

	// did we receive the header
	if (pConnection->dwCurMessageSize == SPMESSAGEHEADERLEN)
	{
		// we just completed receiving message header

		// make sure its valid
		if (VALID_DPWS_MESSAGE(pConnection->pDefaultBuffer))
		{
			 dwMessageSize = SP_MESSAGE_SIZE(pConnection->pDefaultBuffer); // total message size			

#ifdef BIGMESSAGEDEFENSE
			// make sure it is not greater that the max message len
			if (dwMessageSize > pgd->dwMaxMessageSize)
			{
				DPF(0, "Got message (%d bytes) that's bigger than max allowed len (%d)! Disconnecting sender.\n",
					dwMessageSize - sizeof(MESSAGEHEADER), pgd->dwMaxMessageSize - sizeof(MESSAGEHEADER));
				ASSERT(dwMessageSize <= pgd->dwMaxMessageSize);
								
				// we want to receive another 12 bytes so that DPLAY can have
				//	something to look at to decide whether or not to continue
				//	receiving this message.  So instead of setting dwMessageSize
				//	to its real size, we fake it out.
				dwMessageSize = SPMESSAGEHEADERLEN + 12;
			}
#endif
		}
		else 
		{
			DPF(2,"got invalid message - token = 0x%08x",SP_MESSAGE_TOKEN(pConnection->pDefaultBuffer));
			ASSERT(FALSE);
			hr = E_UNEXPECTED;
			goto CLEANUP_EXIT;
		}

		// prepare to receive rest of the message (after the token)
		if (dwMessageSize) 
		{
			pConnection->dwTotalMessageSize = dwMessageSize;

			// which buffer to receive message in ?
			if (dwMessageSize > DEFAULT_RECEIVE_BUFFERSIZE)
			{
				ASSERT(pConnection->pBuffer == pConnection->pDefaultBuffer);
				// get a new buffer to fit the message
				pConnection->pBuffer = MemAlloc(dwMessageSize);
				if (!pConnection->pBuffer)
				{
					DPF(0,"Failed to allocate receive buffer for message - out of memory");
					goto CLEANUP_EXIT;
				}
				// copy header into new message buffer
				memcpy(pConnection->pBuffer, pConnection->pDefaultBuffer, SPMESSAGEHEADERLEN);
			}
		}
	}
#ifdef BIGMESSAGEDEFENSE
	// this MIGHT be because the message is really huge, and we're just getting
	// enough to hand to DPLAY
	else if (pConnection->dwCurMessageSize == SPMESSAGEHEADERLEN + 12)
	{
		dwMessageSize = SP_MESSAGE_SIZE(pConnection->pBuffer);
		if (dwMessageSize > pgd->dwMaxMessageSize)
		{
			DPSP_MSGTOOBIG	msgTooBigErr;
			
			// okay.  This is message is too big, and we now have enough data
			// to hand to DPLAY.  Find out if it wants us to continue receiving,
			//	or bail on this connection

			// call into DPLAY to let it do its thing
			msgTooBigErr.dwType = DPSPWARN_MESSAGETOOBIG;	
			msgTooBigErr.pReceiveBuffer = pConnection->pBuffer + sizeof(MESSAGEHEADER);
			msgTooBigErr.dwBytesReceived = pConnection->dwCurMessageSize;
			msgTooBigErr.dwMessageSize = dwMessageSize - sizeof(MESSAGEHEADER);
			
			LEAVE_DPSP();

			pISP->lpVtbl->HandleSPWarning(pISP, &msgTooBigErr, sizeof(DPSP_MSGTOOBIG), pConnection->pBuffer);
			
			ENTER_DPSP();

//			now, kill the connection
			hr = E_UNEXPECTED;
			goto CLEANUP_EXIT;
		}
	}
#endif

	// did we receive a complete message ?
	if (pConnection->dwCurMessageSize == pConnection->dwTotalMessageSize)
	{
		// process message
		hr = HandleSPMessage(pISP, pgd, pConnection);
		
		// cleanup up new receive buffer if any
		if (pConnection->dwTotalMessageSize > DEFAULT_RECEIVE_BUFFERSIZE)
		{
			DPF(9, "Releasing receive buffer of size %d", pConnection->dwTotalMessageSize);
			if (pConnection->pBuffer) MemFree(pConnection->pBuffer);
		}			
		// initialize message information
		pConnection->dwCurMessageSize = 0;
		pConnection->dwTotalMessageSize = 0;
		pConnection->pBuffer = pConnection->pDefaultBuffer;

		if (FAILED(hr))
		{
			goto CLEANUP_EXIT;
		}
	}

	// all done
	return DP_OK;	
	
CLEANUP_EXIT:

	RemoveSocketFromReceiveList(pgd,pConnection->socket);
	return hr;
	 	
} // StreamReceive


void EmptyConnectionList(LPGLOBALDATA pgd)
{
	UINT i;
	
	ENTER_DPSP();
	
	for (i=0;i<pgd->ReceiveList.nConnections ;i++ )
	{
		if (INVALID_SOCKET != pgd->ReceiveList.pConnection[i].socket)
		{
			KillSocket(pgd->ReceiveList.pConnection[i].socket,TRUE,FALSE);
			FreeConnection(&(pgd->ReceiveList.pConnection[i]));
		}
	}
	
	LEAVE_DPSP();
	
	return ;
	
}  // EmptyConnectionList

// when we get a control event, we need to send a message to the control
// socket (to wake up the receive thread proc).
// this finds the ip addr of this machine to send to. 
HRESULT GetDefaultHostAddr(SOCKADDR * psockaddr)
{
    PHOSTENT phostent;
    IN_ADDR hostaddr;
	    	
    ((LPSOCKADDR_IN)psockaddr)->sin_addr.s_addr = 0;
	
    // find an ip address for this machine
    // we use the default, since all our sends are to local 
    // name servers (no homing issues)
    phostent = GetHostAddr();
    if (NULL == phostent) 
    {
        return E_FAIL;
    }
    DPF(5,"found host name %s \n",phostent->h_name);

    memcpy(&hostaddr,phostent->h_addr_list[0],sizeof(hostaddr));

    DPF(5,"GetDefaultHostAddr ::  found host addr = %s \n",inet_ntoa(hostaddr));
    
    // store the default sockaddr for this system
    ((LPSOCKADDR_IN)psockaddr)->sin_addr.s_addr = hostaddr.s_addr;
	
    return DP_OK;
	
} // GetDefaultHostAddr

// watch our list of sockets, waiting for one to have data to be received, or to be closed
DWORD WINAPI StreamReceiveThreadProc(LPVOID pvCast)
{
	HRESULT hr;
	int rval;
	UINT i = 0;
    UINT err;
    DWORD dwBufferSize = 0;    
	UINT nSelected;
	IDirectPlaySP * pISP = (IDirectPlaySP *)pvCast;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	TIMEVAL tv={0,250000};	// 250000 us = 1/4 sec.
	DWORD dwPrevSelectLastError=0;
	
	// get the global data
	hr =pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		ExitThread(0);
		return 0;
	}

	AddSocketToReceiveList(pgd,pgd->sSystemStreamSocket,SP_STREAM_ACCEPT);

    while (1)
    {
		ENTER_DPSP();

		ASSERT(pgd->readfds.pfdbigset);

    	// add all sockets in our recv list to readfds
		FD_ZERO(pgd->readfds.pfdbigset);
		nSelected = 0;
		for (i=0;i < pgd->ReceiveList.nConnections ; i++)
		{
        	if (INVALID_SOCKET != pgd->ReceiveList.pConnection[i].socket)
        	{
		        FD_BIG_SET(pgd->ReceiveList.pConnection[i].socket,&pgd->readfds);
				nSelected++;
        	}
		}

		LEAVE_DPSP();

		if (0 == nSelected)		
		{
			if (pgd->bShutdown)
			{
				DPF(2,"stream receive thread proc detected shutdown - bailing");
				goto CLEANUP_EXIT;
			}
			// we should have at least one?
			DPF_ERR("No sockets in receive list - missing control socket? bailing!");
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}

		// now, we wait for something to happen w/ our socket set
		rval = select(0,(fd_set *)(pgd->readfds.pfdbigset),NULL,NULL,&tv);
        if (SOCKET_ERROR == rval)
        {
        	err = WSAGetLastError();
        	if(dwPrevSelectLastError==err){
        		DPF(0,"Got two bogus last errors of(%x) from select, bailing",err);
        		goto CLEANUP_EXIT;
        	}
			// WSAEINTR is returned when a socket is shutdown behind us - this can happen
			// when a socket is removed from the receivelist
        	if (WSAEINTR != err)
			{
				dwPrevSelectLastError=err;
	            DPF(2,"StreamReceiveThreadProc failing w/ sockerr = %d\n - trying again",err);
				ASSERT(FALSE);				
	        	rval = 0; // try again...
			} else {
				dwPrevSelectLastError=0;
			}
        } else {
			dwPrevSelectLastError=0;
        }

		// shut 'em down?
        if (pgd->bShutdown)
        {
        	DPF(2,"receive thread proc detected bShutdown - bailing");
            goto CLEANUP_EXIT;
        }
        
		// a-josbor: why are we waking up with 0 events?
		// in any case, a workaround is to just go back to sleep if we have
		// no real events
		if ( rval == 0)
		{
			continue;
		}

    	DPF(5,"receive thread proc - events on %d sockets",rval);
		i = 0;
		
		ENTER_DPSP();
		
        while (rval>0)
        {
	        // walk the receive list, dealing w/ all new sockets
			if (i >= pgd->ReceiveList.nConnections)
			{
				DPF(0, "nConnections = %d, selected = %d", pgd->ReceiveList.nConnections, i);
				ASSERT(FALSE); // should never happen
				rval = 0; // just to be safe, reset
			}
            
            if (pgd->ReceiveList.pConnection[i].socket != INVALID_SOCKET)
            {
            	// see if it's in the set
                if (FD_ISSET(pgd->ReceiveList.pConnection[i].socket,pgd->readfds.pfdbigset))
                {
					DPF(9, "Receiving on socket %d from ReceiveList", i);

					if(pgd->ReceiveList.pConnection[i].dwFlags != SP_STREAM_ACCEPT){

	                	// got one! this socket has something going on...
						hr = StreamReceive(pISP, pgd, &(pgd->ReceiveList.pConnection[i]));
	                    if (FAILED(hr))
	                    {
							DPF(1,"Stream Receive failed - hr = 0x%08lx\n",hr);
	                    }
	                    
                    } else {
                    
               		    // accept any incoming connection
               		    SOCKADDR sockaddr; 
					    INT addrlen=sizeof(sockaddr);
					    SOCKET sSocket;
					    
					    sSocket = accept(pgd->sSystemStreamSocket,&sockaddr,&addrlen);
					    if (INVALID_SOCKET == sSocket) 
					    {
					        err = WSAGetLastError();
				            DPF(2,"\n stream accept error - err = %d socket = %d",err,(DWORD)sSocket);
					    } else {
						    DEBUGPRINTADDR(5,"stream - accepted connection from",&sockaddr);
							
							// add the new socket to our receive q
							hr = AddSocketToReceiveList(pgd,sSocket,0);
							if (FAILED(hr))
							{
								ASSERT(FALSE);
							}
						}	
                    }
                    rval--; // one less to hunt for
                } // IS_SET
            } // != INVALID_SOCKET

            i++;
                
   		} // while rval
		
		LEAVE_DPSP();
		
	} // while 1

CLEANUP_EXIT:

	EmptyConnectionList(pgd);
	    
    return 0;
    
} // ReceiveThreadProc

// send a message of 0 length telling receiver to reuse connection
HRESULT SendReuseConnectionMessage(SOCKET sSocket)
{
	DWORD dwMessage;
	HRESULT hr=DP_OK;
	UINT err;
	
	// send a 0 sized message (w/ our header) to the stream socket, to tell 
	// receive thread proc to reuse this socket for replies to us
	SetMessageHeader(&dwMessage,0,REUSE_TOKEN);
	
    err = send(sSocket,(LPBYTE)&dwMessage,sizeof(DWORD),0);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();

		// if we're shutdown, don't print a scary
		DPF(0,"SendReuseControlMessage failed with error - err = %d\n",err);
		hr = E_FAIL;
	}	

	return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CreateAndConnectSocket"

// called by reliable send and DoTCPEnumSessions
HRESULT CreateAndConnectSocket(LPGLOBALDATA pgd,SOCKET * psSocket,DWORD dwType,LPSOCKADDR psockaddr, BOOL bOutBoundOnly)
{
	UINT err;
	HRESULT hr;
	int iAddrLen = sizeof(SOCKADDR);

	ASSERT(psSocket);
	
	hr = CreateSocket(pgd,psSocket,dwType,0,INADDR_ANY,&err,FALSE);
    if (FAILED(hr)) 
    {
        DPF(0,"createandconnect :: create socket failed - err = %d\n",err);
       	return hr;
    }
	
	// try to connect	
	hr = SPConnect(psSocket,(LPSOCKADDR)psockaddr,iAddrLen, bOutBoundOnly);
    if (FAILED(hr)) 
    {
        DPF(0,"createandconnect - connect socket failed\n");
		goto ERROR_EXIT;
    }

	if (bOutBoundOnly)
	{
		// so we receive the reply (server will reuse the connection)
		hr = AddSocketToReceiveList(pgd, *psSocket,SP_CONNECTION_FULLDUPLEX);
		if (FAILED(hr))
		{
			DPF(0, "failed to add socket to receive list");
			goto ERROR_EXIT;
		}
	}
	
	return DP_OK;
	// not a fall through

ERROR_EXIT:
	if (INVALID_SOCKET != *psSocket)
	{
		err = closesocket(*psSocket);
		if (SOCKET_ERROR == err) 
		{
			err = WSAGetLastError();
			DPF(0,"send closesocket error - err = %d\n",err);
			return E_UNEXPECTED;
		}
	    *psSocket = INVALID_SOCKET;
	}

	return hr;	
	
}  // CreateAndConnectSocket


#undef DPF_MODNAME
#define DPF_MODNAME	"EnumSessions"

// starts the streamacceptthread (TCP) or the dgramlistenthreadproc (IPX) so we can 
// get replies from the nameserver for our requests
HRESULT StartupEnumThread(IDirectPlaySP * pISP,LPGLOBALDATA pgd)
{
	HRESULT hr;
	UINT err;
	DWORD dwThreadID;
	
	// set up socket
	if (AF_IPX == pgd->AddressFamily) // ipx gets dgram socket
	{
		if (pgd->hDGramReceiveThread)
		{
			return DP_OK; // already running
		}
		
		ASSERT(INVALID_SOCKET == pgd->sSystemDGramSocket);
		
	    hr = CreateSocket(pgd,&(pgd->sSystemDGramSocket),SOCK_DGRAM,0,INADDR_ANY,&err,TRUE);
		if (FAILED(hr)) 
		{
			DPF(0,"could not create enum socket - err = %d\n",err);
			return hr;
		}

		pgd->hDGramReceiveThread = CreateThread(NULL,0,DgramListenThreadProc,
			(LPVOID)pISP,0,&dwThreadID);
		if (!pgd->hDGramReceiveThread)
		{
			ASSERT(FALSE);
		} else SetThreadPriority(pgd->hDGramReceiveThread, THREAD_PRIORITY_ABOVE_NORMAL);
	}
	else  // everything else uses reliable
	{
		if (pgd->hStreamReceiveThread)
		{
			return DP_OK; // already running
		}
		
		// create system stream socket so we can start listening for connections
		ASSERT(INVALID_SOCKET == pgd->sSystemStreamSocket);
		hr = CreateAndInitStreamSocket(pgd); 
		if (FAILED(hr)) 
		{
			ASSERT(FALSE);
			return hr;
		}

		// start the enum accept thread (listen for new connections)
	    pgd->hStreamReceiveThread = CreateThread(NULL,0,StreamReceiveThreadProc,
			(LPVOID)pISP,0,&dwThreadID);
		if (!pgd->hStreamReceiveThread)
		{
			DPF(0, "Failed to start stream receive thread");
			ASSERT(FALSE);
		} else SetThreadPriority(pgd->hDGramReceiveThread, THREAD_PRIORITY_ABOVE_NORMAL);
	}
	
	return DP_OK;
	
} // StartupEnumThread

/*
 *		Creates a dgram socket, sends enum sessions request, and closes socket.  
 *
 *		reply is received in streamlistenthreadproc and passed into dplay.
 */
HRESULT DoUDPEnumSessions(LPGLOBALDATA pgd, SOCKADDR *lpSockAddr, DWORD dwAddrSize,
	LPDPSP_ENUMSESSIONSDATA ped)
{
	SOCKET sSocket;
	HRESULT hr;
	BOOL bTrue=TRUE;
	UINT err;

	DEBUGPRINTADDR(5,"enum unreliable - sending to ",lpSockAddr); 
	
  	hr = CreateSocket(pgd,&sSocket,SOCK_DGRAM,0,INADDR_ANY,&err,FALSE);
	if (FAILED(hr)) 
	{
		DPF(0,"!!! enum - could not create socket error = %d\n",err);
	    return E_FAIL;
	}
    
    // enable broadcast on our socket
    if( SOCKET_ERROR == setsockopt( sSocket,SOL_SOCKET,SO_BROADCAST,(char FAR *)&bTrue,
                    sizeof(bTrue) ) )
    {
        err = WSAGetLastError();
		DPF(0,"enum - could not set broadcast err = %d\n",err);
        goto CLEANUP_EXIT;
    }

	// send out the enum message
    err = sendto(sSocket,ped->lpMessage,ped->dwMessageSize,0,lpSockAddr,dwAddrSize);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"send error - err = %d\n",err);
        hr = E_UNEXPECTED;
    }

	// fall through

CLEANUP_EXIT:
	KillSocket(sSocket,TRUE,FALSE);
	return hr;
} // DoUDPEnumSessions

// A very short lived thread -- may hang in connect with invalid id to connect to.
DWORD WINAPI TCPEnumSessionsAsyncThread(LPVOID lpv)
{
	LPGLOBALDATA pgd=(LPGLOBALDATA) lpv;
	HRESULT hr;
	UINT err;


	
	DPF(9,"==> Entering TCPEnumSessionsAsyncThread(0x%08x)\n", lpv);
	
	pgd->sEnum = INVALID_SOCKET;

	DEBUGPRINTADDR(5,"enum reliable - sending to ",&pgd->saEnum); 
	
	// get us a new connection
	hr = CreateAndConnectSocket(pgd,&pgd->sEnum,SOCK_STREAM,&pgd->saEnum,pgd->bOutBoundOnly);
	if (FAILED(hr))
	{
		DPF(0, "Failed to get socket for enum sessions - hr: 0x%08x",hr);
		goto EXIT;
	}
	
	// send the request
    err = send(pgd->sEnum,pgd->lpEnumMessage,pgd->dwEnumMessageSize,0);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"send error - err = %d\n",err);
		DEBUGPRINTADDR(0,"reliable send  - FAILED - sending to ",&pgd->saEnum);
		hr = E_FAIL;
		goto ERROR_EXIT;
		// fall through
    }

    if (!pgd->bOutBoundOnly)
    {
    	DEBUGPRINTSOCK(5,"Closing enum sessions connection - ", &pgd->sEnum);
    	// close the connection
    	KillSocket(pgd->sEnum,TRUE,FALSE);
    	pgd->sEnum=INVALID_SOCKET;
    }

	goto EXIT;
    // not a fall through

ERROR_EXIT:
	if (INVALID_SOCKET != pgd->sEnum) 	{
		KillSocket(pgd->sEnum,TRUE,FALSE);
		pgd->sEnum=INVALID_SOCKET;
	}	
EXIT:

	ENTER_DPSP();
	if(pgd->hTCPEnumAsyncThread){
		CloseHandle(pgd->hTCPEnumAsyncThread);
		pgd->hTCPEnumAsyncThread=0;
	}	
	if(pgd->lpEnumMessage){
		MemFree(pgd->lpEnumMessage);
		pgd->lpEnumMessage=0;
	}
	LEAVE_DPSP();
	DPF(5,"<== Leaving TCPEnumSessionsAsyncThread\n");
	return 0;
	
} // TCPEnumSessionsAsyncThread

/*
 *		Creates a stream socket, sends enum sessions request, and closes socket 
 *		depending on bHostWillReuseConnection. If bHostWillReuseConnection is TRUE, server will
 *		close the connection after sending reply.
 *
 *		reply is received in streamlistenthreadproc and passed into dplay.
 */
HRESULT DoTCPEnumSessionsAsync(LPGLOBALDATA pgd, SOCKADDR *lpSockAddr, DWORD dwAddrSize,	
LPDPSP_ENUMSESSIONSDATA ped,BOOL bOutBoundOnly)
{
	DWORD dwJunk;
	HRESULT hr=DP_OK;

	// First see if we have a thread running already, if we do cancel it.

	KillTCPEnumAsyncThread(pgd);

	// package the request up and hand it to the thread.

	ENTER_DPSP();

	pgd->lpEnumMessage=MemAlloc(ped->dwMessageSize);
	
	if(pgd->lpEnumMessage){
		memcpy(pgd->lpEnumMessage, ped->lpMessage, ped->dwMessageSize);
		pgd->dwEnumMessageSize=ped->dwMessageSize;
	} else {
		hr=DPERR_OUTOFMEMORY;
		goto EXIT;
	}

	memcpy(&pgd->saEnum,lpSockAddr,dwAddrSize);
	pgd->dwEnumAddrSize=dwAddrSize;
	pgd->bOutBoundOnly=bOutBoundOnly;
	pgd->sEnum=INVALID_SOCKET;

	if(!(pgd->hTCPEnumAsyncThread=CreateThread(NULL,0,TCPEnumSessionsAsyncThread,pgd,0,&dwJunk))){
		MemFree(pgd->lpEnumMessage);
		pgd->lpEnumMessage=NULL;
		hr=DPERR_OUTOFMEMORY;
	}
	
EXIT:	
	LEAVE_DPSP();
	return hr;
}

/*
 ** EnumSessions
 *
 *  CALLED BY: DPLAY
 *
 *  PARAMETERS: ped - see dplayi.h
 *
 *  DESCRIPTION:
 *	
 *		creates a stream socket. sends a message to the address specified by the user.
 *		fills in return address so server can reply.  
 *
 *		reply is received in streamlistenthreadproc and passed into dplay.
 *
 *  RETURNS:
 *		DP_OK always.
 *
 */
HRESULT WINAPI SP_EnumSessions(LPDPSP_ENUMSESSIONSDATA ped) 
{
#ifdef DEBUG
    SOCKET sSocket; // bcast socket
#endif // DEBUG
    SOCKADDR sockaddr;
    INT addrlen=sizeof(SOCKADDR);
    HRESULT hr;
    DWORD dwErr=0;
	BOOL bTrue = TRUE;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	BOOL bOutBoundOnly = FALSE;

	DPF(5,"SP_EnumSessions");

	// get the global data
	hr =ped->lpISP->lpVtbl->GetSPData(ped->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}
	
	// Do we have an active IP address?  If not and DUN is enabled, a DUN
	// dialog will pop for enum to a specific machine.
	// bReturnStatus means no extra dialogs are wanted so we will abort
	// if there are no local connections.
	if (ped->bReturnStatus && AF_INET == pgd->AddressFamily)
	{
		PHOSTENT phostent = GetHostAddr();
		if (!phostent || phostent->h_addr_list[0] == 0) 
		{
			DPF(0, "No Dial-up network or netcard present");
			return DPERR_NOCONNECTION;	// no local IP address = no network
		}
	}

	memset(&sockaddr,0,sizeof(sockaddr));
	// find out where we should send request to
	hr = GetServerAddress(pgd,&sockaddr);
	if (FAILED(hr))
	{
		DPF_ERR("failed to get enumeration address");
		return hr;
	}
	
	hr = StartupEnumThread(ped->lpISP,pgd);
	if (FAILED(hr))
	{
		DPF(0," could not start enum handler - hr = 0x%08lx\n",hr);
		return hr;
	}
	
	// set message header
	SetMessageHeader(ped->lpMessage,ped->dwMessageSize,TOKEN);

	SetReturnAddress(ped->lpMessage,SERVICE_SOCKET(pgd));		
	
#ifdef DEBUG	
	sSocket = SERVICE_SOCKET(pgd); // we'll borrow this var for our debug spew
	DEBUGPRINTSOCK(5,"enum - return address = ",&sSocket); 
#endif // DEBUG

	hr = DoUDPEnumSessions(pgd, &sockaddr, addrlen, ped);
	if (FAILED(hr))
	{
		return hr;
	}

	// send a reliable enum sessions as well, duplicates will be filtered by dplay
	if ((pgd->AddressFamily == AF_INET) && (INADDR_BROADCAST != ((LPSOCKADDR_IN)&sockaddr)->sin_addr.s_addr))
	{				
		// poke the correct server port
		if (pgd->wApplicationPort)
		{
			// if app specified a port, let's use the mode specified
			// because we'll be enuming the app directly
			((LPSOCKADDR_IN)&sockaddr)->sin_port = htons(pgd->wApplicationPort);
			bOutBoundOnly = (pgd->dwFlags & DPSP_OUTBOUNDONLY);
		}
		else
		{
			// otherwise send enum to dplaysvr
			// see byte-order comment in dpsp.h for this constant
			((LPSOCKADDR_IN)&sockaddr)->sin_port = SERVER_STREAM_PORT;
			bOutBoundOnly = FALSE;
		}
		
		hr = DoTCPEnumSessionsAsync(pgd, &sockaddr, addrlen, ped, bOutBoundOnly);
	}
	
	// fall through

    DPF(5,"enum exiting");
    
    return DP_OK;

}// EnumSessions


#undef DPFSessions


#undef DPF_MODNAME
#define DPF_MODNAME	"SP_GetAddress"

// helper to handle local player address(es)
HRESULT WINAPI SP_GetAddressLocal(LPDPSP_GETADDRESSDATA pad)
{
	int i, j, count;
	HRESULT hr = DP_OK;
	PHOSTENT phostent;
	char *pszIPAddr, *pszBuf = NULL;
	WCHAR *pszIPAddrW, *pszBufW = NULL;
	LPDPCOMPOUNDADDRESSELEMENT paDPAddrEl = NULL;

	phostent = GetHostAddr();
	if (!phostent || !phostent->h_addr_list[0]) 
	{
		return DPERR_GENERIC;
	}

	// how many IP addresses do we have?
	for (count=0; phostent->h_addr_list[count]; count++) {}

	// allocate our DPAddress assembly buffers
	// ANSI and UNICODE elements for each IP address plus one SP guid
	// max size of IP address dot notation = 15 + terminator = 16
	ENTER_DPSP();
	// addressElement array
	paDPAddrEl = MemAlloc(sizeof(DPCOMPOUNDADDRESSELEMENT)*(2*count + 1));
	// one big buffer each for ANSI and UNICODE strings
	pszIPAddr = pszBuf = MemAlloc(16*count);
	pszIPAddrW = pszBufW = MemAlloc(sizeof(WCHAR)*(16*count));
	if (!paDPAddrEl || !pszBuf || !pszBufW)
	{
		ASSERT(FALSE);
		MemFree(paDPAddrEl);
		MemFree(pszBuf);
		MemFree(pszBufW);
		LEAVE_DPSP();
		return DPERR_NOMEMORY;
	}
	LEAVE_DPSP();
	
	// service provider chunk
	paDPAddrEl[0].guidDataType = DPAID_ServiceProvider;
	paDPAddrEl[0].dwDataSize = sizeof(GUID);
	paDPAddrEl[0].lpData = (LPVOID) &GUID_TCP;

	// make an ANSI and UNICODE string of each IP address
	for (i=0, j=1; i < count; i++)
	{
		DWORD dwStrLen;		// includes terminator
		IN_ADDR hostaddr;

		memcpy(&hostaddr, phostent->h_addr_list[i], sizeof(hostaddr));
		strcpy(pszIPAddr, inet_ntoa(hostaddr));
		dwStrLen = (DWORD)AnsiToWide(pszIPAddrW, pszIPAddr, 16);
		if (dwStrLen == 0 || dwStrLen > 16)
		{
			ASSERT(FALSE);
			hr = DPERR_GENERIC;
			goto cleanup;
		}

		paDPAddrEl[j].guidDataType = DPAID_INet;
		paDPAddrEl[j].dwDataSize = dwStrLen;
		paDPAddrEl[j++].lpData = pszIPAddr;
		paDPAddrEl[j].guidDataType = DPAID_INetW;
		paDPAddrEl[j].dwDataSize = dwStrLen * sizeof(WCHAR);
		paDPAddrEl[j++].lpData = pszIPAddrW;
		pszIPAddr += 16;	// bump buffer ptrs by max str size
		pszIPAddrW += 16;
	}

	// create the address
	hr = pad->lpISP->lpVtbl->CreateCompoundAddress(pad->lpISP,
				paDPAddrEl, 2*count+1, pad->lpAddress, pad->lpdwAddressSize);

cleanup:
	ENTER_DPSP();
	MemFree(paDPAddrEl);
	MemFree(pszBuf);
	MemFree(pszBufW);
	LEAVE_DPSP();

	return hr;
} // SP_GetAddressLocal

// get the ip address of the player from its playerdata
// ask winsock to convert that to a hostname
HRESULT WINAPI SP_GetAddress(LPDPSP_GETADDRESSDATA pad)
{
	HRESULT hr = DP_OK;
	LPSPPLAYERDATA ppd;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSTR pszNetName;
	UINT nStrLen;
	LPSOCKADDR_IN psockaddr;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	DPCOMPOUNDADDRESSELEMENT addressElements[3];
	WCHAR szNetNameW[HOST_NAME_LENGTH];

	// get the global data
	hr = pad->lpISP->lpVtbl->GetSPData(pad->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}
	

	if (AF_IPX == pgd->AddressFamily)
	{
		// not gonna happen
		return E_NOTIMPL;
	}

	hr = pad->lpISP->lpVtbl->GetSPPlayerData(pad->lpISP,pad->idPlayer,&ppd,&dwSize,DPGET_REMOTE);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		return hr;
	}
	
	if (pad->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)	
	{
		// We use a different approach for local players
		return SP_GetAddressLocal(pad);
	}
	else 
	{
		psockaddr = (LPSOCKADDR_IN)DGRAM_PSOCKADDR(ppd);
		pszNetName = inet_ntoa(psockaddr->sin_addr);
	}
	if (!pszNetName)
	{
		// rut ro
		DPF_ERR("got no string back from getaddress");
		return E_FAIL;
	}
	nStrLen = strlen(pszNetName)+1;

	DPF(2,"get address found address for player id %d = %s\n",pad->idPlayer,pszNetName);

	// get UNICODE version of address
	if (!AnsiToWide(szNetNameW, pszNetName, HOST_NAME_LENGTH))
		return (DPERR_GENERIC);

	// service provider chunk
	addressElements[0].guidDataType = DPAID_ServiceProvider;
	addressElements[0].dwDataSize = sizeof(GUID);
	addressElements[0].lpData = (LPVOID) &GUID_TCP;

	// ANSI name
	addressElements[1].guidDataType = DPAID_INet;
	addressElements[1].dwDataSize = nStrLen;
	addressElements[1].lpData = pszNetName;

	// UNICODE name
	addressElements[2].guidDataType = DPAID_INetW;
	addressElements[2].dwDataSize = nStrLen * sizeof(WCHAR);
	addressElements[2].lpData = szNetNameW;

	// create the address
	hr = pad->lpISP->lpVtbl->CreateCompoundAddress(pad->lpISP,
						addressElements, 3,
						pad->lpAddress, pad->lpdwAddressSize);

	return hr;

} // SP_GetAddress

#undef DPF_MODNAME
#define DPF_MODNAME	"Reply"
// called by ReplyThreadProc to send the reply out on the wire
HRESULT SendReply(LPGLOBALDATA pgd,LPREPLYLIST prd)
{
	HRESULT hr;
	SOCKET sSocket;
	UINT addrlen = sizeof(SOCKADDR);
	UINT err;
	BOOL bConnectionExists = FALSE;

	// now, send out prd		
	switch (pgd->AddressFamily)
    {
		case AF_INET:
		{
			DPID dpidPlayer=0;

#ifdef FULLDUPLEX_SUPPORT
			// if client wants us to reuse a connection, it would have indicated so and the connection
			// would have been added to our send list by now. See if it exists.
			
			// todo - we don't want to search the receive list everytime -  find a better way
			bConnectionExists = FindSocketInBag(pgd, &prd->sockaddr, &prd->sSocket,&dpidPlayer);
#endif // FULLDUPLEX_SUPPORT
			
			if (!bConnectionExists)
			{

				// socket didn't exist in our send list, let's send it on a new temporary connection
				
				DEBUGPRINTADDR(9,"Sending reply on a new connection to - ", &(prd->sockaddr));				

				hr = CreateSocket(pgd,&sSocket,SOCK_STREAM,0,INADDR_ANY,&err,FALSE);
				if (FAILED(hr)) 
				{
					DPF(0,"create reply socket failed - err = %d\n",err);
					return hr;
				}

				SetReturnAddress(prd->lpMessage,pgd->sSystemStreamSocket);		
				hr = SPConnect(&sSocket,(LPSOCKADDR)&(prd->sockaddr),addrlen,FALSE);
				if (FAILED(hr))
				{
					DEBUGPRINTADDR(0,"reply - connect failed - addr = ",(LPSOCKADDR)&(prd->sockaddr));
				}
				else 
				{
					DEBUGPRINTADDR(9,"Sending reply to - ", &(prd->sockaddr));
					err = send(sSocket,prd->lpMessage,prd->dwMessageSize,0);					
					if (SOCKET_ERROR == err) 
				    {
				        err = WSAGetLastError();
				        DPF(0,"reply - send error - err = %d\n",err);
						hr = E_FAIL;
				    }
				}
				
				// nuke the socket
				KillSocket(sSocket,TRUE,FALSE);
				
			}
			else
			{
				DEBUGPRINTADDR(9,"Sending reply on an existing connection to - ", &(prd->sockaddr));				

				err = send(prd->sSocket,prd->lpMessage,prd->dwMessageSize,0);					
				if (SOCKET_ERROR == err) 
				{
				       err = WSAGetLastError();
				       DPF(0,"reply - send error - err = %d\n",err);
					hr = E_FAIL;
				}

				// close the connection if it's a temporary one (no player id yet).
				if (0 == dpidPlayer)
				{
					RemoveSocketFromReceiveList(pgd,prd->sSocket);
					RemoveSocketFromBag(pgd,prd->sSocket);
				}
			}
			
			break;
		}

		case AF_IPX:
		{
			hr = CreateSocket(pgd,&sSocket,SOCK_DGRAM,0,INADDR_ANY,&err,FALSE);
			if (FAILED(hr)) 
			{
				DPF(0,"create reply socket failed - err = %d\n",err);
				return hr;
			}

			SetReturnAddress(prd->lpMessage,pgd->sSystemDGramSocket);		
    		err = sendto(sSocket,prd->lpMessage,prd->dwMessageSize,0,
				(LPSOCKADDR)&(prd->sockaddr),addrlen);
			if (SOCKET_ERROR == err) 
		    {
		        err = WSAGetLastError();
		        DPF(0,"reply - send error - err = %d\n",err);
				hr = E_FAIL;
		    }

			// nuke the socket
			KillSocket(sSocket,FALSE,FALSE);

			break;
		}
	
		default:
			hr = E_FAIL;		
			ASSERT(FALSE);
			break;
    }  
	
	return hr;
	
} // SendReply


DWORD WINAPI ReplyThreadProc(LPVOID pvCast)
{
	LPREPLYLIST prd,prdNext;
	HRESULT hr=DP_OK;
	DWORD dwRet;
	LPGLOBALDATA pgd = (LPGLOBALDATA) pvCast;
	
	
	while (1)
	{
		// wait on our event.  when it's set, we either split, or empty the reply list
		dwRet = WaitForSingleObject(pgd->hReplyEvent,INFINITE);
		if (WAIT_OBJECT_0 != dwRet)
		{
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}

		// shutdown?		
		if (pgd->bShutdown)
		{
			goto CLEANUP_EXIT;
		}

	Top:
		// find our reply node
		ENTER_DPSP();
		
		// take the first one off the list
		prd = pgd->pReplyList;		
		if (pgd->pReplyList) pgd->pReplyList = pgd->pReplyList->pNextReply;
		
		LEAVE_DPSP();
		
		while (prd)
		{
			hr = SendReply(pgd,prd);
			if (FAILED(hr))
			{
				DPF_ERR("SendReply failed hr = 0x%08lx\n");
				// we can't reach the guy, clean out other async sends.
				RemovePendingAsyncSends(pgd, prd->dwPlayerTo);
				goto Top;
			}
			
			// free up the reply node
			ENTER_DPSP();
				
			if (prd->lpMessage) MemFree(prd->lpMessage);
			MemFree(prd);

			// take the next one off the list
			prd = pgd->pReplyList;
			if (pgd->pReplyList) pgd->pReplyList = pgd->pReplyList->pNextReply;
				
			LEAVE_DPSP();
		}

	} // 1

CLEANUP_EXIT:
	
	ENTER_DPSP();

	// cleanout reply list
	prd = pgd->pReplyList;	
	while (prd)
	{
		prdNext = prd->pNextReply;
		if (prd->lpMessage) MemFree(prd->lpMessage);
		MemFree(prd);
		prd = prdNext;
	}
	pgd->pReplyList = NULL;
	
	CloseHandle(pgd->hReplyEvent);
	pgd->hReplyEvent = 0;
	
	LEAVE_DPSP();
	
	DPF(6,"replythreadproc exit");
	
	return 0;
	
}  // ReplyThreadProc

HRESULT StartReplyThread(LPGLOBALDATA pgd)
{
	HANDLE hThread;
	DWORD dwThreadID;
	
	// 1st, create the event
	pgd->hReplyEvent = CreateEvent(NULL,FALSE,FALSE,NULL);	
	if (!pgd->hReplyEvent)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// now, spin the thread	
	if (hWS2 && (AF_IPX != pgd->AddressFamily))
	{
	    hThread = CreateThread(NULL,0,AsyncSendThreadProc,pgd,0,&dwThreadID);	
	}
	else 
	{
	    hThread = CreateThread(NULL,0,ReplyThreadProc,pgd,0,&dwThreadID);		
	}

	if (!hThread)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
	pgd->hReplyThread = hThread;
	
	return DP_OK;
	
} // StartReplyThread

HRESULT WINAPI InternalSP_Reply(LPDPSP_REPLYDATA prd, DPID dwPlayerID)
{
    LPSOCKADDR psockaddr;
    HRESULT hr=DP_OK;
	LPMESSAGEHEADER phead;
	LPBYTE pSendBufferCopy;
	LPREPLYLIST prl,prlList;	
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;

	// get the global data
	hr =prd->lpISP->lpVtbl->GetSPData(prd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}
	
	if (prd->dwMessageSize > SPMAXMESSAGELEN)
	{
		ASSERT(FALSE); 
		return DPERR_SENDTOOBIG;
	}

	// check the header
	if (!prd->lpSPMessageHeader || !VALID_DPWS_MESSAGE(prd->lpSPMessageHeader))
	{
		DPF_ERR("	YIKES! Got invalid SP header - can't reply ");
		ASSERT(FALSE);
		return E_FAIL;
	}
    
	// get the address to reply to
	phead = (LPMESSAGEHEADER)prd->lpSPMessageHeader;
    psockaddr = &(phead->sockaddr);
	DEBUGPRINTADDR(5,"reply - sending to ",psockaddr);

    DPF(7,"reply - q'ing %d bytes hEvent = 0x%08lx\n",prd->dwMessageSize,pgd->hReplyEvent);

	// stick the message size in the message
	SetMessageHeader(prd->lpMessage,prd->dwMessageSize,TOKEN);

	// build a copy of everything for our receive thread
	ENTER_DPSP();
	
	prl = MemAlloc(sizeof(REPLYLIST));
	
	if (!prl)
	{
		LEAVE_DPSP();				
		DPF_ERR("could not send reply - out of memory");
		return E_OUTOFMEMORY;
	}

	
	pSendBufferCopy = MemAlloc(prd->dwMessageSize);
	if (!pSendBufferCopy)
	{
		MemFree(prl);
		LEAVE_DPSP();
		DPF_ERR("could not send reply - out of memory");
		return E_OUTOFMEMORY;
	}
	
	memcpy(pSendBufferCopy,prd->lpMessage,prd->dwMessageSize);
	
	prl->lpMessage = pSendBufferCopy;
	prl->dwMessageSize = prd->dwMessageSize;
	prl->sockaddr = *psockaddr;
	prl->sSocket = INVALID_SOCKET;
	// since are replies could be sent async, we need to keep track
	// of how many bytes have gone out
	prl->pbSend = pSendBufferCopy;
	prl->dwBytesLeft = prd->dwMessageSize;
	prl->dwPlayerTo=dwPlayerID; 	
	// put prl on the end of the reply list
	prlList = pgd->pReplyList;
	if (!prlList)
	{
		pgd->pReplyList = prl;	
	}
	else
	{
		// find the end
		while (prlList->pNextReply) prlList = prlList->pNextReply;
		ASSERT(!prlList->pNextReply);
		prlList->pNextReply = prl;
	}
	 
	// do we need to start the reply event?
	if (!pgd->hReplyThread)
	{
		hr = StartReplyThread(pgd);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	LEAVE_DPSP();
		
	// tell the reply event to do its thing
	SetEvent(pgd->hReplyEvent);
	
    return DP_OK;
	
}	// reply

/*
 ** Reply
 *
 *  CALLED BY: DPLAY
 *
 *  PARAMETERS: prd - see dplayi.h
 *
 *  DESCRIPTION:
 *		when one of the receive loops calls into dplay, dplay may call reply.
 *		the receive loop extracts the return address out of the message, and passes
 *		it to dplay .  dplay passes this to reply (via prd), which figures out how to send the
 *		return message.
 *		
 *
 *  RETURNS:   E_FAIL on a socket error or DP_OK.
 *
 */
HRESULT WINAPI SP_Reply(LPDPSP_REPLYDATA prd)
{
	return InternalSP_Reply(prd, 0);
}



#undef DPF_MODNAME
#define DPF_MODNAME	"CreatePlayer"

// 
// if we're starting up a nameserver, register it w/ dphelp.exe
// see %MANROOT%\misc\w95help.c and %MANROOT%\ddhelp\dphelp.c
HRESULT StartDPHelp(LPGLOBALDATA pgd, USHORT port)
{
	DWORD hpid = 0, dwFlags=0;
	HRESULT	hr;

	CreateHelperProcess( &hpid );
	
	if (!hpid)
	{
		// could't start one...
		return DPERR_UNAVAILABLE;
	}

	if (!WaitForHelperStartup())
	{
		return DPERR_UNAVAILABLE;
	}
	
	hr = HelperAddDPlayServer(port);

	return hr;

}  // StartDPHelp


//
// we've just created a player of type dwFlags. 
// if it's a system player, see if we need to start up our receive thread procs
//
HRESULT StartPlayerListenThreads(IDirectPlaySP * pISP,LPGLOBALDATA pgd,DWORD dwFlags)
{
	DWORD dwThreadID;
	HANDLE hThread;
		
	if ( !(dwFlags & DPLAYI_PLAYER_SYSPLAYER) ) return DP_OK;
	
	if (!pgd->hDGramReceiveThread)
	{
		ASSERT(INVALID_SOCKET != pgd->sSystemDGramSocket);
	    hThread = CreateThread(NULL,0,DgramListenThreadProc,
			(LPVOID)pISP,0,&dwThreadID);
		ASSERT(hThread);
		if(pgd->hDGramReceiveThread = hThread){ // check for non-zero hThread
			SetThreadPriority(hThread, THREAD_PRIORITY_ABOVE_NORMAL);
		}
		
	}
	if ( (AF_IPX != pgd->AddressFamily) && !(pgd->hStreamReceiveThread) )
	{		
		ASSERT(INVALID_SOCKET != pgd->sSystemStreamSocket);
	    hThread = CreateThread(NULL,0,StreamReceiveThreadProc,
			(LPVOID)pISP,0,&dwThreadID);			
		ASSERT(hThread);		
		if(pgd->hStreamReceiveThread = hThread){ // check for non-zero hThread
			SetThreadPriority(hThread, THREAD_PRIORITY_ABOVE_NORMAL);
		}
	}

	return DP_OK;
	
} // StartPlayerListenThreads
	
// create a player.  get a stream and dgram socket for it, and start their listen threads.
HRESULT WINAPI SP_CreatePlayer(LPDPSP_CREATEPLAYERDATA pcpd) 
{
    HRESULT hr=DP_OK;
	LPSPPLAYERDATA ppd;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;

	// get the global data
	hr =pcpd->lpISP->lpVtbl->GetSPData(pcpd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (!(pcpd->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		DWORD dwSize = sizeof(SPPLAYERDATA);
		LPMESSAGEHEADER pmsg;

		hr = pcpd->lpISP->lpVtbl->GetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,&ppd,&dwSize,DPGET_REMOTE);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			return hr;
		}

		if (sizeof(SPPLAYERDATA) != dwSize)
		{
			// this can happen if it's a game server supplied player
			return DP_OK;
		}
		
		pmsg = (LPMESSAGEHEADER)pcpd->lpSPMessageHeader;
		if (!pmsg)
		{
			// this can happen if it's a game server supplied player
			return DP_OK;
		}
		// make it multihomed.  we passed the received address w/ the createplayer message.
		// set the receive address on the player here.

		// if the ip addr wasn't set, this player hasn't been "homed" yet.
		// we set it here.
		if (AF_INET == pgd->AddressFamily)
		{
			IP_GetAddr((SOCKADDR_IN *)DGRAM_PSOCKADDR(ppd),(SOCKADDR_IN *)&(pmsg->sockaddr));
			IP_GetAddr((SOCKADDR_IN *)STREAM_PSOCKADDR(ppd),(SOCKADDR_IN *)&(pmsg->sockaddr));
			
#ifdef FULLDUPLEX_SUPPORT
			// if client want's us to reuse a connection, the socket would have been added to the 
			// send bag already, but the id would be 0. Update the player id.
			UpdateSocketPlayerID(pgd,&pmsg->sockaddr,pcpd->idPlayer);
#endif // FULLDUPLEX_SUPPORT		
		}
		else if (AF_IPX == pgd->AddressFamily) 
		{
			IPX_GetNodenum((SOCKADDR_IPX *)DGRAM_PSOCKADDR(ppd),(SOCKADDR_IPX *)&(pmsg->sockaddr));
			IPX_GetNodenum((SOCKADDR_IPX *)STREAM_PSOCKADDR(ppd),(SOCKADDR_IPX *)&(pmsg->sockaddr));
		}
		return DP_OK;
	} // !Local

	// it's local, so get it some sockets + threads if we need to

	// alloc the sp player data for this player
	ENTER_DPSP();
	
	ppd = MemAlloc(sizeof(SPPLAYERDATA));
	
	LEAVE_DPSP();
	
	if (!ppd) 
	{
		DPF_ERR("could not alloc player data struct");
		return E_OUTOFMEMORY;
	}

	hr =  CreatePlayerDgramSocket(pgd,ppd,pcpd->dwFlags);
	if (FAILED(hr))
	{
		DPF_ERR("could not create dgram socket"); 
		goto CLEANUP_EXIT;
	}

	if (AF_IPX != pgd->AddressFamily)
	{
		hr =  CreatePlayerStreamSocket(pgd,ppd,pcpd->dwFlags);
		if (FAILED(hr))
		{
			DPF_ERR("could not create stream socket"); 
			goto CLEANUP_EXIT;
		}
	}
	 
	// store the ppd
	hr = pcpd->lpISP->lpVtbl->SetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,ppd,dwSize,DPSET_REMOTE);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		goto CLEANUP_EXIT;
	}

	// see if we need to start listen thread for this player type.
	hr = StartPlayerListenThreads(pcpd->lpISP,pgd,pcpd->dwFlags);
	
	// if we need ddhelp, start it up
	if ((AF_IPX != pgd->AddressFamily) && (pcpd->dwFlags & DPLAYI_PLAYER_NAMESRVR))
	{
		// it's ok to pass dgram port to dplaysvr always - we use the same number for stream
		// socket as well
	    hr = StartDPHelp(pgd,IP_DGRAM_PORT(ppd));
	    if (FAILED(hr))
	    {
			// ddhelp.exe barfed
	    	DPF_ERR(" CREATE SERVER - COULD NOT START ENUM LISTEN APPLICATION");
			DPF_ERR(" GAME WILL PLAY - BUT WILL NOT RECEIVE ENUMSESSIONS REQUESTS");
			goto CLEANUP_EXIT;
	    }
	}

	// fall through to clean up
CLEANUP_EXIT:	

	ENTER_DPSP();
	
	if (ppd) MemFree(ppd);
	
	LEAVE_DPSP();
	
    return hr;

} // CreatePlayer

#undef DPF_MODNAME
#define DPF_MODNAME	"DeletePlayer"
void RemovePlayerFromSocketBag(LPGLOBALDATA pgd,DWORD dwID)
{
	UINT i=0;
	BOOL bFound = FALSE;
	SOCKET sSocket=INVALID_SOCKET;
	DWORD dwSocketFlags;
	
	if (0 == dwID)
	{
		return;
	}

	ENTER_DPSP();

	// see if we've got one
	while (!bFound && (i<pgd->nSocketsInBag))
	{
		if (pgd->BagOSockets[i].dwPlayerID == dwID) 
		{
			bFound = TRUE;
			sSocket = pgd->BagOSockets[i].sSocket;			
			dwSocketFlags = pgd->BagOSockets[i].dwFlags;
			
			DPF(5,"removing socket from bago id = %d, slot = %d",dwID,i);
			pgd->BagOSockets[i].sSocket = INVALID_SOCKET;
			pgd->BagOSockets[i].dwPlayerID = 0;
		}
		else i++;
	}

	LEAVE_DPSP();
	
	if (bFound)	
	{
		if (INVALID_SOCKET == sSocket) return ;

		// if socket is fullduplex, remove it from the receive list as well
		if (dwSocketFlags & DPSP_OUTBOUNDONLY)
		{
			// this function will kill the socket as well
			RemoveSocketFromReceiveList(pgd,sSocket);
		}
		else
		{		
			KillSocket(sSocket,TRUE,FALSE);
		}
	}

	return ;
	
} // RemovePlayerFromSocketBag

HRESULT WINAPI SP_DeletePlayer(LPDPSP_DELETEPLAYERDATA pdpd) 
{
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
	DWORD sleepcount=0;


	DPF(9, "Entering SP_DeletePlayer, player %d, flags 0x%x, lpISP 0x%08x\n",
		pdpd->idPlayer, pdpd->dwFlags, pdpd->lpISP);
	
	// get the global data
	hr =pdpd->lpISP->lpVtbl->GetSPData(pdpd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	// give the reply list 5 seconds to clear out
	while(bAsyncSendsPending(pgd, pdpd->idPlayer)){
		Sleep(100);
		if(sleepcount++ == 50){
			break;
		}
	}

	RemovePendingAsyncSends(pgd, pdpd->idPlayer);

	// if it's not local, we don't care
	if (!(pdpd->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		RemovePlayerFromSocketBag(pgd,pdpd->idPlayer);
		return DP_OK;
	}

	// if it's not a sysplayer - we're done
	// if its a sysplayer, we kill 'em, cause we may need to rebind to a new port
	if (!(pdpd->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
	{
		return DP_OK;
	}
	
	if ( (pdpd->dwFlags & DPLAYI_PLAYER_NAMESRVR)  && (AF_IPX != pgd->AddressFamily) )
	{
		USHORT port;
		LPSPPLAYERDATA ppd;
		DWORD dwSize = sizeof(SPPLAYERDATA);
		 
		// we need to get the port to to delete the server 
		hr = pdpd->lpISP->lpVtbl->GetSPPlayerData(pdpd->lpISP,pdpd->idPlayer,&ppd,&dwSize,DPGET_REMOTE);
		if ( FAILED(hr) || (sizeof(SPPLAYERDATA) != dwSize) )
		{
			ASSERT(FALSE);
		}
		else 
		{
			// tell dplaysvr to delete this server
			port = IP_DGRAM_PORT(ppd);
		    if ( !HelperDeleteDPlayServer(port) )
		    {
				// ddhelp.exe barfed
		    	DPF_ERR(" could not unregister w/ dphelp");
				// keep going...
		    }
		}
	}

	return DP_OK;

} // DeletePlayer

#undef DPF_MODNAME
#define DPF_MODNAME	"UnreliableSend"
HRESULT UnreliableSend(LPDPSP_SENDDATA psd)
{
    SOCKADDR sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr=DP_OK;
    UINT err;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	
	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (pgd->iMaxUdpDg && (psd->dwMessageSize >= pgd->iMaxUdpDg))
	{
		return DPERR_SENDTOOBIG;
	}

	if (INVALID_SOCKET == pgd->sUnreliableSocket)
	{
	    hr = CreateSocket(pgd,&(pgd->sUnreliableSocket),SOCK_DGRAM,0,INADDR_ANY,&err,FALSE);
	    if (FAILED(hr)) 
	    {
	        DPF(0,"create unreliable send socket failed - err = %d\n",err);
	        return hr;
	    }
	}

	// get to address	
    if (0 == psd->idPlayerTo) 
    {
		sockaddr = pgd->saddrNS;
    }
    else
    {
		hr = psd->lpISP->lpVtbl->GetSPPlayerData(psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize,DPGET_REMOTE);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			return hr;
		}

		sockaddr = *(DGRAM_PSOCKADDR(ppdTo));
    }

	// put the token + size on front of the mesage
	SetMessageHeader(psd->lpMessage,psd->dwMessageSize,TOKEN);

	if (psd->bSystemMessage) 
    {
		SetReturnAddress(psd->lpMessage,SERVICE_SOCKET(pgd));
    } // reply
	else 
	{
		// see if we can send this message w/ no header
		// if the message is smaller than a dword, or, if it's a valid sp header (fooling us
		// on the other end, don't send any header
		if ( !((psd->dwMessageSize >= sizeof(DWORD)) &&  !(VALID_SP_MESSAGE(psd->lpMessage))) )
		{
			psd->lpMessage = (LPBYTE)psd->lpMessage +sizeof(MESSAGEHEADER);
			psd->dwMessageSize -= sizeof(MESSAGEHEADER);
		}
	}
    
	DEBUGPRINTADDR(5,"unreliable send - sending to ",&sockaddr);	

   	err = sendto(pgd->sUnreliableSocket,psd->lpMessage,psd->dwMessageSize,0,
   		(LPSOCKADDR)&sockaddr,iAddrLen);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"send error - err = %d\n",err);
        hr = E_UNEXPECTED;
    }

// fall through...
    return hr;
        
} // UnreliableSend

#undef DPF_MODNAME
#define DPF_MODNAME	"ReliableSend"

// see if we can find or create a connected socket in our
// bag o' sockets for player dwID
HRESULT GetSocketFromBag(LPGLOBALDATA pgd,SOCKET * psSocket, DWORD dwID,
LPSOCKADDR psockaddr)
{
	HRESULT hr;
	UINT i=0;
	BOOL bFound = FALSE;
	BOOL bTrue = TRUE;
	UINT err;
	SOCKET sSocket;
	
	DPF(9, "GetSocketFromBag for id %d",dwID);

	if (0 == dwID)
	{
		// need a real id
		return E_FAIL;
	}

	ENTER_DPSP();

	// see if we've got one	already hooked up
	while ((i < pgd->nSocketsInBag) && !bFound)
	{
		// if it's a valid socket and the id's match, use it
		if ( (INVALID_SOCKET != pgd->BagOSockets[i].sSocket) && 
			(pgd->BagOSockets[i].dwPlayerID == dwID) )
		{
			bFound = TRUE;
		}
		else i++;
	}

	LEAVE_DPSP();

	if (bFound)	
	{
		// bingo! got one
		DPF(7, "Found socket in bag for player %d",dwID);
		*psSocket = pgd->BagOSockets[i].sSocket;
		return DP_OK;
	}

	// we don't have a socket for this player, let's get a new one
	DPF(5,"adding new socket to bag for id = %d, slot = %d",dwID,i);

	// create and connect socket
	hr = CreateAndConnectSocket(pgd,&sSocket,SOCK_STREAM,psockaddr, (pgd->dwFlags & DPSP_OUTBOUNDONLY));
	if (FAILED(hr))
	{
		return hr;
	}

	// enable keepalives
    if( SOCKET_ERROR == setsockopt( sSocket,SOL_SOCKET,SO_KEEPALIVE,
		(char FAR *)&bTrue,sizeof(bTrue) ) )
    {
        err = WSAGetLastError();
		DPF(2,"create - could not turn on keepalive err = %d\n",err);
		// keep trying
    }

	hr = AddSocketToBag(pgd, sSocket, dwID, psockaddr,0);
	if (FAILED(hr))
	{
		DPF(0,"Failed to add socket to bag: hr = 0x%08x", hr);
		return hr;
	}
	DPF(7,"Created a new socket for player %d",dwID);
	
	*psSocket = sSocket ;

	return hr;
	
} // GetSocketFromBag



HRESULT ReliableSend(LPDPSP_SENDDATA psd)
{
    SOCKET sSocket = INVALID_SOCKET;
    SOCKADDR sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo;
	BOOL fKillSocket = FALSE; // don't kill this socket, it's from the bago
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;

	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	// get player to
    if (0 == psd->idPlayerTo) 
    {
		sockaddr = pgd->saddrNS;
    }
    else
    {
		hr = psd->lpISP->lpVtbl->GetSPPlayerData(psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize,DPGET_REMOTE);
		if (FAILED(hr))
		{
			DPF(1, "GetSPPlayerData for player %d returned err %d", psd->idPlayerTo, hr);
			if (hr != DPERR_INVALIDPLAYER) 	// this can happen because of race conditions
				ASSERT(FALSE);
			return hr;
		}

		sockaddr = *(STREAM_PSOCKADDR(ppdTo));
    }

	if (psd->bSystemMessage) 
	{
		SetReturnAddress(psd->lpMessage,SERVICE_SOCKET(pgd));
	}

	// put the token + size on front of the mesage
	SetMessageHeader(psd->lpMessage,psd->dwMessageSize,TOKEN);

	DEBUGPRINTADDR(5,"reliable send - sending to ",&sockaddr);

	hr = InternalReliableSend(pgd,psd->idPlayerTo,&sockaddr, psd->lpMessage, psd->dwMessageSize);

    return hr;
    
} // InternalReliableSend

// puts together a replynode, and calls sp_reply to do 
// an async send
HRESULT AsyncSend(LPDPSP_SENDDATA psd)
{
    SOCKADDR sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	MESSAGEHEADER head;
	DPSP_REPLYDATA rd;
	
	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	// get player to
    if (0 == psd->idPlayerTo) 
    {
		sockaddr = pgd->saddrNS;
    }
    else
    {
		hr = psd->lpISP->lpVtbl->GetSPPlayerData(psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize,DPGET_REMOTE);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			return hr;
		}

		sockaddr = *(STREAM_PSOCKADDR(ppdTo));
    }

	// write the return address into the on the wire message
	SetReturnAddress(psd->lpMessage,SERVICE_SOCKET(pgd));

	// put the token + size on front of the mesage
	SetMessageHeader(psd->lpMessage,psd->dwMessageSize,TOKEN);
	
	// set up a header.  this will be passed to reply, and will tell the reply thread
	// whre to send teh message
	head.sockaddr = sockaddr;
	// put our token on the front so the reply thread knows its a valid reply
	SetMessageHeader((LPDWORD)(&head),0,TOKEN); 
	
	// use SP_Reply to send this for us...
	memset(&rd,0,sizeof(rd));
	rd.lpSPMessageHeader = &head;
	rd.lpMessage = psd->lpMessage;
	rd.dwMessageSize = psd->dwMessageSize;
   	rd.lpISP = psd->lpISP;
	
	hr = InternalSP_Reply(&rd,psd->idPlayerTo);
	
	return hr;

} // AsyncSend

#ifdef SENDEX

HRESULT WINAPI SP_GetMessageQueue(LPDPSP_GETMESSAGEQUEUEDATA pgqd)
{

	LPGLOBALDATA pgd;
	DWORD        dwDataSize;
	BILINK       *pBilinkWalker;
	DWORD        dwNumMsgs = 0;
	DWORD        dwNumBytes = 0;

	LPSENDINFO lpSendInfo;
	HRESULT hr;

	hr = pgqd->lpISP->lpVtbl->GetSPData(pgqd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);

	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	EnterCriticalSection(&pgd->csSendEx);

	if(!pgqd->idFrom && !pgqd->idTo){
		// just wants totals, I already know that!
		dwNumMsgs  = pgd->dwMessagesPending;
		dwNumBytes = pgd->dwBytesPending;
	} else {
		// gotta walk the list.
		pBilinkWalker=pgd->PendingSendQ.next;
		while(pBilinkWalker != &pgd->PendingSendQ) 
		{
			lpSendInfo=CONTAINING_RECORD(pBilinkWalker, SENDINFO, PendingSendQ);
			pBilinkWalker=pBilinkWalker->next;

			if(pgqd->idTo && pgqd->idFrom) {
			
				if(lpSendInfo->idTo==pgqd->idTo && lpSendInfo->idFrom==pgqd->idFrom){
					dwNumMsgs++;
					dwNumBytes+=lpSendInfo->dwMessageSize;
				}	
				
			} else if (pgqd->idTo){
				if(lpSendInfo->idTo==pgqd->idTo){
					dwNumMsgs++;
					dwNumBytes+=lpSendInfo->dwMessageSize;
				}	
			} else if (pgqd->idFrom) {
				if(lpSendInfo->idFrom==pgqd->idFrom){
					dwNumMsgs++;
					dwNumBytes+=lpSendInfo->dwMessageSize;
				}	
			} else {
				ASSERT(0);
			}
		}
	}

	LeaveCriticalSection(&pgd->csSendEx);

	if(pgqd->lpdwNumMsgs){
		*pgqd->lpdwNumMsgs = dwNumMsgs;
	}
	if(pgqd->lpdwNumBytes){
		*pgqd->lpdwNumBytes = dwNumBytes;
	}	
	
	
	return DP_OK;

}

HRESULT WINAPI SP_SendEx(LPDPSP_SENDEXDATA psd)
{
    HRESULT hr=DP_OK;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	LPSENDINFO lpSendInfo;

	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (psd->dwMessageSize >= SPMAXMESSAGELEN)
	{
		return DPERR_SENDTOOBIG;
	}

	// overlapped and SPheader buffer are allocated together.
	lpSendInfo     = pgd->pSendInfoPool->Get(pgd->pSendInfoPool);
	if(!lpSendInfo){
		hr=DPERR_OUTOFMEMORY;
		DPF(0,"WSOCK: sendex couldn't allocate overlapped, out of memory!\n");
		goto EXIT;
	}
	
	lpSendInfo->SendArray[0].buf = (CHAR *)(lpSendInfo+1);
	lpSendInfo->SendArray[0].len = sizeof(MESSAGEHEADER);

	ASSERT(psd->cBuffers < MAX_SG-1); //BUGBUG: coalesce please!
	
	memcpy(&lpSendInfo->SendArray[1], psd->lpSendBuffers, psd->cBuffers*sizeof(SGBUFFER));

	if ((psd->dwFlags & DPSEND_GUARANTEE) && (AF_IPX != pgd->AddressFamily))
    {
        hr = ReliableSendEx(psd,lpSendInfo);	
		if (hr!=DPERR_PENDING && FAILED(hr)) {
			pgd->pSendInfoPool->Release(pgd->pSendInfoPool, lpSendInfo);
			DPF(0,"reliable sendex failed - error - hr = 0x%08lx\n",hr);
		}
    }
    else
    {
    	hr = UnreliableSendEx(psd,lpSendInfo);
		if (hr!=DPERR_PENDING && FAILED(hr)) {
			pgd->pSendInfoPool->Release(pgd->pSendInfoPool, lpSendInfo);
			DPF(0,"unreliable sendex failed - error -  hr = 0x%08lx\n",hr);
		}	
    }
EXIT:
    return hr;

} // send



HRESULT ReliableSendEx(LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo)
{
    SOCKET sSocket = INVALID_SOCKET;
    SOCKADDR sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo;
	BOOL fKillSocket = FALSE; // don't kill this socket, it's from the bago
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;

	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	// get player to
    if (0 == psd->idPlayerTo) 
    {
		sockaddr = pgd->saddrNS;
    }
    else
    {
		hr = psd->lpISP->lpVtbl->GetSPPlayerData(psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize,DPGET_REMOTE);
		if (FAILED(hr))
		{
			DPF(1, "GetSPPlayerData for player %d returned err %d", psd->idPlayerTo, hr);
			if (hr != DPERR_INVALIDPLAYER) 	// this can happen because of race conditions
				ASSERT(FALSE);
			return hr;
		}

		sockaddr = *(STREAM_PSOCKADDR(ppdTo));
    }

	if (psd->bSystemMessage) 
	{
		SetReturnAddress((pSendInfo->SendArray)[0].buf,SERVICE_SOCKET(pgd));
	}

	// put the token + size on front of the mesage
	SetMessageHeader((LPVOID)(pSendInfo->SendArray)[0].buf,psd->dwMessageSize+sizeof(MESSAGEHEADER),TOKEN);

	DEBUGPRINTADDR(5,"reliable send - sending to ",&sockaddr);

	hr = InternalReliableSendEx(pgd,psd,pSendInfo,&sockaddr);

    return hr;
    
} // ReliableSendEx

#endif //SENDEX

HRESULT InternalReliableSend(LPGLOBALDATA pgd, DPID idPlayerTo, SOCKADDR *
							lpSockAddr, LPBYTE lpMessage, DWORD dwMessageSize)
{
	HRESULT hr;
	SOCKET sSocket = INVALID_SOCKET;
	UINT err;

	// see if we have a connection already
	hr = GetSocketFromBag(pgd,&sSocket,idPlayerTo,lpSockAddr);		
	if (SUCCEEDED(hr))
	{
		// we do, send the message
		err = send(sSocket,lpMessage,dwMessageSize,0);
		if (SOCKET_ERROR == err) 
		{
			err = WSAGetLastError();
			// we got a socket from the bag.  send failed,
			// so we're cruising it from the bag
			DPF(0,"send error - err = %d\n",err);
			DPF(4,"send failed - removing socket from bag");
			RemovePlayerFromSocketBag(pgd,idPlayerTo);
			if(err==WSAECONNRESET || err==WSAENETRESET || err==WSAENOTCONN){
				hr=DPERR_CONNECTIONLOST;
			} else {
				hr = E_FAIL;
			}
		}

		return hr;
	}

	// if we reach here, we don't have a connection so get a new one

	hr = CreateAndConnectSocket(pgd,&sSocket,SOCK_STREAM,lpSockAddr, (pgd->dwFlags & DPSP_OUTBOUNDONLY));
	if (FAILED(hr))
	{
		goto CLEANUP_EXIT;
	}

	// send the message
	err = send(sSocket,lpMessage,dwMessageSize,0);
	if (SOCKET_ERROR == err) 
	{
		err = WSAGetLastError();
		DPF(0,"send error - err = %d\n",err);
		if(err == WSAECONNRESET || err==WSAENETRESET || err==WSAENOTCONN){
			hr = DPERR_CONNECTIONLOST;
		} else {
			hr = E_FAIL;
		}	
		goto CLEANUP_EXIT;
	}

	// success
	hr = DP_OK;

	// fall through

CLEANUP_EXIT:

	// if we are in outbound only mode, receiver will close the connection, so don't bother
	if ((INVALID_SOCKET != sSocket) && !(pgd->dwFlags & DPSP_OUTBOUNDONLY))
	{
		KillSocket(sSocket, TRUE, FALSE);
	}
	return hr;
}

// called when a to player can't be reached or is deleted.
VOID RemovePendingAsyncSends(LPGLOBALDATA pgd, DPID dwPlayerTo)
{
	LPREPLYLIST prl, prlPrev;
	#ifdef DEBUG
	DWORD dwBlowAwayCount=0;
	#endif
	if(!dwPlayerTo){
		return;
	}
	
	ENTER_DPSP();
	
	prlPrev = (LPREPLYLIST)(&pgd->pReplyList); // HACKHACK, treat struct as dummy node.
	prl     = pgd->pReplyList;
	
	while(prl){
		if(prl->dwPlayerTo == dwPlayerTo){
			prlPrev->pNextReply=prl->pNextReply;
			if(prl->lpMessage) {
				MemFree(prl->lpMessage);
			}	
			MemFree(prl);
			#ifdef DEBUG
			dwBlowAwayCount++;
			#endif
		} else {
			prlPrev=prl;
		}	
		prl=prlPrev->pNextReply;
		
	}
	DPF(4,"RemovePendingAsyncSends for player %x, blew away %d pending sends\n",dwPlayerTo,dwBlowAwayCount);
	LEAVE_DPSP();
}

// In order to ensure send ordering even if we are doing async sends, we 
// check and wait for any pending async sends to complete.  If they don't complete
// in 5 seconds then we make the send async.
BOOL bAsyncSendsPending(LPGLOBALDATA pgd, DPID dwPlayerTo)
{
	LPREPLYLIST prlList;

	if(!dwPlayerTo){
		return FALSE;
	}
	ENTER_DPSP();
	prlList = pgd->pReplyList;
	while(prlList){
		if(prlList->dwPlayerTo == dwPlayerTo){
			LEAVE_DPSP();
			return TRUE;
		}
		prlList=prlList->pNextReply;
	}
	LEAVE_DPSP()
	return FALSE;
}


HRESULT WINAPI SP_Send(LPDPSP_SENDDATA psd)
{
    HRESULT hr=DP_OK;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;

	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (psd->dwMessageSize >= SPMAXMESSAGELEN)
	{
		return DPERR_SENDTOOBIG;
	}

	if ((psd->dwFlags & DPSEND_GUARANTEE) && (AF_IPX != pgd->AddressFamily))
    {
		if (psd->dwFlags & DPSEND_ASYNC) hr = AsyncSend(psd);
        else {
        	if(bAsyncSendsPending(pgd, psd->idPlayerTo)){
        		hr = AsyncSend(psd);
        	} else {
	        	hr = ReliableSend(psd);	
	        }	
        }
        if (FAILED(hr)) DPF(0,"reliable send failed - error - hr = 0x%08lx\n",hr);
    }
    else
    {
    	hr = UnreliableSend(psd);
		if (FAILED(hr)) DPF(0,"unreliable send failed - error -  hr = 0x%08lx\n",hr);
    }

    return hr;

} // send


#ifdef SENDEX
HRESULT InitGlobalsInPlace(LPGLOBALDATA pgd)
{
	InitBilink(&pgd->PendingSendQ);
	InitBilink(&pgd->ReadyToSendQ);
	//pgd->dwBytesPending=0;	//by memset below.
	//pgd->dwMessagesPending=0; //by memset below.
	// Initialize the pool for send headers and overlapped stucts
	pgd->pSendInfoPool=FPM_Init(sizeof(SENDINFO)+sizeof(MESSAGEHEADER),NULL,NULL,NULL);
	
	if(!pgd->pSendInfoPool){
		goto ERROR_EXIT;
	}
	
	InitializeCriticalSection(&pgd->csSendEx);

	return DP_OK;
	
ERROR_EXIT:
	return DPERR_NOMEMORY;
}
#endif

void KillTCPEnumAsyncThread(LPGLOBALDATA pgd)
{
	HANDLE hTCPEnumAsyncThread;
	DWORD SleepCount=0;

	ENTER_DPSP();

	if(pgd->hTCPEnumAsyncThread){
	
		DPF(9,"Killing Running Async TCP enum thread\n");
		//hTCPEnumAsyncThread is 0, thread knows we are 
		//waiting for thread to finish, so we own closing 
		// the handle.
		hTCPEnumAsyncThread=pgd->hTCPEnumAsyncThread;
		pgd->hTCPEnumAsyncThread=0;

		// We need to close the socket out from under the
		// TCPEnum thread in order to have it continue and
		// exit.  So make sure the socket has been allocated
		// first, but don't wait if the thread has exited 
		// already (which is why we check lpEnumMessage.)
		while(pgd->sEnum==INVALID_SOCKET && pgd->lpEnumMessage){
			LEAVE_DPSP();
			Sleep(500);	
			ENTER_DPSP();
			if(SleepCount++ > 10 )break; // don't wait more than 5 seconds.
		}

		if(pgd->sEnum!=INVALID_SOCKET){
			if(pgd->bOutBoundOnly){
				RemoveSocketFromReceiveList(pgd,pgd->sEnum);
			} else {
				closesocket(pgd->sEnum);
			}
		}	
		LEAVE_DPSP();
		
		WaitForSingleObject(hTCPEnumAsyncThread,150*1000);
		CloseHandle(hTCPEnumAsyncThread);
		
		DPF(9,"Async enum thread is dead.\n");
	} else {
		LEAVE_DPSP();
	}	
}		

void InitGlobals(LPGLOBALDATA pgd)
{
	if(pgd->hTCPEnumAsyncThread){
		KillTCPEnumAsyncThread(pgd);
	}

	ENTER_DPSP();

	if (pgd->BagOSockets)	
	{
		MemFree(pgd->BagOSockets);
	}
	
	if (pgd->ReceiveList.pConnection)
	{
		 MemFree(pgd->ReceiveList.pConnection);
	}

	if (pgd->readfds.pfdbigset)
	{
		 MemFree(pgd->readfds.pfdbigset);
	}
	
#ifdef SENDEX	
	if(pgd->bSendThreadRunning){
		pgd->bStopSendThread=TRUE;
		SetEvent(pgd->hSendWait);
	}
	while(pgd->bSendThreadRunning){
		Sleep(0);
	}
	if(pgd->hSendWait){
		CloseHandle(pgd->hSendWait);
		pgd->hSendWait=NULL;
	}
	if(pgd->pSendInfoPool){
		pgd->pSendInfoPool->Fini(pgd->pSendInfoPool,0);
		DeleteCriticalSection(&pgd->csSendEx);
		//pgd->pSendInfoPool=NULL; //by memset below.
	}
#endif
	// set global data to 0	
	memset(pgd,0,sizeof(GLOBALDATA));

	// uses INVALID_SOCKET, not 0, to indicate bogus socket
	pgd->sSystemDGramSocket= INVALID_SOCKET;
	pgd->sSystemStreamSocket= INVALID_SOCKET;
	pgd->sUnreliableSocket = INVALID_SOCKET;
#ifdef BIGMESSAGEDEFENSE
	pgd->dwMaxMessageSize = SPMAXMESSAGELEN;
#endif
	pgd->uEnumAddress = 0;

	LEAVE_DPSP();

} // InitGlobals

HRESULT WaitForThread(HANDLE hThread)
{
	DWORD dwRet;
	
	if (!hThread) return DP_OK;
	
	// we assume the thread has been told to go away
	// we wait for it to do so
	dwRet = WaitForSingleObject(hThread,INFINITE);
	if (WAIT_OBJECT_0 != dwRet)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
	
	CloseHandle(hThread);
	
	return DP_OK;
} // WaitForThread

HRESULT WINAPI SP_Shutdown(LPDPSP_SHUTDOWNDATA psd) 
{
	UINT err;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
	DPSP_CLOSEDATA cd;
	BOOL bFree;
	
	DPF(2," dpwsock - got shutdown!!\n");

	// get the global data
	hr = psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}
	
	// call close
	cd.lpISP = psd->lpISP;
	hr = SP_Close(&cd);
	if (FAILED(hr))
	{
		DPF(0," shutdown - could not close SP hr = 0x%08lx\n",hr);
		ASSERT(FALSE);
		// rut roh!  - keep trying
	}

#ifdef DPLAY_VOICE_SUPPORT
	// turn off voice, if it exists...
	if (gbVoiceInit) 
	{
		ASSERT(!gbVoiceOpen); // dplay should have shut it down!
		FiniVoice();
		gbVoiceInit = FALSE;
	}
#endif // DPLAY_VOICE_SUPPORT
	
	DPF(2,"shutdown, calling WSACleanup");
	// it's ok to call this for each idirectplaysp that goes away, since
	// we called WSAStartup once for each one at SPInit
    if ( SOCKET_ERROR == WSACleanup()) 
    {
		err = WSAGetLastError();
    	DPF(0,"could not stop winsock err = %d\n",err);
		// keep trying...
    }

	// if we have a winsock2, free it 
	if (hWS2)
	{
		bFree = FreeLibrary(hWS2);
		if (!bFree)
		{
			DWORD dwError = GetLastError();
			DPF(0,"SP_Shutdown - could not free ws2 library - error = %d\n",dwError);
			// keep trying
		}
		hWS2 = NULL;
	}
	
	// reset everything...
	InitGlobals(pgd);

	gdwDPlaySPRefCount--;

	DPF(2,"shutdown leaving");
	return DP_OK;
	
} //Shutdown

// sp only sets fields it cares about
HRESULT WINAPI SP_GetCaps(LPDPSP_GETCAPSDATA pcd) 
{
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;

	// get the global data
	hr =pcd->lpISP->lpVtbl->GetSPData(pcd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (AF_IPX == pgd->AddressFamily)
	{
		// IPX
		pcd->lpCaps->dwHeaderLength = sizeof(MESSAGEHEADER);
		pcd->lpCaps->dwMaxBufferSize = IPX_MAX_DGRAM;
	}
	// else, they want AF_INET
	else 
	{
		// AF_INET optimizes guaranteed
		pcd->lpCaps->dwFlags |= DPCAPS_GUARANTEEDOPTIMIZED;
		
		if (pcd->dwFlags & DPGETCAPS_GUARANTEED)
		{
			// TCP
			pcd->lpCaps->dwHeaderLength = sizeof(MESSAGEHEADER);
			pcd->lpCaps->dwMaxBufferSize = SPMAXMESSAGELEN -sizeof(MESSAGEHEADER);
			pcd->lpCaps->dwMaxPlayers = pgd->nSocketsInBag;
		}
		else 
		{
			// UDP
			pcd->lpCaps->dwHeaderLength = sizeof(MESSAGEHEADER);
			pcd->lpCaps->dwMaxBufferSize = pgd->iMaxUdpDg-sizeof(MESSAGEHEADER);
		}
	}

	// set async caps flags
	if(pgd->bSendThreadRunning){
		// we are supporting async.
		pcd->lpCaps->dwFlags |= (DPCAPS_ASYNCSUPPORTED);
	}
	
	// set the timeout
	pcd->lpCaps->dwLatency = pgd->dwLatency;
	pcd->lpCaps->dwTimeout = SPTIMEOUT(pcd->lpCaps->dwLatency);

#ifdef DPLAY_VOICE_SUPPORT
	// check the voice
	if (gbVoiceInit || CheckVoice()) pcd->lpCaps->dwFlags |= DPCAPS_VOICE;
#endif // DPLAY_VOICE_SUPPORT

	return DP_OK;

} // SP_GetCaps

HRESULT WINAPI SP_Open(LPDPSP_OPENDATA pod) 
{
	LPMESSAGEHEADER phead;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
	
	DPF(5,"SP_Open");

#ifdef DPLAY_VOICE_SUPPORT
	if (pod->dwOpenFlags & DPOPEN_VOICE)	
	{
		if (gbVoiceOpen)
		{
			DPF_ERR("voice channel already open - only one per process");
			return DPERR_ALREADYINITIALIZED;
		}
		if (!gbVoiceInit)
		{
			DPF(0,"DPWSOCK - listen up!!! - init'ing voice!");
			hr = InitVoice();
			if (FAILED(hr))
			{
				DPF(0,"init voice failed hr = 0x%08lx\n");
				return hr;
			}
			gbVoiceInit = TRUE;
		}
	}
#endif // DPLAY_VOICE_SUPPORT
	
	// get the global data
	hr =pod->lpISP->lpVtbl->GetSPData(pod->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	// do we have a TCP connection?
	if (AF_INET == pgd->AddressFamily)
	{
		PHOSTENT phostent = GetHostAddr();
		if (!phostent || phostent->h_addr_list[0] == 0) 
		{
			DPF(0, "No Dial-up network or netcard present");
			return DPERR_NOCONNECTION;	// no local IP address = no network
		}
	}

	// remember session information so we know if we need to turn off nagling
	pgd->dwSessionFlags = pod->dwSessionFlags;

	if (pod->dwOpenFlags & DPOPEN_CREATE)
	{
		// host should never go into this mode
		pgd->dwFlags &= ~(DPSP_OUTBOUNDONLY);
	}
	
	if (pod->bCreate) 
		return DP_OK; // all done

	phead =  (LPMESSAGEHEADER)pod->lpSPMessageHeader;
	// get name server address out of phead, stores it in pgd->saddrNS
	pgd->saddrNS = phead->sockaddr;

	// make sure we have a thread running to get the nametable
	hr = StartupEnumThread(pod->lpISP,pgd);
	if (FAILED(hr))
	{
		DPF(0," could not start open threads - hr = 0x%08lx\n",hr);
		return hr;
	}
	
	return DP_OK;

} // SP_Open


#ifdef DEBUG
// make sure there are no connected sockets left in the bug
void VerifySocketBagIsEmpty(LPGLOBALDATA pgd)
{
	UINT i=0;

	while (i < pgd->nSocketsInBag)
	{
		if (INVALID_SOCKET != pgd->BagOSockets[i].sSocket) 
		{
			DPF_ERR("socket bag not empty at close!");
			ASSERT(FALSE);
		}
		i++;
	}

} // VerifySocketBagIsEmpty
#endif // DEBUG

HRESULT WINAPI SP_Close(LPDPSP_CLOSEDATA pcd)
{
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
	DWORD sleepcount=0;
	
	DPF(2," dpwsock - got close");
	
	// get the global data
	hr =pcd->lpISP->lpVtbl->GetSPData(pcd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}


	// Stop asynchronous TCP enumeration thread if it's running
	KillTCPEnumAsyncThread(pgd);


	// give the reply list 5 seconds to clear out
	while(pgd->pReplyList){
		Sleep(100);
		if(sleepcount++ == 50){
			break;
		}
	}


	// reset the nameserver address
	memset(&(pgd->saddrNS),0,sizeof(SOCKADDR));

	pgd->bShutdown = TRUE;
	
	DPF(2,"close, datagram sockets");
	
	KillSocket(pgd->sSystemDGramSocket,FALSE,TRUE);
	pgd->sSystemDGramSocket = INVALID_SOCKET;

	DPF(2,"Waiting for stream receive thread");

	WaitForThread(pgd->hStreamReceiveThread);
	pgd->hStreamReceiveThread = NULL;

	DPF(2,"close stream socket");
	
	closesocket(pgd->sSystemStreamSocket);
	pgd->sSystemStreamSocket = INVALID_SOCKET;	

	DPF(2,"close unreliable socket");
	
	KillSocket(pgd->sUnreliableSocket,FALSE,TRUE);
	pgd->sUnreliableSocket = INVALID_SOCKET;	
	
	DPF(2,"close, waiting on threads");

	// signal the reply thread
	if (pgd->hReplyEvent)
	{
		SetEvent(pgd->hReplyEvent);
	}

	WaitForThread(pgd->hDGramReceiveThread);
	pgd->hDGramReceiveThread = NULL;
	
	WaitForThread(pgd->hReplyThread);
	pgd->hReplyThread = NULL;

	// if it was ipx, and the nameserver has migrated to us, we may have a spare thread 
	// we need to make sure is gone
	if (AF_IPX == pgd->AddressFamily) 
	{
		WaitForThread(pgd->hIPXSpareThread);	
		pgd->hIPXSpareThread = NULL;
	}
	
	pgd->bShutdown = FALSE;
	
#ifdef DEBUG	
	// verify that the bag o' sockets is really empty
	VerifySocketBagIsEmpty(pgd);
#endif 

	while(pgd->dwMessagesPending){
		DPF(0,"Waiting for pending messages to complete\n");
		Sleep(55);
	}
	
	return DP_OK;

} // SP_Close

#ifdef FIND_IP
//
// we get the ip addr of our host.  this is for debug purposes only.
// we never use the ip addr of our host, since it may be multihomed.
// the receiving system assigns our players their ip addresses
HRESULT DebugFindIPAddresses(void)
{
	PHOSTENT phostent;
	IN_ADDR hostaddr;
	int i;

	phostent = GetHostAddr();
	if (NULL == phostent) 
	{
		return E_FAIL;
	}
	DPF(0,"dpwsock - running on host name %s\n",phostent->h_name);

	i=0;
	while (phostent->h_addr_list[i])
	{
		memcpy(&hostaddr,phostent->h_addr_list[i],sizeof(hostaddr));
		DPF(0,"sp - found host addr = %s \n",inet_ntoa(hostaddr));
		i++;
	}

	return DP_OK;

} // DebugFindIPAddresses

#endif  // FIND_IP


/*
 * EnumConnectionData
 *
 * Search for valid connection data
 */

BOOL FAR PASCAL EnumConnectionData(REFGUID lpguidDataType, DWORD dwDataSize,
							LPCVOID lpData, LPVOID lpContext)
{
	LPGLOBALDATA pgd = (LPGLOBALDATA) lpContext;
	
	// this is an ANSI internet address
	if (IsEqualGUID(lpguidDataType, &DPAID_INet))
	{
		// make sure there is room (for terminating null too)
		if (dwDataSize > ADDR_BUFFER_SIZE)
			dwDataSize = (ADDR_BUFFER_SIZE - 1);

		// copy string for use later
		memcpy(pgd->szServerAddress, lpData, dwDataSize);

		pgd->bHaveServerAddress = TRUE;		// we have a server address
	}
	// this is a UNICODE internet address
	else if (IsEqualGUID(lpguidDataType, &DPAID_INetW))
	{
		if (WideToAnsi(pgd->szServerAddress, (LPWSTR) lpData, ADDR_BUFFER_SIZE))
			pgd->bHaveServerAddress = TRUE;	// we have a server address
	}
	else if (IsEqualGUID(lpguidDataType, &DPAID_INetPort))
	{
		pgd->wApplicationPort = *(LPWORD)lpData;
		DPF(5, "Application port specified in dp address: %d",pgd->wApplicationPort);
	}
	
#ifdef BIGMESSAGEDEFENSE
	else if (IsEqualGUID(lpguidDataType, &DPAID_MaxMessageSize))
	{
		pgd->dwMaxMessageSize = *(LPDWORD)lpData;
		ASSERT(pgd->dwMaxMessageSize > 11);	// set an arbitrary minimum
		if (pgd->dwMaxMessageSize < 12)
			pgd->dwMaxMessageSize = 12;
		DPF(5, "Max message size specified in dp address: %d",pgd->dwMaxMessageSize);
		pgd->dwMaxMessageSize += sizeof(MESSAGEHEADER);	// add a little extra for the shop
	}
#endif

	return TRUE;

} // EnumConnectionData

// nSockets was passed into spinit as dwReserved2
HRESULT InitBagOSockets(LPGLOBALDATA pgd,DWORD nSockets)
{
	UINT i;

	ENTER_DPSP();
		
	if (0 == nSockets)
	{
		pgd->nSocketsInBag = MAX_CONNECTED_SOCKETS;
	}
	else 
	{
		pgd->nSocketsInBag = nSockets;
	}
	
	pgd->BagOSockets = MemAlloc(pgd->nSocketsInBag * sizeof(PLAYERSOCK));
	
	LEAVE_DPSP();
	
	if (!pgd->BagOSockets)
	{
		pgd->nSocketsInBag = 0;
		DPF_ERR("could not alloc space for socket cache - out of memory");
		return E_OUTOFMEMORY; 
	}
	
	for (i=0;i<pgd->nSocketsInBag;i++ )
	{
		pgd->BagOSockets[i].sSocket = INVALID_SOCKET;
	}
	
	return DP_OK ;
} // InitBagOSockets

// CheckIPXInstall
// 		on win 95 gold
// 		go to control panel / network
// 		select your net card / properties
// 		select bindings tab.  unbind ipx.
// 		socket(...) call succeeds, but sendto(...) hangs.
// 		we check here that the sa_nodenum is not 0,0,0,0,0,0
// 		if it is, we will hang later, so we fail.  andyco.
//
HRESULT CheckIPXInstall(SOCKET sSocket)
{
	int cbOpt;
	UINT err;
	IPX_ADDRESS_DATA  IpxData;
  	char pSixZeros[6];
	
	if (INVALID_SOCKET == sSocket)
	{
		return E_FAIL;		
	}

	// go ask the driver for our ipx address
   	memset( &IpxData, 0, sizeof(IpxData));
	cbOpt = sizeof( IpxData );
	err = getsockopt( sSocket, NSPROTO_IPX, IPX_ADDRESS,
               (char*) &IpxData, &cbOpt );
	if (SOCKET_ERROR == err)
	{
		err = WSAGetLastError();
		DPF(0," could not test ipx getopt - err = %d\n",err);
		return E_FAIL;
	}
	
	// see if it's 0
	memset(pSixZeros,0,6*sizeof(char));	
	if (0 == memcmp(pSixZeros,&(IpxData.nodenum),6))
	{
		DPF_ERR("found invalid IPX install!");
		DPF_ERR("IPX has been improperly un-installed by unbinding from net adaptor");
		return E_FAIL;
	}
	
	return DP_OK;

} // CheckIPXInstall

// main entry point for service provider
// sp should fill in callbacks (pSD->lpCB) and do init stuff here
HRESULT WINAPI SPInit(LPSPINITDATA pSD) 
{
    HRESULT hr;
	UINT err;
	GLOBALDATA gd,*pgd;
	UINT dwSize;
	SOCKET sVerifySocket; // used to verify support for the requested address family
						  // so, if they ask for ipx, and it's not installed, we fail here 
	WORD wVersion;
	OSVERSIONINFO osInfo;
	HANDLE hAlertThread;

	// initialize global data
	memset(&gd,0,sizeof(gd));
	InitGlobals(&gd);

	ASSERT(pSD->lpGuid);
	if (IsEqualIID(pSD->lpGuid,&GUID_IPX))
	{
		DPF(0,"---------------- DPWSOCK -- RUNNING IPX -------------");
		gd.AddressFamily = AF_IPX;		
	}
	else 
	{
		if (IsEqualIID(pSD->lpGuid,&GUID_LOCAL_TCP))
		{
			gd.uEnumAddress = INADDR_BROADCAST;
			DPF(0," ** DPWSOCK -- RUNNING LOCAL TCP / IP ** ");			
		}
		else 
		{
			DPF(0," ** DPWSOCK -- RUNNING INTERNET TCP / IP ** ");
		}

		gd.AddressFamily = AF_INET;			
	}
	
	// find out what os we are running on
	memset(&osInfo,0,sizeof(osInfo));
	osInfo.dwOSVersionInfoSize = sizeof(osInfo);
	if (!GetVersionEx(&osInfo)) 
	{
		err = GetLastError();
		DPF(0,"Failed to get OS information - err = %d\n", err);
		return DPERR_GENERIC;
	}	

	// start up sockets
	if (gwsaData.wVersion)
	{
		// note - there is a bug in winsock 1.1.  if you've called WSAStartup 1x in a process,
		// then if any subsequent call asks for a version # > then that returned to the first
		// call, we get WSAEVERNOTSUPPORTED.  So, if we've already got a version in the wsadata,
		// we make sure to use that
		wVersion = gwsaData.wVersion;
		
	}
	// otherwise, ask for winsock 2.0
	else 
	{
		// if we are trying to initialize IPX on a non-NT platform, don't look for Winsock 2.0
		// Only look for Winsock 1.1 as Winsock 2.0 functionality is not supported for IPX on
		// Memphis and Win'95.
		if ((AF_IPX == gd.AddressFamily) && (VER_PLATFORM_WIN32_NT != osInfo.dwPlatformId))
			wVersion = MAKEWORD(1,1);
		else
			wVersion = MAKEWORD(2,0);
	}
	
    err = WSAStartup(wVersion, &gwsaData);
	if (WSAVERNOTSUPPORTED == err)
	{
		// they (the app) must have already called WSAStartup.  see note above 
		// about winsock 1.1 bug.
		wVersion = MAKEWORD(1,1);
	    err = WSAStartup(wVersion, &gwsaData);
	}
	if (err) 
	{
        DPF(0,"could not start winsock err = %d\n",err);
        return E_FAIL;
    }

	DPF(1,"spinit - name = %ls,dwReserved1 = %d,dwReserved2 = %d\n",pSD->lpszName,
		pSD->dwReserved1,pSD->dwReserved2);		

	gd.iMaxUdpDg = gwsaData.iMaxUdpDg;

	DPF(0,"detected winsock version %d.%d\n",LOBYTE(gwsaData.wVersion),HIBYTE(gwsaData.wVersion));	
	if (LOBYTE(gwsaData.wVersion) >= 2)
	{
		hr = InitWinsock2();
		if (FAILED(hr))
		{
			DPF_ERR("detected winsock 2, but could not init it! yikes!");
			ASSERT(FALSE);
		}
	}

	DPF(1,"\nspinit - setting latency to %d\n\n", pSD->dwReserved1);
	gd.dwLatency = pSD->dwReserved1;
	
	hr = InitBagOSockets(&gd,pSD->dwReserved2);	
	if (FAILED(hr))
	{
		DPF_ERR("could not init socket cache. bailing");
		goto ERROR_EXIT;
	}
				
	// make sure support exists for address family
    hr = CreateSocket(&gd,&sVerifySocket,SOCK_DGRAM,0,INADDR_ANY,&err,FALSE);
	if (FAILED(hr)) 
	{
		DPF(0,"	COULD NOT CREATE SOCKET IN REQUESTED ADDRESS FAMILY af = %d, err = %d\n",gd.AddressFamily,err);
		DPF(0," SERVICE PROVIDER INITIALIZATION FAILED");
		// return the same error as the modem service provider
		hr = DPERR_UNAVAILABLE;
		goto ERROR_EXIT;
	}

	if (LOBYTE(gwsaData.wVersion) >= 2)
	{
		// get max udp buffer size through getsockopt because
		// WSAStartup doesn't return this info from winsock 2.0 onwards.
		hr = GetMaxUdpBufferSize(sVerifySocket, &gd.iMaxUdpDg);
		if (FAILED(hr))
		{
			DPF(0,"Failed to get max udp buffer size");
			// since memphis still returns this value in WSAStartup
			// use it. This is just a workaround for memphis bug #43655
			if (gwsaData.iMaxUdpDg)
			{
				DPF(0, "Using iMaxUdpDg value from WSAStartup: %d", gwsaData.iMaxUdpDg);
				gd.iMaxUdpDg = gwsaData.iMaxUdpDg;
			}
			else
			{
				DPF_ERR("No max UDP buffer size could be found!");

				// all done w/ verify socket
				KillSocket(sVerifySocket,FALSE,TRUE);
				goto ERROR_EXIT;
			}
		}
	}

	// check that the IPX stack won't hose us
	if (AF_IPX == gd.AddressFamily)
	{
		hr = CheckIPXInstall(sVerifySocket);
		if (FAILED(hr))
		{
			DPF_ERR("SPInit Failing - corrupt IPX install");
			hr = DPERR_UNAVAILABLE;
			// all done w/ verify socket
			KillSocket(sVerifySocket,FALSE,TRUE);
			goto ERROR_EXIT;
		}
	}
	
	// all done w/ verify socket
	KillSocket(sVerifySocket,FALSE,TRUE);

#ifdef FIND_IP
	// print out the ip address(es) of this host
	DebugFindIPAddresses();
#endif 

    // set up callbacks
    pSD->lpCB->CreatePlayer = SP_CreatePlayer;
    pSD->lpCB->DeletePlayer = SP_DeletePlayer;
    pSD->lpCB->Send = SP_Send;
    pSD->lpCB->EnumSessions = SP_EnumSessions;
    pSD->lpCB->Reply = SP_Reply;
	pSD->lpCB->ShutdownEx = SP_Shutdown;
	pSD->lpCB->GetCaps = SP_GetCaps;
	pSD->lpCB->Open = SP_Open;
	pSD->lpCB->CloseEx = SP_Close;
	pSD->lpCB->GetAddress = SP_GetAddress;
#ifdef DPLAY_VOICE_SUPPORT
	pSD->lpCB->OpenVoice = SP_OpenVoice;
	pSD->lpCB->CloseVoice = SP_CloseVoice;
#endif // DPLAY_VOICE_SUPPORT

#ifdef SENDEX
	if(LOBYTE(gwsaData.wVersion) >= 2)
	{
		DPF(1,"SENDEX being provided by SP\n");
		// Only do new functions when Winsock 2 functions avail.
		// NOTE: not supported on IPX with win9x at present, but reports 1.1 in this case.
		
    	//pSD->lpCB->SendToGroupEx = SP_SendToGroupEx;             // optional - not impl
    	//pSD->lpCB->Cancel        = SP_Cancel;                    // optional - not impl
	    pSD->lpCB->SendEx		   = SP_SendEx;                    // required for async
    	pSD->lpCB->GetMessageQueue = SP_GetMessageQueue;    
    } else {
    	DPF(1,"SENDEX not being provided by SP on winsock ver < 2\n");
    }
#endif

	// we put (at most) 1 sockaddr and one dword (size) in each message
	pSD->dwSPHeaderSize = sizeof(MESSAGEHEADER);

	// return version number so DirectPlay will treat us with respect
	pSD->dwSPVersion = VERSIONNUMBER;

	// look at connnection data
	if (pSD->dwAddressSize)
	{
		// ask dplay to enum the chunks for us. if one of them is
		// af_inet, we'll use it as our name servers address
		pSD->lpISP->lpVtbl->EnumAddress(pSD->lpISP, EnumConnectionData, 
								 pSD->lpAddress, pSD->dwAddressSize,
								 &gd);
	}

#ifdef FULLDUPLEX_SUPPORT
	// get the flags from registry
	hr = GetFlagsFromRegistry(pSD->lpGuid, &gd.dwFlags);
	if (FAILED(hr))
	{
		DPF(2, "Failed to get sp flags from the registry");		
	}
#endif // FULLDUPLEX_SUPPORT

	// store the globaldata
	hr = pSD->lpISP->lpVtbl->SetSPData(pSD->lpISP,&gd,sizeof(GLOBALDATA),DPSET_LOCAL);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		goto ERROR_EXIT;
	}
	
	hr = pSD->lpISP->lpVtbl->GetSPData(pSD->lpISP,&pgd,&dwSize,DPGET_LOCAL);

	if (FAILED(hr))
	{
		ASSERT(FALSE);
		goto ERROR_EXIT;
	}
#ifdef SENDEX	
	if(LOBYTE(gwsaData.wVersion) >= 2) {
		// some globals are self referential, can't set until here.
		hr=InitGlobalsInPlace(pgd);
		if(FAILED(hr))
		{
			ASSERT(FALSE);
			goto ERROR_EXIT;
		}

		// added alertable thread.
		pgd->hSendWait=CreateEvent(NULL, FALSE, FALSE, NULL); // autoreset.
		if(!pgd->hSendWait){
			ASSERT(FALSE);
			goto ERROR_EXIT;
		}
		pgd->bSendThreadRunning=TRUE;
		hAlertThread=CreateThread(NULL, 4000, SPSendThread, pgd, 0, (ULONG *)&hAlertThread);
		if(!hAlertThread){
			pgd->bSendThreadRunning=FALSE;
			ASSERT(FALSE);
			goto ERROR_EXIT;
		} else {
			SetThreadPriority(hAlertThread, THREAD_PRIORITY_ABOVE_NORMAL);
		}
		CloseHandle(hAlertThread);// don't need a handle.
	}
	
#endif	
	
	gdwDPlaySPRefCount++;

	
	// success!
	return DP_OK;    

ERROR_EXIT:

	DPF_ERR("SPInit - abnormal exit");

	// call this again to clean up anything we alloc'ed
	InitGlobals(&gd);
	
	DPF(2,"SPInit - calling WSACleanup");
    if ( SOCKET_ERROR == WSACleanup()) 
    {
		err = WSAGetLastError();
    	DPF(0,"could not stop winsock err = %d\n",err);
    }

	return hr;

} // SPInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\dpsp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplayi.h
 *  Content:	DirectPlay data structures
 *  History:
 *   Date		By	Reason
 *   ====		==	======
 *	1/96		andyco	created it
 *  1/26/96		andyco	list data structures
 *	4/10/96		andyco	removed dpmess.h
 *	4/23/96		andyco	added ipx support
 *	4/25/96		andyco	messages now have blobs (sockaddr's) instead of dwReserveds  
 *	8/10/96		kipo	update max message size to be (2^20) - 1
 *	8/15/96		andyco	added local data
 *	8/30/96		andyco	clean it up b4 you shut it down! added globaldata.
 *	9/3/96		andyco	bagosockets
 *	12/18/96	andyco	de-threading - use a fixed # of prealloced threads.
 *						cruised the enum socket / thread - use the system
 *						socket / thread instead. updated global struct.
 *	2/7/97		andyco	moved all per IDirectPlay globals into globaldata
 *	3/17/97		kipo	GetServerAddress() now returns an error so that we can
 *						return DPERR_USERCANCEL from the EnumSessions dialog
 *	3/25/97		andyco	dec debug lock counter b4 dropping lock! 
 *	4/11/97		andyco	added saddrControlSocket
 *	5/12/97		kipo	added ADDR_BUFFER_SIZE constant and removed unused variables
 *	5/15/97		andyco	added ipx spare thread to global data - used when nameserver 
 *						migrates to this host to make sure that old system receive 
 *						thread shuts down 
 *	6/22/97		kipo	include wsnwlink.h
 *	7/11/97		andyco	added support for ws2 + async reply thread
 *	8/25/97		sohailm	added DEFAULT_RECEIVE_BUFFERSIZE
 *	12/5/97		andyco	voice support
 *	01/5/97		sohailm	added fd big set related definitions and macros (#15244).
 *	1/20/98		myronth	#ifdef'd out voice support
 *	1/27/98		sohailm	added firewall support
 *  2/13/98     aarono  added async support
 *	2/18/98    a-peterz Comment byte order mess-up with SERVER_xxx_PORT constants
 *  3/3/98      aarono  Bug#19188 remove accept thread 
 *  12/15/98    aarono  make async enum run async
 **************************************************************************/

#ifndef __DPSP_INCLUDED__
#define __DPSP_INCLUDED__
#include "windows.h"
#include "windowsx.h"
#include "wsipx.h"
#include "wsnwlink.h"
#include "dplaysp.h"
#include "bilink.h"
#include "fpm.h"

#ifdef DPLAY_VOICE_SUPPORT
#include "nmvoice.h"
#endif // DPLAY_VOICE_SUPPORT

#include "dpf.h"
#include "dputils.h"
#include "memalloc.h"
#include "resource.h"
#include <winsock.h>

// to turn off SendEx support, comment this flag out.
#define SENDEX 1

// use ddraw's assert code (see orion\misc\dpf.h)
#define ASSERT DDASSERT

typedef WORD PORT;
typedef UINT SOCKERR;

// server ports
// Oops! We forgot to convert these constants to net byte order in the code so we
// are really using port 47624 (0xBA08) instead of 2234 (0x08BA)
// We are living with the mistake.
#define SERVER_STREAM_PORT 2234
#define SERVER_DGRAM_PORT 2234

// range of ports used by sp (these are properly converted in the code)
#define DPSP_MIN_PORT	2300
#define DPSP_MAX_PORT	2400
#define DPSP_NUM_PORTS   ((DPSP_MAX_PORT - DPSP_MIN_PORT)+1)

#define SPMESSAGEHEADERLEN (sizeof(DWORD))
#define DEFAULT_RECEIVE_BUFFERSIZE	(4*1024)	// default receive buffer size per connection

// token means this message was received from a remote
// dplay.  
#define TOKEN 0xFAB00000

// helper_token means this message was forwarded by our server helper (host)
#define HELPER_TOKEN 0xCAB00000

// server_token means this message is exchanged with dplaysvr (needed to distinguish 
// messages from a remote dpwsockx)
#define SERVER_TOKEN 0xBAB00000

// tells receiver to reuse the connection for replies (needed to support fullduplex
// connections)
#define REUSE_TOKEN 0xAAB00000


// masks
#define TOKEN_MASK 0xFFF00000
#define SIZE_MASK (~TOKEN_MASK)

// maxmessagelen = 2^20 (need 12 bits for token)
#define SPMAXMESSAGELEN ( 1048576 - 1)
#define VALID_SP_MESSAGE(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK) == TOKEN ? TRUE : FALSE)
#define VALID_HELPER_MESSAGE(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK) == HELPER_TOKEN ? TRUE : FALSE)
#define VALID_REUSE_MESSAGE(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK) == REUSE_TOKEN ? TRUE : FALSE)
#define VALID_SERVER_MESSAGE(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK) == SERVER_TOKEN ? TRUE : FALSE)
#define SP_MESSAGE_SIZE(pMsg) ( (*((DWORD *)pMsg) & SIZE_MASK))
#define SP_MESSAGE_TOKEN(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK))

#define VALID_DPWS_MESSAGE(pMsg) (  VALID_SP_MESSAGE(pMsg) || VALID_HELPER_MESSAGE(pMsg) || \
									VALID_SERVER_MESSAGE(pMsg) || VALID_REUSE_MESSAGE(pMsg) )
#define VALID_DPLAYSVR_MESSAGE(pMsg) (	VALID_SP_MESSAGE(pMsg) || VALID_SERVER_MESSAGE(pMsg) || \
										VALID_REUSE_MESSAGE(pMsg) )

// the actual value is ~ 1500 bytes.
// we use 1024 to be safe (IPX won't packetize for us - it can only 
// send what the underlying net can handle (MTU))
#define IPX_MAX_DGRAM 1024

// relation of timeout to latency
#define TIMEOUT_SCALE 10
#define SPTIMEOUT(latency) (TIMEOUT_SCALE * latency)

// the default size of the socket cache (gBagOSockets)
#define MAX_CONNECTED_SOCKETS 64

// the initial size of the receive list
#define INITIAL_RECEIVELIST_SIZE 16

// version number for service provider
#define SPMINORVERSION      0x0000				// service provider-specific version number
#define VERSIONNUMBER		(DPSP_MAJORVERSION | SPMINORVERSION) // version number for service provider

// biggest user enterable addess
#define ADDR_BUFFER_SIZE 128
								 
// macro picks the service socket depending on ipx vs. tcp
// ipx uses dgram, tcp uses stream
#define SERVICE_SOCKET(pgd) ( (pgd->AddressFamily == AF_IPX) \
	? pgd->sSystemDGramSocket : pgd->sSystemStreamSocket)

//
// In order to listen to any number of sockets we need our own version
// of fd_set and FD_SET().  We call them fd_big_set and FD_BIG_SET().
//
typedef struct fd_big_set {
    u_int   fd_count;           // how many are SET?   
    SOCKET  fd_array[0];        // an array of SOCKETs 
} fd_big_set;

// stolen from winsock2.h

#ifndef _WINSOCK2API_

typedef HANDLE WSAEVENT;

typedef struct _WSAOVERLAPPED {
    DWORD        Internal;
    DWORD        InternalHigh;
    DWORD        Offset;
    DWORD        OffsetHigh;
    WSAEVENT     hEvent;
} WSAOVERLAPPED, FAR * LPWSAOVERLAPPED;

typedef struct _WSABUF {
    u_long      len;     /* the length of the buffer */
    char FAR *  buf;     /* the pointer to the buffer */
} WSABUF, FAR * LPWSABUF;
 
#endif // _WINSOCK2API_

#define MAX_SG 9
typedef WSABUF SENDARRAY[MAX_SG];
typedef SENDARRAY *PSENDARRAY;

#define SI_RELIABLE 0x0000001
#define SI_DATAGRAM 0x0000000

typedef struct _SENDINFO {
	WSAOVERLAPPED wsao;
	SENDARRAY     SendArray;	// Array of buffers
	DWORD         dwFlags;
	DWORD         dwSendFlags;  // DPLAY Send Flags.
	UINT          iFirstBuf;	// First buffer in array to use
	UINT          cBuffers;		// number of buffers to send (starting at iFirstBuf)
	BILINK        PendingSendQ; // when we're pending
	BILINK        ReadyToSendQ; // still waiting to send on this queue.
	DPID          idTo;
	DPID          idFrom;
	SOCKET        sSocket;		// reliable sends
	SOCKADDR      sockaddr;		// datagram sends
	DWORD_PTR     dwUserContext;
	DWORD         dwMessageSize;
	DWORD         RefCount;
	LONG          Status;
	struct _GLOBALDATA *pgd;
	IDirectPlaySP * lpISP;			//  indication interface
	#ifdef DEBUG
	DWORD         wserr;			// winsock extended error on wsasend call
	#endif
} SENDINFO, FAR *LPSENDINFO;

//
// This code is stolen from winsock.h.  It does the same thing as FD_SET()
// except that it assumes the fd_array is large enough.  AddSocketToReceiveList()
// grows the buffer as needed, so this better always be true.
//

#define FD_BIG_SET(fd, address) do { \
    ASSERT((address)->dwArraySize > (address)->pfdbigset->fd_count); \
    (address)->pfdbigset->fd_array[(address)->pfdbigset->fd_count++]=(fd);\
} while(0)

typedef struct fds {
	DWORD		dwArraySize;	// # of sockets that can be stored in pfdbigset->fd_array buffer
	fd_big_set	*pfdbigset;		
} FDS;

typedef struct _CONNECTION
{
	SOCKET	socket;				// socket we can receive off of
	DWORD	dwCurMessageSize;	// current message size
	DWORD	dwTotalMessageSize;	// total message size
	SOCKADDR sockAddr;			// addresses connected to
	LPBYTE	pBuffer;			// points to either default or temporary receive buffer
	LPBYTE	pDefaultBuffer;		// default receive buffer (pBuffer points to this by default)
	// added in DX6
	DWORD	dwFlags;			// connection attributes e.g. SP_CONNECION_FULLDUPLEX
} CONNECTION, *LPCONNECTION;

typedef struct _RECEIVELIST
{
	UINT nConnections;			// how many peers are we connected to
	LPCONNECTION pConnection;// list of connections
} RECEIVELIST;

typedef struct _REPLYLIST * LPREPLYLIST;
typedef struct _REPLYLIST
{
	LPREPLYLIST pNextReply; // next reply in list
	LPVOID	lpMessage; // bufffer to send
	SOCKADDR sockaddr;  // addr to send to
	DWORD dwMessageSize;
	SOCKET sSocket; // socket to send on
	LPBYTE pbSend; // index into message pointing to next byte to send
	DWORD  dwBytesLeft; // how many bytes are left to send
	DWORD  dwPlayerTo; // dpid of to player, 0=>not in use.
} REPLYLIST;

// w store one of these w/ each sys player
typedef struct _SPPLAYERDATA 
{
	SOCKADDR saddrStream,saddrDatagram;
}SPPLAYERDATA,*LPSPPLAYERDATA;

	
// the message header
typedef struct _MESSAGEHEADER
{
	DWORD dwMessageSize; // size of message
	SOCKADDR sockaddr;
} MESSAGEHEADER,*LPMESSAGEHEADER;


// this is one element in our bagosockets
typedef struct _PLAYERSOCK
{
	SOCKET sSocket;
	DPID dwPlayerID;
	// added in DX6
	SOCKADDR sockaddr;
	DWORD dwFlags;			// SP_CONNECTION_FULLDUPLEX, etc.
} PLAYERSOCK,*LPPLAYERSOCK;

// flags that describe a socket
#define SP_CONNECTION_FULLDUPLEX	0x00000001
// stream accept socket in the socket list.
#define SP_STREAM_ACCEPT            0x00000002	

#ifdef SENDEX
typedef struct FPOOL *LPFPOOL;
#endif

typedef struct _GLOBALDATA
{
	SOCKET sSystemDGramSocket;
	SOCKET sSystemStreamSocket;
	HANDLE hStreamReceiveThread;	// does receive and accept.
	HANDLE hDGramReceiveThread;
	HANDLE hReplyThread;
	RECEIVELIST ReceiveList;  // the list of sockets that StreamReceiveThread is listening on
	SOCKET sUnreliableSocket; // cached for unreliable send
	// reply thread	
	LPREPLYLIST pReplyList; // list of replies for reply thread to send
	HANDLE hReplyEvent; // signal the replythread that something is up
	// bago sockets stuff
	LPPLAYERSOCK BagOSockets; // socket cache
	UINT nSocketsInBag; // how many sockets in our bag
	ULONG uEnumAddress; // address entered by user for game server
	ULONG AddressFamily;
	SOCKADDR saddrNS; // address for name server
	DWORD dwLatency; // from dwreserved1 in registry
	BOOL bShutdown;
	SOCKADDR saddrControlSocket;
	BOOL bHaveServerAddress;
    CHAR szServerAddress[ADDR_BUFFER_SIZE];
	HANDLE	hIPXSpareThread; // if nameserver migrates to this host, we start a new receive thread 
							// (bound to our well known socket).  this is the handle to our old receive
							// thread - at shutdown, we need to make sure it's gone
	UINT iMaxUdpDg;			// maximum udp datagram size
	// added in DX6
	FDS	readfds;			// dynamic read fdset
	DWORD dwFlags;			// DPSP_OUTBOUNDONLY, etc.
	DWORD dwSessionFlags;	// session flags passed by app
	WORD wApplicationPort;	// port used for creating system player sockets
#ifdef BIGMESSAGEDEFENSE
	DWORD 	dwMaxMessageSize;	// the max message size we should receive
#endif

	HANDLE  hTCPEnumAsyncThread; // fix async enum.
	LPVOID  lpEnumMessage;
	DWORD   dwEnumMessageSize;
	SOCKADDR saEnum;
	DWORD    dwEnumAddrSize;
	SOCKET   sEnum;
	BOOL     bOutBoundOnly;

#ifdef SENDEX
	CRITICAL_SECTION csSendEx;  // locks sendex data.
	LPFPOOL	pSendInfoPool;     // pool for allocating SENDINFO+SPHeaders for scatter gather sends
	DWORD   dwBytesPending;		// count of total bytes in pending messages.
	DWORD   dwMessagesPending;  // count of total bytes pending.
	BILINK  PendingSendQ;
	BILINK  ReadyToSendQ;
	HANDLE  hSendWait;         // alert thread wait here.
	HANDLE  BogusHandle;	   // don't be fooled by waitfor multiple probs in Win9x, put -1 here.
	BOOL    bSendThreadRunning;
	BOOL    bStopSendThread;
#endif

} GLOBALDATA,*LPGLOBALDATA;

/*
 * SP Flags (from registry)
 */
#define DPSP_OUTBOUNDONLY	0x00000001

/*
 * DPLAYSVR - DPWSOCKX communication related information
 */

// MSG_HDR indicates a dpwsock system message
#define MSG_HDR 0x736F636B

#define SP_MSG_VERSION	1	// DX6

#define IS_VALID_DPWS_MESSAGE(pMsg) (MSG_HDR == (*((DWORD *)(pMsg))) )
#define COMMAND_MASK 0X0000FFFF

#define GET_MESSAGE_VERSION(pMsg) ( ((pMsg)->dwCmdToken & ~COMMAND_MASK) >> 16 )
#define GET_MESSAGE_COMMAND(pMsg) ( (pMsg)->dwCmdToken & COMMAND_MASK)

#define SET_MESSAGE_HDR(pMsg)  (*((DWORD *)(pMsg)) = MSG_HDR )
#define SET_MESSAGE_COMMAND(pMsg,dwCmd) ((pMsg)->dwCmdToken = ((dwCmd & COMMAND_MASK) \
	| (SP_MSG_VERSION<<16)) )

typedef struct {
	DWORD dwHeader;
    DWORD dwCmdToken;	
} MSG_GENERIC, *LPMSG_GENERIC;


// DPLAYSVR


// macros for manipulating the sockaddr in the player data
#ifdef DEBUG
extern int gCSCount;
#endif
extern CRITICAL_SECTION gcsDPSPCritSection;	// defined in dllmain.c
#define INIT_DPSP_CSECT() InitializeCriticalSection(&gcsDPSPCritSection);
#define FINI_DPSP_CSECT() DeleteCriticalSection(&gcsDPSPCritSection);
#ifdef DEBUG
#define ENTER_DPSP() EnterCriticalSection(&gcsDPSPCritSection),gCSCount++;
#define LEAVE_DPSP() gCSCount--,LeaveCriticalSection(&gcsDPSPCritSection);
#else
#define ENTER_DPSP() EnterCriticalSection(&gcsDPSPCritSection);
#define LEAVE_DPSP() LeaveCriticalSection(&gcsDPSPCritSection);
#endif // DEBUG

// get a pointer to the players socket address - used by macros below
#define DGRAM_PSOCKADDR(ppd) ((SOCKADDR *)&(((LPSPPLAYERDATA)ppd)->saddrDatagram))
#define STREAM_PSOCKADDR(ppd) ((SOCKADDR *)&(((LPSPPLAYERDATA)ppd)->saddrStream))

// get the udp ip addr from a player
#define IP_DGRAM_ADDR(ppd) 	(((SOCKADDR_IN *)DGRAM_PSOCKADDR(ppd))->sin_addr.s_addr)
#define IP_DGRAM_PORT(ppd) 	(((SOCKADDR_IN *)DGRAM_PSOCKADDR(ppd))->sin_port)

// get the stream ip addr from a player
#define IP_STREAM_ADDR(ppd) 	(((SOCKADDR_IN *)STREAM_PSOCKADDR(ppd))->sin_addr.s_addr)
#define IP_STREAM_PORT(ppd) 	(((SOCKADDR_IN *)STREAM_PSOCKADDR(ppd))->sin_port)

// used to get the name of the computer we're running on in spinit
#define HOST_NAME_LENGTH 50

// if it's not ipx, it's ip
// {685BC400-9D2C-11cf-A9CD-00AA006886E3}
DEFINE_GUID(GUID_IPX, 
0x685bc400, 0x9d2c, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);

// 36E95EE0-8577-11cf-960C-0080C7534E82
DEFINE_GUID(GUID_TCP,
0x36E95EE0, 0x8577, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);

// {3A826E00-31DF-11d0-9CF9-00A0C90A43CB}
DEFINE_GUID(GUID_LOCAL_TCP, 
0x3a826e00, 0x31df, 0x11d0, 0x9c, 0xf9, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);


// globals
// ghinstance is used when putting up the dialog box to prompt for ip addr
extern HANDLE ghInstance; // set in dllmain. instance handle for dpwsock.dll

#ifdef DEBUG

extern void DebugPrintAddr(UINT level,LPSTR pStr,SOCKADDR * psockaddr);
#define DEBUGPRINTADDR(n,pstr,psockaddr) DebugPrintAddr(n,pstr,psockaddr);
extern void DebugPrintSocket(UINT level,LPSTR pStr,SOCKET * pSock);
#define DEBUGPRINTSOCK(n,pstr,psock) DebugPrintSocket(n,pstr,psock);

#else // debug

#define DEBUGPRINTADDR(n,pstr,psockaddr)
#define DEBUGPRINTSOCK(n,pstr,psock)

#endif // debug

// global vars
extern BOOL gbVoiceOpen; // set to TRUE if we have nm call open

// from dpsp.c
extern HRESULT WaitForThread(HANDLE hThread);
extern HRESULT SetupControlSocket();
extern HRESULT WINAPI SP_Close(LPDPSP_CLOSEDATA pcd);
extern HRESULT InternalReliableSend(LPGLOBALDATA pgd, DPID idPlayerTo, SOCKADDR *
	lpSockAddr, LPBYTE lpMessage, DWORD dwMessageSize);
extern HRESULT DoTCPEnumSessions(LPGLOBALDATA pgd, SOCKADDR *lpSockAddr, DWORD dwAddrSize,
	LPDPSP_ENUMSESSIONSDATA ped, BOOL bHostWillReuseConnection);
extern HRESULT SendControlMessage(LPGLOBALDATA pgd);
extern HRESULT SendReuseConnectionMessage(SOCKET sSocket);
extern HRESULT AddSocketToBag(LPGLOBALDATA pgd, SOCKET socket, DPID dpid, SOCKADDR *psockaddr, DWORD dwFlags);
extern BOOL FindSocketInReceiveList(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, SOCKET * psSocket);
extern void RemoveSocketFromReceiveList(LPGLOBALDATA pgd, SOCKET socket);
extern void RemoveSocketFromBag(LPGLOBALDATA pgd, SOCKET socket);
extern BOOL FindSocketInBag(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, SOCKET * psSocket, LPDPID lpdpidPlayer);
extern HRESULT GetSocketFromBag(LPGLOBALDATA pgd,SOCKET * psSocket, DWORD dwID, LPSOCKADDR psockaddr);
extern HRESULT CreateAndConnectSocket(LPGLOBALDATA pgd,SOCKET * psSocket,DWORD dwType,LPSOCKADDR psockaddr, BOOL bOutBoundOnly);
extern void RemovePlayerFromSocketBag(LPGLOBALDATA pgd,DWORD dwID);
extern void SetMessageHeader(LPDWORD pdwMsg,DWORD dwSize, DWORD dwToken);
extern void KillTCPEnumAsyncThread(LPGLOBALDATA pgd);

// Support for SendEx in dpsp.c

extern HRESULT UnreliableSendEx(LPDPSP_SENDEXDATA psd, LPSENDINFO lpSendInfo);
extern HRESULT ReliableSendEx(LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo);
extern VOID RemovePendingAsyncSends(LPGLOBALDATA pgd, DPID dwPlayerTo);
extern BOOL bAsyncSendsPending(LPGLOBALDATA pgd, DPID dwPlayerTo);

// from winsock.c
extern HRESULT FAR PASCAL CreateSocket(LPGLOBALDATA pgd,SOCKET * psock,INT type,
	WORD port,ULONG address,SOCKERR * perr, BOOL bInRange);
extern HRESULT SPConnect(SOCKET* psSocket, LPSOCKADDR psockaddr,UINT addrlen, BOOL bOutBoundOnly);
extern HRESULT CreateAndInitStreamSocket(LPGLOBALDATA pgd);
extern HRESULT SetPlayerAddress(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,SOCKET sSocket,BOOL fStream); 
extern HRESULT CreatePlayerDgramSocket(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,DWORD dwFlags); 
extern HRESULT CreatePlayerStreamSocket(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,DWORD dwFlags); 
extern HRESULT SetDescriptionAddress(LPSPPLAYERDATA ppd,LPDPSESSIONDESC2 lpsdDesc);
extern HRESULT SetReturnAddress(LPVOID pmsg,SOCKET sSocket);
extern HRESULT GetReturnAddress(LPVOID pmsg,LPSOCKADDR psockaddr);
extern HRESULT GetServerAddress(LPGLOBALDATA pgd,LPSOCKADDR psockaddr) ;
extern void IPX_SetNodenum(LPVOID pmsg,SOCKADDR_IPX * psockaddr);
extern void IP_GetAddr(SOCKADDR_IN * paddrDest,SOCKADDR_IN * paddrSrc) ;
extern void IP_SetAddr(LPVOID pBuffer,SOCKADDR_IN * psockaddr);
extern void IPX_GetNodenum(SOCKADDR_IPX * paddrDest,SOCKADDR_IPX * paddrSrc) ;
extern HRESULT KillSocket(SOCKET sSocket,BOOL fStream,BOOL fHard);
extern HRESULT KillPlayerSockets();
extern HRESULT GetAddress(ULONG * puAddress,char *pBuffer,int cch);
extern HRESULT KillThread(HANDLE hThread);

// from wsock2.c
extern DWORD WINAPI AsyncSendThreadProc(LPVOID pvCast);
extern HRESULT InitWinsock2();
extern HRESULT GetMaxUdpBufferSize(SOCKET socket, unsigned int * lpiSize);

extern HRESULT InternalReliableSendEx(LPGLOBALDATA pgd, LPDPSP_SENDEXDATA psd, 
				LPSENDINFO pSendInfo, SOCKADDR *lpSockAddr);
extern DWORD WINAPI SPSendThread(LPVOID lpv);


#ifdef DPLAY_VOICE_SUPPORT
// from spvoice.c
extern HRESULT WINAPI SP_OpenVoice(LPDPSP_OPENVOICEDATA pod) ;
extern HRESULT WINAPI SP_CloseVoice(LPDPSP_CLOSEVOICEDATA pod) ;
#endif // DPLAY_VOICE_SUPPORT

// from handler.c
HRESULT HandleServerMessage(LPGLOBALDATA pgd, SOCKET sSocket, LPBYTE pBuffer, DWORD dwSize);

#ifdef FULLDUPLEX_SUPPORT
// from registry.c
HRESULT GetFlagsFromRegistry(LPGUID lpguidSP, LPDWORD lpdwFlags);
#endif // FULLDUPLEX_SUPPORT

// MACROS based on fixed pool manager.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\spvoice.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsp.c
 *  Content:	sample direct play service provider, based on winsock
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  10/31/96	andyco	created it. happy holloween!
 ***************************************************************************/

#include "dpsp.h"

// get the player data for pod.  extract ip addr.  use netmeeting to place call.
HRESULT WINAPI SP_OpenVoice(LPDPSP_OPENVOICEDATA pod) 
{
    SOCKADDR_IN * pin;
    INT iAddrLen = sizeof(SOCKADDR_IN);
    HRESULT hr=DP_OK;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	
	// get the global data
	hr =pod->lpISP->lpVtbl->GetSPData(pod->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}
	// tcp only!
	if (pgd->AddressFamily != AF_INET)
	{
		DPF_ERR("voice only supported for TCP / IP");
		ASSERT(FALSE);
		return E_FAIL;
	}

	// get to address	
	hr = pod->lpISP->lpVtbl->GetSPPlayerData(pod->lpISP,pod->idTo,&ppdTo,&dwSize,DPGET_REMOTE);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		return hr;
	}

	pin = (SOCKADDR_IN *) DGRAM_PSOCKADDR(ppdTo);

	DPF(0,"calling hostname = %s\n",inet_ntoa(pin->sin_addr));
	hr = OpenVoice(inet_ntoa(pin->sin_addr));
	if (FAILED(hr))
	{
		DPF(0,"open voice failed - hr = 0x%08lx\n",hr);
		
	} 
	else 
	{
		gbVoiceOpen = TRUE;
	}
	
	return hr;
	
} // SP_OpenVoice

HRESULT WINAPI SP_CloseVoice(LPDPSP_CLOSEVOICEDATA pod) 
{
	HRESULT hr;
	
	hr = CloseVoice();
	if (FAILED(hr))
	{
		DPF(0,"close voice failed - hr = 0x%08lx\n",hr);
	} 

	// even if it failed, give up on this call...
	gbVoiceOpen = FALSE;		
	return hr;
	
} // SP_CloseVoice
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\fpm.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fpm.c
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97  aarono    Original
 ***************************************************************************/

#include "windows.h"
#include "dpsp.h"
#include "fpm.h"

#ifdef SENDEX

BOOL FN_BOOL_DUMMY(void *pvItem)
{
	return TRUE;
}

VOID FN_VOID_DUMMY(void *pvItem)
{
	return;
}

void * FPM_Get(LPFPOOL this)
{
	void * pvItem;

	EnterCriticalSection(&this->cs);
	
	if(!this->pPool){
	
		LeaveCriticalSection(&this->cs);
		pvItem = GlobalAlloc(GPTR, this->cbItemSize);

		if((pvItem) && !(*this->fnBlockInitAlloc)(pvItem) ){
			GlobalFree(pvItem);
			pvItem=NULL;
		}

		EnterCriticalSection(&this->cs);

		if(pvItem){	
			this->nAllocated++;
		}
		
	} else {
		pvItem=this->pPool;
		this->pPool=*((void **)pvItem);
	}

	if(pvItem){
	
		(*this->fnBlockInit)(pvItem);
		
		this->nInUse++;
		if(this->nInUse > this->nMaxInUse){
			this->nMaxInUse = this->nInUse;
		}
	}

	LeaveCriticalSection(&this->cs);

	return pvItem;
}

#ifdef DEBUG
void DebugCheckList(void *pvList, void *pvItem)
{
	void *pvWalker;
	DWORD n=0;
	pvWalker=pvList;

	while(pvWalker){
		if(pvWalker==pvItem){
			DPF(0,"ERROR: Found Item %x in List %x, item # %d\n",pvList,pvItem,n);
			DEBUG_BREAK();
		}
		n++;
		pvWalker=*((void **)pvWalker);
	}
}
#else
#define DebugCheckList()
#endif

void FPM_Release(LPFPOOL this, void *pvItem)
{
	EnterCriticalSection(&this->cs);
	DebugCheckList(this->pPool, pvItem); //BUGBUG: debug only.
	this->nInUse--;
	*((void**)pvItem)=this->pPool;
	this->pPool=pvItem;
	LeaveCriticalSection(&this->cs);
	
}

void FPM_Scale(LPFPOOL this)
{
	void * pvItem;

	if(!InterlockedExchange(&this->bInScale,1)){

		EnterCriticalSection(&this->cs);

		while((this->nAllocated > this->nMaxInUse) && this->pPool){
			pvItem = this->pPool;
			this->pPool=*((void **)pvItem);
			LeaveCriticalSection(&this->cs);
			(*this->fnBlockFini)(pvItem);
			GlobalFree(pvItem);
			EnterCriticalSection(&this->cs);
			this->nAllocated--;
		}
		
		this->nMaxInUse=this->nInUse;

		LeaveCriticalSection(&this->cs);

		InterlockedExchange(&this->bInScale,0);
	}
}

VOID FPM_Fini(LPFPOOL this, int bFORCE)
{
	void *pvItem;

	while(this->pPool){
		pvItem = this->pPool;
		this->pPool=*((void **)pvItem);
		(*this->fnBlockFini)(pvItem);
		GlobalFree(pvItem);
		this->nAllocated--;
	}
	if(this->nAllocated){
		DPF(0,"WSOCK: Exiting with unfreed FPM pool items\n");
	}
	DeleteCriticalSection(&this->cs);
	GlobalFree(this);
}

LPFPOOL FPM_Init(
	unsigned int size, 
	FN_BLOCKINITALLOC fnBlockInitAlloc,
	FN_BLOCKINIT      fnBlockInit, 
	FN_BLOCKFINI      fnBlockFini)
{
	LPFPOOL pPool;
	
	if(!(pPool=(LPFPOOL)GlobalAlloc(GPTR,sizeof(FPOOL))))
	{
	  return NULL;
	}

	InitializeCriticalSection(&pPool->cs);
	
	// by zero init.
	//pPool.pPool      = NULL;
	//pPool.nAllocated = 0;
	//pPool.nInUse     = 0;
	//pPool.nMaxInUse  = 0;
	//pPool.bInScale   = FALSE;

	if(fnBlockInitAlloc){
		pPool->fnBlockInitAlloc = fnBlockInitAlloc;
	} else {
		pPool->fnBlockInitAlloc = FN_BOOL_DUMMY;
	}
	if(fnBlockInit){
		pPool->fnBlockInit      = fnBlockInit;
	} else {
		pPool->fnBlockInit      = FN_VOID_DUMMY;
	}
	if(fnBlockFini){
		pPool->fnBlockFini      = fnBlockFini;
	} else {
		pPool->fnBlockFini      = FN_VOID_DUMMY;
	}

	pPool->Get    = FPM_Get;
	pPool->Release= FPM_Release;
	pPool->Scale  = FPM_Scale;
	pPool->Fini   = FPM_Fini;

	pPool->cbItemSize = size;
	
	return pPool;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\leverage.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       leverage.c
 *  Content:	code to allow third parties to hook our wsock sp
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *	8/30/96	andyco	moved this code from dpsp.c for more better clean
 *	2/18/98 a-peterz Comment byte order for address and port parameters
 **************************************************************************/

#include "dpsp.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"dpwsock helper functions- "


// the functions below are exported from dpwsock so sp's sitting on 
// top of us can hook our enum routine (e.g. for Kali)
// return the port of our enum socket (net byte order)
HRESULT DPWS_GetEnumPort(IDirectPlaySP * pISP,LPWORD pPort)
{
	SOCKADDR_IN sockaddr;
	int iAddrLen = sizeof(SOCKADDR);
	UINT err;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
		
	if (!pISP)
	{
		DPF_ERR("must pass in IDirectPlaySP pointer!");
		return E_FAIL;
	}
	
	// get the global data
	hr =pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		ExitThread(0);
		return 0;

	}

	if (AF_IPX == pgd->AddressFamily) 
	{
		DPF(0," could not get the enum port for AF_IPX");
		return E_FAIL;
	}

	ASSERT(pPort);
	ASSERT(INVALID_SOCKET != pgd->sSystemStreamSocket);
	
    err = getsockname(pgd->sSystemStreamSocket,(SOCKADDR *)&sockaddr,&iAddrLen);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"GetEnumPort - getsockname - err = %d\n",err);
		return E_FAIL;
    } 

	*pPort = sockaddr.sin_port;
	
	return DP_OK;
} // GetEnumPort

// takes a port and an ip (both in net byte order) and builds a message header
HRESULT DPWS_BuildIPMessageHeader(IDirectPlaySP * pISP,LPVOID pvMessageHeader,LPDWORD
 	pdwMessageHeaderSize,WORD port,DWORD inaddr)
{
	LPMESSAGEHEADER	phead;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
		
	if (!pISP)
	{
		DPF_ERR("must pass in IDirectPlaySP pointer!");
		return E_FAIL;
	}
	
	// get the global data
	hr =pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		ExitThread(0);
		return 0;

	}

	ASSERT(pdwMessageHeaderSize);
	if ( (*pdwMessageHeaderSize < sizeof(MESSAGEHEADER)) || (NULL == pvMessageHeader))
	{
		*pdwMessageHeaderSize = sizeof(MESSAGEHEADER);
		return DPERR_BUFFERTOOSMALL;
	}

	if (AF_IPX == pgd->AddressFamily)
	{
		DPF_ERR("can't set header for ipx");
		return E_NOTIMPL;
	}

	phead = (LPMESSAGEHEADER)pvMessageHeader;
	((SOCKADDR_IN *)&(phead->sockaddr))->sin_family =  AF_INET;
	((SOCKADDR_IN *)&(phead->sockaddr))->sin_addr.s_addr =  inaddr;
	((SOCKADDR_IN *)&(phead->sockaddr))->sin_port =  port;

	DEBUGPRINTADDR(5,"BuildIPMessageHeader - setting header to",&(phead->sockaddr));

	return DP_OK;

} // BuildIPMessageHeader


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\helpcli.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       helpcli.c
 *  Content:	client code to talk to dplaysvr.exe
 *					allows multiple dplay winscock clients to share
 *					a single port.  see %manroot%\dplay\dplaysvr\dphelp.c
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/15/97		andyco	created from w95help.h
 *
 ***************************************************************************/
#include "helpcli.h"

extern DWORD	dwHelperPid;

/*
 * sendRequest
 *
 * communicate a request to DPHELP
 */
static BOOL sendRequest( LPDPHELPDATA req_phd )
{
    LPDPHELPDATA	phd;
    HANDLE		hmem;
    HANDLE		hmutex;
    HANDLE		hackevent;
    HANDLE		hstartevent;
    BOOL		rc;

    /*
     * get events start/ack events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_EVENT_NAME );
    if( hstartevent == NULL )
    {
        return FALSE;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_ACK_EVENT_NAME );
    if( hackevent == NULL )
    {
        CloseHandle( hstartevent );
        return FALSE;
    }

    /*
     * create shared memory area
     */
    hmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
    		PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
                DPHELP_SHARED_NAME );
    if( hmem == NULL )
    {
        DPF( 1, "Could not create file mapping!" );
        CloseHandle( hstartevent );
        CloseHandle( hackevent );
        return FALSE;
    }
    phd = (LPDPHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
    if( phd == NULL )
    {
        DPF( 1, "Could not create view of file!" );
        CloseHandle( hmem );
        CloseHandle( hstartevent );
        CloseHandle( hackevent );
        return FALSE;
    }

    /*
     * wait for access to the shared memory
     */
    hmutex = OpenMutex( SYNCHRONIZE, FALSE, DPHELP_MUTEX_NAME );
    if( hmutex == NULL )
    {
        DPF( 1, "Could not create mutex!" );
        UnmapViewOfFile( phd );
        CloseHandle( hmem );
        CloseHandle( hstartevent );
        CloseHandle( hackevent );
        return FALSE;
    }
    WaitForSingleObject( hmutex, INFINITE );

    /*
     * wake up DPHELP with our request
     */
    memcpy( phd, req_phd, sizeof( DPHELPDATA ) );
    if( SetEvent( hstartevent ) )
    {
        WaitForSingleObject( hackevent, INFINITE );
        memcpy( req_phd, phd, sizeof( DPHELPDATA ) );
        rc = TRUE;
    }
    else
    {
        DPF( 1, "Could not signal event to notify DPHELP" );
        rc = FALSE;
    }

    /*
     * done with things
     */
    ReleaseMutex( hmutex );
    CloseHandle( hmutex );
    CloseHandle( hstartevent );
    CloseHandle( hackevent );
    UnmapViewOfFile( phd );
    CloseHandle( hmem );
    return rc;

} /* sendRequest */


/*
 * WaitForHelperStartup
 */
BOOL WaitForHelperStartup( void )
{
    HANDLE	hevent;
    DWORD	rc;

    hevent = CreateEvent( NULL, TRUE, FALSE, DPHELP_STARTUP_EVENT_NAME );
    if( hevent == NULL )
    {
        return FALSE;
    }
    DPF( 3, "Wait DPHELP startup event to be triggered" );
    rc = WaitForSingleObject( hevent, INFINITE );
    CloseHandle( hevent );
    return TRUE;

} /* WaitForHelperStartup */

/*
 * CreateHelperProcess
 */
BOOL CreateHelperProcess( LPDWORD ppid )
{
    if( dwHelperPid == 0 )
    {
        STARTUPINFO		si;
        PROCESS_INFORMATION	pi;
        HANDLE			h;

        h = OpenEvent( SYNCHRONIZE, FALSE, DPHELP_STARTUP_EVENT_NAME );
        if( h == NULL )
        {
            si.cb = sizeof(STARTUPINFO);
            si.lpReserved = NULL;
            si.lpDesktop = NULL;
            si.lpTitle = NULL;
            si.dwFlags = 0;
            si.cbReserved2 = 0;
            si.lpReserved2 = NULL;

            DPF( 3, "Creating helper process dplaysvr.exe now" );
            if( !CreateProcess(NULL, "dplaysvr.exe",  NULL, NULL, FALSE,
                               NORMAL_PRIORITY_CLASS,
                               NULL, NULL, &si, &pi) )
            {
                DPF( 2, "Could not create DPHELP.EXE" );
                return FALSE;
            }
            dwHelperPid = pi.dwProcessId;
            DPF( 3, "Helper Process created" );
        }
        else
        {
            DPHELPDATA	hd;
            DPF( 3, "dplaysvr already exists, waiting for dplaysvr event" );
            WaitForSingleObject( h, INFINITE );
            CloseHandle( h );
            DPF( 3, "Asking for DPHELP pid" );
            hd.req = DPHELPREQ_RETURNHELPERPID;
            sendRequest( &hd );
            dwHelperPid = hd.pid;
            DPF( 3, "DPHELP pid = %08lx", dwHelperPid );
        }
        *ppid = dwHelperPid;
        return TRUE;
    }
    *ppid = dwHelperPid;
    return FALSE;

} /* CreateHelperProcess */

// notify dphelp.c that we have a new server on this system
HRESULT HelperAddDPlayServer(USHORT port)
{
    DPHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

    memset(&hd, 0, sizeof(DPHELPDATA));
    hd.req = DPHELPREQ_DPLAYADDSERVER;
    hd.pid = pid;
    hd.port = port;
    if (sendRequest(&hd)) return hd.hr;
    else return E_FAIL;
				
} // HelperAddDPlayServer

// server is going away
BOOL HelperDeleteDPlayServer(USHORT port)
{
    DPHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

	memset(&hd, 0, sizeof(DPHELPDATA));
    hd.req = DPHELPREQ_DPLAYDELETESERVER;
    hd.pid = pid;
	hd.port = port;
    return sendRequest(&hd);

} // HelperDeleteDPlayServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\registry.c ===
#include "dpsp.h"

#define REGISTRY_NAMELEN	512
// space (in bytes) for a human readable (unicode) guid + some extra
#define GUID_STRING_SIZE 80

#define SZ_SP_KEY		"Software\\Microsoft\\DirectPlay\\Service Providers"
#define SZ_GUID			"Guid"
#define SZ_FLAGS		"dwFlags"

#undef DPF_MODNAME
#define DPF_MODNAME "FindApplicationInRegistry"

// convert a hex char to an int - used by str to guid conversion
// we wrote our own, since the ole one is slow, and requires ole32.dll
// we use ansi strings here, since guids won't get internationalized
int GetDigit(LPSTR lpstr)
{
	char ch = *lpstr;
    
    if (ch >= '0' && ch <= '9')
        return(ch - '0');
    if (ch >= 'a' && ch <= 'f')
        return(ch - 'a' + 10);
    if (ch >= 'A' && ch <= 'F')
        return(ch - 'A' + 10);
    return(0);
}
// walk the string, writing pairs of bytes into the byte stream (guid)
// we need to write the bytes into the byte stream from right to left
// or left to right as indicated by fRightToLeft
void ConvertField(LPBYTE lpByte,LPSTR * ppStr,int iFieldSize,BOOL fRightToLeft)
{
	int i;

	for (i=0;i<iFieldSize ;i++ )
	{
		// don't barf on the field separators
		if ('-' == **ppStr) (*ppStr)++; 
		if (fRightToLeft == TRUE)
		{
			// work from right to left within the byte stream
			*(lpByte + iFieldSize - (i+1)) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
		} 
		else 
		{
			// work from  left to right within the byte stream
			*(lpByte + i) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
		}
		*ppStr+=2; // get next two digit pair
	}
} // ConvertField


// convert the passed in string to a real GUID
// walk the guid, setting each byte in the guid to the two digit hex pair in the
// passed string
HRESULT GUIDFromString(LPSTR lpStr, GUID * pGuid)
{
	BYTE * lpByte; // byte index into guid
	int iFieldSize; // size of current field we're converting
	// since its a guid, we can do a "brute force" conversion
	
	// make sure we have a {xxxx-...} type guid
	if ('{' !=  *lpStr) return E_FAIL;
	lpStr++;
	
	lpByte = (BYTE *)pGuid;
	// data 1
	iFieldSize = sizeof(unsigned long);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 2
	iFieldSize = sizeof(unsigned short);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 3
	iFieldSize = sizeof(unsigned short);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 4
	iFieldSize = 8*sizeof(unsigned char);
	ConvertField(lpByte,&lpStr,iFieldSize,FALSE);
	lpByte += iFieldSize;

	// make sure we ended in the right place
	if ('}' != *lpStr) 
	{
		DPF_ERR("invalid guid!!");
		memset(pGuid,0,sizeof(GUID));
		return E_FAIL;
	}

	return DP_OK;
}// GUIDFromString

BOOL FindSPInRegistry(LPGUID lpguid, LPSTR lpszSPName, DWORD dwNameSize, HKEY * lphkey)
{
	HKEY	hkeyDPSPs, hkeySP;
	DWORD	dwIndex = 0;
	CHAR	szGuidStr[GUID_STRING_SIZE];
	DWORD	dwGuidStrSize = GUID_STRING_SIZE;
	DWORD	dwType = REG_SZ;
	GUID	guidSP;
	LONG	lReturn;
	BOOL	bFound = FALSE;
	DWORD	dwSaveNameSize = dwNameSize;


	DPF(7, "Entering FindSPInRegistry");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			lpguid, lpszSPName, dwNameSize, lphkey);

 	// Open the Applications key
	lReturn = RegOpenKeyExA(HKEY_LOCAL_MACHINE, SZ_SP_KEY, 0,
							KEY_READ, &hkeyDPSPs);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("Unable to open DPlay service provider registry key!");
		return FALSE;
	}

	// Walk the list of sps in the registry, looking for
	// the sp with the right GUID
	while(!bFound)
	{
		// Open the next application key
		dwSaveNameSize = dwNameSize;
		dwGuidStrSize = GUID_STRING_SIZE;
		lReturn = RegEnumKeyExA(hkeyDPSPs, dwIndex++, lpszSPName,
						&dwSaveNameSize, NULL, NULL, NULL, NULL);

		// If the enum returns no more apps, we want to bail
		if(lReturn != ERROR_SUCCESS)
			break;
		
		// Open the application key		
		lReturn = RegOpenKeyExA(hkeyDPSPs, lpszSPName, 0,
									KEY_READ, &hkeySP);
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERR("Unable to open sp key!");
			continue;
		}

		// Get the GUID of the Game
		lReturn = RegQueryValueExA(hkeySP, SZ_GUID, NULL, &dwType,
									(LPBYTE)&szGuidStr, &dwGuidStrSize);
		if(lReturn != ERROR_SUCCESS)
		{
			RegCloseKey(hkeySP);
			DPF_ERR("Unable to query GUID key value!");
			continue;
		}

		// Convert the string to a real GUID & Compare it to the passed in one
		GUIDFromString(szGuidStr, &guidSP);
		if(IsEqualGUID(&guidSP, lpguid))
		{
			bFound = TRUE;
			break;
		}

		// Close the App key
		RegCloseKey(hkeySP);
	}

	// Close the DPApps key
	RegCloseKey(hkeyDPSPs);

	if(bFound)
		*lphkey = hkeySP;

	return bFound;


} // FindSPInRegistry



#undef DPF_MODNAME
#define DPF_MODNAME "GetKeyValue"
BOOL GetKeyValue(HKEY hkeyApp, LPSTR lpszKey, DWORD dwType, LPBYTE * lplpValue)
{
	DWORD	dwSize;
	LPBYTE	lpTemp = NULL;
	LONG	lReturn;


	DPF(7, "Entering GetKeyValue");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			hkeyApp, lpszKey, lplpValue);

	ASSERT(lplpValue);

	// Get the size of the buffer for the Path
	lReturn = RegQueryValueExA(hkeyApp, lpszKey, NULL, &dwType, NULL, &dwSize);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("Error getting size of key value!");
		return FALSE;
	}

	// If the size is 1, then it is an empty string (only contains a
	// null terminator).  Treat this the same as a NULL string or a
	// missing key and fail it.
	if(dwSize <= 1)
		return FALSE;

	ENTER_DPSP();
	
	// Alloc the buffer for the Path
	lpTemp = MemAlloc(dwSize);

	LEAVE_DPSP();
	
	if(!lpTemp)
	{
		DPF_ERR("Unable to allocate temporary string for Path!");
		return FALSE;
	}

	// Get the value itself
	lReturn = RegQueryValueExA(hkeyApp, lpszKey, NULL, &dwType,
							(LPBYTE)lpTemp, &dwSize);
	if(lReturn != ERROR_SUCCESS)
	{
		MemFree(lpTemp);
		DPF_ERR("Unable to get key value!");
		return FALSE;
	}

	*lplpValue = lpTemp;
	return TRUE;

} // GetKeyValue


#undef DPF_MODNAME
#define DPF_MODNAME "GetFlagsFromRegistry"
HRESULT GetFlagsFromRegistry(LPGUID lpguidSP, LPDWORD lpdwFlags)
{
	LPSTR	lpszSPName=NULL;
	HKEY	hkeySP = NULL;
	LPBYTE	lpValue=NULL;
	DWORD	dwSize = 0;
	HRESULT hr = DP_OK;


	DPF(7, "Entering GetFlagsFromRegistry");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpguidSP, lpdwFlags);

	ENTER_DPSP();
	
	// Allocate memory for the App Name
	lpszSPName = MemAlloc(REGISTRY_NAMELEN);

	LEAVE_DPSP();
	
	if(!lpszSPName)
	{
		DPF_ERR("Unable to allocate memory for sp name!");
		return E_OUTOFMEMORY;
	}
	
	// Open the registry key for the App
	if(!FindSPInRegistry(lpguidSP, lpszSPName,REGISTRY_NAMELEN, &hkeySP))
	{
		DPF_ERR("Unable to find sp in registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	// Get the port value.
	if(!GetKeyValue(hkeySP, SZ_FLAGS, REG_BINARY, &lpValue))
	{
		DPF_ERR("Unable to get flags value from registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	*lpdwFlags = *(LPDWORD)lpValue;

	// fall through

CLEANUP_EXIT:

	if (lpszSPName) MemFree(lpszSPName);
	if (lpValue) MemFree(lpValue);
	
	// Close the Apps key
	if(hkeySP)
		RegCloseKey(hkeySP);

	return hr;

} // GetFlagsFromRegistry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\sources.inc ===
MAJORCOMP=windows
MINORCOMP=GDI
UMTYPE=windows

TARGETNAME=dpwsockx
TARGETTYPE=DYNLINK

INCLUDES=..\..\..\inc; \
	 ..\..\..\misc; \
	..\; \
	 ..\..\dplay; \
	 ..\..\dplaysvr; \
	 ..\..\common; \
	 ..\..\nmvoice; \
	 ..\..\..\dplobby\dplobby;

TARGETPATH=obj

TARGETLIBS=$(SDK_LIB_PATH)\libc.lib    \
	   $(SDK_LIB_PATH)\user32.lib    \
	   $(SDK_LIB_PATH)\kernel32.lib  \
	   $(SDK_LIB_PATH)\wsock32.lib \
	   $(SDK_LIB_PATH)\dplayx.lib \
	   $(SDK_LIB_PATH)\ole32.lib \
	   $(SDK_LIB_PATH)\oleaut32.lib \
	   $(SDK_LIB_PATH)\uuid.lib \
	   $(SDK_LIB_PATH)\winmm.lib

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

C_DEFINES=$(C_DEFINES) -DUSE_CRITSECTS -DWIN16_SEPARATE -DNEW_DPF

LINKER_FLAGS=-SECTION:share,RWS

#LINKLIBS= \

SOURCES= \
	..\bilink.c \
	..\fpm.c \
	..\wsock2.c \
	..\leverage.c \
	..\dpsp.c \
	..\winsock.c \
	..\dllmain.c \
	..\helpcli.c \
	..\handler.c \
	..\dpwsock.rc \
	memalloc.c \
	newdpf.c \
	dputils.c

DLLENTRY=_DllMainCRTStartup
DLLDEF=..\dpwsock.def
NTTARGETFILE0=MISC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPLobby"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\w95help.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95hack.c
 *  Content:	Win95 hack-o-rama code
 *		This is a HACK to handle the fact that Win95 doesn't notify
 *		a DLL when a process is destroyed.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   28-mar-95	craige	initial implementation
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	reworked for new ddhelp
 *   09-may-95	craige	loading any DLL
 *   16-sep-95	craige	bug 1117: must UnmapViewOfFile before closing handle
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>

#include "w95help.h"
#include "dpf.h"

//extern DWORD	* pdwHelperPid;
//extern HANDLE	* phModule;	// must be defined
extern DWORD	dwHelperPid;
extern HANDLE	hModule;	// must be defined


/*
 * sendRequest
 *
 * communicate a request to DDHELP
 */
static BOOL sendRequest( LPDDHELPDATA req_phd )
{
    LPDDHELPDATA	phd;
    HANDLE		hmem;
    HANDLE		hmutex;
    HANDLE		hackevent;
    HANDLE		hstartevent;
    BOOL		rc;

    /*
     * get events start/ack events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_EVENT_NAME );
    if( hstartevent == NULL )
    {
	return FALSE;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_ACK_EVENT_NAME );
    if( hackevent == NULL )
    {
	CloseHandle( hstartevent );
	return FALSE;
    }

    /*
     * create shared memory area
     */
    hmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
    		PAGE_READWRITE, 0, sizeof( DDHELPDATA ),
		DDHELP_SHARED_NAME );
    if( hmem == NULL )
    {
	DPF( 1, "Could not create file mapping!" );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    phd = (LPDDHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
    if( phd == NULL )
    {
	DPF( 1, "Could not create view of file!" );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }

    /*
     * wait for access to the shared memory
     */
    hmutex = OpenMutex( SYNCHRONIZE, FALSE, DDHELP_MUTEX_NAME );
    if( hmutex == NULL )
    {
	DPF( 1, "Could not create mutex!" );
	UnmapViewOfFile( phd );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    WaitForSingleObject( hmutex, INFINITE );

    /*
     * wake up DDHELP with our request
     */
    memcpy( phd, req_phd, sizeof( DDHELPDATA ) );
    phd->req_id = hModule;
    if( SetEvent( hstartevent ) )
    {
	WaitForSingleObject( hackevent, INFINITE );
	memcpy( req_phd, phd, sizeof( DDHELPDATA ) );
	rc = TRUE;
    }
    else
    {
	DPF( 1, "Could not signal event to notify DDHELP" );
	rc = FALSE;
    }

    /*
     * done with things
     */
    ReleaseMutex( hmutex );
    CloseHandle( hmutex );
    CloseHandle( hstartevent );
    CloseHandle( hackevent );
    UnmapViewOfFile( phd );
    CloseHandle( hmem );
    return rc;

} /* sendRequest */

/*
 * DoneWithHelperProcess
 */
void DoneWithHelperProcess( void )
{
    DDHELPDATA	hd;

    if( dwHelperPid == 0 )
    {
	return;
    }

    hd.req = DDHELPREQ_FREEDCLIST;
    sendRequest( &hd );

} /* DoneWithHelperProcess */

/*
 * WaitForHelperStartup
 */
BOOL WaitForHelperStartup( void )
{
    HANDLE	hevent;
    DWORD	rc;

    hevent = CreateEvent( NULL, TRUE, FALSE, DDHELP_STARTUP_EVENT_NAME );
    if( hevent == NULL )
    {
	return FALSE;
    }
    DPF( 3, "Wait DDHELP startup event to be triggered" );
    rc = WaitForSingleObject( hevent, INFINITE );
    CloseHandle( hevent );
    return TRUE;

} /* WaitForHelperStartup */

/*
 * HelperLoadDLL
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context )
{
    DDHELPDATA  hd;
    DWORD       rc = 0;

    if( dllname != NULL )
    {
	hd.req = DDHELPREQ_LOADDLL;
	lstrcpy( hd.fname, dllname );
	if( fnname != NULL )
	{
	    strcpy( hd.func, fnname );
	    hd.context = context;
	    DPF( 3, "Context=%08lx", context );
	}
	else
	{
	    hd.func[0] = 0;
	}
	DPF( 3, "Asking DDHELP to load DLL %s", dllname );
        sendRequest( &hd );
        rc = hd.dwReturn;
    }

    return rc;

} /* HelperLoadDLL */

/*
 * HelperCreateThread
 */
void HelperCreateThread( void )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEHELPERTHREAD;
    sendRequest( &hd );

} /* HelperCreateThread */

/*
 * SignalNewProcess
 *
 * Signal DDHELP that a new process has arrived.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc )
{
    DDHELPDATA	hd;

    if( pid == dwHelperPid )
    {
	DPF( 3, "Helper connected to DLL - no signal required" );
	return;
    }

    DPF( 3, "Signalling DDHELP that a new process has connected" );
    hd.req = DDHELPREQ_NEWPID;
    hd.pid = pid;
    hd.lpNotify = proc;
    sendRequest( &hd );

} /* SignalNewProcess */

/*
 * SignalNewDriver
 *
 * Signal DDHELP that a new driver has been loaded.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewDriver( LPSTR fname, BOOL isdisp )
{
    DDHELPDATA	hd;

    DPF( 3, "Signalling DDHELP to create a new DC" );
    hd.req = DDHELPREQ_NEWDC;
    hd.isdisp = isdisp;
    lstrcpy( hd.fname, fname );
    sendRequest( &hd );

} /* SignalNewDriver */

/*
 * CreateHelperProcess
 */
BOOL CreateHelperProcess( LPDWORD ppid )
{
    if( dwHelperPid == 0 )
    {
	STARTUPINFO		si;
	PROCESS_INFORMATION	pi;
	HANDLE			h;

	h = OpenEvent( SYNCHRONIZE, FALSE, DDHELP_STARTUP_EVENT_NAME );
	if( h == NULL )
	{
	    si.cb = sizeof(STARTUPINFO);
	    si.lpReserved = NULL;
	    si.lpDesktop = NULL;
	    si.lpTitle = NULL;
	    si.dwFlags = 0;
	    si.cbReserved2 = 0;
	    si.lpReserved2 = NULL;

	    DPF( 3, "Creating helper process now" );
	    if( !CreateProcess(NULL, "ddhelp.exe",  NULL, NULL, FALSE,
			       NORMAL_PRIORITY_CLASS,
			       NULL, NULL, &si, &pi) )
	    {
		DPF( 2, "Could not create DDHELP.EXE" );
		return FALSE;
	    }
	    dwHelperPid = pi.dwProcessId;
	    DPF( 3, "Helper rocess created" );
	}
	else
	{
	    DDHELPDATA	hd;
	    DPF( 3, "DDHELP already exists, waiting for DDHELP event" );
	    WaitForSingleObject( h, INFINITE );
	    CloseHandle( h );
	    DPF( 3, "Asking for DDHELP pid" );
	    hd.req = DDHELPREQ_RETURNHELPERPID;
	    sendRequest( &hd );
	    dwHelperPid = hd.pid;
	    DPF( 3, "DDHELP pid = %08lx", dwHelperPid );
	}
	*ppid = dwHelperPid;
	return TRUE;
    }
    *ppid = dwHelperPid;
    return FALSE;

} /* CreateHelperProcess */

#ifndef WINNT   //this is Just For Now... dsound will get the help it needs..jeffno 951206
/*
 * HelperWaveOpen
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx )
{
    DDHELPDATA	hd;

    if( (lphwo != NULL) && (pwfx != NULL) )
    {
	hd.req = DDHELPREQ_WAVEOPEN;
	hd.pData1 = lphwo;
	hd.dwData1 = dwDeviceID;
	hd.dwData2 = (DWORD)pwfx;
	DPF( 3, "Asking DDHELP to Open Wave Device %d", dwDeviceID );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Open param error");
	return MMSYSERR_ERROR;
    }

} /* HelperWaveOpen */

/*
 * HelperWaveClose
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveClose( DWORD hwo )
{
    DDHELPDATA	hd;

    if( (hwo != 0) )
    {
	hd.req = DDHELPREQ_WAVECLOSE;
	hd.dwData1 = hwo;
	DPF( 3, "Asking DDHELP to Close Wave Device ");
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperWaveClose */

/*
 * HelperCreateTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperCreateTimer( DWORD dwResolution,
			 LPVOID	pTimerProc,
			 DWORD dwInstanceData )
{
    DDHELPDATA	hd;

    if( (dwResolution != 0) && (pTimerProc != NULL)  )
    {
	hd.req = DDHELPREQ_CREATETIMER;
	hd.pData1 = pTimerProc;
	hd.dwData1 = dwResolution;
	hd.dwData2 = dwInstanceData;
	DPF( 3, "Asking DDHELP to Create Timer" );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperCreateTimer */

/*
 * HelperKillTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperKillTimer( DWORD dwTimerID )
{
    DDHELPDATA	hd;

    if( (dwTimerID != 0) )
    {
	hd.req = DDHELPREQ_KILLTIMER;
	hd.dwData1 = dwTimerID;
	DPF( 3, "Asking DDHELP to KILL Timer %X", dwTimerID );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperKillTimer */

/*
 * HelperCreateDSMixerThread
 *
 * get the helper to create a mixer thread.
 */
HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
				  LPDWORD pdwThreadParam,
				  DWORD dwFlags,
				  LPDWORD pThreadId )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEDSMIXERTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSMixerThread

/*
 * HelperCreateDSFocusThread
 *
 * get the helper to create a sound focus thread.
 */
HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
				  LPDWORD pdwThreadParam,
				  DWORD dwFlags,
				  LPDWORD pThreadId )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEDSFOCUSTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSFocusThread

/*
 * HelperCallDSEmulatorCleanup
 *
 * Call the DirectSound function which cleans up MMSYSTEM handles
 */
void HelperCallDSEmulatorCleanup( LPVOID callback,
                                  LPVOID pDirectSound )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CALLDSCLEANUP;
    hd.pData1 = callback;
    hd.pData2 = pDirectSound;

    sendRequest( &hd );
}

#endif //not winnt -just for now-jeffno

/*
 * HelperCreateModeSetThread
 *
 * get the helper to load a DLL for us.
 */
BOOL HelperCreateModeSetThread(
		LPVOID callback,
		HANDLE *ph,
		LPVOID lpdd,
		DWORD hInstance )
{
    DDHELPDATA	hd;
    HANDLE	h;
    char	str[64];

    hd.req = DDHELPREQ_CREATEMODESETTHREAD;
    hd.lpModeSetNotify = callback;
    hd.pData1 = lpdd;
    hd.dwData1 = hInstance;
    sendRequest( &hd );
    wsprintf( str, DDHELP_MODESET_EVENT_NAME, hInstance );
    DPF( 3, "Trying to open event \"%s\"", str );
    h = OpenEvent( SYNCHRONIZE, FALSE, str );
    if( h == NULL )
    {
	DPF( 3, "Could not open modeset event!" );
	*ph = NULL;
	return FALSE;
    }
    *ph = h;
    DPF( 1, "HelperCreateModeSetThread GotEvent: %08lx", h );
    return TRUE;

} /* HelperCreateModeSetThread */

/*
 * HelperKillModeSetThread
 *
 * get the helper to load a DLL for us.
 */
void HelperKillModeSetThread( DWORD hInstance )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_KILLMODESETTHREAD;
    hd.dwData1 = hInstance;
    sendRequest( &hd );

} /* HelperKillModeSetThread */


// notify dphelp.c that we have a new server on this system
BOOL HelperAddDPlayServer(DWORD port)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

    hd.req = DDHELPREQ_DPLAYADDSERVER;
    hd.pid = pid;
    hd. dwData1 = port;
    return sendRequest(&hd);

} // HelperAddDPlayServer

// server is going away
BOOL HelperDeleteDPlayServer(void)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

    hd.req = DDHELPREQ_DPLAYDELETESERVER;
    hd.pid = pid;
    return sendRequest(&hd);

} // HelperDeleteDPlayServer

#ifdef USE_ALIAS
    /*
     * Get DDHELP to load the DirectSound VXD (if it has not
     * already done so) and return a handle to the VXD)
     */
    HANDLE HelperGetDSVxd( void )
    {
	DDHELPDATA hd;
	hd.req = DDHELPREQ_GETDSVXDHANDLE;
	sendRequest( &hd );
	return (HANDLE) hd.dwReturn;
    } /* HelperGetDSVxd */
#endif /* USE_ALIAS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\winsock.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       winsock.c
 *  Content:	windows socket support for dpsp
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *	3/15/96		andyco	created it
 *	4/12/96		andyco	got rid of dpmess.h! use DPlay_ instead of message macros
 *	4/18/96		andyco	added multihomed support, started ipx
 *	4/25/96		andyco	messages now have blobs (sockaddr's) instead of dwReserveds  
 *	5/31/96		andyco	all non-system players share a socket (gsStream and 
 *						gsDGramSocket).
 *	7/18/96		andyco	added dphelp for server socket
 *	8/1/96		andyco	no retry on connect failure
 *	8/15/96		andyco	local + remote data	- killthread
 *	8/30/96		andyco	clean it up b4 you shut it down! added globaldata.
 *	9/4/96		andyco	took out bye_bye message
 *	12/18/96	andyco	de-threading - use a fixed # of prealloced threads.
 *						cruised the enum socket / thread - use the system
 *						socket / thread instead
 *	3/17/97		kipo	rewrote server dialog code to not use global variable
 *						to return the address and to return any errors getting
 *						the address, especially DPERR_USERCANCEL
 *	5/12/97		kipo	the server address string is now stored in the globals
 *						at SPInit and resolved when you do EnumSessions so we
 *						will return any errors at that time instead of popping
 *						the dialog again. Fixes bug #5866
 *	11/19/97	myronth	Changed LB_SETCURSEL to CB_SETCURSEL (#12711)
 *	01/27/98	sohaim	added firewall support.
 *  02/13/98    aarono  added async support.
 *   2/18/98   a-peterz Comment byte order for address and port params (CreateSocket)
 *   6/19/98    aarono  turned on keepalive on reliable sockets.  If we
 *                      don't do this we can hang if the send target crashes
 *                      while in a low buffer (i.e. no buffer) state.
 *    7/9/99    aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 ***************************************************************************/

#include "dpsp.h"

// backlog for listen() api.  no constant in winsock, so we ask for the moon
#define LISTEN_BACKLOG 60

// how long to wait, in ms, til we abort a blocking WinSock connect() call
#define CONNECT_WATCHER_TIMEOUT		15000

/*
 ** CreateSocket
 *
 *  CALLED BY: all over
 *
 *  PARAMETERS:
 *		pgd - pointer to a global data
 *		psock - new socket. return value.
 *		type - stream or datagram
 *		port - what port we bind to (host byte order)
 *		address - what address to use (net byte order)
 *		*perr - set to the last socket error if fn fails
 *		bInRange - use reserved range of ports
 *
 *  DESCRIPTION:
 *		creates a new socket.  binds to port specified, at the address specified
 *
 *  RETURNS: DP_OK or E_FAIL. if E_FAIL, *perr is set with socket error code (see winsock.h)
 *
 */

HRESULT FAR PASCAL CreateSocket(LPGLOBALDATA pgd,SOCKET * psock,INT type,WORD wApplicationPort,ULONG address, 
	SOCKERR * perr,BOOL bInRange)
{
    SOCKET  sNew;
    SOCKADDR sockAddr;
    int bTrue = TRUE;
	int protocol = 0;
	BOOL bBroadcast = FALSE;
	WORD wPort;
	BOOL bBound = FALSE;

    *psock = INVALID_SOCKET; // in case we bail

    //  Create the socket.
	if (AF_IPX == pgd->AddressFamily) 
	{
		// set up protocol for ipx
		if (SOCK_STREAM == type)
		{
			protocol = NSPROTO_SPXII;
		} 
		else protocol = NSPROTO_IPX;
	}

   	sNew = socket( pgd->AddressFamily, type, protocol);
   	
    if (INVALID_SOCKET == sNew) 
    {
        // no cleanup needed, just bail
    	*perr = WSAGetLastError();
        return E_FAIL;
    }

    //  try to bind an address to the socket.
	// set up the sockaddr
	memset(&sockAddr,0,sizeof(sockAddr));
	switch (pgd->AddressFamily)
	{
		case AF_INET:
			{
				if ((SOCK_STREAM == type))
				{
					BOOL bTrue = TRUE;
					UINT err;
					
					// turn ON keepalive
					if (SOCKET_ERROR == setsockopt(sNew, SOL_SOCKET, SO_KEEPALIVE, (CHAR FAR *)&bTrue, sizeof(bTrue)))
					{
						err = WSAGetLastError();
						DPF(0,"Failed to turn ON keepalive - continue : err = %d\n",err);
					}

					ASSERT(bTrue);
					
					// turn off nagling
					if(pgd->dwSessionFlags & DPSESSION_OPTIMIZELATENCY) 
					{

						DPF(5, "Turning nagling off on socket");
						if (SOCKET_ERROR == setsockopt(sNew, IPPROTO_TCP, TCP_NODELAY, (CHAR FAR *)&bTrue, sizeof(bTrue)))
						{
							err = WSAGetLastError();
							DPF(0,"Failed to turn off naggling - continue : err = %d\n",err);
						}
					}
				}

				((SOCKADDR_IN *)&sockAddr)->sin_family      = PF_INET;
			    ((SOCKADDR_IN *)&sockAddr)->sin_addr.s_addr = address;
			    ((SOCKADDR_IN *)&sockAddr)->sin_port        = htons(wApplicationPort);
			    if (bInRange && !wApplicationPort)
			    {
			    	USHORT rndoffset;
			    	DPF(5, "Application didn't specify a port - using dplay range");

			    	rndoffset=(USHORT)(GetTickCount()%DPSP_NUM_PORTS);
			    	wPort = DPSP_MIN_PORT+rndoffset;
			    	do 
			    	{
					    DPF(5, "Trying to bind to port %d",wPort);
					    ((SOCKADDR_IN *)&sockAddr)->sin_port = htons(wPort);
					    
						// do the bind
					    if( SOCKET_ERROR != bind( sNew, (LPSOCKADDR)&sockAddr, sizeof(sockAddr) ) )
					    {
					    	bBound = TRUE;
						    DPF(5, "Successfully bound to port %d", wPort);				    
					    }
					    else
					    {
					    	if(++wPort > DPSP_MAX_PORT){
					    		wPort=DPSP_MIN_PORT;
					    	}
					    }	
				    }
				    while (!bBound && (wPort != DPSP_MIN_PORT+rndoffset));				    
			    }			    
		    }
			break;
			
		case AF_IPX:
			{
			    ((SOCKADDR_IPX *)&sockAddr)->sa_family      = (SHORT)pgd->AddressFamily;
			    ((SOCKADDR_IPX *)&sockAddr)->sa_socket		= wApplicationPort;
				// nodenum?
				memset(&(((SOCKADDR_IPX *)&sockAddr)->sa_nodenum),0,6);
				
			}
			break;
			
		default:
			ASSERT(FALSE);
			break;

	} // switch

	// do the bind
    if( !bBound && (SOCKET_ERROR == bind( sNew, (LPSOCKADDR)&sockAddr, sizeof(sockAddr))) )
    {
        goto ERROR_EXIT;
    }
    
    // success!
    *psock = sNew;

	DEBUGPRINTSOCK(9,"created a new socket (bound) - ",psock);

    return DP_OK;

ERROR_EXIT:
    // clean up and bail
    *perr = WSAGetLastError();
	DPF(0,"create socket failed- err = %d\n",*perr);
    closesocket(sNew);
    return E_FAIL;

}   // CreateSocket

#undef DPF_MODNAME
#define DPF_MODNAME	"KillSocket"

HRESULT KillSocket(SOCKET sSocket,BOOL fStream,BOOL fHard)
{
	UINT err;

    if (INVALID_SOCKET == sSocket) 
    {
		return E_FAIL;
    }

	if (!fStream)
    {
        if (SOCKET_ERROR == closesocket(sSocket)) 
        {
	        err = WSAGetLastError();
			DPF(0,"killsocket - dgram close err = %d\n",err);
			return E_FAIL;
        }
    }
	else 
	{
		LINGER Linger;

	   	if (fHard)
		{
			Linger.l_onoff=TRUE; // turn linger on
			Linger.l_linger=0; // nice small time out

		    if( SOCKET_ERROR == setsockopt( sSocket,SOL_SOCKET,SO_LINGER,(char FAR *)&Linger,
		                    sizeof(Linger) ) )
		    {
		        err = WSAGetLastError();
				DPF(0,"killsocket - stream setopt err = %d\n",err);
		    }
		}			
		if (SOCKET_ERROR == shutdown(sSocket,2)) 
		{
			// this may well fail, if e.g. no one is using this socket right now...
			// the error would be wsaenotconn 
	        err = WSAGetLastError();
			DPF(5,"killsocket - stream shutdown err = %d\n",err);
		}
        if (SOCKET_ERROR == closesocket(sSocket)) 
        {
	        err = WSAGetLastError();
			DPF(0,"killsocket - stream close err = %d\n",err);
			return E_FAIL;
        }
    }

	return DP_OK;
	
}// KillSocket

#undef DPF_MODNAME
#define DPF_MODNAME	"CreateAndInitStreamSocket"

// set up a stream socket to receive connections
// used w/ the gGlobalData.sStreamAcceptSocket
HRESULT CreateAndInitStreamSocket(LPGLOBALDATA pgd)
{
	HRESULT hr;
	UINT err;
	LINGER Linger;

    hr = CreateSocket(pgd,&(pgd->sSystemStreamSocket),SOCK_STREAM,pgd->wApplicationPort,INADDR_ANY,&err,TRUE);
    if (FAILED(hr)) 
    {
        DPF(0,"init listen socket failed - err = %d\n",err);
        return hr ;
    }

    // set up socket w/ max listening connections
    err = listen(pgd->sSystemStreamSocket,LISTEN_BACKLOG);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"init listen socket / listen error - err = %d\n",err);
        return E_FAIL ;
    }

	// set for hard disconnect
	Linger.l_onoff=1;
	Linger.l_linger=0;
    
    if( SOCKET_ERROR == setsockopt( pgd->sSystemStreamSocket,SOL_SOCKET,SO_LINGER,
		(char FAR *)&Linger,sizeof(Linger) ) )
    {
        err = WSAGetLastError();
		DPF(0,"Delete service socket - stream setopt err = %d\n",err);
    }
	
	DEBUGPRINTSOCK(1,"enum - listening on",&(pgd->sSystemStreamSocket));
	return DP_OK;
	
} // CreateAndInitStreamSocket



#undef DPF_MODNAME
#define DPF_MODNAME	"SPConnect"
// connect socket to sockaddr
HRESULT SPConnect(SOCKET* psSocket, LPSOCKADDR psockaddr,UINT addrlen, BOOL bOutBoundOnly)
{
	UINT err;
	HRESULT hr = DP_OK;
	DWORD dwLastError;
	u_long lNonBlock = 1; // passed to ioctlsocket to make socket non-blocking
	u_long lBlock = 0; // passed to ioctlsocket to make socket blocking again
	fd_set fd_setConnect;
	fd_set fd_setExcept;
	TIMEVAL timevalConnect;

	err=ioctlsocket(*psSocket, FIONBIO, &lNonBlock);	// make socket non-blocking
	if(SOCKET_ERROR == err){
		dwLastError=WSAGetLastError();
		DPF(0,"sp - failed to set socket %d to non-blocking mode err= %d\n", *psSocket, dwLastError);
		return DPERR_CONNECTIONLOST;
	}

	// Start the socket connecting.
    err = connect(*psSocket,psockaddr,addrlen);
    
	if(SOCKET_ERROR == err) {
		dwLastError=WSAGetLastError();
		if(dwLastError != WSAEWOULDBLOCK){
			DPF(0,"sp - connect failed err= %d\n", dwLastError);
			return DPERR_CONNECTIONLOST;
		}
		// we are going to wait for either the connect to succeed (socket to be writeable)
		// or the connect to fail (except fdset bit to be set).  So we init an FDSET with
		// the socket that is connecting and wait.
		FD_ZERO(&fd_setConnect);
		FD_SET(*psSocket, &fd_setConnect);

		FD_ZERO(&fd_setExcept);
		FD_SET(*psSocket, &fd_setExcept);

		timevalConnect.tv_sec=0;
		timevalConnect.tv_usec=CONNECT_WATCHER_TIMEOUT*1000; //msec -> usec
		
		err = select(0, NULL, &fd_setConnect, &fd_setExcept, &timevalConnect);

		// err is the number of sockets with activity or 0 for timeout 
		// or SOCKET_ERROR for error
		
		if(SOCKET_ERROR == err) {
			dwLastError=WSAGetLastError();
			DPF(0,"sp - connect failed err= %d\n", dwLastError);
			return DPERR_CONNECTIONLOST;
		} else if (0==err){
			// timed out
			DPF(0,"Connect timed out on socket %d\n",*psSocket);
			return DPERR_CONNECTIONLOST;
		}

		// Now see if the connect succeeded or the connect got an exception
		if(!(FD_ISSET(*psSocket, &fd_setConnect))){
			DPF(0,"Connect did not succeed on socket %d\n",*psSocket);
			return DPERR_CONNECTIONLOST;
		}
		if(FD_ISSET(*psSocket,&fd_setExcept)){
			DPF(0,"Got exception on socket %d during connect\n",*psSocket);
			return DPERR_CONNECTIONLOST;
		}
	}

	err=ioctlsocket(*psSocket, FIONBIO, &lBlock);	// make socket blocking again

	DEBUGPRINTSOCK(9,"successfully connected socket - ", psSocket);

	if (bOutBoundOnly)
	{
		DEBUGPRINTADDR(5, "Sending reuse connection message to - ",psockaddr);
		// tell receiver to reuse connection
		hr = SendReuseConnectionMessage(*psSocket);
	}

	return hr;

} //SPConnect
    

#undef DPF_MODNAME
#define DPF_MODNAME	"SetPlayerAddress"
// we've created a socket for a player. store its address in the players
// spplayerdata struct.  
HRESULT SetPlayerAddress(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,SOCKET sSocket,BOOL fStream) 
{
	SOCKADDR sockaddr;
	UINT err;
	int iAddrLen = sizeof(SOCKADDR);

    err = getsockname(sSocket,&sockaddr,&iAddrLen);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"setplayeraddress - getsockname - err = %d\n",err);
        closesocket(sSocket);
		return E_FAIL;
    } 

	if (fStream) 
	{
		switch (pgd->AddressFamily)
		{
			case AF_INET:
				STREAM_PSOCKADDR(ppd)->sa_family = AF_INET;
				IP_STREAM_PORT(ppd) = ((SOCKADDR_IN * )&sockaddr)->sin_port;
				// we don't know the address of the local player (multihomed!)
				IP_STREAM_ADDR(ppd) = 0; 
				break;

			case AF_IPX:
			{
				SOCKADDR_IPX * pipx = (SOCKADDR_IPX * )STREAM_PSOCKADDR(ppd);
				
				pipx->sa_family = AF_IPX;
				pipx->sa_socket = ((SOCKADDR_IPX*)&sockaddr)->sa_socket;
				memset(pipx->sa_nodenum,0,6);
				break;

			}

			default:
				ASSERT(FALSE);
		}
	} // stream
	else 
	{
		switch (pgd->AddressFamily)
		{
			case AF_INET:
				DGRAM_PSOCKADDR(ppd)->sa_family = AF_INET;
				IP_DGRAM_PORT(ppd) = ((SOCKADDR_IN *)&sockaddr)->sin_port;
				// we don't know the address of the local player (multihomed!)
				IP_DGRAM_ADDR(ppd) = 0; 
				break;

			case AF_IPX:
			{
				SOCKADDR_IPX * pipx = (SOCKADDR_IPX * )DGRAM_PSOCKADDR(ppd);
				
				pipx->sa_family = AF_IPX;
				pipx->sa_socket = ((SOCKADDR_IPX*)&sockaddr)->sa_socket;
				memset(pipx->sa_nodenum,0,6);
				break;

			}

			default:
				ASSERT(FALSE);
		}

	} // dgram

	return DP_OK;	
} // SetPlayerAddress

#undef DPF_MODNAME
#define DPF_MODNAME	"CreatePlayerSocket"

// called by CreatePlayerDgramSocket
// bind to our well known port for ipx
HRESULT GetIPXNameServerSocket(LPGLOBALDATA pgd)
{
	BOOL bTrue = TRUE;
	SOCKET sSocket;
	HRESULT hr;
	UINT err;
	
	// if there already was a receive thread, we need to kill
	// the socket, and remember the thread, so at shutdown we
	// can make sure it's gone.  note - we can't wait for it to 
	// leave now, since dplay hasn't dropped its locks, and
	// the thread may be blocked on dplay
	if (pgd->hDGramReceiveThread)
	{
		// it's ipx, and we're deleting the system player
		// we need to get rid of the system sockets, so that if we recreate as 
		// nameserver we can bind to a specific port...
		// ipx only uses datagram, so we only stop those...kill the socket
		ASSERT(INVALID_SOCKET != pgd->sSystemDGramSocket);
		KillSocket(pgd->sSystemDGramSocket,FALSE,TRUE);
		pgd->sSystemDGramSocket = INVALID_SOCKET;
		
		// remember the old thread - we'll need to make sure it's gone when we 
		// shut down
		pgd->hIPXSpareThread = pgd->hDGramReceiveThread;
		pgd->hDGramReceiveThread = NULL;
	}
	
    DPF(2,"ipx - creating name server dgram socket\n");
	
	// use name server port
    hr = CreateSocket(pgd,&sSocket,SOCK_DGRAM,SERVER_DGRAM_PORT,INADDR_ANY,&err,FALSE);
	if (FAILED(hr))
	{
		DPF(0,"IPX - DPLAY SERVER SOCKET IS ALREADY IN USE.  PLEASE SHUTDOWN ANY");
		DPF(0,"OTHER NETWORK APPLICATIONS AND TRY AGAIN");
		// boned!
		return DPERR_CANNOTCREATESERVER;
	}

    if( SOCKET_ERROR == setsockopt( sSocket,SOL_SOCKET,SO_BROADCAST,(char FAR *)&bTrue,
                sizeof(bTrue) ) )
    {
        err = WSAGetLastError();
		DPF(0,"create - could not set broadcast err = %d\n",err);
		// keep trying
    }

	DEBUGPRINTSOCK(2,"name server dgram socket (bound) - ",&sSocket);
	
	pgd->sSystemDGramSocket = sSocket;
	
	return DP_OK;

} // GetIPXNameServerSocket

HRESULT CreatePlayerDgramSocket(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,DWORD dwFlags)
{
	HRESULT hr=DP_OK;
	UINT err;
	SOCKET sSocket;
	
    if ( (AF_IPX == pgd->AddressFamily) && (dwFlags & DPLAYI_PLAYER_NAMESRVR))
    {
		//
		// AF_INET uses ddhelp to bind the nameserver to a specific port 
		// (SERVER_DGRAM_PORT).  AF_IPX binds to that port here.
		hr = GetIPXNameServerSocket(pgd);
		if (FAILED(hr))
		{
			return hr;
		}
		// store this for setting player address below
		sSocket = pgd->sSystemDGramSocket;
    } 
	else if (dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
    {
		if (INVALID_SOCKET == pgd->sSystemDGramSocket)
		{

			hr = CreateSocket(pgd,&sSocket,SOCK_DGRAM,pgd->wApplicationPort,INADDR_ANY,&err,TRUE);
		    if (FAILED(hr)) 
		    {
		    	DPF(0,"create sysplayer dgram socket failed - err = %d\n",err);
				return hr;
		    }
				
			#ifdef DEBUG
		    if (dwFlags & DPLAYI_PLAYER_NAMESRVR) 
		    {
		    	DEBUGPRINTSOCK(2,"name server dgram socket - ",&sSocket);
		    }
			#endif // DEBUG
			
			pgd->sSystemDGramSocket = sSocket;
		}
		else 
		{
			// store this for setting player address below
			sSocket = pgd->sSystemDGramSocket;	
		}
    }
	else 
	{
	
		ASSERT(INVALID_SOCKET != pgd->sSystemDGramSocket);
		sSocket = pgd->sSystemDGramSocket;	
	}

	// store the ip + port w/ the player...    
	hr = SetPlayerAddress(pgd,ppd,sSocket,FALSE);

	
	return hr; 
}  // CreatePlayerDgramSocket

HRESULT CreatePlayerStreamSocket(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,DWORD dwFlags) 
{
	SOCKET sSocket;
	HRESULT hr=DP_OK;
	UINT err;
	BOOL bListen = TRUE; // set if we created socket, + need to set it's listen
	
	if (dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
    {
		if (INVALID_SOCKET == pgd->sSystemStreamSocket)
		{
	    	hr = CreateSocket(pgd,&sSocket,SOCK_STREAM,pgd->wApplicationPort,INADDR_ANY,&err,TRUE);
		    if (FAILED(hr)) 
		    {
		    	DPF(0,"create player stream socket failed - err = %d\n",err);
				return hr;
		    }
			
			#ifdef DEBUG
		    if (dwFlags & DPLAYI_PLAYER_NAMESRVR) 
		    {
		    	DEBUGPRINTSOCK(2,"name server stream socket - ",&sSocket);
		    }
			#endif // DEBUG

			pgd->sSystemStreamSocket = sSocket;
		}
		else
		{
			sSocket = pgd->sSystemStreamSocket;	
			bListen = FALSE;
		}
    		
    }
	else 
	{
		ASSERT (INVALID_SOCKET != pgd->sSystemStreamSocket);
		sSocket = pgd->sSystemStreamSocket;	
		bListen = FALSE;			
	}
	
	if (bListen)
	{
		// set up socket to receive connections
	    err = listen(sSocket,LISTEN_BACKLOG);
		if (SOCKET_ERROR == err) 
		{
			err = WSAGetLastError();
			ASSERT(FALSE);
		    DPF(0,"ACK! stream socket listen failed - err = %d\n",err);
			// keep trying
		}
	}
	
	hr = SetPlayerAddress(pgd,ppd,sSocket,TRUE);
	return hr;

} // CreatePlayerStreamSocket


#undef DPF_MODNAME
#define DPF_MODNAME	"PokeAddr"


// poke an ip addr into a message blob
void IP_SetAddr(LPVOID pmsg,SOCKADDR_IN * paddrSrc)
{
	LPSOCKADDR_IN  paddrDest; // tempo variable, makes casting less ugly
	LPMESSAGEHEADER phead;

	phead = (LPMESSAGEHEADER)pmsg;
	// todo - validate header

	// leave the port intact, copy over the ip addr
	paddrDest = (SOCKADDR_IN *)&(phead->sockaddr);
	// poke the new ip addr into the message header
	paddrDest->sin_addr.s_addr = paddrSrc->sin_addr.s_addr;

	return;
	
} // IP_SetAddr

// get an ip addr from a message blob
void IP_GetAddr(SOCKADDR_IN * paddrDest,SOCKADDR_IN * paddrSrc) 
{
	// leave the port intact, copy over the nodenum
	if (0 == paddrDest->sin_addr.s_addr)
	{
		DPF(2,"remote player - setting address!! =  %s\n",inet_ntoa(paddrSrc->sin_addr));
		paddrDest->sin_addr.s_addr = paddrSrc->sin_addr.s_addr;
	}

	return;
		
} // IP_GetAddr

// poke the ipx nodenumber / a message
void IPX_SetNodenum(LPVOID pmsg,SOCKADDR_IPX * paddrSrc)
{
	LPSOCKADDR_IPX  paddrDest;	 // tempo variable, makes casting less ugly
	LPMESSAGEHEADER phead; 

	phead = (LPMESSAGEHEADER)pmsg;
	// todo - validate header
	
	// leave the port intact, copy over the nodenum
	paddrDest = (SOCKADDR_IPX *)&(phead->sockaddr);
	memcpy(paddrDest->sa_nodenum,paddrSrc->sa_nodenum,6);

	return;

}  // IPX_SetNodenum
							   
// reconstruct the nodenum from the msg
void IPX_GetNodenum(SOCKADDR_IPX * paddrDest,SOCKADDR_IPX * paddrSrc) 
{
	char sa_nodenum_zero[6];

	memset(sa_nodenum_zero,0,6);

	// if the nodenum is zero, set it
	if (0 == memcmp(paddrDest->sa_nodenum,sa_nodenum_zero,6))
	{
			DEBUGPRINTADDR(4,"IPX - setting remote player nodenum",(SOCKADDR *)paddrSrc);
			// leave the port intact, copy over the nodenum
			memcpy(paddrDest->sa_nodenum,paddrSrc->sa_nodenum,6);
	}
	return;
} // IPX_GetNodenum

// store the port of the socket w/ the message, so the receiving end
// can reconstruct the address to reply to
HRESULT SetReturnAddress(LPVOID pmsg,SOCKET sSocket) 
{
    SOCKADDR sockaddr;
    INT addrlen=sizeof(SOCKADDR);
	LPMESSAGEHEADER phead;
	UINT err;

	// find out what port gGlobalData.sEnumSocket is on
    err = getsockname(sSocket,(LPSOCKADDR)&sockaddr,&addrlen);
	if (SOCKET_ERROR == err)
	{
		err = WSAGetLastError();
		DPF(0,"could not get socket name - err = %d\n",err);
		return DP_OK;
	}

	DEBUGPRINTADDR(9,"setting return address = ",&sockaddr);

	phead = (LPMESSAGEHEADER)pmsg;
	// todo - validate header

	phead->sockaddr = sockaddr;

	return DP_OK;

} // SetReturnAddress

// code below all called by GetServerAddress. For IP, prompts user for ip address 
// for name server.
#undef DPF_MODNAME
#define DPF_MODNAME	"GetAddress"
// get the ip address from the pBuffer passed in by a user
// can either be a real ip, or a hostname
// called after the user fills out our dialog box
HRESULT GetAddress(ULONG * puAddress,char *pBuffer,int cch)
{
	UINT uiAddr;
	UINT err;
	PHOSTENT phostent;
	IN_ADDR hostaddr;

	if ( (0 == cch)  || (!pBuffer) || (0 == strlen(pBuffer)) )
	{
		*puAddress = INADDR_BROADCAST;
		return (DP_OK);
	} 
	
	// try inet_addr first
	uiAddr = inet_addr(pBuffer);

	if(0 == uiAddr)	// fix bug where "" buffer passed in.
	{
		*puAddress = INADDR_BROADCAST;
		return (DP_OK);
	}
	
	if (INADDR_NONE != uiAddr) 
	{
		// found it
		*puAddress = uiAddr;
		return (DP_OK);
	}
	
	// try hostbyname
	phostent = gethostbyname(pBuffer);
	if (NULL == phostent ) 
	{
		err = WSAGetLastError();
		DPF(0,"could not get host address - err = %d\n",err);
		return (DPERR_INVALIDPARAM);
	}
	memcpy(&hostaddr,phostent->h_addr,sizeof(hostaddr));
	DPF(1,"name server address = %s \n",inet_ntoa(hostaddr));
	*puAddress = hostaddr.s_addr;

	return (DP_OK);
} // GetAddress

// put up a dialog asking for a network address
// call get address to convert user specified address to network usable address
// called by GetServerAddress
INT_PTR CALLBACK DlgServer(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	HWND hWndCtl;
    char pBuffer[ADDR_BUFFER_SIZE];
	UINT cch;
	ULONG *lpuEnumAddress;
	HRESULT hr;

    switch (msg)
    {
    case WM_INITDIALOG:
		// set focus on edit box
        hWndCtl = GetDlgItem(hDlg, IDC_EDIT1);
        if (hWndCtl == NULL)
        {
            EndDialog(hDlg, FALSE);
            return(TRUE);
        }
        SetFocus(hWndCtl);
        SendMessage(hWndCtl, CB_SETCURSEL, 0, 0);

		// save pointer to enum address with the window
		SetWindowLongPtr(hDlg, DWLP_USER, (LONG) lParam);
        return(FALSE);


    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
		case IDOK:
			// get text entered in control
			cch = GetDlgItemText(hDlg, IDC_EDIT1, pBuffer, ADDR_BUFFER_SIZE);

			// get pointer to return address in
			lpuEnumAddress = (ULONG *) GetWindowLongPtr(hDlg, DWLP_USER);

			// convert string to enum address
            hr = GetAddress(lpuEnumAddress,pBuffer,cch);
			if (FAILED(hr))
				EndDialog(hDlg, hr);
			else
				EndDialog(hDlg, TRUE);
            return(TRUE);

		case IDCANCEL:
	        EndDialog(hDlg, FALSE);
	        return(TRUE);
		}
		break;
    }
    return (FALSE);
} // DlgServer

/*
 ** GetServerAddress
 *
 *  CALLED BY: EnumSessions
 *
 *  DESCRIPTION: launches the select network address dialog
 *
 *  RETURNS:  ip address (sockaddr.sin_addr.s_addr)
 *
 */
HRESULT ServerDialog(ULONG *lpuEnumAddress)
{
	HWND hwnd;
	INT_PTR	iResult;
	HRESULT hr;
	
	// we have a valid enum address
	if (*lpuEnumAddress)
		return (DP_OK);

	// use the fg window as our parent, since a ddraw app may be full screen
	// exclusive
	hwnd = GetForegroundWindow();

	iResult = DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_SELECTSERVER), hwnd,
							 DlgServer, (LPARAM) lpuEnumAddress);
	if (iResult == -1)
	{
		DPF_ERR("GetServerAddress - dialog failed");
		hr = DPERR_GENERIC;
	}
	else if (iResult < 0)
	{
		DPF(0, "GetServerAddress - dialog failed: %08X", iResult);
		hr = (HRESULT) iResult;
	}
	else if (iResult == 0)
    {
		hr = DPERR_USERCANCEL;
    }
	else
	{
		hr = DP_OK;
	}
		
	return (hr);
	
} //ServerDialog 

// called by enumsessions - find out where server is...
HRESULT GetServerAddress(LPGLOBALDATA pgd,LPSOCKADDR psockaddr) 
{
	HRESULT hr;

	if (AF_IPX == pgd->AddressFamily)
	{
		((LPSOCKADDR_IPX)psockaddr)->sa_family      = AF_IPX;
	    ((LPSOCKADDR_IPX)psockaddr)->sa_socket 		= SERVER_DGRAM_PORT;
		memset(&(((LPSOCKADDR_IPX)psockaddr)->sa_nodenum),0xff,sizeof(((LPSOCKADDR_IPX)psockaddr)->sa_nodenum));
	
		hr = DP_OK;	
	}
	else
	{
		if (pgd->bHaveServerAddress)
		{
			// use enum address passed to SPInit
            hr = GetAddress(&pgd->uEnumAddress,pgd->szServerAddress,strlen(pgd->szServerAddress));
		}
		else
		{
			// ask user for enum address
			hr = ServerDialog(&pgd->uEnumAddress);
		}

		if (SUCCEEDED(hr))
		{
			// setup winsock to enum this address
			((LPSOCKADDR_IN)psockaddr)->sin_family      = AF_INET;
			((LPSOCKADDR_IN)psockaddr)->sin_addr.s_addr = pgd->uEnumAddress;		
			// see byte-order comment in dpsp.h for this constant
			((LPSOCKADDR_IN)psockaddr)->sin_port 		= SERVER_DGRAM_PORT;
		}
		else
		{
			DPF(0, "Invalid server address: 0x%08lx", hr); 
		}
	}	

	return (hr);
} // GetServerAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\daytona\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\memalloc.c .
	copy ..\..\common\dputils.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\context.c ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       context.c
 *  Content:	Internal methods for context (handle) management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	1/18/97		myronth	Created it
 *	2/12/97		myronth	Mass DX5 changes
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
						this includes removing this file from the build
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetNewContextID"
HRESULT PRV_GetNewContextID(LPDPLOBBYI_DPLOBJECT this, LPDWORD lpdwContext)
{

	DPF(7, "Entering PRV_GetNewContextID");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpdwContext);

	ASSERT(this);
	ASSERT(lpdwContext);

	// Get the current context ID and increment the counter
	if(this->bContextWrap)
	{
		// REVIEW!!!! -- We need to deal with the wrap case, but for
		// now just ASSERT if we hit it (it's pretty unlikely)
		ASSERT(FALSE);
		return DPERR_GENERIC;
	}
	else
	{
		*lpdwContext = this->dwContextCurrent++;
		return DP_OK;
	}
	
} // PRV_GetNewContextID



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindContextNode"
LPDPLOBBYI_CONTEXTNODE PRV_FindContextNode(LPDPLOBBYI_DPLOBJECT this,
											DWORD dwContext)
{
	LPDPLOBBYI_CONTEXTNODE	lpCN;


	DPF(7, "Entering PRV_FindContextNode");
	DPF(9, "Parameters: 0x%08x, %d", this, dwContext);

	ASSERT(this);

	// Walk the list of context nodes, looking for the right ID
	lpCN = this->ContextHead.lpNext;
	while(lpCN != &(this->ContextHead))
	{
		if(lpCN->dwContext == dwContext)
			return lpCN;
		else
			lpCN = lpCN->lpNext;
	}

	// We didn't find it
	return NULL;

} // PRV_FindContextNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetAsyncDataFromContext"
LPDPASYNCDATA PRV_GetAsyncDataFromContext(LPDPLOBBYI_DPLOBJECT this,
											DWORD dwContext)
{
	LPDPLOBBYI_CONTEXTNODE	lpCN;


	DPF(7, "Entering PRV_GetAsyncDataFromContext");
	DPF(9, "Parameters: 0x%08x, %d", this, dwContext);

	ASSERT(this);

	// Find the node and pull out the AsyncData object
	lpCN = PRV_FindContextNode(this, dwContext);
	if(lpCN)
		return lpCN->lpAD;
	else
		return NULL;

} // PRV_GetAsyncDataFromContext



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddContextNode"
HRESULT PRV_AddContextNode(LPDPLOBBYI_DPLOBJECT this, LPDPASYNCDATA lpAD,
							LPDPLOBBYI_CONTEXTNODE * lplpCN)
{
	HRESULT					hr = DP_OK;
	DWORD					dwContext;
	LPDPLOBBYI_CONTEXTNODE	lpCN = NULL;


	DPF(7, "Entering PRV_AddContextNode");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x", this, lpAD, lplpCN);

	ASSERT(this);
	ASSERT(lpAD);
	ASSERT(lplpCN);

	// Allocate memory for the new node
	lpCN = DPMEM_ALLOC(sizeof(DPLOBBYI_CONTEXTNODE));
	if(!lpCN)
	{
		DPF_ERR("Unable to allocate memory for context node");
		return DPERR_OUTOFMEMORY;
	}

	// Get a new context ID
	hr = PRV_GetNewContextID(this, &dwContext);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to get new context ID");
		return DPERR_GENERIC;
	}

	// Fill in the structure
	lpCN->dwContext = dwContext;
	lpCN->lpAD = lpAD;

	// Fill in the output parameter
	*lplpCN = lpCN;

	// Add the node to the end of the list
	this->ContextHead.lpPrev->lpNext = lpCN;
	lpCN->lpPrev = this->ContextHead.lpPrev;
	this->ContextHead.lpPrev = lpCN;
	lpCN->lpNext = &(this->ContextHead);

	return DP_OK;

} // PRV_AddContextNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteContextNode"
HRESULT PRV_DeleteContextNode(LPDPLOBBYI_DPLOBJECT this,
				LPDPLOBBYI_CONTEXTNODE lpCN)
{
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_DeleteContextNode");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpCN);

	ASSERT(this);

	// Remove the node from the list
	lpCN->lpPrev->lpNext = lpCN->lpNext;
	lpCN->lpNext->lpPrev = lpCN->lpPrev;

	// And delete the node
	DPMEM_FREE(lpCN);
	return DP_OK;

} // PRV_DeleteContextNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CleanUpContextList"
void PRV_CleanUpContextList(LPDPLOBBYI_DPLOBJECT this)
{
	LPDPLOBBYI_CONTEXTNODE	lpCN, lpCNNext;


	DPF(7, "Entering PRV_CleanUpContextList");
	DPF(9, "Parameters: 0x%08x", this);

	ASSERT(this);

	// Walk the list, cleaning up the nodes
	lpCN = this->ContextHead.lpNext;
	while(lpCN != &(this->ContextHead))
	{
		lpCNNext = lpCN->lpNext;
		PRV_DeleteContextNode(this, lpCN);
		lpCN = lpCNNext;
	}

} // PRV_CleanUpContextList



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateAndLinkAsyncDataContext"
HRESULT PRV_CreateAndLinkAsyncDataContext(LPDPLOBBYI_DPLOBJECT this,
									LPDPLOBBYI_CONTEXTNODE * lplpCN)
{
	LPDPLOBBYI_CONTEXTNODE	lpCN = NULL;
	LPDPASYNCDATA			lpAD = NULL;
	HRESULT					hr;


	DPF(7, "Entering PRV_CreateAndLinkAsyncDataContext");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lplpCN);

	ASSERT(this);
	ASSERT(lplpCN);

	// Create the AsyncData object
	hr = CreateAsyncData(&lpAD);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to create DPAsyncData object");
		return hr;
	}

	// Add a new context node and link it in
	hr = PRV_AddContextNode(this, lpAD, &lpCN);
	if(FAILED(hr))
	{
		lpAD->lpVtbl->Release(lpAD);
		return hr;
	}

	// Fill in the output vars
	*lplpCN = lpCN;

	return DP_OK;

} // PRV_CreateAndLinkAsyncDataContext



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_UnlinkAndReleaseAsyncDataContext"
void PRV_UnlinkAndReleaseAsyncDataContext(LPDPLOBBYI_DPLOBJECT this,
									LPDPLOBBYI_CONTEXTNODE lpCN)
{
	LPDPASYNCDATA			lpAD = NULL;


	DPF(7, "Entering PRV_CreateAndLinkAsyncDataContext");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpCN);

	ASSERT(this);
	ASSERT(lpCN);

	// Release the AsyncData pointer
	lpCN->lpAD->lpVtbl->Release(lpCN->lpAD);

	// Remove the context node
	PRV_DeleteContextNode(this, lpCN);

} // PRV_UnlinkAndReleaseAsyncDataContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplay\wsock\wsock2.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wsock2.c
 *  Content:	DirectPlay Winsock 2 SP support.  Called from dpsp.c.
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	7/11//97	andyco	created it
 *  2/13/98     aarono  added async support.
 *  4/6/98      aarono  mapped WSAECONNRESET to DPERR_CONNECTIONLOST
 *  6/6/98      aarono  B#27187 fix ref counting on send blocks in sync error case
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 **************************************************************************/

// this module is for async connections and sends
// only used w/ TCP:IP - IPX is dgram only, so we don't bother...
// currently only used as the reply thread proc for async replies. see dpsp.c::sp_reply

#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock 2 fn proto's, for getprocaddress
#include <winsock2.h>
#include "dpsp.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"AsyncSendThreadProc"

extern HINSTANCE hWS2; 	// dynaload the ws2_32.dll, so if it's not installed
						// (e.g. win 95 gold) we still load

// prototypes for our dynaload fn's						

LPFN_WSAWAITFORMULTIPLEEVENTS g_WSAWaitForMultipleEvents;
LPFN_WSASEND g_WSASend;
LPFN_WSASENDTO g_WSASendTo;
LPFN_WSACLOSEEVENT g_WSACloseEvent;
LPFN_WSACREATEEVENT g_WSACreateEvent;
LPFN_WSAENUMNETWORKEVENTS g_WSAEnumNetworkEvents;
LPFN_WSAEVENTSELECT g_WSAEventSelect;
LPFN_GETSOCKOPT g_getsockopt;

// attempt to load the winsock 2 dll, and get our proc addresses from it
HRESULT InitWinsock2()
{
	// load winsock library
    hWS2 = LoadLibrary("ws2_32.dll");
	if (!hWS2)
	{
		DPF(0,"Could not load ws2_32.dll\n");
		// reset our winsock 2 global
		goto LOADLIBRARYFAILED;
	}

	// get pointers to the entry points we need
	g_WSAWaitForMultipleEvents = (LPFN_WSAWAITFORMULTIPLEEVENTS)GetProcAddress(hWS2, "WSAWaitForMultipleEvents");
	if(!g_WSAWaitForMultipleEvents) goto GETPROCADDRESSFAILED;

	g_WSASend = (LPFN_WSASEND)GetProcAddress(hWS2, "WSASend");
	if (!g_WSASend) goto GETPROCADDRESSFAILED;

	g_WSASendTo = (LPFN_WSASENDTO)GetProcAddress(hWS2, "WSASendTo");
	if (!g_WSASendTo) goto GETPROCADDRESSFAILED;

    g_WSAEventSelect = ( LPFN_WSAEVENTSELECT )GetProcAddress(hWS2, "WSAEventSelect");
	if (!g_WSAEventSelect) goto GETPROCADDRESSFAILED;

	g_WSAEnumNetworkEvents = (LPFN_WSAENUMNETWORKEVENTS)GetProcAddress(hWS2, "WSAEnumNetworkEvents");
	if (!g_WSAEnumNetworkEvents) goto GETPROCADDRESSFAILED;

	g_WSACreateEvent = (LPFN_WSACREATEEVENT)GetProcAddress(hWS2, "WSACreateEvent");
	if (!g_WSACreateEvent) goto GETPROCADDRESSFAILED;

	g_WSACloseEvent = (LPFN_WSACLOSEEVENT)GetProcAddress(hWS2, "WSACloseEvent");
	if (!g_WSACloseEvent) goto GETPROCADDRESSFAILED;

	g_getsockopt = (LPFN_GETSOCKOPT)GetProcAddress(hWS2, "getsockopt");
	if (!g_getsockopt) goto GETPROCADDRESSFAILED;

	return DP_OK;	

GETPROCADDRESSFAILED:

	DPF(0,"Could not find required Winsock entry point");
	FreeLibrary(hWS2);
	hWS2 = NULL;
	// fall through
	
LOADLIBRARYFAILED:

	g_WSAEventSelect = NULL;
	g_WSAEnumNetworkEvents = NULL;
	g_WSACreateEvent = NULL;
	g_WSACloseEvent = NULL;

	return DPERR_UNAVAILABLE;
	
} // InitWinsock2

// remove the reply node from the list
void DeleteReplyNode(LPGLOBALDATA pgd,LPREPLYLIST prd, BOOL bKillSocket)
{	
	LPREPLYLIST prdPrev;
	
	ENTER_DPSP();

	// 1st, remove prd from the list
	
	// is it the root?
	if (prd == pgd->pReplyList) pgd->pReplyList = pgd->pReplyList->pNextReply;
	else
	{
		BOOL bFound = FALSE;
		
		// it's not the root - take it out of the middle
		prdPrev = pgd->pReplyList;
		while (prdPrev && !bFound)
		{
			if (prdPrev->pNextReply == prd)
			{
				prdPrev->pNextReply = prd->pNextReply;
				bFound = TRUE;
			}
			else
			{
				prdPrev = prdPrev->pNextReply;
			}
		} // while
		
		ASSERT(bFound);
		
	} // not the root

	// now clean up prd
	
	// nuke the socket
	if (bKillSocket)
		KillSocket(prd->sSocket,TRUE,FALSE);
	
	// free up the node
	if (prd->lpMessage) MemFree(prd->lpMessage);
	MemFree(prd);
	
	LEAVE_DPSP();
	
	return ;

} // DeleteReplyNode

/*
 **  AsyncConnectAndSend
 *
 *  CALLED BY: AsyncSendThreadProc
 *
 *  DESCRIPTION:
 *			
 *			if necessary, creates a non-blocking socket, and initiates a connection
 *				to address specified in prd
 *			once connection has been completed, does a synchronous (blocking) send and
 *				removes prd from the global list
 */
HRESULT AsyncConnectAndSend(LPGLOBALDATA pgd,LPREPLYLIST prd)
{
	UINT err;
	HRESULT hr;
	UINT addrlen = sizeof(SOCKADDR);	
	BOOL bConnectionExists = FALSE;
	BOOL bKillConnection = TRUE;

	if (INVALID_SOCKET == prd->sSocket)
	{
		u_long lNonBlock = 1; // passed to ioctlsocket to make socket non-blocking
		DPID dpidPlayer=0;
		
#ifdef FULLDUPLEX_SUPPORT	
		// if client wants us to reuse a connection, it would have indicated so and the connection
		// would have been added to our send list by now. See if it exists.
		
		// TODO - we don't want to search the list everytime -  find a better way
		bConnectionExists = FindSocketInBag(pgd, &prd->sockaddr, &prd->sSocket, &dpidPlayer);
#endif // FULLDUPLEX_SUPPORT

		if (!bConnectionExists)
		{
			SOCKET sSocket;	

			// socket didn't exist in our send list, let's send it on a new temporary connection
			DEBUGPRINTADDR(9,"Sending aync reply on a new connection to - ", &(prd->sockaddr));				
			
			// need to get the new socket
			hr = CreateSocket(pgd,&sSocket,SOCK_STREAM,0,INADDR_ANY,&err,FALSE);
			if (FAILED(hr))
			{
				DPF(0,"create async socket failed - err = %d\n",err);
				return hr;
			}
			
			prd->sSocket = sSocket;
			
			// set socket to non-blocking
			err = ioctlsocket(prd->sSocket,FIONBIO,&lNonBlock);
			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				DPF(0,"could not set non-blocking mode on socket err = %d!",err);
				DPF(0,"will revert to synchronous behavior.  bummer");
			}

			// now, start the connect
			SetReturnAddress(prd->lpMessage,pgd->sSystemStreamSocket);		
			err = connect(prd->sSocket,&prd->sockaddr,addrlen);
			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				if (WSAEWOULDBLOCK == err)
				{
					// this is expected. the operation needs time to complete.
					// select will tell us when the socket is good to go.
					return DP_OK;
				}
				// else it's a real error!
				DPF(0,"async reply - connect failed - error = %d\n",err);			
				DEBUGPRINTADDR(0,"async reply - connect failed - addr = ",(LPSOCKADDR)&(prd->sockaddr));
				goto CLEANUP_EXIT;
			}
		}
		else
		{
			// we found our connection, let's reuse it
			// set it to non-blocking
			
			DEBUGPRINTADDR(9,"Sending async reply on an existing connection to - ", &(prd->sockaddr));				

			err = ioctlsocket(prd->sSocket,FIONBIO,&lNonBlock);
			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				DPF(0,"could not set non-blocking mode on socket err = %d!",err);
				DPF(0,"will revert to synchronous behavior.  bummer");
			}

			// once we have a player id, the session has started. let's hold on to the connection
			// we have and reuse it for the rest of the session
			if (dpidPlayer) bKillConnection = FALSE;
			
		} // FindSocketInBag
	
	} // INVALID_SOCKET

	// once we get here, we should have a connected socket ready to send!
	err = 0;
	// keep spitting bits at the socket until we finish or get an error
	while ((prd->dwBytesLeft != 0) && (SOCKET_ERROR != err))
	{
	    err = send(prd->sSocket,prd->pbSend,prd->dwBytesLeft,0);
		if (SOCKET_ERROR != err)
		{
			// some bytes went out on the wire
			prd->dwBytesLeft -= err; // we just sent err bytes
			prd->pbSend	+= err; // advance our send buffer by err bytes		
		}
	}
	// now, we've either finished the send, or we have an error
	if (SOCKET_ERROR == err)
	{
		err = WSAGetLastError();
		if (WSAEWOULDBLOCK == err)
		{
			// this means we couldn't send any bytes w/o blocking
			// that's ok.  we'll let select tell us when it's ready to not block			
			return DP_OK; 	
		}
		// else it's a real eror!
		// any other error, we give up and clean up this reply
		DPF(0,"async send - send failed - error = %d\n",err);			
		DEBUGPRINTADDR(0,"async send - send failed - addr = ",(LPSOCKADDR)&(prd->sockaddr));
	}
	else ASSERT(0 == prd->dwBytesLeft); // if it's not an error, we better have sent it all
	
	// fall through

CLEANUP_EXIT:

	if (bConnectionExists && bKillConnection)
	{
		// close the connection after we're done
		RemoveSocketFromReceiveList(pgd,prd->sSocket);
		RemoveSocketFromBag(pgd,prd->sSocket);
		// so DeleteReplyNode won't try to kill socket again
		prd->sSocket = INVALID_SOCKET;
	}
	// remove the node from the list
	DeleteReplyNode(pgd,prd,bKillConnection);
	
	return DP_OK;

} // AsyncConnectAndSend

// walk the reply list, tell winsock to watch any of the nodes which has a valid socket
// (i.e. has a connection or send pending)
HRESULT DoEventSelect(LPGLOBALDATA pgd,WSAEVENT hSelectEvent)
{
	UINT err;
	LPREPLYLIST prd;

	ENTER_DPSP();
	
	prd = pgd->pReplyList;
	while (prd)
	{
		if (INVALID_SOCKET != prd->sSocket)
		{
			// have winscok tell us when anything good (connection complete, ready to write more data)
			// happens on this socket
			err = g_WSAEventSelect(prd->sSocket,hSelectEvent,FD_WRITE | FD_CONNECT);
			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				DPF(0,"could not do event select ! err = %d!",err);
				// keep trying...
			}
		} // invalid_socket
		
		prd = prd->pNextReply;
	}

	LEAVE_DPSP();
	
	return DP_OK;
	
} // DoEventSelect

// wsaeventselect woke us up.  one or more of our sockets had something happen
// (e.g. connect completed, send ready for more data, etc.)
// walk the reply list, find nodes who need to be serviced
void ServiceReplyList(LPGLOBALDATA pgd,WSAEVENT hEvent)
{
	UINT err;
	LPREPLYLIST prd,prdNext;
	WSANETWORKEVENTS WSANetEvents;

	ENTER_DPSP();
	
Top:	
	prd = pgd->pReplyList;
	while (prd)
	{
		// save this now - asyncconnectandsend could destroy prd
		prdNext = prd->pNextReply;
		if (INVALID_SOCKET != prd->sSocket)
		{
			// go ask winsock if this socket had anything intersting happen
			err = g_WSAEnumNetworkEvents(prd->sSocket,NULL,&WSANetEvents);

			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				DPF(0,"could not enum events!! err = %d!",err);
				// keep trying...
			}
			else
			{
				BOOL bError=FALSE;
				// no error - go see what we got
				if ((WSANetEvents.lNetworkEvents & FD_CONNECT) || (WSANetEvents.lNetworkEvents & FD_WRITE))
				{
					// was there an error?
					if (WSANetEvents.iErrorCode[FD_CONNECT_BIT])
					{
						// we got a connect error!
						DPF(0,"async reply - WSANetEvents - connect failed - error = %d\n",
							WSANetEvents.iErrorCode[FD_CONNECT_BIT]);
						DEBUGPRINTADDR(0,"async reply - connect failed - addr = ",
							(LPSOCKADDR)&(prd->sockaddr));
						RemovePendingAsyncSends(pgd, prd->dwPlayerTo);
						goto Top;
							
					}

					if (WSANetEvents.iErrorCode[FD_WRITE_BIT])
					{
						// we got a send error!
						DPF(0,"async reply - WSANetEvents - send failed - error = %d\n",
							WSANetEvents.iErrorCode[FD_WRITE_BIT]);
						DEBUGPRINTADDR(0,"async reply - send failed - addr = ",
							(LPSOCKADDR)&(prd->sockaddr));
						RemovePendingAsyncSends(pgd, prd->dwPlayerTo);
						goto Top;
					}
					// note - we try + send even if there was an error.	seems like it's worth a shot...
					// go try + send

					AsyncConnectAndSend(pgd,prd);
				}
			}
		} // invalid_socket
		else
		{
			// it it's an invalid socket, we need to init our connect and send
			AsyncConnectAndSend(pgd,prd);	
		}
		
		prd = prdNext;		
		
	}

	LEAVE_DPSP();
	
	return ;
	
} // ServiceReplyList

// this thread works on doing async sends
DWORD WINAPI AsyncSendThreadProc(LPVOID pvCast)
{
	HRESULT hr=DP_OK;
	LPGLOBALDATA pgd = (LPGLOBALDATA) pvCast;
	HANDLE hHandleList[3];
	DWORD rc;
	WSAEVENT hSelectEvent; // event used by WSASelectEvent

	DPF(9,"Entered AsyncSendThreadProc\n");


	// get the event 4 selectevent
	hSelectEvent = g_WSACreateEvent();

	if (WSA_INVALID_EVENT == hSelectEvent)
	{
		rc = WSAGetLastError();
		DPF(0,"could not create winsock event - rc = %d\n",rc);
		ExitThread(0);
		return 0;
	}
	
	hHandleList[0] = hSelectEvent;
	hHandleList[1] = pgd->hReplyEvent;
	// This extra handle is here because of a Windows 95 bug.  Windows
	// will occasionally miss when it walks the handle table, causing
	// my thread to wait on the wrong handles.  By putting a guaranteed
	// invalid handle at the end of our array, the kernel will do a
	// forced re-walk of the handle table and find the correct handles.
	hHandleList[2] = INVALID_HANDLE_VALUE;

	while (1)
	{
		// tell winsock to watch all of our reply nodes.  it will set our event
		// when something cool happens...
		DoEventSelect(pgd,hSelectEvent);

		// wait on our event.  when it's set, we either split, or empty the reply list
		rc = WaitForMultipleObjectsEx(2,hHandleList,FALSE,INFINITE,TRUE);
		if ((DWORD)-1 == rc)
		{
			DWORD dwError = GetLastError();
			// rut roh!  errror on the wait
			DPF(0,"!!!!!	error on WaitForMultipleObjects -- async reply bailing -- dwError = %d",dwError);
			goto CLEANUP_EXIT;			
			
		}
		
		if (rc == WAIT_OBJECT_0)	// a-josbor: need to reset this manual event
		{
			ResetEvent(hSelectEvent);
		}
		
		// ok.  someone woke us up.  it could be 1. shutdown,  or 2. one
		// of our sockets needs attention (i.e. a connect completed), or 3. someone
		// put a new reply node on the list
		
		// shutdown?		
		if (pgd->bShutdown)
		{
			goto CLEANUP_EXIT;
		}
		
		DPF(8,"In AsyncSendThreadProc, servicing event %d\n", rc - WAIT_OBJECT_0);

		// otherwise, it must be a socket in need or a new replynode
		ServiceReplyList(pgd,hSelectEvent);
	} // 1

CLEANUP_EXIT:
	
	ENTER_DPSP();

	// cleanout reply list
	while (pgd->pReplyList) DeleteReplyNode(pgd,pgd->pReplyList,TRUE);
	
	CloseHandle(pgd->hReplyEvent);
	pgd->hReplyEvent = 0;

	LEAVE_DPSP();

	g_WSACloseEvent(hSelectEvent);
	
	DPF(6,"replythreadproc exit");
	
	return 0;

} // AsyncSendThreadProc


HRESULT GetMaxUdpBufferSize(SOCKET socket, UINT * piMaxUdpDg)
{
	INT iBufferSize;
	INT err;

	ASSERT(piMaxUdpDg);

	iBufferSize = sizeof(UINT);
	err = g_getsockopt(socket, SOL_SOCKET, SO_MAX_MSG_SIZE, (LPBYTE)piMaxUdpDg, &iBufferSize);
	if (SOCKET_ERROR == err)
	{
		DPF(0,"getsockopt for SO_MAX_MSG_SIZE returned err = %d", WSAGetLastError());
		return DPERR_UNAVAILABLE;
	}

	return DP_OK;
}

#ifdef SENDEX

DWORD wsaoDecRef(LPSENDINFO pSendInfo)
{
	#define pgd (pSendInfo->pgd)
	
	DWORD count;
#ifdef DEBUG
		EnterCriticalSection(&pgd->csSendEx);
		count=(--pSendInfo->RefCount);
		LeaveCriticalSection(&pgd->csSendEx);
#else
	count=InterlockedDecrement(&pSendInfo->RefCount);
#endif

	if(!count){
	
		EnterCriticalSection(&pgd->csSendEx);
		
			Delete(&pSendInfo->PendingSendQ);
			pgd->dwBytesPending -= pSendInfo->dwMessageSize;
			pgd->dwMessagesPending -= 1;
		
		LeaveCriticalSection(&pgd->csSendEx);

		DPF(9,"RefCount 0 pSendInfo %x , SC context %x, status=%x \n",pSendInfo, pSendInfo->dwUserContext,pSendInfo->Status);

		if(pSendInfo->dwSendFlags & DPSEND_ASYNC){
			pSendInfo->lpISP->lpVtbl->SendComplete(pSendInfo->lpISP,(LPVOID)pSendInfo->dwUserContext,pSendInfo->Status);
		}	
		
		pgd->pSendInfoPool->Release(pgd->pSendInfoPool, pSendInfo);
	} else {
		DPF(9,"wsaoDecRef pSendInfo %x, Refcount= %d\n",pSendInfo,pSendInfo->RefCount);
	}

	if(count& 0x80000000){
		DEBUG_BREAK();
	}
	
	return count;
	
	#undef pgd
}


void CALLBACK SendComplete(
  DWORD dwError,
  DWORD cbTransferred,
  LPWSAOVERLAPPED lpOverlapped,
  DWORD dwFlags
)
{
	LPSENDINFO lpSendInfo=(LPSENDINFO)CONTAINING_RECORD(lpOverlapped,SENDINFO,wsao);

	DPF(9,"DPWSOCK:SendComplete, lpSendInfo %x\n",lpSendInfo);

	if(dwError){
		DPF(0,"DPWSOCK: send completion error, dwError=x%x\n",dwError);
		lpSendInfo->Status=DPERR_GENERIC;
	}

	wsaoDecRef(lpSendInfo);
}

HRESULT DoSend(LPGLOBALDATA pgd, LPSENDINFO pSendInfo)
{
	#define fAsync (pSendInfo->dwSendFlags & DPSEND_ASYNC)
	
	DWORD dwBytesSent;
	UINT err;
	HRESULT hr;
	
	if(pSendInfo->dwFlags & SI_RELIABLE){
	
		// Reliable Send
		DPF(9,"WSASend, pSendInfo %x\n",pSendInfo);

		// send the message
		err = g_WSASend(pSendInfo->sSocket,
					  (LPWSABUF)&pSendInfo->SendArray[pSendInfo->iFirstBuf],
					  pSendInfo->cBuffers,
					  &dwBytesSent,
				  	  0,				/*flags*/
				  	  (fAsync)?(&pSendInfo->wsao):NULL,
				  	  (fAsync)?(SendComplete):NULL);

		if(!err){
				DPF(9,"WSASend, sent synchronously, pSendInfo %x\n",pSendInfo);
				wsaoDecRef(pSendInfo);
				hr=DP_OK;
		} else {

			if (SOCKET_ERROR == err)
			{
			
				err = WSAGetLastError();

				if(err==WSA_IO_PENDING){
					hr=DPERR_PENDING;
					wsaoDecRef(pSendInfo);
					DPF(9,"ASYNC SEND Pending pSendInfo %x\n",pSendInfo);
				} else {
					if(err==WSAECONNRESET){
						hr=DPERR_CONNECTIONLOST;
					} else {
						hr=DPERR_GENERIC;
					}	
					if(fAsync){
						// Got an error, need to dump 2 refs.
						pSendInfo->RefCount=1;
						pSendInfo->Status=hr;
					}	
					wsaoDecRef(pSendInfo);
					// we got a socket from the bag.  send failed,
					// so we're cruising it from the bag
					DPF(0,"send error - err = %d\n",err);
						DPF(4,"send failed - removing socket from bag");
						RemovePlayerFromSocketBag(pgd,pSendInfo->idTo);
				}	
			
			}
		}	
	
	} else {
	
		// Datagram Send
		DEBUGPRINTADDR(5,"unreliable send - sending to ",&pSendInfo->sockaddr);	
		// send the message
		err = g_WSASendTo(pSendInfo->sSocket,
						  (LPWSABUF)&pSendInfo->SendArray[pSendInfo->iFirstBuf],
						  pSendInfo->cBuffers,
						  &dwBytesSent,
						  0,				/*flags*/
						  (LPSOCKADDR)&pSendInfo->sockaddr,
					      sizeof(SOCKADDR),
					  	  (fAsync)?(&pSendInfo->wsao):NULL,
					  	  (fAsync)?(SendComplete):NULL);


		if(!err){
			hr=DP_OK;
			wsaoDecRef(pSendInfo);
		} else {
		    if (SOCKET_ERROR == err)
		    {
		        err = WSAGetLastError();
		
		        if(err==WSA_IO_PENDING){
		        	hr=DPERR_PENDING;
					wsaoDecRef(pSendInfo);
				} else {
					hr=DPERR_GENERIC;
					if(fAsync){
						// some error, force completion.
						pSendInfo->RefCount=1;
						pSendInfo->Status=DPERR_GENERIC;
					}	
					wsaoDecRef(pSendInfo);
			        DPF(0,"send error - err = %d\n",err);
		        }
		    } else {
		    	DEBUG_BREAK();// SHOULD NEVER HAPPEN
		    }

		}
		
	}
	return hr;
	
	#undef fAsync
}

// Alert thread provides a thread for send completions to run on.

DWORD WINAPI SPSendThread(LPVOID lpv)
{
	LPGLOBALDATA pgd=(LPGLOBALDATA) lpv;
	LPSENDINFO  pSendInfo;

	DWORD rcWait=WAIT_IO_COMPLETION;
	BILINK *pBilink;
	BOOL bSent;

	pgd->BogusHandle=INVALID_HANDLE_VALUE;	// workaround win95 wait for multiple bug.
	
	while(!pgd->bStopSendThread){
		rcWait=g_WSAWaitForMultipleEvents(1,&pgd->hSendWait,FALSE,INFINITE,TRUE);
		#ifdef DEBUG
		if(rcWait==WAIT_IO_COMPLETION){
			DPF(9,"ooooh, IO completion\n");
		}
		#endif

		do {
			bSent = FALSE;
		
			EnterCriticalSection(&pgd->csSendEx);

			pBilink=pgd->ReadyToSendQ.next;

			if(pBilink != &pgd->ReadyToSendQ){
				Delete(pBilink);
				LeaveCriticalSection(&pgd->csSendEx);
				pSendInfo=CONTAINING_RECORD(pBilink, SENDINFO, ReadyToSendQ);
				DoSend(pgd, pSendInfo);
				bSent=TRUE;
			} else {
				LeaveCriticalSection(&pgd->csSendEx);
			}	
		} while (bSent);
	}	

	pgd->bSendThreadRunning=FALSE;
	
	return FALSE;
	
	#undef hWait
}




void QueueForSend(LPGLOBALDATA pgd,LPSENDINFO pSendInfo)
{
	EnterCriticalSection(&pgd->csSendEx);
		InsertBefore(&pSendInfo->ReadyToSendQ,&pgd->ReadyToSendQ);
	LeaveCriticalSection(&pgd->csSendEx);
	
	SetEvent(pgd->hSendWait);
}

// some common code for InternalReliableSendEx and UnreliableSendEx
VOID CommonInitForSend(LPGLOBALDATA pgd,LPDPSP_SENDEXDATA psd,LPSENDINFO pSendInfo)
{

	pSendInfo->dwMessageSize= psd->dwMessageSize;
	pSendInfo->dwUserContext= (DWORD_PTR)psd->lpDPContext;
	pSendInfo->RefCount     = 2;		// one for completion, 1 for this routine
	pSendInfo->pgd          = pgd;
	pSendInfo->lpISP        = psd->lpISP;
	pSendInfo->Status       = DP_OK;
	pSendInfo->idTo         = psd->idPlayerTo;
	pSendInfo->idFrom       = psd->idPlayerFrom;
	pSendInfo->dwSendFlags  = psd->dwFlags;
	
	if(psd->lpdwSPMsgID){
		*psd->lpdwSPMsgID=0;
	}	

	EnterCriticalSection(&pgd->csSendEx);
	
		InsertBefore(&pSendInfo->PendingSendQ,&pgd->PendingSendQ);
		pgd->dwBytesPending += psd->dwMessageSize;
		pgd->dwMessagesPending += 1;
		
	LeaveCriticalSection(&pgd->csSendEx);
}

VOID UnpendSendInfo(LPGLOBALDATA pgd, LPSENDINFO pSendInfo)
{
	EnterCriticalSection(&pgd->csSendEx);
	Delete(&pSendInfo->PendingSendQ);
	pgd->dwBytesPending -= pSendInfo->dwMessageSize;
	pgd->dwMessagesPending -= 1;
	LeaveCriticalSection(&pgd->csSendEx);
}

HRESULT InternalReliableSendEx(LPGLOBALDATA pgd, LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo, SOCKADDR *lpSockAddr)
{
	HRESULT hr;
	SOCKET sSocket = INVALID_SOCKET;
	BOOL fCreate=FALSE;

	// see if we have a connection already
	hr = GetSocketFromBag(pgd,&sSocket,psd->idPlayerTo,lpSockAddr);		

	if(hr != DP_OK){
		hr=DPERR_GENERIC;
		return hr;
	}
	
	CommonInitForSend(pgd,psd,pSendInfo); // puts 2 refs on send.
	pSendInfo->dwFlags      = SI_RELIABLE;
	pSendInfo->sSocket      = sSocket;
	pSendInfo->iFirstBuf	= 0;
	pSendInfo->cBuffers 	= psd->cBuffers+1;

	if(psd->dwFlags & DPSEND_ASYNC){
		QueueForSend(pgd,pSendInfo);
		hr=DPERR_PENDING;
	} else {
		hr=DoSend(pgd,pSendInfo);
		if(hr==DP_OK || hr==DPERR_PENDING){
			wsaoDecRef(pSendInfo);
		} else {
			// error,
			UnpendSendInfo(pgd, pSendInfo);
		}
	}

	return hr;
}

HRESULT UnreliableSendEx(LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo)
{
    SOCKADDR sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr=DP_OK;
    UINT err;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;

	BOOL bSendHeader;
	
	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (pgd->iMaxUdpDg && (psd->dwMessageSize >= pgd->iMaxUdpDg))
	{
		return DPERR_SENDTOOBIG;
	}

	if (INVALID_SOCKET == pgd->sUnreliableSocket)
	{
	    hr = CreateSocket(pgd,&(pgd->sUnreliableSocket),SOCK_DGRAM,0,INADDR_ANY,&err,FALSE);
	    if (FAILED(hr))
	    {
	        DPF(0,"create unreliable send socket failed - err = %d\n",err);
	        return hr;
	    }
	}

	// get to address	
    if (0 == psd->idPlayerTo)
    {
		sockaddr = pgd->saddrNS;
    }
    else
    {
		hr = psd->lpISP->lpVtbl->GetSPPlayerData(psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize,DPGET_REMOTE);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			return hr;
		}

		sockaddr = *(DGRAM_PSOCKADDR(ppdTo));
    }

	// put the token + size on front of the mesage
	SetMessageHeader((LPVOID)(pSendInfo->SendArray[0].buf),psd->dwMessageSize+sizeof(MESSAGEHEADER),TOKEN);
   	bSendHeader=TRUE;
   	
	if (psd->bSystemMessage)
    {
		SetReturnAddress(pSendInfo->SendArray[0].buf,SERVICE_SOCKET(pgd));
    } // reply
	else
	{
		// see if we can send this message w/ no header
		// if the message is smaller than a dword, or, if it's a valid sp header (fooling us
		// on the other end, don't send any header
		if ( !((psd->dwMessageSize >= sizeof(DWORD)) &&  !(VALID_SP_MESSAGE(pSendInfo->SendArray[0].buf))) )
		{
			bSendHeader=FALSE;
		}
	}

    CommonInitForSend(pgd,psd,pSendInfo);
	pSendInfo->dwFlags      = SI_DATAGRAM;
	pSendInfo->sSocket      = pgd->sUnreliableSocket;
	pSendInfo->sockaddr     = sockaddr;

	if(bSendHeader){
		pSendInfo->iFirstBuf=0;
		pSendInfo->cBuffers =psd->cBuffers+1;
	} else {
		pSendInfo->iFirstBuf=1;
		pSendInfo->cBuffers=psd->cBuffers;
	}

	if(psd->dwFlags & DPSEND_ASYNC){
		QueueForSend(pgd,pSendInfo);
		hr=DPERR_PENDING;
	} else {
		hr=DoSend(pgd,pSendInfo);
		if(hr==DP_OK || hr==DPERR_PENDING){
			wsaoDecRef(pSendInfo);
		} else {
			UnpendSendInfo(pgd, pSendInfo);
		}
	}
	
	return hr;

} // UnreliableSendEx

#endif //SendEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\dplgame.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplgame.c
 *  Content:	Methods for game management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	4/13/96		myronth	Created it
 *	6/24/96		kipo	changed guidGame to guidApplication.
 *	10/23/96	myronth	added client/server methods
 *	12/12/96	myronth	Fixed DPLCONNECTION validation
 *	2/12/97		myronth	Mass DX5 changes
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	4/3/97		myronth	#ifdef'd out DPLC_StartGame (Nov. spec related)
 *	5/8/97		myronth	Purged dead code
 *	5/22/97		myronth Changed error code processing of RunApplication which
 *						was calling the wrong cleanup function (#8871)
 *	6/4/97		myronth	Fixed handle leak (#9458)
 *	6/19/97		myronth	Fixed handle leak (#10063)
 *	7/30/97		myronth	Added support for standard lobby messaging and fixed
 *						additional backslash on current directory bug (#10592)
 *	1/20/98		myronth	Added WaitForConnectionSettings
 *	1/26/98		myronth	Added OS_CompareString function for Win95
 *	7/07/98		kipo	Define and use PROCESSENTRY32A to avoid passing
 *						Unicode data structures to Win95 functions expecting ANSI
 *  7/09/99     aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *
 ***************************************************************************/
#include "dplobpr.h"
#include <tchar.h>
#include <tlhelp32.h>
#include <winperf.h>

//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindGameInRegistry"
BOOL PRV_FindGameInRegistry(LPGUID lpguid, LPWSTR lpwszAppName,
							DWORD dwNameSize, HKEY * lphkey)
{
	HKEY	hkeyDPApps, hkeyApp;
	DWORD	dwIndex = 0;
	WCHAR	wszGuidStr[GUID_STRING_SIZE];
	DWORD	dwGuidStrSize = GUID_STRING_SIZE;
	DWORD	dwType = REG_SZ;
	GUID	guidApp;
	LONG	lReturn;
	BOOL	bFound = FALSE;
	DWORD	dwSaveNameSize = dwNameSize;


	DPF(7, "Entering PRV_FindGameInRegistry");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			lpguid, lpwszAppName, dwNameSize, lphkey);

 	// Open the Applications key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY, 0,
								KEY_READ, &hkeyDPApps);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("Unable to open DPlay Applications registry key!");
		return FALSE;
	}

	// Walk the list of DPlay games in the registry, looking for
	// the app with the right GUID
	while(!bFound)
	{
		// Open the next application key
		dwSaveNameSize = dwNameSize;
		dwGuidStrSize = GUID_STRING_SIZE;
		lReturn = OS_RegEnumKeyEx(hkeyDPApps, dwIndex++, lpwszAppName,
						&dwSaveNameSize, NULL, NULL, NULL, NULL);

		// If the enum returns no more apps, we want to bail
		if(lReturn != ERROR_SUCCESS)
			break;
		
		// Open the application key		
		lReturn = OS_RegOpenKeyEx(hkeyDPApps, lpwszAppName, 0,
									KEY_READ, &hkeyApp);
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERR("Unable to open app key!");
			continue;
		}

		// Get the GUID of the Game
		lReturn = OS_RegQueryValueEx(hkeyApp, SZ_GUID, NULL, &dwType,
									(LPBYTE)&wszGuidStr, &dwGuidStrSize);
		if(lReturn != ERROR_SUCCESS)
		{
			RegCloseKey(hkeyApp);
			DPF_ERR("Unable to query GUID key value!");
			continue;
		}

		// Convert the string to a real GUID & Compare it to the passed in one
		GUIDFromString(wszGuidStr, &guidApp);
		if(IsEqualGUID(&guidApp, lpguid))
		{
			bFound = TRUE;
			break;
		}

		// Close the App key
		RegCloseKey(hkeyApp);
	}

	// Close the DPApps key
	RegCloseKey(hkeyDPApps);

	if(bFound)
		*lphkey = hkeyApp;

	return bFound;


} // PRV_FindGameInRegistry



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetKeyStringValue"
BOOL PRV_GetKeyStringValue(HKEY hkeyApp, LPWSTR lpwszKey, LPWSTR * lplpwszValue)
{
	DWORD	dwType = REG_SZ;
	DWORD	dwSize;
	LPWSTR	lpwszTemp = NULL;
	LONG	lReturn;


	DPF(7, "Entering PRV_GetKeyStringValue");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			hkeyApp, lpwszKey, lplpwszValue);

	ASSERT(lplpwszValue);

	// Get the size of the buffer for the Path
	lReturn = OS_RegQueryValueEx(hkeyApp, lpwszKey, NULL, &dwType,
								NULL, &dwSize);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("Error getting size of key value!");
		return FALSE;
	}

	// If the size is 2, then it is an empty string (only contains a
	// null terminator).  Treat this the same as a NULL string or a
	// missing key and fail it.
	if(dwSize <= 2)
		return FALSE;

	// Alloc the buffer for the Path
	lpwszTemp = DPMEM_ALLOC(dwSize);
	if(!lpwszTemp)
	{
		DPF_ERR("Unable to allocate temporary string for Path!");
		return FALSE;
	}

	// Get the value itself
	lReturn = OS_RegQueryValueEx(hkeyApp, lpwszKey, NULL, &dwType,
							(LPBYTE)lpwszTemp, &dwSize);
	if(lReturn != ERROR_SUCCESS)
	{
		DPMEM_FREE(lpwszTemp);
		DPF_ERR("Unable to get key value!");
		return FALSE;
	}

	*lplpwszValue = lpwszTemp;
	return TRUE;

} // PRV_GetKeyStringValue



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeConnectInfo"
BOOL PRV_FreeConnectInfo(LPCONNECTINFO lpci)
{
	DPF(7, "Entering PRV_FreeConnectInfo");
	DPF(9, "Parameters: 0x%08x", lpci);

	if(!lpci)
		return TRUE;

	if(lpci->lpszName)
		DPMEM_FREE(lpci->lpszName);
	if(lpci->lpszPath)
		DPMEM_FREE(lpci->lpszPath);
	if(lpci->lpszFile)
		DPMEM_FREE(lpci->lpszFile);
	if(lpci->lpszCommandLine)
		DPMEM_FREE(lpci->lpszCommandLine);
	if(lpci->lpszCurrentDir)
		DPMEM_FREE(lpci->lpszCurrentDir);
	if(lpci->lpszAppLauncherName)
		DPMEM_FREE(lpci->lpszAppLauncherName);


	return TRUE;

} // PRV_FreeConnectInfo



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetConnectInfoFromRegistry"
BOOL PRV_GetConnectInfoFromRegistry(LPCONNECTINFO lpci)
{
	LPWSTR	lpwszAppName;
	HKEY	hkeyApp = NULL;
	LPWSTR	lpwszTemp;
	DWORD	dwSize = 0;
	DWORD	dwError;
	GUID	guidApp;
	BOOL	bReturn;


	DPF(7, "Entering PRV_GetConnectInfoFromRegistry");
	DPF(9, "Parameters: 0x%08x", lpci);

	// Clear our ConnectInfo structure since we will be overwriting
	// whatever is in it, and we are making assumptions that the
	// string pointers are NULL to start with.  However, we need
	// the Application guid, so save it off
	guidApp = lpci->guidApplication;
	memset(lpci, 0, sizeof(CONNECTINFO));
	lpci->guidApplication = guidApp;

	// Allocate memory for the App Name
	lpwszAppName = DPMEM_ALLOC(DPLOBBY_REGISTRY_NAMELEN);
	if(!lpwszAppName)
	{
		DPF_ERR("Unable to allocate memory for App Name!");
		return FALSE;
	}
	
	
	// Open the registry key for the App
	if(!PRV_FindGameInRegistry(&(lpci->guidApplication), lpwszAppName,
								DPLOBBY_REGISTRY_NAMELEN, &hkeyApp))
	{
		DPMEM_FREE(lpwszAppName);
		DPF_ERR("Unable to find game in registry!");
		return FALSE;
	}

	lpci->lpszName = lpwszAppName;

	// Get the string value for the Path.  If this fails, we
	// can use a NULL path, which represents the default path
	// on the CreateProcess call
	if(PRV_GetKeyStringValue(hkeyApp, SZ_PATH, &lpwszTemp))
	{
		lpci->lpszPath = lpwszTemp;
	}
		
	// Get the string value for the File
	if(!PRV_GetKeyStringValue(hkeyApp, SZ_FILE, &lpwszTemp))
	{
		DPF_ERR("Error getting value for File key!");
		bReturn = FALSE;
		goto EXIT_GETCONNECTINFO;
	}
	
	lpci->lpszFile = lpwszTemp;

	// Get the string value for the CommandLine.  If this fails,
	// we can pass a NULL command line to the CreateProcess call
	if(PRV_GetKeyStringValue(hkeyApp, SZ_COMMANDLINE, &lpwszTemp))
	{
		lpci->lpszCommandLine = lpwszTemp;
	}
	
	// Get the string value for the AppLauncherName.  If this fails,
	// then we assume there is no launcher application.
	if(PRV_GetKeyStringValue(hkeyApp, SZ_LAUNCHER, &lpwszTemp))
	{
		lpci->lpszAppLauncherName = lpwszTemp;
	}

	// Get the string value for the CurrentDir.  If this fails, just
	// use the value returned by GetCurrentDirectory.
	if(!PRV_GetKeyStringValue(hkeyApp, SZ_CURRENTDIR, &lpwszTemp))
	{
		// Get the size of the string
		dwSize = OS_GetCurrentDirectory(0, NULL);
		if(!dwSize)
		{
			dwError = GetLastError();
			// WARNING: this last error value may not be correct in debug
			// since OS_GetCurrentDirectory may have called another function.
			DPF(0, "GetCurrentDirectory returned an error! dwError = %d", dwError);
			bReturn = FALSE;
			goto EXIT_GETCONNECTINFO;
		}

		lpwszTemp = DPMEM_ALLOC(dwSize * sizeof(WCHAR));
		if(!lpwszTemp)
		{
			DPF_ERR("Unable to allocate temporary string for CurrentDirectory!");
			bReturn = FALSE;
			goto EXIT_GETCONNECTINFO;
		}

		if(!OS_GetCurrentDirectory(dwSize, lpwszTemp))
		{
			DPF_ERR("Unable to get CurrentDirectory!");
			bReturn = FALSE;
			goto EXIT_GETCONNECTINFO;
		}
	}
	
	lpci->lpszCurrentDir = lpwszTemp;

	bReturn = TRUE;

EXIT_GETCONNECTINFO:

	// Free any string we allocated if we failed
	if(!bReturn)
		PRV_FreeConnectInfo(lpci);

	// Close the Apps key
	if(hkeyApp)
		RegCloseKey(hkeyApp);

	return bReturn;

} // PRV_GetConnectInfoFromRegistry



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateGameProcess"
HRESULT PRV_CreateGameProcess(LPCONNECTINFO lpci, LPPROCESS_INFORMATION lppi)
{
	STARTUPINFO			si;
	HRESULT				hr;
	LPWSTR				lpwszPathAndFile = NULL;
	LPWSTR				lpwszTemp = NULL;
	LPWSTR				lpwszCommandLine = NULL;
	LPWSTR              lpwszFileToRun;
	DWORD				dwPathSize,
						dwFileSize,
						dwCurrentDirSize,
						dwPathAndFileSize,
						dwCommandLineSize,
						dwIPCSwitchSize,
						dwError;
	

	DPF(7, "Entering PRV_CreateGameProcess");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpci, lppi);
	

	// Allocate enough memory for the Path, File, an additional backslash,
	// and the null termination
	// Note: the following two OS_StrLen calls with count the null terms
	// on the end of each string.  Since this comes to two characters
	// (4 bytes), this will account for our null terminator and the
	// possible additional backslash after concatenation.  Thus, the
	// size here is big enough for the concatenated string.
	dwPathSize = OS_StrLen(lpci->lpszPath);

	if(lpci->lpszAppLauncherName){
		// when launching with an applauncher, we need a GUID.
		OS_CreateGuid(&lpci->guidIPC);
		lpwszFileToRun = lpci->lpszAppLauncherName;
	} else {
		lpwszFileToRun = lpci->lpszFile;
	}	
		
	dwFileSize = OS_StrLen(lpwszFileToRun);
		
	dwPathAndFileSize = dwPathSize + dwFileSize;
	lpwszPathAndFile = DPMEM_ALLOC(dwPathAndFileSize * sizeof(WCHAR));
	if(!lpwszPathAndFile)
	{
		DPF_ERR("Couldn't allocate memory for temporary string!");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_CREATE_GAME_PROCESS;
	}
	

	// Concatenate the path & file together
	if(dwPathSize)
	{
		memcpy(lpwszPathAndFile, lpci->lpszPath, (dwPathSize  * sizeof(WCHAR)));
		lpwszTemp = lpwszPathAndFile + dwPathSize - 1;

		// Only add a backslash if one doesn't already exists
		if(memcmp((lpwszTemp - 1), SZ_BACKSLASH, sizeof(WCHAR)))
			memcpy(lpwszTemp++, SZ_BACKSLASH, sizeof(WCHAR));
		else 
			// since we didn't add a backslash, the actual used
			// size is one WCHAR less than the full allocated size so
			// we need to reduce it so when we calculate the spot for
			// the command line we aren't after a NULL.
			dwPathAndFileSize--;
	}
	else
		lpwszTemp = lpwszPathAndFile;

	memcpy(lpwszTemp, lpwszFileToRun, (dwFileSize * sizeof(WCHAR)));


	// Allocate memory for temporary command line string
	// Note: Since the OS_StrLen function counts the null terminator,
	// we will be large enough to include the extra space when we
	// concatenate the two strings together.
	dwCommandLineSize = OS_StrLen(lpci->lpszCommandLine);

	if(lpci->lpszAppLauncherName){
		// leave space for GUID on the command line
		dwIPCSwitchSize = sizeof(SZ_DP_IPC_GUID SZ_GUID_PROTOTYPE)/sizeof(WCHAR);
	} else {
		dwIPCSwitchSize = 0;
	}
	
	lpwszCommandLine = DPMEM_ALLOC(((dwCommandLineSize + dwPathAndFileSize+dwIPCSwitchSize) *
								sizeof(WCHAR)));
	if(!lpwszCommandLine)
	{
		// REVIEW!!!! -- We should fix these error paths post-DX3
		DPF_ERR("Couldn't allocate memory for temporary command line string!");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_CREATE_GAME_PROCESS;
	}

	// Concatenate the path & file string with the rest of the command line
	memcpy(lpwszCommandLine, lpwszPathAndFile, (dwPathAndFileSize *
			sizeof(WCHAR)));

	// Add the rest of the command line if it exists
	lpwszTemp = lpwszCommandLine + dwPathAndFileSize;
	if(dwCommandLineSize)
	{
		// First change the null terminator to a space
		lpwszTemp -= 1; 
		memcpy(lpwszTemp++, SZ_SPACE, sizeof(WCHAR));

		// Now copy in the command line
		memcpy(lpwszTemp, lpci->lpszCommandLine, (dwCommandLineSize *
				sizeof(WCHAR)));

	}
	
	if(dwIPCSwitchSize){
		// add switch with a GUID on the command line for IPC when
		// application is started by a launcher
		lpwszTemp += dwCommandLineSize-1;
		// change NULL terminator to a space
		memcpy(lpwszTemp++, SZ_SPACE, sizeof(WCHAR));
		// copy /dplay_ipc_guid: but skip the NULL
		memcpy(lpwszTemp, SZ_DP_IPC_GUID, sizeof(SZ_DP_IPC_GUID)-sizeof(WCHAR));
		lpwszTemp+=(sizeof(SZ_DP_IPC_GUID)-sizeof(WCHAR))/sizeof(WCHAR);
		// Copy the GUID directly into the target
		StringFromGUID(&lpci->guidIPC,lpwszTemp,GUID_STRING_SIZE);
	}

	// Make sure the CurrentDirectory string doesn't have a trailing backslash
	// (This will cause CreateProcess to not use the right directory)
	dwCurrentDirSize = OS_StrLen(lpci->lpszCurrentDir);
	if(dwCurrentDirSize > 2)
	{
		lpwszTemp = lpci->lpszCurrentDir + dwCurrentDirSize - 2;

		if(!(memcmp((lpwszTemp), SZ_BACKSLASH, sizeof(WCHAR))))
			memset(lpwszTemp, 0, sizeof(WCHAR));
	}

	// Create the game's process in a suspended state
	memset(&si, 0, sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);

	if(!OS_CreateProcess(lpwszPathAndFile, lpwszCommandLine, NULL,
			NULL, FALSE, (CREATE_SUSPENDED | CREATE_DEFAULT_ERROR_MODE |
			CREATE_NEW_CONSOLE), NULL, lpci->lpszCurrentDir, &si, lppi))
	{
		dwError = GetLastError();
		// WARNING Last error produced here may not be correct since OS_CreateProcess 
		// may call out to other functions (like DPF) before returning.
		DPF_ERR("Couldn't create game process");
		DPF(0, "CreateProcess error = 0x%08x, (WARNING Error may not be correct)", dwError);
		hr = DPERR_CANTCREATEPROCESS;
		goto ERROR_CREATE_GAME_PROCESS;
	} 

	hr = DP_OK;

	// Fall through

ERROR_CREATE_GAME_PROCESS:

	if(lpwszPathAndFile)
		DPMEM_FREE(lpwszPathAndFile);
	if(lpwszCommandLine)
		DPMEM_FREE(lpwszCommandLine);
	return hr;

} // PRV_CreateGameProcess



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_IsAppInWaitMode"
BOOL PRV_IsAppInWaitMode(DWORD dwProcessID)
{
	DPLOBBYI_GAMENODE		gn;
	LPDPLOBBYI_CONNCONTROL	lpConnControl = NULL;
	SECURITY_ATTRIBUTES		sa;
	WCHAR					szName[MAX_MMFILENAME_LENGTH * sizeof(WCHAR)];
	HRESULT					hr;
	HANDLE					hFile = NULL;
	HANDLE					hMutex = NULL;
	BOOL					bReturn = FALSE;
	DWORD					dwError;


	DPF(7, "Entering PRV_IsAppInWaitMode");
	DPF(9, "Parameters: %lu", dwProcessID);

	// Setup a temporary gamenode structure
	memset(&gn, 0, sizeof(DPLOBBYI_GAMENODE));
	gn.dwFlags = GN_LOBBY_CLIENT;
	gn.dwGameProcessID = dwProcessID;
	
	// Get the name of the shared connection settings buffer
	hr = PRV_GetInternalName(&gn, TYPE_CONNECT_DATA_FILE, (LPWSTR)szName);
	if(FAILED(hr))
	{
		DPF(5, "Unable to get name for shared conn settings buffer");
		goto EXIT_ISAPPINWAITMODE;
	}

	// Map the file into our process
	hFile = OS_OpenFileMapping(FILE_MAP_ALL_ACCESS, TRUE, (LPWSTR)szName);
	if(!hFile)
	{
		dwError = GetLastError();
		// WARNING: Error may not be correct since OpenFileMapping calls out to other functions before returning.
		DPF(5, "Couldn't get a handle to the shared local memory, dwError = %lu (ERROR MAY NOT BE CORRECT)", dwError);
		goto EXIT_ISAPPINWAITMODE;
	}

	// Map a View of the file
	lpConnControl = MapViewOfFile(hFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);
	if(!lpConnControl)
	{
		dwError = GetLastError();
		DPF(5, "Unable to get pointer to shared local memory, dwError = %lu", dwError);
		goto EXIT_ISAPPINWAITMODE;
	}

	// Get the name of the connection settings buffer mutex	
	hr = PRV_GetInternalName(&gn, TYPE_CONNECT_DATA_MUTEX, (LPWSTR)szName);
	if(FAILED(hr))
	{
		DPF(5, "Unable to get name for shared conn settings buffer mutex");
		goto EXIT_ISAPPINWAITMODE;
	}

	// Set up the security attributes (so that our objects can
	// be inheritable)
	memset(&sa, 0, sizeof(SECURITY_ATTRIBUTES));
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.bInheritHandle = TRUE;

	// Open the Mutex
	hMutex = OS_CreateMutex(&sa, FALSE, (LPWSTR)&szName);
	if(!hMutex)
	{
		DPF(5, "Unable to create shared conn settings buffer mutex");
		goto EXIT_ISAPPINWAITMODE;
	}

	// Now grab the mutex and see if the app is in wait mode (and
	// it is not in pending mode)
	WaitForSingleObject(hMutex, INFINITE);
	if((lpConnControl->dwFlags & BC_WAIT_MODE) &&
		!(lpConnControl->dwFlags & BC_PENDING_CONNECT))
	{
		// Put the app in pending mode
		lpConnControl->dwFlags |= BC_PENDING_CONNECT;

		// Set the return code to true
		bReturn = TRUE;
	}

	// Release the mutex
	ReleaseMutex(hMutex);

	// Fall through

EXIT_ISAPPINWAITMODE:

	if(lpConnControl)
		UnmapViewOfFile(lpConnControl);
	if(hFile)
		CloseHandle(hFile);
	if(hMutex)
		CloseHandle(hMutex);

	return bReturn;

} // PRV_IsAppInWaitMode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindRunningAppNT"

#define INITIAL_SIZE        51200
#define EXTEND_SIZE         25600
#define REGKEY_PERF         _T("software\\microsoft\\windows nt\\currentversion\\perflib")
#define REGSUBKEY_COUNTERS  _T("Counters")
#define PROCESS_COUNTER     _T("process")
#define PROCESSID_COUNTER   _T("id process")


HRESULT PRV_FindRunningAppNT(LPCONNECTINFO lpci, LPPROCESS_INFORMATION lppi)
{
	HANDLE		hProcess = NULL;
	DWORD		dwProcessID = 0;
	DWORD		dwError;
	HRESULT		hr = -1;

    DWORD                        rc;
    HKEY                         hKeyNames;
    DWORD                        dwType;
    DWORD                        dwSize;
    LPBYTE                       buf = NULL;
    TCHAR                         szSubKey[1024];
    LANGID                       lid;
    LPTSTR                        p;
    LPTSTR                        p2;
	LPWSTR						nameStr;
    PPERF_DATA_BLOCK             pPerf;
    PPERF_OBJECT_TYPE            pObj;
    PPERF_INSTANCE_DEFINITION    pInst;
    PPERF_COUNTER_BLOCK          pCounter;
    PPERF_COUNTER_DEFINITION     pCounterDef;
    DWORD                        i;
    DWORD                        dwProcessIdTitle;
    DWORD                        dwProcessIdCounter;
    DWORD						dwNumTasks;
    WCHAR						fileString[256];


	INT							ccStrFind;
	INT							ccStrMatch;


    //
    // Look for the list of counters.  Always use the neutral
    // English version, regardless of the local language.  We
    // are looking for some particular keys, and we are always
    // going to do our looking in English.  We are not going
    // to show the user the counter names, so there is no need
    // to go find the corresponding name in the local language.
    //
    lid = MAKELANGID( LANG_ENGLISH, SUBLANG_NEUTRAL );
    wsprintf( szSubKey, _T("%s\\%03x"), REGKEY_PERF, lid );
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       szSubKey,
                       0,
                       KEY_READ,
                       &hKeyNames
                     );
    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // get the buffer size for the counter names
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          NULL,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // allocate the counter names buffer
    //
    buf = (LPBYTE) DPMEM_ALLOC( dwSize );
    if (buf == NULL) {
        goto exit;
    }
    memset( buf, 0, dwSize );

    //
    // read the counter names from the registry
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          buf,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // now loop thru the counter names looking for the following counters:
    //
    //      1.  "Process"           process name
    //      2.  "ID Process"        process id
    //
    // the buffer contains multiple null terminated strings and then
    // finally null terminated at the end.  the strings are in pairs of
    // counter number and counter name.
    //

	// convert the string to ansi because we can't use _wtoi

    p = (LPTSTR) buf;
    while (*p) {
        if (p > (LPTSTR) buf) {
            for( p2=p-2; _istdigit(*p2); p2--) ;
        }
        if (_tcsicmp(p, PROCESS_COUNTER) == 0) {
            //
            // look backwards for the counter number
            //
            for( p2=p-2; _istdigit(*p2); p2--) ;
            _tcscpy( szSubKey, p2+1 );
        }
        else
        if (_tcsicmp(p, PROCESSID_COUNTER) == 0) {
            //
            // look backwards for the counter number
            //
            for( p2=p-2; _istdigit(*p2); p2--) ;
            dwProcessIdTitle = _ttoi( p2+1 );
        }
        //
        // next string
        //
        p += (_tcslen(p) + 1);
    }

    //
    // free the counter names buffer
    //
    DPMEM_FREE( buf );


    //
    // allocate the initial buffer for the performance data
    //
    dwSize = INITIAL_SIZE;
    buf = DPMEM_ALLOC( dwSize );
    if (buf == NULL) {
        goto exit;
    }
    memset( buf, 0, dwSize );


    while (TRUE) {

        rc = RegQueryValueEx( HKEY_PERFORMANCE_DATA,
                              szSubKey,
                              NULL,
                              &dwType,
                              buf,
                              &dwSize
                            );

        pPerf = (PPERF_DATA_BLOCK) buf;

        //
        // check for success and valid perf data block signature
        //
        if ((rc == ERROR_SUCCESS) &&
            (dwSize > 0) &&
            (pPerf)->Signature[0] == (WCHAR)'P' &&
            (pPerf)->Signature[1] == (WCHAR)'E' &&
            (pPerf)->Signature[2] == (WCHAR)'R' &&
            (pPerf)->Signature[3] == (WCHAR)'F' ) {
            break;
        }

        //
        // if buffer is not big enough, reallocate and try again
        //
        if (rc == ERROR_MORE_DATA) {
            dwSize += EXTEND_SIZE;
            buf = DPMEM_REALLOC( buf, dwSize );
            memset( buf, 0, dwSize );
        }
        else {
            goto exit;
        }
    }

    //
    // set the perf_object_type pointer
    //
    pObj = (PPERF_OBJECT_TYPE) ((DWORD_PTR)pPerf + pPerf->HeaderLength);

    //
    // loop thru the performance counter definition records looking
    // for the process id counter and then save its offset
    //
    pCounterDef = (PPERF_COUNTER_DEFINITION) ((DWORD_PTR)pObj + pObj->HeaderLength);
    for (i=0; i<(DWORD)pObj->NumCounters; i++) {
        if (pCounterDef->CounterNameTitleIndex == dwProcessIdTitle) {
            dwProcessIdCounter = pCounterDef->CounterOffset;
            break;
        }
        pCounterDef++;
    }

    dwNumTasks = (DWORD)pObj->NumInstances;

    pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD_PTR)pObj + pObj->DefinitionLength);

    //
    // loop thru the performance instance data extracting each process name
    // and process id
    //

	ccStrFind=(WSTRLEN(lpci->lpszFile)-1)-4; // don't include .exe in compare

	if(ccStrFind > 15){
		ccStrFind=15;
	}
    
    for (i=0; i<dwNumTasks; i++) {
        //
        // pointer to the process name
        //

		nameStr = (LPWSTR) ((DWORD_PTR)pInst + pInst->NameOffset);

 		pCounter = (PPERF_COUNTER_BLOCK) ((DWORD_PTR)pInst + pInst->ByteLength);

		// Compare the process name with the executable name we are
		// looking for
		dwProcessID = *((LPDWORD) ((DWORD_PTR)pCounter + dwProcessIdCounter));

//		tack .exe onto the end
		wcscpy(fileString, nameStr);
//		wcscat(fileString, L".exe");

		ccStrMatch=WSTRLEN(fileString)-1; // 1 for NULL
		if(ccStrMatch == 16){ // when it is 16, it included a trailing . so strip it.
			ccStrMatch--;
		}

		if(CSTR_EQUAL == OS_CompareString(LOCALE_SYSTEM_DEFAULT,
			NORM_IGNORECASE, fileString, ccStrMatch, lpci->lpszFile, ccStrFind))
		{
			// See if the process is in wait mode
			if(PRV_IsAppInWaitMode(dwProcessID))
			{
				hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID);
				if(!hProcess)
				{
					dwError = GetLastError();
					DPF_ERRVAL("Unable to open running process, dwError = %lu", dwError);
					goto exit;
				}
				else
				{
					// Save off the stuff we need
					lppi->dwProcessId = dwProcessID;
					lppi->hProcess = hProcess;
					hr = DP_OK;
					goto exit;
				}
			} // IsAppInWaitMode
		} // Are Filenames Equal
		
		//
        // next process
        //
        pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD_PTR)pCounter + pCounter->ByteLength);
    }

exit:
    if (buf) {
        DPMEM_FREE( buf );
    }

    RegCloseKey( hKeyNames );
    RegCloseKey( HKEY_PERFORMANCE_DATA );


	return hr;
} // PRV_FindAppRunningNT

// If you build with the UNICODE flag set, the headers will redefine PROCESSENTRY32
// to be PROCESSENTRY32W. Unfortunately, passing PROCESSENTRY32W to Win9x functions
// will cause them to fail (because of the embedded Unicode string).
//
// Fix is to define our own PROCESSENTRY32A which is guaranteed to have an ANSI
// embedded string which Win9x will always accept.

typedef struct tagPROCESSENTRY32 PROCESSENTRY32A;
typedef PROCESSENTRY32A	*LPPROCESSENTRY32A;

#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindRunningAppWin9x"
HRESULT PRV_FindRunningAppWin9x(LPCONNECTINFO lpci, LPPROCESS_INFORMATION lppi)
{
	HANDLE			hSnapShot = NULL;
	PROCESSENTRY32A	procentry;
	BOOL			bFlag;
	HRESULT			hr = DPERR_UNAVAILABLE;
	LPBYTE			lpbTemp = NULL;
	DWORD			dwStrSize;
	LPWSTR			lpszFile = NULL;
	HANDLE			hProcess = NULL;
	DWORD			dwError;
	HANDLE			hInstLib = NULL;
	HRESULT			hrTemp;

	// ToolHelp Function Pointers.
	HANDLE (WINAPI *lpfCreateToolhelp32Snapshot)(DWORD,DWORD);
	BOOL (WINAPI *lpfProcess32First)(HANDLE,LPPROCESSENTRY32A);
	BOOL (WINAPI *lpfProcess32Next)(HANDLE,LPPROCESSENTRY32A);
	  

	DPF(7, "Entering PRV_FindRunningAppWin9x");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpci, lppi);

	// Load library and get the procedures explicitly. We do
	// this so that we can load the entry points dynamically,
	// which allows us to build correctly under WinNT even
	// though the NT kernel32 doesn't have these entry points
	hInstLib = LoadLibraryA( "Kernel32.DLL" );
	if(hInstLib == NULL)
	{
		DPF_ERR("Unable to load Kernel32.DLL");
		goto EXIT_FIND_RUNNING_APP_WIN9X;
	}

	// Get procedure addresses.
	// We are linking to these functions of Kernel32
	// explicitly, because otherwise a module using
	// this code would fail to load under Windows NT,
	// which does not have the Toolhelp32
	// functions in the Kernel 32.
	lpfCreateToolhelp32Snapshot=(HANDLE(WINAPI *)(DWORD,DWORD)) GetProcAddress( hInstLib, "CreateToolhelp32Snapshot" );
	lpfProcess32First=(BOOL(WINAPI *)(HANDLE,LPPROCESSENTRY32A))	GetProcAddress( hInstLib, "Process32First" );
	lpfProcess32Next=(BOOL(WINAPI *)(HANDLE,LPPROCESSENTRY32A)) GetProcAddress( hInstLib, "Process32Next" );
	if( lpfProcess32Next == NULL || lpfProcess32First == NULL || lpfCreateToolhelp32Snapshot == NULL )
	{
		DPF_ERR("Unable to get needed entry points in PSAPI.DLL");
		goto EXIT_FIND_RUNNING_APP_WIN9X;
	}

	// Get a handle to a Toolhelp snapshot of the systems processes. 
	hSnapShot = lpfCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if(hSnapShot == INVALID_HANDLE_VALUE)
	{
		DPF_ERR("Unable to get snapshot of system processes");
		goto EXIT_FIND_RUNNING_APP_WIN9X;
	}
	
	// Get the first process' information.
	procentry.dwSize = sizeof(PROCESSENTRY32A);
	bFlag = lpfProcess32First(hSnapShot, &procentry);

	// While there are processes, keep looping.
	while(bFlag)
	{
		// Walk the path and filename string (guaranteed to be ANSI)
		// looking for the final backslash (\).  Once we find it,
		// convert the filename to Unicode so we can compare it.
		dwStrSize = lstrlenA((LPBYTE)procentry.szExeFile);
		lpbTemp = (LPBYTE)procentry.szExeFile + dwStrSize - 1;
		while(--dwStrSize)
		{
			if(lpbTemp[0] == '\\')
			{
				lpbTemp++;
				break;
			}
			else
				lpbTemp--;
		}
		
		hrTemp = GetWideStringFromAnsi(&lpszFile, (LPSTR)lpbTemp);
		if(FAILED(hrTemp))
		{
			DPF_ERR("Failed making temporary copy of filename string");
			goto EXIT_FIND_RUNNING_APP_WIN9X;
		}
		
		// Compare the process name with the executable name we are
		// looking for
		if(CSTR_EQUAL == OS_CompareString(LOCALE_SYSTEM_DEFAULT,
			NORM_IGNORECASE, lpszFile, -1, lpci->lpszFile, -1))
		{
			// See if the process is in wait mode
			if(PRV_IsAppInWaitMode(procentry.th32ProcessID))
			{
				// Open the process since Windows9x doesn't do
				// it for us.
				hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, procentry.th32ProcessID);
				if(!hProcess)
				{
					dwError = GetLastError();
					DPF_ERRVAL("Unable to open running process, dwError = %lu", dwError);
					bFlag = FALSE;
				}
				else
				{
					// Save off the stuff we need
					lppi->dwProcessId = procentry.th32ProcessID;
					lppi->hProcess = hProcess;
					hr = DP_OK;
					bFlag = FALSE;
				}

			} // IsAppInWaitMode
		} // Are Filenames Equal

		// Free our temporary string
		DPMEM_FREE(lpszFile);

		// If we haven't found it, and we didn't error, then move to
		// the next process
		if(bFlag)
		{
			// Move to the next process
			procentry.dwSize = sizeof(PROCESSENTRY32A);
			bFlag = lpfProcess32Next(hSnapShot, &procentry);
		}
	}
		

EXIT_FIND_RUNNING_APP_WIN9X:

	if(hSnapShot)
		CloseHandle(hSnapShot);
	if(hInstLib)
		FreeLibrary(hInstLib) ;

	return hr;

} // PRV_FindRunningAppWin9x



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindRunningApp"
HRESULT PRV_FindRunningApp(LPCONNECTINFO lpci, LPPROCESS_INFORMATION lppi)
{
	OSVERSIONINFOA	ver;
	HRESULT			hr = DPERR_UNAVAILABLE;


	DPF(7, "Entering PRV_FindRunningApp");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpci, lppi);

	ASSERT(lpci);
	ASSERT(lppi);


	// Clear our structure since it's on the stack
	memset(&ver, 0, sizeof(OSVERSIONINFOA));
	ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

	// Figure out which platform we are running on and
	// call the appropriate process enumerating function
	if(!GetVersionExA(&ver))
	{
		DPF_ERR("Unable to determinte platform -- not looking for running app");
		return DPERR_UNAVAILABLE;
	}

	switch(ver.dwPlatformId)
	{
		case VER_PLATFORM_WIN32_WINDOWS:
			// Call the Win9x version of FindRunningApp
			hr = PRV_FindRunningAppWin9x(lpci, lppi);
			break;

		case VER_PLATFORM_WIN32_NT:
			hr = PRV_FindRunningAppNT(lpci, lppi);
			break;

		default:
			DPF_ERR("Unable to determinte platform -- not looking for running app");
			hr = DPERR_UNAVAILABLE;
			break;
	}

	return hr;

} // PRV_FindRunningApp



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_RunApplication"
HRESULT DPLAPI DPL_RunApplication(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
							LPDWORD lpdwGameID, LPDPLCONNECTION lpConn,
							HANDLE hReceiveEvent)
{
    LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr;
	PROCESS_INFORMATION		pi;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
	CONNECTINFO				ci;
	HANDLE					hDupReceiveEvent = NULL;
	HANDLE					hReceiveThread = NULL;
	HANDLE					hTerminateThread = NULL;
	HANDLE					hKillReceiveThreadEvent = NULL;
	HANDLE					hKillTermThreadEvent = NULL;
	DWORD					dwThreadID;
	BOOL					bCreatedProcess = FALSE;
	GUID					*lpguidIPC = NULL;

	DPF(7, "Entering DPL_RunApplication");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lpdwGameID, lpConn, hReceiveEvent);

    ENTER_DPLOBBY();
    
    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
        
		// Validate the DPLCONNECTION structure and it's members
		hr = PRV_ValidateDPLCONNECTION(lpConn, FALSE);
		if(FAILED(hr))
		{
			LEAVE_DPLOBBY();
			return hr;
		}

		if( !VALID_DWORD_PTR( lpdwGameID ) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDPARAMS;
		}
	
		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDFLAGS;
		}

		// Validate the handle
		if(hReceiveEvent)
		{
			if(!OS_IsValidHandle(hReceiveEvent))
			{
				LEAVE_DPLOBBY();
				DPF_ERR("Invalid hReceiveEvent handle");
				return DPERR_INVALIDPARAMS;
			}
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Clear the CONNECTINFO structure since it's on the stack
	memset(&ci, 0, sizeof(CONNECTINFO)); 

	// Get the guid of the game we want to launch
	if(lpConn && lpConn->lpSessionDesc)
		ci.guidApplication = lpConn->lpSessionDesc->guidApplication;
	else
	{
		LEAVE_DPLOBBY();
		return DPERR_UNKNOWNAPPLICATION;
	}

	// Get the information out the registry based on the GUID
	if(!PRV_GetConnectInfoFromRegistry(&ci))
	{
		LEAVE_DPLOBBY();
		return DPERR_UNKNOWNAPPLICATION;
	}

	// Clear the PROCESS_INFORMATION structure since it's on the stack
	memset(&pi, 0, sizeof(PROCESS_INFORMATION)); 

	// Look to see if this game is already running AND is in wait mode
	// waiting for new connection settings.  If it is, we want to 
	// send the connection settings to it.
	hr = PRV_FindRunningApp(&ci, &pi);
	if(FAILED(hr))
	{
		// It isn't waiting, so create the game's process & suspend it
		hr = PRV_CreateGameProcess(&ci, &pi);
		if(FAILED(hr))
		{
			LEAVE_DPLOBBY();
			return hr;
		}
		if(!(IsEqualGUID(&ci.guidIPC,&GUID_NULL))){
			lpguidIPC=&ci.guidIPC;
		}
		// Set our created flag
		bCreatedProcess = TRUE;
	}

	// Create a game node
	hr = PRV_AddNewGameNode(this, &lpgn, pi.dwProcessId,
							pi.hProcess, TRUE, lpguidIPC);
	if(FAILED(hr))
	{
		DPF_ERR("Couldn't create new game node");
		goto RUN_APP_ERROR_EXIT;
	}

	// If the ConnectionSettings are from a StartSession message (lobby launched),
	// we need to set the flag
	if(lpConn->lpSessionDesc->dwReserved1)
	{
		// Set the flag that says we were lobby client launched
		lpgn->dwFlags |= GN_CLIENT_LAUNCHED;
	}

	// Write the connection settings in the shared memory buffer
	hr = PRV_WriteConnectionSettings(lpgn, lpConn, TRUE);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to write the connection settings!");
		goto RUN_APP_ERROR_EXIT;
	}

	// Send the app a message that the new connection settings are available
	// but only if we've sent the settings to a running app
	if(!bCreatedProcess)
		PRV_SendStandardSystemMessage(lpDPL, DPLSYS_NEWCONNECTIONSETTINGS, pi.dwProcessId);

	// Duplicate the Receive Event handle to use a signal to the
	// lobby client that the game has sent game settings to it.
	if(hReceiveEvent)
	{
		hDupReceiveEvent = PRV_DuplicateHandle(hReceiveEvent);
		if(!hDupReceiveEvent)
		{
			DPF_ERR("Unable to duplicate ReceiveEvent handle");
			hr = DPERR_OUTOFMEMORY;
			goto RUN_APP_ERROR_EXIT;
		}
	}

	lpgn->hDupReceiveEvent = hDupReceiveEvent;

	// Create the kill thread event for the monitor thread
	hKillTermThreadEvent = OS_CreateEvent(NULL, FALSE, FALSE, NULL);

	if(!hKillTermThreadEvent)
	{
		DPF_ERR("Unable to create kill thread event");
		hr = DPERR_OUTOFMEMORY;
		goto RUN_APP_ERROR_EXIT;
	}

	lpgn->hKillTermThreadEvent = hKillTermThreadEvent;

	// Spawn off a terminate monitor thread
	hTerminateThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)
						PRV_ClientTerminateNotification, lpgn, 0, &dwThreadID);

	if(!hTerminateThread)
	{
		DPF_ERR("Unable to create Terminate Monitor Thread!");
		hr = DPERR_OUTOFMEMORY;
		goto RUN_APP_ERROR_EXIT;
	}

	lpgn->hTerminateThread = hTerminateThread;

	// Resume the game's process & let it run, then
	// free the thread handle since we won't use it anymore
	if(bCreatedProcess)
	{
		ResumeThread(pi.hThread);
		CloseHandle(pi.hThread);
	}

	// Set the output pointer
	*lpdwGameID = pi.dwProcessId;

	// Free the strings in the connect info struct
	PRV_FreeConnectInfo(&ci);

	LEAVE_DPLOBBY();
	return DP_OK;

RUN_APP_ERROR_EXIT:

		if(pi.hThread && bCreatedProcess)
			CloseHandle(pi.hThread);
		if(bCreatedProcess && pi.hProcess)
			TerminateProcess(pi.hProcess, 0L);
		if(lpgn)
			PRV_RemoveGameNodeFromList(lpgn);
		PRV_FreeConnectInfo(&ci);

		LEAVE_DPLOBBY();
		return hr;

} // DPL_RunApplication
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\dplobbyi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobbyi.h
 *  Content:    DirectPlayLobby internal include file
 *
 *  History:
 *	Date		By		Reason
 *	===========	=======	==========
 *	2/25/97		myronth	Created it
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/12/97		myronth	Added Connection & Session Management stuff plus
 *						a few forward declarations for internal objects
 *	3/17/97		myronth	Create/DestroyGroup/Player
 *	3/20/97		myronth	AddPlayerToGroup, DeletePlayerFromGroup
 *	3/21/97		myronth	SetGroup/PlayerName, Get/SetGroup/PlayerData
 *	3/25/97		kipo	EnumConnections takes a const *GUID now
 *	3/31/97		myronth	Send
 *	4/10/97		myronth	GetCaps, GetPlayerCaps
 *	5/8/97		myronth	Subgroup functions, GroupConnSettings, StartSession,
 *						Purged dead code
 *	5/13/97		myronth	Pass credentials to PRV_Open, pass them on to the LP
 *	5/17/97		myronth	SendChatMessage
 *	8/19/97		myronth	More prototypes for sending standard lobby messages
 *	8/19/97		myronth	Removed prototypes for dead functions
 *	9/29/97		myronth	Added PRV_ConvertDPLCONNECTIONToAnsiInPlace prototype
 *	10/29/97	myronth	Added group owner ID to create group methods, exposed
 *						map table functions, exposed group owner methods
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/13/97	myronth	Added functions for asynchronous Connect (#12541)
 *	11/20/97	myronth	Made EnumConnections & DirectPlayEnumerate 
 *						drop the lock before calling the callback (#15208)
 *	1/20/98		myronth	Moved PRV_SendStandardSystemMessage into this file
 ***************************************************************************/
#ifndef __DPLOBBYI_INCLUDED__
#define __DPLOBBYI_INCLUDED__


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------
#ifndef DPLAPI
#define DPLAPI WINAPI
#endif

typedef struct DPLOBBYI_DPLOBJECT * LPDPLOBBYI_DPLOBJECT;
typedef struct LSPNODE * LPLSPNODE;

#define DPLOBBYPR_GAMEID				0

// Forward declarations needed because of the include file order in DPlay
typedef struct _DPLAYI_DPLAY * LPDPLAYI_DPLAY;

//--------------------------------------------------------------------------
//
//	Globals
//
//--------------------------------------------------------------------------
extern LPLSPNODE	glpLSPHead;			// In dplenum.c

//--------------------------------------------------------------------------
//
//	Prototypes
//
//--------------------------------------------------------------------------

// create.c
extern HRESULT PRV_AllocateLobbyObject(LPDPLAYI_DPLAY, LPDPLOBBYI_DPLOBJECT *);

// dplenum.c
extern void PRV_FreeLSPList(LPLSPNODE);
extern HRESULT PRV_EnumConnections(LPCGUID, LPDPENUMCONNECTIONSCALLBACK,
									LPVOID, DWORD, BOOL);

// dplobby.c
extern HRESULT DPLAPI PRV_GetCaps(LPDPLOBBYI_DPLOBJECT, DWORD, LPDPCAPS);
extern BOOL PRV_GetConnectPointers(LPDIRECTPLAYLOBBY, LPDIRECTPLAY2 *, LPDPLCONNECTION *);
extern void PRV_SaveConnectPointers(LPDIRECTPLAYLOBBY, LPDIRECTPLAY2, LPDPLCONNECTION);
extern BOOL PRV_IsAsyncConnectOn(LPDIRECTPLAYLOBBY);
void PRV_TurnAsyncConnectOn(LPDIRECTPLAYLOBBY);
void PRV_TurnAsyncConnectOff(LPDIRECTPLAYLOBBY);

// dplobbya.c
extern HRESULT DPLAPI DPL_A_GetGroupConnectionSettings(LPDIRECTPLAY,
						DWORD, DPID, LPVOID, LPDWORD);
extern HRESULT DPLAPI DPL_A_SetGroupConnectionSettings(LPDIRECTPLAY,
						DWORD, DPID, LPDPLCONNECTION);

// dplpack.c
extern void PRV_FixupDPLCONNECTIONPointers(LPDPLCONNECTION);
extern HRESULT PRV_ConvertDPLCONNECTIONToAnsiInPlace(LPDPLCONNECTION, LPDWORD, DWORD);

// dplshare.c
extern HRESULT PRV_SendStandardSystemMessage(LPDIRECTPLAYLOBBY, DWORD, DWORD);

// dplunk.c
extern HRESULT PRV_DestroyDPLobby(LPDPLOBBYI_DPLOBJECT);
extern void PRV_FreeAllLobbyObjects(LPDPLOBBYI_DPLOBJECT);

// group.c
extern HRESULT DPLAPI PRV_AddGroupToGroup(LPDPLOBBYI_DPLOBJECT, DPID, DPID);
extern HRESULT DPLAPI PRV_AddPlayerToGroup(LPDPLOBBYI_DPLOBJECT, DPID, DPID);
extern HRESULT DPLAPI PRV_CreateGroup(LPDPLOBBYI_DPLOBJECT,
			LPDPID, LPDPNAME, LPVOID, DWORD, DWORD, DPID);
extern HRESULT DPLAPI PRV_CreateGroupInGroup(LPDPLOBBYI_DPLOBJECT, DPID,
			LPDPID, LPDPNAME, LPVOID, DWORD, DWORD, DPID);
extern HRESULT DPLAPI PRV_DeleteGroupFromGroup(LPDPLOBBYI_DPLOBJECT, DPID, DPID);
extern HRESULT DPLAPI PRV_DeletePlayerFromGroup(LPDPLOBBYI_DPLOBJECT, DPID, DPID);
extern HRESULT DPLAPI PRV_DestroyGroup(LPDPLOBBYI_DPLOBJECT, DPID);
extern HRESULT DPLAPI DPL_GetGroupConnectionSettings(LPDIRECTPLAY, DWORD,
			DPID, LPVOID, LPDWORD);
extern HRESULT DPLAPI PRV_GetGroupData(LPDPLOBBYI_DPLOBJECT, DPID, LPVOID, LPDWORD);
extern HRESULT DPLAPI DPL_SetGroupConnectionSettings(LPDIRECTPLAY, DWORD,
			DPID, LPDPLCONNECTION);
extern HRESULT DPLAPI DPL_GetGroupOwner(LPDIRECTPLAY, DPID, LPDPID);
extern HRESULT DPLAPI PRV_SetGroupData(LPDPLOBBYI_DPLOBJECT, DPID, LPVOID, DWORD, DWORD);
extern HRESULT DPLAPI PRV_SetGroupName(LPDPLOBBYI_DPLOBJECT, DPID, LPDPNAME, DWORD);
extern HRESULT DPLAPI DPL_SetGroupOwner(LPDIRECTPLAY, DPID, DPID);
extern HRESULT DPLAPI DPL_StartSession(LPDIRECTPLAY, DWORD, DPID);

// player.c
extern HRESULT DPLAPI PRV_CreatePlayer(LPDPLOBBYI_DPLOBJECT,
			LPDPID, LPDPNAME, HANDLE, LPVOID, DWORD, DWORD);
extern HRESULT DPLAPI PRV_DestroyPlayer(LPDPLOBBYI_DPLOBJECT, DPID);
extern HRESULT DPLAPI PRV_GetPlayerCaps(LPDPLOBBYI_DPLOBJECT, DWORD, DPID, LPDPCAPS);
extern HRESULT DPLAPI PRV_GetPlayerData(LPDPLOBBYI_DPLOBJECT, DPID, LPVOID, LPDWORD);
extern HRESULT DPLAPI PRV_Send(LPDPLOBBYI_DPLOBJECT, DPID, DPID, DWORD, LPVOID, DWORD);
extern HRESULT DPLAPI PRV_SendChatMessage(LPDPLOBBYI_DPLOBJECT, DPID, DPID, DWORD, LPDPCHAT);
extern HRESULT DPLAPI PRV_SetPlayerData(LPDPLOBBYI_DPLOBJECT, DPID, LPVOID, DWORD, DWORD);
extern HRESULT DPLAPI PRV_SetPlayerName(LPDPLOBBYI_DPLOBJECT, DPID, LPDPNAME, DWORD);
extern BOOL PRV_GetDPIDByLobbyID(LPDPLOBBYI_DPLOBJECT, DWORD, DPID *);
extern BOOL PRV_GetLobbyIDByDPID(LPDPLOBBYI_DPLOBJECT, DPID, LPDWORD);
extern HRESULT PRV_AddMapIDNode(LPDPLOBBYI_DPLOBJECT, DWORD, DPID);
extern BOOL PRV_DeleteMapIDNode(LPDPLOBBYI_DPLOBJECT, DWORD);

// server.c
extern HRESULT PRV_LoadSP(LPDPLOBBYI_DPLOBJECT, LPGUID, LPVOID, DWORD);
extern BOOL FAR PASCAL PRV_FindLPGUIDInAddressCallback(REFGUID, DWORD,
							LPCVOID, LPVOID);

// session.c
extern HRESULT DPLAPI PRV_Close(LPDPLOBBYI_DPLOBJECT);
extern HRESULT DPLAPI PRV_EnumSessions(LPDPLOBBYI_DPLOBJECT, LPDPSESSIONDESC2, DWORD, DWORD);
extern HRESULT DPLAPI PRV_GetSessionDesc(LPDPLOBBYI_DPLOBJECT);
extern HRESULT DPLAPI PRV_Open(LPDPLOBBYI_DPLOBJECT, LPDPSESSIONDESC2, DWORD, LPCDPCREDENTIALS);
extern HRESULT DPLAPI PRV_SetSessionDesc(LPDPLOBBYI_DPLOBJECT);

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#endif // __DPLOBBYI_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\create.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       create.c
 *  Content:	DirectPlayLobby creation code
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	4/13/96		myronth	Created it
 *	6/24/96		myronth	Added Time Bomb
 *	8/23/96		kipo	removed time bomb
 *	10/23/96	myronth	Added client/server methods
 *	10/25/96	myronth	Added DX5 methods
 *	11/20/96	myronth	Added DPLC_A_LogonServer
 *	1/2/97		myronth	Changed vtbl entries for CreateAddress & EnumAddress
 *	1/2/97		myronth	Cleaned up creation code by adding PRV_LobbyCreate
 *	2/12/97		myronth	Mass DX5 changes
 *	2/18/97		myronth	Implemented GetObjectCaps
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/12/97		myronth	Added AllocateLobbyObject, removed response methods
 *						for Open and Close since they are synchronous
 *	3/17/97		myronth	Removed unnecessary Enum functions from IDPLobbySP
 *	3/21/97		myronth	Removed unnecessary Get/Set response functions
 *	3/24/97		kipo	Added support for IDirectPlayLobby2 interface
 *	3/31/97		myronth	Removed dead code, changed IDPLobbySP interface methods
 *	5/8/97		myronth	Added subgroup methods & StartSession to IDPLobbySP
 *	5/17/97		myronth	Added SendChatMessage to IDPLobbySP
 *	6/25/97		kipo	remove time bomb for DX5
 *	10/3/97		myronth	Added CreateCompoundAddress and EnumAddress to
 *						IDPLobbySP (12648)
 *	10/29/97	myronth	Added SetGroupOwner to IDPLobbySP
 *	11/24/97	kipo	Added time bomb for DX6
 *	12/2/97		myronth	Added Register/UnregisterApplication methods
 *	12/4/97		myronth	Added ConnectEx
 *	1/20/98		myronth	Added WaitForConnectionSettings
 *	6/25/98		a-peterz Added DPL_A_ConnectEx
 *  2/2/99		aarono  Added lobbies to refcount on DPLAY dll to avoid
 *                      accidental unload.
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Globals
//
//--------------------------------------------------------------------------
UINT		gnSPCount;		// Running sp count


//
// The one copy of the direct play callbacks (this is the vtbl!)
//
DIRECTPLAYLOBBYCALLBACKS dplCallbacks =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_EnumLocalApplications,
	(LPVOID)DPL_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
};  				

DIRECTPLAYLOBBYCALLBACKSA dplCallbacksA =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_A_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_A_EnumLocalApplications,
	(LPVOID)DPL_A_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_A_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_A_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
};  				

// IDirectPlayLobby2 interface
DIRECTPLAYLOBBYCALLBACKS2 dplCallbacks2 =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_EnumLocalApplications,
	(LPVOID)DPL_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
    /*** IDirectPlayLobby2 methods ***/
	(LPVOID)DPL_CreateCompoundAddress
};  				

DIRECTPLAYLOBBYCALLBACKS2A dplCallbacks2A =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_A_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_A_EnumLocalApplications,
	(LPVOID)DPL_A_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_A_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_A_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
    /*** IDirectPlayLobby2A methods ***/
	(LPVOID)DPL_CreateCompoundAddress
};  				
  
// IDirectPlayLobby3 interface
DIRECTPLAYLOBBYCALLBACKS3 dplCallbacks3 =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_EnumLocalApplications,
	(LPVOID)DPL_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
    /*** IDirectPlayLobby2 methods ***/
	(LPVOID)DPL_CreateCompoundAddress,
    /*** IDirectPlayLobby3 methods ***/
	(LPVOID)DPL_ConnectEx,
	(LPVOID)DPL_RegisterApplication,
	(LPVOID)DPL_UnregisterApplication,
	(LPVOID)DPL_WaitForConnectionSettings
};  				

DIRECTPLAYLOBBYCALLBACKS3A dplCallbacks3A =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_A_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_A_EnumLocalApplications,
	(LPVOID)DPL_A_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_A_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_A_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
    /*** IDirectPlayLobby2A methods ***/
	(LPVOID)DPL_CreateCompoundAddress,
    /*** IDirectPlayLobby3 methods ***/
	(LPVOID)DPL_A_ConnectEx,
	(LPVOID)DPL_A_RegisterApplication,
	(LPVOID)DPL_UnregisterApplication,
	(LPVOID)DPL_WaitForConnectionSettings
};  				
  
DIRECTPLAYLOBBYSPCALLBACKS dplCallbacksSP =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPLP_AddGroupToGroup,
	(LPVOID)DPLP_AddPlayerToGroup,
	(LPVOID)DPLP_CreateGroup,
	(LPVOID)DPLP_CreateGroupInGroup,
	(LPVOID)DPLP_DeleteGroupFromGroup,
	(LPVOID)DPLP_DeletePlayerFromGroup,
	(LPVOID)DPLP_DestroyGroup,
	(LPVOID)DPLP_EnumSessionsResponse,
	(LPVOID)DPLP_GetSPDataPointer,
	(LPVOID)DPLP_HandleMessage,
	(LPVOID)DPLP_SendChatMessage,
	(LPVOID)DPLP_SetGroupName,
	(LPVOID)DPLP_SetPlayerName,
	(LPVOID)DPLP_SetSessionDesc,
	(LPVOID)DPLP_SetSPDataPointer,
	(LPVOID)DPLP_StartSession,
    /*** Methods added for DX6 ***/
	(LPVOID)DPL_CreateCompoundAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPLP_SetGroupOwner,
};  				

//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AllocateLobbyObject"
HRESULT PRV_AllocateLobbyObject(LPDPLAYI_DPLAY lpDPObject,
							LPDPLOBBYI_DPLOBJECT * lpthis)
{
	LPDPLOBBYI_DPLOBJECT	this = NULL;


	DPF(7, "Entering PRV_AllocateLobbyObject");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpDPObject, lpthis);

	// Allocate memory for our lobby object
    this = DPMEM_ALLOC(sizeof(DPLOBBYI_DPLOBJECT));
    if(!this) 
    {
    	DPF_ERR("Unable to allocate memory for lobby object");
        return DPERR_OUTOFMEMORY;
    }

	// Initialize the ref count
	this->dwRefCnt = 0;
	this->dwSize = sizeof(DPLOBBYI_DPLOBJECT);

	// Store the back pointer
	this->lpDPlayObject = lpDPObject;

	// Set the output pointer
	*lpthis = this;

	gnObjects++;

	return DP_OK;

} // PRV_AllocateLobbyObject



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_LobbyCreate"
HRESULT WINAPI PRV_LobbyCreate(LPGUID lpGUID, LPDIRECTPLAYLOBBY *lplpDPL,
				IUnknown *pUnkOuter, LPVOID lpSPData, DWORD dwSize, BOOL bAnsi)
{
    LPDPLOBBYI_DPLOBJECT	this = NULL;
	LPDPLOBBYI_INTERFACE	lpInterface = NULL;
	HRESULT					hr;


	DPF(7, "Entering PRV_LobbyCreate");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu, %lu",
			lpGUID, lplpDPL, pUnkOuter, lpSPData, dwSize, bAnsi);
	
	// Must be NULL for this release
	if( lpGUID )
	{
		if( !VALID_READ_PTR(lpGUID, sizeof(GUID)) )
			return DPERR_INVALIDPARAMS;

		if(!IsEqualGUID(lpGUID, &GUID_NULL))
			return DPERR_INVALIDPARAMS;
	}

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }
   
	if( lpSPData )
	{
		// Must be NULL for this release
		return DPERR_INVALIDPARAMS;
	}

	if( dwSize )
	{
		// Must be zero for this release
		return DPERR_INVALIDPARAMS;
	}


    TRY
    {
        *lplpDPL = NULL;
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

#if 0

#pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return DPERR_GENERIC;
	}

#endif

	// Allocate the lobby object
	hr = PRV_AllocateLobbyObject(NULL, &this);
	if(FAILED(hr))
		return hr;

	// Get the Unicode interface
	hr = PRV_GetInterface(this, &lpInterface, (bAnsi ? &dplCallbacksA : &dplCallbacks));
	if(FAILED(hr))
	{
		DPMEM_FREE(this);
    	DPF_ERR("Unable to allocate memory for lobby interface structure");
        return hr;
	}

	*lplpDPL = (LPDIRECTPLAYLOBBY)lpInterface;

    return DP_OK;

} // PRV_LobbyCreate


#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayLobbyCreateW"
HRESULT WINAPI DirectPlayLobbyCreateW(LPGUID lpGUID, LPDIRECTPLAYLOBBY *lplpDPL,
							IUnknown *pUnkOuter, LPVOID lpSPData, DWORD dwSize)
{
	HRESULT		hr = DP_OK;


    ENTER_DPLOBBY();
    
	// Call the private create function
	hr = PRV_LobbyCreate(lpGUID, lplpDPL, pUnkOuter, lpSPData, dwSize, FALSE);

    LEAVE_DPLOBBY();

    return hr;

} // DirectPlayLobbyCreateW


#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayLobbyCreateA"
HRESULT WINAPI DirectPlayLobbyCreateA(LPGUID lpGUID, LPDIRECTPLAYLOBBY *lplpDPL,
							IUnknown *pUnkOuter, LPVOID lpSPData, DWORD dwSize)
{
	HRESULT		hr = DP_OK;


    ENTER_DPLOBBY();
    
	// Call the private create function
	hr = PRV_LobbyCreate(lpGUID, lplpDPL, pUnkOuter, lpSPData, dwSize, TRUE);

    LEAVE_DPLOBBY();

    return hr;

} // DirectPlayLobbyCreateA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\dplenum.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplenum.c
 *  Content:	Methods for enumeration
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	4/13/96		myronth	Created it
 *	10/23/96	myronth	Added client/server methods
 *	12/10/96	myronth	Fixed bugs #4622 and #5043
 *	2/12/97		myronth	Mass DX5 changes
 *	3/4/97		myronth	Fixed enum size bug #6149
 *	3/12/97		myronth	Added EnumConnections
 *	3/25/97		kipo	EnumConnections takes a const *GUID now
 *	4/7/97		myronth	Fixed PRV_EnumConnections to use CreateCompoundAddress
 *	5/10/97		kipo	added GUID to EnumConnections callback
 *	5/14/97		myronth	Check for valid guid in EnumLocalApps, bug #7695
 *	5/17/97		myronth	Fixed bug #8506 (return bogus error if last app
 *						is invalid), fixed more GUIDFromString bugs
 *	8/22/97		myronth	Added registry support for Description and Private
 *						values, also cleaned up LP enumeration code
 *	11/20/97	myronth	Made EnumConnections & DirectPlayEnumerate 
 *						drop the lock before calling the callback (#15208)
 *	12/2/97		myronth	Changed EnumLocalApp to use Desc fields (#15448)
 *	01/20/98	sohailm	Don't free sp list after EnumConnections (#17006)
 ***************************************************************************/
#include "dplobpr.h"

//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------


//--------------------------------------------------------------------------
//
//	Globals
//
//--------------------------------------------------------------------------
LPLSPNODE	glpLSPHead = NULL;


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CallEnumAddressTypesCallback"
HRESULT PRV_CallEnumAddressTypesCallback(HKEY hkeySP,
				LPDPLENUMADDRESSTYPESCALLBACK lpfnEnumCallback,
				LPVOID lpContext)
{
	HRESULT		hr;
	WCHAR		wszGuidStr[GUID_STRING_SIZE];
	DWORD		dwGuidStrSize = sizeof(wszGuidStr);
	GUID		guidAddressType;
	HKEY		hkeyAddressTypes;
	DWORD		dwIndex = 0;
	LONG		lReturn;
	BOOL		bReturn = TRUE;


	DPF(7, "Entering PRV_CallEnumAddressTypesCallback");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			hkeySP, lpfnEnumCallback, lpContext);
	
	ASSERT(hkeySP);	
	
	// Get the Address Type registry key
	lReturn = OS_RegOpenKeyEx(hkeySP, SZ_ADDRESS_TYPES, 0,
								KEY_READ, &hkeyAddressTypes);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("No Address Types found for the Service Provider!");
		return DP_OK;
	}

	// Walk the list of Address Types in the registry, looking for the GUID passed in
	while((ERROR_NO_MORE_ITEMS != OS_RegEnumKeyEx(hkeyAddressTypes, dwIndex++,
			(LPWSTR)&wszGuidStr, &dwGuidStrSize, NULL, NULL, NULL, NULL)) && bReturn)
	{
		// Convert the string to a real GUID
		hr = GUIDFromString(wszGuidStr, &guidAddressType);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't convert Address Type string to GUID");
			dwGuidStrSize = sizeof(wszGuidStr);
			continue;
		}

		// Call the callback
		bReturn = ((LPDPLENUMADDRESSTYPESCALLBACK)lpfnEnumCallback)
					(&guidAddressType, lpContext, 0L);


		// Reset the size variable in the success case
		dwGuidStrSize = sizeof(wszGuidStr);
	}

	// Close the Address Types key
	RegCloseKey(hkeyAddressTypes);

	return DP_OK;


} // PRV_CallEnumAddressTypesCallback


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_EnumAddressTypes"
HRESULT PRV_EnumAddressTypes(LPDIRECTPLAYLOBBY lpDPL,
				LPDPLENUMADDRESSTYPESCALLBACK lpfnEnumCallback,
				REFGUID guidSPIn, LPVOID lpContext, DWORD dwFlags)
{
    LPDPLOBBYI_DPLOBJECT	this;
    HRESULT					hr = DP_OK;
	HKEY					hkeySPHead, hkeySP;
	DWORD					dwIndex = 0;
	DWORD					dwNameSize;
	WCHAR					wszSPName[DPLOBBY_REGISTRY_NAMELEN];
	WCHAR					wszGuidStr[GUID_STRING_SIZE];
	DWORD					dwGuidStrSize = sizeof(wszGuidStr);
	DWORD					dwType = REG_SZ;
	GUID					guidSP;
	LONG					lReturn;
	BOOL					bFound = FALSE;


	DPF(7, "Entering PRV_EnumAddressTypes");
	DPF(9, "Parameters: 0x%08x, 0x%08x, guid, 0x%08x, 0x%08x",
			lpDPL, lpfnEnumCallback, lpContext, dwFlags);
    
	TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            return DPERR_INVALIDOBJECT;
        }
        
        if( !VALIDEX_CODE_PTR( lpfnEnumCallback ) )
        {
            return DPERR_INVALIDPARAMS;
        }

		if (!VALID_READ_PTR(guidSPIn, sizeof(GUID)))
		{
			DPF_ERR("Invalid SP GUID pointer");
			return DPERR_INVALIDPARAMS;	
		}

		// There are no flags defined for DX3
		if( dwFlags )
		{
			return DPERR_INVALIDPARAMS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Open the Service Providers key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_SP_KEY, 0,
								KEY_READ, &hkeySPHead);
	if(lReturn != ERROR_SUCCESS)
	{
		// This just means that the Service Providers key doesn't exist (most
		// likely), so in that case, there are no SP's to enumerate.
		DPF_ERR("There are no Service Providers registered");
		return DP_OK;
	}


	// Walk the list of SP's in the registry, looking for the GUID passed in
	while(!bFound)
	{
		// Get the next SP in the list
		dwNameSize = DPLOBBY_REGISTRY_NAMELEN;
		lReturn = OS_RegEnumKeyEx(hkeySPHead, dwIndex++, (LPWSTR)&wszSPName,
					&dwNameSize, NULL, NULL, NULL, NULL);

		// If lReturn is ERROR_NO_MORE_ITEMS, we want to end on this iteration
		if(lReturn == ERROR_NO_MORE_ITEMS)
			break;;

		// Open the SP key
		lReturn = OS_RegOpenKeyEx(hkeySPHead, (LPWSTR)wszSPName, 0,
									KEY_READ, &hkeySP);
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERR("Unable to open key for Service Provider!");
			continue;
		}

		// Get the GUID of the SP
		dwGuidStrSize = GUID_STRING_SIZE;
		lReturn = OS_RegQueryValueEx(hkeySP, SZ_GUID, NULL, &dwType,
									(LPBYTE)&wszGuidStr, &dwGuidStrSize);
		if(lReturn != ERROR_SUCCESS)
		{
			RegCloseKey(hkeySP);
			DPF_ERR("Unable to query GUID key value!");
			continue;
		}

		// Convert the string to a real GUID
		hr = GUIDFromString(wszGuidStr, &guidSP);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Invalid SP guid -- skipping SP, hr = 0x%08x", hr);
			RegCloseKey(hkeySP);
			// Set the hresult back to DP_OK in case this is the last
			// SP in the registry -- we want the method call
			// to succeed if we got this far, we just don't want to
			// call the callback for this particular SP
			hr = DP_OK;
			continue;
		}

		// If we match the GUID passed in, then enumerate them
		if(IsEqualGUID(guidSPIn, &guidSP))
		{
			// Enumerate the Address Types for this SP
			hr = PRV_CallEnumAddressTypesCallback(hkeySP,
							lpfnEnumCallback, lpContext);
			bFound = TRUE;
		}

		// Close the SP key
		RegCloseKey(hkeySP);
	}

	// Close the DPlay Apps key
	RegCloseKey(hkeySPHead);

	// If we didn't find the SP, return an error
	// REVIEW!!!! -- Is this really the error we want here????
	if(!bFound)
		return DPERR_UNAVAILABLE;

	return hr;

} // PRV_EnumAddressTypes


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_EnumAddressTypes"
HRESULT DPLAPI DPL_EnumAddressTypes(LPDIRECTPLAYLOBBY lpDPL,
				LPDPLENUMADDRESSTYPESCALLBACK lpfnEnumCallback,
				REFGUID guidSP, LPVOID lpContext, DWORD dwFlags)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_EnumAddressTypes");
	DPF(9, "Parameters: 0x%08x, 0x%08x, guid, 0x%08x, 0x%08x",
			lpDPL, lpfnEnumCallback, lpContext, dwFlags);

	ENTER_DPLOBBY();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_EnumAddressTypes(lpDPL, lpfnEnumCallback, guidSP, lpContext, dwFlags);

	LEAVE_DPLOBBY();

	return hr;

} // DPL_EnumAddressTypes



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeLSPNode"
void PRV_FreeLSPNode(LPLSPNODE lpNode)
{
	DPF(7, "Entering PRV_FreeLSPNode");

	if(!lpNode)
		return;

	if(lpNode->lpwszName)
		DPMEM_FREE(lpNode->lpwszName);
	if(lpNode->lpwszPath)
		DPMEM_FREE(lpNode->lpwszPath);
	if(lpNode->lpszDescA)
		DPMEM_FREE(lpNode->lpszDescA);
	if(lpNode->lpwszDesc)
		DPMEM_FREE(lpNode->lpwszDesc);
	DPMEM_FREE(lpNode);

} // PRV_FreeLSPNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeLSPList"
void PRV_FreeLSPList(LPLSPNODE lpLSPHead)
{
	LPLSPNODE	lpTemp;


	DPF(7, "Entering PRV_FreeLSPList");
	DPF(9, "Parameters: 0x%08x", lpLSPHead);
	
	// Walk the list and free each node
	while(lpLSPHead)
	{
		// Save the next one
		lpTemp = lpLSPHead->lpNext;
		
		// Free all of the members
		PRV_FreeLSPNode(lpLSPHead);

		// Move to the next one
		lpLSPHead = lpTemp;
	}

} // PRV_FreeLSPList



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddLSPNode"
HRESULT PRV_AddLSPNode(LPWSTR lpwszName, LPWSTR lpwszPath, LPWSTR lpwszDesc,
			LPSTR lpszDescA, LPWSTR lpwszGuid, DWORD dwReserved1,
			DWORD dwReserved2, DWORD dwNodeFlags)
{
	LPLSPNODE	lpLSPNode = NULL;
	DWORD		dwDescASize;
	HRESULT		hr;


	DPF(7, "Entering PRV_AddLSPNode");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu, %lu, 0x%08x",
			lpwszName, lpwszPath, lpwszDesc, lpszDescA, lpwszGuid, dwReserved1,
			dwReserved2, dwNodeFlags);


	// Allocate memory for the node
	lpLSPNode = DPMEM_ALLOC(sizeof(LSPNODE));
	if(!lpLSPNode)
	{
		DPF_ERR("Failed to allocate memory for Lobby Provider node, skipping LP");
		return DPERR_OUTOFMEMORY;
	}

	// Allocate memory for the Name string and copy it
	hr = GetString(&lpLSPNode->lpwszName, lpwszName);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to allocate memory for Lobby Provider Name string, skipping provider");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_ADDLSPNODE;
	}

	// Allocate memory for the Path string and copy it
	hr = GetString(&lpLSPNode->lpwszPath, lpwszPath);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to allocate memory for Lobby Provider Path string, skipping provider");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_ADDLSPNODE;
	}

	if(dwNodeFlags & LSPNODE_DESCRIPTION)
	{
		// Allocate memory for the DescriptionA string and copy it
		dwDescASize = lstrlenA(lpszDescA)+1;
		lpLSPNode->lpszDescA = DPMEM_ALLOC(dwDescASize);
		if(!lpLSPNode->lpszDescA)
		{
			DPF_ERR("Unable to allocate memory for Lobby Provider Path string, skipping provider");
			hr = DPERR_OUTOFMEMORY;
			goto ERROR_ADDLSPNODE;
		}
		memcpy(lpLSPNode->lpszDescA, lpszDescA, dwDescASize);

		// Allocate memory for the DescriptionW string and copy it
		hr = GetString(&lpLSPNode->lpwszDesc, lpwszDesc);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to allocate memory for Lobby Provider DescriptionW string, skipping provider");
			hr = DPERR_OUTOFMEMORY;
			goto ERROR_ADDLSPNODE;
		}
	}

	// Convert the string to a real GUID
	hr = GUIDFromString(lpwszGuid, &lpLSPNode->guid);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Invalid LP guid -- skipping LP, hr = 0x%08x", hr);
		goto ERROR_ADDLSPNODE;
	}

	// Finish setting up the node
	lpLSPNode->dwReserved1 = dwReserved1;
	lpLSPNode->dwReserved2 = dwReserved2;
	lpLSPNode->dwNodeFlags = dwNodeFlags;

	// Add the node to the list
	lpLSPNode->lpNext = glpLSPHead;
	glpLSPHead = lpLSPNode;

	return DP_OK;

ERROR_ADDLSPNODE:

	if(lpLSPNode->lpwszName)
		DPMEM_FREE(lpLSPNode->lpwszName);
	if(lpLSPNode->lpwszPath)
		DPMEM_FREE(lpLSPNode->lpwszPath);
	if(lpLSPNode->lpwszDesc)
		DPMEM_FREE(lpLSPNode->lpwszDesc);
	if(lpLSPNode->lpszDescA)
		DPMEM_FREE(lpLSPNode->lpszDescA);
	DPMEM_FREE(lpLSPNode);

	return hr;

} // PRV_AddLSPNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_BuildLSPList"
HRESULT PRV_BuildLSPList()
{
	HKEY		hkeyLobbySP, hkeySP;
	WCHAR		szSPName[DPLOBBY_REGISTRY_NAMELEN];
	WCHAR		szSPPath[DPLOBBY_REGISTRY_NAMELEN];
	WCHAR		szSPDescW[DPLOBBY_REGISTRY_NAMELEN];
	CHAR		szSPDescA[DPLOBBY_REGISTRY_NAMELEN];
	WCHAR		wszGuidStr[GUID_STRING_SIZE];
	DWORD		dwSize;
	DWORD		dwGuidStrSize = GUID_STRING_SIZE;
	DWORD		dwType = REG_SZ;
	DWORD		dwIndex = 0;
	DWORD		dwReserved1, dwReserved2, dwReservedSize;
	LONG		lReturn;
	DWORD		dwError;
	HRESULT		hr;
	DWORD		dwNodeFlags = 0;

												
	DPF(7, "Entering PRV_BuildLSPList");
	
	if(glpLSPHead)
	{
		return DP_OK;
	}

	// Open the DPLobby SP key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLOBBY_SP_KEY, 0,
								KEY_READ, &hkeyLobbySP);
	if(lReturn != ERROR_SUCCESS)
	{
		// This just means that the DPLobby SP key doesn't exist (most
		// likely), so in that case, there are no Lobby SP's to enumerate.
		return DP_OK;
	}

	// Walk the list of Lobby SP's in the registry, enumerating them
	while(1)
	{
		// Get the next LSP Name
		dwSize = sizeof(szSPName);
		lReturn = OS_RegEnumKeyEx(hkeyLobbySP, dwIndex++, szSPName,
					&dwSize, NULL, NULL, NULL, NULL);
		if(lReturn == ERROR_NO_MORE_ITEMS)
			break;
		else if(lReturn != ERROR_SUCCESS)
		{
			dwError = GetLastError();
			DPF_ERRVAL("Unable to get Lobby Provider name from the registry -- dwError = %u -- skipping provider", dwError);
			continue;
		}

		// Open the subkey
		lReturn = OS_RegOpenKeyEx(hkeyLobbySP, szSPName, 0, KEY_READ, &hkeySP);
		if(lReturn != ERROR_SUCCESS)
		{
			dwError = GetLastError();
			DPF_ERRVAL("Unable to open Lobby Provider key in the registry -- dwError = %u -- skipping provider", dwError);
			continue;
		}


		// First see if the "Private" key exists.  If it does, then set the flag
		// so that it will get skipped during enumeration
		lReturn = OS_RegQueryValueEx(hkeySP, SZ_PRIVATE, NULL, &dwType, NULL, &dwSize);
		if (ERROR_SUCCESS == lReturn) 
		{
			// The key exists, so set the flag so we don't enumerate it
			dwNodeFlags |= LSPNODE_PRIVATE;
		}


		// Get the LSP Path
		dwSize = sizeof(szSPPath);
		lReturn = OS_RegQueryValueEx(hkeySP, SZ_PATH, NULL, &dwType,
					(LPBYTE)&szSPPath, &dwSize);
		if(lReturn != ERROR_SUCCESS)
		{
			dwError = GetLastError();
			DPF_ERRVAL("Unable to get Lobby Provider path from the registry -- dwError = %u -- skipping provider", dwError);
			RegCloseKey(hkeySP);
			continue;
		}

		// Get the LSP Descriptions
		// If the DescriptionA value doesn't exist, then don't worry about
		// getting the DescriptionW value.  If the DescriptionA value exits,
		// but the DescriptionW value does not, convert the DescriptionA
		// value to Unicode and store it in DescriptionW.
		// NOTE: We always assume the DescriptionA value is an ANSI string,
		// even if it's stored in a Unicode format on NT & Memphis.  So we
		// always retrieve this as an ANSI string
		dwSize = sizeof(szSPDescA);
		lReturn = RegQueryValueExA(hkeySP, "DescriptionA", NULL, &dwType,
					(LPBYTE)&szSPDescA, &dwSize);
		if(lReturn == ERROR_SUCCESS)
		{
			// Save the description flag
			dwNodeFlags |= LSPNODE_DESCRIPTION;

			// Get the DescriptionW value
			dwSize = sizeof(szSPDescW);
			lReturn = OS_RegQueryValueEx(hkeySP, SZ_DESCRIPTIONW, NULL, &dwType,
						(LPBYTE)&szSPDescW, &dwSize);
			if(lReturn != ERROR_SUCCESS)
			{
				// Convert the ANSI Description string to Unicode and store it
				AnsiToWide(szSPDescW, szSPDescA, (lstrlenA(szSPDescA)+1));
			}
		}
		
		// Get the GUID of the LSP
		dwGuidStrSize = GUID_STRING_SIZE;
		lReturn = OS_RegQueryValueEx(hkeySP, SZ_GUID, NULL, &dwType,
					(LPBYTE)&wszGuidStr, &dwGuidStrSize);
		if(lReturn != ERROR_SUCCESS)
		{
			RegCloseKey(hkeySP);
			DPF_ERR("Unable to query GUID key value for Lobby Provider!");
			continue;
		}

		// Get the Reserved1 dword (we don't care if it fails)
		dwType = REG_DWORD;
		dwReservedSize = sizeof(DWORD);
		dwReserved1 = 0;
		OS_RegQueryValueEx(hkeySP, SZ_DWRESERVED1, NULL, &dwType,
			(LPBYTE)&dwReserved1, &dwReservedSize);
		
		// Get the Reserved1 dword (we don't care if it fails)
		dwReservedSize = sizeof(DWORD);
		dwReserved2 = 0;
		OS_RegQueryValueEx(hkeySP, SZ_DWRESERVED1, NULL, &dwType,
			(LPBYTE)&dwReserved2, &dwReservedSize);
		
		
		// Add the node to the list
		hr = PRV_AddLSPNode(szSPName, szSPPath, szSPDescW, szSPDescA,
				wszGuidStr, dwReserved1, dwReserved2, dwNodeFlags);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed adding Lobby Provider to internal list, hr = 0x%08x", hr);
		}

		// Close the SP key
		RegCloseKey(hkeySP);
	}

	// Close the Lobby SP key
	RegCloseKey(hkeyLobbySP);

	return DP_OK;

} // PRV_BuildLSPList



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_EnumConnections"
HRESULT PRV_EnumConnections(LPCGUID lpGuid, LPDPENUMCONNECTIONSCALLBACK lpCallback,
			LPVOID lpContext, DWORD dwFlags, BOOL bAnsi)
{
	LPLSPNODE					lpLSPNode, lpLSPHead;
	BOOL						bContinue = TRUE;
	DPNAME						name;
	HRESULT						hr = DP_OK;
	DPCOMPOUNDADDRESSELEMENT	AddrOnly;
	LPDPADDRESS					lpAddress = NULL;
	DWORD						dwAddressSize;
	DWORD						dwAddressSizeSave;
	LPWSTR						lpwszName = NULL;


	DPF(7, "Entering PRV_EnumConnections");
	DPF(9, "Parameters: ");

	// Rebuild the LSP List
	PRV_BuildLSPList();

	// If we don't have any entries, just bail here
	if(!glpLSPHead)
		return DP_OK;

	// Get a pointer to the first lobby provider, and store our head pointer
	lpLSPHead = glpLSPHead;
	lpLSPNode = glpLSPHead;

	// Setup the unfinished address
	memset(&AddrOnly, 0, sizeof(DPCOMPOUNDADDRESSELEMENT));
	AddrOnly.guidDataType = DPAID_LobbyProvider;
	AddrOnly.dwDataSize = sizeof(GUID);
	AddrOnly.lpData = &lpLSPNode->guid;

	// Calculate the size of the finished address
	hr = InternalCreateCompoundAddress(&AddrOnly, 1, NULL, &dwAddressSize);
	if(hr != DPERR_BUFFERTOOSMALL)
	{
		DPF_ERRVAL("Failed to retrieve the size of the output address buffer, hr = 0x%08x", hr);
		return hr;
	}

	// Allocate the buffer for the finished address
	lpAddress = DPMEM_ALLOC(dwAddressSize);
	if(!lpAddress)
	{
		DPF_ERR("Unable to allocate memory for temporary address structure");
		return DPERR_OUTOFMEMORY;
	}

	// Clear the DPNAME struct
	memset(&name,0,sizeof(name));
	name.dwSize = sizeof(name);
	
	// now, we have a list of SP's.  walk the list, and call the app back
	// run through what we found...
	dwAddressSizeSave = dwAddressSize;

	// Drop the locks
	LEAVE_ALL();

	while ((lpLSPNode) && (bContinue))
	{
		// If the private flag is set, don't enumerate it
		if(!(lpLSPNode->dwNodeFlags & LSPNODE_PRIVATE))
		{
			// Create the real DPADDRESS
			dwAddressSize = dwAddressSizeSave;
			AddrOnly.lpData = &lpLSPNode->guid;
			hr = InternalCreateCompoundAddress(&AddrOnly, 1, lpAddress,
					&dwAddressSize);
			if(SUCCEEDED(hr))
			{
				// Call the callback
				// If the caller is ANSI, convert the string
				if (bAnsi)
				{
					// If we have a description string, use it, and we already
					// have an ANSI version to use
					if(lpLSPNode->dwNodeFlags & LSPNODE_DESCRIPTION)
					{
						name.lpszShortNameA = lpLSPNode->lpszDescA;

						// Call the app's callback
						bContinue= lpCallback(&lpLSPNode->guid, lpAddress, dwAddressSize, &name,
									DPCONNECTION_DIRECTPLAYLOBBY, lpContext);
					}
					else
					{
						hr = GetAnsiString(&(name.lpszShortNameA), lpLSPNode->lpwszName);
						if(SUCCEEDED(hr))
						{
							// Call the app's callback
							bContinue= lpCallback(&lpLSPNode->guid, lpAddress, dwAddressSize, &name,
										DPCONNECTION_DIRECTPLAYLOBBY, lpContext);

							// Free our short name buffer
							DPMEM_FREE(name.lpszShortNameA);
						}
						else
						{
							DPF_ERR("Unable to allocate memory for temporary name string, skipping Connection");
						}
					}
				}
				else 
				{
					// If we have a description, use it
					if(lpLSPNode->dwNodeFlags & LSPNODE_DESCRIPTION)
						lpwszName = lpLSPNode->lpwszDesc;
					else
						lpwszName = lpLSPNode->lpwszName;

					name.lpszShortName = lpwszName;

					// Call the app's callback
					bContinue= lpCallback(&lpLSPNode->guid, lpAddress, dwAddressSize, &name,
								DPCONNECTION_DIRECTPLAYLOBBY, lpContext);
				}
			}
			else
			{
				DPF(2, "Failed to create DPADDRESS structure, skipping this Connection, hr = 0x%08x", hr);
			}
		}
				
		lpLSPNode = lpLSPNode->lpNext;

	} // while

	// Take the locks back
	ENTER_ALL();

	// Free our temporary address struct
	DPMEM_FREE(lpAddress);
	
	return DP_OK;	

} // PRV_EnumConnections





#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CallEnumLocalAppCallback"
HRESULT PRV_CallEnumLocalAppCallback(LPWSTR lpwszAppName, LPGUID lpguidApp,
				LPDPLENUMLOCALAPPLICATIONSCALLBACK lpfnEnumCallback,
				LPVOID lpContext, BOOL bAnsi, LPSTR lpszDescA,
				LPWSTR lpwszDescW)
{
	LPDPLAPPINFO	lpai = NULL;
	LPSTR			lpszAppName = NULL;
	BOOL			bReturn;


	DPF(7, "Entering PRV_CallEnumLocalAppCallback");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu, 0x%08x, 0x%08x",
			lpwszAppName, lpguidApp, lpfnEnumCallback, lpContext, bAnsi,
			lpszDescA, lpwszDescW);

	// Allocate memory for the AppInfo struct
	lpai = DPMEM_ALLOC(sizeof(DPLAPPINFO));
	if(!lpai)
	{
		DPF_ERR("Unable to allocate memory for AppInfo structure!");
		return DPERR_OUTOFMEMORY;
	}

	// Set the size
	lpai->dwSize = sizeof(DPLAPPINFO);

	// If the description strings exist, use them
	// NOTE: We can assume that if the DescriptionA string exists,
	// they both do.
	if(lpszDescA)
	{
		if(bAnsi)
			lpai->lpszAppNameA = lpszDescA;
		else
			lpai->lpszAppName = lpwszDescW;
	}
	else
	{
		// If we're ANSI, convert the string
		if(bAnsi)
		{
			if(FAILED(GetAnsiString(&lpszAppName, lpwszAppName)))
			{
				DPMEM_FREE(lpai);
				DPF_ERR("Unable to allocate memory for temporary string!");
				return DPERR_OUTOFMEMORY;
			}

			lpai->lpszAppNameA = lpszAppName;
		}
		else
		{
			lpai->lpszAppName = lpwszAppName;
		}
	}

	// Set the GUID
	lpai->guidApplication = *lpguidApp;

	// Call the callback
	bReturn = ((LPDPLENUMLOCALAPPLICATIONSCALLBACK)lpfnEnumCallback)
				(lpai, lpContext, 0L);

	// Free all of our memory
	if(lpszAppName)
		DPMEM_FREE(lpszAppName);
	DPMEM_FREE(lpai);

	// Set our HRESULT return value
	if(bReturn)
		return DP_OK;
	else
		return DPLOBBYPR_CALLBACKSTOP;

} // PRV_CallEnumLocalAppCallback


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_EnumLocalApplications"
HRESULT PRV_EnumLocalApplications(LPDIRECTPLAYLOBBY lpDPL,
				LPDPLENUMLOCALAPPLICATIONSCALLBACK lpfnEnumCallback,
				LPVOID lpContext, DWORD dwFlags, BOOL bAnsi)
{
    LPDPLOBBYI_DPLOBJECT	this;
    HRESULT					hr = DP_OK;
	HKEY					hkeyDPApps, hkeyApp;
	WCHAR					wszAppName[DPLOBBY_REGISTRY_NAMELEN];
	DWORD					dwIndex = 0;
	DWORD					dwNameSize;
	WCHAR					wszGuidStr[GUID_STRING_SIZE];
	DWORD					dwGuidStrSize = sizeof(wszGuidStr);
	DWORD					dwType = REG_SZ;
	GUID					guidApp;
	LONG					lReturn;
	CHAR					szDescA[DPLOBBY_REGISTRY_NAMELEN];
	WCHAR					wszDescW[DPLOBBY_REGISTRY_NAMELEN];
	DWORD					dwDescSize;
	BOOL					bDesc = FALSE;
	LPSTR					lpszDescA = NULL;
	LPWSTR					lpwszDescW = NULL;


	DPF(7, "Entering PRV_EnumLocalApplications");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu",
			lpDPL, lpfnEnumCallback, lpContext, dwFlags, bAnsi);

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            return DPERR_INVALIDOBJECT;
        }
        
        if( !VALIDEX_CODE_PTR( lpfnEnumCallback ) )
        {
            return DPERR_INVALIDPARAMS;
        }

		if( dwFlags )
		{
			return DPERR_INVALIDPARAMS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Open the Applications key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY, 0,
								KEY_READ, &hkeyDPApps);
	if(lReturn != ERROR_SUCCESS)
	{
		// This just means that the application key doesn't exist (most
		// likely), so in that case, there are no apps to enumerate.
		return DP_OK;
	}


	// Walk the list of DPlay games in the registry, enumerating them
	while(1)
	{
		// Reset the pointers and the flag
		lpszDescA = NULL;
		lpwszDescW = NULL;
		bDesc = FALSE;

		// Get the next app in the list
		dwNameSize = DPLOBBY_REGISTRY_NAMELEN;
		lReturn = OS_RegEnumKeyEx(hkeyDPApps, dwIndex++, (LPWSTR)&wszAppName,
						&dwNameSize, NULL, NULL, NULL, NULL);

		// If lReturn is ERROR_NO_MORE_ITEMS, we want this to be the last iteration
		if(lReturn == ERROR_NO_MORE_ITEMS)
			break;

		// Open the app key
		lReturn = OS_RegOpenKeyEx(hkeyDPApps, (LPWSTR)wszAppName, 0,
									KEY_READ, &hkeyApp);
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERR("Unable to open app key!");
			continue;
		}

		// Get the GUID of the Game
		dwGuidStrSize = GUID_STRING_SIZE;
		lReturn = OS_RegQueryValueEx(hkeyApp, SZ_GUID, NULL, &dwType,
									(LPBYTE)&wszGuidStr, &dwGuidStrSize);
		if(lReturn != ERROR_SUCCESS)
		{
			RegCloseKey(hkeyApp);
			DPF_ERR("Unable to query GUID key value!");
			continue;
		}

		// Convert the string to a real GUID
		hr = GUIDFromString(wszGuidStr, &guidApp);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Invalid game guid -- skipping game, hr = 0x%08x", hr);
			RegCloseKey(hkeyApp);
			// Set the hresult back to DP_OK in case this is the last
			// application in the registry -- we want the method call
			// to succeed if we got this far, we just don't want to
			// call the callback for this particular application
			hr = DP_OK;
			continue;
		}

		// Get the Description strings
		dwDescSize = sizeof(szDescA);
		lReturn = RegQueryValueExA(hkeyApp, "DescriptionA", NULL, &dwType,
					(LPBYTE)szDescA, &dwDescSize);
		if(lReturn != ERROR_SUCCESS) 
		{
			DPF(5,"Could not read Description lReturn = %d\n",lReturn);
			// it's ok if the app doesn't have one of these...
		}
		else
		{
			DPF(5,"Got DescriptionA = %s\n",szDescA);
			
			// Set our description flag
			bDesc = TRUE;

			// Now try to get the DescriptionW string if one exists.  If for some
			// reason a DescriptionW string exists, but the DescriptionA does not,
			// we pretend the DescriptionW string doesn't exist either.
			// NOTE: We always assume the DescriptionW string is a Unicode string,
			// even on Win95.  On Win95, this will be of the type REG_BINARY, but
			// it is really just a Unicode string.
			dwDescSize = sizeof(wszDescW);
			lReturn = OS_RegQueryValueEx(hkeyApp, SZ_DESCRIPTIONW, NULL,
						&dwType, (LPBYTE)wszDescW, &dwDescSize);
			if(lReturn != ERROR_SUCCESS) 
			{
				DPF(5,"Could not get DescriptionW, converting DescriptionA");

				// We couldn't get DescriptionW, so convert DescriptionA...
				AnsiToWide(wszDescW,szDescA,(lstrlenA(szDescA)+1));
			}
			else
			{
				DPF(5,"Got DescriptionW = %ls\n",wszDescW);
			}

		}

		// Close the App key
		RegCloseKey(hkeyApp);

		// Setup the description pointers if they are valid
		if(bDesc)
		{
			lpszDescA = (LPSTR)&szDescA;
			lpwszDescW = (LPWSTR)&wszDescW;
		}

		// Call the callback
		hr = PRV_CallEnumLocalAppCallback(wszAppName, &guidApp,
						lpfnEnumCallback, lpContext, bAnsi,
						lpszDescA, lpwszDescW);

		if(hr == DPLOBBYPR_CALLBACKSTOP)
		{
			hr = DP_OK;
			break;
		}
		else
		{
			if(FAILED(hr))
				break;
			else
				continue;
		}
	}

	// Close the DPlay Apps key
	RegCloseKey(hkeyDPApps);
	dwNameSize = DPLOBBY_REGISTRY_NAMELEN;

	return hr;

} // PRV_EnumLocalApplications


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_EnumLocalApplications"
HRESULT DPLAPI DPL_EnumLocalApplications(LPDIRECTPLAYLOBBY lpDPL,
				LPDPLENUMLOCALAPPLICATIONSCALLBACK lpfnEnumCallback,
				LPVOID lpContext, DWORD dwFlags)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_EnumLocalApplications");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, lpfnEnumCallback, lpContext, dwFlags);

	ENTER_DPLOBBY();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_EnumLocalApplications(lpDPL, lpfnEnumCallback, lpContext,
								dwFlags, FALSE);

	LEAVE_DPLOBBY();

	return hr;

} // DPL_EnumLocalApplications
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\dplobbya.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobbya.c
 *  Content:	ANSI Methods for IDirectPlayLobby
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	5/24/96		myronth	Created it
 *	9/09/96		kipo	Pass UNICODE IDirectPlayLobby interface to
 *						DPL_Connect() instead of ANSI interface. Bug #3790.
 *	10/23/96	myronth	Added client/server methods
 *	12/12/96	myronth	Fixed DPLCONNECTION validation
 *	2/12/97		myronth	Mass DX5 changes
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	5/8/97		myronth	Get/SetGroupConnectionSettings, removed dead code
 *	9/29/97		myronth	Fixed DPLCONNECTION package size bug (#12475)
 *	11/5/97		myronth	Fixed locking macro
 *	11/13/97	myronth	Added stop async check for asynchronous Connect (#12541)
 *	12/2/97		myronth	Added DPL_A_RegisterApplication
 *	12/3/97		myronth	Changed DPCONNECT flag to DPCONNECT_RETURNSTATUS (#15451)
 *	6/25/98		a-peterz Added DPL_A_ConnectEx
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_Connect"
HRESULT DPLAPI DPL_A_Connect(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
				LPDIRECTPLAY2 * lplpDP2A, IUnknown FAR * lpUnk)
{
	HRESULT			hr;
	LPDIRECTPLAY2	lpDP2;
	LPDIRECTPLAYLOBBY	lpDPLW;


	DPF(7, "Entering DPL_A_Connect");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lplpDP2A, lpUnk);

    ENTER_DPLOBBY();

	TRY
	{
		if( !VALID_WRITE_PTR( lplpDP2A, sizeof(LPDIRECTPLAY2 *) ) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDPARAMS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	LEAVE_DPLOBBY();

	// QueryInterface for the UNICODE DirectPlayLobby interface
	hr = lpDPL->lpVtbl->QueryInterface(lpDPL, &IID_IDirectPlayLobby, &lpDPLW);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to QueryInterface for the UNICODE DirectPlayLobby interface");
		return (hr);
	}

	// Use the UNICODE IDirectPlayLobby interface (fixes bug #3790)
	hr = DPL_Connect(lpDPLW, dwFlags, &lpDP2, lpUnk);

	// release UNICODE IDirectPlayLobby interface
	lpDPLW->lpVtbl->Release(lpDPLW);
	lpDPLW = NULL;

	if(SUCCEEDED(hr))
	{
		ENTER_DPLOBBY();

		// QueryInterface for the ANSI interface
		hr = lpDP2->lpVtbl->QueryInterface(lpDP2, &IID_IDirectPlay2A, lplpDP2A);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to QueryInterface for the ANSI DirectPlay interface");
		}

		// Release the Unicode interface
		lpDP2->lpVtbl->Release(lpDP2);

		LEAVE_DPLOBBY();
	}

	return hr;

} // DPL_A_Connect



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_ConnectEx"
HRESULT DPLAPI DPL_A_ConnectEx(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
				REFIID riid, LPVOID * ppvObj, IUnknown FAR * lpUnk)
{
	LPDIRECTPLAY2		lpDP2A = NULL;
	HRESULT				hr;


	DPF(7, "Entering DPL_A_ConnectEx");
	DPF(9, "Parameters: 0x%08x, 0x%08x, iid, 0x%08x, 0x%08x",
			lpDPL, dwFlags, ppvObj, lpUnk);


	hr = DPL_A_Connect(lpDPL, dwFlags, &lpDP2A, lpUnk);
	if(SUCCEEDED(hr))
	{
		hr = DP_QueryInterface((LPDIRECTPLAY)lpDP2A, riid, ppvObj);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed calling QueryInterface, hr = 0x%08x", hr);
		}

		// Release the DP2 object
		DP_Release((LPDIRECTPLAY)lpDP2A);
	}

	return hr;

} // DPL_A_ConnectEx



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_EnumLocalApplications"
HRESULT DPLAPI DPL_A_EnumLocalApplications(LPDIRECTPLAYLOBBY lpDPL,
					LPDPLENUMLOCALAPPLICATIONSCALLBACK lpCallback,
					LPVOID lpContext, DWORD dwFlags)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_A_EnumLocalApplications");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, lpCallback, lpContext, dwFlags);

    ENTER_DPLOBBY();
    
	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_EnumLocalApplications(lpDPL, lpCallback, lpContext,
								dwFlags, TRUE);
	LEAVE_DPLOBBY();
	return hr;

} // DPL_A_EnumLocalApplications



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_GetConnectionSettings"
HRESULT DPLAPI DPL_A_GetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL,
					DWORD dwGameID, LPVOID lpData, LPDWORD lpdwSize)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_A_GetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwGameID, lpData, lpdwSize);

    ENTER_DPLOBBY();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_GetConnectionSettings(lpDPL, dwGameID, lpData,
									lpdwSize, TRUE);

	LEAVE_DPLOBBY();
	return hr;

} // DPL_A_GetConnectionSettings


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_GetGroupConnectionSettings"
HRESULT DPLAPI DPL_A_GetGroupConnectionSettings(LPDIRECTPLAY lpDP,
		DWORD dwFlags, DPID idGroup, LPVOID lpData, LPDWORD lpdwSize)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_A_GetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, idGroup, lpData, lpdwSize);

	ENTER_LOBBY_ALL();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_GetGroupConnectionSettings(lpDP, dwFlags, idGroup,
							lpData, lpdwSize);
	if(SUCCEEDED(hr))
	{
		// Now convert the DPLCONNECTION to ANSI in place
		hr = PRV_ConvertDPLCONNECTIONToAnsiInPlace((LPDPLCONNECTION)lpData,
				lpdwSize, 0);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed converting DPLCONNECTION struct to ANSI, hr = 0x%08x", hr);
		}
	}

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_A_GetGroupConnectionSettings


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_RegisterApplication"
HRESULT DPLAPI DPL_A_RegisterApplication(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, LPVOID lpvDesc)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPAPPLICATIONDESC		lpDescW = NULL;
	HRESULT					hr = DP_OK;
	LPDPAPPLICATIONDESC 	lpDesc=(LPDPAPPLICATIONDESC)lpvDesc;
	
	DPF(7, "Entering DPL_A_RegisterApplication");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lpDesc);

	ENTER_DPLOBBY();

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDOBJECT;
		}

		if(dwFlags)
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}

		// Validate the ApplicationDesc struct
		hr = PRV_ValidateDPAPPLICATIONDESC(lpDesc, TRUE);
		if(FAILED(hr))
		{
			LEAVE_DPLOBBY();
			DPF_ERR("Invalid DPAPPLICATIONDESC structure");
			return hr;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	// If we're on an ANSI platform, just write the stuff in the registry.
	// If it's not, we need to convert the DPAPPLICATIONDESC struct to Unicode
	if(OS_IsPlatformUnicode())
	{
		// Convert the APPDESC struct to Unicode
		hr = PRV_ConvertDPAPPLICATIONDESCToUnicode(lpDesc, &lpDescW);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to convert DPAPPLICATIONDESC to Unicode, hr = 0x%08x", hr);
			goto ERROR_REGISTERAPPLICATION;
		}

		// Write to the registry
		hr = PRV_WriteAppDescInRegistryUnicode(lpDescW);

		// Free our APPDESC structure
		PRV_FreeLocalDPAPPLICATIONDESC(lpDescW);
	}
	else
	{
		// Just write to the registry
		hr = PRV_WriteAppDescInRegistryAnsi(lpDesc);
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed writing ApplicationDesc to registry, hr = 0x%08x", hr);
	}

ERROR_REGISTERAPPLICATION:

	LEAVE_DPLOBBY();
	return hr;

} // DPL_A_RegisterApplication



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeInternalDPLCONNECTION"
void PRV_FreeInternalDPLCONNECTION(LPDPLCONNECTION lpConn)
{
	LPDPSESSIONDESC2	lpsd;
	LPDPNAME			lpn;


	DPF(7, "Entering PRV_FreeInternalDPLCONNECTION");
	DPF(9, "Parameters: 0x%08x", lpConn);

	if(!lpConn)
		return;

	if(lpConn->lpSessionDesc)
	{
		lpsd = lpConn->lpSessionDesc;
		if(lpsd->lpszSessionName)
			DPMEM_FREE(lpsd->lpszSessionName);
		if(lpsd->lpszPassword)
			DPMEM_FREE(lpsd->lpszPassword);
		DPMEM_FREE(lpsd);
	}

	if(lpConn->lpPlayerName)
	{
		lpn = lpConn->lpPlayerName;
		if(lpn->lpszShortName)
			DPMEM_FREE(lpn->lpszShortName);
		if(lpn->lpszLongName)
			DPMEM_FREE(lpn->lpszLongName);
		DPMEM_FREE(lpn);
	}

	DPMEM_FREE(lpConn);

} // PRV_FreeInternalDPLCONNECTION


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_RunApplication"
HRESULT DPLAPI DPL_A_RunApplication(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
							LPDWORD lpdwGameID, LPDPLCONNECTION lpConnA,
							HANDLE hReceiveEvent)
{
	LPDPLCONNECTION	lpConnW = NULL;
	HRESULT			hr;


	DPF(7, "Entering DPL_A_RunApplication");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lpdwGameID, lpConnA, hReceiveEvent);

    ENTER_DPLOBBY();

	
	// Validate the DPLCONNECTION structure and it's members
	hr = PRV_ValidateDPLCONNECTION(lpConnA, TRUE);
	if(FAILED(hr))
	{
		LEAVE_DPLOBBY();
		return hr;
	}

	// Convert the ANSI DPLCONNECTION structure to Unicode
	hr = PRV_ConvertDPLCONNECTIONToUnicode(lpConnA, &lpConnW);
	if(FAILED(hr))
	{
		DPF_ERR("Failed to convert ANSI DPLCONNECTION structure to Unicode (temp)");
		LEAVE_DPLOBBY();
		return hr;
	}

	LEAVE_DPLOBBY();
	hr = DPL_RunApplication(lpDPL, dwFlags, lpdwGameID, lpConnW,
							hReceiveEvent);
	ENTER_DPLOBBY();

	// Free our temporary Unicode DPLCONNECTION structure
	PRV_FreeInternalDPLCONNECTION(lpConnW);

	LEAVE_DPLOBBY();
	return hr;

} // DPL_A_RunApplication



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_SetConnectionSettings"
HRESULT DPLAPI DPL_A_SetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL,
						DWORD dwFlags, DWORD dwGameID,
						LPDPLCONNECTION lpConnA)
{
	HRESULT			hr;
	LPDPLCONNECTION	lpConnW = NULL;


	DPF(7, "Entering DPL_A_SetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, dwGameID, lpConnA);

    ENTER_DPLOBBY();

	// Validate the DPLCONNECTION structure and it's members
	hr = PRV_ValidateDPLCONNECTION(lpConnA, TRUE);
	if(FAILED(hr))
	{
		LEAVE_DPLOBBY();
		return hr;
	}

	// Conver the ANSI DPLCONNECTION struct to Unicode
	hr = PRV_ConvertDPLCONNECTIONToUnicode(lpConnA, &lpConnW);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to convert DPLCONNECTION structure to Unicode");
		LEAVE_DPLOBBY();
		return hr;
	}

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_SetConnectionSettings(lpDPL, dwFlags, dwGameID, lpConnW);

	// Free our temporary Unicode DPLCONNECTION structure
	PRV_FreeInternalDPLCONNECTION(lpConnW);

	LEAVE_DPLOBBY();
	return hr;

} // DPL_A_SetConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_SetGroupConnectionSettings"
HRESULT DPLAPI DPL_A_SetGroupConnectionSettings(LPDIRECTPLAY lpDP,
						DWORD dwFlags, DPID idGroup,
						LPDPLCONNECTION lpConnA)
{
	HRESULT			hr;
	LPDPLCONNECTION	lpConnW = NULL;


	DPF(7, "Entering DPL_A_SetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, idGroup, lpConnA);

	ENTER_LOBBY_ALL();

	// Validate the DPLCONNECTION structure and it's members
	hr = PRV_ValidateDPLCONNECTION(lpConnA, TRUE);
	if(FAILED(hr))
	{
		LEAVE_LOBBY_ALL();
		return hr;
	}

	// Conver the ANSI DPLCONNECTION struct to Unicode
	hr = PRV_ConvertDPLCONNECTIONToUnicode(lpConnA, &lpConnW);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to convert DPLCONNECTION structure to Unicode");
		LEAVE_LOBBY_ALL();
		return hr;
	}

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_SetGroupConnectionSettings(lpDP, dwFlags, idGroup,
										lpConnW, TRUE);

	// Free our temporary Unicode DPLCONNECTION structure
	PRV_FreeInternalDPLCONNECTION(lpConnW);

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_A_SetGroupConnectionSettings
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\dpneed.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpneed.h
 *  Content:	Private definitions needed by DPlay to build
 *
 *  History:
 *	Date	By		Reason
 *	======	=======	======
 *	6/16/96	myronth	Created it
 *	11/5/97	myronth	Added LOBBY_ALL macros
 ***************************************************************************/
#ifndef __DPNEED_INCLUDED__
#define __DPNEED_INCLUDED__

#define INIT_DPLOBBY_CSECT() InitializeCriticalSection(gpcsDPLCritSection);
#define FINI_DPLOBBY_CSECT() DeleteCriticalSection(gpcsDPLCritSection);
#define ENTER_DPLOBBY() EnterCriticalSection(gpcsDPLCritSection);
#define LEAVE_DPLOBBY() LeaveCriticalSection(gpcsDPLCritSection);

#define ENTER_LOBBY_ALL() ENTER_DPLAY(); ENTER_DPLOBBY();
#define LEAVE_LOBBY_ALL() LEAVE_DPLOBBY(); LEAVE_DPLAY();

#define INIT_DPLQUEUE_CSECT() InitializeCriticalSection(gpcsDPLQueueCritSection);
#define FINI_DPLQUEUE_CSECT() DeleteCriticalSection(gpcsDPLQueueCritSection);
#define ENTER_DPLQUEUE() EnterCriticalSection(gpcsDPLQueueCritSection);
#define LEAVE_DPLQUEUE() LeaveCriticalSection(gpcsDPLQueueCritSection);

#define INIT_DPLGAMENODE_CSECT() InitializeCriticalSection(gpcsDPLGameNodeCritSection);
#define FINI_DPLGAMENODE_CSECT() DeleteCriticalSection(gpcsDPLGameNodeCritSection);
#define ENTER_DPLGAMENODE() EnterCriticalSection(gpcsDPLGameNodeCritSection);
#define LEAVE_DPLGAMENODE() LeaveCriticalSection(gpcsDPLGameNodeCritSection);

#endif // __DPNEED_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\dplshare.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplshare.c
 *  Content:	Methods for shared buffer management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	5/18/96		myronth	Created it
 *	12/12/96	myronth	Fixed DPLCONNECTION validation & bug #4692
 *	12/13/96	myronth	Fixed bugs #4697 and #4607
 *	2/12/97		myronth	Mass DX5 changes
 *	2/20/97		myronth	Changed buffer R/W to be circular
 *	3/12/97		myronth	Kill thread timeout, DPF error levels
 *	4/1/97		myronth	Fixed handle leak -- bug #7054
 *	5/8/97		myronth	Added bHeader parameter to packing function
 *  5/21/97		ajayj	DPL_SendLobbyMessage - allow DPLMSG_STANDARD flag #8929
 *	5/30/97		myronth	Fixed SetConnectionSettings for invalid AppID (#9110)
 *						Fixed SetLobbyMessageEvent for invalid handle (#9111)
 *	6/19/97		myronth	Fixed handle leak (#10063)
 *	7/30/97		myronth	Added support for standard lobby messaging and
 *						fixed receive loop race condition (#10843)
 *	8/11/97		myronth	Added guidInstance handling in standard lobby requests
 *	8/19/97		myronth	Support for DPLMSG_NEWSESSIONHOST
 *	8/19/97		myronth	Removed dead PRV_SendStandardSystemMessageByObject
 *	8/20/97		myronth	Added DPLMSG_STANDARD to all standard messages
 *	11/13/97	myronth	Added guidInstance to lobby system message (#10944)
 *	12/2/97		myronth	Fixed swallowed error code, moved structure
 *						validation for DPLCONNECTION (#15527, 15529)
 *	1/20/98		myronth	Added WaitForConnectionSettings
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *	10/31/99	aarono add node lock when to SetLobbyMessageEvent
 *			       NTB#411892
 ***************************************************************************/
#include "dplobpr.h"

//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------

#define MAX_APPDATABUFFERSIZE		(65535)
#define APPDATA_RESERVEDSIZE		(2 * sizeof(DWORD))


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------

HRESULT PRV_ReadCommandLineIPCGuid(GUID *lpguidIPC)
{
	LPWSTR  pwszCommandLine;
	LPWSTR  pwszAlloc=NULL;
	LPWSTR  pwszSwitch=NULL;
	HRESULT hr=DP_OK;
	
	if(!OS_IsPlatformUnicode()){
		// if we get a command line in ANSI, convert to UNICODE, this allows
		// us to avoid the DBCS issues in ANSI while scanning for the IPC GUID
		LPSTR pszCommandLine;
		pszCommandLine=(LPSTR)GetCommandLineA();
		pwszAlloc=DPMEM_ALLOC(MAX_PATH*sizeof(WCHAR));
		if(pwszAlloc){
			hr=AnsiToWide(pwszAlloc,pszCommandLine,MAX_PATH);
			if(FAILED(hr)){
				goto exit;
			}
			pwszCommandLine=pwszAlloc;
		}
	} else {
		pwszCommandLine=(LPWSTR)GetCommandLine(); 
	}

	// pwszCommandLine now points to the UNICODE command line.
	if(pwszSwitch=OS_StrStr(pwszCommandLine,SZ_DP_IPC_GUID)){
		// found the GUID on the command line
		if (OS_StrLen(pwszSwitch) >= (sizeof(SZ_DP_IPC_GUID)+sizeof(SZ_GUID_PROTOTYPE)-sizeof(WCHAR))/sizeof(WCHAR)){
			// skip past the switch description to the actual GUID and extract
			hr=GUIDFromString(pwszSwitch+(sizeof(SZ_DP_IPC_GUID)/sizeof(WCHAR))-1, lpguidIPC);
		} else {
			hr=DPERR_GENERIC;
		}
	} else {
		hr=DPERR_GENERIC;
	}


exit:

	if(pwszAlloc){
		DPMEM_FREE(pwszAlloc);
	}
	
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetInternalName"
HRESULT PRV_GetInternalName(LPDPLOBBYI_GAMENODE lpgn, DWORD dwType, LPWSTR lpName)
{
	DWORD	pid;
	LPWSTR	lpFileName;
	LPSTR	lpstr1, lpstr2, lpstr3;
	char	szName[256];
	BOOL    bUseGuid=FALSE;


	DPF(7, "Entering PRV_GetInternalName");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x", lpgn, dwType, lpName);


	if(lpgn->dwFlags & GN_IPCGUID_SET){
		bUseGuid=TRUE;
	}
	// Get the current process ID if we are a game, otherwise, we need to
	// get the process ID of the game that we spawned
	else if(lpgn->dwFlags & GN_LOBBY_CLIENT)
	{
		if(lpgn->dwGameProcessID)
			pid = lpgn->dwGameProcessID;
		else
			return DPERR_APPNOTSTARTED;
	}
	else
	{
		pid = GetCurrentProcessId();
	}

	switch(dwType)
	{
		case TYPE_CONNECT_DATA_FILE:
			lpFileName = SZ_CONNECT_DATA_FILE;
			break;

		case TYPE_CONNECT_DATA_MUTEX:
			lpFileName = SZ_CONNECT_DATA_MUTEX;
			break;

		case TYPE_GAME_WRITE_FILE:
			lpFileName = SZ_GAME_WRITE_FILE;
			break;

		case TYPE_LOBBY_WRITE_FILE:
			lpFileName = SZ_LOBBY_WRITE_FILE;
			break;

		case TYPE_LOBBY_WRITE_EVENT:
			lpFileName = SZ_LOBBY_WRITE_EVENT;
			break;

		case TYPE_GAME_WRITE_EVENT:
			lpFileName = SZ_GAME_WRITE_EVENT;
			break;

		case TYPE_LOBBY_WRITE_MUTEX:
			lpFileName = SZ_LOBBY_WRITE_MUTEX;
			break;

		case TYPE_GAME_WRITE_MUTEX:
			lpFileName = SZ_GAME_WRITE_MUTEX;
			break;

		default:
			DPF(2, "We got an Internal Name Type that we didn't expect!");
			return DPERR_GENERIC;
	}

	GetAnsiString(&lpstr2, SZ_FILENAME_BASE);
	GetAnsiString(&lpstr3, lpFileName);

	if(!bUseGuid){
		// REVIEW!!!! -- I can't get the Unicode version of wsprintf to work, so
		// for now, use the ANSI version and convert
		//	wsprintf(lpName, SZ_NAME_TEMPLATE, SZ_FILENAME_BASE, lpFileName, pid);
		GetAnsiString(&lpstr1, SZ_NAME_TEMPLATE);
		wsprintfA((LPSTR)szName, lpstr1, lpstr2, lpstr3, pid);
	} else {
		GetAnsiString(&lpstr1, SZ_GUID_NAME_TEMPLATE);
		wsprintfA((LPSTR)szName, lpstr1, lpstr2, lpstr3);
	}

	AnsiToWide(lpName, szName, (strlen(szName) + 1));

	if(bUseGuid){
		// concatenate the guid to the name if we are using the guid.
		WCHAR *pGuid;
		pGuid = lpName + WSTRLEN(lpName) - 1;
		StringFromGUID(&lpgn->guidIPC, pGuid, GUID_STRING_SIZE);
	}

	if(lpstr1)
		DPMEM_FREE(lpstr1);
	if(lpstr2)
		DPMEM_FREE(lpstr2);
	if(lpstr3)
		DPMEM_FREE(lpstr3);

	return DP_OK;

} // PRV_GetInternalName



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddNewGameNode"
HRESULT PRV_AddNewGameNode(LPDPLOBBYI_DPLOBJECT this,
				LPDPLOBBYI_GAMENODE * lplpgn, DWORD dwGameID,
				HANDLE hGameProcess, BOOL bLobbyClient, GUID *lpguidIPC)
{
	LPDPLOBBYI_GAMENODE	lpgn;


	DPF(7, "Entering PRV_AddNewGameNode");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu",
			this, lplpgn, dwGameID, hGameProcess, bLobbyClient);

	lpgn = DPMEM_ALLOC(sizeof(DPLOBBYI_GAMENODE));
	if(!lpgn)
	{
		DPF(2, "Unable to allocate memory for GameNode structure!");
		return DPERR_OUTOFMEMORY;
	}

	// Initialize the GameNode
	lpgn->dwSize = sizeof(DPLOBBYI_GAMENODE);
	lpgn->dwGameProcessID = dwGameID;
	lpgn->hGameProcess = hGameProcess;
	lpgn->this = this;
	lpgn->MessageHead.lpPrev = &lpgn->MessageHead;
	lpgn->MessageHead.lpNext = &lpgn->MessageHead;

	if(lpguidIPC){
		// provided during launch by lobby client
		lpgn->guidIPC=*lpguidIPC;
		lpgn->dwFlags |= GN_IPCGUID_SET;
	} else {
		// need to extract the GUID from the command line if present.
		if(DP_OK==PRV_ReadCommandLineIPCGuid(&lpgn->guidIPC)){
			lpgn->dwFlags |= GN_IPCGUID_SET;
		}
	}

	// If we are a lobby client, set the flag
	if(bLobbyClient)
		lpgn->dwFlags |= GN_LOBBY_CLIENT;
	
	// Add the GameNode to the list
	lpgn->lpgnNext = this->lpgnHead;
	this->lpgnHead = lpgn;

	// Set the output pointer
	*lplpgn = lpgn;

	return DP_OK;

} // PRV_AddNewGameNode


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetGameNode"
LPDPLOBBYI_GAMENODE PRV_GetGameNode(LPDPLOBBYI_GAMENODE lpgnHead, DWORD dwGameID)
{
	LPDPLOBBYI_GAMENODE	lpgnTemp = lpgnHead;
	GUID guidIPC=GUID_NULL;
	BOOL bFoundGUID;

	DPF(7, "Entering PRV_GetGameNode");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpgnHead, dwGameID);

	if(DP_OK==PRV_ReadCommandLineIPCGuid(&guidIPC)){
		bFoundGUID=TRUE;
	} else {
		bFoundGUID=FALSE;
	}

	while(lpgnTemp)
	{
		if((lpgnTemp->dwGameProcessID == dwGameID) || 
		   ((bFoundGUID) && (lpgnTemp->dwFlags & GN_IPCGUID_SET) && (IsEqualGUID(&lpgnTemp->guidIPC,&guidIPC))))
			return lpgnTemp;
		else
			lpgnTemp = lpgnTemp->lpgnNext;
	}

	return NULL;

} // PRV_GetGameNode


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetupClientDataAccess"
BOOL PRV_SetupClientDataAccess(LPDPLOBBYI_GAMENODE lpgn)
{
	SECURITY_ATTRIBUTES		sa;
	HANDLE					hConnDataMutex = NULL;
	HANDLE					hLobbyWrite = NULL;
	HANDLE					hLobbyWriteMutex = NULL;
	HANDLE					hGameWrite = NULL;
	HANDLE					hGameWriteMutex = NULL;
	WCHAR					szName[MAX_MMFILENAME_LENGTH * sizeof(WCHAR)];


	DPF(7, "Entering PRV_SetupClientDataAccess");
	DPF(9, "Parameters: 0x%08x", lpgn);

	// Set up the security attributes (so that our objects can
	// be inheritable)
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;

	// Create the ConnectionData Mutex
	if(SUCCEEDED(PRV_GetInternalName(lpgn, TYPE_CONNECT_DATA_MUTEX,
								(LPWSTR)&szName)))
	{
		hConnDataMutex = OS_CreateMutex(&sa, FALSE, (LPWSTR)&szName);
	}

	// Create the GameWrite Event
	if(SUCCEEDED(PRV_GetInternalName(lpgn, TYPE_GAME_WRITE_EVENT, (LPWSTR)&szName)))
	{
		hGameWrite = OS_CreateEvent(&sa, FALSE, FALSE, (LPWSTR)&szName);
	}

	// Create the GameWrite Mutex
	if(SUCCEEDED(PRV_GetInternalName(lpgn, TYPE_GAME_WRITE_MUTEX,
								(LPWSTR)&szName)))
	{
		hGameWriteMutex = OS_CreateMutex(&sa, FALSE, (LPWSTR)&szName);
	}

	// Create the LobbyWrite Event
	if(SUCCEEDED(PRV_GetInternalName(lpgn, TYPE_LOBBY_WRITE_EVENT, (LPWSTR)&szName)))
	{
		hLobbyWrite = OS_CreateEvent(&sa, FALSE, FALSE, (LPWSTR)&szName);
	}

	// Create the LobbyWrite Mutex
	if(SUCCEEDED(PRV_GetInternalName(lpgn, TYPE_LOBBY_WRITE_MUTEX,
								(LPWSTR)&szName)))
	{
		hLobbyWriteMutex = OS_CreateMutex(&sa, FALSE, (LPWSTR)&szName);
	}


	// Check for errors
	if(!hConnDataMutex || !hGameWrite || !hGameWriteMutex
			|| !hLobbyWrite || !hLobbyWriteMutex)
	{
		if(hConnDataMutex)
			CloseHandle(hConnDataMutex);
		if(hGameWrite)
			CloseHandle(hGameWrite);
		if(hGameWriteMutex)
			CloseHandle(hGameWriteMutex);
		if(hLobbyWrite)
			CloseHandle(hLobbyWrite);
		if(hLobbyWriteMutex)
			CloseHandle(hLobbyWriteMutex);

		return FALSE;
	}

	// Save the handles
	lpgn->hConnectDataMutex = hConnDataMutex;
	lpgn->hGameWriteEvent = hGameWrite;
	lpgn->hGameWriteMutex = hGameWriteMutex;
	lpgn->hLobbyWriteEvent = hLobbyWrite;
	lpgn->hLobbyWriteMutex = hLobbyWriteMutex;

	return TRUE;

} // PRV_SetupClientDataAccess



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetDataBuffer"
HRESULT PRV_GetDataBuffer(LPDPLOBBYI_GAMENODE lpgn, DWORD dwType,
				DWORD dwSize, LPHANDLE lphFile, LPVOID * lplpMemory)
{
	HRESULT						hr;
	SECURITY_ATTRIBUTES			sa;
	WCHAR						szName[MAX_MMFILENAME_LENGTH * sizeof(WCHAR)];
	LPVOID						lpMemory = NULL;
	HANDLE						hFile = NULL;
	DWORD						dwError = 0;


	DPF(7, "Entering PRV_GetDataBuffer");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x, 0x%08x",
			lpgn, dwType, dwSize, lphFile, lplpMemory);

	// Get the data buffer filename
	hr = PRV_GetInternalName(lpgn, dwType, (LPWSTR)szName);
	if(FAILED(hr))
		return hr;

	// If we are a Lobby Client, we need to create the file. If we
	// are a game, we need to open the already created file for
	// connection data, or we can create the file for game data (if
	// it doesn't already exist).
	if(lpgn->dwFlags & GN_LOBBY_CLIENT)
	{
		// Set up the security attributes (so that our mapping can
		// be inheritable
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;
		sa.bInheritHandle = TRUE;
		
		// Create the file mapping
		hFile = OS_CreateFileMapping(INVALID_HANDLE_VALUE, &sa,
							PAGE_READWRITE,	0, dwSize,
							(LPWSTR)szName);
	}
	else
	{
		hFile = OS_OpenFileMapping(FILE_MAP_ALL_ACCESS, TRUE, (LPWSTR)szName);
	}

	if(!hFile)
	{
		dwError = GetLastError();
		// WARNING: error may not be correct since calls we are trying to get last error from may have called out
		// to another function before returning.
		DPF(5, "Couldn't get a handle to the shared local memory, dwError = %lu (WARINING: error may not be correct)", dwError);
		return DPERR_OUTOFMEMORY;
	}

	// Map a View of the file
	lpMemory = MapViewOfFile(hFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);

	if(!lpMemory)
	{
		dwError = GetLastError();
		DPF(5, "Unable to get pointer to shared local memory, dwError = %lu", dwError);
		CloseHandle(hFile);
		return DPERR_OUTOFMEMORY;
	}


	// Setup the control structure based on the buffer type
	switch(dwType)
	{
		case TYPE_CONNECT_DATA_FILE:
		{
			LPDPLOBBYI_CONNCONTROL		lpControl = NULL;
						
			
			lpControl = (LPDPLOBBYI_CONNCONTROL)lpMemory;

			// If the buffer has been initialized, then don't worry
			// about it.  If the token is wrong (uninitialized), then do it
			if(lpControl->dwToken != BC_TOKEN)
			{
				lpControl->dwToken = BC_TOKEN;
				lpControl->dwFlags = 0;
			}
			break;
		}
		case TYPE_GAME_WRITE_FILE:
		case TYPE_LOBBY_WRITE_FILE:
		{
			LPDPLOBBYI_BUFFERCONTROL	lpControl = NULL;


			lpControl = (LPDPLOBBYI_BUFFERCONTROL)lpMemory;
			if(lpgn->dwFlags & GN_LOBBY_CLIENT)
			{
				// Since we're the lobby client, we know we create the buffer, so
				// initialize the entire structure
				lpControl->dwToken = BC_TOKEN;
				lpControl->dwReadOffset = sizeof(DPLOBBYI_BUFFERCONTROL);
				lpControl->dwWriteOffset = sizeof(DPLOBBYI_BUFFERCONTROL);
				lpControl->dwFlags = BC_LOBBY_ACTIVE;
				lpControl->dwMessages = 0;
				lpControl->dwBufferSize = dwSize;
				lpControl->dwBufferLeft = dwSize - sizeof(DPLOBBYI_BUFFERCONTROL);
			}
			else
			{
				// We're the game, but we don't know for sure if we just created
				// the buffer or if a lobby client did.  So check the token.  If
				// it is incorrect, we will assume we just created it and we need
				// to initialize the buffer control struct.  Otherwise, we will
				// assume a lobby client created it and we just need to add
				// our flag.
				if(lpControl->dwToken != BC_TOKEN)
				{
					// We don't see the token, so initialize the structure
					lpControl->dwReadOffset = sizeof(DPLOBBYI_BUFFERCONTROL);
					lpControl->dwWriteOffset = sizeof(DPLOBBYI_BUFFERCONTROL);
					lpControl->dwFlags = BC_GAME_ACTIVE;
					lpControl->dwMessages = 0;
					lpControl->dwBufferSize = dwSize;
					lpControl->dwBufferLeft = dwSize - sizeof(DPLOBBYI_BUFFERCONTROL);
				}
				else
				{
					// We assume the lobby created this buffer, so just set our flag
					lpControl->dwFlags |= BC_GAME_ACTIVE;
				}
			}
			break;
		}
	}

	// Fill in the output parameters
	*lphFile = hFile;
	*lplpMemory = lpMemory;

	return DP_OK;

} // PRV_GetDataBuffer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_StartReceiveThread"
HRESULT PRV_StartReceiveThread(LPDPLOBBYI_GAMENODE lpgn)
{
	HANDLE	hReceiveThread = NULL;
	HANDLE	hKillEvent = NULL;
	DWORD	dwThreadID;


	DPF(7, "Entering PRV_StartReceiveThread");
	DPF(9, "Parameters: 0x%08x", lpgn);

	ASSERT(lpgn);

	// Create the kill event if one doesn't exists
	if(!(lpgn->hKillReceiveThreadEvent))
	{
		hKillEvent = OS_CreateEvent(NULL, FALSE, FALSE, NULL);
		if(!hKillEvent)
		{
			DPF(2, "Unable to create Kill Receive Thread Event");
			return DPERR_OUTOFMEMORY;
		}
	}

	// If the Receive Thread isn't going, start it
	if(!(lpgn->hReceiveThread))
	{
		// Spawn off a receive notification thread for the cross-proc communication
		hReceiveThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)
							PRV_ReceiveClientNotification, lpgn, 0, &dwThreadID);

		if(!hReceiveThread)
		{
			DPF(2, "Unable to create Receive Thread!");
			if(hKillEvent)
				CloseHandle(hKillEvent);
			return DPERR_OUTOFMEMORY;
		}

		lpgn->hReceiveThread = hReceiveThread;
		if(hKillEvent)
			lpgn->hKillReceiveThreadEvent = hKillEvent;

	}

	return DP_OK;

} // PRV_StartReceiveThread



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetupAllSharedMemory"
HRESULT PRV_SetupAllSharedMemory(LPDPLOBBYI_GAMENODE lpgn)
{
	HRESULT	hr;
	LPVOID		lpConnDataMemory = NULL;
	LPVOID		lpGameMemory = NULL;
	LPVOID		lpLobbyMemory = NULL;
	HANDLE		hFileConnData = NULL;
	HANDLE		hFileGameWrite = NULL;
	HANDLE		hFileLobbyWrite = NULL;
	DWORD		dwError = 0;


	DPF(7, "Entering PRV_SetupAllSharedMemory");
	DPF(9, "Parameters: 0x%08x", lpgn);

	// Get access to the Connection Data File
	hr = PRV_GetDataBuffer(lpgn, TYPE_CONNECT_DATA_FILE,
								MAX_APPDATABUFFERSIZE,
								&hFileConnData, &lpConnDataMemory);
	if(FAILED(hr))
	{
		DPF(5, "Couldn't get access to Connection Data buffer");
		goto ERROR_SETUP_SHARED_MEMORY;
	}

	// Do the same for the Game Write File...
	hr = PRV_GetDataBuffer(lpgn, TYPE_GAME_WRITE_FILE,
								MAX_APPDATABUFFERSIZE,
								&hFileGameWrite, &lpGameMemory);
	if(FAILED(hr))
	{
		DPF(5, "Couldn't get access to Game Write buffer");
		goto ERROR_SETUP_SHARED_MEMORY;
	}


	// Do the same for the Lobby Write File...
	hr = PRV_GetDataBuffer(lpgn, TYPE_LOBBY_WRITE_FILE,
								MAX_APPDATABUFFERSIZE,
								&hFileLobbyWrite, &lpLobbyMemory);
	if(FAILED(hr))
	{
		DPF(5, "Couldn't get access to Lobby Write buffer");
		goto ERROR_SETUP_SHARED_MEMORY;
	}


	// Setup the signalling objects
	if(!PRV_SetupClientDataAccess(lpgn))
	{
		DPF(5, "Unable to create synchronization objects for shared memory!");
		return DPERR_OUTOFMEMORY;
	}

	// Save the file handles
	lpgn->hConnectDataFile = hFileConnData;
	lpgn->lpConnectDataBuffer = lpConnDataMemory;
	lpgn->hGameWriteFile = hFileGameWrite;
	lpgn->lpGameWriteBuffer = lpGameMemory;
	lpgn->hLobbyWriteFile = hFileLobbyWrite;
	lpgn->lpLobbyWriteBuffer = lpLobbyMemory;

	// Set the flag that tells us the shared memory files are valid
	lpgn->dwFlags |= GN_SHARED_MEMORY_AVAILABLE;

	// Start the Receive Thread
	hr = PRV_StartReceiveThread(lpgn);
	if(FAILED(hr))
	{
		// In this case, we will keep our shared buffers around.  Don't
		// worry about cleaning them up here -- we'll probably still need
		// them later, and they will get cleaned up later.
		DPF(5, "Unable to start receive thread");
		return hr;
	}

	return DP_OK;


ERROR_SETUP_SHARED_MEMORY:

		if(hFileConnData)
			CloseHandle(hFileConnData);
		if(lpConnDataMemory)
			UnmapViewOfFile(lpConnDataMemory);
		if(hFileGameWrite)
			CloseHandle(hFileGameWrite);
		if(lpGameMemory)
			UnmapViewOfFile(lpGameMemory);
		if(hFileLobbyWrite)
			CloseHandle(hFileLobbyWrite);
		if(lpLobbyMemory)
			UnmapViewOfFile(lpLobbyMemory);

		return hr;

} // PRV_SetupAllSharedMemory



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_EnterConnSettingsWaitMode"
void PRV_EnterConnSettingsWaitMode(LPDPLOBBYI_GAMENODE lpgn)
{
	LPDPLOBBYI_CONNCONTROL		lpConnControl = NULL;
	LPDPLOBBYI_BUFFERCONTROL	lpBufferControl = NULL;


	DPF(7, "Entering PRV_EnterConnSettingsWaitMode");
	DPF(9, "Parameters: 0x%08x", lpgn);

	ASSERT(lpgn);

	// Set the flag in the ConnSettings buffer
	WaitForSingleObject(lpgn->hConnectDataMutex, INFINITE);
	lpConnControl = (LPDPLOBBYI_CONNCONTROL)lpgn->lpConnectDataBuffer;
	lpConnControl->dwFlags |= BC_WAIT_MODE;
	ReleaseMutex(lpgn->hConnectDataMutex);

	// Set the flag in the GameWrite buffer
	WaitForSingleObject(lpgn->hGameWriteMutex, INFINITE);
	lpBufferControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpGameWriteBuffer;
	lpBufferControl->dwFlags |= BC_WAIT_MODE;
	ReleaseMutex(lpgn->hGameWriteMutex);

	// Set the flag in the LobbyWrite buffer
	WaitForSingleObject(lpgn->hLobbyWriteMutex, INFINITE);
	lpBufferControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpLobbyWriteBuffer;
	lpBufferControl->dwFlags |= BC_WAIT_MODE;
	ReleaseMutex(lpgn->hLobbyWriteMutex);

} // PRV_EnterConnSettingsWaitMode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_LeaveConnSettingsWaitMode"
void PRV_LeaveConnSettingsWaitMode(LPDPLOBBYI_GAMENODE lpgn)
{
	LPDPLOBBYI_CONNCONTROL		lpConnControl = NULL;
	LPDPLOBBYI_BUFFERCONTROL	lpBufferControl = NULL;


	DPF(7, "Entering PRV_LeaveConnSettingsWaitMode");
	DPF(9, "Parameters: 0x%08x", lpgn);

	ASSERT(lpgn);

	// Clear the flag in the ConnSettings buffer
	WaitForSingleObject(lpgn->hConnectDataMutex, INFINITE);
	lpConnControl = (LPDPLOBBYI_CONNCONTROL)lpgn->lpConnectDataBuffer;
	lpConnControl->dwFlags &= ~(BC_WAIT_MODE | BC_PENDING_CONNECT);
	ReleaseMutex(lpgn->hConnectDataMutex);

	// Clear the flag in the GameWrite buffer
	WaitForSingleObject(lpgn->hGameWriteMutex, INFINITE);
	lpBufferControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpGameWriteBuffer;
	lpBufferControl->dwFlags &= ~BC_WAIT_MODE;
	ReleaseMutex(lpgn->hGameWriteMutex);

	// Clear the flag in the LobbyWrite buffer
	WaitForSingleObject(lpgn->hLobbyWriteMutex, INFINITE);
	lpBufferControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpLobbyWriteBuffer;
	lpBufferControl->dwFlags &= ~BC_WAIT_MODE;
	ReleaseMutex(lpgn->hLobbyWriteMutex);

} // PRV_LeaveConnSettingsWaitMode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_WriteClientData"
HRESULT PRV_WriteClientData(LPDPLOBBYI_GAMENODE lpgn, DWORD dwFlags,
							LPVOID lpData, DWORD dwSize)
{
	LPDPLOBBYI_BUFFERCONTROL	lpControl = NULL;
	LPDPLOBBYI_MESSAGEHEADER	lpHeader = NULL;
	HANDLE						hMutex = NULL;
	DWORD						dwSizeToEnd = 0;
	LPBYTE						lpTemp = NULL;
    HRESULT						hr = DP_OK;


	DPF(7, "Entering PRV_WriteClientData");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, %lu",
			lpgn, dwFlags, lpData, dwSize);

	// Make sure we have a valid shared memory buffer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	ENTER_DPLGAMENODE();
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		hr = PRV_SetupAllSharedMemory(lpgn);
		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF(2, "Unable to access App Data memory");
			return hr;
		}
	}
	LEAVE_DPLGAMENODE();

	
	// Grab the mutex
	hMutex = (lpgn->dwFlags & GN_LOBBY_CLIENT) ?
			(lpgn->hLobbyWriteMutex) : (lpgn->hGameWriteMutex);
	WaitForSingleObject(hMutex, INFINITE);

	// Get a pointer to our control structure
	lpControl = (LPDPLOBBYI_BUFFERCONTROL)((lpgn->dwFlags &
				GN_LOBBY_CLIENT) ? (lpgn->lpLobbyWriteBuffer)
				: (lpgn->lpGameWriteBuffer));

	// If we're in wait mode, bail
	if(lpControl->dwFlags & BC_WAIT_MODE)
	{
		DPF_ERR("Cannot send lobby message while in Wait Mode for new ConnectionSettings");
		hr = DPERR_UNAVAILABLE;
		goto EXIT_WRITE_CLIENT_DATA;
	}

	// If we are the game, check to see if the lobby client is even there. In
	// the self-lobbied case, it won't be.  If it is not there, don't even
	// bother sending anything.
	if((!(lpgn->dwFlags & GN_LOBBY_CLIENT)) && (!(lpControl->dwFlags
		& BC_LOBBY_ACTIVE)))
	{
		DPF(5, "There is not active lobby client; Not sending message");
		hr = DPERR_UNAVAILABLE;
		goto EXIT_WRITE_CLIENT_DATA;
	}

	// Make sure there is enough space left for the message and two dwords
	if(lpControl->dwBufferLeft < (dwSize + sizeof(DPLOBBYI_MESSAGEHEADER)))
	{
		DPF(5, "Not enough space left in the message buffer");
		hr = DPERR_BUFFERTOOSMALL;
		goto EXIT_WRITE_CLIENT_DATA;
	}

	// Copy in the data. First make sure we can write from the cursor
	// forward without having to wrap around to the beginning of the buffer,
	// but make sure we don't write past the read cursor
	if(lpControl->dwWriteOffset >= lpControl->dwReadOffset)
	{
		// Our write pointer is ahead of our read pointer (cool). Figure
		// out if we have enough room between our write pointer and the
		// end of the buffer.  If we do, then just write it.  If we don't
		// we need to wrap it.
		dwSizeToEnd = lpControl->dwBufferSize - lpControl->dwWriteOffset;
		if(dwSizeToEnd >= (dwSize + sizeof(DPLOBBYI_MESSAGEHEADER)))
		{
			// We have enough room
			lpHeader = (LPDPLOBBYI_MESSAGEHEADER)((LPBYTE)lpControl
							+ lpControl->dwWriteOffset);
			lpHeader->dwSize = dwSize;
			lpHeader->dwFlags = dwFlags;
			lpTemp = (LPBYTE)(++lpHeader);
			memcpy(lpTemp, lpData, dwSize);

			// Move the write cursor, and check to see if we have enough
			// room for the header on the next message.  If the move causes
			// us to wrap, or if we are within one header's size,
			// we need to move the write cursor back to the beginning
			// of the buffer
			lpControl->dwWriteOffset += dwSize + sizeof(DPLOBBYI_MESSAGEHEADER);
			if(lpControl->dwWriteOffset > (lpControl->dwBufferSize -
					sizeof(DPLOBBYI_MESSAGEHEADER)))
			{
				// Increment the amount of free buffer by the amount we
				// are about to skip over to wrap
				lpControl->dwBufferLeft -= (lpControl->dwBufferSize -
					lpControl->dwWriteOffset);
				
				// We're closer than one header's size
				lpControl->dwWriteOffset = sizeof(DPLOBBYI_BUFFERCONTROL);
			}
		}
		else
		{
			// We don't have enough room before the end, so we need to
			// wrap the message (ugh).  Here's the rules:
			//		1. If we don't have enough bytes for the header, start
			//			the whole thing at the beginning of the buffer
			//		2. If we have enough bytes, write as much
			//			as we can and wrap the rest.
			if(dwSizeToEnd < sizeof(DPLOBBYI_MESSAGEHEADER))
			{
				// We don't even have room for our two dwords, so wrap
				// the whole thing. So first decrement the amount of
				// free memory left and make sure we will still fit
				lpControl->dwBufferLeft -= dwSizeToEnd;
				if(lpControl->dwBufferLeft < (dwSize +
						sizeof(DPLOBBYI_MESSAGEHEADER)))
				{
					DPF(5, "Not enough space left in the message buffer");
					hr = DPERR_BUFFERTOOSMALL;
					goto EXIT_WRITE_CLIENT_DATA;
				}
				
				// Reset the write pointer and copy
				lpHeader = (LPDPLOBBYI_MESSAGEHEADER)((LPBYTE)lpControl +
						sizeof(DPLOBBYI_BUFFERCONTROL));
				lpHeader->dwSize = dwSize;
				lpHeader->dwFlags = dwFlags;
				lpTemp = (LPBYTE)(++lpHeader);
				memcpy(lpTemp, lpData, dwSize);

				// Move the write cursor
				lpControl->dwWriteOffset += sizeof(DPLOBBYI_BUFFERCONTROL) +
							(dwSize + sizeof(DPLOBBYI_MESSAGEHEADER));
			}
			else
			{
				// We at least have enough room for the two dwords
				lpHeader = (LPDPLOBBYI_MESSAGEHEADER)((LPBYTE)lpControl
							+ lpControl->dwWriteOffset);
				lpHeader->dwSize = dwSize;
				lpHeader->dwFlags = dwFlags;

				// Now figure out how much we can write
				lpTemp = (LPBYTE)(++lpHeader);
				dwSizeToEnd -= sizeof(DPLOBBYI_MESSAGEHEADER);
				if(!dwSizeToEnd)
				{
					// We need to wrap to write the whole message
					lpTemp = (LPBYTE)lpControl + sizeof(DPLOBBYI_BUFFERCONTROL);
					memcpy(lpTemp, lpData, dwSize);

					// Move the write cursor
					lpControl->dwWriteOffset = sizeof(DPLOBBYI_BUFFERCONTROL)
							+ dwSize;
				}
				else
				{
					// Copy as many bytes as we can
					memcpy(lpTemp, lpData, dwSizeToEnd);

					// Move both pointers and finish the job
					lpTemp = (LPBYTE)lpControl + sizeof(DPLOBBYI_BUFFERCONTROL);
					memcpy(lpTemp, ((LPBYTE)lpData + dwSizeToEnd), (dwSize -
							dwSizeToEnd));

					// Move the write cursor
					lpControl->dwWriteOffset = sizeof(DPLOBBYI_BUFFERCONTROL)
							+ (dwSize - dwSizeToEnd);
				}
			}
		}
	}
	else
	{
		// Our read pointer is ahead of our write pointer.  Since we checked
		// and found there is enough room to write, we should just be able
		// to just slam this guy in.
		lpHeader = (LPDPLOBBYI_MESSAGEHEADER)((LPBYTE)lpControl +
						lpControl->dwWriteOffset);
		lpHeader->dwSize = dwSize;
		lpHeader->dwFlags = dwFlags;
		lpTemp = (LPBYTE)(++lpHeader);
		memcpy(lpTemp, lpData, dwSize);

		// Move the write cursor
		lpControl->dwWriteOffset += dwSize + sizeof(DPLOBBYI_MESSAGEHEADER);
	}

	// Decrement the amount of free space left and increment the message count
	lpControl->dwBufferLeft -= (dwSize + sizeof(DPLOBBYI_MESSAGEHEADER));
	lpControl->dwMessages++;

	// Signal the other user that we have written something
	SetEvent((lpgn->dwFlags & GN_LOBBY_CLIENT) ?
			(lpgn->hLobbyWriteEvent) : (lpgn->hGameWriteEvent));

	// Fall through

EXIT_WRITE_CLIENT_DATA:

	// Release the mutex
	ReleaseMutex(hMutex);
	return hr;

} // PRV_WriteClientData



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendStandardSystemMessage"
HRESULT PRV_SendStandardSystemMessage(LPDIRECTPLAYLOBBY lpDPL,
			DWORD dwMessage, DWORD dwGameID)
{
	LPDPLOBBYI_DPLOBJECT	this = NULL;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
	HRESULT					hr;
	DWORD					dwMessageSize;
	LPVOID					lpmsg = NULL;
	DWORD					dwFlags;


	DPF(7, "Entering PRV_SendStandardSystemMessage");
	DPF(9, "Parameters: 0x%08x, %lu, %lu",
			lpDPL, dwMessage, dwGameID);

    ENTER_DPLOBBY();

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If dwGameID is zero it means that we are the game, so
	// we need to get the current process ID.  Otherwise, it
	// means we are the lobby client
	if(!dwGameID)
		dwGameID = GetCurrentProcessId();

	// Now find the correct game node
	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);
	if(!lpgn)
	{
		if(FAILED(PRV_AddNewGameNode(this, &lpgn, dwGameID, NULL, FALSE,NULL)))
		{
			LEAVE_DPLOBBY();
			return DPERR_OUTOFMEMORY;
		}
	}

	// Get the size of the message
	switch(dwMessage)
	{
		case DPLSYS_NEWSESSIONHOST:
			dwMessageSize = sizeof(DPLMSG_NEWSESSIONHOST);
			break;

		default:
			dwMessageSize = sizeof(DPLMSG_SYSTEMMESSAGE);
			break;
	}

	// Allocate a buffer for the message
	lpmsg = DPMEM_ALLOC(dwMessageSize);
	if(!lpmsg)
	{
		LEAVE_DPLOBBY();
		DPF_ERRVAL("Unable to allocate memory for lobby system message, dwMessage = %lu", dwMessage);
		return DPERR_OUTOFMEMORY;
	}

	// Setup the message
	((LPDPLMSG_SYSTEMMESSAGE)lpmsg)->dwType = dwMessage;
	((LPDPLMSG_SYSTEMMESSAGE)lpmsg)->guidInstance = lpgn->guidInstance;

	// Write into the shared buffer
	dwFlags = DPLMSG_SYSTEM | DPLMSG_STANDARD;
	hr = PRV_WriteClientData(lpgn, dwFlags, lpmsg, dwMessageSize);
	if(FAILED(hr))
	{
		DPF(8, "Couldn't send system message");
	}

	// Free our buffer
	DPMEM_FREE(lpmsg);

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SendStandardSystemMessage



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddNewRequestNode"
HRESULT PRV_AddNewRequestNode(LPDPLOBBYI_DPLOBJECT this,
		LPDPLOBBYI_GAMENODE lpgn, LPDPLMSG_GENERIC lpmsg, BOOL bSlamGuid)
{
	LPDPLOBBYI_REQUESTNODE	lprn = NULL;


	// Allocate memory for a Request Node
	lprn = DPMEM_ALLOC(sizeof(DPLOBBYI_REQUESTNODE));
	if(!lprn)
	{
		DPF_ERR("Unable to allocate memory for request node, system message not sent");
		return DPERR_OUTOFMEMORY;
	}
	
	// Setup the request node
	lprn->dwFlags = lpgn->dwFlags;
	lprn->dwRequestID = this->dwCurrentRequest;
	lprn->dwAppRequestID = ((LPDPLMSG_GETPROPERTY)lpmsg)->dwRequestID;
	lprn->lpgn = lpgn;

	// Add the slammed guid flag if needed
	if(bSlamGuid)
		lprn->dwFlags |= GN_SLAMMED_GUID;

	// Change the request ID in the message to our internal one (we'll
	// change it back on Receive
	((LPDPLMSG_GETPROPERTY)lpmsg)->dwRequestID = this->dwCurrentRequest++;

	// Add the node to the list
	if(this->lprnHead)
		this->lprnHead->lpPrev = lprn;
	lprn->lpNext = this->lprnHead;
	this->lprnHead = lprn;

	return DP_OK;

} // PRV_AddNewRequestNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_RemoveRequestNode"
void PRV_RemoveRequestNode(LPDPLOBBYI_DPLOBJECT this,
		LPDPLOBBYI_REQUESTNODE lprn)
{
	// If we're the head, move it
	if(lprn == this->lprnHead)
		this->lprnHead = lprn->lpNext;

	// Fixup the previous & next pointers
	if(lprn->lpPrev)
		lprn->lpPrev->lpNext = lprn->lpNext;
	if(lprn->lpNext)
		lprn->lpNext->lpPrev = lprn->lpPrev;

	// Free the node
	DPMEM_FREE(lprn);

} // PRV_RemoveRequestNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ForwardMessageToLobbyServer"
HRESULT PRV_ForwardMessageToLobbyServer(LPDPLOBBYI_GAMENODE lpgn,
		LPVOID lpBuffer, DWORD dwSize, BOOL bStandard)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPLMSG_GENERIC		lpmsg = NULL;
	HRESULT					hr;
	BOOL					bSlamGuid = FALSE;


	DPF(7, "Entering PRV_ForwardMessageToLobbyServer");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, %lu",
			lpgn, lpBuffer, dwSize, bStandard);


    TRY
    {
		// Validate the dplay object
		hr = VALID_DPLAY_PTR( lpgn->lpDPlayObject );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}

		// Validate the lobby object
		this = lpgn->lpDPlayObject->lpLobbyObject;
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			DPF_ERR("Invalid lobby object");
			return DPERR_INVALIDOBJECT;
        }
	}
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If this is a property request, we need to create a request node
	lpmsg = (LPDPLMSG_GENERIC)lpBuffer;
	if(bStandard)
	{
		// If it's a property message, we need a request node
		switch(lpmsg->dwType)
		{
			case DPLSYS_GETPROPERTY:
			{
				LPDPLMSG_GETPROPERTY	lpgp = lpBuffer;

				// If it's a GETPROPERTY message, we need to check to see if
				// the player guid is NULL.  If it is, we need to
				// stuff the game's Instance guid in that field
				if(IsEqualGUID(&lpgp->guidPlayer, &GUID_NULL))
				{
					// Stuff the instance guid of the game
					lpgp->guidPlayer = lpgn->guidInstance;
					bSlamGuid = TRUE;
				}

				// Add a request node to the pending requests list
				hr = PRV_AddNewRequestNode(this, lpgn, lpmsg, bSlamGuid);
				if(FAILED(hr))
				{
					DPF_ERRVAL("Unable to add request node to list, hr = 0x%08x", hr);
					return hr;
				}
				break;
			}
			
			case DPLSYS_SETPROPERTY:
			{
				LPDPLMSG_SETPROPERTY	lpsp = lpBuffer;
				
				// If it's a SETPROPERTY message, we need to check to see if
				// the player guid is NULL.  If it is, we need to
				// stuff the game's Instance guid in that field
				if(IsEqualGUID(&lpsp->guidPlayer, &GUID_NULL))
				{
					// Stuff the instance guid of the game
					lpsp->guidPlayer = lpgn->guidInstance;
					bSlamGuid = TRUE;
				}

				// If the request ID is zero, we don't need to swap
				// the ID's or add a pending request
				if(lpsp->dwRequestID != 0)
				{
					// Add a request node to the pending requests list
					hr = PRV_AddNewRequestNode(this, lpgn, lpmsg, bSlamGuid);
					if(FAILED(hr))
					{
						DPF_ERRVAL("Unable to add request node to list, hr = 0x%08x", hr);
						return hr;
					}
				}
				break;
			}

			case DPLSYS_NEWSESSIONHOST:
				((LPDPLMSG_NEWSESSIONHOST)lpBuffer)->guidInstance = lpgn->guidInstance;
				break;
			
			default:
				break;
		}
	}


	// Call Send on the lobby object
	hr = PRV_Send(this, lpgn->dpidPlayer, DPID_SERVERPLAYER,
			DPSEND_LOBBYSYSTEMMESSAGE, lpBuffer, dwSize);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed sending lobby message, hr = 0x%08x", hr);
	}

	return hr;

} // PRV_ForwardMessageToLobbyServer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_InjectMessageInQueue"
HRESULT PRV_InjectMessageInQueue(LPDPLOBBYI_GAMENODE lpgn, DWORD dwFlags,
							LPVOID lpData, DWORD dwSize, BOOL bForward)
{
	LPDPLOBBYI_MESSAGE	lpm = NULL;
	LPVOID				lpBuffer = NULL;
	HRESULT				hr;


	DPF(7, "Entering PRV_InjectMessageInQueue");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, %lu, %lu",
			lpgn, dwFlags, lpData, dwSize, bForward);

	ASSERT(lpData);

	// Allocate memory for the node and the data buffer
	lpm = DPMEM_ALLOC(sizeof(DPLOBBYI_MESSAGE));
	lpBuffer = DPMEM_ALLOC(dwSize);
	if((!lpm) || (!lpBuffer))
	{
		DPF_ERR("Unable to allocate memory for system message");
		if(lpm)
			DPMEM_FREE(lpm);
		if(lpBuffer)
			DPMEM_FREE(lpBuffer);
		return DPERR_OUTOFMEMORY;
	}

	// Copy the data
	memcpy(lpBuffer, lpData, dwSize);

	// Before we put it in our own queue, forward it onto the lobby server
	// if there is one.
	if(bForward && (lpgn->dwFlags & GN_CLIENT_LAUNCHED))
	{
		hr = PRV_ForwardMessageToLobbyServer(lpgn, lpData, dwSize, FALSE);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed forwarding system message to lobby server, hr = 0x%08x", hr);
		}
	}

	// Save the data pointer & the external flags
	// Note: If we're injecting this, it has to be a system message,
	// so set the flag just in case we forgot elsewhere.
	lpm->dwFlags = (dwFlags | DPLAD_SYSTEM);
	lpm->dwSize = dwSize;
	lpm->lpData = lpBuffer;

	// Add the message to the end of the queue & increment the count
	ENTER_DPLQUEUE();
	lpm->lpPrev = lpgn->MessageHead.lpPrev;
	lpgn->MessageHead.lpPrev->lpNext = lpm;
	lpgn->MessageHead.lpPrev = lpm;
	lpm->lpNext = &lpgn->MessageHead;

	lpgn->dwMessageCount++;
	LEAVE_DPLQUEUE();

	// Kick the event handle
	if(lpgn->hDupReceiveEvent)
	{
		SetEvent(lpgn->hDupReceiveEvent);
	}

	return DP_OK;

} // PRV_InjectMessageInQueue


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ReadClientData"
HRESULT PRV_ReadClientData(LPDPLOBBYI_GAMENODE lpgn, LPDWORD lpdwFlags,
							LPVOID lpData, LPDWORD lpdwDataSize)
{
	LPDPLOBBYI_BUFFERCONTROL	lpControl = NULL;
	LPDPLOBBYI_MESSAGEHEADER	lpHeader = NULL;
	DWORD						dwSize = 0;
	DWORD_PTR					dwSizeToEnd = 0;
	HANDLE						hMutex = NULL;
	LPBYTE						lpTemp = NULL;
	LPBYTE						lpEnd = NULL;
	HRESULT						hr = DP_OK;


	DPF(7, "Entering PRV_ReadClientData");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpgn, lpdwFlags, lpData, lpdwDataSize);

	// Make sure we have a valid shared memory buffer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	ENTER_DPLGAMENODE();
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		hr = PRV_SetupAllSharedMemory(lpgn);
		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF(2, "Unable to access App Data memory");
			return hr;
		}
	}
	LEAVE_DPLGAMENODE();

	// Grab the mutex
	// REVIEW!!!! -- Is there anything that might cause this wait to hang????
	hMutex = (lpgn->dwFlags & GN_LOBBY_CLIENT) ?
			(lpgn->hGameWriteMutex) : (lpgn->hLobbyWriteMutex);
	WaitForSingleObject(hMutex, INFINITE);

	// Get a pointer to our control structure
	lpControl = (LPDPLOBBYI_BUFFERCONTROL)((lpgn->dwFlags &
				GN_LOBBY_CLIENT) ? (lpgn->lpGameWriteBuffer)
				: (lpgn->lpLobbyWriteBuffer));

	// Make sure there are any messages in the buffer
	if(!lpControl->dwMessages)
	{
		DPF(8, "No messages in shared buffer");
		hr = DPERR_NOMESSAGES;
		goto EXIT_READ_CLIENT_DATA;
	}

	// Make sure there is enough space for the message
	lpHeader = (LPDPLOBBYI_MESSAGEHEADER)((LPBYTE)lpControl
				+ lpControl->dwReadOffset);
	dwSize = lpHeader->dwSize;

	// Set the output data size (even if we fail, we want to return it)
	if(lpdwDataSize)
		*lpdwDataSize = dwSize;

	if((!lpData) || (dwSize > *lpdwDataSize))
	{
		DPF(8, "Message buffer is too small, must be at least %d bytes", dwSize);
		hr = DPERR_BUFFERTOOSMALL;
		goto EXIT_READ_CLIENT_DATA;
	}

	// Set the output flags
	if(lpdwFlags)
		*lpdwFlags = lpHeader->dwFlags;

	// Now check and see if we are going to wrap. If we are, some of the message
	// will be at the end of the buffer, some will be at the beginning.
	lpTemp = (LPBYTE)(++lpHeader) + dwSize;
	if(lpTemp > ((LPBYTE)lpControl + lpControl->dwBufferSize))
	{
		// Figure out where we need to wrap
		dwSizeToEnd = ((LPBYTE)lpControl + lpControl->dwBufferSize)
						- (LPBYTE)(lpHeader);

		if(!dwSizeToEnd)
		{
			// We are at the end, so the whole message must be at the
			// beginning of the buffer
			lpTemp = (LPBYTE)lpControl + sizeof(DPLOBBYI_BUFFERCONTROL);
			memcpy(lpData, lpTemp, dwSize);

			// Move the read cursor
			lpControl->dwReadOffset = sizeof(DPLOBBYI_BUFFERCONTROL) + dwSize;
		}
		else
		{
			// Copy the first part of the data
			lpTemp = (LPBYTE)lpHeader;
			memcpy(lpData, lpTemp, (DWORD)dwSizeToEnd);

			// Move the read cursor and copy the rest
			lpTemp = (LPBYTE)lpControl + sizeof(DPLOBBYI_BUFFERCONTROL);
			memcpy(((LPBYTE)lpData + dwSizeToEnd), lpTemp,
					(DWORD)(dwSize - dwSizeToEnd));

			// Move the read pointer
			lpControl->dwReadOffset = (DWORD)(sizeof(DPLOBBYI_BUFFERCONTROL)
						+ (dwSize - dwSizeToEnd));
		}
	}
	else
	{
		// We don't have to wrap (cool).
		lpTemp = (LPBYTE)lpHeader;
		memcpy(lpData, lpTemp, dwSize);

		// Move the read pointer.  If there are less than 8 bytes left in the
		// buffer, we should move the read pointer to the beginning.  We need
		// to add however many bytes we skip (at the end) back into our free
		// buffer memory counter.
		lpTemp += dwSize;
		lpEnd = (LPBYTE)lpControl + lpControl->dwBufferSize;
		if(lpTemp > (lpEnd	- sizeof(DPLOBBYI_MESSAGEHEADER)))
		{
			// Move the read cursor to the beginning
			lpControl->dwReadOffset = sizeof(DPLOBBYI_BUFFERCONTROL);

			// Add the number of bytes to the free buffer total
			lpControl->dwBufferLeft += (DWORD)(lpEnd - lpTemp);
		}
		else
			lpControl->dwReadOffset += (DWORD)(dwSize + sizeof(DPLOBBYI_MESSAGEHEADER));
	}


	// Increment the amount of free space left and decrement the message count
	lpControl->dwBufferLeft += (dwSize + sizeof(DPLOBBYI_MESSAGEHEADER));
	lpControl->dwMessages--;

	// Fall through

EXIT_READ_CLIENT_DATA:

	// Release the mutex
	ReleaseMutex(hMutex);

	return hr;

} // PRV_ReadClientData



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ReceiveClientNotification"
DWORD WINAPI PRV_ReceiveClientNotification(LPVOID lpParam)
{
    LPDPLOBBYI_GAMENODE			lpgn = (LPDPLOBBYI_GAMENODE)lpParam;
    LPDPLOBBYI_MESSAGE			lpm = NULL;
	LPDPLOBBYI_BUFFERCONTROL	lpControl = NULL;
	LPDPLMSG_GENERIC			lpmsg = NULL;
	HRESULT						hr;
	HANDLE						hEvents[3];
	LPVOID						lpBuffer = NULL;
	DWORD						dwFlags;
	DWORD						dwSize;
	DWORD						dwReturn;
	BOOL						bForward;


	DPF(7, "Entering PRV_ReceiveClientNotification");
	DPF(9, "Parameters: 0x%08x", lpParam);

	// Make sure we have a valid shared memory buffer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	ENTER_DPLGAMENODE();
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		BOOL	bGameCreate;


		DPF(2, "NOTE: ReceiveClientNotification thread starting without shared memory set up.  Setting up now.");
		
		// HACK!!!! -- SetLobbyMessageReceiveEvent may get called from
		// the game without having been lobbied yet.  If that is the case,
		// we need to create the shared memory buffer.  If we don't do
		// that, we may miss messages.
		
		if(!(lpgn->dwFlags & GN_LOBBY_CLIENT))
		{
			// Fake the setup routine by setting the lobby client flag
			lpgn->dwFlags |= GN_LOBBY_CLIENT;

			// Set our flag
			bGameCreate = TRUE;
		}

		hr = PRV_SetupAllSharedMemory(lpgn);

		// HACK!!!! -- Reset the settings we changed to fake the setup routines
		if(bGameCreate)
		{
			lpgn->dwFlags &= (~GN_LOBBY_CLIENT);
		}

	
		//hr = PRV_SetupAllSharedMemory(lpgn);
		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF(2, "Unable to access App Data memory");
			return 0L;
		}
	}
	LEAVE_DPLGAMENODE();

	// Setup the two events -- one receive event, one kill event
	hEvents[0] = ((lpgn->dwFlags & GN_LOBBY_CLIENT) ?
				(lpgn->hGameWriteEvent) : (lpgn->hLobbyWriteEvent));
	hEvents[1] = lpgn->hKillReceiveThreadEvent;
	// This extra handle is here because of a Windows 95 bug.  Windows
	// will occasionally miss when it walks the handle table, causing
	// my thread to wait on the wrong handles.  By putting a guaranteed
	// invalid handle at the end of our array, the kernel will do a
	// forced re-walk of the handle table and find the correct handles.
	hEvents[2] = INVALID_HANDLE_VALUE;

	// Make sure we have a valid event
	if(!hEvents[0] || !hEvents[1])
	{
		DPF(2, "Either the Write Event or the Kill Event is NULL and it shouldn't be!");
		ExitThread(0L);
		return 0;
	}

	// If we are the game, we should check the buffer to see if any messages
	// already exist in the shared buffer.
	if(!(lpgn->dwFlags & GN_LOBBY_CLIENT))
	{
		lpControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpLobbyWriteBuffer;
		// If there are any messages, kick our event so that our receive
		// loop will immediately put the messages in the queue
		if(lpControl->dwMessages)
			SetEvent(hEvents[0]);
	}

	// Wait for the event notification
	while(1)
	{
		// Sleep until something shows up
		dwReturn = WaitForMultipleObjects(2, (HANDLE *)hEvents,
											FALSE, INFINITE);

		// If the return value was anything bug the receive event,
		// kill the thread
		if(dwReturn != WAIT_OBJECT_0)
		{
			if(dwReturn == WAIT_FAILED)
			{
				// This is a Windows 95 bug -- We may have gotten
				// kicked for no reason.  If that was the case, we
				// still have valid handles (we think), the OS
				// just goofed up.  So, validate the handle and if
				// they are valid, just return to waiting.  See
				// bug #3340 for a better explanation.
				if(ERROR_INVALID_HANDLE == GetLastError())
				{
					if(!OS_IsValidHandle(hEvents[0]))
						break;
					if(!OS_IsValidHandle(hEvents[1]))
						break;
					continue;
				}
				break;
			}
			else
			{
				// It is either our kill event, or something we don't
				// understand or expect.  In this case, let's exit.
				break;
			}
		}

		while(1)
		{
			// First, call PRV_ReadClientData to get the size of the data
			hr = PRV_ReadClientData(lpgn, NULL, NULL, &dwSize);
			
			// If there are no messages, end the while loop
			if(hr == DPERR_NOMESSAGES)
				break;

			// Otherwise, we should get the BUFFERTOOSMALL case
			if(hr != DPERR_BUFFERTOOSMALL)
			{
				// We should never have a problem here
				DPF_ERRVAL("Recieved an unexpected error reading from shared buffer, hr = 0x%08x", hr);
				ASSERT(FALSE);
				// Might as well keep trying
				break;
			}
			
			// Allocate memory for the node and the data buffer
			lpm = DPMEM_ALLOC(sizeof(DPLOBBYI_MESSAGE));
			lpBuffer = DPMEM_ALLOC(dwSize);
			if((!lpm) || (!lpBuffer))
			{
				DPF_ERR("Unable to allocate memory for message");
				ASSERT(FALSE);
				// Might as well keep trying
				break;
			}

			// Copy the data into our buffer
			hr = PRV_ReadClientData(lpgn, &dwFlags, lpBuffer, &dwSize);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Error reading shared buffer, message not read, hr = 0x%08x", hr);
				ASSERT(FALSE);
				DPMEM_FREE(lpm);
				DPMEM_FREE(lpBuffer);
				// Might as well keep trying
				break;
			}

			// Clear our foward flag
			bForward = FALSE;
			
			// If we are a dplay lobby client, we need to forward the message
			// onto the lobby server using the IDP3 interface.  If we're not,
			// then just put the message in the receive queue.
			if(lpgn->dwFlags & GN_CLIENT_LAUNCHED)
			{
				// Foward the message
				hr = PRV_ForwardMessageToLobbyServer(lpgn, lpBuffer, dwSize,
					((dwFlags & DPLMSG_STANDARD) ? TRUE : FALSE));
				if(FAILED(hr))
				{
					DPF_ERRVAL("Unable to send lobby system message, hr = 0x%08x", hr);
				}

				// Set the forwarded flag
				bForward = TRUE;
			}

			// Check for an App Terminated message.  If we get one off the wire,
			// we need to shut down our ClientTerminateMonitor thread, signal
			// this thread (the receive thread to shut down, and mark the game
			// node as dead.  This will keep us from sending or receiving any
			// more messages from the now dead game.  (This message will only
			// ever be received by a lobby client).
			lpmsg = (LPDPLMSG_GENERIC)lpBuffer;
			if(lpmsg->dwType == DPLSYS_APPTERMINATED)
			{
				// Kick the TerminateMonitor thread with it's kill event
				SetEvent(lpgn->hKillTermThreadEvent);

				// Set this thread's kill event (so that when we get done
				// reading messages out of the shared buffer, we go away)
				SetEvent(lpgn->hKillReceiveThreadEvent);

				// Mark the GAMENODE as dead, but don't remove it since we know
				// there will still messages in the queue.
				lpgn->dwFlags |= GN_DEAD_GAME_NODE;
			}

			// If it's one of our DX3 messages, we need to put it in the queue
			// otherwise if we already forwarded it, we can free it. NOTE: All
			// DX3 lobby system messages had a value between 0 and
			// DPLSYS_APPTERMINATED (0x04).
			if((!bForward) || (lpmsg->dwType <= DPLSYS_APPTERMINATED))
			{
				// Save the data pointer & the external flags
				lpm->dwFlags = dwFlags & (~DPLOBBYPR_INTERNALMESSAGEFLAGS);
				lpm->dwSize = dwSize;
				lpm->lpData = lpBuffer;

				// Add the message to the end of the queue & increment the count
				ENTER_DPLQUEUE();
				lpm->lpPrev = lpgn->MessageHead.lpPrev;
				lpgn->MessageHead.lpPrev->lpNext = lpm;
				lpgn->MessageHead.lpPrev = lpm;
				lpm->lpNext = &lpgn->MessageHead;

				lpgn->dwMessageCount++;
				LEAVE_DPLQUEUE();

				// NOTE: There is a potential thread problem here, but we are going
				// to ignore it for now.  It is possible for another thread to be
				// going through the SetAppData code which changes this event handle.
				// The problem is if they change it after this IF statement, but
				// before we call SetEvent.  However, the SetEvent call will either
				// succeed on the new handle, or return an error if the handle is
				// changed to NULL.  In either case, no harm, no foul -- we don't care.
				if(!lpgn->hDupReceiveEvent)
				{
					DPF(8, "The Receive Event handle is NULL!");
					continue;
				}

				SetEvent(lpgn->hDupReceiveEvent);
			}
			else
			{
				// Free the buffers
				DPMEM_FREE(lpm);
				DPMEM_FREE(lpBuffer);
			}
		}
	}

	DPF(8, "Lobby Receive Thread is going away!!!!!");
	ExitThread(0L);

	return 0L; // avoid warning.
} // PRV_ReceiveClientNotification



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_RemoveNodeFromQueue"
void PRV_RemoveNodeFromQueue(LPDPLOBBYI_GAMENODE lpgn, LPDPLOBBYI_MESSAGE lpm)
{
	DPF(7, "Entering PRV_RemoveNodeFromQueue");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpgn, lpm);

	ASSERT(lpgn);
	ASSERT(lpm);

	// Delete the message from the queue & decrement the count
	lpm->lpPrev->lpNext = lpm->lpNext;
	lpm->lpNext->lpPrev = lpm->lpPrev;

	lpgn->dwMessageCount--;

	// Free the memory for the message node
	DPMEM_FREE(lpm->lpData);
	DPMEM_FREE(lpm);

} // PRV_RemoveNodeFromQueue



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CleanUpQueue"
void PRV_CleanUpQueue(LPDPLOBBYI_GAMENODE lpgn)
{
	LPDPLOBBYI_MESSAGE	lpm, lpmNext;


	DPF(7, "Entering PRV_CleanUpQueue");
	DPF(9, "Parameters: 0x%08x", lpgn);

	ASSERT(lpgn);

	lpm = lpgn->MessageHead.lpNext;
	while(lpm != &lpgn->MessageHead)
	{
		// Save the next pointer
		lpmNext = lpm->lpNext;

		// Remove the node
		PRV_RemoveNodeFromQueue(lpgn, lpm);

		// Move to the next node
		lpm = lpmNext;
	}


} // PRV_CleanUpQueue



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_KillThread"
void PRV_KillThread(HANDLE hThread, HANDLE hEvent)
{

	DPF(7, "Entering PRV_KillThread");
	DPF(9, "Parameters: 0x%08x, 0x%08x", hThread, hEvent);
	
	ASSERT(hThread);
	ASSERT(hEvent);
	
	// Signal the thread to die.
	SetEvent(hEvent);

	// Wait until the thread terminates, if it doesn't something is
	// wrong, so we better fix it.
	DPF(8, "Starting to wait for a thread to exit -- hThread = 0x%08x, hEvent = 0x%08x", hThread, hEvent);
	WaitForSingleObject(hThread, INFINITE);

	// Now close both handles
	CloseHandle(hThread);
	CloseHandle(hEvent);

} // PRV_KillThread



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeGameNode"
HRESULT PRV_FreeGameNode(LPDPLOBBYI_GAMENODE lpgn)
{
	LPDPLOBBYI_BUFFERCONTROL	lpControl = NULL;


	DPF(7, "Entering PRV_FreeGameNode");
	DPF(9, "Parameters: 0x%08x", lpgn);

	// FIRST: Take care of the connection settings data buffer
	// Unmap & release the shared memory
	if(lpgn->lpConnectDataBuffer)
		UnmapViewOfFile(lpgn->lpConnectDataBuffer);

	if(lpgn->hConnectDataFile)
		CloseHandle(lpgn->hConnectDataFile);

	if(lpgn->hConnectDataMutex)
		CloseHandle(lpgn->hConnectDataMutex);

	// NEXT: Take care of the App Data Events & Buffers
	// Kill the Receive Thread
	if(lpgn->hReceiveThread)
	{
		PRV_KillThread(lpgn->hReceiveThread, lpgn->hKillReceiveThreadEvent);
		CloseHandle(lpgn->hDupReceiveEvent);
	}

	// Close the event handles
	if(lpgn->hLobbyWriteEvent)
		CloseHandle(lpgn->hLobbyWriteEvent);

	if(lpgn->hGameWriteEvent)
		CloseHandle(lpgn->hGameWriteEvent);

	// Kill the Terminate Monitor Thread
	if(lpgn->hTerminateThread)
	{
		PRV_KillThread(lpgn->hTerminateThread, lpgn->hKillTermThreadEvent);
	}

	// Clear the flags since we are no longer going to be active
	if(lpgn->lpGameWriteBuffer)
	{
		lpControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpGameWriteBuffer;
		lpControl->dwFlags &= ~((lpgn->dwFlags & GN_LOBBY_CLIENT) ?
					BC_LOBBY_ACTIVE : BC_GAME_ACTIVE);
	}

	if(lpgn->lpLobbyWriteBuffer)
	{
		lpControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpLobbyWriteBuffer;
		lpControl->dwFlags &= ~((lpgn->dwFlags & GN_LOBBY_CLIENT) ?
					BC_LOBBY_ACTIVE : BC_GAME_ACTIVE);
	}

	// Unmap & release the Game Write memory
	if(lpgn->lpGameWriteBuffer)
		UnmapViewOfFile(lpgn->lpGameWriteBuffer);

	if(lpgn->hGameWriteFile)
		CloseHandle(lpgn->hGameWriteFile);

	if(lpgn->hGameWriteMutex)
		CloseHandle(lpgn->hGameWriteMutex);

	// Unmap & release the Lobby Write memory
	if(lpgn->lpLobbyWriteBuffer)
		UnmapViewOfFile(lpgn->lpLobbyWriteBuffer);

	if(lpgn->hLobbyWriteFile)
		CloseHandle(lpgn->hLobbyWriteFile);

	if(lpgn->hLobbyWriteMutex)
		CloseHandle(lpgn->hLobbyWriteMutex);

	// Clean up the message queue
	PRV_CleanUpQueue(lpgn);

	// Close the process handle we have for the game
	if(lpgn->hGameProcess)
		CloseHandle(lpgn->hGameProcess);
	
	// Free the game node structure
	DPMEM_FREE(lpgn);

	return DP_OK;

} // PRV_FreeGameNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DuplicateHandle"
HANDLE PRV_DuplicateHandle(HANDLE hSource)
{
	HANDLE					hProcess = NULL;
	HANDLE					hTarget = NULL;
	DWORD					dwProcessID;
	DWORD					dwError;


	DPF(7, "Entering PRV_DuplicateHandle");
	DPF(9, "Parameters: 0x%08x", hSource);

	dwProcessID = GetCurrentProcessId();
	hProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessID);
	if(!DuplicateHandle(hProcess, hSource, hProcess, &hTarget,
					0L, FALSE, DUPLICATE_SAME_ACCESS))
	{
		dwError = GetLastError();
		CloseHandle(hProcess);
		return NULL;
	}

	CloseHandle(hProcess);
	return hTarget;

} // PRV_DuplicateHandle



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SetLobbyMessageEvent"
HRESULT DPLAPI DPL_SetLobbyMessageEvent(LPDIRECTPLAYLOBBY lpDPL,
									DWORD dwFlags, DWORD dwGameID,
									HANDLE hReceiveEvent)
{
    LPDPLOBBYI_DPLOBJECT		this;
	LPDPLOBBYI_GAMENODE			lpgn = NULL;
	LPVOID						lpBuffer = NULL;
	HANDLE						hReceiveThread = NULL;
	HANDLE						hDupReceiveEvent = NULL;
	HRESULT						hr;
	BOOL						bCreated = FALSE;
	BOOL						bLobbyClient = TRUE;
	BOOL						bNewEvent = FALSE;


	DPF(7, "Entering DPL_SetLobbyMessageEvent");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, dwGameID, hReceiveEvent);

    ENTER_DPLOBBY();

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }

		// Validate the handle
		if(hReceiveEvent)
		{
			if(!OS_IsValidHandle(hReceiveEvent))
			{
				LEAVE_DPLOBBY();
				DPF_ERR("Invalid hReceiveEvent handle");
				return DPERR_INVALIDPARAMS;
			}
		}

		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDPARAMS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// If the dwGameID is zero, we assume we are a game.  In that case,
	// the GameNode we are looking for should have our own ProcessID.
	if(!dwGameID)
	{
		dwGameID = GetCurrentProcessId();
		bLobbyClient = FALSE;
	}

	ENTER_DPLGAMENODE();
	
	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);


	// If the event handle is null, kill our duplicate handle
	if(!hReceiveEvent)
	{
		if(!lpgn)
		{
			DPF(5, "Unable to find GameNode -- Invalid dwGameID!");
			LEAVE_DPLGAMENODE();
			LEAVE_DPLOBBY();
			return DPERR_GENERIC;
		}

		CloseHandle(lpgn->hDupReceiveEvent);
		lpgn->hDupReceiveEvent = NULL;
		LEAVE_DPLGAMENODE();
		LEAVE_DPLOBBY();
		return DP_OK;
	}

	// If a GameNode structure exists for this process, we must be trying
	// to replace the event handle, so kill the old event handle, OTHERWISE
	// we need to allocate a new GameNode for this process
	if(lpgn)
	{
		if(lpgn->hDupReceiveEvent)
		{
			CloseHandle(lpgn->hDupReceiveEvent);
			lpgn->hDupReceiveEvent = NULL;
		}
	}
	else
	{
		// If we are a game, go ahead and create the node
		if(!bLobbyClient)
		{
			hr = PRV_AddNewGameNode(this, &lpgn, dwGameID, NULL, bLobbyClient,NULL);
			if(FAILED(hr))
			{
				LEAVE_DPLGAMENODE();
				LEAVE_DPLOBBY();
				return hr;
			}
		}
		else
		{
			LEAVE_DPLGAMENODE();
			LEAVE_DPLOBBY();
			return DPERR_INVALIDPARAMS;
		}

	}

	// Duplicate the caller's handle in case they free it without calling
	// us first to remove the Receive thread.
	hDupReceiveEvent = PRV_DuplicateHandle(hReceiveEvent);
	if(!hDupReceiveEvent)
	{
		DPF(2, "Unable to duplicate ReceiveEvent handle");
		LEAVE_DPLGAMENODE();
		LEAVE_DPLOBBY();
		return DPERR_OUTOFMEMORY;
	}

	if(!lpgn->hDupReceiveEvent)
		bNewEvent = TRUE;
	lpgn->hDupReceiveEvent = hDupReceiveEvent;

	// Check to see if the Receive thread already exists. If it
	// doesn't, create it.  Otherwise, leave it alone.
	if(!(lpgn->hReceiveThread))
	{
		hr = PRV_StartReceiveThread(lpgn);
		if(FAILED(hr))
		{
			if(lpgn->hDupReceiveEvent)
			{
				CloseHandle(lpgn->hDupReceiveEvent);
				lpgn->hDupReceiveEvent = NULL;
			}

			LEAVE_DPLGAMENODE();
			LEAVE_DPLOBBY();
			return hr;
		}
	}

	// If this is a new event, check to see if there are any messages in the
	// queue.  If there are, kick the event so the user knows they are there.
	if(bNewEvent && lpgn->dwMessageCount)
		SetEvent(hDupReceiveEvent);

	LEAVE_DPLGAMENODE();
	LEAVE_DPLOBBY();
	return DP_OK;

} // DPL_SetLobbyMessageEvent


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SendLobbyMessage"
HRESULT DPLAPI DPL_SendLobbyMessage(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
					DWORD dwGameID, LPVOID lpData, DWORD dwSize)
{
    LPDPLOBBYI_DPLOBJECT	this;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
	LPDPLMSG_GENERIC		lpmsg = NULL;
    HRESULT					hr = DP_OK;
	BOOL					bLobbyClient = TRUE;
	BOOL					bStandard = FALSE;


	DPF(7, "Entering DPL_SendLobbyMessage");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu",
			lpDPL, dwFlags, dwGameID, lpData, dwSize);

    ENTER_DPLOBBY();

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }

        if( !VALID_READ_PTR( lpData, dwSize ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDPARAMS;
        }

		// Check for valid flags
		if( !VALID_SENDLOBBYMESSAGE_FLAGS(dwFlags))
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDFLAGS;
		}

		// If it's of the system message format, validate the dwType
		if( dwFlags & DPLMSG_STANDARD )
		{
			// Mark this as a standard message
			bStandard = TRUE;
			
			// Make sure the message is big enough to read
			if(! VALID_READ_PTR( lpData, sizeof(DPLMSG_GENERIC)) )
			{
				LEAVE_DPLOBBY();
				DPF_ERR("Invalid message buffer");
				return DPERR_INVALIDPARAMS;
			}
			
			// Make sure it's one we support
			lpmsg = (LPDPLMSG_GENERIC)lpData;			
			switch(lpmsg->dwType)
			{
				case DPLSYS_GETPROPERTY:
				case DPLSYS_SETPROPERTY:
					break;
				default:
					DPF_ERR("The dwType of the message is invalid for a legal standard lobby message");
					LEAVE_DPLOBBY();
					return DPERR_INVALIDPARAMS;
			}
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If a GameID was passed in, use it to find the correct GameNode.  If
	// one wasn't passed in, assume we are the game and use our ProcessID.
	if(!dwGameID)
	{
		dwGameID = GetCurrentProcessId();
		bLobbyClient = FALSE;
	}

	// Now find the correct game node.  If we don't find it, assume we
	// have an invalid ID and error out.
	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);
	if(!lpgn)
	{
		LEAVE_DPLOBBY();
		DPF_ERR("Invalid dwGameID");
		return DPERR_INVALIDPARAMS;
	}

	// If we are self-lobbied, we need to send the message onto the lobby
	// using the IDP3 interface that we are communicating with the lobby on
	// If not, we need to put it in the shared buffer and let the lobby
	// client deal with it.
	if(lpgn->dwFlags & GN_SELF_LOBBIED)
	{
		// Drop the lobby lock so we can call PRV_Send
		LEAVE_DPLOBBY();
		
		// Foward the message
		hr = PRV_ForwardMessageToLobbyServer(lpgn, lpData, dwSize, bStandard);
		
		// Take the lock back
		ENTER_DPLOBBY();
		
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to send lobby system message, hr = 0x%08x", hr);
		}
	}
	else
	{
		// Write the data to our shared memory
		hr = PRV_WriteClientData(lpgn, dwFlags, lpData, dwSize);
	}

	LEAVE_DPLOBBY();
	return hr;

} // DPL_SendLobbyMessage



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetMessageFromQueue"
HRESULT PRV_GetMessageFromQueue(LPDPLOBBYI_GAMENODE lpgn, LPDWORD lpdwFlags,
								LPVOID lpData, LPDWORD lpdwSize)
{
	LPDPLOBBYI_MESSAGE	lpm;


	DPF(7, "Entering PRV_GetMessageFromQueue");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpgn, lpdwFlags, lpData, lpdwSize);

	ENTER_DPLQUEUE();

	// Get the top message in the queue
	lpm = lpgn->MessageHead.lpNext;

	// Make sure we have a message
	if((!lpgn->dwMessageCount) || (lpm == &lpgn->MessageHead))
	{
		LEAVE_DPLQUEUE();
		return DPERR_NOMESSAGES;
	}

	// If the lpData pointer is NULL, just return the size
	if(!lpData)
	{
		*lpdwSize = lpm->dwSize;
		LEAVE_DPLQUEUE();
		return DPERR_BUFFERTOOSMALL;
	}

	// Otherwise, check the remaining output parameters
	if( !VALIDEX_CODE_PTR( lpData ) )
	{
		LEAVE_DPLQUEUE();
		return DPERR_INVALIDPARAMS;
	}

	if( !VALID_DWORD_PTR( lpdwFlags ) )
	{
		LEAVE_DPLQUEUE();
		return DPERR_INVALIDPARAMS;
	}

	// Copy the message
	if(*lpdwSize < lpm->dwSize)
	{
		*lpdwSize = lpm->dwSize;
		LEAVE_DPLQUEUE();
		return DPERR_BUFFERTOOSMALL;
	}
	else
		memcpy(lpData, lpm->lpData, lpm->dwSize);

	// Set the other output parameters
	*lpdwSize = lpm->dwSize;
	*lpdwFlags = lpm->dwFlags;


	// Delete the message from the queue & decrement the count
	PRV_RemoveNodeFromQueue(lpgn, lpm);

	// Check and see if our GAMENODE is dead.  If it is, and if the message
	// count has gone to zero, then free the GAMENODE structure.
	if((!lpgn->dwMessageCount) && IS_GAME_DEAD(lpgn))
		PRV_RemoveGameNodeFromList(lpgn);

	LEAVE_DPLQUEUE();
	return DP_OK;

} // PRV_GetMessageFromQueue


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ReceiveLobbyMessage"
HRESULT DPLAPI DPL_ReceiveLobbyMessage(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
					DWORD dwGameID, LPDWORD lpdwMessageFlags, LPVOID lpData,
					LPDWORD lpdwDataLength)
{
    LPDPLOBBYI_DPLOBJECT	this;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
    HRESULT					hr = DP_OK;
	BOOL					bLobbyClient = TRUE;


	DPF(7, "Entering DPL_ReceiveLobbyMessage");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
		lpDPL, dwFlags, dwGameID, lpdwMessageFlags, lpData, lpdwDataLength);

    ENTER_DPLOBBY();

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }

		if( !VALID_DWORD_PTR( lpdwDataLength ) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDPARAMS;
		}

		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDFLAGS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If a GameID was passed in, use it to find the correct GameNode.  If
	// one wasn't passed in, assume we are the game and use our ProcessID.
	if(!dwGameID)
	{
		dwGameID = GetCurrentProcessId();
		bLobbyClient = FALSE;
	}

	// Now find the correct game node.  If we don't find it, assume we
	// have an invalid ID and error out.
	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);
	if(!lpgn)
	{
		DPF_ERR("Invalid dwGameID");
		hr = DPERR_INVALIDPARAMS;
		goto EXIT_RECEIVE_LOBBY_MESSAGE;
	}

	// Read the data from shared memory
	hr = PRV_GetMessageFromQueue(lpgn, lpdwMessageFlags, lpData, lpdwDataLength);

	// REVIEW!!!! -- Do we need to send this to the lobby server as part of this API????

EXIT_RECEIVE_LOBBY_MESSAGE:

	LEAVE_DPLOBBY();
	return hr;

} // DPL_ReceiveLobbyMessage


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_WriteConnectionSettings"
HRESULT PRV_WriteConnectionSettings(LPDPLOBBYI_GAMENODE lpgn,
			LPDPLCONNECTION lpConn, BOOL bOverrideWaitMode)
{
    HRESULT					hr;
	DWORD					dwSize;
	BOOL					bGameCreate = FALSE;
	LPBYTE					lpConnBuffer = NULL;
	LPDPLOBBYI_CONNCONTROL	lpConnControl = NULL;


	DPF(7, "Entering PRV_WriteConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu",
			lpgn, lpConn, bOverrideWaitMode);

	ENTER_DPLGAMENODE();

	// Make sure we have a valid shared memory buffer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		// HACK!!!! -- SetConnectionSettings may get called from the game
		// without having been lobbied.  If that is the case, we need to
		// create the shared memory with the game's process ID (this process)
		if(!(lpgn->dwFlags & GN_LOBBY_CLIENT))
		{
			// Fake the setup routine by setting the lobby client flag
			lpgn->dwFlags |= GN_LOBBY_CLIENT;

			// Set our flag
			bGameCreate = TRUE;
		}

		hr = PRV_SetupAllSharedMemory(lpgn);

		// HACK!!!! -- Reset the settings we changed to fake the setup routines
		if(bGameCreate)
		{
			lpgn->dwFlags &= (~GN_LOBBY_CLIENT);
		}

		// Now handle the failure
		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF(2, "Unable to access Connection Settings memory");
			return hr;
		}
	}

	// If the ConnectionSettings come from a StartSession message, we need to
	// pick the dplay object pointer out of the DPLCONNECTION structure's
	// reserved field.  This pointer to a dplay object represents the object
	// that has a connection to the lobby server.
	if(lpConn->lpSessionDesc->dwReserved1)
	{
		// Save the pointer and player ID in our gamenode structure
		lpgn->lpDPlayObject = (LPDPLAYI_DPLAY)lpConn->lpSessionDesc->dwReserved1;
		lpgn->dpidPlayer = (DWORD)lpConn->lpSessionDesc->dwReserved2;

		// Clear the field
		lpConn->lpSessionDesc->dwReserved1 = 0L;
		lpConn->lpSessionDesc->dwReserved2 = 0L;
	}

	// Save the instance pointer for the system messages
	lpgn->guidInstance = lpConn->lpSessionDesc->guidInstance;

	// Get the packaged size of the DPLCONNECTION structure
	PRV_GetDPLCONNECTIONPackageSize(lpConn, &dwSize, NULL);

	// Check data sizes
	if(dwSize > (MAX_APPDATABUFFERSIZE - APPDATA_RESERVEDSIZE))
	{
		DPF(2, "Packaged Connection Settings exceeded max buffer size of %d",
				(MAX_APPDATABUFFERSIZE - APPDATA_RESERVEDSIZE));
		LEAVE_DPLGAMENODE();
		return DPERR_BUFFERTOOLARGE;
	}

	// Make sure we have the mutex for the shared conn settings buffer
	WaitForSingleObject(lpgn->hConnectDataMutex, INFINITE);

	// Look at the control block to see if we are in wait mode
	// If we are, and this is not a call from RunApplication, then
	// we don't want to write the connection settings
	hr = DPERR_UNAVAILABLE;		// Default set to error
	lpConnControl = (LPDPLOBBYI_CONNCONTROL)lpgn->lpConnectDataBuffer;
	if((!(lpConnControl->dwFlags & BC_WAIT_MODE)) || bOverrideWaitMode)
	{
		// Get a pointer to the actual buffer
		lpConnBuffer = (LPBYTE)lpConnControl + sizeof(DPLOBBYI_CONNCONTROL);

		// Package the connection settings into the buffer
		hr = PRV_PackageDPLCONNECTION(lpConn, lpConnBuffer, TRUE);
		
		// If it succeeded, and we were overriding wait mode, we need
		// to take the buffers out of wait mode and send the new connection
		// settings available message
		if(SUCCEEDED(hr) && bOverrideWaitMode)
		{
			// Take the buffers out of wait mode
			PRV_LeaveConnSettingsWaitMode(lpgn);
		}
	}

	ReleaseMutex(lpgn->hConnectDataMutex);

	LEAVE_DPLGAMENODE();
	return hr;

} // PRV_WriteConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetConnectionSettings"
HRESULT PRV_SetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
					DWORD dwGameID,	LPDPLCONNECTION lpConn)
{
    LPDPLOBBYI_DPLOBJECT	this;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
    HRESULT					hr;
	BOOL					bLobbyClient = TRUE;


	DPF(7, "Entering PRV_SetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, dwGameID, lpConn);

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            return DPERR_INVALIDOBJECT;
        }

		// Validate the DPLCONNECTION structure
		hr = PRV_ValidateDPLCONNECTION(lpConn, FALSE);
		if(FAILED(hr))
		{
			return hr;
		}

		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            return DPERR_INVALIDFLAGS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If dwGameID is zero, we assume we are a game.  In that case, the
	// GameNode we are looking for should have our ProcessID.
	if(!dwGameID)
	{
		dwGameID = GetCurrentProcessId();
		bLobbyClient = FALSE;
	}

	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);
	if(!lpgn)
	{
		// If we are a game, go ahead and create the node
		if(!bLobbyClient)
		{
			hr = PRV_AddNewGameNode(this, &lpgn, dwGameID, NULL, bLobbyClient,NULL);
			if(FAILED(hr))
				return hr;
		}
		else
			return DPERR_INVALIDPARAMS;

	}
	
	// If the ConnectionSettings are from a StartSession message (lobby launched),
	// we need to set the flag saying we are self-lobbied
	if(lpConn->lpSessionDesc->dwReserved1)
	{
		// Set the flag that says we were lobby client launched
		lpgn->dwFlags |= GN_SELF_LOBBIED;
	}

	// Write the connection settings to our shared buffer
	hr = PRV_WriteConnectionSettings(lpgn, lpConn, FALSE);

	return hr;

} // PRV_SetConnectionSettings


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SetConnectionSettings"
HRESULT DPLAPI DPL_SetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, DWORD dwGameID, LPDPLCONNECTION lpConn)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_SetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, dwGameID, lpConn);

    ENTER_DPLOBBY();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_SetConnectionSettings(lpDPL, dwFlags, dwGameID, lpConn);

	LEAVE_DPLOBBY();
	return hr;

} // DPL_SetConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ReadConnectionSettings"
HRESULT PRV_ReadConnectionSettings(LPDPLOBBYI_GAMENODE lpgn, LPVOID lpData,
											LPDWORD lpdwSize, BOOL bAnsi)
{
    HRESULT					hr = DP_OK;
	LPDWORD					lpdwBuffer;
	LPDPLOBBYI_CONNCONTROL	lpConnControl = NULL;
	LPBYTE					lpConnBuffer = NULL;
	DWORD					dwSize = 0,
							dwSizeAnsi,
							dwSizeUnicode;


	DPF(7, "Entering PRV_ReadConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, %lu",
			lpgn, lpData, lpdwSize, bAnsi);

	// Make sure we have a valid memory pointer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	ENTER_DPLGAMENODE();
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		hr = PRV_SetupAllSharedMemory(lpgn);
		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF(5, "Unable to access Connect Data memory");
			return DPERR_NOTLOBBIED;
		}
	}

	// Grab the shared buffer mutex
	WaitForSingleObject(lpgn->hConnectDataMutex, INFINITE);

	// Make sure we are not in wait mode without being in pending mode
	lpConnControl = (LPDPLOBBYI_CONNCONTROL)lpgn->lpConnectDataBuffer;
	if((lpConnControl->dwFlags & BC_WAIT_MODE) &&
		!(lpConnControl->dwFlags & BC_PENDING_CONNECT))
	{
		hr = DPERR_UNAVAILABLE;
		goto EXIT_READ_CONN_SETTINGS;
	}

	// Take us out of wait mode and pending mode
	PRV_LeaveConnSettingsWaitMode(lpgn);

	// Verify that the buffer is big enough.  If it's not, OR if the lpData
	// buffer pointer is NULL, just set the lpdwSize parameter to the
	// correct size and return an error.  Note: In our packed structure, the
	// first DWORD is the size of the packed structure with Unicode strings
	// and the second DWORD is the size of the packed structure with ANSI.
	lpConnBuffer = (LPBYTE)lpConnControl + sizeof(DPLOBBYI_CONNCONTROL);
	lpdwBuffer = (LPDWORD)lpConnBuffer;
	dwSizeUnicode = *lpdwBuffer++;
	dwSizeAnsi = *lpdwBuffer;
	dwSize = (bAnsi) ? dwSizeAnsi : dwSizeUnicode;

	if(((*lpdwSize) < dwSize) || (!lpData))
	{
		if(bAnsi)
			*lpdwSize = dwSizeAnsi;
		else		
			*lpdwSize = dwSizeUnicode;

		hr = DPERR_BUFFERTOOSMALL;
		goto EXIT_READ_CONN_SETTINGS;
	}

	// Copy the DPLCONNECTION structure, taking the ANSI conversion
	// into account if necessary.
	if(bAnsi)
		hr = PRV_UnpackageDPLCONNECTIONAnsi(lpData, lpConnBuffer);
	else
		hr = PRV_UnpackageDPLCONNECTIONUnicode(lpData, lpConnBuffer);

	// If we haven't yet saved off the Instance guid for the game, save
	// it now so that we have it for the system messages
	if(IsEqualGUID(&lpgn->guidInstance, &GUID_NULL))
		lpgn->guidInstance = ((LPDPLCONNECTION)lpData)->lpSessionDesc->guidInstance;

	// Fall through

EXIT_READ_CONN_SETTINGS:

	ReleaseMutex(lpgn->hConnectDataMutex);
	LEAVE_DPLGAMENODE();
	return hr;	

} // PRV_ReadConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetConnectionSettings"
HRESULT PRV_GetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL, DWORD dwGameID,
							LPVOID lpData, LPDWORD lpdwSize, BOOL bAnsi)
{
    LPDPLOBBYI_DPLOBJECT	this;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
    HRESULT					hr;
	BOOL					bLobbyClient = TRUE;


	DPF(7, "Entering PRV_GetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu",
			lpDPL, dwGameID, lpData, lpdwSize, bAnsi);

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            return DPERR_INVALIDOBJECT;
        }

		if( !VALID_DWORD_PTR( lpdwSize ) )
		{
			DPF_ERR("lpdwSize was not a valid dword pointer!");
			return DPERR_INVALIDPARAMS;
		}

		if(lpData)
		{
			if( !VALID_WRITE_PTR(lpData, *lpdwSize) )
			{
				DPF_ERR("lpData is not a valid output buffer of the size specified in *lpdwSize");
				return DPERR_INVALIDPARAMS;
			}
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If dwGameID is zero, we assume we are a game.  In that case, the
	// GameNode we are looking for should have our ProcessID.
	if(!dwGameID)
	{
		dwGameID = GetCurrentProcessId();
		bLobbyClient = FALSE;
	}

	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);
	if(!lpgn)
	{
		// If we are a game, go ahead and create the node
		if(!bLobbyClient)
		{
			hr = PRV_AddNewGameNode(this, &lpgn, dwGameID, NULL, bLobbyClient,NULL);
			if(FAILED(hr))
				return hr;
		}
		else
			return DPERR_INVALIDPARAMS;
	}
	
	// Read the data from our shared memory
	hr = PRV_ReadConnectionSettings(lpgn, lpData, lpdwSize, bAnsi);

	return hr;

} // PRV_GetConnectionSettings


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_GetConnectionSettings"
HRESULT DPLAPI DPL_GetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwGameID, LPVOID lpData, LPDWORD lpdwSize)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_GetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwGameID, lpData, lpdwSize);

    ENTER_DPLOBBY();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_GetConnectionSettings(lpDPL, dwGameID, lpData,
									lpdwSize, FALSE);

	LEAVE_DPLOBBY();
	return hr;

} // DPL_GetConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_RemoveGameNodeFromList"
void PRV_RemoveGameNodeFromList(LPDPLOBBYI_GAMENODE lpgn)
{
	LPDPLOBBYI_GAMENODE	lpgnTemp;
	BOOL				bFound = FALSE;


	DPF(7, "Entering PRV_RemoveGameNodeFromList");
	DPF(9, "Parameters: 0x%08x", lpgn);

	// Get the head pointer
	lpgnTemp = lpgn->this->lpgnHead;

	// Make sure it's not the first node.  If it is, move the head pointer
	if(lpgnTemp == lpgn)
	{
		lpgn->this->lpgnHead = lpgn->lpgnNext;
		PRV_FreeGameNode(lpgn);
		return;
	}

	// Walk the list looking for the previous node
	while(lpgnTemp)
	{
		if(lpgnTemp->lpgnNext == lpgn)
		{
			bFound = TRUE;
			break;
		}

		lpgnTemp = lpgnTemp->lpgnNext;
	}

	if(!bFound)
	{
		DPF_ERR("Unable to remove GameNode from list!");
		return;
	}

	// We've now got it's previous one, so remove it from the linked list
	// and delete it.
	lpgnTemp->lpgnNext = lpgn->lpgnNext;
	PRV_FreeGameNode(lpgn);

	return;

}  // PRV_RemoveGameNodeFromList



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ClientTerminateNotification"
DWORD WINAPI PRV_ClientTerminateNotification(LPVOID lpParam)
{
    LPDPLOBBYI_GAMENODE		lpgn = (LPDPLOBBYI_GAMENODE)lpParam;
	DPLMSG_SYSTEMMESSAGE	msg;
	HANDLE					hObjects[3];
	HRESULT					hr;
	DWORD					dwResult;
	DWORD					dwError;


	DPF(7, "Entering PRV_ClientTerminateNotification");
	DPF(9, "Parameters: 0x%08x", lpParam);

	// Setup the objects to wait on -- one process handle, one kill event
	hObjects[0] = lpgn->hGameProcess;
	hObjects[1] = lpgn->hKillTermThreadEvent;
	// This extra handle is here because of a Windows 95 bug.  Windows
	// will occasionally miss when it walks the handle table, causing
	// my thread to wait on the wrong handles.  By putting a guaranteed
	// invalid handle at the end of our array, the kernel will do a
	// forced re-walk of the handle table and find the correct handles.
	hObjects[2] = INVALID_HANDLE_VALUE;

	// Wait for the event notification
	while(1)
	{
		// Wait for the process to go away
		dwResult = WaitForMultipleObjects(2, (HANDLE *)hObjects,
											FALSE, INFINITE);

		// If we are signalled by anything but the process going away,
		// just kill the thread.
		if(dwResult != WAIT_OBJECT_0)
		{
			if(dwResult == WAIT_FAILED)
			{
				// This is a Windows 95 bug -- We may have gotten
				// kicked for no reason.  If that was the case, we
				// still have valid handles (we think), the OS
				// just goofed up.  So, validate the handle and if
				// they are valid, just return to waiting.  See
				// bug #3340 for a better explanation.
				dwError = GetLastError();
				if(ERROR_INVALID_HANDLE == dwError)
				{
					if(!OS_IsValidHandle(hObjects[0]))
						break;
					if(!OS_IsValidHandle(hObjects[1]))
						break;
					continue;
				}
				break;
			}
			else
			{
				// This is something we don't understand, so just go away.
				ExitThread(0L);
				return 0L;
			}
		}
		else
		{
			// This is our process handle going away, so bail out of
			// the wait loop and send the system message.
			break;
		}
	}

	// Send the system message which says the app terminated
	memset(&msg, 0, sizeof(DPLMSG_SYSTEMMESSAGE));
	msg.dwType = DPLSYS_APPTERMINATED;
	msg.guidInstance = lpgn->guidInstance;
	hr = PRV_InjectMessageInQueue(lpgn, DPLAD_SYSTEM, &msg,
							sizeof(DPLMSG_SYSTEMMESSAGE), TRUE);
	if(FAILED(hr))
	{
		DPF(0, "Failed to send App Termination message, hr = 0x%08x", hr);
	}

	// Mark the GAMENODE as dead, but don't remove it since we know
	// there are still messages in the queue.
	lpgn->dwFlags |= GN_DEAD_GAME_NODE;

	ExitThread(0L);

	return 0L; // avoid warning.
} // PRV_ClientTerminateNotification



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_WaitForConnectionSettings"
HRESULT DPLAPI DPL_WaitForConnectionSettings(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags)
{
    LPDPLOBBYI_DPLOBJECT		this;
	LPDPLOBBYI_GAMENODE			lpgn = NULL;
	LPDPLOBBYI_CONNCONTROL		lpConnControl = NULL;
	LPDPLOBBYI_BUFFERCONTROL	lpBuffControl = NULL;
	HRESULT						hr = DP_OK;
	BOOL						bCreated = FALSE;
	DWORD						dwProcessID;
	BOOL						bGameCreate = FALSE;
	BOOL						bMessages = TRUE;


	DPF(7, "Entering DPL_WaitForConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpDPL, dwFlags);

    ENTER_DPLOBBY();

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
			return DPERR_INVALIDOBJECT;
        }

		if(!VALID_WAIT_FLAGS(dwFlags))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Get the game node
	dwProcessID = GetCurrentProcessId();
	lpgn = PRV_GetGameNode(this->lpgnHead, dwProcessID);
	if(!lpgn)
	{
		// Create the game node
		hr = PRV_AddNewGameNode(this, &lpgn, dwProcessID, NULL, FALSE, NULL);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed creating game node, hr = 0x%08x", hr);
			goto EXIT_WAIT_FOR_CONN_SETTINGS;
		}

		// Set our flag saying we just created the game node
		bCreated = TRUE;
	}

	// when doing a wait for connection settings, we do NOT use the
	// IPC_GUID, this is because the lobby launching us may not have
	// provided the GUID.
	lpgn->dwFlags &= ~(GN_IPCGUID_SET);

	// Make sure we have a valid memory pointer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	ENTER_DPLGAMENODE();
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		// First we need to try to setup access to the buffers assuming
		// they already exist (we were lobby launched).  If this doesn't
		// work, then we need to create them.
		hr = PRV_SetupAllSharedMemory(lpgn);
		if(FAILED(hr))
		{
			// We don't have any memory, so set it up
			// HACK!!!! -- WaitForConnectionSettings may get called from the game
			// without having been lobbied.  If that is the case, we need to
			// create the shared memory with the game's process ID (this process)
			// so we'll set the lobby client flag to fake out the creation
			if(!(lpgn->dwFlags & GN_LOBBY_CLIENT))
			{
				// Fake the setup routine by setting the lobby client flag
				lpgn->dwFlags |= GN_LOBBY_CLIENT;

				// Set our flag
				bGameCreate = TRUE;
			}

			// Setup the shared buffers
			hr = PRV_SetupAllSharedMemory(lpgn);

			// HACK!!!! -- Reset the settings we changed to fake the setup routines
			if(bGameCreate)
			{
				lpgn->dwFlags &= (~GN_LOBBY_CLIENT);
			}
		}

		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF_ERRVAL("Unable to access Connect Data memory, hr = 0x%08x", hr);
			goto EXIT_WAIT_FOR_CONN_SETTINGS;
		}
	}

	// Drop the lock
	LEAVE_DPLGAMENODE();

	// If we are in wait mode, and the caller wants to end it, do so,
	// otherwise, just return success
	WaitForSingleObject(lpgn->hConnectDataMutex, INFINITE);
	lpConnControl = (LPDPLOBBYI_CONNCONTROL)lpgn->lpConnectDataBuffer;
	if(lpConnControl->dwFlags & BC_WAIT_MODE)
	{
		if(dwFlags & DPLWAIT_CANCEL)
		{
			// Release Mutex
			ReleaseMutex(lpgn->hConnectDataMutex);

			// Take us out of wait mode
			PRV_LeaveConnSettingsWaitMode(lpgn);
			goto EXIT_WAIT_FOR_CONN_SETTINGS;
		}
		else
		{
			// Release Mutex
			ReleaseMutex(lpgn->hConnectDataMutex);

			// Might as well just return OK since we're already doing it
			DPF_ERR("We're already in wait mode");
			goto EXIT_WAIT_FOR_CONN_SETTINGS;
		}
	}
	else
	{
		// We're not it wait mode, and the caller asked us to turn it off
		if(dwFlags & DPLWAIT_CANCEL)
		{
			// Release Mutex
			ReleaseMutex(lpgn->hConnectDataMutex);

			DPF_ERR("Cannot turn off wait mode - we're not in wait mode");
			hr = DPERR_UNAVAILABLE;
			goto EXIT_WAIT_FOR_CONN_SETTINGS;
		}
	}

	// Release Mutex
	ReleaseMutex(lpgn->hConnectDataMutex);

	// See if a lobby client exists on the other side, if it does, we
	// need to tell him we are going into wait mode by sending him an
	// AppTerminated message.
	PRV_SendStandardSystemMessage(lpDPL, DPLSYS_APPTERMINATED, 0);

	// Go into wait mode
	PRV_EnterConnSettingsWaitMode(lpgn);

	// Kick the receive thread to empty the buffer (just in case there
	// are any messages in it)
	SetEvent(lpgn->hLobbyWriteEvent);

	// Spin waiting for the buffer to get emptied
	while(bMessages)
	{
		// Grab the mutex for the lobby write buffer
		WaitForSingleObject(lpgn->hLobbyWriteMutex, INFINITE);
		lpBuffControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpLobbyWriteBuffer;

		if(!lpBuffControl->dwMessages)
			bMessages = FALSE;

		// Drop the mutex
		ReleaseMutex(lpgn->hLobbyWriteMutex);

		if(bMessages)
		{
			// Now sleep to give the receive thread a chance to work
			Sleep(50);
		}
	}

	// Now clean out the message queue
	PRV_CleanUpQueue(lpgn);

	// Fall through

EXIT_WAIT_FOR_CONN_SETTINGS:

	LEAVE_DPLOBBY();
	return hr;

} // DPL_WaitForConnectionSettings
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\dplobby.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobby.h
 *  Content:    DirectPlayLobby include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *	Date		By		Reason
 *	===========	=======	==========
 *	4/13/96		myronth	Created it
 *	6/20/96		myronth	Cleaned it up
 *	6/24/96		myronth	More cleanup
 *	7/1/96		myronth	Changed DPLERR_ to DPERR_
 *  7/9/96      ajayj   Cleaned up formatting to match dplay.h
 *  7/15/96     ajayj   Added DPADDRESS chunk tags for dplaunch
 *                      sample app.
 *	7/16/96		kipo	changed address types to be GUIDs instead of 4CC
 *  8/1/96      sohailm Added IDirectPlayLobby interface macros
 *  8/10/96     sohailm Bug#2227: declared pointers in callbacks as const.
 *  8/15/96     sohailm Added type definition for LPCDPLCONNECTION
 *                      Changed LPGUIDs to REFGUIDs in IDirectPlayLobby interface 
 *                      Made function parameters constant where appropriate
 *	8/16/96		andyco	took out some const and ref stuff for ship
 *	8/16/96		myronth	Added SetConnectionSettings & Connect methods
 *  8/21/96     ajayj   replace tabs with spaces
 *	8/21/96		kipo	Added DPCOMPORTADDRESS structure
 *	9/5/96		myronth	Wrapped DPLCAPS with MSINTERNAL
 *	10/23/96	myronth	Added first cut of client/server methods
 *	10/25/96	myronth	Added DX5 methods
 *	12/13/96	myronth	Changed DPLAD_SYSTEM to DPLMSG_SYSTEM
 *	1/30/97		myronth	Added MSINTERNAL's to DX5 stuff for meltdown
 *	2/12/97		myronth	Removed meltdown changes
 *	2/12/97		myronth	Mass DX5 changes
 *	2/18/97		myronth	Implemented GetObjectCaps
 *	3/5/97		andyco	added DPAID_TotalSize
 *	3/12/97		myronth	Added DPAID_LobbyProvider chunk
 *	3/17/97		kipo	Added data structures for CreateCompoundAddress() and
 *						added guids for Unicode phone numbers and IP addresses
 *	3/24/97		kipo	Added support for IDirectPlayLobby2 interface
 *	4/11/97		myronth	Added CLSID_DirectPlayLobby clsid
 *	5/8/97		myronth	Moved DPLCONNECTION structure definition to dplay.h
 *  5/21/97		ajayj	Added structures and definitions for standard lobby 
 *						messages
 *  5/23/97		ajayj	Added DPLDATA_PLAYERGUID structure
 *  5/30/97		ajayj	Added DPLPROPERTY_MessagesSupported GUID
 *	6/7/97		myronth	Fixed CreateCompoundAddress macros
 *	6/6/97		kipo	Added "FAR" to all structures
 *	8/19/97		myronth	Added DPLMSG_NEWSESSIONHOST structure
 *	11/13/97	myronth	Added guidInstance to lobby system messages (#10944)
 *	12/2/97		myronth	Added Register/UnregisterApplication
 *	12/4/97		myronth	Added ConnectEx
 *	1/20/98		myronth	Added WaitForConnectionSettings
 *	1/29/98		sohailm	Added DPAID_INetPort.
 *	2/11/98		a-peterz Clarify that DPAID_INetPort value is a word (#18210)
 *	4/15/98		a-peterz Fix IDirectPlayLobby_CreateCompoundAddress C++ version
 *@@END_MSINTERNAL
 ***************************************************************************/
#ifndef __DPLOBBY_INCLUDED__
#define __DPLOBBY_INCLUDED__

#include "dplay.h"

/* avoid warnings at Level 4 */
#pragma warning(disable:4201)

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*
 * GUIDS used by DirectPlay objects
 */

/* {AF465C71-9588-11cf-A020-00AA006157AC} */
DEFINE_GUID(IID_IDirectPlayLobby, 0xaf465c71, 0x9588, 0x11cf, 0xa0, 0x20, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
/* {26C66A70-B367-11cf-A024-00AA006157AC} */
DEFINE_GUID(IID_IDirectPlayLobbyA, 0x26c66a70, 0xb367, 0x11cf, 0xa0, 0x24, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
/* {0194C220-A303-11d0-9C4F-00A0C905425E} */
DEFINE_GUID(IID_IDirectPlayLobby2, 0x194c220, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
/* {1BB4AF80-A303-11d0-9C4F-00A0C905425E} */
DEFINE_GUID(IID_IDirectPlayLobby2A, 0x1bb4af80, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
/* {2DB72490-652C-11d1-A7A8-0000F803ABFC} */
DEFINE_GUID(IID_IDirectPlayLobby3, 0x2db72490, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
/* {2DB72491-652C-11d1-A7A8-0000F803ABFC} */
DEFINE_GUID(IID_IDirectPlayLobby3A, 0x2db72491, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
/* {2FE8F810-B2A5-11d0-A787-0000F803ABFC} */
DEFINE_GUID(CLSID_DirectPlayLobby, 0x2fe8f810, 0xb2a5, 0x11d0, 0xa7, 0x87, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);


/****************************************************************************
 *
 * IDirectPlayLobby Structures
 *
 * Various structures used to invoke DirectPlayLobby.
 *
 ****************************************************************************/

typedef struct IDirectPlayLobby     FAR *LPDIRECTPLAYLOBBY;
typedef struct IDirectPlayLobby     FAR *LPDIRECTPLAYLOBBYA;
typedef struct IDirectPlayLobby     IDirectPlayLobbyA;

typedef struct IDirectPlayLobby2    FAR *LPDIRECTPLAYLOBBY2;
typedef struct IDirectPlayLobby2    FAR *LPDIRECTPLAYLOBBY2A;
typedef struct IDirectPlayLobby2    IDirectPlayLobby2A;

typedef struct IDirectPlayLobby3    FAR *LPDIRECTPLAYLOBBY3;
typedef struct IDirectPlayLobby3    FAR *LPDIRECTPLAYLOBBY3A;
typedef struct IDirectPlayLobby3    IDirectPlayLobby3A;


/*
 * DPLAPPINFO
 * Used to hold information about a registered DirectPlay
 * application
 */
typedef struct DPLAPPINFO
{
    DWORD       dwSize;             // Size of this structure
    GUID        guidApplication;    // GUID of the Application
    union
    {
        LPSTR   lpszAppNameA;       // Pointer to the Application Name
        LPWSTR  lpszAppName;
    };

} DPLAPPINFO, FAR *LPDPLAPPINFO;

/*
 * LPCDPLAPPINFO
 * A constant pointer to DPLAPPINFO
 */
typedef const DPLAPPINFO FAR *LPCDPLAPPINFO;

/*
 * DPCOMPOUNDADDRESSELEMENT
 *
 * An array of these is passed to CreateCompoundAddresses()
 */
typedef struct DPCOMPOUNDADDRESSELEMENT
{
    GUID                guidDataType;
    DWORD               dwDataSize;
	LPVOID				lpData;
} DPCOMPOUNDADDRESSELEMENT, FAR *LPDPCOMPOUNDADDRESSELEMENT;

/*
 * LPCDPCOMPOUNDADDRESSELEMENT
 * A constant pointer to DPCOMPOUNDADDRESSELEMENT
 */
typedef const DPCOMPOUNDADDRESSELEMENT FAR *LPCDPCOMPOUNDADDRESSELEMENT;

/*
 * LPDPAPPLICATIONDESC
 * Used to register a DirectPlay application
 */
typedef struct DPAPPLICATIONDESC
{
    DWORD       dwSize;
    DWORD       dwFlags;
    union
    {
        LPSTR       lpszApplicationNameA;
        LPWSTR      lpszApplicationName;
    };
    GUID        guidApplication;
    union
    {
        LPSTR       lpszFilenameA;
        LPWSTR      lpszFilename;
    };
    union
    {
        LPSTR       lpszCommandLineA;
        LPWSTR      lpszCommandLine;
    };
    union
    {
        LPSTR       lpszPathA;
        LPWSTR      lpszPath;
    };
    union
    {
        LPSTR       lpszCurrentDirectoryA;
        LPWSTR      lpszCurrentDirectory;
    };
    LPSTR       lpszDescriptionA;
    LPWSTR      lpszDescriptionW;
} DPAPPLICATIONDESC, *LPDPAPPLICATIONDESC;

/*
 * LPDPAPPLICATIONDESC2
 * Used to register a DirectPlay application
 */
typedef struct DPAPPLICATIONDESC2
{
    DWORD       dwSize;
    DWORD       dwFlags;
    union
    {
        LPSTR       lpszApplicationNameA;
        LPWSTR      lpszApplicationName;
    };
    GUID        guidApplication;
    union
    {
        LPSTR       lpszFilenameA;
        LPWSTR      lpszFilename;
    };
    union
    {
        LPSTR       lpszCommandLineA;
        LPWSTR      lpszCommandLine;
    };
    union
    {
        LPSTR       lpszPathA;
        LPWSTR      lpszPath;
    };
    union
    {
        LPSTR       lpszCurrentDirectoryA;
        LPWSTR      lpszCurrentDirectory;
    };
    LPSTR       lpszDescriptionA;
    LPWSTR      lpszDescriptionW;
    union
    {
    	LPSTR		lpszAppLauncherNameA;
    	LPWSTR      lpszAppLauncherName;
    };
} DPAPPLICATIONDESC2, *LPDPAPPLICATIONDESC2;


/****************************************************************************
 *
 * Enumeration Method Callback Prototypes
 *
 ****************************************************************************/

/*
 * Callback for EnumAddress()
 */
typedef BOOL (FAR PASCAL *LPDPENUMADDRESSCALLBACK)(
    REFGUID         guidDataType,
    DWORD           dwDataSize,
    LPCVOID         lpData,
    LPVOID          lpContext);

/*
 * Callback for EnumAddressTypes()
 */
typedef BOOL (FAR PASCAL *LPDPLENUMADDRESSTYPESCALLBACK)(
    REFGUID         guidDataType,
    LPVOID          lpContext,
    DWORD           dwFlags);

/*
 * Callback for EnumLocalApplications()
 */
typedef BOOL (FAR PASCAL * LPDPLENUMLOCALAPPLICATIONSCALLBACK)(
    LPCDPLAPPINFO   lpAppInfo,
    LPVOID          lpContext,
    DWORD           dwFlags);


/****************************************************************************
 *
 * DirectPlayLobby API Prototypes
 *
 ****************************************************************************/
#ifdef UNICODE
#define DirectPlayLobbyCreate   DirectPlayLobbyCreateW
#else
#define DirectPlayLobbyCreate   DirectPlayLobbyCreateA
#endif /* UNICODE */

extern HRESULT WINAPI DirectPlayLobbyCreateW(LPGUID, LPDIRECTPLAYLOBBY *, IUnknown *, LPVOID, DWORD );
extern HRESULT WINAPI DirectPlayLobbyCreateA(LPGUID, LPDIRECTPLAYLOBBYA *, IUnknown *, LPVOID, DWORD );


/****************************************************************************
 *
 * IDirectPlayLobby (and IDirectPlayLobbyA) Interface
 *
 ****************************************************************************/
#undef INTERFACE
#define INTERFACE IDirectPlayLobby
DECLARE_INTERFACE_( IDirectPlayLobby, IUnknown )
{
    /*  IUnknown Methods	*/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectPlayLobby Methods	*/
    STDMETHOD(Connect)              (THIS_ DWORD, LPDIRECTPLAY2 *, IUnknown FAR *) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID, REFGUID, LPCVOID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
    STDMETHOD(EnumAddressTypes)     (THIS_ LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD) PURE;
    STDMETHOD(EnumLocalApplications)(THIS_ LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(GetConnectionSettings)(THIS_ DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(ReceiveLobbyMessage)  (THIS_ DWORD, DWORD, LPDWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(RunApplication)       (THIS_ DWORD, LPDWORD, LPDPLCONNECTION, HANDLE) PURE;
    STDMETHOD(SendLobbyMessage)     (THIS_ DWORD, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetConnectionSettings)(THIS_ DWORD, DWORD, LPDPLCONNECTION) PURE;
    STDMETHOD(SetLobbyMessageEvent) (THIS_ DWORD, DWORD, HANDLE) PURE;

};

/****************************************************************************
 *
 * IDirectPlayLobby2 (and IDirectPlayLobby2A) Interface
 *
 ****************************************************************************/
#undef INTERFACE
#define INTERFACE IDirectPlayLobby2
DECLARE_INTERFACE_( IDirectPlayLobby2, IDirectPlayLobby )
{
    /*  IUnknown Methods	*/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectPlayLobby Methods	*/
    STDMETHOD(Connect)              (THIS_ DWORD, LPDIRECTPLAY2 *, IUnknown FAR *) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID, REFGUID, LPCVOID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
    STDMETHOD(EnumAddressTypes)     (THIS_ LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD) PURE;
    STDMETHOD(EnumLocalApplications)(THIS_ LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(GetConnectionSettings)(THIS_ DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(ReceiveLobbyMessage)  (THIS_ DWORD, DWORD, LPDWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(RunApplication)       (THIS_ DWORD, LPDWORD, LPDPLCONNECTION, HANDLE) PURE;
    STDMETHOD(SendLobbyMessage)     (THIS_ DWORD, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetConnectionSettings)(THIS_ DWORD, DWORD, LPDPLCONNECTION) PURE;
    STDMETHOD(SetLobbyMessageEvent) (THIS_ DWORD, DWORD, HANDLE) PURE;

    /*  IDirectPlayLobby2 Methods	*/
    STDMETHOD(CreateCompoundAddress)(THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlayLobby3 (and IDirectPlayLobby3A) Interface
 *
 ****************************************************************************/
#undef INTERFACE
#define INTERFACE IDirectPlayLobby3
DECLARE_INTERFACE_( IDirectPlayLobby3, IDirectPlayLobby )
{
    /*  IUnknown Methods	*/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectPlayLobby Methods	*/
    STDMETHOD(Connect)              (THIS_ DWORD, LPDIRECTPLAY2 *, IUnknown FAR *) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID, REFGUID, LPCVOID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
    STDMETHOD(EnumAddressTypes)     (THIS_ LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD) PURE;
    STDMETHOD(EnumLocalApplications)(THIS_ LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(GetConnectionSettings)(THIS_ DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(ReceiveLobbyMessage)  (THIS_ DWORD, DWORD, LPDWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(RunApplication)       (THIS_ DWORD, LPDWORD, LPDPLCONNECTION, HANDLE) PURE;
    STDMETHOD(SendLobbyMessage)     (THIS_ DWORD, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetConnectionSettings)(THIS_ DWORD, DWORD, LPDPLCONNECTION) PURE;
    STDMETHOD(SetLobbyMessageEvent) (THIS_ DWORD, DWORD, HANDLE) PURE;

    /*  IDirectPlayLobby2 Methods	*/
    STDMETHOD(CreateCompoundAddress)(THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;

    /*  IDirectPlayLobby3 Methods	*/
    STDMETHOD(ConnectEx)            (THIS_ DWORD, REFIID, LPVOID *, IUnknown FAR *) PURE;
    STDMETHOD(RegisterApplication)  (THIS_ DWORD, LPVOID) PURE;
    STDMETHOD(UnregisterApplication)(THIS_ DWORD, REFGUID) PURE;
    STDMETHOD(WaitForConnectionSettings)(THIS_ DWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlayLobby interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlayLobby_QueryInterface(p,a,b)              (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayLobby_AddRef(p)                          (p)->lpVtbl->AddRef(p)
#define IDirectPlayLobby_Release(p)                         (p)->lpVtbl->Release(p)
#define IDirectPlayLobby_Connect(p,a,b,c)                   (p)->lpVtbl->Connect(p,a,b,c)
#define IDirectPlayLobby_ConnectEx(p,a,b,c,d)               (p)->lpVtbl->ConnectEx(p,a,b,c,d)
#define IDirectPlayLobby_CreateAddress(p,a,b,c,d,e,f)       (p)->lpVtbl->CreateAddress(p,a,b,c,d,e,f)
#define IDirectPlayLobby_CreateCompoundAddress(p,a,b,c,d)   (p)->lpVtbl->CreateCompoundAddress(p,a,b,c,d)
#define IDirectPlayLobby_EnumAddress(p,a,b,c,d)             (p)->lpVtbl->EnumAddress(p,a,b,c,d)
#define IDirectPlayLobby_EnumAddressTypes(p,a,b,c,d)        (p)->lpVtbl->EnumAddressTypes(p,a,b,c,d)
#define IDirectPlayLobby_EnumLocalApplications(p,a,b,c)     (p)->lpVtbl->EnumLocalApplications(p,a,b,c)
#define IDirectPlayLobby_GetConnectionSettings(p,a,b,c)     (p)->lpVtbl->GetConnectionSettings(p,a,b,c)
#define IDirectPlayLobby_ReceiveLobbyMessage(p,a,b,c,d,e)   (p)->lpVtbl->ReceiveLobbyMessage(p,a,b,c,d,e)
#define IDirectPlayLobby_RegisterApplication(p,a,b)         (p)->lpVtbl->RegisterApplication(p,a,b)
#define IDirectPlayLobby_RunApplication(p,a,b,c,d)          (p)->lpVtbl->RunApplication(p,a,b,c,d)
#define IDirectPlayLobby_SendLobbyMessage(p,a,b,c,d)        (p)->lpVtbl->SendLobbyMessage(p,a,b,c,d)
#define IDirectPlayLobby_SetConnectionSettings(p,a,b,c)		(p)->lpVtbl->SetConnectionSettings(p,a,b,c)
#define IDirectPlayLobby_SetLobbyMessageEvent(p,a,b,c)	    (p)->lpVtbl->SetLobbyMessageEvent(p,a,b,c)
#define IDirectPlayLobby_UnregisterApplication(p,a,b)       (p)->lpVtbl->UnregisterApplication(p,a,b)
#define IDirectPlayLobby_WaitForConnectionSettings(p,a)     (p)->lpVtbl->WaitForConnectionSettings(p,a)

#else /* C++ */

#define IDirectPlayLobby_QueryInterface(p,a,b)              (p)->QueryInterface(a,b)
#define IDirectPlayLobby_AddRef(p)                          (p)->AddRef()
#define IDirectPlayLobby_Release(p)                         (p)->Release()
#define IDirectPlayLobby_Connect(p,a,b,c)                   (p)->Connect(a,b,c)
#define IDirectPlayLobby_ConnectEx(p,a,b,c,d)               (p)->ConnectEx(a,b,c,d)
#define IDirectPlayLobby_CreateAddress(p,a,b,c,d,e,f)       (p)->CreateAddress(a,b,c,d,e,f)
#define IDirectPlayLobby_CreateCompoundAddress(p,a,b,c,d)   (p)->CreateCompoundAddress(a,b,c,d)
#define IDirectPlayLobby_EnumAddress(p,a,b,c,d)             (p)->EnumAddress(a,b,c,d)
#define IDirectPlayLobby_EnumAddressTypes(p,a,b,c,d)        (p)->EnumAddressTypes(a,b,c,d)
#define IDirectPlayLobby_EnumLocalApplications(p,a,b,c)     (p)->EnumLocalApplications(a,b,c)
#define IDirectPlayLobby_GetConnectionSettings(p,a,b,c)     (p)->GetConnectionSettings(a,b,c)
#define IDirectPlayLobby_ReceiveLobbyMessage(p,a,b,c,d,e)   (p)->ReceiveLobbyMessage(a,b,c,d,e)
#define IDirectPlayLobby_RegisterApplication(p,a,b)         (p)->RegisterApplication(a,b)
#define IDirectPlayLobby_RunApplication(p,a,b,c,d)          (p)->RunApplication(a,b,c,d)
#define IDirectPlayLobby_SendLobbyMessage(p,a,b,c,d)        (p)->SendLobbyMessage(a,b,c,d)
#define IDirectPlayLobby_SetConnectionSettings(p,a,b,c)		(p)->SetConnectionSettings(a,b,c)
#define IDirectPlayLobby_SetLobbyMessageEvent(p,a,b,c)	    (p)->SetLobbyMessageEvent(a,b,c)
#define IDirectPlayLobby_UnregisterApplication(p,a,b)       (p)->UnregisterApplication(a,b)
#define IDirectPlayLobby_WaitForConnectionSettings(p,a)     (p)->WaitForConnectionSettings(a)

#endif

/****************************************************************************
 *
 * DirectPlayLobby Flags
 *
 ****************************************************************************/

/*
 *	This flag is used by IDirectPlayLobby->WaitForConnectionSettings to
 *	cancel a current wait that is in progress.
 */
#define DPLWAIT_CANCEL                  0x00000001


/*
 *	This is a message flag used by ReceiveLobbyMessage.  It can be
 *	returned in the dwMessageFlags parameter to indicate a message from
 *	the system.
 */
#define DPLMSG_SYSTEM					0x00000001

/*
 *	This is a message flag used by ReceiveLobbyMessage and SendLobbyMessage.
 *  It is used to indicate that the message is a standard lobby message.
 *  DPLMSG_SETPROPERTY, DPLMSG_SETPROPERTYRESPONSE, DPLMSG_GETPROPERTY,
 *	DPLMSG_GETPROPERTYRESPONSE
 */
#define DPLMSG_STANDARD					0x00000002


/****************************************************************************
 *
 * DirectPlayLobby messages and message data structures
 *
 * All system messages have a dwMessageFlags value of DPLMSG_SYSTEM returned
 * from a call to ReceiveLobbyMessage.
 *
 * All standard messages have a dwMessageFlags value of DPLMSG_STANDARD returned
 * from a call to ReceiveLobbyMessage.
 *
 ****************************************************************************/

/*
 * DPLMSG_GENERIC
 * Generic message structure used to identify the message type.
 */
typedef struct _DPLMSG_GENERIC
{
    DWORD       dwType;         // Message type
} DPLMSG_GENERIC, FAR *LPDPLMSG_GENERIC;

/*
 * DPLMSG_SYSTEMMESSAGE
 * Generic message format for all system messages --
 * DPLSYS_CONNECTIONSETTINGSREAD, DPLSYS_DPLYCONNECTSUCCEEDED,
 * DPLSYS_DPLAYCONNECTFAILED, DPLSYS_APPTERMINATED, DPLSYS_NEWCONNECTIONSETTINGS
 */
typedef struct _DPLMSG_SYSTEMMESSAGE
{
    DWORD       dwType;         // Message type
    GUID        guidInstance;   // Instance GUID of the dplay session the message corresponds to
} DPLMSG_SYSTEMMESSAGE, FAR *LPDPLMSG_SYSTEMMESSAGE;

/*
 *  DPLMSG_SETPROPERTY
 *  Standard message sent by an application to a lobby to set a
 *  property
 */
typedef struct _DPLMSG_SETPROPERTY
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID (DPL_NOCONFIRMATION if no confirmation desired)
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
	DWORD	dwDataSize;			// Size of data
	DWORD	dwPropertyData[1];	// Buffer containing data
} DPLMSG_SETPROPERTY, FAR *LPDPLMSG_SETPROPERTY;

#define	DPL_NOCONFIRMATION			0

/*
 *  DPLMSG_SETPROPERTYRESPONSE
 *  Standard message returned by a lobby to confirm a 
 *  DPLMSG_SETPROPERTY message.
 */
typedef struct _DPLMSG_SETPROPERTYRESPONSE
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
	HRESULT	hr;					// Return Code
} DPLMSG_SETPROPERTYRESPONSE, FAR *LPDPLMSG_SETPROPERTYRESPONSE;

/*
 *  DPLMSG_GETPROPERTY
 *  Standard message sent by an application to a lobby to request
 *	the current value of a property
 */
typedef struct _DPLMSG_GETPROPERTY
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
} DPLMSG_GETPROPERTY, FAR *LPDPLMSG_GETPROPERTY;

/*
 *  DPLMSG_GETPROPERTYRESPONSE
 *  Standard message returned by a lobby in response to a
 *	DPLMSG_GETPROPERTY message.
 */
typedef struct _DPLMSG_GETPROPERTYRESPONSE
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
	HRESULT	hr;					// Return Code
	DWORD	dwDataSize;			// Size of data
	DWORD	dwPropertyData[1];	// Buffer containing data
} DPLMSG_GETPROPERTYRESPONSE, FAR *LPDPLMSG_GETPROPERTYRESPONSE;

/*
 *  DPLMSG_NEWSESSIONHOST
 *  Standard message returned by a lobby in response to a
 *	the session host migrating to a new client
 */
typedef struct _DPLMSG_NEWSESSIONHOST
{
    DWORD   dwType;             // Message type
    GUID    guidInstance;       // GUID Instance of the session
} DPLMSG_NEWSESSIONHOST, FAR *LPDPLMSG_NEWSESSIONHOST;


/******************************************
 *
 *	DirectPlay Lobby message dwType values
 *
 *****************************************/

/*
 *  The application has read the connection settings.
 *  It is now O.K. for the lobby client to release
 *  its IDirectPlayLobby interface.
 */
#define DPLSYS_CONNECTIONSETTINGSREAD   0x00000001

/*
 *  The application's call to DirectPlayConnect failed
 */
#define DPLSYS_DPLAYCONNECTFAILED       0x00000002

/*
 *  The application has created a DirectPlay session.
 */
#define DPLSYS_DPLAYCONNECTSUCCEEDED    0x00000003

/*
 *  The application has terminated.
 */
#define DPLSYS_APPTERMINATED            0x00000004

/*
 *  The message is a DPLMSG_SETPROPERTY message.
 */
#define DPLSYS_SETPROPERTY				0x00000005

/*
 *  The message is a DPLMSG_SETPROPERTYRESPONSE message.
 */
#define DPLSYS_SETPROPERTYRESPONSE		0x00000006

/*
 *  The message is a DPLMSG_GETPROPERTY message.
 */
#define DPLSYS_GETPROPERTY				0x00000007

/*
 *  The message is a DPLMSG_GETPROPERTYRESPONSE message.
 */
#define DPLSYS_GETPROPERTYRESPONSE		0x00000008

/*
 *  The message is a DPLMSG_NEWSESSIONHOST message.
 */
#define DPLSYS_NEWSESSIONHOST           0x00000009

/*
 *  New connection settings are available.
 */
#define DPLSYS_NEWCONNECTIONSETTINGS    0x0000000A


/****************************************************************************
 *
 * DirectPlay defined property GUIDs and associated data structures
 *
 ****************************************************************************/

/*
 * DPLPROPERTY_MessagesSupported
 *
 * Request whether the lobby supports standard.  Lobby with respond with either
 * TRUE or FALSE or may not respond at all.
 * 
 * Property data is a single BOOL with TRUE or FALSE
 */
// {762CCDA1-D916-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_MessagesSupported, 
0x762ccda1, 0xd916, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLPROPERTY_LobbyGuid
 *
 * Request the GUID that identifies the lobby software that the application
 * is communicating with.
 *
 * Property data is a single GUID.
 */
// {F56920A0-D218-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_LobbyGuid, 
0xf56920a0, 0xd218, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLPROPERTY_PlayerGuid
 *
 * Request the GUID that identifies the player on this machine for sending
 * property data back to the lobby.
 *
 * Property data is the DPLDATA_PLAYERDATA structure
 */
// {B4319322-D20D-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerGuid, 
0xb4319322, 0xd20d, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLDATA_PLAYERGUID
 *
 * Data structure to hold the GUID of the player and player creation flags
 * from the lobby.
 */
typedef struct _DPLDATA_PLAYERGUID
{
	GUID	guidPlayer;
	DWORD	dwPlayerFlags;
} DPLDATA_PLAYERGUID, FAR *LPDPLDATA_PLAYERGUID;

/*
 * DPLPROPERTY_PlayerScore
 *
 * Used to send an array of long integers to the lobby indicating the 
 * score of a player.
 *
 * Property data is the DPLDATA_PLAYERSCORE structure.
 */
// {48784000-D219-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerScore, 
0x48784000, 0xd219, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLDATA_PLAYERSCORE
 *
 * Data structure to hold an array of long integers representing a player score.
 * Application must allocate enough memory to hold all the scores.
 */
typedef struct _DPLDATA_PLAYERSCORE
{
	DWORD	dwScoreCount;
	LONG	Score[1];
} DPLDATA_PLAYERSCORE, FAR *LPDPLDATA_PLAYERSCORE;

/****************************************************************************
 *
 * DirectPlay Address ID's
 *
 ****************************************************************************/

/* DirectPlay Address
 *
 * A DirectPlay address consists of multiple chunks of data, each tagged
 * with a GUID signifying the type of data in the chunk. The chunk also
 * has a length so that unknown chunk types can be skipped.
 *
 * The EnumAddress() function is used to parse these address data chunks.
 */

/*
 * DPADDRESS
 *
 * Header for block of address data elements
 */
typedef struct _DPADDRESS
{
    GUID                guidDataType;
    DWORD               dwDataSize;
} DPADDRESS;

typedef DPADDRESS FAR *LPDPADDRESS;

/*
 * DPAID_TotalSize
 *
 * Chunk is a DWORD containing size of entire DPADDRESS structure
 */

// {1318F560-912C-11d0-9DAA-00A0C90A43CB}
DEFINE_GUID(DPAID_TotalSize, 
0x1318f560, 0x912c, 0x11d0, 0x9d, 0xaa, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

/*
 * DPAID_ServiceProvider
 *
 * Chunk is a GUID describing the service provider that created the chunk.
 * All addresses must contain this chunk.
 */

// {07D916C0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ServiceProvider, 
0x7d916c0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_LobbyProvider
 *
 * Chunk is a GUID describing the lobby provider that created the chunk.
 * All addresses must contain this chunk.
 */

// {59B95640-9667-11d0-A77D-0000F803ABFC}
DEFINE_GUID(DPAID_LobbyProvider, 
0x59b95640, 0x9667, 0x11d0, 0xa7, 0x7d, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);

/*
 * DPAID_Phone and DPAID_PhoneW
 *
 * Chunk is a string containing a phone number (i.e. "1-800-555-1212")
 * in ANSI or UNICODE format
 */

// {78EC89A0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_Phone, 
0x78ec89a0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {BA5A7A70-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_PhoneW, 
0xba5a7a70, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_Modem and DPAID_ModemW
 *
 * Chunk is a string containing a modem name registered with TAPI
 * in ANSI or UNICODE format
 */

// {F6DCC200-A2FE-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_Modem, 
0xf6dcc200, 0xa2fe, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {01FD92E0-A2FF-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_ModemW, 
0x1fd92e0, 0xa2ff, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_Inet and DPAID_InetW
 *
 * Chunk is a string containing a TCP/IP host name or an IP address
 * (i.e. "dplay.microsoft.com" or "137.55.100.173") in ANSI or UNICODE format
 */

// {C4A54DA0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_INet, 
0xc4a54da0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {E63232A0-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_INetW, 
0xe63232a0, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_InetPort
 *
 * Chunk is the port number used for creating the apps TCP and UDP sockets.
 * WORD value (i.e. 47624).
 */
 
// {E4524541-8EA5-11d1-8A96-006097B01411}
DEFINE_GUID(DPAID_INetPort, 
0xe4524541, 0x8ea5, 0x11d1, 0x8a, 0x96, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

#ifdef BIGMESSAGEDEFENSE
//@@BEGIN_MSINTERNAL
/*
 * DPAID_MaxMessageSize
 *
 * Tells DPLAY what the maximum allowed message size is.  Enables SPs to
 *	combat Denial of Service attacks
 */
 
 // this terrible hack is needed so the SP can work with the Elmer build.
 // it can be removed when the MSINTERNAL stuff is removed
 #define MAXMSGSIZEGUIDDEFINED

// {F5D09980-F0C4-11d1-8326-006097B01411}
DEFINE_GUID(DPAID_MaxMessageSize, 
0xf5d09980, 0xf0c4, 0x11d1, 0x83, 0x26, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
//@@END_MSINTERNAL
#endif

/*
 * DPCOMPORTADDRESS
 *
 * Used to specify com port settings. The constants that define baud rate,
 * stop bits and parity are defined in WINBASE.H. The constants for flow
 * control are given below.
 */

#define DPCPA_NOFLOW        0           // no flow control
#define DPCPA_XONXOFFFLOW   1           // software flow control
#define DPCPA_RTSFLOW       2           // hardware flow control with RTS
#define DPCPA_DTRFLOW       3           // hardware flow control with DTR
#define DPCPA_RTSDTRFLOW    4           // hardware flow control with RTS and DTR

typedef struct _DPCOMPORTADDRESS
{
    DWORD   dwComPort;                  // COM port to use (1-4)
    DWORD   dwBaudRate;                 // baud rate (100-256k)
    DWORD   dwStopBits;                 // no. stop bits (1-2)
    DWORD   dwParity;                   // parity (none, odd, even, mark)
    DWORD   dwFlowControl;              // flow control (none, xon/xoff, rts, dtr)
} DPCOMPORTADDRESS;

typedef DPCOMPORTADDRESS FAR *LPDPCOMPORTADDRESS;

/*
 * DPAID_ComPort
 *
 * Chunk contains a DPCOMPORTADDRESS structure defining the serial port.
 */

// {F2F0CE00-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ComPort, 
0xf2f0ce00, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/****************************************************************************
 *
 * 	dplobby 1.0 obsolete definitions
 *	Included for compatibility only.
 *
 ****************************************************************************/
#define DPLAD_SYSTEM          DPLMSG_SYSTEM


#ifdef __cplusplus
};
#endif /* __cplusplus */

#pragma warning(default:4201)

#endif /* __DPLOBBY_INCLUDED__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\dplobby.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobby.c
 *  Content:	Methods for lobby management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	4/13/96		myronth	Created it
 *	10/23/96	myronth	Added client/server methods
 *	1/2/97		myronth	Added wrappers for CreateAddress and EnumAddress
 *	2/12/97		myronth	Mass DX5 changes
 *	3/24/97		kipo	Added support for IDirectPlayLobby2 interface
 *	4/3/97		myronth	Fixed interface pointer casts for CreateAddress and
 *						EnumAddress
 *	4/10/97		myronth	Added support for GetCaps
 *	5/8/97		myronth	Drop lobby lock when calling LP
 *	11/13/97	myronth	Added functions for asynchronous Connect (#12541)
 *	12/2/97		myronth	Added Register/UnregisterApplication
 *	12/4/97		myronth	Added ConnectEx
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DPL_Connect"
HRESULT DPLAPI DPL_Connect(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
					LPDIRECTPLAY2 * lplpDP2, IUnknown FAR * lpUnk)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr;


	DPF(7, "Entering DPL_Connect");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lplpDP2, lpUnk);

	ENTER_DPLOBBY();
    
    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDOBJECT;
		}

		if( !VALID_WRITE_PTR( lplpDP2, sizeof(LPDIRECTPLAY2 *)) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDPARAMS;
		}

		if( lpUnk != NULL )
		{
			LEAVE_DPLOBBY();
			return CLASS_E_NOAGGREGATION;
		}

		if(!VALID_CONNECT_FLAGS(dwFlags))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_DPLOBBY();
		return DPERR_INVALIDPARAMS;
	}


	// Call the ConnectMe function which resides in the DPlay project
	hr = ConnectMe(lpDPL, lplpDP2, lpUnk, dwFlags);


	LEAVE_DPLOBBY();
	return hr;

} // DPL_Connect



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ConnectEx"
HRESULT DPLAPI DPL_ConnectEx(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
				REFIID riid, LPVOID * ppvObj, IUnknown FAR * lpUnk)
{
	LPDIRECTPLAY2		lpDP2 = NULL;
	HRESULT				hr;


	DPF(7, "Entering DPL_ConnectEx");
	DPF(9, "Parameters: 0x%08x, 0x%08x, iid, 0x%08x, 0x%08x",
			lpDPL, dwFlags, ppvObj, lpUnk);


	// Call the ConnectMe function which resides in the DPlay project
	hr = DPL_Connect(lpDPL, dwFlags, &lpDP2, lpUnk);
	if(SUCCEEDED(hr))
	{
		hr = DP_QueryInterface((LPDIRECTPLAY)lpDP2, riid, ppvObj);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed calling QueryInterface, hr = 0x%08x", hr);
		}

		// Release the DP2 object
		DP_Release((LPDIRECTPLAY)lpDP2);
	}

	return hr;

} // DPL_ConnectEx



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SaveConnectPointers"
void PRV_SaveConnectPointers(LPDIRECTPLAYLOBBY lpDPL,
		LPDIRECTPLAY2 lpDP2, LPDPLCONNECTION lpConn)
{
	LPDPLOBBYI_DPLOBJECT	this;


	DPF(7, "Entering PRV_SaveConnectPointers");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDPL, lpDP2, lpConn);

	this = DPLOBJECT_FROM_INTERFACE(lpDPL);
#ifdef DEBUG
	if( !VALID_DPLOBBY_PTR( this ) )
		return;
#endif

	// Save the pointers
	this->lpDP2 = lpDP2;
	this->lpConn = lpConn;

} // PRV_SaveConnectPointers



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetConnectPointers"
BOOL PRV_GetConnectPointers(LPDIRECTPLAYLOBBY lpDPL,
		LPDIRECTPLAY2 * lplpDP2, LPDPLCONNECTION * lplpConn)
{
	LPDPLOBBYI_DPLOBJECT	this;


	DPF(7, "Entering PRV_GetConnectPointers");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDPL, lplpDP2, lplpConn);


	ASSERT(lplpDP2);
	ASSERT(lplpConn);

	this = DPLOBJECT_FROM_INTERFACE(lpDPL);
#ifdef DEBUG
	if( !VALID_DPLOBBY_PTR( this ) )
		return FALSE;
#endif

	// See if we have the pointers
	if((!this->lpDP2) || (!this->lpConn))
		return FALSE;

	// Set the output pointers
	*lplpDP2 = this->lpDP2;
	*lplpConn = this->lpConn;
	return TRUE;

} // PRV_GetConnectPointers



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_IsAsyncConnectOn"
BOOL PRV_IsAsyncConnectOn(LPDIRECTPLAYLOBBY lpDPL)
{
	LPDPLOBBYI_DPLOBJECT	this;


	DPF(7, "Entering PRV_IsAsyncConnectOn");
	DPF(9, "Parameters: 0x%08x", lpDPL);

	this = DPLOBJECT_FROM_INTERFACE(lpDPL);
#ifdef DEBUG
	if( !VALID_DPLOBBY_PTR( this ) )
		return FALSE;
#endif

	// Check the flag
	if(this->dwFlags & DPLOBBYPR_ASYNCCONNECT)
		return TRUE;
	else
		return FALSE;

} // PRV_IsAsyncConnectOn



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_TurnAsyncConnectOn"
void PRV_TurnAsyncConnectOn(LPDIRECTPLAYLOBBY lpDPL)
{
	LPDPLOBBYI_DPLOBJECT	this;


	DPF(7, "Entering PRV_TurnAsyncConnectOn");
	DPF(9, "Parameters: 0x%08x", lpDPL);

	this = DPLOBJECT_FROM_INTERFACE(lpDPL);
#ifdef DEBUG
	if( !VALID_DPLOBBY_PTR( this ) )
	{
		ASSERT(FALSE);
		return;
	}
#endif

	// Set the flag
	this->dwFlags |= DPLOBBYPR_ASYNCCONNECT;

} // PRV_TurnAsyncConnectOn



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_TurnAsyncConnectOff"
void PRV_TurnAsyncConnectOff(LPDIRECTPLAYLOBBY lpDPL)
{
	LPDPLOBBYI_DPLOBJECT	this;


	DPF(7, "Entering PRV_TurnAsyncConnectOff");
	DPF(9, "Parameters: 0x%08x", lpDPL);

	this = DPLOBJECT_FROM_INTERFACE(lpDPL);
#ifdef DEBUG
	if( !VALID_DPLOBBY_PTR( this ) )
	{
		ASSERT(FALSE);
		return;
	}
#endif

	// Clear the flag
	this->dwFlags &= (~DPLOBBYPR_ASYNCCONNECT);

} // PRV_TurnAsyncConnectOff



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_CreateAddress"
HRESULT DPLAPI DPL_CreateAddress(LPDIRECTPLAYLOBBY lpDPL,
					REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
					LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr;


	DPF(7, "Entering DPL_CreateAddress");
	DPF(9, "Parameters: 0x%08x, guid, guid, 0x%08x, %lu, 0x%08x, 0x%08x",
			lpDPL, lpData, dwDataSize, lpAddress, lpdwAddressSize);

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			return DPERR_INVALIDOBJECT;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	// Call the CreateAddress function which resides in the DPlay project
	hr = InternalCreateAddress((LPDIRECTPLAYSP)lpDPL, lpguidSP, lpguidDataType, lpData,
							dwDataSize, lpAddress, lpdwAddressSize);

	return hr;

} // DPL_CreateCompoundAddress

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_CreateCompoundAddress"

HRESULT DPLAPI DPL_CreateCompoundAddress(LPDIRECTPLAYLOBBY lpDPL,
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr;


	DPF(7, "Entering DPL_CreateCompoundAddress");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x, 0x%08x",
			lpDPL, lpAddressElements, dwAddressElementCount, lpAddress, lpdwAddressSize);

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			return DPERR_INVALIDOBJECT;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	// Call the CreateCompoundAddress function which resides in the DPlay project
	hr = InternalCreateCompoundAddress(lpAddressElements, dwAddressElementCount,
									   lpAddress, lpdwAddressSize);
	return hr;

} // DPL_CreateCompoundAddress


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_EnumAddress"
HRESULT DPLAPI DPL_EnumAddress(LPDIRECTPLAYLOBBY lpDPL,
					LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress,
					DWORD dwAddressSize, LPVOID lpContext)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr;


	DPF(7, "Entering DPL_EnumAddress");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, %lu, 0x%08x",
			lpDPL, lpEnumCallback, lpAddress, dwAddressSize, lpContext);

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			return DPERR_INVALIDOBJECT;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	// Call the CreateAddress function which resides in the DPlay project
	hr = InternalEnumAddress((LPDIRECTPLAYSP)lpDPL, lpEnumCallback, lpAddress,
							dwAddressSize, lpContext);

	return hr;

} // DPL_EnumAddress



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetCaps"
HRESULT DPLAPI PRV_GetCaps(LPDPLOBBYI_DPLOBJECT this, DWORD dwFlags,
				LPDPCAPS lpcaps)
{
	SPDATA_GETCAPS		gcd;
	HRESULT				hr = DP_OK;


	DPF(7, "Entering PRV_GetCaps");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x", this, dwFlags, lpcaps);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	
	// Setup our SPDATA struct
	memset(&gcd, 0, sizeof(SPDATA_GETCAPS));
	gcd.dwSize = sizeof(SPDATA_GETCAPS);
	gcd.dwFlags = dwFlags;
	gcd.lpcaps = lpcaps;

	// Call the GetCaps method in the LP
	if(CALLBACK_EXISTS(GetCaps))
	{
		gcd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, GetCaps, &gcd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// GetCaps is required
		DPF_ERR("The Lobby Provider callback for GetCaps doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF(2, "Failed calling GetCaps in the Lobby Provider, hr = 0x%08x", hr);
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_GetCaps



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteAppKeyFromRegistry"
HRESULT PRV_DeleteAppKeyFromRegistry(LPGUID lpguid)
{
	LPWSTR		lpwszAppName = NULL;
	HKEY		hkeyApp, hkeyDPApps = NULL;
	HRESULT		hr;
	LONG		lReturn;


	DPF(7, "Entering PRV_DeleteAppKeyFromRegistry");
	DPF(9, "Parameters: 0x%08x", lpguid);


	// Allocate memory for the App Name
	lpwszAppName = DPMEM_ALLOC(DPLOBBY_REGISTRY_NAMELEN);
	if(!lpwszAppName)
	{
		DPF_ERR("Unable to allocate memory for App Name!");
		return DPERR_OUTOFMEMORY;
	}
	
	// Open the registry key for the App
	if(!PRV_FindGameInRegistry(lpguid, lpwszAppName,
				DPLOBBY_REGISTRY_NAMELEN, &hkeyApp))
	{
		DPF_ERR("Unable to find game in registry!");
		hr = DPERR_UNKNOWNAPPLICATION;
		goto EXIT_DELETEAPPKEY;
	}

	// Close the app key
	RegCloseKey(hkeyApp);

 	// Open the Applications key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY, 0,
								KEY_READ, &hkeyDPApps);
	if(lReturn != ERROR_SUCCESS)
	{
		// If we can't open it, we assume it doesn't exist, so
		// we'll call it a success.
		hr = DP_OK;
		goto EXIT_DELETEAPPKEY;
	}

	// Now delete the key
	hr = OS_RegDeleteKey(hkeyDPApps, lpwszAppName);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to delete app key, hr = 0x%08x", hr);
		goto EXIT_DELETEAPPKEY;
	}

EXIT_DELETEAPPKEY:

	// Free our string memory
	if(lpwszAppName)
		DPMEM_FREE(lpwszAppName);
	
	// Close the DP Applications key
	if(hkeyDPApps)
		RegCloseKey(hkeyDPApps);

	return hr;

} // PRV_DeleteAppKeyFromRegistry



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_WriteAppDescInRegistryAnsi"
HRESULT PRV_WriteAppDescInRegistryAnsi(LPDPAPPLICATIONDESC lpDesc)
{
	HKEY	hkeyDPApps = NULL, hkeyApp = NULL;
	LONG	lReturn;
	DWORD	dwDisposition;
	WCHAR	wszGuid[GUID_STRING_SIZE];
	CHAR	szGuid[GUID_STRING_SIZE];
	HRESULT	hr;
	LPDPAPPLICATIONDESC2 lpDesc2=(LPDPAPPLICATIONDESC2)lpDesc;


	DPF(7, "Entering PRV_WriteAppDescInRegistryAnsi");
	DPF(9, "Parameters: 0x%08x", lpDesc);


	// Delete the application key if it exists
	hr = PRV_DeleteAppKeyFromRegistry(&lpDesc->guidApplication);

 	// Open the Applications key (or create it if it doesn't exist
	lReturn = OS_RegCreateKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY, 0, NULL,
				REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyDPApps,
				&dwDisposition);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to open DPlay Applications registry key!, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}

	// Create the app's key
	lReturn = RegCreateKeyExA(hkeyDPApps, lpDesc->lpszApplicationNameA,
				0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
				&hkeyApp, &dwDisposition);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to create application registry key, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}

	// Set the guid value
	hr = StringFromGUID(&lpDesc->guidApplication, wszGuid, sizeof(wszGuid));
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to convert application guid to string, hr = 0x%08x", hr);
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}
	
	WideToAnsi(szGuid, wszGuid, WSTRLEN_BYTES(wszGuid));
	
	lReturn = OS_RegSetValueEx(hkeyApp, SZ_GUID, 0, REG_SZ,
				(LPBYTE)szGuid, lstrlenA(szGuid));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Application guid, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}

	// Set the Filename value
	ASSERT(lpDesc->lpszFilenameA);
	lReturn = OS_RegSetValueEx(hkeyApp, SZ_FILE, 0, REG_SZ,
				lpDesc->lpszFilenameA, lstrlenA(lpDesc->lpszFilenameA));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Filename string, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}

	// Set the CommandLine value (optional)
	if(lpDesc->lpszCommandLineA)
	{
		lReturn = OS_RegSetValueEx(hkeyApp, SZ_COMMANDLINE, 0, REG_SZ,
			lpDesc->lpszCommandLineA, lstrlenA(lpDesc->lpszCommandLineA));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register CommandLine string, lReturn = %lu", lReturn);
		}
	}

	// Set the Path value
	ASSERT(lpDesc->lpszPathA);
	lReturn = OS_RegSetValueEx(hkeyApp, SZ_PATH, 0, REG_SZ,
				lpDesc->lpszPathA, lstrlenA(lpDesc->lpszPathA));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Path string, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}

	// Set the CurrentDirectory value (optional)
	if(lpDesc->lpszCurrentDirectoryA)
	{
		lReturn = OS_RegSetValueEx(hkeyApp, SZ_CURRENTDIR, 0, REG_SZ,
			lpDesc->lpszCurrentDirectoryA, lstrlenA(lpDesc->lpszCurrentDirectoryA));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register CurrentDirectory string, lReturn = %lu", lReturn);
		}
	}

	// Set the DescriptionA value (optional)
	if(lpDesc->lpszDescriptionA)
	{
		lReturn = OS_RegSetValueEx(hkeyApp, SZ_DESCRIPTIONA, 0, REG_SZ,
			lpDesc->lpszDescriptionA, lstrlenA(lpDesc->lpszDescriptionA));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register DescriptionA string, lReturn = %lu", lReturn);
		}
	}

	// Set the DescriptionW value (optional)
	if(lpDesc->lpszDescriptionW)
	{
		lReturn = OS_RegSetValueEx(hkeyApp, SZ_DESCRIPTIONW, 0, REG_BINARY,
				(BYTE *)lpDesc->lpszDescriptionW,
				WSTRLEN_BYTES(lpDesc->lpszDescriptionW));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register DescriptionW string, lReturn = %lu", lReturn);
		}
	}

	if(IS_DPLOBBY_APPLICATIONDESC2(lpDesc) && lpDesc2->lpszAppLauncherNameA){
		lReturn = OS_RegSetValueEx(hkeyApp, SZ_LAUNCHER, 0, REG_SZ,
			lpDesc2->lpszAppLauncherNameA, lstrlenA(lpDesc2->lpszAppLauncherNameA));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register LauncherA string, lReturn = %lu", lReturn);
		}
	}

	// Close the two keys
	RegCloseKey(hkeyDPApps);
	RegCloseKey(hkeyApp);

	return DP_OK;

ERROR_WRITEAPPINREGISTRYANSI:

	if(hkeyApp)
	{
		// Delete the key
		// REVIEW!!!! -- TODO

		// Now close the key
		RegCloseKey(hkeyApp);
	}

	if(hkeyDPApps)
		RegCloseKey(hkeyDPApps);

	return hr;

} // PRV_WriteAppDescInRegistryAnsi



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_WriteAppDescInRegistryUnicode"
HRESULT PRV_WriteAppDescInRegistryUnicode(LPDPAPPLICATIONDESC lpDesc)
{
	HKEY	hkeyDPApps = NULL, hkeyApp = NULL;
	LONG	lReturn;
	DWORD	dwDisposition;
	WCHAR	wszGuid[GUID_STRING_SIZE];
	HRESULT	hr;
	LPDPAPPLICATIONDESC2 lpDesc2=(LPDPAPPLICATIONDESC2)lpDesc;


	DPF(7, "Entering PRV_WriteAppDescInRegistryUnicode");
	DPF(9, "Parameters: 0x%08x", lpDesc);

	// Delete the application key if it exists
	hr = PRV_DeleteAppKeyFromRegistry(&lpDesc->guidApplication);

 	// Open the Applications key (or create it if it doesn't exist
	lReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY, 0, NULL,
				REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyDPApps,
				&dwDisposition);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to open DPlay Applications registry key!, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}

	// Create the app's key
	lReturn = RegCreateKeyEx(hkeyDPApps, lpDesc->lpszApplicationName,
				0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
				&hkeyApp, &dwDisposition);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to create application registry key, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}

	// Set the guid value
	hr = StringFromGUID(&lpDesc->guidApplication, wszGuid, sizeof(wszGuid));
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to convert application guid to string, hr = 0x%08x", hr);
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}
	
	lReturn = RegSetValueEx(hkeyApp, SZ_GUID, 0, REG_SZ, (BYTE *)wszGuid,
				WSTRLEN_BYTES(wszGuid));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Application guid, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}

	// Set the Filename value
	ASSERT(lpDesc->lpszFilename);
	lReturn = RegSetValueEx(hkeyApp, SZ_FILE, 0, REG_SZ,
				(LPBYTE)lpDesc->lpszFilename, WSTRLEN_BYTES(lpDesc->lpszFilename));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Filename string, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}

	// Set the CommandLine value (optional)
	if(lpDesc->lpszCommandLine)
	{
		lReturn = RegSetValueEx(hkeyApp, SZ_COMMANDLINE, 0, REG_SZ,
				(LPBYTE)lpDesc->lpszCommandLine,
				WSTRLEN_BYTES(lpDesc->lpszCommandLine));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register CommandLine string, lReturn = %lu", lReturn);
		}
	}

	// Set the Path value
	ASSERT(lpDesc->lpszPath);
	lReturn = RegSetValueEx(hkeyApp, SZ_PATH, 0, REG_SZ,
				(LPBYTE)lpDesc->lpszPath, WSTRLEN_BYTES(lpDesc->lpszPath));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Path string, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}

	// Set the CurrentDirectory value (optional)
	if(lpDesc->lpszCurrentDirectory)
	{
		lReturn = RegSetValueEx(hkeyApp, SZ_CURRENTDIR, 0, REG_SZ,
					(LPBYTE)lpDesc->lpszCurrentDirectory,
					WSTRLEN_BYTES(lpDesc->lpszCurrentDirectory));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register CurrentDirectory string, lReturn = %lu", lReturn);
		}
	}

	// Set the DescriptionA value (optional)
	if(lpDesc->lpszDescriptionA)
	{
		lReturn = RegSetValueExA(hkeyApp, "DescriptionA", 0, REG_SZ,
				lpDesc->lpszDescriptionA, lstrlenA(lpDesc->lpszDescriptionA));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register DescriptionA string, lReturn = %lu", lReturn);
		}
	}

	// Set the DescriptionW value (optional)
	if(lpDesc->lpszDescriptionW)
	{
		lReturn = RegSetValueEx(hkeyApp, SZ_DESCRIPTIONW, 0, REG_SZ,
				(LPBYTE)lpDesc->lpszDescriptionW,
				WSTRLEN_BYTES(lpDesc->lpszDescriptionW));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register DescriptionW string, lReturn = %lu", lReturn);
		}
	}

	// Set the LauncherName value (optional, DESC2 only)
	if(IS_DPLOBBY_APPLICATIONDESC2(lpDesc) && lpDesc2->lpszAppLauncherName){
		lReturn = RegSetValueEx(hkeyApp, SZ_LAUNCHER, 0, REG_SZ,
				(LPBYTE)lpDesc2->lpszAppLauncherName,
				WSTRLEN_BYTES(lpDesc2->lpszAppLauncherName));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register LauncherName string, lReturn = %lu", lReturn);
		}
	}

	// Close the two keys
	RegCloseKey(hkeyDPApps);
	RegCloseKey(hkeyApp);

	return DP_OK;

ERROR_WRITEAPPINREGISTRYUNICODE:

	if(hkeyApp)
	{
		// Delete the key
		// REVIEW!!!! -- TODO

		// Now close the key
		RegCloseKey(hkeyApp);
	}

	if(hkeyDPApps)
		RegCloseKey(hkeyDPApps);

	return hr;

} // PRV_WriteAppDescInRegistryUnicode



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_RegisterApplication"
HRESULT DPLAPI DPL_RegisterApplication(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, LPVOID lpvDesc)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPAPPLICATIONDESC		lpDescA = NULL;
	HRESULT					hr = DP_OK;
	LPDPAPPLICATIONDESC lpDesc=(LPDPAPPLICATIONDESC)lpvDesc;

	DPF(7, "Entering DPL_RegisterApplication");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lpDesc);

	ENTER_DPLOBBY();

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDOBJECT;
		}

		if(dwFlags)
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}

		// Validate the ApplicationDesc struct
		hr = PRV_ValidateDPAPPLICATIONDESC(lpDesc, FALSE);
		if(FAILED(hr))
		{
			LEAVE_DPLOBBY();
			DPF_ERR("Invalid DPAPPLICATIONDESC structure");
			return hr;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	// If we're on a Unicode platform, just write the stuff in the registry.
	// If it's not, we need to convert the DPAPPLICATIONDESC struct to ANSI
	if(OS_IsPlatformUnicode())
	{
		// Just write to the registry
		hr = PRV_WriteAppDescInRegistryUnicode(lpDesc);
	}
	else
	{
		// Convert the APPDESC struct to ANSI
		hr = PRV_ConvertDPAPPLICATIONDESCToAnsi(lpDesc, &lpDescA);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to convert DPAPPLICATIONDESC to Ansi, hr = 0x%08x", hr);
			goto ERROR_REGISTERAPPLICATION;
		}

		// Write to the registry
		hr = PRV_WriteAppDescInRegistryAnsi(lpDescA);

		// Free our APPDESC structure
		PRV_FreeLocalDPAPPLICATIONDESC(lpDescA);
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed writing ApplicationDesc to registry, hr = 0x%08x", hr);
	}

ERROR_REGISTERAPPLICATION:

	LEAVE_DPLOBBY();
	return hr;

} // DPL_RegisterApplication



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_UnregisterApplication"
HRESULT DPLAPI DPL_UnregisterApplication(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, REFGUID lpguid)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_UnregisterApplication");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lpguid);

	ENTER_DPLOBBY();

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDOBJECT;
		}

		if(dwFlags)
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}

		if(!VALID_READ_UUID_PTR(lpguid))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDPARAMS;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	hr = PRV_DeleteAppKeyFromRegistry((LPGUID)lpguid);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to delete app key from registry, hr = 0x%08x", hr);
	}

	LEAVE_DPLOBBY();

	return hr;

} // DPL_UnregisterApplication
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\dplobpr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobpr.h
 *  Content:	DirectPlayLobby private header file
 *  History:
 *	Date		By		Reason
 *	====		==		======
 *	4/13/96		myronth	created it
 *	6/24/96		kipo	changed guidGame to guidApplication.
 *	7/16/96		kipo	changed address types to be GUIDs instead of 4CC
 *	10/23/96	myronth	added client/server methods
 *	11/20/96	myronth	Added Implemented Logon/LogoffServer
 *	12/12/96	myronth	Added validation macros for DPSESSIONDESC2 and DPNAME
 *	1/2/97		myronth	Added wrappers for CreateAddress and EnumAddress
 *	2/12/97		myronth	Mass DX5 changes
 *	2/18/97		myronth	Implemented GetObjectCaps
 *	2/20/97		myronth	Changed buffer R/W to be circular
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/12/97		myronth	Added LP node stuff, initial async enumsessions
 *	3/13/97		myronth	Changed reg key, other bug fixes
 *	3/17/97		myronth	Added ID map table to lobby object
 *	3/21/97		myronth	Removed unnecessary response function prototypes
 *	3/24/97		kipo	Added support for IDirectPlayLobby2 interface
 *	3/31/97		myronth	Removed dead code, Added IDPLobbySP methods
 *	4/3/97		myronth	Added dplaypr.h dependency, removed dplayi.h dep,
 *						Removed all duplicated code with dplaypr.h, cleaned
 *						up a bunch of dead code
 *	4/4/97		myronth	Changed IDPLobbySP methods' structure names
 *	5/8/97		myronth	Added packed connection header, subgroup function
 *						prototypes
 *	5/12/97		myronth	Added lobby system player
 *	5/17/97		myronth	SendChatMessage function prototype for IDPLobbySP
 *	5/17/97		myronth	Added parent ID to CreateAndMapNewGroup
 *	5/20/97		myronth	Added PRV_DeleteRemotePlayerFromGroup prototype
 *	5/22/97		myronth	Added DPLP_DestroyGroup prototype
 *	6/3/97		myronth	Added PRV_DestroySubgroups and PRV_RemoveSubgroups-
 *						AndPlayersFromGroup function prototypes
 *	6/6/97		myronth	Added prototypes for PRV_DestroyGroupAndParents and
 *						PRV_DeleteRemoteGroupFromGroup
 *	6/16/97		myronth	Added prototype for PRV_SendDeleteShortcutMessage-
 *						ForExitingGroup
 *	7/30/97		myronth	Added support for standard lobby messaging
 *	8/11/97		myronth	Added guidInstance to GameNode struct, added internal
 *						flad indicating we slammed this guid in a request
 *	8/22/97		myronth	Added Desciptions & flags to LSPNODE structure
 *	9/29/97		myronth	Added prototypes for PRV_SendName/DataChangedMessageLocally
 *	10/7/97		myronth	Added LP version to lobby struct
 *	10/23/97	myronth	Added lpStopParent group parameter to DeleteGroupAndParents
 *						and DeleteRemoteGroupFromGroup (#12885)
 *	10/29/97	myronth	Changed and added internal prototypes for group owners
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/13/97	myronth	Added stuff for asynchronous Connect (#12541)
 *	12/2/97		myronth	Added IDPLobby3 interface, Register/UnregisterApp
 *	12/4/97		myronth	Added ConnectEx
 *	1/20/98		myronth	Added WaitForConnectionSettings
 *	1/25/98		sohailm	Added #define for CSTR_EQUAL (we define it if it's not already defined)
 *	6/25/98		a-peterz Added DPL_A_ConnectEx
 ***************************************************************************/
#ifndef __DPLOBPR_INCLUDED__
#define __DPLOBPR_INCLUDED__

#include <windows.h>
#include "dpmem.h"
#include "dpf.h"
#include "dplobby.h"
#include "dpneed.h"
#include "dpos.h"
#include "lobbysp.h"
#include "dplaypr.h"
#include "dpmess.h"

//--------------------------------------------------------------------------
//
//	Prototypes
//
//--------------------------------------------------------------------------
typedef struct IDirectPlayLobbyVtbl DIRECTPLAYLOBBYCALLBACKS;
typedef DIRECTPLAYLOBBYCALLBACKS * LPDIRECTPLAYLOBBYCALLBACKS;
// Right now the ASCII Vtbl is the same (by definition), but we may need
// to change it in the future, so let's use this structure
typedef struct IDirectPlayLobbyVtbl DIRECTPLAYLOBBYCALLBACKSA;
typedef DIRECTPLAYLOBBYCALLBACKSA * LPDIRECTPLAYLOBBYCALLBACKSA;

typedef struct IDirectPlayLobby2Vtbl DIRECTPLAYLOBBYCALLBACKS2;
typedef DIRECTPLAYLOBBYCALLBACKS2 * LPDIRECTPLAYLOBBYCALLBACKS2;
// Right now the ASCII Vtbl is the same (by definition), but we may need
// to change it in the future, so let's use this structure
typedef struct IDirectPlayLobby2Vtbl DIRECTPLAYLOBBYCALLBACKS2A;
typedef DIRECTPLAYLOBBYCALLBACKS2A * LPDIRECTPLAYLOBBYCALLBACKS2A;

typedef struct IDirectPlayLobby3Vtbl DIRECTPLAYLOBBYCALLBACKS3;
typedef DIRECTPLAYLOBBYCALLBACKS3 * LPDIRECTPLAYLOBBYCALLBACKS3;
// Right now the ASCII Vtbl is the same (by definition), but we may need
// to change it in the future, so let's use this structure
typedef struct IDirectPlayLobby3Vtbl DIRECTPLAYLOBBYCALLBACKS3A;
typedef DIRECTPLAYLOBBYCALLBACKS3A * LPDIRECTPLAYLOBBYCALLBACKS3A;

typedef struct IDPLobbySPVtbl DIRECTPLAYLOBBYSPCALLBACKS;
typedef DIRECTPLAYLOBBYSPCALLBACKS * LPDIRECTPLAYLOBBYSPCALLBACKS;

//--------------------------------------------------------------------------
//
//	DPLobby SP Node stuff
//
//--------------------------------------------------------------------------

//	DirectPlay Service Provider for DPLobby
//	{4AF206E0-9712-11cf-A021-00AA006157AC}
DEFINE_GUID(GUID_DirectPlaySP, 0x4af206e0, 0x9712, 0x11cf, 0xa0, 0x21, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);

// This is where the service provider info read from
// the registry is kept
typedef struct LSPNODE
{
	LPWSTR		lpwszName;
	LPWSTR		lpwszPath;
	GUID		guid;
	DWORD		dwReserved1;
	DWORD		dwReserved2;
	DWORD		dwNodeFlags;
	LPSTR		lpszDescA;
	LPWSTR		lpwszDesc;
	struct LSPNODE * lpNext;
} LSPNODE, * LPLSPNODE;

#define LSPNODE_DESCRIPTION		(0x00000001)
#define LSPNODE_PRIVATE			(0x00000002)

//--------------------------------------------------------------------------
//
//	DirectPlayLobby Stuff
//
//--------------------------------------------------------------------------

// Forward declarations for pointers to these two structs
typedef struct DPLOBBYI_INTERFACE * LPDPLOBBYI_INTERFACE;
typedef struct DPLOBBYI_DPLOBJECT * LPDPLOBBYI_DPLOBJECT;

// This is a structure represent each interface on our DPLobby object
typedef struct DPLOBBYI_INTERFACE
{
// REVIEW!!!! -- Why isn't this strongly typed????
//	LPDIRECTPLAYLOBBYCALLBACKS	lpVtbl;
	LPVOID						lpVtbl;
	LPDPLOBBYI_DPLOBJECT		lpDPLobby;
	LPDPLOBBYI_INTERFACE		lpNextInterface;	// Next interface on DPLobby object
	DWORD 						dwIntRefCnt;		// Ref count for this interface
} DPLOBBYI_INTERFACE;

// This structure represents a message node for messages sent between the
// lobby client & the game using Send/ReceiveLobbyMessage
typedef struct DPLOBBYI_MESSAGE
{
	DWORD		dwFlags;				// Flags pertinent to the data in the message
	DWORD		dwSize;					// Size of the data
	LPVOID		lpData;					// Pointer to the data
	struct DPLOBBYI_MESSAGE * lpPrev;	// Pointer to the previous message
	struct DPLOBBYI_MESSAGE * lpNext;	// Pointer to the next message
} DPLOBBYI_MESSAGE, * LPDPLOBBYI_MESSAGE;

// This represents an entry in our ID map table
typedef struct DPLOBBYI_MAPIDNODE
{
	DWORD		dwLobbyID;
	DPID		dpid;
} DPLOBBYI_MAPIDNODE, * LPDPLOBBYI_MAPIDNODE;

// This structure represents each game launched by the lobby client
typedef struct DPLOBBYI_GAMENODE
{
	DWORD		dwSize;					// Size of this structure
	DWORD		dwFlags;				// Flags relevant to the GameNode
	DWORD		dwGameProcessID;		// Process ID of Game spun off
	HANDLE		hGameProcess;			// Process Hande for the Game spun off
	GUID        guidIPC;                // IPC guid for handling ripple launch case
	HANDLE		hTerminateThread;		// Handle to the Terminate monitor thread
	HANDLE		hKillTermThreadEvent;	// Handle of an event used to kill the monitor thread
	DPLOBBYI_MESSAGE	MessageHead;	// Message queue head
	DWORD		dwMessageCount;			// Count of messages in the queue

	// Connection settings shared memory buffer related stuff	
	HANDLE		hConnectDataMutex;		// Mutex for write access to connect data buffer
	HANDLE		hConnectDataFile;		// File handle for game data buffer
	LPVOID		lpConnectDataBuffer;	// Pointer to game data buffer	

	// Game settings shared memory buffer related stuff	
	HANDLE		hGameWriteFile;			// File handle for game write buffer
	LPVOID		lpGameWriteBuffer;		// Pointer to game write buffer	
	HANDLE		hGameWriteEvent;		// Handle to GameWriteEvent
	HANDLE		hGameWriteMutex;		// Handle to GameWrite Mutex

	HANDLE		hLobbyWriteFile;		// File handle for lobby write buffer
	LPVOID		lpLobbyWriteBuffer;		// Pointer to lobby write buffer	
	HANDLE		hLobbyWriteEvent;		// Handle to LobbyWrite Event
	HANDLE		hLobbyWriteMutex;		// Handle to LobbyWrite Mutex

	HANDLE		hReceiveThread;			// Handle to the Receive thread
	HANDLE		hDupReceiveEvent;		// Duplicate Handle of Caller's Event
	HANDLE		hKillReceiveThreadEvent;// Handle of an event used to kill receive thread

	LPDPLOBBYI_DPLOBJECT	this;		// Back pointer to the DPLobby object
	struct DPLOBBYI_GAMENODE * lpgnNext;// Pointer to the next GameNode in the list

	// Pointer to the dplay object which has a connection to the lobby server
	// and the ID of the player that received the start session message
	LPDPLAYI_DPLAY	lpDPlayObject;
	DPID			dpidPlayer;
	GUID			guidInstance;		// Instance guid for the game

} DPLOBBYI_GAMENODE, *LPDPLOBBYI_GAMENODE;

// This is used to keep track of Property requests made via SendLobbyMessage
typedef struct DPLOBBYI_REQUESTNODE
{
	DWORD		dwFlags;					// GN_* flags
	DWORD		dwRequestID;				// Internal Request ID
	DWORD		dwAppRequestID;				// Request ID passed in by the app
	LPDPLOBBYI_GAMENODE	lpgn;				// Pointer to a Game Node
	struct DPLOBBYI_REQUESTNODE * lpPrev;	// Pointer to the previous request node
	struct DPLOBBYI_REQUESTNODE * lpNext;	// Pointer to the next request node

} DPLOBBYI_REQUESTNODE, * LPDPLOBBYI_REQUESTNODE;

// This is the DirectPlayLobby object
typedef struct DPLOBBYI_DPLOBJECT
{
	DWORD						dwSize;				// Size of this structure
	LPDPLOBBYI_INTERFACE		lpInterfaces;		// List of interface on this object
    DWORD						dwRefCnt;			// Reference Count for the object
    DWORD						dwFlags;			// DPLOBBYPR_xxx
	HINSTANCE					hInstanceLP;		// Lobby Provider DLL's hInstance
    LPSP_CALLBACKS				pcbSPCallbacks;		// SP entry points
	LPVOID						lpSPData;			// SP-specific blob storage
	LPDPLOBBYI_GAMENODE			lpgnHead;			// Head node for all launched games

	LPDPLAYI_DPLAY				lpDPlayObject;		// Back pointer to aggregate DPlay object
	LPDPLOBBYI_MAPIDNODE		lpMap;				// Pointer to the ID map table
	DWORD						dwTotalMapEntries;	// Number of total entries in the map table
	DWORD						dwMapEntries;		// Number of used entries in the map table
	DPID						dpidSysPlayer;		// ID of the lobby's system player

	LPDPLOBBYI_REQUESTNODE		lprnHead;			// Head node for all property requests
	DWORD						dwCurrentRequest;	// ID of the next request

	DWORD						dwLPVersion;		// Version of the lobby provider

	LPDIRECTPLAY2				lpDP2;				// DPlay2 interface pointer used by async DP_Connect
	LPDPLCONNECTION				lpConn;				// DPLCONNECTION pointer used by async DP_Connect
} DPLOBBYI_DPLOBJECT;

typedef struct DPLOBBYI_BUFFERCONTROL
{
	DWORD		dwToken;		// Set by the lobby client
	DWORD		dwReadOffset;	// Offset of the read cursor (relative to this structure)
	DWORD		dwWriteOffset;	// Offset of the write cursor (relative to this structure)
	DWORD		dwFlags;		// Flags for this buffer
	DWORD		dwMessages;		// Number of messages in the buffer
	DWORD		dwBufferSize;	// Size of the entire buffer
	DWORD		dwBufferLeft;	// Number of free bytes left in the buffer
} DPLOBBYI_BUFFERCONTROL, * LPDPLOBBYI_BUFFERCONTROL;

typedef struct DPLOBBYI_CONNCONTROL
{
	DWORD		dwToken;		// Set by the lobby client
	DWORD		dwFlags;		// Flags for this buffer
} DPLOBBYI_CONNCONTROL, * LPDPLOBBYI_CONNCONTROL;

typedef struct DPLOBBYI_MESSAGEHEADER
{
	DWORD		dwSize;
	DWORD		dwFlags;
} DPLOBBYI_MESSAGEHEADER, * LPDPLOBBYI_MESSAGEHEADER;

typedef struct DPLOBBYI_PACKEDCONNHEADER
{
	DWORD		dwUnicodeSize;
	DWORD		dwAnsiSize;
} DPLOBBYI_PACKEDCONNHEADER, * LPDPLOBBYI_PACKEDCONNHEADER;

typedef struct CONNECTINFO
{
	GUID		guidApplication;
	GUID        guidIPC;
	LPWSTR		lpszName;
	LPWSTR		lpszFile;
	LPWSTR		lpszPath;
	LPWSTR		lpszCommandLine;
	LPWSTR		lpszCurrentDir;
	LPWSTR      lpszAppLauncherName;
} CONNECTINFO, * LPCONNECTINFO;

// This is used for messaging during the StartGame method
typedef struct DPLOBBYI_STARTGAME
{
	DWORD		dwFlags;
	HRESULT		hr;
} DPLOBBYI_STARTGAME, * LPDPLOBBYI_STARTGAME;

//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------

// These two entries are only used by dplos.c.  They can be removed if we
// generalize these functions between DPlay & DPLobby
#define DPLAY_MAX_FILENAMELEN	512
#define DPLOBBY_DEFAULT_CHAR	"-"

#define DPLOBBYPR_DEFAULTMAPENTRIES		100

#define DPLOBBYPR_SIZE_HANDLEMESSAGE_DX50	20

// Note, the 'L' Macro makes these strings Unicode (the TEXT macro uses L also)
#define SZ_DPLAY_APPS_KEY	L"Software\\Microsoft\\DirectPlay\\Applications"
#define SZ_DPLAY_SP_KEY		L"Software\\Microsoft\\DirectPlay\\Service Providers"
#define SZ_DPLOBBY_SP_KEY	L"Software\\Microsoft\\DirectPlay\\Lobby Providers"
#define SZ_ADDRESS_TYPES	L"Address Types"
#define SZ_GUID				L"Guid"
#define SZ_PATH				L"Path"
#define SZ_DESCRIPTIONA		L"DescriptionA"
#define SZ_DESCRIPTIONW		L"DescriptionW"
#define SZ_PRIVATE			L"Private"
#define SZ_FILE				L"File"
#define SZ_LAUNCHER         L"Launcher"
#define SZ_MAJORVERSION		L"Major Version"
#define SZ_MINORVERSION		L"Minor Version"
#define SZ_DWRESERVED1		L"dwReserved1"
#define SZ_DWRESERVED2		L"dwReserved2"
#define SZ_COMMANDLINE		L"CommandLine"
#define SZ_CURRENTDIR		L"CurrentDirectory"
#define SZ_BACKSLASH		L"\\"
#define SZ_SPACE			L" "
#define SZ_SP_FOR_DPLAY		L"dpldplay.dll"
#define SZ_DP_IPC_GUID      L"/dplay_ipc_guid:"
#define SZ_GUID_PROTOTYPE   L"{01020304-0506-0708-090A-0B0C0D0E0F10}"

// The following #defines are all for the shared buffers and control
// elements used by the lobby methods for communication between
// a lobby client and a game
#define MAX_PID_LENGTH				(10)
#define	MAX_MMFILENAME_LENGTH		(_MAX_FNAME + MAX_PID_LENGTH)
#define SZ_FILENAME_BASE			L"DPLobby"
#define SZ_CONNECT_DATA_FILE		L"ConnectDataSharedMemory"
#define SZ_CONNECT_DATA_MUTEX		L"ConnectDataMutex"
#define SZ_GAME_WRITE_FILE			L"GameWriteSharedMemory"
#define SZ_GAME_WRITE_EVENT			L"GameWriteEvent"
#define SZ_GAME_WRITE_MUTEX			L"GameWriteMutex"
#define SZ_LOBBY_WRITE_FILE			L"LobbyWriteSharedMemory"
#define SZ_LOBBY_WRITE_EVENT		L"LobbyWriteEvent"
#define SZ_LOBBY_WRITE_MUTEX		L"LobbyWriteMutex"
#define SZ_NAME_TEMPLATE			L"%s-%s-%u"
#define SZ_GUID_NAME_TEMPLATE       L"%s-%s-"

#define TYPE_CONNECT_DATA_FILE		1
#define TYPE_CONNECT_DATA_MUTEX		2
#define TYPE_GAME_WRITE_FILE		3
#define TYPE_LOBBY_WRITE_FILE		4
#define TYPE_LOBBY_WRITE_EVENT		5
#define TYPE_GAME_WRITE_EVENT		7
#define TYPE_LOBBY_WRITE_MUTEX		9
#define TYPE_GAME_WRITE_MUTEX		10



// If this flag is set, the Lobby object has been registered with a lobby
// server.  Some methods require the client to be registered.
#define DPLOBBYPR_REGISTERED			0x00000010

// If this flag is set, we have allocated an IDPLobbySP interface
#define DPLOBBYPR_SPINTERFACE			0x00000020

// If this flag is set, the app has called Connect with the async flag
#define DPLOBBYPR_ASYNCCONNECT			0x00000040

// Message flags
#define DPLOBBYPR_MESSAGE_SYSTEM		0x00000001
#define DPLOBBYPR_INTERNALMESSAGEFLAGS	(0x00000000) // This will change

// HRESULT used by EnumLocalApplication to denote a callback return of
// FALSE (internally, of course)
#define DPLOBBYPR_CALLBACKSTOP			(0xFFFFFFFF)

// Transport Flags
#define DPLOBBYPR_DPLAYSP				(0x00000001)

// Default Timeout value (15 seconds)
#define DPLOBBYPR_DEFAULTTIMEOUT		(15000)

//
// GameNode Flags
//
// If this flag is set, the calling application is a lobby client and not
// a game.  The user shouldn't even set this, but we should be able to
// figure it out from the connection method.  Use this flag to distinguish
// when to "Create" the memory-mapped files, or when to "Open" them.
#define GN_LOBBY_CLIENT					(0x00000001)

// The memory mapped files are available and ready for use
#define GN_SHARED_MEMORY_AVAILABLE		(0x00000002)

// Used to denote when an application's process has gone away.
#define GN_DEAD_GAME_NODE				(0x00000004)

// These two flags determine whether the game was lobby client launched or
// self-lobbied.  If neither of these are set, the game was lobby client
// launched, and the flag is set on the lobby client side (not on the game side)
#define GN_CLIENT_LAUNCHED				(0x00000008)
#define GN_SELF_LOBBIED					(0x00000010)

// This flag is used to identify whether the guidInstance for the game
// was exchanged for GUID_NULL in the guidPlayer field of a Get/SetProperty
// lobby system message.
#define GN_SLAMMED_GUID					(0x00000020)

// This flag is set when the guidIPC field of the game node has been set
// either because we are a lobby client that ripple launched or it was
// on the application's command line.
#define GN_IPCGUID_SET					(0x00000040)
//
// BufferControl Flags
//
// Flags used by the dwFlags member of the BUFFERCONTROL struct
#define BC_LOBBY_ACTIVE					(0x00000001)
#define BC_GAME_ACTIVE					(0x00000002)
#define BC_WAIT_MODE					(0x00000004)
#define BC_PENDING_CONNECT				(0x00000008)

#define BC_TOKEN						(0xFEEDFACE)

#ifndef CSTR_EQUAL
#define CSTR_EQUAL	2
#endif

//--------------------------------------------------------------------------
//
//	Globals
//
//--------------------------------------------------------------------------

// The vtable!
extern DIRECTPLAYLOBBYCALLBACKS		dplCallbacks;
extern DIRECTPLAYLOBBYCALLBACKSA	dplCallbacksA;
extern DIRECTPLAYLOBBYCALLBACKS2	dplCallbacks2;
extern DIRECTPLAYLOBBYCALLBACKS2A	dplCallbacks2A;
extern DIRECTPLAYLOBBYCALLBACKS3	dplCallbacks3;
extern DIRECTPLAYLOBBYCALLBACKS3A	dplCallbacks3A;
extern DIRECTPLAYLOBBYSPCALLBACKS	dplCallbacksSP;

//--------------------------------------------------------------------------
//
//	Macros, etc.
//
//--------------------------------------------------------------------------

// Our own hard-coded break
#define DEBUGBREAK() _asm { int 3 }

#define DPLOBJECT_FROM_INTERFACE(ptr) (((LPDPLOBBYI_INTERFACE)ptr)->lpDPLobby)

#define DPLOBBY_REGISTRY_NAMELEN	512

// Crit section
extern LPCRITICAL_SECTION gpcsDPLCritSection;		// defined in dllmain.c
extern LPCRITICAL_SECTION gpcsDPLQueueCritSection;	// also in dllmain.c
extern LPCRITICAL_SECTION gpcsDPLGameNodeCritSection;	// also in dllmain.c


// Validation macros
#define VALID_DPLOBBY_INTERFACE( ptr ) \
        (!IsBadWritePtr(ptr, sizeof(DPLOBBYI_INTERFACE)) && \
        ((((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacks) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacksA) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacks2) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacks2A) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacks3) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacks3A) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacksSP)))

#define VALID_DPLOBBY_PTR(ptr) \
        (!IsBadWritePtr(ptr, sizeof(DPLOBBYI_DPLOBJECT)) && \
        (ptr->dwSize == sizeof(DPLOBBYI_DPLOBJECT)))

#define VALID_UUID_PTR(ptr) \
        (ptr && !IsBadWritePtr( ptr, sizeof(UUID)))

#define VALID_READ_UUID_PTR(ptr) \
        (ptr && !IsBadReadPtr( ptr, sizeof(UUID)))

#define VALID_DPLOBBY_CONNECTION( ptr ) \
		(!IsBadWritePtr(ptr, sizeof(DPLCONNECTION)) && \
        (ptr->dwSize == sizeof(DPLCONNECTION)))

#define VALID_DPLOBBY_APPLICATIONDESC( ptr ) \
		(!IsBadWritePtr(ptr, sizeof(DPAPPLICATIONDESC)) && \
        (ptr->dwSize == sizeof(DPAPPLICATIONDESC)))

#define VALID_DPLOBBY_APPLICATIONDESC2( ptr ) \
		(!IsBadWritePtr(ptr, sizeof(DPAPPLICATIONDESC2)) && \
        (ptr->dwSize == sizeof(DPAPPLICATIONDESC2)))

#define IS_DPLOBBY_APPLICATIONDESC2(ptr) \
		(ptr->dwSize == sizeof(DPAPPLICATIONDESC2))

#define VALID_DPLOGONINFO( ptr ) \
		(!IsBadWritePtr(ptr, sizeof(DPLOGONINFO)) && \
        (ptr->dwSize == sizeof(DPLOGONINFO)))

#define VALID_DPLOBBY_SP_LOADED( ptr ) \
		(ptr->pcbSPCallbacks)

#define VALID_SENDLOBBYMESSAGE_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPLMSG_STANDARD) \
		) )

#define VALID_WAIT_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPLWAIT_CANCEL) \
		) )

#define IS_GAME_DEAD(lpgn) \
		(lpgn->dwFlags & GN_DEAD_GAME_NODE)

#define CALLBACK_EXISTS(fn)	(((LPSP_CALLBACKS)this->pcbSPCallbacks)->fn)

#define CALL_LP(ptr,fn,pdata) (((LPSP_CALLBACKS)ptr->pcbSPCallbacks)->fn(pdata))

#define DPLAPI WINAPI

//--------------------------------------------------------------------------
//
//	Prototypes
//
//--------------------------------------------------------------------------

// convert.c
HRESULT PRV_ConvertDPLCONNECTIONToUnicode(LPDPLCONNECTION, LPDPLCONNECTION *);

// dplunk.c
extern HRESULT 	DPLAPI DPL_QueryInterface(LPDIRECTPLAYLOBBY,
								REFIID riid, LPVOID * ppvObj);
extern ULONG	DPLAPI DPL_AddRef(LPDIRECTPLAYLOBBY);  
extern ULONG 	DPLAPI DPL_Release(LPDIRECTPLAYLOBBY); 

LPDPLOBBYSP PRV_GetDPLobbySPInterface(LPDPLOBBYI_DPLOBJECT);
HRESULT PRV_GetInterface(LPDPLOBBYI_DPLOBJECT, LPDPLOBBYI_INTERFACE *, LPVOID);

// dplgame.c
extern HRESULT	DPLAPI DPL_RunApplication(LPDIRECTPLAYLOBBY, DWORD,
						LPDWORD, LPDPLCONNECTION, HANDLE);

BOOL PRV_FindGameInRegistry(LPGUID, LPWSTR, DWORD, HKEY *);

// dplenum.c
extern HRESULT	DPLAPI DPL_EnumLocalApplications(LPDIRECTPLAYLOBBY,
					LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD);
extern HRESULT	DPLAPI DPL_EnumAddressTypes(LPDIRECTPLAYLOBBY,
					LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD);
HRESULT PRV_EnumLocalApplications(LPDIRECTPLAYLOBBY,
				LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD, BOOL);

// dplobby.c
extern HRESULT	DPLAPI DPL_Connect(LPDIRECTPLAYLOBBY, DWORD, LPDIRECTPLAY2 *,
						IUnknown FAR *);
extern HRESULT DPLAPI DPL_ConnectEx(LPDIRECTPLAYLOBBY, DWORD, REFIID,
					LPVOID *, IUnknown FAR *);
extern HRESULT DPLAPI DPL_CreateAddress(LPDIRECTPLAYLOBBY pISP,
					REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
					LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);
extern HRESULT DPLAPI DPL_CreateCompoundAddress(LPDIRECTPLAYLOBBY pISP,
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);
extern HRESULT DPLAPI DPL_EnumAddress(LPDIRECTPLAYLOBBY pISP,
					LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress, DWORD dwAddressSize, 
					LPVOID lpContext);
extern HRESULT DPLAPI DPL_RegisterApplication(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, LPVOID lpvDesc);
extern HRESULT DPLAPI DPL_UnregisterApplication(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, REFGUID lpguid);

HRESULT PRV_WriteAppDescInRegistryAnsi(LPDPAPPLICATIONDESC);
HRESULT PRV_WriteAppDescInRegistryUnicode(LPDPAPPLICATIONDESC);

// dplobbya.c	(Ansi entry points)
extern HRESULT	DPLAPI DPL_A_Connect(LPDIRECTPLAYLOBBY, DWORD,
				LPDIRECTPLAY2 *, IUnknown FAR *);
extern HRESULT DPLAPI DPL_A_ConnectEx(LPDIRECTPLAYLOBBY, DWORD, REFIID,
					LPVOID *, IUnknown FAR *);
extern HRESULT	DPLAPI DPL_A_EnumLocalApplications(LPDIRECTPLAYLOBBY,
						LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD);
extern HRESULT	DPLAPI DPL_A_GetConnectionSettings(LPDIRECTPLAYLOBBY, DWORD,
						LPVOID, LPDWORD);
extern HRESULT DPLAPI DPL_A_RegisterApplication(LPDIRECTPLAYLOBBY,
				DWORD, LPVOID);
extern HRESULT	DPLAPI DPL_A_RunApplication(LPDIRECTPLAYLOBBY,	DWORD, LPDWORD,
						LPDPLCONNECTION, HANDLE);
extern HRESULT	DPLAPI DPL_A_SetConnectionSettings(LPDIRECTPLAYLOBBY,
						DWORD, DWORD, LPDPLCONNECTION);

// dplpack.c
void PRV_GetDPLCONNECTIONPackageSize(LPDPLCONNECTION, LPDWORD, LPDWORD);
HRESULT PRV_PackageDPLCONNECTION(LPDPLCONNECTION, LPVOID, BOOL);
HRESULT PRV_UnpackageDPLCONNECTIONAnsi(LPVOID, LPVOID);
HRESULT PRV_UnpackageDPLCONNECTIONUnicode(LPVOID, LPVOID);
HRESULT PRV_ValidateDPLCONNECTION(LPDPLCONNECTION, BOOL);
HRESULT PRV_ValidateDPAPPLICATIONDESC(LPDPAPPLICATIONDESC, BOOL);
HRESULT PRV_ConvertDPAPPLICATIONDESCToAnsi(LPDPAPPLICATIONDESC,
		LPDPAPPLICATIONDESC *);
HRESULT PRV_ConvertDPAPPLICATIONDESCToUnicode(LPDPAPPLICATIONDESC,
		LPDPAPPLICATIONDESC *);
void PRV_FreeLocalDPAPPLICATIONDESC(LPDPAPPLICATIONDESC);

// dplshare.c
extern HRESULT	DPLAPI DPL_GetConnectionSettings(LPDIRECTPLAYLOBBY, DWORD,
						LPVOID, LPDWORD);
extern HRESULT	DPLAPI DPL_ReceiveLobbyMessage(LPDIRECTPLAYLOBBY, DWORD,
						DWORD, LPDWORD, LPVOID, LPDWORD);
extern HRESULT	DPLAPI DPL_SendLobbyMessage(LPDIRECTPLAYLOBBY, DWORD,
						DWORD, LPVOID, DWORD);
extern HRESULT	DPLAPI DPL_SetConnectionSettings(LPDIRECTPLAYLOBBY, DWORD,
						DWORD, LPDPLCONNECTION);
extern HRESULT	DPLAPI DPL_SetLobbyMessageEvent(LPDIRECTPLAYLOBBY, DWORD,
						DWORD, HANDLE);
extern HRESULT DPLAPI DPL_WaitForConnectionSettings(LPDIRECTPLAYLOBBY, DWORD);

HRESULT PRV_GetInternalName(LPDPLOBBYI_GAMENODE, DWORD, LPWSTR);
HRESULT PRV_AddNewGameNode(LPDPLOBBYI_DPLOBJECT, LPDPLOBBYI_GAMENODE *,
						DWORD, HANDLE, BOOL, LPGUID);
HRESULT PRV_WriteConnectionSettings(LPDPLOBBYI_GAMENODE, LPDPLCONNECTION, BOOL);
HRESULT PRV_FreeGameNode(LPDPLOBBYI_GAMENODE);
void PRV_RemoveGameNodeFromList(LPDPLOBBYI_GAMENODE);
HANDLE PRV_DuplicateHandle(HANDLE);
DWORD WINAPI PRV_ReceiveClientNotification(LPVOID);
DWORD WINAPI PRV_ClientTerminateNotification(LPVOID);
HRESULT PRV_GetConnectionSettings(LPDIRECTPLAYLOBBY, DWORD, LPVOID,
						LPDWORD, BOOL);
HRESULT PRV_SetConnectionSettings(LPDIRECTPLAYLOBBY, DWORD, DWORD,
						LPDPLCONNECTION);
void PRV_KillThread(HANDLE, HANDLE);
HRESULT PRV_InjectMessageInQueue(LPDPLOBBYI_GAMENODE, DWORD, LPVOID, DWORD, BOOL);
HRESULT PRV_WriteClientData(LPDPLOBBYI_GAMENODE, DWORD, LPVOID, DWORD); 
void PRV_RemoveRequestNode(LPDPLOBBYI_DPLOBJECT, LPDPLOBBYI_REQUESTNODE);

// dplsp.c
extern HRESULT DPLAPI DPLP_AddGroupToGroup(LPDPLOBBYSP, LPSPDATA_ADDREMOTEGROUPTOGROUP);
extern HRESULT DPLAPI DPLP_AddPlayerToGroup(LPDPLOBBYSP, LPSPDATA_ADDREMOTEPLAYERTOGROUP);
extern HRESULT DPLAPI DPLP_CreateGroup(LPDPLOBBYSP, LPSPDATA_CREATEREMOTEGROUP);
extern HRESULT DPLAPI DPLP_CreateGroupInGroup(LPDPLOBBYSP, LPSPDATA_CREATEREMOTEGROUPINGROUP);
extern HRESULT DPLAPI DPLP_DeleteGroupFromGroup(LPDPLOBBYSP, LPSPDATA_DELETEREMOTEGROUPFROMGROUP);
extern HRESULT DPLAPI DPLP_DeletePlayerFromGroup(LPDPLOBBYSP, LPSPDATA_DELETEREMOTEPLAYERFROMGROUP);
extern HRESULT DPLAPI DPLP_DestroyGroup(LPDPLOBBYSP, LPSPDATA_DESTROYREMOTEGROUP);
extern HRESULT DPLAPI DPLP_GetSPDataPointer(LPDPLOBBYSP, LPVOID *);
extern HRESULT DPLAPI DPLP_HandleMessage(LPDPLOBBYSP, LPSPDATA_HANDLEMESSAGE);
extern HRESULT DPLAPI DPLP_SendChatMessage(LPDPLOBBYSP, LPSPDATA_CHATMESSAGE);
extern HRESULT DPLAPI DPLP_SetGroupName(LPDPLOBBYSP, LPSPDATA_SETREMOTEGROUPNAME);
extern HRESULT DPLAPI DPLP_SetGroupOwner(LPDPLOBBYSP, LPSPDATA_SETREMOTEGROUPOWNER);
extern HRESULT DPLAPI DPLP_SetPlayerName(LPDPLOBBYSP, LPSPDATA_SETREMOTEPLAYERNAME);
extern HRESULT DPLAPI DPLP_SetSessionDesc(LPDPLOBBYSP, LPSPDATA_SETSESSIONDESC);
extern HRESULT DPLAPI DPLP_SetSPDataPointer(LPDPLOBBYSP, LPVOID);
extern HRESULT DPLAPI DPLP_StartSession(LPDPLOBBYSP, LPSPDATA_STARTSESSIONCOMMAND);

HRESULT DPLAPI PRV_BroadcastDestroyGroupMessage(LPDPLOBBYI_DPLOBJECT, DPID);
HRESULT PRV_DeleteRemotePlayerFromGroup(LPDPLOBBYI_DPLOBJECT,
		LPSPDATA_DELETEREMOTEPLAYERFROMGROUP, BOOL);
HRESULT DPLAPI DPLP_DestroyGroup(LPDPLOBBYSP, LPSPDATA_DESTROYREMOTEGROUP);
void PRV_RemoveSubgroupsAndPlayersFromGroup(LPDPLOBBYI_DPLOBJECT,
		LPDPLAYI_GROUP, DWORD, BOOL);
HRESULT PRV_DeleteRemoteGroupFromGroup(LPDPLOBBYI_DPLOBJECT,
		LPSPDATA_DELETEREMOTEGROUPFROMGROUP, BOOL, LPDPLAYI_GROUP);
void PRV_SendDeleteShortcutMessageForExitingGroup(LPDPLOBBYI_DPLOBJECT,	LPDPLAYI_GROUP);
HRESULT PRV_SendDataChangedMessageLocally(LPDPLOBBYI_DPLOBJECT, DPID, LPVOID, DWORD);
HRESULT PRV_SendNameChangedMessageLocally(LPDPLOBBYI_DPLOBJECT, DPID, LPDPNAME, BOOL);
HRESULT PRV_SendGroupOwnerMessageLocally(LPDPLOBBYI_DPLOBJECT, DPID, DPID, DPID);

// group.c
extern HRESULT PRV_GetGroupConnectionSettings(LPDIRECTPLAY, DWORD, DPID,
							LPVOID, LPDWORD);
extern HRESULT PRV_SetGroupConnectionSettings(LPDIRECTPLAY, DWORD, DPID,
							LPDPLCONNECTION, BOOL);
extern HRESULT PRV_CreateAndMapNewGroup(LPDPLOBBYI_DPLOBJECT,
			DPID *, LPDPNAME, LPVOID, DWORD, DWORD, DWORD, DPID, DWORD);

void PRV_DestroySubgroups(LPDPLOBBYI_DPLOBJECT, LPDPLAYI_GROUP, BOOL);
void PRV_DestroyGroupAndParents(LPDPLOBBYI_DPLOBJECT, LPDPLAYI_GROUP, LPDPLAYI_GROUP);

// player.c
extern HRESULT PRV_GrowMapTable(LPDPLOBBYI_DPLOBJECT);
extern HRESULT PRV_CreateAndMapNewPlayer(LPDPLOBBYI_DPLOBJECT,
			DPID *, LPDPNAME, HANDLE, LPVOID, DWORD, DWORD, DWORD, BOOL);
extern BOOL IsValidLobbyID(DWORD);
extern BOOL IsLobbyIDInMapTable(LPDPLOBBYI_DPLOBJECT, DWORD);

// session.c
extern HRESULT DPLAPI DPLP_EnumSessionsResponse(LPDPLOBBYSP, LPSPDATA_ENUMSESSIONSRESPONSE);


// api.c (in the dplay project)
HRESULT TimeBomb();
HRESULT ConnectMe(LPDIRECTPLAYLOBBY, LPDIRECTPLAY2 FAR *, IUnknown FAR *, DWORD); 


#endif // __DPLOBPR_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\dplpack.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplpack.c
 *  Content:	Methods for packing/unpacking structures
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	5/31/96		myronth	Created it
 *	6/26/96		kipo	added support for DPADDRESS.
 *  7/13/96		kipo	Bug fix - added (LPBYTE) cast to lpConnPack (address calc)
 *						in PRV_UnpackageDPLCONNECTIONAnsi()
 *	11/20/96	myronth	Removed packing for DPTRANSPORT
 *	12/12/96	myronth	Added DPLCONNECTION structure validation
 *	2/12/97		myronth	Mass DX5 changes
 *	4/3/97		myronth Changed STRLEN's to WSTRLEN's from dplaypr.h
 *	5/8/97		myronth	Changed most packing functions to use the packed
 *						conn header, added pointer fixup function, Moved
 *						PRV_ConvertDPLCONNECTIONToUnicode from convert.c
 *	9/29/97		myronth	Fixed DPLCONNECTION package size bug (#12475)
 *	12/2/97		myronth	Made SessionDesc mandatory in DPLCONNECTION (#15529)
 *	7/08/98	   a-peterz	Allow for MBCS for ANSI string sizes. ManBug 16299
 *  2/10/99     aarono  add support for application launcher
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetDPLCONNECTIONPackageSize"
void PRV_GetDPLCONNECTIONPackageSize(LPDPLCONNECTION lpConn,
						LPDWORD lpdwUnicode, LPDWORD lpdwAnsi)
{
	DWORD				dwSize;
	DWORD				dwStringSize = 0;
	DWORD				dwStringSizeA = 0;
	LPDPSESSIONDESC2	lpsd = NULL;
	LPDPNAME			lpn = NULL;


	DPF(7, "Entering PRV_GetDPLCONNECTIONPackageSize");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpConn, lpdwUnicode, lpdwAnsi);

	ASSERT(lpConn);
	
	// First calculate the size of the structures
	dwSize = sizeof(DPLCONNECTION);

	// Add the size of the SessionDesc and Name structs
	if(lpConn->lpSessionDesc)
	{
		dwSize += sizeof(DPSESSIONDESC2);
		lpsd = lpConn->lpSessionDesc;
		
		if(lpsd->lpszSessionName)
			dwStringSize += WSTRLEN(lpsd->lpszSessionName);
		if(lpsd->lpszPassword)
			dwStringSize += WSTRLEN(lpsd->lpszPassword);
		// only compute ANSI size if needed. Macro handles NULLS; includes terminator
		if(lpdwAnsi)
		{
			dwStringSizeA += WSTR_ANSILENGTH(lpsd->lpszSessionName);
			dwStringSizeA += WSTR_ANSILENGTH(lpsd->lpszPassword);
		}
	}


	if(lpConn->lpPlayerName)
	{
		dwSize += sizeof(DPNAME);
		lpn = lpConn->lpPlayerName;
		
		if(lpn->lpszShortName)
			dwStringSize += WSTRLEN(lpn->lpszShortName);
		if(lpn->lpszLongName)
			dwStringSize += WSTRLEN(lpn->lpszLongName);
		// only compute ANSI size if needed. Macro handles NULLS; includes terminator
		if(lpdwAnsi)
		{
			dwStringSizeA += WSTR_ANSILENGTH(lpn->lpszShortName);
			dwStringSizeA += WSTR_ANSILENGTH(lpn->lpszLongName);
		}
	}

	// Add the size of the SP-specific data
	if(lpConn->lpAddress)
		dwSize += lpConn->dwAddressSize;

	// Now add in the size of the packed structure header
	dwSize += sizeof(DPLOBBYI_PACKEDCONNHEADER);

	// Fill in the output variables
	if(lpdwAnsi)
		*lpdwAnsi = dwSize + dwStringSizeA;
	if(lpdwUnicode)
		*lpdwUnicode = dwSize + (dwStringSize * sizeof(WCHAR));

} // PRV_GetDPLCONNECTIONPackageSize


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_PackageDPLCONNECTION"
HRESULT PRV_PackageDPLCONNECTION(LPDPLCONNECTION lpConn, LPVOID lpBuffer,
			BOOL bHeader)
{
	LPDPLOBBYI_PACKEDCONNHEADER		lpHeader = NULL;
	LPDPLCONNECTION					lpConnPacked = NULL;
	LPDPSESSIONDESC2				lpsd = NULL,
									lpsdPacked = NULL;
	LPDPNAME						lpn = NULL,
									lpnPacked = NULL;
	LPBYTE							lpStart, lpCurrent;
	DWORD							dwSizeAnsi,
									dwSizeUnicode,
									dwTemp;
	

	DPF(7, "Entering PRV_PackageDPLCONNECTION");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu", lpConn, lpBuffer, bHeader);

	ASSERT(lpConn);
	
	// If the bHeader flag is set, we want to copy the packed header into the
	// buffer first.  If it is not, we only want the packed DPLCONNECTION struct
	if(bHeader)
	{
		PRV_GetDPLCONNECTIONPackageSize(lpConn, &dwSizeUnicode, &dwSizeAnsi);
		lpHeader = (LPDPLOBBYI_PACKEDCONNHEADER)lpBuffer;
		lpHeader->dwUnicodeSize = dwSizeUnicode;
		lpHeader->dwAnsiSize = dwSizeAnsi;
		lpStart = (LPBYTE)lpBuffer + sizeof(DPLOBBYI_PACKEDCONNHEADER);
	}
	else
	{
		lpStart = lpBuffer;
	}

	// Copy in the structures & store the offsets
	memcpy(lpStart, lpConn, sizeof(DPLCONNECTION));
	lpConnPacked = (LPDPLCONNECTION)lpStart;
	lpCurrent = lpStart + sizeof(DPLCONNECTION);

	if(lpConn->lpSessionDesc)
	{
		lpsd = lpConn->lpSessionDesc;
		memcpy(lpCurrent, lpsd, sizeof(DPSESSIONDESC2));
		lpsdPacked = (LPDPSESSIONDESC2)lpCurrent;
		(DWORD_PTR)lpConnPacked->lpSessionDesc = (DWORD_PTR)(lpCurrent - lpStart);
		lpCurrent += sizeof(DPSESSIONDESC2);
	}

	if(lpConn->lpPlayerName)
	{
		lpn = lpConn->lpPlayerName;
		memcpy(lpCurrent, lpn, sizeof(DPNAME));
		lpnPacked = (LPDPNAME)lpCurrent;
		(DWORD_PTR)lpConnPacked->lpPlayerName = (DWORD_PTR)(lpCurrent - lpStart);
		lpCurrent += sizeof(DPNAME);
	}

	// Copy in the strings in the SessionDesc and store the offset of the
	// string from lpStart (relative offset in our package) in the pointer
	// for the string in the SessionDesc structure.  We will use this
	// value to unpack and fix up the pointers during GetConnectionSettings
	if(lpsd)
	{
		if(lpsd->lpszSessionName)
		{
			// Copy the string
			dwTemp = WSTRLEN(lpsd->lpszSessionName) * sizeof(WCHAR);
			memcpy(lpCurrent, lpsd->lpszSessionName, dwTemp);

			// Store the offset
			lpsdPacked->lpszSessionName = (LPWSTR)((DWORD)(lpCurrent - lpStart));

			lpCurrent += dwTemp;
		}

		if(lpsd->lpszPassword)
		{
			// Copy the string
			dwTemp = WSTRLEN(lpsd->lpszPassword) * sizeof(WCHAR);
			memcpy(lpCurrent, lpsd->lpszPassword, dwTemp);

			// Store the offset
			lpsdPacked->lpszPassword = (LPWSTR)((DWORD)(lpCurrent - lpStart));

			lpCurrent += dwTemp;
		}

	}

	// Copy in the strings in the DPName struct and store the offset of the
	// string from lpStart (relative offset in our package) in the pointer
	// for the string in the SessionDesc structure.  We will use this
	// value to unpack and fix up the pointers during GetConnectionSettings
	if(lpn)
	{
		if(lpn->lpszShortName)
		{
			// Copy the string
			dwTemp = WSTRLEN(lpn->lpszShortName) * sizeof(WCHAR);
			memcpy(lpCurrent, lpn->lpszShortName, dwTemp);

			// Store the offset
			lpnPacked->lpszShortName = (LPWSTR)((DWORD)(lpCurrent - lpStart));

			lpCurrent += dwTemp;
		}

		if(lpn->lpszLongName)
		{
			// Copy the string
			dwTemp = WSTRLEN(lpn->lpszLongName) * sizeof(WCHAR);
			memcpy(lpCurrent, lpn->lpszLongName, dwTemp);

			// Store the offset
			lpnPacked->lpszLongName = (LPWSTR)((DWORD)(lpCurrent - lpStart));

			lpCurrent += dwTemp;
		}

	}

	// Copy in the SP-specific data
	if(lpConn->lpAddress)
	{
			// Copy the data
			memcpy(lpCurrent, lpConn->lpAddress, lpConn->dwAddressSize);

			// Store the offset
			(((LPDPLCONNECTION)lpStart)->lpAddress = (LPVOID)((DWORD)(lpCurrent - lpStart)));
	}

	return DP_OK;

} // PRV_PackageDPLCONNECTION



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_UnpackageDPLCONNECTIONUnicode"
//BUGBUG: really need to define a WIRE LPDPLCONNECTION so that
//        we can crack it that way.  This will allow compile, until
//        we can test on Win64, there is no way to verify cracking
//        the packet, so I've deffered this work until then AO 11/10/98
HRESULT PRV_UnpackageDPLCONNECTIONUnicode(LPVOID lpData, LPVOID lpPackage)
{
	LPDPLOBBYI_PACKEDCONNHEADER		lpHeader = NULL;
	LPDPLCONNECTION					lpConn = NULL;
	LPDPSESSIONDESC2				lpsd = NULL;
	LPDPNAME						lpn = NULL;
	LPBYTE							lpPackCur, lpDataStart;
	DWORD_PTR						dwSize;
	

	DPF(7, "Entering PRV_UnpackageDPLCONNECTIONUnicode");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpData, lpPackage);

	// If we're Unicode, all we need to do is copy the entire package
	// and fix up the pointers
	lpHeader = (LPDPLOBBYI_PACKEDCONNHEADER)lpPackage;
	dwSize = lpHeader->dwUnicodeSize;
	lpPackCur = ((LPBYTE)lpPackage) + sizeof(DPLOBBYI_PACKEDCONNHEADER);
	lpDataStart = lpData;
	
	// Copy the data
	memcpy(lpData, lpPackCur, (DWORD)dwSize);

	// Fix up the pointers -- the offset of every element relative to
	// the start of lpConn is stored in the pointer for the element.
	// So all we have to do to fix up the pointers is calculate it from
	// the given offset + the value of lpConn.
	lpConn = (LPDPLCONNECTION)lpData;

	if(lpConn->lpSessionDesc)
	{
		dwSize = (DWORD_PTR)lpConn->lpSessionDesc;
		lpsd = lpConn->lpSessionDesc = (LPDPSESSIONDESC2)(lpDataStart + dwSize);

		// Now do the same for the strings
		if(lpsd->lpszSessionName)
		{
			lpsd->lpszSessionName = (LPWSTR)(lpDataStart +
								((DWORD_PTR)lpsd->lpszSessionName));
		}

		if(lpsd->lpszPassword)
		{
			lpsd->lpszPassword = (LPWSTR)(lpDataStart +
								((DWORD_PTR)lpsd->lpszPassword));
		}
	}

	if(lpConn->lpPlayerName)
	{
		dwSize = (DWORD_PTR)lpConn->lpPlayerName;
		lpn = lpConn->lpPlayerName = (LPDPNAME)(lpDataStart + dwSize);

		// Now do the same for the strings
		if(lpn->lpszShortName)
		{
			lpn->lpszShortName = (LPWSTR)(lpDataStart +
								((DWORD_PTR)lpn->lpszShortName));
		}

		if(lpn->lpszLongName)
		{
			lpn->lpszLongName = (LPWSTR)(lpDataStart +
								((DWORD_PTR)lpn->lpszLongName));
		}

	}

	// Fix the SPData pointer
	if(lpConn->lpAddress)
	{
		lpConn->lpAddress = lpDataStart + ((DWORD_PTR)lpConn->lpAddress);
	}

	return DP_OK;

} // PRV_UnpackageDPLCONNECTIONUnicode


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_UnpackageDPLCONNECTIONAnsi"
HRESULT PRV_UnpackageDPLCONNECTIONAnsi(LPVOID lpData, LPVOID lpPackage)
{
	LPDPLOBBYI_PACKEDCONNHEADER		lpHeader = NULL;
	LPDPLCONNECTION					lpConnData, lpConnPack;
	LPDPSESSIONDESC2				lpsdData = NULL,
									lpsdPack = NULL;
	LPDPNAME						lpnData = NULL,
									lpnPack = NULL;
	LPBYTE							lpDataCur, lpPackCur;
	DWORD							dwTemp;
	LPWSTR							lpszTemp;
	

	DPF(7, "Entering PRV_UnpackageDPLCONNECTIONAnsi");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpData, lpPackage);

	// If we're Ansi, we need to do is copy the structures, convert
	// and copy the strings, and fix up all the pointers
	lpPackCur = ((LPBYTE)lpPackage) + sizeof(DPLOBBYI_PACKEDCONNHEADER);
	lpDataCur = lpData;
	
	// First copy the main structures
	dwTemp = sizeof(DPLCONNECTION);
	memcpy(lpDataCur, lpPackCur, dwTemp);
	lpConnData = (LPDPLCONNECTION)lpDataCur;
	lpConnPack = (LPDPLCONNECTION)lpPackCur;

	lpDataCur += dwTemp;
	lpPackCur += dwTemp;

	if(lpConnData->lpSessionDesc)
	{
		dwTemp = sizeof(DPSESSIONDESC2);
		memcpy(lpDataCur, lpPackCur, sizeof(DPSESSIONDESC2));
		lpsdData = lpConnData->lpSessionDesc = (LPDPSESSIONDESC2)lpDataCur;
		lpsdPack = (LPDPSESSIONDESC2)lpPackCur;
		lpDataCur += dwTemp;
		lpPackCur += dwTemp;
	}

	if(lpConnData->lpPlayerName)
	{
		dwTemp = sizeof(DPNAME);
		memcpy(lpDataCur, lpPackCur, sizeof(DPNAME));
		lpnData = lpConnData->lpPlayerName = (LPDPNAME)lpDataCur;
		lpnPack = (LPDPNAME)lpPackCur;
		lpDataCur += dwTemp;
		lpPackCur += dwTemp;
	}

	// Copy the strings & fix up the pointers
	if(lpsdData)
	{
		if(lpsdData->lpszSessionName)
		{
			lpszTemp = (LPWSTR)((LPBYTE)lpConnPack + (DWORD_PTR)lpsdPack->lpszSessionName);
			dwTemp = WideToAnsi(NULL, lpszTemp, 0);	// size includes terminator
			WideToAnsi((LPSTR)lpDataCur, lpszTemp, dwTemp);
			lpsdData->lpszSessionNameA = (LPSTR)lpDataCur;
			lpDataCur += dwTemp;
		}

		if(lpsdData->lpszPassword)
		{
			lpszTemp = (LPWSTR)((LPBYTE)lpConnPack + (DWORD_PTR)lpsdPack->lpszPassword);
			dwTemp = WideToAnsi(NULL, lpszTemp, 0);	// size includes terminator
			WideToAnsi((LPSTR)lpDataCur, lpszTemp, dwTemp);
			lpsdData->lpszPasswordA = (LPSTR)lpDataCur;
			lpDataCur += dwTemp;
		}
	}

	if(lpnData)
	{
		if(lpnData->lpszShortName)
		{
			lpszTemp = (LPWSTR)((LPBYTE)lpConnPack + (DWORD_PTR)lpnPack->lpszShortName);
			dwTemp = WideToAnsi(NULL, lpszTemp, 0);	// size includes terminator
			WideToAnsi((LPSTR)lpDataCur, lpszTemp, dwTemp);
			lpnData->lpszShortNameA = (LPSTR)lpDataCur;
			lpDataCur += dwTemp;
		}

		if(lpnData->lpszLongName)
		{
			lpszTemp = (LPWSTR)((LPBYTE)lpConnPack + (DWORD_PTR)lpnPack->lpszLongName);
			dwTemp = WideToAnsi(NULL, lpszTemp, 0);	// size includes terminator
			WideToAnsi((LPSTR)lpDataCur, lpszTemp, dwTemp);
			lpnData->lpszLongNameA = (LPSTR)lpDataCur;
			lpDataCur += dwTemp;
		}

	}

	// Copy in the SPData & fix up the pointer
	if(lpConnData->lpAddress)
	{
		lpPackCur = ((LPBYTE)lpConnPack) + (DWORD_PTR)lpConnPack->lpAddress;
		memcpy(lpDataCur, lpPackCur, lpConnPack->dwAddressSize);
		lpConnData->lpAddress = lpDataCur;
	}

	return DP_OK;

} // PRV_UnpackageDPLCONNECTIONAnsi




#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ValidateDPLCONNECTION"
HRESULT PRV_ValidateDPLCONNECTION(LPDPLCONNECTION lpConn, BOOL bAnsi)
{
	LPDPSESSIONDESC2	lpsd = NULL;
	LPDPNAME			lpn = NULL;


	DPF(7, "Entering PRV_ValidateDPLCONNECTION");
	DPF(9, "Parameters: 0x%08x, %lu", lpConn, bAnsi);
	

	TRY
	{
		// Validate the connection structure itself
		if(!VALID_DPLOBBY_CONNECTION(lpConn))
		{
			DPF_ERR("Invalid DPLCONNECTION structure");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the flags
		if(lpConn->dwFlags & ~(DPLCONNECTION_CREATESESSION | DPLCONNECTION_JOINSESSION))
		{
			DPF_ERR("Invalid flags exist in the dwFlags member of the DPLCONNECTION structure");
			return DPERR_INVALIDFLAGS;
		}

		// Validate the SessionDesc structure
		if(lpConn->lpSessionDesc)
		{
			lpsd = lpConn->lpSessionDesc;
			// Validate the structure itself
			if(!VALID_READ_DPSESSIONDESC2(lpsd))
			{
				DPF_ERR("Invalid DPSESSIONDESC2 structure in DPLCONNECTION structure");
				return DPERR_INVALIDPARAMS;
			}

			// Validate the SessionName string
			if(lpsd->lpszSessionName)
			{
				if(!VALID_READ_PTR(lpsd->lpszSessionName, (bAnsi ?
					strlen(lpsd->lpszSessionNameA) : WSTRLEN_BYTES(lpsd->lpszSessionName))))
				{
					DPF_ERR("Invalid SessionName string in DPLCONNECTION structure");
					return DPERR_INVALIDPARAMS;
				}
			}

			// Validate the Password string
			if(lpsd->lpszPassword)
			{
				if(!VALID_READ_PTR(lpsd->lpszPassword, (bAnsi ?
					strlen(lpsd->lpszPasswordA) : WSTRLEN_BYTES(lpsd->lpszPassword))))
				{
					DPF_ERR("Invalid Password string in DPLCONNECTION structure");
					return DPERR_INVALIDPARAMS;
				}
			}
		}
		else
		{
			DPF_ERR("Invalid SessionDesc pointer in DPLCONNECTION structure");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the Name structure
		if(lpConn->lpPlayerName)
		{
			lpn = lpConn->lpPlayerName;
			if(!VALID_READ_DPNAME_PTR(lpn))
			{
				DPF_ERR("Invalid DPNAME structure in DPLCONNECTION structure");
				return DPERR_INVALIDPARAMS;
			}

			// Validate the ShortName string
			if(lpn->lpszShortName)
			{
				if(!VALID_READ_PTR(lpn->lpszShortName, (bAnsi ?
					strlen(lpn->lpszShortNameA) : WSTRLEN_BYTES(lpn->lpszShortName))))
				{
					DPF_ERR("Invalid ShortName string in DPLCONNECTION structure");
					return DPERR_INVALIDPARAMS;
				}
			}

			// Validate the LongName string
			if(lpn->lpszLongName)
			{
				if(!VALID_READ_PTR(lpn->lpszLongName, (bAnsi ?
					strlen(lpn->lpszLongNameA) : WSTRLEN_BYTES(lpn->lpszLongName))))
				{
					DPF_ERR("Invalid LongName string in DPLCONNECTION structure");
					return DPERR_INVALIDPARAMS;
				}
			}
		}

		// Validate the DPADDRESS structure
		if(lpConn->lpAddress)
		{
			if(!VALID_READ_PTR(lpConn->lpAddress, lpConn->dwAddressSize))
			{
				DPF_ERR("Invalid lpAddress in DPLCONNECTION structure");
				return DPERR_INVALIDPARAMS;
			}
		}
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	return DP_OK;

} // PRV_ValidateDPLCONNECTION



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ConvertDPLCONNECTIONToUnicode"
HRESULT PRV_ConvertDPLCONNECTIONToUnicode(LPDPLCONNECTION lpConnA,
					LPDPLCONNECTION * lplpConnW)
{
	LPDPLCONNECTION		lpConnW = NULL;
	LPDPSESSIONDESC2	lpsdW = NULL, lpsdA;
	LPDPNAME			lpnW = NULL, lpnA;
	LPWSTR				lpwszSessionName = NULL;
	LPWSTR				lpwszPassword = NULL;
	LPWSTR				lpwszLongName = NULL;
	LPWSTR				lpwszShortName = NULL;
	HRESULT				hr = DP_OK;


	DPF(7, "Entering PRV_ConvertDPLCONNECTIONToUnicode");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpConnA, lplpConnW);

	ASSERT(lpConnA);
	ASSERT(lplpConnW);


	// Allocate memory for the DPLCONNECTION structure
	lpConnW = DPMEM_ALLOC(sizeof(DPLCONNECTION));
	if(!lpConnW)
	{
		DPF_ERR("Unable to allocate memory for temporary Unicode DPLCONNECTION struct");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_CONVERT_DPLCONNECTION;
	}

	// If we need a SessionDesc struct, allocate one
	if(lpConnA->lpSessionDesc)
	{
		lpsdW = DPMEM_ALLOC(sizeof(DPSESSIONDESC2));
		if(!lpsdW)
		{
			DPF_ERR("Unable to allocate memory for temporary Unicode DPSESSIONDESC struct");
			hr = DPERR_OUTOFMEMORY;
			goto ERROR_CONVERT_DPLCONNECTION;
		}
	}

	// If we need a DPName struct, allocate one
	if(lpConnA->lpPlayerName)
	{
		lpnW = DPMEM_ALLOC(sizeof(DPNAME));
		if(!lpnW)
		{
			DPF_ERR("Unable to allocate memory for temporary Unicode DPNAME struct");
			hr = DPERR_OUTOFMEMORY;
			goto ERROR_CONVERT_DPLCONNECTION;
		}
	}

	// Copy the fixed size members of the structures
	memcpy(lpConnW, lpConnA, sizeof(DPLCONNECTION));
	if(lpsdW)
		memcpy(lpsdW, lpConnA->lpSessionDesc, sizeof(DPSESSIONDESC2));
	if(lpnW)
		memcpy(lpnW, lpConnA->lpPlayerName, sizeof(DPNAME));


	// Get Unicode copies of all the strings
	if(lpConnA->lpSessionDesc)
	{
		lpsdA = lpConnA->lpSessionDesc;
		if(lpsdA->lpszSessionNameA)
		{
			hr = GetWideStringFromAnsi((LPWSTR *)&(lpwszSessionName),
										(LPSTR)lpsdA->lpszSessionNameA);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to allocate temporary Unicode Session Name string");
				goto ERROR_CONVERT_DPLCONNECTION;
			}
		}

		if(lpsdA->lpszPasswordA)
		{
			hr = GetWideStringFromAnsi((LPWSTR *)&(lpwszPassword),
										(LPSTR)lpsdA->lpszPasswordA);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to allocate temporary Unicode Password string");
				goto ERROR_CONVERT_DPLCONNECTION;
			}
		}
	}    

	if(lpConnA->lpPlayerName)
	{
		lpnA = lpConnA->lpPlayerName;
		if(lpnA->lpszShortNameA)
		{
			hr = GetWideStringFromAnsi((LPWSTR *)&(lpwszShortName),
										(LPSTR)lpnA->lpszShortNameA);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to allocate temporary Unicode Short Name string");
				goto ERROR_CONVERT_DPLCONNECTION;
			}
		}

		if(lpnA->lpszLongNameA)
		{
			hr = GetWideStringFromAnsi((LPWSTR *)&(lpwszLongName),
										(LPSTR)lpnA->lpszLongNameA);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to allocate temporary Unicode Long Name string");
				goto ERROR_CONVERT_DPLCONNECTION;
			}
		}
	}    

	// Now we've got everything so just fix up the pointers
	lpConnW->lpSessionDesc = lpsdW;
	lpConnW->lpPlayerName = lpnW;

	if(lpsdW)
	{
		lpsdW->lpszSessionName = lpwszSessionName;
		lpsdW->lpszPassword = lpwszPassword;
	}

	if(lpnW)
	{
		lpnW->lpszShortName = lpwszShortName;
		lpnW->lpszLongName = lpwszLongName;
	}

	*lplpConnW = lpConnW;

	return DP_OK;


ERROR_CONVERT_DPLCONNECTION:

	if(lpConnW)
		DPMEM_FREE(lpConnW);
	if(lpsdW)
		DPMEM_FREE(lpsdW);
	if(lpnW)
		DPMEM_FREE(lpnW);
	if(lpwszSessionName)
		DPMEM_FREE(lpwszSessionName);
	if(lpwszPassword)
		DPMEM_FREE(lpwszPassword);
	if(lpwszShortName)
		DPMEM_FREE(lpwszShortName);
	if(lpwszLongName)
		DPMEM_FREE(lpwszLongName);

	return hr;		

} // PRV_ConvertDPLCONNECTIONToUnicode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FixupDPLCONNECTIONPointers"
void PRV_FixupDPLCONNECTIONPointers(LPDPLCONNECTION lpConn)
{
	LPDPSESSIONDESC2	lpsd = NULL;
	LPDPNAME			lpn = NULL;
	

	DPF(7, "Entering PRV_FixupDPLCONNECTIONPointers");
	DPF(9, "Parameters: 0x%08x", lpConn);

	// Make sure we have a valid DPLCONNECTION pointer
	if(!lpConn)
	{
		DPF_ERR("Invalid DPLCONNECTION pointer");
		ASSERT(FALSE);
		return;
	}

	// Fixup the DPSESSIONDESC2 pointer
	if(lpConn->lpSessionDesc)
	{
		lpsd = (LPDPSESSIONDESC2)((LPBYTE)lpConn + (DWORD_PTR)lpConn->lpSessionDesc);
		lpConn->lpSessionDesc = lpsd;
	}

	// Fixup the name strings in the SessionDesc struct
	if(lpsd)
	{
		// Fixup the session name
		if(lpsd->lpszSessionName)
		{
			lpsd->lpszSessionName = (LPWSTR)((LPBYTE)lpConn +
				(DWORD_PTR)lpsd->lpszSessionName);
		}

		// Fixup the password
		if(lpsd->lpszPassword)
		{
			lpsd->lpszPassword = (LPWSTR)((LPBYTE)lpConn +
				(DWORD_PTR)lpsd->lpszPassword);
		}
	}

	// Fixup the DPNAME pointer
	if(lpConn->lpPlayerName)
	{
		lpn = (LPDPNAME)((LPBYTE)lpConn + (DWORD_PTR)lpConn->lpPlayerName);
		lpConn->lpPlayerName = lpn;
	}

	// Fixup the name strings
	if(lpn)
	{
		// Fixup the short name
		if(lpn->lpszShortName)
		{
			lpn->lpszShortName = (LPWSTR)((LPBYTE)lpConn +
				(DWORD_PTR)lpn->lpszShortName);
		}

		// Fixup the long name
		if(lpn->lpszLongName)
		{
			lpn->lpszLongName = (LPWSTR)((LPBYTE)lpConn +
				(DWORD_PTR)lpn->lpszLongName);
		}
	}

	// Fixup the address pointer
	if(lpConn->lpAddress)
	{
		lpConn->lpAddress = (LPBYTE)lpConn + (DWORD_PTR)lpConn->lpAddress;
	}

} // PRV_FixupDPLCONNECTIONPointers



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ConvertDPLCONNECTIONToAnsiInPlace"
HRESULT PRV_ConvertDPLCONNECTIONToAnsiInPlace(LPDPLCONNECTION lpConn,
		LPDWORD lpdwSize, DWORD dwHeaderSize)
{
	DWORD					dwSessionNameSize = 0, dwPasswordSize = 0;
	DWORD					dwShortNameSize = 0, dwLongNameSize = 0;
	DWORD					dwSessionDescSize = 0, dwNameSize = 0;
	DWORD					dwAnsiSize = 0;
	LPSTR					lpszSession = NULL, lpszPassword = 0;
	LPSTR					lpszShort = NULL, lpszLong = 0;
	LPBYTE					lpByte = NULL;

	
	DPF(7, "Entering PRV_ConvertDPLCONNECTIONToAnsiInPlace");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu",
			lpConn, lpdwSize, dwHeaderSize);

	// If we don't have a DPLCONNECTION struct, something's wrong
	ASSERT(lpConn);
	ASSERT(lpdwSize);

	// Start with the DPSESSIONDESC2 strings
	if(lpConn->lpSessionDesc)
	{
		if(lpConn->lpSessionDesc->lpszSessionName)
		{
			GetAnsiString(&lpszSession, lpConn->lpSessionDesc->lpszSessionName);
			dwSessionNameSize = STRLEN(lpszSession);
		}

		if(lpConn->lpSessionDesc->lpszPassword)
		{
			GetAnsiString(&lpszPassword, lpConn->lpSessionDesc->lpszPassword);
			dwPasswordSize = STRLEN(lpszPassword);
		}
		dwSessionDescSize = sizeof(DPSESSIONDESC2) + dwSessionNameSize +
								dwPasswordSize;
	}

	// Next the DPNAME strings
	if(lpConn->lpPlayerName)
	{
		if(lpConn->lpPlayerName->lpszShortName)
		{
			GetAnsiString(&lpszShort, lpConn->lpPlayerName->lpszShortName);
			dwShortNameSize = STRLEN(lpszShort);
		}

		if(lpConn->lpPlayerName->lpszLongName)
		{
			GetAnsiString(&lpszLong, lpConn->lpPlayerName->lpszLongName);
			dwLongNameSize = STRLEN(lpszLong);
		}
		dwNameSize = sizeof(DPNAME) + dwShortNameSize + dwLongNameSize;
	}

	dwAnsiSize = dwHeaderSize + sizeof(DPLCONNECTION) +
				dwSessionDescSize + dwNameSize + lpConn->dwAddressSize;

	if (dwAnsiSize > *lpdwSize)
	{
		if(lpszSession)
			DPMEM_FREE(lpszSession);
		if(lpszPassword)
			DPMEM_FREE(lpszPassword);
		if(lpszShort)
			DPMEM_FREE(lpszShort);
		if(lpszLong)
			DPMEM_FREE(lpszLong);
		*lpdwSize = dwAnsiSize;
		return DPERR_BUFFERTOOSMALL;
	}

	// store return size
	*lpdwSize = dwAnsiSize;

	// figure out where to start repacking strings
	lpByte = (LPBYTE)lpConn + sizeof(DPLCONNECTION);
	if(lpConn->lpSessionDesc)
		lpByte += sizeof(DPSESSIONDESC2);
	if(lpConn->lpPlayerName)
		lpByte += sizeof(DPNAME);

	// repack 'em
	if(lpszSession)
	{
		memcpy(lpByte, lpszSession, dwSessionNameSize);
		lpConn->lpSessionDesc->lpszSessionNameA = (LPSTR)lpByte;
		DPMEM_FREE(lpszSession);
		lpByte += dwSessionNameSize;
	}
	if(lpszPassword)
	{
		memcpy(lpByte, lpszPassword, dwPasswordSize);
		lpConn->lpSessionDesc->lpszPasswordA = (LPSTR)lpByte;
		DPMEM_FREE(lpszPassword);
		lpByte += dwPasswordSize;
	}
	if(lpszShort)
	{
		memcpy(lpByte, lpszShort, dwShortNameSize);
		lpConn->lpPlayerName->lpszShortNameA = (LPSTR)lpByte;
		DPMEM_FREE(lpszShort);
		lpByte += dwShortNameSize;
	}
	if(lpszLong)
	{
		memcpy(lpByte, lpszLong, dwLongNameSize);
		lpConn->lpPlayerName->lpszLongNameA = (LPSTR)lpByte;
		DPMEM_FREE(lpszLong);
		lpByte += dwLongNameSize;
	}

	if(lpConn->lpAddress)
	{
		// recopy the address, and account for the fact that we could
		// be doing an overlapping memory copy (So use MoveMemory instead
		// of CopyMemory or memcpy)
		MoveMemory(lpByte, lpConn->lpAddress, lpConn->dwAddressSize);
		lpConn->lpAddress = lpByte;
	}

	return DP_OK;
} // PRV_ConvertDPLCONNECTIONToAnsiInPlace



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ValidateDPAPPLICATIONDESC"
HRESULT PRV_ValidateDPAPPLICATIONDESC(LPDPAPPLICATIONDESC lpDesc, BOOL bAnsi)
{
	DWORD LobbyDescVer;
	LPDPAPPLICATIONDESC2 lpDesc2=(LPDPAPPLICATIONDESC2) lpDesc;

	DPF(7, "Entering PRV_ValidateDPAPPLICATIONDESC");
	DPF(9, "Parameters: 0x%08x, %lu", lpDesc, bAnsi);
	

	TRY
	{
		// Validate the connection structure itself
		if(VALID_DPLOBBY_APPLICATIONDESC(lpDesc)){
			LobbyDescVer=1;
		} else if (VALID_DPLOBBY_APPLICATIONDESC2(lpDesc)){
			LobbyDescVer=2;
		} else {
			DPF_ERR("Invalid structure pointer or invalid size");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the flags
		if(lpDesc->dwFlags)
		{
			DPF_ERR("Invalid flags exist in the dwFlags member of the DPAPPLICATIONDESC structure");
			return DPERR_INVALIDFLAGS;
		}

		// Validate the ApplicationName string (required)
		if(lpDesc->lpszApplicationName)
		{
			if(!VALID_READ_PTR(lpDesc->lpszApplicationName, (bAnsi ?
				strlen(lpDesc->lpszApplicationNameA) :
				WSTRLEN_BYTES(lpDesc->lpszApplicationName))))
			{
				DPF_ERR("Invalid lpszApplicationName string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}
		else
		{
			DPF_ERR("The lpszApplicationName member of the DPAPPLICTIONDESC structure is required");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the GUID (required)
		// We can really only check this against GUID_NULL since it will
		// always be a valid guid structure inside the APPDESC struct
		if(IsEqualGUID(&lpDesc->guidApplication, &GUID_NULL))
		{
			DPF_ERR("The guidApplication member of the DPAPPLICTIONDESC structure is required");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the Filename string (required)
		if(lpDesc->lpszFilename)
		{
			if(!VALID_READ_PTR(lpDesc->lpszFilename, (bAnsi ?
				strlen(lpDesc->lpszFilenameA) :
				WSTRLEN_BYTES(lpDesc->lpszFilename))))
			{
				DPF_ERR("Invalid lpszFilename string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}
		else
		{
			DPF_ERR("The lpszFilename member of the DPAPPLICTIONDESC structure is required");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the CommandLine string (optional)
		if(lpDesc->lpszCommandLine)
		{
			if(!VALID_READ_PTR(lpDesc->lpszCommandLine, (bAnsi ?
				strlen(lpDesc->lpszCommandLineA) :
				WSTRLEN_BYTES(lpDesc->lpszCommandLine))))
			{
				DPF_ERR("Invalid lpszCommandLine string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}

		// Validate the Path string (required)
		if(lpDesc->lpszPath)
		{
			if(!VALID_READ_PTR(lpDesc->lpszPath, (bAnsi ?
				strlen(lpDesc->lpszPathA) :
				WSTRLEN_BYTES(lpDesc->lpszPath))))
			{
				DPF_ERR("Invalid lpszPath string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}
		else
		{
			DPF_ERR("The lpszPath member of the DPAPPLICTIONDESC structure is required");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the CurrentDirectory string (optional)
		if(lpDesc->lpszCurrentDirectory)
		{
			if(!VALID_READ_PTR(lpDesc->lpszCurrentDirectory, (bAnsi ?
				strlen(lpDesc->lpszCurrentDirectoryA) :
				WSTRLEN_BYTES(lpDesc->lpszCurrentDirectory))))
			{
				DPF_ERR("Invalid lpszCurrentDirectory string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}

		// Validate the DescriptionA string (optional)
		if(lpDesc->lpszDescriptionA)
		{
			if(!VALID_READ_PTR(lpDesc->lpszDescriptionA,
				strlen(lpDesc->lpszDescriptionA)))
			{
				DPF_ERR("Invalid lpszDescriptionA string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}

		// Validate the DescriptionW string (optional)
		if(lpDesc->lpszDescriptionW)
		{
			if(!VALID_READ_PTR(lpDesc->lpszDescriptionW,
				WSTRLEN_BYTES(lpDesc->lpszDescriptionW)))
			{
				DPF_ERR("Invalid lpszDescriptionW string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}

		// if the DPAPPLICATIONDESC2 is being used, validate the launcher name if present
		if(LobbyDescVer==2)
		{
			// Validate AppLauncherName Name
			if(lpDesc2->lpszAppLauncherNameA){
				if(!VALID_READ_PTR(lpDesc2->lpszAppLauncherNameA, (bAnsi ?
					strlen(lpDesc2->lpszAppLauncherNameA) :
					WSTRLEN_BYTES(lpDesc2->lpszAppLauncherName))))
				{
					DPF_ERR("Invalid lpszAppLauncherName string in DPAPPLICATIONDESC2 structure");
					return DPERR_INVALIDPARAMS;
				}
			}	
		}
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	return DP_OK;

} // PRV_ValidateDPAPPLICATIONDESC



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ConvertDPAPPLICATIONDESCToUnicode"
HRESULT PRV_ConvertDPAPPLICATIONDESCToUnicode(LPDPAPPLICATIONDESC lpDescA,
					LPDPAPPLICATIONDESC * lplpDescW)
{
	#define lpDesc2A ((LPDPAPPLICATIONDESC2) lpDescA)
	#define lpDesc2W ((LPDPAPPLICATIONDESC2) lpDescW)

	LPDPAPPLICATIONDESC		lpDescW = NULL;
	LPWSTR					lpwszApplicationName = NULL;
	LPWSTR					lpwszFilename = NULL;
	LPWSTR					lpwszCommandLine = NULL;
	LPWSTR					lpwszPath = NULL;
	LPWSTR					lpwszCurrentDirectory = NULL;
	LPWSTR					lpwszAppLauncherName = NULL;
	HRESULT					hr;


	DPF(7, "Entering PRV_ValidateDPAPPLICATIONDESC");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpDescA, lplpDescW);

	ASSERT(lpDescA);
	ASSERT(lplpDescW);

	
	// Allocate memory for the DPAPPLICATIONDESC structure
	lpDescW = DPMEM_ALLOC(lpDescA->dwSize);
	if(!lpDescW)
	{
		DPF_ERR("Unable to allocate memory for temporary Unicode DPAPPLICATIONDESC struct");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
	}

	// Copy the structure itself
	memcpy(lpDescW, lpDescA, lpDescA->dwSize);

	// Convert the ApplicationName
	if(lpDescA->lpszApplicationNameA)
	{
		hr = GetWideStringFromAnsi(&lpwszApplicationName,
				lpDescA->lpszApplicationNameA);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert ApplicationName string to Unicode");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
		}
	}

	// Convert the Filename
	if(lpDescA->lpszFilenameA)
	{
		hr = GetWideStringFromAnsi(&lpwszFilename,
				lpDescA->lpszFilenameA);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert Filename string to Unicode");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
		}
	}

	// Convert the CommandLine
	if(lpDescA->lpszCommandLineA)
	{
		hr = GetWideStringFromAnsi(&lpwszCommandLine,
				lpDescA->lpszCommandLineA);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert CommandLine string to Unicode");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
		}
	}

	// Convert the Path
	if(lpDescA->lpszPathA)
	{
		hr = GetWideStringFromAnsi(&lpwszPath,
				lpDescA->lpszPathA);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert Path string to Unicode");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
		}
	}

	// Convert the CurrentDirectory
	if(lpDescA->lpszCurrentDirectoryA)
	{
		hr = GetWideStringFromAnsi(&lpwszCurrentDirectory,
				lpDescA->lpszCurrentDirectoryA);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert CurrentDirectory string to Unicode");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
		}
	}

	// Convert the AppLauncher string if presend on an APPLICATIONDESC2
	if(IS_DPLOBBY_APPLICATIONDESC2(lpDescA)){
		if(lpDesc2A->lpszAppLauncherNameA){
			hr = GetWideStringFromAnsi(&lpwszAppLauncherName,
					lpDesc2A->lpszAppLauncherNameA);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to convert CurrentDirectory string to Unicode");
				goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
			}
		} 
		lpDesc2W->lpszAppLauncherName=lpwszAppLauncherName;
	}

	// We won't convert the description strings because they will
	// get put in the registry as-is.

	// So now that we have all the strings, setup the structure
	lpDescW->lpszApplicationName = lpwszApplicationName;
	lpDescW->lpszFilename = lpwszFilename;
	lpDescW->lpszCommandLine = lpwszCommandLine;
	lpDescW->lpszPath = lpwszPath;
	lpDescW->lpszCurrentDirectory = lpwszCurrentDirectory;
	
	lpDescW->lpszDescriptionA = lpDescA->lpszDescriptionA;
	lpDescW->lpszDescriptionW = lpDescA->lpszDescriptionW;

	// Set the output pointer
	*lplpDescW = lpDescW;

	return DP_OK;

ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE:

	if(lpwszApplicationName)
		DPMEM_FREE(lpwszApplicationName);
	if(lpwszFilename)
		DPMEM_FREE(lpwszFilename);
	if(lpwszCommandLine)
		DPMEM_FREE(lpwszCommandLine);
	if(lpwszPath)
		DPMEM_FREE(lpwszPath);
	if(lpwszCurrentDirectory)
		DPMEM_FREE(lpwszCurrentDirectory);
	if(lpDescW)
		DPMEM_FREE(lpDescW);
	if(lpwszAppLauncherName){
		DPMEM_FREE(lpwszAppLauncherName);
	}

	return hr;

	#undef lpDesc2A
	#undef lpDesc2W 
	
} // PRV_ConvertDPAPPLICATIONDESCToUnicode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ConvertDPAPPLICATIONDESCToAnsi"
HRESULT PRV_ConvertDPAPPLICATIONDESCToAnsi(LPDPAPPLICATIONDESC lpDescW,
					LPDPAPPLICATIONDESC * lplpDescA)
{
	#define lpDesc2W ((LPDPAPPLICATIONDESC2)(lpDescW))
	#define lpDesc2A ((LPDPAPPLICATIONDESC2)(lpDescA))

	LPDPAPPLICATIONDESC		lpDescA = NULL;
	LPSTR					lpszApplicationName = NULL;
	LPSTR					lpszFilename = NULL;
	LPSTR					lpszCommandLine = NULL;
	LPSTR					lpszPath = NULL;
	LPSTR					lpszCurrentDirectory = NULL;
	LPSTR					lpszAppLauncherName=NULL;
	HRESULT					hr;

	DPF(7, "Entering PRV_ValidateDPAPPLICATIONDESC");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpDescW, lplpDescA);

	ASSERT(lpDescW);
	ASSERT(lplpDescA);

	// Allocate memory for the DPAPPLICATIONDESC structure
	lpDescA = DPMEM_ALLOC(lpDescW->dwSize);
	if(!lpDescA)
	{
		DPF_ERR("Unable to allocate memory for temporary Ansi DPAPPLICATIONDESC struct");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
	}

	// Copy the structure itself
	memcpy(lpDescA, lpDescW, lpDescW->dwSize);

	// Convert the ApplicationName
	if(lpDescW->lpszApplicationName)
	{
		hr = GetAnsiString(&lpszApplicationName, lpDescW->lpszApplicationName);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert ApplicationName string to Ansi");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
		}
	}

	// Convert the Filename
	if(lpDescW->lpszFilename)
	{
		hr = GetAnsiString(&lpszFilename, lpDescW->lpszFilename);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert Filename string to Ansi");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
		}
	}

	// Convert the CommandLine
	if(lpDescW->lpszCommandLine)
	{
		hr = GetAnsiString(&lpszCommandLine, lpDescW->lpszCommandLine);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert CommandLine string to Ansi");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
		}
	}

	// Convert the Path
	if(lpDescW->lpszPath)
	{
		hr = GetAnsiString(&lpszPath, lpDescW->lpszPath);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert Path string to Ansi");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
		}
	}

	// Convert the CurrentDirectory
	if(lpDescW->lpszCurrentDirectory)
	{
		hr = GetAnsiString(&lpszCurrentDirectory, lpDescW->lpszCurrentDirectory);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert CurrentDirectory string to Ansi");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
		}
	}

	// Convers the app launcher string if present.
	if(IS_DPLOBBY_APPLICATIONDESC2(lpDesc2W)){
		if(lpDesc2W->lpszAppLauncherName){
			hr = GetAnsiString(&lpszAppLauncherName, lpDesc2W->lpszAppLauncherName);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to convert AppLauncherName string to Ansi");
				goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
			}
		} 
		lpDesc2A->lpszAppLauncherNameA = lpszAppLauncherName;
	}	

	// We won't convert the description strings because they will
	// get put in the registry as-is.

	// So now that we have all the strings, setup the structure
	lpDescA->lpszApplicationNameA = lpszApplicationName;
	lpDescA->lpszFilenameA = lpszFilename;
	lpDescA->lpszCommandLineA = lpszCommandLine;
	lpDescA->lpszPathA = lpszPath;
	lpDescA->lpszCurrentDirectoryA = lpszCurrentDirectory;
	
	lpDescA->lpszDescriptionA = lpDescW->lpszDescriptionA;
	lpDescA->lpszDescriptionW = lpDescW->lpszDescriptionW;

	// Set the output pointer
	*lplpDescA = lpDescA;

	return DP_OK;

ERROR_CONVERT_DPAPPLICATIONDESC_ANSI:

	if(lpszApplicationName)
		DPMEM_FREE(lpszApplicationName);
	if(lpszFilename)
		DPMEM_FREE(lpszFilename);
	if(lpszCommandLine)
		DPMEM_FREE(lpszCommandLine);
	if(lpszPath)
		DPMEM_FREE(lpszPath);
	if(lpszCurrentDirectory)
		DPMEM_FREE(lpszCurrentDirectory);
	if(lpDescA)
		DPMEM_FREE(lpDescA);
	if(lpszAppLauncherName)
		DPMEM_FREE(lpszAppLauncherName);

	return hr;

	#undef lpDesc2A
	#undef lpDesc2W
} // PRV_ConvertDPAPPLICATIONDESCToAnsi



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeLocalDPAPPLICATIONDESC"
void PRV_FreeLocalDPAPPLICATIONDESC(LPDPAPPLICATIONDESC lpDesc)
{
	LPDPAPPLICATIONDESC2 lpDesc2 = (LPDPAPPLICATIONDESC2)lpDesc;
	DPF(7, "Entering PRV_ValidateDPAPPLICATIONDESC");
	DPF(9, "Parameters: 0x%08x", lpDesc);

	if(lpDesc)
	{
		if(lpDesc->lpszApplicationName)
			DPMEM_FREE(lpDesc->lpszApplicationName);
		if(lpDesc->lpszFilename)
			DPMEM_FREE(lpDesc->lpszFilename);
		if(lpDesc->lpszCommandLine)
			DPMEM_FREE(lpDesc->lpszCommandLine);
		if(lpDesc->lpszPath)
			DPMEM_FREE(lpDesc->lpszPath);
		if(lpDesc->lpszCurrentDirectory)
			DPMEM_FREE(lpDesc->lpszCurrentDirectory);
		if(IS_DPLOBBY_APPLICATIONDESC2(lpDesc) && lpDesc2->lpszAppLauncherName)
			DPMEM_FREE(lpDesc2->lpszAppLauncherName);

		// Note: We don't need to free the Description strings because they
		// were never allocated in either of the above routines, the pointers
		// were just copied.

		DPMEM_FREE(lpDesc);
	}

} // PRV_FreeLocalDPAPPLICATIONDESC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\dplsp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplsp.c
 *  Content:	DirectPlayLobby Service Provider interface code
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	10/23/96	myronth	Created it
 *	11/20/96	myronth Added DPLAPI to function declarations
 *	2/12/97		myronth	Mass DX5 changes
 *	2/18/97		myronth	Implemented GetObjectCaps
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/31/97		myronth	Implemented all IDPLobbySP methods without putting
 *						player management message in the message queue.
 *						Removed dead code
 *	4/4/97		myronth	Changed IDPLobbySP methods' structure names and
 *						implemented system messages for all of them
 *  4/27/97     sohailm Updated calls to HandlePlayerMessage to reflect new params
 *	5/8/97		myronth	All remote subgroup functions for IDPLobbySP
 *						including StartSession, Purged dead code
 *	5/12/97		myronth	Extra semi-colon bug fixes, Fixed group player count
 *						decrement that was in the wrong place
 *	5/14/97		myronth	Allow CreateGroup message to pass even if the
 *						Group ID is in the map table (bug #8354).
 *	5/17/97		myronth	Fixed HandleMessage, Added SendChatMessage
 *	5/17/97		myronth	Filtered some message to certain groups, Fixed calls
 *						to CreateAndMapNewGroup which needed a parent ID
 *	5/20/97		myronth	Changed DPLP_DeleteRemotePlayerFromGroup to use
 *						InternalDeletePlayerFromGroup instead of
 *						RemovedPlayerFromGroup (now includes system player)
 *						(Bug #8586)
 *	5/21/97		myronth	Fixed the player name for players joining a session
 *						(#8798), Changed to new DPMSG_CHAT format (#8642)
 *	5/22/97		myronth	Fixed flag propagation in DPLP_CreateGroup (#8813)
 *	5/23/97		myronth	Send messages locally for CreateGroup and
 *						CreateGroupInGroup (#8870)
 *	6/3/97		myronth	Added support for player flags in AddPlayerToGroup
 *						(#9091) and added PRV_RemoveSubgroupsAndPlayers-
 *						FromGroup function (#9134)
 *	6/5/97		myronth	Fixed AddGroupToGroup & DeleteGroupFromGroup by
 *						adding heirarchy creating & deletion. (#8731)
 *	6/6/97		myronth	Moved code from PRV_DeleteRemoteGroupFromGroup to
 *						PRV_DestroyGroupAndParents in group.c, Changed all
 *						DistributeGroupMessage calls to go to all players
 *	6/16/97		myronth	Fixed call to InternalAddGroupToGroup (#9745) and
 *						fixed Delete messages for shortcuts on DestroyGroup
 *						(#9739)
 *	6/20/97		myronth	Changed AddGroupToGroup to check if a group exists
 *						and not send a duplicate message (#10139)
 *	6/24/97		myronth	Changed AddPlayerToGroup to check if a player exists
 *						and not send a duplicate message (#10287)
 *	7/30/97		myronth	Added support for standard lobby messaging
 *	8/11/97		myronth	Added guidInstance handling in standard lobby requests
 *	8/19/97		myronth	Removed bogus assert
 *	9/29/97		myronth	Ignore SetPlayerName/Data msgs for local players (#12554)
 *	10/3/97		myronth	Fixed player & group data for remote players/groups (#10961)
 *	10/7/97		myronth	Fixed LP version checking for player & group data (regresssion)
 *	10/8/97		myronth	Rolled back fix for #10961 (group & player data)
 *	10/23/97	myronth	Added hidden group support (#12688), fixed crashing
 *						bug on DeletePlayerFromGroup (#12885)
 *	10/29/97	myronth	Added support for group owners, including DPLP_SetGroupOwner
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/6/97		myronth	Made SendChatMessage handle a dwFromID of
 *						DPID_SERVERPLAYER (#12843)
 *	11/19/97	myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 *	 2/13/98	aarono	changed InternalDeletePlayer, added flag.
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendBuildParentalHeirarchyMessage"
void PRV_SendBuildParentalHeirarchyMessage(LPDPLOBBYI_DPLOBJECT this,
				DWORD dwGroupID, DWORD dwParentID)
{
	SPDATA_BUILDPARENTALHEIRARCHY	bph;
	HRESULT							hr;


	DPF(7, "Entering PRV_SendBuildParentalHeirarchyMessage");
	DPF(9, "Parameters: 0x%08x, %lu, %lu", this, dwGroupID, dwParentID);

	// Setup the SPDATA structure
	memset(&bph, 0, sizeof(SPDATA_BUILDPARENTALHEIRARCHY));
	bph.dwSize = sizeof(SPDATA_BUILDPARENTALHEIRARCHY);
	bph.lpISP = PRV_GetDPLobbySPInterface(this);
	bph.dwGroupID = dwGroupID;
	bph.dwMessage = DPSYS_ADDGROUPTOGROUP;
	bph.dwParentID = dwParentID;

	// Call the BuildParentalHeirarchy method in the SP
	if(CALLBACK_EXISTS(BuildParentalHeirarchy))
	{
		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, BuildParentalHeirarchy, &bph);
		ENTER_DPLOBBY();
	}
	else 
	{
		// BuildParentalHeirarchy is required
		DPF_ERR("The Lobby Provider callback for BuildParentalHeirarchy doesn't exist -- it's required");
		ASSERT(FALSE);
	}

} // PRV_SendBuildParentalHeirarchyMessage



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_AddGroupToGroup"
HRESULT DPLAPI DPLP_AddGroupToGroup(LPDPLOBBYSP lpILP,
				LPSPDATA_ADDREMOTEGROUPTOGROUP lpd)
{
	SPDATA_CREATEREMOTEGROUPINGROUP		cgig;
	SPDATA_DESTROYREMOTEGROUP			dg;
	SPDATA_CREATEREMOTEGROUP			cg;
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	LPDPLAYI_GROUP			lpAnchor = NULL;
	LPDPLAYI_SUBGROUP		lpSubgroup = NULL;
	MSG_PLAYERMGMTMESSAGE	msg;
	BOOL					bCreated = FALSE;


	DPF(7, "Entering DPLP_AddGroupToGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_ADDREMOTEGROUPTOGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLOBBY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwAnchorID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved AddGroupToGroup message for unknown anchor group, dwGroupID = %lu, discarding message", lpd->dwAnchorID);
		return DPERR_INVALIDGROUP;
	}

	// Now see if the group is in our map table.  If it is, we
	// probably want to update the name.  If it's not, we need to
	// add them to the nametable and the map table
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		// See if the group is a root group (remember hidden groups won't
		// get pushed down to us).  If it is, then just create it.
		if(!(lpd->dwParentID))
		{
			// Setup the SPDATA struct for CreateRemoteGroup
			memset(&cg, 0, sizeof(SPDATA_CREATEREMOTEGROUP));
			cg.dwSize = sizeof(SPDATA_CREATEREMOTEGROUP);
			cg.dwGroupID = lpd->dwGroupID;
			cg.lpName = lpd->lpName;
			cg.dwFlags = lpd->dwGroupFlags;

			if(this->dwLPVersion > DPLSP_DX5VERSION)
				cg.dwGroupOwnerID = lpd->dwGroupOwnerID;
			else
				cg.dwGroupOwnerID = DPID_SERVERPLAYER;

			// Call our internal remote create
			hr = DPLP_CreateGroup((LPDPLOBBYSP)this->lpInterfaces, &cg);
			if(FAILED(hr))
			{
				LEAVE_DPLOBBY();
				DPF_ERRVAL("Failed creating remote parent group, hr = 0x%08x", hr);
				return hr;
			}

			bCreated = TRUE;
		}
		else
		{
			// See if it's parent shows up in the map table, if it doesn't,
			// we need to send a message to the server to tell it to build
			// the entire tree for us
			if(!IsLobbyIDInMapTable(this, lpd->dwParentID))
			{
				DPF(8, "Sending message to server to build parental heirarchy, ignoring AddGroupToGroup message");
				PRV_SendBuildParentalHeirarchyMessage(this, lpd->dwGroupID,
						lpd->dwAnchorID);
				LEAVE_DPLOBBY();
				return DPERR_INVALIDGROUP;
			}

			// Setup the SPDATA struct for CreateRemoteGroupInGroup
			memset(&cgig, 0, sizeof(SPDATA_CREATEREMOTEGROUPINGROUP));
			cgig.dwSize = sizeof(SPDATA_CREATEREMOTEGROUPINGROUP);
			cgig.dwParentID = lpd->dwParentID;
			cgig.dwGroupID = lpd->dwGroupID;
			cgig.lpName = lpd->lpName;
			cgig.dwFlags = lpd->dwGroupFlags;

			if(this->dwLPVersion > DPLSP_DX5VERSION)
				cgig.dwGroupOwnerID = lpd->dwGroupOwnerID;
			else
				cgig.dwGroupOwnerID = DPID_SERVERPLAYER;

			// Call our internal remote create
			hr = DPLP_CreateGroupInGroup((LPDPLOBBYSP)this->lpInterfaces, &cgig);
			if(FAILED(hr))
			{
				LEAVE_DPLOBBY();
				DPF_ERRVAL("Failed creating remote group in group, hr = 0x%08x", hr);
				return hr;
			}

			bCreated = TRUE;
		}
	}

	// Take the dplay lock
	ENTER_DPLAY();

	// Make sure the group isn't already in the parent group.  If it is,
	// we just want to return DP_OK and exit so that we don't send any
	// duplicate messages.
	lpAnchor = GroupFromID(this->lpDPlayObject, lpd->dwAnchorID);
	if(!lpAnchor)
	{
		DPF_ERR("Unable to find group in nametable");
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_ADDGROUPTOGROUP;
	}
	
	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if(!lpGroup)
	{
		DPF_ERR("Unable to find group in nametable");
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_ADDGROUPTOGROUP;
	}
	
	lpSubgroup = lpAnchor->pSubgroups;
    while(lpSubgroup) 
    {
        if (lpSubgroup->pGroup == lpGroup) 
        {
			DPF(2,"Group already in group!");
			hr = DP_OK;
			goto ERROR_DPLP_ADDGROUPTOGROUP;
        }
		// check next node
        lpSubgroup = lpSubgroup->pNextSubgroup;
    }

	// So now we should have a valid group and valid player in both
	// the map table and the nametable, so call dplay's AGtoG function
	hr = InternalAddGroupToGroup((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
				lpd->dwAnchorID, lpd->dwGroupID, DPGROUP_SHORTCUT, FALSE);
	if(FAILED(hr))
	{
		// If we created the player and mapped it, then destroy the
		// player and unmap it.
		if(bCreated)
		{
			// Setup the SPDATA struct for DestroyRemoteGroup
			memset(&dg, 0, sizeof(SPDATA_DESTROYREMOTEGROUP));
			dg.dwSize = sizeof(SPDATA_DESTROYREMOTEGROUP);
			dg.dwGroupID = lpd->dwGroupID;

			// Call our internal remote create
			hr = DPLP_DestroyGroup((LPDPLOBBYSP)this->lpInterfaces, &dg);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed destroying remote group, hr = 0x%08x", hr);
				goto ERROR_DPLP_ADDGROUPTOGROUP;
			}
		}

		// If we failed, don't send the system message
		DPF_ERRVAL("Failed adding remote group to group from the lobby, hr = 0x%08x", hr);
		goto ERROR_DPLP_ADDGROUPTOGROUP;
	}


	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERR("Unable to find group in nametable");
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_ADDGROUPTOGROUP;
	}

	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_ADDSHORTCUTTOGROUP);
	msg.dwPlayerID = lpd->dwGroupID;
	msg.dwGroupID = lpd->dwAnchorID;

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding AddGroupToGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}


ERROR_DPLP_ADDGROUPTOGROUP:

	// Drop the lock
	LEAVE_LOBBY_ALL();
	return hr;

} // DPLP_AddGroupToGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_AddPlayerToGroup"
HRESULT DPLAPI DPLP_AddPlayerToGroup(LPDPLOBBYSP lpILP,
				LPSPDATA_ADDREMOTEPLAYERTOGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	DPID					dpidPlayer;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	LPDPLAYI_GROUPNODE		lpGroupnode = NULL;
	MSG_PLAYERMGMTMESSAGE	msg, cpmsg;
	BOOL					bCreated = FALSE;
	DWORD					dwPlayerFlags = 0;


	DPF(7, "Entering DPLP_AddPlayerToGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_ADDREMOTEPLAYERTOGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLOBBY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved AddPlayerToGroup message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// Fix up the player flags
	if(lpd->dwPlayerFlags & DPPLAYER_SPECTATOR)
		dwPlayerFlags |= DPLAYI_PLAYER_SPECTATOR;
	if(lpd->dwPlayerFlags & DPPLAYER_SERVERPLAYER)
		dwPlayerFlags |= DPLAYI_PLAYER_APPSERVER;

	// Take the dplay lock
	ENTER_DPLAY();

	// Now see if the player is in our map table.  If it is, we
	// probably want to update the name.  If it's not, we need to
	// add them to the nametable and the map table
	if(!IsLobbyIDInMapTable(this, lpd->dwPlayerID))
	{
		// It doesn't show up in our map table, so create a new
		// nametable entry for them and put them in our map table.
		hr = PRV_CreateAndMapNewPlayer(this, &dpidPlayer, lpd->lpName,
				NULL, NULL, 0, dwPlayerFlags,
				lpd->dwPlayerID, FALSE);
		if(FAILED(hr))
		{
			DPF(8, "Unable to add player to nametable or map table, hr = 0x%08x", hr);
			goto ERROR_DPLP_ADDPLAYER;
		}

		bCreated = TRUE;
	}

	// Make sure the player isn't already in the group.  If it is,
	// we just want to return DP_OK and exit so that we don't send any
	// duplicate messages.
	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if(!lpGroup)
	{
		DPF_ERR("Unable to find group in nametable");
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_ADDPLAYER;
	}
	
	lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwPlayerID);
	if(!lpPlayer)
	{
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDPLAYER;
		goto ERROR_DPLP_ADDPLAYER;
	}
	
	lpGroupnode = lpGroup->pGroupnodes;
    while(lpGroupnode) 
    {
        if(lpGroupnode->pPlayer == lpPlayer) 
        {
			DPF(2, "Player already in group!");
			hr = DP_OK;
			goto ERROR_DPLP_ADDPLAYER;
        }

		// check next node
        lpGroupnode = lpGroupnode->pNextGroupnode;
    }

	// So now we should have a valid group and valid player in both
	// the map table and the nametable, so call dplay with the add message
	hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
				lpd->dwGroupID, lpd->dwPlayerID, FALSE);
	if(FAILED(hr))
	{
		// If we created the player and mapped it, then destroy the
		// player and unmap it.
		if(bCreated)
		{
			// Remove the player from the nametable
			InternalDestroyPlayer(this->lpDPlayObject, lpPlayer, FALSE, FALSE);
		}

		// If we failed, don't send the system message
		DPF_ERRVAL("Failed adding remote player to group from the lobby, hr = 0x%08x", hr);
		goto ERROR_DPLP_ADDPLAYER;
	}

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_ADDPLAYER;
	}

	// If we created this player, we need to send a CreatePlayer message ahead
	// of the AddPlayerToGroup message
	if(bCreated)
	{
		// Now build the system message (at least the parts we need)
		memset(&cpmsg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&cpmsg);
		SET_MESSAGE_COMMAND(&cpmsg, DPSP_MSG_CREATEPLAYER);
		cpmsg.dwPlayerID = lpd->dwPlayerID;

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&cpmsg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding CreatePlayer message to player's receive queue from lobby, hr = 0x%08x", hr);
		}
	}

	// Now build the system message for AddPlayerToGroup
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_ADDPLAYERTOGROUP);
	msg.dwPlayerID = lpd->dwPlayerID;
	msg.dwGroupID = lpd->dwGroupID;

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding AddPlayerToGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

	// We need to see if this player is the group owner.  If it is,
	// we need to send a SetGroupOwner message as well.
	if(lpd->dwPlayerID == lpGroup->dwOwnerID)
	{
		// Now send the message
		PRV_SendGroupOwnerMessageLocally(this, lpd->dwGroupID,
				lpd->dwPlayerID, 0);
	}

ERROR_DPLP_ADDPLAYER:

	// Drop the lock
	LEAVE_LOBBY_ALL();
	return hr;

} // DPLP_AddPlayerToGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_CreateGroup"
HRESULT DPLAPI DPLP_CreateGroup(LPDPLOBBYSP lpILP,
						LPSPDATA_CREATEREMOTEGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	MSG_PLAYERMGMTMESSAGE	msg;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	HRESULT					hr = DP_OK;
	DPID					dpidGroup;
	DWORD					dwInternalFlags = 0;
	DWORD					dwOwnerID;


	DPF(7, "Entering DPLP_CreateGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_CREATEREMOTEGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Fix the flags from external to internal
	if(lpd->dwFlags & DPGROUP_STAGINGAREA)
		dwInternalFlags = DPLAYI_GROUP_STAGINGAREA;
	if(lpd->dwFlags & DPGROUP_HIDDEN)
		dwInternalFlags |= DPLAYI_GROUP_HIDDEN;

	// Take the lock
	ENTER_DPLAY();

	// First see if the group is in our map table.  If it is,
	// we just want to return.  If it's not, we want to add
	// them and send the appropriate message
	if(IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		DPF(2, "Received a CreateGroup message for a group we already know about");
		hr = DP_OK;
		goto ERROR_DPLP_CREATEGROUP;
	}
	else
	{
		// Make the owner default to the server player if we have a problem
		dwOwnerID = DPID_SERVERPLAYER;

		// If we are talking to at least a DX6 lobby provider, we should
		// be able to use the GroupOwnerID element
		if(this->dwLPVersion > DPLSP_DX5VERSION)
			dwOwnerID = lpd->dwGroupOwnerID;
		
		// Create a new entry in the nametable and map the ID's
		hr = PRV_CreateAndMapNewGroup(this, &dpidGroup, lpd->lpName,
				lpd->lpData, lpd->dwDataSize, dwInternalFlags,
				lpd->dwGroupID, 0, dwOwnerID);
		if(FAILED(hr))
		{
			// If we fail, we don't want to send the system message
			DPF_ERRVAL("Unable to add group to nametable or map table, hr = 0x%08x", hr);
			goto ERROR_DPLP_CREATEGROUP;
		}
	}

	// Now build the system message (at least the parts we need
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_CREATEGROUP);
	msg.dwPlayerID = lpd->dwGroupID;

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_CREATEGROUP;
	}

	// Call dplay's DistributeGroupMessage function to put the message in
	// the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo, (LPBYTE)&msg,
			sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding CreateGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

ERROR_DPLP_CREATEGROUP:

	// Drop the lock
	LEAVE_LOBBY_ALL();
	return hr;

} // DPLP_CreateGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_CreateGroupInGroup"
HRESULT DPLAPI DPLP_CreateGroupInGroup(LPDPLOBBYSP lpILP,
					LPSPDATA_CREATEREMOTEGROUPINGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	DPID					dpidGroup;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	MSG_PLAYERMGMTMESSAGE	msg;
	BOOL					bCreated = FALSE;
	DWORD					dwInternalFlags = 0;
	DWORD					dwOwnerID;


	DPF(7, "Entering DPLP_CreateGroupInGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_CREATEREMOTEGROUPINGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLOBBY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwParentID))
	{
		LEAVE_DPLOBBY();
		DPF_ERRVAL("Recieved CreateGroupInGroup message for unknown parent group, dwGroupID = %lu, discarding message", lpd->dwParentID);
		return DPERR_INVALIDGROUP;
	}

	// Take the dplay lock
	ENTER_DPLAY();

	// First see if the group is in our map table.  If it is,
	// we just want to return.  If it's not, we want to add
	// them and send the appropriate message
	if(IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		DPF(2, "Received a CreateGroupInGroup message for a group we already know about");
		hr = DP_OK;
		goto ERROR_DPLP_CREATEGROUPINGROUP;
	}
	else
	{
		// Setup the internal flags
		if(lpd->dwFlags & DPGROUP_STAGINGAREA)
			dwInternalFlags = DPLAYI_GROUP_STAGINGAREA;
		if(lpd->dwFlags & DPGROUP_HIDDEN)
			dwInternalFlags |= DPLAYI_GROUP_HIDDEN;
		
		// Make the owner default to the server player if we have a problem
		dwOwnerID = DPID_SERVERPLAYER;

		// If we are talking to at least a DX6 lobby provider, we should
		// be able to use the GroupOwnerID element
		if(this->dwLPVersion > DPLSP_DX5VERSION)
			dwOwnerID = lpd->dwGroupOwnerID;
		
		// It doesn't show up in our map table, so create a new
		// nametable entry for them and put them in our map table.
		hr = PRV_CreateAndMapNewGroup(this, &dpidGroup, lpd->lpName,
				NULL, 0, dwInternalFlags,
				lpd->dwGroupID, lpd->dwParentID, dwOwnerID);
		if(FAILED(hr))
		{
			DPF(8, "Unable to add group to nametable or map table, hr = 0x%08x", hr);
			goto ERROR_DPLP_CREATEGROUPINGROUP;
		}

		bCreated = TRUE;
	}

	// So now we should have a valid group and valid player in both
	// the map table and the nametable, so call dplay with the add message
	hr = InternalAddGroupToGroup((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
				lpd->dwParentID, lpd->dwGroupID, lpd->dwFlags, FALSE);
	if(FAILED(hr))
	{
		// If we created the player and mapped it, then destroy the
		// player and unmap it.
		if(bCreated)
		{
			// Get a pointer to dplay's group struct
			lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);

			// Remove the group from the nametable
			InternalDestroyGroup(this->lpDPlayObject, lpGroup, FALSE);
		}

		// If we failed, don't send the system message
		DPF_ERRVAL("Failed creating remote group in group from the lobby, hr = 0x%08x", hr);
		goto ERROR_DPLP_CREATEGROUPINGROUP;
	}


	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_CREATEGROUP);
	msg.dwPlayerID = lpd->dwGroupID;

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_CREATEGROUPINGROUP;
	}

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding CreateGroupInGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}


ERROR_DPLP_CREATEGROUPINGROUP:

	// Drop the lock
	LEAVE_LOBBY_ALL();
	return hr;

} // DPLP_CreateGroupInGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteRemoteGroupFromGroup"
HRESULT PRV_DeleteRemoteGroupFromGroup(LPDPLOBBYI_DPLOBJECT this,
			LPSPDATA_DELETEREMOTEGROUPFROMGROUP lpd, BOOL fPropagate,
			LPDPLAYI_GROUP lpStopParent)
{
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL, lpParentGroup = NULL;
	MSG_PLAYERMGMTMESSAGE	msg;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_DeleteRemoteGroupFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			this, lpd, fPropagate, lpStopParent);


	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwParentID))
	{
		DPF(8, "Recieved DeleteGroupFromGroup message for unknown parent group, dwGroupID = %lu, discarding message", lpd->dwParentID);
		return DPERR_INVALIDGROUP;
	}

	// Now make sure the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we don't know about.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		DPF(8, "Recieved DeleteGroupFromGroup message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// Take the lock
	ENTER_DPLAY();

	// Get dplay's internal group structures
	lpParentGroup = GroupFromID(this->lpDPlayObject, lpd->dwParentID);
	if(!lpParentGroup)
	{
		LEAVE_DPLAY();
		DPF(8, "Unable to find parent group in nametable");
		return DPERR_INVALIDGROUP;
	}

	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if(!lpGroup)
	{
		LEAVE_DPLAY();
		DPF(8, "Unable to find group in nametable");
		return DPERR_INVALIDGROUP;
	}

	// Call dplay's internal removegroupfromgroup to remove the attachment
	// in the nametable
	hr = RemoveGroupFromGroup(lpParentGroup, lpGroup);
	if(FAILED(hr))
	{
		DPF(8, "Failed removing group from group, hr = 0x%08x", hr);
		goto EXIT_DPLP_DELETEREMOTEGROUPFROMGROUP;
	}

	// If the fPropagate flag is not set, we don't want to send this message
	if(fPropagate)
	{
		// Now build the system message (at least the parts we need)
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEGROUPFROMGROUP);
		msg.dwPlayerID = lpd->dwGroupID;
		msg.dwGroupID = lpd->dwParentID;

		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			DPF(8, "Unable to find system group in nametable");
			goto EXIT_DPLP_DELETEREMOTEGROUPFROMGROUP;
		}

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding DeleteGroupFromGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}
	}

	// Even if we couldn't send the message above, destroy the group anyway

EXIT_DPLP_DELETEREMOTEGROUPFROMGROUP:

	// Destroy the group and any of it's parents if there are no more local
	// references to it or any of it's heirarchy
	PRV_DestroyGroupAndParents(this, lpGroup, lpStopParent);

	// Drop the lock
	LEAVE_DPLAY();

	return hr;

} // PRV_DeleteRemoteGroupFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_DeleteGroupFromGroup"
HRESULT DPLAPI DPLP_DeleteGroupFromGroup(LPDPLOBBYSP lpILP,
					LPSPDATA_DELETEREMOTEGROUPFROMGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPLP_DeleteGroupFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_DELETEREMOTEGROUPFROMGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Call our internal routine, setting the propagate flag to TRUE so that
	// we post the appropriate message in the player's receive queue
	hr = PRV_DeleteRemoteGroupFromGroup(this, lpd, TRUE, NULL);

	LEAVE_DPLOBBY();
	return hr;

} // DPLP_DeleteGroupFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteRemotePlayerFromGroup"
HRESULT PRV_DeleteRemotePlayerFromGroup(LPDPLOBBYI_DPLOBJECT this,
			LPSPDATA_DELETEREMOTEPLAYERFROMGROUP lpd, BOOL fPropagate)
{
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	MSG_PLAYERMGMTMESSAGE	msg, dpmsg;
	HRESULT					hr;


	DPF(7, "Entering PRV_DeleteRemotePlayerFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu", this, lpd, fPropagate);


	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		DPF(8, "Recieved DeletePlayerFromGroup message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// Now make sure the player is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// player we don't know about.
	if(!IsLobbyIDInMapTable(this, lpd->dwPlayerID))
	{
		DPF(8, "Recieved DeletePlayerFromGroup message for unknown player, dwPlayerID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDPLAYER;
	}

	// Take the lock
	ENTER_DPLAY();

	// Call dplay's internal removeplayerfromgroup to remove the attachment
	// in the nametable
	hr = InternalDeletePlayerFromGroup((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
			lpd->dwGroupID, lpd->dwPlayerID, FALSE);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed removing player from group, hr = 0x%08x", hr);
		goto ERROR_DPLP_DELETEPLAYERFROMGROUP;
	}

	// If the fPropagate flag is not set, we don't want to send this message
	if(fPropagate)
	{
		// Now build the system message (at least the parts we need)
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEPLAYERFROMGROUP);
		msg.dwPlayerID = lpd->dwPlayerID;
		msg.dwGroupID = lpd->dwGroupID;

		// Find dplay's internal group struct for the To group
		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
			hr = DPERR_INVALIDGROUP;
			goto ERROR_DPLP_DELETEPLAYERFROMGROUP;
		}

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding DeletePlayerFromGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}
	}

	// Get dplay's internal group & player structures
	lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwPlayerID);
	if(!lpPlayer)
	{
		// So if this fails, the above call to InternalDeletePlayerFromGroup
		// shouldn't have succeeded either
		DPF_ERR("Unable to find player in nametable");
		ASSERT(FALSE);
		goto ERROR_DPLP_DELETEPLAYERFROMGROUP;
	}

	// Now we need to decide if this is the last group this player was in.  If
	// it is, then we need to destroy the player as well, and remove them from
	// our map table.  Of course, only destroy the player if it is a remote player.
	if((!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)) &&
		(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP)))
	{
		// However, before we do this, we need to send a DestroyPlayer
		// message to all the people who got the DeletePlayerFromGroup
		if(lpGroupTo && fPropagate)
		{
			// Now build the system message (at least the parts we need)
			memset(&dpmsg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
			SET_MESSAGE_HDR(&dpmsg);
			SET_MESSAGE_COMMAND(&dpmsg, DPSP_MSG_DELETEPLAYER);
			dpmsg.dwPlayerID = lpd->dwPlayerID;

			// Call dplay's DistributeGroupMessage function to put the message
			// in the queues of all the appropriate players
			DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
					(LPBYTE)&dpmsg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
			if(FAILED(hr))
			{
				DPF(8, "Failed adding DestroyPlayer message to player's receive queue from lobby, hr = 0x%08x", hr);
			}
		}

		// Destroy the player and remove it from the nametable
		InternalDestroyPlayer(this->lpDPlayObject, lpPlayer, FALSE, FALSE);
	}


ERROR_DPLP_DELETEPLAYERFROMGROUP:

	// Drop the lock
	LEAVE_DPLAY();

	return hr;

} // PRV_DeleteRemotePlayerFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_DeletePlayerFromGroup"
HRESULT DPLAPI DPLP_DeletePlayerFromGroup(LPDPLOBBYSP lpILP,
						LPSPDATA_DELETEREMOTEPLAYERFROMGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPLP_DeletePlayerFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_DELETEREMOTEPLAYERFROMGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Call our internal routine, setting the propagate flag to TRUE so that
	// we post the appropriate message in the player's receive queue
	hr = PRV_DeleteRemotePlayerFromGroup(this, lpd, TRUE);

	LEAVE_DPLOBBY();
	return hr;

} // DPLP_DeletePlayerFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_BroadcastDestroyGroupMessage"
HRESULT DPLAPI PRV_BroadcastDestroyGroupMessage(LPDPLOBBYI_DPLOBJECT this,
					DWORD dwGroupID)
{
	MSG_PLAYERMGMTMESSAGE	msg;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	HRESULT					hr;


	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEGROUP);
	msg.dwGroupID = dwGroupID;

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERR("Unable to find system group in nametable");
		hr = DPERR_INVALIDGROUP;
	}
	else
	{
		// Call dplay's DistributeGroupMessage function to put the message in the queue
		hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding DestroyGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}
	}

	return hr;

} // PRV_BroadcastDestroyGroupMessage



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_RemoveSubgroupsAndPlayersFromGroup"
void PRV_RemoveSubgroupsAndPlayersFromGroup(LPDPLOBBYI_DPLOBJECT this,
		LPDPLAYI_GROUP lpGroup, DWORD dwGroupID, BOOL bRemoteOnly)
{
	SPDATA_DELETEREMOTEPLAYERFROMGROUP	dpd;
	LPDPLAYI_GROUPNODE					lpGroupnode = NULL;
	LPDPLAYI_GROUPNODE					lpNextGroupnode = NULL;
	HRESULT								hr = DP_OK;


	DPF(7, "Entering PRV_RemoveSubgroupsAndPlayersFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpGroup);

	ASSERT(lpGroup);

	// Destroy any subgroups hanging off of this group
	PRV_DestroySubgroups(this, lpGroup, bRemoteOnly);

	// Walk the list of nodes, removing each player from the group manually.
	// The reason for doing this manually is so that the lobby gets a chance
	// to remove every remote player out of the nametable whose only existence
	// was inside this room.  It also allows the lobby to remove the player's
	// ID from the map table.  Do this by calling the lobby's
	// DPLP_DeletePlayerFromGroup function which responds to that message.

	// Setup the DeletePlayerFromGroup data structure
	memset(&dpd, 0, sizeof(SPDATA_DELETEREMOTEPLAYERFROMGROUP));
	dpd.dwSize = sizeof(SPDATA_DELETEREMOTEPLAYERFROMGROUP);
	dpd.dwGroupID = dwGroupID;

	// Walk the list of groupnodes, deleting all of the remote players
	lpGroupnode = lpGroup->pGroupnodes;
	while(lpGroupnode)
	{
		// Save the next groupnode
		lpNextGroupnode = lpGroupnode->pNextGroupnode;
		
		// If the player is local, skip them
		if(lpGroupnode->pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
		{
			lpGroupnode = lpNextGroupnode;
			continue;
		}

		// Get the lobby ID for the player
		dpd.dwPlayerID = lpGroup->pGroupnodes->pPlayer->dwID;

		// Now call the lobby's delete function, setting the fPropagate flag
		// to true so we put a delete message in the player's queue
		hr = PRV_DeleteRemotePlayerFromGroup(this, &dpd, TRUE);
		if(FAILED(hr))
		{
			// Same here, if this fails, something is tragically wrong
			// with the map table, so just continue;
			ASSERT(FALSE);
			break;
		}

		// Move to the next node
		lpGroupnode = lpNextGroupnode;
	}

} // PRV_RemoveSubgroupsAndPlayersFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendDeleteShortcutMessageForExitingGroup"
void PRV_SendDeleteShortcutMessageForExitingGroup(LPDPLOBBYI_DPLOBJECT this,
			LPDPLAYI_GROUP lpGroup)
{
	MSG_PLAYERMGMTMESSAGE	msg;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	LPDPLAYI_GROUP			lpGroupTemp = NULL;
	LPDPLAYI_SUBGROUP		lpSubgroupTemp = NULL;
	UINT					nGroupsIn;
	HRESULT					hr;


	DPF(7, "Entering PRV_SendDeleteShortcutMessageForExitingGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpGroup);

	// Take the dplay lock since we will be walking dplay's group list
	ENTER_DPLAY();

	// Get the number of subgroups this group is in
	nGroupsIn = lpGroup->nGroups;

	// Setup the static parts of the message, and get a pointer to the system group
	if(nGroupsIn)
	{
		// Build the message struct
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEGROUPFROMGROUP);
		msg.dwPlayerID = lpGroup->dwID;

		// Get a pointer to the system group
		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			LEAVE_DPLAY();
			DPF_ERR("Unable to get a pointer to the system group - not sending deletegroupfromgroup messages");
			return;
		}
	}

	// Walk the list of groups, and send a DeleteGroupFromGroup message
	// for each shortcut
	lpGroupTemp = this->lpDPlayObject->pGroups;
	while(nGroupsIn && lpGroupTemp)
	{
		// Walk the list of subgroups for the group
		lpSubgroupTemp = lpGroupTemp->pSubgroups;
		while(nGroupsIn && lpSubgroupTemp)
		{
			// If the group is our group, send a message, but only if
			// it is not the parent group (since we will never do a
			// DeleteGroupFromGroup on a parent-child)
			if(lpSubgroupTemp->pGroup == lpGroup)
			{
				// Make sure it's not the group's parent
				if(lpGroup->dwIDParent != lpGroupTemp->dwID)
				{
					// Send the message
					msg.dwGroupID = lpGroupTemp->dwID;

					// Call dplay's DistributeGroupMessage function to put the message
					// in the queues of all the appropriate players
					hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
							(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
					if(FAILED(hr))
					{
						DPF(8, "Failed adding DeleteGroupFromGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
					}
				}

				// Decrement the count of subgroups
				nGroupsIn--;
			}
			
			// Move to the next subgroup
			lpSubgroupTemp = lpSubgroupTemp->pNextSubgroup;
		}

		// Move to the next group
		lpGroupTemp = lpGroupTemp->pNextGroup;
	}

	ASSERT(!nGroupsIn);

	// Drop the dplay lock since we're done
	LEAVE_DPLAY();

} // PRV_SendDeleteShortcutMessageForExitingGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_DestroyGroup"
HRESULT DPLAPI DPLP_DestroyGroup(LPDPLOBBYSP lpILP,
					LPSPDATA_DESTROYREMOTEGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT				this;
	HRESULT								hr = DP_OK;
	LPDPLAYI_GROUP						lpGroup = NULL;
	LPDPLAYI_GROUPNODE					lpGroupNode = NULL;


	DPF(7, "Entering DPLP_DestroyGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_DESTROYGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved DestroyGroup message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// This is either a group we are in, or it is a root group.  If it has
	// any players, it's a group we are in, so we need to delete all remote
	// players from the nametable and map table (if this is the only group
	// they are in).

	// Take the lock
	ENTER_DPLAY();

	// So, get dplay's internal group structure
	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if(!lpGroup)
	{
		// If we don't have an lpGroup, we need to fail because some of
		// the functions below will crash if lpGroup is invalid.
		DPF(8, "Unable to find group in nametable, dpidGroup = %lu", lpd->dwGroupID);
		LEAVE_LOBBY_ALL();
		return DPERR_INVALIDGROUP;
	}

	// Send messages to remove shortcuts to this group (since dplay won't
	// do it for us)
	PRV_SendDeleteShortcutMessageForExitingGroup(this, lpGroup);

	// Destroy all the remote subgroups and players
	PRV_RemoveSubgroupsAndPlayersFromGroup(this, lpGroup, lpd->dwGroupID, FALSE);

	// Now send a DestroyGroup system message to all the local players
	hr = PRV_BroadcastDestroyGroupMessage(this, lpd->dwGroupID);

	// Now call dplay's destroy group
	hr = InternalDestroyGroup(this->lpDPlayObject, lpGroup, FALSE); 
	if(FAILED(hr))
	{
		DPF(8, "Failed destroying group from nametable, hr = 0x%08x", hr);
	}

	// Drop the locks
	LEAVE_LOBBY_ALL();

	return hr;

} // DPLP_DestroyGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_GetSPDataPointer"
HRESULT DPLAPI DPLP_GetSPDataPointer(LPDPLOBBYSP lpDPLSP, LPVOID * lplpData)
{
	LPDPLOBBYI_DPLOBJECT this;


	//	Make sure the SP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpDPLSP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// Go ahead and save the pointer
	*lplpData = this->lpSPData;

	return DP_OK;

} // DPLP_GetSPDataPointer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_HandleLobbySystemMessage"
HRESULT PRV_HandleLobbySystemMessage(LPDPLOBBYI_DPLOBJECT this,
						LPSPDATA_HANDLEMESSAGE lpd)
{
	LPDPLMSG_GENERIC				lpmsg = lpd->lpBuffer;
	LPDPLMSG_GETPROPERTYRESPONSE	lpgpr = NULL;
	LPDPLOBBYI_REQUESTNODE			lprn = NULL;
	HRESULT							hr = DP_OK;

	
	// If it's a property message, we need to deal with the request
	switch(lpmsg->dwType)
	{
		case DPLSYS_GETPROPERTYRESPONSE:
		case DPLSYS_SETPROPERTYRESPONSE:
		{
			// Cast it to a GetPropertyResponse message
			lpgpr = (LPDPLMSG_GETPROPERTYRESPONSE)lpmsg;
			
			// Find the request ID in our list of pending requests
			lprn = this->lprnHead;
			while(lprn)
			{
				if(lprn->dwRequestID == lpgpr->dwRequestID)
					break;
				else
					lprn = lprn->lpNext;
			}

			// Print some debug spew if we didn't find it, but return DP_OK since
			// we "handled" the message
			if(!lprn)
			{
				DPF(5, "Unable to find request ID in pending request list");
				return DP_OK;
			}

			// See if we slammed the guid, and replace it with GUID_NULL if we did
			if(lprn->dwFlags & GN_SLAMMED_GUID)
				lpgpr->guidPlayer = GUID_NULL;
			
			// If we found it, swap out the request ID, and send it to the
			// appropriate place
			lpgpr->dwRequestID = lprn->dwAppRequestID;
			if(lprn->dwFlags & GN_SELF_LOBBIED)
			{
				// Put the message in the lobby message receive queue
				hr = PRV_InjectMessageInQueue(lprn->lpgn, DPLMSG_STANDARD,
						lpgpr, lpd->dwBufSize, FALSE);
				if(FAILED(hr))
				{
					DPF_ERRVAL("Failed to put message in lobby receive queue, hr = 0x%08x", hr);
					goto EXIT_HANDLELOBBYSYSTEMMESSAGE;
				}
			}
			else
			{
				// Call SendLobbyMessage to send the message to the game
				hr = PRV_WriteClientData(lprn->lpgn, DPLMSG_STANDARD,
						lpgpr, lpd->dwBufSize);
				if(FAILED(hr))
				{
					DPF_ERRVAL("Failed to forward message to game, hr = 0x%08x", hr);
					goto EXIT_HANDLELOBBYSYSTEMMESSAGE;
				}
			}

			break;
		}
		default:
			break;
	}

EXIT_HANDLELOBBYSYSTEMMESSAGE:
	
	// Remove the pending request node if we serviced it (which would have
	// happened if we have a valid pointer to it)
	if(lprn)
		PRV_RemoveRequestNode(this, lprn);	
	
	return hr;

} // PRV_HandleLobbySystemMessage



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_HandleMessage"
HRESULT DPLAPI DPLP_HandleMessage(LPDPLOBBYSP lpILP,
						LPSPDATA_HANDLEMESSAGE lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	LPMSG_PLAYERMESSAGE		lpmsg = NULL;
	LPBYTE					lpByte = NULL;
	DWORD					dwSize;
	BOOL					bAllocBuffer = FALSE;
	LPDPLAYI_PLAYER			lpPlayer = NULL;


	DPF(7, "Entering DPLP_HandleMessage");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();
	
	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_HANDLEMESSAGE structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// If the message is a lobby system message, process it
	// NOTE: Make sure the size of the SPDATA_HANDLEMESSAGE is big enough
	// to contain a flags field (the shipping 5.0 bits did not have
	// this field, but the 5.1 bits did).
	if((lpd->dwSize > DPLOBBYPR_SIZE_HANDLEMESSAGE_DX50) &&
		(lpd->dwFlags & DPSEND_LOBBYSYSTEMMESSAGE))
	{
		hr = PRV_HandleLobbySystemMessage(this, lpd);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to handle lobby system message, hr = 0x%08x", hr);
		}

		LEAVE_DPLOBBY();
		return hr;
	}

	// REVIEW!!!! -- We should be able to handle a generic send to a group
	// as well as a player.  Currently, I don't think we do.

	// If this session is using naked messages, we can just send the buffer.
	// Otherwise, we need to allocate a MSG_PLAYERMESSAGE struct and fill
	// in the header.
	if(this->lpDPlayObject->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID)
	{
		lpmsg = lpd->lpBuffer;
		dwSize = lpd->dwBufSize;
	}
	else
	{
		// Calculate the size of the message
		dwSize = sizeof(MSG_PLAYERMESSAGE) + lpd->dwBufSize;

		// Allocate memory for a message buffer
		lpmsg = DPMEM_ALLOC(dwSize);
		if(!lpmsg)
		{
			DPF_ERR("Unable to allocate temporary message buffer");
			hr = DPERR_OUTOFMEMORY;
			goto ERROR_DPLP_HANDLEMESSAGE;
		}

		// Copy in the message header
		lpmsg->idFrom = lpd->dwFromID;
		lpmsg->idTo = lpd->dwToID;

		// Copy in the message
		lpByte = (LPBYTE)lpmsg + sizeof(MSG_PLAYERMESSAGE);
		memcpy(lpByte, lpd->lpBuffer, lpd->dwBufSize);

		// Set our flag indicating that we allocated a buffer
		bAllocBuffer = TRUE;
	}

	// Take the lock
	ENTER_DPLAY();

	// Find dplay's internal player struct for the To player
	lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwToID);
	if(!lpPlayer)
	{
		LEAVE_DPLAY();
		DPF_ERRVAL("Unable to find player in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDPLAYER;
		goto ERROR_DPLP_HANDLEMESSAGE;
	}

	// Call dplay's handleplayermessage function to put the message in the queue
	hr = HandlePlayerMessage(lpPlayer, (LPBYTE)lpmsg, dwSize, TRUE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

	// Drop the lock
	LEAVE_DPLAY();
			

ERROR_DPLP_HANDLEMESSAGE:
	if(bAllocBuffer && lpmsg)
		DPMEM_FREE(lpmsg);

	LEAVE_DPLOBBY();
	return hr;

} // DPLP_HandleMessage



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SendChatMessage"
HRESULT DPLAPI DPLP_SendChatMessage(LPDPLOBBYSP lpILP,
						LPSPDATA_CHATMESSAGE lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	LPMSG_CHAT				lpmsg = NULL;
	LPBYTE					lpByte = NULL;
	DWORD					dwSize;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	DWORD					dwStringSize;
	BOOL					bToGroup = FALSE;
		


	DPF(7, "Entering DPLP_SendChatMessage");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();
	
	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_HANDLEMESSAGE structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Calculate the size of the message
	dwStringSize = WSTRLEN_BYTES(lpd->lpChat->lpszMessage);
	dwSize = sizeof(MSG_CHAT) + dwStringSize;

	// Allocate memory for a message buffer
	lpmsg = DPMEM_ALLOC(dwSize);
	if(!lpmsg)
	{
		DPF_ERR("Unable to allocate temporary message buffer");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_DPLP_SENDCHATMESSAGE;
	}

	// Copy in the message header
	SET_MESSAGE_HDR(lpmsg);
	SET_MESSAGE_COMMAND(lpmsg,DPSP_MSG_CHAT);
	lpmsg->dwIDFrom = lpd->dwFromID;
	lpmsg->dwIDTo = lpd->dwToID;
	lpmsg->dwFlags = lpd->lpChat->dwFlags;
	lpmsg->dwMessageOffset = sizeof(MSG_CHAT);

	// Copy in the message
	lpByte = (LPBYTE)lpmsg + sizeof(MSG_CHAT);
	memcpy(lpByte, lpd->lpChat->lpszMessage, dwStringSize);


	// Take the lock
	ENTER_DPLAY();

	// Make sure it's from a valid player or the server player
	if(lpd->dwFromID != DPID_SERVERPLAYER)
	{
		lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwFromID);
		if(!VALID_DPLAY_PLAYER(lpPlayer)) 
		{
			LEAVE_DPLAY();
			DPF_ERR("Received chat message FROM invalid player id!!");
			hr = DPERR_INVALIDPLAYER;
			goto ERROR_DPLP_SENDCHATMESSAGE;
		}
	}

	// See who the message is for
	lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwToID);
	if(!VALID_DPLAY_PLAYER(lpPlayer)) 
	{
		// See if it's to a group
		lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwToID);
		if(!VALID_DPLAY_GROUP(lpGroup))
		{
			LEAVE_DPLAY();
			DPF_ERR("Received chat message for invalid player / group");
			hr = DPERR_INVALIDPLAYER;
			goto ERROR_DPLP_SENDCHATMESSAGE;
		}
		bToGroup = TRUE;
	}

	// Send it out
	if(bToGroup)
	{
		// Send the message
		hr = DistributeGroupMessage(this->lpDPlayObject, lpGroup,
				(LPBYTE)lpmsg, dwSize, FALSE, 0);						
	} 
	else 
	{
		// Send the message
		hr = HandlePlayerMessage(lpPlayer, (LPBYTE)lpmsg, dwSize, FALSE, 0);
	}

	// Drop the lock
	LEAVE_DPLAY();
			

ERROR_DPLP_SENDCHATMESSAGE:
	if(lpmsg)
		DPMEM_FREE(lpmsg);

	LEAVE_DPLOBBY();
	return hr;

} // DPLP_SendChatMessage



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendDataChangedMessageLocally"
HRESULT PRV_SendDataChangedMessageLocally(LPDPLOBBYI_DPLOBJECT this,
		DPID dpidPlayer, LPVOID lpData, DWORD dwDataSize)
{
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	HRESULT					hr = DP_OK;
	LPMSG_PLAYERDATA		lpmsg = NULL;
	LPBYTE					lpByte = NULL;
	DWORD					dwSize;


	DPF(7, "Entering PRV_SendDataChangedMessageLocally");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, %lu",
			this, dpidPlayer, lpData, dwDataSize);


	// Take the lock
	ENTER_DPLAY();
	
	// Setup the message to put in the player's queue
	// Calculate the size of the message
	dwSize = sizeof(MSG_PLAYERDATA) + dwDataSize;

	// Allocate memory for the message
	lpmsg = DPMEM_ALLOC(dwSize);
	if(!lpmsg)
	{
		DPF_ERR("Unable to allocate memory for temporary message structure");
		// Since the name has been changed, we'll just return success here
		hr = DP_OK;
		goto EXIT_SENDDATACHANGED;
	}

	// Now build the system message
	SET_MESSAGE_HDR(lpmsg);
	SET_MESSAGE_COMMAND(lpmsg, DPSP_MSG_PLAYERDATACHANGED);
	lpmsg->dwPlayerID = dpidPlayer;
	lpmsg->dwDataSize = sizeof(MSG_PLAYERDATA);
	lpmsg->dwDataOffset = sizeof(MSG_PLAYERDATA) + dwDataSize;

	// Copy in the data
	lpByte = (LPBYTE)lpmsg + sizeof(MSG_PLAYERDATA);
	memcpy(lpByte, lpData, dwDataSize);

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto EXIT_SENDDATACHANGED;
	}

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)lpmsg, dwSize, FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding SetGroupData message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

EXIT_SENDDATACHANGED:

	// Free our message
	if(lpmsg)
		DPMEM_FREE(lpmsg);
	
	// Drop the lock
	LEAVE_DPLAY();

	return hr;

} // PRV_SendDataChangedMessageLocally



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendNameChangedMessageLocally"
HRESULT PRV_SendNameChangedMessageLocally(LPDPLOBBYI_DPLOBJECT this,
		DPID dpidPlayer, LPDPNAME lpName, BOOL bPlayer)
{
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	HRESULT					hr = DP_OK;
	LPMSG_PLAYERNAME		lpmsg = NULL;
	DWORD					dwSize, dwShortSize = 0, dwLongSize = 0;
	LPBYTE					lpByte = NULL;

	DPF(7, "Entering PRV_SendNameChangedMessageLocally");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dpidPlayer, lpName, bPlayer);


	// Take the lock
	ENTER_DPLAY();
	
	// Setup the message to put in the player's queue
	// Calculate the size of the message
	if(lpName->lpszShortName)
		dwShortSize = WSTRLEN_BYTES(lpName->lpszShortName);
	if(lpName->lpszLongName)
		dwLongSize = WSTRLEN_BYTES(lpName->lpszLongName);
	dwSize = sizeof(MSG_PLAYERNAME) + dwShortSize + dwLongSize;

	// Allocate memory for the message
	lpmsg = DPMEM_ALLOC(dwSize);
	if(!lpmsg)
	{
		DPF_ERR("Unable to allocate memory for temporary message structure");
		// Since the name has been changed, we'll just return success here
		hr = DP_OK;
		goto EXIT_SENDNAMECHANGED;
	}

	// Now build the system message
	SET_MESSAGE_HDR(lpmsg);
	if(bPlayer)
		SET_MESSAGE_COMMAND(lpmsg, DPSP_MSG_PLAYERNAMECHANGED);
	else
		SET_MESSAGE_COMMAND(lpmsg, DPSP_MSG_GROUPNAMECHANGED);
	lpmsg->dwPlayerID = dpidPlayer;
	lpmsg->dwShortOffset = sizeof(MSG_PLAYERNAME);
	lpmsg->dwLongOffset = sizeof(MSG_PLAYERNAME) + dwShortSize;

	// Copy in the names
	lpByte = (LPBYTE)lpmsg + sizeof(MSG_PLAYERNAME);
	memcpy(lpByte, lpName->lpszShortName, dwShortSize);
	lpByte += dwShortSize;
	memcpy(lpByte, lpName->lpszLongName, dwLongSize);

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto EXIT_SENDNAMECHANGED;
	}

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)lpmsg, dwSize, FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding SetGroupName message to player's receive queue from lobby, hr = 0x%08x", hr);
	}


EXIT_SENDNAMECHANGED:

	// Free our message
	if(lpmsg)
		DPMEM_FREE(lpmsg);
	
	// Drop the lock
	LEAVE_DPLAY();

	return hr;

} // PRV_SendNameChangedMessageLocally



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SetGroupName"
HRESULT DPLAPI DPLP_SetGroupName(LPDPLOBBYSP lpILP,
					LPSPDATA_SETREMOTEGROUPNAME lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPLAYI_GROUP			lpGroup = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPLP_SetGroupName");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();
	
	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_SETGROUPNAME structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	
	// First see if the group is in our map table.  If it is not,
	// we should just ignore this message because it's for a
	// group we don't know about.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved SetGroupName message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// Take the lock
	ENTER_DPLAY();

	// See if the group is local or remote.  If it's local, ignore this message
	// and just return DP_OK becuase we've already sent this message locally.
	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if((!lpGroup) || (lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		hr = DP_OK;
		goto ERROR_DPLP_SETGROUPNAME;
	}

	// Call dplay's internalsetname function to update the name in the cache
	hr = InternalSetName((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
			lpd->dwGroupID, lpd->lpName, FALSE, lpd->dwFlags, FALSE);
	if(FAILED(hr))
	{
		DPF(8, "Failed to SetGroupName internally for remote group, hr = 0x%08x", hr);
		goto ERROR_DPLP_SETGROUPNAME;
	}

	// Send the message to all the local players
	hr = PRV_SendNameChangedMessageLocally(this, lpd->dwGroupID, lpd->lpName, FALSE);

ERROR_DPLP_SETGROUPNAME:

	// Drop the locks
	LEAVE_LOBBY_ALL();

	return hr;

} // DPLP_SetGroupName



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendGroupOwnerMessageLocally"
HRESULT PRV_SendGroupOwnerMessageLocally(LPDPLOBBYI_DPLOBJECT this,
		DPID dpidGroup, DPID dpidNewOwner, DPID dpidOldOwner)
{
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	HRESULT					hr = DP_OK;
	MSG_GROUPOWNERCHANGED	msg;


	DPF(7, "Entering PRV_SendGroupOwnerMessageLocally");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			this, dpidGroup, dpidNewOwner, dpidOldOwner);


	// Take the lock
	ENTER_DPLAY();
	
	// Now build the system message
	memset(&msg, 0, sizeof(MSG_GROUPOWNERCHANGED));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_GROUPOWNERCHANGED);
	msg.dwIDGroup = dpidGroup;
	msg.dwIDNewOwner = dpidNewOwner;
	msg.dwIDOldOwner = dpidOldOwner;

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto EXIT_SENDGROUPOWNER;
	}

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)&msg, sizeof(MSG_GROUPOWNERCHANGED), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding SetGroupOwner message to player's receive queue from lobby, hr = 0x%08x", hr);
	}


EXIT_SENDGROUPOWNER:

	// Drop the lock
	LEAVE_DPLAY();

	return hr;

} // PRV_SendGroupOwnerMessageLocally



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SetGroupOwner"
HRESULT DPLAPI DPLP_SetGroupOwner(LPDPLOBBYSP lpILP,
					LPSPDATA_SETREMOTEGROUPOWNER lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPLAYI_GROUP			lpGroup = NULL;
	HRESULT					hr = DP_OK;
	DWORD					dwOldOwnerID;


	DPF(7, "Entering DPLP_SetGroupOwner");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();
	
	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_SETGROUPNAME structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	
	// First see if the group is in our map table.  If it is not,
	// we should just ignore this message because it's for a
	// group we don't know about.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved SetGroupOwner message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// Take the lock
	ENTER_DPLAY();

	// See if the group is local or remote.  If it's local, ignore this message
	// and just return DP_OK becuase we've already sent this message locally.
	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if(!lpGroup)
	{
		hr = DP_OK;
		goto ERROR_DPLP_SETGROUPOWNER;
	}

	// If the player is already the owner of the group, we don't need
	// to do any processing (this is the buffer in case the server
	// sends us duplicate messages for stuff we've already sent locally)
	if(lpGroup->dwOwnerID == lpd->dwOwnerID)
	{
		hr = DP_OK;
		goto ERROR_DPLP_SETGROUPOWNER;
	}
	
	// Make sure the old owner is in our map table, otherwise just set
	// it to zero (the default)
	dwOldOwnerID = lpGroup->dwOwnerID;

	// Change the owner locally
	lpGroup->dwOwnerID = lpd->dwOwnerID;

	// Send a SetGroupOwner message locally
	PRV_SendGroupOwnerMessageLocally(this, lpd->dwGroupID,
		lpd->dwOwnerID, dwOldOwnerID);

ERROR_DPLP_SETGROUPOWNER:

	// Drop the locks
	LEAVE_LOBBY_ALL();

	return hr;

} // DPLP_SetGroupOwner



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SetPlayerName"
HRESULT DPLAPI DPLP_SetPlayerName(LPDPLOBBYSP lpILP,
					LPSPDATA_SETREMOTEPLAYERNAME lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	LPDPLAYI_PLAYER			lpPlayer = NULL;


	DPF(7, "Entering DPLP_SetPlayerName");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();
	
	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_SETPLAYERNAME structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// First see if the player is in our map table.  If it is not,
	// we should just ignore this message because it's for a
	// player we don't know about.
	if(!IsLobbyIDInMapTable(this, lpd->dwPlayerID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved SetPlayerName message for unknown player, dwPlayerID = %lu, discarding message", lpd->dwPlayerID);
		return DPERR_INVALIDPLAYER;
	}

	// Take the lock
	ENTER_DPLAY();

	// See if the player is local or remote.  If it's local, ignore this message
	// and just return DP_OK becuase we've already sent this message locally.
	lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwPlayerID);
	if((!lpPlayer) || (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		hr = DP_OK;
		goto ERROR_DPLP_SETPLAYERNAME;
	}

	// Call dplay's internalsetname function to update the name in the cache
	hr = InternalSetName((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
			lpd->dwPlayerID, lpd->lpName, TRUE, lpd->dwFlags, FALSE);
	if(FAILED(hr))
	{
		DPF(8, "Failed to SetPlayerName internally for remote group, hr = 0x%08x", hr);
		goto ERROR_DPLP_SETPLAYERNAME;
	}

	// Send the message to all the local players
	hr = PRV_SendNameChangedMessageLocally(this, lpd->dwPlayerID, lpd->lpName, TRUE);


ERROR_DPLP_SETPLAYERNAME:

	// Drop the lock
	LEAVE_LOBBY_ALL();

	return hr;

} // DPLP_SetPlayerName



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SetSessionDesc"
HRESULT DPLAPI DPLP_SetSessionDesc(LPDPLOBBYSP lpILP,
						LPSPDATA_SETSESSIONDESC lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPLP_SetSessionDesc");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_SETSESSIONDESC structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	LEAVE_DPLOBBY();
	return hr;

} // DPLP_SetSessionDesc



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SetSPDataPointer"
HRESULT DPLAPI DPLP_SetSPDataPointer(LPDPLOBBYSP lpDPLSP, LPVOID lpData)
{
	LPDPLOBBYI_DPLOBJECT this;

	
	//	Make sure the SP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpDPLSP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// Go ahead and save the pointer
	this->lpSPData = lpData;

	return DP_OK;

} // DPLP_SetSPDataPointer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_BuildStartSessionMessage"
HRESULT PRV_BuildStartSessionMessage(LPVOID * lplpmsg, LPDWORD lpdwSize,
				LPDPLCONNECTION	lpConn, LPDPLAYI_PLAYER lpPlayer)
{
	LPMSG_STARTSESSION		lpmsg = NULL;
	DWORD					dwPackageSize;
	DWORD					dwSize;
	LPBYTE					lpTemp = NULL;
	DPNAME					dpn;
	HRESULT					hr;


	// Setup a local DPNAME struct for the player if the names exist
	if((lpPlayer->lpszShortName) || (lpPlayer->lpszLongName))
	{
		// Setup the struct
		memset(&dpn, 0, sizeof(DPNAME));
		dpn.dwSize = sizeof(DPNAME);
		dpn.lpszShortName = lpPlayer->lpszShortName;
		dpn.lpszLongName = lpPlayer->lpszLongName;
		lpConn->lpPlayerName = &dpn;
	}
	else
	{
		// Make sure the PlayerName pointer is NULL
		lpConn->lpPlayerName = NULL;
	}

	// Calculate the size of our message in Unicode
	PRV_GetDPLCONNECTIONPackageSize(lpConn, &dwPackageSize, NULL);
	dwSize = sizeof(MSG_STARTSESSION) + dwPackageSize -
				sizeof(DPLOBBYI_PACKEDCONNHEADER);

	// Allocate memory for the message
	lpmsg = DPMEM_ALLOC(dwSize);
	if(!lpmsg)
	{
		DPF_ERR("Unable to allocate memory for temporary message structure");
		return DPERR_OUTOFMEMORY;
	}

	// Now build the system message
	SET_MESSAGE_HDR(lpmsg);
	SET_MESSAGE_COMMAND(lpmsg, DPSP_MSG_STARTSESSION);
	
	// Set the DPLCONNECTION pointer
	lpmsg->dwConnOffset = sizeof(MSG_STARTSESSION);
	lpTemp = (LPBYTE)lpmsg + lpmsg->dwConnOffset;

	// Copy in the package
	hr = PRV_PackageDPLCONNECTION(lpConn, lpTemp, FALSE);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to pack DPLCONNECTION struct, hr = 0x%08x", hr);
		DPMEM_FREE(lpmsg);
		return hr;
	}

	// Set the output pointers
	*lpdwSize = dwSize;
	*lplpmsg = lpmsg;

	return DP_OK;

} // PRV_BuildStartSessionMessage



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_StartSession"
HRESULT DPLAPI DPLP_StartSession(LPDPLOBBYSP lpILP,
				LPSPDATA_STARTSESSIONCOMMAND lpd)
{
	LPDPLOBBYI_DPLOBJECT	this = NULL;
	LPDPLAYI_DPLAY			lpDP = NULL;
	DPLCONNECTION			conn;
	LPBYTE					lpmsg = NULL;
	HRESULT					hr = DP_OK;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	DWORD					dwMessageSize;
	LPDPLAYI_GROUPNODE		lpGroupnode = NULL;
	UINT					nPlayers;


	DPF(7, "Entering DPLP_StartSession");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_STARTSESSIONCOMMAND structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Make a local copy of the DPLCONNECTION structure since we will
	// be modifying some elements of it.  We are currently only modifying
	// elements in the DPLCONNECTION structure itself, so we can get
	// away with using it's pointers to SessionDesc and PlayerName structs,
	// but if we modify those in the future, we need to copy them as well
	memcpy(&conn, lpd->lpConn, sizeof(DPLCONNECTION));

	// Make a local variable pointer to the dplay object
	lpDP = this->lpDPlayObject;

	// Make sure we know about this group
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		DPF(8, "Received StartSessionCommand message for an unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		LEAVE_DPLOBBY();
		return DPERR_INVALIDGROUP;
	}

	// Take the dplay lock since we'll be looking at it's structures
	ENTER_DPLAY();	

	// See if the host is even in our nametable, if it isn't, we'll assume
	// we're not the host
	// See if the host is a local player, if it is, send separate messages
	if(IsLobbyIDInMapTable(this, lpd->dwHostID))
	{
		// Get dplay's player struct for the host player
		lpPlayer = PlayerFromID(lpDP, lpd->dwHostID);

		// If we know the host player (we should) and he's local, we
		// want to send the host message first
		if((lpPlayer) && (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			// So set the host bit
			conn.dwFlags |= DPLCONNECTION_CREATESESSION;

			// Build the StartSession message for the host
			hr = PRV_BuildStartSessionMessage(&lpmsg, &dwMessageSize,
						&conn, lpPlayer);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed building StartSessionCommand message, hr = 0x%08x", hr);
				goto EXIT_DPLP_STARTSESSION;
			}

			// Now send the message to the host player alone
			hr = HandlePlayerMessage(lpPlayer, (LPBYTE)lpmsg,
							dwMessageSize, FALSE, 0);
			if(FAILED(hr))
			{
				DPF(8, "Failed adding message to player's receive queue from lobby, hr = 0x%08x", hr);
			}

			// Free our message since we're done with it
			DPMEM_FREE(lpmsg);
			lpmsg = NULL;
			
			// Now fall through and send the join message to everyone else
			// in the group
		}
	}

	// We must be joining, so set the join bit, and make sure the host
	// bit isn't still set from above
	conn.dwFlags &= ~DPLCONNECTION_CREATESESSION;
	conn.dwFlags |= DPLCONNECTION_JOINSESSION;

	// Get a pointer to dplay's internal group structure
	lpGroup = GroupFromID(lpDP, lpd->dwGroupID);
	if(!lpGroup)
	{
		DPF(5, "Unable to find group in nametable, idGroup = %lu", lpd->dwGroupID);
		goto EXIT_DPLP_STARTSESSION;
	}


	// Figure out how many players we are looking for
	lpGroupnode = FindPlayerInGroupList(lpGroup->pSysPlayerGroupnodes,lpDP->pSysPlayer->dwID);
	if (!lpGroupnode)
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}
	nPlayers = lpGroupnode->nPlayers;

	// Walk the list of groupnodes, looking for nPlayers local players to give
	// the message to, excluding the host
	lpGroupnode = lpGroup->pGroupnodes;
	while ((nPlayers > 0) && (lpGroupnode))
	{
		if ((lpGroupnode->pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
			(lpGroupnode->pPlayer->dwID != lpd->dwHostID))
		{
			// Build the StartSession (join) message for this player
			hr = PRV_BuildStartSessionMessage(&lpmsg, &dwMessageSize,
						&conn, lpGroupnode->pPlayer);
			if(FAILED(hr))
			{
				DPF(5, "Failed building StartSessionCommand message, hr = 0x%08x", hr);
				goto EXIT_DPLP_STARTSESSION;
			}

			// Send the message to this player
			hr = HandlePlayerMessage(lpGroupnode->pPlayer, lpmsg,
					dwMessageSize, FALSE, 0);

			// Free our message
			if(lpmsg)
				DPMEM_FREE(lpmsg);
			lpmsg = NULL;

			nPlayers--;
		} // local & !host

		lpGroupnode = lpGroupnode->pNextGroupnode;

	} // while
	

EXIT_DPLP_STARTSESSION:

	if(lpmsg)
		DPMEM_FREE(lpmsg);

	LEAVE_LOBBY_ALL();
	return hr;

} // DPLP_StartSession
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\dplunk.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplunk.c
 *  Content:	IUnknown implementation for dplobby
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	4/13/96		myronth	Created it
 *	10/23/96	myronth	Added client/server methods
 *	11/08/96	myronth	Added PRV_GetDPLobbySPInterface
 *	11/20/96	myronth	Added LogoffServer call to Release code
 *	2/12/97		myronth	Mass DX5 changes
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/12/97		myronth	New release code for DPlay3 (order different)
 *	3/13/97		myronth	Added FreeLibrary code for LP's
 *	3/17/97		myronth	Cleanup map table
 *	3/24/97		kipo	Added support for IDirectPlayLobby2 interface
 *	4/3/97		myronth	Changed CALLSP macro to CALL_LP
 *	5/8/97		myronth	Drop the lobby lock when calling the LP, Purged
 *						dead code
 *	7/30/97		myronth	Added request node cleanup for standard lobby messaging
 *	8/19/97		myronth Added PRV_GetLobbyObjectFromInterface
 *	8/19/97		myronth	Removed PRV_GetLobbyObjectFromInterface (not needed)
 *	12/2/97		myronth	Added IDirectPlayLobby3 interface
 *  2/2/99		aarono  Added lobbies to refcount on DPLAY dll to avoid
 *                      accidental unload.
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetDPLobbySPInterface"
LPDPLOBBYSP PRV_GetDPLobbySPInterface(LPDPLOBBYI_DPLOBJECT this)
{
	LPDPLOBBYI_INTERFACE	lpInt;


	ASSERT(this);

	// Get an IDPLobbySP interface
	if(FAILED(PRV_GetInterface(this, &lpInt, &dplCallbacksSP)))
	{
		DPF_ERR("Unable to get non-reference counted DPLobbySP Interface pointer");
		ASSERT(FALSE);
		return NULL;
	}

	// Decrement the ref cnt on the interface
	lpInt->dwIntRefCnt--;

	// Return the interface pointer
	return (LPDPLOBBYSP)lpInt;

} // PRV_GetDPLobbySPInterface

// Find an interface with the pCallbacks vtbl on this object.
// If one doesn't exist, create it, increment the ref count,
// and return the interface
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetInterface"
HRESULT PRV_GetInterface(LPDPLOBBYI_DPLOBJECT this,
							LPDPLOBBYI_INTERFACE * ppInt,
							LPVOID lpCallbacks)
{
	LPDPLOBBYI_INTERFACE	lpCurrentInts = this->lpInterfaces;
	BOOL					bFound = FALSE;


	DPF(7, "Entering PRV_GetInterface");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, ppInt, lpCallbacks);

	ASSERT(ppInt);

	// See if there is already an interface
	while (lpCurrentInts && !bFound)
	{
		if (lpCurrentInts->lpVtbl == lpCallbacks)
		{
			bFound = TRUE;
		}
		else
			lpCurrentInts = lpCurrentInts->lpNextInterface;
	}

	// If there is one, return it
	if(bFound)
	{
		*ppInt = lpCurrentInts;
		(*ppInt)->dwIntRefCnt++;
		// we don't increment this->dwRefCnt, since it's one / interface object
		return DP_OK;
	}

	// Otherwise create one
	*ppInt = DPMEM_ALLOC(sizeof(DPLOBBYI_INTERFACE));
	if (!(*ppInt)) 
	{
		DPF_ERR("Could not alloc interface - out of memory");
		return E_OUTOFMEMORY;
	}

	(*ppInt)->dwIntRefCnt = 1;
	(*ppInt)->lpDPLobby = this;
	(*ppInt)->lpNextInterface = this->lpInterfaces;
	(*ppInt)->lpVtbl = lpCallbacks;

	this->lpInterfaces = *ppInt;
	this->dwRefCnt++;				// One time only for each interface object
	return DP_OK;
	
} // PRV_GetInterface


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_QueryInterface"
HRESULT DPLAPI DPL_QueryInterface(LPDIRECTPLAYLOBBY lpDPL, REFIID riid, LPVOID * ppvObj) 
{
    LPDPLOBBYI_DPLOBJECT	this;
    HRESULT					hr;


	DPF(7, "Entering DPL_QueryInterface");
	DPF(9, "Parameters: 0x%08x, refiid, 0x%08x", lpDPL, ppvObj);

    ENTER_DPLOBBY();
    
    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }

		if ( !VALID_READ_UUID_PTR(riid) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDPARAMS;
		}
		
		if ((!VALID_UUID_PTR(ppvObj)) )
		{
			LEAVE_DPLOBBY();
			DPF_ERR("Object pointer is invalid!");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLOBBY();
        return DPERR_INVALIDPARAMS;
    }

     *ppvObj=NULL;
        
    if( IsEqualIID(riid, &IID_IUnknown) || 
        IsEqualIID(riid, &IID_IDirectPlayLobby) )
    {
		// Get an IDirectPlayLobby Interface (Unicode)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacks);
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayLobbyA) )
	{
		// Get an IDirectPlayLobbyA Interface (ANSI)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacksA);
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayLobby2) )
    {
		// Get an IDirectPlayLobby2 Interface (Unicode)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacks2);
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayLobby2A) )
	{
		// Get an IDirectPlayLobby2A Interface (ANSI)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacks2A);
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayLobby3) )
    {
		// Get an IDirectPlayLobby3 Interface (Unicode)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacks3);
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayLobby3A) )
	{
		// Get an IDirectPlayLobby3A Interface (ANSI)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacks3A);
	}
	else 
	{
	    hr =  E_NOINTERFACE;		
	}
        
    LEAVE_DPLOBBY();
    return hr;

} //DPL_QueryInterface


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_AddRef"
ULONG DPLAPI DPL_AddRef(LPDIRECTPLAYLOBBY lpDPL) 
{
	LPDPLOBBYI_INTERFACE lpInt = (LPDPLOBBYI_INTERFACE)lpDPL;    
    LPDPLOBBYI_DPLOBJECT this;


	DPF(7, "Entering DPL_AddRef");
	DPF(9, "Parameters: 0x%08x", lpDPL);

    ENTER_DPLOBBY();
    
    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return 0;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLOBBY();
        return 0;
    }


	// Make sure someone isn't calling AddRef on our IDPLobbySP interface
	if(lpInt->lpVtbl == &dplCallbacksSP)
	{
		DPF_ERR("You cannot call AddRef on an IDPLobbySP interface");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return 0;
	}

	// Increment the interface's reference count
    lpInt->dwIntRefCnt++;
        
    LEAVE_DPLOBBY();
    return (lpInt->dwIntRefCnt);

} //DPL_AddRef


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyDPLobby"
HRESULT PRV_DestroyDPLobby(LPDPLOBBYI_DPLOBJECT this) 
{
	HRESULT				hr = DP_OK;


	DPF(7, "Entering PRV_DestroyDPLobby");
	DPF(9, "Parameters: 0x%08x", this);

	// Since we can now be called from the DPlay3 object's Release code,
	// make sure we don't have any interface objects when we go to
	// free our lobby object.  Assert here if any interfaces exist.
	ASSERT(!this->lpInterfaces);

	// Walk the list of GameNodes, freeing them as you go
	while(this->lpgnHead)
		PRV_RemoveGameNodeFromList(this->lpgnHead);

	// Walk the list of pending lobby server requests and free them
	while(this->lprnHead)
		PRV_RemoveRequestNode(this, this->lprnHead);

	// Free our callback table if one exists
	if(this->pcbSPCallbacks)
		DPMEM_FREE(this->pcbSPCallbacks);

	// Free our ID Map Table if it exists
	if(this->lpMap)
		DPMEM_FREE(this->lpMap);

	// Free the dplobby object
	DPMEM_FREE(this);	

	gnObjects--;

	ASSERT(gnObjects >= 0);

	return DP_OK;

} // PRV_DestroyDPlayLobby


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyDPLobbyInterface"
HRESULT  PRV_DestroyDPLobbyInterface(LPDPLOBBYI_DPLOBJECT this,
								LPDPLOBBYI_INTERFACE lpInterface)
{
	LPDPLOBBYI_INTERFACE	lpIntPrev; // The interface preceeding pInt in the list
	BOOL					bFound = FALSE;


	DPF(7, "Entering PRV_DestroyDPLobbyInterface");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpInterface);

	// Remove pInt from the list of interfaces
	if (this->lpInterfaces == lpInterface)
	{
		// It's the 1st one, just remove it
		this->lpInterfaces = lpInterface->lpNextInterface;
	}
	else 
	{
		lpIntPrev = this->lpInterfaces;
		while (lpIntPrev && !bFound)
		{
			if (lpIntPrev->lpNextInterface == lpInterface)
			{
				bFound = TRUE;
			}
			else lpIntPrev = lpIntPrev->lpNextInterface;
		}
		if (!bFound)
		{
			ASSERT(FALSE);
			return E_UNEXPECTED;
		}
		// take pint out of the list
		lpIntPrev->lpNextInterface = lpInterface->lpNextInterface;
		
	}

	DPMEM_FREE(lpInterface);
	return DP_OK;

} // PRV_DestroyDPLobbyInterface


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_Release"
ULONG PRV_Release(LPDPLOBBYI_DPLOBJECT this, LPDPLOBBYI_INTERFACE lpInterface)
{
	HRESULT				hr = DP_OK;
	SPDATA_SHUTDOWN		sdd;
	DWORD				dwError;


	DPF(7, "==> PRV_Release");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpInterface);

	ENTER_DPLOBBY();

	// Decrement the interface ref count
	if (0 == --(lpInterface->dwIntRefCnt))
	{
		DPF(7,"Lobby interface Refcount hit 0, freeing\n");
		// Since we're destroying an interface, dec the object count
	    this->dwRefCnt--;
		
		// If our object ref cnt just went to zero, we need to call
		// shutdown in the LP if one is loaded
		if(this->dwFlags & DPLOBBYPR_SPINTERFACE)
		{
			// Clear our stack-based structure
			memset(&sdd, 0, sizeof(SPDATA_SHUTDOWN));

			// Call the Shutdown method in the SP
			if(CALLBACK_EXISTS(Shutdown))
			{
				sdd.lpISP = PRV_GetDPLobbySPInterface(this);

				// Drop the lock so the lobby provider's receive thread can get back
				// in with other messages if they show up in the queue before our
				// CreatePlayer response (which always happens)
				LEAVE_DPLOBBY();
				hr = CALL_LP(this, Shutdown, &sdd);
				ENTER_DPLOBBY();
			}
			else 
			{
				// All LP's should support Shutdown
				ASSERT(FALSE);
				hr = DPERR_UNAVAILABLE;
			}
			
			if (FAILED(hr)) 
			{
				DPF_ERR("Could not invoke Shutdown method in the Service Provider");
			}
		}

		// REVIEW!!!! -- Are we going to have the same problem dplay has
		// with SP's hanging around and crashing after we go away?  We
		// need to make sure the LP goes away first.
		if(this->hInstanceLP)
		{
			DPF(7,"About to free lobby provider library, hInstance %x\n",this->hInstanceLP);
			if (!FreeLibrary(this->hInstanceLP))
			{
				dwError = GetLastError();
				DPF_ERRVAL("Unable to free Lobby Provider DLL, dwError = %lu", dwError);
				ASSERT(FALSE);
			}

			// Just to be safe
			this->hInstanceLP = NULL;
		}

		// If the interface is the IDPLobbySP interface, we had to have been
		// called from the DPlay3 release code, so clear the SP flag since
		// we are going to remove the IDPLobbySP interface just below here.
		this->dwFlags &= ~DPLOBBYPR_SPINTERFACE;

		// Take the interface out of the table
		hr = PRV_DestroyDPLobbyInterface(this, lpInterface);
		if (FAILED(hr)) 
		{
			DPF(0,"Could not destroy DPLobby interface! hr = 0x%08lx\n", hr);
			ASSERT(FALSE);
		}

		// Now destroy the interface if the ref cnt is 0
		if(0 == this->dwRefCnt)
	    {
			// Destroy the DPLobby object
			DPF(0,"Destroying DirectPlayLobby object - ref cnt = 0!");
			hr = PRV_DestroyDPLobby(this);
			if (FAILED(hr)) 
			{
				DPF(0,"Could not destroy DPLobby! hr = 0x%08lx\n",hr);
				ASSERT(FALSE);
			}
	    
		} // 0 == this->dwRefCnt
		
		LEAVE_DPLOBBY();
		return 0;

	} //0 == pInt->dwIntRefCnt 

	DPF(7, "<==PRV_Release, rc=%d\n",lpInterface->dwIntRefCnt);
   	
    LEAVE_DPLOBBY();
    return (lpInterface->dwIntRefCnt);
} // PRV_Release
		


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_Release"
ULONG DPLAPI DPL_Release(LPDIRECTPLAYLOBBY lpDPL)
{
	LPDPLOBBYI_INTERFACE	lpInterface;
    LPDPLOBBYI_DPLOBJECT	this;
    HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_Release");
	DPF(9, "Parameters: 0x%08x", lpDPL);

    TRY
    {
		lpInterface = (LPDPLOBBYI_INTERFACE)lpDPL;
		if( !VALID_DPLOBBY_INTERFACE( lpInterface ))
		{
			return 0;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return 0;
    }


	// Make sure someone isn't calling Release on our IDPLobbySP interface
	if(lpInterface->lpVtbl == &dplCallbacksSP)
	{
		DPF_ERR("You cannot call Release on an IDPLobbySP interface");
		ASSERT(FALSE);
		return 0;
	}

	// Call our internal release function
	return PRV_Release(this, lpInterface);

} //DPL_Release



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeAllLobbyObjects"
void PRV_FreeAllLobbyObjects(LPDPLOBBYI_DPLOBJECT this)
{

	DPF(7, "Entering PRV_FreeAllLobbyObjects");
	DPF(9, "Parameters: 0x%08x", this);

	ASSERT(this);

	// If we have an SP interface, just call release on it
	if(this->dwFlags & DPLOBBYPR_SPINTERFACE)
	{
		// Assert if an interface doesn't exist, because it should
		ASSERT(this->lpInterfaces);
		PRV_Release(this, this->lpInterfaces);
		return;
	}

	// Otherwise, we should only have an uninitialized object,
	// which we should just be able to destroy
	PRV_DestroyDPLobby(this);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\tlhelp32.h ===
/*****************************************************************************\
*                                                                             *
* tlhelp32.h -	WIN32 tool help functions, types, and definitions	      *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* NOTE: windows.h/winbase.h must be #included first			      *
*                                                                             *
* Copyright (c) 1994-1995, Microsoft Corp.   All rights reserved. 	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_TOOLHELP32
#define _INC_TOOLHELP32


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#define MAX_MODULE_NAME32 255

/****** Shapshot function **********************************************/

HANDLE WINAPI CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
//
// The th32ProcessID argument is only used if TH32CS_SNAPHEAPLIST or
// TH32CS_SNAPMODULE is specified. th32ProcessID == 0 means the current
// process.
//
// NOTE that all of the snapshots are global except for the heap and module
//	lists which are process specific. To enumerate the heap or module
//	state for all WIN32 processes call with TH32CS_SNAPALL and the
//	current process. Then for each process in the TH32CS_SNAPPROCESS
//	list that isn't the current process, do a call with just
//	TH32CS_SNAPHEAPLIST and/or TH32CS_SNAPMODULE.
//
// dwFlags
//
#define TH32CS_SNAPHEAPLIST 0x00000001
#define TH32CS_SNAPPROCESS  0x00000002
#define TH32CS_SNAPTHREAD   0x00000004
#define TH32CS_SNAPMODULE   0x00000008
#define TH32CS_SNAPALL	    (TH32CS_SNAPHEAPLIST | TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD | TH32CS_SNAPMODULE)
#define TH32CS_INHERIT	    0x80000000
//
// Use CloseHandle to destroy the snapshot
//

/****** heap walking ***************************************************/

typedef struct tagHEAPLIST32
{
    DWORD  dwSize;
    DWORD  th32ProcessID;   // owning process
    DWORD  th32HeapID;	    // heap (in owning process's context!)
    DWORD  dwFlags;
} HEAPLIST32;
typedef HEAPLIST32 *  PHEAPLIST32;
typedef HEAPLIST32 *  LPHEAPLIST32;
//
// dwFlags
//
#define HF32_DEFAULT	  1  // process's default heap
#define HF32_SHARED	  2  // is shared heap

BOOL WINAPI Heap32ListFirst(HANDLE hSnapshot, LPHEAPLIST32 lphl);
BOOL WINAPI Heap32ListNext(HANDLE hSnapshot, LPHEAPLIST32 lphl);

typedef struct tagHEAPENTRY32
{
    DWORD  dwSize;
    HANDLE hHandle;	// Handle of this heap block
    DWORD  dwAddress;	// Linear address of start of block
    DWORD  dwBlockSize; // Size of block in bytes
    DWORD  dwFlags;
    DWORD  dwLockCount;
    DWORD  dwResvd;
    DWORD  th32ProcessID;   // owning process
    DWORD  th32HeapID;	    // heap block is in
} HEAPENTRY32;
typedef HEAPENTRY32 *  PHEAPENTRY32;
typedef HEAPENTRY32 *  LPHEAPENTRY32;
//
// dwFlags
//
#define LF32_FIXED    0x00000001
#define LF32_FREE     0x00000002
#define LF32_MOVEABLE 0x00000004

BOOL WINAPI Heap32First(LPHEAPENTRY32 lphe, DWORD th32ProcessID,
			DWORD th32HeapID);
BOOL WINAPI Heap32Next(LPHEAPENTRY32 lphe);
BOOL WINAPI Toolhelp32ReadProcessMemory(DWORD	th32ProcessID,
					LPCVOID lpBaseAddress,
					LPVOID	lpBuffer,
					DWORD	cbRead,
					LPDWORD lpNumberOfBytesRead);

/***** Process walking *************************************************/

typedef struct tagPROCESSENTRY32
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ProcessID;	    // this process
    DWORD   th32DefaultHeapID;
    DWORD   th32ModuleID;	    // associated exe
    DWORD   cntThreads;
    DWORD   th32ParentProcessID;    // this process's parent process
    LONG    pcPriClassBase;	    // Base priority of process's threads
    DWORD   dwFlags;
    char    szExeFile[MAX_PATH];    // Path
} PROCESSENTRY32;
typedef PROCESSENTRY32 *  PPROCESSENTRY32;
typedef PROCESSENTRY32 *  LPPROCESSENTRY32;

BOOL WINAPI Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
BOOL WINAPI Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);

/***** Thread walking **************************************************/

typedef struct tagTHREADENTRY32
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ThreadID;	// this thread
    DWORD   th32OwnerProcessID; // Process this thread is associated with
    LONG    tpBasePri;
    LONG    tpDeltaPri;
    DWORD   dwFlags;
} THREADENTRY32;
typedef THREADENTRY32 *  PTHREADENTRY32;
typedef THREADENTRY32 *  LPTHREADENTRY32;

BOOL WINAPI Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
BOOL WINAPI Thread32Next(HANDLE hSnapshot, LPTHREADENTRY32 lpte);

/***** Module walking *************************************************/

typedef struct tagMODULEENTRY32
{
    DWORD   dwSize;
    DWORD   th32ModuleID;	// This module
    DWORD   th32ProcessID;	// owning process
    DWORD   GlblcntUsage;	// Global usage count on the module
    DWORD   ProccntUsage;	// Module usage count in th32ProcessID's context
    BYTE  * modBaseAddr;	// Base address of module in th32ProcessID's context
    DWORD   modBaseSize;	// Size in bytes of module starting at modBaseAddr
    HMODULE hModule;		// The hModule of this module in th32ProcessID's context
    char    szModule[MAX_MODULE_NAME32 + 1];
    char    szExePath[MAX_PATH];
} MODULEENTRY32;
typedef MODULEENTRY32 *  PMODULEENTRY32;
typedef MODULEENTRY32 *  LPMODULEENTRY32;

//
// NOTE CAREFULLY that the modBaseAddr and hModule fields are valid ONLY
// in th32ProcessID's process context.
//

BOOL WINAPI Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
BOOL WINAPI Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme);

#ifdef __cplusplus
}
#endif

#endif // _INC_TOOLHELP32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\group.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       group.c
 *  Content:	Methods for managing groups
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	2/27/97		myronth	Created it
 *	3/17/97		myronth	Create/DestroyGroup, Removed unnecessary Enum functions
 *	3/20/97		myronth	AddPlayerToGroup, DeletePlayerFromGroup
 *	3/21/97		myronth	SetGroupName, Get/SetGroupData
 *	3/31/97		myronth	Removed dead code, Added CreateAndMapNewGroup function
 *	4/3/97		myronth	Changed CALLSP macro to CALL_LP
 *	5/6/97		kipo	GetGroup() now takes a parent ID
 *	5/8/97		myronth	Subgroup support, GroupConnSettings, StartSession,
 *						and drop the lobby lock when calling the LP
 *	5/12/97		myronth	Handle remote groups properly
 *	5/17/97		myronth	Added parent ID to CreateAndMapNewGroup calls, 
 *						Added send message code for DestroyGroup and
 *						DeletePlayerFromGroup on the local machine
 *	5/20/97		myronth	Send Delete & DestroyPlayer messages for remote
 *						players when a local player leaves a group (#8586)
 *						Made AddPlayerToGroup & DeletePlayerFromGroup return
 *						DPERR_ACCESSDENIED on remote players (#8679),
 *						Fixed a bunch of other lock bugs, Changed debug levels
 *	5/21/97		myronth	Pass CreateGroup flags through the lobby (#8813)
 *	5/22/97		myronth	Added functions to destroy remote subgroups when
 *						a local player leaves a group (#8810)
 *	5/23/97		myronth	Send messages locally for CreateGroup and
 *						CreateGroupInGroup (#8870)
 *	6/3/97		myronth	Added PRV_DestroySubgroups function (#9134) and
 *						rearranged some of the DestroyGroup code
 *	6/5/97		myronth	Added shortcut checking to PRV_DestroySubgroups by
 *						adding the PRV_AreSubgroupsShortcuts function
 *	6/6/97		myronth	Added PRV_DestroyGroupAndParents and PRV_Destroy-
 *						ShortcutsForExitingPlayer, cleaned up PRV_Delete-
 *						PlayerFromGroup, Fixed StartSession bugs (#9573,#9574)
 *	6/9/97		myronth	Only delete shortcuts (don't destroy the subgoup)
 *						in the PRV_DestroySubgroups function
 *	6/16/97		myronth	Fixed bad deletion of uncle groups & some subgroups
 *						during DeletePlayerFromGroup (#9655)
 *	6/20/97		myronth	Send AddGroupToGroup message locally to avoid
 *						sending duplicate messages.  Also added code to
 *						send local DeleteGroupFromGroup messages (#10139)
 *	6/24/97		myronth	Send AddPlayerToGroup message locally to avoid
 *						sending duplicate messages (#10287)
 *	8/22/97		myronth	Force guidInstance to NULL in SetGroupConnectionSettings
 *	9/29/97		myronth	Send local SetGroupName/Data msgs after call to
 *						lobby server succeeds (#12554)
 *	10/23/97	myronth	Added hidden group support (#12688), fixed crashing
 *						bug on DeletePlayerFromGroup (#12885)
 *	10/29/97	myronth	Added support for group owners, including
 *						DPL_SetGroupOwner and DPL_GetGroupOwner
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddGroupToGroup"
HRESULT DPLAPI PRV_AddGroupToGroup(LPDPLOBBYI_DPLOBJECT this, DWORD dwParentID,
					DWORD dwGroupID)
{
	SPDATA_ADDGROUPTOGROUP		ad;
	MSG_PLAYERMGMTMESSAGE		msg;
	LPDPLAYI_GROUP				lpGroupTo = NULL;
	HRESULT						hr = DP_OK;


	DPF(7, "Entering DPL_AddGroupToGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, dwParentID, dwGroupID);


    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }

	
	// Setup our SPDATA struct
	memset(&ad, 0, sizeof(SPDATA_ADDGROUPTOGROUP));
	ad.dwSize = sizeof(SPDATA_ADDGROUPTOGROUP);
	ad.dwParentID = dwParentID;
	ad.dwGroupID = dwGroupID;

	// Call the AddGroupToGroup method in the SP
	if(CALLBACK_EXISTS(AddGroupToGroup))
	{
		ad.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, AddGroupToGroup, &ad);
		ENTER_DPLOBBY();
	}
	else 
	{
		// AddGroupToGroup is required
		DPF_ERR("The Lobby Provider callback for AddGroupToGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_ADDGROUPTOGROUP;
	}

	// If it succeeded, send the AddGroupToGroup message to our local players
	if(SUCCEEDED(hr))
	{
		// Take the dplay lock
		ENTER_DPLAY();
		
		// Find dplay's internal group struct for the To group
		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			LEAVE_DPLAY();
			DPF_ERR("Unable to find group in nametable");
			hr = DPERR_INVALIDGROUP;
			goto EXIT_ADDGROUPTOGROUP;
		}

		// Now build the system message (at least the parts we need)
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_ADDSHORTCUTTOGROUP);
		msg.dwPlayerID = dwGroupID;
		msg.dwGroupID = dwParentID;

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding AddGroupToGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}

		// Drop the dplay lock
		LEAVE_DPLAY();
	}
	else
	{
		DPF_ERRVAL("Failed calling AddGroupToGroup in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_ADDGROUPTOGROUP:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_AddGroupToGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddPlayerToGroup"
HRESULT DPLAPI PRV_AddPlayerToGroup(LPDPLOBBYI_DPLOBJECT this, DWORD dwGroupID,
					DWORD dwPlayerID)
{
	SPDATA_ADDPLAYERTOGROUP		ad;
	LPDPLAYI_PLAYER				lpPlayer = NULL;
	MSG_PLAYERMGMTMESSAGE		msg;
	LPDPLAYI_GROUP				lpGroupTo = NULL;
	LPDPLAYI_GROUP				lpGroup = NULL;
	HRESULT						hr = DP_OK;


	DPF(7, "Entering DPL_AddPlayerToGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, dwGroupID, dwPlayerID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }

	
	// Take the dplay lock since we'll be looking at a dplay internal struct
	ENTER_DPLAY();

	// Make sure the player is a local player, otherwise return AccessDenied
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwPlayerID);
	if(!lpPlayer)
	{
		LEAVE_DPLAY();
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_ADDPLAYERTOGROUP;
	}

	if(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		LEAVE_DPLAY();
		DPF_ERR("Cannot add a remote player to a group");
		hr = DPERR_ACCESSDENIED;
		goto EXIT_ADDPLAYERTOGROUP;
	}
	
	// Drop the dplay lock since we're done
	LEAVE_DPLAY();

	// Setup our SPDATA struct
	memset(&ad, 0, sizeof(SPDATA_ADDPLAYERTOGROUP));
	ad.dwSize = sizeof(SPDATA_ADDPLAYERTOGROUP);
	ad.dwGroupID = dwGroupID;
	ad.dwPlayerID = dwPlayerID;

	// Call the AddPlayerToGroup method in the SP
	if(CALLBACK_EXISTS(AddPlayerToGroup))
	{
		ad.lpISP = PRV_GetDPLobbySPInterface(this);
		
		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
		hr = CALL_LP(this, AddPlayerToGroup, &ad);
		ENTER_DPLOBBY();
	}
	else 
	{
		// AddPlayerToGroup is required
		DPF_ERR("The Lobby Provider callback for AddPlayerToGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_ADDPLAYERTOGROUP;
	}

	// If it succeeded, send the AddPlayerToGroup message to our local players
	if(SUCCEEDED(hr))
	{
		// Take the dplay lock
		ENTER_DPLAY();
		
		// Find dplay's internal group struct for the To group
		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			LEAVE_DPLAY();
			DPF_ERR("Unable to find group in nametable");
			hr = DPERR_INVALIDGROUP;
			goto EXIT_ADDPLAYERTOGROUP;
		}

		// Now build the system message (at least the parts we need)
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_ADDPLAYERTOGROUP);
		msg.dwPlayerID = dwPlayerID;
		msg.dwGroupID = dwGroupID;

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding AddPlayerToGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}
		else
		{
			// We need to see if this player is the group owner.  If it is,
			// we need to send a SetGroupOwner message as well.
			lpGroup = GroupFromID(this->lpDPlayObject, dwGroupID);
			if(lpGroup && (dwPlayerID == lpGroup->dwOwnerID))
			{
				// Now send the message
				PRV_SendGroupOwnerMessageLocally(this, dwGroupID, dwPlayerID, 0);
			}
		 }


		// Drop the dplay lock
		LEAVE_DPLAY();
	}
	else
	{
		DPF_ERRVAL("Failed calling AddPlayerToGroup in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_ADDPLAYERTOGROUP:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_AddPlayerToGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateGroup"
HRESULT DPLAPI PRV_CreateGroup(LPDPLOBBYI_DPLOBJECT this, LPDPID lpidGroup,
			LPDPNAME lpName, LPVOID lpData, DWORD dwDataSize, DWORD dwFlags,
			DWORD dwOwnerID)
{
	SPDATA_CREATEGROUP		cg;
	MSG_PLAYERMGMTMESSAGE	msg;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	DWORD					dwInternalFlags;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_CreateGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu, 0x%08x, 0x%08x",
			this, lpidGroup, lpName, lpData, dwDataSize, dwFlags, dwOwnerID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA struct
	memset(&cg, 0, sizeof(SPDATA_CREATEGROUP));
	cg.dwSize = sizeof(SPDATA_CREATEGROUP);
	cg.lpName = lpName;
	cg.lpData = lpData;
	cg.dwDataSize = dwDataSize;
	cg.dwFlags = dwFlags;
	cg.dwGroupOwnerID = dwOwnerID;

	// Call the CreateGroup method in the SP
	if(CALLBACK_EXISTS(CreateGroup))
	{
		cg.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, CreateGroup, &cg);
		ENTER_DPLOBBY();
	}
	else 
	{
		// CreateGroup is required
		DPF_ERR("The Lobby Provider callback for CreateGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling CreateGroup in the Lobby Provider, hr = 0x%08x", hr);
		goto EXIT_CREATEGROUP;
	}

	// Setup the flags to pass to GetGroup
	dwInternalFlags = DPLAYI_PLAYER_PLAYERLOCAL;
	if(dwFlags & DPGROUP_STAGINGAREA)
		dwInternalFlags |= DPLAYI_GROUP_STAGINGAREA;
	if(dwFlags & DPGROUP_HIDDEN)
		dwInternalFlags |= DPLAYI_GROUP_HIDDEN;

	// Add the player to dplay's nametable and put it in our map table
	hr = PRV_CreateAndMapNewGroup(this, lpidGroup, lpName, lpData,
			dwDataSize, dwInternalFlags, cg.dwGroupID, 0, dwOwnerID);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed creating a new local group, hr = 0x%08x", hr);
		// REVIEW!!!! -- We need to send a message back to the server saying
		// we couldn't complete the deal on our end.
		goto EXIT_CREATEGROUP;
	}

	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_CREATEGROUP);
	msg.dwPlayerID = *lpidGroup;

	// Take the lock
	ENTER_DPLAY();

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		LEAVE_DPLAY();
		DPF_ERRVAL("Unable to find system group in nametable, hr = 0x%08x", hr);
		goto EXIT_CREATEGROUP;
	}

	// Call dplay's DistributeGroupMessage function to put the message in
	// the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo, (LPBYTE)&msg,
			sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(2, "Failed adding CreateGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

	LEAVE_DPLAY();

EXIT_CREATEGROUP:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_CreateGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateGroupInGroup"
HRESULT DPLAPI PRV_CreateGroupInGroup(LPDPLOBBYI_DPLOBJECT this, DWORD dwParentID,
			LPDPID lpidGroup, LPDPNAME lpName, LPVOID lpData, DWORD dwDataSize,
			DWORD dwFlags, DWORD dwOwnerID)
{
	SPDATA_CREATEGROUPINGROUP	cgig;
	MSG_PLAYERMGMTMESSAGE		msg;
	LPDPLAYI_GROUPNODE			lpGroupnode = NULL;
	LPDPLAYI_GROUP				lpGroupTo = NULL;
	HRESULT						hr = DP_OK;
	DWORD						dwInternalFlags;


	DPF(7, "Entering PRV_CreateGroupInGroup");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x, 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dwParentID, lpidGroup, lpName, lpData, dwDataSize, dwFlags, dwOwnerID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&cgig, 0, sizeof(SPDATA_CREATEGROUPINGROUP));
	cgig.dwSize = sizeof(SPDATA_CREATEGROUPINGROUP);
	cgig.dwParentID = dwParentID;
	cgig.lpName = lpName;
	cgig.lpData = lpData;
	cgig.dwDataSize = dwDataSize;
	cgig.dwFlags = dwFlags;
	cgig.dwGroupOwnerID = dwOwnerID;

	// Call the CreateGroupInGroup method in the SP
	if(CALLBACK_EXISTS(CreateGroupInGroup))
	{
		cgig.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, CreateGroupInGroup, &cgig);
		ENTER_DPLOBBY();
	}
	else 
	{
		// CreateGroupInGroup is required
		DPF_ERR("The Lobby Provider callback for CreateGroupInGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling CreateGroupInGroup in the Lobby Provider, hr = 0x%08x", hr);
		LEAVE_DPLOBBY();
		return hr;
	}


	// Setup the flags to pass to GetGroup
	dwInternalFlags = DPLAYI_PLAYER_PLAYERLOCAL;
	if(dwFlags & DPGROUP_STAGINGAREA)
		dwInternalFlags |= DPLAYI_GROUP_STAGINGAREA;
	if(dwFlags & DPGROUP_HIDDEN)
		dwInternalFlags |= DPLAYI_GROUP_HIDDEN;


	// Add the group to dplay's nametable and put it in our map table
	hr = PRV_CreateAndMapNewGroup(this, lpidGroup, lpName, lpData,
			dwDataSize, dwInternalFlags, cgig.dwGroupID, dwParentID, dwOwnerID);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed creating a new local group, hr = 0x%08x", hr);
		// REVIEW!!!! -- We need to send a message back to the server saying
		// we couldn't complete the deal on our end.
		goto EXIT_CREATEGROUPINGROUP;
	}

	// Take the dplay lock
	ENTER_DPLAY();

	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_CREATEGROUP);
	msg.dwPlayerID = *lpidGroup;

	// Find dplay's internal group struct for the To group
	// Since this is local, send it to all players
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		LEAVE_DPLAY();
		DPF_ERRVAL("Unable to find parent group in nametable, hr = 0x%08x", hr);
		goto EXIT_CREATEGROUPINGROUP;
	}

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(2, "Failed adding CreateGroupInGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

	// Drop the dplay lock
	LEAVE_DPLAY();


EXIT_CREATEGROUPINGROUP:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_CreateGroupInGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteGroupFromGroup"
HRESULT DPLAPI PRV_DeleteGroupFromGroup(LPDPLOBBYI_DPLOBJECT this,
					DWORD dwParentID, DWORD dwGroupID)
{
	SPDATA_DELETEGROUPFROMGROUP		dgd;
	MSG_PLAYERMGMTMESSAGE			msg;
	LPDPLAYI_GROUP					lpGroupTo = NULL;
	HRESULT							hr = DP_OK;


	DPF(7, "Entering DPL_DeleteGroupFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, dwParentID, dwGroupID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA struct
	memset(&dgd, 0, sizeof(SPDATA_DELETEGROUPFROMGROUP));
	dgd.dwSize = sizeof(SPDATA_DELETEGROUPFROMGROUP);
	dgd.dwParentID = dwParentID;
	dgd.dwGroupID = dwGroupID;

	// Call the DeleteGroupFromGroup method in the SP
	if(CALLBACK_EXISTS(DeleteGroupFromGroup))
	{
		dgd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, DeleteGroupFromGroup, &dgd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// DeleteGroupFromGroup is required
		DPF_ERR("The Lobby Provider callback for DeleteGroupFromGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	// If it succeeded, send the DeleteGroupFromGroup message to all local players
	if(SUCCEEDED(hr))
	{
		// Take the dplay lock
		ENTER_DPLAY();

		// Get a pointer to dplay's system group
		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			LEAVE_LOBBY_ALL();
			DPF_ERR("Unable to find system group in nametable, not sending DeleteGroupFromGroup message");
			return DPERR_INVALIDGROUP;
		}

		// Now build the system message (at least the parts we need)
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEGROUPFROMGROUP);
		msg.dwPlayerID = dwGroupID;
		msg.dwGroupID = dwParentID;

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding DeleteGroupFromGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}

		// Drop the dplay lock
		LEAVE_DPLAY();
	}
	else
	{
		DPF_ERRVAL("Failed calling DeleteGroupFromGroup in the Lobby Provider, hr = 0x%08x", hr);
	}

	// The dplay InternalDeletePlayerFromGroup code will take care of the rest of
	// the internal cleanup (nametable, players, etc.), so we can just return
	// from here.

	LEAVE_DPLOBBY();
	return hr;

} // PRV_DeleteGroupFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DoSubgroupsContainLocalPlayers"
BOOL PRV_DoSubgroupsContainLocalPlayers(LPDPLAYI_GROUP lpGroup,
		BOOL bIncludeGroup)
{
	LPDPLAYI_GROUPNODE		lpGroupnode = NULL;
	LPDPLAYI_SUBGROUP		lpSubgroup = NULL;


	DPF(7, "Entering PRV_DoSubgroupsContainLocalPlayers");
	DPF(9, "Parameters: 0x%08x, %lu", lpGroup, bIncludeGroup);

	ASSERT(lpGroup);

	// Figure out how many local players are in this group.  If it's
	// nonzero, just return true from this function.  If the bIncludeGroup
	// parameter is set to FALSE, then don't look at the group passed in
	lpGroupnode = FindPlayerInGroupList(lpGroup->pSysPlayerGroupnodes,
					lpGroup->lpDP->pSysPlayer->dwID);
	if(lpGroupnode && (lpGroupnode->nPlayers > 0) && bIncludeGroup)
		return TRUE;	

	// Walk the list of subgroups
	lpSubgroup = lpGroup->pSubgroups;
	while(lpSubgroup)
	{
		// We're going recursive here to do the entire heirarchy
		// Check out any of it's subgroups
		if((!(lpSubgroup->dwFlags & DPGROUP_SHORTCUT)) &&
			(PRV_DoSubgroupsContainLocalPlayers(lpSubgroup->pGroup, TRUE)))
			return TRUE;
		else
			lpSubgroup = lpSubgroup->pNextSubgroup;
		
	} // while subgroups

	return FALSE;

} // PRV_DoSubgroupsContainLocalPlayers



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AreSubgroupsShortcuts"
BOOL PRV_AreSubgroupsShortcuts(LPDPLAYI_GROUP lpGroup)
{
	LPDPLAYI_SUBGROUP		lpSubgroup = NULL;


	DPF(7, "Entering PRV_AreSubgroupsShortcuts");
	DPF(9, "Parameters: 0x%08x", lpGroup);

	ASSERT(lpGroup);

	// If the group is one of the following, then we want to return TRUE so
	// it doesn't get nuked:
	// 1) Root group, nGroups > 0
	// 2) Root group, hidden, nGroups = 0
	// 2) Non-root group, nGroups > 1
	// Otherwise, we can check it's subgroups and return FALSE as appropriate
	if(((lpGroup->dwIDParent == 0) && ((lpGroup->nGroups > 0) ||
		(!(lpGroup->dwFlags & DPLAYI_GROUP_HIDDEN)) && (lpGroup->nGroups == 0))) ||
		((lpGroup->dwIDParent != 0) && (lpGroup->nGroups > 1)))
		return TRUE;	

	// Walk the list of subgroups
	lpSubgroup = lpGroup->pSubgroups;
	while(lpSubgroup)
	{
		// We're going recursive here to do the entire heirarchy
		// Check out any of it's subgroups
		if(PRV_AreSubgroupsShortcuts(lpSubgroup->pGroup))
			return TRUE;
		else
			lpSubgroup = lpSubgroup->pNextSubgroup;
		
	} // while subgroups

	return FALSE;

} // PRV_AreSubgroupsShortcuts



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyGroupAndParents"
void PRV_DestroyGroupAndParents(LPDPLOBBYI_DPLOBJECT this,
		LPDPLAYI_GROUP lpGroup, LPDPLAYI_GROUP lpStopParent)
{
	LPDPLAYI_GROUPNODE			lpGroupnode = NULL;
	LPDPLAYI_GROUP				lpParentGroup = NULL;
	SPDATA_DESTROYREMOTEGROUP	dg;
	DPID						dpidParent;
	HRESULT						hr;


	DPF(7, "Entering PRV_DestroyGroupAndParents");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, lpGroup, lpStopParent);

	ASSERT(lpGroup);

	// Now we need to decide if this is the last group this group was in.  If
	// it is, then we need to destroy the group as well, and remove them from
	// our map table.  Of course, only destroy the group if it is a remote group.
	// ALSO, we need to walk the heirarchy backward (up the tree) to the root
	// node and delete all groups that were only created to get to our shortcut.
	if(!(lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// Walk our parental heirarchy until we reach a a root group.
		dpidParent = lpGroup->dwIDParent;
		while(dpidParent)
		{
			// Get dplay's internal group structures
			lpParentGroup = GroupFromID(this->lpDPlayObject, dpidParent);
			if(!lpParentGroup)
			{
				ASSERT(FALSE);
				DPF_ERRVAL("Unable to find group in nametable, dpidGroup = %lu", dpidParent);
				return;
			}

			// If there are any local players in the parent group, we don't want to
			// destroy it or any of it's subgroups (since players in the group will
			// be able to see subgroups)
			lpGroupnode = FindPlayerInGroupList(lpParentGroup->pSysPlayerGroupnodes,
					this->lpDPlayObject->pSysPlayer->dwID);
			if((lpGroupnode) && (lpGroupnode->nPlayers > 0))
				return;

			// Make sure we haven't reached our stop parent group if the caller
			// passed one in.  This will keep us from recursively destroying
			// a subgroup's parent, which we might be spinning on, deleting all
			// of it's subgroups.
			if(lpStopParent && (lpStopParent == lpParentGroup))
				return;

			// Destroy the subgroups
			PRV_DestroySubgroups(this, lpParentGroup, TRUE);

			// Get the next parent
			dpidParent = lpParentGroup->dwIDParent;
		}

		// See if we processed any parents, or if we already have a root
		// group.  If lpParentGroup is NULL, we have a root group, so just
		// stuff our group pointer in the parent group pointer
		if(!lpParentGroup)
			lpParentGroup = lpGroup;
		
		// Now see if our root group is hidden, and if it doesn't contain any
		// references, then we want to destroy it as well.
		if((!PRV_DoSubgroupsContainLocalPlayers(lpParentGroup, TRUE)) &&
			(!PRV_AreSubgroupsShortcuts(lpParentGroup)) &&
			(lpParentGroup->dwFlags & DPLAYI_GROUP_HIDDEN))
		{
			// Setup the SPDATA struct for DestroyRemoteGroup
			memset(&dg, 0, sizeof(SPDATA_DESTROYREMOTEGROUP));
			dg.dwSize = sizeof(SPDATA_DESTROYREMOTEGROUP);
			dg.dwGroupID = lpParentGroup->dwID;

			// Call our internal remote create
			hr = DPLP_DestroyGroup((LPDPLOBBYSP)this->lpInterfaces, &dg);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed destroying remote root group, hr = 0x%08x", hr);
			}
		}
	}

} // PRV_DestroyGroupAndParents



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyRemoteShortcutsForExitingPlayer"
void PRV_DestroyRemoteShortcutsForExitingPlayer(LPDPLOBBYI_DPLOBJECT this,
				LPDPLAYI_GROUP lpGroup, DWORD dwGroupID)
{
	SPDATA_DELETEREMOTEGROUPFROMGROUP	drgd;
	LPDPLAYI_SUBGROUP		lpSubgroup = NULL;
	LPDPLAYI_SUBGROUP		lpNextSubgroup = NULL;
	HRESULT					hr;


	DPF(7, "Entering PRV_DestroyRemoteShortcutsForExitingPlayer");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu", this, lpGroup, dwGroupID);

	ASSERT(lpGroup);

	// Setup the SPDATA_DELETEREMOTEPLAYERFROMGROUP data struct
	memset(&drgd, 0, sizeof(SPDATA_DELETEREMOTEGROUPFROMGROUP));
	drgd.dwSize = sizeof(SPDATA_DELETEREMOTEGROUPFROMGROUP);
	drgd.dwParentID = dwGroupID;

	// Walk the list of subgroups, destroying all remote shortcuts
	lpSubgroup = lpGroup->pSubgroups;
	while(lpSubgroup)
	{
		// Save the next subgroup
		lpNextSubgroup = lpSubgroup->pNextSubgroup;

		// Make sure the group is remote and that this is really
		// a shortcut and not a child
		if(((lpSubgroup->dwFlags & DPGROUP_SHORTCUT)) &&
			(!(lpSubgroup->pGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)))
		{
			// Get the subgroup's lobby ID
			drgd.dwGroupID = lpSubgroup->pGroup->dwID;
			
			// Call our internal DeleteGroupFromGroup routine to delete
			// the shortcut and send the appropriate messages
			// NOTE: It is imperative that we pass in a pointer to the
			// group who's shortcuts we are removing as the stop parent.
			// If we do not, we run the risk of deleting it or one of
			// it's children that we haven't yet looped through, which
			// will result in a crash as we continue to walk the
			// subgroup list.
			hr = PRV_DeleteRemoteGroupFromGroup(this, &drgd, TRUE, lpGroup);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed deleting remote group from group, hr = 0x%08x", hr);
			}
		}


		// Go to the next one
		lpSubgroup = lpNextSubgroup;
	}

} // PRV_DestroyRemoteShortcutsForExitingPlayer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyRemotePlayersForExitingPlayer"
void PRV_DestroyRemotePlayersForExitingPlayer(LPDPLOBBYI_DPLOBJECT this,
				LPDPLAYI_GROUP lpGroup, DWORD dwGroupID)
{
	SPDATA_DELETEREMOTEPLAYERFROMGROUP	drpd;
	LPDPLAYI_GROUPNODE					lpGroupnode = NULL;
	LPDPLAYI_GROUPNODE					lpNextGroupnode = NULL;
	HRESULT								hr;


	DPF(7, "Entering PRV_DestroyRemotePlayersForExitingPlayer");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpGroup);

	ASSERT(lpGroup);

	// Setup the SPDATA_DELETEREMOTEPLAYERFROMGROUP data struct
	memset(&drpd, 0, sizeof(SPDATA_DELETEREMOTEPLAYERFROMGROUP));
	drpd.dwSize = sizeof(SPDATA_DELETEREMOTEPLAYERFROMGROUP);
	drpd.dwGroupID = dwGroupID;
	
	// Walk the list of groupnodes, deleting remote players that are not in
	// any other groups
	lpGroupnode = lpGroup->pGroupnodes;
	while(lpGroupnode)
	{
		// Save our next groupnode pointer since our current groupnode
		// will be gone when we come back from the delete
		lpNextGroupnode = lpGroupnode->pNextGroupnode;

		// Delete the player from the group if it's remote and then
		// destroy the player if he is in no other groups
		if (!(lpGroupnode->pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			// Get the remote player's ID
			drpd.dwPlayerID = lpGroupnode->pPlayer->dwID;

			// Delete the player from the group
			hr = PRV_DeleteRemotePlayerFromGroup(this, &drpd, TRUE);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed deleting remote player from group, hr = 0x%08x", hr);
			}
		}

		lpGroupnode = lpNextGroupnode;

	} // while

} // PRV_DestroyRemotePlayersForExitingPlayer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroySubgroups"
void PRV_DestroySubgroups(LPDPLOBBYI_DPLOBJECT this, LPDPLAYI_GROUP lpGroup,
		BOOL bRemoteOnly)
{
	LPDPLAYI_SUBGROUP			lpSubgroup = NULL;
	LPDPLAYI_SUBGROUP			lpNextSubgroup = NULL;
	SPDATA_DESTROYREMOTEGROUP	dgd;
	SPDATA_DELETEREMOTEGROUPFROMGROUP	drg;
	HRESULT						hr;


	DPF(7, "Entering PRV_DestroySubgroups");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu", this, lpGroup, bRemoteOnly);

	ASSERT(lpGroup);

	// Setup the static part of the SPDATA structures
	memset(&dgd, 0, sizeof(SPDATA_DESTROYREMOTEGROUP));
	dgd.dwSize = sizeof(SPDATA_DESTROYREMOTEGROUP);

	memset(&drg, 0, sizeof(SPDATA_DELETEREMOTEGROUPFROMGROUP));
	drg.dwSize = sizeof(SPDATA_DELETEREMOTEGROUPFROMGROUP);
	drg.dwParentID = lpGroup->dwID;

	// Walk the list of subgroups
	lpSubgroup = lpGroup->pSubgroups;
	while(lpSubgroup)
	{
		// Save the next subgroup
		lpNextSubgroup = lpSubgroup->pNextSubgroup;
		
		// Make sure it's a remote group if the flag is set
		if((bRemoteOnly) &&
			(lpSubgroup->pGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			lpSubgroup = lpNextSubgroup;
			continue;
		}
		
		// If the subgroup doesn't contain any local players,
		// nor do any of it's subgroups, then destroy it
		if((!bRemoteOnly) || 
			((!PRV_DoSubgroupsContainLocalPlayers(lpSubgroup->pGroup, TRUE)) &&
			(!PRV_AreSubgroupsShortcuts(lpSubgroup->pGroup))))
		{
			// If the group is a shortcut, just delete the link.  If it's a child,
			// destroy the subgroup.
			if(lpSubgroup->dwFlags & DPGROUP_SHORTCUT)
			{
				// Finish setting up the SPDATA structure
				drg.dwGroupID = lpSubgroup->pGroup->dwID;
	
				// Destroy the subgroup
				hr = DPLP_DeleteGroupFromGroup((LPDPLOBBYSP)this->lpInterfaces, &drg);
				if(FAILED(hr))
				{
					DPF_ERRVAL("Failed deleting remote group from group, hr = 0x%08x", hr);
				}
			}
			else
			{
				// Finish setting up the SPDATA structure
				dgd.dwGroupID = lpSubgroup->pGroup->dwID;
	
				// Destroy the subgroup
				hr = DPLP_DestroyGroup((LPDPLOBBYSP)this->lpInterfaces, &dgd);
				if(FAILED(hr))
				{
					DPF_ERRVAL("Failed destroying remote group, hr = 0x%08x", hr);
				}
			}
		}

		lpSubgroup = lpNextSubgroup;

	} // while lpSubgroups

} // PRV_DestroySubgroups



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeletePlayerFromGroup"
HRESULT DPLAPI PRV_DeletePlayerFromGroup(LPDPLOBBYI_DPLOBJECT this,
					DWORD dwGroupID, DWORD dwPlayerID)
{
	SPDATA_DELETEPLAYERFROMGROUP		dpd;
	MSG_PLAYERMGMTMESSAGE				msg;
	LPDPLAYI_PLAYER						lpPlayer = NULL;
	LPDPLAYI_GROUP						lpGroup =NULL;
	LPDPLAYI_GROUPNODE					lpGroupnode = NULL;
	HRESULT								hr = DP_OK;


	DPF(7, "Entering PRV_DeletePlayerFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, dwGroupID, dwPlayerID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Take the dplay lock since we'll be looking at a dplay internal struct
	ENTER_DPLAY();

	// Make sure the player is a local player, otherwise return AccessDenied
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwPlayerID);
	if(!lpPlayer)
	{
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDGROUP;
		goto EXIT_DELETEPLAYERFROMGROUP;
	}

	if(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		DPF_ERR("Cannot delete a remote player from a group");
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_DELETEPLAYERFROMGROUP;
	}
	
	// Drop the dplay lock since we're done
	LEAVE_DPLAY();

	// Setup our SPDATA struct
	memset(&dpd, 0, sizeof(SPDATA_DELETEPLAYERFROMGROUP));
	dpd.dwSize = sizeof(SPDATA_DELETEPLAYERFROMGROUP);
	dpd.dwGroupID = dwGroupID;
	dpd.dwPlayerID = dwPlayerID;

	// Call the DeletePlayerFromGroup method in the SP
	if(CALLBACK_EXISTS(DeletePlayerFromGroup))
	{
		dpd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, DeletePlayerFromGroup, &dpd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// DeletePlayerFromGroup is required
		DPF_ERR("The Lobby Provider callback for DeletePlayerFromGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling DeletePlayerFromGroup in the Lobby Provider, hr = 0x%08x", hr);
		LEAVE_DPLOBBY();
		return hr;
	}

	// Take the dplay lock
	ENTER_DPLAY();

	// We need to remove all other players in the group and send the appropriate
	// message to the player we are about to delete because he won't see the
	// system messages for them once he leaves the group.  However, if any other
	// local players are in the group, we don't want to remove the remote players
	// from the nametable because the other local players need to see them.

	// Get a pointer to dplay's internal group structure
	lpGroup = GroupFromID(this->lpDPlayObject, dwGroupID);
	if(!lpGroup)
	{
		DPF_ERRVAL("Unable to find group in nametable, idGroup = %lu", dwGroupID);
		hr = DPERR_INVALIDGROUP;
		goto EXIT_DELETEPLAYERFROMGROUP;
	}

	// Get a pointer to dplay's internal player structure
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwPlayerID);
	if(!lpPlayer)
	{
		DPF_ERRVAL("Unable to find player in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_DELETEPLAYERFROMGROUP;
	}

	// We need to send a DeletePlayerFromGroup message to the player who
	// was deleted since he won't get the group message once he's gone

	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEPLAYERFROMGROUP);
	msg.dwPlayerID = dwPlayerID;
	msg.dwGroupID = dwGroupID;

	// Call dplay's handleplayermessage function to put the message in the queue
	hr = HandlePlayerMessage(lpPlayer, (LPBYTE)&msg,
			sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed adding message to player's receive queue from lobby, hr = 0x%08x", hr);
		// Set the hresult back to DP_OK since only the message failed
		hr = DP_OK;
	}

	// Figure out how many local players are in this group.  If it's only 1,
	// then delete all the remote players.
	lpGroupnode = FindPlayerInGroupList(lpGroup->pSysPlayerGroupnodes,
					this->lpDPlayObject->pSysPlayer->dwID);
	if((!lpGroupnode) || (lpGroupnode->nPlayers == 0))
	{
		// Destroy all remote players that are only in this group
		PRV_DestroyRemotePlayersForExitingPlayer(this, lpGroup, dwGroupID);

		// Destroy all the remote shortcut groups, making sure we are
		// not in them, and removing their entire parental heirarchy
		PRV_DestroyRemoteShortcutsForExitingPlayer(this, lpGroup, dwGroupID);

		// Destroy all remote subgroups of this group, making sure we're
		// not in them for some reason
		PRV_DestroySubgroups(this, lpGroup, TRUE);

		// Destroy the group we're leaving if it is remote as well as it's
		// parental chain.
		PRV_DestroyGroupAndParents(this, lpGroup, NULL);
	}


EXIT_DELETEPLAYERFROMGROUP:

	// The dplay InternalDeletePlayerFromGroup code will take care of the rest of
	// the internal cleanup (nametable, players, etc.), so we can just return
	// from here.

	LEAVE_LOBBY_ALL();
	return hr;

} // PRV_DeletePlayerFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyGroup"
HRESULT DPLAPI PRV_DestroyGroup(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID)
{
	SPDATA_DESTROYGROUP		dg;
	LPDPLAYI_GROUP			lpGroup = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_DestroyGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, dwLobbyID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA struct
	memset(&dg, 0, sizeof(SPDATA_DESTROYGROUP));
	dg.dwSize = sizeof(SPDATA_DESTROYGROUP);
	dg.dwGroupID = dwLobbyID;

	// Call the DestroyGroup method in the SP
	if(CALLBACK_EXISTS(DestroyGroup))
	{
		dg.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, DestroyGroup, &dg);
		ENTER_DPLOBBY();
	}
	else 
	{
		// DestroyGroup is required
		DPF_ERR("The Lobby Provider callback for DestroyGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling DestroyGroup in the Lobby Provider, hr = 0x%08x", hr);
		LEAVE_DPLOBBY();
		return hr;
	}

	// Take the lock
	ENTER_DPLAY();

	// So, get dplay's internal group structure
	lpGroup = GroupFromID(this->lpDPlayObject, dwLobbyID);
	if(!lpGroup)
	{
		// This shouldn't ever happen.  If the groups isn't in the nametable,
		// we should never get this far.
		ASSERT(FALSE);
		LEAVE_LOBBY_ALL();
		DPF_ERRVAL("Unable to find group in nametable, dpidGroup = %lu", dwLobbyID);
		return DPERR_INVALIDGROUP;
	}

	// Send messages to remove shortcuts to this group (since dplay won't
	// do it for us)
	PRV_SendDeleteShortcutMessageForExitingGroup(this, lpGroup);

	// Destroy all the subgroups and remote players
	PRV_RemoveSubgroupsAndPlayersFromGroup(this, lpGroup, dwLobbyID, FALSE);

	// Drop the dplay lock since we're done mucking around with it's structures
	LEAVE_DPLAY();

	// Broadcast the DestroyGroup message
	hr = PRV_BroadcastDestroyGroupMessage(this, dwLobbyID);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed to send DestroyGroup message to local players, hr = 0x%08x", hr);
	}

	// The dplay InternalDestroyGroup code will take care of the rest of
	// the internal cleanup (nametable, players, etc.), so we can just return
	// from here.

	LEAVE_DPLOBBY();
	return hr;

} // PRV_DestroyGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetGroupConnectionSettings"
HRESULT PRV_GetGroupConnectionSettings(LPDIRECTPLAY lpDP, DWORD dwFlags,
			DWORD dwGroupID, LPVOID lpData, LPDWORD lpdwSize) 
{
	SPDATA_GETGROUPCONNECTIONSETTINGS	gcs;
	LPDPLOBBYI_DPLOBJECT				this = NULL;
    LPDPLAYI_DPLAY						lpDPObject = NULL;
	LPDPLAYI_GROUP						lpGroup = NULL;
    HRESULT								hr = DP_OK;


	DPF(7, "Entering PRV_GetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, dwGroupID, lpData, lpdwSize);

    TRY
    {
        lpDPObject = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( lpDPObject );
		if (FAILED(hr))
		{
			DPF_ERRVAL("Bad DPlay interface pointer - hr = 0x%08lx\n",hr);
			return hr;
        }
    
		if(!IS_LOBBY_OWNED(lpDPObject))
		{
			DPF_ERR("GetGroupConnectionSettings is only supported for lobby connections");
			return DPERR_UNSUPPORTED;
		}

		this = lpDPObject->lpLobbyObject;
		if(!VALID_DPLOBBY_PTR(this))
		{
			DPF_ERR("Bad DPLobby object");
			return DPERR_INVALIDOBJECT;
		}

		lpGroup = GroupFromID(lpDPObject, dwGroupID);
        if (!VALID_DPLAY_GROUP(lpGroup)) 
        {
			DPF_ERR("Invalid group id");
            return DPERR_INVALIDGROUP;
        }

		if( !VALID_DWORD_PTR( lpdwSize ) )
		{
			DPF_ERR("lpdwSize was not a valid dword pointer!");
			return DPERR_INVALIDPARAMS;
		}

		if(lpData)
		{
			if( !VALID_WRITE_PTR(lpData, *lpdwSize) )
			{
				DPF_ERR("lpData is not a valid output buffer of the size specified in *lpdwSize");
				return DPERR_INVALIDPARAMS;
			}
		}

		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            return DPERR_INVALIDFLAGS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&gcs, 0, sizeof(SPDATA_GETGROUPCONNECTIONSETTINGS));
	gcs.dwSize = sizeof(SPDATA_GETGROUPCONNECTIONSETTINGS);
	gcs.dwFlags = dwFlags;
	gcs.dwGroupID = dwGroupID;
	gcs.lpdwBufferSize = lpdwSize;
	gcs.lpBuffer = lpData;

	// Call the GetGroupConnectionSettings method in the SP
	if(CALLBACK_EXISTS(GetGroupConnectionSettings))
	{
		gcs.lpISP = PRV_GetDPLobbySPInterface(this);
	    
		// Drop the dplay lock since we are going to send a guaranteed message
		LEAVE_LOBBY_ALL();

		hr = CALL_LP(this, GetGroupConnectionSettings, &gcs);

		// Take the lock back
		ENTER_LOBBY_ALL();
	}
	else 
	{
		// GetGroupConnectionSettings is required
		DPF_ERR("The Lobby Provider callback for GetGroupConnectionSettings doesn't exist -- it's required");
		ASSERT(FALSE);
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr) && (hr != DPERR_BUFFERTOOSMALL))
	{
		DPF_ERRVAL("Failed calling GetGroupConnectionSettings in the Lobby Provider, hr = 0x%08x", hr);
	}

	return hr;

} // PRV_GetGroupConnectionSettings


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_GetGroupConnectionSettings"
HRESULT DPLAPI DPL_GetGroupConnectionSettings(LPDIRECTPLAY lpDP, 
		DWORD dwFlags, DPID idGroup, LPVOID lpData, LPDWORD lpdwSize)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_GetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, idGroup, lpData, lpdwSize);

	ENTER_LOBBY_ALL();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_GetGroupConnectionSettings(lpDP, dwFlags, idGroup,
							lpData,	lpdwSize);

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_GetGroupConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetGroupData"
HRESULT DPLAPI PRV_GetGroupData(LPDPLOBBYI_DPLOBJECT this, DWORD dwGroupID,
					LPVOID lpData, LPDWORD lpdwDataSize)
{
	SPDATA_GETGROUPDATA		ggd;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_GetGroupData");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dwGroupID, lpData, lpdwDataSize);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&ggd, 0, sizeof(SPDATA_GETGROUPDATA));
	ggd.dwSize = sizeof(SPDATA_GETGROUPDATA);
	ggd.dwGroupID = dwGroupID;
	ggd.lpdwDataSize = lpdwDataSize;
	ggd.lpData = lpData;

	// Call the GetGroupData method in the SP
	if(CALLBACK_EXISTS(GetGroupData))
	{
		ggd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, GetGroupData, &ggd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// GetGroupData is required
		DPF_ERR("The Lobby Provider callback for GetGroupData doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling GetGroupData in the Lobby Provider, hr = 0x%08x", hr);
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_GetGroupData



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_GetGroupOwner"
HRESULT DPAPI DPL_GetGroupOwner(LPDIRECTPLAY lpDP, DWORD dwGroupID,
		LPDPID lpidOwner)
{
	LPDPLAYI_DPLAY		this;
	LPDPLAYI_GROUP		lpGroup = NULL;
	HRESULT				hr;


	DPF(7, "Entering DPL_GetGroupOwner");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwGroupID, lpidOwner);

	ENTER_DPLAY();
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			LEAVE_DPLAY();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

		lpGroup = GroupFromID(this, dwGroupID);
	    if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == dwGroupID)) 
	    {
			LEAVE_DPLAY();
			DPF_ERR("Invalid group id");
	        return DPERR_INVALIDGROUP;
	    }

		if (!VALID_DWORD_PTR(lpidOwner))
		{
			LEAVE_DPLAY();
			DPF_ERR("Invalid owner id pointer");
			return DPERR_INVALIDPARAMS;	
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// This method is only valid in lobby session
	if(IS_LOBBY_OWNED(this))
	{	
		*lpidOwner = lpGroup->dwOwnerID;
	}
	else
	{
		DPF_ERR("GetGroupOwner is only supported for lobby sessions");
		hr = DPERR_UNSUPPORTED;
	}

	LEAVE_DPLAY();
	return hr;

} // DPL_GetGroupOwner



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetGroupConnectionSettings"
HRESULT PRV_SetGroupConnectionSettings(LPDIRECTPLAY lpDP, DWORD dwFlags,
				DWORD dwGroupID, LPDPLCONNECTION lpConn, BOOL bAnsi) 
{
	SPDATA_SETGROUPCONNECTIONSETTINGS	scs;
	LPDPLOBBYI_DPLOBJECT				this = NULL;
    LPDPLAYI_DPLAY						lpDPObject = NULL;
	LPDPLAYI_GROUP						lpGroup = NULL;
    HRESULT								hr = DP_OK;


	DPF(7, "Entering PRV_SetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu",
			lpDP, dwFlags, dwGroupID, lpConn, bAnsi);

    TRY
    {
        lpDPObject = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( lpDPObject );
		if (FAILED(hr))
		{
			DPF_ERRVAL("Bad DPlay interface pointer - hr = 0x%08lx\n",hr);
			return hr;
        }
    
		if(!IS_LOBBY_OWNED(lpDPObject))
		{
			DPF_ERR("SetGroupConnectionSettings is only supported for lobby connections");
			return DPERR_UNSUPPORTED;
		}

		this = lpDPObject->lpLobbyObject;
		if(!VALID_DPLOBBY_PTR(this))
		{
			DPF_ERR("Bad DPLobby object");
			return DPERR_INVALIDOBJECT;
		}

		lpGroup = GroupFromID(lpDPObject, dwGroupID);
        if (!VALID_DPLAY_GROUP(lpGroup)) 
        {
			DPF_ERR("Invalid group id");
            return DPERR_INVALIDGROUP;
        }

		hr = PRV_ValidateDPLCONNECTION(lpConn, FALSE);
		if(FAILED(hr))
		{
			DPF_ERR("Invalid DPLCONNECTION structure");
			return hr;
		}

		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            return DPERR_INVALIDFLAGS;
		}

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&scs, 0, sizeof(SPDATA_SETGROUPCONNECTIONSETTINGS));
	scs.dwSize = sizeof(SPDATA_SETGROUPCONNECTIONSETTINGS);
	scs.dwFlags = dwFlags;
	scs.dwGroupID = dwGroupID;
	scs.lpConn = lpConn;

	// Ensure that the guidInstance in the DPLCONNECTION structure is NULL
	lpConn->lpSessionDesc->guidInstance = GUID_NULL;

	// Call the SetGroupConnectionSettings method in the SP
	if(CALLBACK_EXISTS(SetGroupConnectionSettings))
	{
		scs.lpISP = PRV_GetDPLobbySPInterface(this);
	    
		// Drop the dplay lock since we're sending a guaranteed message
		LEAVE_LOBBY_ALL();

		hr = CALL_LP(this, SetGroupConnectionSettings, &scs);

		// Take the lock back
		ENTER_LOBBY_ALL();
	}
	else 
	{
		// SetGroupConnectionSettings is required
		DPF_ERR("The Lobby Provider callback for SetGroupConnectionSettings doesn't exist -- it's required");
		ASSERT(FALSE);
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling SetGroupConnectionSettings in the Lobby Provider, hr = 0x%08x", hr);
	}

	return hr;

} // PRV_SetGroupConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SetGroupConnectionSettings"
HRESULT DPLAPI DPL_SetGroupConnectionSettings(LPDIRECTPLAY lpDP, 
				DWORD dwFlags, DPID idGroup, LPDPLCONNECTION lpConn)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_SetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, idGroup, lpConn);

	ENTER_LOBBY_ALL();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_SetGroupConnectionSettings(lpDP, dwFlags, idGroup, lpConn, FALSE);

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_SetGroupConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetGroupData"
HRESULT DPLAPI PRV_SetGroupData(LPDPLOBBYI_DPLOBJECT this, DWORD dwGroupID,
					LPVOID lpData, DWORD dwDataSize, DWORD dwFlags)
{
	SPDATA_SETGROUPDATA		sgd;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_SetGroupData");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, %lu, 0x%08x",
			this, dwGroupID, lpData, dwDataSize, dwFlags);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&sgd, 0, sizeof(SPDATA_SETGROUPDATA));
	sgd.dwSize = sizeof(SPDATA_SETGROUPDATA);
	sgd.dwGroupID = dwGroupID;
	sgd.dwDataSize = dwDataSize;
	sgd.lpData = lpData;
	sgd.dwFlags = dwFlags;

	// Call the SetGroupData method in the SP
	if(CALLBACK_EXISTS(SetGroupData))
	{
		sgd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, SetGroupData, &sgd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// SetGroupData is required
		DPF_ERR("The Lobby Provider callback for SetGroupData doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SETGROUPDATA;
	}

	// If it succeeded, send the SetGroupData message to our local players
	if(SUCCEEDED(hr))
	{
		hr = PRV_SendDataChangedMessageLocally(this, dwGroupID, lpData, dwDataSize);
	}
	else
	{
		DPF_ERRVAL("Failed calling SetGroupData in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_SETGROUPDATA:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SetGroupData



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetGroupName"
HRESULT DPLAPI PRV_SetGroupName(LPDPLOBBYI_DPLOBJECT this, DWORD dwGroupID,
					LPDPNAME lpName, DWORD dwFlags)
{
	SPDATA_SETGROUPNAME		sgn;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_SetGroupName");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dwGroupID, lpName, dwFlags);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&sgn, 0, sizeof(SPDATA_SETGROUPNAME));
	sgn.dwSize = sizeof(SPDATA_SETGROUPNAME);
	sgn.dwGroupID = dwGroupID;
	sgn.lpName = lpName;
	sgn.dwFlags = dwFlags;

	// Call the SetGroupName method in the SP
	if(CALLBACK_EXISTS(SetGroupName))
	{
		sgn.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, SetGroupName, &sgn);
		ENTER_DPLOBBY();
	}
	else 
	{
		// SetGroupName is required
		DPF_ERR("The Lobby Provider callback for SetGroupName doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SETGROUPNAME;
	}

	// If it succeeded, send the SetGroupName message to our local players
	if(SUCCEEDED(hr))
	{
		hr = PRV_SendNameChangedMessageLocally(this, dwGroupID, lpName, FALSE);
	}
	else
	{
		DPF_ERRVAL("Failed calling SetGroupName in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_SETGROUPNAME:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SetGroupName



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SetGroupOwner"
HRESULT DPLAPI DPL_SetGroupOwner(LPDIRECTPLAY lpDP, DWORD dwGroupID,
		DWORD dwOwnerID)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPLAYI_DPLAY			lpDPlayObject;
	SPDATA_SETGROUPOWNER	sgo;
	LPDPLAYI_PLAYER			lpNewOwner = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	HRESULT					hr = DP_OK;
	DWORD					dwOldOwnerID;


	DPF(7, "Entering DPL_SetGroupOwner");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwGroupID, dwOwnerID);

	ENTER_LOBBY_ALL();
	
    TRY
    {
		lpDPlayObject = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( lpDPlayObject );
		if (FAILED(hr))
		{
			LEAVE_LOBBY_ALL();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

        this = lpDPlayObject->lpLobbyObject;
		if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_LOBBY_ALL();
			return DPERR_INVALIDOBJECT;
        }

	    lpGroup = GroupFromID(lpDPlayObject, dwGroupID);
	    if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == dwGroupID)) 
	    {
			LEAVE_LOBBY_ALL();
			DPF_ERR("Invalid group id");
	        return DPERR_INVALIDGROUP;
	    }

	    // DPID_SERVERPLAYER is valid here
		if(dwOwnerID != DPID_SERVERPLAYER)
		{
			lpNewOwner = PlayerFromID(lpDPlayObject, dwOwnerID);
			if (!VALID_DPLAY_PLAYER(lpNewOwner))
			{
				LEAVE_LOBBY_ALL();
				DPF_ERR("Invalid new owner player id");
				return DPERR_INVALIDPLAYER;
			}
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_LOBBY_ALL();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	

	// do the send
	if(!IS_LOBBY_OWNED(lpDPlayObject))
	{
		DPF_ERR("SetGroupOwner is only supported for lobby sessions");
		hr = DPERR_UNSUPPORTED;
		goto EXIT_SETGROUPOWNER;
	}


	// Setup our SPDATA struct
	memset(&sgo, 0, sizeof(SPDATA_SETGROUPOWNER));
	sgo.dwSize = sizeof(SPDATA_SETGROUPOWNER);
	sgo.dwGroupID = dwGroupID;
	sgo.dwOwnerID = dwOwnerID;

	// Call the SetGroupOwner method in the SP
	if(CALLBACK_EXISTS(SetGroupOwner))
	{
		sgo.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// response (which always happens)
		LEAVE_LOBBY_ALL();
	    hr = CALL_LP(this, SetGroupOwner, &sgo);
		ENTER_LOBBY_ALL();
	}
	else 
	{
		// SetGroupOwner is required
		DPF_ERR("The Lobby Provider callback for SetGroupOwner doesn't exist");
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SETGROUPOWNER;
	}

	// If it succeeded, send the SetGroupOwner message to our local players
	if(SUCCEEDED(hr))
	{
		// Get a pointer to our internal data struct for the group, just in
		// case it changed for some reason while we had dropped the locks
		lpGroup = GroupFromID(this->lpDPlayObject, dwGroupID);
		if(!lpGroup)
		{
			DPF_ERR("Unable to find group in nametable -- local nametable will be incorrect");
		}

		// Save the old owner so we can put it in the message
		dwOldOwnerID = lpGroup->dwOwnerID;
		
		// Change the owner
		lpGroup->dwOwnerID = dwOwnerID;

		// Send a SetGroupOwner message locally
		PRV_SendGroupOwnerMessageLocally(this, dwGroupID, dwOwnerID, dwOldOwnerID);
	}
	else
	{
		DPF_ERRVAL("Failed calling SetGroupOwner in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_SETGROUPOWNER:

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_SetGroupOwner



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_StartSession"
HRESULT DPLAPI DPL_StartSession(LPDIRECTPLAY lpDP, DWORD dwFlags, DWORD dwGroupID)
{
	SPDATA_STARTSESSION		ss;
	LPDPLOBBYI_DPLOBJECT	this = NULL;
	LPDPLAYI_DPLAY			lpDPObject = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_StartSession");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, dwGroupID);

	ENTER_LOBBY_ALL();

    TRY
    {
        lpDPObject = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( lpDPObject );
		if (FAILED(hr))
		{
			DPF_ERRVAL("Bad DPlay interface pointer - hr = 0x%08lx\n",hr);
			goto ERROR_STARTSESSION;
        }
    
		if(!IS_LOBBY_OWNED(lpDPObject))
		{
			DPF_ERR("SetGroupConnectionSettings is only supported for lobby connections");
			hr = DPERR_UNSUPPORTED;
			goto ERROR_STARTSESSION;
		}

		this = lpDPObject->lpLobbyObject;
		if(!VALID_DPLOBBY_PTR(this))
		{
			DPF_ERR("Bad DPLobby object");
			hr = DPERR_INVALIDOBJECT;
			goto ERROR_STARTSESSION;
		}

		if(dwFlags)
		{
			DPF_ERR("Invalid flags");
			hr = DPERR_INVALIDFLAGS;
			goto ERROR_STARTSESSION;
		}

		lpGroup = GroupFromID(lpDPObject, dwGroupID);
        if (!VALID_DPLAY_GROUP(lpGroup)) 
        {
			DPF_ERR("Invalid group id");
            hr = DPERR_INVALIDGROUP;
			goto ERROR_STARTSESSION;
        }

		// Make sure the group is a staging area
		if(!(lpGroup->dwFlags & DPLAYI_GROUP_STAGINGAREA))
		{
			DPF_ERR("StartSession can only be called on a Staging Area");
			hr = DPERR_INVALIDGROUP;
			goto ERROR_STARTSESSION;
		}
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        hr = DPERR_INVALIDPARAMS;
		goto ERROR_STARTSESSION;
    }


	// Setup our SPDATA struct
	memset(&ss, 0, sizeof(SPDATA_STARTSESSION));
	ss.dwSize = sizeof(SPDATA_STARTSESSION);
	ss.dwGroupID = dwGroupID;
	ss.dwFlags = dwFlags;

	// Call the StartSession method in the SP
	if(CALLBACK_EXISTS(StartSession))
	{
		ss.lpISP = PRV_GetDPLobbySPInterface(this);

	    // Drop the dplay lock so we can send a guarateed message
		LEAVE_LOBBY_ALL();

		hr = CALL_LP(this, StartSession, &ss);

		// Take the lock back
		ENTER_LOBBY_ALL();
	}
	else 
	{
		// StartSession is required
		DPF_ERR("The Lobby Provider callback for StartSession doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto ERROR_STARTSESSION;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling StartSession in the Lobby Provider, hr = 0x%08x", hr);
	}

ERROR_STARTSESSION:

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_StartSession



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateAndMapNewGroup"
HRESULT PRV_CreateAndMapNewGroup(LPDPLOBBYI_DPLOBJECT this,
			DPID * lpdpid, LPDPNAME lpName, LPVOID lpData,
			DWORD dwDataSize, DWORD dwFlags, DWORD dwLobbyID,
			DPID dpidParent, DWORD dwOwnerID)
{
	LPDPLAYI_GROUP		lpGroup = NULL, lpSysGroup = NULL;
	HRESULT				hr;
	DPID				dpidGroup, dpidSysPlayer;


	// Take the dplay lock
	ENTER_DPLAY();

	// Make sure the lobby ID is valid
	if(!IsValidLobbyID(dwLobbyID))
	{
		DPF_ERRVAL("ID %lu is reserved, cannot create new player", dwLobbyID);
		goto EXIT_CREATEANDMAPNEWGROUP;
	}

	// If this is a remote player, we need allocate a new nametable entry
	// for them and set the correct system player ID
	if(!(dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// Allocate a new ID for the player
		hr = NS_AllocNameTableEntry(this->lpDPlayObject, &dpidGroup);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to allocate new nametable id, hr = 0x%08x", hr);
			goto EXIT_CREATEANDMAPNEWGROUP;
		}

		// Make sure we have a lobby system player (for all remote players
		// & groups). If we don't then allocate a new one.
		if(!(this->dpidSysPlayer))
		{
			hr = PRV_CreateAndMapNewPlayer(this, &dpidSysPlayer, NULL, NULL,
					NULL, 0, DPLAYI_PLAYER_SYSPLAYER,
					DPID_LOBBYREMOTESYSTEMPLAYER, TRUE);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Unable to create lobby system player, hr = 0x%08x", hr);
				ASSERT(FALSE);
				goto EXIT_CREATEANDMAPNEWGROUP;
			}

			// Set the lobby system player ID pointer to the new ID
			this->dpidSysPlayer = dpidSysPlayer;
		}
	}

	// Get a group struct for the group (if it's local, this will add it
	// to the nametable.  If it's remote, we need to add it below)
	hr = GetGroup(this->lpDPlayObject, &lpGroup, lpName, lpData,
					dwDataSize, dwFlags, dpidParent, dwLobbyID);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed trying to add group to the nametable, hr = 0x%08x", hr);
		goto EXIT_CREATEANDMAPNEWGROUP;
	}

	// Fixup the group's owner
	lpGroup->dwOwnerID = dwOwnerID;
	
	// If the group is remote, set the group's ID to the new one we
	// allocated and then set the system group ID to the lobby system group
	if(!(dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// 
		lpGroup->dwIDSysPlayer = this->dpidSysPlayer;

		// Add the group to the nametable
		hr = AddItemToNameTable(this->lpDPlayObject, (DWORD_PTR)lpGroup,
				&dpidGroup, TRUE, dwLobbyID);
	    if (FAILED(hr)) 
	    {
			DPF_ERRVAL("Unable to add new group to the nametable, hr = 0x%08x", hr);
			ASSERT(FALSE);
			goto EXIT_CREATEANDMAPNEWGROUP;
	    }

		// Set the group's ID
		lpGroup->dwID = dpidGroup;
	}

	// Set the output dpid pointer
	*lpdpid = lpGroup->dwID;

EXIT_CREATEANDMAPNEWGROUP:

	LEAVE_DPLAY();
	return hr;

} // PRV_CreateAndMapNewGroup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=w32

#SYNCHRONIZE_BLOCK=1

TARGETNAME=dplobby
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=..\..\..\dplay\dplay;\
		..\..\..\dplay\common;\
		..\..\..\misc; \

#SYNCHRONIZE_DRAIN=1

C_DEFINES=$(C_DEFINES) -DWINVER=0x0400

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

C_DEFINES=$(C_DEFINES) -D_NO_COM -DUNICODE -D_UNICODE -DNEW_DPF -DSECURITY_WIN32


NTPROFILEINPUT=yes


SOURCES= \
        ..\create.c \
        ..\dplenum.c \
        ..\dplgame.c \
        ..\dplobby.c \
        ..\dplobbya.c \
        ..\dplpack.c \
        ..\dplshare.c \
        ..\dplsp.c \
        ..\dplunk.c \
        ..\group.c \
        ..\player.c \
        ..\server.c \
        ..\session.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\player.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       player.c
 *  Content:	Methods for player management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	2/27/97		myronth	Created it
 *	3/17/97		myronth	Create/DestroyPlayer, Removed unnecessary Enum fn's
 *	3/21/97		myronth	SetPlayerName, Get/SetPlayerData, Removed more
 *						unnecessary functions
 *	3/25/97		myronth	Fixed GetPlayer prototype (1 new parameter)
 *	3/31/97		myronth	Removed dead code, Implemented Send, Added
 *						CreateAndMapNewPlayer function
 *	4/3/97		myronth	Changed CALLSP macro to CALL_LP
 *	4/10/97		myronth	Added support for GetPlayerCaps
 *	5/8/97		myronth	Drop lobby lock when calling LP, Propagate player's
 *						receive event on CreatePlayer call
 *	5/12/97		myronth	Handle remote players properly, create a lobby
 *						system player for all remote players & groups
 *	5/17/97		myronth	SendChatMessage
 *	5/20/97		myronth	Made AddPlayerToGroup & DeletePlayerFromGroup return
 *						DPERR_ACCESSDENIED on remote players (#8679),
 *						Fixed a bunch of other lock bugs, Changed debug levels
 *	6/3/97		myronth	Added support for player flags in CreatePlayer
 *	9/29/97		myronth	Send local SetPlayerName/Data msgs after call to
 *						lobby server succeeds (#12554)
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreatePlayer"
HRESULT DPLAPI PRV_CreatePlayer(LPDPLOBBYI_DPLOBJECT this, LPDPID lpidPlayer,
						LPDPNAME lpName, HANDLE hEvent, LPVOID lpData,
						DWORD dwDataSize, DWORD dwFlags)
{
	SPDATA_CREATEPLAYER		cp;
	HRESULT					hr = DP_OK;
	DWORD					dwPlayerFlags;


	DPF(7, "Entering PRV_CreatePlayer");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu, 0x%08x",
			this, lpidPlayer, lpName, hEvent, lpData, dwDataSize, dwFlags);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA struct
	memset(&cp, 0, sizeof(SPDATA_CREATEPLAYER));
	cp.dwSize = sizeof(SPDATA_CREATEPLAYER);
	cp.lpName = lpName;
	cp.lpData = lpData;
	cp.dwDataSize = dwDataSize;
	cp.dwFlags = dwFlags;

	// Call the CreatePlayer method in the SP
	if(CALLBACK_EXISTS(CreatePlayer))
	{
		cp.lpISP = PRV_GetDPLobbySPInterface(this);
	    
		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
		hr = CALL_LP(this, CreatePlayer, &cp);
		ENTER_DPLOBBY();
	}
	else 
	{
		// CreatePlayer is required
		DPF_ERR("The Lobby Provider callback for CreatePlayer doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling CreatePlayer in the Lobby Provider, hr = 0x%08x", hr);
		LEAVE_DPLOBBY();
		return hr;
	}

	// Fix up the player flags
	dwPlayerFlags = DPLAYI_PLAYER_PLAYERLOCAL;
	if(dwFlags & DPPLAYER_SPECTATOR)
		dwPlayerFlags |= DPLAYI_PLAYER_SPECTATOR;

	// Add the player to dplay's nametable and put it in our map table
	hr = PRV_CreateAndMapNewPlayer(this, lpidPlayer, lpName, hEvent, lpData,
			dwDataSize, dwPlayerFlags, cp.dwPlayerID, FALSE);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed creating a new local player, hr = 0x%08x", hr);
		// REVIEW!!!! -- We need to send a message back to the server saying
		// we couldn't complete the deal on our end.
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_CreatePlayer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyPlayer"
HRESULT DPLAPI PRV_DestroyPlayer(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID)
{
	SPDATA_DESTROYPLAYER	dp;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_DestroyPlayer");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, dwLobbyID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Take the dplay lock since we'll be looking at a dplay internal struct
	ENTER_DPLAY();

	// Make sure the player is a local player, otherwise return AccessDenied
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwLobbyID);
	if(!lpPlayer)
	{
		LEAVE_DPLAY();
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_DESTROYPLAYER;
	}

	if(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		LEAVE_DPLAY();
		DPF_ERR("Cannot add a remote player to a group");
		hr = DPERR_ACCESSDENIED;
		goto EXIT_DESTROYPLAYER;
	}
	
	// Drop the dplay lock since we're done
	LEAVE_DPLAY();

	// Setup our SPDATA struct
	memset(&dp, 0, sizeof(SPDATA_DESTROYPLAYER));
	dp.dwSize = sizeof(SPDATA_DESTROYPLAYER);
	dp.dwPlayerID = dwLobbyID;

	// Call the DestroyPlayer method in the SP
	if(CALLBACK_EXISTS(DestroyPlayer))
	{
		dp.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, DestroyPlayer, &dp);
		ENTER_DPLOBBY();
	}
	else 
	{
		// DestroyPlayer is required
		DPF_ERR("The Lobby Provider callback for DestroyPlayer doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_DESTROYPLAYER;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling DestroyPlayer in the Lobby Provider, hr = 0x%08x", hr);
		goto EXIT_DESTROYPLAYER;
	}

	// The dplay InternalDestroyPlayer code will take care of the rest of
	// the internal cleanup (nametable, groups, etc.), so we can just return
	// from here.

EXIT_DESTROYPLAYER:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_DestroyPlayer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetPlayerCaps"
HRESULT DPLAPI PRV_GetPlayerCaps(LPDPLOBBYI_DPLOBJECT this, DWORD dwFlags,
				DWORD dwPlayerID, LPDPCAPS lpcaps)
{
	SPDATA_GETPLAYERCAPS	gcd;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_GetPlayerCaps");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			this, dwFlags, dwPlayerID, lpcaps);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }

	
	// Setup our SPDATA struct
	memset(&gcd, 0, sizeof(SPDATA_GETCAPS));
	gcd.dwSize = sizeof(SPDATA_GETCAPS);
	gcd.dwFlags = dwFlags;
	gcd.dwPlayerID = dwPlayerID;
	gcd.lpcaps = lpcaps;

	// Call the GetPlayerCaps method in the LP
	if(CALLBACK_EXISTS(GetPlayerCaps))
	{
		gcd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, GetPlayerCaps, &gcd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// GetPlayerCaps is required
		DPF_ERR("The Lobby Provider callback for GetPlayerCaps doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_GETPLAYERCAPS;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling GetPlayerCaps in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_GETPLAYERCAPS:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_GetPlayerCaps



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetPlayerData"
HRESULT DPLAPI PRV_GetPlayerData(LPDPLOBBYI_DPLOBJECT this, DWORD dwPlayerID,
					LPVOID lpData, LPDWORD lpdwDataSize)
{
	SPDATA_GETPLAYERDATA	gpd;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_GetPlayerData");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dwPlayerID, lpData, lpdwDataSize);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&gpd, 0, sizeof(SPDATA_GETPLAYERDATA));
	gpd.dwSize = sizeof(SPDATA_GETPLAYERDATA);
	gpd.dwPlayerID = dwPlayerID;
	gpd.lpdwDataSize = lpdwDataSize;
	gpd.lpData = lpData;

	// Call the GetPlayerData method in the SP
	if(CALLBACK_EXISTS(GetPlayerData))
	{
		gpd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, GetPlayerData, &gpd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// GetPlayerData is required
		DPF_ERR("The Lobby Provider callback for GetPlayerData doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_GETPLAYERDATA;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling GetPlayerData in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_GETPLAYERDATA:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_GetPlayerData



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_Send"
HRESULT DPLAPI PRV_Send(LPDPLOBBYI_DPLOBJECT this, DWORD dwFromID, DWORD dwToID,
					DWORD dwFlags, LPVOID lpBuffer, DWORD dwBufSize)
{
	SPDATA_SEND		sd;
	HRESULT			hr = DP_OK;


	DPF(7, "Entering PRV_Send");
	DPF(9, "Parameters: 0x%08x, %lu, %lu, 0x%08x, 0x%08x, %lu",
			this, dwFromID, dwToID, dwFlags, lpBuffer, dwBufSize);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA structure
	memset(&sd, 0, sizeof(SPDATA_SEND));
	sd.dwSize = sizeof(SPDATA_SEND);
	sd.dwFromID = dwFromID;
	sd.dwToID = dwToID;
	sd.dwFlags = dwFlags;
	sd.lpBuffer = lpBuffer;
	sd.dwBufSize = dwBufSize;

	// Call the Send method in the SP
	if(CALLBACK_EXISTS(Send))
	{
		sd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, Send, &sd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// Send is required
		DPF_ERR("The Lobby Provider callback for Send doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_Send



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendChatMessage"
HRESULT DPLAPI PRV_SendChatMessage(LPDPLOBBYI_DPLOBJECT this, DWORD dwFromID,
			DWORD dwToID, DWORD dwFlags, LPDPCHAT lpChat)
{
	SPDATA_CHATMESSAGE		sd;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_SendChatMessage");
	DPF(9, "Parameters: 0x%08x, %lu, %lu, 0x%08x, 0x%08x",
			this, dwFromID, dwToID, dwFlags, lpChat);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA structure
	memset(&sd, 0, sizeof(SPDATA_CHATMESSAGE));
	sd.dwSize = sizeof(SPDATA_CHATMESSAGE);
	sd.dwFromID = dwFromID;
	sd.dwToID = dwToID;
	sd.dwFlags = dwFlags;
	sd.lpChat = lpChat;

	// Call the SendChatMessage method in the SP
	if(CALLBACK_EXISTS(SendChatMessage))
	{
		sd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, SendChatMessage, &sd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// SendChatMessage is required
		DPF_ERR("The Lobby Provider callback for SendChatMessage doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SENDCHATMESSAGE;
	}

EXIT_SENDCHATMESSAGE:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SendChatMessage



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetPlayerData"
HRESULT DPLAPI PRV_SetPlayerData(LPDPLOBBYI_DPLOBJECT this, DWORD dwPlayerID,
					LPVOID lpData, DWORD dwDataSize, DWORD dwFlags)
{
	SPDATA_SETPLAYERDATA	spd;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_SetPlayerData");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, %lu, 0x%08x",
			this, dwPlayerID, lpData, dwDataSize, dwFlags);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Take the dplay lock since we'll be looking at a dplay internal struct
	ENTER_DPLAY();

	// Make sure the player is a local player, otherwise return AccessDenied
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwPlayerID);
	if(!lpPlayer)
	{
		LEAVE_DPLAY();
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_SETPLAYERDATA;
	}

	if(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		LEAVE_DPLAY();
		DPF_ERR("Cannot add a remote player to a group");
		hr = DPERR_ACCESSDENIED;
		goto EXIT_SETPLAYERDATA;
	}
	
	// Drop the dplay lock since we're finished
	LEAVE_DPLAY();

	// Setup our SPDATA struct
	memset(&spd, 0, sizeof(SPDATA_SETPLAYERDATA));
	spd.dwSize = sizeof(SPDATA_SETPLAYERDATA);
	spd.dwPlayerID = dwPlayerID;
	spd.dwDataSize = dwDataSize;
	spd.lpData = lpData;
	spd.dwFlags = dwFlags;

	// Call the SetPlayerData method in the SP
	if(CALLBACK_EXISTS(SetPlayerData))
	{
		spd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, SetPlayerData, &spd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// SetPlayerData is required
		DPF_ERR("The Lobby Provider callback for SetPlayerData doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SETPLAYERDATA;
	}

	// If it succeeded, send the SetPlayerData message to our local players
	if(SUCCEEDED(hr))
	{
		hr = PRV_SendDataChangedMessageLocally(this, dwPlayerID, lpData, dwDataSize);
	}
	else
	{
		DPF_ERRVAL("Failed calling SetPlayerData in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_SETPLAYERDATA:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SetPlayerData



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetPlayerName"
HRESULT DPLAPI PRV_SetPlayerName(LPDPLOBBYI_DPLOBJECT this, DWORD dwPlayerID,
					LPDPNAME lpName, DWORD dwFlags)
{
	SPDATA_SETPLAYERNAME	spn;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_SetPlayerName");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dwPlayerID, lpName, dwFlags);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Take the dplay lock since we'll be looking at a dplay internal struct
	ENTER_DPLAY();

	// Make sure the player is a local player, otherwise return AccessDenied
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwPlayerID);
	if(!lpPlayer)
	{
		LEAVE_DPLAY();
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_SETPLAYERNAME;
	}

	if(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		LEAVE_DPLAY();
		DPF_ERR("Cannot add a remote player to a group");
		hr = DPERR_ACCESSDENIED;
		goto EXIT_SETPLAYERNAME;
	}
	
	// Drop the dplay lock since we're finished
	LEAVE_DPLAY();

	// Setup our SPDATA struct
	memset(&spn, 0, sizeof(SPDATA_SETPLAYERNAME));
	spn.dwSize = sizeof(SPDATA_SETPLAYERNAME);
	spn.dwPlayerID = dwPlayerID;
	spn.lpName = lpName;
	spn.dwFlags = dwFlags;

	// Call the SetPlayerName method in the SP
	if(CALLBACK_EXISTS(SetPlayerName))
	{
		spn.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, SetPlayerName, &spn);
		ENTER_DPLOBBY();
	}
	else 
	{
		// SetPlayerName is required
		DPF_ERR("The Lobby Provider callback for SetPlayerName doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SETPLAYERNAME;
	}

	// If it succeeded, send the SetPlayerName message to our local players
	if(SUCCEEDED(hr))
	{
		hr = PRV_SendNameChangedMessageLocally(this, dwPlayerID, lpName, TRUE);
	}
	else
	{
		DPF_ERRVAL("Failed calling SetPlayerName in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_SETPLAYERNAME:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SetPlayerName



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GrowMapTable"
HRESULT PRV_GrowMapTable(LPDPLOBBYI_DPLOBJECT this)
{
	LPDPLOBBYI_MAPIDNODE	lpTempMap = NULL;


	// If we haven't already allocated a buffer, allocate one with
	// DPLOBBYPR_DEFAULTMAPENTRIES entries in it
	if(!this->lpMap)
	{
		this->lpMap = DPMEM_ALLOC(DPLOBBYPR_DEFAULTMAPENTRIES *
							sizeof(DPLOBBYI_MAPIDNODE));
		if(!this->lpMap)
		{
			DPF(2, "Unable to allocate memory for ID map table");
			return DPERR_OUTOFMEMORY;
		}

		this->dwTotalMapEntries = DPLOBBYPR_DEFAULTMAPENTRIES;
		return DP_OK;
	}

	// Otherwise, grow the table by the default number of entries
	lpTempMap = DPMEM_REALLOC(this->lpMap, (this->dwTotalMapEntries +
				DPLOBBYPR_DEFAULTMAPENTRIES * sizeof(DPLOBBYI_MAPIDNODE)));
	if(!lpTempMap)
	{
		DPF(2, "Unable to grow map table");
		return DPERR_OUTOFMEMORY;
	}

	this->lpMap = lpTempMap;
	this->dwTotalMapEntries += DPLOBBYPR_DEFAULTMAPENTRIES *
								sizeof(DPLOBBYI_MAPIDNODE);

	return DP_OK;

} // PRV_GrowMapTable



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DoesLobbyIDExist"
BOOL PRV_DoesLobbyIDExist(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID,
		LPDWORD lpdwIndex)
{
	DWORD	dwIndex = 0;


	if(this->lpMap && this->dwMapEntries)
	{
		// REVIEW!!!! -- We need to make this faster -- use a sorted array
		while(dwIndex < this->dwMapEntries)
		{
			if(this->lpMap[dwIndex++].dwLobbyID == dwLobbyID)
			{
				*lpdwIndex = --dwIndex;
				return TRUE;
			}
		}
	}

	return FALSE;

} // PRV_DoesLobbyIDExist



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddMapIDNode"
HRESULT PRV_AddMapIDNode(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID, DPID dpid)
{
	HRESULT		hr = DP_OK;
	DWORD		dwIndex = 0;


	// Make sure we have room for a new entry
	if(this->dwMapEntries == this->dwTotalMapEntries)
	{
		hr = PRV_GrowMapTable(this);
		if(FAILED(hr))
			return hr;
	}

	// Verify that this LobbyID doesn't already exist in the table
	if(PRV_DoesLobbyIDExist(this, dwLobbyID, &dwIndex))
	{
		DPF(2, "Tried to add Lobby ID to map table which already existed, overwriting data");
		ASSERT(FALSE);
		this->lpMap[dwIndex].dwLobbyID = dwLobbyID;
		this->lpMap[dwIndex].dpid = dpid;
		return hr;
	}	

	// REVIEW!!!! -- We need to add this in and keep the array sorted to
	// make lookups faster, but for now, don't worry about it.
	// Fill in a new node at the end of the array
	this->lpMap[this->dwMapEntries].dwLobbyID = dwLobbyID;
	this->lpMap[this->dwMapEntries].dpid = dpid;
	this->dwMapEntries++;

	return hr;

} // PRV_AddMapIDNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteMapIDNode"
BOOL PRV_DeleteMapIDNode(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID)
{
	DWORD	dwIndex = 0;


	// Make sure we have entries
	if((this->lpMap) && (this->dwMapEntries))
	{
		// REVIEW!!!! -- We need to make this faster by using a sorted array
		while(dwIndex < this->dwMapEntries)
		{
			if(this->lpMap[dwIndex].dwLobbyID == dwLobbyID)
			{
				// Check for the boundary case (last entry)
				if((++dwIndex) == this->dwMapEntries)
				{
					// This is the last entry, so don't do anything but
					// decrement the number of entries
					this->dwMapEntries--;
					return TRUE;
				}
				else
				{
					// Move all entries from here to the end of the list
					// up one array entry
					MoveMemory((LPDPLOBBYI_MAPIDNODE)(&this->lpMap[dwIndex-1]),
						(LPDPLOBBYI_MAPIDNODE)(&this->lpMap[dwIndex]),
						((this->dwMapEntries - dwIndex) *
						sizeof(DPLOBBYI_MAPIDNODE)));

					// Decrement the count of entries
					this->dwMapEntries--;
					
					return TRUE;
				}
			}
			else
				dwIndex++;
		}
	}

	// We weren't able to delete the entry in the map table
	DPF(2, "Trying to delete an entry in the map ID table which doesn't exist");
	ASSERT(FALSE);
	return FALSE;

} // PRV_DeleteMapIDNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetDPIDByLobbyID"
BOOL PRV_GetDPIDByLobbyID(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID,
									DPID * lpdpid)
{
	DWORD	dwIndex = 0;

	
	// Take care of the known cases or else look in the map table
	switch(dwLobbyID)
	{
		case DPID_ALLPLAYERS:
		case DPID_SERVERPLAYER:
			*lpdpid = dwLobbyID;
			return TRUE;

		default:
			// Walk the list look for the ID
			while(dwIndex < this->dwMapEntries)
			{
				if(this->lpMap[dwIndex].dwLobbyID == dwLobbyID)
				{
					*lpdpid = this->lpMap[dwIndex].dpid;
					return TRUE;
				}
				else
					dwIndex++;
			}
	}

	return FALSE;

} // PRV_GetDPIDByLobbyID



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetLobbyIDByDPID"
BOOL PRV_GetLobbyIDByDPID(LPDPLOBBYI_DPLOBJECT this, DPID dpid,
									LPDWORD lpdwLobbyID)
{
	DWORD	dwIndex = 0;

	
	// Take care of the known cases or else look in the map table
	switch(dpid)
	{
		case DPID_ALLPLAYERS:
		case DPID_SERVERPLAYER:
			*lpdwLobbyID = dpid;
			return TRUE;

		default:
			// Walk the list look for the ID
			while(dwIndex < this->dwMapEntries)
			{
				if(this->lpMap[dwIndex].dpid == dpid)
				{
					*lpdwLobbyID = this->lpMap[dwIndex].dwLobbyID;
					return TRUE;
				}
				else
					dwIndex++;
			}
			break;
	}

	return FALSE;

} // PRV_GetLobbyIDByDPID



#undef DPF_MODNAME
#define DPF_MODNAME "IsLobbyIDInMapTable"
BOOL IsLobbyIDInMapTable(LPDPLOBBYI_DPLOBJECT this, DWORD dwID)
{
	DPID	dpidTemp;

	// If we can get it, then it's in there
	if(PRV_GetDPIDByLobbyID(this, dwID, &dpidTemp))
		return TRUE;

	// Otherwise, return FALSE
	return FALSE;

} // IsLobbyIDInMapTable



#undef DPF_MODNAME
#define DPF_MODNAME "IsValidLobbyID"
BOOL IsValidLobbyID(DWORD dwID)
{
	// If it's in our reserved range, it's invalid.  Otherwise, it's valid
	if(dwID <= DPID_RESERVEDRANGE)
		return FALSE;
	else
		return TRUE;

} // IsValidLobbyID



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateAndMapNewPlayer"
HRESULT PRV_CreateAndMapNewPlayer(LPDPLOBBYI_DPLOBJECT this,
			DPID * lpdpid, LPDPNAME lpName, HANDLE hEvent, LPVOID lpData,
			DWORD dwDataSize, DWORD dwFlags, DWORD dwLobbyID,
			BOOL bSystemPlayer)
{
	LPDPLAYI_PLAYER		lpPlayer = NULL, lpSysPlayer = NULL;
	HRESULT				hr;
	DPID				dpidPlayer, dpidSysPlayer;


	// Take the dplay lock
	ENTER_DPLAY();

	// Make sure the lobby ID is valid, but only if it's not a system player
	if((!bSystemPlayer) && (!IsValidLobbyID(dwLobbyID)))
	{
		DPF_ERRVAL("ID %lu is reserved, cannot create new player", dwLobbyID);
		goto EXIT_CREATEANDMAPNEWPLAYER;
	}

	// If this is a remote player, we need allocate a new nametable entry
	// for them and set the correct system player ID
	if(!(dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// Allocate a new ID for the player
		hr = NS_AllocNameTableEntry(this->lpDPlayObject, &dpidPlayer);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to allocate new nametable id, hr = 0x%08x", hr);
			goto EXIT_CREATEANDMAPNEWPLAYER;
		}

		// Make sure we have a lobby system player (for all remote players)
		// If we don't then allocate a new one, unless we are creating
		// the system player currently
		if((!(this->dpidSysPlayer)) && (!(dwFlags & DPLAYI_PLAYER_SYSPLAYER)))
		{
			hr = PRV_CreateAndMapNewPlayer(this, &dpidSysPlayer, NULL, NULL, NULL,
					0, DPLAYI_PLAYER_SYSPLAYER,
					DPID_LOBBYREMOTESYSTEMPLAYER, TRUE);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Unable to create lobby system player, hr = 0x%08x", hr);
				ASSERT(FALSE);
				goto EXIT_CREATEANDMAPNEWPLAYER;
			}

			// Set the lobby system player ID pointer to the new ID
			this->dpidSysPlayer = dpidSysPlayer;
		}
	}

	// Get a player struct for the player (if it's local, this will add it
	// to the nametable.  If it's remote, we need to add it below)
	hr = GetPlayer(this->lpDPlayObject, &lpPlayer, lpName, hEvent, lpData,
					dwDataSize, dwFlags, NULL, dwLobbyID);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed trying to add player to the nametable, hr = 0x%08x", hr);
		goto EXIT_CREATEANDMAPNEWPLAYER;
	}

	// If the player is remote, set the player's ID to the new one we
	// allocated and then set the system player ID to the lobby system player
	if(!(dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// Set the player's system player
		lpPlayer->dwIDSysPlayer = this->dpidSysPlayer;

		// Add the player to the nametable
		hr = AddItemToNameTable(this->lpDPlayObject, (DWORD_PTR)lpPlayer,
				&dpidPlayer, TRUE, dwLobbyID);
	    if (FAILED(hr)) 
	    {
			DPF_ERRVAL("Unable to add new player to the nametable, hr = 0x%08x", hr);
			ASSERT(FALSE);
			goto EXIT_CREATEANDMAPNEWPLAYER;
	    }

		// Set the player's ID
		lpPlayer->dwID = dpidPlayer;
	}

	// Set the output dpid pointer
	*lpdpid = lpPlayer->dwID;

EXIT_CREATEANDMAPNEWPLAYER:

	LEAVE_DPLAY();
	return hr;

} // PRV_CreateAndMapNewPlayer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\server.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       server.c
 *  Content:	Methods for connecting and interrogating a lobby server
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	10/25/96	myronth	Created it
 *	11/20/96	myronth	Implemented Logon/LogoffServer
 *	2/12/97		myronth	Mass DX5 changes
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/12/97		myronth	Fixed LoadSP code for DPlay3, reg & DPF bug fixes
 *	3/13/97		myronth	Save hInstance handle for LP DLL
 *	4/3/97		myronth	Changed CALLSP macro to CALL_LP
 *	4/9/97		myronth	Fixed structure passed to LP at DPLSPInit
 *	5/8/97		myronth	Purged dead code
 *	6/19/97		myronth	Moved setting of DPLOBBYPR_SPINTERFACE flag (#10118)
 *  7/28/97		sohailm	PRV_FindLPGUIDInAddressCallback was assuming pointers 
 *						were valid after duration of call.
 *	10/3/97		myronth	Bumped version to DX6, added it to DPLSPInit struct (#12667)
 *	10/7/97		myronth	Save the LP version in the lobby struct for later use
 *	11/6/97		myronth	Added version existence flag and dwReserved values
 *						to SPDATA_INIT (#12916, #12917)
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------
#define NUM_CALLBACKS( ptr ) ((ptr->dwSize-2*sizeof( DWORD ))/ sizeof( LPVOID ))

typedef struct LOOKFORSP
{
	LPGUID	lpguid;
	LPBOOL	lpbSuccess;
} LOOKFORSP, FAR * LPLOOKFORSP;

//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_VerifySPCallbacks"
HRESULT PRV_VerifySPCallbacks(LPDPLOBBYI_DPLOBJECT this)
{
	LPDWORD	lpCallback;
	int		nCallbacks = NUM_CALLBACKS(((LPSP_CALLBACKS)this->pcbSPCallbacks));
	int		i;


	DPF(2,"Verifying %d callbacks\n",nCallbacks);
	DPF(7, "Entering PRV_VerifySPCallbacks");
	DPF(9, "Parameters: 0x%08x", this);

	lpCallback = (LPDWORD)this->pcbSPCallbacks + 2; // + 1 for dwSize, + 1 for dwFlags

	for (i=0;i<nCallbacks ;i++ )
	{
		if ((lpCallback) && !VALIDEX_CODE_PTR(lpCallback)) 
		{
			DPF_ERR("SP provided bad callback pointer!");
			return E_FAIL;
		}
		lpCallback++;
	}

	return DP_OK;	

} // PRV_VerifySPCallbacks



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_LookForSPCallback"
BOOL FAR PASCAL PRV_LookForSPCallback(LPGUID lpguidSP, LPWSTR lpSPName,
				DWORD dwMajorVersion, DWORD dwMinorVersion, LPVOID lpContext)
{
	LPLOOKFORSP		lplook = (LPLOOKFORSP)lpContext;


	ASSERT(lpguidSP);
	ASSERT(lplook);

	// Check the guid and see if they match
	if(IsEqualGUID(lpguidSP, lplook->lpguid))
	{
		// Set the flag to true and stop enumerating
		*(lplook->lpbSuccess) = TRUE;
		return FALSE;
	}

	return TRUE;

} // PRV_LookForSPCallback



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindSPName"
HRESULT PRV_FindSPName(LPGUID lpguidSP, LPWSTR * lplpName,
		LPDWORD lpdwReserved1, LPDWORD lpdwReserved2)
{
	HKEY		hkeyLobbySP, hkeySP;
	WCHAR		wszSPName[DPLOBBY_REGISTRY_NAMELEN];
	DWORD		dwIndex = 0, dwSPNameSize;
	WCHAR		wszGuidStr[GUID_STRING_SIZE];
	DWORD		dwGuidStrSize = sizeof(wszGuidStr);
	DWORD		dwFileStrSize = 0;
	DWORD		dwType = REG_SZ;
	LPWSTR		lpwszFile = NULL;
	GUID		guidSP;
	LOOKFORSP	look;
	LONG		lReturn;
	BOOL		bFound = FALSE;
	DWORD		dwError;
	HRESULT		hr;
	DWORD		dwSize;



	DPF(7, "Entering PRV_FindSPName");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpguidSP, lplpName);

	ASSERT(lpguidSP);
	ASSERT(lplpName);


	// First see if it is a Lobby SP
	// Open the DPLobby SP key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLOBBY_SP_KEY, 0,
								KEY_READ, &hkeyLobbySP);
	// If this fails, it just means that the DPLobby SP key doesn't exist (most
	// likely), so in that case, there are no Lobby SP's to enumerate.
	if(lReturn == ERROR_SUCCESS)
	{
		// Walk the list of Lobby SP's in the registry, enumerating them
		while(!bFound)
		{
		
			// Get the next key's name
			dwSPNameSize = DPLOBBY_REGISTRY_NAMELEN;
			lReturn = OS_RegEnumKeyEx(hkeyLobbySP, dwIndex++, (LPWSTR)&wszSPName,
							&dwSPNameSize, NULL, NULL, NULL, NULL);
			if(ERROR_NO_MORE_ITEMS == lReturn)
				break;
			else if(lReturn != ERROR_SUCCESS)
			{
				dwError = GetLastError();
				DPF(2, "Unable to get Lobby Provider name -- skipping provider -- dwError = %u", dwError);
				continue;
			}
			

			// Open the key
			lReturn = OS_RegOpenKeyEx(hkeyLobbySP, (LPWSTR)wszSPName, 0,
										KEY_READ, &hkeySP);
			if(lReturn != ERROR_SUCCESS)
			{
				DPF_ERR("Unable to open Lobby Service Provider key in the registry!");
				continue;
			}

			// Get the GUID of the SP
			dwGuidStrSize = GUID_STRING_SIZE;
			lReturn = OS_RegQueryValueEx(hkeySP, SZ_GUID, NULL, &dwType,
										(LPBYTE)&wszGuidStr, &dwGuidStrSize);
			if(lReturn != ERROR_SUCCESS)
			{
				RegCloseKey(hkeySP);
				DPF_ERR("Unable to query GUID key value!");
				continue;
			}

			// Convert the string to a real GUID
			GUIDFromString(wszGuidStr, &guidSP);

			// Check to see if the guid is the one we are looking for
			if(IsEqualGUID(&guidSP, lpguidSP))
			{
				// Allocate memory for the filename string
				lReturn = OS_RegQueryValueEx(hkeySP, SZ_PATH, NULL, &dwType,
											NULL, &dwFileStrSize);
				if(lReturn != ERROR_SUCCESS)
				{
					RegCloseKey(hkeySP);
					DPF_ERR("Unable to get the size of the SP Path string");
					continue;
				}
				
				// Allocate memory for the string
				lpwszFile = DPMEM_ALLOC(dwFileStrSize);
				if(!lpwszFile)
				{
					RegCloseKey(hkeySP);
					DPF_ERR("Unable to allocate memory for temporary file string");
					continue;
				}

				// Get the filename string
				lReturn = OS_RegQueryValueEx(hkeySP, SZ_PATH, NULL, &dwType,
											(LPBYTE)lpwszFile, &dwFileStrSize);
				if(lReturn != ERROR_SUCCESS)
				{
					RegCloseKey(hkeySP);
					DPF_ERR("Unable to get filename string from registry");
					continue;
				}

				// Get the Reserved1 value
				dwSize = sizeof(DWORD);
				lReturn = OS_RegQueryValueEx(hkeySP, SZ_DWRESERVED1, NULL,
							&dwType, (LPBYTE)lpdwReserved1, &dwSize);
				if (lReturn != ERROR_SUCCESS) 
				{
					DPF(0,"Could not read dwReserved1 lReturn = %d\n", lReturn);
					// It's ok if LP doesn't have one of these...
				}

				// Get the Reserved2 value
				dwSize = sizeof(DWORD);
				lReturn = OS_RegQueryValueEx(hkeySP, SZ_DWRESERVED2, NULL,
							&dwType, (LPBYTE)lpdwReserved2, &dwSize);
				if (lReturn != ERROR_SUCCESS) 
				{
					DPF(0,"Could not read dwReserved2 lReturn = %d\n", lReturn);
					// It's ok if LP doesn't have one of these...
				}

				// We've got our information, so set the flag and bail
				bFound = TRUE;
				RegCloseKey(hkeySP);
				break;
			}

			// Close the SP key
			RegCloseKey(hkeySP);
		}
	}

	// Close the Lobby SP key
	RegCloseKey(hkeyLobbySP);

	// If we haven't found the SP, start checking the DPlay SP's for it
	if(!bFound)
	{
		// Set up a struct containing the guid and a success flag
		look.lpguid = lpguidSP;
		look.lpbSuccess = &bFound;
		
		// Call DirectPlayEnumerate and look for our SP
		hr = DirectPlayEnumerate(PRV_LookForSPCallback, &look);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to enumerate DirectPlay Service Providers");
		}

		// If the flag is TRUE, that means we found it, so set the output
		// pointer to a string containing our LobbySP for DPlay
		if(bFound)
		{
			hr = GetString(&lpwszFile, SZ_SP_FOR_DPLAY);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to allocate temporary string for filename");
			}
		}
	}	

	// If we haven't found the filename, return an error
	if(!bFound)
		return DPERR_GENERIC;

	// Set the output parameter
	*lplpName = lpwszFile;

	return DP_OK;

} // PRV_FindSPName



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_LoadSP"
HRESULT PRV_LoadSP(LPDPLOBBYI_DPLOBJECT this, LPGUID lpguidSP,
						LPVOID lpAddress, DWORD dwAddressSize)
{
	SPDATA_INIT				sd;
	SPDATA_SHUTDOWN			sdd;
	LPDPLOBBYSP				lpISP = NULL;
	LPWSTR					lpwszSP = NULL;
	HANDLE					hModule = NULL;
	HRESULT					hr;
	HRESULT					(WINAPI *SPInit)(LPSPDATA_INIT pSD);
	DWORD					dwError;
	DWORD					dwReserved1 = 0;
	DWORD					dwReserved2 = 0;


	DPF(7, "Entering PRV_LoadSP");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, lpguidSP, lpAddress);

	ASSERT(this);
	ASSERT(lpguidSP);


	// Find the requested Service Provider
	hr = PRV_FindSPName(lpguidSP, &lpwszSP, &dwReserved1, &dwReserved2);
	if(FAILED(hr))
	{
		DPF_ERR("Unabled to find requested LobbyProvider");
		hr = DPERR_GENERIC;
		goto ERROR_EXIT_LOADSP;
	}

 	// Try to load the specified sp
    hModule = OS_LoadLibrary(lpwszSP);
	if (!hModule) 
	{
		dwError = GetLastError();
		DPF_ERR("Could not load service provider\n");
		DPF(0, "GetLastError returned dwError = %d\n", dwError);
		hr = DPERR_GENERIC;
		goto ERROR_EXIT_LOADSP;
	}

	// Free the name string
	DPMEM_FREE(lpwszSP);
	lpwszSP = NULL;

	// Get our DPLSPInit entry point
    (FARPROC)SPInit = OS_GetProcAddress(hModule, "DPLSPInit");
	if (!SPInit) 
	{
		DPF(0,"Could not find service provider entry point");
		hr = DPERR_GENERIC;
		goto ERROR_EXIT_LOADSP;
	}

	// Get an IDPLobbySP to pass it
	hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *)&lpISP, &dplCallbacksSP);
	if (FAILED(hr)) 
	{
		DPF(0,"Unable to get an IDPLobbySP interface. hr = 0x%08lx\n",hr);
		hr = DPERR_GENERIC;
		goto ERROR_EXIT_LOADSP;
	}
	
	// Alloc the callbacks
	this->pcbSPCallbacks = DPMEM_ALLOC(sizeof(SP_CALLBACKS));
	if (!this->pcbSPCallbacks) 
	{
		DPF_ERR("Unable to allocate memory for SPCallback structure");
		LEAVE_DPLOBBY();
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_EXIT_LOADSP;
	}

	// Set up the init data struct
	memset(&sd,0,sizeof(sd));
	sd.lpCB = this->pcbSPCallbacks;
    sd.lpCB->dwSize = sizeof(SP_CALLBACKS);
	sd.lpCB->dwDPlayVersion = DPLSP_MAJORVERSION;
	sd.lpISP = lpISP;
	sd.lpAddress = lpAddress;
	sd.dwReserved1 = dwReserved1;
	sd.dwReserved2 = dwReserved2;

	hr = SPInit(&sd);
    if (FAILED(hr))
    {
    	DPF_ERR("Could not start up service provider!");
		goto ERROR_EXIT_LOADSP;
    }

	// Verify the callbacks are valid
	hr = PRV_VerifySPCallbacks(this);
    if (FAILED(hr))
    {
    	DPF_ERR("Invalid callbacks from service provider!");
		goto ERROR_EXIT_LOADSP;
    }

	// Make sure the SP version is valid
	if (sd.dwSPVersion < DPLSP_DX5VERSION)
	{
    	DPF_ERR("Incompatible version returned from lobby provider!");
		// Since the init succeeded, try to call shutdown
		memset(&sdd, 0, sizeof(SPDATA_SHUTDOWN));
		// REVIEW!!!! -- Should we pass a valid interface pointer
		// to the shutdown callback?  If so, which one?
		if (CALLBACK_EXISTS(Shutdown))
		{
			sdd.lpISP = PRV_GetDPLobbySPInterface(this);
			hr = CALL_LP(this, Shutdown, &sdd);
			if (FAILED(hr)) 
			{
				DPF_ERR("Could not invoke shutdown on the Lobby Provider");
			}
		}
		else 
		{
			ASSERT(FALSE);
		}

		hr = DPERR_UNAVAILABLE;
		goto ERROR_EXIT_LOADSP;
	}
	else
	{
		// Save the version of the lobby provider
		this->dwLPVersion = sd.dwSPVersion;
	}

	// Set the flag which tells us we have an IDPLobbySP interface
	this->dwFlags |= DPLOBBYPR_SPINTERFACE;

	// Save the hInstance for the LP's DLL
	this->hInstanceLP = hModule;

	return DP_OK;

ERROR_EXIT_LOADSP:
	
	// If the LP DLL was loaded, unload it
    if(hModule)
    {
        if(!FreeLibrary(hModule))
        {
			dwError = GetLastError();
			DPF_ERRVAL("Unable to free Lobby Provider DLL, dwError = %lu", dwError);
            ASSERT(FALSE);
        }
    }

	// Free our allocated callback table
	if(this->pcbSPCallbacks)
	{
		DPMEM_FREE(this->pcbSPCallbacks);
		this->pcbSPCallbacks = NULL;
	}

    return hr;

} // PRV_LoadSP



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindLPGUIDInAddressCallback"
BOOL FAR PASCAL PRV_FindLPGUIDInAddressCallback(REFGUID lpguidDataType, DWORD dwDataSize,
							LPCVOID lpData, LPVOID lpContext)
{	
	// See if this chunk is our LobbyProvider GUID
	if (IsEqualGUID(lpguidDataType, &DPAID_LobbyProvider))
	{
		// We found it, so we can stop enumerating chunks
		*((LPGUID)lpContext) = *((LPGUID)lpData);
		return FALSE;
	}
	
	// Try the next chunk
	return TRUE;

} // PRV_FindLPGUIDInAddressCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\misc\dpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.h
 *  Content:    header file for debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-apr-95  craige  initial implementation
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96	kipo	added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
#include "newdpf.h"
#else

    #ifndef __DPF_INCLUDED__
    #define __DPF_INCLUDED__

    #ifdef __cplusplus
    extern "C" {
    #endif

    #ifdef WINNT
        #undef DEBUG
        #ifdef DBG
	    #define DEBUG
        #endif
    #endif

    extern void cdecl dprintf( UINT lvl, LPSTR szFormat, ...);
    extern void DPFInit( void );
    #ifdef DEBUG
        #define DPFINIT()   DPFInit()
        #define DPF         dprintf
        #define DPF_ERR(a)  dprintf( 0, DPF_MODNAME ": " a );
        extern HWND hWndListBox;
        #if defined( _WIN32 ) && !defined(WINNT)
	    #define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
        #else
	    #define DEBUG_BREAK()       DebugBreak()
        #endif
        #define USE_DDASSERT
    #else
        #pragma warning(disable:4002)
        #define DPFINIT()
        #define DPF()
        #define DPF_ERR(a)
        #define DEBUG_BREAK()
    #endif

    #if defined(DEBUG) && defined(USE_DDASSERT)

    extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);

    #define DDASSERT(condition) if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)

    #else  /* DEBUG && USE_DDASSERT */

    #define DDASSERT(condition)

    #endif /* DEBUG && USE_DDASSERT */

    #ifdef _WIN32

    #ifdef DEBUG
        __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
        __inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

        #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
        #define TIMEZERO(t)   t ## T = 0, t ## N = 0
        #define TIMESTART(t)  t ## T -= clock(), t ## N ++
        #define TIMESTOP(t)   t ## T += clock()
        #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
        #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
    #else
        #define TIMEVAR(t)
        #define TIMEZERO(t)
        #define TIMESTART(t)
        #define TIMESTOP(t)
        #define TIMEFMT(t)
        #define TIMEOUT(t)
    #endif

    #endif
    #ifdef __cplusplus
    }
    #endif

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\misc\dpfa.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:	debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-jan-95	craige	initial implementation
 *   03-mar-95	craige	added dprintf2
 *   31-mar-95	craige	add DPFInit to read WIN.INI for [DirectDraw] section;
 *			added dprintf3
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	made stand-alone
 *   18-jun-95	craige	use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed dprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96	kipo	added msinternal
 *	 20-may-96	andyco	forced ansi entry points on all functions
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "dpf.h"
#include <stdarg.h>

//#ifdef WINNT
//int abs(int x)
//{
//    return x>=0?x:-x;
//}
//#endif

#ifdef DEBUG

#define USE_DDASSERT

#ifndef START_STR
    #define START_STR	"DDRAW: "
#endif
#ifndef PROF_SECT
    #define PROF_SECT	"DirectDraw"
#endif

#define END_STR		"\r\n"

HWND		hWndListBox;
LONG		lDebugLevel = 0;

/*
 * dumpStr
 */
static void dumpStr( LPSTR str )
{
    OutputDebugStringA( str );

    #ifdef DPF_HWND
	if( hWndListBox != NULL )
	{
	    if( !IsWindow( hWndListBox ) )
	    {
		hWndListBox = NULL;
	    }
	}
	if( hWndListBox != NULL )
	{
	    UINT	sel;
	    int	len;
	    len = strlen( str );
	    if( len > 0 )
	    {
		if( str[len-1] == '\r' || str[len-1] == '\n' )
		{
		    str[len-1] = 0;
		}
		if( len > 1 )
		{
		    if( str[len-2] == '\r' || str[len-2] == '\n' )
		    {
			str[len-2] = 0;
		    }
		}
	    }
	    SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
	    sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
	    if( sel != LB_ERR )
	    {
		SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
	    }
	}
    #endif

} /* dumpStr */

/*
 * dprintf
 */
void cdecl dprintf( UINT lvl, LPSTR szFormat, ...)
{
    char 	str[256];
    BOOL	allow = FALSE;
    va_list ap;
    va_start(ap,szFormat);


    if( lDebugLevel < 0 )
    {
#ifdef WINNT
	if( (UINT) abs( lDebugLevel ) == lvl )
#else
	if( (UINT) labs( lDebugLevel ) == lvl )
#endif
	{
	    allow = TRUE;
	}
    }
    else if( (UINT) lDebugLevel >= lvl )
    {
	allow = TRUE;
    }

    if( allow )
    {
	wsprintfA( (LPSTR) str, START_STR );
	wvsprintfA( str+lstrlenA( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

	lstrcatA( (LPSTR) str, END_STR );
	dumpStr( str );
    }

    va_end(ap);
} /* dprintf */

/*
 * DPFInit
 */
void DPFInit( void )
{
    lDebugLevel = GetProfileIntA( PROF_SECT, "debug", 0 );

} /* DPFInit */

#ifdef USE_DDASSERT

/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    wsprintfA( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( GetProfileIntA( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
	/*
	 * Into the debugger we go...
	 */
	DEBUG_BREAK();
    }
}

#endif /* USE_DDASSERT */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\psapi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994-1996  Microsoft Corporation

Module Name:

    psapi.h

Abstract:

    Include file for APIs provided by PSAPI.DLL

Author:

    Richard Shupak   [richards]  06-Jan-1994

Revision History:

--*/

#ifndef _PSAPI_H_
#define _PSAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

BOOL
WINAPI
EnumProcesses(
    DWORD * lpidProcess,
    DWORD   cb,
    DWORD * cbNeeded
    );

BOOL
WINAPI
EnumProcessModules(
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    );

DWORD
WINAPI
GetModuleBaseNameA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpBaseName,
    DWORD nSize
    );

DWORD
WINAPI
GetModuleBaseNameW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpBaseName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetModuleBaseName  GetModuleBaseNameW
#else
#define GetModuleBaseName  GetModuleBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetModuleFileNameExA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetModuleFileNameExW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetModuleFileNameEx  GetModuleFileNameExW
#else
#define GetModuleFileNameEx  GetModuleFileNameExA
#endif // !UNICODE


typedef struct _MODULEINFO {
    LPVOID lpBaseOfDll;
    DWORD SizeOfImage;
    LPVOID EntryPoint;
} MODULEINFO, *LPMODULEINFO;


BOOL
WINAPI
GetModuleInformation(
    HANDLE hProcess,
    HMODULE hModule,
    LPMODULEINFO lpmodinfo,
    DWORD cb
    );


BOOL
WINAPI
EmptyWorkingSet(
    HANDLE hProcess
    );


BOOL
WINAPI
QueryWorkingSet(
    HANDLE hProcess,
    PVOID pv,
    DWORD cb
    );

BOOL
WINAPI
InitializeProcessForWsWatch(
    HANDLE hProcess
    );


typedef struct _PSAPI_WS_WATCH_INFORMATION {
    LPVOID FaultingPc;
    LPVOID FaultingVa;
} PSAPI_WS_WATCH_INFORMATION, *PPSAPI_WS_WATCH_INFORMATION;

BOOL
WINAPI
GetWsChanges(
    HANDLE hProcess,
    PPSAPI_WS_WATCH_INFORMATION lpWatchInfo,
    DWORD cb
    );

DWORD
WINAPI
GetMappedFileNameW(
    HANDLE hProcess,
    LPVOID lpv,
    LPWSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetMappedFileNameA(
    HANDLE hProcess,
    LPVOID lpv,
    LPSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetMappedFilenameEx  GetMappedFilenameExW
#else
#define GetMappedFilenameEx  GetMappedFilenameExA
#endif // !UNICODE

BOOL
WINAPI
EnumDeviceDrivers(
    LPVOID *lpImageBase,
    DWORD cb,
    LPDWORD lpcbNeeded
    );


DWORD
WINAPI
GetDeviceDriverBaseNameA(
    LPVOID ImageBase,
    LPSTR lpBaseName,
    DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverBaseNameW(
    LPVOID ImageBase,
    LPWSTR lpBaseName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameW
#else
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetDeviceDriverFileNameA(
    LPVOID ImageBase,
    LPSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverFileNameW(
    LPVOID ImageBase,
    LPWSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverFileName  GetDeviceDriverFileNameW
#else
#define GetDeviceDriverFileName  GetDeviceDriverFileNameA
#endif // !UNICODE

// Structure for GetProcessMemoryInfo()

typedef struct _PROCESS_MEMORY_COUNTERS {
    DWORD cb;
    DWORD PageFaultCount;
    DWORD PeakWorkingSetSize;
    DWORD WorkingSetSize;
    DWORD QuotaPeakPagedPoolUsage;
    DWORD QuotaPagedPoolUsage;
    DWORD QuotaPeakNonPagedPoolUsage;
    DWORD QuotaNonPagedPoolUsage;
    DWORD PagefileUsage;
    DWORD PeakPagefileUsage;
} PROCESS_MEMORY_COUNTERS;
typedef PROCESS_MEMORY_COUNTERS *PPROCESS_MEMORY_COUNTERS;

BOOL
WINAPI
GetProcessMemoryInfo(
    HANDLE Process,
    PPROCESS_MEMORY_COUNTERS ppsmemCounters,
    DWORD cb
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\session.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       session.c
 *  Content:	Methods for session management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	2/27/97		myronth	Created it
 *	3/12/97		myronth	Implemented EnumSessions, Open, & Close
 *	3/31/97		myronth	Removed dead code, Fixed EnumSessionReponse fn name
 *	4/3/97		myronth	Changed CALLSP macro to CALL_LP
 *	5/8/97		myronth	Drop lobby lock when calling the LP
 *	5/13/97		myronth	Handle Credentials in Open, pass them to LP
 *	6/4/97		myronth	Fixed PRV_Open to fail on DPOPEN_CREATE (#9491)
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_Close"
HRESULT DPLAPI PRV_Close(LPDPLOBBYI_DPLOBJECT this)
{
	SPDATA_CLOSE	cd;
	HRESULT			hr = DP_OK;


	DPF(7, "Entering PRV_Close");
	DPF(9, "Parameters: 0x%08x", this);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA structure
	memset(&cd, 0, sizeof(SPDATA_CLOSE));
	cd.dwSize = sizeof(SPDATA_CLOSE);

	// Call the Close method in the SP
	if(CALLBACK_EXISTS(Close))
	{
		cd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, Close, &cd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// Close is required
		DPF_ERR("The Lobby Provider callback for Close doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_Close



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_EnumSessions"
HRESULT DPLAPI PRV_EnumSessions(LPDPLOBBYI_DPLOBJECT this,
		LPDPSESSIONDESC2 lpsd, DWORD dwTimeout, DWORD dwFlags)
{
	HRESULT					hr = DP_OK;
	SPDATA_ENUMSESSIONS		esd;


	DPF(7, "Entering PRV_EnumSessions");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			this, lpsd, dwTimeout, dwFlags);

	ASSERT(this);
	ASSERT(lpsd);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Call the EnumSessions method in the SP
	if(CALLBACK_EXISTS(EnumSessions))
	{
		// Clear our stack-based structure
		memset(&esd, 0, sizeof(SPDATA_ENUMSESSIONS));

		// Set up the structure and call the callback
		esd.dwSize = sizeof(SPDATA_ENUMSESSIONS);
		esd.lpISP = PRV_GetDPLobbySPInterface(this);
		esd.lpsd = lpsd;
		esd.dwTimeout = dwTimeout;
		esd.dwFlags = dwFlags;

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, EnumSessions, &esd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// EnumSessions is required
		// REVIEW!!!! -- What error should we return here????
		DPF_ERR("The Lobby Provider callback for EnumSessions doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
	}

	if(FAILED(hr)) 
	{
		DPF_ERR("Could not invoke EnumSessions in the Service Provider");
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_EnumSessions



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_EnumSessionsResponse"
HRESULT DPLAPI DPLP_EnumSessionsResponse(LPDPLOBBYSP lpDPLSP,
						LPSPDATA_ENUMSESSIONSRESPONSE lpr)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPMSG_ENUMSESSIONSREPLY	lpBuffer = NULL;
	LPBYTE					lpIndex = NULL;
	DWORD					dwNameLength, dwMessageSize;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPLP_EnumSessionsResponse");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpDPLSP, lpr);

	//	Make sure the SP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpDPLSP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			DPF_ERR("SP passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpr)
		{
			DPF_ERR("SPDATA_ENUMSESSIONSRESPONSE structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// REVIEW!!!! -- Can we put this packing code that's duplicated
	// from dplay into a single function???
	dwNameLength =  WSTRLEN_BYTES(lpr->lpsd->lpszSessionName);

	// Calculate the size of the message to send back to dplay
	dwMessageSize = sizeof(MSG_ENUMSESSIONSREPLY);
	dwMessageSize +=  dwNameLength;

	lpBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!lpBuffer) 
	{
		DPF(2, "Unable to allocate memory for EnumSessions request");
		return DPERR_OUTOFMEMORY;
	}

	// Set up the message
	SET_MESSAGE_HDR(lpBuffer);
    SET_MESSAGE_COMMAND(lpBuffer, DPSP_MSG_ENUMSESSIONSREPLY);
    lpBuffer->dpDesc =  *(lpr->lpsd);

	// Pack strings on end
	lpIndex = (LPBYTE)lpBuffer+sizeof(MSG_ENUMSESSIONSREPLY);
	if(dwNameLength) 
	{
		memcpy(lpIndex, lpr->lpsd->lpszSessionName, dwNameLength);
		lpBuffer->dwNameOffset = sizeof(MSG_ENUMSESSIONSREPLY);
	}

	// set string pointers to NULL - they must be set at client
	lpBuffer->dpDesc.lpszPassword = NULL;
	lpBuffer->dpDesc.lpszSessionName = NULL;

	// Now send it to dplay
	ENTER_DPLAY();
	hr = HandleEnumSessionsReply(this->lpDPlayObject, (LPBYTE)lpBuffer, NULL);
	LEAVE_DPLAY();

	// Free our buffer
	DPMEM_FREE(lpBuffer);

	return hr;

} // DPLP_EnumSessionsResponse



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_Open"
HRESULT DPLAPI PRV_Open(LPDPLOBBYI_DPLOBJECT this, LPDPSESSIONDESC2 lpsd,
				DWORD dwFlags, LPCDPCREDENTIALS lpCredentials)
{
	SPDATA_OPEN		od;
	HRESULT			hr = DP_OK;


	DPF(7, "Entering PRV_Open");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			this, lpsd, dwFlags, lpCredentials);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }

		// We cannot host a lobby session
		if(dwFlags & DPOPEN_CREATE)
		{
			DPF_ERR("Cannot host a lobby session");
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA structure
	memset(&od, 0, sizeof(SPDATA_OPEN));
	od.dwSize = sizeof(SPDATA_OPEN);
	od.lpsd = lpsd;
	od.dwFlags = dwFlags;
	od.lpCredentials = lpCredentials;

	// Call the ConnectServer method in the SP
	if(CALLBACK_EXISTS(Open))
	{
		od.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, Open, &od);
		ENTER_DPLOBBY();
	}
	else 
	{
		// Open is required
		DPF_ERR("The Lobby Provider callback for Open doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_Open
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\dplobby\dplobby\lobbysp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       lobbysp.h
 *  Content:    DirectPlayLobby data structures for Service Providers
 *@@BEGIN_MSINTERNAL
 *  History:
 *	Date		By		Reason
 *	====		==		======
 *	7/23/96		myronth	Created it
 *	10/23/96	myronth	Added IDPLobbySP interface stuff
 *	10/28/96	myronth	Changed to DX5 methods
 *	11/20/96	myronth	Added DPLOGONINFO to LogonServer data
 *	2/12/97		myronth	Mass DX5 changes
 *	2/18/97		myronth	Implemented GetObjectCaps
 *	3/12/97		myronth	Implemented EnumSessions, Removed Open & Close Responses
 *	3/13/97		myronth	Added link to global DPlay SP count (imported)
 *	3/17/97		myronth	Create/DestroyGroup/Player, Removed unnecessary
 *						Enum functions & structures
 *	3/21/97		myronth	SetGroup/PlayerName, Get/SetGroup/PlayerData, Removed
 *						more unnecessary response functions
 *	3/31/97		myronth	Removed dead code, Added new IDPLobbySP method structs
 *	4/4/97		myronth	Added new IDPLobbySP method structures
 *	4/9/97		myronth	Cleaned up SPINIT structure elements, Added
 *						GetCaps and GetPlayerCaps
 *	5/8/97		myronth	Subgroup methods, GroupConnSettings, StartSession
 *	5/13/97		myronth	Added Credentials to Open data struct
 *	5/17/97		myronth	SendChatMessage callback functions, structs, etc.
 *	5/23/97		myronth	Removed dwPlayerToID from the SPDATA structs
 *	6/3/97		myronth	Added dwPlayerFlags to SPDATA_ADDREMOTEPLAYERTOGROUP
 *	6/5/97		myronth	Added parent to SPDATA_ADDREMOTEPLAYERTOGROUP and
 *						added SPDATA_BUILDPARENTALHEIRARCHY message & structs
 *	7/30/97		myronth	Added dwFlags member to SPDATA_HANDLEMESSAGE
 *	10/3/97		myronth	Added dwDPlayVersion to DPLSPInit data struct
 *						Added player & group data to several remote structs
 *						Bumped version to DX6 (#12667)
 *	10/8/97		myronth	Rolled back the fix to #10961 which added lpData and
 *						dwDataSize to all remote structs -- It's not needed
 *	10/29/97	myronth	Added support for group owner and it's methods
 *	11/6/97		myronth	Added version existence flag and dwReserved values
 *						to SPDATA_INIT (#12916, #12917)
 *	12/29/97	myronth	Fixed DX6 macros (#15739)
 *@@END_MSINTERNAL
 ***************************************************************************/
#ifndef __LOBBYSP_INCLUDED__
#define __LOBBYSP_INCLUDED__

#include "dplobby.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


/*
 * gdwDPlaySPRefCount
 *
 * To ensure that the DPLAYX.DLL will not be unloaded before the lobby
 * provider, the lobby provider should statically link to DPLAYX.LIB and
 * increment this global during the DPLSPInit call and decrement this global
 * during Shutdown.
 */
extern __declspec(dllimport) DWORD gdwDPlaySPRefCount;


// A few forward declarations
typedef struct SPDATA_ADDGROUPTOGROUP * LPSPDATA_ADDGROUPTOGROUP;
typedef struct SPDATA_ADDPLAYERTOGROUP *LPSPDATA_ADDPLAYERTOGROUP;
typedef struct SPDATA_ADDREMOTEGROUPTOGROUP *LPSPDATA_ADDREMOTEGROUPTOGROUP;
typedef struct SPDATA_ADDREMOTEPLAYERTOGROUP *LPSPDATA_ADDREMOTEPLAYERTOGROUP;
typedef struct SPDATA_BUILDPARENTALHEIRARCHY *LPSPDATA_BUILDPARENTALHEIRARCHY;
typedef struct SPDATA_CHATMESSAGE *LPSPDATA_CHATMESSAGE;
typedef struct SPDATA_CLOSE *LPSPDATA_CLOSE;
typedef struct SPDATA_CREATEGROUP *LPSPDATA_CREATEGROUP;
typedef struct SPDATA_CREATEGROUPINGROUP *LPSPDATA_CREATEGROUPINGROUP;
typedef struct SPDATA_CREATEREMOTEGROUP *LPSPDATA_CREATEREMOTEGROUP;
typedef struct SPDATA_CREATEREMOTEGROUPINGROUP *LPSPDATA_CREATEREMOTEGROUPINGROUP;
typedef struct SPDATA_CREATEPLAYER *LPSPDATA_CREATEPLAYER;
typedef struct SPDATA_DELETEGROUPFROMGROUP * LPSPDATA_DELETEGROUPFROMGROUP;
typedef struct SPDATA_DELETEPLAYERFROMGROUP *LPSPDATA_DELETEPLAYERFROMGROUP;
typedef struct SPDATA_DELETEREMOTEGROUPFROMGROUP *LPSPDATA_DELETEREMOTEGROUPFROMGROUP;
typedef struct SPDATA_DELETEREMOTEPLAYERFROMGROUP *LPSPDATA_DELETEREMOTEPLAYERFROMGROUP;
typedef struct SPDATA_DESTROYGROUP *LPSPDATA_DESTROYGROUP;
typedef struct SPDATA_DESTROYREMOTEGROUP *LPSPDATA_DESTROYREMOTEGROUP;
typedef struct SPDATA_DESTROYPLAYER *LPSPDATA_DESTROYPLAYER;
typedef struct SPDATA_ENUMSESSIONS *LPSPDATA_ENUMSESSIONS;
typedef struct SPDATA_ENUMSESSIONSRESPONSE * LPSPDATA_ENUMSESSIONSRESPONSE;
typedef struct SPDATA_GETCAPS *LPSPDATA_GETCAPS;
typedef struct SPDATA_GETGROUPCONNECTIONSETTINGS *LPSPDATA_GETGROUPCONNECTIONSETTINGS;
typedef struct SPDATA_GETGROUPDATA *LPSPDATA_GETGROUPDATA;
typedef struct SPDATA_GETPLAYERCAPS *LPSPDATA_GETPLAYERCAPS;
typedef struct SPDATA_GETPLAYERDATA *LPSPDATA_GETPLAYERDATA;
typedef struct SPDATA_HANDLEMESSAGE *LPSPDATA_HANDLEMESSAGE;
typedef struct SPDATA_OPEN *LPSPDATA_OPEN;
typedef struct SPDATA_SEND *LPSPDATA_SEND;
typedef struct SPDATA_SETGROUPDATA *LPSPDATA_SETGROUPDATA;
typedef struct SPDATA_SETGROUPNAME *LPSPDATA_SETGROUPNAME;
typedef struct SPDATA_SETGROUPOWNER *LPSPDATA_SETGROUPOWNER;
typedef struct SPDATA_SETREMOTEGROUPNAME *LPSPDATA_SETREMOTEGROUPNAME;
typedef struct SPDATA_SETREMOTEGROUPOWNER *LPSPDATA_SETREMOTEGROUPOWNER;
typedef struct SPDATA_SETGROUPCONNECTIONSETTINGS *LPSPDATA_SETGROUPCONNECTIONSETTINGS;
typedef struct SPDATA_SETPLAYERDATA *LPSPDATA_SETPLAYERDATA;
typedef struct SPDATA_SETPLAYERNAME *LPSPDATA_SETPLAYERNAME;
typedef struct SPDATA_SETREMOTEPLAYERNAME *LPSPDATA_SETREMOTEPLAYERNAME;
typedef struct SPDATA_SETSESSIONDESC *LPSPDATA_SETSESSIONDESC;
typedef struct SPDATA_SHUTDOWN *LPSPDATA_SHUTDOWN;
typedef struct SPDATA_STARTSESSION *LPSPDATA_STARTSESSION;
typedef struct SPDATA_STARTSESSIONCOMMAND *LPSPDATA_STARTSESSIONCOMMAND;


/*
 *	IDPLobbySP
 *
 *	Lobby Service Providers are passed an IDPLobbySP interface
 *	in the LobbySPInit method. This interface is used to call
 *	back into DirectPlayLobby.
 */
struct IDPLobbySP;
typedef struct IDPLobbySP FAR* LPDPLOBBYSP;

#undef INTERFACE
#define INTERFACE IDPLobbySP
DECLARE_INTERFACE_( IDPLobbySP, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)               (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;
    /*** IDPLobbySP methods ***/
	STDMETHOD(AddGroupToGroup)              (THIS_ LPSPDATA_ADDREMOTEGROUPTOGROUP) PURE;
	STDMETHOD(AddPlayerToGroup)             (THIS_ LPSPDATA_ADDREMOTEPLAYERTOGROUP) PURE;
	STDMETHOD(CreateGroup)                  (THIS_ LPSPDATA_CREATEREMOTEGROUP) PURE;
	STDMETHOD(CreateGroupInGroup)           (THIS_ LPSPDATA_CREATEREMOTEGROUPINGROUP) PURE;
	STDMETHOD(DeleteGroupFromGroup)         (THIS_ LPSPDATA_DELETEREMOTEGROUPFROMGROUP) PURE;
	STDMETHOD(DeletePlayerFromGroup)        (THIS_ LPSPDATA_DELETEREMOTEPLAYERFROMGROUP) PURE;
	STDMETHOD(DestroyGroup)                 (THIS_ LPSPDATA_DESTROYREMOTEGROUP) PURE;
	STDMETHOD(EnumSessionsResponse)	        (THIS_ LPSPDATA_ENUMSESSIONSRESPONSE) PURE;
	STDMETHOD(GetSPDataPointer)		        (THIS_ LPVOID *) PURE;
	STDMETHOD(HandleMessage)				(THIS_ LPSPDATA_HANDLEMESSAGE) PURE;
	STDMETHOD(SendChatMessage)              (THIS_ LPSPDATA_CHATMESSAGE) PURE;
	STDMETHOD(SetGroupName)                 (THIS_ LPSPDATA_SETREMOTEGROUPNAME) PURE;
	STDMETHOD(SetPlayerName)                (THIS_ LPSPDATA_SETREMOTEPLAYERNAME) PURE;
	STDMETHOD(SetSessionDesc)               (THIS_ LPSPDATA_SETSESSIONDESC) PURE;
	STDMETHOD(SetSPDataPointer)		        (THIS_ LPVOID) PURE;
	STDMETHOD(StartSession)                 (THIS_ LPSPDATA_STARTSESSIONCOMMAND) PURE;
    /*** Methods added for DX6 ***/
    STDMETHOD(CreateCompoundAddress)        (THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(EnumAddress)                  (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
	STDMETHOD(SetGroupOwner)				(THIS_ LPSPDATA_SETREMOTEGROUPOWNER) PURE;
};

/*
 * GUID for IDPLobbySP
 */
// IID_IDPLobbySP	{5A4E5A20-2CED-11d0-A889-00A0C905433C}
DEFINE_GUID(IID_IDPLobbySP, 0x5a4e5a20, 0x2ced, 0x11d0, 0xa8, 0x89, 0x0, 0xa0, 0xc9, 0x5, 0x43, 0x3c);

/*
 * Major version number for service provider.
 *
 * The most-significant 16 bits are reserved for the DirectPlay
 * major version number. The least-significant 16 bits are for
 * use by the service provider.
 */
#define DPLSP_MAJORVERSION               0x00060000

// Major version used by DX5
#define DPLSP_DX5VERSION                 0x00050000

// Size of the SPDATA_INIT structure in DX5
#define DPLSP_SIZE_DX5_INIT_STRUCT       (16)

//--------------------------------------------------------------------------
//
//	Service Provider Callback Stuff
//
//--------------------------------------------------------------------------

// Callback prototypes
typedef HRESULT (WINAPI *LPSP_ADDGROUPTOGROUP)(LPSPDATA_ADDGROUPTOGROUP);
typedef HRESULT	(WINAPI *LPSP_ADDPLAYERTOGROUP)(LPSPDATA_ADDPLAYERTOGROUP);
typedef HRESULT	(WINAPI *LPSP_BUILDPARENTALHEIRARCHY)(LPSPDATA_BUILDPARENTALHEIRARCHY);
typedef HRESULT	(WINAPI *LPSP_CLOSE)(LPSPDATA_CLOSE);
typedef HRESULT	(WINAPI *LPSP_CREATEGROUP)(LPSPDATA_CREATEGROUP);
typedef HRESULT (WINAPI *LPSP_CREATEGROUPINGROUP)(LPSPDATA_CREATEGROUPINGROUP);
typedef HRESULT	(WINAPI *LPSP_CREATEPLAYER)(LPSPDATA_CREATEPLAYER);
typedef HRESULT (WINAPI *LPSP_DELETEGROUPFROMGROUP)(LPSPDATA_DELETEGROUPFROMGROUP);
typedef HRESULT	(WINAPI *LPSP_DELETEPLAYERFROMGROUP)(LPSPDATA_DELETEPLAYERFROMGROUP);
typedef HRESULT	(WINAPI *LPSP_DESTROYGROUP)(LPSPDATA_DESTROYGROUP);
typedef HRESULT	(WINAPI *LPSP_DESTROYPLAYER)(LPSPDATA_DESTROYPLAYER);
typedef HRESULT	(WINAPI *LPSP_ENUMSESSIONS)(LPSPDATA_ENUMSESSIONS);
typedef HRESULT (WINAPI *LPSP_GETCAPS)(LPSPDATA_GETCAPS);
typedef HRESULT (WINAPI *LPSP_GETGROUPCONNECTIONSETTINGS)(LPSPDATA_GETGROUPCONNECTIONSETTINGS);
typedef HRESULT	(WINAPI *LPSP_GETGROUPDATA)(LPSPDATA_GETGROUPDATA);
typedef HRESULT (WINAPI *LPSP_GETPLAYERCAPS)(LPSPDATA_GETPLAYERCAPS);
typedef HRESULT	(WINAPI *LPSP_GETPLAYERDATA)(LPSPDATA_GETPLAYERDATA);
typedef HRESULT	(WINAPI *LPSP_HANDLEMESSAGE)(LPSPDATA_HANDLEMESSAGE);
typedef HRESULT	(WINAPI *LPSP_OPEN)(LPSPDATA_OPEN);
typedef HRESULT	(WINAPI *LPSP_SEND)(LPSPDATA_SEND);
typedef HRESULT	(WINAPI *LPSP_SENDCHATMESSAGE)(LPSPDATA_CHATMESSAGE);
typedef HRESULT (WINAPI *LPSP_SETGROUPCONNECTIONSETTINGS)(LPSPDATA_SETGROUPCONNECTIONSETTINGS);
typedef HRESULT	(WINAPI *LPSP_SETGROUPDATA)(LPSPDATA_SETGROUPDATA);
typedef HRESULT	(WINAPI *LPSP_SETGROUPNAME)(LPSPDATA_SETGROUPNAME);
typedef HRESULT	(WINAPI *LPSP_SETGROUPOWNER)(LPSPDATA_SETGROUPOWNER);
typedef HRESULT	(WINAPI *LPSP_SETPLAYERDATA)(LPSPDATA_SETPLAYERDATA);
typedef HRESULT	(WINAPI *LPSP_SETPLAYERNAME)(LPSPDATA_SETPLAYERNAME);
typedef HRESULT	(WINAPI *LPSP_SHUTDOWN)(LPSPDATA_SHUTDOWN);
typedef HRESULT (WINAPI *LPSP_STARTSESSION)(LPSPDATA_STARTSESSION);

// Callback table for dplay to call into service provider
typedef struct SP_CALLBACKS
{
    DWORD								dwSize;
    DWORD								dwDPlayVersion;
    LPSP_ADDGROUPTOGROUP				AddGroupToGroup;
	LPSP_ADDPLAYERTOGROUP				AddPlayerToGroup;
	LPSP_BUILDPARENTALHEIRARCHY			BuildParentalHeirarchy;
	LPSP_CLOSE							Close;
    LPSP_CREATEGROUP					CreateGroup;
	LPSP_CREATEGROUPINGROUP				CreateGroupInGroup;
	LPSP_CREATEPLAYER					CreatePlayer;
    LPSP_DELETEGROUPFROMGROUP			DeleteGroupFromGroup;
	LPSP_DELETEPLAYERFROMGROUP			DeletePlayerFromGroup;
    LPSP_DESTROYGROUP					DestroyGroup;
	LPSP_DESTROYPLAYER					DestroyPlayer;
	LPSP_ENUMSESSIONS					EnumSessions;
	LPSP_GETCAPS						GetCaps;
	LPSP_GETGROUPCONNECTIONSETTINGS		GetGroupConnectionSettings;
	LPSP_GETGROUPDATA					GetGroupData;
	LPSP_GETPLAYERCAPS					GetPlayerCaps;
	LPSP_GETPLAYERDATA					GetPlayerData;
	LPSP_OPEN							Open;
	LPSP_SEND							Send;
	LPSP_SENDCHATMESSAGE				SendChatMessage;
	LPSP_SETGROUPCONNECTIONSETTINGS		SetGroupConnectionSettings;
	LPSP_SETGROUPDATA					SetGroupData;
	LPSP_SETGROUPNAME					SetGroupName;
	LPSP_SETPLAYERDATA					SetPlayerData;
	LPSP_SETPLAYERNAME					SetPlayerName;
	LPSP_SHUTDOWN						Shutdown;
	LPSP_STARTSESSION					StartSession;
	LPSP_SETGROUPOWNER					SetGroupOwner;
} SP_CALLBACKS, * LPSP_CALLBACKS;             


// CALLBACK DATA STRUCTURES. These are passed by DPLAY to the sp when
// the callback is invoked
typedef struct SPDATA_ADDGROUPTOGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwParentID;		// ID of the parent group
	DWORD			dwGroupID;		// ID of the new group to be created (output param)
} SPDATA_ADDGROUPTOGROUP;

typedef struct SPDATA_ADDPLAYERTOGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	DWORD			dwPlayerID;		// ID of the player
} SPDATA_ADDPLAYERTOGROUP;

typedef struct SPDATA_ADDREMOTEGROUPTOGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwAnchorID;		// ID of the anchor group (group the shortcut is added to)
	DWORD			dwGroupID;		// ID of the group the shortcut references
	DWORD			dwParentID;		// ID of the group's parent (not the group being added to)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	DWORD			dwGroupFlags;	// Group flags for the group the shortcut references
	DWORD			dwGroupOwnerID;	// ID of the owner of the group the shortcut references
} SPDATA_ADDREMOTEGROUPTOGROUP;

typedef struct SPDATA_ADDREMOTEPLAYERTOGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	DWORD			dwPlayerID;		// ID of the player
	DWORD			dwPlayerFlags;	// Player flags
	LPDPNAME		lpName;			// Name of the player
} SPDATA_ADDREMOTEPLAYERTOGROUP;

typedef struct SPDATA_BUILDPARENTALHEIRARCHY
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group to build the heirarchy for
	DWORD			dwMessage;		// Message type the lobby errored on
	DWORD			dwParentID;		// ID of the parent (for an AddGroupToGroup call)
} SPDATA_BUILDPARENTALHEIRARCHY;

typedef struct SPDATA_CLOSE
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
} SPDATA_CLOSE;

typedef struct SPDATA_CREATEGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group (output parameter)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	LPVOID			lpData;			// Pointer to group data
	DWORD			dwDataSize;		// Size of the group data
	DWORD			dwFlags;		// CreateGroup flags
	DWORD			dwGroupOwnerID;	// ID of the group's owner
} SPDATA_CREATEGROUP;

typedef struct SPDATA_CREATEGROUPINGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwParentID;		// ID of the parent group
	DWORD			dwGroupID;		// ID of the new group to be created (output param)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	LPVOID			lpData;			// Pointer to group data
	DWORD			dwDataSize;		// Size of the group data
	DWORD			dwFlags;		// CreateGroup flags
	DWORD			dwGroupOwnerID;	// ID of the group's owner
} SPDATA_CREATEGROUPINGROUP;

typedef struct SPDATA_CREATEREMOTEGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group (output parameter)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	LPVOID			lpData;			// Pointer to group data
	DWORD			dwDataSize;		// Size of the group data
	DWORD			dwFlags;		// CreateGroup flags
	DWORD			dwGroupOwnerID;	// ID of the group's owner
} SPDATA_CREATEREMOTEGROUP;

typedef struct SPDATA_CREATEREMOTEGROUPINGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwParentID;		// ID of the parent group
	DWORD			dwGroupID;		// ID of the new group to be created (output param)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	DWORD			dwFlags;		// CreateGroupInGroup flags
	DWORD			dwGroupOwnerID;	// ID of the group's owner
} SPDATA_CREATEREMOTEGROUPINGROUP;

typedef struct SPDATA_CREATEPLAYER
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the group (output parameter)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	LPVOID			lpData;			// Pointer to group data
	DWORD			dwDataSize;		// Size of the group data
	DWORD			dwFlags;		// CreatePlayer flags
} SPDATA_CREATEPLAYER;

typedef struct SPDATA_DELETEGROUPFROMGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwParentID;		// ID of the Parent Group
	DWORD			dwGroupID;		// ID of the Group to be deleted
} SPDATA_DELETEGROUPFROMGROUP;

typedef struct SPDATA_DELETEPLAYERFROMGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the Group
	DWORD			dwPlayerID;		// ID of the Player
} SPDATA_DELETEPLAYERFROMGROUP;

typedef struct SPDATA_DELETEREMOTEGROUPFROMGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwParentID;		// ID of the Parent Group
	DWORD			dwGroupID;		// ID of the Group to be deleted
} SPDATA_DELETEREMOTEGROUPFROMGROUP;

typedef struct SPDATA_DELETEREMOTEPLAYERFROMGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the Group
	DWORD			dwPlayerID;		// ID of the Player
} SPDATA_DELETEREMOTEPLAYERFROMGROUP;

typedef struct SPDATA_DESTROYGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the player on the lobby
} SPDATA_DESTROYGROUP;

typedef struct SPDATA_DESTROYREMOTEGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the player on the lobby
} SPDATA_DESTROYREMOTEGROUP;

typedef struct SPDATA_DESTROYPLAYER
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the player on the lobby
} SPDATA_DESTROYPLAYER;

typedef struct SPDATA_ENUMSESSIONS
{
	DWORD				dwSize;		// Size of this structure
	LPDPLOBBYSP			lpISP;		// Pointer to an IDPLobbySP interface
	LPDPSESSIONDESC2	lpsd;		// SessionDesc to enumerate on
	DWORD               dwTimeout;	// Timeout value
	DWORD               dwFlags;	// Flags
} SPDATA_ENUMSESSIONS;

typedef struct SPDATA_ENUMSESSIONSRESPONSE
{
	DWORD				dwSize;		// Size of this structure
	LPDPSESSIONDESC2	lpsd;		// SessionDesc returned by server
} SPDATA_ENUMSESSIONSRESPONSE;

typedef struct SPDATA_GETCAPS
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwFlags;		// Flags
	LPDPCAPS		lpcaps;			// Pointer to DPCAPS structure
} SPDATA_GETCAPS;

typedef struct SPDATA_GETGROUPCONNECTIONSETTINGS
{
	DWORD			dwSize;			// Size of this structure
	DWORD			dwFlags;		// Flags
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the Group
	LPDWORD			lpdwBufferSize;	// Pointer to the size of the buffer
	LPVOID			lpBuffer;		// Pointer to a buffer
} SPDATA_GETGROUPCONNECTIONSETTINGS;

typedef struct SPDATA_GETGROUPDATA
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the Group
	LPDWORD			lpdwDataSize;	// Pointer to the size of the lpData buffer
	LPVOID			lpData;			// Pointer to a data buffer
} SPDATA_GETGROUPDATA;

typedef struct SPDATA_GETPLAYERCAPS
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwFlags;		// Flags
	DWORD			dwPlayerID;		// ID of the Player
	LPDPCAPS		lpcaps;			// Pointer to DPCAPS structure
} SPDATA_GETPLAYERCAPS;

typedef struct SPDATA_GETPLAYERDATA
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the Player
	LPDWORD			lpdwDataSize;	// Pointer to the size of the lpData buffer
	LPVOID			lpData;			// Pointer to a data buffer
} SPDATA_GETPLAYERDATA;

typedef struct SPDATA_HANDLEMESSAGE
{
	DWORD			dwSize;			// Size of this structure
	DWORD			dwFromID;		// ID of the player from
	DWORD			dwToID;			// ID of the player to
	LPVOID			lpBuffer;		// Message buffer
	DWORD			dwBufSize;		// Size of the message buffer
	DWORD			dwFlags;		// Message flags
} SPDATA_HANDLEMESSAGE;

typedef struct SPDATA_OPEN
{
	DWORD				dwSize;		// Size of this structure (including data)
	LPDPLOBBYSP			lpISP;	    // Pointer to an IDPLobbySP interface
	LPDPSESSIONDESC2	lpsd;		// Pointer to SessionDesc of the Lobby to open
	DWORD				dwFlags;	// Flags
	LPCDPCREDENTIALS	lpCredentials;	// Pointer to a Credentials structure
} SPDATA_OPEN;

typedef struct SPDATA_SEND
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwFromID;		// ID of the player from
	DWORD			dwToID;			// ID of the player to
	DWORD			dwFlags;		// Flags
	LPVOID			lpBuffer;		// Message buffer
	DWORD			dwBufSize;		// Size of the message buffer
} SPDATA_SEND;

typedef struct SPDATA_CHATMESSAGE
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwFromID;		// ID of the player from
	DWORD			dwToID;			// ID of the player to
	DWORD			dwFlags;		// Send Flags
	LPDPCHAT		lpChat;			// Pointer to a DPCHAT structure
} SPDATA_CHATMESSAGE;

typedef struct SPDATA_SETGROUPCONNECTIONSETTINGS
{
	DWORD			dwSize;			// Size of this structure
	DWORD			dwFlags;		// Flags
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	LPDPLCONNECTION	lpConn;			// Pointer to a DPLCONNECTION structure
} SPDATA_SETGROUPCONNECTIONSETTINGS;

typedef struct SPDATA_SETGROUPDATA
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	LPVOID			lpData;			// Pointer to the new group data
	DWORD			dwDataSize;		// Size of lpData
	DWORD			dwFlags;		// Flags
} SPDATA_SETGROUPDATA;

typedef struct SPDATA_SETGROUPNAME
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	LPDPNAME		lpName;			// Pointer to the new DPNAME struct
	DWORD			dwFlags;		// Flags
} SPDATA_SETGROUPNAME;

typedef struct SPDATA_SETREMOTEGROUPNAME
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	LPDPNAME		lpName;			// Pointer to the new DPNAME struct
	DWORD			dwFlags;		// Flags
} SPDATA_SETREMOTEGROUPNAME;

typedef struct SPDATA_SETGROUPOWNER
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	DWORD			dwOwnerID;		// ID of the group's owner
} SPDATA_SETGROUPOWNER;

typedef struct SPDATA_SETREMOTEGROUPOWNER
{
	DWORD			dwSize;			// Size of this structure
	DWORD			dwGroupID;		// ID of the group
	DWORD			dwOwnerID;		// ID of the group's owner
} SPDATA_SETREMOTEGROUPOWNER;

typedef struct SPDATA_SETPLAYERDATA
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the player
	LPVOID			lpData;			// Pointer to the new player data
	DWORD			dwDataSize;		// Size of lpData
	DWORD			dwFlags;		// Flags
} SPDATA_SETPLAYERDATA;

typedef struct SPDATA_SETPLAYERNAME
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the player
	LPDPNAME		lpName;			// Pointer to the new DPNAME struct
	DWORD			dwFlags;		// Flags
} SPDATA_SETPLAYERNAME;

typedef struct SPDATA_SETREMOTEPLAYERNAME
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the player
	LPDPNAME		lpName;			// Pointer to the new DPNAME struct
	DWORD			dwFlags;		// Flags
} SPDATA_SETREMOTEPLAYERNAME;

typedef struct SPDATA_SETSESSIONDESC
{
	DWORD				dwSize;		// Size of this structure
	LPDPSESSIONDESC2	lpsd;		// Pointer to a SessionDesc struct
	LPDPLOBBYSP			lpISP;		// Pointer to an IDPLobbySP interface
} SPDATA_SETSESSIONDESC;

typedef struct SPDATA_SHUTDOWN
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
} SPDATA_SHUTDOWN;

typedef struct SPDATA_STARTSESSION
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwFlags;		// Flags
	DWORD			dwGroupID;		// ID of the group who's session to start
} SPDATA_STARTSESSION;

typedef struct SPDATA_STARTSESSIONCOMMAND
{
	DWORD			dwFlags;		// Flags
	DWORD			dwGroupID;		// Group ID of the group to start the session on
	DWORD			dwHostID;		// ID of the host player for the session
	LPDPLCONNECTION	lpConn;			// Pointer to a DPLCONNECTION struct for the session information
} SPDATA_STARTSESSIONCOMMAND;

// Data structure passed to the service provider at DPLSPInit
typedef struct SPDATA_INIT 
{
	LPSP_CALLBACKS      lpCB;			// Lobby Provider fills in entry points
    DWORD               dwSPVersion;	// Lobby provider fills in version number 16 | 16 , major | minor version 
	LPDPLOBBYSP         lpISP;			// DPLobbySP interface pointer
	LPDPADDRESS			lpAddress;		// DPADDRESS of the Lobby (partial or complete)
	DWORD				dwReserved1;	// Reserved DWORD from the registry entry for the LP
	DWORD				dwReserved2;	// Reserved DWORD from the registry entry for the LP
} SPDATA_INIT, * LPSPDATA_INIT;

// This is the function that DPLobby calls to
// get the SP to fill in callbacks
typedef HRESULT (WINAPI *LPSP_INIT)(LPSPDATA_INIT);
HRESULT WINAPI DPLSPInit(LPSPDATA_INIT);


/****************************************************************************
 *
 * IDirectPlayLobby interface macros
 *
 ****************************************************************************/


#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDPLobbySP_QueryInterface(p,a,b)         (p)->lpVtbl->QueryInterface(p,a,b)
#define IDPLobbySP_AddRef(p)                     (p)->lpVtbl->AddRef(p)
#define IDPLobbySP_Release(p)                    (p)->lpVtbl->Release(p)
#define IDPLobbySP_AddGroupToGroup(p,a)          (p)->lpVtbl->AddGroupToGroup(p,a)
#define IDPLobbySP_AddPlayerToGroup(p,a)         (p)->lpVtbl->AddPlayerToGroup(p,a)
#define IDPLobbySP_CreateCompoundAddress(p,a,b,c,d) (p)->lpVtbl->CreateCompoundAddress(p,a,b,c,d)
#define IDPLobbySP_CreateGroup(p,a)              (p)->lpVtbl->CreateGroup(p,a)
#define IDPLobbySP_CreateGroupInGroup(p,a)       (p)->lpVtbl->CreateGroupInGroup(p,a)
#define IDPLobbySP_DeleteGroupFromGroup(p,a)     (p)->lpVtbl->DeleteGroupFromGroup(p,a)
#define IDPLobbySP_DeletePlayerFromGroup(p,a)    (p)->lpVtbl->DeletePlayerFromGroup(p,a)
#define IDPLobbySP_DestroyGroup(p,a)             (p)->lpVtbl->DestroyGroup(p,a)
#define IDPLobbySP_EnumAddress(p,a,b,c,d)        (p)->lpVtbl->EnumAddress(p,a,b,c,d)
#define IDPLobbySP_EnumSessionsResponse(p,a)     (p)->lpVtbl->EnumSessionsResponse(p,a)
#define IDPLobbySP_GetSPDataPointer(p,a)         (p)->lpVtbl->GetSPDataPointer(p,a)
#define IDPLobbySP_HandleMessage(p,a)            (p)->lpVtbl->HandleMessage(p,a)
#define IDPLobbySP_SetGroupName(p,a)             (p)->lpVtbl->SetGroupName(p,a)
#define IDPLobbySP_SetPlayerName(p,a)            (p)->lpVtbl->SetPlayerName(p,a)
#define IDPLobbySP_SetSessionDesc(p,a)           (p)->lpVtbl->SetSessionDesc(p,a)
#define IDPLobbySP_StartSession(p,a)             (p)->lpVtbl->StartSession(p,a)
#define IDPLobbySP_SetGroupOwner(p,a)            (p)->lpVtbl->SetGroupOwner(p,a)
#define IDPLobbySP_SetSPDataPointer(p,a)         (p)->lpVtbl->SetSPDataPointer(p,a)

#else /* C++ */

#define IDPLobbySP_QueryInterface(p,a,b)         (p)->QueryInterface(a,b)
#define IDPLobbySP_AddRef(p)                     (p)->AddRef()
#define IDPLobbySP_Release(p)                    (p)->Release()
#define IDPLobbySP_AddGroupToGroup(p,a)          (p)->AddGroupToGroup(a)
#define IDPLobbySP_AddPlayerToGroup(p,a)         (p)->AddPlayerToGroup(a)
#define IDPLobbySP_CreateCompoundAddress(p,a,b,c,d) (p)->CreateCompoundAddress(a,b,c,d)
#define IDPLobbySP_CreateGroup(p,a)              (p)->CreateGroup(a)
#define IDPLobbySP_CreateGroupInGroup(p,a)       (p)->CreateGroupInGroup(a)
#define IDPLobbySP_DeleteGroupFromGroup(p,a)     (p)->DeleteGroupFromGroup(a)
#define IDPLobbySP_DeletePlayerFromGroup(p,a)    (p)->DeletePlayerFromGroup(a)
#define IDPLobbySP_DestroyGroup(p,a)             (p)->DestroyGroup(a)
#define IDPLobbySP_EnumAddress(p,a,b,c,d)        (p)->EnumAddress(a,b,c,d)
#define IDPLobbySP_EnumSessionsResponse(p,a)     (p)->EnumSessionsResponse(a)
#define IDPLobbySP_GetSPDataPointer(p,a)         (p)->GetSPDataPointer(a)
#define IDPLobbySP_HandleMessage(p,a)            (p)->HandleMessage(a)
#define IDPLobbySP_SetGroupName(p,a)             (p)->SetGroupName(a)
#define IDPLobbySP_SetPlayerName(p,a)            (p)->SetPlayerName(a)
#define IDPLobbySP_SetSessionDesc(p,a)           (p)->SetSessionDesc(a)
#define IDPLobbySP_StartSession(p,a)             (p)->StartSession(a)
#define IDPLobbySP_SetGroupOwner(p,a)            (p)->SetGroupOwner(a)
#define IDPLobbySP_SetSPDataPointer(p,a)         (p)->SetSPDataPointer(a)

#endif /* C or C++ */


#ifdef __cplusplus
};
#endif // __cplusplus

#endif // __LOBBYSP_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\misc\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:	header file for memory allocation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   22-may-95	craige	added MemAlloc16
 *   12-jun-95	craige	added MemReAlloc
 *   26-jun-95  craige  added GetPtr16
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *
 ***************************************************************************/
#ifndef __MEMALLOC_INCLUDED__
#define __MEMALLOC_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif
extern void MemFini( void );
extern void MemState( void );
extern BOOL MemInit( void );
extern void MemFree( LPVOID lptr );
extern UINT_PTR __cdecl MemSize( LPVOID lptr );
extern LPVOID __cdecl MemAlloc( UINT size );
extern LPVOID __cdecl MemReAlloc( LPVOID ptr, UINT size );
extern LPVOID __cdecl MemAlloc16( UINT size, DWORD FAR *p16 );
extern LPVOID GetPtr16( LPVOID ptr );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\misc\dpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:	debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-jan-95	craige	initial implementation
 *   03-mar-95	craige	added dprintf2
 *   31-mar-95	craige	add DPFInit to read WIN.INI for [DirectDraw] section;
 *			added dprintf3
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	made stand-alone
 *   18-jun-95	craige	use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed dprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96	kipo	added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
    #include "newdpf.c"
#else   //use old debug:

    #undef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
    #include <windows.h>
    #include "dpf.h"
    #include <stdarg.h>

    //#ifdef WINNT
    //int abs(int x)
    //{
    //    return x>=0?x:-x;
    //}
    //#endif

    #ifdef DEBUG

    #define USE_DDASSERT

    #ifndef START_STR
        #define START_STR	"DDRAW: "
    #endif
    #ifndef PROF_SECT
        #define PROF_SECT	"DirectDraw"
    #endif

    #define END_STR		"\r\n"

    HWND		hWndListBox;
    LONG		lDebugLevel = 0;

    /*
     * dumpStr
     */
    static void dumpStr( LPSTR str )
    {
        OutputDebugString( str );

        #ifdef DPF_HWND
	    if( hWndListBox != NULL )
	    {
	        if( !IsWindow( hWndListBox ) )
	        {
		    hWndListBox = NULL;
	        }
	    }
	    if( hWndListBox != NULL )
	    {
	        UINT	sel;
	        int	len;
	        len = strlen( str );
	        if( len > 0 )
	        {
		    if( str[len-1] == '\r' || str[len-1] == '\n' )
		    {
		        str[len-1] = 0;
		    }
		    if( len > 1 )
		    {
		        if( str[len-2] == '\r' || str[len-2] == '\n' )
		        {
			    str[len-2] = 0;
		        }
		    }
	        }
	        SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
	        sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
	        if( sel != LB_ERR )
	        {
		    SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
	        }
	    }
        #endif

    } /* dumpStr */

    /*
     * dprintf
     */
    void cdecl dprintf( UINT lvl, LPSTR szFormat, ...)
    {
        char 	str[256];
        //char 	str2[256];

        BOOL	allow = FALSE;
        va_list ap;
        va_start(ap,szFormat);


        if( lDebugLevel < 0 )
        {
	    if(  (UINT) -lDebugLevel == lvl )
	    {
	        allow = TRUE;
	    }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
	    allow = TRUE;
        }

        if( allow )
        {
	    wsprintf( (LPSTR) str, START_STR );
            //GetModuleFileName(NULL,str2,256);
            //if (strrchr(str2,'\\'))
            //    wsprintf(str+strlen(str),"%12s",strrchr(str2,'\\')+1);
            //strcat(str,":");
	    wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

	    lstrcat( (LPSTR) str, END_STR );
	    dumpStr( str );
        }

        va_end(ap);
    } /* dprintf */

    /*
     * DPFInit
     */
    void DPFInit( void )
    {
        lDebugLevel = GetProfileInt( PROF_SECT, "debug", 0 );

    } /* DPFInit */

    #ifdef USE_DDASSERT

    /*
     * NOTE: I don't want to get into error checking for buffer overflows when
     * trying to issue an assertion failure message. So instead I just allocate
     * a buffer that is "bug enough" (I know, I know...)
     */
    #define ASSERT_BUFFER_SIZE   512
    #define ASSERT_BANNER_STRING "************************************************************"
    #define ASSERT_BREAK_SECTION "BreakOnAssert"
    #define ASSERT_BREAK_DEFAULT FALSE
    #define ASSERT_MESSAGE_LEVEL 0

    void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
    {
        char buffer[ASSERT_BUFFER_SIZE];

        /*
         * Build the debug stream message.
         */
        wsprintf( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

        /*
         * Actually issue the message. These messages are considered error level
         * so they all go out at error level priority.
         */
        dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
        dprintf( ASSERT_MESSAGE_LEVEL, buffer );
        dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

        /*
         * Should we drop into the debugger?
         */
        if( GetProfileInt( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
        {
	    /*
	     * Into the debugger we go...
	     */
	    DEBUG_BREAK();
        }
    }

    #endif /* USE_DDASSERT */

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\misc\dxvalid.h ===
//--------------------------------------------------------------------------;
//
//  File: dxvalid.h
//
//  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//      This header contains common parameter validate macros for DirectX.
//
//  History:
//      02/14/96    angusm    Initial version
//      03/05/96    angusm    added VALIDEX_GUID_PTR
//
//--------------------------------------------------------------------------;


// _________________________________________________________________________
// VALIDEX_xxx 
//     macros are the same for debug and retail


#define VALIDEX_PTR( ptr, size ) \
	(!IsBadReadPtr( ptr, size) )

#define VALIDEX_GUID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( GUID ) ) )

#define VALIDEX_IID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( IID )) )

#define VALIDEX_PTR_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID )) )

#define VALIDEX_CODE_PTR( ptr ) \
	(!IsBadCodePtr( (LPVOID) ptr ) )


// _________________________________________________________________________
// VALID_xxx 
//     macros that check memory allocated and sent as API parameters


#ifndef DEBUG
#define FAST_CHECKING
#endif

#ifndef FAST_CHECKING

#define VALID_BOOL_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( BOOL ) ))
#define VALID_DDCOLORKEY_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( DDCOLORKEY ) ) )
#define VALID_RGNDATA_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( RGNDATA ) ) )
#define VALID_RECT_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( RECT ) ) )
#define VALID_PTR_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID )) )
#define VALID_IID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( IID )) )
#define VALID_HWND_PTR( ptr ) \
	(!IsBadWritePtr( (LPVOID) ptr, sizeof( HWND )) )
#define VALID_VMEM_PTR( ptr ) \
	(!IsBadWritePtr( (LPVOID) ptr, sizeof( VMEM )) )
#define VALID_POINTER_ARRAY( ptr, cnt ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID ) * cnt ) )
#define VALID_HANDLE_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( HANDLE )) )
#define VALID_DWORD_ARRAY( ptr, cnt ) \
	(!IsBadWritePtr( ptr, sizeof( DWORD ) * cnt ) )
#define VALID_GUID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( GUID ) ) )
#define VALID_BYTE_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( BYTE ) * cnt ) )
#define VALID_PTR( ptr, size ) \
	(!IsBadReadPtr( ptr, size) )

#else
#define VALID_PTR( ptr, size ) 		1
#define VALID_DIRECTDRAW_PTR( ptr )	1
#define VALID_DIRECTDRAWSURFACE_PTR( ptr )	1
#define VALID_DIRECTDRAWPALETTE_PTR( ptr )	1
#define VALID_DIRECTDRAWCLIPPER_PTR( ptr )	1
#define VALID_DDSURFACEDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDSURFACEDESC ))
#define VALID_BOOL_PTR( ptr )	1
#define VALID_HDC_PTR( ptr )	1
#define VALID_DDPIXELFORMAT_PTR( ptr ) (ptr->dwSize == sizeof( DDPIXELFORMAT ))
#define VALID_DDCOLORKEY_PTR( ptr )	1
#define VALID_RGNDATA_PTR( ptr )	1
#define VALID_RECT_PTR( ptr )	1
#define VALID_DDOVERLAYFX_PTR( ptr ) (ptr->dwSize == sizeof( DDOVERLAYFX ))
#define VALID_DDBLTFX_PTR( ptr ) (ptr->dwSize == sizeof( DDBLTFX ))
#define VALID_DDBLTBATCH_PTR( ptr )	1
#define VALID_DDMASK_PTR( ptr )	1
#define VALID_DDSCAPS_PTR( ptr )	1
#define VALID_PTR_PTR( ptr )	1
#define VALID_IID_PTR( ptr )	1
#define VALID_HWND_PTR( ptr )	1
#define VALID_VMEM_PTR( ptr )	1
#define VALID_POINTER_ARRAY( ptr, cnt ) 1
#define VALID_PALETTEENTRY_ARRAY( ptr, cnt )	1
#define VALID_HANDLE_PTR( ptr )	1
#define VALID_DDCAPS_PTR( ptr ) (ptr->dwSize == sizeof( DDCAPS ))
#define VALID_READ_DDSURFACEDESC_ARRAY( ptr, cnt )	1
#define VALID_DWORD_ARRAY( ptr, cnt )	1
#define VALID_GUID_PTR( ptr )	1
#define VALID_BYTE_ARRAY( ptr, cnt ) 1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\misc\logger.h ===
/*
	logger.h

	Use to write log info to a file.

	Multiple-instance aware. If one instance already owns the output
        file, another will sleep (up to 20s) until the first is done.
	Nicely outputs a header containing user, computer, and driver names,
	date/time and starting display resolution.


        You use it like this:

                CLogfile Log("test.log","your comment here");

                // or CLogfile Log("test.log");
                // for no comment, and overwriting the file.

                // or CLogfile Log("test.log","your comment here",TRUE);
                // to make it append to the file. Default is overwrite.
                
                Log << "\n\n42 decimal is " << 42ul <<" in hex\n";
                Log << "Hi"<<'!'<<'\n' ;
                Log << "The value of 0x2a is " << 0x2al << " in decimal\n";

				CLogfile Faults("faults.log","my test's faults",TRUE);	//append new faults
				Faults << "Encountered a booboo, here's what i did:\n";
				Faults << Log;		//copies contents of test.log to Fault
				Faults << "so now you can diagnose\n";

        The class will then write stuff like this to test.log:


                ----------------------------------------------------------
                EnumSurface test
                Beginning test at 10:38 on 1995/8/14
                User Name:jeffno
                Computer Name:JEFFNO2
                Display driver:S3 Vision864 PCI
                Starting resolution: 640x480x8
                - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
                42 decimal is 0000002a in hex
                Hi!
                The value of 0x2a is 42 in decimal
                ----------- Test ends at 10:38 on 1995/8/14 -------------
                
		And faults.log will get:
				< a header like above>
				Encountered a booboo, here's what i did:
				< a copy of the test.log contents surrounded by
					notes that say this is a snapshot of test.log >
				so now you can diagnose
				< a trailer like above (test ends at etc...)>



        The class can output DWORDS, which it does as an 8-digit hex number,
        LONGs which are output as decimal, chars and strings. As shown
		above you can output one log object to another, which copies 
		everything in the source file from the pos at which the source
		file was opened (if appending to a pre-existing file) up to
		the end.


        But wait! you also get...
                A routine called char * ErrorName(HRESULT) which takes
                a ddraw return value and returns a string describing it.
                Very handy.
                BTW: this header file includes a statically declared array
                full of names, at file level scope. This means you get a 2k
                array in your source wether you want ErrorName or not.
                Go ahead and edit this file if you don't want this array.

        NOTE: this uses WNetGetUser API, so you'll need to add mpr.lib
        to you LIBS line in your makefile.
*/

//#include <stdio.h>
#include <windows.h>
#include <windowsx.h> 


struct {
	char name[100];
	HRESULT errcode;
} ErrorLookup[] = {
				{"DD_OK",DD_OK},
				{"DDERR_ALREADYINITIALIZED",DDERR_ALREADYINITIALIZED},
				{"DDERR_CANNOTATTACHSURFACE",DDERR_CANNOTATTACHSURFACE},
				{"DDERR_CANNOTDETACHSURFACE",DDERR_CANNOTDETACHSURFACE},
				{"DDERR_CURRENTLYNOTAVAIL",DDERR_CURRENTLYNOTAVAIL},
				{"DDERR_EXCEPTION",DDERR_EXCEPTION},
				{"DDERR_GENERIC",DDERR_GENERIC},
				{"DDERR_HEIGHTALIGN",DDERR_HEIGHTALIGN},
				{"DDERR_INCOMPATIBLEPRIMARY",DDERR_INCOMPATIBLEPRIMARY},
				{"DDERR_INVALIDCAPS",DDERR_INVALIDCAPS},
				{"DDERR_INVALIDCLIPLIST",DDERR_INVALIDCLIPLIST},
				{"DDERR_INVALIDMODE",DDERR_INVALIDMODE},
				{"DDERR_INVALIDOBJECT",DDERR_INVALIDOBJECT},
				{"DDERR_INVALIDPARAMS",DDERR_INVALIDPARAMS},
				{"DDERR_INVALIDPIXELFORMAT",DDERR_INVALIDPIXELFORMAT},
				{"DDERR_INVALIDRECT",DDERR_INVALIDRECT},
				{"DDERR_LOCKEDSURFACES",DDERR_LOCKEDSURFACES},
				{"DDERR_NO3D",DDERR_NO3D},
				{"DDERR_NOALPHAHW",DDERR_NOALPHAHW},
				{"DDERR_NOANTITEARHW",DDERR_NOANTITEARHW},
				{"DDERR_NOBLTQUEUEHW",DDERR_NOBLTQUEUEHW},
				{"DDERR_NOCLIPLIST",DDERR_NOCLIPLIST},
				{"DDERR_NOCOLORCONVHW",DDERR_NOCOLORCONVHW},
				{"DDERR_NOCOOPERATIVELEVELSET",DDERR_NOCOOPERATIVELEVELSET},
				{"DDERR_NOCOLORKEY",DDERR_NOCOLORKEY},
				{"DDERR_NOCOLORKEYHW",DDERR_NOCOLORKEYHW},
				{"DDERR_NOEXCLUSIVEMODE",DDERR_NOEXCLUSIVEMODE},
				{"DDERR_NOFLIPHW",DDERR_NOFLIPHW},
				{"DDERR_NOGDI",DDERR_NOGDI},
				{"DDERR_NOMIRRORHW",DDERR_NOMIRRORHW},
				{"DDERR_NOTFOUND",DDERR_NOTFOUND},
				{"DDERR_NOOVERLAYHW",DDERR_NOOVERLAYHW},
				{"DDERR_NORASTEROPHW",DDERR_NORASTEROPHW},
				{"DDERR_NOROTATIONHW",DDERR_NOROTATIONHW},
				{"DDERR_NOSTRETCHHW",DDERR_NOSTRETCHHW},
				{"DDERR_NOT4BITCOLOR",DDERR_NOT4BITCOLOR},
				{"DDERR_NOT4BITCOLORINDEX",DDERR_NOT4BITCOLORINDEX},
				{"DDERR_NOT8BITCOLOR",DDERR_NOT8BITCOLOR},
				{"DDERR_NOTEXTUREHW",DDERR_NOTEXTUREHW},
				{"DDERR_NOVSYNCHW",DDERR_NOVSYNCHW},
				{"DDERR_NOZBUFFERHW",DDERR_NOZBUFFERHW},
				{"DDERR_NOZOVERLAYHW",DDERR_NOZOVERLAYHW},
				{"DDERR_OUTOFCAPS",DDERR_OUTOFCAPS},
				{"DDERR_OUTOFMEMORY",DDERR_OUTOFMEMORY},
				{"DDERR_OUTOFVIDEOMEMORY",DDERR_OUTOFVIDEOMEMORY},
				{"DDERR_OVERLAYCANTCLIP",DDERR_OVERLAYCANTCLIP},
				{"DDERR_OVERLAYCOLORKEYONLYONEACTIVE",DDERR_OVERLAYCOLORKEYONLYONEACTIVE},
				{"DDERR_PALETTEBUSY",DDERR_PALETTEBUSY},
				{"DDERR_COLORKEYNOTSET",DDERR_COLORKEYNOTSET},
				{"DDERR_SURFACEALREADYATTACHED",DDERR_SURFACEALREADYATTACHED},
				{"DDERR_SURFACEALREADYDEPENDENT",DDERR_SURFACEALREADYDEPENDENT},
				{"DDERR_SURFACEBUSY",DDERR_SURFACEBUSY},
				{"DDERR_SURFACEISOBSCURED",DDERR_SURFACEISOBSCURED},
				{"DDERR_SURFACELOST",DDERR_SURFACELOST},
				{"DDERR_SURFACENOTATTACHED",DDERR_SURFACENOTATTACHED},
				{"DDERR_TOOBIGHEIGHT",DDERR_TOOBIGHEIGHT},
				{"DDERR_TOOBIGSIZE",DDERR_TOOBIGSIZE},
				{"DDERR_TOOBIGWIDTH",DDERR_TOOBIGWIDTH},
				{"DDERR_UNSUPPORTED",DDERR_UNSUPPORTED},
				{"DDERR_UNSUPPORTEDFORMAT",DDERR_UNSUPPORTEDFORMAT},
				{"DDERR_UNSUPPORTEDMASK",DDERR_UNSUPPORTEDMASK},
				{"DDERR_VERTICALBLANKINPROGRESS",DDERR_VERTICALBLANKINPROGRESS},
				{"DDERR_WASSTILLDRAWING",DDERR_WASSTILLDRAWING},
				{"DDERR_XALIGN",DDERR_XALIGN},
				{"DDERR_INVALIDDIRECTDRAWGUID",DDERR_INVALIDDIRECTDRAWGUID},
				{"DDERR_DIRECTDRAWALREADYCREATED",DDERR_DIRECTDRAWALREADYCREATED},
				{"DDERR_NODIRECTDRAWHW",DDERR_NODIRECTDRAWHW},
				{"DDERR_PRIMARYSURFACEALREADYEXISTS",DDERR_PRIMARYSURFACEALREADYEXISTS},
				{"DDERR_NOEMULATION",DDERR_NOEMULATION},
				{"DDERR_REGIONTOOSMALL",DDERR_REGIONTOOSMALL},
				{"DDERR_CLIPPERISUSINGHWND",DDERR_CLIPPERISUSINGHWND},
				{"DDERR_NOCLIPPERATTACHED",DDERR_NOCLIPPERATTACHED},
				{"DDERR_NOHWND",DDERR_NOHWND},
				{"DDERR_HWNDSUBCLASSED",DDERR_HWNDSUBCLASSED},
				{"DDERR_HWNDALREADYSET",DDERR_HWNDALREADYSET},
				{"DDERR_NOPALETTEATTACHED",DDERR_NOPALETTEATTACHED},
				{"DDERR_NOPALETTEHW",DDERR_NOPALETTEHW},
				{"DDERR_BLTFASTCANTCLIP",DDERR_BLTFASTCANTCLIP},
				{"DDERR_NOBLTHW",DDERR_NOBLTHW},
				{"DDERR_NODDROPSHW",DDERR_NODDROPSHW},
				{"DDERR_OVERLAYNOTVISIBLE",DDERR_OVERLAYNOTVISIBLE},
				{"DDERR_NOOVERLAYDEST",DDERR_NOOVERLAYDEST},
				{"DDERR_INVALIDPOSITION",DDERR_INVALIDPOSITION},
				{"DDERR_NOTAOVERLAYSURFACE",DDERR_NOTAOVERLAYSURFACE},
				{"DDERR_EXCLUSIVEMODEALREADYSET",DDERR_EXCLUSIVEMODEALREADYSET},
				{"DDERR_NOTFLIPPABLE",DDERR_NOTFLIPPABLE},
				{"DDERR_CANTDUPLICATE",DDERR_CANTDUPLICATE},
				{"DDERR_NOTLOCKED",DDERR_NOTLOCKED},
				{"DDERR_CANTCREATEDC",DDERR_CANTCREATEDC},
				{"DDERR_NODC",DDERR_NODC},
				{"DDERR_WRONGMODE",DDERR_WRONGMODE},
				{"DDERR_IMPLICITLYCREATED",DDERR_IMPLICITLYCREATED},
				{"DDERR_NOTPALETTIZED",DDERR_NOTPALETTIZED},
				{"DDERR_UNSUPPORTEDMODE",DDERR_UNSUPPORTEDMODE},
				{"END",0}
};

inline char * ErrorName(HRESULT err)
{
	int e=0;
	while (strcmp(ErrorLookup[e].name,"END"))
	{
		if (err == ErrorLookup[e].errcode)
			return ErrorLookup[e].name;
		e++;
	};
	return "Unknown Error code";
}	


class CLogfile
{	
	private:
		char smalltemp[10];
		HFILE 	fh;
		OFSTRUCT of;
		BOOL bHeaderWritten;
		char *cComment;
		char line[1000];
		LONG lStartPos;
		char Path[200];
	public:
		CLogfile(char * path, char * comment = 0,BOOL bAppend=FALSE)
		{
			if (path)
				strncpy(Path,path,199);

			fh = HFILE_ERROR;
			bHeaderWritten = FALSE;
			lStartPos = 0;

			//if the file does not exist, create it:
			if (GetFileAttributes(path) == 0xffffffff)
				fh = OpenFile(path,&of,OF_CREATE|OF_READWRITE|OF_SHARE_DENY_WRITE);
			else
				//first attempt to get a lock on the file...
				for (int i=0;i<20 && fh==HFILE_ERROR;i++)
				{
					if (bAppend)
						fh = OpenFile(path,&of, OF_READWRITE|OF_SHARE_DENY_WRITE);
					else
						fh = OpenFile(path,&of, OF_CREATE|OF_READWRITE|OF_SHARE_DENY_WRITE);
					if (fh==HFILE_ERROR)
						Sleep(1000);
				}

			if (fh==HFILE_ERROR)
				return;

			lStartPos = _llseek(fh,0,SEEK_END);

			cComment = comment;
		}

		void OutputHeader(void)
		{
			//now we have the file, write user/computer info:

			//write separator, comment if necessary and date and time:
			SYSTEMTIME st;
			GetLocalTime(&st);
			wsprintf(line,"----------------------------------------------------------\r\n");
			_lwrite(fh,line,strlen(line));
			if (cComment && strlen(cComment))
			{
				wsprintf(line,"%s\r\n",cComment);
				_lwrite(fh,line,strlen(line));
			}
			wsprintf(line,"Beginning test at %d:%02d on %d/%d/%d\r\n",st.wHour,st.wMinute,st.wYear,st.wMonth,st.wDay);
			_lwrite(fh,line,strlen(line));


			//write user's name:
			DWORD length = 100;
			wsprintf(line,"User Name:");

			WNetGetUser(NULL,line+strlen(line),&length);
			_lwrite(fh,line,strlen(line));

			//write computer's name:
			wsprintf(line,"\r\nComputer Name:");
			GetComputerName(line+strlen(line),&length);
			_lwrite(fh,line,strlen(line));

			//write display driver's name:
			wsprintf(line,"\r\nDisplay driver:");
			GetPrivateProfileString("boot.description","display.drv","(Unknown)",line+strlen(line),100,"system.ini");
			_lwrite(fh,line,strlen(line));

			_lwrite(fh,"\r\n",2);

			HDC hdc = GetDC(NULL);
			if (hdc)
			{
				wsprintf(line,"Starting resolution: %dx%dx%d\r\n",
							GetDeviceCaps(hdc,HORZRES)
							,GetDeviceCaps(hdc,VERTRES)
							,GetDeviceCaps(hdc,BITSPIXEL) );
				_lwrite(fh,line,strlen(line));
				ReleaseDC(NULL,hdc);
			}
			wsprintf(line,"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n");
			_lwrite(fh,line,strlen(line));

			bHeaderWritten = TRUE;
		}
		~CLogfile()
		{
			SYSTEMTIME st;
			if(fh != HFILE_ERROR)
			{
				if (bHeaderWritten)
				{
					GetLocalTime(&st);
					wsprintf(line,"----------- Test ends at %d:%02d on %d/%d/%d -------------\r\n",st.wHour,st.wMinute,st.wYear,st.wMonth,st.wDay);
					_lwrite(fh,line,strlen(line));
				}
				_lclose(fh);
			}
		}
		CLogfile & operator << (DWORD dw)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			wsprintf(smalltemp,"%08x",dw);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (LONG dw)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			wsprintf(smalltemp,"%d",dw);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
                CLogfile & operator << (void * p)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
            wsprintf(smalltemp,"%08x",p);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (char * cp)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			while( *cp)
				*this << *cp++;
			return *this;
		}
		CLogfile & operator << (char  c)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			if (c=='\n')
			{
				wsprintf(smalltemp,"\r");
				_lwrite(fh,smalltemp,strlen(smalltemp));
			}
			wsprintf(smalltemp,"%c",c);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (CLogfile & log)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();

			LONG pos = _llseek(log.fh,0,FILE_CURRENT);
			LONG from = _llseek(log.fh,log.lStartPos,FILE_BEGIN);

			char ch;
			*this << "= = = = = = = Snapshot of ";
			if (log.Path)
				*this << log.Path;
			else
				*this << "Unknown file";
			*this << " = = = = = = =\n";

			for (LONG j=0;j<pos-from;j++)
			{
				_lread(log.fh,&ch,1);
				*this << ch;
			}

			*this << "= = = = = = = = = Snapshot ends = = = = = = = = = = =\n";
			return *this;
		}
			
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\misc\memalloc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.c
 *  Content:    allocates memory
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   20-jan-95  craige  initial implementation
 *   27-feb-95  craige  don't call HeapFree with NULL, it is a huge time sink
 *   29-mar-95  craige  memory tracker
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   22-may-95  craige  added MemAlloc16
 *   12-jun-95  craige  added MemReAlloc
 *   18-jun-95  craige  deadlock joy: don't take DLL csect here
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *   29-feb-96  colinmc added optional debugging code to blat a a specific
 *                      bit pattern over freed memory
 *   08-oct-96	ketand	change debug message to give a total for the terminating
 *			process
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "memalloc.h"
#include "dpf.h"

#define FREE_MEMORY_PATTERN 0xDEADBEEFUL

#ifdef WIN95
    #ifdef NOSHARED
	#define HEAP_SHARED     0
    #else
	#define HEAP_SHARED     0x04000000      // put heap in shared memory
    #endif
#else
    #define HEAP_SHARED         0
#endif

static HANDLE   hHeap = NULL;           // handle to shared heap for this DLL

/*
 * memory track struct and list
 */
#ifdef DEBUG
#define MCOOKIE 0xbaaabaaa
#define MCOOKIE_FREE    0xbabababa
typedef struct _MEMTRACK
{
    DWORD               dwCookie;
    struct _MEMTRACK    FAR *lpNext;
    struct _MEMTRACK    FAR *lpPrev;
    DWORD               dwSize;
    LPVOID              lpAddr;
    DWORD               dwPid;
} MEMTRACK, FAR *LPMEMTRACK;

static LPMEMTRACK       lpHead;
static LPMEMTRACK       lpTail;
static LONG             lAllocCount;

#define DEBUG_TRACK( lptr, first ) \
    if( lptr == NULL ) \
    { \
	DPF( 1, "Alloc of size %u FAILED!", size ); \
    } \
    else \
    { \
	LPMEMTRACK      pmt; \
	pmt = (LPMEMTRACK) lptr; \
	pmt->dwSize = size - sizeof( MEMTRACK ); \
	pmt->dwCookie = MCOOKIE; \
	pmt->lpAddr = _ReturnAddress(); \
	pmt->dwPid = GetCurrentProcessId(); \
	if( lpHead == NULL ) \
	{ \
	    lpHead = lpTail = pmt; \
	} \
	else \
	{ \
	    lpTail->lpNext = pmt; \
	    pmt->lpPrev = lpTail; \
	    lpTail = pmt; \
	} \
	lptr = (LPVOID) (((LPBYTE) lptr) + sizeof( MEMTRACK )); \
	lAllocCount++; \
    }

#define DEBUG_TRACK_UPDATE_SIZE( s ) s += sizeof( MEMTRACK );

#else

#define DEBUG_TRACK( lptr, first )
#define DEBUG_TRACK_UPDATE_SIZE( size )

#endif


#if defined( WIN95 ) && defined( WANT_MEM16 )

extern DWORD _stdcall MapLS( LPVOID ); // flat -> 16:16
extern void _stdcall UnMapLS( DWORD ); // unmap 16:16

typedef struct SELLIST {
    struct SELLIST      *link;
    LPBYTE              base;
    WORD                sel;
} SELLIST, *LPSELLIST;

static LPSELLIST        lpSelList;

/*
 * MemAlloc16
 *
 * Allocate some memory, and return a 16:16 pointer to that memory
 *
 * NOTE: ASSUMES WE ARE IN THE DLL CRITICAL SECTION!
 */
LPVOID __cdecl MemAlloc16( UINT size, LPDWORD p16 )
{
    LPBYTE              lptr;
    LPSELLIST           psel;
    DWORD               diff;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );
    if( lptr == NULL )
    {
	return NULL;
    }

    /*
     * try to find an existing selector that maps this area
     */
    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff+size < 0xf000 )
	    {
		*p16 = ((DWORD)psel->sel << 16l) + diff;
		return lptr;
	    }
	}
	psel = psel->link;
    }

    /*
     * no selector found, create a new one
     */
    psel = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, sizeof( SELLIST ));
    if( psel == NULL )
    {
	return NULL;
    }
    psel->sel = HIWORD( MapLS( lptr ) );
    DPF( 2, "$$$$$$ New selector allocated: %04x", psel->sel );
    psel->base = lptr;
    psel->link = lpSelList;
    lpSelList = psel;
    *p16 = ((DWORD) psel->sel) << 16l;

    return lptr;

} /* MemAlloc16 */

/*
 * GetPtr16
 */
LPVOID GetPtr16( LPVOID ptr )
{
    DWORD       diff;
    DWORD       p16;
    LPSELLIST   psel;
    LPBYTE      lptr;

    lptr = ptr;

    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff <= 0xf000 )
	    {
		p16 = ((DWORD)psel->sel << 16l) + diff;
		return (LPVOID) p16;
	    }
	}
	psel = psel->link;
    }
    DPF( 1, "ERROR: NO 16:16 PTR for %08lx", lptr );
    return NULL;

} /* GetPtr16 */

/*
 * freeSelectors
 */
static void freeSelectors( void )
{
    LPSELLIST           psel;
    LPSELLIST           link;

    psel = lpSelList;
    while( psel != NULL )
    {
	link = psel->link;
	DPF( 2, "$$$$$$ Freeing selector %04x", psel->sel );
	UnMapLS( ((DWORD)psel->sel) << 16l );
	HeapFree( hHeap, 0, psel );
	psel = link;
    }
    lpSelList = NULL;

} /* freeSelectors */
#endif

/*
 * MemAlloc - allocate memory from our global pool
 */
LPVOID __cdecl MemAlloc( UINT size )
{
    LPBYTE lptr;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );

    return lptr;

} /* MemAlloc */

/*
 * MemSize - return size of object
 */
UINT_PTR __cdecl MemSize( LPVOID lptr )
{
#ifdef DEBUG
    if (lptr)
    {
	LPMEMTRACK  pmt;
	lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	pmt = lptr;
	return pmt->dwSize;
    }
#endif
    return HeapSize(hHeap, 0, lptr);

} /* MemSize */

/*
 * MemFree - free memory from our global pool
 */
void MemFree( LPVOID lptr )
{
    if( lptr != NULL )
    {
	#ifdef DEBUG
	{
	    /*
	     * get real pointer and unlink from chain
	     */
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;

	    if( pmt->dwCookie == MCOOKIE_FREE )
	    {
		DPF( 1, "FREE OF FREED MEMORY! ptr=%08lx", pmt );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	    else if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID FREE! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	    else
	    {
		pmt->dwCookie = MCOOKIE_FREE;
		if( pmt == lpHead && pmt == lpTail )
		{
		    lpHead = NULL;
		    lpTail = NULL;
		}
		else if( pmt == lpHead )
		{
		    lpHead = pmt->lpNext;
		    lpHead->lpPrev = NULL;
		}
		else if( pmt == lpTail )
		{
		    lpTail = pmt->lpPrev;
		    lpTail->lpNext = NULL;
		}
		else
		{
		    pmt->lpPrev->lpNext = pmt->lpNext;
		    pmt->lpNext->lpPrev = pmt->lpPrev;
		}

		#ifdef FILL_ON_MEMFREE
		{
		    LPDWORD lpMem;
		    DWORD   dwPat;
		    DWORD   dwSize;

		    dwSize = pmt->dwSize;
		    lpMem = (LPDWORD)( (LPBYTE)lptr + sizeof( MEMTRACK ) );
		    while (dwSize >= sizeof(DWORD))
		    {
			*lpMem++ = FREE_MEMORY_PATTERN;
			dwSize -= sizeof(DWORD);
		    }
		    if (dwSize != 0UL)
		    {
			dwPat = FREE_MEMORY_PATTERN;
			memcpy(lpMem, &dwPat, dwSize);
		    }
		}
		#endif
	    }
	    lAllocCount--;
	    if( lAllocCount < 0 )
	    {
		DPF( 1, "Too Many Frees!\n" );
	    }
	}
	#endif

	HeapFree( hHeap, 0, lptr );

    }

} /* MemFree */

/*
 * MemReAlloc
 */
LPVOID __cdecl MemReAlloc( LPVOID lptr, UINT size )
{
    LPVOID new;

    DEBUG_TRACK_UPDATE_SIZE( size );
    #ifdef DEBUG
	if( lptr != NULL )
	{
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;
	    if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID REALLOC! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	}
    #endif

    new = HeapReAlloc( hHeap, HEAP_ZERO_MEMORY, lptr, size );

    #ifdef DEBUG
    if (new != NULL)
    {
	LPMEMTRACK pmt = new;

	pmt->dwSize = size - sizeof( MEMTRACK );

	if( lptr == (LPVOID)lpHead )
	    lpHead = pmt;
	else
	    pmt->lpPrev->lpNext = pmt;

	if( lptr == (LPVOID)lpTail )
	    lpTail = pmt;
	else
	    pmt->lpNext->lpPrev = pmt;

	new = (LPVOID) (((LPBYTE)new) + sizeof(MEMTRACK));
    }
    #endif
    return new;

} /* MemReAlloc */

/*
 * MemInit - initialize the heap manager
 */
BOOL MemInit( void )
{
    if( hHeap == NULL )
    {
	hHeap = HeapCreate( HEAP_SHARED, 0x2000, 0 );
	if( hHeap == NULL )
	{
	    return FALSE;
	}
    }
    #ifdef DEBUG
	lAllocCount = 0;
	lpHead = NULL;
	lpTail = NULL;
    #endif
    return TRUE;

} /* MemInit */

#ifdef DEBUG
/*
 * MemState - finished with our heap manager
 */
void MemState( void )
{
    DPF( 2, "MemState" );
    if( lAllocCount != 0 )
    {
	DPF( 1, "Memory still allocated!  Alloc count = %ld", lAllocCount );
	DPF( 1, "Current Process (pid) = %08lx", GetCurrentProcessId() );
    }
    if( lpHead != NULL )
    {
	LPMEMTRACK      pmt;
	DWORD		dwTotal = 0;
	DWORD		pidCurrent = GetCurrentProcessId();
	pmt = lpHead;
	while( pmt != NULL )
	{
	    if( pidCurrent == pmt->dwPid )
		dwTotal += pmt->dwSize;
	    DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx (pid=%08lx)", pmt, pmt->dwSize, pmt->lpAddr, pmt->dwPid );
	    pmt = pmt->lpNext;
	}
	DPF ( 1, "Total Memory Unfreed From Current Process = %ld bytes", dwTotal );
    }
} /* MemState */
#endif

/*
 * MemFini - finished with our heap manager
 */
void MemFini( void )
{
    DPF( 2, "MemFini!" );
    #ifdef DEBUG
	MemState();
    #endif
    #if defined( WIN95 ) && defined( WANT_MEM16 )
	freeSelectors();
    #endif
    if( hHeap )
    {
	HeapDestroy( hHeap );
	hHeap = NULL;
    }
} /* MemFini */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\misc\lists.h ===
/* Copyright (c) 1997  Microsoft Corporation */
/* See the .C test code at the end of this file for examples of how to use
   this stuff.
*/
#ifndef	_LISTS_H
#define	_LISTS_H

#if __cplusplus
extern "C" {
#endif

#define LIST_ROOT(name, type) struct name {struct type *Root;}

#define LIST_MEMBER(type) struct { struct type **Prev; struct type *Next;}
/* Note!  Prev is the ADDRESS of the previous next element ptr */

#define LIST_INSERT_ROOT(root,element,field)\
{   if(((element)->field.Next = (root)->Root) != 0)\
	(root)->Root->field.Prev = &(element)->field.Next;\
    (root)->Root = (element);\
    (element)->field.Prev = &(root)->Root;\
}

#define LIST_DELETE(element,field)\
{\
    if((element)->field.Next)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define	LIST_INITIALIZE(root)\
{\
    (root)->Root = 0;\
}

#define LIST_INITIALIZE_MEMBER(element,field)\
{   (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define LIST_ORPHAN_MEMBER(element,field) (!((element)->field.Prev))

#define LIST_FIRST(root) (root)->Root
#define LIST_NEXT(element,field) (element)->field.Next



#define	TAIL_QUEUE_INITIALIZE(root)\
{\
    (root)->First = NULL;\
    (root)->Last = &(root)->First;\
}

#define TAIL_QUEUE_ROOT(name,type)\
struct name\
{   struct type *First;\
    struct type **Last;\
}/* NOTE!  This is the address of the last Next pointer. */


#define TAIL_QUEUE_MEMBER(type)\
struct\
{   struct type *Next;\
    struct type **Prev;	/* NOTE!  Address of previous Next element ptr */\
}

#define TAIL_QUEUE_INSERT_END(root,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = 0;\
    *(root)->Last = (element);\
    (root)->Last = &(element)->field.Next;\
}

#define TAIL_QUEUE_DELETE(root,element,field)\
{\
    if (((element)->field.Next) != NULL)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define TAIL_QUEUE_FIRST(root) (root)->First
#define TAIL_QUEUE_NEXT(element,field) (element)->field.Next



#define CIRCLE_QUEUE_ROOT(name,type)\
struct name\
{   struct type *Last;\
    struct type *First;\
}

#define CIRCLE_QUEUE_MEMBER(type)\
struct\
{   struct type *Prev;\
    struct type *Next;\
}

#define	CIRCLE_QUEUE_INITIALIZE(root,type)\
{   (root)->Last = (type *)(root);\
    (root)->First = (type *)(root);\
}

#define CIRCLE_QUEUE_INITIALIZE_MEMBER(element,field)\
{ (element)->field.Next = (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_INSERT_END(root,type,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = (type *)(root);\
    if((root)->First != (type *)(root))\
	(root)->Last->field.Next = (element);\
    else\
	(root)->First = (element);\
    (root)->Last = (element);\
}

#define CIRCLE_QUEUE_INSERT_ROOT(root,type,element,field)\
{   (element)->field.Prev = (type *)(root);\
    (element)->field.Next = (root)->First;\
    if ((root)->Last != (void *)(root))\
	(root)->First->field.Prev = (element);\
    else\
	(root)->Last = (element);\
    (root)->First = (element);\
}

#define CIRCLE_QUEUE_INSERT_PREVIOUS(root,current_element,element,field)\
{   (element)->field.Prev = (current_element)->field.Prev;\
    (element)->field.Next = (current_element);\
    if ((current_element)->field.Prev != (void *)(root))\
	(current_element)->field.Prev->field.Next = (element);\
    else\
	(root)->First = (element);\
    (current_element)->field.Prev = (element);\
}

#define	CIRCLE_QUEUE_DELETE(root,element,field)\
{   if((element)->field.Next != (void *)(root))\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    if((element)->field.Prev != (void *)(root))\
	(element)->field.Prev->field.Next = (element)->field.Next;\
    else\
	(root)->First = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_FIRST(root)\
((root)->First == (void *) (root)? 0: (root)->First)

#define CIRCLE_QUEUE_LAST(root)\
((root)->Last == (void *) (root)? 0: (root)->Last)

#define CIRCLE_QUEUE_NEXT(root,element,field)\
((void *) (element)->field.Next == (void *) (root)? 0: (element)->field.Next)

#define CIRCLE_QUEUE_PREVIOUS(root,element,field)\
((element)->field.Prev == (void *) (root)? 0: (element)->field.Prev)

#if 0
/*
Test code.  Strip it out, put it in a .C (or .CPP) file and compile it as a
console app to test this stuff. It should run without any assertion failures.

Also, use this as example code.
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "lists.h"

void TestList(void)
{
    struct Foo
    {
	int a;
	LIST_MEMBER(Foo) ListStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    LIST_ROOT(sRoot, Foo) MyListRoot;

    fputs("Testing LIST.\n",stdout);

    LIST_INITIALIZE(&MyListRoot);

    LIST_INITIALIZE_MEMBER(&MyFoo1,ListStuff);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;

    LIST_INITIALIZE_MEMBER(&MyFoo2,ListStuff);
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;

    LIST_INITIALIZE_MEMBER(&MyFoo3,ListStuff);
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    assert(LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo3,ListStuff);
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    assert(!LIST_ORPHAN_MEMBER(&MyFoo1,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo2,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 3. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 1. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == 0);

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("List passed.\n", stdout);
}

void TestTailQueue(void)
{
    struct Foo
    {
	int a;
	TAIL_QUEUE_MEMBER(Foo) TQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    TAIL_QUEUE_ROOT(sRoot, Foo) MyTQRoot;

    fputs("Testing TAIL_QUEUE.\n",stdout);

    TAIL_QUEUE_INITIALIZE(&MyTQRoot);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo3,TQStuff);

    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 3. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 1. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == 0);

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("Tail Queue passed.\n", stdout);
}
void TestCircleQueue(void)
{
    enum {END,ROOT,PREVIOUS,DONE} WhichInsert = END;
    int i;
    struct Foo
    {
	int a;
	CIRCLE_QUEUE_MEMBER(Foo) CQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    CIRCLE_QUEUE_ROOT(sRoot, Foo) MyCQRoot;

    fputs("Testing CIRCLE_QUEUE.\n",stdout);

    while(WhichInsert != DONE)
    {
	CIRCLE_QUEUE_INITIALIZE(&MyCQRoot,Foo);
	MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
	MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
	MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    
	switch(WhichInsert)
	{
	case END:
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    WhichInsert = ROOT;
	    break;
	case ROOT:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    WhichInsert = PREVIOUS;
	    break;
	case PREVIOUS:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo3,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo2,&MyFoo1,CQStuff);
	    WhichInsert = DONE;
	    break;
	default:
	    assert(0);
	}

        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x2A);
        assert(pFoo->b == 0x2B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo == 0);

	pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == 0);
	pFoo = CIRCLE_QUEUE_LAST(&MyCQRoot);
	assert(pFoo == &MyFoo3);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == &MyFoo2);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,&MyFoo2,CQStuff) == &MyFoo1);
    
        /* Delete member 2. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x2B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Make sure that there are only members 1 and 3 in the list now. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 3. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x3B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 1. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == 0);
    
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        
        /* Delete member 1 while there are other members in the list. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == &MyFoo2);
    
        assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
        assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
        assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);
    }

    fputs("Circle Queue passed.\n", stdout);
}

int main()
{
    TestList();
    TestTailQueue();
    TestCircleQueue();
    fputs("All tests passed.", stdout);
    return EXIT_SUCCESS;
}
#endif /* End of test code. */

#if __cplusplus
}
#endif

#endif // !_LISTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\misc\newdpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.c
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#if defined(DEBUG) || defined(DBG)

#ifdef IS_16
    #define OUTPUTDEBUGSTRING OutputDebugString
    #define GETPROFILESTRING GetProfileString
    #define GETPROFILEINT GetProfileInt
    #define WSPRINTF wsprintf
    #define WVSPRINTF wvsprintf
    #define LSTRLEN lstrlen
#else
    #define OUTPUTDEBUGSTRING OutputDebugStringA
    #define GETPROFILESTRING GetProfileStringA
    #define GETPROFILEINT GetProfileIntA
    #define WSPRINTF wsprintfA
    #define WVSPRINTF wvsprintfA
    #define LSTRLEN lstrlenA
#endif

#include "dpf.h"

#undef DEBUG_TOPIC
#define DEBUG_TOPIC(flag,name) {#flag,name,TRUE},

static 
    struct {
        char cFlag[4];
        char cName[64];
        BOOL bOn;
} DebugTopics[] = {
    {"","Filler",FALSE},
    {"A","API Usage",TRUE},
#include "DBGTOPIC.H"
    {"","End",FALSE}
};

#ifndef DPF_MODULE_NAME
    #define DPF_MODULE_NAME ""
#endif

static DWORD bDetailOn = 1;

static BOOL bInited=FALSE;
static BOOL bAllowMisc=TRUE;
static bBreakOnAsserts=FALSE;
static bPrintLineNumbers=FALSE;
static bPrintFileNames=FALSE;
static bPrintExecutableName=FALSE;
static bPrintTID=FALSE;
static bPrintPID=FALSE;
static bIndentOnMessageLevel=FALSE;
static bPrintTopicsAndLevels=FALSE;
static bPrintModuleName=TRUE;
static bPrintFunctionName=FALSE;
static bRespectColumns=FALSE;
static bPrintAPIStats=FALSE;
static bPrintAllTopics=TRUE;

static DWORD dwFileLineTID=0;
static char cFile[100];
static char cFnName[100];
static DWORD dwLineNo;
static bMute=FALSE;

static BOOL bLogging=FALSE; // whether to use the logging VxD instead of dumping.


DPF_PROC_STATS ProcStats[MAX_PROC_ORDINAL];
#ifdef cplusplus
	extern "C" {
#endif

void mystrncpy(char * to,char * from,int n)
{
    for(;n;n--)
        *(to++)=*(from++);
}

char * mystrrchr(char * in,char c)
{
    char * last=0;
    while (*in)
    {
        if (*in == c)
            last = in;
        in++;
    }
    return last;
}

char Junk[]="DPF_MODNAME undef'd";
char * DPF_MODNAME = Junk;
 
int DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber, LPSTR szFnName)
{
    if (!(bPrintFileNames||bPrintLineNumbers||bPrintFunctionName))
    {
        return 1;
    }
#ifdef WIN32
    dwFileLineTID = GetCurrentThreadId();
#endif
    mystrncpy (cFile,szFile,sizeof(cFile));
    mystrncpy (cFnName,szFnName,sizeof(cFnName));
    dwLineNo = dwLineNumber;
    return 1;
}

/*
BOOL DeviceIoControl( 
HANDLE hDevice, 			// handle to device of interest 
DWORD dwIoControlCode, 		// control code of operation to perform 
LPVOID lpInBuffer, 			// pointer to buffer to supply input data 
DWORD nInBufferSize, 		// size of input buffer 
LPVOID lpOutBuffer, 		// pointer to buffer to receive output data 
DWORD nOutBufferSize, 		// size of output buffer 
LPDWORD lpBytesReturned, 	// pointer to variable to receive output byte count 
LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation 
); 
*/

#define MAX_STRING       240
#define LOG_SIZE         2000
#define FIRST_DEBUG_PROC 100

#define OPEN_DEBUGLOG 	(FIRST_DEBUG_PROC)
#define WRITE_DEBUGLOG 	(FIRST_DEBUG_PROC+1)

HANDLE hDPLAY_VxD=0;

typedef struct _LOGENTRY {
	CHAR	debuglevel;
	CHAR    str[1];
} LOGENTRY, *PLOGENTRY;

typedef struct {
	UINT	nLogEntries;
	UINT    nCharsPerLine;
} IN_LOGINIT, *PIN_LOGINIT;

typedef struct {
	UINT    hr;
} OUT_LOGINIT, *POUT_LOGINIT;

typedef struct {
	CHAR	debuglevel;
	CHAR    str[1];
} IN_LOGWRITE, *PIN_LOGWRITE;

typedef struct {
	UINT	hr;
} OUT_LOGWRITE, *POUT_LOGWRITE;


static void LogString( LPSTR str )
{
	char logstring[MAX_STRING+sizeof(LOGENTRY)];
	int  i=0;
	PLOGENTRY pLogEntry=(PLOGENTRY)&logstring;
	UINT rc;
	UINT cbRet;

	if(hDPLAY_VxD && str){
		while(str[i])i++;
		pLogEntry->debuglevel=0;
		memcpy(pLogEntry->str,str,i+1);
		DeviceIoControl(hDPLAY_VxD,WRITE_DEBUGLOG,pLogEntry,i+sizeof(LOGENTRY), &rc, sizeof(rc), &cbRet, NULL);
	}
}

static void dumpStr( LPSTR str )
{
    /*
     * Have to warm the string, since OutputDebugString is buried
     * deep enough that it won't page the string in before reading it.
     */
    int i=0;
    if (str)
        while(str[i])
            i++;
	if(bLogging!=2)
	{            
	    OUTPUTDEBUGSTRING( str );
	    OUTPUTDEBUGSTRING("\n");
    }
    if(bLogging)
    {
	    LogString(str);
	}    
    
}
    
void DebugPrintfInit(void)
{
    signed int lDebugLevel;
    int i;
    char cTopics[100];

#ifndef PROF_SECT
    #define PROF_SECT	"DirectDraw"
#endif
    bDetailOn=1;

    for (i=0;i<LAST_TOPIC;i++)
        DebugTopics[i].bOn=FALSE;

    //ZeroMemory(ProcStats,sizeof(ProcStats));

    GETPROFILESTRING( "DirectX", DPF_CONTROL_LINE, "DefaultTopics", cTopics, sizeof(cTopics) );
    if (!strcmp(cTopics,"DefaultTopics"))
    {
        DebugSetTopicsAndLevels("");
        bAllowMisc=TRUE;
        bPrintAllTopics=TRUE;
        lDebugLevel = (signed int) GETPROFILEINT( PROF_SECT, "debug", 0 );
        bLogging    = (signed int) GETPROFILEINT( PROF_SECT, "log" , 0);

        if (lDebugLevel <0)
        {
            if (lDebugLevel < -9)
                lDebugLevel=-9;

            bDetailOn |= (1<<(-lDebugLevel));
        }
        else
        {
            for (i=0;i<= (lDebugLevel<10?lDebugLevel:10);i++)
                bDetailOn |= 1<<i;
        }

        if(bLogging){
        	hDPLAY_VxD = CreateFileA("\\\\.\\DPLAY",0,0,0,0,0,0);
        	if(hDPLAY_VxD){
        		IN_LOGINIT In;
        		OUT_LOGINIT Out;
        		UINT cbRet;
        		In.nCharsPerLine=MAX_STRING;
        		In.nLogEntries=5000;
				DeviceIoControl(hDPLAY_VxD,OPEN_DEBUGLOG,&In,sizeof(In), &Out, sizeof(Out), &cbRet, NULL);
        	}
        }
    }
    else
    {
        DebugSetTopicsAndLevels(cTopics);
        if (!strcmp(cTopics,"?") && !bInited)
        {
            dumpStr("--------------" DPF_MODULE_NAME " Debug Output Control -------------");
            dumpStr("Each character on the control line controls a topic, a detail");
            dumpStr("level or an extra info. E.g. 0-36A@ means print detail levels 0");
            dumpStr("through 3 and 6 for topic A with source file name and line numbers.");
            dumpStr("The extra info control characters are:");
            dumpStr("   !: Break on asserts");
            dumpStr("   ^: Print TID of calling thread");
            dumpStr("   #: Print PID of calling process");
            dumpStr("   >: Indent on message detail levels");
            dumpStr("   &: Print the topic and detail level of each message");
            dumpStr("   =: Print function name");
            dumpStr("   +: Print all topics, including topic-less");
            dumpStr("   / or -: do not allow topic-less messages");
            dumpStr("   @ or $: Print source filename and line number of DPF");
            dumpStr("Topics for this module are:");
            for(i=0;strcmp(DebugTopics[i].cName,"End");i++)
            {
                OUTPUTDEBUGSTRING("   ");
                OUTPUTDEBUGSTRING(DebugTopics[i].cFlag);
                OUTPUTDEBUGSTRING(": ");
                dumpStr(DebugTopics[i].cName);
            }
            dumpStr("Tip: Use 0-3A to get debug info about API calls");
        }
    }
    bInited=TRUE;
}


/*
 *
 * The full output can be:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn) Messagemessagemessage
 * or, if indentation turned on:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn)        Messagemessagemessage
 */
int DebugPrintf(DWORD dwDetail, ...)
{
#define MSGBUFFERSIZE 1000
    char cMsg[MSGBUFFERSIZE];
    char cTopics[20];
    DWORD arg;
    LPSTR szFormat;
    BOOL bAllowed=FALSE;
    BOOL bMiscMessage=TRUE;
    int i;

    va_list ap;


    if (!bInited)
        DebugPrintfInit();

	if(bLogging != 2){
	    //error checking:
	    if (dwDetail >= 10)
	        return 1;

	    if ( (bDetailOn & (1<<dwDetail)) == 0 )
	        return 1;

	    if (bMute)
	        return 1;
	}        
    va_start(ap,dwDetail);
    WSPRINTF(cTopics,"%d",dwDetail);

    while ( (arg = va_arg(ap,DWORD)) <256 )
    {
        if (arg>0 && arg < LAST_TOPIC)
        {
            bMiscMessage=FALSE;
            if (DebugTopics[arg].bOn)
                bAllowed = TRUE;
        }
    }
    if (bMiscMessage)
        if (bAllowMisc || dwDetail == 0)
            bAllowed=TRUE;

    if ( bPrintAllTopics )
        bAllowed=TRUE;

    if (!bAllowed)
        return FALSE;

    szFormat = (LPSTR) arg;

    cMsg[0]=0;
    
    /*
     * Add the module name first
     */

    if (bPrintModuleName)
    {
        WSPRINTF( cMsg+strlen(cMsg),DPF_MODULE_NAME ":" );
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"(");

#ifdef WIN32
#if 0
    /*
     * deleted due to RIP in GetModuleFilename on debug windows when win16 lock held
     */
    if (bPrintExecutableName)
    {
        GetModuleFileName(NULL,str,256);
        if (mystrrchr(str,'\\'))
            WSPRINTF(cMsg+strlen(cMsg),"%12s",mystrrchr(str,'\\')+1);
    }
#endif
    if (bPrintPID)
    {
        if (bPrintExecutableName)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Px%02x",GetCurrentProcessId());
    }

    if (bPrintTID)
    {
        if (bPrintExecutableName || bPrintPID)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Tx%04x",GetCurrentThreadId());
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"):");
#endif

    if (bPrintFunctionName)
    {
        WSPRINTF( cMsg+strlen(cMsg),cFnName);
    }

    if (bPrintFileNames || bPrintLineNumbers)
    {
        if (mystrrchr(cFile,'\\'))
            WSPRINTF( cMsg+strlen(cMsg),":%12s",mystrrchr(cFile,'\\')+1 );
        else
            WSPRINTF( cMsg+strlen(cMsg),":%12s",cFile);
        WSPRINTF( cMsg+strlen(cMsg),"@%d",dwLineNo);
    }

    if (bPrintTopicsAndLevels)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(%3s)",cTopics);
    }

    if (cMsg[strlen(cMsg)-1] != ':')
        WSPRINTF( cMsg+strlen(cMsg),":");

    if (bIndentOnMessageLevel)
    {
        for(i=0;(DWORD)i<dwDetail;i++)
            strcat(cMsg," ");
    }

    WVSPRINTF( cMsg+LSTRLEN( cMsg ), szFormat, ap);

    if (bAllowed)
        dumpStr( cMsg );

    va_end(ap);
    return 1;
    
}

void DebugSetMute(BOOL bMuteFlag)
{
    bMute=bMuteFlag;
}

void DebugEnterAPI(char *pFunctionName , LPDWORD pIface)
{
    DebugPrintf(2,A,"%08x->%s",pIface,pFunctionName);
}

void DebugSetTopicsAndLevels(char * cTopics)
{
    int i;
    int j;
    bAllowMisc=TRUE;
    bBreakOnAsserts=FALSE;
    bPrintLineNumbers=FALSE;
    bPrintFileNames=FALSE;
    bPrintExecutableName=FALSE;
    bPrintTID=FALSE;
    bPrintPID=FALSE;
    bIndentOnMessageLevel=FALSE;
    bPrintTopicsAndLevels=FALSE;
    bPrintFunctionName=FALSE;
    bPrintAPIStats=FALSE;
    bPrintAllTopics=FALSE;
    bDetailOn=1;    /* always print detail level 0*/


    for (i=0;(DWORD)i<strlen(cTopics);i++)
    {
        switch (cTopics[i])
        {
        case '/':
        case '-':
            bAllowMisc=FALSE;
            break;
        case '!':
            bBreakOnAsserts=TRUE;
            break;
        case '@':
            bPrintLineNumbers=TRUE;
            break;
        case '$':
            bPrintFileNames=TRUE;
            break;
#if 0
            /*
             * Currently deleted because GetModuleFilename causes a RIP on debug windows when the win16
             * lock is held.
             */
        case '?':
            bPrintExecutableName=TRUE;
            break;
#endif
        case '^':
            bPrintTID=TRUE;
            break;
        case '#':
            bPrintPID=TRUE;
            break;
        case '>':
            bIndentOnMessageLevel=TRUE;
            break;
        case '&':
            bPrintTopicsAndLevels=TRUE;
            break;
        case '=':
            bPrintFunctionName=TRUE;
            break;
        case '%':
            bPrintAPIStats=TRUE;
            break;
        case '+':
            bPrintAllTopics=TRUE;
            break;
        default:
            if (cTopics[i]>='0' && cTopics[i]<='9')
            {
                if (cTopics[i+1]=='-')
                {
                    if (cTopics[i+2]>='0' && cTopics[i+2]<='9')
                    {
                        for(j=cTopics[i]-'0';j<=cTopics[i+2]-'0';j++)
                            bDetailOn |= 1<<j;
                        i+=2;
                    }
                }
                else
                    bDetailOn |= 1<<(cTopics[i]-'0');
            }
            else
            {
                for(j=0;j<LAST_TOPIC;j++)
                    if (cTopics[i]==DebugTopics[j].cFlag[0])
                        DebugTopics[j].bOn=TRUE;
            }
        } //end switch
    }
}


/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    WSPRINTF( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( bBreakOnAsserts || GETPROFILEINT( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
	/*
	 * Into the debugger we go...
	 */
	DEBUG_BREAK();
    }
}


#ifdef cplusplus
}
#endif

#endif //defined debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\misc\w95help.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95help.h
 *  Content:	header file for Win95 helper interface
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo	return an HRESULT from HelperAddDPlayServer()
 *
 ***************************************************************************/
#ifndef __W95HELP_INCLUDED__
#define __W95HELP_INCLUDED__
#include "ddhelp.h"

#ifdef __cplusplus
extern "C" {
#endif

extern void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void SignalNewDriver( LPSTR fname, BOOL isdisp );

extern BOOL CreateHelperProcess( LPDWORD ppid );

extern void DoneWithHelperProcess( void );

extern BOOL WaitForHelperStartup( void );

extern DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context );

extern void HelperCreateThread( void );

extern DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx );

extern DWORD HelperWaveClose( DWORD hwo );

extern DWORD HelperCreateTimer( DWORD dwResolution,LPVOID pTimerProc,DWORD dwInstanceData );

extern DWORD HelperKillTimer( DWORD dwTimerID );

#ifdef _WIN32
extern HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern void HelperCallDSEmulatorCleanup( LPVOID pCleanupFunc,
                                         LPVOID pDirectSound );

#endif

extern BOOL HelperCreateModeSetThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern BOOL HelperCreateDOSBoxThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern void HelperKillModeSetThread( DWORD hInstance );

extern void HelperKillDOSBoxThread( DWORD hInstance );

extern DWORD HelperAddDPlayServer(DWORD port);
extern BOOL HelperDeleteDPlayServer();

#ifdef WIN95
extern HANDLE HelperGetDSVxd( void );
#endif

extern void HelperSetOnDisplayChangeNotify( void *pfn );

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\misc\w95help.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95hack.c
 *  Content:	Win95 hack-o-rama code
 *		This is a HACK to handle the fact that Win95 doesn't notify
 *		a DLL when a process is destroyed.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   28-mar-95	craige	initial implementation
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	reworked for new ddhelp
 *   09-may-95	craige	loading any DLL
 *   16-sep-95	craige	bug 1117: must UnmapViewOfFile before closing handle
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo	return an HRESULT from HelperAddDPlayServer()
 *   29-jan-97  colinmc vxd handling stuff is no longer win16 lock specific
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>

#include "w95help.h"
#include "dpf.h"

#undef E_FAIL
#define E_FAIL	0x80004005L

//extern DWORD	* pdwHelperPid;
//extern HANDLE	* phModule;	// must be defined
extern DWORD	dwHelperPid;
extern HANDLE	hModule;	// must be defined


/*
 * sendRequest
 *
 * communicate a request to DDHELP
 */
static BOOL sendRequest( LPDDHELPDATA req_phd )
{
    LPDDHELPDATA	phd;
    HANDLE		hmem;
    HANDLE		hmutex;
    HANDLE		hackevent;
    HANDLE		hstartevent;
    BOOL		rc;

    /*
     * get events start/ack events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_EVENT_NAME );
    if( hstartevent == NULL )
    {
	return FALSE;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_ACK_EVENT_NAME );
    if( hackevent == NULL )
    {
	CloseHandle( hstartevent );
	return FALSE;
    }

    /*
     * create shared memory area
     */
    hmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
    		PAGE_READWRITE, 0, sizeof( DDHELPDATA ),
		DDHELP_SHARED_NAME );
    if( hmem == NULL )
    {
	DPF( 1, "Could not create file mapping!" );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    phd = (LPDDHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
    if( phd == NULL )
    {
	DPF( 1, "Could not create view of file!" );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }

    /*
     * wait for access to the shared memory
     */
    hmutex = OpenMutex( SYNCHRONIZE, FALSE, DDHELP_MUTEX_NAME );
    if( hmutex == NULL )
    {
	DPF( 1, "Could not create mutex!" );
	UnmapViewOfFile( phd );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    WaitForSingleObject( hmutex, INFINITE );

    /*
     * wake up DDHELP with our request
     */
    memcpy( phd, req_phd, sizeof( DDHELPDATA ) );
    phd->req_id = hModule;
    if( SetEvent( hstartevent ) )
    {
	WaitForSingleObject( hackevent, INFINITE );
	memcpy( req_phd, phd, sizeof( DDHELPDATA ) );
	rc = TRUE;
    }
    else
    {
	DPF( 1, "Could not signal event to notify DDHELP" );
	rc = FALSE;
    }

    /*
     * done with things
     */
    ReleaseMutex( hmutex );
    CloseHandle( hmutex );
    CloseHandle( hstartevent );
    CloseHandle( hackevent );
    UnmapViewOfFile( phd );
    CloseHandle( hmem );
    return rc;

} /* sendRequest */

/*
 * DoneWithHelperProcess
 */
void DoneWithHelperProcess( void )
{
    DDHELPDATA	hd;

    if( dwHelperPid == 0 )
    {
	return;
    }

    hd.req = DDHELPREQ_FREEDCLIST;
    sendRequest( &hd );

} /* DoneWithHelperProcess */

/*
 * WaitForHelperStartup
 */
BOOL WaitForHelperStartup( void )
{
    HANDLE	hevent;
    DWORD	rc;

    hevent = CreateEvent( NULL, TRUE, FALSE, DDHELP_STARTUP_EVENT_NAME );
    if( hevent == NULL )
    {
	return FALSE;
    }
    DPF( 3, "Wait DDHELP startup event to be triggered" );
    rc = WaitForSingleObject( hevent, INFINITE );
    CloseHandle( hevent );
    return TRUE;

} /* WaitForHelperStartup */

/*
 * HelperLoadDLL
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context )
{
    DDHELPDATA  hd;
    DWORD       rc = 0;

    if( dllname != NULL )
    {
	hd.req = DDHELPREQ_LOADDLL;
	lstrcpy( hd.fname, dllname );
	if( fnname != NULL )
	{
	    strcpy( hd.func, fnname );
	    hd.context = context;
	    DPF( 3, "Context=%08lx", context );
	}
	else
	{
	    hd.func[0] = 0;
	}
	DPF( 3, "Asking DDHELP to load DLL %s", dllname );
        sendRequest( &hd );
        rc = hd.dwReturn;
    }

    return rc;

} /* HelperLoadDLL */


/*
 * HelperCreateThread
 */
void HelperCreateThread( void )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEHELPERTHREAD;
    sendRequest( &hd );

} /* HelperCreateThread */

/*
 * SignalNewProcess
 *
 * Signal DDHELP that a new process has arrived.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc )
{
    DDHELPDATA	hd;

    if( pid == dwHelperPid )
    {
	DPF( 3, "Helper connected to DLL - no signal required" );
	return;
    }

    DPF( 3, "Signalling DDHELP that a new process has connected" );
    hd.req = DDHELPREQ_NEWPID;
    hd.pid = pid;
    hd.lpNotify = proc;
    sendRequest( &hd );

} /* SignalNewProcess */

/*
 * SignalNewDriver
 *
 * Signal DDHELP that a new driver has been loaded.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewDriver( LPSTR fname, BOOL isdisp )
{
    DDHELPDATA	hd;

    DPF( 3, "Signalling DDHELP to create a new DC" );
    hd.req = DDHELPREQ_NEWDC;
    hd.isdisp = isdisp;
    lstrcpy( hd.fname, fname );
    sendRequest( &hd );

} /* SignalNewDriver */

/*
 * CreateHelperProcess
 */
BOOL CreateHelperProcess( LPDWORD ppid )
{
    if( dwHelperPid == 0 )
    {
	STARTUPINFO		si;
	PROCESS_INFORMATION	pi;
	HANDLE			h;

	h = OpenEvent( SYNCHRONIZE, FALSE, DDHELP_STARTUP_EVENT_NAME );
	if( h == NULL )
	{
	    si.cb = sizeof(STARTUPINFO);
	    si.lpReserved = NULL;
	    si.lpDesktop = NULL;
	    si.lpTitle = NULL;
	    si.dwFlags = 0;
	    si.cbReserved2 = 0;
	    si.lpReserved2 = NULL;

	    DPF( 3, "Creating helper process now" );
	    if( !CreateProcess(NULL, "ddhelp.exe",  NULL, NULL, FALSE,
			       NORMAL_PRIORITY_CLASS,
			       NULL, NULL, &si, &pi) )
	    {
		DPF( 2, "Could not create DDHELP.EXE" );
		return FALSE;
	    }
	    dwHelperPid = pi.dwProcessId;
	    DPF( 3, "Helper rocess created" );
	}
	else
	{
	    DDHELPDATA	hd;
	    DPF( 3, "DDHELP already exists, waiting for DDHELP event" );
	    WaitForSingleObject( h, INFINITE );
	    CloseHandle( h );
	    DPF( 3, "Asking for DDHELP pid" );
	    hd.req = DDHELPREQ_RETURNHELPERPID;
	    sendRequest( &hd );
	    dwHelperPid = hd.pid;
	    DPF( 3, "DDHELP pid = %08lx", dwHelperPid );
	}
	*ppid = dwHelperPid;
	return TRUE;
    }
    *ppid = dwHelperPid;
    return FALSE;

} /* CreateHelperProcess */

#ifndef WINNT   //this is Just For Now... dsound will get the help it needs..jeffno 951206
/*
 * HelperWaveOpen
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx )
{
    DDHELPDATA	hd;

    if( (lphwo != NULL) && (pwfx != NULL) )
    {
	hd.req = DDHELPREQ_WAVEOPEN;
	hd.pData1 = lphwo;
	hd.dwData1 = dwDeviceID;
	hd.dwData2 = (DWORD)pwfx;
	DPF( 3, "Asking DDHELP to Open Wave Device %d", dwDeviceID );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Open param error");
	return MMSYSERR_ERROR;
    }

} /* HelperWaveOpen */

/*
 * HelperWaveClose
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveClose( DWORD hwo )
{
    DDHELPDATA	hd;

    if( (hwo != 0) )
    {
	hd.req = DDHELPREQ_WAVECLOSE;
	hd.dwData1 = hwo;
	DPF( 3, "Asking DDHELP to Close Wave Device ");
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperWaveClose */

/*
 * HelperCreateTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperCreateTimer( DWORD dwResolution,
			 LPVOID	pTimerProc,
			 DWORD dwInstanceData )
{
    DDHELPDATA	hd;

    if( (dwResolution != 0) && (pTimerProc != NULL)  )
    {
	hd.req = DDHELPREQ_CREATETIMER;
	hd.pData1 = pTimerProc;
	hd.dwData1 = dwResolution;
	hd.dwData2 = dwInstanceData;
	DPF( 3, "Asking DDHELP to Create Timer" );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperCreateTimer */

/*
 * HelperKillTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperKillTimer( DWORD dwTimerID )
{
    DDHELPDATA	hd;

    if( (dwTimerID != 0) )
    {
	hd.req = DDHELPREQ_KILLTIMER;
	hd.dwData1 = dwTimerID;
	DPF( 3, "Asking DDHELP to KILL Timer %X", dwTimerID );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperKillTimer */

/*
 * HelperCreateDSMixerThread
 *
 * get the helper to create a mixer thread.
 */
HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
				  LPDWORD pdwThreadParam,
				  DWORD dwFlags,
				  LPDWORD pThreadId )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEDSMIXERTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSMixerThread

/*
 * HelperCreateDSFocusThread
 *
 * get the helper to create a sound focus thread.
 */
HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
				  LPDWORD pdwThreadParam,
				  DWORD dwFlags,
				  LPDWORD pThreadId )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEDSFOCUSTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSFocusThread

/*
 * HelperCallDSEmulatorCleanup
 *
 * Call the DirectSound function which cleans up MMSYSTEM handles
 */
void HelperCallDSEmulatorCleanup( LPVOID callback,
                                  LPVOID pDirectSound )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CALLDSCLEANUP;
    hd.pData1 = callback;
    hd.pData2 = pDirectSound;

    sendRequest( &hd );
}

#endif //not winnt -just for now-jeffno

/*
 * HelperCreateModeSetThread
 *
 * get the helper to load a DLL for us.
 */
BOOL HelperCreateModeSetThread(
		LPVOID callback,
		HANDLE *ph,
		LPVOID lpdd,
		DWORD hInstance )
{
    DDHELPDATA	hd;
    HANDLE	h;
    char	str[64];

    hd.req = DDHELPREQ_CREATEMODESETTHREAD;
    hd.lpModeSetNotify = callback;
    hd.pData1 = lpdd;
    hd.dwData1 = hInstance;
    sendRequest( &hd );
    wsprintf( str, DDHELP_MODESET_EVENT_NAME, hInstance );
    DPF( 3, "Trying to open event \"%s\"", str );
    h = OpenEvent( SYNCHRONIZE, FALSE, str );
    if( h == NULL )
    {
	DPF( 3, "Could not open modeset event!" );
	*ph = NULL;
	return FALSE;
    }
    *ph = h;
    DPF( 1, "HelperCreateModeSetThread GotEvent: %08lx", h );
    return TRUE;

} /* HelperCreateModeSetThread */

/*
 * HelperKillModeSetThread
 *
 * get the helper to load a DLL for us.
 */
void HelperKillModeSetThread( DWORD hInstance )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_KILLMODESETTHREAD;
    hd.dwData1 = hInstance;
    sendRequest( &hd );

} /* HelperKillModeSetThread */

/*
 * HelperCreateDOSBoxThread
 *
 * get the helper to create a thread so kernel mode can notify us of DOS box
 * changes.
 */
BOOL HelperCreateDOSBoxThread(
		LPVOID callback,
		HANDLE *ph,
		LPVOID lpdd,
		DWORD hInstance )
{
    DDHELPDATA	hd;
    HANDLE	h;
    char	str[64];

    hd.req = DDHELPREQ_CREATEDOSBOXTHREAD;
    hd.lpModeSetNotify = callback;
    hd.pData1 = lpdd;
    hd.dwData1 = hInstance;
    sendRequest( &hd );
    wsprintf( str, DDHELP_DOSBOX_EVENT_NAME, hInstance );
    DPF( 3, "Trying to open event \"%s\"", str );
    h = OpenEvent( SYNCHRONIZE, FALSE, str );
    if( h == NULL )
    {
	DPF( 3, "Could not open DOS box event!" );
	*ph = NULL;
	return FALSE;
    }
    *ph = h;
    DPF( 1, "HelperCreateDOSBoxThread GotEvent: %08lx", h );
    return TRUE;

} /* HelperCreateDOSBoxThread */

/*
 * HelperKillDOSBoxThread
 *
 * get the helper to load a DLL for us.
 */
void HelperKillDOSBoxThread( DWORD hInstance )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_KILLDOSBOXTHREAD;
    hd.dwData1 = hInstance;
    sendRequest( &hd );

} /* HelperKillDOSBoxThread */

// notify dphelp.c that we have a new server on this system
DWORD HelperAddDPlayServer(DWORD port)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

	memset(&hd, 0, sizeof(DDHELPDATA));
    hd.req = DDHELPREQ_DPLAYADDSERVER;
    hd.pid = pid;
    hd. dwData1 = port;
    if (sendRequest(&hd))
		return (hd.dwReturn);
	else
		return ((DWORD) E_FAIL);
} // HelperAddDPlayServer

// server is going away
BOOL HelperDeleteDPlayServer(void)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

    hd.req = DDHELPREQ_DPLAYDELETESERVER;
    hd.pid = pid;
    return sendRequest(&hd);

} // HelperDeleteDPlayServer

#ifdef WIN95
    /*
     * Get DDHELP to load the DirectSound VXD (if it has not
     * already done so) and return a handle to the VXD)
     */
    HANDLE HelperGetDSVxd( void )
    {
	DDHELPDATA hd;
	hd.req = DDHELPREQ_GETDSVXDHANDLE;
	sendRequest( &hd );
	return (HANDLE) hd.dwReturn;
    } /* HelperGetDSVxd */
#endif /* WIN95 */

/*
 * HelperSetOnDisplayChangeNotify
 *
 * get the helper to call us back if there is DisplayChange
 * message. (This is for multi-mon topology changes.)
 */
void HelperSetOnDisplayChangeNotify( void *pfn )
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_NOTIFYONDISPLAYCHANGE;
    hd.dwData1 = (DWORD)pfn;
    sendRequest( &hd );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\dplayx\misc\newdpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.h
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DEBUGPF_H
#define __DEBUGPF_H

#include <stdarg.h>
#include <windows.h>

#ifdef __cplusplus
	extern "C" {
#endif
#ifndef DPF_MODNAME
    extern char * DPF_MODNAME;
#endif

#if defined(DEBUG) || defined(DBG)

    #undef DEBUG_TOPIC
    #define DEBUG_TOPIC(flag,name) flag,
    typedef enum DEBUG_TOPICS {
        A=1,    /* For API Usage */
    #include "DBGTOPIC.H"
        LAST_TOPIC
    };

    #line 21
/*
    #undef DBG
    #define DBG 1
    */
    #undef DEBUG
    #define DEBUG
    #if defined( _WIN32 ) && !defined(WINNT)
	#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
    #else
	#define DEBUG_BREAK()       DebugBreak()
    #endif


    /*
     * DEBUG_TOPIC
     * This structure describes a debugging topic and associates a single-letter key to it.
     */

    #define DEBUG_TOPIC_NAME_LENGTH 59
    typedef struct
    {
        DWORD   dwSize; //for versioning
        char    cKey;
        char    cName[DEBUG_TOPIC_NAME_LENGTH];
    } DPF_DEBUG_TOPIC;

    /*
     * PROC_STATS
     * This struct saves statistics about each proc as maintained by DebugEnterProc
     */
    typedef struct
    {
        char            cName[DEBUG_TOPIC_NAME_LENGTH];
        DWORD           dwCalls;
#ifdef WIN32
        LARGE_INTEGER   liTotalTime;
        LARGE_INTEGER   liLastEnteredAt;
#else
        DWORD           dwFiller[8];
#endif
    } DPF_PROC_STATS;

    #define MAX_PROC_ORDINAL 100

    /*
     * Debugging output/flow-control calls
     */
   extern void DebugSetTopicsAndLevels(char * pcTopicsAndLevelsToDisplay);
   extern void DebugHalt(void);       //Break if control level allows
   extern int  DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber,LPSTR szFnName);
   extern int  DebugPrintf(DWORD dwDetail, ...);
   extern void DebugSetMute(BOOL bMuteFlag);
   extern void DebugPrintfInit(void);
   extern void DebugEnterAPI(char *,LPDWORD);
   extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);
 
    #define dprintf(a,b)                            DebugPrintf(a,b);
    #define DPFINIT()                               DebugPrintfInit();
    #define DPF                                     DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
    #define DPF_ERR(a)                              DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf( 0, a )
    #define DPF_ENTERAPI(pIface)                    DebugEnterAPI(DPF_MODNAME,(LPDWORD)pIface)
    #define DPF_APIRETURNS(hr)                      DPF(3,"   %s returns %08x (%d)",DPF_MODNAME,hr,hr&0xfff)
    #define DDASSERT(condition)                     if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)
    #define DPF_MUTEWHEN(c)                         {DebugSetMute((BOOL) (c) );}
    #define DPF_SPEWWHEN(c)                         {DebugSetMute((BOOL) (!(c)) );}
    #define DPF_SETTOPICS(t)
    #define DPF_STRUCT(level,topic,struct_identifier,struct_ptr)    {extern void DUMP_##struct_identifier(DWORD,DWORD,LP##struct_identifier);\
                                                    DUMP_##struct_identifier(level,topic,struct_ptr);}


#else
    #pragma warning(disable:4002)
    #define dprintf()
    #define DPFINIT()
    #define DPFFINI()
    #define DPF()
    #define DPF_ENTERAPI()
    #define DPF_APIRETURNS()
    #define DPF_DUMP()
    #define DPF_DUMPHEX()
    #define DPF_DUMPGUID()
    #define DDASSERT()
    #define DPF_ERR()
    #define DEBUG_BREAK()
    #define DPF_MUTEWHEN()
    #define DPF_SPEWWHEN()
    #define DPF_SETTOPICS()
    #define DPF_DUMPGUID()
    #define DPF_STRUCT()

#endif


#ifdef _WIN32

#ifdef DEBUG
    __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
    __inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

    #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
    #define TIMEZERO(t)   t ## T = 0, t ## N = 0
    #define TIMESTART(t)  t ## T -= clock(), t ## N ++
    #define TIMESTOP(t)   t ## T += clock()
    #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
    #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
#else
    #define TIMEVAR(t)
    #define TIMEZERO(t)
    #define TIMESTART(t)
    #define TIMESTOP(t)
    #define TIMEFMT(t)
    #define TIMEOUT(t)
#endif

#endif


#ifdef __cplusplus
}
#endif

#endif //__DEBUG_PF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\drvlib\drvutil.c ===
/****************************************************************************
 *
 *   drvutil.c
 *
 *   Multimedia kernel driver support component (drvlib)
 *
 *   Copyright (c) 1993-1995 Microsoft Corporation
 *
 *   Support functions common to multiple multi-media drivers :
 *
 *   -- Open a device
 *   -- Translate a kernel IO return code to a multi-media return code
 *   -- Count the number of devices of a given type
 *   -- Set and Get data synchronously to a kernel device
 *
 *   History
 *      01-Feb-1992 - Robin Speed (RobinSp) wrote it
 *      04-Feb-1992 - Reviewed by SteveDav
 *
 ***************************************************************************/

#include <drvlib.h>
#include <ntddwave.h>
#include <ntddmidi.h>
#include <ntddaux.h>
#include <registry.h>

/*
**  External name of driver
*/

extern TCHAR DriverName[];

/*
**  We need an hInstance module handle to get strings from since the kernel
**  driver returns string Ids in its structures
*/

extern HINSTANCE hInstance;

/*
**  Internal structures
*/

/*
**  List of cached device descriptions.  This is generated when the
**  driver is loaded from the data in the registry so that multiple
**  queries are faster and consistent.
*/

typedef struct _DEVICE_LIST {
    struct _DEVICE_LIST *Next;    // Next pointer
    DWORD   DeviceType;           // Type of device
    ULONG   CardIndex;            // Card entry registry key index
    PVOID   DeviceInstanceData;   // Instance data for this specific device
                                  // if needed.
    ULONG   DeviceInstanceDataSize;
    WCHAR   Name[1];              // Device name
} DEVICE_LIST, *PDEVICE_LIST;

PDEVICE_LIST DeviceList;

/*
**  Internal routines
*/

PDEVICE_LIST sndFindDevice(DWORD DeviceType, DWORD dwId);
BOOL sndProcessDevices(HKEY DevicesKey, PDEVICE_LIST *DeviceList, DWORD CardIndex);
BOOL sndAppendToDeviceList(PDEVICE_LIST *pList, DWORD DeviceType, DWORD CardIndex,
                           LPWSTR       Name);
VOID sndFreeDeviceList(VOID);
BOOL sndEnumKey(HKEY Key, DWORD Index, LPTSTR OurKey, HKEY *pSubkey);

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | sndOpenDev | Open the kernel driver device corresponding
 *       to a logical wave device id
 *
 * @parm UINT | DeviceType | The type of device
 *
 * @parm DWORD | dwId | The device id
 *
 * @parm PHANDLE | phDev | Where to return the kernel device handle
 *
 * @parm ACCESS_MASK | Access | The desired access
 *
 * @comm For our sound devices the only relevant access are read and
 *    read/write.  Device should ALWAYS allow opens for read unless some
 *    resource or access-rights restriction occurs.
 ***************************************************************************/
MMRESULT sndOpenDev(UINT DeviceType, DWORD dwId,
                    PHANDLE phDev, DWORD Access)
{
    PDEVICE_LIST List;
    WCHAR cDev[SOUND_MAX_DEVICE_NAME + 4];

    List = sndFindDevice(DeviceType, dwId);

    *phDev = INVALID_HANDLE_VALUE;  // Always initialise the return value

    if (List == NULL) {
        return MMSYSERR_BADDEVICEID;
    }

    //
    // Create the device name and open it - remove '\Device'
    //

    wsprintf(cDev, L"\\\\.\\%ls", List->Name);

    *phDev = CreateFile(cDev,
                        Access,
                        FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        Access != GENERIC_READ ? FILE_FLAG_OVERLAPPED : 0,
                        NULL);

    //
    // Check up on the driver for refusing to open
    // multiply for read
    //

    WinAssert(!(GetLastError() == ERROR_ACCESS_DENIED &&
                Access == GENERIC_READ));

    //
    // Return status to caller
    //

    return *phDev != INVALID_HANDLE_VALUE ? MMSYSERR_NOERROR : sndTranslateStatus();
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | sndTranslateStatus | This function translates an NT status
 *     code into a multi-media error code as far as possible.
 *
 * @parm NTSTATUS | Status | The NT base operating system return status.
 *
 *
 * @rdesc The multi-media error code.
 ***************************************************************************/
DWORD sndTranslateStatus(void)
{
#if DBG
    UINT n;
    switch (n=GetLastError()) {
#else
    switch (GetLastError()) {
#endif
    case NO_ERROR:
    case ERROR_IO_PENDING:
        return MMSYSERR_NOERROR;

    case ERROR_BUSY:
        return MMSYSERR_ALLOCATED;

    case ERROR_NOT_SUPPORTED:
    case ERROR_INVALID_FUNCTION:
        return MMSYSERR_NOTSUPPORTED;

    case ERROR_NOT_ENOUGH_MEMORY:
        return MMSYSERR_NOMEM;

    case ERROR_ACCESS_DENIED:
        return MMSYSERR_BADDEVICEID;

    case ERROR_INSUFFICIENT_BUFFER:
        return MMSYSERR_INVALPARAM;

    default:
        dprintf2(("sndTranslateStatus:  LastError = %d", n));
        return MMSYSERR_ERROR;
    }
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | sndGetNumDevs | This function returns the number of (kernel)
 *
 * @parm UINT | DeviceType | The Device type
 *
 * @rdesc The number of devices.
 ***************************************************************************/

DWORD sndGetNumDevs(UINT DeviceType)
{
    //
    // Search the device list for devices of our type
    //
    int i;
    PDEVICE_LIST List;

    for (List = DeviceList, i= 0; List != NULL; List = List->Next) {
        if (List->DeviceType == DeviceType) {
            i++;
        }
    }

    return i;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | sndSetData | This function sets the volume given a device id
 *                           and could be used for other soft value setting
 *                           when only read access is required to the device
 *
 * @parm UINT | DeviceType | The Device type
 *
 * @parm UINT | DeviceId | The device id
 *
 * @parm UINT | Length | Length of data to set
 *
 * @parm PBYTE | Data | Data to set
 *
 * @parm ULONG | Ioctl | The Ioctl to use
 *
 * @rdesc MM... return code.
 ***************************************************************************/

MMRESULT sndSetData(UINT DeviceType, UINT DeviceId, UINT Length, PBYTE Data,
                    ULONG Ioctl)
{

   HANDLE hDev;
   MMRESULT mRet;
   DWORD BytesReturned;

   //
   // Open the device
   //

   mRet = sndOpenDev(DeviceType, DeviceId, &hDev, GENERIC_READ);
   if (mRet != MMSYSERR_NOERROR) {
        return mRet;
   }

   //
   // Set our data.
   //
   // Setting the overlapped parameter (last) to null means we
   // wait until the operation completes.
   //

   mRet = DeviceIoControl(hDev, Ioctl, Data, Length, NULL, 0,
                          &BytesReturned, NULL) ?
          MMSYSERR_NOERROR : sndTranslateStatus();


   //
   // Close our file and return
   //

   CloseHandle(hDev);

   return mRet;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | sndGetData | This function gets data from a given device
 *                           specified by device id when read-only access is
 *                           sufficient
 *
 * @parm UINT | DeviceType | The Device type
 *
 * @parm UINT | DeviceId | The device id
 *
 * @parm UINT | Length | Length of data to set
 *
 * @parm PBYTE | Data | Data to set
 *
 * @parm ULONG | Ioctl | The Ioctl to use
 *
 * @rdesc MM... return code.
 ***************************************************************************/

MMRESULT sndGetData(UINT DeviceType, UINT DeviceId, UINT Length, PBYTE Data,
                    ULONG Ioctl)
{

   HANDLE hDev;
   MMRESULT mRet;
   DWORD BytesReturned;

   //
   // Open the wave output device
   //

   mRet = sndOpenDev(DeviceType, DeviceId, &hDev, GENERIC_READ);
   if (mRet != MMSYSERR_NOERROR) {
        return mRet;
   }

   //
   // Set our data.
   //
   // Setting the overlapped parameter (last) to null means we
   // wait until the operation completes.
   //

   mRet = DeviceIoControl(hDev, Ioctl, NULL, 0, (LPVOID)Data, Length,
                          &BytesReturned, NULL) ?
          MMSYSERR_NOERROR : sndTranslateStatus();


   //
   // Close our file and return
   //

   CloseHandle(hDev);

   return mRet;
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | sndGetHandleData | Get data from a device using its handle
 *
 * @parm PWAVEALLOC | pClient | Client handle.
 *
 * @parm DWORD | dwSize | Size of the data
 *
 * @parm PVOID | pData | Where to put the data.
 *
 * @parm ULONG | Function | The Ioctl to use
 *
 * @rdesc MMSYS... return value.
 ***************************************************************************/

MMRESULT sndGetHandleData(HANDLE     hDev,
                          DWORD      dwSize,
                          PVOID      pData,
                          ULONG      Ioctl,
                          HANDLE     hEvent)
{
    OVERLAPPED Overlap;
    DWORD BytesReturned;

    WinAssert(hDev != NULL);

    memset(&Overlap, 0, sizeof(Overlap));

    Overlap.hEvent = hEvent;

    //
    // Issue the IO control.  We must wait with our own event because
    // setting the overlapped object to null will complete if other
    // IOs complete.
    //

    if (!DeviceIoControl(hDev,
                         Ioctl,
                         NULL,
                         0,
                         pData,
                         dwSize,
                         &BytesReturned,
                         &Overlap)) {
         DWORD cbTransfer;

         //
         // Wait for completion if necessary
         //

         if (GetLastError() == ERROR_IO_PENDING) {
             if (!GetOverlappedResult(hDev, &Overlap, &cbTransfer,
                                      TRUE)) {
                  return sndTranslateStatus();
             }
         } else {
             return sndTranslateStatus();
         }
    }

    //
    // We'd better peek aleratbly to flush out any IO
    // completions so that things like RESET only
    // return when all buffers have been completed
    //
    // This relies on the fact that SleepEx will return
    // WAIT_IO_COMPLETION in preference to OK
    //

    while (SetEvent(hEvent) &&
           WaitForSingleObjectEx(hEvent, 0, TRUE) == WAIT_IO_COMPLETION) {}


    return MMSYSERR_NOERROR;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | sndSetHandleData | Pass data to a device using its handle
 *
 * @parm PWAVEALLOC | pClient | Client handle.
 *
 * @parm DWORD | dwSize | Size of the data
 *
 * @parm PVOID | pData | Data to send.
 *
 * @parm ULONG | Function | The Ioctl to use
 *
 * @rdesc MMSYS... return value.
 ***************************************************************************/
MMRESULT sndSetHandleData(HANDLE     hDev,
                          DWORD      dwSize,
                          PVOID      pData,
                          ULONG      Ioctl,
                          HANDLE     hEvent)
{
    OVERLAPPED Overlap;
    DWORD BytesReturned;

    WinAssert(hDev != NULL);

    memset((PVOID)&Overlap, 0, sizeof(Overlap));

    Overlap.hEvent = hEvent;

    //
    // Issue the IO control.  We must wait with our own event because
    // setting the overlapped object to null will complete if other
    // IOs complete.
    //

    if (!DeviceIoControl(hDev,
                         Ioctl,
                         pData,
                         dwSize,
                         NULL,
                         0,
                         &BytesReturned,
                         &Overlap)) {
         DWORD cbTransfer;

         //
         // Wait for completion if necessary
         //

         if (GetLastError() == ERROR_IO_PENDING) {
             if (!GetOverlappedResult(hDev, &Overlap, &cbTransfer,
                                      TRUE)) {
                  return sndTranslateStatus();
             }
         } else {
             return sndTranslateStatus();
         }
    }

    //
    // We'd better peek alertably to flush out any IO
    // completions so that things like RESET only
    // return when all buffers have been completed
    //
    // This relies on the fact that SleepEx will return
    // WAIT_IO_COMPLETION in preference to OK
    //

    while (SleepEx(0, TRUE) == WAIT_IO_COMPLETION) {}

    return MMSYSERR_NOERROR;
}

HKEY sndOpenParametersKey(VOID)
{
    return DrvOpenRegKey(DriverName, TEXT(""));
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | sndFindDevices | Find all the devices using its handle
 *
 * @parm HKEY | Key| Handle to
 *
 * @parm PDEVICE_LIST * | DeviceList | The data about the devices found is
 *     returned here.
 *
 * @rdesc MMSYS... return value.
 *
 * @comm
 *    The registry structure is assumed to be (eg)
 *
 *    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\sndsys\Parameters..
 *
 *           Parameters
 *              Device0              One key for each card found
 *                 DriverParameters
 *                     Interrupt     REG_DWORD
 *                     Port          REG_DWORD
 *                     DmaChannel    REG_DWORD
 *                 Devices           (Volatile key)
 *                     WSSWave0      REG_BINARY (device data)
 *                     WSSMix1       REG_BINARY (device data)
 *                 MixerSettings     REG_BINARY
 *
 *   The (device data) for each device contains :
 *
 *      DWORD  DeviceType
 *      BYTE   DeviceInstanceData[]
 *
 *   NOTE - DON'T use the 'standard' names (eg WaveOut0) for your device
 *   or mmdrv will try to grab those devices.
 *
 *
 ***************************************************************************/
MMRESULT sndFindDevices(VOID)
{
    DWORD Index;
    HKEY DriverKey;

    WinAssert(DeviceList == NULL);

    /*
    **  Open the driver's registry key
    */

    DriverKey = sndOpenParametersKey();

    if (DriverKey == NULL) {
        return sndTranslateStatus();
    }

    for (Index = 0; ; Index++) {

        BOOL Rc;
        HKEY Subkey;

        if (!sndEnumKey(DriverKey, Index, SOUND_DEVICES_SUBKEY, &Subkey)) {

            sndFreeDeviceList();
            RegCloseKey(DriverKey);
            return sndTranslateStatus();
        }

        /*
        **  Null returned subkey means end of list
        */

        if (Subkey == NULL) {
            break;
        }

        /*
        **  Process all the data for this device :
        */

        Rc = sndProcessDevices(Subkey, &DeviceList, Index);

        RegCloseKey(Subkey);

        if (!Rc) {
            sndFreeDeviceList();
            RegCloseKey(DriverKey);
            return sndTranslateStatus();
        }
    }

    RegCloseKey(DriverKey);

    return MMSYSERR_NOERROR;
}

BOOL sndProcessDevices(HKEY DevicesKey, PDEVICE_LIST *DeviceList, DWORD CardIndex)
{
    BOOL Rc;
    DWORD Index;
    DWORD Length;
    DWORD Type;
    DWORD Value;

    Rc = TRUE;

    for (Index = 0; ; Index++) {
        WCHAR DeviceName[SOUND_MAX_DEVICE_NAME];
        DWORD Error;
        DWORD cbSize;
        PBYTE Data;

        Length = sizeof(DeviceName) / sizeof(DeviceName[0]);
        cbSize = 0;

        /*
        **  Can't get the value at the same time as the key name because
        **  bugs in RegEnumValue mean that if the value is too big you
        **  won't get any of it!
        */

        Error = RegEnumValue(DevicesKey,
                             Index,
                             DeviceName,
                             &Length,
                             NULL,
                             NULL,
                             NULL,
                             &cbSize);

        if (Error == ERROR_NO_MORE_ITEMS) {
            break;
        }

        /*
        **  Check we got the data we wanted
        */

        if (Error != ERROR_SUCCESS) {
            Rc = FALSE;
            break;
        }

        if (cbSize < sizeof(DWORD)) {
            SetLastError(ERROR_INVALID_DATA);
            Rc = FALSE;
            break;
        }

        /*
        **  Get some space for the value
        */

        Data = (PBYTE)HeapAlloc(hHeap, 0, cbSize);

        if (Data == NULL) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            Rc = FALSE;
            break;
        }

        /*
        **  Read the actual value
        */

        Error = RegQueryValueEx(DevicesKey,
                                DeviceName,
                                NULL,
                                &Type,
                                Data,
                                &cbSize);

        Value = *(LPDWORD)Data;
        HeapFree(hHeap, 0, Data);

        /*
        **  The kernel driver is supposed to put either a binary or
        **  DWORD into the registry
        */

        if (Error != ERROR_SUCCESS) {

            Rc = FALSE;
            break;
        }

        if (Type != REG_DWORD && Type != REG_BINARY ||
            cbSize < sizeof(DWORD)) {
            dprintf(("Invalid device type!"));
            WinAssert(FALSE);
            SetLastError(ERROR_INVALID_DATA);
            Rc = FALSE;
            break;
        }

        /*
        **  Store the device data in the table
        **
        **  When we actually open it we're going to need to append
        **  \\.\ .. to it
        */

        if (!sndAppendToDeviceList(DeviceList, Value, CardIndex, DeviceName)) {
            Rc = FALSE;
            break;
        }
    }

    return Rc;
}

BOOL sndEnumKey(HKEY Key, DWORD Index, LPTSTR OurKey, HKEY *pSubkey)
{
    DWORD cchName;
    WCHAR SubKeyName[50];
    HKEY Subkey;
    UINT OurKeyLen;

    OurKeyLen = lstrlen(OurKey);

    cchName = sizeof(SubKeyName) / sizeof(SubKeyName[0]) - OurKeyLen;

    switch (RegEnumKeyEx(Key,
                         Index,
                         SubKeyName,
                         &cchName,
                         NULL,
                         NULL,
                         NULL,
                         NULL)) {
        case ERROR_SUCCESS:

            if (OurKeyLen != 0) {
                wcscat(SubKeyName, TEXT("\\"));
            }
            wcscat(SubKeyName, OurKey);

            if (ERROR_SUCCESS != RegOpenKeyEx(Key,
                                         SubKeyName,
                                         0,
                                         KEY_READ,
                                         &Subkey)) {
                return FALSE;
            } else {
                *pSubkey = Subkey;
                return TRUE;
            }


        case ERROR_NO_MORE_ITEMS:
            *pSubkey = NULL;
            return TRUE;

        default:
            return FALSE;
    }
}

BOOL sndAppendToDeviceList(
    PDEVICE_LIST *pList,
    DWORD        DeviceType,
    DWORD        CardIndex,
    LPWSTR       Name)
{
    PDEVICE_LIST pNew;

#if DBG
    PDEVICE_LIST List;
    for (List = *pList; List != NULL; List = List->Next) {
        if (List->DeviceType == DeviceType &&
            lstrcmpi(List->Name, Name) == 0) {
            dprintf(("Duplicate device name found - %ls!!", Name));
            DebugBreak();
        }
    }
#endif // DBG

    /*
    **  Allocate space for the new entry.
    **
    **  Note that the space for the  trailing null in the name is accounted
    **  for by the length of 1 given to the Name structure entry.
    */

    pNew = (PDEVICE_LIST)HeapAlloc(
                hHeap,
                0,
                sizeof(DEVICE_LIST) + lstrlen(Name) * sizeof(WCHAR));

    if (pNew == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    /*
    **  Fill in the new entry
    */

    pNew->DeviceType = DeviceType;
    pNew->CardIndex = CardIndex;
    lstrcpy(pNew->Name, Name);
    pNew->DeviceInstanceData = NULL;

    pNew->Next = *pList;

    *pList = pNew;

    return TRUE;
}

VOID sndFreeDeviceList(VOID)
{
    PDEVICE_LIST pFree;

    for (; DeviceList != NULL; ) {
        pFree = DeviceList;
        DeviceList = pFree->Next;
        if (pFree->DeviceInstanceData != NULL) {
            HeapFree(hHeap, 0, (LPVOID)pFree->DeviceInstanceData);
        }
        HeapFree(hHeap, 0, (LPSTR)pFree);
    }
}

/*
**  Load the device data into the device list
*/

PVOID sndLoadDeviceData(DWORD DeviceType, DWORD dwId, LPDWORD pSize)
{
    PDEVICE_LIST List;
    HKEY DriverKey;
    DWORD Index;
    BOOL Rc;
    PVOID DeviceData;

    DeviceData = NULL;

    List = sndFindDevice(DeviceType, dwId);

    WinAssert(List != NULL);

    /*
    **  Search through all the entries trying to open the key with the
    **  device name.  Note that it's possible for the registry to have
    **  totally changed so we can't assume all this is going to work
    **  or give the correct result.  We can check the device type of
    **  the entry we open and of course the name must be correct.
    */

    DriverKey = sndOpenParametersKey();

    for (Index = 0, Rc = FALSE; ; Index++) {

        HKEY Subkey;
        DWORD Type;
        DWORD Size;

        if (!sndEnumKey(DriverKey, Index, SOUND_DEVICES_SUBKEY, &Subkey)) {

            RegCloseKey(DriverKey);
            return FALSE;
        }

        /*
        **  Null returned subkey means end of list
        */

        if (Subkey == NULL) {
            break;
        }

        if (Rc) {
            /*
            **  Try to get the data for this device
            */

            Size = 0;
            Rc = (ERROR_SUCCESS == RegQueryValueEx(Subkey,
                                              List->Name,
                                              NULL,
                                              &Type,
                                              NULL,
                                              &Size));
        }

        if (Rc) {

            /*
            **  Allocate some space and try to load it
            */

            DeviceData = (PVOID)HeapAlloc(hHeap, 0, Size);

            if (DeviceData != NULL) {

                Rc = (ERROR_SUCCESS == RegQueryValueEx(Subkey,
                                                  List->Name,
                                                  NULL,
                                                  &Type,
                                                  DeviceData,
                                                  &Size));

                RegCloseKey(Subkey);

                if (!Rc ||
                    *(LPDWORD)DeviceData != DeviceType) {

                    LocalFree((HLOCAL)DeviceData);
                    DeviceData = NULL;

                } else {

                    *pSize = Size;
                }
            }

            /*
            **  This was the one we wanted
            */

            break;
        } else {
            RegCloseKey(Subkey);
        }
    }

    RegCloseKey(DriverKey);

    return DeviceData;
}

PDEVICE_LIST sndFindDevice(DWORD DeviceType, DWORD dwId)
{
   PDEVICE_LIST List;
   DWORD CurrentId;

   for (List = DeviceList, CurrentId = 0; List != NULL; List = List->Next) {
       if (List->DeviceType == DeviceType) {
           if (CurrentId == dwId) {
               break;
           } else {
               CurrentId++;
           }
       }
   }

   return List;
}

BOOL sndFindDeviceInstanceData(DWORD DeviceType, DWORD dwId,
                               PVOID *InstanceData)
{
   PDEVICE_LIST List;

   List = sndFindDevice(DeviceType, dwId);

   if (List == NULL) {
       return FALSE;
   }

   *InstanceData = List->DeviceInstanceData;

   return TRUE;
}

BOOL sndSetDeviceInstanceData(DWORD DeviceType, DWORD dwId,
                                PVOID InstanceData)
{
   PDEVICE_LIST List;

   List = sndFindDevice(DeviceType, dwId);

   WinAssert(List != NULL);
   WinAssert(List->DeviceInstanceData == NULL);
   List->DeviceInstanceData = InstanceData;

   return TRUE;
}

/*
**  Package up LoadString a bit
*/

void InternalLoadString(UINT StringId, LPTSTR pszString, UINT Length)
{
    ZeroMemory(pszString, Length * sizeof(pszString[0]));

    if (StringId != 0) {
        LoadString(hInstance, StringId, pszString, Length);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\drvlib\mididd.c ===
/****************************************************************************
 *
 *   mididd.c
 *
 *   Multimedia kernel driver support component (mmdrv)
 *
 *   Copyright (c) 1991-1995 Microsoft Corporation
 *
 *   Driver for midi input and output devices
 *
 *   -- Midi driver entry points (modMessage, midMessage)
 *   -- Auxiliary task (necessary for receiving Apcs and generating
 *      callbacks ASYNCRHONOUSLY)
 *   -- Interface to kernel driver (NtDeviceIoControlFile)
 *   -- Midi parsing code (ported from Windows 3.1).
 *
 *   History
 *      01-Feb-1992 - Robin Speed (RobinSp) wrote it
 *
 ***************************************************************************/

#include <drvlib.h>
#include <ntddmidi.h>

/*****************************************************************************

    internal declarations

 ****************************************************************************/

//
// Stack size for our auxiliary task
//

#define MIDI_STACK_SIZE 300

#define SYSEX_ERROR    0xFF              // internal error for sysex's on input

//
// Functions for auxiliary thread to perform
//

typedef enum {
    MidiThreadInvalid,
    MidiThreadAddBuffer,
    MidiThreadSetState,
    MidiThreadSetData,
    MidiThreadClose,
    MidiThreadTerminate
} MIDITHREADFUNCTION;

//
// Our local buffers for interfacing to midi input
//

#define LOCAL_MIDI_DATA_SIZE 20
typedef struct _LOCALMIDIHDR {
    OVERLAPPED          Ovl;
    DWORD               BytesReturned;
    struct _LOCALMIDIHDR *lpNext;       // Queueing (really debug only)
    BOOL                Done;           // Driver completed buffer
    PVOID               pClient;        // Our instance data for Apcs
    MIDI_DD_INPUT_DATA  MidiData;       // What the driver wants to process
    BYTE                ExtraData[LOCAL_MIDI_DATA_SIZE - sizeof(ULONG)];
                                        // The rest of our input buffer
} LOCALMIDIHDR, *PLOCALMIDIHDR;

//
// Midi input data
//

#define NUMBER_OF_LOCAL_MIDI_BUFFERS 8

typedef struct {

    //
    // Static data for managing midi input
    //
    BOOL                fMidiInStarted; // Do we think midi in is running ?
    DWORD               dwMsg;          // Current short msg
    DWORD               dwCurData;      // Position in long message
    BYTE                status;         // Running status byte
    BOOLEAN             fSysex;         // Processing extended message
    BOOLEAN             Bad;            // Input not working properly
    BYTE                bBytesLeft;     // Bytes left in short message
    BYTE                bBytePos;       // Position in short message
    DWORD               dwCurTime;      // Latest time from driver
    DWORD               dwMsgTime;      // Time to insert into message
                                        // in milliseconds since device
                                        // was opened
    PLOCALMIDIHDR       DeviceQueue;    // Keep track of what the device
                                        // has (debugging only)
    LOCALMIDIHDR                        // Driver interface buffers
     Bufs[NUMBER_OF_LOCAL_MIDI_BUFFERS];// When input is active these
                                        // are queued on the device
                                        // except while data is being
                                        // processed from them
} LOCALMIDIDATA, *PLOCALMIDIDATA;


//
// per allocation structure for Midi
//

typedef struct tag_MIDIALLOC {
    struct tag_MIDIALLOC *Next;         // Chain of devices
    UINT                DeviceNumber;   // Number of device
    UINT                DeviceType;     // MidiInput or MidiOutput
    DWORD_PTR           dwCallback;     // client's callback
    DWORD_PTR           dwInstance;     // client's instance data
    HMIDI               hMidi;          // handle for stream
    HANDLE              hDev;           // Midi device handle
    LPMIDIHDR           lpMIQueue;      // Buffers sent to device
                                        // This is only required so that
                                        // CLOSE knows when things have
                                        // really finished.
                                        // notify.  This is only accessed
                                        // on the device thread and its
                                        // apcs so does not need any
                                        // synchronized access.
    HANDLE              Event;          // Event for driver syncrhonization
                                        // and notification of auxiliary
                                        // task operation completion.
    MIDITHREADFUNCTION  AuxFunction;    // Function for thread to perform
    union {
        LPMIDIHDR       pHdr;           // Buffer to pass in aux task
        ULONG           State;          // State to set
        struct {
            ULONG       Function;       // IOCTL to use
            PBYTE       pData;          // Data to set or get
            ULONG       DataLen;        // Length of data
        } GetSetData;

    } AuxParam;
                                        // 0 means terminate task.
    HANDLE              ThreadHandle;   // Handle for termination ONLY
    HANDLE              AuxEvent1;      // Aux thread waits on this
    HANDLE              AuxEvent2;      // Aux thread caller waits on this
    DWORD               AuxReturnCode;  // Return code from Aux task
    DWORD               dwFlags;        // Open flags
    PLOCALMIDIDATA      Mid;            // Extra midi input structures
    int                 l;              // Helper global for modMidiLength

} MIDIALLOC, *PMIDIALLOC;

PMIDIALLOC MidiHandleList;              // Our chain of wave handles

/*****************************************************************************

    internal function prototypes

 ****************************************************************************/

STATIC DWORD midiThread(LPVOID lpParameter);
STATIC void midiCleanUp(PMIDIALLOC pClient);
STATIC DWORD midiThreadCall(MIDITHREADFUNCTION Function, PMIDIALLOC pClient);
STATIC DWORD midiSetState(PMIDIALLOC pClient, ULONG State);
STATIC void midiInOvl(DWORD dwRet, DWORD dwBytes, LPOVERLAPPED pOverlap);
STATIC DWORD midiInWrite(LPMIDIHDR pHdr, PMIDIALLOC pClient);
STATIC DWORD midiOutWrite(PBYTE pData, ULONG Len, PMIDIALLOC pClient);
STATIC void midiBlockFinished(LPMIDIHDR lpHdr, DWORD MsgId);
STATIC void midiCallback(PMIDIALLOC pMidi, DWORD msg, DWORD_PTR dw1, DWORD_PTR dw2);
STATIC int modMIDIlength(PMIDIALLOC pClient, BYTE b);
STATIC void midByteRec(PMIDIALLOC pClient, BYTE byte);
STATIC void midSendPartBuffer(PMIDIALLOC pClient);
STATIC void midFreeQ(PMIDIALLOC pClient);
STATIC void midiFlush(PMIDIALLOC pClient);

/****************************************************************************
 * @doc INTERNAL
 *
 * @api VOID | TerminateMidi | Free all midi resources for mmdrv.dll
 *
 * @rdesc None
 ***************************************************************************/
VOID TerminateMidi(VOID)
{
    //
    // Don't do any cleanup - Midi input resources cleaned up on Close.
    //
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midiGetDevCaps | Get the device capabilities.
 *
 * @parm DWORD | id | Device id
 *
 * @parm UINT | DeviceType | type of device
 *
 * @parm LPBYTE | lpCaps | Far pointer to a MIDIOUTCAPS structure to
 *      receive the information.
 *
 * @parm DWORD | dwSize | Size of the MIDIOUTCAPS structure.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
STATIC DWORD midiGetDevCaps(DWORD id, UINT DeviceType,
                            LPBYTE lpCaps, DWORD dwSize)
{
    MMRESULT mrc;
    if (DeviceType != MIDI_IN) {
        MIDIOUTCAPSW mc;
        mrc = sndGetData(DeviceType, id, sizeof(mc), (LPBYTE)&mc,
                         IOCTL_MIDI_GET_CAPABILITIES);

        if (mrc != MMSYSERR_NOERROR) {
            return mrc;
        }
        InternalLoadString((UINT)*(LPDWORD)mc.szPname, mc.szPname,
                           sizeof(mc.szPname) / sizeof(WCHAR));

        CopyMemory(lpCaps, &mc, min(sizeof(mc), dwSize));
    } else {
        MIDIINCAPSW mc;
        mrc = sndGetData(DeviceType, id, sizeof(mc), (LPBYTE)&mc,
                         IOCTL_MIDI_GET_CAPABILITIES);

        if (mrc != MMSYSERR_NOERROR) {
            return mrc;
        }
        InternalLoadString((UINT)*(LPDWORD)mc.szPname, mc.szPname,
                           sizeof(mc.szPname) / sizeof(WCHAR));

        CopyMemory(lpCaps, &mc, min(sizeof(mc), dwSize));
    }

    return MMSYSERR_NOERROR;
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiOpen | Open midi device and set up logical device data
 *    and auxilary task for issuing requests and servicing Apc's
 *
 * @parm MIDIDEVTYPE | DeviceType | Whether it's a midi input or output device
 *
 * @parm DWORD | id | The device logical id
 *
 * @parm DWORD | msg | Input parameter to modMessage
 *
 * @parm DWORD | dwUser | Input parameter to modMessage - pointer to
 *   application's handle (generated by this routine)
 *
 * @parm DWORD | dwParam1 | Input parameter to modMessage
 *
 * @parm DWORD | dwParam2 | Input parameter to modMessage
 *
 * @rdesc modMessage return code.
 ***************************************************************************/

STATIC DWORD midiOpen(UINT  DeviceType,
                      DWORD id,
                      DWORD_PTR dwUser,
                      DWORD_PTR dwParam1,
                      DWORD_PTR dwParam2)
{
    PMIDIALLOC     pClient;  // pointer to client information structure
    MMRESULT mRet;

    // dwParam1 contains a pointer to a MIDIOPENDESC
    // dwParam2 contains midi driver specific flags in the LOWORD
    // and generic driver flags in the HIWORD

    //
    // allocate my per-client structure
    //
    if (DeviceType == MIDI_OUT) {
        pClient = (PMIDIALLOC)HeapAlloc(hHeap, 0, sizeof(MIDIALLOC));

        if (pClient != NULL) {
            memset(pClient, 0, sizeof(MIDIALLOC));
        }
    } else {
        WinAssert(DeviceType == MIDI_IN);
        pClient = (PMIDIALLOC)HeapAlloc(hHeap, 0,
                   sizeof(struct _xx {MIDIALLOC S1; LOCALMIDIDATA S2;}));

        if (pClient != NULL) {
            memset(pClient, 0, sizeof(struct _xx {MIDIALLOC S1; LOCALMIDIDATA S2;}));
        }
    }

    if (pClient == NULL) {
        return MMSYSERR_NOMEM;
    }

    if (DeviceType == MIDI_IN) {
	PLOCALMIDIDATA pMid;
        int i;
        pMid = pClient->Mid = (PLOCALMIDIDATA)(pClient + 1);
        for (i = 0 ;i < NUMBER_OF_LOCAL_MIDI_BUFFERS ; i++) {
            pMid->Bufs[i].pClient = pClient;
        }
    }

    //
    // and fill it with info
    //
    // (note that setting everything to 0 correctly initialized our
    //  midi input processing static data).

    pClient->DeviceType  = DeviceType;
    pClient->dwCallback  = ((LPMIDIOPENDESC)dwParam1)->dwCallback;
    pClient->dwInstance  = ((LPMIDIOPENDESC)dwParam1)->dwInstance;
    pClient->hMidi       = ((LPMIDIOPENDESC)dwParam1)->hMidi;
    pClient->dwFlags     = (DWORD)dwParam2;

    //
    // See if we can open our device
    // If it's only a query be sure only to open for read, otherwise
    // we could get STATUS_BUSY if someone else is writing to the
    // device.
    //

    mRet = sndOpenDev(DeviceType,
                       id,
                       &pClient->hDev,
                       (GENERIC_READ | GENERIC_WRITE));

    if (mRet != MMSYSERR_NOERROR) {

        midiCleanUp(pClient);
        return mRet;
    }


    //
    // Create our event for syncrhonization with the device driver
    //

    pClient->Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (pClient->Event == NULL) {
        midiCleanUp(pClient);
        return MMSYSERR_NOMEM;
    }

    if (DeviceType == MIDI_IN) {

        //
        // Create our event pair for synchronization with the auxiliary
        // thread
        //

        pClient->AuxEvent1 = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (pClient->AuxEvent1 == NULL) {
            midiCleanUp(pClient);
            return MMSYSERR_NOMEM;
        }
        pClient->AuxEvent2 = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (pClient->AuxEvent2 == NULL) {
            midiCleanUp(pClient);
            return MMSYSERR_NOMEM;
        }

        //
        // Create our auxiliary thread for sending buffers to the driver
        // and collecting Apcs
        //

        mRet = mmTaskCreate((LPTASKCALLBACK)midiThread,
                            &pClient->ThreadHandle,
                            (DWORD_PTR)pClient);

        if (mRet != MMSYSERR_NOERROR) {
            midiCleanUp(pClient);
            return MMSYSERR_NOMEM;
        }

        //
        // Make sure the thread has really started
        //

        WaitForSingleObject(pClient->AuxEvent2, INFINITE);
    }

    //
    // give the client my driver dw
    //
    {
        PMIDIALLOC *pUserHandle;
        pUserHandle = (PMIDIALLOC *)dwUser;
        *pUserHandle = pClient;
    }

    //
    // sent client his OPEN callback message
    //
    midiCallback(pClient, DeviceType == MIDI_OUT ? MOM_OPEN : MIM_OPEN,
                 0L, 0L);

    return MMSYSERR_NOERROR;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midiCleanUp | Free resources for a midi device
 *
 * @parm PMIDIALLOC | pClient | Pointer to a MIDIALLOC structure describing
 *      resources to be freed.
 *
 * @rdesc There is no return value.
 *
 * @comm If the pointer to the resource is NULL then the resource has not
 *     been allocated.
 ***************************************************************************/
STATIC void midiCleanUp(PMIDIALLOC pClient)
{
    if (pClient->hDev != INVALID_HANDLE_VALUE) {
        CloseHandle(pClient->hDev);
    }
    if (pClient->AuxEvent1) {
        CloseHandle(pClient->AuxEvent1);
    }
    if (pClient->AuxEvent2) {
        CloseHandle(pClient->AuxEvent2);
    }
    if (pClient->Event) {
        CloseHandle(pClient->Event);
    }

    HeapFree(hHeap, 0, (LPSTR)pClient);
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiOutWrite | Synchronously process a midi output
 *       buffer.
 *
 * @parm LPMIDIHDR | pHdr | Pointer to a midi buffer
 *
 * @parm PMIDIALLOC | pClient | The data associated with the logical midi
 *     device.
 *
 * @rdesc A MMSYS... type return code for the application.
 ***************************************************************************/
STATIC DWORD midiOutWrite(PBYTE pData, ULONG Len, PMIDIALLOC pClient)
{
    DWORD BytesReturned;

    //
    // Try passing the request to our driver
    // We operate synchronously but allow for the driver to operate
    // asynchronously by waiting on an event.
    //

    if (!DeviceIoControl(
                    pClient->hDev,
                    IOCTL_MIDI_PLAY,
                    (PVOID)pData,                // Input buffer
                    Len,                         // Input buffer size
                    NULL,                        // Output buffer
                    0,                           // Output buffer size
                    &BytesReturned,
                    NULL)) {
        return sndTranslateStatus();
    }

    return MMSYSERR_NOERROR;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiInPutBuffer | Pass a buffer to receive midi input
 *
 * @parm LPMIDIHDR | pHdr | Pointer to a midi buffer
 *
 * @parm PMIDIALLOC | pClient | The data associated with the logical midi
 *     device.
 *
 * @rdesc A MMSYS... type return code for the application.
 ***************************************************************************/
STATIC MMRESULT midiInPutBuffer(PLOCALMIDIHDR pHdr, PMIDIALLOC pClient)
{
    DWORD BytesReturned;
    BOOL Result;

    WinAssert(!pHdr->Done);  // Flag should be clear ready for setting by Apc

    //
    // BUGBUG - nice to have a semaphore for some of this !
    //

    //
    // Try passing the request to our driver
    // We operate synchronously but allow for the driver to operate
    // asynchronously by waiting on an event.
    //

    Result = ReadFileEx(
                 pClient->hDev,
                 (LPVOID)&pHdr->MidiData,
                 sizeof(pHdr->ExtraData) +
                     sizeof(MIDI_DD_INPUT_DATA),
                 &pHdr->Ovl,
                 midiInOvl);

    //
    // Put the buffer in our queue
    //

    if (Result || GetLastError() == ERROR_IO_PENDING) {
        PLOCALMIDIHDR *ppHdr;
        pHdr->lpNext = NULL;
        ppHdr = &pClient->Mid->DeviceQueue;
        while (*ppHdr) {
           ppHdr = &(*ppHdr)->lpNext;
        }

        *ppHdr = pHdr;

        return MMSYSERR_NOERROR;
    }
    return sndTranslateStatus();
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiInWrite | Pass a new buffer to the Auxiliary thread for
 *       a midi device.
 *
 * @parm LPMIDIHDR | pHdr | Pointer to a midit buffer
 *
 * @parm PMIDIALLOC | pClient | The data associated with the logical midi
 *     device.
 *
 * @rdesc A MMSYS... type return code for the application.
 *
 * @comm The buffer flags are set and the buffer is passed to the auxiliary
 *     device task for processing.
 ***************************************************************************/
STATIC DWORD midiInWrite(LPMIDIHDR pHdr, PMIDIALLOC pClient)
{
    //
    // Put the request at the end of our queue.
    //
    pHdr->dwFlags |= MHDR_INQUEUE;
    pHdr->dwFlags &= ~MHDR_DONE;
    pClient->AuxParam.pHdr = pHdr;
    return midiThreadCall(MidiThreadAddBuffer, pClient);
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiSetState | Set a midi device to a given state
 *
 * @parm PMIDIALLOC | pClient | The data associated with the logical midi
 *     output device.
 *
 * @parm ULONG | State | The new state
 *
 * @rdesc A MMSYS... type return code for the application.
 ***************************************************************************/
STATIC DWORD midiSetState(PMIDIALLOC pClient, ULONG State)
{
    MMRESULT mRc;

    mRc = sndSetHandleData(pClient->hDev,
                           sizeof(State),
                           &State,
                           IOCTL_MIDI_SET_STATE,
                           pClient->Event);

    midiFlush(pClient);

    return mRc;
}



/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiThreadCall | Set the function for the thread to perform
 *     and 'call' the thread using the event pair mechanism.
 *
 * @parm MIDITHREADFUNCTION | Function | The function to perform
 *
 * @parm PMIDIALLOC | Our logical device data
 *
 * @rdesc An MMSYS... type return value suitable for returning to the
 *      application
 *
 * @comm The AuxParam field in the device data is the 'input' to
 *      the function processing loop in MidiThread().
 ***************************************************************************/
STATIC DWORD midiThreadCall(MIDITHREADFUNCTION Function, PMIDIALLOC pClient)
{
    //
    // Set the function code
    //
    pClient->AuxFunction = Function;

    //
    // Kick off the thread
    //
    SetEvent(pClient->AuxEvent1);

    //
    // Wait for it to complete
    //
    WaitForSingleObject(pClient->AuxEvent2, INFINITE);

    //
    // Return the return code that our task set.
    //
    return pClient->AuxReturnCode;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midiInApc | Apc routine.  Called when a kernel sound driver
 *     completes processing of a midi buffer.
 *
 * @parm PVOID | ApcContext | The Apc parameter.  In our case this is a
 *     pointer to our midi device data.
 *
 * @parm PIO_STATUS_BLOCK | pIosb | Pointer to the Io status block
 *     used for the request.
 *
 * @rdesc There is no return code.
 ***************************************************************************/
STATIC void midiInOvl(DWORD dwRet, DWORD dwBytesReturned, LPOVERLAPPED pOverlap)
{
    PLOCALMIDIHDR pHdr;

    pHdr = ((PLOCALMIDIHDR)pOverlap);

    WinAssert(((PMIDIALLOC)pHdr->pClient)->DeviceType == MIDI_IN);

    //
    // Note that the buffer is complete.  We don't do anything else here
    // because funny things happen if we call the client's callback
    // routine from within an Apc.
    //

    pHdr->BytesReturned = dwBytesReturned;
    pHdr->Done = TRUE;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midiFlush | Buffer completion routine.  This completes
 *     the work of the Apc routine at below Apc priority.  This gets
 *     round the nasty situations arising when the user's callback
 *     causes more apcs to run (I strongly suspect this is a kernel
 *     but).
 *
 * @parm PMIDIALLOC | pClient | The client's handle data
 *
 * @rdesc There is no return code.
 ***************************************************************************/

STATIC void midiFlush(PMIDIALLOC pClient)
{
    //
    // Process any completed buffers - the Apc routine
    // set the 'Done' flag in any completed requests.
    // Note that the call to the user's callback can
    // cause more requests to become complete
    //

    if (pClient->DeviceType == MIDI_IN) {  // Output is synchronous
        while (pClient->Mid->DeviceQueue &&
               pClient->Mid->DeviceQueue->Done) {

            PLOCALMIDIHDR pHdr;

            pHdr = pClient->Mid->DeviceQueue;

            //
            // Clear our flag ready for next time
            //

            pHdr->Done = FALSE;

            //
            // Take buffer off the device queue
            //


            pClient->Mid->DeviceQueue = pHdr->lpNext;

            //
            // Grab the latest time estimate - convert from 100ns units
            // to milliseconds
            //

            pClient->Mid->dwCurTime =
                (DWORD)(pHdr->MidiData.Time.QuadPart / 10000);

            //
            // Complete our buffer
            //

            if (!pClient->Mid->Bad) {
                int i;
                for (i = 0;
                             i + sizeof(LARGE_INTEGER) < pHdr->BytesReturned;
                                 i++) {
                    midByteRec(pClient, pHdr->MidiData.Data[i]);
                }
                //
                // Requeue our buffer if we're still recording
                //
                if (pClient->Mid->fMidiInStarted) {
                    if (midiInPutBuffer(pHdr, pClient) != MMSYSERR_NOERROR) {
                        pClient->Mid->Bad = TRUE;
                    }
                }
            }
        } // End of processing completed buffers
    }
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiThread | Midi device auxiliary thread.
 *
 * @parm LPVOID | lpParameter | The thread parameter.  In our case this is a
 *     pointer to our midi device data.
 *
 * @rdesc Thread return code.
 ***************************************************************************/
STATIC DWORD midiThread(LPVOID lpParameter)
{
    PMIDIALLOC pClient;
    BOOL Close;

    Close = FALSE;

    pClient = (PMIDIALLOC)lpParameter;

    //
    // Set our thread to high priority so we don't fail to pass
    // new buffers to the device when we get them back.  Also
    // we don't want any gaps if callbacks are meant to play
    // notes just received.
    //

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    //
    // We start notifying our creator we have started and
    // waiting for something to do.
    //

    SetEvent(pClient->AuxEvent2);
    WaitForSingleObject(pClient->AuxEvent1, INFINITE);

    //
    // Now we're going
    //

    for(;;) {
        //
        // Initialize our return code
        //

        pClient->AuxReturnCode = MMSYSERR_NOERROR;

        //
        // Decode function number to perform
        //

        switch (pClient->AuxFunction) {
        case MidiThreadAddBuffer:

            //
            // Add the buffer to our list to be processed
            //
            {
                LPMIDIHDR *pHdrSearch;

                pClient->AuxParam.pHdr->lpNext = NULL;

                pHdrSearch = &pClient->lpMIQueue;
                while (*pHdrSearch) {
                    pHdrSearch = &(*pHdrSearch)->lpNext;
                }

                *pHdrSearch = pClient->AuxParam.pHdr;
            }
            break;

        case MidiThreadSetState:



            switch (pClient->AuxParam.State) {
            case MIDI_DD_RECORD:
                //
                // Start means we must add our buffers to the driver's list
                //
                if (!pClient->Mid->fMidiInStarted && !pClient->Mid->Bad) {
                    int i;
                    for (i = 0; i < NUMBER_OF_LOCAL_MIDI_BUFFERS; i++) {
                        pClient->AuxReturnCode =
                            midiInPutBuffer(&pClient->Mid->Bufs[i], pClient);

                        if (pClient->AuxReturnCode != MMSYSERR_NOERROR) {
                            //
                            // Failed to add our buffer so give up and
                            // get our buffers back !
                            //
                            pClient->Mid->Bad = TRUE;
                            break;
                        }
                    }
                    //
                    // Set Device state.  By issuing state changes on THIS
                    // thread the calling thread can be sure that all Apc's
                    // generated by buffer completions will complete
                    // BEFORE this function completes.
                    //

                    pClient->AuxReturnCode =
                        midiSetState(pClient, pClient->AuxParam.State);

                    //
                    // If this failed then get our buffers back,
                    // otherwise set our new state
                    //
                    if (pClient->AuxReturnCode != MMSYSERR_NOERROR) {
                        pClient->Mid->Bad = TRUE;
                    } else {
                        pClient->Mid->fMidiInStarted = TRUE;
                    }
                } else {
                    //
                    // Already started or bad
                    //
                }
                break;

            case MIDI_DD_STOP:
                //
                // Set Device state.  By issuing state changes on THIS
                // thread the calling thread can be sure that all Apc's
                // generated by buffer completions will complete
                // BEFORE this function completes.
                //

                if (pClient->Mid->fMidiInStarted) {
                    pClient->Mid->fMidiInStarted = FALSE;

                    //
                    // RESET so we get our buffers back
                    //
                    pClient->AuxReturnCode =
                        midiSetState(pClient, MIDI_DD_RESET);
                        WinAssert(!pClient->Mid->DeviceQueue);

                    if (pClient->AuxReturnCode == MMSYSERR_NOERROR) {
                        midSendPartBuffer(pClient);
                    }
                }
                break;

            case MIDI_DD_RESET:
                //
                // Set Device state.  By issuing state changes on THIS
                // thread the calling thread can be sure that all Apc's
                // generated by buffer completions will complete
                // BEFORE this function completes.
                //

                if (pClient->Mid->fMidiInStarted) {
                    pClient->Mid->fMidiInStarted = FALSE;
                    pClient->AuxReturnCode =
                        midiSetState(pClient, pClient->AuxParam.State);
                        WinAssert(!pClient->Mid->DeviceQueue);

                    if (pClient->AuxReturnCode == MMSYSERR_NOERROR) {
                        pClient->Mid->Bad = FALSE; // Recovered !!
                        midSendPartBuffer(pClient);
                    }
                }
                //
                // We zero the input queue anyway - compatibility with
                // windows 3.1
                //
                midFreeQ(pClient);
                break;

            }
            break;

        case MidiThreadSetData:
            {
                pClient->AuxReturnCode =
                    sndSetHandleData(pClient->hDev,
                                     pClient->AuxParam.GetSetData.DataLen,
                                     pClient->AuxParam.GetSetData.pData,
                                     pClient->AuxParam.GetSetData.Function,
                                     pClient->Event);
            }
            break;

        case MidiThreadClose:
            //
            // Try to complete.
            // If we're completed all our buffers then we can.
            // otherwise we can't
            //
            if (pClient->lpMIQueue == NULL) {
                pClient->AuxReturnCode = MMSYSERR_NOERROR;
                Close = TRUE;
            } else {
                pClient->AuxReturnCode = MIDIERR_STILLPLAYING;
            }
            break;

        default:
            WinAssert(FALSE);   // Invalid call
            break;
        }
        //
        // Trap invalid callers
        //
        pClient->AuxFunction = MidiThreadInvalid;

                //
                // See if apcs completed
                //
                midiFlush(pClient);

        //
        // Release the caller
        //
        SetEvent(pClient->AuxEvent2);

        //
        // Complete ?
        //
        if (Close) {
            break;
        }
        //
        // Wait for more !
        //
        while (WaitForSingleObjectEx(pClient->AuxEvent1, INFINITE, TRUE) ==
                   WAIT_IO_COMPLETION) {
                        //
                        // Complete buffers whose Apcs ran
                        //
                        midiFlush(pClient);
        }
    }

    //
    // We've been asked to terminte
    //

    return 1;
}



/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midiCallback | This calls DriverCallback for a MIDIHDR.
 *
 * @parm PMIDIALLOC | pMidi | Pointer to midi device.
 *
 * @parm DWORD | msg | The message.
 *
 * @parm DWORD | dw1 | message DWORD (dw2 is always set to 0).
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void midiCallback(PMIDIALLOC pMidi, DWORD msg, DWORD_PTR dw1, DWORD_PTR dw2)
{

    // invoke the callback function, if it exists.  dwFlags contains
    // midi driver specific flags in the LOWORD and generic driver
    // flags in the HIWORD

    if (pMidi->dwCallback)
        DriverCallback(pMidi->dwCallback,       // user's callback DWORD
                       HIWORD(pMidi->dwFlags),  // callback flags
                       (HDRVR)pMidi->hMidi,     // handle to the midi device
                       msg,                     // the message
                       pMidi->dwInstance,       // user's instance data
                       dw1,                     // first DWORD
                       dw2);                    // second DWORD
}



/****************************************************************************

    This function conforms to the standard Midi input driver message proc
    (midMessage), which is documented in mmddk.d.

****************************************************************************/
DWORD APIENTRY midMessage(DWORD id, DWORD msg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
    PMIDIALLOC pInClient;

    switch (msg) {

        case MIDM_GETNUMDEVS:
            D2(("MIDM_GETNUMDEVS"));
            return sndGetNumDevs(MIDI_IN);

        case MIDM_GETDEVCAPS:
            D2(("MIDM_GETDEVCAPS"));
            return midiGetDevCaps(id, MIDI_IN, (LPBYTE)dwParam1,
                                  (DWORD)dwParam2);

        case MIDM_OPEN:
            D2(("MIDM_OPEN"));
            return midiOpen(MIDI_IN, id, dwUser, dwParam1, dwParam2);

        case MIDM_CLOSE:
            D2(("MIDM_CLOSE"));
            pInClient = (PMIDIALLOC)dwUser;

            //
            // Call our task to see if it's ready to complete
            //
            if (midiThreadCall(MidiThreadClose, pInClient) != 0L) {
                return MIDIERR_STILLPLAYING;
            }

            //
            // Wait for our thread to terminate and close our device
            //
            WaitForSingleObject(pInClient->ThreadHandle, INFINITE);
            CloseHandle(pInClient->ThreadHandle);

            //
            // Tell the caller we're done
            //
            midiCallback(pInClient, MIM_CLOSE, 0L, 0L);

            midiCleanUp(pInClient);


            return MMSYSERR_NOERROR;

        case MIDM_ADDBUFFER:
            D2(("MIDM_ADDBUFFER"));

            // check if it's been prepared
            if (!(((LPMIDIHDR)dwParam1)->dwFlags & MHDR_PREPARED))
                return MIDIERR_UNPREPARED;

            WinAssert(!(((LPMIDIHDR)dwParam1)->dwFlags & MHDR_INQUEUE));

            // if it is already in our Q, then we cannot do this
            if ( ((LPMIDIHDR)dwParam1)->dwFlags & MHDR_INQUEUE )
                return ( MIDIERR_STILLPLAYING );

            // store the pointer to my MIDIALLOC structure in the midihdr
            pInClient = (PMIDIALLOC)dwUser;
            ((LPMIDIHDR)dwParam1)->reserved = (DWORD_PTR)(LPSTR)pInClient;

            return midiInWrite((LPMIDIHDR)dwParam1, pInClient);

        case MIDM_STOP:
            D2(("MIDM_PAUSE"));
            pInClient = (PMIDIALLOC)dwUser;
            pInClient->AuxParam.State = MIDI_DD_STOP;
            return midiThreadCall(MidiThreadSetState, pInClient);

        case MIDM_START:
            D2(("MIDM_RESTART"));
            pInClient = (PMIDIALLOC)dwUser;
            pInClient->AuxParam.State = MIDI_DD_RECORD;
            return midiThreadCall(MidiThreadSetState, pInClient);

        case MIDM_RESET:
            D2(("MIDM_RESET"));
            pInClient = (PMIDIALLOC)dwUser;
            pInClient->AuxParam.State = MIDI_DD_RESET;
            return midiThreadCall(MidiThreadSetState, pInClient);

        default:
            return MMSYSERR_NOTSUPPORTED;
    }

    //
    // Should not get here
    //

    WinAssert(0);
    return MMSYSERR_NOTSUPPORTED;
}

/****************************************************************************

    This function conforms to the standard Midi output driver message proc
    (modMessage), which is documented in mmddk.d.

****************************************************************************/
DWORD APIENTRY modMessage(DWORD id, DWORD msg, DWORD_PTR dwUser, DWORD_PTR dwParam1,
                          DWORD_PTR dwParam2)
{
    PMIDIALLOC pOutClient;

    switch (msg) {
    case MODM_GETNUMDEVS:
        D2(("MODM_GETNUMDEVS"));
        return sndGetNumDevs(MIDI_OUT);

    case MODM_GETDEVCAPS:
        D2(("MODM_GETDEVCAPS"));
        return midiGetDevCaps(id, MIDI_OUT, (LPBYTE)dwParam1,
                              (DWORD)dwParam2);

    case MODM_OPEN:
        D2(("MODM_OPEN"));
        return midiOpen(MIDI_OUT, id, dwUser, dwParam1, dwParam2);

    case MODM_CLOSE:
        D2(("MODM_CLOSE"));
        pOutClient = (PMIDIALLOC)dwUser;

        midiCallback(pOutClient, MOM_CLOSE, 0L, 0L);

        //
        // Close our device
        //
        midiCleanUp(pOutClient);

        return MMSYSERR_NOERROR;

    case MODM_DATA:
        D2(("MODM_DATA"));
        {
            int i;
            BYTE b[4];
            for (i = 0; i < 4; i ++) {
                b[i] = (BYTE)(dwParam1 % 256);
                dwParam1 /= 256;
            }
            return midiOutWrite(b, modMIDIlength((PMIDIALLOC)dwUser, b[0]),
                                (PMIDIALLOC)dwUser);
        }

    case MODM_LONGDATA:
        D2(("MODM_LONGDATA"));

        pOutClient = (PMIDIALLOC)dwUser;
        {
            LPMIDIHDR lpHdr;
            MMRESULT  mRet;

            //
            // check if it's been prepared
            //
            lpHdr = (LPMIDIHDR)dwParam1;
            if (!(lpHdr->dwFlags & MHDR_PREPARED)) {
                return MIDIERR_UNPREPARED;
            }

            //
            //
            //

            mRet = midiOutWrite((LPBYTE)lpHdr->lpData, lpHdr->dwBufferLength,
                                pOutClient);

            // note that clearing the done bit or setting the inqueue bit
            // isn't necessary here since this function is synchronous -
            // the client will not get control back until it's done.

            lpHdr->dwFlags |= MHDR_DONE;

            // notify client

            if (mRet == MMSYSERR_NOERROR) {
                midiCallback(pOutClient, MOM_DONE, (DWORD_PTR)lpHdr, 0L);
            }

            return mRet;
        }


    case MODM_RESET:
        D2(("MODM_RESET"));
        return midiSetState((PMIDIALLOC)dwUser, MIDI_DD_RESET);


    case MODM_SETVOLUME:
        D2(("MODM_SETVOLUME"));
        //pOutClient = (PMIDIALLOC)dwUser;
        //pOutClient->AuxParam.GetSetData.pData = *(PBYTE *)&dwParam1;
        //pOutClient->AuxParam.GetSetData.DataLen = sizeof(DWORD);
        //pOutClient->AuxParam.GetSetData.Function = IOCTL_MIDI_SET_VOLUME;
        //return midiThreadCall(MidiThreadSetData, pOutClient);

        return sndSetData(MIDI_OUT, id, sizeof(DWORD),
                          (PBYTE)&dwParam1, IOCTL_MIDI_SET_VOLUME);


    case MODM_GETVOLUME:
        D2(("MODM_GETVOLUME"));
        //pOutClient = (PMIDIALLOC)dwUser;
        //pOutClient->AuxParam.GetSetData.pData = *(PBYTE *)&dwParam1;
        //pOutClient->AuxParam.GetSetData.DataLen = sizeof(DWORD);
        //pOutClient->AuxParam.GetSetData.Function = IOCTL_MIDI_GET_VOLUME;
        //return midiThreadCall(MidiThreadGetData, pOutClient);

        return sndGetData(MIDI_OUT, id, sizeof(DWORD),
                          (PBYTE)dwParam1, IOCTL_MIDI_GET_VOLUME);

    case MODM_CACHEPATCHES:

        D2(("MODM_CACHEPATCHES"));

        pOutClient = (PMIDIALLOC)dwUser;
        {
            MIDI_DD_CACHE_PATCHES AppData;
            DWORD BytesReturned;

            AppData.Bank = HIWORD(dwParam2);
            AppData.Flags = LOWORD(dwParam2);
            memcpy(AppData.Patches, (PVOID)dwParam1, sizeof(AppData.Patches));

            return DeviceIoControl(
                           pOutClient->hDev,
                           IOCTL_MIDI_CACHE_PATCHES,
                           (PVOID)&AppData,
                           sizeof(AppData),
                           NULL,
                           0,
                           &BytesReturned,
                           NULL) ?
                 MMSYSERR_NOERROR :
                 sndTranslateStatus();
        }

    case MODM_CACHEDRUMPATCHES:

        D2(("MODM_CACHEDRUMPATCHES"));

        pOutClient = (PMIDIALLOC)dwUser;
        {
            MIDI_DD_CACHE_DRUM_PATCHES AppData;
            DWORD BytesReturned;

            AppData.Patch = HIWORD(dwParam2);
            AppData.Flags = LOWORD(dwParam2);
            memcpy(AppData.DrumPatches, (PVOID)dwParam1,
                   sizeof(AppData.DrumPatches));

            return DeviceIoControl(
                           pOutClient->hDev,
                           IOCTL_MIDI_CACHE_DRUM_PATCHES,
                           (PVOID)&AppData,
                           sizeof(AppData),
                           NULL,
                           0,
                           &BytesReturned,
                           NULL) ?
                 MMSYSERR_NOERROR :
                 sndTranslateStatus();
        }

    default:
        return MMSYSERR_NOTSUPPORTED;
    }

    //
    // Should not get here
    //

    WinAssert(0);
    return MMSYSERR_NOTSUPPORTED;
}


/***********************************************************************

 UTILITY ROUTINES PORTED DIRECTLY FROM WIN 3.1

 ***********************************************************************/


/****************************************************************************
 * @doc INTERNAL
 *
 * @api int | modMIDIlength | Get the length of a short midi message.
 *
 * @parm DWORD | dwMessage | The message.
 *
 * @rdesc Returns the length of the message.
 ***************************************************************************/
STATIC int modMIDIlength(PMIDIALLOC pClient, BYTE b)
{
    if (b >= 0xF8) {             // system realtime
        /*  for realtime messages, leave running status untouched */
        return 1;                // write one byte
    }

    switch (b) {
    case 0xF0: case 0xF4: case 0xF5: case 0xF6: case 0xF7:
        pClient->l = 1;
        return pClient->l;

    case 0xF1: case 0xF3:
        pClient->l = 2;
        return pClient->l;

    case 0xF2:
        pClient->l = 3;
        return pClient->l;
    }

    switch (b & 0xF0) {
    case 0x80: case 0x90: case 0xA0: case 0xB0: case 0xE0:
        pClient->l = 3;
        return pClient->l;

    case 0xC0: case 0xD0:
        pClient->l = 2;
        return pClient->l;
    }

    return (pClient->l - 1);        // uses previous value if data byte (running status)
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midBufferWrite | This function writes a byte into the long
 *     message buffer.  If the buffer is full or a SYSEX_ERROR or
 *     end-of-sysex byte is received, the buffer is marked as 'done' and
 *     it's owner is called back.
 *
 * @parm BYTE | byte | The byte received.
 *
 * @rdesc There is no return value
 ***************************************************************************/
STATIC void midBufferWrite(PMIDIALLOC pClient, BYTE byte)
{
LPMIDIHDR  lpmh;
UINT       msg;

    // if no buffers, nothing happens
    if (pClient->lpMIQueue == NULL)
        return;

    lpmh = pClient->lpMIQueue;

    if (byte == SYSEX_ERROR) {
        D2(("sysexerror"));
        msg = MIM_LONGERROR;
    }
    else {
        D2(("bufferwrite"));
        msg = MIM_LONGDATA;
        *((LPSTR)(lpmh->lpData) + pClient->Mid->dwCurData++) = byte;
    }

    // if end of sysex, buffer full or error, send them back the buffer
    if ((byte == SYSEX_ERROR) || (byte == 0xF7) || (pClient->Mid->dwCurData >= lpmh->dwBufferLength)) {
        D2(("bufferdone"));
        pClient->lpMIQueue = pClient->lpMIQueue->lpNext;
        lpmh->dwBytesRecorded = pClient->Mid->dwCurData;
        pClient->Mid->dwCurData = 0L;
        lpmh->dwFlags |= MHDR_DONE;
        lpmh->dwFlags &= ~MHDR_INQUEUE;
        midiCallback(pClient, msg, (DWORD_PTR)lpmh, pClient->Mid->dwMsgTime);
    }

    return;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midByteRec | This function constructs the complete midi
 *     messages from the individual bytes received and passes the message
 *     to the client via his callback.
 *
 * @parm WORD | word | The byte received is in the low order byte.
 *
 * @rdesc There is no return value
 *
 * @comm Note that currently running status isn't turned off on errors.
 ***************************************************************************/
STATIC void midByteRec(PMIDIALLOC pClient, BYTE byte)
{

    if (!pClient->Mid->fMidiInStarted)
        return;

    // if it's a system realtime message, send it
    // this does not affect running status or any current message
    if (byte >= 0xF8) {
        D2((" rt"));
        midiCallback(pClient, MIM_DATA, (DWORD)byte, pClient->Mid->dwCurTime);
    }

    // else if it's a system common message
    else if (byte >= 0xF0) {

        if (pClient->Mid->fSysex) {                        // if we're in a sysex
            pClient->Mid->fSysex = FALSE;                  // status byte during sysex ends it
            if (byte == 0xF7)
            {
                midBufferWrite(pClient, 0xF7);        // write in long message buffer
                return;
            }
            else
                midBufferWrite(pClient, SYSEX_ERROR); // secret code indicating error
        }

        if (pClient->Mid->dwMsg) {              // throw away any incomplete short data
            midiCallback(pClient, MIM_ERROR, pClient->Mid->dwMsg, pClient->Mid->dwMsgTime);
            pClient->Mid->dwMsg = 0L;
        }

        pClient->Mid->status = 0;               // kill running status
        pClient->Mid->dwMsgTime = pClient->Mid->dwCurTime;    // save timestamp

        switch(byte) {

        case 0xF0:
            D2((" F0"));
            pClient->Mid->fSysex = TRUE;
            midBufferWrite(pClient, 0xF0);
            break;

        case 0xF7:
            D2((" F7"));
            if (!pClient->Mid->fSysex)
                midiCallback(pClient, MIM_ERROR, (DWORD)byte, pClient->Mid->dwMsgTime);
            // else already took care of it above
            break;

        case 0xF4:      // system common, no data bytes
        case 0xF5:
        case 0xF6:
            D2((" status0"));
            midiCallback(pClient, MIM_DATA, (DWORD)byte, pClient->Mid->dwMsgTime);
            pClient->Mid->bBytePos = 0;
            break;

        case 0xF1:      // system common, one data byte
        case 0xF3:
            D2((" status1"));
            pClient->Mid->dwMsg |= byte;
            pClient->Mid->bBytesLeft = 1;
            pClient->Mid->bBytePos = 1;
            break;

        case 0xF2:      // system common, two data bytes
            D2((" status2"));
            pClient->Mid->dwMsg |= byte;
            pClient->Mid->bBytesLeft = 2;
            pClient->Mid->bBytePos = 1;
            break;
        }
    }

    // else if it's a channel message
    else if (byte >= 0x80) {

        if (pClient->Mid->fSysex) {                        // if we're in a sysex
            pClient->Mid->fSysex = FALSE;                  // status byte during sysex ends it
            midBufferWrite(pClient, SYSEX_ERROR);     // secret code indicating error
        }

        if (pClient->Mid->dwMsg) {              // throw away any incomplete data
            midiCallback(pClient, MIM_ERROR, pClient->Mid->dwMsg, pClient->Mid->dwMsgTime);
            pClient->Mid->dwMsg = 0L;
        }

        pClient->Mid->status = byte;            // save for running status
        pClient->Mid->dwMsgTime = pClient->Mid->dwCurTime;    // save timestamp
        pClient->Mid->dwMsg |= byte;
        pClient->Mid->bBytePos = 1;

        switch(byte & 0xF0) {

        case 0xC0:         // channel message, one data byte
        case 0xD0:
            D2((" status1"));
            pClient->Mid->bBytesLeft = 1;
            break;

        case 0x80:         // channel message, two data bytes
        case 0x90:
        case 0xA0:
        case 0xB0:
        case 0xE0:
            D2((" status2"));
            pClient->Mid->bBytesLeft = 2;
            break;
        }
    }

    // else if it's an expected data byte for a long message
    else if (pClient->Mid->fSysex) {
        D2((" sxdata"));
        midBufferWrite(pClient, byte);        // write in long message buffer
    }

    // else if it's an expected data byte for a short message
    else if (pClient->Mid->bBytePos != 0) {
        D2((" data"));
        if ((pClient->Mid->status) && (pClient->Mid->bBytePos == 1)) { // if running status
             pClient->Mid->dwMsg |= pClient->Mid->status;
             pClient->Mid->dwMsgTime = pClient->Mid->dwCurTime;        // save timestamp
        }
        pClient->Mid->dwMsg += (DWORD)byte << ((pClient->Mid->bBytePos++) * 8);
        if (--pClient->Mid->bBytesLeft == 0) {
            midiCallback(pClient, MIM_DATA, pClient->Mid->dwMsg, pClient->Mid->dwMsgTime);
            pClient->Mid->dwMsg = 0L;
            if (pClient->Mid->status) {
                pClient->Mid->bBytesLeft = pClient->Mid->bBytePos - (BYTE)1;
                pClient->Mid->bBytePos = 1;
            }
            else {
                pClient->Mid->bBytePos = 0;
            }
        }
    }

    // else if it's an unexpected data byte
    else {
        D2((" baddata"));
        midiCallback(pClient, MIM_ERROR, (DWORD)byte, pClient->Mid->dwMsgTime);
    }

    return;
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midFreeQ | Free all buffers in the MIQueue.
 *
 * @comm Currently this is only called after sending off any partially filled
 *     buffers, so all buffers here are empty.  The timestamp value is 0 in
 *     this case.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
STATIC void midFreeQ(PMIDIALLOC pClient)
{
LPMIDIHDR   lpH, lpN;

    lpH = pClient->lpMIQueue;              // point to top of the queue
    pClient->lpMIQueue = NULL;             // mark the queue as empty
    pClient->Mid->dwCurData = 0L;

    while (lpH) {
        lpN = lpH->lpNext;
        lpH->dwFlags |= MHDR_DONE;
        lpH->dwFlags &= ~MHDR_INQUEUE;
        lpH->dwBytesRecorded = 0;
        midiCallback(pClient, MIM_LONGDATA, (DWORD_PTR)lpH,
                     pClient->Mid->dwCurTime);
        lpH = lpN;
    }
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midSendPartBuffer | This function is called from midStop().
 *     It looks at the buffer at the head of the queue and, if it contains
 *     any data, marks it as done as sends it back to the client.
 *
 * @rdesc The return value is the number of bytes transfered. A value of zero
 *     indicates that there was no more data in the input queue.
 ***************************************************************************/
STATIC void midSendPartBuffer(PMIDIALLOC pClient)
{
LPMIDIHDR lpH;

    if (pClient->lpMIQueue && pClient->Mid->dwCurData) {
        lpH = pClient->lpMIQueue;
        pClient->lpMIQueue = pClient->lpMIQueue->lpNext;
        lpH->dwFlags |= MHDR_DONE;
        lpH->dwFlags &= ~MHDR_INQUEUE;
        pClient->Mid->dwCurData = 0L;
        midiCallback(pClient, MIM_LONGERROR, (DWORD_PTR)lpH,
                     pClient->Mid->dwMsgTime);
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\drvlib\auxdd.c ===
/****************************************************************************
 *
 *   auxdd.c
 *
 *   Multimedia kernel driver support component (mmdrv)
 *
 *   Copyright (c) 1991-1996 Microsoft Corporation
 *
 *   Driver for wave input and output devices
 *
 *   -- Aux driver entry point(auxMessage)
 *
 *   History
 *      25-Aug-1992 - Robin Speed (RobinSp) wrote it
 *
 ***************************************************************************/

 #include <drvlib.h>
 #include <ntddaux.h>

/****************************************************************************

    This function conforms to the standard Aux driver message proc
    (auxMessage), which is documented in the DDK.

****************************************************************************/
 DWORD APIENTRY auxMessage(UINT uDevice,
                           UINT uMsg,
                           DWORD_PTR dwUser,
                           DWORD_PTR dwParam1,
                           DWORD_PTR dwParam2)

{
    MMRESULT mRet;
    AUX_DD_VOLUME Volume;

    switch (uMsg) {
    case AUXDM_GETDEVCAPS:
        dprintf2(("AUXDM_GETDEVCAPS"));
        {
            MMRESULT mrc;
            AUXCAPSW ac;
            mrc = sndGetData(AUX_DEVICE, uDevice, sizeof(ac), (LPBYTE)&ac,
                             IOCTL_AUX_GET_CAPABILITIES);

            if (mrc != MMSYSERR_NOERROR) {
                return mrc;
            }
            InternalLoadString((UINT)*(LPDWORD)ac.szPname, ac.szPname,
                               sizeof(ac.szPname) / sizeof(WCHAR));

            CopyMemory((LPVOID)dwParam1, &ac, min(sizeof(ac), dwParam2));

            return MMSYSERR_NOERROR;
        }

    case AUXDM_GETNUMDEVS:
        dprintf2(("AUXDM_GETNUMDEVS"));
        return sndGetNumDevs(AUX_DEVICE);

    case AUXDM_GETVOLUME:
        dprintf2(("AUXDM_GETVOLUME"));

        mRet = sndGetData(AUX_DEVICE, uDevice, sizeof(Volume),
                          (PBYTE)&Volume, IOCTL_AUX_GET_VOLUME);

        if (mRet == MMSYSERR_NOERROR) {
            *(LPDWORD)dwParam1 =
                (DWORD)MAKELONG(HIWORD(Volume.Left),
                                HIWORD(Volume.Right));
        }

        return mRet;

    case AUXDM_SETVOLUME:
        dprintf2(("AUXDM_SETVOLUME"));
        Volume.Left = LOWORD(dwParam1) << 16;
        Volume.Right = HIWORD(dwParam1) << 16;

        return sndSetData(AUX_DEVICE, uDevice, sizeof(Volume),
                          (PBYTE)&Volume, IOCTL_AUX_SET_VOLUME);

    default:
        return MMSYSERR_NOTSUPPORTED;
    }

    //
    // Should not get here
    //

    WinAssert(0);
    return MMSYSERR_NOTSUPPORTED;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\drvlib\registry.c ===
/****************************************************************************
 *
 *   registry.c
 *
 *   Copyright (c) 1992-1994 Microsoft Corporation
 *
 *   This file contains functions to maintain registry entries for
 *   kernel drivers installed via the drivers control panel applet.
 *
 *   Note that the ONLY state maintained between calls here is whatever
 *   state the registry and its handles maintain.
 *
 *   The registry entries are structured as follows :
 *   (see also winreg.h, winnt.h)
 *
 *   HKEY_LOCAL_MACHINE
 *       SYSTEM
 *           CurrentControlSet
 *               Services
 *                   DriverNode      (eg sndblst)
 *                           Type         = SERVICE_KERNEL_DRIVER (eg)
 *                           Group        = "Base"
 *                           ErrorControl = SERVICE_ERROR_NORMAL
 *                           Start        = SERVICE_SYSTEM_START |
 *                                          SERVICE_DEMAND_START |
 *                                          SERVICE_DISABLED
 *                                          ...
 *                           Tag          = A unique number ???
 *
 *                        Parameters
 *                           Device0
 *                                   Interrupt  =
 *                                   Port       =
 *                                   DMAChannel =
 *
 *   The Driver node is set up by the services manager when we call
 *   CreateService but we have to insert the device data ourselves.
 *
 *
 *
 *   The registry entries are shared between :
 *
 *        The system loader (which uses the Services entry)
 *        The kernel driver (which reads from the Device entry)
 *        This component called from the drivers control panel applet
 *        The service control manager
 *        The Setup utility
 *
 *   Security access
 *   ---------------
 *
 *   The driver determines whether it can perform configuration and
 *   installation by whether it can get read and write access to the
 *   service control manager.  This is required to manipulate the kernel
 *   driver database.
 *
 *   Services controller
 *   -------------------
 *
 *   The services controller is used because this is the only way we
 *   are allowed to load and unload kernel drivers.  Only the services
 *   controller can call LoadDriver and UnloadDriver and not get 'access
 *   denied'.
 *
 *   Note also that we can't keep the services controller handle open
 *   at the same time as the registry handle because then we can't get
 *   write access (actually we only need KEY_CREATE_SUB_KEY access) to
 *   our device parameters subkey.
 *
 ***************************************************************************/

 #include <stdio.h>
 #include <windows.h>
 #include <mmsystem.h>
 #include <winsvc.h>
 #include <soundcfg.h>
 #include "registry.h"

/***************************************************************************
 *
 * Constants for accessing the registry
 *
 ***************************************************************************/

    /*
     *  Path to service node key
     */

     #define STR_SERVICES_NODE TEXT("SYSTEM\\CurrentControlSet\\Services\\")

    /*
     *  Node sub-key for device parameters
     */

     #define STR_DEVICE_DATA PARMS_SUBKEY

    /*
     *  Name of Base group where sound drivers normally go
     */

     #define STR_BASE_GROUP TEXT("Base")

    /*
     *  Name of driver group for synthesizers
     *     - we use our own name here to make sure
     *       we are loaded after things like the PAS driver.  (Base is a
     *       known group and drivers in it are always loaded before unknown
     *       groups like this one).
     */

     #define STR_SYNTH_GROUP TEXT("Synthesizer Drivers")

    /*
     *  Name of service
     */

     #define STR_DRIVER TEXT("\\Driver\\")

    /*
     *  Path to kernel drivers directory from system directory
     */

     #define STR_DRIVERS_DIR TEXT("\\SystemRoot\\System32\\drivers\\")

    /*
     *  Extension for drivers
     */

     #define STR_SYS_EXT TEXT(".SYS")

 BOOL DrvSaveParametersKey(PREG_ACCESS RegAccess)
 {
     TCHAR TempFilePath[MAX_PATH];
     HKEY  ParametersKey;


     if (GetTempPath(MAX_PATH, TempFilePath) > MAX_PATH) {
         return FALSE;
     }

     if (GetTempFileName(TempFilePath,
                         TEXT("DRV"),
                         0,
                         RegAccess->TempKeySaveFileName) == 0) {
         return FALSE;
     }

     ParametersKey = DrvOpenRegKey(RegAccess->DriverName, NULL);

     if (ParametersKey == NULL) {
         RegAccess->TempKeySaveFileName[0] = '\0';
         return FALSE;
     }

     if (ERROR_SUCCESS != RegSaveKey(ParametersKey,
                                     RegAccess->TempKeySaveFileName,
                                     NULL)) {
         RegCloseKey(ParametersKey);
         RegAccess->TempKeySaveFileName[0] = '\0';
         return FALSE;
     }

     RegCloseKey(ParametersKey);

     return TRUE;
 }

 BOOL DrvRestoreParametersKey(PREG_ACCESS RegAccess)
 {
     BOOL Rc;
     HKEY ParametersKey;

     ParametersKey = DrvOpenRegKey(RegAccess->DriverName, NULL);

     Rc = ParametersKey != NULL &&
          ERROR_SUCCESS == RegRestoreKey(ParametersKey,
                                         RegAccess->TempKeySaveFileName,
                                         0);

     RegCloseKey(ParametersKey);
     DeleteFile(RegAccess->TempKeySaveFileName);

     RegAccess->TempKeySaveFileName[0] = '\0';

     return Rc;
 }

 HKEY DrvOpenRegKey(LPCTSTR DriverName, LPCTSTR Path)
 {
     TCHAR RegistryPath[MAX_PATH];
     HKEY NodeHandle;

     //
     // Create the path to our node
     //

     lstrcpy(RegistryPath, STR_SERVICES_NODE);
     lstrcat(RegistryPath, DriverName);
     lstrcat(RegistryPath, TEXT("\\"));
     lstrcat(RegistryPath, PARMS_SUBKEY);
     if (Path != NULL && lstrlen(Path) != 0) {
         lstrcat(RegistryPath, TEXT("\\"));
         lstrcat(RegistryPath, Path);
     }

     //
     // See if we can get a registry handle to our device data
     //


     if (RegCreateKey(HKEY_LOCAL_MACHINE, RegistryPath, &NodeHandle)
         != ERROR_SUCCESS) {
         return NULL;
     } else {
         return NodeHandle;
     }
 }

 HKEY DrvCreateDeviceKey(LPCTSTR DriverName) {
     UINT i;
     HKEY hKey;

     for (i = 0; ; i++) {

         hKey = DrvOpenDeviceKey(DriverName, i);

         if (hKey == NULL) {
             TCHAR DeviceKeyName[MAX_PATH];

             wsprintf(DeviceKeyName, TEXT("Device%d"), i);

             return DrvOpenRegKey(DriverName, DeviceKeyName);
         } else {
             RegCloseKey(hKey);
         }
     }
 }

 HKEY DrvOpenDeviceKey(LPCTSTR DriverName, UINT n)
 {
     TCHAR DeviceKeyName[MAX_PATH];
     HKEY  hKeyParameters;
     HKEY  hKeyReturn;
     DWORD SubKeySize;

     SubKeySize = MAX_PATH;

     hKeyParameters = DrvOpenRegKey(DriverName, NULL);

     if (hKeyParameters == NULL) {
         return NULL;
     }

     hKeyReturn = NULL;

     if (ERROR_SUCCESS == RegEnumKeyEx(hKeyParameters,
                                       n,
                                       DeviceKeyName,
                                       &SubKeySize,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL)) {
         RegOpenKey(hKeyParameters, DeviceKeyName, &hKeyReturn);
     }

     RegCloseKey(hKeyParameters);

     return hKeyReturn;
 }

 SC_HANDLE DrvOpenService(PREG_ACCESS RegAccess)
 {
     SC_HANDLE Handle;
     Handle = OpenService(RegAccess->ServiceManagerHandle,
                          RegAccess->DriverName,
                          SERVICE_ALL_ACCESS);

#if 0
     if (Handle == NULL) {
         char buf[100];
         sprintf(buf, "OpenService failed code %d\n", GetLastError());
         OutputDebugStringA(buf);
     }
#endif

     return Handle;
 }

 void DrvCloseService(PREG_ACCESS RegAccess, SC_HANDLE ServiceHandle)
 {
     CloseServiceHandle(ServiceHandle);
 }

/***************************************************************************
 *
 *  Function :
 *      DrvCreateServicesNode
 *
 *  Parameters :
 *      DriverNodeName      The name of the service node.  Same as the
 *                          name of the driver which must be
 *                          DriverNodeName.sys for the system to find it.
 *
 *      DriverType          Type of driver - see registry.h
 *
 *      ServiceNodeKey      Pointer to where to put returned handle
 *
 *  Return code :
 *
 *      Standard error code (see winerror.h)
 *
 *  Description :
 *
 *      Create the service node key
 *
 *      The class name of the registry node is ""
 *
 ***************************************************************************/

 BOOL
 DrvCreateServicesNode(LPTSTR DriverName,
                       SOUND_KERNEL_MODE_DRIVER_TYPE DriverType,
                       PREG_ACCESS RegAccess,
                       BOOL Create)
 {
     SERVICE_STATUS ServiceStatus;
     SC_HANDLE ServiceHandle;                 // Handle to our driver 'service'

     RegAccess->DriverName = DriverName;

     //
     // See if we can open the registry
     //

     if (RegAccess->ServiceManagerHandle == NULL) {
         RegAccess->ServiceManagerHandle =
             OpenSCManager(
                 NULL,                        // This machine
                 NULL,                        // The active database
                 SC_MANAGER_ALL_ACCESS);      // We want to create and change

         if (RegAccess->ServiceManagerHandle == NULL) {
             return FALSE;
         }
     }

     //
     // Open our particular service
     //

     ServiceHandle = DrvOpenService(RegAccess);

     //
     // See if that worked
     //

     if (ServiceHandle == NULL &&
         GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST) {
         if (Create) {
             SC_LOCK ServicesDatabaseLock;
             TCHAR ServiceName[MAX_PATH];
             TCHAR BinaryPath[MAX_PATH];

             lstrcpy(BinaryPath, STR_DRIVERS_DIR);
             lstrcat(BinaryPath, DriverName);
             lstrcat(BinaryPath, STR_SYS_EXT);

             lstrcpy(ServiceName, STR_DRIVER);
             lstrcat(ServiceName, DriverName);

            /*
             *  Lock the service controller database to avoid deadlocks
             *  we have to loop because we can't wait
             */


             for (ServicesDatabaseLock = NULL;
                  (ServicesDatabaseLock =
                       LockServiceDatabase(RegAccess->ServiceManagerHandle))
                     == NULL;
                  Sleep(100)) {
             }


            /*
             *  Create the service
             */


             ServiceHandle =
                 CreateService(
                     RegAccess->ServiceManagerHandle,
                     DriverName,               // Service name
                     NULL,                     // ???
                     SERVICE_ALL_ACCESS,       // Full access
                     SERVICE_KERNEL_DRIVER,    // Kernel driver
                     SERVICE_DEMAND_START,     // Start at sys start
                     SERVICE_ERROR_NORMAL,     // Not a disaster if fails
                     BinaryPath,               // Default path

                     DriverType == SoundDriverTypeSynth ?
                         STR_SYNTH_GROUP :     // Driver group
                         STR_BASE_GROUP,
                     NULL,                     // do not want TAG information
                     TEXT("\0"),               // No dependencies
                     NULL, // ServiceName,              // Driver object - optional
                     NULL);                    // No password

             UnlockServiceDatabase(ServicesDatabaseLock);
#if DBG
             if (ServiceHandle == NULL) {
                 TCHAR buf[100];
                 wsprintf(buf, TEXT("CreateService failed code %d\n"), GetLastError());
                 OutputDebugString(buf);
             }
#endif

         }
     }

     //
     // Check at least that it's a device driver
     //

     if (ServiceHandle != NULL) {
         if (!QueryServiceStatus(
                 ServiceHandle,
                 &ServiceStatus) ||
             ServiceStatus.dwServiceType != SERVICE_KERNEL_DRIVER) {

             //
             // Doesn't look like ours
             //

             CloseServiceHandle(RegAccess->ServiceManagerHandle);
             RegAccess->ServiceManagerHandle = NULL;
             DrvCloseService(RegAccess, ServiceHandle);
             return FALSE;
         }

     }

     if (ServiceHandle == NULL) {
         //
         // Leave the SC manager  handle open.  We use the presence of this
         // handle to test whether the driver can be configured (ie whether we
         // have the access rights to get into the SC manager).
         //

         return FALSE;
     } else {
         //
         // We can't keep this handle open (even though we'd like to) because
         // we need write access to the registry node created so that
         // we can add device parameters
         //

         DrvCloseService(RegAccess, ServiceHandle);
         return TRUE;
     }
 }


/***************************************************************************
 *
 *  Function :
 *      DrvCloseServicesNode
 *
 *  Parameters :
 *      ServiceNodeKey
 *
 *  Return code :
 *
 *      Standard error code (see winerror.h)
 *
 *  Description :
 *
 *      Close our handle
 *
 ***************************************************************************/

 VOID
 DrvCloseServiceManager(
     PREG_ACCESS RegAccess)
 {
     if (RegAccess->ServiceManagerHandle != NULL) {
         CloseServiceHandle(RegAccess->ServiceManagerHandle);
         RegAccess->ServiceManagerHandle = NULL;
     }

     if (RegAccess->TempKeySaveFileName[0] != '\0') {
         DeleteFile(RegAccess->TempKeySaveFileName);
     }
 }

/***************************************************************************
 *
 *  Function :
 *      DrvDeleteServicesNode
 *
 *  Parameters :
 *      DeviceName
 *
 *  Return code :
 *
 *      TRUE = success, FALSE = failed
 *
 *  Description :
 *
 *      Delete our node using the handle proviced
 *
 ***************************************************************************/

 BOOL
 DrvDeleteServicesNode(
     PREG_ACCESS RegAccess)
 {
     BOOL Success;
     SC_LOCK ServicesDatabaseLock;
     SC_HANDLE ServiceHandle;

     /*
     **  Delete the service node and free tha handle
     **  (Note the service cannot be deleted until all handles are closed)
     */

     ServiceHandle = DrvOpenService(RegAccess);

     if (ServiceHandle == NULL) {
         LONG Error;
         Error = GetLastError();
         if (Error == ERROR_SERVICE_DOES_NOT_EXIST) {
             /*
             **  It's already gone !
             */
             return TRUE;
         } else {
             return FALSE; // It was there but something went wrong
         }
     }

    /*
     *  Lock the service controller database to avoid deadlocks
     *  we have to loop because we can't wait
     */


     for (ServicesDatabaseLock = NULL;
          (ServicesDatabaseLock =
               LockServiceDatabase(RegAccess->ServiceManagerHandle))
             == NULL;
          Sleep(100)) {
     }

     Success = DeleteService(ServiceHandle);

     UnlockServiceDatabase(ServicesDatabaseLock);

     DrvCloseService(RegAccess, ServiceHandle);

     return Success;
 }


/***************************************************************************
 *
 *  Function :
 *      DrvNumberOfDevices
 *
 *  Parameters :
 *      ServiceNodeKey       Handle to the device services node key
 *      NumberOfDevices      DWORD value to set to number of subkeys
 *
 *  Return code :
 *
 *      Standard error code (see winerror.h)
 *
 *  Description :
 *
        Find out how many device keys we have
 *
 ***************************************************************************/
 LONG
 DrvNumberOfDevices(
     PREG_ACCESS RegAccess,
     LPDWORD NumberOfDevices)
{
     HKEY ParmsKey;
     LONG ReturnCode;
     DWORD Junk;
     DWORD cchClassName;
     TCHAR ClassName[100];
     DWORD cbJunk = 0;
     FILETIME FileTime;

     *NumberOfDevices = 0;
     ParmsKey = DrvOpenRegKey(RegAccess->DriverName, NULL);

     if (ParmsKey == NULL) {
         return ERROR_FILE_NOT_FOUND;
     }

     cchClassName = 100;
     ReturnCode =  RegQueryInfoKey(
                       ParmsKey,
                       ClassName,
                       &cchClassName,
                       NULL,
                       NumberOfDevices,
                       &Junk,
                       &Junk,
                       &Junk,
                       &Junk,
                       &Junk,
                       &Junk,
                       &FileTime);

     RegCloseKey(ParmsKey);

     return ReturnCode;

}


/***************************************************************************
 *
 *  Function :
 *      DrvSetDeviceParameter
 *
 *  Parameters :
 *      ServiceNodeKey       Handle to the device services node key
 *      ValueName            Name of value to set
 *      Value                DWORD value to set
 *
 *  Return code :
 *
 *      Standard error code (see winerror.h)
 *
 *  Description :
 *
 *      Add the value to the device parameters section under the
 *      services node.
 *      This section is created if it does not already exist.
 *
 ***************************************************************************/

 LONG
 DrvSetDeviceIdParameter(
     PREG_ACCESS RegAccess,
     UINT   DeviceNumber,
     LPTSTR ValueName,
     DWORD Value)
 {
     HKEY ParmsKey;
     LONG ReturnCode;

     //
     //  ALWAYS create a key 0 - that way old drivers work
     //
     if (DeviceNumber == 0) {
         ParmsKey = DrvOpenRegKey(RegAccess->DriverName, TEXT("Device0"));
     } else {
         ParmsKey = DrvOpenDeviceKey(RegAccess->DriverName, DeviceNumber);
     }

     if (ParmsKey == NULL) {
         return ERROR_FILE_NOT_FOUND;
     }

     //
     // Write the value
     //


     ReturnCode = RegSetValueEx(ParmsKey,             // Registry handle
                                ValueName,            // Name of item
                                0,                    // Reserved 0
                                REG_DWORD,            // Data type
                                (LPBYTE)&Value,       // The value
                                sizeof(Value));       // Data length

     //
     // Free the handles we created
     //

     RegCloseKey(ParmsKey);

     return ReturnCode;
 }


/***************************************************************************
 *
 *  Function :
 *      DrvQueryDeviceIdParameter
 *
 *  Parameters :
 *      ServiceNodeKey       Handle to the device services node key
 *      ValueName            Name of value to query
 *      pValue               Returned value
 *
 *  Return code :
 *
 *      Standard error code (see winerror.h)
 *
 *  Description :
 *
 *      Add the value to the device parameters section under the
 *      services node.
 *      This section is created if it does not already exist.
 *
 ***************************************************************************/

 LONG
 DrvQueryDeviceIdParameter(
     PREG_ACCESS RegAccess,
     UINT  DeviceNumber,
     LPTSTR ValueName,
     PDWORD pValue)
 {
     HKEY ParmsKey;
     LONG ReturnCode;
     DWORD Index;
     DWORD Type;
     DWORD Value;
     DWORD ValueLength;

     ParmsKey = DrvOpenDeviceKey(RegAccess->DriverName, DeviceNumber);

     if (ParmsKey == NULL) {
         return ERROR_FILE_NOT_FOUND;
     }

     ValueLength = sizeof(Value);

     ReturnCode = RegQueryValueEx(ParmsKey,
                                  ValueName,
                                  NULL,
                                  &Type,
                                  (LPBYTE)&Value,
                                  &ValueLength);

     RegCloseKey(ParmsKey);

     if (ReturnCode == ERROR_SUCCESS) {

         if (Type == REG_DWORD) {
             *pValue = Value;
         } else {
             ReturnCode = ERROR_FILE_NOT_FOUND;
         }
     }

     return ReturnCode;
 }


/***************************************************************************
 *
 *  Function :
 *      DrvLoadKernelDriver
 *
 *  Parameters :
 *      Drivername         Name of driver to load
 *
 *  Return code :
 *
 *      TRUE if successful, otherwise FALSE
 *
 *  Description :
 *
 *      Call StartService to load the driver.  This assumes the services
 *      name is the driver name
 *
 ***************************************************************************/

 BOOL
 DrvLoadKernelDriver(
     PREG_ACCESS RegAccess)
 {
     SC_HANDLE ServiceHandle;
     BOOL Success;
     ServiceHandle = DrvOpenService(RegAccess);

     if (ServiceHandle == NULL) {
         return FALSE;
     }

    /*
     *  StartService causes the system to try to load the kernel driver
     */

     Success = StartService(ServiceHandle, 0, NULL);

    /*
     *  If this was successful we can change the start type to system
     *  start
     */

     if (Success) {
         Success = ChangeServiceConfig(ServiceHandle,
                                       SERVICE_NO_CHANGE,
                                       SERVICE_SYSTEM_START,
                                       SERVICE_NO_CHANGE,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL);
     }
     DrvCloseService(RegAccess, ServiceHandle);
     return Success;
 }

/***************************************************************************
 *
 *  Function :
 *      DrvUnLoadKernelDriver
 *
 *  Parameters :
 *      RegAccess          Access variables to registry and Service control
 *                         manager
 *
 *  Return code :
 *
 *      TRUE if successful, otherwise FALSE
 *
 *  Description :
 *
 *      Call ControlService to unload the driver.  This assumes the services
 *      name is the driver name
 *
 ***************************************************************************/

 BOOL
 DrvUnloadKernelDriver(
     PREG_ACCESS RegAccess)
 {
     SERVICE_STATUS ServiceStatus;
     SC_HANDLE ServiceHandle;
     BOOL Success;


     ServiceHandle = DrvOpenService(RegAccess);
     if (ServiceHandle == NULL) {
         return GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST;
     }

    /*
     *  Set it not to load at system start until we've reconfigured
     */

     Success = ChangeServiceConfig(ServiceHandle,
                                   SERVICE_NO_CHANGE,
                                   SERVICE_DEMAND_START,
                                   SERVICE_NO_CHANGE,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL);

     if (Success) {
        /*
         *  Don't try to unload if it's not loaded
         */

         if (DrvIsDriverLoaded(RegAccess)) {

            /*
             *  Note that the driver object name will not be found if
             *  the driver is not loaded.  However, the services manager may
             *  get in first and decide that the driver file does not exist.
             */

             Success = ControlService(ServiceHandle,
                                      SERVICE_CONTROL_STOP,
                                      &ServiceStatus);

         }

     }

     DrvCloseService(RegAccess, ServiceHandle);
     return Success;
 }

/***************************************************************************
 *
 *  Function :
 *
 *      DrvIsDriverLoaded
 *
 *  Parameters :
 *
 *      RegAccess          Access variables to registry and Service control
 *                         manager
 *
 *  Return code :
 *
 *      TRUE if successful, otherwise FALSE
 *
 *  Description :
 *
 *      See if a service by our name is started.
 *      Note - this assumes that we think our service is installed
 *
 ***************************************************************************/
 BOOL
 DrvIsDriverLoaded(
     PREG_ACCESS RegAccess)
 {
     SERVICE_STATUS ServiceStatus;
     SC_HANDLE ServiceHandle;
     BOOL Success;
     ServiceHandle = DrvOpenService(RegAccess);
     if (ServiceHandle == NULL) {
         return FALSE;
     }


     if (!QueryServiceStatus(ServiceHandle, &ServiceStatus)) {
         DrvCloseService(RegAccess, ServiceHandle);
         return FALSE;
     }

     Success = ServiceStatus.dwServiceType == SERVICE_KERNEL_DRIVER &&
               (ServiceStatus.dwCurrentState == SERVICE_RUNNING ||
                ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING);

     DrvCloseService(RegAccess, ServiceHandle);
     return Success;
 }


/***************************************************************************
 *
 *  Function :
 *
 *      DrvConfigureDriver
 *
 *  Parameters :
 *
 *      RegAccess          Access variables to registry and Service control
 *                         manager
 *
 *      DriverName         Name of the driver
 *
 *      DriverType         Type of driver (see registry.h)
 *
 *      SetParms           Callback to set the registry parameters
 *
 *      Context            Context value for callback
 *
 *  Return code :
 *
 *      TRUE if successful, otherwise FALSE
 *
 *  Description :
 *
 *      Performs the necessary operations to (re) configure a driver :
 *
 *      1.  If the driver is already installed :
 *
 *              Unload it if necessary
 *
 *              Set its start type to Demand until we know we're safe
 *              (This is so the system won't load a bad config if we crash)
 *
 *      2.  If the driver is not installed create its service entry in the
 *          registry.
 *
 *      3.  Run the callback to set up the driver's parameters
 *
 *      4.  Load the driver
 *
 *      5.  If the load returns success set the start type to System start
 *
 ***************************************************************************/

 BOOL DrvConfigureDriver(
          PREG_ACCESS RegAccess,
          LPTSTR      DriverName,
          SOUND_KERNEL_MODE_DRIVER_TYPE
                      DriverType,
          BOOL (*     SetParms    )(PVOID),
          PVOID       Context)
 {
     return

    /*
     *  If there isn't a services node create one - this is done first
     *  because this is how the driver name gets into the REG_ACCESS
     *  structure
     */

     DrvCreateServicesNode(
         DriverName,
         DriverType,
         RegAccess,
         TRUE)

     &&

    /*
     *  Unload driver if it's loaded
     */

     DrvUnloadKernelDriver(RegAccess)

     &&

    /*
     *  Run the callback
     */

     (SetParms == NULL || (*SetParms)(Context))

     &&

    /*
     *  Try reloading the driver
     */

     DrvLoadKernelDriver(RegAccess)

     ;

 }


/***************************************************************************
 *
 *  Function :
 *
 *      DrvRemoveDriver
 *
 *  Parameters :
 *
 *      RegAccess          Access variables to registry and Service control
 *                         manager
 *
 *  Return code :
 *
 *      DRVCNF_CANCEL  - Error occurred
 *
 *      DRVCNF_OK      - Registry entry delete but driver wasn't loaded
 *
 *      DRVCNF_RESTART - Driver unloaded and registry entry deleted
 *
 *  Description :
 *
 *      Unload the driver and remove its service control entry
 *
 ***************************************************************************/

 LRESULT DrvRemoveDriver(
             PREG_ACCESS RegAccess)
 {
     BOOL Loaded;

     Loaded = DrvIsDriverLoaded(RegAccess);

     if (Loaded) {
         DrvUnloadKernelDriver(RegAccess);
     }
     if (DrvDeleteServicesNode(RegAccess)) {
         return Loaded ? DRVCNF_RESTART : DRVCNF_OK;
     } else {
         return DRVCNF_CANCEL;
     }
 }

/***************************************************************************
 *
 *  Function :
 *
 *      DrvSetMapperName
 *
 *  Parameters :
 *
 *      Mapping Name       Name of mapping from midimap.cfg to use
 *
 *  Return code :
 *
 *      None - may or may not work
 *
 *  Description :
 *
 *      Tell the midi mapper which map to use
 *
 ***************************************************************************/

 VOID DrvSetMapperName(LPTSTR SetupName)
 {
     HKEY hKey;

     if (ERROR_SUCCESS ==
         RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Midimap"),
                      0L,
                      KEY_WRITE,
                      &hKey)) {

         RegSetValueEx( hKey,
                        TEXT("Mapping Name"),
                        0L,
                        REG_SZ,
                        (LPBYTE)SetupName,
                        sizeof(TCHAR) * (1 + lstrlen(SetupName)));

         RegCloseKey(hKey);
     }

     return;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\drvlib\reslist.c ===
/****************************************************************************
 *
 *   reslist.c
 *
 *   Copyright (c) 1994 Microsoft Corporation.  All Rights Reserved.
 *
 *   This file contains code for querying the registry so that drivers
 *   can grey invalid resource options prior to loading drivers
 *
 ****************************************************************************/
#include <windows.h>
#include "reslist.h"
#include <registry.h>
#include <stdio.h>


typedef BOOL ENUMKEYSCALLBACK(PVOID, HKEY, LPTSTR);
typedef BOOL ENUMKEYVALUESCALLBACK(PVOID, LPTSTR, DWORD, PVOID, DWORD);

/*
**
**
**
*/

BOOL EnumKeys(HKEY hKey,
              LPTSTR KeyName,
              ENUMKEYSCALLBACK *Callback,
              PVOID Context
)
{
    HKEY  SubKey;
    DWORD Index;
    TCHAR SubKeyName[MAX_PATH];

    if (ERROR_SUCCESS != RegOpenKey(hKey, KeyName, &SubKey)) {
        return FALSE;
    }

    for (Index = 0; ;Index++) {
        DWORD Rc;

        Rc = RegEnumKey(SubKey,
                        Index,
                        SubKeyName,
                        MAX_PATH);

        if (Rc == ERROR_SUCCESS) {
            if (!(*Callback)(Context, SubKey, SubKeyName)) {
                RegCloseKey(SubKey);
                return FALSE;
            }
        } else {

            RegCloseKey(SubKey);
            return Rc == ERROR_NO_MORE_ITEMS;
        }
    }
}
BOOL EnumKeyValues(HKEY hKey,
                   LPTSTR KeyName,
                   ENUMKEYVALUESCALLBACK *Callback,
                   PVOID Context
)
{
    HKEY  SubKey;
    DWORD Index;
    TCHAR ValueName[MAX_PATH];

    if (ERROR_SUCCESS != RegOpenKey(hKey, KeyName, &SubKey)) {
        return FALSE;
    }

    for (Index = 0; ;Index++) {
        DWORD Rc;
        DWORD Type;
        DWORD cchName;
        DWORD ccbData;

        cchName = MAX_PATH;

        Rc = RegEnumValue(SubKey,
                          Index,
                          ValueName,
                          &cchName,
                          NULL,
                          &Type,
                          NULL,
                          &ccbData);

        if (Rc == ERROR_SUCCESS) {
            PBYTE pData;
            pData = (PBYTE)LocalAlloc(LPTR, ccbData);
            if (pData == NULL) {
                RegCloseKey(SubKey);
                return FALSE;
            }
            Rc = RegQueryValueEx(SubKey,
                                 ValueName,
                                 NULL,
                                 &Type,
                                 pData,
                                 &ccbData);

            if (ERROR_SUCCESS != Rc ||
                !(*Callback)(Context, ValueName, Type, pData, ccbData)) {
                LocalFree((HLOCAL)pData);
                RegCloseKey(SubKey);
                return FALSE;
            }
            LocalFree((HLOCAL)pData);
        } else {

            RegCloseKey(SubKey);
            return Rc == ERROR_NO_MORE_ITEMS;
        }
    }
}

BOOL EnumerateDrivers(PVOID Context, HKEY hKey, LPTSTR SubKeyName)
{
    PRESOURCE_INFO ResInfo = (PRESOURCE_INFO)Context;
    if (ResInfo->IgnoreDriver != NULL &&
        lstrcmpi(SubKeyName, ResInfo->IgnoreDriver) == 0) {
        return TRUE;
    }
    ResInfo->DriverName = SubKeyName;
    return EnumKeyValues(hKey, SubKeyName, EnumerateDevices, Context);
}
BOOL EnumerateDriverTypes(PVOID Context, HKEY hKey, LPTSTR SubKeyName)
{
    PRESOURCE_INFO ResInfo = (PRESOURCE_INFO)Context;
    ResInfo->DriverType = SubKeyName;
    return EnumKeys(hKey, SubKeyName, EnumerateDrivers, Context);
}


BOOL EnumResources(ENUMRESOURCECALLBACK Callback, PVOID Context, LPCTSTR IgnoreDriver)
{
    HKEY          hKey;
    RESOURCE_INFO ResInfo;

    ResInfo.AppContext  = Context;
    ResInfo.AppCallback = Callback;
    ResInfo.IgnoreDriver = IgnoreDriver;

    /*
    **  Open the resources registry key then recursively enumerate
    **  all resource lists
    */

    return EnumKeys(HKEY_LOCAL_MACHINE,
                    TEXT("HARDWARE\\RESOURCEMAP"),
                    EnumerateDriverTypes,
                    (PVOID)&ResInfo);

}

/*
**  Build a simple routine to find what interrupts and DMA channels
**  are in use
*/

typedef struct {
    DD_BUS_TYPE MinBusType;
    DWORD Interrupts[DD_NumberOfBusTypes];
    DWORD DmaChannels[DD_NumberOfBusTypes];
} INTERRUPTS_AND_DMA, *PINTERRUPTS_AND_DMA;

BOOL GetInterruptsAndDMACallback(
    PVOID Context,
    DD_BUS_TYPE BusType,
    DD_RESOURCE_TYPE ResourceType,
    PDD_CONFIG_DATA ConfigData
)
{
    PINTERRUPTS_AND_DMA pData;

    pData = Context;

    if (pData->MinBusType > BusType) {
        pData->MinBusType = BusType;
    }

    switch (ResourceType) {
        case DD_Interrupt:
            pData->Interrupts[BusType] |= 1 << ConfigData->Interrupt;
            break;

        case DD_DmaChannel:
            pData->DmaChannels[BusType] |= 1 << ConfigData->DmaChannel;
            break;
            break;
    }

    return TRUE;
}


BOOL GetInterruptsAndDMA(
    LPDWORD InterruptsInUse,
    LPDWORD DmaChannelsInUse,
    LPCTSTR IgnoreDriver
)
{
    INTERRUPTS_AND_DMA Data;

    ZeroMemory((PVOID)&Data, sizeof(Data));
    Data.MinBusType = DD_NumberOfBusTypes;

    EnumResources(GetInterruptsAndDMACallback, &Data, IgnoreDriver);

    if (Data.MinBusType == DD_NumberOfBusTypes) {
        return FALSE;
    }

    *InterruptsInUse = Data.Interrupts[Data.MinBusType];
    *DmaChannelsInUse = Data.DmaChannels[Data.MinBusType];

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\drvlib\drvlib.c ===
/****************************************************************************
 *
 *   drvlib.c
 *
 *   Multimedia kernel driver support library (drvlib)
 *
 *   Copyright (c) 1993-1995 Microsoft Corporation
 *
 *   This module contains
 *
 *   -- the entry point and startup code
 *   -- debug support code
 *
 *   History
 *
 ***************************************************************************/

#include <drvlib.h>
#include <stdarg.h>
#include <stdlib.h>

CRITICAL_SECTION mmDrvCritSec;  // Serialize access to device lists

#if DBG
    char ModuleName[MAX_PATH];
#endif

#if DBG
/*
 * read profile item from registry
 */

//#include <profile.key>
#define KEYNAMEA    "Software\\Microsoft\\Multimedia\\"
#define KEYNAME     TEXT("Software\\Microsoft\\Multimedia\\")
#define KEYNAMEW    KEYNAME
#define ROOTKEY     HKEY_CURRENT_USER

UINT mmGetProfileIntA(LPCSTR appname, LPCSTR valuename, INT uDefault);

// Now map all instances of GetProfileIntA to mmGetProfileIntA
#define GetProfileIntA mmGetProfileIntA

static HKEY GetKeyA(LPCSTR appname, BOOL fCreate)
{
    HKEY key = 0;
    char achName[MAX_PATH];

    lstrcpyA(achName, KEYNAMEA);
    lstrcatA(achName, appname);

    if ((!fCreate && RegOpenKeyA(ROOTKEY, achName, &key) == ERROR_SUCCESS)
        || (fCreate && RegCreateKeyA(ROOTKEY, achName, &key) == ERROR_SUCCESS)) {
    }

    return(key);
}

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT
mmGetProfileIntA(LPCSTR appname, LPCSTR valuename, INT uDefault)
{
    DWORD dwType;
    INT value = uDefault;
    DWORD dwData;
    int cbData;

    HKEY key = GetKeyA(appname, FALSE);

    if (key) {

        cbData = sizeof(dwData);
        if (RegQueryValueExA(
            key,
            (LPSTR)valuename,
            NULL,
            &dwType,
            (PBYTE) &dwData,
            &cbData) == ERROR_SUCCESS) {
            if (dwType == REG_DWORD || dwType == REG_BINARY) {
                value = (INT)dwData;
            } else if (dwType == REG_SZ) {
		value = atoi((LPSTR) &dwData);
	    }
	}

        RegCloseKey(key);
    }

    return((UINT)value);
}

#endif // DBG

/**************************************************************************

    @doc EXTERNAL

    @api BOOL | DllInstanceInit | This procedure is called whenever a
        process attaches or detaches from the DLL.

    @parm PVOID | hModule | Handle of the DLL.

    @parm ULONG | Reason | What the reason for the call is.

    @parm PCONTEXT | pContext | Some random other information.

    @rdesc The return value is TRUE if the initialisation completed ok,
        FALSE if not.

**************************************************************************/

BOOL DrvLibInit(HINSTANCE hModule, ULONG Reason, PCONTEXT pContext)
{

    UNREFERENCED_PARAMETER(pContext);

    if (Reason == DLL_PROCESS_ATTACH) {

#if DBG
        /*
        **  Cache our dll name for debugging
        */

        {
            char ModuleFileName[MAX_PATH];

            if (GetModuleFileNameA((HMODULE)hModule, ModuleFileName, MAX_PATH) ==
                0) {
                mmdrvDebugLevel = 0;
            } else {
                char drive[MAX_PATH];
                char dir[MAX_PATH];
                char ext[MAX_PATH];

		// note: we could use the WIN32 API GetFileTitle
                _splitpath(ModuleFileName, drive, dir, ModuleName, ext);
                mmdrvDebugLevel = GetProfileIntA("DEBUG", ModuleName, 0);
                dprintf2  (("Starting, debug level=%d", mmdrvDebugLevel));
            }
        }
#endif
        hInstance = hModule;

        //
        // Create our process DLL heap
        //
        hHeap = GetProcessHeap();
        if (hHeap == NULL) {
            return FALSE;
        }

        DisableThreadLibraryCalls(hModule);
        InitializeCriticalSection(&mmDrvCritSec);

        //
        // Load our device list
        //

        if (sndFindDevices() != MMSYSERR_NOERROR) {
            DeleteCriticalSection(&mmDrvCritSec);
            return FALSE;
        }

    } else {
        if (Reason == DLL_PROCESS_DETACH) {
            dprintf2(("Ending"));

            TerminateMidi();
            TerminateWave();

            DeleteCriticalSection(&mmDrvCritSec);
        }
    }
    return TRUE;
}

#if DBG

int mmdrvDebugLevel = 0;

/***************************************************************************

    @doc INTERNAL

    @api void | mmdrvDbgOut | This function sends output to the current
        debug output device.

    @parm LPSTR | lpszFormat | Pointer to a printf style format string.
    @parm ??? | ... | Args.

    @rdesc There is no return value.

****************************************************************************/

void mmdrvDbgOut(LPSTR lpszFormat, ...)
{
    char buf[256];
    va_list va;

    OutputDebugStringA(ModuleName);
    OutputDebugStringA(": ");

    va_start(va, lpszFormat);
    vsprintf(buf, lpszFormat, va);
    va_end(va);

    OutputDebugStringA(buf);
    OutputDebugStringA("\n");
}

/***************************************************************************

    @doc INTERNAL

    @api void | dDbgAssert | This function prints an assertion message.

    @parm LPSTR | exp | Pointer to the expression string.
    @parm LPSTR | file | Pointer to the file name.
    @parm int | line | The line number.

    @rdesc There is no return value.

****************************************************************************/

void dDbgAssert(LPSTR exp, LPSTR file, int line)
{
    dprintf1(("Assertion failure:"));
    dprintf1(("  Exp: %s", exp));
    dprintf1(("  File: %s, line: %d", file, line));
    DebugBreak();
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\drvlib\config.c ===
/****************************************************************************
 *
 *   config.c
 *
 *   Multimedia kernel driver support component (drvlib)
 *
 *   Copyright (c) 1993-1994 Microsoft Corporation
 *
 *   Support configuration of multi-media drivers :
 *
 *      This code steps through the stages of configuration and calls back
 *      the real driver when there's something to do.  We also handle setting
 *      registry parameters and loading/unloading the kernel driver,
 *      retrieving new/changed parameters etc.
 *
 *   History
 *
 ***************************************************************************/

 /**************************************************************************

  Spec :

      State :

         Set of install card instances in the registry

         Set of state variables

  **************************************************************************/

BOOL DriverConfigCheckAccess(PDRIVER_CONFIGURATION Config)
{
    BOOL Result;
    REG_ACCESS RegAccess;

    //
    // Check to see if we can access the registry.
    // Note thta this may be a config immediately after install
    // so we may not have a service or node yet
    //
    DrvCreateServicesNode(STR_DRIVERNAME,
                          SoundDriverTypeNormal,
                          &RegAccess,
                          FALSE);             // Don't create
    Result = DrvAccess(&RegAccess);
    DrvCloseServiceManager(&RegAccess);

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\drvlib\mixerdd.c ===
/****************************************************************************
 *
 *   mixerdd.c
 *
 *   Multimedia kernel driver support component
 *
 *   Copyright (c) 1993-1996 Microsoft Corporation
 *
 *   Win32 Driver support for mixer devices including interface to kernel
 *   driver.
 *
 ***************************************************************************/

/****************************************************************************

     Design :

        The win32 mixer driver first initializes itself by reading the mixer
        information from the registry.

        The mixer configuration information is stored inside the mixer device's
        value under the (volatile) devices key for the specific mixer device.

        See drvutil.c for a detailed description of the registry structure.

        The format of the mixer configuration is defined in ntddmix.h :

            MIXER_DD_CONFIGURATION_DATA

        No variable data is (for obvious reasons) cached by this driver.  It's
        assumed the application does this.  The driver will request the
        information from the kernel driver when requested.

        A single overlapped ioctl is left incomplete on the mixer kernel device.
        This Ioctl is completed when changes occur.  The Ioctl uses overlapped IO.
        The overlap routine only runs when an alertable wait (such as in
        GetMessage) is executed at which point PostMessage is issued, the
        Ioctl requeued and the overlapped routine returns (at which point
        the Ioctl could be complete again and another overlapped routine run).

     Important note:

        The opening of devices is purely for obtaining notifications.
        Otherwise applications can call the APIs in a completely unstructured
        way by using the mixer API and device numbers instead of handles.

     Serialization

        The API layer serializes us on each device id.

     Control structures

        For an individual mixer there is a set of 'global' data and a
        handle list for notifications.  A critical section is needed to
        serialize the notify thread access to this list and opens and
        closes.

        The global data consists of

            An open handle to the kernel device

            A notification thread 'handle'

            The overlapped structure for callbacks

            The critical section


 ****************************************************************************/

#include <drvlib.h>
#include <ntddmix.h>
#include <tchar.h>

/*
**   Information about each 'handle'.  These are chained together
**   to support notification callbacks.  There's no actual need to
**   chain in ones which don't want notification.
*/

struct _MIXER_DRIVER_ALLOC;

typedef struct _MM_MIXER_NOTIFY {
    struct _MM_MIXER_NOTIFY    * Next;
    MIXEROPENDESC                ClientData;
    DWORD                        fdwOpen;
    struct _MIXER_DRIVER_ALLOC * pMixerData;
} MM_MIXER_NOTIFY, *PMM_MIXER_NOTIFY;

/*
**   MIXER_DRIVER_ALLOC is a stucture allocated and initialized when a
**   mixer driver is first used.  It is never freed.
**
**   It is used to cache all the mixer configuration information
*/


typedef struct _MIXER_DRIVER_ALLOC {
    HANDLE                    hDevice;           // Handle of kernel device
    DWORD                     BytesReturned;     // Keep DeviceIoControl
                                                 // happy.

    /*
    **  Notification stuff
    */

    HANDLE                    hThreadTerm;
    OVERLAPPED                Ovl;
    MIXER_DD_REQUEST_NOTIFY   NotificationData;
    HANDLE                    hMxdStartupEvent;

    /*
    **  Precanned write location
    */

    OVERLAPPED                WriteOvl;
    HANDLE                    TerminateEvent;    // Set for termination

    /*
    **  Custom controls
    */
    MMRESULT (CALLBACK *
                              fnCustom)(struct _MIXER_DRIVER_ALLOC *,
                                        LPMIXERCONTROLDETAILS,
                                        DWORD);


    /*
    **  Manage requestors of notifications
    */

    CRITICAL_SECTION          HandleListCritSec;
    PMM_MIXER_NOTIFY          NotificationList;         // 'Open' handles

    /*
    **  Configuration data
    */

    PMIXER_DD_LINE_CONFIGURATION_DATA
                              pLineConfigurationData;   // List of lines
    PMIXER_DD_CONTROL_CONFIGURATION_DATA
                              pControlConfigurationData;// List of controls
    PMIXER_DD_CONFIGURATION_DATA
                              pConfigurationData;       // MUST be at the end
} MIXER_DRIVER_ALLOC, *PMIXER_DRIVER_ALLOC;


/*
**  Local functions
*/

void MxdFreeMixerData(PMIXER_DRIVER_ALLOC pMixerData);


/*
**  MxdNotifyClients
**
**  Generate notifications when our asynchronous IOCTL completes
*/

void MxdNotifyClients(PMIXER_DRIVER_ALLOC pMixerData)
{
    PMM_MIXER_NOTIFY pNotify;

    EnterCriticalSection(&pMixerData->HandleListCritSec);

#if DBG

    /*
    **  Check the notification data
    */

    if (pMixerData->NotificationData.Message ==
                 MM_MIXM_CONTROL_CHANGE) {
        if (pMixerData->NotificationData.Id >
                pMixerData->pConfigurationData->NumberOfControls) {
             dprintf(("Mixer notify Control out of range - value %lu, no. controls %lu",
                     pMixerData->NotificationData.Id,
                     pMixerData->pConfigurationData->NumberOfControls));
             DebugBreak();
        }
    } else {
        if (pMixerData->NotificationData.Message ==
                     MM_MIXM_LINE_CHANGE) {
            if (pMixerData->NotificationData.Id >
                    pMixerData->pConfigurationData->NumberOfLines) {
                 dprintf(("Mixer notify Line out of range - value %lu, no. controls %lu",
                         pMixerData->NotificationData.Id,
                         pMixerData->pConfigurationData->NumberOfLines));
                 DebugBreak();
            }
        } else {
            dprintf(("Mixer notify message id invalid - value %lu",
                    pMixerData->NotificationData.Message));
            DebugBreak();
        }
    }
#endif // DBG

    /*
    **  Dispatch each requestor for notification
    */

    for (pNotify = pMixerData->NotificationList;
         pNotify != NULL;
         pNotify = pNotify->Next) {
        DriverCallback(pNotify->ClientData.dwCallback,
                       (DWORD)HIWORD(pNotify->fdwOpen & CALLBACK_TYPEMASK),
                       (HDRVR)pNotify->ClientData.hmx,
                       pMixerData->NotificationData.Message,
                       pNotify->ClientData.dwInstance,
                       pMixerData->NotificationData.Id,
                       0L);
    }

    LeaveCriticalSection(&pMixerData->HandleListCritSec);
}

/*
**   MxdNotifyThread
*/

DWORD MxdNotifyThread(PMIXER_DRIVER_ALLOC pMixerData)
{
    HANDLE Events[2];
    HANDLE hStartupEvent;
    Events[0] = pMixerData->Ovl.hEvent;
    Events[1] = pMixerData->TerminateEvent;


    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

    /*
    **  Loop dispatching our Ioctl
    */

    for (;;) {

        /*
        **  Call DeviceIoControl to start our callback chain
        **  Actually there's nothing much we can do if this fails
        **  - it may fail later as well.
        */

        while (!DeviceIoControl(pMixerData->hDevice,
                                IOCTL_MIX_REQUEST_NOTIFY,
                                (PVOID)&pMixerData->NotificationData,
                                sizeof(pMixerData->NotificationData),
                                (PVOID)&pMixerData->NotificationData,
                                sizeof(pMixerData->NotificationData),
                                &pMixerData->BytesReturned,
                                &pMixerData->Ovl) &&
               GetLastError() != ERROR_IO_PENDING) {
            dprintf1(("DeviceIoControl for mixer failed!"));
            Sleep(300);
        }

        if (pMixerData->hMxdStartupEvent != NULL)
        {
           if (FALSE == SetEvent (pMixerData->hMxdStartupEvent)) dprintf(("MxdNotifyThread: Could not set startup event"));
           if (FALSE == CloseHandle (pMixerData->hMxdStartupEvent)) dprintf(("MxdNotifyThread: Count not close startup event handle"));
           pMixerData->hMxdStartupEvent = NULL;
        }

        /*
        **  Wait for something to change or to be asked to terminate
        */

        if (WaitForMultipleObjects(
                2,
                Events,
                FALSE,
                INFINITE) == WAIT_OBJECT_0 + 1) {

            /*
            **  Termination event set
            */

            return 0;
        }

        /*
        **  Call drivercallback for all open handles
        */

        MxdNotifyClients(pMixerData);

        /*
        **  Don't do things in too much of a rush - this is
        **  sort of equivalent to a Yield() in Win16
        */

        Sleep(0);
    }
}

/*
**  Free our notification thread
*/

void MxdFreeMixerThread(PMIXER_DRIVER_ALLOC pMixerData)
{
    /*
    **  Close down our thread if it's started.
    */

    if (pMixerData->hThreadTerm) {

        /*
        **  Tell the thread to finish
        */

        SetEvent(pMixerData->TerminateEvent);
        WaitForSingleObject(pMixerData->hThreadTerm, INFINITE);
        CloseHandle(pMixerData->hThreadTerm);
        pMixerData->hThreadTerm = NULL;
    }

    /*
    **  Note that if the IOCTL is still outstanding then the IO subsystem
    **  still has a reference to this event object so it can be safely
    **  set when the IOCTL completes - even though we won't hear about it.
    */

    if (pMixerData->Ovl.hEvent != NULL) {
        CloseHandle(pMixerData->Ovl.hEvent);
        pMixerData->Ovl.hEvent = NULL;
    }

    if (pMixerData->TerminateEvent != NULL) {
        CloseHandle(pMixerData->TerminateEvent);
        pMixerData->TerminateEvent = NULL;
    }

    if (pMixerData->hMxdStartupEvent != NULL) {
        CloseHandle(pMixerData->hMxdStartupEvent);
        pMixerData->hMxdStartupEvent = NULL;
    }
}

/*
**   MxdFreeMixerData
*/

void MxdFreeMixerData(PMIXER_DRIVER_ALLOC pMixerData)
{

    MxdFreeMixerThread(pMixerData);

    if (pMixerData->hDevice != NULL &&
        pMixerData->hDevice != INVALID_HANDLE_VALUE) {
        CloseHandle(pMixerData->hDevice);
    }

    DeleteCriticalSection(&pMixerData->HandleListCritSec);

    if (pMixerData->pConfigurationData) {
        HeapFree(hHeap, 0, (LPVOID)pMixerData->pConfigurationData);
    }

    HeapFree(hHeap, 0, (LPVOID)pMixerData);

}

/*
**  Find number of control items for a control
*/

UINT NumberOfControlItems(PMIXER_DRIVER_ALLOC pMixerData, UINT ControlId)
{
    PMIXER_DD_CONTROL_CONFIGURATION_DATA pControlData;
    UINT cChannels, cMultipleItems;

    pControlData = &pMixerData->pControlConfigurationData[ControlId];

    if (pControlData->fdwControl & MIXERCONTROL_CONTROLF_MULTIPLE) {
        cMultipleItems = pControlData->cMultipleItems;
    } else {
        cMultipleItems = 1;
    }

    if (pControlData->fdwControl & MIXERCONTROL_CONTROLF_UNIFORM) {
        cChannels = 1;
    } else {
        cChannels = pMixerData->pLineConfigurationData[
                                       pControlData->LineID].cChannels;
    }

    return cChannels * cMultipleItems;
}

/*
**  Get the text data for a control with multiple elements
*/

PMIXER_DD_CONTROL_LISTTEXT
GetControlText(
    PMIXER_DRIVER_ALLOC pMixerData,
    UINT            ControlId,
    UINT            MemberId
)
{
    PMIXER_DD_CONTROL_CONFIGURATION_DATA pControlData;
    pControlData = &pMixerData->pControlConfigurationData[ControlId];

    if (pControlData->TextDataOffset == 0) {
        return NULL;
    }

    return (PMIXER_DD_CONTROL_LISTTEXT)((PBYTE)pMixerData->pConfigurationData +
                                        pControlData->TextDataOffset) +
                                        MemberId;
}


#if DBG

/*
**  Check the configuration data dumped in the registry by the kernel
**  driver
*/

void ValidateMixerConfigurationData(PMIXER_DRIVER_ALLOC pMixerData,
                                    DWORD ConfigurationDataSize)
{
    /*
    **  Validate the data
    */

    UINT i;
    DWORD ExpectedConfigurationDataSize;
    PMIXER_DD_CONTROL_CONFIGURATION_DATA pControlData;
    PMIXER_DD_LINE_CONFIGURATION_DATA pLineData;
    UINT cControls;
    UINT cSources;
    UINT cControlsInLine;
    UINT cLines;

    if (ConfigurationDataSize != pMixerData->pConfigurationData->cbSize) {
        dprintf(("Configuration data size wrong"));
    }

    ExpectedConfigurationDataSize =
              sizeof(MIXER_DD_CONFIGURATION_DATA) +
              pMixerData->pConfigurationData->NumberOfLines *
              sizeof(MIXER_DD_LINE_CONFIGURATION_DATA) +
              pMixerData->pConfigurationData->NumberOfControls *
              sizeof(MIXER_DD_CONTROL_CONFIGURATION_DATA);

    /*
    **  Check the controls data
    */

    for (i = 0, cLines = 0, cControlsInLine = 0,
         pControlData = pMixerData->pControlConfigurationData;

         i < pMixerData->pConfigurationData->NumberOfControls;

         i++, pControlData++) {

        PMIXER_DD_CONTROL_LISTTEXT pListText;
        ULONG ListTextOffset;

        if (ConfigurationDataSize < ExpectedConfigurationDataSize) {
            dprintf(("Configuration data size too small on control %u - was %u, expected at least %u",
                    i, ConfigurationDataSize, ExpectedConfigurationDataSize));
        }

        /*
        **  Check line id - should be the same as the previous or one
        **  greater - can't have a line with 0 controls!
        */

        if ((DWORD)pControlData->LineID >=
            pMixerData->pConfigurationData->NumberOfLines) {
            dprintf(("Invalid line ID - Number of lines %u, this line %u",
                     (UINT)pMixerData->pConfigurationData->NumberOfLines,
                     (UINT)pControlData->LineID));
        }

        if (cLines == (UINT)pControlData->LineID) {
            cControlsInLine++;
        }
        if (cLines != (UINT)pControlData->LineID ||
            i == pMixerData->pConfigurationData->NumberOfControls
            ) {

            if (cControlsInLine !=
                pMixerData->pLineConfigurationData[cLines].cControls) {
                dprintf(("Wrong number of controls for line %u, expected %u, got %u",
                         cLines,
                         (UINT)pMixerData->pLineConfigurationData[cLines].cControls,
                         cControlsInLine));
            }

            cLines++;
            cControlsInLine = 1;
        }

        pListText = GetControlText(pMixerData, i, 0);

        if (pListText != NULL) {
            ListTextOffset =
                (ULONG)((PBYTE)pListText - (PBYTE)pMixerData->pConfigurationData);
            if (ListTextOffset != ExpectedConfigurationDataSize) {
                 dprintf(("Control Text Data Offset wrong - expected %u, was %u",
                         ExpectedConfigurationDataSize, ListTextOffset));
            } else {
                 UINT j;

                 /*
                 **  Check embedded control ids in listtext data
                 */

                 for (j = 0; j < NumberOfControlItems(pMixerData, i); j++) {
                     if (GetControlText(pMixerData, i, j)->ControlId != i) {
                         dprintf(("Text data control id wrong - expected %u, was %u",
                                 i,
                                 GetControlText(pMixerData, i, j)->ControlId));
                     }
                 }

                 ExpectedConfigurationDataSize +=
                     sizeof(MIXER_DD_CONTROL_LISTTEXT) *
                     NumberOfControlItems(pMixerData, i);
            }
        }
    }

    /*
    **  Check the sources vs destinations and number of controls and
    **  Lines
    */

    if (pMixerData->pConfigurationData->DeviceCaps.cDestinations >
        pMixerData->pConfigurationData->NumberOfLines) {
         dprintf(("Too many destinations! - %u Destinations, %u Lines",
                 pMixerData->pConfigurationData->DeviceCaps.cDestinations,
                 pMixerData->pConfigurationData->NumberOfLines));
    }

    for (i = 0, cControls = 0, cSources = 0,
         pLineData = pMixerData->pLineConfigurationData;
         i < pMixerData->pConfigurationData->NumberOfLines;
         i++, pLineData++) {

#if 0
        /*
        **  The destinations come FIRST
        */

        if ((pLineData->fdwLine & MIXERLINE_LINEF_SOURCE) &&
            i < pMixerData->pConfigurationData->DeviceCaps.cDestinations ||
            !(pLineData->fdwLine & MIXERLINE_LINEF_SOURCE) &&
            i >= pMixerData->pConfigurationData->DeviceCaps.cDestinations) {

           dprintf(("Destination line too large! - %u Destinations, %u Lines Id",
                   pMixerData->pConfigurationData->DeviceCaps.cDestinations,
                   i));
        }
#endif

        cControls += pLineData->cControls;
    }

    /*
    **  Check number of controls
    */

    if (cControls != pMixerData->pConfigurationData->NumberOfControls) {
        dprintf(("Wrong number of controls! - expected %u, found %u",
                pMixerData->pConfigurationData->NumberOfControls,
                cControls));
    }


    /*
    **  End of registry data validation
    */

}

#endif // DBG

/*
**  MxdInitDevice
**
**  Allocate fixed stuff for a mixer device
*/

MMRESULT MxdInitDevice(
    UINT   DeviceId,
    PMIXER_DRIVER_ALLOC *ppMixerData
)
{

    DWORD ConfigurationDataSize;
    PMIXER_DRIVER_ALLOC pMixerData;
    MMRESULT mmRet;
    DWORD BytesReturned;

    /*
    **  Allocate space for the configuration data and read it
    */

    pMixerData =
        (PMIXER_DRIVER_ALLOC)HeapAlloc(hHeap, 0, sizeof(MIXER_DRIVER_ALLOC));

    if (pMixerData == NULL) {
        return MMSYSERR_NOMEM;
    }

    ZeroMemory((PVOID)pMixerData, sizeof(*pMixerData));

    InitializeCriticalSection(&pMixerData->HandleListCritSec);

    /*
    **  See if we can actually open the thing
    */

    mmRet = sndOpenDev(MIXER_DEVICE,
                       DeviceId,
                       &pMixerData->hDevice,
                       GENERIC_READ | GENERIC_WRITE);

    if (mmRet != MMSYSERR_NOERROR) {
        MxdFreeMixerData(pMixerData);
        return mmRet;
    }

    /*
    **  Load the configuration data from the registry
    */

    DeviceIoControl(pMixerData->hDevice,
                    IOCTL_MIX_GET_CONFIGURATION,
                    NULL,
                    0,
                    (PVOID)&ConfigurationDataSize,
                    sizeof(ConfigurationDataSize),
                    &BytesReturned,
                    NULL);

    if (BytesReturned != sizeof(ConfigurationDataSize)) {
        dprintf(("Mixer config not available"));
        MxdFreeMixerData(pMixerData);
        return (MMRESULT)sndTranslateStatus();
    }

    WinAssert(ConfigurationDataSize >= sizeof(MIXER_DD_CONFIGURATION_DATA));

    pMixerData->pConfigurationData = HeapAlloc(hHeap, 0, ConfigurationDataSize);

    if (pMixerData->pConfigurationData == NULL) {
        MxdFreeMixerData(pMixerData);
        return MMSYSERR_NOMEM;
    }


    if (!DeviceIoControl(pMixerData->hDevice,
                         IOCTL_MIX_GET_CONFIGURATION,
                         NULL,
                         0,
                         (PVOID)pMixerData->pConfigurationData,
                         ConfigurationDataSize,
                         &BytesReturned,
                         NULL) ||
        BytesReturned != ConfigurationDataSize) {
        dprintf(("Wrong size for mixer Config"));
        MxdFreeMixerData(pMixerData);
        return (MMRESULT)sndTranslateStatus();
    }

    pMixerData->pLineConfigurationData =
        (PMIXER_DD_LINE_CONFIGURATION_DATA)&pMixerData->pConfigurationData[1];
    pMixerData->pControlConfigurationData =
        (PMIXER_DD_CONTROL_CONFIGURATION_DATA)
            &pMixerData->pLineConfigurationData[
                pMixerData->pConfigurationData->NumberOfLines];

#if DBG

    /*
    **  Check the kernel driver dumped correct stuff in the registry
    */

    ValidateMixerConfigurationData(pMixerData,
                                   ConfigurationDataSize);

#endif // DBG


    *ppMixerData = pMixerData;

    return MMSYSERR_NOERROR;
}

/*
**  Create the notification thread
*/

BOOL MxdCreateThread(PMIXER_DRIVER_ALLOC pMixerData)
{
    MMRESULT mmRet;

    /*
    **  Create notification event (we wouldn't need any of this if we
    **  had overlapped routines for ioctls)
    */

    pMixerData->Ovl.hEvent =
        CreateEvent(NULL, TRUE, FALSE, NULL);    // Manual reset

    if (pMixerData->Ovl.hEvent == NULL) {
        MxdFreeMixerThread(pMixerData);
        return FALSE;
    }

    pMixerData->TerminateEvent =
        CreateEvent(NULL, FALSE, FALSE, NULL);

    if (pMixerData->TerminateEvent == NULL) {
        MxdFreeMixerThread(pMixerData);
        return FALSE;
    }

    pMixerData->hMxdStartupEvent = CreateEvent (NULL,       // no security attribs
                                                FALSE,      // auto-reset
                                                FALSE,      // non signaled
                                                NULL);
    if (pMixerData->hMxdStartupEvent == NULL) {
        MxdFreeMixerThread(pMixerData);
        return FALSE;
    }

    /*
    **  Create the thread
    */

    mmRet = mmTaskCreate((LPTASKCALLBACK)MxdNotifyThread,
                         &pMixerData->hThreadTerm,
                         (DWORD_PTR)pMixerData);

    if (mmRet != MMSYSERR_NOERROR) {
        MxdFreeMixerThread(pMixerData);
        return FALSE;
    }

    WaitForSingleObjectEx(pMixerData->hMxdStartupEvent, INFINITE, FALSE);

    return TRUE;
}

/*
**   MxdOpen
**
**   Allocates device data structure
*/

MMRESULT MxdOpen(
    PMIXER_DRIVER_ALLOC pMixerData,
    PDWORD_PTR        dwDrvUser,
    PMIXEROPENDESC    pmxod,
    DWORD             fdwOpen
)
{
    PMM_MIXER_NOTIFY pNotify;

    pNotify = (PMM_MIXER_NOTIFY)HeapAlloc(hHeap, 0, sizeof(MM_MIXER_NOTIFY));

    if (pNotify == NULL) {
        return MMSYSERR_NOMEM;
    }

    /*
    **  We're done - fill in the structure and return the data
    */

    pNotify->ClientData = *pmxod;  // Whom and how to notify
    pNotify->fdwOpen = fdwOpen;
    pNotify->pMixerData = pMixerData;

    /*
    **  Start getting notifications (even though nothing's changed?)
    */

    if ((fdwOpen & CALLBACK_TYPEMASK) != CALLBACK_NULL) {
        EnterCriticalSection(&mmDrvCritSec);
        if (pMixerData->NotificationList == NULL) {

            if (!MxdCreateThread(pMixerData)) {
                LeaveCriticalSection(&mmDrvCritSec);
                return MMSYSERR_NOMEM;
            }
        }

        /*
        **  Add to the list - ONLY if they want notification
        */

        EnterCriticalSection(&pMixerData->HandleListCritSec);

        pNotify->Next = pMixerData->NotificationList;
        pMixerData->NotificationList = pNotify;

        LeaveCriticalSection(&pMixerData->HandleListCritSec);
        LeaveCriticalSection(&mmDrvCritSec);

    }

    /*
    **  Return our handle to the user.  Note - they may start getting floods
    **  of notifications before they even return - but this won't confuse
    **  single-thread applications.
    */

    *dwDrvUser = (DWORD_PTR)pNotify;

    return MMSYSERR_NOERROR;

}

/*
**  Close a user handle
*/

MMRESULT MxdClose(PMM_MIXER_NOTIFY pNotify)
{

    PMM_MIXER_NOTIFY *pSearch;

    /*
    **  Remove it from the list
    */

    EnterCriticalSection(&mmDrvCritSec);
    EnterCriticalSection(&pNotify->pMixerData->HandleListCritSec);

    for (pSearch = &pNotify->pMixerData->NotificationList;
         *pSearch != NULL && *pSearch != pNotify;
         pSearch = &(*pSearch)->Next) {}

    if (*pSearch != NULL) {

        /*
        **  After this the notify loop in the notification thread
        **  will not find this notification in this list so won't
        **  make any more notifications for this device
        */

        *pSearch = (*pSearch)->Next;

        WinAssert ((pNotify->fdwOpen & CALLBACK_TYPEMASK) !=
            CALLBACK_NULL);

        LeaveCriticalSection(&pNotify->pMixerData->HandleListCritSec);

        /*
        **  See if all requestors for notification have gone away
        **
        **  If they have no more can be created because we're holding
        **  on to mmDrvCritSec which is held when when add stuff
        **  to the list and create the thread.
        **
        **  Thus it's safe to wait for the thread to finish in its
        **  own time.
        */

        if (pNotify->pMixerData->NotificationList == NULL) {
            MxdFreeMixerThread(pNotify->pMixerData);
        }
    } else {
        LeaveCriticalSection(&pNotify->pMixerData->HandleListCritSec);
    }

    LeaveCriticalSection(&mmDrvCritSec);

    HeapFree(hHeap, 0, (LPVOID)pNotify);

    return MMSYSERR_NOERROR;
}

/*
**  MxdCreateControlInfo
**
**  Expand the control info for the caller from our compacted form to
**  a MIXERCONTROL structure.
*/

DWORD
MxdCreateControlInfo(
    PMIXER_DRIVER_ALLOC pMixerData,
    DWORD               dwControlId,
    LPMIXERCONTROL      pmxctrl
)
{
    PMIXER_DD_CONTROL_CONFIGURATION_DATA pControlData;

    pControlData = &pMixerData->pControlConfigurationData[dwControlId];

    pmxctrl->cbStruct        = sizeof(MIXERCONTROL);
    pmxctrl->dwControlID     = dwControlId;
    pmxctrl->dwControlType   = pControlData->dwControlType;
    pmxctrl->cMultipleItems  = (DWORD)pControlData->cMultipleItems;
    pmxctrl->fdwControl      = pControlData->fdwControl;

    InternalLoadString(pControlData->ShortNameStringId,
                       pmxctrl->szShortName,
                       sizeof(pmxctrl->szShortName) / sizeof(TCHAR));

    InternalLoadString(pControlData->LongNameStringId,
                       pmxctrl->szName,
                       sizeof(pmxctrl->szName) / sizeof(TCHAR));

    CopyMemory(&pmxctrl->Bounds, &pControlData->Bounds,
               sizeof(*pmxctrl) - FIELD_OFFSET(MIXERCONTROL, Bounds));

#if 0
     /*
     **  Go and ask the kernel about the flags state
     */

     if (!DeviceIoControl(pMixerData->hDevice,
                          IOCTL_MIX_GET_CONTROL_FLAGS,
                          NULL,
                          0,
                          (PVOID)&pmxctrl->fdwControl,
                          sizeof(pmxl->fdwControl),
                          &pMixerData->BytesReturned,
                          NULL) {
         ugh!
     }
#endif

     return (DWORD)pControlData->LineID;
 }

/*
**  Expand the line info for the caller from our compacted form to
**  a MIXERLINE structure - getting the variable flags from the kernel
**  mode driver at the same time.
*/

MMRESULT MxdCreateLineInfo(
    PMIXER_DRIVER_ALLOC pMixerData,
    DWORD               dwLineId,
    LPMIXERLINE         pmxl
)
{
    PMIXER_DD_LINE_CONFIGURATION_DATA pConfigData;

    /*
    **  Find our compressed data for this line
    */

    pConfigData = &pMixerData->pLineConfigurationData[dwLineId];

    pmxl->cbStruct         = sizeof(MIXERLINE);
    pmxl->dwDestination    = (DWORD)pConfigData->Destination;
    pmxl->dwSource         = (DWORD)pConfigData->Source;
    pmxl->dwLineID         = dwLineId;

    /*
    **  Go and ask the kernel about the line state and user field
    */

    if (!DeviceIoControl(pMixerData->hDevice,
                         IOCTL_MIX_GET_LINE_DATA,
                         (PVOID)&dwLineId,
                         sizeof(dwLineId),
                         (PVOID)&pmxl->fdwLine,
                         sizeof(pmxl->fdwLine),
                         &pMixerData->BytesReturned,
                         NULL)) {
        return (MMRESULT)sndTranslateStatus();
    }

    pmxl->dwUser           = pConfigData->dwUser;

    pmxl->dwComponentType  = pConfigData->dwComponentType;
    pmxl->cChannels        = (DWORD)pConfigData->cChannels;
    pmxl->cConnections     = (DWORD)pConfigData->cConnections;
    pmxl->cControls        = (DWORD)pConfigData->cControls;

    InternalLoadString(pConfigData->ShortNameStringId,
                       pmxl->szShortName,
                       sizeof(pmxl->szShortName) / sizeof(TCHAR));

    InternalLoadString(pConfigData->LongNameStringId,
                       pmxl->szName,
                       sizeof(pmxl->szName) / sizeof(TCHAR));

    /*
    **  Target data
    */

    pmxl->Target.dwType         = (DWORD)pConfigData->Type;

    if (pmxl->Target.dwType != MIXERLINE_TARGETTYPE_UNDEFINED) {
        pmxl->Target.dwDeviceID     = 0;
        pmxl->Target.wPid           = pConfigData->wPid;
        pmxl->Target.wMid           = pMixerData->pConfigurationData->DeviceCaps.wMid;
        pmxl->Target.vDriverVersion = pMixerData->pConfigurationData->DeviceCaps.vDriverVersion;
    }

    InternalLoadString(pConfigData->PnameStringId,
                       pmxl->Target.szPname,
                       sizeof(pmxl->Target.szPname) / sizeof(TCHAR));

    return MMSYSERR_NOERROR;
}


/*************************************************************************

    Query and setting APIs

 *************************************************************************/

MMRESULT MxdGetDevCaps(
    PMIXER_DRIVER_ALLOC pMixerData,
    LPMIXERCAPS         pmxcaps,
    DWORD               cbmxcaps
)
{
    MIXERCAPS mxCaps;

    mxCaps.wMid           = pMixerData->pConfigurationData->DeviceCaps.wMid;
    mxCaps.wPid           = pMixerData->pConfigurationData->DeviceCaps.wPid;
    mxCaps.vDriverVersion = pMixerData->pConfigurationData->DeviceCaps.vDriverVersion;
    mxCaps.fdwSupport     = pMixerData->pConfigurationData->DeviceCaps.fdwSupport;
    mxCaps.cDestinations  = pMixerData->pConfigurationData->DeviceCaps.cDestinations;

    InternalLoadString(pMixerData->pConfigurationData->DeviceCaps.PnameStringId,
                       mxCaps.szPname,
                       sizeof(mxCaps.szPname) / sizeof(mxCaps.szPname[0]));

    CopyMemory((PVOID)pmxcaps,
               (PVOID)&mxCaps,
               min(cbmxcaps, sizeof(MIXERCAPS)));

    return MMSYSERR_NOERROR;
}


DWORD MxdGetLineInfo
(
    PMIXER_DRIVER_ALLOC pMixerData,
    LPMIXERLINE         pmxl,
    DWORD               fdwInfo
)
{

    /*
    **  determine what line to get the information for. a mixer driver
    **  MUST support the following four queries:
    **
    **      MIXER_GETLINEINFOF_DESTINATION
    **      MIXER_GETLINEINFOF_SOURCE
    **      MIXER_GETLINEINFOF_LINEID
    **      MIXER_GETLINEINFOF_COMPONENTTYPE
    **
    **
    **  others (no others are defined for V1.00 of MSMIXMGR) can optionally
    **  be supported. if this mixer driver does NOT support a query, then
    **  MMSYSERR_NOTSUPPORTED must be returned.
    */

    switch (fdwInfo & MIXER_GETLINEINFOF_QUERYMASK)
    {
        /*
        **  MIXER_GETLINEINFOF_DESTINATION
        **
        **  this query specifies that the caller is interested in the
        **  line information for MIXERLINE.dwDestination. this index can
        **  range from 0 to MIXERCAPS.cDestinations - 1.
        **
        **  valid elements of MIXERLINE:
        **      cbStruct
        **      dwDestination
        **
        **  all other MIXERLINE elements are undefined.
        */

        case MIXER_GETLINEINFOF_DESTINATION:

            /*
            **  Our lines our ordered so that the destination lines
            **  come first
            */

            if (pmxl->dwDestination >=
                   pMixerData->pConfigurationData->DeviceCaps.cDestinations)
            {
                dprintf1(("MxdGetLineInfo: caller specified an invalid destination."));
                return (MIXERR_INVALLINE);
            }

            return MxdCreateLineInfo(pMixerData, pmxl->dwDestination, pmxl);


        /*
        **  MIXER_GETLINEINFOF_SOURCE
        **
        **  this query specifies that the caller is interested in the
        **  line information for MIXERLINE.dwSource associated with
        **  MIXERLINE.dwDestination.
        **
        **  valid elements of MIXERLINE:
        **      cbStruct
        **      dwDestination
        **      dwSource
        **
        **  all other MIXERLINE elements are undefined.
        */

        case MIXER_GETLINEINFOF_SOURCE:
            dprintf3(("---MxdGetLineInfo: by source"));

            /*
            ** Search for the right destination and source by stepping
            ** through all the lines
            */
            {
                UINT i;
                PMIXER_DD_LINE_CONFIGURATION_DATA pLineData;

                for (i = pMixerData->pConfigurationData->DeviceCaps.cDestinations,
                     pLineData = pMixerData->pLineConfigurationData + i;
                     i < pMixerData->pConfigurationData->NumberOfLines;
                     i++, pLineData++) {

                    if (pmxl->dwDestination == (DWORD)pLineData->Destination &&
                        pmxl->dwSource == (DWORD)pLineData->Source) {

                        return MxdCreateLineInfo(pMixerData, i, pmxl);
                    }
                }
            }

            return MIXERR_INVALLINE;


        /*
        **  MIXER_GETLINEINFOF_LINEID
        **
        **  this query specifies that the caller is interested in the
        **  line information for MIXERLINE.dwLineID. the dwLineID is
        **  completely mixer driver dependent, so this driver must validate
        **  the ID.
        **
        **  valid elements of MIXERLINE:
        **      cbStruct
        **      dwLineID
        **
        **  all other MIXERLINE elements are undefined.
        */

        case MIXER_GETLINEINFOF_LINEID:
            dprintf3(("MxdGetLineInfo: by lineid"));

            if (pmxl->dwLineID >
                   pMixerData->pConfigurationData->NumberOfLines)
            {
                dprintf1(("MxdGetLineInfo: caller specified an invalid line id."));
                return MIXERR_INVALLINE;
            }

            return MxdCreateLineInfo(pMixerData, pmxl->dwLineID, pmxl);


        /*
        **  MIXER_GETLINEINFOF_COMPONENTTYPE
        **
        **  this query specifies that the caller is interested in the
        **  line information for MIXERLINE.dwComponentType
        **
        **  valid elements of MIXERLINE:
        **      cbStruct
        **      dwComponentType
        **
        **  all other MIXERLINE elements are undefined.
        */

        case MIXER_GETLINEINFOF_COMPONENTTYPE:
            dprintf3(("MxdGetLineInfo: by componenttype"));

            /*
            ** Walk all lines until we find the one with the right
            ** component type.
            **
            */
            {
                UINT i;
                PMIXER_DD_LINE_CONFIGURATION_DATA pLineData;

                for (i = 0, pLineData = pMixerData->pLineConfigurationData;
                     i < pMixerData->pConfigurationData->NumberOfLines;
                     i++, pLineData++) {

                    if (pmxl->dwComponentType ==
                        pLineData->dwComponentType) {

                        return MxdCreateLineInfo(pMixerData, i, pmxl);
                    }
                }
            }

            return MIXERR_INVALLINE;

        /*
        **  MIXER_GETLINEINFOF_TARGETTYPE
        **
        **  this query specifies that the caller is interested in the
        **  line information for MIXERLINE.Target.
        **
        **  valid elements of MIXERLINE:
        **      cbStruct
        **      Target.dwType
        **      Target.wMid
        **      Target.wPid
        **      Target.vDriverVersion
        **      Target.szPname
        **
        **  all other MIXERLINE elements are undefined.
        */

        case MIXER_GETLINEINFOF_TARGETTYPE:
        {
            /*
            **  Check Manufacturer id and driver version against
            **  the mixer driver caps
            */

            if (pMixerData->pConfigurationData->DeviceCaps.wMid != pmxl->Target.wMid)
                return (MIXERR_INVALLINE);

            if (pMixerData->pConfigurationData->DeviceCaps.vDriverVersion != pmxl->Target.vDriverVersion)
                return MIXERR_INVALLINE;

            /*
            **  Walk all lines until we find one with the right target
            **  device info.
            */
            {
                UINT i;
                PMIXER_DD_LINE_CONFIGURATION_DATA pLineData;

                for (i = 0, pLineData = pMixerData->pLineConfigurationData;
                     i < pMixerData->pConfigurationData->NumberOfLines;
                     i++, pLineData++) {
                    if (pmxl->Target.wPid == pLineData->wPid &&
                        pmxl->Target.dwType == (DWORD)pLineData->Type) {

                        MIXERLINE mxl;
                        MMRESULT mmRet;

                        /*
                        **  Get the data to expand the product name
                        */

                        mmRet = MxdCreateLineInfo(pMixerData, i, &mxl);

                        if (mmRet != MMSYSERR_NOERROR) {
                            return mmRet;
                        }

                        /*
                        **  Check product name
                        */

                        if (_tcsnicmp(mxl.Target.szPname, pmxl->Target.szPname,
                                      sizeof(mxl.Target.szPname)) == 0) {

                            *pmxl = mxl;
                            return  MMSYSERR_NOERROR;
                        }
                    }
                }
            }

            /*
            **  No line compared
            */

            return MIXERR_INVALLINE;
        }


        /*
        **  if the query type is not something this driver understands, then
        **  return MMSYSERR_NOTSUPPORTED.
        */

        default:
            return (MMSYSERR_NOTSUPPORTED);
    }
}

DWORD MxdGetLineControls(
    PMIXER_DRIVER_ALLOC pMixerData,
    LPMIXERLINECONTROLS pmxlc,
    DWORD               fdwControl
)
{
    LPMIXERCONTROL pmxctrl;
    PMIXER_DD_CONTROL_CONFIGURATION_DATA pControlData;
    UINT i;

    pmxctrl = pmxlc->pamxctrl;

    /*
    **  Determine for which control(s) to get the information.
    **  A mixer driver MUST support the following three queries:
    **
    **      MIXER_GETLINECONTROLSF_ALL
    **      MIXER_GETLINECONTROLSF_ONEBYID
    **      MIXER_GETLINECONTROLSF_ONEBYTYPE
    **
    **  Others (no others are defined for V1.00 of MSMIXMGR) can optionally
    **  be supported. If this mixer driver does NOT support a query, then
    **  MMSYSERR_NOTSUPPORTED must be returned.
    */

    switch (fdwControl & MIXER_GETLINECONTROLSF_QUERYMASK)
    {
        /*
        **  MIXER_GETLINECONTROLSF_ALL
        **
        **  This query specifies that the caller is interested in ALL
        **  controls for a line.
        **
        **  Valid elements of MIXERLINECONTROLS:
        **      cbStruct
        **      dwLineID
        **      cControls
        **      cbmxctrl
        **      pamxctrl
        **
        **  All other MIXERLINECONTROLS elements are undefined.
        */

        case MIXER_GETLINECONTROLSF_ALL:
            dprintf3(("MxdGetLineControls: all"));

            /*
            **  Check Line ID
            */

            if (pmxlc->dwLineID >=
                    pMixerData->pConfigurationData->NumberOfLines) {
                dprintf1(("MxdGetLineControls: caller specified an invalid dwLineID."));
                return MIXERR_INVALLINE;
            }

            /*
            **  Check the number of controls requested
            */

            if (pMixerData->pLineConfigurationData[pmxlc->dwLineID].cControls
                != pmxlc->cControls) {
                dprintf1(("MxdGetLineControls: caller specified an invalid dwLineID."));
                return MMSYSERR_INVALPARAM;
            }

            /*
            **  Find the control data for this control
            */

            for (i = 0, pControlData = pMixerData->pControlConfigurationData;
                 i < pMixerData->pConfigurationData->NumberOfControls;
                 i++, pControlData++) {

                if ((DWORD)pControlData->LineID == pmxlc->dwLineID) {

                    MxdCreateControlInfo(pMixerData, i, pmxctrl);

                    /*
                    **  This is going to be confusing!
                    */

                    pmxctrl = (LPMIXERCONTROL)((PBYTE)pmxctrl + pmxlc->cbmxctrl);
                }
            }

            /*
            **  Tell the what's valid
            */

            pmxlc->cbmxctrl = sizeof(MIXERCONTROL);

            return MMSYSERR_NOERROR;


        /*
        **  MIXER_GETLINECONTROLSF_ONEBYID
        **
        **  This query specifies that the caller is interested in ONE
        **  control specified by dwControlID.
        **
        **  valid elements of MIXERLINECONTROLS:
        **      cbStruct
        **      dwControlID
        **      cbmxctrl
        **      pamxctrl
        **
        **  all other MIXERLINECONTROLS elements are undefined.
        */

        case MIXER_GETLINECONTROLSF_ONEBYID:
            dprintf3(("MxdGetLineControls: by id"));

            /*
            ** Make sure the control ID they gave us is OK.
            */

            if (pmxlc->dwControlID >=
                    pMixerData->pConfigurationData->NumberOfControls) {
                return MIXERR_INVALCONTROL;
            }

            {
                MIXERCONTROL mxctrl;
                DWORD        dwLineID;

                dwLineID = MxdCreateControlInfo(pMixerData,
                                                pmxlc->dwControlID,
                                                &mxctrl);

                if (mxctrl.fdwControl & MIXERCONTROL_CONTROLF_DISABLED) {
                    return MIXERR_INVALCONTROL;
                }

                pmxlc->cbmxctrl = sizeof(MIXERCONTROL);

                /*
                ** Set the line ID (what a hack!!)
                */

                pmxlc->dwLineID = dwLineID;
                CopyMemory(pmxctrl, &mxctrl, sizeof(MIXERCONTROL));
            }
            return MMSYSERR_NOERROR;

        /*
        **  MIXER_GETLINECONTROLSF_ONEBYTYPE
        **
        **  This query specifies that the caller is interested in the
        **  FIRST control of type dwControlType on dwLineID.
        **
        **  Valid elements of MIXERLINECONTROLS:
        **      cbStruct
        **      dwLineID
        **      dwControlType
        **      cbmxctrl
        **      pamxctrl
        **
        **  all other MIXERLINECONTROLS elements are undefined.
        */

        case MIXER_GETLINECONTROLSF_ONEBYTYPE:
            dprintf3(("MxdGetLineControls: by type"));

            if (pmxlc->dwLineID > pMixerData->pConfigurationData->NumberOfControls)
            {
                dprintf1(("MxdGetLineControls: caller specified an invalid dwLineID."));
                return MIXERR_INVALLINE;
            }

            /*
            **  Find the control data for this control
            */

            for (i = 0, pControlData = pMixerData->pControlConfigurationData;
                 i < pMixerData->pConfigurationData->NumberOfControls;
                 i++, pControlData++) {

                if ((DWORD)pControlData->LineID == pmxlc->dwLineID &&
                    (DWORD)pControlData->dwControlType == pmxlc->dwControlType) {
                    MxdCreateControlInfo(pMixerData, i, pmxctrl);

                    /*
                    **  Tell them what's valid
                    */

                    pmxlc->cbmxctrl = sizeof(MIXERCONTROL);

                    return MMSYSERR_NOERROR;
                }
            }

            return MIXERR_INVALCONTROL;


        /*
        **  If the query type is not something this driver understands,
        **  then return MMSYSERR_NOTSUPPORTED.
        */
        default:
            return MMSYSERR_NOTSUPPORTED;
    }
}

/*
**  Check MIXERCONTROLDETAILS info
**
**  Returns number of items if OK or (UINT)-1 otherwise
*/

UINT MxdValidateMixerControlData(
    PMIXER_DRIVER_ALLOC     pMixerData,
    LPMIXERCONTROLDETAILS   pmxcd
)
{
    UINT NumberOfItems;
    PMIXER_DD_CONTROL_CONFIGURATION_DATA pControlData;

    pControlData = &pMixerData->pControlConfigurationData[pmxcd->dwControlID];

    /*
    **  Work out how many items are being requested and validate
    **  the number requested.
    */

    if (pmxcd->cChannels != 1 &&
        pmxcd->cChannels !=
            pMixerData->pLineConfigurationData[
                             pControlData->LineID].cChannels) {
        return (UINT)-1;
    }
    NumberOfItems = pmxcd->cChannels;

    if (pmxcd->cMultipleItems != pControlData->cMultipleItems) {
        return (UINT)-1;
    }

    if (pControlData->fdwControl & MIXERCONTROL_CONTROLF_MULTIPLE) {
        NumberOfItems *= pmxcd->cMultipleItems;
    }

    //
    //  Having made the following rule the APPs don't keep it !!!
    //
#if 0
    else {
        if (pmxcd->cMultipleItems != 0) {
            return (UINT)-1;
        }
    }
#endif

    return NumberOfItems;
}

MMRESULT MxdGetControlDetails
(
    PMIXER_DRIVER_ALLOC     pMixerData,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
)
{
    UINT NumberOfItems;

    if (pmxcd->dwControlID >= pMixerData->pConfigurationData->NumberOfControls)
    {
        return MIXERR_INVALCONTROL;
    }

    NumberOfItems = MxdValidateMixerControlData(pMixerData, pmxcd);

    if (NumberOfItems == (UINT)-1) {
        return MIXERR_INVALVALUE;
    }

    /*
    **  Check for LISTTEXT
    */

    switch (MIXER_GETCONTROLDETAILSF_QUERYMASK & fdwDetails) {
        case MIXER_GETCONTROLDETAILSF_VALUE:
        {
            if (!DeviceIoControl(pMixerData->hDevice,
                                 IOCTL_MIX_GET_CONTROL_DATA,
                                 &pmxcd->dwControlID,
                                 sizeof(MIXER_DD_READ_DATA),
                                 (PVOID)pmxcd->paDetails,
                                 pmxcd->cbDetails * NumberOfItems,
                                 &pMixerData->BytesReturned,
                                 NULL)) {

                return sndTranslateStatus();
            }
            return MMSYSERR_NOERROR;
        }

        case MIXER_GETCONTROLDETAILSF_LISTTEXT:
        {

            PMIXER_DD_CONTROL_CONFIGURATION_DATA pControlData;

            /*
            **  Validate the control id and channel
            */

            pControlData = &pMixerData->pControlConfigurationData[pmxcd->dwControlID];

            {
                UINT i;
                LPMIXERCONTROLDETAILS_LISTTEXT pmxListText;

                for (i = 0,
                     pmxListText = (LPMIXERCONTROLDETAILS_LISTTEXT)
                                       pmxcd->paDetails;

                     i < NumberOfItems;

                     i++,
                     pmxListText = (LPMIXERCONTROLDETAILS_LISTTEXT)
                                   ((PBYTE)pmxListText + pmxcd->cbDetails))
                {
                    PMIXER_DD_CONTROL_LISTTEXT pListText;
                    pListText =
                        GetControlText(pMixerData, pmxcd->dwControlID, i);

                    if (pListText == NULL) {
                        return MMSYSERR_INVALPARAM;
                    }

                    pmxListText->dwParam1 = pListText->dwParam1;
                    pmxListText->dwParam2 = pListText->dwParam2;

                    InternalLoadString(pListText->SubControlTextStringId,
                                       pmxListText->szName,
                                       sizeof(pmxListText->szName) / sizeof(TCHAR));
                }
            }

            return MMSYSERR_NOERROR;
        }

        default:
            return MMSYSERR_NOTSUPPORTED;
    }
}

MMRESULT
MxdSetControlDetails
(
    PMIXER_DRIVER_ALLOC   pMixerData,
    LPMIXERCONTROLDETAILS pmxcd,
    DWORD                 fdwDetails
)
{
    UINT NumberOfItems;

    if (pmxcd->dwControlID >= pMixerData->pConfigurationData->NumberOfControls)
    {
        return MIXERR_INVALCONTROL;
    }

    NumberOfItems = MxdValidateMixerControlData(pMixerData, pmxcd);

    if (NumberOfItems == (UINT)-1) {
        return MIXERR_INVALVALUE;
    }

    /*
    **  Check for custom controls
    */

    switch (MIXER_SETCONTROLDETAILSF_QUERYMASK & fdwDetails) {

        /*
        **  Non-custom - just call the kernel driver to set the
        **  details.
        */

        case MIXER_SETCONTROLDETAILSF_VALUE:
        {
            /*
            **  Sneaky hack to pass the control id in.
            **  DeviceIoControl wouldn't work because all the 'input'
            **  has to be in a single structure so we'd need to
            **  concatenate our data which would be a real pain.
            */

            pMixerData->WriteOvl.Offset = pmxcd->dwControlID;

            if (!WriteFile(pMixerData->hDevice,
                           (PVOID)pmxcd->paDetails,
                           pmxcd->cbDetails * NumberOfItems,
                           &pMixerData->BytesReturned,
                           &pMixerData->WriteOvl)) {

                return (MMRESULT)sndTranslateStatus();
            }

            /*
            **  Check data length returned
            */

            // ???

            return MMSYSERR_NOERROR;
        }

        case MIXER_SETCONTROLDETAILSF_CUSTOM:
        {

            /*
            **  Call the custom dialog and then set the data into the
            **  control
            */

            if (pMixerData->fnCustom) {
                MMRESULT mmr;

                mmr = (*pMixerData->fnCustom)(pMixerData,
                                              pmxcd,
                                              fdwDetails);

                if (mmr != MMSYSERR_NOERROR) {
                    return mmr;
                }
            }

            return
                MxdSetControlDetails(
                    pMixerData,
                    pmxcd,
                    fdwDetails ^
                        (MIXER_SETCONTROLDETAILSF_CUSTOM ^
                         MIXER_SETCONTROLDETAILSF_VALUE));
        }

        default:
            return MMSYSERR_NOTSUPPORTED;
    }
}

/****************************************************************************
**
**  DWORD mxdMessage
**
**  Description:
**
**
**  Arguments:
**      UINT uDevId:
**
**      UINT uMsg:
**
**      DWORD dwUser:
**
**      DWORD dwParam1:
**
**      DWORD dwParam2:
**
**  Return (DWORD):
**
**
*****************************************************************************/

DWORD APIENTRY mxdMessage
(
    UINT            uDevId,
    UINT            uMsg,
    DWORD_PTR       dwUser,
    DWORD_PTR       dwParam1,
    DWORD_PTR       dwParam2
)
{
    PMIXER_DRIVER_ALLOC pmxdi;
    DWORD               dw;

    /*
    **  See if this device is initialized
    */

    if (uMsg != MXDM_INIT &&
        uMsg != MXDM_GETNUMDEVS) {

        if (!sndFindDeviceInstanceData(MIXER_DEVICE,
                                         uDevId,
                                         (PVOID *)&pmxdi)) {
            return MMSYSERR_BADDEVICEID;
        }

        if (pmxdi == NULL) {

            if (MxdInitDevice(uDevId, &pmxdi) !=
                MMSYSERR_NOERROR) {
                return MMSYSERR_BADDEVICEID;
            }

            /*
            **  Set the instance data so we find it next time.
            */

            sndSetDeviceInstanceData(MIXER_DEVICE, uDevId, (PVOID)pmxdi);
        }
    }

    switch (uMsg)
    {
        case MXDM_INIT:
            return (0L);

        case MXDM_GETNUMDEVS:
            return sndGetNumDevs(MIXER_DEVICE);

        case MXDM_GETDEVCAPS:
            dw = MxdGetDevCaps(pmxdi, (LPMIXERCAPS)dwParam1, (DWORD)dwParam2);
            return (dw);

        case MXDM_OPEN:
            dw = MxdOpen(pmxdi, (PDWORD_PTR)dwUser, (LPMIXEROPENDESC)dwParam1, (DWORD)dwParam2);
            return (dw);

        case MXDM_CLOSE:
            dw = MxdClose((PMM_MIXER_NOTIFY)dwUser);
            return (dw);

        case MXDM_GETLINEINFO:
            dw = MxdGetLineInfo(pmxdi, (LPMIXERLINE)dwParam1, (DWORD)dwParam2);
            return (dw);

        case MXDM_GETLINECONTROLS:
            dw = MxdGetLineControls(pmxdi, (LPMIXERLINECONTROLS)dwParam1, (DWORD)dwParam2);
            return (dw);

        case MXDM_GETCONTROLDETAILS:
            dw = MxdGetControlDetails(pmxdi, (LPMIXERCONTROLDETAILS)dwParam1, (DWORD)dwParam2);
            return (dw);

        case MXDM_SETCONTROLDETAILS:
            dw = MxdSetControlDetails(pmxdi, (LPMIXERCONTROLDETAILS)dwParam1, (DWORD)dwParam2);
            return (dw);
    }

    return (MMSYSERR_NOTSUPPORTED);

} // mxdMessage()


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\drvlib\reslist.h ===
/****************************************************************************
 *
 *   reslist.h
 *
 *   Copyright (c) 1994 Microsoft Corporation.  All Rights Reserved.
 *
 *   This file contains definitions for querying the registry so that drivers
 *   can grey invalid resource options prior to loading drivers.
 *
 ****************************************************************************/

typedef enum {
    DD_IsaBus = 0,
    DD_EisaBus,
    DD_MCABus,
    DD_NumberOfBusTypes
} DD_BUS_TYPE;

typedef enum {
    DD_Port,
    DD_Interrupt,
    DD_DmaChannel,
    DD_Memory
} DD_RESOURCE_TYPE;


typedef union {
    DWORD  Interrupt;
    DWORD  DmaChannel;
    struct {
        DWORD Port;
        DWORD Length;
    } PortData;
    struct {
        DWORD Address;
        DWORD Length;
    } MemoryData;
} DD_CONFIG_DATA, *PDD_CONFIG_DATA;

typedef BOOL ENUMRESOURCECALLBACK(PVOID            Context,
                                  DD_BUS_TYPE      BusType,
                                  DD_RESOURCE_TYPE ResourceType,
                                  PDD_CONFIG_DATA  ResourceData
                                 );

typedef struct {
    PVOID                        AppContext;
    ENUMRESOURCECALLBACK         *AppCallback;
    LPCTSTR                      DriverType;
    LPCTSTR                      DriverName;
    LPCTSTR                      IgnoreDriver;
} RESOURCE_INFO, *PRESOURCE_INFO;

BOOL EnumerateDevices(
    PVOID Context,
    LPTSTR ValueName,
    DWORD Type,
    PVOID Value,
    DWORD cbValue);

BOOL EnumResources(
    ENUMRESOURCECALLBACK Callback,
    PVOID Context,
    LPCTSTR IgnoreDriver);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\drvlib\inc\config.h ===
/****************************************************************************
 *
 *   config.h
 *
 *   Multimedia kernel driver support component (drvlib)
 *
 *   Copyright (c) 1993-1994 Microsoft Corporation
 *
 *   Support configuration of multi-media drivers :
 *
 *   History
 *
 ***************************************************************************/


 typedef struct {
     PCTSTR   ParameterName;
     DWORD    DefaultValue;     // Used if not found in the registry
     DWORD    InitialValue;     // At start of configuration action
     DWORD    CurrentTry;       // Latest user try
     DWORD    DriverReturn;     // Value after driver loaded
 }
 DRIVER_CONFIG_PARM, *PDRIVER_CONFIG_PARM;

 typedef struct {
     UINT                  NumerOfParameters;
     PDRIVER_CONFIG_PARM   Parameters;
 } DRIVER_CONFIG_STATE, *PDRIVER_CONFIG_STATE;

 typedef struct {
     UINT     DlgId;
     DLGPROC  Dialog;
 } CONFIGURE_DIALOG;

 /*
 **  To set this stuff up the device-specific driver must support
 **  DriverConfigInit (DRIVER_CONFIG_INIT)
 */

 typedef struct {
     PTSTR                    DriverName;  // This gives us the registry location
     PTSTR                    DriverClass; // For class for starting driver

     /*
     **  Dialogs converse with user to update the state
     */

     BOOL                     bInstall;        // For configure dialog
     BOOL                     InitiallyLoaded; // Was it initially loaded?

     DRIVER_CONFIG_PARAM      Parms;
 } DRIVER_CONFIGURATION, *PDRIVER_CONFIGURATION;

 typedef VOID DRIVER_CONFIG_INIT (PDRIVER_CONFIGURATION);

 LONG DriverConfigConfigureDriver(PDRIVER_CONFIGURATION);
 LONG DriverConfigInstallDriver(PDRIVER_CONFIGURATION);
 BOOL DriverConfigCheckAccess(PDRIVER_CONFIGURATION);

 /*
 **  Internal utility routines
 */

 BOOL DriverConfigReadInitialValues(PDRIVER_CONFIGURATION);
 BOOL DriverConfigReadCurrentValues(PDRIVER_CONFIGURATION);
 BOOL DriverConfigSetCurrentValues(PDRIVER_CONFIGURATION);
 BOOL DriverConfigRevertValues(PDRIVER_CONFIGURATION);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\drvlib\inc\drvlib.h ===
/****************************************************************************
 *
 *   drvlib.h
 *
 *   Multimedia kernel driver support component (mmdrv)
 *
 *   Copyright (c) 1991-1994 Microsoft Corporation
 *
 *   Local declarations :
 *
 *   -- Debug
 *   -- Device types
 *   -- Routine prototypes
 *
 *   History
 *      06-Oct-1993 - Robin Speed (RobinSp) wrote it
 *
 ***************************************************************************/

/****************************************************************************

 General includes

 ***************************************************************************/

#ifndef RC_INVOKED

#include <string.h>
#include <stdio.h>

#endif /* RC_INVOKED */

#include <windows.h>
#include <mmsystem.h>
#include <devioctl.h>

#include <mmddk.h>

#include <soundcfg.h>

#if DBG
    #define STATIC
#else
    #define STATIC
#endif

HINSTANCE hInstance;

/***************************************************************************

    DEBUGGING SUPPORT

 ***************************************************************************/


#if DBG

    #define DEBUG_RETAIL

    extern int mmdrvDebugLevel;
    extern void mmdrvDbgOut(LPSTR lpszFormat, ...);
    extern void dDbgAssert(LPSTR exp, LPSTR file, int line);

    DWORD __dwEval;

    #define dprintf( _x_ )                            mmdrvDbgOut _x_
    #define dprintf1( _x_ ) if (mmdrvDebugLevel >= 1) mmdrvDbgOut _x_
    #define dprintf2( _x_ ) if (mmdrvDebugLevel >= 2) mmdrvDbgOut _x_
    #define dprintf3( _x_ ) if (mmdrvDebugLevel >= 3) mmdrvDbgOut _x_
    #define dprintf4( _x_ ) if (mmdrvDebugLevel >= 4) mmdrvDbgOut _x_

    #define WinAssert(exp) \
        ((exp) ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__))
    #define WinEval(exp) \
        ((__dwEval=(DWORD)(exp)) ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__), __dwEval)

#else

	#define WinAssert(x) 0
	#define WinEval(exp) exp

    #define dprintf(x)
    #define dprintf1(x)
    #define dprintf2(x)
    #define dprintf3(x)
    #define dprintf4(x)

#endif

#define D1 dprintf1
#define D2 dprintf2
#define D3 dprintf3


/****************************************************************************

  Our heap

****************************************************************************/

 HANDLE hHeap;

/****************************************************************************

  Our serialization

****************************************************************************/

 CRITICAL_SECTION mmDrvCritSec;  // Serialize access to device lists

/****************************************************************************

 Local routines

 ***************************************************************************/

BOOL DrvLibInit(HINSTANCE hModule, ULONG Reason, PCONTEXT pContext);

DWORD    sndTranslateStatus(void);
MMRESULT sndOpenDev(UINT DeviceType, DWORD dwId,
                    PHANDLE phDev, DWORD Access);
DWORD    sndGetNumDevs(UINT DeviceType);
MMRESULT sndSetData(UINT DeviceType, UINT DeviceId, UINT Length, PBYTE Data,
                    ULONG Ioctl);
MMRESULT sndGetData(UINT DeviceType, UINT DeviceId, UINT Length, PBYTE Data,
                    ULONG Ioctl);

MMRESULT sndGetHandleData(HANDLE     hDev,
                          DWORD      dwSize,
                          PVOID      pData,
                          ULONG      Ioctl,
                          HANDLE     hEvent);

MMRESULT sndSetHandleData(HANDLE     hDev,
                          DWORD      dwSize,
                          PVOID      pData,
                          ULONG      Ioctl,
                          HANDLE     hEvent);

BOOL sndFindDeviceInstanceData(DWORD DeviceType,
                               DWORD dwId,
                               PVOID *InstanceData);

BOOL sndSetDeviceInstanceData(DWORD DeviceType,
                              DWORD dwId,
                              PVOID InstanceData);

PVOID sndLoadDeviceData(DWORD DeviceType,
                        DWORD dwId,
                        LPDWORD pSize);

MMRESULT sndFindDevices(VOID);

VOID     TerminateWave(VOID);
VOID     TerminateMidi(VOID);

DWORD midiGetDevCaps(DWORD id, UINT DeviceType, LPBYTE lpCaps, DWORD dwSize);
void InternalLoadString(UINT StringId, LPTSTR pszString, UINT Length);

/****************************************************************************

  Our local driver procs

****************************************************************************/

DWORD APIENTRY widMessage(DWORD, DWORD, DWORD_PTR, DWORD_PTR, DWORD_PTR);
DWORD APIENTRY wodMessage(DWORD, DWORD, DWORD_PTR, DWORD_PTR, DWORD_PTR);
DWORD APIENTRY midMessage(DWORD, DWORD, DWORD_PTR, DWORD_PTR, DWORD_PTR);
DWORD APIENTRY modMessage(DWORD, DWORD, DWORD_PTR, DWORD_PTR, DWORD_PTR);
DWORD APIENTRY mxdMessage(UINT, UINT, DWORD_PTR, DWORD_PTR, DWORD_PTR);
DWORD APIENTRY auxMessage(UINT, UINT, DWORD_PTR, DWORD_PTR, DWORD_PTR);

/****************************************************************************

  Private messages supported by the library

****************************************************************************/

#define WIDM_LOWPRIORITY  0x4093


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\drvlib\inc\registry.h ===
/****************************************************************************
 *
 *   registry.h
 *
 *   Copyright (c) 1992-1994 Microsoft Corporation
 *
 *   This file contains public definitions for maintaining registry information
 *   for drivers managing kernel driver registry related data.
 ****************************************************************************/


/****************************************************************************

 Our registry access data

 ****************************************************************************/

 typedef struct {
     SC_HANDLE ServiceManagerHandle;  // Handle to the service controller
     LPTSTR DriverName;               // Name of driver
     TCHAR  TempKeySaveFileName[MAX_PATH];  // Where parameters key is saved
 } REG_ACCESS, *PREG_ACCESS;

/****************************************************************************

 Test if configuration etc can be supported

 ****************************************************************************/

 #define DrvAccess(RegAccess) ((RegAccess)->ServiceManagerHandle != NULL)


/****************************************************************************

 Driver types

 ****************************************************************************/

 typedef enum {
     SoundDriverTypeNormal = 1,
     SoundDriverTypeSynth           /* Go in the synth group */
 } SOUND_KERNEL_MODE_DRIVER_TYPE;

/****************************************************************************

 Function prototypes

 ****************************************************************************/

/*
 *      Create a new key
 */
 HKEY DrvCreateDeviceKey(LPCTSTR DriverName);

/*
 *      Open a subkey under our driver's node
 */
 HKEY DrvOpenRegKey(LPCTSTR DriverName,
                    LPCTSTR Path);
/*
 *      Create a services node for our driver if there isn't one already,
 *      otherwise open the existing one.  Returns ERROR_SUCCESS if OK.
 */
 BOOL
 DrvCreateServicesNode(PTCHAR DriverName,
                       SOUND_KERNEL_MODE_DRIVER_TYPE DriverType,
                       PREG_ACCESS RegAccess,
                       BOOL Create);

/*
 *      Close down our connection to the services manager
 */

 VOID
 DrvCloseServiceManager(
     PREG_ACCESS RegAccess);
/*
 *      Delete the services node for our driver
 */

 BOOL
 DrvDeleteServicesNode(
     PREG_ACCESS RegAccess);

/*
 *  Save the parameters subkey
 */
 BOOL DrvSaveParametersKey(PREG_ACCESS RegAccess);

/*
 *  Restore the parameters subkey
 */
 BOOL DrvRestoreParametersKey(PREG_ACCESS RegAccess);

/*
 *  Create the 'Parameters' subkey
 */
 LONG
 DrvCreateParamsKey(
     PREG_ACCESS RegAccess);

/*
 *  Open the key to a numbered device (starts at 0)
 */
 HKEY DrvOpenDeviceKey(LPCTSTR DriverName, UINT n);

/*
 *      Set a device parameter
 */
 #define DrvSetDeviceParameter(a, b, c) \
     DrvSetDeviceIdParameter(a, 0, b, c)
 LONG
 DrvSetDeviceIdParameter(
     PREG_ACCESS RegAccess,
     UINT   DeviceNumber,
     PTCHAR ValueName,
     DWORD Value);

/*
 *      Read current parameter setting
 */

 #define DrvQueryDeviceParameter(a, b, c) \
           DrvQueryDeviceIdParameter(a, 0, b, c)
 LONG
 DrvQueryDeviceIdParameter(
     PREG_ACCESS RegAccess,
     UINT   DeviceNumber,
     PTCHAR ValueName,
     PDWORD pValue);


/*
 *      Try loading a kernel driver
 */
 BOOL
 DrvLoadKernelDriver(
     PREG_ACCESS RegAccess);
/*
 *      Try unloading a kernel driver
 */

 BOOL
 DrvUnloadKernelDriver(
     PREG_ACCESS RegAccess);

/*
 *      See if driver is loaded
 */

 BOOL
 DrvIsDriverLoaded(
     PREG_ACCESS RegAccess);

/*
 *      Do driver (installation+) configuration
 */

 BOOL DrvConfigureDriver(
          PREG_ACCESS RegAccess,
          LPTSTR      DriverName,
          SOUND_KERNEL_MODE_DRIVER_TYPE
                      DriverType,
          BOOL (*     SetParms    )(PVOID),
          PVOID       Context);


/*
 *      Remove a driver
 */

 LRESULT DrvRemoveDriver(
             PREG_ACCESS RegAccess);

/*
 *      Number of card instances installed for a given driver
 */

 LONG
 DrvNumberOfDevices(
     PREG_ACCESS RegAccess,
     LPDWORD NumberOfDevices);


/*
 *      Set the midi mapper setup to use
 */
 VOID DrvSetMapperName(LPTSTR SetupName);

/*
 *      Find which interrupts and DMA Channels are free
 */

BOOL GetInterruptsAndDMA(
    LPDWORD InterruptsInUse,
    LPDWORD DmaChannelsInUse,
    LPCTSTR IgnoreDriver
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\drvlib\reslist1.c ===
/****************************************************************************
 *
 *   reslist1.c
 *
 *   Copyright (c) 1994-1996 Microsoft Corporation
 *
 *   This file contains code for querying the registry so that drivers
 *   can grey invalid resource options prior to loading drivers
 *
 *   This code is separated out from reslist.c because ntddk.h and windows.h
 *   can't be included simultaneously.
 *
 ****************************************************************************/

#include <ntddk.h>
#include <windef.h>
#include "reslist.h"
#include <string.h>
#include <tchar.h>

BOOL EnumerateDevices(PVOID Context, LPTSTR ValueName, DWORD Type, PVOID Value, DWORD cbValue)
{
    PRESOURCE_INFO ResInfo = (PRESOURCE_INFO)Context;

#if 0
    printf("Found device %s for driver %s\n",
           ValueName,
           ResInfo->DriverName);
#endif

    if (Type == REG_RESOURCE_LIST) {
        LPTSTR Search;
        LPTSTR LastDot = NULL;
        CM_FULL_RESOURCE_DESCRIPTOR ResourceDescriptor;
        PCM_RESOURCE_LIST ResourceList;
        DWORD iResourceDescriptor;

        ResourceList = Value;

        //
        //  Now filter out the RAW resource lists (the translated ones are not
        //  very interesting to the user
        //

        for (Search = ValueName; *Search; Search++) {
            if (*Search == TEXT('.')) {
                LastDot = Search;
            }
        }

        if (LastDot == NULL || _tcsicmp(LastDot + 1, TEXT("Raw")) != 0) {
            return TRUE;
        }

        *LastDot = TEXT('\0');   // Truncate device name

        //
        //  Now pass each element of the list in turn
        //

        for (iResourceDescriptor = 0;
             iResourceDescriptor < ResourceList->Count;
             iResourceDescriptor++) {
            INTERFACE_TYPE            InterfaceType;
            DWORD                     BusNumber;
            PCM_PARTIAL_RESOURCE_LIST PartialList;
            DWORD                     iPartialResourceDescriptor;
            DD_BUS_TYPE               BusType;
            DD_RESOURCE_TYPE          ResourceType;
            DD_CONFIG_DATA            ConfigData;

            InterfaceType =
                ResourceList->List[iResourceDescriptor].InterfaceType;
            BusNumber =
                ResourceList->List[iResourceDescriptor].BusNumber;
            PartialList =
                &ResourceList->List[iResourceDescriptor].PartialResourceList;

            for (iPartialResourceDescriptor = 0;
                 iPartialResourceDescriptor < PartialList->Count;
                 iPartialResourceDescriptor++) {
                PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor;

                PartialResourceDescriptor =
                    &PartialList->PartialDescriptors[
                       iPartialResourceDescriptor];

                /*
                **  Don't bother if it's not the first bus of this type
                */
                if (BusNumber != 0) {
                    continue;
                }

                /*
                **  Make up our callback data
                */

                switch (InterfaceType) {
                    case Isa:
                        BusType = DD_IsaBus;
                        break;
                    case Eisa:
                        BusType = DD_EisaBus;
                        break;
                    case MicroChannel:
                        BusType = DD_MCABus;
                        break;
                    default:
                        continue;
                }
                switch (PartialResourceDescriptor->Type) {
                    case CmResourceTypeInterrupt:
                        ResourceType = DD_Interrupt;
                        ConfigData.Interrupt =
                            PartialResourceDescriptor->u.Interrupt.Level;
                        break;

                    case CmResourceTypeDma:
                        ResourceType = DD_DmaChannel;
                        ConfigData.Interrupt =
                            PartialResourceDescriptor->u.Dma.Channel;
                        break;

                    case CmResourceTypePort:
                        ResourceType = DD_Port;
                        ConfigData.PortData.Port =
                            PartialResourceDescriptor->u.Port.Start.LowPart;
                        ConfigData.PortData.Length =
                            PartialResourceDescriptor->u.Port.Length;
                        break;

                    case CmResourceTypeMemory:
                        ResourceType = DD_Memory;
                        ConfigData.MemoryData.Address =
                            PartialResourceDescriptor->u.Memory.Start.LowPart;
                        ConfigData.MemoryData.Length =
                            PartialResourceDescriptor->u.Memory.Length;
                        break;

                    default:
                        continue;

                }

                if (!(*ResInfo->AppCallback)(
                          ResInfo->AppContext,
                          BusType,
                          ResourceType,
                          &ConfigData)) {
                    return TRUE;
                }
            }
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\synthlib\adlib.c ===
/*
 * Copyright (c) 1992-1995 Microsoft Corporation
 */


/*
 * definition of interface functions to the adlib midi device type.
 *
 * These functions are called from midi.c when the kernel driver
 * has decreed that this is an adlib-compatible device.
 *
 * Geraint Davies, Dec 92
 */

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "driver.h"
#include "adlib.h"

/*
 * overview
 *
 * The FM synthesis chip consists of 18 operator cells or 'slots'. Each slot
 * can produce a sine wave modified by a number of parameters such
 * as frequency, output level and envelope shape (attack/decay/sustain
 * release). Slots are arranged in pairs, with one slot modulating
 * the sine wave of another to produce the harmonics desired for
 * a given instrument sound. Thus one pair of slots is a 'voice' and can
 * play one note at a time.
 *
 * In percussive mode (which we always use), there are 6 melodic voices
 * available, and one voice for the base drum. The remaining four slots
 * are used singly rather than in pairs to produce four further percussive
 * voices. The 6 melodic voices will be changed to any given timbre
 * as needed. The five percussive voices are fixed to particular instrument
 * timbres: bass drum, snare, tom-tom, hi-hat and cymbal.
 *
 * To play a note, we first find a free voice of the appropriate type. If
 * there are none free, we use the oldest busy one. We then set the
 * parameters for both operator slots from the patch table - this table gives
 * parameter settings for the different instrument timbres available.
 * We adjust the output level and frequency depending on the
 * note played and the velocity it was played with, and then switch on the
 * note.
 */

/* --- typedefs ------------------------------------------------- */

#define NUMVOICES     (11)		// number of voices we have
#define NUMMELODIC    (6)  		// number of melodic voices
#define NUMPERCUSSIVE (5)  		// number of percussive voices

#define MAXPATCH      180		// nr of patches (including drums)
#define MAXVOLUME    0x7f
#define NUMLOCPARAM    14               // number of loc params per slot

#define FIRSTDRUMNOTE  35
#define LASTDRUMNOTE   81
#define NUMDRUMNOTES   (LASTDRUMNOTE - FIRSTDRUMNOTE + 1)

#define MAX_PITCH    0x3fff         	// maximum pitch bend value
#define MID_PITCH    0x2000         	// mid pitch bend value (no shift)
#define PITCHRANGE	  2		// total bend range +- 2 semitones
#define NR_STEP_PITCH    25         	// steps per half-tone for pitch bend
#define MID_C            60         	// MIDI standard mid C
#define CHIP_MID_C       48         	// sound chip mid C

/*
 * to write to the device, we write a SYNTH_DATA port,data pair
 * to the kernel driver.
 */
#define SndOutput(p,d)	MidiSendFM(p, d)




/****************************************************************************
 *
 *   definitions of sound chip parameters
 */

// parameters of each voice
#define prmKsl          0         // key scale level (KSL) - level controller
#define prmMulti        1         // frequency multiplier (MULTI) - oscillator
#define prmFeedBack     2         // modulation feedback (FB) - oscillator
#define prmAttack       3         // attack rate (AR) - envelope generator
#define prmSustain      4         // sustain level (SL) - envelope generator
#define prmStaining     5         // sustaining sound (SS) - envelope generator
#define prmDecay        6         // decay rate (DR) - envelope generator
#define prmRelease      7         // release rate (RR) - envelope generator
#define prmLevel        8         // output level (OL) - level controller
#define prmAm           9         // amplitude vibrato (AM) - level controller
#define prmVib          10        // frequency vibrator (VIB) - oscillator
#define prmKsr          11        // envelope scaling (KSR) - envelope generator
#define prmFm           12        // fm=0, additive=1 (FM) (operator 0 only)
#define prmWaveSel      13        // wave select

// global parameters
#define prmAmDepth      14
#define prmVibDepth     15
#define prmNoteSel      16
#define prmPercussion   17

// percussive voice numbers (0-5 are melodic voices, 2 op):
#define BD              6         // bass drum (2 op)
#define SD              7         // snare drum (1 op)
#define TOM             8         // tom-tom (1 op)
#define CYMB            9         // cymbal (1 op)
#define HIHAT           10        // hi-hat (1 op)

// In percussive mode, the last 4 voices (SD TOM HH CYMB) are created
// using melodic voices 7 & 8. A noise generator uses channels 7 & 8
// frequency information for creating rhythm instruments. Best results
// are obtained by setting TOM two octaves below mid C and SD 7 half-tones
// above TOM. In this implementation, only the TOM pitch may vary, with the
// SD always set 7 half-tones above.
#define TOM_PITCH        24      // best frequency, in range of 0 to 95
#define TOM_TO_SD        7       // 7 half-tones between voice 7 & 8
#define SD_PITCH         (TOM_PITCH + TOM_TO_SD)

/****************************************************************************
 *
 *   bank file support
 *
 ***************************************************************************/

#define BANK_SIG_LEN        6
#define BANK_FILLER_SIZE    8

typedef BYTE *HPBYTE;
typedef BYTE NEAR * NPBYTE;
typedef WORD NEAR * NPWORD;

// instrument bank file header
typedef struct {
    char      majorVersion;
    char      minorVersion;
    char      sig[BANK_SIG_LEN];            // signature: "ADLIB-"
    WORD      nrDefined;                    // number of list entries used
    WORD      nrEntry;                      // number of total entries in list
    long      offsetIndex;                  // offset of start of list of names
    long      offsetTimbre;                 // offset of start of data
    char      filler[BANK_FILLER_SIZE];     // must be zero
} BANKHDR, NEAR *NPBANKHDR, FAR *LPBANKHDR;


// all the parameters for one slot
typedef struct {
    BYTE ksl;            // KSL
    BYTE freqMult;       // MULTI
    BYTE feedBack;       // FB
    BYTE attack;         // AR
    BYTE sustLevel;      // SL
    BYTE sustain;        // SS
    BYTE decay;          // DR
    BYTE release;        // RR
    BYTE output;         // OL
    BYTE am;             // AM
    BYTE vib;            // VIB
    BYTE ksr;            // KSR
    BYTE fm;             // FM
} OPERATOR, NEAR *NPOPERATOR, FAR *LPOPERATOR;

// definition of a particular instrument sound or timbre -
// one of these per patch
typedef struct {
    BYTE      mode;             // 0 = melodic, 1 = percussive
    BYTE      percVoice;        // if mode == 1, voice number to be used
    OPERATOR  op0;		// params for slot 0
    OPERATOR  op1;		// params for slot 1
    BYTE      wave0;            // waveform for operator 0
    BYTE      wave1;            // waveform for operator 1
} TIMBRE, NEAR *NPTIMBRE, FAR *LPTIMBRE;

typedef struct drumpatch_tag {
    BYTE patch;                 // the patch to use
    BYTE note;                  // the note to play
} DRUMPATCH;

// format of drumkit.dat file
typedef struct drumfilepatch_tag {
    BYTE key;                   // the key to map
    BYTE patch;                 // the patch to use
    BYTE note;                  // the note to play
} DRUMFILEPATCH, *PDRUMFILEPATCH;


typedef struct _VOICE {
    BYTE alloc;                 // is voice allocated?
    BYTE note;                  // note that is currently being played
    BYTE channel;               // channel that it is being played on
    BYTE volume;                // current volume setting of voice
    DWORD dwTimeStamp;          // time voice was allocated
} VOICE;

#define GetLocPrm(slot_num, prm)   ((WORD)paramSlot[slot_num][prm])


/* --- module data ---------------------------------------------- */

// this table gives the offset of each slot within the chip.
BYTE offsetSlot[] = {
         0,  1,  2,  3,  4,  5,
         8,  9, 10, 11, 12, 13,
        16, 17, 18, 19, 20, 21
};

static BYTE percMasks[] = {
        0x10, 0x08, 0x04, 0x02, 0x01 };

// voice number associated with each slot (melodic mode only)
static BYTE voiceSlot[] = {
        0, 1, 2,
        0, 1, 2,
        3, 4, 5,
        3, 4, 5,
        6, 7, 8,
        6, 7, 8,
};

// slot numbers for percussive voices (0 indicates that there is only one slot)
static BYTE slotPerc[][2] = {
        {12, 15},        // Bass Drum
        {16, 0},         // SD
        {14, 0},         // TOM
        {17, 0},         // TOP-CYM
        {13, 0}          // HH
};

// slot numbers as a function of the voice and the operator (melodic only)
static BYTE slotVoice[][2] = {
        {0, 3},          // voice 0
        {1, 4},          // 1
        {2, 5},          // 2
        {6, 9},          // 3
        {7, 10},         // 4
        {8, 11},         // 5
        {12, 15},        // 6
        {13, 16},        // 7
        {14, 17}         // 8
};

// this table indicates if the slot is a modulator (0) or a carrier (1).
BYTE operSlot[] = {
        0, 0, 0,           // 1 2 3
        1, 1, 1,           // 4 5 6
        0, 0, 0,           // 7 8 9
        1, 1, 1,           // 10 11 12
        0, 0, 0,           // 13 14 15
        1, 1, 1,           // 16 17 18
};

// this array adjusts the octave of a note for certain patches.
static char patchKeyOffset[] = {
       0, -12,  12,   0,   0,  12, -12,   0,   0, -24,   // 0 - 9
       0,   0,   0,   0,   0,   0,   0,   0, -12,   0,   // 10 - 19
       0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   // 20 - 29
       0,   0,  12,  12,  12,   0,   0,  12,  12,   0,   // 30 - 39
     -12, -12,   0,  12, -12, -12,   0,  12,   0,   0,   // 40 - 49
     -12,   0,   0,   0,  12,  12,   0,   0,  12,   0,   // 50 - 59
       0,   0,  12,   0,   0,   0,  12,  12,   0,  12,   // 60 - 69
       0,   0, -12,   0, -12, -12,   0,   0, -12, -12,   // 70 - 79
       0,   0,   0,   0,   0, -12, -19,   0,   0, -12,   // 80 - 89
       0,   0,   0,   0,   0,   0, -31, -12,   0,  12,   // 90 - 99
      12,  12,  12,   0,  12,   0,  12,   0,   0,   0,   // 100 - 109
       0,  12,   0,   0,   0,   0,  12,  12,  12,   0,   // 110 - 119
       0,   0,   0,   0, -24, -36,   0,   0};            // 120 - 127

static BYTE loudervol[128] = {
    0,   0,  65,  65,  66,  66,  67,  67,         // 0 - 7
   68,  68,  69,  69,  70,  70,  71,  71,         // 8 - 15
   72,  72,  73,  73,  74,  74,  75,  75,         // 16 - 23
   76,  76,  77,  77,  78,  78,  79,  79,         // 24 - 31
   80,  80,  81,  81,  82,  82,  83,  83,         // 32 - 39
   84,  84,  85,  85,  86,  86,  87,  87,         // 40 - 47
   88,  88,  89,  89,  90,  90,  91,  91,         // 48 - 55
   92,  92,  93,  93,  94,  94,  95,  95,         // 56 - 63
   96,  96,  97,  97,  98,  98,  99,  99,         // 64 - 71
  100, 100, 101, 101, 102, 102, 103, 103,         // 72 - 79
  104, 104, 105, 105, 106, 106, 107, 107,         // 80 - 87
  108, 108, 109, 109, 110, 110, 111, 111,         // 88 - 95
  112, 112, 113, 113, 114, 114, 115, 115,         // 96 - 103
  116, 116, 117, 117, 118, 118, 119, 119,         // 104 - 111
  120, 120, 121, 121, 122, 122, 123, 123,         // 112 - 119
  124, 124, 125, 125, 126, 126, 127, 127};        // 120 - 127

/*
 * attenuation setting for each slot - combination
 * of the channel attenuation for this channel, and the
 * velocity (converted to attenuation). Combine with
 * global attenuation and timbre output attenuation before
 * writing to device.
 */
WORD slotAtten[18];		// vol-control attenuation of slots

WORD wSynthAtten;		// overall volume setting	

BYTE gbChanAtten[NUMCHANNELS];	// attenuation for each channel

VOICE voices[11];		// 9 voices if melodic mode or 11 if percussive
BYTE voiceKeyOn[11];		// keyOn bit for each voice (implicit 0 init)
BYTE paramSlot[18][NUMLOCPARAM]; // all the parameters of slots...

BYTE percBits;              // control bits of percussive voices

WORD fNumNotes[NR_STEP_PITCH][12];
PWORD fNumFreqPtr[11];      // lines of fNumNotes table (one per voice)
int  halfToneOffset[11];    // one per voice
BYTE notePitch[11];         // pitch value for each voice (implicit 0 init)

// patches - parameters for different instrument timbres
TIMBRE    patches[MAXPATCH];            // patch data
DRUMPATCH drumpatch[NUMDRUMNOTES];      // drum kit data


DWORD dwAge = 0;                // voice relative age




/* --- internal functions --------------------------------------- */



/* -- initialisation --- */
/****************************************************************************
 * @doc INTERNAL
 *
 * @api int | LoadPatches | Reads the patch set from the BANK resource and
 *     builds the <p patches> array.
 *
 * @rdesc Returns the number of patches loaded, or 0 if an error occurs.
 ***************************************************************************/
static BYTE PatchRes[] = {
#include "adlib.dat"
};

int  LoadPatches(void)
{
#ifdef WIN16
    HANDLE hResInfo;
    HANDLE hResData;
#endif
    LPSTR  lpRes;
    int    iPatches;
    DWORD  dwOffset;
    DWORD  dwResSize;
    LPTIMBRE  lpBankTimbre;
    LPTIMBRE  lpPatchTimbre;
    LPBANKHDR lpBankHdr;


    // find resource and get its size
#ifdef WIN16
    hResInfo = FindResource(ghInstance, MAKEINTRESOURCE(DEFAULTBANK), MAKEINTRESOURCE(RT_BANK));
    if (!hResInfo) {
        D1(("Default bank resource not found"));
        return 0;
    }
    dwResSize = (DWORD)SizeofResource(ghInstance, hResInfo);

    // load and lock resource
    hResData = LoadResource(ghInstance, hResInfo);
    if (!hResData) {
        D1(("Bank resource not loaded"));
        return 0;
    }
    lpRes = LockResource(hResData);
    if (!lpRes) {
        D1(("Bank resource not locked"));
        return 0;
    }
#else
    lpRes = PatchRes;
    dwResSize = sizeof(PatchRes);
#endif

    // read the bank resource, loading patches as we find them

    D2(("loading patches"));
    lpBankHdr = (LPBANKHDR)lpRes;
    dwOffset = lpBankHdr->offsetTimbre;                // point to first one

    for (iPatches = 0; iPatches < MAXPATCH; iPatches++) {

        lpBankTimbre = (LPTIMBRE)(lpRes + dwOffset);
        lpPatchTimbre = &patches[iPatches];
        *lpPatchTimbre = *lpBankTimbre;

        dwOffset += sizeof(TIMBRE);
        if (dwOffset + sizeof(TIMBRE) > dwResSize) {
            D1(("Attempt to read past end of bank resource"));
            break;
        }
    }

#ifdef WIN16
    UnlockResource(hResData);
    FreeResource(hResData);
#endif

    return iPatches;
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api int | LoadDrumPatches | Reads the drum kit patch set from the
 *     DRUMKIT resource and builds the <p drumpatch> array.
 *
 * @comm Each entry of the <t drumpatch> array (representing a key number
 *     from the "drum patch") consists of a patch number and note number
 *     from some other patch.
 *
 * @rdesc Returns the number of patches loaded, or 0 if an error occurs.
 ***************************************************************************/

static BYTE DrumRes[] = {
#include "drumkit.dat"
};

int LoadDrumPatches(void)
{
#ifdef WIN16
    HANDLE hResInfo;
    HANDLE hResData;
#endif
    LPSTR  lpRes;
    int    iPatches;
    int    key;
    DWORD  dwOffset;
    DWORD  dwResSize;
    PDRUMFILEPATCH lpResPatch;

#ifdef WIN16
    // find resource and get its size
    hResInfo = FindResource(ghInstance, MAKEINTRESOURCE(DEFAULTDRUMKIT), MAKEINTRESOURCE(RT_DRUMKIT));
    if (!hResInfo) {
        D1(("Default drum resource not found"));
        return 0;
    }
    dwResSize = (DWORD)SizeofResource(ghInstance, hResInfo);

    // load and lock resource
    hResData = LoadResource(ghInstance, hResInfo);
    if (!hResData) {
        D1(("Drum resource not loaded"));
        return 0;
    }
    lpRes = LockResource(hResData);
    if (!lpRes) {
        D1(("Drum resource not locked"));
        return 0;
    }
#else
    lpRes = DrumRes;
    dwResSize = sizeof(DrumRes);
#endif

    // read the drum resource, loading patches as we find them

    D2(("reading drum data"));
    dwOffset = 0;
    for (iPatches = 0; iPatches < NUMDRUMNOTES; iPatches++) {

        lpResPatch = (PDRUMFILEPATCH)(lpRes + dwOffset);
        key = lpResPatch->key;
        if ((key >= FIRSTDRUMNOTE) && (key <= LASTDRUMNOTE)) {
            drumpatch[key - FIRSTDRUMNOTE].patch = lpResPatch->patch;
            drumpatch[key - FIRSTDRUMNOTE].note = lpResPatch->note;
        }
        else {
            D1(("Drum patch key out of range"));
        }

        dwOffset += sizeof(DRUMFILEPATCH);
        if (dwOffset > dwResSize) {
            D1(("Attempt to read past end of drum resource"));
            break;
        }
    }

#ifdef WIN16
    UnlockResource(hResData);
    FreeResource(hResData);
#endif

    return iPatches;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api long | CalcPremFNum | Calculates some magic number that is used in
 *     setting the values in the <p fNumNotes> table.
 *
 * @parm int | numDeltaDemiTon | Numerator (-100 to +100).
 *
 * @parm int | denDeltaDemiTon | Denominator (1 to 100).
 *
 * @comm If the numerator (numDeltaDemiTon) is positive, the frequency is
 *     increased; if negative, it is decreased.  The function calculates:
 *         f8 = Fb(1 + 0.06 num /den)          (where Fb = 26044 * 2 / 25)
 *         fNum8 = f8 * 65536 * 72 / 3.58e6
 *
 * @rdesc Returns fNum8, which is the binary value of the frequency 260.44 (C)
 *     shifted by +/- <p numdeltaDemiTon> / <p denDeltaDemiTon> * 8.
 ***************************************************************************/
long NEAR CalcPremFNum(int numDeltaDemiTon, int denDeltaDemiTon)
{
    long f8;
    long fNum8;
    long d100;

    d100 = denDeltaDemiTon * 100;
    f8 = (d100 + 6 * numDeltaDemiTon) * (26044L * 2L);
    f8 /= d100 * 25;

    fNum8 = f8 * 16384;
    fNum8 *= 9L;
    fNum8 /= 179L * 625L;

    return fNum8;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | SetFNum | Initializes a line in the frequency table with
 *     shifted frequency values.  The values are shifted a fraction (num/den)
 *     of a half-tone.
 *
 * @parm NPWORD | fNumVec | The line from the frequency table.
 *
 * @parm int | num | Numerator.
 *
 * @parm int | den | Denominator.
 *
 * @xref CalcPremFNum
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void NEAR SetFNum(NPWORD fNumVec, int num, int den)
{
    int  i;
    long val;

    *fNumVec++ = (WORD)((4 + (val = CalcPremFNum(num, den))) >> 3);
    for (i = 1; i < 12; i++) {
        val *= 106;
        *fNumVec++ = (WORD)((4 + (val /= 100)) >> 3);
    }
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | InitFNums | Initializes all lines of the frequency table
 *     (the <p fNumNotes> array). Each line represents 12 half-tones shifted
 *     by (n / NR_STEP_PITCH), where 'n' is the line number and ranges from
 *     1 to NR_STEP_PITCH.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void NEAR InitFNums(void)
{
    WORD i;
    WORD num;           // numerator
    WORD numStep;       // step value for numerator
    WORD row;           // row in the frequency table

    // calculate each row in the fNumNotes table
    numStep = 100 / NR_STEP_PITCH;
    for (num = row = 0; row < NR_STEP_PITCH; row++, num += numStep)
        SetFNum(fNumNotes[row], num, 100);

    // fNumFreqPtr has an element for each voice, pointing to the
    // appropriate row in the fNumNotes table.  They're all initialized
    // to the first row, which represents no pitch shift.
    for (i = 0; i < 11; i++) {
        fNumFreqPtr[i] = fNumNotes[0];
        halfToneOffset[i] = 0;
    }
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | SoundChut | Sets the frequency of voice <p voice> to 0 Hz.
 *
 * @parm BYTE | voice | Specifies which voice to set.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void NEAR SoundChut(BYTE voice)
{

    SndOutput((BYTE)(0xA0 | voice), 0);
    SndOutput((BYTE)(0xB0 | voice), 0);
}

/* --- write parameters to chip ------------------------*/

/*
 * switch chip to rhythm (percussive) mode, set the amplitude and
 * vibrato depth and switch on any percussion voices that are on
 */
void SndSAmVibRhythm(void)
{

    // we always set amdepth, vibdepth to 0 and perc mode on

    // t1 = (BYTE)(amDepth ? 0x80 : 0);
    // t1 |= vibDepth ? 0x40 : 0;
    // t1 |= (percussionmode ? 0x20 : 0);

    SndOutput((BYTE)0xBD, (BYTE)(0x20|percBits));
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | SndSNoteSel | Sets the NoteSel value.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void SndSNoteSel(BOOL bNoteSel)
{
    SndOutput(0x08, (BYTE)(bNoteSel ? 64 : 0));
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | SndSKslLevel | Sets the KSL and LEVEL values.
 *
 * @parm BYTE | slot | Specifies which slot to set.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void SndSKslLevel(BYTE slot)
{
    WORD t1;

    t1 = GetLocPrm(slot, prmLevel) & 0x3f;

    t1 += slotAtten[slot];
    t1 = min (t1, 0x3f);
    t1 |= GetLocPrm(slot, prmKsl) << 6;
    SndOutput((BYTE)(0x40 | offsetSlot[slot]), (BYTE) t1);
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | SndSAVEK | Sets the AM, VIB, EG-TYP (sustaining), KSR, and
 *     MULTI values.
 *
 * @parm BYTE | slot | Specifies which slot to set.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void SndSAVEK(BYTE slot)
{
    BYTE t1;

    t1 = (BYTE)(GetLocPrm(slot, prmAm) ? 0x80 : 0);
    t1 += GetLocPrm(slot, prmVib) ? 0x40 : 0;
    t1 += GetLocPrm(slot, prmStaining) ? 0x20 : 0;
    t1 += GetLocPrm(slot, prmKsr) ? 0x10 : 0;
    t1 += GetLocPrm(slot, prmMulti) & 0xf;
    SndOutput((BYTE)(0x20 | offsetSlot[slot]), t1);
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | SndSFeedFm | Sets the FEEDBACK and FM (connection) values.
 *     Applicable only to operator 0 for melodic voices.
 *
 * @parm BYTE | slot | Specifies which slot to set.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void SndSFeedFm(BYTE slot)
{
    BYTE t1;

    if (operSlot[slot])
        return;

    t1 = (BYTE)(GetLocPrm(slot, prmFeedBack) << 1);
    t1 |= GetLocPrm(slot, prmFm) ? 0 : 1;
    SndOutput((BYTE)(0xC0 | voiceSlot[slot]), t1);
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | SndSAttDecay | Sets the ATTACK and DECAY values.
 *
 * @parm BYTE | slot | Specifies which slot to set.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void SndSAttDecay(BYTE slot)
{
    BYTE t1;

    t1 = (BYTE)(GetLocPrm(slot, prmAttack) << 4);
    t1 |= GetLocPrm(slot, prmDecay) & 0xf;
    SndOutput((BYTE)(0x60 | offsetSlot[slot]), t1);
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | SndSSusRelease | Sets the SUSTAIN and RELEASE values.
 *
 * @parm BYTE | slot | Specifies which slot to set.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void SndSSusRelease(BYTE slot)
{
    BYTE t1;

    t1 = (BYTE)(GetLocPrm(slot, prmSustain) << 4);
    t1 |= GetLocPrm(slot, prmRelease) & 0xf;
    SndOutput((BYTE)(0x80 | offsetSlot[slot]), t1);
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | SndWaveSelect | Sets the wave-select parameter.
 *
 * @parm BYTE | slot | Specifies which slot to set.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void SndWaveSelect(BYTE slot)
{
    BYTE wave;

    wave = (BYTE)(GetLocPrm(slot, prmWaveSel) & 0x03);

    SndOutput((BYTE)(0xE0 | offsetSlot[slot]), wave);
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | SndSetAllPrm | Transfers all the parameters from slot <p slot>
 *     to the chip.
 *
 * @parm BYTE | slot | Specifies which slot to set.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void SndSetAllPrm(BYTE slot)
{

    /* global am-depth and vib-depth settings */
    SndSAmVibRhythm();

    /* note sel is always false */
    SndSNoteSel(FALSE);

    /* slot-specific parameters */

    /* initialise volume to minimum to avoid clicks if the note is
     * off but still playing (during decay phase).
     *
     * only applies to carrier slots.
     */
    if (operSlot[slot]) {
	/* its a carrier slot */
        slotAtten[slot] = 0x3f;		// max attenuation
    }
    SndSKslLevel(slot);

    SndSFeedFm(slot);
    SndSAttDecay(slot);
    SndSSusRelease(slot);
    SndSAVEK(slot);
    SndWaveSelect(slot);
}



/* --- setting slot parameters ------------------ */

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | SetSlotParam | Sets the 14 parameters (13 in <p param>,
 *     1 in <p waveSel>) of slot <p slot>. Updates both the parameter array
 *     and the chip.
 *
 * @parm BYTE | slot | Specifies which slot to set.
 *
 * @parm NPBYTE | param | Pointer to the new parameter array.
 *
 * @parm BYTE | waveSel | The new waveSel value.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void SetSlotParam(BYTE slot, NPOPERATOR pOper, BYTE waveSel)
{
    LPBYTE ptr;

    ptr = &paramSlot[slot][0];

    *ptr++ = pOper->ksl;
    *ptr++ = pOper->freqMult;
    *ptr++ = pOper->feedBack;
    *ptr++ = pOper->attack;
    *ptr++ = pOper->sustLevel;
    *ptr++ = pOper->sustain;
    *ptr++ = pOper->decay;
    *ptr++ = pOper->release;
    *ptr++ = pOper->output;
    *ptr++ = pOper->am;
    *ptr++ = pOper->vib;
    *ptr++ = pOper->ksr;
    *ptr++ = pOper->fm;

    *ptr = waveSel & 0x3;

    // set default volume settings
    slotAtten[slot] = 0;

    SndSetAllPrm(slot);
}

/*
 * set this voice up to the correct parameters for a timbre
 * copy the parameters to the slot array and write them to the
 * chip
 *
 */

void SetVoiceTimbre(BYTE voice, NPTIMBRE pTimbre)
{

    if (voice < BD) {        // melodic only
	SetSlotParam(slotVoice[voice][0], &pTimbre->op0, pTimbre->wave0);
	SetSlotParam(slotVoice[voice][1], &pTimbre->op1, pTimbre->wave1);
    }
    else if (voice == BD) {                   // bass drum
	SetSlotParam(slotPerc[0][0], &pTimbre->op0, pTimbre->wave0);
	SetSlotParam(slotPerc[0][1], &pTimbre->op1, pTimbre->wave1);
    } else {                                    // percussion, 1 slot
	SetSlotParam(slotPerc[voice - BD][0], &pTimbre->op0, pTimbre->wave0);
    }
}



/* --- frequency calculation -------------------- */


/* convert the given pitch (0 .. 95) into a frequency
 * and write to the chip.
 *
 * this will turn the note on if keyon is true.
 */
VOID SetFreq(BYTE voice, BYTE pitch, BYTE keyOn)
{
    WORD  FNum;
    BYTE  t1;


    // remember the keyon and pitch of the voice

    voiceKeyOn[voice] = keyOn;
    notePitch[voice] = pitch;

    pitch += (BYTE)halfToneOffset[voice];
    if (pitch > 95)
        pitch = 95;

    // get the FNum for the voice
    FNum = * (fNumFreqPtr[voice] + pitch % 12);

    // output the FNum, KeyOn and Block values
    SndOutput((BYTE)(0xA0 | voice), (BYTE)FNum);   // FNum bits 0 - 7 (D0 - D7)
    t1 = (BYTE)(keyOn ? 32 : 0);                   // Key On (D5)
    t1 += (pitch / 12 << 2);                       // Block (D2 - D4)
    t1 += (0x3 & (FNum >> 8));                     // FNum bits 8 - 9 (D0 - D1)
    SndOutput((BYTE)(0xB0 | voice), t1);
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | ChangePitch | This routine sets the <t halfToneOffset[]> and
 *     <t fNumFreqPtr[]> arrays.  These two global variables are used to
 *     determine the frequency variation to use when a note is played.
 *
 * @parm BYTE | voice | Specifies which voice to use.
 *
 * @parm WORD | pitchBend | Specifies the pitch bend value (0 to 0x3fff,
 *     where 0x2000 is exact tuning).
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void  ChangePitch(BYTE voice, WORD pitchBend)
{
    int     t1;
    int     t2;
    int     delta;
    int pitchrange;

    /* pitch bend range 0-3fff is +-PITCHRANGE semitones. We move
     * NR_STEP_PITCH steps per semitone.
     * so the bend range is +- (PITCHRANGE * NR_STEP_PITCH) steps.
     */
    pitchrange = PITCHRANGE * NR_STEP_PITCH;

    t1 = (int)(((long)((int)pitchBend - MID_PITCH) * pitchrange) / MID_PITCH);

    if (t1 < 0)
    {
	t2 = NR_STEP_PITCH - 1 - t1;
	halfToneOffset[voice] = -(t2 / NR_STEP_PITCH);
	delta = (t2 - NR_STEP_PITCH + 1) % NR_STEP_PITCH;
	if (delta) {
	    delta = NR_STEP_PITCH - delta;
	}
    }
    else
    {
	halfToneOffset[voice] = t1 / NR_STEP_PITCH;
	delta = t1 % NR_STEP_PITCH;
    }
    fNumFreqPtr[voice] = fNumNotes[delta];

}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | SetVoicePitch | Changes the pitch value of a voice.  Does
 *     not affect the percussive voices, except for the bass drum.  The change
 *     takes place immediately.
 *
 * @parm BYTE | voice | Specifies which voice to set.
 *
 * @parm WORD | pitchBend | Specifies the new pitch bend value (0 to 0x3fff,
 *     where 0x2000 == exact tuning).
 *
 * @comm The variation in pitch is a function of the previous call to
 *     <f SetPitchRange> and the value of <p pitchBend>.  A value of 0 means
 *     -half-tone * pitchRangeStep, 0x2000 means no variation (exact pitch) and
 *      0x3fff means +half-tone * pitchRangeStep.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void SetVoicePitch(BYTE voice, WORD pitchBend)
{
    if (voice <= BD) {       // melodic and bass drum voices
        if (pitchBend > MAX_PITCH) {
	    pitchBend = MAX_PITCH;
	}
        ChangePitch(voice, pitchBend);
        SetFreq(voice, notePitch[voice], voiceKeyOn[voice]);
    }
}

/* --- volume calculation ------------------------ */

/*
 * set the attenuation for a slot (combine the channel attenuation
 * setting with the key velocity).
 */
VOID SetVoiceAtten(BYTE voice, BYTE bChannel, BYTE bVelocity)
{
    BYTE bAtten;
    BYTE   slot;
    PBYTE slots;

    // scale up the volume since the patch maps are too quiet
    //bVelocity = loudervol[bVelocity];


    /*
     * set channel attenuation
     */
    bAtten = gbVelocityAtten[bVelocity >> 2] + gbChanAtten[bChannel];


    /*
     * add on any global (volume-setting) attenuation
     */
    bAtten += wSynthAtten;


    /* save this for each non-modifier slot */

    if (voice <= BD) {      // melodic voice
        slots = slotVoice[voice];

        slotAtten[slots[1]] = bAtten;
        SndSKslLevel(slots[1]);

        if (!GetLocPrm(slots[0], prmFm)) {
            // additive synthesis: set volume of first slot too
	    slotAtten[slots[0]] = bAtten;
            SndSKslLevel(slots[0]);
        }
    }
    else {                                  // percussive voice
        slot = slotPerc[voice - BD][0];
	slotAtten[slot] = bAtten;
        SndSKslLevel(slot);
    }
}

/* adjust each slot attenuation to allow for a global volume
 * change - note that we only need to change the
 * carrier, not the modifier slots.
 *
 * change for channel bChannel, or all channels if bChannel is
 * 0xff
 */
VOID ChangeAtten(BYTE bChannel, int iChangeAtten)
{
    BYTE voice;
    BYTE   slot;
    PBYTE slots;

    /* find voices using this channel */
    for (voice = 0; voice < NUMVOICES; voice++) {
	if ((voices[voice].channel == bChannel) || (bChannel == 0xff)) {

	    if (voice <= BD) {

		/* melodic voice */
		slots = slotVoice[voice];

		slotAtten[slots[1]] += (WORD)iChangeAtten;
		SndSKslLevel(slots[1]);

		if (!GetLocPrm(slots[0], prmFm)) {
		    // additive synthesis: set volume of first slot too
		    slotAtten[slots[0]] += (WORD)iChangeAtten;
		    SndSKslLevel(slots[0]);
		}
    	    } else {
		slot = slotPerc[voice - BD][0];
		slotAtten[slot] += (WORD)iChangeAtten;
		SndSKslLevel(slot);
	    }
	}
    }
}


/* --- note on/off ------------------------------- */

/* switch off the note a given voice is playing */
void NoteOff(BYTE voice)
{

    if (voice < BD) {

	/* melodic voice */
	SetFreq(voice, notePitch[voice], 0);
    } else {
	percBits &= ~percMasks[voice-BD];
	SndSAmVibRhythm();
    }
}

/* switch on a voice at a given note (0 - 127, where 60 is middle c) */
void NoteOn(BYTE voice, BYTE bNote)
{
    BYTE bPitch;

    /* convert note to chip pitch */
    if (bNote < (MID_C - CHIP_MID_C)) {
	bPitch = 0;
    } else {
	bPitch = bNote - (MID_C - CHIP_MID_C);
    }

    if (voice < BD) {
	/* melodic voice */

	/* set frequency and start note */
	SetFreq(voice, bPitch, 1);
    } else {
	/*
	 * nb we don't change the pitch of some percussion instruments.
	 *
	 * also note that for percussive instruments (including BD),
	 * the note-on setting should always be 0. You switch the percussion
	 * on by writing to the AmVibRhythm register.
	 */

	if (voice == BD) {
	    SetFreq(voice, bPitch, 0);
	} else if (voice == TOM) {
	    /*
	     * for best sounds, we do change the TOM freq, but we always keep
	     * the SD 7 semi-tones above TOM.
	     */
	    SetFreq(TOM, bPitch, 0);
	    SetFreq(SD, (BYTE)(bPitch + TOM_TO_SD), 0);
	}
	/* other instruments never change */

	percBits |= percMasks[voice - BD];
	SndSAmVibRhythm();
    }
}



/* -- voice allocation -------- */

/*
 * find the voice that is currently playing a given channel/note pair
 * (if any)
 */
BYTE
FindVoice(BYTE bNote, BYTE bChannel)
{
    BYTE i;

    for (i = 0; i < (BYTE)NUMVOICES; i++) {
	if ((voices[i].alloc) && (voices[i].note == bNote)
	   && (voices[i].channel == bChannel)) {
    	    voices[i].dwTimeStamp = dwAge++;
    	    return(i);
	}
    }

    /* no voice is playing this */
    return(0xff);
}

/*
 * mark a voice as unused
 */
VOID FreeVoice(voice)
{
    voices[voice].alloc = 0;
}


/*
 * GetNewVoice - allocate a voice to play this note. if no voices are
 * free, re-use the note with the oldest timestamp.
 */
BYTE GetNewVoice(BYTE patch, BYTE note, BYTE channel)
{
    BYTE  i;
    BYTE  voice;
    BYTE  bVoiceToUse, bVoiceSame, bVoiceOldest;
    DWORD dwOldestTime = dwAge + 1;	 	// init to past current "time"
    DWORD dwOldestSame = dwAge + 1;
    DWORD dwOldestOff = dwAge + 1;

    if (patches[patch].mode) {            // it's a percussive patch
        voice = patches[patch].percVoice;       // use fixed percussion voice
        voices[voice].alloc = TRUE;
        voices[voice].note = note;
        voices[voice].channel = channel;
        voices[voice].dwTimeStamp = MAKELONG(patch, 0);

        SetVoiceTimbre(voice, &patches[patch]);

        return voice;
    }

    bVoiceToUse = bVoiceSame = bVoiceOldest = 0xff;

    // find a free melodic voice to use
    for (i = 0; i < (BYTE)NUMMELODIC; i++) {    // it's a melodic patch
        if (!voices[i].alloc) {

	    if (voices[i].dwTimeStamp < dwOldestOff) {
		bVoiceToUse = i;
		dwOldestOff = voices[i].dwTimeStamp;
	    }

        } else if (voices[i].channel == channel) {
	    if (voices[i].dwTimeStamp < dwOldestSame) {
		dwOldestSame = voices[i].dwTimeStamp;
		bVoiceSame = i;
	    }
        } else if (voices[i].dwTimeStamp < dwOldestTime) {
                dwOldestTime = voices[i].dwTimeStamp;
                bVoiceOldest = i;                // remember oldest one to steal
        }
    }

    // choose a free voice if we have found one. If not, choose the
    // oldest voice of the same channel. if none, choose the oldest voice.
    if (bVoiceToUse == 0xff) {
	if (bVoiceSame != 0xff) {
	    bVoiceToUse = bVoiceSame;
	} else {
	    bVoiceToUse = bVoiceOldest;
	}
    }


    if (voices[bVoiceToUse].alloc)  {      // if we stole it, turn it off
        NoteOff(bVoiceToUse);
    }

    voices[bVoiceToUse].alloc = 1;
    voices[bVoiceToUse].note = note;
    voices[bVoiceToUse].channel = channel;
    voices[bVoiceToUse].dwTimeStamp = dwAge++;

    SetVoiceTimbre(bVoiceToUse, &patches[patch]);

    return bVoiceToUse;
}


/* --- externally-called functions ------------------------------ */

/*
 * Adlib_NoteOn - This turns a note on. (Including drums, with
 *	a patch # of the drum Note + 128)
 *
 * inputs
 *      BYTE    bPatch - MIDI patch number
 *	BYTE    bNote - MIDI note number
 *      BYTE    bChannel - MIDI channel #
 *	BYTE    bVelocity - Velocity #
 *	short   iBend - current pitch bend from -32768, to 32767
 * returns
 *	none
 */
VOID NEAR PASCAL Adlib_NoteOn (BYTE bPatch,
	BYTE bNote, BYTE bChannel, BYTE bVelocity,
	short iBend)
{

    BYTE voice;
    WORD wBend;

    if (bVelocity == 0) {               // 0 velocity means note off
        Adlib_NoteOff(bPatch, bNote, bChannel);
	return;
    }

    // octave registration for melodic patches
    if (bPatch < 128) {
	bNote += patchKeyOffset[bPatch];
	if ((bNote < 0) || (bNote > 127)) {
	    bNote -= patchKeyOffset[bPatch];
	}
    }


    if (bPatch >= 128) {
	/*
	 * it's a percussion note
	 */

	bNote = bPatch - 128;

        if ((bNote < FIRSTDRUMNOTE) || (bNote > LASTDRUMNOTE)) {
            return;
	}

	/* use the drum patch table to map the note to a given
	 * TIMBRE/note pair
	 */
	bPatch = drumpatch[bNote - FIRSTDRUMNOTE].patch;
	bNote = drumpatch[bNote - FIRSTDRUMNOTE].note;

	/* each drum patch plays on one specific voice.
	 * find that voice
	 */
	voice = patches[bPatch].percVoice;
	
	/* switch note off if playing */
	if (voices[voice].alloc) {
	    NoteOff(voice);
	}

	/* call GetNewVoice to set the voice params and timestamp
	 * even if we found it.
	 */
	voice = GetNewVoice(bPatch, bNote, bChannel);

    } else {

	/* switch note off if it's playing  */
	if ( (voice = FindVoice(bNote, bChannel)) != 0xFF ) {
		NoteOff(voice);
	} else {
	    voice = GetNewVoice(bPatch, bNote, bChannel);
	}
    }

    /* convert the velocity to an attenuation setting, and
     * write that to the device
     */
    SetVoiceAtten(voice, bChannel, bVelocity);

    /*
     * apply pitch bend. note that we are passed a pitch bend in the
     * range 8000-7fff, but our code assumes 0-3fff, so we convert here.
     */
    wBend = (((WORD)iBend + 0x8000) >> 2) & 0x3fff;
    SetVoicePitch(voice, wBend);

    // play the note
    NoteOn(voice, bNote);

}


/* Adlib_NoteOff - This turns a note off. (Including drums,
 *	with a patch # of the drum note + 128)
 *
 * inputs
 *	BYTE    bPatch - MIDI patch #
 *	BYTE    bNote - MIDI note number
 *	BYTE    bChannel - MIDI channel #
 * returns
 *	none
 */
VOID FAR PASCAL Adlib_NoteOff (BYTE bPatch,
	BYTE bNote, BYTE bChannel)
{
    BYTE bVoice;

    if (bPatch > 127) {

	/* drum note. These all use a fixed voice */


        if ((bNote < FIRSTDRUMNOTE) || (bNote > LASTDRUMNOTE)) {
            return;
	}

	/* use the drum patch table to map the note to a given
	 * TIMBRE/note pair
	 */
	bPatch = drumpatch[bNote - FIRSTDRUMNOTE].patch;
	bNote = drumpatch[bNote - FIRSTDRUMNOTE].note;
	bVoice = patches[bPatch].percVoice;
	
	/* switch note off if playing our patch */
	if (LOWORD(voices[bVoice].dwTimeStamp) == bPatch) {
	    NoteOff(bVoice);
	}
    } else {

	bVoice = FindVoice(bNote, bChannel);
	if (bVoice != 0xff) {

	    if (voices[bVoice].note) {
		NoteOff(bVoice);
		FreeVoice(bVoice);
	    }
	}
    }
}

/* Adlib_AllNotesOff - turn off all notes
 *
 * inputs - none
 * returns - none
 */
VOID Adlib_AllNotesOff(void)
{

    BYTE i;

    for (i = 0; i < NUMVOICES; i++) {
    	NoteOff(i);
    }
}


/* Adlib_NewVolume - This should be called if a volume level
 *	has changed. This will adjust the levels of all the playing
 *	voices.
 *
 * inputs
 *	WORD	wLeft	- left attenuation (1.5 db units)
 *	WORD	wRight  - right attenuation (ignore if mono)
 * returns
 *	none
 */
VOID FAR PASCAL Adlib_NewVolume (WORD wLeft, WORD wRight)
{
    /* ignore the right attenuation since this is a mono device */
    int iChange;

    wLeft = min(wLeft, wRight) << 1;
    iChange = wLeft - wSynthAtten;

    wSynthAtten = wLeft;

    /* change attenuation for all channels */
    ChangeAtten(0xff, iChange);
}



/* Adlib_ChannelVolume - set the volume level for an individual channel.
 *
 * inputs
 * 	BYTE	bChannel - channel number to change
 *	WORD	wAtten	- attenuation in 1.5 db units
 *
 * returns
 *	none
 */
VOID FAR PASCAL Adlib_ChannelVolume(BYTE bChannel, WORD wAtten)
{	
    int iChange;

    iChange = wAtten - gbChanAtten[bChannel];

    gbChanAtten[bChannel] = (BYTE)wAtten;


    /* change attenuation for this channel */
    ChangeAtten(bChannel, iChange);
}


/* Adlib_SetPan - set the left-right pan position.
 *
 * inputs
 *      BYTE    bChannel  - channel number to alter
 *	BYTE	bPan   - 0 for left, 127 for right or somewhere in the middle.
 *
 * returns - none
 *
 * does nothing - this is a mono device
 */
VOID FAR PASCAL Adlib_SetPan(BYTE bChannel, BYTE bPan)
{

    /* do nothing */
}


/* Adlib_PitchBend - This pitch bends a channel.
 *
 * inputs
 *	BYTE    bChannel - channel
 *	short   iBend - Values from -32768 to 32767, being
 *			-2 to +2 half steps
 * returns
 *	none
 */
VOID NEAR PASCAL Adlib_PitchBend (BYTE bChannel, short iBend)
{
    BYTE i;
    WORD w;

    /* note that our code expects 0 - 0x3fff not 0x8000 - 0x7fff */
    w = (((WORD) iBend + 0x8000) >> 2) & 0x3fff;

    for (i = 0; i < NUMVOICES; i++) {
	if ((voices[i].alloc) && (voices[i].channel == bChannel)) {
	    SetVoicePitch(i,  w);
	}
    }
}



/* Adlib_BoardInit - initialise board and load patches as necessary.
 *
 * inputs - none
 * returns - 0 for success or the error code
 */
WORD Adlib_BoardInit(void)
{
    BYTE i;

    wSynthAtten = 0;

    /* build the freq table */
    InitFNums();

    /* silence and free all voices */
    for (i = 0; i <= 8; i++) {
	SoundChut(i);
	FreeVoice(i);
    }

    /* switch to percussive mode and set fixed frequencies */
    SetFreq(TOM, TOM_PITCH, 0);
    SetFreq(SD, SD_PITCH, 0);
    percBits = 0;
    SndSAmVibRhythm();

    /* init all slots to sine-wave */
    for (i= 0; i < 18; i++) {
	SndOutput((BYTE)(0xE0 | offsetSlot[i]), 0);
    }
    /* enable wave-form selection */
    SndOutput(1, 0x20);

    LoadPatches();
    LoadDrumPatches();

// don't initialise - the data is static and will thus
// be initialised to 0 at load time. no other change should be made
// since the mci sequencer will not re-send channel volume change
// messages.
//
//    /* init all channels to loudest */
//    for (i = 0; i < NUMCHANNELS; i++) {
//	gbChanAtten[i] = 4;
//    }

    return(0);
}


/*
 * Adlib_BoardReset - silence the board and set all voices off.
 */
VOID Adlib_BoardReset(void)
{
    BYTE i;

    /* silence and free all voices */
    for (i = 0; i <= 8; i++) {
	SoundChut(i);
	FreeVoice(i);
    }

    /* switch to percussive mode and set fixed frequencies */
    SetFreq(TOM, TOM_PITCH, 0);
    SetFreq(SD, SD_PITCH, 0);
    percBits = 0;
    SndSAmVibRhythm();

}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\drvlib\wavedd.c ===
/****************************************************************************
 *
 *   wavedd.c
 *
 *   Multimedia kernel driver support component (mmdrv)
 *
 *   Copyright (c) 1991-1996 Microsoft Corporation
 *
 *   Driver for wave input and output devices
 *
 *   -- Wave driver entry points (wodMessage, widMessage)
 *   -- Auxiliary task (necessary for receiving Apcs and generating
 *      callbacks ASYNCRHONOUSLY)
 *   -- Interface to kernel driver (via DeviceIoControl)
 *
 *   Note that if any error occurs then the kernel device is closed
 *   and all subsequent calls requiring calls to the kernel device
 *   return error until the device is closed by the application.
 *
 *   History
 *      01-Feb-1992 - Robin Speed (RobinSp) wrote it
 *      04-Feb-1992 - SteveDav reviewed it
 *      08-Feb-1992 - RobinSp - Redesign to chop up caller's data.
 *                          Also does loops so we can remove them from the
 *                          kernel driver.
 *
 ***************************************************************************/

#include "drvlib.h"
#include <ntddwave.h>
#include <mmreg.h>

/*****************************************************************************

    internal declarations

 ****************************************************************************/

// Stack size for our auxiliary task

#define WAVE_STACK_SIZE 300

typedef enum {
    WaveThreadInvalid,
    WaveThreadAddBuffer,
    WaveThreadSetState,
    WaveThreadSetData,
    WaveThreadGetData,
    WaveThreadBreakLoop,
    WaveThreadClose,
    WaveThreadTerminate
} WAVETHREADFUNCTION;


#define MAX_BUFFER_SIZE           8192  // Largest buffer we send to device
#define MAX_WAVE_BYTES          5*8192  // Max bytes we have queued on was 22000

//
// Structure to hide our overlapped structure in so we can get some
// context on IO completion
//

typedef struct {
    OVERLAPPED Ovl;
    LPWAVEHDR WaveHdr;
} WAVEOVL, *PWAVEOVL;

// per allocation structure for wave
typedef struct tag_WAVEALLOC {
    struct tag_WAVEALLOC *Next;         // Chaining
    UINT                DeviceNumber;   // Which device
    UINT                DeviceType;     // WaveInput or WaveOutput
    DWORD_PTR           dwCallback;     // client's callback
    DWORD_PTR           dwInstance;     // client's instance data
    DWORD               dwFlags;        // Open flags
    HWAVE               hWave;          // handle for stream
    DWORD               dwStatus;       // Status bits (LowPri, etc)

    HANDLE              hDev;           // Wave device handle
    LPWAVEHDR           DeviceQueue;    // Buffers queued by application
    LPWAVEHDR           NextBuffer;     // Next buffer to send to device
    DWORD               BufferPosition; // How far we're into a large buffer
    DWORD               BytesOutstanding;
                                        // Bytes being processed by device
    LPWAVEHDR           LoopHead;       // Start of loop if any
    DWORD               LoopCount;      // Number more loops to go

    WAVEOVL             DummyWaveOvl;   // For break loop
                                                                                //
    HANDLE              Event;          // Event for driver syncrhonization
                                        // and notification of auxiliary
                                        // task operation completion.
    WAVETHREADFUNCTION  AuxFunction;    // Function for thread to perform
    union {
        LPWAVEHDR       pHdr;           // Buffer to pass in aux task
        ULONG           State;          // State to set
        struct {
            ULONG       Function;       // IOCTL to use
            PBYTE       pData;          // Data to set or get
            ULONG       DataLen;        // Length of data
        } GetSetData;

    } AuxParam;
                                        // 0 means terminate task.
    HANDLE              AuxEvent1;      // Aux thread waits on this
    HANDLE              AuxEvent2;      // Caller of Aux thread waits on this
    HANDLE              ThreadHandle;   // Handle for thread termination ONLY
    MMRESULT            AuxReturnCode;  // Return code from Aux task
}WAVEALLOC, *PWAVEALLOC;

PWAVEALLOC WaveHandleList;              // Our chain of wave handles


//
// extra flag to track buffer completion
//

#define WHDR_COMPLETE 0x80000000


//
// Status bits for WAVEALLOC.dwStatus
//
#define  WAVEALLOC_STATUS_LOWPRIORITY   0x00000001


/*****************************************************************************

    internal function prototypes

 ****************************************************************************/

STATIC MMRESULT waveGetDevCaps(DWORD id, UINT DeviceType, LPBYTE lpCaps,
                            DWORD dwSize);
STATIC DWORD    waveThread(LPVOID lpParameter);
STATIC void     waveCleanUp(PWAVEALLOC pClient);
STATIC MMRESULT waveThreadCall(WAVETHREADFUNCTION Function, PWAVEALLOC pClient);
STATIC MMRESULT waveSetState(PWAVEALLOC pClient, ULONG State);
STATIC MMRESULT waveWrite(LPWAVEHDR pHdr, PWAVEALLOC pClient);
STATIC void     waveBlockFinished(LPWAVEHDR lpHdr, DWORD MsgId);
STATIC void     waveCallback(PWAVEALLOC pWave, DWORD msg, DWORD_PTR dw1);
STATIC void     waveCompleteBuffers(PWAVEALLOC pClient);
STATIC void     waveFreeQ(PWAVEALLOC pClient);
STATIC void     waveOvl(DWORD dwErrorCode, DWORD BytesTransferred, LPOVERLAPPED pOverlapped);

/* Attempt to pre-touch up to MIN(iSize,PRETOUCHLIMIT) bytes on from pb.
   If AllowFault then keep going to fault the stuff in.
   Otherwise stop as soon as you notice the clock ticking
*/
//PreTouch(BYTE * pb, int iSize, BOOL AllowFault)
//{
//    DWORD dwTicks = GetTickCount();
//    int pages = 0;
//    static int Headway[100];
//    static int c = 0;
//    static int TotalTouches = 0;
//    static int TimesThrough = 0;   // number of times this code has run.
//
//    if (iSize > PRETOUCHLIMIT) {
//        iSize = PRETOUCHLIMIT;
//    }
//
//    ++TimesThrough;
//
//    // pre-touch the pages but get out if it's taking too long
//    // (which probably means we took a page fault.
//    // Touch at least 2 pages as we may want 2 pages per DMA 1/2 buffer.
//    while (iSize>0) {
//        volatile BYTE b;
//        b = *pb;
//        pb += 4096;    // move to next page.  Are they ALWAYS 4096?
//        iSize -= 4096; // and count it off
//        ++pages;
//        ++TotalTouches;
//        if (dwTicks<GetTickCount() && pages>1 && !AllowFault) break;
//    }
//    Headway[c] = pages;
//    ++c;
//
//    if (c==100){
//        for (c=0; c<=99; c += 10){
//            dprintf(("%5ld %5ld %5ld %5ld %5ld %5ld %5ld %5ld %5ld %5ld",Headway[c],Headway[c+1],Headway[c+2],Headway[c+3],Headway[c+4],Headway[c+5],Headway[c+6],Headway[c+7],Headway[c+8],Headway[c+9]));
//        }
//        dprintf((" "));
//        c = 0;
//    }
//}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api VOID | TerminateWave | Free all wave resources
 *
 * @rdesc None
 ***************************************************************************/
VOID TerminateWave(VOID)
{
#ifdef TERMINATE

    //
    // This is all wrong - we need to find out how to terminate threads !
    //

    PWAVEALLOC pClient;

    //
    // Remove all our threads and their resources
    //

    for (pClient = WaveHandleList; pClient != NULL; pClient = pClient->Next) {
        if (pClient->ThreadHandle) {
            //
            // Kill our thread.  But be careful !  It may
            // already have gone away - so don't wait for
            // it to set its event, just wait for it
            // to finish
            //

            //
            // Set the function code
            //
            pClient->AuxFunction = WaveThreadTerminate;

            //
            // Kick off the thread
            //
            SetEvent(pClient->AuxEvent1);

            //
            // We created our threads with mmTaskCreate so it's
            // safe to wait on them
            //
            WaitForSingleObject(pClient->ThreadHandle, INFINITE);
        }
        waveCleanUp(pClient);
    }
#endif
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveGetDevCaps | Get the device capabilities.
 *
 * @parm DWORD | id | Device id
 *
 * @parm UINT | DeviceType | type of device
 *
 * @parm LPBYTE | lpCaps | Far pointer to a WAVEOUTCAPS structure to
 *      receive the information.
 *
 * @parm DWORD | dwSize | Size of the WAVEOUTCAPS structure.
 *
 * @rdesc MMSYS.. return code.
 ***************************************************************************/
STATIC MMRESULT waveGetDevCaps(DWORD id, UINT DeviceType,
                            LPBYTE lpCaps, DWORD dwSize)
{
    MMRESULT mrc;

    if (DeviceType == WAVE_OUT) {
        WAVEOUTCAPSW wc;
        mrc = sndGetData(DeviceType, id, sizeof(wc), (LPBYTE)&wc,
                         IOCTL_WAVE_GET_CAPABILITIES);

        if (mrc != MMSYSERR_NOERROR) {
            return mrc;
        }
        InternalLoadString((UINT)*(LPDWORD)wc.szPname, wc.szPname,
                           sizeof(wc.szPname) / sizeof(WCHAR));

        CopyMemory(lpCaps, &wc, min(sizeof(wc), dwSize));
    } else {
        WAVEINCAPSW wc;
        mrc = sndGetData(DeviceType, id, sizeof(wc), (LPBYTE)&wc,
                         IOCTL_WAVE_GET_CAPABILITIES);

        if (mrc != MMSYSERR_NOERROR) {
            return mrc;
        }
        InternalLoadString((UINT)*(LPDWORD)wc.szPname, wc.szPname,
                           sizeof(wc.szPname) / sizeof(WCHAR));

        CopyMemory(lpCaps, &wc, min(sizeof(wc), dwSize));
    }

    return MMSYSERR_NOERROR;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | waveGetPos | Get the stream position in samples.
 *
 * @parm PWAVEALLOC | pClient | Client handle.
 *
 * @parm LPMMTIME | lpmmt | Far pointer to an MMTIME structure.
 *
 * @parm DWORD | dwSize | Size of the MMTIME structure.
 *
 * @rdesc MMSYS... return value.
 ***************************************************************************/
MMRESULT waveGetPos(PWAVEALLOC pClient, LPMMTIME lpmmt, DWORD dwSize)
{
    WAVE_DD_POSITION PositionData;
    MMRESULT mErr;

    if (dwSize < sizeof(MMTIME))
        return MMSYSERR_ERROR;

    //
    // Get the current position from the driver
    //
    mErr = sndGetHandleData(pClient->hDev,
                            sizeof(PositionData),
                            &PositionData,
                            IOCTL_WAVE_GET_POSITION,
                            pClient->Event);

    if (mErr == MMSYSERR_NOERROR) {
        if (lpmmt->wType == TIME_BYTES) {
            lpmmt->u.cb = PositionData.ByteCount;
        }

        // default is samples.
        else {
            lpmmt->wType = TIME_SAMPLES;
            lpmmt->u.sample = PositionData.SampleCount;
        }
    }

    return mErr;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | waveOpen | Open wave device and set up logical device data
 *    and auxilary task for issuing requests and servicing Apc's
 *
 * @parm WAVEDEVTYPE | DeviceType | Whether it's a wave input or output device
 *
 * @parm DWORD | id | The device logical id
 *
 * @parm DWORD | msg | Input parameter to wodMessage
 *
 * @parm DWORD | dwUser | Input parameter to wodMessage - pointer to
 *   application's handle (generated by this routine)
 *
 * @parm DWORD | dwParam1 | Input parameter to wodMessage
 *
 * @parm DWORD | dwParam2 | Input parameter to wodMessage
 *
 * @rdesc wodMessage return code.
 ***************************************************************************/

STATIC MMRESULT waveOpen(UINT  DeviceType,
                         DWORD id,
                         DWORD_PTR dwUser,
                         DWORD_PTR dwParam1,
                         DWORD_PTR dwParam2)
{
    PWAVEALLOC     pClient;  // pointer to client information structure
    MMRESULT mRet;
    BOOL Result;
    DWORD BytesReturned;
    LPWAVEFORMATEX Format;

    Format = (LPWAVEFORMATEX)((LPWAVEOPENDESC)dwParam1)->lpFormat;

    // dwParam1 contains a pointer to a WAVEOPENDESC
    // dwParam2 contains wave driver specific flags in the LOWORD
    // and generic driver flags in the HIWORD

    //
    // If it's only a query to check if the device supports our format
    // we :
    //     Open the device
    //     Test the format
    //     Close the device
    //

    if (dwParam2 & WAVE_FORMAT_QUERY) {
        HANDLE hDev;

        //
        // See if we can open our device
        // Only open for read (this should always work for our devices
        // unless there are system problems).
        //

        mRet = sndOpenDev(DeviceType,
                           id,
                           &hDev,
                           GENERIC_READ);

        if (mRet != MMSYSERR_NOERROR) {
	    D2(("drvlib: waveOpen, device=%x, QUERY failed to open",id));
            return mRet;
        }

        //
        // Check the format
        //

        Result = DeviceIoControl(
                        hDev,
                        IOCTL_WAVE_QUERY_FORMAT,
                        (PVOID)Format,
                        Format->wFormatTag == WAVE_FORMAT_PCM ?
                            sizeof(PCMWAVEFORMAT) :
                            sizeof(WAVEFORMATEX) + Format->cbSize,
                                                     // Input buffer size
                        NULL,                        // Output buffer
                        0,                           // Output buffer size
                        &BytesReturned,
                        NULL);


        //
        // Only a query so close the device
        //

        CloseHandle(hDev);
#if DBG
        {
	    MMRESULT mmr;
            mmr = Result ? MMSYSERR_NOERROR :
               GetLastError() == ERROR_NOT_SUPPORTED ? WAVERR_BADFORMAT :
                                                sndTranslateStatus();
	    D2(("drvlib: waveOpen, device=%x, QUERY returning %x",id, mmr));
	    return(mmr);
	}
#else
        return Result ? MMSYSERR_NOERROR :
               GetLastError() == ERROR_NOT_SUPPORTED ? WAVERR_BADFORMAT :
                                                sndTranslateStatus();
#endif
    }

    //
    // See if we've got this device already in our list (in
    // which case we have a thread and events for it already made)
    //

    EnterCriticalSection(&mmDrvCritSec);

    for (pClient = WaveHandleList;
         pClient != NULL;
         pClient = pClient->Next) {
        if (pClient->DeviceNumber == id &&
            pClient->DeviceType == DeviceType &&
            (!(pClient->dwStatus & WAVEALLOC_STATUS_LOWPRIORITY))  ) {

            //
            // We already have a thread and resources for this device
            //

            if (pClient->hDev != INVALID_HANDLE_VALUE) {
                //
                // Someone else is using it!
                //

                LeaveCriticalSection(&mmDrvCritSec);
                return MMSYSERR_ALLOCATED;
            }
            break;
        }
    }

    //
    // allocate my per-client structure and zero it (LPTR).
    //

    if (pClient == NULL) {
        pClient = (PWAVEALLOC)HeapAlloc(hHeap, 0, sizeof(WAVEALLOC));
        if (pClient == NULL) {
            LeaveCriticalSection(&mmDrvCritSec);
	    D3(("waveopen failing... NOMEM"));
            return MMSYSERR_NOMEM;
        }

        dprintf2(("Creating new device resource for device id %d, type %s",
                 id,
                 DeviceType == WAVE_IN ? "Wave Input" : "Wave Output"));

        memset((PVOID)pClient, 0, sizeof(WAVEALLOC));

        //  Make it look free
        pClient->hDev = INVALID_HANDLE_VALUE;

        //
        // Add it to the list
        //
        pClient->DeviceNumber = id;
        pClient->DeviceType = DeviceType;
        pClient->Next = WaveHandleList;
        WaveHandleList = pClient;
    } else {
        dprintf2(("Reusing old device resource for device id %d, type %s",
                 id,
                 DeviceType == WAVE_IN ? "Wave Input" : "Wave Output"));
    }


    //
    // and fill it with info
    //

    pClient->dwCallback  = ((LPWAVEOPENDESC)dwParam1)->dwCallback;
    pClient->dwInstance  = ((LPWAVEOPENDESC)dwParam1)->dwInstance;
    pClient->hWave       = ((LPWAVEOPENDESC)dwParam1)->hWave;
    pClient->dwFlags     = (DWORD)dwParam2;

    // pClient->hDev is initialized by sndOpenDev

    pClient->DeviceQueue = NULL;
    pClient->NextBuffer  = NULL;
    pClient->BufferPosition = 0;
    pClient->BytesOutstanding = 0;
    pClient->LoopHead    = NULL;
    pClient->LoopCount   = 0;

    //
    // See if we can open our device
    // We could get ERROR_BUSY if someone else has the device open
    // for writing.
    //

    mRet = sndOpenDev(DeviceType,
                      id,
                      &pClient->hDev,
                      (GENERIC_READ | GENERIC_WRITE));

    if (mRet != MMSYSERR_NOERROR) {

        WinAssert(pClient->hDev == INVALID_HANDLE_VALUE);
        LeaveCriticalSection(&mmDrvCritSec);
        return mRet;
    }


    //
    // make sure we can handle the format and set it.
    //

    Result = DeviceIoControl(
                 pClient->hDev,
                 IOCTL_WAVE_SET_FORMAT,
                 (PVOID)Format,
                 Format->wFormatTag == WAVE_FORMAT_PCM ?
                     sizeof(PCMWAVEFORMAT) :
                     sizeof(WAVEFORMATEX) + Format->cbSize,
                 NULL,                        // Output buffer
                 0,                           // Output buffer size
                 &BytesReturned,
                 NULL);


    if (!Result) {
        CloseHandle(pClient->hDev);
        pClient->hDev = INVALID_HANDLE_VALUE;
        LeaveCriticalSection(&mmDrvCritSec);
        return GetLastError() == ERROR_NOT_SUPPORTED ? WAVERR_BADFORMAT :
                                                sndTranslateStatus();
    }

    LeaveCriticalSection(&mmDrvCritSec);

    //
    // Create our event for synchronization with the kernel driver
    //

    if (!pClient->Event) {
        pClient->Event = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (pClient->Event == NULL) {
            waveCleanUp(pClient);
            return MMSYSERR_NOMEM;
        }
        //
        // Create our event for our thread to wait on
        //

        pClient->AuxEvent1 = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!pClient->AuxEvent1) {
            waveCleanUp(pClient);
            return MMSYSERR_NOMEM;
        }
        //
        // Create our event for waiting for the auxiliary thread
        //

        pClient->AuxEvent2 = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!pClient->AuxEvent2) {
            waveCleanUp(pClient);
            return MMSYSERR_NOMEM;
        }

        //
        // Create our auxiliary thread for sending buffers to the driver
        // and collecting Apcs
        //

        mRet = mmTaskCreate((LPTASKCALLBACK)waveThread,
                            &pClient->ThreadHandle,
                            (DWORD_PTR)pClient);

        if (mRet != MMSYSERR_NOERROR) {
            waveCleanUp(pClient);
            return MMSYSERR_NOMEM;
        }

        //
        // Make sure the thread has really started
        //

        WaitForSingleObject(pClient->AuxEvent2, INFINITE);
    }

    //
    // give the client my driver dw
    //
    {
        PWAVEALLOC *pUserHandle;
        pUserHandle = (PWAVEALLOC *)dwUser;
        *pUserHandle = pClient;
    }

    //
    // sent client his OPEN callback message
    //
    waveCallback(pClient, DeviceType == WAVE_OUT ? WOM_OPEN : WIM_OPEN, 0L);

    return MMSYSERR_NOERROR;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveCleanUp | Free resources for a wave device
 *
 * @parm PWAVEALLOC | pClient | Pointer to a WAVEALLOC structure describing
 *      resources to be freed.
 *
 * @rdesc There is no return value.
 *
 * @comm If the pointer to the resource is NULL then the resource has not
 *     been allocated.
 ***************************************************************************/
STATIC void waveCleanUp(PWAVEALLOC pClient)
{
    EnterCriticalSection(&mmDrvCritSec);
    if (pClient->hDev != INVALID_HANDLE_VALUE) {
        CloseHandle(pClient->hDev);
        pClient->hDev = INVALID_HANDLE_VALUE;
    }
    if (pClient->AuxEvent1) {
        CloseHandle(pClient->AuxEvent1);
        pClient->AuxEvent1 = NULL;
    }
    if (pClient->AuxEvent2) {
        CloseHandle(pClient->AuxEvent2);
        pClient->AuxEvent2 = NULL;
    }
    if (pClient->Event) {
        CloseHandle(pClient->Event);
        pClient->Event = NULL;
    }

    //
    //  Clean up low priority flag or our thread will be lost forever
    //
    pClient->dwStatus = 0;

    LeaveCriticalSection(&mmDrvCritSec);
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | waveWrite | Pass a new buffer to the Auxiliary thread for
 *       a wave device.
 *
 * @parm LPWAVEHDR | pHdr | Pointer to a wave buffer
 *
 * @parm PWAVEALLOC | pClient | The data associated with the logical wave
 *     device.
 *
 * @rdesc A MMSYS... type return code for the application.
 *
 * @comm The buffer flags are set and the buffer is passed to the auxiliary
 *     device task for processing.
 ***************************************************************************/
STATIC MMRESULT waveWrite(LPWAVEHDR pHdr, PWAVEALLOC pClient)
{
    //
    // Put the request at the end of our queue.
    //
    pHdr->dwFlags |= WHDR_INQUEUE;
    pHdr->dwFlags &= ~WHDR_DONE;
    pClient->AuxParam.pHdr = pHdr;
    return waveThreadCall(WaveThreadAddBuffer, pClient);
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | waveSetState | Set a wave device to a given state
 *     This function is executed on the Auxiliary thread to synchronize
 *     correctly.
 *
 * @parm PWAVEALLOC | pClient | The data associated with the logical wave
 *     output device.
 *
 * @parm ULONG | State | The new state
 *
 * @rdesc A MMSYS... type return code for the application.
 ***************************************************************************/
STATIC MMRESULT waveSetState(PWAVEALLOC pClient, ULONG State)
{
    return sndSetHandleData(pClient->hDev,
                            sizeof(State),
                            &State,
                            IOCTL_WAVE_SET_STATE,
                            pClient->Event);
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveBlockFinished | This function sets the done bit and invokes
 *     the callback function if there is one.
 *
 * @parm LPWAVEHDR | lpHdr | Far pointer to the header.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
STATIC void waveBlockFinished(LPWAVEHDR lpHdr, DWORD MsgId)
{
    PWAVEALLOC pWav;

    D3(("blkfin: lpHdr = %x", lpHdr));
    // Clear our private flag
    lpHdr->dwFlags &= ~WHDR_COMPLETE;

    // We are giving the block back to the application.  The header is no
    // longer in our queue, so we reset the WHDR_INQUEUE bit.  Also, we
    // clear our driver specific bit and cauterize the lpNext pointer.
    lpHdr->dwFlags &= ~WHDR_INQUEUE;
    lpHdr->lpNext = NULL;

    pWav = (PWAVEALLOC)(lpHdr->reserved);

    // set the 'done' bit - note that some people poll this bit.
    lpHdr->dwFlags |= WHDR_DONE;

    // invoke the callback function
    waveCallback(pWav, MsgId, (DWORD_PTR)lpHdr);
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | waveThreadCall | Set the function for the thread to perform
 *     and 'call' the thread using the event pair mechanism.
 *
 * @parm WAVETHREADFUNCTION | Function | The function to perform
 *
 * @parm PWAVEALLOC | Our logical device data
 *
 * @rdesc An MMSYS... type return value suitable for returning to the
 *      application
 *
 * @comm The AuxParam field in the device data is the 'input' to
 *      the function processing loop in WaveThread().
 ***************************************************************************/
STATIC MMRESULT waveThreadCall(WAVETHREADFUNCTION Function, PWAVEALLOC pClient)
{
    //
    // Trap any failures
    //
    WinAssert(pClient->hDev != INVALID_HANDLE_VALUE);

    //
    // Set the function code
    //
    pClient->AuxFunction = Function;

    //
    // Kick off the thread
    //
    SetEvent(pClient->AuxEvent1);

    //
    // Wait for it to complete
    //
    WaitForSingleObject(pClient->AuxEvent2, INFINITE);

    //
    // Return the return code that our task set.
    //

    D3(("waveThreadCall: function==%x, return=%x", Function, pClient->AuxReturnCode));
    return pClient->AuxReturnCode;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | wavePartialApc | Called when a partial buffer is complete.
 *
 * @parm DWORD | BytesTransferred | Not relevant to us
 *
 * @parm LPOVERLAPPED | pOverLapped | Overlapped structure for this callback
 *
 * @rdesc None
 *
 * @comm The IO status block is freed and the BytesOutstanding count
 *       used to limit the buffers we have locked down is updated (we
 *       know here that parital buffers are all the same size).
 *       Also the byte count for a recording buffer is updated.
 ***************************************************************************/
STATIC void wavePartialOvl(DWORD dwErrorCode, DWORD BytesTransferred, LPOVERLAPPED pOverlapped)
{
    LPWAVEHDR pHdr;
    PWAVEALLOC pClient;

    pHdr = ((PWAVEOVL)pOverlapped)->WaveHdr;
    D3(("wavePartialOvl: pHdr = %x", pHdr));

    pClient = (PWAVEALLOC)pHdr->reserved;

    //
    // We can't trust the IO system to return our buffers in the right
    // order so we set a flag in the buffer but only complete buffers
    // at the FRONT of the queue which have the flag set.  In fact
    // we don't process the stuff here - leave that for when we
    // exit the wait because calling the client's callback can
    // do nasty things inside and Apc routine
    //

    WinAssert(pHdr->dwFlags & WHDR_INQUEUE);
    WinAssert(!(pHdr->dwFlags & WHDR_COMPLETE));

    //
    // Recalculate how many bytes are outstanding on the device
    //

    pClient->BytesOutstanding -= MAX_BUFFER_SIZE;

    //
    // Work out how much was recorded if we're a recording device
    //

    if (pClient->DeviceType == WAVE_IN) {
        pHdr->dwBytesRecorded += BytesTransferred;
    }

    //
    // Free our Iosb
    //

    HeapFree(hHeap, 0, (LPSTR)pOverlapped);

}



/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveOvl | Called when a (user) buffer is complete.
 *
 * @parm DWORD | BytesTransferred | Not relevant to us
 *
 * @parm LPOVERLAPPED | pOverLapped | Overlapped structure for this callback
 *
 * @parm PIO_STATUS_BLOCK | The Io status block we used
 *
 * @rdesc None
 *
 * @comm The IO status block is freed and the BytesOutstanding count
 *       used to limit the buffers we have locked down is updated (we
 *       know here that parital buffers are all the same size so we
 *       can compute the size of the 'last' buffer for a given user buffer).
 *       Also the byte count for a recording buffer is updated.
 *       The user buffer is marked as 'DONE'.
 ***************************************************************************/
STATIC void waveOvl(DWORD dwErrorCode, DWORD BytesTransferred, LPOVERLAPPED pOverlapped)
{
    PWAVEHDR pHdr;
    PWAVEALLOC pClient;

    pHdr = ((PWAVEOVL)pOverlapped)->WaveHdr;
    D3(("waveOvl: pHdr = %x", pHdr));
    pClient = (PWAVEALLOC)pHdr->reserved;

    //
    // We can't trust the IO system to return our buffers in the right
    // order so we set a flag in the buffer but only complete buffers
    // at the FRONT of the queue which have the flag set.  In fact
    // we don't process the stuff here - leave that for when we
    // exit the wait because calling the client's callback can
    // do nasty things inside and Apc routine
    //

    WinAssert(pHdr->dwFlags & WHDR_INQUEUE);
    WinAssert(!(pHdr->dwFlags & WHDR_COMPLETE));

    //
    // Mark buffer as done unless we're doing more loops with it
    //
    pHdr->dwFlags |= WHDR_COMPLETE;

    //
    // It's now our duty to see if there were some old loops lying
    // around earlier in the queue which are vestiges of old loops.
    //

    if (pHdr->dwFlags & WHDR_BEGINLOOP) {
        PWAVEHDR pHdrSearch;
        for (pHdrSearch = pClient->DeviceQueue ;
             pHdrSearch != pHdr ;
             pHdrSearch = pHdrSearch->lpNext) {
            WinAssert(pHdrSearch != NULL);
            pHdrSearch->dwFlags |= WHDR_COMPLETE;
        }
    }
    //
    // Recalculate how many bytes are outstanding on the device
    //

    if (pHdr->dwBufferLength) {
        pClient->BytesOutstanding -= (pHdr->dwBufferLength - 1) %
                                         MAX_BUFFER_SIZE + 1;
    }

    //
    // Work out how much was recorded if we're a recording device
    //

    if (pClient->DeviceType == WAVE_IN) {
        pHdr->dwBytesRecorded += BytesTransferred;
    }

    //
    // Free our Iosb
    //

    HeapFree(hHeap, 0, (LPSTR)pOverlapped);

}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | waveLoopOvl | Called when a (user) buffer is complete.
 *                               but the buffer was need for more loops.
 *
 * @parm DWORD | BytesTransferred | Not relevant to us
 *
 * @parm LPOVERLAPPED | pOverLapped | Overlapped structure for this callback
 *
 * @rdesc None
 *
 * @comm Same as waveApc but the buffer is not marked complete.
 ***************************************************************************/
STATIC void waveLoopOvl(DWORD dwErrorCode, DWORD BytesTransferred, LPOVERLAPPED pOverlapped)
{
    DWORD dwFlags;
    PWAVEHDR pHdr;

    D3(("waveLoopOvl"));
    pHdr = ((PWAVEOVL)pOverlapped)->WaveHdr;

    //
    // Do it this way to avoid falling into a hole if the Apcs are
    // in the wrong order !!!
    //
    dwFlags = pHdr->dwFlags;
    waveOvl(dwErrorCode, BytesTransferred, pOverlapped);
    pHdr->dwFlags = dwFlags;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | waveBreakOvl | Used to chase out a buffer to break a loop.
 *
 * @parm DWORD | BytesTransferred | Not relevant to us
 *
 * @parm LPOVERLAPPED | pOverLapped | Overlapped structure for this callback
 *
 * @rdesc None
 *
 * @comm Mark the relevant buffer complete
 ***************************************************************************/
STATIC void waveBreakOvl(DWORD dwErrorCode, DWORD BytesTransferred, LPOVERLAPPED pOverlapped)
{
    D3(("waveBreakOvl"));
    ((PWAVEOVL)pOverlapped)->WaveHdr->dwFlags |= WHDR_COMPLETE;
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveStart | Send more buffers to the device if possible
 *
 * @parm PWAVEALLOC | pClient | The client's handle data
 *
 * @rdesc There is no return code.
 *
 * @comm  The routine is called both when new buffers become available
 *        or when old buffers or parital buffers are completed so
 *        that device can accept more data.
 *
 *        No more that MAX_WAVE_BYTES in buffers no bigger than
 *        MAX_BUFFER_SIZE are to be outstanding on the device at
 *        any one time.
 *
 *        An additional complication is that we have to process loops
 *        which means (among other things) that the SAME BUFFER may
 *        appear multiple times in the driver's list (as different
 *        requests).  There are no loops for input devices.
 *        Loop buffers complete with Apcs which do not complete them
 *        (except for the final loop iteration) which means that if
 *        we decide unexpectedly to finish a loop (ie by waveOutBreakLoop)
 *        we must 'chase' the loop out with an artificial buffer to
 *        get our Apc going.
 *
 ***************************************************************************/
STATIC MMRESULT waveStart(PWAVEALLOC pClient)
{
    DWORD dwSize;
    BOOL Result;

    //
    // See if we can fit any more data on the device
    //

    WinAssert(pClient->hDev != INVALID_HANDLE_VALUE);

    while (pClient->NextBuffer) {
        PWAVEHDR pHdr;

        pHdr = pClient->NextBuffer;

        WinAssert(pClient->DeviceQueue != NULL);
                WinAssert(!(pHdr->dwFlags & (WHDR_DONE | WHDR_COMPLETE)));

        dwSize = pHdr->dwBufferLength - pClient->BufferPosition;
        if (dwSize > MAX_BUFFER_SIZE) {
            dwSize = MAX_BUFFER_SIZE;
        }

        if (dwSize + pClient->BytesOutstanding <= MAX_WAVE_BYTES) {
            //
            // OK - we can fit another buffer in
            //
            // Don't have our overlay structure on the stack for an
            // ASYNCHRONOUS IO !   Otherwise the IO subsystem will overwrite
            // somebody else's data when the operation completes
            //
            PWAVEOVL pWaveOvl;
	    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine;

            if (pClient->BufferPosition == 0) {
                //
                // Start of new buffer
                // See if the buffer is the start of a new loop
                // (Check not continuation of old one)
                //
                if (pClient->NextBuffer &&
                    (pClient->NextBuffer->dwFlags & WHDR_BEGINLOOP) &&
                    pClient->NextBuffer != pClient->LoopHead) {

                    pClient->LoopHead = pClient->NextBuffer;

                    pClient->LoopCount = pClient->NextBuffer->dwLoops;

                    //
                    // Loop count is number of times to play
                    //
                    if (pClient->LoopCount > 0) {
                        pClient->LoopCount--;
                    }
                }
                //
                // See if the loop is actually finished
                //
                if (pClient->LoopCount == 0) {
                    pClient->LoopHead = NULL;
                }

            }

            pWaveOvl = (PWAVEOVL)HeapAlloc(hHeap, 0, sizeof(*pWaveOvl));

            if (pWaveOvl == NULL) {
                return MMSYSERR_NOMEM;
            }

            memset((PVOID)pWaveOvl, 0, sizeof(*pWaveOvl));

            pWaveOvl->WaveHdr = pHdr;

	    lpCompletionRoutine = pHdr->dwBufferLength !=
                                  pClient->BufferPosition + dwSize ?
				    wavePartialOvl :
				    NULL != pClient->LoopHead ?
                                      waveLoopOvl :
                                      waveOvl;

            if (pClient->DeviceType == WAVE_OUT) {
                Result =  WriteFileEx(
                              pClient->hDev,
                                (PBYTE)pHdr->lpData +        // Output buffer
                                    pClient->BufferPosition,
                              dwSize,
                              (LPOVERLAPPED)pWaveOvl,      // Overlap structure
                              lpCompletionRoutine);            // Overlap callback
            } else {
                Result =  ReadFileEx(
                              pClient->hDev,
                                (PBYTE)pHdr->lpData +        // Output buffer
                                    pClient->BufferPosition,
                              dwSize,
                              (LPOVERLAPPED)pWaveOvl,      // Overlap structure
                              lpCompletionRoutine);            // Overlap callback
            }

            dprintf3(("Sent/Read %u wave bytes to device, return code %8X",
                     dwSize, GetLastError()));

            if (!Result && GetLastError() != ERROR_IO_PENDING) {

                //
                // Free the Iosb since we won't be getting any callbacks
                //
                HeapFree(hHeap, 0, (LPSTR)pWaveOvl);

                //
                // If the driver has not got any bytes outstanding then
                // everything may grind to a halt so release everything
                // here and notify 'completion' (ie mark all buffers
                // complete).  This is unsatisfactory but there's no
                // way of telling the application what happenend.
                //

                if (pClient->BytesOutstanding == 0) {

                    //
                    // This will cause acknowlegements to be made when
                    // waveCompleteBuffers is run
                    //
                    waveFreeQ(pClient);
                }
                return sndTranslateStatus();

            } else {
                //
                // We successfully queued the buffer
                // Update our local data
                //
                pClient->BytesOutstanding += dwSize;
                pClient->BufferPosition += dwSize;
                if (pClient->BufferPosition == pHdr->dwBufferLength) {
                    //
                    // Finished this buffer - move on to the next
                    //
                    if (!pClient->LoopHead ||
                        !(pHdr->dwFlags & WHDR_ENDLOOP)) {
                        //
                        // Not end of in a loop so we can free this buffer
                        //
                        pClient->NextBuffer = pHdr->lpNext;

                    } else {
                        //
                        // Finished a loop
                        //
                        if (pClient->LoopCount != 0) {
                            pClient->LoopCount--;
                            pClient->NextBuffer = pClient->LoopHead;
                        } else {
                            //
                            // Someone's tried to kill us.  We have
                            // to 'chase out' the start of this loop
                            // so send a dummy (NULL) packet at the
                            // back of the driver's queue
                            //

                            pClient->DummyWaveOvl.WaveHdr = pClient->LoopHead;

                            Result =
                                WriteFileEx(
                                    pClient->hDev,
                                    (PVOID)pHdr->lpData,
                                    0,
                                    &pClient->DummyWaveOvl.Ovl, // Static for async
                                    waveBreakOvl);

                            if (Result || GetLastError() == ERROR_IO_PENDING) {
                                pClient->LoopHead = NULL; // Loop complete
                                pClient->NextBuffer = pHdr->lpNext;
                            }
                        }
                    }
                    pClient->BufferPosition = 0;
                }
            }
            {
            //    /* Before we go home, let's just touch ONE page - if there is one */
            //    PBYTE pb = (PBYTE)pHdr->lpData + pClient->BufferPosition;
            //    pb = ((DWORD)pb & 0xFFFFF000) + 0x1000;  /* find page start of next page */
            //
            //    if ( (PBYTE)pHdr->lpData + pHdr->dwBufferLength > pb )
            //        PreTouch( pb, 1, FALSE);

            //    /* Before we go home, let's just try to pre-touch that which we will soon want */
            //    PreTouch( (PBYTE)pHdr->lpData + pClient->BufferPosition
            //            , pHdr->dwBufferLength - pClient->BufferPosition
            //            , FALSE
            //            );
            }

        } else {
            //
            // Cannot fit any more bytes in at the moment
            //

//            /* Before we go home, let's just try to pre-touch that which we will soon want */
//            PreTouch( (PBYTE)pHdr->lpData + pClient->BufferPosition
//                    , pHdr->dwBufferLength - pClient->BufferPosition
//                    , FALSE
//                    );

            /* NOW go home! */
            break;
        }
    }
    return MMSYSERR_NOERROR;
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveCompleteBuffers | Buffer completion routine.  This completes
 *     the work of the Apc routine at below Apc priority.  This gets
 *     round the nasty situations arising when the user's callback
 *     causes more apcs to run (I strongly suspect this is a kernel
 *     bug).
 *
 * @parm PWAVEALLOC | pClient | The client's handle data
 *
 * @rdesc There is no return code.
 ***************************************************************************/
STATIC void waveCompleteBuffers(PWAVEALLOC pClient)
{
    //
    // Process buffers from the front of our queue unless we're in
    // a loop
    //

    while (pClient->DeviceQueue &&
           (pClient->DeviceQueue->dwFlags & WHDR_COMPLETE)) {

        PWAVEHDR pHdr;

        pHdr = pClient->DeviceQueue;
        //
        // Release buffer
        //
        pClient->DeviceQueue = pHdr->lpNext;


        //
        // Complete our buffer - note - this can cause another
        // buffer to be marked as complete if the client's
        // callback runs into an alertable wait.
        //

        waveBlockFinished(pHdr,
                          pClient->DeviceType == WAVE_OUT ?
                          WOM_DONE : WIM_DATA);
    }

    //
    // We might be able to start some more output at this point
    //

    waveStart(pClient);
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveFreeQ | Mark all outstanding buffers complete
 *
 * @parm PWAVEALLOC | pClient | The client's handle data
 *
 * @rdesc There is no return code.
 ***************************************************************************/
STATIC void waveFreeQ(PWAVEALLOC pClient)
{
    PWAVEHDR pHdr;
    for (pHdr = pClient->DeviceQueue;
         pHdr != NULL;
         pHdr = pHdr->lpNext) {
        pHdr->dwFlags |= WHDR_COMPLETE;
    }
        //
        // Tidy up next buffer
        //
        pClient->NextBuffer = NULL;
        pClient->BufferPosition = 0;
}

#if 0
typedef struct {
        LPBYTE Addr;
        DWORD  Len;
} PRETOUCHTHREADPARM;

/* asynchronous pre-toucher thread */
DWORD PreToucher(DWORD dw)
{
    PRETOUCHTHREADPARM * pttp;

    int iSize;
    BYTE * pb;

    pttp = (PRETOUCHTHREADPARM *) dw;
    iSize = pttp->Len;
    pb = pttp->Addr;

    LocalFree(pttp);

    while (iSize>0) {
        volatile BYTE b;
        b = *pb;
        pb += 4096;    // move to next page.  Are they ALWAYS 4096?
        iSize -= 4096; // and count it off
    }
    dprintf(("All pretouched!"));
    return 0;
}
#endif //0

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | waveThread | Wave device auxiliary thread.
 *
 * @parm LPVOID | lpParameter | The thread parameter.  In our case this is a
 *     pointer to our wave device data.
 *
 * @rdesc Thread return code.
 ***************************************************************************/
STATIC DWORD waveThread(LPVOID lpParameter)
{
    PWAVEALLOC pClient;
    BOOL Terminate;
//  DWORD dwThread;                   // garbage


    Terminate = FALSE;

    pClient = (PWAVEALLOC)lpParameter;

    //
    // Set our thread to high priority so we don't fail to pass
    // new buffers to the device
    //

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    //
    // We start by waiting for something signalling that we've started
    // and waiting for something to do.
    //

    SetEvent(pClient->AuxEvent2);
    WaitForSingleObject(pClient->AuxEvent1, INFINITE);

    //
    // Now we're going
    //

    for (;;) {
        WinAssert(pClient->hDev != INVALID_HANDLE_VALUE);

        //
        // Decode function number to perform
        //

        switch (pClient->AuxFunction) {
        case WaveThreadAddBuffer:
            //
            // Intialize bytes recorded
            //
            if (pClient->DeviceType == WAVE_IN) {
                pClient->AuxParam.pHdr->dwBytesRecorded = 0;
            }

            //
            // Add the buffer to our list
            //
            {
                LPWAVEHDR *pHdrSearch;

                pClient->AuxParam.pHdr->lpNext = NULL;

                pHdrSearch = &pClient->DeviceQueue;
                while (*pHdrSearch) {
                    pHdrSearch = &(*pHdrSearch)->lpNext;
                }

                *pHdrSearch = pClient->AuxParam.pHdr;
            }
//          {
//               PRETOUCHTHREADPARM * pttp;
//
//               pttp = LocalAlloc(LMEM_FIXED,8);
//
//               if (pttp!=NULL) {
//                   pttp->Addr = pClient->AuxParam.pHdr->lpData;
//                   pttp->Len = pClient->AuxParam.pHdr->dwBufferLength;
//                   CreateThread(NULL, 0, PreToucher, pttp, 0, &dwThread);
//               }
//          }
//          Would need to declutter the system by WAITing for dead threads at some point???

            //
            // See if we can send more to the driver
            //
            if (pClient->NextBuffer == NULL) {
                pClient->NextBuffer = pClient->AuxParam.pHdr;
                pClient->BufferPosition = 0;
            }


//            /* Before we waveStart, let's just try to pre-touch that which we will soon want */
//            {
//                PWAVEHDR pHdr = pClient->NextBuffer;
//                DWORD dwTick = GetTickCount();
//                PreTouch( (PBYTE)pHdr->lpData + pClient->BufferPosition
//                        , pHdr->dwBufferLength - pClient->BufferPosition
//                        , TRUE
//                        );
//                dprintf(("pre-touched out to limit. Took %d mSec", GetTickCount()-dwTick));
//            }

            pClient->AuxReturnCode = waveStart(pClient);
            break;

        case WaveThreadSetState:
            //
            // We have to make sure at least ONE buffer gets
            // completed if we're doing input and it's input.
            //



            //
            // Set Device state.  By issuing state changes on THIS
            // thread the calling thread can be sure that all Apc's
            // generated by buffer completions will complete
            // BEFORE this function completes.
            //

            pClient->AuxReturnCode =
                waveSetState(pClient, pClient->AuxParam.State);


            //
            // Free the rest of our buffers if we're resetting
            //

            if (pClient->AuxParam.State == WAVE_DD_RESET) {
                //
                // Cancel any loops
                //
                pClient->LoopHead = NULL;

                //
                // This function must ALWAYS succeed
                // Note that waveSetState closes the device on failure
                //
                pClient->AuxReturnCode = MMSYSERR_NOERROR;

                //
                // Check this worked (even if the driver's OK the
                // IO subsystem can fail)
                //
                WinAssert(pClient->BytesOutstanding == 0);

                //
                // Free all buffers
                //
                waveFreeQ(pClient);

            } else {
                if (pClient->DeviceType == WAVE_IN &&
                    pClient->AuxReturnCode == MMSYSERR_NOERROR) {

                    if (pClient->AuxParam.State == WAVE_DD_STOP) {
                        //
                        // We're sort of stuck - we want to complete this
                        // buffer but we've got it tied up in the device
                        // We'll reset it here although this erroneously
                        // sets the position to 0
                        //
                        if (pClient->DeviceQueue) {
                            while (!(pClient->DeviceQueue->dwFlags & WHDR_COMPLETE) &&
                                   pClient->BytesOutstanding != 0) {
                                waveSetState(pClient, WAVE_DD_RECORD);
                                pClient->AuxReturnCode =
                                    waveSetState(pClient, WAVE_DD_STOP);
                                if (pClient->AuxReturnCode != MMSYSERR_NOERROR) {
                                    break;
                                }
                            }
                            if (pClient->AuxReturnCode == MMSYSERR_NOERROR) {
                                pClient->DeviceQueue->dwFlags |= WHDR_COMPLETE;
                                                                //
                                                                // Tidy up next buffer
                                                                //
                                                                if (pClient->NextBuffer ==
                                                                    pClient->DeviceQueue) {
                                                                        pClient->NextBuffer =
                                                                            pClient->DeviceQueue->lpNext;
                                                                    pClient->BufferPosition = 0;
                                                            }
                            }
                        }
                    } else {
                        //
                        // If recording restore some buffers if necessary
                        //
                        if (pClient->AuxParam.State == WAVE_DD_RECORD) {
                            pClient->AuxReturnCode = waveStart(pClient);
                        }
                    }
                }
            }
            break;

        case WaveThreadGetData:
            {
                pClient->AuxReturnCode =
                    sndGetHandleData(pClient->hDev,
                                     pClient->AuxParam.GetSetData.DataLen,
                                     pClient->AuxParam.GetSetData.pData,
                                     pClient->AuxParam.GetSetData.Function,
                                     pClient->Event);
            }
            break;

        case WaveThreadSetData:
            {
                pClient->AuxReturnCode =
                    sndSetHandleData(pClient->hDev,
                                     pClient->AuxParam.GetSetData.DataLen,
                                     pClient->AuxParam.GetSetData.pData,
                                     pClient->AuxParam.GetSetData.Function,
                                     pClient->Event);
            }
            break;

        case WaveThreadBreakLoop:
            if (pClient->LoopHead) {
                //
                // If we're in a loop then exit the loop at the
                // end of the next iteration.
                //

                pClient->LoopCount = 0;
            }
            pClient->AuxReturnCode = MMSYSERR_NOERROR;
            break;

        case WaveThreadClose:
            //
            // Try to complete.
            // If we're completed all our buffers then we can.
            // otherwise we can't
            //
            if (pClient->DeviceQueue == NULL) {
                pClient->AuxReturnCode = MMSYSERR_NOERROR;
            } else {
                pClient->AuxReturnCode = WAVERR_STILLPLAYING;
            }
            break;

        case WaveThreadTerminate:
            Terminate = TRUE;
            break;


        default:
            WinAssert(FALSE);   // Invalid call
            break;
        }
        //
        // Trap invalid callers
        //
        pClient->AuxFunction = WaveThreadInvalid;

                //
                // See if any Apcs need completing
                //
                waveCompleteBuffers(pClient);

        //
        // Complete ? - don't set the event here.
        //
        if (Terminate) {
            return 1;
        }

        //
        // Release the thread caller
        //
        SetEvent(pClient->AuxEvent2);

        //
        // Wait for more !
        //

        while (WaitForSingleObjectEx(pClient->AuxEvent1, INFINITE, TRUE) ==
                   WAIT_IO_COMPLETION) {
                waveCompleteBuffers(pClient);
        }
    }

    return 1;      // Satisfy the compiler !
}



/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveCallback | This calls DriverCallback for a WAVEHDR.
 *
 * @parm PWAVEALLOC | pWave | Pointer to wave device.
 *
 * @parm DWORD | msg | The message.
 *
 * @parm DWORD | dw1 | message DWORD (dw2 is always set to 0).
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void waveCallback(PWAVEALLOC pWave, DWORD msg, DWORD_PTR dw1)
{

    // invoke the callback function, if it exists.  dwFlags contains
    // wave driver specific flags in the LOWORD and generic driver
    // flags in the HIWORD

    if (pWave->dwCallback)
        DriverCallback(pWave->dwCallback,       // user's callback DWORD
                       HIWORD(pWave->dwFlags),  // callback flags
                       (HDRVR)pWave->hWave,     // handle to the wave device
                       msg,                     // the message
                       pWave->dwInstance,       // user's instance data
                       dw1,                     // first DWORD
                       0L);                     // second DWORD
}



/****************************************************************************

    This function conforms to the standard Wave input driver message proc
    (widMessage), which is documented in mmddk.d.

****************************************************************************/
DWORD APIENTRY widMessage(DWORD id, DWORD msg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
    PWAVEALLOC pInClient;
    MMRESULT mRet;

    switch (msg) {

        case WIDM_GETNUMDEVS:
            D2(("WIDM_GETNUMDEVS"));
            return sndGetNumDevs(WAVE_IN);

        case WIDM_GETDEVCAPS:
            D2(("WIDM_GETDEVCAPS"));
            return waveGetDevCaps(id, WAVE_IN, (LPBYTE)dwParam1,
                                  (DWORD)dwParam2);

        case WIDM_OPEN:
            D2(("WIDM_OPEN, device id==%d", id));
            return waveOpen(WAVE_IN, id, dwUser, dwParam1, dwParam2);

        case WIDM_CLOSE:
            D2(("WIDM_CLOSE, device id==%d", id));
            pInClient = (PWAVEALLOC)dwUser;

            //
            // Call our task to see if it's ready to complete
            //
            mRet = waveThreadCall(WaveThreadClose, pInClient);
            if (mRet != MMSYSERR_NOERROR) {
                return mRet;
            }

            waveCallback(pInClient, WIM_CLOSE, 0L);

            //
            // Close our device
            //
            if (pInClient->hDev != INVALID_HANDLE_VALUE) {
                CloseHandle(pInClient->hDev);
            }

            EnterCriticalSection(&mmDrvCritSec);

            /* We must set the status to 0 otherwise this thread
               will never be used again if it the
               WAVEALLOC_STATUS_LOWPRIORITY flag was set.
            */
            pInClient->dwStatus = 0;

            /*  This makes this device free
            */
            pInClient->hDev = INVALID_HANDLE_VALUE;
            LeaveCriticalSection(&mmDrvCritSec);

            return MMSYSERR_NOERROR;

        case WIDM_ADDBUFFER:
            D2(("WIDM_ADDBUFFER, device id==%d", id));
            WinAssert(dwParam1 != 0);
            WinAssert(!(((LPWAVEHDR)dwParam1)->dwFlags & ~(WHDR_INQUEUE|WHDR_DONE|WHDR_PREPARED|WHDR_BEGINLOOP|WHDR_ENDLOOP)));

            ((LPWAVEHDR)dwParam1)->dwFlags &= (WHDR_INQUEUE|WHDR_DONE|WHDR_PREPARED);

            WinAssert(((LPWAVEHDR)dwParam1)->dwFlags & WHDR_PREPARED);

            // check if it's been prepared
            if (!(((LPWAVEHDR)dwParam1)->dwFlags & WHDR_PREPARED))
                return WAVERR_UNPREPARED;

            WinAssert(!(((LPWAVEHDR)dwParam1)->dwFlags & WHDR_INQUEUE));

            // if it is already in our Q, then we cannot do this
            if ( ((LPWAVEHDR)dwParam1)->dwFlags & WHDR_INQUEUE )
                return ( WAVERR_STILLPLAYING );

            // store the pointer to my WAVEALLOC structure in the wavehdr
            pInClient = (PWAVEALLOC)dwUser;
            ((LPWAVEHDR)dwParam1)->reserved = (DWORD_PTR)(LPSTR)pInClient;

            return waveWrite((LPWAVEHDR)dwParam1, pInClient);

        case WIDM_STOP:
            D2(("WIDM_STOP, device id==%d", id));
            pInClient = (PWAVEALLOC)dwUser;
            pInClient->AuxParam.State = WAVE_DD_STOP;
            return waveThreadCall(WaveThreadSetState, pInClient);

        case WIDM_START:
            D2(("WIDM_START, device id==%d", id));
            pInClient = (PWAVEALLOC)dwUser;
            pInClient->AuxParam.State = WAVE_DD_RECORD;
            return waveThreadCall(WaveThreadSetState, pInClient);

        case WIDM_RESET:
            D2(("WIDM_RESET, device id==%d", id));
            pInClient = (PWAVEALLOC)dwUser;
            pInClient->AuxParam.State = WAVE_DD_RESET;
            return waveThreadCall(WaveThreadSetState, pInClient);

        case WIDM_GETPOS:
            D2(("WIDM_GETPOS"));
            pInClient = (PWAVEALLOC)dwUser;
            return waveGetPos(pInClient, (LPMMTIME)dwParam1, (DWORD)dwParam2);

        /*
        **  Allow WOW version of WIDM_LOWPRIORITY
        */

        case WIDM_LOWPRIORITY:
        case MAKELONG(WIDM_LOWPRIORITY, 0xFFFF):
            D2(("WIDM_LOWPRIORITY, device id==%d", id));
            pInClient = (PWAVEALLOC)dwUser;

            pInClient->dwStatus |= WAVEALLOC_STATUS_LOWPRIORITY;

            return sndSetHandleData(pInClient->hDev,
                                    0,
                                    NULL,
                                    IOCTL_WAVE_SET_LOW_PRIORITY,
                                    pInClient->Event);


        default:
            return MMSYSERR_NOTSUPPORTED;
    }

    //
    // Should not get here
    //

    WinAssert(0);
    return MMSYSERR_NOTSUPPORTED;
}

/****************************************************************************

    This function conforms to the standard Wave output driver message proc
    (wodMessage), which is documented in mmddk.h.

****************************************************************************/
DWORD APIENTRY wodMessage(DWORD id, DWORD msg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
    PWAVEALLOC pOutClient;
    MMRESULT mRet;

    switch (msg) {
        case WODM_GETNUMDEVS:
            D2(("WODM_GETNUMDEVS"));
            return sndGetNumDevs(WAVE_OUT);

        case WODM_GETDEVCAPS:
            D2(("WODM_GETDEVCAPS, device id==%d", id));
            return waveGetDevCaps(id, WAVE_OUT, (LPBYTE)dwParam1,
                                  (DWORD)dwParam2);

        case WODM_OPEN:
            D2(("WODM_OPEN, device id==%d", id));
            return waveOpen(WAVE_OUT, id, dwUser, dwParam1, dwParam2);

        case WODM_CLOSE:
            D2(("WODM_CLOSE, device id==%d", id));
            pOutClient = (PWAVEALLOC)dwUser;

            //
            // Call our task to see if it's ready to complete
            //
            mRet = waveThreadCall(WaveThreadClose, pOutClient);
            if (mRet != MMSYSERR_NOERROR) {
                return mRet;
            }

            waveCallback(pOutClient, WOM_CLOSE, 0L);

            //
            // Close our device
            //
            if (pOutClient->hDev != INVALID_HANDLE_VALUE) {
                CloseHandle(pOutClient->hDev);

                EnterCriticalSection(&mmDrvCritSec);
                pOutClient->hDev = INVALID_HANDLE_VALUE;
                LeaveCriticalSection(&mmDrvCritSec);
            }

            return MMSYSERR_NOERROR;

        case WODM_WRITE:
            D3(("WODM_WRITE, device id==%d", id));
            WinAssert(dwParam1 != 0);
            WinAssert(!(((LPWAVEHDR)dwParam1)->dwFlags &
                     ~(WHDR_INQUEUE|WHDR_DONE|WHDR_PREPARED|
                       WHDR_BEGINLOOP|WHDR_ENDLOOP)));

            ((LPWAVEHDR)dwParam1)->dwFlags &=
                (WHDR_INQUEUE|WHDR_DONE|WHDR_PREPARED|
                 WHDR_BEGINLOOP|WHDR_ENDLOOP);

            WinAssert(((LPWAVEHDR)dwParam1)->dwFlags & WHDR_PREPARED);

            // check if it's been prepared
            if (!(((LPWAVEHDR)dwParam1)->dwFlags & WHDR_PREPARED))
                return WAVERR_UNPREPARED;

            WinAssert(!(((LPWAVEHDR)dwParam1)->dwFlags & WHDR_INQUEUE));

            // if it is already in our Q, then we cannot do this
            if ( ((LPWAVEHDR)dwParam1)->dwFlags & WHDR_INQUEUE )
                return ( WAVERR_STILLPLAYING );

            // store the pointer to my WAVEALLOC structure in the wavehdr
            pOutClient = (PWAVEALLOC)dwUser;
            ((LPWAVEHDR)dwParam1)->reserved = (DWORD_PTR)(LPSTR)pOutClient;

            return waveWrite((LPWAVEHDR)dwParam1, pOutClient);


        case WODM_PAUSE:
            D2(("WODM_PAUSE, device id==%d", id));
            pOutClient = (PWAVEALLOC)dwUser;
            pOutClient->AuxParam.State = WAVE_DD_STOP;
            return waveThreadCall(WaveThreadSetState, pOutClient);

        case WODM_RESTART:
            D2(("WODM_RESTART, device id==%d", id));
            pOutClient = (PWAVEALLOC)dwUser;
            pOutClient->AuxParam.State = WAVE_DD_PLAY;
            return waveThreadCall(WaveThreadSetState, pOutClient);

        case WODM_RESET:
            D2(("WODM_RESET, device id==%d", id));
            pOutClient = (PWAVEALLOC)dwUser;
            pOutClient->AuxParam.State = WAVE_DD_RESET;
            return waveThreadCall(WaveThreadSetState, pOutClient);

        case WODM_BREAKLOOP:
            pOutClient = (PWAVEALLOC)dwUser;
            D2(("WODM_BREAKLOOP, device id==%d", id));
            return waveThreadCall(WaveThreadBreakLoop, pOutClient);


        case WODM_GETPOS:
            D2(("WODM_GETPOS, device id==%d", id));
            pOutClient = (PWAVEALLOC)dwUser;
            return waveGetPos(pOutClient, (LPMMTIME)dwParam1, (DWORD)dwParam2);

        case WODM_SETPITCH:
            D2(("WODM_SETPITCH, device id==%d", id));
            pOutClient = (PWAVEALLOC)dwUser;
            pOutClient->AuxParam.GetSetData.pData = (PBYTE)&dwParam1;
            pOutClient->AuxParam.GetSetData.DataLen = sizeof(DWORD);
            pOutClient->AuxParam.GetSetData.Function = IOCTL_WAVE_SET_PITCH;
            return waveThreadCall(WaveThreadSetData, pOutClient);

        case WODM_SETVOLUME:
            D2(("WODM_SETVOLUME, device id==%d", id));
            //pOutClient = (PWAVEALLOC)dwUser;
            //pOutClient->AuxParam.GetSetData.pData = *(PBYTE *)&dwParam1;
            //pOutClient->AuxParam.GetSetData.DataLen = sizeof(DWORD);
            //pOutClient->AuxParam.GetSetData.Function = IOCTL_WAVE_SET_VOLUME;
            //return waveThreadCall(WaveThreadSetData, pOutClient);

            {
                //
                // Translate to device volume structure
                //

                WAVE_DD_VOLUME Volume;
                Volume.Left = LOWORD(dwParam1) << 16;
                Volume.Right = HIWORD(dwParam1) << 16;

                return sndSetData(WAVE_OUT, id, sizeof(Volume),
                                  (PBYTE)&Volume, IOCTL_WAVE_SET_VOLUME);
            }


        case WODM_SETPLAYBACKRATE:
            D2(("WODM_SETPLAYBACKRATE, device id==%d", id));
            pOutClient = (PWAVEALLOC)dwUser;
            pOutClient->AuxParam.GetSetData.pData = (PBYTE)&dwParam1;
            pOutClient->AuxParam.GetSetData.DataLen = sizeof(DWORD);
            pOutClient->AuxParam.GetSetData.Function =
                IOCTL_WAVE_SET_PLAYBACK_RATE;
            return waveThreadCall(WaveThreadSetData, pOutClient);

        case WODM_GETPITCH:
            D2(("WODM_GETPITCH, device id==%d", id));
            pOutClient = (PWAVEALLOC)dwUser;
            pOutClient->AuxParam.GetSetData.pData = (PBYTE)dwParam1;
            pOutClient->AuxParam.GetSetData.DataLen = sizeof(DWORD);
            pOutClient->AuxParam.GetSetData.Function = IOCTL_WAVE_GET_PITCH;
            return waveThreadCall(WaveThreadGetData, pOutClient);

        case WODM_GETVOLUME:
            D2(("WODM_GETVOLUME, device id==%d", id));
            //pOutClient = (PWAVEALLOC)dwUser;
            //pOutClient->AuxParam.GetSetData.pData = *(PBYTE *)&dwParam1;
            //pOutClient->AuxParam.GetSetData.DataLen = sizeof(DWORD);
            //pOutClient->AuxParam.GetSetData.Function = IOCTL_WAVE_GET_VOLUME;
            //return waveThreadCall(WaveThreadGetData, pOutClient);

            {
                //
                // Translate to device volume structure
                //

                WAVE_DD_VOLUME Volume;
                DWORD rc;

                rc = sndGetData(WAVE_OUT, id, sizeof(Volume),
                                (PBYTE)&Volume, IOCTL_WAVE_GET_VOLUME);

                if (rc == MMSYSERR_NOERROR) {
                    *(LPDWORD)dwParam1 =
                        (DWORD)MAKELONG(HIWORD(Volume.Left),
                                        HIWORD(Volume.Right));
                }

                return rc;
            }

        case WODM_GETPLAYBACKRATE:
            D2(("WODM_GETPLAYBACKRATE, device id==%d", id));
            pOutClient = (PWAVEALLOC)dwUser;
            pOutClient->AuxParam.GetSetData.pData = (PBYTE)dwParam1;
            pOutClient->AuxParam.GetSetData.DataLen = sizeof(DWORD);
            pOutClient->AuxParam.GetSetData.Function =
                IOCTL_WAVE_GET_PLAYBACK_RATE;
            return waveThreadCall(WaveThreadGetData, pOutClient);

        default:
            return MMSYSERR_NOTSUPPORTED;
    }

    //
    // Should not get here
    //

    WinAssert(0);
    return MMSYSERR_NOTSUPPORTED;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\synthlib\adlib.h ===
/*
 * Copyright (c) 1992-1994 Microsoft Corporation
 */

/*
 * definition of interface functions to the adlib midi device type.
 *
 * These functions are called from midi.c when the kernel driver
 * has decreed that this is an adlib-compatible device.
 *
 * Geraint Davies, Dec 92
 */


/*
 * Adlib_NoteOn - This turns a note on. (Including drums, with
 *	a patch # of the drum Note + 128)
 *
 * inputs
 *      BYTE    bPatch - MIDI patch number
 *	BYTE    bNote - MIDI note number
 *      BYTE    bChannel - MIDI channel #
 *	BYTE    bVelocity - Velocity #
 *	short   iBend - current pitch bend from -32768, to 32767
 * returns
 *	none
 */
VOID NEAR PASCAL Adlib_NoteOn (BYTE bPatch,
	BYTE bNote, BYTE bChannel, BYTE bVelocity,
	short iBend);



/* Adlib_NoteOff - This turns a note off. (Including drums,
 *	with a patch # of the drum note + 128)
 *
 * inputs
 *	BYTE    bPatch - MIDI patch #
 *	BYTE    bNote - MIDI note number
 *	BYTE    bChannel - MIDI channel #
 * returns
 *	none
 */
VOID FAR PASCAL Adlib_NoteOff (BYTE bPatch,
	BYTE bNote, BYTE bChannel);


/* Adlib_AllNotesOff - turn off all notes
 *
 * inputs - none
 * returns - none
 */
VOID Adlib_AllNotesOff(void);



/* Adlib_NewVolume - This should be called if a volume level
 *	has changed. This will adjust the levels of all the playing
 *	voices.
 *
 * inputs
 *	WORD	wLeft	- left attenuation (1.5 db units)
 *	WORD	wRight  - right attenuation (ignore if mono)
 * returns
 *	none
 */
VOID FAR PASCAL Adlib_NewVolume (WORD wLeft, WORD wRight);



/* Adlib_ChannelVolume - set the volume level for an individual channel.
 *
 * inputs
 * 	BYTE	bChannel - channel number to change
 *	WORD	wAtten	- attenuation in 1.5 db units
 *
 * returns
 *	none
 */
VOID FAR PASCAL Adlib_ChannelVolume(BYTE bChannel, WORD wAtten);
	


/* Adlib_SetPan - set the left-right pan position.
 *
 * inputs
 *      BYTE    bChannel  - channel number to alter
 *	BYTE	bPan   - 0 for left, 127 for right or somewhere in the middle.
 *
 * returns - none
 */
VOID FAR PASCAL Adlib_SetPan(BYTE bChannel, BYTE bPan);



/* Adlib_PitchBend - This pitch bends a channel.
 *
 * inputs
 *	BYTE    bChannel - channel
 *	short   iBend - Values from -32768 to 32767, being
 *			-2 to +2 half steps
 * returns
 *	none
 */
VOID NEAR PASCAL Adlib_PitchBend (BYTE bChannel, short iBend);



/* Adlib_BoardInit - initialise board and load patches as necessary.
 *
 * inputs - none
 * returns - 0 for success or the error code
 */
WORD Adlib_BoardInit(void);


/*
 * Adlib_BoardReset - silence the board and set all voices off.
 */
VOID Adlib_BoardReset(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\synthlib\driver.h ===
/****************************************************************************
 *
 *   driver.h
 *
 *   Copyright (c) 1991-1994 Microsoft Corporation
 *
 ***************************************************************************/

#include <drvlib.h>
#include <synth.h>




#define SR_ALERT_NORESOURCE     11
#define DATA_FMPATCHES          1234

#ifndef RC_INVOKED
#define RT_BINARY               MAKEINTRESOURCE( 256 )
#else
#define RT_BINARY               256
#endif



//
// Porting stuff
//

#define BCODE

#define fEnabled TRUE

#define AsULMUL(a, b) ((DWORD)((DWORD)(a) * (DWORD)(b)))
#define AsLSHL(a, b) ((DWORD)((DWORD)(a) << (DWORD)(b)))
#define AsULSHR(a, b) ((DWORD)((DWORD)(a) >> (DWORD)(b)))

#define AsMemCopy CopyMemory

extern HANDLE MidiDeviceHandle;
extern SYNTH_DATA DeviceData[];
extern int MidiPosition;
extern VOID MidiFlush(VOID);
extern VOID MidiCloseDevice(HANDLE DeviceHandle);
extern MMRESULT MidiOpenDevice(LPHANDLE lpHandle, BOOL Write);
extern MMRESULT MidiSetVolume(DWORD Left, DWORD Right);
extern VOID MidiCheckVolume(VOID);
extern MMRESULT MidiGetVolume(LPDWORD lpVolume);

#define SYNTH_DATA_SIZE 80

extern VOID FAR PASCAL MidiSendFM (DWORD wAddress, BYTE bValue);
extern VOID FAR PASCAL MidiNewVolume (WORD wLeft, WORD wRight);
extern WORD FAR PASCAL MidiInit (VOID);

extern BYTE gbVelocityAtten[32];

//
// End of porting stuff
//

/*
 * midi device type - determined by kernel driver
 */
UINT gMidiType;
/*
 * values for gMidiType - set in MidiOpenDevice
 */
#define TYPE_ADLIB	1
#define TYPE_OPL3	2


/*
 *  String IDs
 *  NOTE - these are shared with the drivers and should be made COMMON
 *  definitions
 */

#define SR_ALERT                1
#define SR_ALERT_NOPATCH        10

#define SYSEX_ERROR     0xFF    // internal error code for sysexes on input

#define STRINGLEN               (100)

/* volume defines */
#define VOL_MIDI                (0)
#define VOL_NUMVOL              (1)

#define VOL_LEFT                (0)
#define VOL_RIGHT               (1)

/* MIDI defines */

#define NUMCHANNELS                     (16)
#define NUMPATCHES                      (256)
#define DRUMCHANNEL                     (9)     /* midi channel 10 */

/****************************************************************************

       typedefs

 ***************************************************************************/


// per allocation structure for midi
typedef struct portalloc_tag {
    DWORD_PTR           dwCallback;     // client's callback
    DWORD_PTR           dwInstance;     // client's instance data
    HMIDIOUT            hMidi;          // handle for stream
    DWORD               dwFlags;        // allocation flags
}PORTALLOC, NEAR *NPPORTALLOC;




/****************************************************************************

       strings

 ***************************************************************************/

#define INI_STR_PATCHLIB TEXT("Patches")
#define INI_SOUND        TEXT("synth.ini")
#define INI_DRIVER       TEXT("Driver")


/****************************************************************************

       globals

 ***************************************************************************/

/* midi.c */
extern BYTE	gbMidiInUse;		/* if MIDI is in use */

extern HMODULE  ghModule;           // our module handle

/***************************************************************************

    prototypes

***************************************************************************/

/* midi.c */
VOID NEAR PASCAL MidiMessage (DWORD dwData);
DWORD APIENTRY modSynthMessage(UINT id,
        UINT msg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
UINT MidiOpen (VOID);
VOID MidiClose (VOID);
void MidiReset(void);






=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\synthlib\midint.c ===
/******************************************************************

    midint.c - midi routines for NT


    Copyright (c) 1991-1994 Microsoft Corporation

*******************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <devioctl.h>
#include <ntddwave.h>
#include <ntddmidi.h>
#include <ntddaux.h>
#include "driver.h"

//
// global variable saying whether the kernel driver thinks
// we have an opl3-type or an adlib-type device
//
UINT gMidiType;

//
// For NT we pipe the port writes to the kernel driver in batches.
// Each batch is a pair of port,data values in DeviceData.
//
// MidiPosition contains the next position to use in the array.

SYNTH_DATA DeviceData[SYNTH_DATA_SIZE];
int MidiPosition;
HANDLE MidiDeviceHandle;
static MIDI_DD_VOLUME MidiVolume;
static MIDI_DD_VOLUME CurrentVolume;

static OVERLAPPED WriteOverlapped;      // We need to use this, otherwise
                                // write file complains.

static OVERLAPPED VolumeOverlapped;// For asynch IO for volume notify

/*
 *  Translate a win error code (ERROR_...) to a multi-media error code
 *  (MMSYSERR_...).
 *
 */


/*************************************************************************
VolLinearToLog - converts a linear scale to logarithm
        0xffff -> 0
        0x0001 -> 191

inputs
        WORD    volume - 0 to 0xffff
returns
        BYTE    - value in decibels attenuation, each unit is 1.5 dB
*/
BYTE VolLinearToLog (WORD volume)
{
    WORD    gain, shift;
    WORD    temp;
    WORD    lut[16] = {0,0,0,1,1,1,2,2,2,2,3,3,3,3,3,3};
    BYTE    out;

    /* get an estimate to within 6 dB of gain */
    for (temp = volume, gain = 0, shift = 0;
        temp != 0;
        gain += 4, temp >>= 1, shift++);

    /* look at highest 3 bits in number into look-up-table to
        find how many more dB */
    if (shift > 5)
        temp = volume >> (shift - 5);
    else if (shift < 5)
        temp = volume << (5 - shift);
    else
        temp = volume;
    temp &= 0x000f;

    gain += lut[temp];

    out = (BYTE) ((16 * 4) + 3 - gain);
    return (out < 128) ? out : (BYTE)127;
}

/*
 *  Set the MIDI device volume
 */

VOID MidiSetTheVolume(DWORD Left, DWORD Right)
{
    CurrentVolume.Left = Left;
    CurrentVolume.Right = Right;


    //
    // Call the routine to store and set the settings
    //

    MidiNewVolume(VolLinearToLog(HIWORD(Left)), VolLinearToLog(HIWORD(Right)));
}

/*
 *  See if the device volume has changed, if it has then copy it
 *  to our local variables.
 *
 *  This is achieved by passing an IOCTL_SOUND_GET_CHANGED volume
 *  packet to the kernel driver then testing if it's completed.
 */

VOID MidiCheckVolume(VOID)
{
    DWORD BytesReturned;

    if (WaitForSingleObject(VolumeOverlapped.hEvent, 0) == 0) {
        //
        // We got a volume change - Set the volume we've now got
        //

        MidiSetTheVolume(MidiVolume.Left, MidiVolume.Right);

        //
        // Wait until the volume does not change (so the IO does
        // not complete
        //

        while (DeviceIoControl(MidiDeviceHandle,
                             IOCTL_SOUND_GET_CHANGED_VOLUME,
                             &MidiVolume,
                             sizeof(MidiVolume),
                             &MidiVolume,
                             sizeof(MidiVolume),
                             &BytesReturned,
                             &VolumeOverlapped)) {
            MidiSetTheVolume(MidiVolume.Left, MidiVolume.Right);
        }
        if (GetLastError() == ERROR_IO_PENDING) {
            //
            // This is what we want
            //
            return;
        } else {
            //
            // We failed so make sure the next caller doesn't hang!
            //
            SetEvent(VolumeOverlapped.hEvent);
        }
    }
}

/*
 *  Send any data in our output strem to the kernel driver
 */

VOID MidiFlush(VOID)
{

    DWORD BytesWritten;

    if (MidiPosition != 0) {
        WriteFile(MidiDeviceHandle,
                  DeviceData,
                  MidiPosition * sizeof(SYNTH_DATA),
                  &BytesWritten,
                  &WriteOverlapped);
    }

    //
    // We know our kernel driver doesn't operate asynchronously so
    // we don't need to wait for the write to complete.
    //

    MidiPosition = 0;
}

/*
 *  Close the kernel device (if write type)
 */

VOID MidiCloseDevice(HANDLE DeviceHandle)
{
   /*
    *  Close the device first to stop any more events
    */

    CloseHandle(DeviceHandle);
    CloseHandle(VolumeOverlapped.hEvent);
    CloseHandle(WriteOverlapped.hEvent);
    DeviceHandle = NULL;
    VolumeOverlapped.hEvent = NULL;
    WriteOverlapped.hEvent = NULL;

}

/*
 *  Open the kernel device corresponding to our midi device
 */

MMRESULT MidiOpenDevice(LPHANDLE lpHandle, BOOL Write)
{
    MMRESULT mmr;
    HANDLE   DeviceHandle;

    mmr = sndOpenDev(SYNTH_DEVICE, 0, &DeviceHandle,
                     Write ? GENERIC_READ | GENERIC_WRITE :
                             GENERIC_READ);

    if (mmr != MMSYSERR_NOERROR) {
        return mmr;
    }

    //
    // Load patches etc if we're actually going to write to the device
    //

    if (Write) {

         DWORD dwBytesReturned;

        /*
         * Try to set it into OPL3 mode
         */

         gMidiType = DeviceIoControl(DeviceHandle,
                                     IOCTL_MIDI_SET_OPL3_MODE,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     &dwBytesReturned,
                                     NULL) ?

                       TYPE_OPL3 : TYPE_ADLIB;

        /*
         * always call MidiInit, in case we have not loaded the patches
         * for this device type. MidiInit can have a static bInit if needed
         */
        MidiInit();

        //
        // Create an event for waiting for volume changes and an
        // event for writes.
        //

        VolumeOverlapped.hEvent = CreateEvent(NULL, FALSE, TRUE, NULL);

        if (VolumeOverlapped.hEvent == NULL) {
            CloseHandle(DeviceHandle);

            return sndTranslateStatus();
        }

        WriteOverlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (WriteOverlapped.hEvent == NULL) {
            CloseHandle(VolumeOverlapped.hEvent);
            CloseHandle(DeviceHandle);

            return sndTranslateStatus();
        }
    }

    //
    // Return our handle to the caller
    //

    *lpHandle = DeviceHandle;

    //
    // Set ourselves up to find out about volume changes
    //

    if (Write) {
        MidiCheckVolume();
    }


    return MMSYSERR_NOERROR;

}

/*
 *  Read the current volume setting direct from the kernel driver
 */

MMRESULT MidiGetVolume(LPDWORD lpVolume)
{
    HANDLE hDevice;
    MIDI_DD_VOLUME Vol;
    MMRESULT mRc;
    DWORD BytesReturned;

    //
    // Open a new device and get the volume
    //

    mRc = MidiOpenDevice(&hDevice, FALSE);   // Open for read only

    if (mRc == MMSYSERR_NOERROR) {

        if (!DeviceIoControl(hDevice,
                             IOCTL_MIDI_GET_VOLUME,
                             NULL,
                             0,
                             &Vol,
                             sizeof(MIDI_DD_VOLUME),
                             &BytesReturned,
                             NULL)) {
            mRc = sndTranslateStatus();
        } else {
            *lpVolume = (DWORD)MAKELONG(HIWORD(Vol.Left), HIWORD(Vol.Right));
        }
        CloseHandle(hDevice);
    }

    return mRc;
}

/*
 *  Set the volume by calling the kernel driver - this will cause our
 *  IOCTL_SOUND_GET_CHANGED_VOLUME packet to complete
 */

MMRESULT MidiSetVolume(DWORD Left, DWORD Right)
{
    HANDLE hDevice;
    MIDI_DD_VOLUME Vol;
    MMRESULT mRc;
    DWORD BytesReturned;

    //
    // Open a new device and set the volume
    //

    Vol.Left = Left;
    Vol.Right = Right;

    mRc = MidiOpenDevice(&hDevice, FALSE);   // Open for read only

    if (mRc == MMSYSERR_NOERROR) {

        if (!DeviceIoControl(hDevice,
                             IOCTL_MIDI_SET_VOLUME,
                             &Vol,
                             sizeof(MIDI_DD_VOLUME),
                             NULL,
                             0,
                             &BytesReturned,
                             NULL)) {
            mRc = sndTranslateStatus();
        }
        CloseHandle(hDevice);
    }

    return mRc;
}


/**************************************************************
 * MidiSendFM - Sends a byte to the FM chip.
 *
 * inputs
 *      WORD    wAddress - 0x00 to 0x1ff
 *      BYTE    bValue - value wirtten
 * returns
 *      none
 */
VOID FAR PASCAL MidiSendFM (DWORD wAddress, BYTE bValue)
{


    // NT :
    //
    // Pipe our port writes to the kernel driver
    // Note that MidiFlush is called again after each midi message
    // is processed by modMessage.
    //

    if (MidiPosition == SYNTH_DATA_SIZE) {
            MidiFlush();
    }

    DeviceData[MidiPosition].IoPort = wAddress < 0x100 ? 0x388 : 0x38a;
    DeviceData[MidiPosition].PortData = (WORD)(BYTE)wAddress;
    DeviceData[MidiPosition + 1].IoPort = wAddress < 0x100 ? 0x389 : 0x38b;
    DeviceData[MidiPosition + 1].PortData = (WORD)bValue;

    MidiPosition += 2;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\synthlib\opl3.c ===
/*
 * Copyright (c) 1992-1994 Microsoft Corporation
 */

/*
 * Interface functions for the OPL3 midi device type.
 *
 * These functions are called from midi.c when the kernel driver
 * has decreed that this is an opl3-compatible device.
 *
 * Geraint Davies, Dec 92
 */

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "driver.h"
#include "opl3.h"

#pragma pack(1)

/* --- typedefs ----------------------------------------------- */

/* typedefs for MIDI patches */
#define NUMOPS                  (4)
#define PATCH_1_4OP             (0) /* use 4-operator patch */
#define PATCH_2_2OP             (1) /* use two 2-operator patches */
#define PATCH_1_2OP             (2) /* use one 2-operator patch */

#define RIFF_PATCH              (mmioFOURCC('P','t','c','h'))
#define RIFF_FM4                (mmioFOURCC('f','m','4',' '))
#define NUM2VOICES              (18)            /* # 2operator voices */

typedef struct _operStruct {
    BYTE    bAt20;              /* flags which are send to 0x20 on fm */
    BYTE    bAt40;              /* flags seet to 0x40 */
                                /* the note velocity & midi velocity affect total level */
    BYTE    bAt60;              /* flags sent to 0x60 */
    BYTE    bAt80;              /* flags sent to 0x80 */
    BYTE    bAtE0;              /* flags send to 0xe0 */
} operStruct;

typedef struct _noteStruct {
    operStruct op[NUMOPS];      /* operators */
    BYTE    bAtA0[2];           /* send to 0xA0, A3 */
    BYTE    bAtB0[2];           /* send to 0xB0, B3 */
                                /* use in a patch, the block should be 4 to indicate
                                    normal pitch, 3 => octave below, etc. */
    BYTE    bAtC0[2];           /* sent to 0xc0, C3 */
    BYTE    bOp;                /* see PATCH_??? */
    BYTE    bDummy;             /* place holder */
} noteStruct;


typedef struct _patchStruct {
    noteStruct note;            /* note. This is all in the structure at the moment */
} patchStruct;
#pragma pack()

/* MIDI */

typedef struct _voiceStruct {
        BYTE    bNote;                  /* note played */
        BYTE    bChannel;               /* channel played on */
        BYTE    bPatch;                 /* what patch is the note,
                                           drums patch = drum note + 128 */
        BYTE    bOn;                    /* TRUE if note is on, FALSE if off */
        BYTE    bVelocity;              /* velocity */
        BYTE    bJunk;                  /* filler */
        DWORD   dwTime;                 /* time that was turned on/off;
                                           0 time indicates that its not in use */
        DWORD   dwOrigPitch[2];         /* original pitch, for pitch bend */
        BYTE    bBlock[2];              /* value sent to the block */
} voiceStruct;


/* --- module data -------------------------------------------- */

/* a bit of tuning information */
#define FSAMP                           (50000.0)     /* sampling frequency */
#define PITCH(x)                        ((DWORD)((x) * (double) (1L << 19) / FSAMP))
                                                        /* x is the desired frequency,
                                                                == FNUM at b=1 */
#define EQUAL                           (1.059463094359)
#ifdef EUROPE
#       define  A                                                       (442.0)
#else
#       define  A                           (440.0)
#endif
#define ASHARP                          (A * EQUAL)
#define B                               (ASHARP * EQUAL)
#define C                               (B * EQUAL / 2.0)
#define CSHARP                          (C * EQUAL)
#define D                               (CSHARP * EQUAL)
#define DSHARP                          (D * EQUAL)
#define E                               (DSHARP * EQUAL)
#define F                               (E * EQUAL)
#define FSHARP                          (F * EQUAL)
#define G                               (FSHARP * EQUAL)
#define GSHARP                          (G * EQUAL)

/* volume */
WORD    wSynthAttenL = 0;        /* in 1.5dB steps */
WORD    wSynthAttenR = 0;        /* in 1.5dB steps */

/* patch library */
patchStruct FAR * glpPatch = NULL;  /* points to the patches */

/* voices being played */
voiceStruct gVoice[NUM2VOICES];  /* info on what voice is where */
static DWORD gdwCurTime = 1;    /* for note on/off */

BYTE    gbCur4opReg = 0;                /* current value to 4-operator connection */

/* channel volumes */
BYTE    gbChanAtten[NUMCHANNELS];       /* attenuation of each channel, in .75 db steps */
BYTE    gbStereoMask[NUMCHANNELS];              /* mask for left/right for stereo midi files */
extern short  giBend[ NUMCHANNELS ] ;               // bend for each channel

/* operator offset location */
static WORD BCODE gw2OpOffset[ NUM2VOICES ][ 2 ] =
   {
     { 0x000,0x003 },
     { 0x001,0x004 },
     { 0x002,0x005 },
     { 0x008,0x00b },
     { 0x009,0x00c },
     { 0x00a,0x00d },
     { 0x010,0x013 },
     { 0x011,0x014 },
     { 0x012,0x015 },

     { 0x100,0x103 },
     { 0x101,0x104 },
     { 0x102,0x105 },
     { 0x108,0x10b },
     { 0x109,0x10c },
     { 0x10a,0x10d },
     { 0x110,0x113 },
     { 0x111,0x114 },
     { 0x112,0x115 },
   } ;

/* pitch values, from middle c, to octave above it */
static DWORD BCODE gdwPitch[12] = {
        PITCH(C), PITCH(CSHARP), PITCH(D), PITCH(DSHARP),
        PITCH(E), PITCH(F), PITCH(FSHARP), PITCH(G),
        PITCH(GSHARP), PITCH(A), PITCH(ASHARP), PITCH(B)};



/* --- internal functions -------------------------------------- */

//------------------------------------------------------------------------
//  VOID MidiFMNote
//
//  Description:
//     Turns on an FM-synthesizer note.
//
//  Parameters:
//     WORD wNote
//        the note number from 0 to NUMVOICES
//
//     noteStruct FAR *lpSN
//        structure containing information about what
//        is to be played.
//
//  Return Value:
//     Nothing.
//
//
//------------------------------------------------------------------------

VOID NEAR PASCAL Opl3_FMNote
(
    WORD                wNote,
    noteStruct FAR *    lpSN
)
{
   WORD            i ;
   WORD            wOffset ;
   operStruct FAR  *lpOS ;

   // D1( "\nMidiFMNote" ) ;

   // write out a note off, just to make sure...

   wOffset =
      (wNote < (NUM2VOICES / 2)) ? wNote : (wNote + 0x100 - 9) ;
   MidiSendFM( AD_BLOCK + wOffset, 0 ) ;

   // writing the operator information

//   for (i = 0; i < (WORD)((wNote < NUM4VOICES) ? NUMOPS : 2); i++)
   for (i = 0; i < 2; i++)
   {
      lpOS = &lpSN -> op[ i ] ;
      wOffset = gw2OpOffset[ wNote ][ i ] ;
      MidiSendFM( 0x20 + wOffset, lpOS -> bAt20) ;
      MidiSendFM( 0x40 + wOffset, lpOS -> bAt40) ;
      MidiSendFM( 0x60 + wOffset, lpOS -> bAt60) ;
      MidiSendFM( 0x80 + wOffset, lpOS -> bAt80) ;
      MidiSendFM( 0xE0 + wOffset, lpOS -> bAtE0) ;

#ifdef DEBUG
{
   char  szDebug[ 80 ] ;

   wsprintf( szDebug, "20=%02x 40=%02x 60=%02x 80=%02x E0=%02x",
             lpOS -> bAt20, lpOS -> bAt40, lpOS -> bAt60,
             lpOS -> bAt80, lpOS -> bAtE0 ) ;
   D1( szDebug ) ;
}
#endif

   }

   // write out the voice information

   wOffset = (wNote < 9) ? wNote : (wNote + 0x100 - 9) ;
   MidiSendFM( 0xa0 + wOffset, lpSN -> bAtA0[ 0 ] ) ;
   MidiSendFM( 0xc0 + wOffset, lpSN -> bAtC0[ 0 ] ) ;

   // Note on...

   MidiSendFM( 0xb0 + wOffset,
               (BYTE)(lpSN -> bAtB0[ 0 ] | 0x20) ) ;

#ifdef NOT_USED
{
   char  szDebug[ 80 ] ;

   wsprintf( szDebug, "A0=%02x B0=%02x C0=%02x", lpSN -> bAtA0[ 0 ],
             lpSN -> bAtB0[ 0 ], lpSN -> bAtC0[ 0 ] ) ;
   D1( szDebug ) ;
}
#endif


} // end of MidiFMNote()

//------------------------------------------------------------------------
//  WORD MidiFindEmptySlot
//
//  Description:
//     This finds an empty note-slot for a MIDI voice.
//     If there are no empty slots then this looks for the oldest
//     off note.  If this doesn't work then it looks for the oldest
//     on-note of the same patch.  If all notes are still on then
//     this finds the oldests turned-on-note.
//
//  Parameters:
//     BYTE bPatch
//        MIDI patch that will replace it.
//
//  Return Value:
//     WORD
//        note slot #
//
//
//------------------------------------------------------------------------

WORD NEAR PASCAL Opl3_FindEmptySlot
(
    BYTE            bPatch
)
{
   WORD   i, found ;
   DWORD  dwOldest ;

   // D1( "\nMidiFindEmptySlot" ) ;

   // First, look for a slot with a time == 0

   for (i = 0;  i < NUM2VOICES; i++)
      if (!gVoice[ i ].dwTime)
         return ( i ) ;

   // Now, look for a slot of the oldest off-note

   dwOldest = 0xffffffff ;
   found = 0xffff ;

   for (i = 0; i < NUM2VOICES; i++)
      if (!gVoice[ i ].bOn && (gVoice[ i ].dwTime < dwOldest))
      {
         dwOldest = gVoice[ i ].dwTime ;
         found = i ;
      }
   if (found != 0xffff)
      return ( found ) ;

   // Now, look for a slot of the oldest note with
   // the same patch

   dwOldest = 0xffffffff ;
   found = 0xffff ;
   for (i = 0; i < NUM2VOICES; i++)
      if ((gVoice[ i ].bPatch == bPatch) && (gVoice[ i ].dwTime < dwOldest))
      {
         dwOldest = gVoice[ i ].dwTime ;
         found = i ;
      }
   if (found != 0xffff)
      return ( found ) ;

   // Now, just look for the oldest voice

   found = 0 ;
   dwOldest = gVoice[ found ].dwTime ;
   for (i = (found + 1); i < NUM2VOICES; i++)
      if (gVoice[ i ].dwTime < dwOldest)
      {
         dwOldest = gVoice[ i ].dwTime ;
         found = i ;
      }

   return ( found ) ;

} // end of MidiFindEmptySlot()

//------------------------------------------------------------------------
//  WORD MidiFindFullSlot
//
//  Description:
//     This finds a slot with a specific note, and channel.
//     If it is not found then 0xFFFF is returned.
//
//  Parameters:
//     BYTE bNote
//        MIDI note number
//
//     BYTE bChannel
//        MIDI channel #
//
//  Return Value:
//     WORD
//        note slot #, or 0xFFFF if can't find it
//
//
//------------------------------------------------------------------------

WORD NEAR PASCAL Opl3_FindFullSlot
(
    BYTE            bNote,
    BYTE            bChannel
)
{
   WORD  i ;

   // D1( "\nMidiFindFullSlot" ) ;

   for (i = 0; i < NUM2VOICES; i++)
      if ((bChannel == gVoice[ i ].bChannel) &&
          (bNote == gVoice[ i ].bNote) && (gVoice[ i ].bOn))
   return ( i ) ;

   // couldn't find it

   return ( 0xFFFF ) ;

} // end of MidiFindFullSlot()

/**************************************************************
Opl3_CalcBend - This calculates the effects of pitch bend
        on an original value.

inputs
        DWORD   dwOrig - original frequency
        short   iBend - from -32768 to 32768, -2 half steps to +2
returns
        DWORD - new frequency
*/
DWORD NEAR PASCAL Opl3_CalcBend (DWORD dwOrig, short iBend)
{
    DWORD   dw;
    // D1 (("Opl3_CalcBend"));

    /* do different things depending upon positive or
        negative bend */
    if (iBend > 0)
    {
        dw = (DWORD)((iBend * (LONG)(256.0 * (EQUAL * EQUAL - 1.0))) >> 8);
        dwOrig += (DWORD)(AsULMUL(dw, dwOrig) >> 15);
    }
    else if (iBend < 0)
    {
        dw = (DWORD)(((-iBend) * (LONG)(256.0 * (1.0 - 1.0 / EQUAL / EQUAL))) >> 8);
        dwOrig -= (DWORD)(AsULMUL(dw, dwOrig) >> 15);
    }

    return dwOrig;
}


/*****************************************************************
Opl3_CalcFAndB - Calculates the FNumber and Block given
        a frequency.

inputs
        DWORD   dwPitch - pitch
returns
        WORD - High byte contains the 0xb0 section of the
                        block and fNum, and the low byte contains the
                        0xa0 section of the fNumber
*/
WORD NEAR PASCAL Opl3_CalcFAndB (DWORD dwPitch)
{
    BYTE    bBlock;

    // D1(("Opl3_CalcFAndB"));
    /* bBlock is like an exponential to dwPitch (or FNumber) */
    for (bBlock = 1; dwPitch >= 0x400; dwPitch >>= 1, bBlock++)
        ;

    if (bBlock > 0x07)
        bBlock = 0x07;  /* we cant do anything about this */

    /* put in high two bits of F-num into bBlock */
    return ((WORD) bBlock << 10) | (WORD) dwPitch;
}


/**************************************************************
Opl3_CalcVolume - This calculates the attenuation for an operator.

inputs
        BYTE    bOrigAtten - original attenuation in 0.75 dB units
        BYTE    bChannel - MIDI channel
        BYTE    bVelocity - velocity of the note
        BYTE    bOper - operator number (from 0 to 3)
        BYTE    bMode - voice mode (from 0 through 7 for
                                modulator/carrier selection)
returns
        BYTE - new attenuation in 0.75 dB units, maxing out at 0x3f.
*/
BYTE NEAR PASCAL Opl3_CalcVolume (BYTE bOrigAtten, BYTE bChannel,
        BYTE bVelocity, BYTE bOper, BYTE bMode)
{
    BYTE        bVolume;
    WORD        wTemp;
    WORD        wMin;

    switch (bMode) {
        case 0:
                bVolume = (BYTE)(bOper == 3);
                break;
        case 1:
                bVolume = (BYTE)((bOper == 1) || (bOper == 3));
                break;
        case 2:
                bVolume = (BYTE)((bOper == 0) || (bOper == 3));
                break;
        case 3:
                bVolume = (BYTE)(bOper != 1);
                break;
        case 4:
                bVolume = (BYTE)((bOper == 1) || (bOper == 3));
                break;
        case 5:
                bVolume = (BYTE)(bOper >= 1);
                break;
        case 6:
                bVolume = (BYTE)(bOper <= 2);
                break;
        case 7:
                bVolume = TRUE;
                break;
        };
    if (!bVolume)
        return bOrigAtten; /* this is a modulator wave */

    wMin =(wSynthAttenL < wSynthAttenR) ? wSynthAttenL : wSynthAttenR;
    wTemp = bOrigAtten + ((wMin << 1) +
        gbChanAtten[bChannel] + gbVelocityAtten[bVelocity >> 2]);
    return (wTemp > 0x3f) ? (BYTE) 0x3f : (BYTE) wTemp;
}

/**************************************************************
Opl3_CalcStereoMask - This calculates the stereo mask.

inputs
        BYTE    bChannel - MIDI channel
returns
        BYTE - mask (for register 0xc0-c8) for eliminating the
                left/right/both channels
*/
BYTE NEAR PASCAL Opl3_CalcStereoMask (BYTE bChannel)
{
    WORD        wLeft, wRight;

    /* figure out the basic levels of the 2 channels */
    wLeft = (wSynthAttenL << 1) + gbChanAtten[bChannel];
    wRight = (wSynthAttenR << 1) + gbChanAtten[bChannel];

    /* if both are too quiet then mask to nothing */
    if ((wLeft > 0x3f) && (wRight > 0x3f))
        return 0xcf;

    /* if one channel is significantly quieter than the other than
        eliminate it */
    if ((wLeft + 8) < wRight)
        return (BYTE)(0xef & gbStereoMask[bChannel]);   /* right is too quiet so eliminate */
    else if ((wRight + 8) < wLeft)
        return (BYTE)(0xdf & gbStereoMask[bChannel]);   /* left too quiet so eliminate */
    else
        return (BYTE)(gbStereoMask[bChannel]);  /* use both channels */
}



//------------------------------------------------------------------------
//  VOID MidiNewVolume
//
//  Description:
//     This should be called if a volume level has changed.
//     This will adjust the levels of all the playing voices.
//
//  Parameters:
//     BYTE bChannel
//        channel # of 0xFF for all channels
//
//  Return Value:
//     Nothing.
//
//
//------------------------------------------------------------------------

VOID FAR PASCAL Opl3_setvolume
(
    BYTE            bChannel
)
{
   WORD            i, j, wTemp, wOffset ;
   noteStruct FAR  *lpPS ;
   BYTE            bMode, bStereo ;

   // Make sure that we are actually open...

   if (!glpPatch)
      return ;

   // Loop through all the notes looking for the right
   // channel.  Anything with the right channel gets
   // its pitch bent.

   for (i = 0; i < NUM2VOICES; i++)
      if ((gVoice[ i ].bChannel == bChannel) || (bChannel == 0xff))
      {
         // Get a pointer to the patch

         lpPS = &(glpPatch + gVoice[ i ].bPatch) -> note ;

         // Modify level for each operator, but only if they
         // are carrier waves...

         bMode = (BYTE) ( (lpPS->bAtC0[0] & 0x01) * 2 + 4);

         for (j = 0; j < 2; j++)
          {
            wTemp =
               (BYTE) Opl3_CalcVolume( (BYTE)(lpPS -> op[ j ].bAt40 & (BYTE) 0x3f),
                                       gVoice[ i ].bChannel,
                                       gVoice[i].bVelocity, (BYTE) j, bMode ) ;

            // Write the new value out.

            wOffset = gw2OpOffset[ i ][ j ] ;
            MidiSendFM( 0x40 + wOffset,
                        (BYTE) ((lpPS -> op[ j ].bAt40 & (BYTE)0xc0) |
                                (BYTE) wTemp) ) ;
         }

         // Do stereo panning, but cutting off a left or right
         // channel if necessary.

         bStereo = Opl3_CalcStereoMask( gVoice[ i ].bChannel ) ;
         wOffset = (i < (NUM2VOICES / 2)) ? i : (i + 0x100 - 9) ;
         MidiSendFM( 0xc0 + wOffset, (BYTE)(lpPS -> bAtC0[ 0 ] & bStereo) ) ;
      }

} // end of MidiNewVolume()

//------------------------------------------------------------------------
//  WORD MidiNoteOn
//
//  Description:
//     This turns on a note, including drums with a patch # of the
//     drum note + 0x80.
//
//  Parameters:
//     BYTE bPatch
//        MIDI patch
//
//     BYTE bNote
//        MIDI note
//
//     BYTE bChannel
//        MIDI channel
//
//     BYTE bVelocity
//        velocity value
//
//     short iBend
//        current pitch bend from -32768 to 32767
//
//  Return Value:
//     WORD
//        note slot #, or 0xFFFF if it is inaudible
//
//
//------------------------------------------------------------------------

VOID NEAR PASCAL Opl3_NoteOn
(
    BYTE            bPatch,
    BYTE            bNote,
    BYTE            bChannel,
    BYTE            bVelocity,
    short           iBend
)
{
   WORD             wTemp, i, j ;
   BYTE             b4Op, bTemp, bMode, bStereo ;
   patchStruct FAR  *lpPS ;
   DWORD            dwBasicPitch, dwPitch[ 2 ] ;
   noteStruct       NS ;

   // D1( "\nMidiNoteOn" ) ;

   // Get a pointer to the patch

   lpPS = glpPatch + bPatch ;

#ifdef DEBUG
{
   char szDebug[ 80 ] ;

   wsprintf( szDebug, "bPatch = %d, bNote = %d", bPatch, bNote ) ;
   D1( szDebug ) ;
}
#endif

   // Find out the basic pitch according to our
   // note value.  This may be adjusted because of
   // pitch bends or special qualities for the note.

   dwBasicPitch = gdwPitch[ bNote % 12 ] ;
   bTemp = bNote / (BYTE) 12 ;
   if (bTemp > (BYTE) (60 / 12))
      dwBasicPitch = AsLSHL( dwBasicPitch, (BYTE)(bTemp - (BYTE)(60/12)) ) ;
   else if (bTemp < (BYTE) (60/12))
      dwBasicPitch = AsULSHR( dwBasicPitch, (BYTE)((BYTE) (60/12) - bTemp) ) ;

   // Copy the note information over and modify
   // the total level and pitch according to
   // the velocity, midi volume, and tuning.

   AsMemCopy( (LPSTR) &NS, (LPSTR) &lpPS -> note, sizeof( noteStruct ) ) ;
   b4Op = (BYTE)(NS.bOp != PATCH_1_2OP) ;

//   for (j = 0; j < (WORD)(b4Op ? 2 : 1); j++)
   for (j = 0; j < 2; j++)
   {
      // modify pitch

      dwPitch[ j ] = dwBasicPitch ;
      bTemp = (BYTE)((NS.bAtB0[ j ] >> 2) & 0x07) ;
      if (bTemp > 4)
         dwPitch[ j ] = AsLSHL( dwPitch[ j ], (BYTE)(bTemp - (BYTE)4) ) ;
      else if (bTemp < 4)
         dwPitch[ j ] = AsULSHR( dwPitch[ j ], (BYTE)((BYTE)4 - bTemp) ) ;

      wTemp = Opl3_CalcFAndB( Opl3_CalcBend( dwPitch[ j ], iBend ) ) ;
      NS.bAtA0[ j ] = (BYTE) wTemp ;
      NS.bAtB0[ j ] = (BYTE) 0x20 | (BYTE) (wTemp >> 8) ;
   }

   // Modify level for each operator, but only
   // if they are carrier waves

//   if (b4Op)
//   {
//      bMode = (BYTE)((NS.bAtC0[ 0 ] & 0x01) * 2 | (NS.bAtC0[ 1 ] & 0x01)) ;
//      if (NS.bOp == PATCH_2_2OP)
//         bMode += 4 ;
//   }
//   else
      bMode = (BYTE) ((NS.bAtC0[ 0 ] & 0x01) * 2 + 4) ;

//   for (i = 0; i < (WORD)(b4Op ? NUMOPS : 2); i++)
   for (i = 0; i < 2; i++)
   {
      wTemp =
         (BYTE) Opl3_CalcVolume ( (BYTE)(NS.op[ i ].bAt40 & (BYTE) 0x3f),
                                 bChannel, bVelocity, (BYTE) i, bMode ) ;
      NS.op[ i ].bAt40 = (NS.op[ i ].bAt40 & (BYTE)0xc0) | (BYTE) wTemp ;
   }

   // Do stereo panning, but cutting off a left or
   // right channel if necessary...

   bStereo = Opl3_CalcStereoMask( bChannel ) ;
   NS.bAtC0[ 0 ] &= bStereo ;
//   if (b4Op)
//      NS.bAtC0[ 1 ] &= bStereo ;

   // Find an empty slot, and use it...

//   wTemp = Opl3_FindEmptySlot( bPatch, b4Op ) ;
   wTemp = Opl3_FindEmptySlot( bPatch ) ;

#ifdef DEBUG
{
   char  szDebug[ 80 ] ;

   wsprintf( szDebug, "Found empty slot: %d", wTemp ) ;
   D1( szDebug ) ;

}
#endif

   Opl3_FMNote( wTemp, &NS ) ;
   gVoice[ wTemp ].bNote = bNote ;
   gVoice[ wTemp ].bChannel = bChannel ;
   gVoice[ wTemp ].bPatch = bPatch ;
   gVoice[ wTemp ].bVelocity = bVelocity ;
   gVoice[ wTemp ].bOn = TRUE ;
   gVoice[ wTemp ].dwTime = gdwCurTime++ ;
   gVoice[ wTemp ].dwOrigPitch[0] = dwPitch[ 0 ] ;  // not including bend
   gVoice[ wTemp ].dwOrigPitch[1] = dwPitch[ 1 ] ;  // not including bend
   gVoice[ wTemp ].bBlock[0] = NS.bAtB0[ 0 ] ;
   gVoice[ wTemp ].bBlock[1] = NS.bAtB0[ 1 ] ;


} // end of Opl3_NoteOn()

//------------------------------------------------------------------------
//  VOID Opl3_NoteOff
//
//  Description:
//     This turns off a note, including drums with a patch
//     # of the drum note + 128.
//
//  Parameters:
//     BYTE bPatch
//        MIDI patch
//
//     BYTE bNote
//        MIDI note
//
//     BYTE bChannel
//        MIDI channel
//
//  Return Value:
//     Nothing.
//
//
//------------------------------------------------------------------------

VOID FAR PASCAL Opl3_NoteOff
(
    BYTE            bPatch,
    BYTE            bNote,
    BYTE            bChannel
)
{
   patchStruct FAR  *lpPS ;
   WORD             wOffset, wTemp ;

   // D1( "\nMidiNoteOff" ) ;

   // Find the note slot

   wTemp = Opl3_FindFullSlot( bNote, bChannel ) ;

   if (wTemp != 0xffff)
   {
      // get a pointer to the patch

      lpPS = glpPatch + (BYTE) gVoice[ wTemp ].bPatch ;

      // shut off the note portion

      // we have the note slot, turn it off.

//      if (wTemp < NUM4VOICES)
//      {
//         MidiSendFM( AD_BLOCK + gw4VoiceOffset[ wTemp ],
//                     (BYTE)(gVoice[ wTemp ].bBlock[ 0 ] & 0x1f) ) ;
//         MidiSendFM( AD_BLOCK + gw4VoiceOffset[ wTemp ] + 3,
//                     (BYTE)(gVoice[ wTemp ].bBlock[ 1 ] & 0x1f) ) ;
//      }
//      else

      wOffset = (wTemp < (NUM2VOICES / 2)) ? wTemp : (wTemp + 0x100 - 9) ;
      MidiSendFM( AD_BLOCK + wOffset,
                  (BYTE)(gVoice[ wTemp ].bBlock[ 0 ] & 0x1f) ) ;

      // Note this...

      gVoice[ wTemp ].bOn = FALSE ;
      gVoice[ wTemp ].bBlock[ 0 ] &= 0x1f ;
      gVoice[ wTemp ].bBlock[ 1 ] &= 0x1f ;
      gVoice[ wTemp ].dwTime = gdwCurTime ;
   }

} // end of Opl3_NoteOff()

/*
 * Opl3_ChannelNotesOff - turn off all notes on a channel
 */
VOID Opl3_ChannelNotesOff(BYTE bChannel)
{
    int i;

    for (i = 0; i < NUM2VOICES; i++) {
       if ((gVoice[ i ].bOn) && (gVoice[ i ].bChannel == bChannel)) {

          Opl3_NoteOff( gVoice[i].bPatch, gVoice[i].bNote,
                       gVoice[i].bChannel ) ;
       }
    }
}
/*
 * Opl3_AllNotesOff - turn off all notes
 *
 */
VOID Opl3_AllNotesOff(void)
{
    BYTE i;

    for (i = 0; i < NUM2VOICES; i++) {
        Opl3_NoteOff (gVoice[i].bPatch, gVoice[i].bNote, gVoice[i].bChannel);
    }
}



/* Opl3_NewVolume - This should be called if a volume level
 *      has changed. This will adjust the levels of all the playing
 *      voices.
 *
 * inputs
 *      WORD    wLeft   - left attenuation (1.5 db units)
 *      WORD    wRight  - right attenuation (ignore if mono)
 * returns
 *      none
 */
VOID FAR PASCAL Opl3_NewVolume (WORD wLeft, WORD wRight)
{

    /* make sure that we are actually open */
    if (!glpPatch)
        return;

    wSynthAttenL = wLeft;
    wSynthAttenR = wRight;

    Opl3_setvolume(0xff);

}



/* Opl3_ChannelVolume - set the volume level for an individual channel.
 *
 * inputs
 *      BYTE    bChannel - channel number to change
 *      WORD    wAtten  - attenuation in 1.5 db units
 *
 * returns
 *      none
 */
VOID FAR PASCAL Opl3_ChannelVolume(BYTE bChannel, WORD wAtten)
{
    gbChanAtten[bChannel] = (BYTE)wAtten;

    Opl3_setvolume(bChannel);
}



/* Opl3_SetPan - set the left-right pan position.
 *
 * inputs
 *      BYTE    bChannel  - channel number to alter
 *      BYTE    bPan   - 0 for left, 127 for right or somewhere in the middle.
 *
 * returns - none
 */
VOID FAR PASCAL Opl3_SetPan(BYTE bChannel, BYTE bPan)
{
    /* change the pan level */
    if (bPan > (64 + 16))
            gbStereoMask[bChannel] = 0xef;      /* let only right channel through */
    else if (bPan < (64 - 16))
            gbStereoMask[bChannel] = 0xdf;      /* let only left channel through */
    else
            gbStereoMask[bChannel] = 0xff;      /* let both channels */

    /* change any curently playing patches */
    Opl3_setvolume(bChannel);
}


//------------------------------------------------------------------------
//  VOID MidiPitchBend
//
//  Description:
//     This pitch bends a channel.
//
//  Parameters:
//     BYTE bChannel
//        channel
//
//     short iBend
//        values from -32768 to 32767, being -2 to +2 half steps
//
//  Return Value:
//     Nothing.
//
//
//------------------------------------------------------------------------

VOID NEAR PASCAL Opl3_PitchBend
(
    BYTE            bChannel,
    short           iBend
)
{
   WORD   i, wTemp[ 2 ], wOffset, j ;
   DWORD  dwNew ;

   // D1( "\nMidiPitchBend" ) ;

   // Remember the current bend..

   giBend[ bChannel ] = iBend ;

   // Loop through all the notes looking for the right
   // channel.  Anything with the right channel gets its
   // pitch bent...

   for (i = 0; i < NUM2VOICES; i++)
      if (gVoice[ i ].bChannel == bChannel)
      {
         j = 0 ;
         dwNew = Opl3_CalcBend( gVoice[ i ].dwOrigPitch[ j ], iBend ) ;
         wTemp[ j ] = Opl3_CalcFAndB( dwNew ) ;
         gVoice[ i ].bBlock[ j ] =
            (gVoice[ i ].bBlock[ j ] & (BYTE) 0xe0) |
               (BYTE) (wTemp[ j ] >> 8) ;

         wOffset = (i < (NUM2VOICES / 2)) ? i : (i + 0x100 - 9) ;
         MidiSendFM( AD_BLOCK + wOffset, gVoice[ i ].bBlock[ 0 ] ) ;
         MidiSendFM( AD_FNUMBER + wOffset, (BYTE) wTemp[ 0 ] ) ;
      }

} // end of MidiPitchBend()

#ifdef LOAD_PATCHES
static TCHAR BCODE gszDefPatchLib[]          = TEXT("SYNTH.PAT");
static TCHAR BCODE gszIniKeyPatchLib[]       = INI_STR_PATCHLIB;
static TCHAR BCODE gszIniDrvSection[]        = INI_DRIVER;
static TCHAR BCODE gszIniDrvFile[]           = INI_SOUND;
static TCHAR BCODE gszSysIniSection[]        = TEXT("synth.dll");
static TCHAR BCODE gszSysIniFile[]           = TEXT("System.Ini");

/** static DWORD NEAR PASCAL DrvGetProfileString(LPSTR szKeyName, LPSTR szDef, LPSTR szBuf, UINT wBufLen)
 *
 *  DESCRIPTION:
 *
 *
 *  ARGUMENTS:
 *      (LPSTR szKeyName, LPSTR szDef, LPSTR szBuf, WORD wBufLen)
 *              HINT    wSystem - if TRUE write/read to system.ini
 *
 *  RETURN (static DWORD NEAR PASCAL):
 *
 *
 *  NOTES:
 *
 ** cjp */

static DWORD NEAR PASCAL DrvGetProfileString(LPTSTR szKeyName, LPTSTR szDef, LPTSTR szBuf, UINT wBufLen,
        UINT wSystem)
{
    return GetPrivateProfileString(wSystem ? gszSysIniSection : gszIniDrvSection, szKeyName, szDef,
                szBuf, wBufLen, wSystem ? gszSysIniFile : gszIniDrvFile);
} /* DrvGetProfileString() */
#endif // LOAD_PATCHES

/* Opl3_BoardInit - initialise board and load patches as necessary.
 *
 * inputs - none
 * returns - 0 for success or the error code
 */
WORD Opl3_BoardInit(void)
{
    HMMIO       hmmio;
    MMCKINFO    mmckinfo, mm2;
    TCHAR       szPatchLib[STRINGLEN];     /* patch libarary */

    D1 (("Opl3_Init"));

    /* Check we haven't already initialized */
    if (glpPatch != NULL) {
        return 0;
    }


    /* allocate the memory, and fill it up from the patch
     * library.
     */
    glpPatch = (patchStruct FAR *)GlobalLock(GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE|GMEM_ZEROINIT, sizeof(patchStruct) * NUMPATCHES));
    if (!glpPatch) {
        D1 (("Opl3_Init: could not allocate patch container memory!"));
        return ERROR_OUTOFMEMORY;
    }

#ifdef LOAD_PATCHES
    /* should the load patches be moved to the init section? */
    DrvGetProfileString(gszIniKeyPatchLib, TEXT(""),
        szPatchLib, sizeof(szPatchLib), FALSE);



   if (lstrcmpi( (LPTSTR) szPatchLib, TEXT("") ) == 0)
#endif // LOAD_PATCHES
   {
      HRSRC   hrsrcPatches ;
      HGLOBAL hPatches ;
      LPTSTR  lpPatches ;

      hrsrcPatches =
         FindResource( ghModule, MAKEINTRESOURCE( DATA_FMPATCHES ),
                       RT_BINARY ) ;

      if (NULL != hrsrcPatches)
      {
         hPatches = LoadResource( ghModule, hrsrcPatches ) ;
         lpPatches = LockResource( hPatches ) ;
         AsMemCopy( glpPatch, lpPatches,
                    sizeof( patchStruct ) * NUMPATCHES ) ;
         UnlockResource( hPatches ) ;
         FreeResource( hPatches ) ;
      }
      else
      {
         TCHAR  szAlert[ 50 ] ;
         TCHAR  szErrorBuffer[ 255 ] ;

         LoadString( ghModule, SR_ALERT, szAlert, sizeof( szAlert ) / sizeof(TCHAR)) ;
         LoadString( ghModule, SR_ALERT_NORESOURCE, szErrorBuffer,
                     sizeof( szErrorBuffer ) / sizeof(TCHAR) ) ;
         MessageBox( NULL, szErrorBuffer, szAlert, MB_OK|MB_ICONHAND ) ;
      }
   }
#ifdef LOAD_PATCHES
   else
   {

    hmmio = mmioOpen (szPatchLib, NULL, MMIO_READ);
    if (hmmio) {
        mmioDescend (hmmio, &mmckinfo, NULL, 0);
        if ((mmckinfo.ckid == FOURCC_RIFF) &&
            (mmckinfo.fccType == RIFF_PATCH)) {

            mm2.ckid = RIFF_FM4;
            if (!mmioDescend (hmmio, &mm2, &mmckinfo, MMIO_FINDCHUNK)) {
                    /* we have found the synthesis chunk */
                    if (mm2.cksize > (sizeof(patchStruct)*NUMPATCHES))
                            mm2.cksize = sizeof(patchStruct)*NUMPATCHES;
                    mmioRead (hmmio, (LPSTR) glpPatch, mm2.cksize);
            } else {
                    D1(("Bad mmioDescend2"));
            }
        } else {
            D1(("Bad mmioDescend1"));
        }

        mmioClose (hmmio, 0);
    } else {

        TCHAR   szAlert[50];
        TCHAR   szErrorBuffer[255];

        LoadString(ghModule, SR_ALERT, szAlert, sizeof(szAlert));
        LoadString(ghModule, SR_ALERT_NOPATCH, szErrorBuffer, sizeof(szErrorBuffer));
        MessageBox(NULL, szErrorBuffer, szAlert, MB_OK|MB_ICONHAND);
        D1 (("Bad mmioOpen"));
    }

   }
#endif // LOAD_PATCHES


    return 0;       /* done */
}


/*
 * Opl3_BoardReset - silence the board and set all voices off.
 */
VOID Opl3_BoardReset(void)
{

    BYTE i;

    /* make sure all notes turned off */
    Opl3_AllNotesOff();


    /* ---- silence the chip -------- */

    /* tell the FM chip to use 4-operator mode, and
    fill in any other random variables */
    MidiSendFM (AD_NEW, 0x01);
    MidiSendFM (AD_MASK, 0x60);
    MidiSendFM (AD_CONNECTION, 0x00);
    MidiSendFM (AD_NTS, 0x00);


    /* turn off the drums, and use high vibrato/modulation */
    MidiSendFM (AD_DRUM, 0xc0);

    /* turn off all the oscillators */
    for (i = 0; i < 0x15; i++) {
        MidiSendFM (AD_LEVEL + i, 0x3f);
        MidiSendFM (AD_LEVEL2 + i, 0x3f);
    };

    /* turn off all the voices */
    for (i = 0; i < 0x08; i++) {
        MidiSendFM (AD_BLOCK + i, 0x00);
        MidiSendFM (AD_BLOCK2 + i, 0x00);
    };


    /* clear all of the voice slots to empty */
    for (i = 0; i < NUM2VOICES; i++)
            gVoice[i].dwTime = 0;

    /* start attenuations at -3 dB, which is 90 MIDI level */
    for (i = 0; i < NUMCHANNELS; i++) {
            gbChanAtten[i] = 4;
            gbStereoMask[i] = 0xff;
    };

    /* turn off the pitch bend */
    for (i = 0; i < NUMCHANNELS; i++)
          giBend[i] = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\inc\gmem.h ===
/*
    gmem.h

    This module supplies macros for fixed global memory
    allocation compatible with those used in the Multimedia
    extensions to Windows 3.x.  It is included to simplify
    porting of the Windows 3.x 16 bit code.

    Jul-16-91   NigelT

*/

#ifndef _GMEMMACROS_
#define _GMEMMACROS_

#define GAllocPtr(ul)       GlobalAlloc(GPTR,(ul))
#define GAllocPtrF(f,ul)    GlobalAlloc(GPTR,(ul))
#define GReAllocPtr(lp,ul)  GlobalReAlloc((HANDLE)(lp),(ul),GPTR)
#define GFreePtr(lp)        GlobalFree((HANDLE)(lp))

#define GlobalAllocPtrF(f,ul)    GlobalAlloc(GPTR,(ul))
//#define GlobalReAllocPtr(lp,ul,f)  GlobalReAlloc((HANDLE)(lp),(ul),GPTR)

#define GlobalPtrHandle(h)   (GlobalHandle(h))

/* the following are extracts from 3.1 WindowsX.h */
#define     GlobalUnlockPtr(lp) 	\
                GlobalUnlock(GlobalPtrHandle(lp))

#define     GlobalAllocPtr(flags, cb)	\
                (GlobalLock(GlobalAlloc((flags), (cb))))

#define     GlobalReAllocPtr(lp, cbNew, flags)	\
                (GlobalUnlockPtr(lp), GlobalLock(GlobalReAlloc(GlobalPtrHandle(lp) , (cbNew), (flags))))

#define     GlobalFreePtr(lp)		\
                (GlobalUnlockPtr(lp), (BOOL)GlobalFree(GlobalPtrHandle(lp)))

#endif // _GMEMMACROS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\synthlib\opl3.h ===
/*
 * Copyright (c) 1992-1994 Microsoft Corporation
 */

/*
 * declaration of interface functions to the OPL3 midi device type.
 *
 * These functions are called from midi.c when the kernel driver
 * has decreed that this is an opl3-compatible device.
 *
 * Geraint Davies, Dec 92
 */


/*
 * Opl3_NoteOn - This turns a note on. (Including drums, with
 *	a patch # of the drum Note + 128)
 *
 * inputs
 *      BYTE    bPatch - MIDI patch number
 *	BYTE    bNote - MIDI note number
 *      BYTE    bChannel - MIDI channel #
 *	BYTE    bVelocity - Velocity #
 *	short   iBend - current pitch bend from -32768, to 32767
 * returns
 *	none
 */
VOID NEAR PASCAL Opl3_NoteOn (BYTE bPatch,
	BYTE bNote, BYTE bChannel, BYTE bVelocity,
	short iBend);



/* Opl3_NoteOff - This turns a note off. (Including drums,
 *	with a patch # of the drum note + 128)
 *
 * inputs
 *	BYTE    bPatch - MIDI patch #
 *	BYTE    bNote - MIDI note number
 *	BYTE    bChannel - MIDI channel #
 * returns
 *	none
 */
VOID FAR PASCAL Opl3_NoteOff (BYTE bPatch,
	BYTE bNote, BYTE bChannel);

/* Opl3_AllNotesOff - turn off all notes
 *
 * inputs - none
 * returns - none
 */
VOID Opl3_AllNotesOff(void);

VOID Opl3_ChannelNotesOff(BYTE bChannel);

/* Opl3_NewVolume - This should be called if a volume level
 *	has changed. This will adjust the levels of all the playing
 *	voices.
 *
 * inputs
 *	WORD	wLeft	- left attenuation (1.5 db units)
 *	WORD	wRight  - right attenuation (ignore if mono)
 * returns
 *	none
 */
VOID FAR PASCAL Opl3_NewVolume (WORD wLeft, WORD wRight);



/* Opl3_ChannelVolume - set the volume level for an individual channel.
 *
 * inputs
 * 	BYTE	bChannel - channel number to change
 *	WORD	wAtten	- attenuation in 1.5 db units
 *
 * returns
 *	none
 */
VOID FAR PASCAL Opl3_ChannelVolume(BYTE bChannel, WORD wAtten);
	


/* Opl3_SetPan - set the left-right pan position.
 *
 * inputs
 *      BYTE    bChannel  - channel number to alter
 *	BYTE	bPan   - 0 for left, 127 for right or somewhere in the middle.
 *
 * returns - none
 */
VOID FAR PASCAL Opl3_SetPan(BYTE bChannel, BYTE bPan);



/* Opl3_PitchBend - This pitch bends a channel.
 *
 * inputs
 *	BYTE    bChannel - channel
 *	short   iBend - Values from -32768 to 32767, being
 *			-2 to +2 half steps
 * returns
 *	none
 */
VOID NEAR PASCAL Opl3_PitchBend (BYTE bChannel, short iBend);



/* Opl3_BoardInit - initialise board and load patches as necessary.
 *
 * inputs - none
 * returns - 0 for success or the error code
 */
WORD Opl3_BoardInit(void);


/*
 * Opl3_BoardReset - silence the board and set all voices off.
 */
VOID Opl3_BoardReset(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\drivers\synthlib\midi.c ===
/*
 *
 * Copyright (c) 1992-1995 Microsoft Corporation
 *
 */

/*
 * midi.c
 *
 * Midi FM Synthesis routines. converts midi messages into calls to
 * FM Synthesis functions  - currently supports base adlib (in adlib.c)
 * and opl3 synthesisers (in opl3.c).
 *
 * 15 Dec 92 Geraint Davies - based on a combination of the adlib
 *                            and WSS midi drivers.
 */


#include <windows.h>
#include <mmsystem.h>

#include "mmddk.h"
#include "driver.h"

#include "adlib.h"
#include "opl3.h"


/***********************************************************
global memory */


PORTALLOC gMidiInClient;     // input client information structure
DWORD dwRefTime;             // time when midi input was opened

DWORD dwMsgTime;             // timestamp (in ms) of current msg
DWORD dwMsg = 0L;            // short midi message
BYTE  bBytesLeft = 0;        // number of bytes needed to complete message
BYTE  bBytePos = 0;          // position in short message buffer
DWORD dwCurData = 0L;        // position in long message buffer
BOOL  fSysex = FALSE;        // are we in sysex mode?
BYTE  status = 0;
BYTE    fMidiInStarted = 0;     /* has the midi been started */
LPMIDIHDR      lpMIQueue = NULL;
BYTE    gbMidiInUse = 0;                /* if MIDI is in use */

static WORD  wMidiOutEntered = 0;    // reentrancy check
static PORTALLOC gMidiOutClient;     // client information

/* transformation of linear velocity value to
        logarithmic attenuation */
BYTE gbVelocityAtten[32] = {
        40, 36, 32, 28, 23, 21, 19, 17,
        15, 14, 13, 12, 11, 10, 9, 8,
        7, 6, 5, 5, 4, 4, 3, 3,
        2, 2, 1, 1, 1, 0, 0, 0 };

BYTE BCODE gbPercMap[53][2] =
{
   {  0, 35 },
   {  0, 35 },
   {  2, 52 },
   {  3, 48 },
   {  4, 58 },
   {  5, 60 },
   {  6, 47 },
   {  7, 43 },
   {  6, 49 },
   {  9, 43 },
   {  6, 51 },
   { 11, 43 },
   {  6, 54 },
   {  6, 57 },
   { 14, 72 },
   {  6, 60 },
   { 16, 76 },
   { 17, 84 },
   { 18, 36 },
   { 19, 76 },
   { 20, 84 },
   { 21, 83 },
   { 22, 84 },
   { 23, 24 },
   { 16, 77 },
   { 25, 60 },
   { 26, 65 },
   { 27, 59 },
   { 28, 51 },
   { 29, 45 },
   { 30, 71 },
   { 31, 60 },
   { 32, 58 },
   { 33, 53 },
   { 34, 64 },
   { 35, 71 },
   { 36, 61 },
   { 37, 61 },
   { 38, 48 },
   { 39, 48 },
   { 40, 69 },
   { 41, 68 },
   { 42, 63 },
   { 43, 74 },
   { 44, 60 },
   { 45, 80 },
   { 46, 64 },
   { 47, 69 },
   { 48, 73 },
   { 49, 75 },
   { 50, 68 },
   { 51, 48 },
   { 52, 53 }
} ;

short   giBend[NUMCHANNELS];    /* bend for each channel */
BYTE    gbPatch[NUMCHANNELS];   /* patch number mapped to */

/* --- interface functions ---------------------------------- */


/*
 * the functions in this section call out to adlib.c or opl3.c
 * depending on which device we have installed.
 */


/**************************************************************
MidiAllNotesOff - switch off all active voices.

inputs - none
returns - none
*/
VOID MidiAllNotesOff(void)
{
    switch (gMidiType) {
    case TYPE_OPL3:
        Opl3_AllNotesOff();
        break;

    case TYPE_ADLIB:
        Adlib_AllNotesOff();
        break;
    }
}


/**************************************************************
MidiNewVolume - This should be called if a volume level
        has changed. This will adjust the levels of all the playing
        voices.

inputs
        WORD    wLeft   - left attenuation (1.5 db units)
        WORD    wRight  - right attenuation (ignore if mono)
returns
        none
*/
VOID FAR PASCAL MidiNewVolume (WORD wLeft, WORD wRight)
{
    switch (gMidiType) {
    case TYPE_OPL3:
        Opl3_NewVolume(wLeft, wRight);
        break;

    case TYPE_ADLIB:
        Adlib_NewVolume(wLeft, wRight);
        break;
    }

}

/***************************************************************
MidiChannelVolume - set the volume level for an individual channel.

inputs
        BYTE    bChannel - channel number to change
        WORD    wAtten  - attenuation in 1.5 db units

returns
        none
*/
VOID FAR PASCAL MidiChannelVolume(BYTE bChannel, WORD wAtten)
{

    switch (gMidiType) {
    case TYPE_OPL3:
        Opl3_ChannelVolume(bChannel, wAtten);
        break;

    case TYPE_ADLIB:
        Adlib_ChannelVolume(bChannel, wAtten);
        break;
    }

}



/***************************************************************
MidiSetPan - set the left-right pan position.

inputs
        BYTE    bChannel  - channel number to alter
        BYTE    bPan   - 0 for left, 127 for right or somewhere in the middle.

returns - none
*/
VOID FAR PASCAL MidiSetPan(BYTE bChannel, BYTE bPan)
{
    switch (gMidiType) {
    case TYPE_OPL3:
        Opl3_SetPan(bChannel, bPan);
        break;

    case TYPE_ADLIB:
        Adlib_SetPan(bChannel, bPan);
        break;
    }

}

/***************************************************************
MidiPitchBend - This pitch bends a channel.

inputs
        BYTE    bChannel - channel
        short   iBend - Values from -32768 to 32767, being
                        -2 to +2 half steps
returns
        none
*/
VOID NEAR PASCAL MidiPitchBend (BYTE bChannel,
        short iBend)
{
    switch (gMidiType) {
    case TYPE_OPL3:
        Opl3_PitchBend(bChannel, iBend);
        break;

    case TYPE_ADLIB:
        Adlib_PitchBend(bChannel, iBend);
        break;
    }

}

/***************************************************************
MidiBoardInit - initialise board and load patches as necessary.

* inputs - none
* returns - 0 for success or the error code
*/
WORD MidiBoardInit(void)
{
    /*
     * load patch tables and reset board
     */

    switch (gMidiType) {
    case TYPE_OPL3:
        return( Opl3_BoardInit());
        break;

    case TYPE_ADLIB:
        return (Adlib_BoardInit());
        break;
    }
    return(MMSYSERR_ERROR);
}

/*
 * MidiBoardReset - silence the board and set all voices off.
 */
VOID MidiBoardReset(void)
{
    BYTE i;

    /*
     * switch off pitch bend (we own this, not the opl3/adlib code)
     */
    for (i = 0; i < NUMCHANNELS; i++)
        giBend[i] = 0;

    /*
     * set all voices off, set channel atten to default,
     * & silence board.
     */
    switch (gMidiType) {
    case TYPE_OPL3:
        Opl3_BoardReset();
        break;

    case TYPE_ADLIB:
        Adlib_BoardReset();
        break;
    }
}



/* --- midi interpretation -------------------------------------*/


/***************************************************************
MidiMessage - This handles a MIDI message. This
        does not do running status.

inputs
        DWORD dwData - up to 4 bytes of MIDI data
                depending upon the message.
returns
        none
*/
VOID NEAR PASCAL MidiMessage (DWORD dwData)
{
    BYTE    bChannel, bVelocity, bNote;
    WORD    wTemp;

    // D1("\nMidiMessage");
    bChannel = (BYTE) dwData & (BYTE)0x0f;
    bVelocity = (BYTE) (dwData >> 16) & (BYTE)0x7f;
    bNote = (BYTE) ((WORD) dwData >> 8) & (BYTE)0x7f;

    switch ((BYTE)dwData & 0xf0) {
        case 0x90:
#ifdef DEBUG
            {
                    char szTemp[4];
                    szTemp[0] = "0123456789abcdef"[bNote >> 4];
                    szTemp[1] = "0123456789abcdef"[bNote & 0x0f];
                    szTemp[2] = ' ';
                    szTemp[3] = 0;
                    if ((bChannel == 9) && bVelocity) D1(szTemp);
            }
#endif
            /* turn key on, or key off if volume == 0 */
            if (bVelocity) {
                switch(gMidiType) {
                case TYPE_OPL3:
                    if (bChannel == DRUMCHANNEL)
                    {
                       if (bNote >= 35 && bNote <= 87)
                       {
#ifdef DEBUG
                          char szDebug[ 80 ] ;

                          wsprintf( szDebug, "bChannel = %d, bNote = %d",
                                    bChannel, bNote ) ;
                          D1( szDebug ) ;
#endif

                          Opl3_NoteOn( (BYTE) (gbPercMap[ bNote - 35 ][ 0 ] + 0x80),
                                       gbPercMap[ bNote - 35 ][ 1 ],
                                       bChannel, bVelocity,
                                       (short) giBend[ bChannel ] ) ;
                       }
                    }
                    else
                        Opl3_NoteOn( (BYTE) gbPatch[ bChannel ], bNote, bChannel,
                                     bVelocity, (short) giBend[ bChannel ] ) ;
                    break;

                case TYPE_ADLIB:
                    Adlib_NoteOn (
                            (BYTE) ((bChannel == DRUMCHANNEL) ?
                                    (BYTE) (bNote + 128) : (BYTE) gbPatch[bChannel]),
                            bNote, bChannel, bVelocity, (short) giBend[bChannel]);
                    break;
                }
                break;
            }

                /* else, continue through and turn key off */
        case 0x80:
                /* turn key off */
                switch (gMidiType) {
                case TYPE_OPL3:
                    if (bChannel == DRUMCHANNEL)
                    {
                       if (bNote >= 35 && bNote <= 87)
                          Opl3_NoteOff( (BYTE) (gbPercMap[ bNote - 35 ][ 0 ] + 0x80),
                                       gbPercMap[ bNote - 35 ][ 1 ], bChannel ) ;
                    }
                    else
                       Opl3_NoteOff( (BYTE) gbPatch[bChannel], bNote, bChannel ) ;
                    break;

                case TYPE_ADLIB:
                    Adlib_NoteOff (
                            (BYTE) ((bChannel == DRUMCHANNEL) ?
                                    (BYTE) (bNote + 128) : (BYTE) gbPatch[bChannel]),
                                    bNote, bChannel);
                    break;
                }
                break;

        case 0xb0:
                // D1("\nChangeControl");
                /* change control */
                switch (bNote) {
                        case 7:
                                /* change channel volume */
                                MidiChannelVolume(
                                    bChannel,
                                    gbVelocityAtten[(bVelocity & 0x7f) >> 2]);

                                break;
                        case 8:
                        case 10:
                                /* change the pan level */
                                MidiSetPan(bChannel, bVelocity);
                                break;
                        };
                break;

        case 0xc0:
            if (bChannel != DRUMCHANNEL)
            {
               int  i ;

               // Turn off all active notes for this channel...

               if (gMidiType == TYPE_OPL3) {
                   Opl3_ChannelNotesOff(bChannel);
               }

               gbPatch[ bChannel ] = bNote ;

            }
            break;

        case 0xe0:
                // D1("\nBend");
                /* pitch bend */
                wTemp = ((WORD) bVelocity << 9) | ((WORD) bNote << 2);
                giBend[bChannel] = (short) (WORD) (wTemp + 0x7FFF);
                MidiPitchBend (bChannel, giBend[bChannel]);

                break;
    };

    return;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midiSynthCallback | This calls DriverCallback for a midi device.
 *
 * @parm NPPORTALLOC| pPort | Pointer to the PORTALLOC.
 *
 * @parm WORD | msg | The message to send.
 *
 * @parm DWORD | dw1 | Message-dependent parameter.
 *
 * @parm DWORD | dw2 | Message-dependent parameter.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void NEAR PASCAL midiSynthCallback(NPPORTALLOC pPort, WORD msg, DWORD_PTR dw1, DWORD_PTR dw2)
{

    // invoke the callback function, if it exists.  dwFlags contains driver-
    // specific flags in the LOWORD and generic driver flags in the HIWORD
    if (pPort->dwCallback)
        DriverCallback(pPort->dwCallback,       // client's callback DWORD
            HIWORD(pPort->dwFlags) | DCB_NOSWITCH,  // callback flags
            (HDRVR)pPort->hMidi,     // handle to the wave device
            msg,                     // the message
            pPort->dwInstance,       // client's instance data
            dw1,                     // first DWORD
            dw2);                    // second DWORD
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midBufferWrite | This function writes a byte into the long
 *     message buffer.  If the buffer is full or a SYSEX_ERROR or
 *     end-of-sysex byte is received, the buffer is marked as 'done' and
 *     it's owner is called back.
 *
 * @parm BYTE | byte | The byte received.
 *
 * @rdesc There is no return value
 ***************************************************************************/
static void NEAR PASCAL midBufferWrite(BYTE byte)
{
    LPMIDIHDR  lpmh;
    WORD       msg;

    // if no buffers, nothing happens
    if (lpMIQueue == NULL)
        return;

    lpmh = lpMIQueue;

    if (byte == SYSEX_ERROR) {
        D2(("sysexerror"));
        msg = MIM_LONGERROR;
        }
    else {
        D2(("bufferwrite"));
        msg = MIM_LONGDATA;
        *((HPSTR)(lpmh->lpData) + dwCurData++) = byte;
        }

    // if end of sysex, buffer full or error, send them back the buffer
    if ((byte == SYSEX_ERROR) || (byte == 0xF7) || (dwCurData >= lpmh->dwBufferLength)) {
        D2(("bufferdone"));
        lpMIQueue = lpMIQueue->lpNext;
        lpmh->dwBytesRecorded = dwCurData;
        dwCurData = 0L;
        lpmh->dwFlags |= MHDR_DONE;
        lpmh->dwFlags &= ~MHDR_INQUEUE;
        midiSynthCallback(&gMidiInClient, msg, (DWORD_PTR)lpmh, dwMsgTime);
    }

    return;
}



/****************************************************************************

    This function conforms to the standard MIDI output driver message proc
    modMessage, which is documented in mmddk.d.

 ***************************************************************************/
DWORD APIENTRY modSynthMessage(UINT id,
        UINT msg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
    LPMIDIHDR    lpHdr;
    LPSTR           lpBuf;          /* current spot in the long msg buf */
    DWORD           dwBytesRead;    /* how far are we in the buffer */
    DWORD           dwMsg = 0;      /* short midi message sent to synth */
    BYTE            bBytePos=0;     /* shift current byte by dwBytePos*s */
    BYTE            bBytesLeft = 0; /* how many dat bytes needed */
    BYTE            curByte;        /* current byte in long buffer */
    UINT            mRc;            /* Return code */


    // this driver only supports one device
    if (id != 0) {
        D1(("invalid midi device id"));
        return MMSYSERR_BADDEVICEID;
    }

    switch (msg) {
        case MODM_GETNUMDEVS:
            D1(("MODM_GETNUMDEVS"));
        //
        // Check if the kernel driver got loaded OK
        //
        mRc = sndGetNumDevs(SYNTH_DEVICE);
                break;

        case MODM_GETDEVCAPS:
            D1(("MODM_GETDEVCAPS"));
            mRc = midiGetDevCaps(0, SYNTH_DEVICE, (LPBYTE)dwParam1, (WORD)dwParam2);
            break;

        case MODM_OPEN:
            D1(("MODM_OPEN"));

            /* open the midi */
            if (MidiOpen())
                return MMSYSERR_ALLOCATED;

            // save client information
            gMidiOutClient.dwCallback = ((LPMIDIOPENDESC)dwParam1)->dwCallback;
            gMidiOutClient.dwInstance = ((LPMIDIOPENDESC)dwParam1)->dwInstance;
            gMidiOutClient.hMidi      = (HMIDIOUT)((LPMIDIOPENDESC)dwParam1)->hMidi;
            gMidiOutClient.dwFlags    = (DWORD)dwParam2;

            // notify client
            midiSynthCallback(&gMidiOutClient, MOM_OPEN, 0L, 0L);

            /* were in use */
            gbMidiInUse = TRUE;

            mRc = 0L;
                break;

        case MODM_CLOSE:
            D1(("MODM_CLOSE"));

            /* shut up the FM synthesizer */
            MidiClose();

            // notify client
            midiSynthCallback(&gMidiOutClient, MOM_CLOSE, 0L, 0L);

            /* were not used any more */
            gbMidiInUse = FALSE;

            mRc = 0L;
                break;

        case MODM_RESET:
            D1(("MODM_RESET"));

            //
            //  turn off FM synthesis
            //
            //  note that we increment our 're-entered' counter so that a
            //  background interrupt handler doesn't mess up our resetting
            //  of the synth by calling midiOut[Short|Long]Msg.. just
            //  practicing safe midi. NOTE: this should never be necessary
            //  if a midi app is PROPERLY written!
            //
            wMidiOutEntered++;
            {
                if (wMidiOutEntered == 1)
                {
                    MidiReset();
                    dwParam1 = 0L;
                }
                else
                {
                    D1(("MODM_RESET reentered!"));
                    dwParam1 = MIDIERR_NOTREADY;
                }
            }
            wMidiOutEntered--;
            mRc = (DWORD)dwParam1;
                break;

        case MODM_DATA:                    // message is in dwParam1
            MidiCheckVolume();             // See if the volume has changed

            // make sure we're not being reentered
            wMidiOutEntered++;
            if (wMidiOutEntered > 1) {
                        D1(("MODM_DATA reentered!"));
                        wMidiOutEntered--;
                        return MIDIERR_NOTREADY;
                    }

            /* if have repeated messages */
            if (dwParam1 & 0x00000080)  /* status byte */
                        status = LOBYTE(LOWORD(dwParam1));
            else
                        dwParam1 = (dwParam1 << 8) | ((DWORD) status);

            /* if not, have an FM synthesis message */
            MidiMessage ((DWORD)dwParam1);

            wMidiOutEntered--;
            mRc = 0L;
                break;

        case MODM_LONGDATA:      // far pointer to header in dwParam1

            MidiCheckVolume();   // See if the volume has changed

            // make sure we're not being reentered
            wMidiOutEntered++;
            if (wMidiOutEntered > 1) {
                        D1(("MODM_LONGDATA reentered!"));
                        wMidiOutEntered--;
                        return MIDIERR_NOTREADY;
                        }

            // check if it's been prepared
            lpHdr = (LPMIDIHDR)dwParam1;
            if (!(lpHdr->dwFlags & MHDR_PREPARED)) {
                        wMidiOutEntered--;
                        return MIDIERR_UNPREPARED;
                        }

            lpBuf = lpHdr->lpData;
            dwBytesRead = 0;
            curByte = *lpBuf;

            while (TRUE) {
                        /* if its a system realtime message send it and continue
                                this does not affect the running status */

                        if (curByte >= 0xf8)
                                MidiMessage (0x000000ff & curByte);
                        else if (curByte >= 0xf0) {
                                status = 0;     /* kill running status */
                                dwMsg = 0L;     /* throw away any incomplete data */
                                bBytePos = 0;   /* start at beginning of message */

                                switch (curByte) {
                                        case 0xf0:      /* sysex - ignore */
                                        case 0xf7:
                                                break;
                                        case 0xf4:      /* system common, no data */
                                        case 0xf5:
                                        case 0xf6:
                                                MidiMessage (0x000000ff & curByte);
                                                break;
                                        case 0xf1:      /* system common, one data byte */
                                        case 0xf3:
                                                dwMsg |= curByte;
                                                bBytesLeft = 1;
                                                bBytePos = 1;
                                                break;
                                        case 0xf2:      /* system common, 2 data bytes */
                                                dwMsg |= curByte;
                                                bBytesLeft = 2;
                                                bBytePos = 1;
                                                break;
                                        };
                                }
                    /* else its a channel message */
                    else if (curByte >= 0x80) {
                                status = curByte;
                                dwMsg = 0L;

                                switch (curByte & 0xf0) {
                                        case 0xc0:      /* channel message, one data */
                                        case 0xd0:
                                                dwMsg |= curByte;
                                                bBytesLeft = 1;
                                                bBytePos = 1;
                                                break;
                                        case 0x80:      /* two bytes */
                                        case 0x90:
                                        case 0xa0:
                                        case 0xb0:
                                        case 0xe0:
                                                dwMsg |= curByte;
                                                bBytesLeft = 2;
                                                bBytePos = 1;
                                                break;
                                        };
                                }

                        /* else if its an expected data byte */
                    else if (bBytePos != 0) {
                                dwMsg |= ((DWORD)curByte) << (bBytePos++ * 8);
                                if (--bBytesLeft == 0) {

                                                MidiMessage (dwMsg);

                                        if (status) {
                                                dwMsg = status;
                                                bBytesLeft = bBytePos - (BYTE)1;
                                                bBytePos = 1;
                                                }
                                        else {
                                                dwMsg = 0L;
                                                bBytePos = 0;
                                                };
                                        };
                                };

            /* read the next byte if there is one */
            /* remember we have already read and processed one byte that
             * we have not yet counted- so we need to pre-inc, not post-inc
             */
            if (++dwBytesRead >= lpHdr->dwBufferLength) break;
                curByte = *++lpBuf;
            };      /* while TRUE */

            /* return buffer to client */
            lpHdr->dwFlags |= MHDR_DONE;
            midiSynthCallback (&gMidiOutClient, MOM_DONE, dwParam1, 0L);

            wMidiOutEntered--;
            mRc = 0L;
                break;

        case MODM_SETVOLUME:
                mRc = MidiSetVolume(LOWORD(dwParam1) << 16, HIWORD(dwParam1) << 16);
                break;

        case MODM_GETVOLUME:
                mRc = MidiGetVolume((LPDWORD)dwParam1);
                break;

        default:
            return MMSYSERR_NOTSUPPORTED;
    }
    MidiFlush();

    return mRc;


// should never get here...
return MMSYSERR_NOTSUPPORTED;
}

/****************************************************************
MidiInit - Initializes the FM synthesis chip and internal
        variables. This assumes that HwInit() has been called
        and that a card location has been found. This loads in
        the patch information.

inputs
        none
returns
        WORD - 0 if successful, else error
*/
WORD FAR PASCAL MidiInit (VOID)
{
//    WORD        i;

    D1 (("\nMidiInit"));

// don't reset the patch map - it will be initialised at loadtime to 0
// (because its static data) and we should not change it after that
// since the mci sequencer will not re-send patch change messages.
//
//
//    /* reset all channels to patch 0 */
//    for (i = 0; i < NUMCHANNELS; i++) {
//      gbPatch[i] = 0;
//    }

    /* initialise the h/w specific patch tables */
    return MidiBoardInit();
}


/*****************************************************************
MidiOpen - This should be called when a midi file is opened.
        It initializes some variables and locks the patch global
        memories.

inputs
        none
returns
        UINT - 0 if succedes, else error
*/
UINT FAR PASCAL MidiOpen (VOID)
{
    MMRESULT mRc;

    D1(("MidiOpen"));


    //
    // For 32-bit we must open our kernel device
    //

    mRc = MidiOpenDevice(&MidiDeviceHandle, TRUE);

    if (mRc != MMSYSERR_NOERROR) {
            return mRc;
    }


    /*
     * reset the device (set default channel attenuation etc)
     */
    MidiBoardReset();

    return 0;
}

/***************************************************************
MidiClose - This kills the playing midi voices and closes the kernel driver

inputs
        none
returns
        none
*/
VOID FAR PASCAL MidiClose (VOID)
{

    D1(("MidiClose"));

    if (MidiDeviceHandle == NULL) {
        return;
    }

    /* make sure all notes turned off */
    MidiAllNotesOff();

    MidiCloseDevice(MidiDeviceHandle);

    MidiDeviceHandle = NULL;
}

/** void FAR PASCAL MidiReset(void)
 *
 *  DESCRIPTION:
 *
 *
 *  ARGUMENTS:
 *      (void)
 *
 *  RETURN (void FAR PASCAL):
 *
 *
 *  NOTES:
 *
 ** cjp */

void FAR PASCAL MidiReset(void)
{

    D1(("MidiReset"));

    /* make sure all notes turned off */
    MidiAllNotesOff();

    /* silence the board and reset board-specific variables */
    MidiBoardReset();


} /* MidiReset() */



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\inc\mcihand.h ===
/*
    mcihand.h

    This file defines the constants, structures and APIs used
    to implement the MCI handler interface.

    6/17/91 NigelT

*/

#ifndef MCIHAND_H
#define MCIHAND_H

//
// Define the name of a handler entry point
//

#define MCI_HANDLER_PROC_NAME "DriverProc"

//
// Typedef the entry routine for a driver
//

typedef LONG (HANDLERPROC)(DWORD dwId, UINT msg, LONG lp1, LONG lp2);
typedef HANDLERPROC *LPHANDLERPROC;

//
// Define the messages sent to a handler which are generic to the
// handler rather than a specific device handled by it.
//

#define MCI_OPEN_HANDLER    0x0001
#define MCI_CLOSE_HANDLER   0x0002
#define MCI_QUERY_CONFIGURE 0x0003
#define MCI_CONFIGURE       0x0004

//
// Define the device specific messages sent to the handlers
//

#define MCI_OPEN_DEVICE     0x0800
#define MCI_CLOSE_DEVICE    0x0801

/*
// #ifndef MAKEMCIRESOURCE
// #define MAKEMCIRESOURCE(wRet, wRes)    MAKELONG((wRet), (wRes))
// #endif
*/

//
// Define the return code for happy campers
// This is returned in response to driver messages which succeed
//

#define MCI_SUCCESS         0x00000000


//
// String return values only used with MAKEMCIRESOURCE
//

#define MCI_FORMAT_RETURN_BASE          MCI_FORMAT_MILLISECONDS_S
#define MCI_FORMAT_MILLISECONDS_S       (MCI_STRING_OFFSET + 21)
#define MCI_FORMAT_HMS_S                (MCI_STRING_OFFSET + 22)
#define MCI_FORMAT_MSF_S                (MCI_STRING_OFFSET + 23)
#define MCI_FORMAT_FRAMES_S             (MCI_STRING_OFFSET + 24)
#define MCI_FORMAT_SMPTE_24_S        (MCI_STRING_OFFSET + 25)
#define MCI_FORMAT_SMPTE_25_S        (MCI_STRING_OFFSET + 26)
#define MCI_FORMAT_SMPTE_30_S        (MCI_STRING_OFFSET + 27)
#define MCI_FORMAT_SMPTE_30DROP_S       (MCI_STRING_OFFSET + 28)
#define MCI_FORMAT_BYTES_S              (MCI_STRING_OFFSET + 29)
#define MCI_FORMAT_SAMPLES_S            (MCI_STRING_OFFSET + 30)
#define MCI_FORMAT_TMSF_S               (MCI_STRING_OFFSET + 31)

#define    WAVE_FORMAT_PCM_S        (MCI_WAVE_OFFSET + 0)
#define    WAVE_MAPPER_S            (MCI_WAVE_OFFSET + 1)

#define MIDIMAPPER_S                    (MCI_SEQ_OFFSET + 11)

//
// Parameters for internal version of MCI_OPEN message sent from
// mciOpenDevice to the handler.  The wCustomCommandTable field is
// set by the driver.  It is set to MCI_TABLE_NOT_PRESENT if there
// is no table.  The wType field is also set by the driver.
//

typedef struct {
    LPSTR   lpstrParams;           // parameter string for entry in ini file
    DWORD   wDeviceID;             // device ID
    UINT    wCustomCommandTable;   // custom command table
    UINT    wType;                 // driver type
} MCI_OPEN_HANDLER_PARMS;
typedef MCI_OPEN_HANDLER_PARMS FAR * LPMCI_OPEN_HANDLER_PARMS;

//
// The maximum length of an MCI device type
//

#define MCI_MAX_DEVICE_TYPE_LENGTH 80

//
// Flags for mciSendCommandInternal which direct mciSendString how to
// interpret the return value
//

#define MCI_RESOURCE_RETURNED       0x00010000  // resource ID
#define MCI_COLONIZED3_RETURN       0x00020000  // colonized ID, 3 bytes data
#define MCI_COLONIZED4_RETURN       0x00040000  // colonized ID, 4 bytes data
#define MCI_INTEGER_RETURNED        0x00080000  // Integer conversion needed
#define MCI_RESOURCE_DRIVER         0x00100000  // driver owns returned resource

//
// Command table information type tags
//

#define MCI_TABLE_NOT_PRESENT   (-1)
#define MCI_CUSTOM_TABLE        0

#define MCI_COMMAND_HEAD        0
#define MCI_STRING              1
#define MCI_INTEGER             2
#define MCI_END_COMMAND         3
#define MCI_RETURN              4
#define MCI_FLAG                5
#define MCI_END_COMMAND_LIST    6
#define MCI_RECT                7
#define MCI_CONSTANT            8
#define MCI_END_CONSTANT        9


#endif /* MCIHAND_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\inc\mcihlpid.h ===
//Context Sensitive Help ID for MCIWAVE Driver Configuration Dialog.
#define     IDH_MCI_WAVEFORM_DRIVER     2000


//Context Sensitive Help IDs for MCIVISCA Driver Configuration Dialog.
#define     IDH_MCI_VISCA_COMM          2100
#define     IDH_MCI_VISCA_VCR           2101
#define     IDH_MCI_VISCA_DETECT        2102

//Context Sensitive Help IDs for MCIPIONR Driver Configuration Dialog.
#define     IDH_MCI_PIONEER_DRIVER      2201
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\inc\mmsndcs.h ===
/**************************************************************************\
* Module Name: csuser.h
*
* User client/server shared definitions.
*
* Copyright (c) Microsoft Corp.  1990 All Rights Reserved
*
* Created: 10-Dec-90
*
* History:
*   1  May 92 plagiarised by SteveDav
*
\**************************************************************************/

#ifndef CSUSER_INCLUDED

typedef struct _MMSNDCONNECT {
    IN  ULONG ulVersion;
    OUT ULONG ulCurrentVersion;
	OUT HANDLE hFileMapping;
	OUT HANDLE hEvent;
	OUT HANDLE hMutex;
} MMSNDCONNECT, *PMMSNDCONNECT;

#define MMSNDCURRENTVERSION   0x1000

#define CSUSER_INCLUDED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\inc\mmcntrls.h ===
/******************************Module*Header*******************************\
* Module Name: mmcntrls.h
*
*  Contains a collection of common controls used by various MM apps...
*   mciwnd      - uses toolbars and trackbars
*   cdplayer    - uses toolbars, bitmap buttons and multiple drag lists
*   mplayer     - uses toolbars and trackbars
*   soundrec    - uses trackbars and bitmap buttons
*
*
* Created: 15-02-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

/*REVIEW: this stuff needs Windows style in many places; find all REVIEWs. */

#ifndef _INC_MMCNTRLS
#define _INC_MMCNTRLS

#ifdef __cplusplus
extern "C" {
#endif


#ifndef NOTOOLBAR
#define InitToolbarClass          private1
#define CreateToolbarEx           private2
#define GetDitherBrush            private3
#define CreateDitherBrush         private4
#define FreeDitherBrush           private5
#endif

#ifndef NOTRACKBAR
#define InitTrackBar              private6
#endif

#ifndef NOBITMAPBTN
#define BtnCreateBitmapButtons    private7
#define BtnDestroyBitmapButtons   private8
#define BtnDrawButton             private9
#define BtnDrawFocusRect          private10
#define BtnUpdateColors           private11
#endif

#ifndef NOSTATUSBAR
#define CreateStatusWindowW       private12
#define CreateStatusWindowA       private13
#define DrawStatusTextA           private14
#define DrawStatusTextW           private15
#endif

/* Users of this header may define any number of these constants to avoid
 * the definitions of each functional group.
 *    NOTOOLBAR    Customizable bitmap-button toolbar control.
 *    NOMENUHELP   APIs to help manage menus, especially with a status bar.
 *    NOTRACKBAR   Customizable column-width tracking control.
 *    NODRAGLIST   APIs to make a listbox source and sink drag&drop actions.
 *    NOBITMAPBTN  APIs to draw bitmaps on buttons
 */


/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NOBITMAPBTN

/* -------------------------------------------------------------------------
** Bitmap button styles
** -------------------------------------------------------------------------
*/

/*
** If you want little tool tips to popup next to your toolbar buttons
** use the style below.
*/
#define BBS_TOOLTIPS    0x00000100L   /* make/use a tooltips control */



/* -------------------------------------------------------------------------
** Bitmap button states
** -------------------------------------------------------------------------
*/
#define BTNSTATE_PRESSED     ODS_SELECTED
#define BTNSTATE_DISABLED    ODS_DISABLED
#define BTNSTATE_HAS_FOCUS   ODS_FOCUS




/* -------------------------------------------------------------------------
** Bitmap button structures
** -------------------------------------------------------------------------
*/
typedef struct {
    int     iBitmap;    /* Index into mondo bitmap of this button's picture */
    UINT    uId;        /* Button ID */
    UINT    fsState;    /* Button's state, see BTNSTATE_XXXX above */
} BITMAPBTN, NEAR *PBITMAPBTN, FAR *LPBITMAPBTN;




/* -------------------------------------------------------------------------
** Bitmap buttons public interfaces
** -------------------------------------------------------------------------
*/

BOOL WINAPI
BtnCreateBitmapButtons(
    HWND hwndOwner,
    HINSTANCE hBMInst,
    UINT wBMID,
    UINT uStyle,
    LPBITMAPBTN lpButtons,
    int nButtons,
    int dxBitmap,
    int dyBitmap
    );

void WINAPI
BtnDestroyBitmapButtons(
    HWND hwndOwner
    );

void WINAPI
BtnDrawButton(
    HWND hwndOwner,
    HDC hdc,
    int dxButton,
    int dyButton,
    LPBITMAPBTN lpButton
    );

void WINAPI
BtnDrawFocusRect(
    HDC hdc,
    const RECT *lpRect,
    UINT fsState
    );

void WINAPI
BtnUpdateColors(
    HWND hwndOwner
    );
#endif


/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NOTOOLBAR

#define TOOLBARCLASSNAME TEXT("MCIWndToolbar")


/* Note that LOWORD(dwData) is at the same offset as idsHelp in the old
** structure, since it was never used anyway.
*/
typedef struct tagTBBUTTON
{
/*REVIEW: index, command, flag words, resource ids should be UINT */
    int iBitmap;	/* index into bitmap of this button's picture */
    int idCommand;	/* WM_COMMAND menu ID that this button sends */
    BYTE fsState;	/* button's state */
    BYTE fsStyle;	/* button's style */
    DWORD dwData;	/* app defined data */
    int iString;	/* index into string list */
} TBBUTTON;
typedef TBBUTTON NEAR* PTBBUTTON;
typedef TBBUTTON FAR* LPTBBUTTON;
typedef const TBBUTTON FAR* LPCTBBUTTON;


/*REVIEW: is this internal? if not, call it TBADJUSTINFO, prefix tba */
typedef struct tagADJUSTINFO
{
    TBBUTTON tbButton;
    TCHAR szDescription[1];
} ADJUSTINFO;
typedef ADJUSTINFO NEAR* PADJUSTINFO;
typedef ADJUSTINFO FAR* LPADJUSTINFO;


/*REVIEW: is this internal? if not, call it TBCOLORMAP, prefix tbc */
typedef struct tagCOLORMAP
{
    COLORREF from;
    COLORREF to;
} COLORMAP;
typedef COLORMAP NEAR* PCOLORMAP;
typedef COLORMAP FAR* LPCOLORMAP;


BOOL WINAPI
InitToolbarClass(
    HINSTANCE hInstance
    );

/* This is likely to change several times in the near future. */
HWND WINAPI
CreateToolbarEx(
    HWND hwnd,
    DWORD ws,
    UINT wID,
    int nBitmaps,
    HINSTANCE hBMInst,
    UINT wBMID,
    LPCTBBUTTON lpButtons,
    int iNumButtons,
    int dxButton,
    int dyButton,
    int dxBitmap,
    int dyBitmap,
    UINT uStructSize
    );

/*REVIEW: idBitmap, iNumMaps should be UINT */
HBITMAP WINAPI
CreateMappedBitmap(
    HINSTANCE hInstance,
    int idBitmap,
    WORD wFlags,
    LPCOLORMAP lpColorMap,
    int iNumMaps
    );

#define CMB_DISCARDABLE	0x01	/* create bitmap as discardable */
#define CMB_MASKED	0x02	/* create image/mask pair in bitmap */

HBRUSH WINAPI
GetDitherBrush(
    void
    );


/*REVIEW: TBSTATE_* should be TBF_* (for Flags) */
#define TBSTATE_CHECKED		0x01	/* radio button is checked */
#define TBSTATE_PRESSED		0x02	/* button is being depressed (any style) */
#define TBSTATE_ENABLED		0x04	/* button is enabled */
#define TBSTATE_HIDDEN		0x08	/* button is hidden */
#define TBSTATE_INDETERMINATE	0x10	/* button is indeterminate */
                                        /*  (needs to be endabled, too) */

/*REVIEW: TBSTYLE_* should be TBS_* (for Style) */
#define TBSTYLE_BUTTON		0x00	/* this entry is button */
#define TBSTYLE_SEP		0x01	/* this entry is a separator */
#define TBSTYLE_CHECK		0x02	/* this is a check button (it stays down) */
#define TBSTYLE_GROUP		0x04	/* this is a check button (it stays down) */
#define TBSTYLE_CHECKGROUP	(TBSTYLE_GROUP | TBSTYLE_CHECK)	/* this group is a member of a group radio group */


/* Because MciWnd and Mplayer require toolbar style with a miss-aligned
** button style, set this flag when creating a the toolbar
** with button alignment identical to one in comctl32.dll
*/
#define TBS_NORMAL      0x00000080L   /* normal style */

/*
** If you want little tool tips to popup next to your toolbar buttons
** use the style below.
*/
#define TBS_TOOLTIPS    0x00000100L   /* make/use a tooltips control */
#define TBSTYLE_TOOLTIPS TBS_TOOLTIPS



/*REVIEW: ifdef _INC_WINDOWSX, should we provide message crackers? */

#define TB_ENABLEBUTTON	(WM_USER + 1)
	/* wParam: UINT, button ID
	** lParam: BOOL LOWORD, enable if nonzero; HIWORD not used, 0
	** return: not used
	*/

#define TB_CHECKBUTTON	(WM_USER + 2)
	/* wParam: UINT, button ID
	** lParam: BOOL LOWORD, check if nonzero; HIWORD not used, 0
	** return: not used
	*/

#define TB_PRESSBUTTON	(WM_USER + 3)
	/* wParam: UINT, button ID
	** lParam: BOOL LOWORD, press if nonzero; HIWORD not used, 0
	** return: not used
	*/

#define TB_HIDEBUTTON	(WM_USER + 4)
	/* wParam: UINT, button ID
	** lParam: BOOL LOWORD, hide if nonzero; HIWORD not used, 0
	** return: not used
	*/
#define TB_INDETERMINATE	(WM_USER + 5)
	/* wParam: UINT, button ID
	** lParam: BOOL LOWORD, make indeterminate if nonzero; HIWORD not used, 0
	** return: not used
	*/

/*REVIEW: Messages up to WM_USER+8 are reserved until we define more state bits */

#define TB_ISBUTTONENABLED	(WM_USER + 9)
	/* wParam: UINT, button ID
	** lParam: not used, 0
	** return: BOOL LOWORD, enabled if nonzero; HIWORD not used
	*/

#define TB_ISBUTTONCHECKED	(WM_USER + 10)	
	/* wParam: UINT, button ID
	** lParam: not used, 0
	** return: BOOL LOWORD, checked if nonzero; HIWORD not used
	*/

#define TB_ISBUTTONPRESSED	(WM_USER + 11)	
	/* wParam: UINT, button ID
	** lParam: not used, 0
	** return: BOOL LOWORD, pressed if nonzero; HIWORD not used
	*/

#define TB_ISBUTTONHIDDEN	(WM_USER + 12)	
	/* wParam: UINT, button ID
	** lParam: not used, 0
	** return: BOOL LOWORD, hidden if nonzero; HIWORD not used
	*/

#define TB_ISBUTTONINDETERMINATE	(WM_USER + 13)	
	/* wParam: UINT, button ID
	** lParam: not used, 0
	** return: BOOL LOWORD, indeterminate if nonzero; HIWORD not used
	*/

/*REVIEW: Messages up to WM_USER+16 are reserved until we define more state bits */

#define TB_SETSTATE             (WM_USER + 17)
	/* wParam: UINT, button ID
	** lParam: UINT LOWORD, state bits; HIWORD not used, 0
	** return: not used
	*/

#define TB_GETSTATE             (WM_USER + 18)
	/* wParam: UINT, button ID
	** lParam: not used, 0
	** return: UINT LOWORD, state bits; HIWORD not used
	*/

#define TB_ADDBITMAP		(WM_USER + 19)

#ifdef WIN32
//    lparam - pointer to
typedef struct tagTB_ADDBITMAPINFO {
    UINT idResource;
    HANDLE hBitmap;
} TB_ADDBITMAPINFO;
#endif

	/* wParam: UINT, number of button graphics in bitmap
	** lParam: one of:
	**         HINSTANCE LOWORD, module handle; UINT HIWORD, resource id
	**         HINSTANCE LOWORD, NULL; HBITMAP HIWORD, bitmap handle
	** return: one of:
	**         int LOWORD, index for first new button; HIWORD not used
	**         int LOWORD, -1 indicating error; HIWORD not used
	*/

#define TB_ADDBUTTONS		(WM_USER + 20)
	/* wParam: UINT, number of buttons to add
	** lParam: LPTBBUTTON, pointer to array of TBBUTTON structures
	** return: not used
	*/

#define TB_INSERTBUTTON		(WM_USER + 21)
	/* wParam: UINT, index for insertion (appended if index doesn't exist)
	** lParam: LPTBBUTTON, pointer to one TBBUTTON structure
	** return: not used
	*/

#define TB_DELETEBUTTON		(WM_USER + 22)
	/* wParam: UINT, index of button to delete
	** lParam: not used, 0
	** return: not used
	*/

#define TB_GETBUTTON		(WM_USER + 23)
	/* wParam: UINT, index of button to get
	** lParam: LPTBBUTTON, pointer to TBBUTTON buffer to receive button
	** return: not used
	*/

#define TB_BUTTONCOUNT		(WM_USER + 24)
	/* wParam: not used, 0
	** lParam: not used, 0
	** return: UINT LOWORD, number of buttons; HIWORD not used
	*/

#define TB_COMMANDTOINDEX	(WM_USER + 25)
	/* wParam: UINT, command id
	** lParam: not used, 0
	** return: UINT LOWORD, index of button (-1 if command not found);
	**         HIWORD not used
	**/

#define TB_SAVERESTORE		(WM_USER + 26)
	/* wParam: BOOL, save state if nonzero (otherwise restore)
	** lParam: LPSTR FAR*, pointer to two LPSTRs:
	**         (LPSTR FAR*)(lParam)[0]: ini section name
	**         (LPSTR FAR*)(lParam)[1]: ini file name or NULL for WIN.INI
	** return: not used
	*/

#define TB_CUSTOMIZE            (WM_USER + 27)
	/* wParam: not used, 0
	** lParam: not used, 0
	** return: not used
	*/

#define TB_ADDSTRING		(WM_USER + 28)
	/* wParam: UINT, 0 if no resource; HINSTANCE, module handle
	** lParam: LPSTR, null-terminated strings with double-null at end
	**         UINT LOWORD, resource id
	** return: one of:
	**         int LOWORD, index for first new string; HIWORD not used
	**         int LOWORD, -1 indicating error; HIWORD not used
	*/

#define TB_GETITEMRECT		(WM_USER + 29)
	/* wParam: UINT, index of toolbar item whose rect to retrieve
	** lParam: LPRECT, pointer to a RECT struct to fill
	** return: Non-zero, if the RECT is successfully filled
	**         Zero, otherwise (item did not exist or was hidden)
	*/

#define TB_BUTTONSTRUCTSIZE	(WM_USER + 30)
	/* wParam: UINT, size of the TBBUTTON structure.  This is used
	**         as a version check.
	** lParam: not used
	** return: not used
	**
	** This is required before any buttons are added to the toolbar if
	** the toolbar is created using CreateWindow, but is implied when
	** using CreateToolbar and is a parameter to CreateToolbarEx.
	*/

#define TB_SETBUTTONSIZE	(WM_USER + 31)
	/* wParam: not used, 0
	** lParam: UINT LOWORD, button width
	**         UINT HIWORD, button height
	** return: not used
	**
	** The button size can only be set before any buttons are
	** added.  A default size of 24x22 is assumed if the size
	** is not set explicitly.
	*/

#define TB_SETBITMAPSIZE	(WM_USER + 32)
	/* wParam: not used, 0
	** lParam: UINT LOWORD, bitmap width
	**         UINT HIWORD, bitmap height
	** return: not used
	**
	** The bitmap size can only be set before any bitmaps are
	** added.  A default size of 16x15 is assumed if the size
	** is not set explicitly.
	*/

#define TB_AUTOSIZE		(WM_USER + 33)
	/* wParam: not used, 0
	** lParam: not used, 0
	** return: not used
	**
	** Application should call this after causing the toolbar size
	** to change by either setting the button or bitmap size or
	** by adding strings for the first time.
	*/

#define TB_SETBUTTONTYPE	(WM_USER + 34)
	/* wParam: WORD, frame control style of button (DFC_*)
	** lParam: not used, 0
	** return: not used
	*/

#define TB_GETTOOLTIPS		(WM_USER + 35)
	/* all params are NULL
	 * returns the hwnd for tooltips control  or NULL
	 */

#define TB_SETTOOLTIPS		(WM_USER + 36)
	/* wParam: HWND of ToolTips control to use
	 * lParam unused
	 */

#define TB_ACTIVATE_TOOLTIPS	(WM_USER + 37)
	/* wParam: TRUE = active, FALSE = unactive
	 * lParam unused
	 */

#endif /* NOTOOLBAR */


/*//////////////////////////////////////////////////////////////////////*/
#ifndef NOTOOLTIPS

#define WM_NOTIFY                       0x004E
typedef struct tagNMHDR                                 //
{                                                       //
    HWND  hwndFrom;                                     //
    UINT  idFrom;                                       //
    UINT  code;                                         //
}   NMHDR;                                              //
typedef NMHDR FAR * LPNMHDR;                            //

LRESULT WINAPI
SendNotify(
    HWND hwndTo,
    HWND hwndFrom,
    int code,
    NMHDR FAR *pnmhdr
    );

/* LRESULT Cls_OnNotify(HWND hwnd, int idFrom, NMHDR FAR* pnmhdr); */
#define HANDLE_WM_NOTIFY(hwnd, wParam, lParam, fn) \
    (fn)((hwnd), (int)(wParam), (NMHDR FAR*)(lParam))
#define FORWARD_WM_NOTIFY(hwnd, idFrom, pnmhdr, fn) \
    (void)(fn)((hwnd), WM_NOTIFY, (WPARAM)(int)(id), (LPARAM)(NMHDR FAR*)(pnmhdr))

// Generic WM_NOTIFY notification codes


#define NM_OUTOFMEMORY          (NM_FIRST-1)
#define NM_CLICK                (NM_FIRST-2)
#define NM_DBLCLK               (NM_FIRST-3)
#define NM_RETURN               (NM_FIRST-4)
#define NM_RCLICK               (NM_FIRST-5)
#define NM_RDBLCLK              (NM_FIRST-6)
#define NM_SETFOCUS             (NM_FIRST-7)
#define NM_KILLFOCUS            (NM_FIRST-8)


// WM_NOTIFY ranges

#define NM_FIRST        (0U-  0U)
#define NM_LAST         (0U- 99U)

#define LVN_FIRST       (0U-100U)
#define LVN_LAST        (0U-199U)

#define HDN_FIRST       (0U-300U)
#define HDN_LAST        (0U-399U)

#define TVN_FIRST       (0U-400U)
#define TVN_LAST        (0U-499U)

#define TTN_FIRST	(0U-520U)
#define TTN_LAST	(0U-549U)


#define TOOLTIPS_CLASS  TEXT("MCItooltips_class")

typedef struct {
    UINT cbSize;
    UINT uFlags;

    HWND hwnd;
    UINT uId;
    RECT rect;

    HINSTANCE hinst;
    LPTSTR lpszText;
} TOOLINFO, NEAR *PTOOLINFO, FAR *LPTOOLINFO;

#define LPSTR_TEXTCALLBACK   ((LPTSTR)-1)

#define TTS_ALWAYSTIP           0x01            // check over inactive windows as well

#define TTF_WIDISHWND   	0x01
#define TTF_STRIPACCELS 	0x08		// ;Internal (this is implicit now)

#define TTM_ACTIVATE		(WM_USER + 1)   // wparam = BOOL (true or false  = activate or deactivate)
//#define TTM_DEACTIVATE		(WM_USER + 2)     // ;Internal
#define TTM_SETDELAYTIME	(WM_USER + 3)
#define TTM_ADDTOOL		(WM_USER + 4)
#define TTM_DELTOOL		(WM_USER + 5)
#define TTM_NEWTOOLRECT		(WM_USER + 6)
#define TTM_RELAYEVENT		(WM_USER + 7)

// lParam has TOOLINFO with hwnd and wid.  this gets filled in
#define TTM_GETTOOLINFO    	(WM_USER + 8)

// lParam has TOOLINFO
#define TTM_SETTOOLINFO    	(WM_USER + 9)

// returns true or false for found, not found.
// fills in LPHITTESTINFO->ti
#define TTM_HITTEST             (WM_USER +10)
#define TTM_GETTEXT             (WM_USER +11)
#define TTM_UPDATETIPTEXT       (WM_USER +12)

typedef struct _TT_HITTESTINFO {
    HWND hwnd;
    POINT pt;
    TOOLINFO ti;
} TTHITTESTINFO, FAR * LPHITTESTINFO;




// WM_NOTIFY message sent to parent window to get tooltip text
// if TTF_QUERYFORTIP is set on any tips
#define TTN_NEEDTEXT	(TTN_FIRST - 0)

// WM_NOTIFY structure sent if TTF_QUERYFORTIP is set
typedef struct {
    NMHDR hdr;
    LPWSTR lpszText;
    WCHAR szText[80];
    HINSTANCE hinst;
} TOOLTIPTEXT, FAR *LPTOOLTIPTEXT;


#endif //NOTOOLTIPS


/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NOTRACKBAR
/*
    This control keeps its ranges in LONGs.  but for
    convienence and symetry with scrollbars
    WORD parameters are are used for some messages.
    if you need a range in LONGs don't use any messages
    that pack values into loword/hiword pairs

    The trackbar messages:
    message         wParam  lParam  return

    TBM_GETPOS      ------  ------  Current logical position of trackbar.
    TBM_GETRANGEMIN ------  ------  Current logical minimum position allowed.
    TBM_GETRANGEMAX ------  ------  Current logical maximum position allowed.
    TBM_SETTIC
    TBM_SETPOS
    TBM_SETRANGEMIN
    TBM_SETRANGEMAX
*/

#define TRACKBAR_CLASS          TEXT("MCIWndTrackbar")


BOOL WINAPI
InitTrackBar(
    HINSTANCE hInstance
    );

/* Trackbar styles */

/* add ticks automatically on TBM_SETRANGE message */
#define TBS_AUTOTICKS           0x0001L


/* Trackbar messages */

/* returns current position (LONG) */
#define TBM_GETPOS              (WM_USER)

/* set the min of the range to LPARAM */
#define TBM_GETRANGEMIN         (WM_USER+1)

/* set the max of the range to LPARAM */
#define TBM_GETRANGEMAX         (WM_USER+2)

/* wParam is index of tick to get (ticks are in the range of min - max) */
#define TBM_GETTIC              (WM_USER+3)

/* wParam is index of tick to set */
#define TBM_SETTIC              (WM_USER+4)

/* set the position to the value of lParam (wParam is the redraw flag) */
#define TBM_SETPOS              (WM_USER+5)

/* LOWORD(lParam) = min, HIWORD(lParam) = max, wParam == fRepaint */
#define TBM_SETRANGE            (WM_USER+6)

/* lParam is range min (use this to keep LONG precision on range) */
#define TBM_SETRANGEMIN         (WM_USER+7)

/* lParam is range max (use this to keep LONG precision on range) */
#define TBM_SETRANGEMAX         (WM_USER+8)

/* remove the ticks */
#define TBM_CLEARTICS           (WM_USER+9)

/* select a range LOWORD(lParam) min, HIWORD(lParam) max */
#define TBM_SETSEL              (WM_USER+10)

/* set selection rang (LONG form) */
#define TBM_SETSELSTART         (WM_USER+11)
#define TBM_SETSELEND           (WM_USER+12)

// #define TBM_SETTICTOK           (WM_USER+13)

/* return a pointer to the list of tics (DWORDS) */
#define TBM_GETPTICS            (WM_USER+14)

/* get the pixel position of a given tick */
#define TBM_GETTICPOS           (WM_USER+15)
/* get the number of tics */
#define TBM_GETNUMTICS          (WM_USER+16)

/* get the selection range */
#define TBM_GETSELSTART         (WM_USER+17)
#define TBM_GETSELEND  	        (WM_USER+18)

/* clear the selection */
#define TBM_CLEARSEL  	        (WM_USER+19)

/*REVIEW: these match the SB_ (scroll bar messages); define them that way? */

#define TB_LINEUP		0
#define TB_LINEDOWN		1
#define TB_PAGEUP		2
#define TB_PAGEDOWN		3
#define TB_THUMBPOSITION	4
#define TB_THUMBTRACK		5
#define TB_TOP			6
#define TB_BOTTOM		7
#define TB_ENDTRACK             8
#endif

/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NOSTATUSBAR

/* Here exists the only known documentation for status.c and header.c
 */

#ifndef _INC_STATUSBAR
#define _INC_STATUSBAR
VOID WINAPI DrawStatusTextA(HDC hDC, LPRECT lprc, LPCSTR szText, UINT uFlags);
VOID WINAPI DrawStatusTextW(HDC hDC, LPRECT lprc, LPCWSTR szText, UINT uFlags);
#ifdef UNICODE
#define DrawStatusText DrawStatusTextW
#else
#define DrawStatusText DrawStatusTextA
#endif // !UNICODE
/* This is used if the app wants to draw status in its client rect,
 * instead of just creating a window.  Note that this same function is
 * used internally in the status bar window's WM_PAINT message.
 * hDC is the DC to draw to.  The font that is selected into hDC will
 * be used.  The RECT lprc is the only portion of hDC that will be drawn
 * to: the outer edge of lprc will have the highlights (the area outside
 * of the highlights will not be drawn in the BUTTONFACE color: the app
 * must handle that).  The area inside the highlights will be erased
 * properly when drawing the text.
 */

HWND WINAPI CreateStatusWindowA(LONG style, LPCSTR lpszText,
      HWND hwndParent, WORD wID);
HWND WINAPI CreateStatusWindowW(LONG style, LPCWSTR lpszText,
      HWND hwndParent, WORD wID);
#ifdef UNICODE
#define CreateStatusWindow CreateStatusWindowW
#else
#define CreateStatusWindow CreateStatusWindowA
#endif // !UNICODE
HWND WINAPI CreateHeaderWindowA(LONG style, LPCSTR lpszText,
      HWND hwndParent, WORD wID);
HWND WINAPI CreateHeaderWindowW(LONG style, LPCWSTR lpszText,
      HWND hwndParent, WORD wID);
#ifdef UNICODE
#define CreateHeaderWindow CreateHeaderWindowW
#else
#define CreateHeaderWindow CreateHeaderWindowA
#endif // !UNICODE
/* This creates a "default" status/header window.  This window will have the
 * default borders around the text, the default font, and only one pane.
 * It may also automatically resize and move itself (depending on the SBS_*
 * flags).
 * style should contain WS_CHILD, and can contain WS_BORDER and WS_VISIBLE,
 * plus any of the SBS_* styles described below.  I don't know about other
 * WS_* styles.
 * lpszText is the initial text for the first pane.
 * hwndParent is the window the status bar exists in, and should not be NULL.
 * wID is the child window ID of the window.
 * hInstance is the instance handle of the application using this.
 * Note that the app can also just call CreateWindow with
 * STATUSCLASSNAME/HEADERCLASSNAME to create a window of a specific size.
 */


#define STATUSCLASSNAMEW L"msctls_statusbar"
#define STATUSCLASSNAMEA "msctls_statusbar"

#ifdef UNICODE
#define STATUSCLASSNAME STATUSCLASSNAMEW
#else
#define STATUSCLASSNAME STATUSCLASSNAMEA
#endif

/* This is the name of the status bar class (it will probably change later
 * so use the #define here).
 */
#define HEADERCLASSNAMEW L"msctls_headerbar"
#define HEADERCLASSNAMEA "msctls_headerbar"

#ifdef UNICODE
#define HEADERCLASSNAME HEADERCLASSNAMEW
#else
#define HEADERCLASSNAME HEADERCLASSNAMEA
#endif

/* This is the name of the header class (it will probably change later
 * so use the #define here).
 */


#define SB_SETTEXTA      WM_USER+1
#define SB_GETTEXTA      WM_USER+2
#define SB_GETTEXTW      WM_USER+10
#define SB_SETTEXTW      WM_USER+11

#ifdef UNICODE
#define SB_GETTEXT       SB_GETTEXTW
#define SB_SETTEXT       SB_SETTEXTW
#else
#define SB_GETTEXT       SB_GETTEXTA
#define SB_SETTEXT       SB_SETTEXTA
#endif // UNICODE

#define SB_GETTEXTLENGTH   WM_USER+3
/* Just like WM_?ETTEXT*, with wParam specifying the pane that is referenced
 * (at most 255).
 * Note that you can use the WM_* versions to reference the 0th pane (this
 * is useful if you want to treat a "default" status bar like a static text
 * control).
 * For SETTEXT, wParam is the pane or'ed with SBT_* style bits (defined below).
 * If the text is "normal" (not OWNERDRAW), then a single pane may have left,
 * center, and right justified text by separating the parts with a single tab,
 * plus if lParam is NULL, then the pane has no text.  The pane will be
 * invalidated, but not draw until the next PAINT message.
 * For GETTEXT and GETTEXTLENGTH, the LOWORD of the return will be the length,
 * and the HIWORD will be the SBT_* style bits.
 */
#define SB_SETPARTS     WM_USER+4
/* wParam is the number of panes, and lParam points to an array of points
 * specifying the right hand side of each pane.  A right hand side of -1 means
 * it goes all the way to the right side of the control minus the X border
 */
#define SB_SETBORDERS      WM_USER+5
/* lParam points to an array of 3 integers: X border, Y border, between pane
 * border.  If any is less than 0, the default will be used for that one.
 */
#define SB_GETPARTS     WM_USER+6
/* lParam is a pointer to an array of integers that will get filled in with
 * the right hand side of each pane and wParam is the size (in integers)
 * of the lParam array (so we do not go off the end of it).
 * Returns the number of panes.
 */
#define SB_GETBORDERS      WM_USER+7
/* lParam is a pointer to an array of 3 integers that will get filled in with
 * the X border, the Y border, and the between pane border.
 */
#define SB_SETMINHEIGHT    WM_USER+8
/* wParam is the minimum height of the status bar "drawing" area.  This is
 * the area inside the highlights.  This is most useful if a pane is used
 * for an OWNERDRAW item, and is ignored if the SBS_NORESIZE flag is set.
 * Note that WM_SIZE must be sent to the control for any size changes to
 * take effect.
 */
#define SB_SIMPLE    WM_USER+9
/* wParam specifies whether to set (non-zero) or unset (zero) the "simple"
 * mode of the status bar.  In simple mode, only one pane is displayed, and
 * its text is set with LOWORD(wParam)==255 in the SETTEXT message.
 * OWNERDRAW is not allowed, but other styles are.
 * The pane gets invalidated, but not painted until the next PAINT message,
 * so you can set new text without flicker (I hope).
 * This can be used with the WM_INITMENU and WM_MENUSELECT messages to
 * implement help text when scrolling through a menu.
 */

#define HB_SAVERESTORE     WM_USER+0x100
/* This gets a header bar to read or write its state to or from an ini file.
 * wParam is 0 for reading, non-zero for writing.  lParam is a pointer to
 * an array of two LPTSTR's: the section and file respectively.
 * Note that the correct number of partitions must be set before calling this.
 */
#define HB_ADJUST    WM_USER+0x101
/* This puts the header bar into "adjust" mode, for changing column widths
 * with the keyboard.
 */
#define HB_SETWIDTHS    SB_SETPARTS
/* Set the widths of the header columns.  Note that "springy" columns only
 * have a minumum width, and negative width are assumed to be hidden columns.
 * This works just like SB_SETPARTS.
 */
#define HB_GETWIDTHS    SB_GETPARTS
/* Get the widths of the header columns.  Note that "springy" columns only
 * have a minumum width.  This works just like SB_GETPARTS.
 */
#define HB_GETPARTS     WM_USER+0x102
/* Get a list of the right-hand sides of the columns, for use when drawing the
 * actual columns for which this is a header.
 * lParam is a pointer to an array of integers that will get filled in with
 * the right hand side of each pane and wParam is the size (in integers)
 * of the lParam array (so we do not go off the end of it).
 * Returns the number of panes.
 */
#define HB_SHOWTOGGLE      WM_USER+0x103
/* Toggle the hidden state of a column.  wParam is the 0-based index of the
 * column to toggle.
 */


#define SBT_OWNERDRAW   0x1000
/* The lParam of the SB_SETTEXT message will be returned in the DRAWITEMSTRUCT
 * of the WM_DRAWITEM message.  Note that the fields CtlType, itemAction, and
 * itemState of the DRAWITEMSTRUCT are undefined for a status bar.
 * The return value for GETTEXT will be the itemData.
 */
#define SBT_NOBORDERS   0x0100
/* No borders will be drawn for the pane.
 */
#define SBT_POPOUT   0x0200
/* The text pops out instead of in
 */
#define HBT_SPRING   0x0400
/* this means that the item is "springy", meaning that it has a minimum
 * width, but will grow if there is extra room in the window.  Note that
 * multiple springs are allowed, and the extra room will be distributed
 * among them.
 */

/* Here's a simple dialog function that uses a default status bar to display
 * the mouse position in the given window.
 *
 * extern HINSTANCE hInst;
 *
 * BOOL CALLBACK MyWndProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
 * {
 *   switch (msg)
 *     {
 *       case WM_INITDIALOG:
 *         CreateStatusWindow(WS_CHILD|WS_BORDER|WS_VISIBLE, "", hDlg,
 *               IDC_STATUS, hInst);
 *         break;
 *
 *       case WM_SIZE:
 *         SendDlgItemMessage(hDlg, IDC_STATUS, WM_SIZE, 0, 0L);
 *         break;
 *
 *       case WM_MOUSEMOVE:
 *         wsprintf(szBuf, "%d,%d", LOWORD(lParam), HIWORD(lParam));
 *         SendDlgItemMessage(hDlg, IDC_STATUS, SB_SETTEXT, 0,
 *               (LPARAM)(LPTSTR)szBuf);
 *         break;
 *
 *       default:
 *         break;
 *     }
 *   return(FALSE);
 * }
 */

#endif /* _INC_STATUSBAR */

#endif


#ifndef HBN_BEGINDRAG
/*/////////////////////////////////////////////////////////////////////////*/

/*REVIEW: move these to their appropriate control sections. */

/* Note that the set of HBN_* and TBN_* defines must be a disjoint set so
 * that MenuHelp can tell them apart.
 */

/* These are in the HIWORD of lParam in WM_COMMAND messages sent from a
 * header bar when the user adjusts the headers with the mouse or keyboard.
 */
#define HBN_BEGINDRAG	0x0101
#define HBN_DRAGGING	0x0102
#define HBN_ENDDRAG	0x0103

/* These are in the HIWORD of lParam in WM_COMMAND messages sent from a
 * header bar when the user adjusts the headers with the keyboard.
 */
#define HBN_BEGINADJUST	0x0111
#define HBN_ENDADJUST	0x0112

/* These are in the HIWORD of lParam in WM_COMMAND messages sent from a
 * tool bar.  If the left button is pressed and then released in a single
 * "button" of a tool bar, then a WM_COMMAND message will be sent with wParam
 * being the id of the button.
 */
#define TBN_BEGINDRAG	0x0201
#define TBN_ENDDRAG	0x0203

/* These are in the HIWORD of lParam in WM_COMMAND messages sent from a
 * tool bar.  The TBN_BEGINADJUST message is sent before the "insert"
 * dialog appears.  The app must return a handle (which will
 * NOT be freed by the toolbar) to an ADJUSTINFO struct for the TBN_ADJUSTINFO
 * message; the LOWORD of lParam is the index of the button whose info should
 * be retrieved.  The app can clean up in the TBN_ENDADJUST message.
 * The app should reset the toolbar on the TBN_RESET message.
 */
#define TBN_BEGINADJUST	0x0204
#define TBN_ADJUSTINFO	0x0205
#define TBN_ENDADJUST	0x0206
#define TBN_RESET	0x0207

/* These are in the HIWORD of lParam in WM_COMMAND messages sent from a
 * tool bar.  The LOWORD is the index where the button is or will be.
 * If the app returns FALSE from either of these during a button move, then
 * the button will not be moved.  If the app returns FALSE to the INSERT
 * when the toolbar tries to add buttons, then the insert dialog will not
 * come up.  TBN_TOOLBARCHANGE is sent whenever any button is added, moved,
 * or deleted from the toolbar by the user, so the app can do stuff.
 */
#define TBN_QUERYINSERT	0x0208
#define TBN_QUERYDELETE	0x0209
#define TBN_TOOLBARCHANGE	0x020a

/* This is in the HIWORD of lParam in a WM_COMMAND message.  It notifies the
 * parent of a toolbar that the HELP button was pressed in the toolbar
 * customize dialog.  The dialog window handle is in the LOWORD of lParam.
 */
#define TBN_CUSTHELP	0x020b


/* Note that the following flags are checked every time the window gets a
 * WM_SIZE message, so the style of the window can be changed "on-the-fly".
 * If NORESIZE is set, then the app is responsible for all control placement
 * and sizing.  If NOPARENTALIGN is set, then the app is responsible for
 * placement.  If neither is set, the app just needs to send a WM_SIZE
 * message for the window to be positioned and sized correctly whenever the
 * parent window size changes.
 * Note that for STATUS bars, CCS_BOTTOM is the default, for HEADER bars,
 * CCS_NOMOVEY is the default, and for TOOL bars, CCS_TOP is the default.
 */
#define CCS_TOP			0x00000001L
/* This flag means the status bar should be "top" aligned.  If the
 * NOPARENTALIGN flag is set, then the control keeps the same top, left, and
 * width measurements, but the height is adjusted to the default, otherwise
 * the status bar is positioned at the top of the parent window such that
 * its client area is as wide as the parent window and its client origin is
 * the same as its parent.
 * Similarly, if this flag is not set, the control is bottom-aligned, either
 * with its original rect or its parent rect, depending on the NOPARENTALIGN
 * flag.
 */
#define CCS_NOMOVEY		0x00000002L
/* This flag means the control may be resized and moved horizontally (if the
 * CCS_NORESIZE flag is not set), but it will not move vertically when a
 * WM_SIZE message comes through.
 */
#define CCS_BOTTOM		0x00000003L
/* Same as CCS_TOP, only on the bottom.
 */
#define CCS_NORESIZE		0x00000004L
/* This flag means that the size given when creating or resizing is exact,
 * and the control should not resize itself to the default height or width
 */
#define CCS_NOPARENTALIGN	0x00000008L
/* This flag means that the control should not "snap" to the top or bottom
 * or the parent window, but should keep the same placement it was given
 */
#define CCS_NOHILITE		0x00000010L
/* Don't draw the one pixel highlight at the top of the control
 */
#define CCS_ADJUSTABLE		0x00000020L
/* This allows a toolbar (header bar?) to be configured by the user.
 */
#define CCS_NODIVIDER		0x00000040L
/* Don't draw the 2 pixel highlight at top of control (toolbar)
 */
#endif

/*/////////////////////////////////////////////////////////////////////////*/

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif /* _INC_MMCNTRLS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcicda\cddrvr.c ===
/*******************************Module*Header*********************************\
* Module Name: cddrvr.c
*
* Installalble driver stuff for the
*
* Media Control Architecture Redbook Audio Device Driver
*
* Created: 10/7/90
* Author:  DLL (DavidLe)
*
* History:
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\******************************************************************************/
#include <stdlib.h>
#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <winreg.h>
#include "mcicda.h"
#include "cda.h"
#include "cdio.h"

HANDLE    InitCritSection = NULL;

#define MYREGSTR_PATH_MEDIA  TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaResources")
static TCHAR gszRegstrCDAPath[] = MYREGSTR_PATH_MEDIA TEXT("\\mci\\cdaudio");
static TCHAR gszUnitEnum[] = TEXT("%s\\unit %d");
static TCHAR gszSettingsKey[] = TEXT("Volume Settings");
static TCHAR gszDefaultCDA[] = TEXT("Default Drive");

int PASCAL FAR CDAConfig (HWND hwndParent);
DWORD NEAR PASCAL drvOpen (LPMCI_OPEN_DRIVER_PARMS lpDrvOpen);

UINT CDAudio_GetDefDrive();

typedef BOOL (WINAPI *SHOWMMCPLPROPSHEETW)(HWND hwndParent,
                                           LPCWSTR szPropSheetID,
                                           LPWSTR szTabName,
                                           LPWSTR szCaption);

#define _MAX_PATH 260

/*****************************************************************************
 @doc INTERNAL MCICDA

 @api   DWORD NEAR PASCAL | drvOpen |

 @parm  LPMCI_OPEN_DRIVER_PARMS | lpDrvOpen |

 @rdesc

 @comm
*****************************************************************************/

#define CONFIG_ID   10000L  // Use the hiword of dwDriverID to identify
                            // config. opens

DWORD NEAR PASCAL drvOpen (LPMCI_OPEN_DRIVER_PARMS lpDrvOpen)
{
    DWORD dwRes;
    if (lpDrvOpen == NULL)
    {
        dwRes = CONFIG_ID;
    }
    else
    {
        long    lSupportInfo;
        int     numdrives;
        LPCTSTR lpstrBuf;
        DID     didDrive;
        PINSTDATA pInst;
        /*
          Sent to the driver when it is opened.

          dwDriverID is 0L.

          lParam1 is a far pointer to a zero-terminated string
          containing the name used to open the driver.

          lParam2 is passed through from the drvOpen call.

          Return 0L to FAIL the open.
        */

        lpDrvOpen->wType = MCI_DEVTYPE_CD_AUDIO;
        lpDrvOpen->wCustomCommandTable = MCI_TABLE_NOT_PRESENT;

		EnterCrit (InitCritSection);
        numdrives = CDA_init_audio ();
		LeaveCrit (InitCritSection);
        dprintf2(("Number of CD drives found = %d", numdrives));

        if (numdrives <= 0)
            return 0;

        if (numdrives > 1)
        {
            lpstrBuf = lpDrvOpen->lpstrParams;

            while (*lpstrBuf == ' ')
                ++lpstrBuf;
            if (*lpstrBuf == '\0')
            {
                didDrive = CDAudio_GetDefDrive();
            }
            else
                didDrive = *lpstrBuf - '0';

            if (didDrive >= MCIRBOOK_MAX_DRIVES)
                return 0;
        } else
            didDrive = 0;

        // get the next drive with audio support

        for (;didDrive < numdrives;didDrive++)
        {
            EnterCrit (CdInfo[didDrive].DeviceCritSec);
            if (!CDA_open (didDrive)) {
               LeaveCrit (CdInfo[didDrive].DeviceCritSec);
               continue;
            }

            lSupportInfo = CDA_get_support_info(didDrive);

            if (lSupportInfo & SUPPORTS_REDBOOKAUDIO)
                break;

            CDA_close (didDrive);
            LeaveCrit (CdInfo[didDrive].DeviceCritSec);
        }

        // no drives with audio

        if (! (lSupportInfo & SUPPORTS_REDBOOKAUDIO))
        {
            return 0;
        }

        // Future domain driver will not fail previous checks if no data cable

        if ((lSupportInfo & DISC_IN_DRIVE) &&
            CDA_time_info (didDrive, NULL, NULL) != COMMAND_SUCCESSFUL)
        {
            CDA_close (didDrive);
            LeaveCrit (CdInfo[didDrive].DeviceCritSec);
            return 0;
        }

        CDA_close (didDrive);
        LeaveCrit (CdInfo[didDrive].DeviceCritSec);

        if ((pInst = (PINSTDATA)LocalAlloc(LPTR, sizeof(INSTDATA))) == NULL)
        {
            return 0;
        }

        pInst->uMCIDeviceID = lpDrvOpen->wDeviceID;
        pInst->uDevice = didDrive;

        mciSetDriverData (lpDrvOpen->wDeviceID, (DWORD_PTR)pInst);
        dwRes = lpDrvOpen->wDeviceID;
    }
    return dwRes;
}


UINT CDAudio_GetDefDrive()
{
    HKEY hkTmp;
    DWORD uDrive = 0;
    if (RegOpenKey(HKEY_LOCAL_MACHINE
                   , gszRegstrCDAPath
                   , &hkTmp ) == ERROR_SUCCESS)
    {
        DWORD cb = sizeof(DWORD);
        RegQueryValueEx(hkTmp
                      , gszDefaultCDA
                      , NULL
                      , NULL
                      , (LPBYTE)&uDrive
                      , &cb);
        RegCloseKey(hkTmp);
    }
    return (UINT)uDrive;
}

typedef struct {
    DWORD   unit;
    DWORD   dwVol;
} CDAREG, *PCDAREG;

DWORD CDAudio_GetUnitVolume(
    UINT uDrive)
{
    HKEY hkTmp;
    CDAREG cda;
    TCHAR  szRegstrCDAudio[_MAX_PATH];

    wsprintf (szRegstrCDAudio, gszUnitEnum, gszRegstrCDAPath, uDrive);

    cda.dwVol = 0xff;

    if (RegOpenKey(HKEY_LOCAL_MACHINE,szRegstrCDAudio,&hkTmp) == ERROR_SUCCESS)
    {
        DWORD cbCDA = sizeof(CDAREG);
        RegQueryValueEx(hkTmp
                        , gszSettingsKey
                        , NULL
                        , NULL
                        , (LPBYTE)&cda
                        , &cbCDA);
        RegCloseKey(hkTmp);
    }
    return cda.dwVol;
}



/***************************************************************************
 *
 * @doc     INTERNAL
 *
 * @func    DWORD | DriverProc | The entry point for an installable driver.
 *
 * @parm    DWORD | dwDriverId | For most messages, dwDriverId is the DWORD
 *          value that the driver returns in response to a DRV_OPEN message.
 *          Each time that the driver is opened, through the DrvOpen API,
 *          the driver receives a DRV_OPEN message and can return an
 *          arbitrary, non-zero, value. The installable driver interface
 *          saves this value and returns a unique driver handle to the
 *          application. Whenever the application sends a message to the
 *          driver using the driver handle, the interface routes the message
 *          to this entry point and passes the corresponding dwDriverId.
 *
 *          This mechanism allows the driver to use the same or different
 *          identifiers for multiple opens but ensures that driver handles
 *          are unique at the application interface layer.
 *
 *          The following messages are not related to a particular open
 *          instance of the driver.
 *
 *              DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 * @parm    HANDLE | hDriver | This is the handle returned to the
 *          application by the driver interface.
 *
 * @parm    UINT | message | The requested action to be performed. Message
 *          values below DRV_RESERVED are used for globally defined messages.
 *          Message values from DRV_RESERVED to DRV_USER are used for
 *          defined driver portocols. Messages above DRV_USER are used
 *          for driver specific messages.
 *
 * @parm    DWORD | dwParam1 | Data for this message.  Defined separately for
 *          each message
 *
 * @parm    DWORD | dwParam2 | Data for this message.  Defined separately for
 *          each message
 *
 * @rdesc Defined separately for each message.
 *
 ***************************************************************************/
LRESULT DriverProc (DWORD_PTR dwDriverID, HANDLE hDriver, UINT message,
                   LPARAM lParam1, LPARAM lParam2)
{
    LRESULT   dwRes;
    PINSTDATA pInst;
	TCHAR     szMutex[32];

    switch (message)
        {

        // Standard, globally used messages.

        case DRV_LOAD:
            {
                int i;

				InitCritSection = CreateMutex (NULL, FALSE, TEXT ("MCICDA_InitCritSection"));

                for ( i = 0; i <  MCIRBOOK_MAX_DRIVES; i++ ) {
					CdInfo[i].DeviceCritSec = NULL;
					wsprintf (szMutex, TEXT ("%s%ld"), TEXT ("MCICDA_DeviceCritSec_"), i);
					CdInfo[i].DeviceCritSec = CreateMutex (NULL, FALSE, szMutex);
                }

#if DBG
                DebugLevel = GetProfileIntW(L"mmdebug", L"mcicda", 0);
#endif
                dprintf2(("DRV_LOAD"));

                /*
                   Sent to the driver when it is loaded. Always the first
                   message received by a driver.

                   dwDriverID is 0L.
                   lParam1 is 0L.
                   lParam2 is 0L.

                   Return 0L to FAIL the load.
                */

                hInstance = GetModuleHandleW( L"mcicda");
                dwRes = 1L;

            }
            break;



        case DRV_FREE:
            {
                int     i;

                dprintf2(("DRV_FREE"));
                /*
                   Sent to the driver when it is about to be discarded. This
                   will always be the last message received by a driver before
                   it is freed.

                   dwDriverID is 0L.
                   lParam1 is 0L.
                   lParam2 is 0L.

                   Return value is IGNORED.
                */

                dwRes = 1L;
				if (InitCritSection) {
					CloseHandle (InitCritSection);
					InitCritSection = NULL;
				}

                for ( i = 0; i <  MCIRBOOK_MAX_DRIVES; i++ ) {
					if (CdInfo[i].DeviceCritSec) {
						CloseHandle (CdInfo[i].DeviceCritSec);
						CdInfo[i].DeviceCritSec = NULL;
					}
                }
            }
            break;

        case DRV_OPEN:
            dprintf2(("DRV_OPEN"));
            dwRes = drvOpen((LPMCI_OPEN_DRIVER_PARMS)lParam2);
            break;

        case DRV_CLOSE:

            dprintf2(("DRV_CLOSE"));
            /*
               Sent to the driver when it is closed. Drivers are unloaded
               when the close count reaches zero.

               dwDriverID is the driver identifier returned from the
               corresponding DRV_OPEN.

               lParam1 is passed through from the drvOpen call.

               lParam2 is passed through from the drvOpen call.

               Return 0L to FAIL the close.
            */

            dwRes = 1L;
            break;

        case DRV_ENABLE:

            dprintf2(("DRV_ENABLE"));
            /*
               Sent to the driver when the driver is loaded or reloaded
               and whenever windows is enabled. Drivers should only
               hook interrupts or expect ANY part of the driver to be in
               memory between enable and disable messages

               dwDriverID is 0L.
               lParam1 is 0L.
               lParam2 is 0L.

               Return value is ignored.

            */

            dwRes = 1L;
            break;

        case DRV_DISABLE:

            dprintf2(("DRV_DISABLE"));
            /*
               Sent to the driver before the driver is freed.
               and whenever windows is disabled

               dwDriverID is 0L.
               lParam1 is 0L.
               lParam2 is 0L.

               Return value is ignored.

            */

            dwRes = 1L;
            break;

       case DRV_QUERYCONFIGURE:
            dprintf2(("DRV_QUERYCONFIGURE"));

            /*
                Sent to the driver so that applications can
                determine whether the driver supports custom
                configuration. The driver should return a
                non-zero value to indicate that configuration
                is supported.

                dwDriverID is the value returned from the DRV_OPEN
                call that must have succeeded before this message
                was sent.

                lParam1 is passed from the app and is undefined.
                lParam2 is passed from the app and is undefined.

                return 0L to indicate configuration NOT supported.

            */

            dwRes = 1L;
            break;

       case DRV_CONFIGURE:
            dprintf2(("DRV_CONFIGURE"));

            /*
                Sent to the driver so that it can display a custom
                configuration dialog box.

                lParam1 is passed from the app. and should contain
                the parent window handle in the loword.
                lParam2 is passed from the app and is undefined.

                return value is undefined.

                Drivers should create their own section in
                system.ini. The section name should be the driver
                name.


            */

            if (lParam1)
            {
                dwRes = CDAConfig((HWND)LOWORD (lParam1));
            } else {
                dwRes = DRVCNF_CANCEL;
            }
            break;

        default:
            if (dwDriverID != CONFIG_ID &&
                message >= DRV_MCI_FIRST && message <= DRV_MCI_LAST) {
                dwRes = CD_MCI_Handler ((MCIDEVICEID)dwDriverID, message,
                                        lParam1, lParam2);
            } else {
                dwRes = DefDriverProc(dwDriverID, hDriver, message,
                                      lParam1, lParam2);
            }
            break;
        }

    return (LRESULT)dwRes;
}

/*****************************Private*Routine******************************\
* EnterCrit
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
EnterCrit(
	HANDLE hMutex
    )
{
    dprintf4(( "Entering Crit Sect 0x%X", hMutex ));
	if (hMutex)
	{
		WaitForSingleObject (hMutex, INFINITE);
	}
}

/*****************************Private*Routine******************************\
* LeaveCrit
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
LeaveCrit(
    HANDLE hMutex
    )
{
    dprintf4(( "Leaving Crit Sect 0x%X", hMutex ));
	if (hMutex)
	{
		ReleaseMutex (hMutex);
	}
}


/*****************************************************************************
 @doc INTERNAL MCICDA

 @api   int |   CDAConfig |

 @parm  HWND | hwndParent  |

 @rdesc

 @comm
*****************************************************************************/
int CDAConfig (HWND hwndParent)
{
    static HWND     hwndPrevParent = NULL;
    WCHAR           szCaptionW[ 128 ];

    // We need only a unicode version of the caption (for FindWindow()
    // and ShowMMCPLPropertySheetW(), which are unicode-enabled).
    //
    LoadStringW(hInstance,IDS_CDMUSICCAPTION,szCaptionW,cchLENGTH(szCaptionW));

    if (hwndPrevParent)
    {
        BringWindowToTop(FindWindowW(NULL, szCaptionW));
    }
    else
    {
        HINSTANCE h;
        SHOWMMCPLPROPSHEETW fn;
        static TCHAR aszMMSystemW[] = TEXT("MMSYS.CPL");
        static char aszShowPropSheetA[] = "ShowMMCPLPropertySheetW";
        static WCHAR aszCDAudioW[] = L"CDAUDIO";
        WCHAR   szCDMusicW[64];
        LoadStringW(hInstance, IDS_CDMUSIC, szCDMusicW, cchLENGTH(szCDMusicW));

        h = LoadLibrary (aszMMSystemW);
        if (h)
        {
            fn = (SHOWMMCPLPROPSHEETW)GetProcAddress(h, aszShowPropSheetA);
            if (fn)
            {
                BOOL f;

                hwndPrevParent = hwndParent;
                CDA_init_audio ();
                f = fn(hwndParent, aszCDAudioW, szCDMusicW, szCaptionW);
                CDA_terminate_audio ();
                hwndPrevParent = NULL;
            }
            FreeLibrary(h);
        }
    }
    return DRVCNF_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\inc\win32.h ===
/****************************************************************************
 *
 *  Win32.h
 *
 *  Windows 16/32 porting helper file
 *
 *
 ***************************************************************************/
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/

#ifndef INC_OLE2
#define INC_OLE2
#endif

#ifndef INC_WIN32_H
#define INC_WIN32_H  // Protect against double inclusion of this file

#if !defined(WIN32) && defined(_WIN32)
    #define WIN32
#endif

#if !defined(DEBUG) && defined(_DEBUG)
    #define DEBUG
#endif


#ifdef WIN32

// Set up a single define to allow CHICAGO or NT (Daytona)
// N.B.  We CANNOT use WINVER <= 0x400 to determine if this is Chicago
// or Daytona.  Parts of the Daytona code use Common Controls.  For this
// to work WINVER is defined as 0x0400...
// On the other hand, no Chicago code is compiled with UNICODE defined.
#ifdef UNICODE
    #define DAYTONA
    #undef CHICAGO
#else
    #ifndef CHICAGO
	#define CHICAGO
    #endif
    #undef  DAYTONA
#endif // UNICODE

#ifndef RC_INVOKED
    #pragma warning(disable:4103)
#endif
    #define     _INC_OLE

#else  // 16 bit compilation - must be Chicago

    #ifndef CHICAGO
    #define     CHICAGO
    #endif

#endif  // WIN32

#if !defined(_INC_WINDOWS) || !defined(_WINDOWS)
#include <windows.h>
#include <windowsx.h>
#if WINVER >= 0x400
#include <winerror.h>
#endif
#include <mmsystem.h>
#endif // INC_WINDOWS...

#ifndef EXTERN_C
#ifdef __cplusplus
	#define EXTERN_C extern "C"
#else
	#define EXTERN_C extern
#endif
#endif

// Not just for Daytona, things like mciavi define WINVER=0x30a
#ifndef WS_EX_RIGHT
	#define WS_EX_RIGHT             0x00001000L     // ;Internal 4.0
	#define WS_EX_LEFT              0x00000000L     // ;Internal 4.0
	#define WS_EX_RTLREADING        0x00002000L     // ;Internal 4.0
	#define WS_EX_LTRREADING        0x00000000L     // ;Internal 4.0
	#define WS_EX_LEFTSCROLLBAR     0x00004000L     // ;Internal 4.0
	#define WS_EX_RIGHTSCROLLBAR    0x00000000L     // ;Internal 4.0
#endif

// Win 16 and Win 32 use different macros to turn code debugging on/off
// Map the 16 bit version to the NT conventions.
// In particular on NT, debug builds are identified by DBG==1  (and retail
// with DBG==0), hence the NT only source uses #if DBG.  Note: #ifdef DBG
// is ALWAYS true on NT.
// Chicago (and VFW 16 bit code) uses #ifdef DEBUG.  The complex of
// instructions below should ensure that whether this is Chicago or NT that
//    a debug build implies DEBUG defined and DBG==1
//    a retail build implies DEBUG NOT defined, and DBG==0

#ifdef WIN32
#ifndef DBG
#ifdef DEBUG
    #define DBG 1
#else
    #define DBG 0
#endif
#endif

#undef DEBUG

#if DBG
    #define DEBUG
    #define STATICFN
    #define STATICDT
#else
    #define STATICFN static
    #define STATICDT static
#endif

#else    // !WIN32
    #define STATICFN static
    #define STATICDT static
#endif //WIN32

#if !defined FASTCALL
#define FASTCALL  __fastcall
#endif
#if !defined _FASTCALL
#define _FASTCALL __fastcall
#endif

#if !defined NUMELMS
#define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif


#ifdef WIN32

/* --- Win32 version --------------------------------------------------- */

	#include <string.h>
	#include <memory.h>

	#undef CDECL
#if defined(_MIPS_) || defined(_PPC_)
	#define __stdcall
	#define _stdcall
	#define _cdecl
	#define __cdecl
	#define CDECL
#else
	#define CDECL _cdecl
#endif

    //typedef BITMAPINFOHEADER FAR *LPBITMAPINFOHEADER;

	#define far
	#define _far
	#define __far
	#define HUGE_T
	#undef HUGE
    #define HUGE
	#define huge
	#define _huge
	#define __huge
	#define near
	#define _near
	#define __near
	#define _fastcall
	#define __fastcall
	#define _loadds
	#define __loadds
	#define _LOADDS
	#define LOADDS
	#define _export     //should _export be blank?
	#define __export
	#define EXPORT
	#define _based(x)
	#define __based(x)
	#define _based32(x)
	#define __based32(x)

	#ifdef _X86_
	// __inline provides speed improvements for x86 platforms.  Unfortunately
	// the MIPS compiler does not have inline support.  Alpha is unknown, so
	// we do not assume and play it safe.
	#define INLINE   __inline
	#define inline   __inline
	#define _inline  __inline
	#else
	#define INLINE
	#define inline
	#define _inline
	#define __inline
	#endif

	//typedef RGBQUAD FAR *LPRGBQUAD;

	//#ifdef DAYTONA
	//typedef LRESULT (*DRIVERPROC)(DWORD, HDRVR, UINT, WPARAM, LPARAM);
	//#endif
    // DriverProc is in the common win 32 sdk mmsystem.h.

	#define GetCurrentTask()    (HTASK)LongToHandle(GetCurrentThreadId())

	#define WF_PMODE        0x0001
	#define WF_CPU286       0x0002
	#define WF_CPU386       0x0004
	#define WF_CPU486       0x0008
	#define WF_80x87        0x0400
	#define WF_PAGING       0x0800

	#define GetWinFlags()   (WF_PMODE|WF_CPU486|WF_PAGING|WF_80x87)
	
	//#define hmemcpy  memcpy
	#define _fmemcpy memcpy
	#define _fmemset memset
	//#define lstrcpyn(dest, source, cb)  ( strncpy(dest, source, cb), ((char *) dest) [cb - 1] = 0)

	//!!! should use LARGE_INTEGER stuff.
	#define muldiv32                MulDiv
	#define muldivru32(a,b,c)       (long)(((double)(a) * (double)(b) + (double)((c)-1)) / (double)(c))
	#define muldivrd32(a,b,c)       (long)(((double)(a) * (double)(b)) / (double)(c))

	#define IsTask(x) ((x) != 0)
	#define IsGDIObject(obj) (GetObjectType((HGDIOBJ)(obj)) != 0)
	
	#define SZCODEA CHAR
	#define SZCODE  TCHAR
	typedef TCHAR * NPTSTR;

#ifndef UNICODE
// !!!!!!! need lstrcpyW, lstrlenW, wsprintfW, lstrcpynW for Chicago!
#endif
	
#else

/* --- Win16 version --------------------------------------------------- */

	#include <string.h>
	#include <memory.h>

	#define SZCODEA SZCODE
	typedef char  TCHAR;
	typedef WORD  WCHAR;
	typedef NPSTR NPTSTR;
	typedef LPSTR LPTSTR;
	typedef LPSTR LPOLESTR;
	typedef LPCSTR LPCOLESTR;
	typedef char  OLECHAR;
	
	typedef int   INT;

	#define _LOADDS _loadds
	#define LOADDS  _loadds
	#define EXPORT  _export

	#define HUGE    _huge

	#define DRIVERS_SECTION "Drivers"
	#define MCI_SECTION "MCI"
	#define MCIAVI_SECTION "MCIAVI"
	#define TEXT(sz) sz

	// stuff in muldiv32.asm
	EXTERN_C  LONG FAR PASCAL muldiv32(LONG,LONG,LONG);
	EXTERN_C  LONG FAR PASCAL muldivru32(LONG,LONG,LONG);
	EXTERN_C  LONG FAR PASCAL muldivrd32(LONG,LONG,LONG);

	#define UNALIGNED
	#define INLINE __inline
	#define CharPrev AnsiPrev

	/*
	 * define these so we can explicitly use Ansi or Unicode versions
	 * in the NT code, and the standard entry point for Win16.
	 */
	#define SetWindowTextA                  SetWindowText
	#define GetProfileStringA               GetProfileString
	#define GetPrivateProfileStringA        GetPrivateProfileString
	#define GetProfileIntA                  GetProfileInt
	#define GetModuleHandleA                GetModuleHandle
	#define GetModuleFileNameA              GetModuleFileName
	#define wvsprintfA                      wvsprintf
	#define wsprintfA                       wsprintf
	#define lstrcmpA                        lstrcmp
	#define lstrcmpiA                       lstrcmpi
	#define lstrcpyA                        lstrcpy
	#define lstrcatA                        lstrcat
	#define lstrlenA                        lstrlen
	#define LoadStringA                     LoadString
	#define LoadStringW                     LoadString
	#define OutputDebugStringA              OutputDebugString
	#define MessageBoxA                     MessageBox

	// Needed for writing OLE-style code that builds 16/32....
	#define lstrcpyW lstrcpy
	#define lstrcpynW lstrcpyn
	#define lstrlenW lstrlen

	#define SZCODE char _based(_segname("_CODE"))
	#define LPCWSTR      LPCSTR
	#define LPCTSTR      LPCSTR
	#define LPWSTR       LPSTR
	#define PTSTR        PSTR

/****** Alternate porting layer macros ****************************************/

#ifndef GET_WPARAM

    /* USER MESSAGES: */

    #define GET_WPARAM(wp, lp)                      (wp)
    #define GET_LPARAM(wp, lp)                      (lp)

    #define GET_WM_ACTIVATE_STATE(wp, lp)               (wp)
    #define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)          (BOOL)HIWORD(lp)
    #define GET_WM_ACTIVATE_HWND(wp, lp)                (HWND)LOWORD(lp)
    #define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)   \
	    (WPARAM)(s), MAKELONG(hwnd, fmin)

    #define GET_WM_CHARTOITEM_CHAR(wp, lp)              (CHAR)(wp)
    #define GET_WM_CHARTOITEM_POS(wp, lp)               HIWORD(lp)
    #define GET_WM_CHARTOITEM_HWND(wp, lp)              (HWND)LOWORD(lp)
    #define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd) \
	    (WPARAM)(ch), MAKELONG(hwnd, pos)

    #define GET_WM_COMMAND_ID(wp, lp)                   (wp)
    #define GET_WM_COMMAND_HWND(wp, lp)                 (HWND)LOWORD(lp)
    #define GET_WM_COMMAND_CMD(wp, lp)                  HIWORD(lp)
    #define GET_WM_COMMAND_MPS(id, hwnd, cmd)    \
	    (WPARAM)(id), MAKELONG(hwnd, cmd)

    #define WM_CTLCOLORMSGBOX       0x0132
    #define WM_CTLCOLOREDIT         0x0133
    #define WM_CTLCOLORLISTBOX      0x0134
    #define WM_CTLCOLORBTN          0x0135
    #define WM_CTLCOLORDLG          0x0136
    #define WM_CTLCOLORSCROLLBAR    0x0137
    #define WM_CTLCOLORSTATIC       0x0138

    #define GET_WM_CTLCOLOR_HDC(wp, lp, msg)            (HDC)(wp)
    #define GET_WM_CTLCOLOR_HWND(wp, lp, msg)           (HWND)LOWORD(lp)
    #define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)           HIWORD(lp)
    #define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type) \
	    (WPARAM)(hdc), MAKELONG(hwnd, type)


    #define GET_WM_MENUSELECT_CMD(wp, lp)               (wp)
    #define GET_WM_MENUSELECT_FLAGS(wp, lp)             LOWORD(lp)
    #define GET_WM_MENUSELECT_HMENU(wp, lp)             (HMENU)HIWORD(lp)
    #define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)  \
	    (WPARAM)(cmd), MAKELONG(f, hmenu)

    // Note: the following are for interpreting MDIclient to MDI child messages.
    #define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)
    #define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
    #define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)
    // Note: the following is for sending to the MDI client window.
    #define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA)\
	    (WPARAM)(hwndA), 0

    #define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW) 0, MAKELONG(hmenuF, hmenuW)

    #define GET_WM_MENUCHAR_CHAR(wp, lp)                (CHAR)(wp)
    #define GET_WM_MENUCHAR_HMENU(wp, lp)               (HMENU)LOWORD(lp)
    #define GET_WM_MENUCHAR_FMENU(wp, lp)               (BOOL)HIWORD(lp)
    #define GET_WM_MENUCHAR_MPS(ch, hmenu, f)    \
	    (WPARAM)(ch), MAKELONG(hmenu, f)

    #define GET_WM_PARENTNOTIFY_MSG(wp, lp)             (wp)
    #define GET_WM_PARENTNOTIFY_ID(wp, lp)              HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)       (HWND)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_X(wp, lp)               (INT)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_Y(wp, lp)               (INT)HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd) \
	    (WPARAM)(msg), MAKELONG(hwnd, id)
    #define GET_WM_PARENTNOTIFY2_MPS(msg, x, y) \
	    (WPARAM)(msg), MAKELONG(x, y)

    #define GET_WM_VKEYTOITEM_CODE(wp, lp)              (wp)
    #define GET_WM_VKEYTOITEM_ITEM(wp, lp)              (INT)HIWORD(lp)
    #define GET_WM_VKEYTOITEM_HWND(wp, lp)              (HWND)LOWORD(lp)
    #define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) \
	    (WPARAM)(code), MAKELONG(hwnd, item)

    #define GET_EM_SETSEL_START(wp, lp)                 LOWORD(lp)
    #define GET_EM_SETSEL_END(wp, lp)                   HIWORD(lp)
    #define GET_EM_SETSEL_MPS(iStart, iEnd) \
	    0, MAKELONG(iStart, iEnd)

    #define GET_EM_LINESCROLL_MPS(vert, horz)     \
	    0, MAKELONG(vert, horz)

    #define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)       (HWND)LOWORD(lp)

    #define GET_WM_HSCROLL_CODE(wp, lp)                 (wp)
    #define GET_WM_HSCROLL_POS(wp, lp)                  LOWORD(lp)
    #define GET_WM_HSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
    #define GET_WM_HSCROLL_MPS(code, pos, hwnd)    \
	    (WPARAM)(code), MAKELONG(pos, hwnd)

    #define GET_WM_VSCROLL_CODE(wp, lp)                 (wp)
    #define GET_WM_VSCROLL_POS(wp, lp)                  LOWORD(lp)
    #define GET_WM_VSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
    #define GET_WM_VSCROLL_MPS(code, pos, hwnd)    \
	    (WPARAM)(code), MAKELONG(pos, hwnd)

#endif  // !GET_WPARAM

#endif  // !WIN32

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcicda\cda.c ===
/******************************Module*Header*********************************\
* Module Name: cda.c
*
* Media Control Architecture Redbook CD Audio Driver
*
* Author:  RobinSp
*
* History:
*   RobinSp 10th March 1992 - Move to Windows NT
*
* Copyright (c) 1990-1996 Microsoft Corporation
*
\****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include "mcicda.h"
#include "cda.h"
#include "cdio.h"

int Usage;          // See CDA_init_audio and CDA_terminate_audio
                    // Counts number of 'init's over number of 'terminate's

#define validdisk(did) ((did) >= 0 && (did) < MCIRBOOK_MAX_DRIVES && \
                        CdInfo[did].hDevice != NULL)

int CDA_traystate (DID did)
{
    if (!validdisk(did))
       return(INVALID_DRIVE);
    return CdTrayClosed(&CdInfo[did]) ? TRAY_CLOSED : TRAY_OPEN;
}

/*
 *  Convert frames to MSF
 */

redbook CDA_bin2red (unsigned long ul)
{
    return MAKERED(ul / (75 * 60), (ul / 75) % 60, ul % 75);
}

/*
 *  Convert MSF to frames
 */

unsigned long CDA_red2bin (redbook red)
{
    return (unsigned long)((REDMINUTE(red) * 60) +
                            REDSECOND(red)) * 75 +
                            REDFRAME(red);
}

BOOL CDA_open(DID did)
{
    return CdOpen(did);
}

BOOL CDA_close(DID did)
{
    return CdClose(&CdInfo[did]);
}

int CDA_eject(DID did)
{
    if (!validdisk(did))
       return(INVALID_DRIVE);
    return CdEject(&CdInfo[did]);
}

/*
 *  Close the door.
 *
 *  Returns :
 *       TRUE          if successful
 *       FALSE         if failed
 */

BOOL CDA_closetray(DID did)
{
    if (!validdisk(did))
       return(FALSE);
    return CdCloseTray(&CdInfo[did]);
}

/*
 *  Check if the disk is ready
 *
 *  Returns :
 *       TRUE          if successful
 *       FALSE         if failed
 */

BOOL CDA_disc_ready(DID did)
{
    if (!validdisk(did))
       return(FALSE);

    /* if drive is ejected, the disc is not ready! */
    if (CDA_traystate(did) != TRAY_CLOSED)
       return(FALSE);

    /* volume size ioctl just to get error code */
    return CdReady(&CdInfo[did]);
}

/*
 *  Seek to the requested redbook address
 *
 *  did - disk id
 *  address - redbook address
 *
 *  Return value :
 *    INVALID_DRIVE - Invalid disk drive
 *    COMMAND_SUCCESSFUL - OK
 *    COMMAND_FAILED - did not succeed - possible hardware problem.
 */

int  CDA_seek_audio(DID did, redbook address, BOOL fForceAudio)
{
    if (!validdisk(did))
       return(INVALID_DRIVE);

    //
    //  LMSI drive needs to be stopped/paused before seeking
    //

    CdPause(&CdInfo[did]);
    return CdSeek(&CdInfo[did], address, fForceAudio) ? COMMAND_SUCCESSFUL : COMMAND_FAILED;
}

/*
 *  init the CDA library, return the number of CD-Drives present
 */
int CDA_init_audio(void)
{
    //
    //  if we are inited already, get out fast.
    //
    if (Usage++ == 0)
    {
        //
        // try the CDROM Extentions
        //
        NumDrives = CdGetNumDrives();
        if (NumDrives == 0) {
            CDA_terminate_audio();
        }
    }

    return NumDrives;
}

int CDA_terminate_audio()
{
    DID did;

    if (Usage > 0 && --Usage == 0)
    {
        for(did=0;did<MCIRBOOK_MAX_DRIVES;did++) {
            if (CdInfo[did].hDevice) {
                CdClose(&CdInfo[did]);
            }
        }
    }

    return Usage;
}

unsigned long  CDA_get_support_info(DID did)
{
    if (!validdisk(did))
            return(0);
    return SUPPORTS_REDBOOKAUDIO | SUPPORTS_CHANNELCONTROL;
}

int  CDA_drive_status (DID did)
{
    if (!validdisk(did))
        return(INVALID_DRIVE);

    return (int)CdStatus(&CdInfo[did]);
}



/*
 *  Find the number of tracks on the CD Rom.  If the CD Rom can't be
 *  accessed or has no audio tracks then 0 is returned.
 *
 *  This function has the (MAJOR) side effect of updating the table
 *  of contents of it's thought to be out of date
 */

int  CDA_num_tracks(DID did)
{
    if (!validdisk(did))
       return 0;

    return CdNumTracks(&CdInfo[did]);
}

redbook  CDA_track_start(DID did, int trk)
{

    if (!validdisk(did)) {
       return (redbook)INVALID_TRACK;
    }

    return REDTH(CdTrackStart(&CdInfo[did], (UCHAR)trk), trk);
}

redbook  CDA_track_length(DID did, int trk)
{
    if (!validdisk(did)) {
       return (redbook)INVALID_TRACK;
    }

    return CdTrackLength(&CdInfo[did], (UCHAR)trk);

}

int CDA_track_type(DID did, int trk)
{
    if (!validdisk(did)) {
       return INVALID_TRACK;
    }

    return CdTrackType(&CdInfo[did], (UCHAR)trk);

}

redbook  CDA_disc_length(DID did)
{
    if (!validdisk(did)) {
        return (redbook)INVALID_TRACK;
    }

    return CdDiskLength(&CdInfo[did]); // NB - subtract 1 for bad systems
}

int  CDA_play_audio(DID did, redbook start, redbook to)
{
    redbook diskinfo;

    if (!validdisk(did))
       return(INVALID_DRIVE);

    //
    // Must use Stop because Pause may not allow reading of data from
    // the CD.  However, Stop sometimes has the nasty side-effect of
    // seeking to the start (!).
    //

    CdPause(&CdInfo[did]);

    if (start != to) {
        return CdPlay(&CdInfo[did], start, to) ?
            COMMAND_SUCCESSFUL : COMMAND_FAILED;
    } else {
        return COMMAND_SUCCESSFUL;
    }
}

int  CDA_stop_audio(DID did)
{
    return CdStop(&CdInfo[did]) ? COMMAND_SUCCESSFUL : COMMAND_FAILED;
}

int  CDA_pause_audio(DID did)
{
    return CdPause(&CdInfo[did]) ? COMMAND_SUCCESSFUL : COMMAND_FAILED;
}

int  CDA_resume_audio(DID did)
{
    return CdResume(&CdInfo[did]) ? COMMAND_SUCCESSFUL : COMMAND_FAILED;
}


int  CDA_set_audio_volume(DID did, int channel, UCHAR volume)
{
    if (!validdisk(did))
       return(INVALID_DRIVE);

    if ((channel > 3) || (channel < 0))
       return(COMMAND_FAILED);

    return CdSetVolume(&CdInfo[did], channel, volume) ?
               COMMAND_SUCCESSFUL : COMMAND_FAILED;
}

int CDA_set_audio_volume_all (DID did, UCHAR volume)
{
    int  rc = COMMAND_SUCCESSFUL;
    int  channel;

    if (!validdisk(did))
       return(INVALID_DRIVE);

    if (!CdSetVolumeAll(&CdInfo[did], volume))
    {
        rc = COMMAND_FAILED;
    }

/*
    for (channel = 0; channel < 4; ++channel)
    {
        if (!CdSetVolume(&CdInfo[did], channel, volume))
        {
            rc = COMMAND_FAILED;
        }
    }
*/

    return rc;
}



int CDA_time_info(DID did, redbook *ptracktime, redbook *pdisctime)
{
    int rc;
    redbook tracktime, disctime;
    tracktime = INVALID_TRACK;
    disctime = INVALID_TRACK;

    if (!validdisk(did))
    {
        rc = INVALID_DRIVE;
    } else {
        if (CdPosition(&CdInfo[did], &tracktime, &disctime)) {
            rc = COMMAND_SUCCESSFUL;
        } else {
            rc = COMMAND_FAILED;
        }
    }
    if (ptracktime) {
        *ptracktime = tracktime;
    }
    if (pdisctime) {
        *pdisctime = disctime;
    }

    return rc;
}

/*
 *  CDA_disc_end
 *
 *  Parameters
 *     did - The disk ID
 *
 *  Return the redbook address for the end of the disk defined by did
 */

redbook CDA_disc_end(DID did)
{
    return CdDiskEnd(&CdInfo[did]);
}

/*
 *  CDA_disc_upc
 *
 *  Parameters
 *    did - The disk ID
 *    upc - where to store the upc
 */

int CDA_disc_upc(DID did, LPTSTR upc)
{
    if (!validdisk(did)) {
       return FALSE;
    }

    return CdDiskUPC(&CdInfo[did], upc) ?
              COMMAND_SUCCESSFUL : COMMAND_FAILED;
}

/*
 *  CDA_disc_id
 *
 *  Parameters
 *    lpstrname - device name
 *    pdid - The disk ID
 */

DWORD CDA_disc_id(DID did)
{
    if (!validdisk(did)) {
       return (DWORD)-1;
    }

    return CdDiskID(&CdInfo[did]);
}

/*
 *  CDA_reset_drive
 *
 *  Parameters
 *    did - The disk ID
 */

void CDA_reset_drive(DID did)
{
    if (!validdisk(did)) {
       return;
    }

    return;
}

/*
 *  CDA_get_drive
 *
 *  Parameters
 *
 *    lpstrDeviceName - name of device
 *    pdid            - The disk ID
 */

int CDA_get_drive(LPCTSTR lpstrDeviceName, DID * pdid)
{
    return CdGetDrive(lpstrDeviceName, pdid) ? COMMAND_SUCCESSFUL : COMMAND_FAILED;
}



/*
 *  CDA_status_track_pos
 *
 *  Parameters
 *    pdid          - The disk ID
 *    pStatus       - return status code
 *    pTrackTime    - track time
 *    pDiscTime     - disc time
 */

int CDA_status_track_pos(
    DID         did, 
    DWORD *     pStatus,
    redbook *   pTrackTime,
    redbook *   pDiscTime)
{
    int rc;
    DWORD   status;
    redbook tracktime, disctime;

    status    = DISC_NOT_READY;
    tracktime = INVALID_TRACK;
    disctime  = INVALID_TRACK;

    if (!validdisk(did))
    {
        rc = INVALID_DRIVE;
    } 
    else 
    {
        if (CdStatusTrackPos(&CdInfo[did], &status, &tracktime, &disctime)) 
        {
            rc = COMMAND_SUCCESSFUL;
        } 
        else 
        {
            rc = COMMAND_FAILED;
        }
    }

    if (pStatus)
    {
        *pStatus = status;
    }

    if (pTrackTime) 
    {
        *pTrackTime = tracktime;
    }

    if (pDiscTime) 
    {
        *pDiscTime = disctime;
    }

    return rc;
} // End CDA_status_track_pos
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcicda\cda.h ===
/*******************************Module*Header*********************************\
* Module Name: cda.h
*
* Media Control Architecture Redbook CD Audio Driver
*
* Created:
* Author:
*
* History:
*
* Internal data structures
*
* Copyright (c) 1990-1996 Microsoft Corporation
*
\****************************************************************************/
typedef unsigned long  redbook;   /* redbook address */
typedef int DID;                  /* drive id */

/*
 *  Return codes from CDA_... routines
 */

#define INVALID_DRIVE            -1
#define NO_EXTENSIONS            -1
#define BAD_EXTENSIONS_VERSION   -2
#define NO_REQUEST_BUFF          -3
#define TRAY_OPEN                 1
#define TRAY_CLOSED               2
#define INVALID_TRACK             0xFF000000
#define COMMAND_FAILED            1
#define COMMAND_SUCCESSFUL        0
#define SUPPORTS_REDBOOKAUDIO     1
#define SUPPORTS_CHANNELCONTROL   2
#define DISC_IN_DRIVE             4

#define DISC_PLAYING              1
#define DISC_PAUSED               2
#define DISC_NOT_READY            3
#define DISC_READY                4
#define NEW_DISC                  5
#define SAME_DISC                 6

#define DISC_NOT_IN_CDROM         7


/*
 *  Macros to handle conversions of various time formats
 */

#define REDFRAME(x)  ((UCHAR)((int)( (x) & 0x000000FF)))
#define REDSECOND(x) ((UCHAR)((int)(((x) & 0x0000FF00)>>8)))
#define REDMINUTE(x) ((UCHAR)((int)(((x) & 0x00FF0000)>>16)))
#define REDTRACK(x)  ((UCHAR)((int)(((x) & 0xFF000000)>>24)))

#define MAKERED(m,s,f) ((unsigned long)(((unsigned char)(f) | \
                       ((unsigned short)(s)<<8)) | \
                       (((unsigned long)(unsigned char)(m))<<16)))

#define REDTH(red,trk) \
                   ((redbook)((red) & 0xFFFFFF | ((trk) << 24) & 0xFF000000))

#define TRACK_ERROR (0xFF000000)
#define reddiff(high,low) (CDA_bin2red(CDA_red2bin((high)) - CDA_red2bin((low))))
#define redadd(onered,twored) (CDA_bin2red(CDA_red2bin((onered)) + CDA_red2bin((twored))))

/*
 *  Function prototypes
 */

extern redbook       CDA_bin2red (unsigned long ul);
extern unsigned long CDA_red2bin (redbook red);

extern BOOL          CDA_open(DID did);
extern BOOL          CDA_close(DID did);
extern int           CDA_seek_audio(DID did, redbook address, BOOL fForceAudio);
extern int           CDA_init_audio(void);
extern int           CDA_terminate_audio(void);

extern BOOL          CDA_disc_ready(DID did);
extern int           CDA_traystate(DID did);
extern int           CDA_num_tracks(DID did);
extern int           CDA_track_type(DID did, int trk);
extern redbook       CDA_track_start(DID did, int whichtrack);
extern redbook       CDA_track_length(DID did, int whichtrack);
extern int           CDA_track_type(DID did, int trk);
extern int           CDA_play_audio(DID did, redbook start, redbook length);
extern int           CDA_stop_audio(DID did);
extern void          CDA_reset_drive(DID did);
extern int           CDA_eject(DID did);
extern BOOL          CDA_closetray(DID did);
extern redbook       CDA_disc_length(DID did);
extern int           CDA_drive_status (DID did);
extern int           CDA_disc_changed(DID did);
extern int           CDA_pause_audio(DID did);
extern int           CDA_resume_audio(DID did);
extern int           CDA_time_info(DID did, redbook FAR *disctime, redbook FAR *tracktime);
extern int           CDA_set_audio_volume(DID did, int channel, UCHAR volume);
extern int           CDA_set_audio_volume_all(DID did, UCHAR volume);
extern redbook       CDA_disc_end( DID did ); //leadout
extern DWORD         CDA_disc_id( DID did );
extern BOOL          CDA_disc_upc( DID did, LPTSTR upc );
unsigned long        CDA_get_support_info(DID did);
int                  CDA_get_drive(LPCTSTR lpstrDeviceName, DID * pdid);
int                  CDA_status_track_pos(DID did, DWORD * pStatus, 
                                          redbook * pTrackTime, redbook * pDiscTime);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcicda\cdio.h ===
/*******************************Module*Header*********************************\
* Module Name: cdio.h
*
* Media Control Architecture Redbook CD Audio Driver
*
* Created:
* Author:
*
* History:
*
* Internal data structures
*
* Copyright (c) 1990-1997 Microsoft Corporation
*
\****************************************************************************/

#include <devioctl.h>
#include <ntddcdrm.h>

//
// define types
//

typedef redbook MSF;        // minutes, seconds, frames.

#define ANSI_NAME_SIZE  32  // device name size

#define IS_DATA_TRACK 0x04  // Flag for track control byte - defines type of
                            // track = bit = 0 => audio, bit = 1 => data

//
// Private structures
//

typedef struct _TRACK_INFO {
    UCHAR TrackNumber;                  // Track number read from TOC
    MSF   msfStart;                     // Track start MSF from TOC
    UCHAR Ctrl;                         // Track control byte (defined by SCSI2)
} TRACK_INFO, *LPTRACK_INFO;

//
// Information about a single device and any disk in it
//

typedef struct _CD_INFO {
    HANDLE                       DeviceCritSec;                   // The device critical section
    TCHAR            cDrive;                  // The device disc letter
    HANDLE           hDevice;                 // Handle to an open device
    int              NumberOfUsers;           // Support multiple opens
    BOOL             bTOCValid;               // TOC info is valid
    UCHAR            FirstTrack;
    UCHAR            LastTrack;
    MSF              msfEnd;                  // Address of the end of the disk
    MSF              leadout;                 // Address of the real of the disk
    UCHAR            fPrevStatus;             // fixes Audio Status bug !
    MSF              fPrevSeekTime;           // Store away previous seek time
    UCHAR            VolChannels[4];          // Store away volume channels
    TRACK_INFO       Track[MAXIMUM_NUMBER_TRACKS];
} CDINFO, *LPCDINFO;

typedef LPCDINFO HCD;                   // handle to a CD device driver
                                        // (in cdio.c)

//
// Global data
//

int NumDrives;                          // The number of drives
CDINFO CdInfo[MCIRBOOK_MAX_DRIVES];     // Data on each drive


//
// Device functions
//

int   CdGetNumDrives(void);
BOOL  CdOpen(int Drive);
BOOL  CdClose(HCD hCD);
BOOL  CdReload(LPCDINFO lpInfo);
BOOL  CdReady(HCD hCD);
BOOL  CdPlay(HCD hCD, MSF msfStart, MSF msfEnd);
BOOL  CdSeek(HCD hCD, MSF msf, BOOL fForceAudio);
MSF   CdTrackStart(HCD hCD, UCHAR Track);
MSF   CdTrackLength(HCD hCD, UCHAR Track);
int   CdTrackType(HCD hCD, UCHAR Track);
BOOL  CdPosition(HCD hCD, MSF *tracktime, MSF *disktime);
MSF   CdDiskEnd(HCD hCD);
MSF   CdDiskLength(HCD hCD);
DWORD CdStatus(HCD hCD);
BOOL  CdEject(HCD hCD);
BOOL  CdPause(HCD hCD);
BOOL  CdResume(HCD hCD);
BOOL  CdStop(HCD hCD);
BOOL  CdSetVolumeAll(HCD hCD, UCHAR Volume);
BOOL  CdSetVolume(HCD hCD, int Channel, UCHAR Volume);
BOOL  CdCloseTray(HCD hCD);
int   CdNumTracks(HCD hCD);
BOOL  CdTrayClosed(HCD hCD);
DWORD CdDiskID(HCD hCD);
BOOL  CdDiskUPC(HCD hCD, LPTSTR upc);
BOOL  CdGetDrive(LPCTSTR lpstrDeviceName, DID * pdid);
BOOL  CdStatusTrackPos(HCD hCD, DWORD * pStatus,
                      MSF * pTrackTime, MSF * pDiscTime);


void
EnterCrit(
    HANDLE hMutex
    );

void
LeaveCrit(
    HANDLE hMutex
    );

/***************************************************************************

    DEBUGGING SUPPORT

***************************************************************************/


#if DBG

    #define STATICFN
    #define STATICDT

    extern void mcicdaDbgOut(LPSTR lpszFormat, ...);
    extern void mcicdaSetDebugLevel(int level);

    int DebugLevel;

    #define dprintf( _x_ )                       mcicdaDbgOut _x_
    #define dprintf1( _x_ ) if (DebugLevel >= 1) mcicdaDbgOut _x_
    #define dprintf2( _x_ ) if (DebugLevel >= 2) mcicdaDbgOut _x_
    #define dprintf3( _x_ ) if (DebugLevel >= 3) mcicdaDbgOut _x_
    #define dprintf4( _x_ ) if (DebugLevel >= 4) mcicdaDbgOut _x_

#else

    #define STATICFN
    #define STATICDT   static

    #define dprintf(x)
    #define dprintf1(x)
    #define dprintf2(x)
    #define dprintf3(x)
    #define dprintf4(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcicda\cdio.c ===
/*
*   cdio.c
*
*
*   This module provides a C interface to the CD-ROM device
*   drivers to make the audio control a little simpler for
*   the rest of the driver.
*
*   21-Jun-91  NigelT
*   10-Mar-92  RobinSp - Catch up with windows 3.1
*
* Copyright (c) 1990-1998 Microsoft Corporation
*
*/
#include <windows.h>
#include <devioctl.h>
#include <mmsystem.h>
#include <tchar.h>
#include "mcicda.h"
#include "cda.h"
#include "cdio.h"

//#include <ntstatus.h>     
#ifndef STATUS_VERIFY_REQUIRED
#define STATUS_VERIFY_REQUIRED           ((DWORD)0x80000016L)
#endif


//
// Private constants
//


//
// Local functions (cd prefix, globals have Cd)
//

HANDLE cdOpenDeviceDriver(TCHAR szAnsiDeviceName, DWORD Access);
void   cdCloseDeviceDriver(HANDLE hDevice);
DWORD  cdGetDiskInfo(LPCDINFO lpInfo);
DWORD  cdIoctl(LPCDINFO lpInfo, DWORD Request, PVOID lpData, DWORD size);
DWORD  cdIoctlData(LPCDINFO lpInfo, DWORD Request, PVOID lpData,
		   DWORD size, PVOID lpOutput, DWORD OutputSize);
void   CdSetAudioStatus (HCD hCD, UCHAR fStatus);
BOOL   CdGetAudioStatus (HCD hCD, UCHAR fStatus, DWORD * pStatus);
BOOL   CdGetTrack(LPCDINFO lpInfo, MSF msfPos, UCHAR * pTrack, MSF * pmsfStart);


/***************************************************************************

    @doc EXTERNAL

    @api MSF | CdFindAudio | Given a position to start playing find
	the next audio track (if this one isn't) if any.

    @parm LPCDINFO | lpInfo | Pointer to CD info including track data.

    @parm MSF | msfStart | Position to start looking.

    @rdesc A new MSF to play from / seek to  within an audio track or
	the end of the CD if none was found.

***************************************************************************/
MSF CdFindAudio(LPCDINFO lpInfo, MSF msfStart)
{
    UINT tracknum;
    MSF  lastaudio = lpInfo->msfEnd;

    //
    // If we don't have a valid TOC then just obey - they may know
    // what they're doing.
    //

    dprintf2(("CdFindAudio"));

    if (!lpInfo->bTOCValid) {
	    dprintf2(("CdFindAudio - No valid TOC"));
	    return msfStart;
    }

    //
    // If we're being asked to play a data track then move forward
    // to the next audio track if there is one
    //

    //
    // Search for the track which ends after ours and is audio
    //

    for (tracknum = 0; ;tracknum++) {

	    //
	    // Note that some CDs return positions outside the playing range
	    // sometimes (notably 0) so msfStart may be less than the first
	    // track start
	    //

	    //
	    // If we're beyond the start of the track and before the start
	    // of the next track then this is the track we want.
	    //
	    // We assume we're always beyond the start of the first track
	    // and we check that if we're looking at the last track then
	    // we check we're before the end of the CD.
	    //

    	if (!(lpInfo->Track[tracknum].Ctrl & IS_DATA_TRACK)) {
	        // Remember the last audio track.  The MCI CDAudio spec
	        // for Seek to end says we position at the last audio track
	        // which is not necessarily the last track on the disc
	        lastaudio = lpInfo->Track[tracknum].msfStart;
	    }

	    if ((msfStart >= lpInfo->Track[tracknum].msfStart || tracknum == 0)
	    &&
#ifdef OLD
	        (tracknum + lpInfo->FirstTrack == lpInfo->LastTrack &&
	        msfStart < lpInfo->msfEnd ||
	        tracknum + lpInfo->FirstTrack != lpInfo->LastTrack &&
	        msfStart < lpInfo->Track[tracknum + 1].msfStart)) {
#else
	        // Simplify the logic.  When reviewed to the extent that the
	        // reviewer is convinced the test below is identical to the
	        // test above the old code can be deleted.
	        (tracknum + lpInfo->FirstTrack == lpInfo->LastTrack
	        ? msfStart <= lpInfo->msfEnd
	        : msfStart < lpInfo->Track[tracknum + 1].msfStart)
	     ) {
#endif

	        if (!(lpInfo->Track[tracknum].Ctrl & IS_DATA_TRACK)) {
		        return msfStart;
	        }

	        //
	        // Move to next track if there is one and this one is a
	        // data track
	        //

	        if (tracknum + lpInfo->FirstTrack >= lpInfo->LastTrack) {

		        //
		        // Didn't find a suitable start point so return end of CD
		        //

		        return lpInfo->msfEnd;
	        } else {

		        //
		        // We don't get here if this was already the last track
		        //
		        msfStart = lpInfo->Track[tracknum + 1].msfStart;
	        }
	    }

	    //
	    // Exhausted all tracks ?
	    //

	    if (tracknum + lpInfo->FirstTrack >= lpInfo->LastTrack) {
	        return lastaudio;
	    }

    }
}


/***************************************************************************

    @doc EXTERNAL

    @api WORD | CdGetNumDrives | Get the number of CD-ROM drives in
	the system.

    @rdesc The return value is the number of drives available.

    @comm It is assumed that all CD-ROM drives have audio capability,
	but this may not be true and consequently later calls which
	try to play audio CDs on those drives may fail.  It takes a
	fairly bad user to put an audio CD in a drive not connected
	up to play audio.

***************************************************************************/

int CdGetNumDrives(void)
{
    TCHAR    cDrive;
    LPCDINFO lpInfo;
    TCHAR    szName[ANSI_NAME_SIZE];
    DWORD    dwLogicalDrives;

    dprintf2(("CdGetNumDrives"));

    if (NumDrives == 0) {
	    //
	    // We start with the name A: and work up to Z: or until we have
	    // accumulated MCIRBOOK_MAX_DRIVES drives.
	    //

	    lpInfo = CdInfo;
	    lstrcpy(szName, TEXT("?:\\"));

	    for (cDrive = TEXT('A'), dwLogicalDrives = GetLogicalDrives();
	         NumDrives < MCIRBOOK_MAX_DRIVES &&  cDrive <= TEXT('Z');
	         cDrive++) {

	        szName[0] = cDrive;
	        if (dwLogicalDrives & (1 << (cDrive - TEXT('A'))) &&
		        GetDriveType(szName) == DRIVE_CDROM) 
	        {
		        lpInfo->cDrive = cDrive;
		        NumDrives++;
		        lpInfo++;      // Move on to next device info structure
	 
	            dprintf2(("CdGetNumDrives - %c: is a CDROM drive", cDrive));
	        }
	    }
    }

    return NumDrives;
}


/***************************************************************************

    @doc EXTERNAL

    @api HCD | CdOpen | Open a drive.

    @parm int | Drive | The drive number to open.

    @rdesc
	If the drive exists and is available then the return value is TRUE.

	If no drive exists, it is unavavilable, already open or an error
	occurs then the return value is set to FALSE.

    @comm
	The CdInfo slot for this drive is initialized if the open is
	successful.

***************************************************************************/

BOOL CdOpen(int Drive)
{
    LPCDINFO lpInfo;
    TCHAR    szName[ANSI_NAME_SIZE];

    //
    // Check the drive number is valid
    //

    if (Drive > NumDrives || Drive < 0) {
	    dprintf1(("Drive %u is invalid", Drive));
	    return FALSE;
    }

    lpInfo = &CdInfo[Drive];

    //
    // See if it's already open
    // CONSIDER: Do shareable support code here
    //

    if (lpInfo->hDevice != NULL) {
	    dprintf2(("Drive %u (%c) is being opened recursively - %d users",
                 Drive, (char)(lpInfo->cDrive), lpInfo->NumberOfUsers + 1));
	    lpInfo->NumberOfUsers++;
	    return TRUE;
    }


    //
    // Make sure it really is a CDROM drive
    //
	lstrcpy(szName, TEXT("?:\\"));
    szName[0] = lpInfo->cDrive;
    if (GetDriveType(szName) != DRIVE_CDROM)
    {
	    dprintf2(("CdOpen - Error, Drive %u, Letter = %c: is not a CDROM drive", 
                 Drive, (char)(lpInfo->cDrive)));
	    return FALSE;
    }

    //
    // open the device driver
    //
    lpInfo->hDevice = cdOpenDeviceDriver(lpInfo->cDrive, GENERIC_READ);
    if (lpInfo->hDevice == NULL) {
	    dprintf2(("Failed to open %c:", (char)(lpInfo->cDrive)));
	    return FALSE;
    }

    //
    // reset the TOC valid indicator
    //

    lpInfo->bTOCValid       = FALSE;
    lpInfo->fPrevStatus     = 0;
    lpInfo->fPrevSeekTime   = 0;
    lpInfo->VolChannels[0]  = 0xFF;
    lpInfo->VolChannels[1]  = 0xFF;
    lpInfo->VolChannels[2]  = 0xFF;
    lpInfo->VolChannels[3]  = 0xFF;


    //
    // Device now in use
    //

    lpInfo->NumberOfUsers = 1;

#if 0 // unnecessary and slows down media player startup
    //
    // Get the TOC if it's available (helps with the problems with the
    // Pioneer DRM-600 drive not being ready until the TOC has been read).
    //

    cdGetDiskInfo(lpInfo);
#endif

    return TRUE;
}

/***************************************************************************

    @doc EXTERNAL

    @api BOOL | CdClose | Close a drive.

    @parm HCD | hCD | The handle of a currently open drive.

    @rdesc The return value is TRUE if the drive is closed, FALSE
	if the drive was not open or some other error occured.

***************************************************************************/

BOOL CdClose(HCD hCD)
{
    LPCDINFO lpInfo;

    lpInfo = (LPCDINFO) hCD;

    dprintf2(("CdClose(%08XH)", hCD));

    if (lpInfo == NULL) {
	    dprintf1(("CdClose, NULL info pointer"));
	    return FALSE;
    }
    lpInfo->fPrevStatus = 0;

    if (lpInfo->hDevice == NULL) {
	    dprintf1(("CdClose, Attempt to close unopened device"));
	    return FALSE;
    }

    if (lpInfo->NumberOfUsers == 0)
    {
	    dprintf2(("CdClose (%c), number of users already = 0",
                 (char)(lpInfo->cDrive)));
    }
    else if (--lpInfo->NumberOfUsers == 0) 
    {
	    cdCloseDeviceDriver(lpInfo->hDevice);
	    lpInfo->hDevice = (HANDLE) 0;
    } 
    else 
    {
	    dprintf2(("CdClose (%c), Device still open with %d users", 
                 (char)(lpInfo->cDrive), lpInfo->NumberOfUsers));
    }

    return TRUE;
}


/***************************************************************************

    @doc EXTERNAL

    @api BOOL | CdReload | Reload Device

    @parm HCD | hCD | The handle of a currently open drive.

    @rdesc The return value is TRUE if the drive tray is reloaded

***************************************************************************/

BOOL CdReload (LPCDINFO lpInfo)
{
	DWORD           ii;
	DWORD           index;
	HANDLE          hNewDevice;

	if (!lpInfo)
    {
	    dprintf2(("CdReload, NULL info pointer"));
		return FALSE;
    }

		//
		// Reload Device
		// Note:  Don't close old device til we have a new device
		//        so we don't hose any users out there
		//

	EnterCrit (lpInfo->DeviceCritSec);

		// Make sure we have an open device
	if (NULL == lpInfo->hDevice)
	{
	    dprintf2(("CdReload, Attempt to reload unopened device"));
		LeaveCrit (lpInfo->DeviceCritSec);
		return FALSE;
	}

		// Open New Device
    hNewDevice = cdOpenDeviceDriver(lpInfo->cDrive, GENERIC_READ);
    if (NULL == hNewDevice) 
	{
	    dprintf2(("CdReload, Failed to reload driver"));
		LeaveCrit (lpInfo->DeviceCritSec);
		return FALSE;
    }

		// Close Old Device
    cdCloseDeviceDriver(lpInfo->hDevice);
	
		// Assign New Device
	lpInfo->hDevice = hNewDevice;
    //lpInfo->fPrevStatus = 0;

    //
    // reset the TOC valid indicator
    //

    lpInfo->bTOCValid = FALSE;

	LeaveCrit (lpInfo->DeviceCritSec);
	
		// Succesfully Reloaded
	return TRUE;

} // End CdReload


  
/***************************************************************************

    @doc EXTERNAL

    @api BOOL | CdReady | Test if a CD is ready.

    @parm HCD | hCD | The handle of a currently open drive.

    @rdesc The return value is TRUE if the drive has a disk in it
	and we have read the TOC. It is FALSE if the drive is not
	ready or we cannot read the TOC.

***************************************************************************/

BOOL CdReady(HCD hCD)
{
    LPCDINFO lpInfo;

    dprintf2(("CdReady(%08XH)", hCD));

    lpInfo = (LPCDINFO) hCD;

    //
    // Check a disk is in the drive and the door is shut and
    // we have a valid table of contents
    //

    return ERROR_SUCCESS == cdIoctl(lpInfo,
				    IOCTL_CDROM_CHECK_VERIFY,
				    NULL,
				    0);
}

/***************************************************************************

    @doc EXTERNAL

    @api BOOL | CdTrayClosed | Test what state a CD is in.

    @parm HCD | hCD | The handle of a currently open drive.

    @rdesc The return value is TRUE if the drive tray is closed

***************************************************************************/

BOOL CdTrayClosed(HCD hCD)
{
    LPCDINFO lpInfo;
	DWORD    dwError;

    dprintf2(("CdTrayClosed(%08XH)", hCD));

    lpInfo = (LPCDINFO) hCD;

    //
    // Check a disk is in the drive and the door is shut.
    //

	dwError = cdIoctl(lpInfo, IOCTL_CDROM_CHECK_VERIFY, NULL, 0);
	switch (dwError) 
    {
	case ERROR_NO_MEDIA_IN_DRIVE:
	case ERROR_UNRECOGNIZED_MEDIA:
	case ERROR_NOT_READY:
		return FALSE;

	default:
		return TRUE;
    }
}






/***************************************************************************

    @doc INTERNAL

    @api DWORD | cdGetDiskInfo | Read the disk info and TOC

    @parm LPCDINFO | lpInfo | Pointer to a CDINFO structure.

    @rdesc The return value is ERROR_SUCCESS if the info is read ok,
	otherwise the NT status code if not.

***************************************************************************/

DWORD cdGetDiskInfo(LPCDINFO lpInfo)
{
    CDROM_TOC    Toc;
    int          i;
    PTRACK_DATA  pTocTrack;
    LPTRACK_INFO pLocalTrack;
    DWORD        Status;
    UCHAR        TrackNumber;

    dprintf2(("cdGetDiskInfo(%08XH)", lpInfo));

#if 0  // If the app doesn't poll we may miss a disk change

    //
    // If the TOC is valid already then don't read it
    //

    if (lpInfo->bTOCValid) {
	    return TRUE;
    }
#endif

    //
    // Read the table of contents (TOC)
    //

    FillMemory(&Toc, sizeof(Toc), 0xFF);

    Status = cdIoctl(lpInfo, IOCTL_CDROM_READ_TOC, &Toc, sizeof(Toc));

    if (ERROR_SUCCESS != Status) {
	    dprintf2(("cdGetDiskInfo - Failed to read TOC"));
	    return Status;
    }

#ifdef DBGG
    dprintf4(("  TOC..."));
    dprintf4(("  Length[0]   %02XH", Toc.Length[0]));
    dprintf4(("  Length[1]   %02XH", Toc.Length[1]));
    dprintf4(("  FirstTrack  %u", Toc.FirstTrack));
    dprintf4(("  LastTrack   %u", Toc.LastTrack));
    dprintf4(("  Track info..."));
    for (i=0; i<20; i++) {
	    dprintf4(("  Track: %03u, Ctrl: %02XH, MSF: %02d %02d %02d",
		         Toc.TrackData[i].TrackNumber,
		         Toc.TrackData[i].Control,
		         Toc.TrackData[i].Address[1],
		         Toc.TrackData[i].Address[2],
		         Toc.TrackData[i].Address[3]));
    }
#endif

    //
    // Avoid problems with bad CDs
    //

    if (Toc.FirstTrack == 0) {
	    return ERROR_INVALID_DATA;
    }
    if (Toc.LastTrack > MAXIMUM_NUMBER_TRACKS - 1) {
	    Toc.LastTrack = MAXIMUM_NUMBER_TRACKS - 1;
    }

    //
    // hide the data track on Enhanced CDs (CD+).
    //

    for (i=0; i < (Toc.LastTrack - Toc.FirstTrack + 1); i++) {

        if (Toc.TrackData[i].Control & AUDIO_DATA_TRACK) {

            //
            // if first track, just exit out.
            //
            if (i == 0) {
                
                i = Toc.LastTrack+1;
            
            } else {
                
                //
                // remove one track from the TOC
                //
                Toc.LastTrack -= 1;

                //
                // knock 2.5 minutes off the current track to
                // hide the final leadin and make it the lead-out
                // track
                //

                Toc.TrackData[i].Address[1] -= 2;
                Toc.TrackData[i].Address[2] += 30;
                if (Toc.TrackData[i].Address[2] < 60) {
                    Toc.TrackData[i].Address[1] -= 1;
                } else {
                    Toc.TrackData[i].Address[2] -= 60;
                }
                Toc.TrackData[i].TrackNumber = 0xAA;

            }
        }
    }

#ifdef DBGG
    dprintf4(("  TOC (munged)..."));
    dprintf4(("  Length[0]   %02XH", Toc.Length[0]));
    dprintf4(("  Length[1]   %02XH", Toc.Length[1]));
    dprintf4(("  FirstTrack  %u", Toc.FirstTrack));
    dprintf4(("  LastTrack   %u", Toc.LastTrack));
    dprintf4(("  Track info..."));
    for (i=0; i<20; i++) {
	    dprintf4(("  Track: %03u, Ctrl: %02XH, MSF: %02d %02d %02d",
		         Toc.TrackData[i].TrackNumber,
		         Toc.TrackData[i].Control,
		         Toc.TrackData[i].Address[1],
		         Toc.TrackData[i].Address[2],
		         Toc.TrackData[i].Address[3]));
    }
#endif

    //
    // Copy the data we got back to our own cache in the format
    // we like it.  We copy all the tracks and then use the next track
    // data as the end of the disk. (Lead out info).
    //

    lpInfo->FirstTrack = Toc.FirstTrack;
    lpInfo->LastTrack = Toc.LastTrack;


    pTocTrack = &Toc.TrackData[0];
    pLocalTrack = &(lpInfo->Track[0]);
    TrackNumber = lpInfo->FirstTrack;

    while (TrackNumber <= Toc.LastTrack) {
	    pLocalTrack->TrackNumber = TrackNumber;
	    if (TrackNumber != pTocTrack->TrackNumber) {
	        dprintf2(("Track data not correct in TOC"));
	        return ERROR_INVALID_DATA;
	    }
	    pLocalTrack->msfStart = MAKERED(pTocTrack->Address[1],
		    			                pTocTrack->Address[2],
			    		                pTocTrack->Address[3]);
	    pLocalTrack->Ctrl = pTocTrack->Control;
	    pTocTrack++;
	    pLocalTrack++;
	    TrackNumber++;
    }

    //
    // Save the leadout for the disc id algorithm
    //
    lpInfo->leadout = MAKERED(pTocTrack->Address[1],
			                  pTocTrack->Address[2],
			                  pTocTrack->Address[3]);
    //
    // Some CD Rom drives don't like to go right to the end
    // so we fake it to be 1 frames earlier
    //
    lpInfo->msfEnd = reddiff(lpInfo->leadout, 1);

    lpInfo->bTOCValid = TRUE;

    return ERROR_SUCCESS;
}


/***************************************************************************

    @doc INTERNAL

    @api HANDLE | cdOpenDeviceDriver | Open a device driver.

    @parm LPSTR | szAnsiDeviceName | The name of the device to open.

    @parm DWORD | Access | Access to use to open the file.  This
	will be one of:

	GENERIC_READ if we want to actually operate the device

	FILE_READ_ATTRIBTES if we just want to see if it's there.  This
	    prevents the device from being mounted and speeds things up.

    @rdesc The return value is the handle to the open device or
	NULL if the device driver could not be opened.

***************************************************************************/

HANDLE cdOpenDeviceDriver(TCHAR cDrive, DWORD Access)
{
    HANDLE hDevice;
    TCHAR  szDeviceName[7];  //  "\\\\.\\?:"
    DWORD  dwErr;

    dprintf2(("cdOpenDeviceDriver"));

    wsprintf(szDeviceName, TEXT("\\\\.\\%c:"), cDrive);

    //
    // have a go at opening the driver
    //

    {
	    UINT OldErrorMode;

	    //
	    // We don't want to see hard error popups
	    //

	    OldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

	    hDevice = CreateFile( szDeviceName,
			                  Access,
		            	      FILE_SHARE_READ|FILE_SHARE_WRITE,
			                  NULL,
			                  OPEN_EXISTING,
			                  FILE_ATTRIBUTE_NORMAL,
			                  NULL );

	    if (hDevice == INVALID_HANDLE_VALUE) {
	        hDevice = (HANDLE) 0;
	        dwErr = GetLastError ();
	        dprintf1(("cdOpenDeviceDriver - Failed to open device driver %c: code %d", cDrive, dwErr));
	    }

	    //
	    // Restore the error mode
	    //

	    SetErrorMode(OldErrorMode);
    }


    return hDevice;
}


/***************************************************************************

    @doc INTERNAL

    @api void | cdCloseDeviceDriver | Close a device driver.

    @parm HANDLE | hDevice | Handle of the device to close.

    @rdesc There is no return value.

***************************************************************************/

void cdCloseDeviceDriver(HANDLE hDevice)
{
    DWORD status;

    dprintf2(("cdCloseDeviceDriver"));

    if (hDevice == NULL) {
	    dprintf1(("Attempt to close NULL handle"));
    }

    status = CloseHandle(hDevice);

    if (!status) {
	    dprintf1(("cdCloseDeviceDriver - Failed to close device. Error %08XH", GetLastError()));
    }
}

/***************************************************************************

    @doc INTERNAL

    @api DWORD | cdIoctl | Send an IOCTL request to the device driver.

    @parm LPCDINFO | lpInfo | Pointer to a CDINFO structure.

    @parm DWORD | Request | The IOCTL request code.

    @parm PVOID | lpData | Pointer to a data structure to be passed.

    @parm DWORD | dwSize | The length of the data strucure.

    @comm This function returns the disk status

    @rdesc The return value is the status value returned from the
	   call to DeviceIoControl



***************************************************************************/

DWORD cdIoctl(LPCDINFO lpInfo, DWORD Request, PVOID lpData, DWORD dwSize)
{
    DWORD Status;
    Status = cdIoctlData(lpInfo, Request, lpData, dwSize, lpData, dwSize);

    //if (ERROR_SUCCESS != Status && Request == IOCTL_CDROM_CHECK_VERIFY) {
	//    lpInfo->bTOCValid = FALSE;
    //}

    return Status;
}

/***************************************************************************

    @doc INTERNAL

    @api DWORD | cdIoctlData | Send an IOCTL request to the device driver.

    @parm LPCDINFO | lpInfo | Pointer to a CDINFO structure.

    @parm DWORD | Request | The IOCTL request code.

    @parm PVOID | lpData | Pointer to a data structure to be passed.

    @parm DWORD | dwSize | The length of the data strucure.

    @parm PVOID | lpOutput | Our output data

    @parm DWORD | OutputSize | Our output data (maximum) size

    @comm This function returns the disk status

    @rdesc The return value is the status value returned from the
	   call to DeviceIoControl

***************************************************************************/

DWORD cdIoctlData(LPCDINFO lpInfo, DWORD Request, PVOID lpData,
		  DWORD dwSize, PVOID lpOutput, DWORD OutputSize)
{
    BOOL  status;
    UINT  OldErrorMode;
    DWORD BytesReturned;
    DWORD dwError = ERROR_SUCCESS;
    BOOL  fTryAgain;

    dprintf3(("cdIoctl(%08XH, %08XH, %08XH, %08XH", lpInfo, Request, lpData, dwSize));

    if (!lpInfo->hDevice) {
	    dprintf1(("cdIoctlData - Device not open"));
	    return ERROR_INVALID_FUNCTION;
    }

#if DBG
    switch (Request) {

	case IOCTL_CDROM_READ_TOC:
	     dprintf3(("IOCTL_CDROM_READ_TOC"));
	     break;
	case IOCTL_CDROM_GET_CONTROL:
	     dprintf3(("IOCTL_CDROM_GET_CONTROL"));
	     break;
	case IOCTL_CDROM_PLAY_AUDIO_MSF:
	     dprintf3(("IOCTL_CDROM_PLAY_AUDIO_MSF"));
	     break;
	case IOCTL_CDROM_SEEK_AUDIO_MSF:
	     dprintf3(("IOCTL_CDROM_SEEK_AUDIO_MSF"));
	     break;
	case IOCTL_CDROM_STOP_AUDIO:
	     dprintf3(("IOCTL_CDROM_STOP_AUDIO"));
	     break;
	case IOCTL_CDROM_PAUSE_AUDIO:
	     dprintf3(("IOCTL_CDROM_PAUSE_AUDIO"));
	     break;
	case IOCTL_CDROM_RESUME_AUDIO:
	     dprintf3(("IOCTL_CDROM_RESUME_AUDIO"));
	     break;
	case IOCTL_CDROM_GET_VOLUME:
	     dprintf3(("IOCTL_CDROM_SET_VOLUME"));
	     break;
	case IOCTL_CDROM_SET_VOLUME:
	     dprintf3(("IOCTL_CDROM_GET_VOLUME"));
	     break;
	case IOCTL_CDROM_READ_Q_CHANNEL:
	     dprintf3(("IOCTL_CDROM_READ_Q_CHANNEL"));
	     break;
	case IOCTL_CDROM_CHECK_VERIFY:
	     dprintf3(("IOCTL_CDROM_CHECK_VERIFY"));
	     break;
    }
#endif // DBG

    //
    // We don't want to see hard error popups
    //

    fTryAgain = TRUE;
    while (fTryAgain)
    {
        fTryAgain = FALSE;

        OldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

        status = DeviceIoControl(lpInfo->hDevice,
		    	                 Request,
			                     lpData,
			                     dwSize,
			                     lpOutput,
			                     OutputSize,
			                     &BytesReturned,
			                     NULL);

        //
        // Restore the error mode
        //

        SetErrorMode(OldErrorMode);

        // Check for Failure
        if (!status)
        {
            dwError = GetLastError();
            if (dwError == ERROR_MEDIA_CHANGED)
            {
	            dprintf2(("Error Media Changed"));
            }

            //
            // Treat anything bad as invalidating our TOC.  Some of the things
            // we call are invalid on some devices so don't count those.  Also
            // the device can be 'busy' while playing so don't count that case
            // either.
            //
            if (Request == IOCTL_CDROM_CHECK_VERIFY)
            {
                lpInfo->bTOCValid = FALSE;

                switch (dwError)
                {
                case ERROR_MEDIA_CHANGED:
	                dprintf2(("Error Media Changed, Reloading Device"));

                    // Reload new Device
		            if (CdReload (lpInfo))
                        fTryAgain = TRUE;
                    break;

                case ERROR_INVALID_FUNCTION:
	            case ERROR_BUSY:
	            default:
	                break;
            }
        }

        #if DBG
	    dprintf1(("IOCTL %8XH  Status: %08XH", Request, dwError));
        #endif
        }
    } // End While (fTryAgain)

    return dwError;
}

/***************************************************************************

    @doc EXTERNAL

    @api BOOL | CdPlay | Play a section of the CD

    @parm HCD | hCD | The handle of a currently open drive.

    @parm MSF | msfStart | Where to start

    @parm MSF | msfEnd | Where to end

    @rdesc The return value is TRUE if the drive is play is started,
	FALSE if not.

***************************************************************************/

BOOL CdPlay(HCD hCD, MSF msfStart, MSF msfEnd)
{
    LPCDINFO lpInfo;
    CDROM_PLAY_AUDIO_MSF msfPlay;
    BOOL fResult;

    dprintf2(("CdPlay(%08XH, %08XH, %08XH)", hCD, msfStart, msfEnd));
    
    lpInfo = (LPCDINFO) hCD;

    msfStart = CdFindAudio(lpInfo, msfStart);

    //
    // If the start is now beyond the end then don't play anything
    //
    if (msfStart > msfEnd) {
	    return TRUE;
    }

    //
    // Set up the data for the call to the driver
    //

    msfPlay.StartingM = REDMINUTE(msfStart);
    msfPlay.StartingS = REDSECOND(msfStart);
    msfPlay.StartingF = REDFRAME(msfStart);

    msfPlay.EndingM = REDMINUTE(msfEnd);
    msfPlay.EndingS = REDSECOND(msfEnd);
    msfPlay.EndingF = REDFRAME(msfEnd);

    fResult = (ERROR_SUCCESS == cdIoctl(lpInfo,
				                     IOCTL_CDROM_PLAY_AUDIO_MSF,
				                     &msfPlay,
				                     sizeof(msfPlay)));
    if (fResult)
    {
        lpInfo->fPrevSeekTime = msfStart;
    }
    return fResult;
}


/***************************************************************************

    @doc EXTERNAL

    @api BOOL | CdSeek | Seek to a given part of the CD

    @parm HCD | hCD | The handle of a currently open drive.

    @parm MSF | msf | Where to seek to

    @rdesc The return value is TRUE if the seek is successful,
	FALSE if not.

***************************************************************************/

BOOL CdSeek(HCD hCD, MSF msf, BOOL fForceAudio)
{
    LPCDINFO lpInfo;
    CDROM_SEEK_AUDIO_MSF msfSeek;
    BOOL fResult;

    dprintf2(("CdSeek(%08XH, %08XH)  Forcing search for audio: %d", hCD, msf, fForceAudio));

    lpInfo = (LPCDINFO) hCD;

    //
    // Only seek to audio
    //
    if (fForceAudio) {   // On a seek to END or seek to START command
	    msf = CdFindAudio(lpInfo, msf);
	    dprintf2(("Cd Seek changed msf to %08XH", msf));
    } else {
	    if (msf != CdFindAudio(lpInfo, msf)) {
		    return TRUE;
	    }
    }


#if 1
    msfSeek.M = REDMINUTE(msf);
    msfSeek.S = REDSECOND(msf);
    msfSeek.F = REDFRAME(msf);

    fResult = (ERROR_SUCCESS == cdIoctl(lpInfo, IOCTL_CDROM_SEEK_AUDIO_MSF,
					                    &msfSeek, sizeof(msfSeek)));
    if (fResult)
    {
        lpInfo->fPrevSeekTime = msf;
    }
    return fResult;
#else
    //
    //  This is a hideous hack to make more drives work.  It uses the
    //  method originally used by Cd player to seek - viz play from
    //  the requested position and immediatly pause
    //

    return CdPlay(hCD, msf, redadd(lpInfo->msfEnd,1)) || CdPause(hCD);
#endif
}

/***************************************************************************

    @doc EXTERNAL

    @api MSF | CdTrackStart | Get the start time of a track.

    @parm HCD | hCD | The handle of a currently open drive.

    @parm UCHAR | Track | The track number.

    @rdesc The return value is the start time of the track expressed
	in MSF or INVALID_TRACK if the track number is not in the TOC.

***************************************************************************/

MSF CdTrackStart(HCD hCD, UCHAR Track)
{
    LPCDINFO lpInfo;
    LPTRACK_INFO lpTrack;

    dprintf2(("CdTrackStart(%08XH, %u)", hCD, Track));

    lpInfo = (LPCDINFO) hCD;

    //
    // We may need to read the TOC because we're not doing it on open
    // any more
    //

    if (!lpInfo->bTOCValid && CdNumTracks(hCD) == 0) {
	    dprintf1(("TOC not valid"));
	    return INVALID_TRACK;
    }

    if ((Track < lpInfo->FirstTrack) || (Track > lpInfo->LastTrack)) {
	    dprintf1(("Track number out of range"));
	    return INVALID_TRACK;
    }

    // search for the track info in the TOC

    lpTrack = lpInfo->Track;
    while (lpTrack->TrackNumber != Track) lpTrack++;

    return lpTrack->msfStart;
}

/***************************************************************************

    @doc EXTERNAL

    @api MSF | CdTrackLength | Get the length of a track.

    @parm HCD | hCD | The handle of a currently open drive.

    @parm UCHAR | Track | The track number.

    @rdesc The return value is the start time of the track expressed
	in MSF or INVALID_TRACK if the track number is not in the TOC.

***************************************************************************/

MSF CdTrackLength(HCD hCD, UCHAR Track)
{
    LPCDINFO lpInfo;
    MSF      TrackStart;
    MSF      NextTrackStart;

    lpInfo = (LPCDINFO) hCD;

    dprintf2(("CdTrackLength(%08XH, %u)", hCD, Track));

    //
    // Get the start of this track
    //
    TrackStart = CdTrackStart(hCD, Track);

    if (TrackStart == INVALID_TRACK) {
	    return INVALID_TRACK;
    }

    if (Track == lpInfo->LastTrack) {
    	return reddiff(lpInfo->msfEnd, TrackStart);
    } else {
	    NextTrackStart = CdTrackStart(hCD, (UCHAR)(Track + 1));
	    if (NextTrackStart == INVALID_TRACK) {
    	    return INVALID_TRACK;
	    } else {
	        return reddiff(NextTrackStart, TrackStart);
	    }
    }
}

/***************************************************************************

    @doc EXTERNAL

    @api MSF | CdTrackType | Get the type of a track.

    @parm HCD | hCD | The handle of a currently open drive.

    @parm UCHAR | Track | The track number.

    @rdesc The return value is either MCI_TRACK_AUDIO or MCI_TRACK_OTHER.

***************************************************************************/

int CdTrackType(HCD hCD, UCHAR Track)
{
    LPCDINFO lpInfo;

    lpInfo = (LPCDINFO) hCD;

    dprintf2(("CdTrackType(%08XH, %u)", hCD, Track));

    if ( INVALID_TRACK == CdTrackStart(hCD, (UCHAR)Track) ) {
	    return INVALID_TRACK;
    }

    if ( lpInfo->Track[Track-lpInfo->FirstTrack].Ctrl & IS_DATA_TRACK) {
	    return MCI_CDA_TRACK_OTHER;
    }
    return MCI_CDA_TRACK_AUDIO;
}


/***************************************************************************

    @doc EXTERNAL

    @api MSF | CdPosition | Get the current position.

    @parm HCD | hCD | The handle of a currently open drive.

    @parm MSF * | tracktime | position in MSF (track relative)

    @parm MSF * | disktime | position in MSF (disk relative)

    @rdesc TRUE if position returned correctly (in tracktime and disktime).
	   FALSE otherwise.

	   If the device does not support query of the position then
	   we return position 0.

***************************************************************************/

BOOL CdPosition(HCD hCD, MSF *tracktime, MSF *disktime)
{
    LPCDINFO lpInfo;
    SUB_Q_CHANNEL_DATA sqd;
    CDROM_SUB_Q_DATA_FORMAT Format;
    MSF msfPos;
    int tries;
    DWORD dwReturn;
    UCHAR fStatus;
    UCHAR fCode;
    UCHAR cTrack;

    dprintf2(("CdPosition(%08XH)", hCD));

    Format.Format = IOCTL_CDROM_CURRENT_POSITION;

    lpInfo = (LPCDINFO) hCD;

    for (tries=0; tries<10; tries++) 
    {
	    memset(&sqd, 0xFF, sizeof(sqd));
	    dwReturn = cdIoctlData(lpInfo, IOCTL_CDROM_READ_Q_CHANNEL,
			                   &Format, sizeof(Format), &sqd, sizeof(sqd));

        switch (dwReturn)
	    {
        case ERROR_SUCCESS:
            fStatus = sqd.CurrentPosition.Header.AudioStatus;
            fCode   = sqd.CurrentPosition.FormatCode;
            cTrack  = sqd.CurrentPosition.TrackNumber;

            // Save previous audio status to prevent bug
            CdSetAudioStatus (hCD, fStatus);

		    // If the track > 100  (outside spec'ed range)
		    // OR track > last track number
	        // then display an error message
		    if ((fCode == 0x01) &&
		        ( (100 < cTrack) || 
                  ((lpInfo->bTOCValid) && (lpInfo->LastTrack < cTrack))) &&
		        (tries<9)) {
			    // Always display this message on checked builds.
			    // We need some feeling for how often this happens
			    // It should NEVER happen, but (at least for NEC
			    // drives) we see it after a seek to end
			    dprintf1(("CDIoctlData returned track==%d, retrying", cTrack));
		        continue;
		    }
		    break;

        case ERROR_INVALID_FUNCTION:
        	dprintf2(("CdPositon - Error Invalid Function"));
		    *tracktime = REDTH(0, 1);
		    *disktime = REDTH(0, 0);
		    return TRUE;

	    default:
		    dprintf1(("CdPosition - Failed to get Q channel data"));
		    return FALSE;
	    }

	    dprintf4(("Status = %02X, Length[0] = %02X, Length[1] = %02X",
		         fStatus,
		         sqd.CurrentPosition.Header.DataLength[0],
		         sqd.CurrentPosition.Header.DataLength[1]));

	    dprintf4(("  Format %02XH", fCode));
	    dprintf4(("  Absolute Address %02X%02X%02X%02XH",
		         sqd.CurrentPosition.AbsoluteAddress[0],
		         sqd.CurrentPosition.AbsoluteAddress[1],
		         sqd.CurrentPosition.AbsoluteAddress[2],
		         sqd.CurrentPosition.AbsoluteAddress[3]));
	    dprintf4(("  Relative Address %02X%02X%02X%02XH",
		         sqd.CurrentPosition.TrackRelativeAddress[0],
		         sqd.CurrentPosition.TrackRelativeAddress[1],
		         sqd.CurrentPosition.TrackRelativeAddress[2],
		         sqd.CurrentPosition.TrackRelativeAddress[3]));

	    if (fCode == 0x01) {        // MSF format ?

	        // data is current position

	        msfPos = MAKERED(sqd.CurrentPosition.AbsoluteAddress[1],
			                  sqd.CurrentPosition.AbsoluteAddress[2],
			                  sqd.CurrentPosition.AbsoluteAddress[3]);


	        if (msfPos == 0) 
  