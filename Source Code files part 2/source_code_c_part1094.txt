yPath
    //

    printf("rtdmp: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtdmp: t0: %08lx\n", status);
        exit(1);
    }

    Dump(BaseHandle);
}


void
Dump(
    HANDLE  Handle
    )
{
    NTSTATUS    status;
    PKEY_BASIC_INFORMATION KeyInformation;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG   NamePos;
    ULONG   index;
    STRING  enumname;
    HANDLE  WorkHandle;
    ULONG   ResultLength;
    static  char buffer[WORK_SIZE];
    PUCHAR  p;

    KeyInformation = (PKEY_BASIC_INFORMATION)buffer;
    NamePos = WorkName.Length;

    //
    // Print name of node we are about to dump out
    //
    print(&WorkName);
    printf("::\n\n");

    //
    // Print out node's values
    //
    DumpValues(Handle);

    //
    // Enumerate node's children and apply ourselves to each one
    //

    for (index = 0; TRUE; index++) {

        RtlZeroMemory(KeyInformation, WORK_SIZE);
        status = NtEnumerateKey(
                    Handle,
                    index,
                    KeyBasicInformation,
                    KeyInformation,
                    WORK_SIZE,
                    &ResultLength
                    );

        if (status == STATUS_NO_MORE_ENTRIES) {

            WorkName.Length = NamePos;
            return;

        } else if (!NT_SUCCESS(status)) {

            printf("rtdmp: dump1: status = %08lx\n", status);
            exit(1);

        }

        enumname.Buffer = &(KeyInformation->Name[0]);
        enumname.Length = KeyInformation->NameLength;
        enumname.MaximumLength = KeyInformation->NameLength;

        p = WorkName.Buffer;
        p += WorkName.Length;
        *p = '\\';
        p++;
        *p = '\0';
        WorkName.Length += 2;

        RtlAppendStringToString((PSTRING)&WorkName, (PSTRING)&enumname);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &enumname,
            0,
            Handle,
            NULL
            );
        ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

        status = NtOpenKey(
                    &WorkHandle,
                    MAXIMUM_ALLOWED,
                    &ObjectAttributes
                    );
        if (!NT_SUCCESS(status)) {
            printf("rtdmp: dump2: %08lx\n", status);
            exit(1);
        }

        Dump(WorkHandle);
        NtClose(WorkHandle);
        WorkName.Length = NamePos;
    }
}


void
DumpValues(
    HANDLE  Handle
    )
{
    NTSTATUS    status;
    static  char        tempbuffer[WORK_SIZE];
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    ULONG   index;
    ULONG   ResultLength;
    PULONG  p;
    ULONG i;
    UNICODE_STRING valname;

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)tempbuffer;

    for (index = 0; TRUE; index++) {

        RtlZeroMemory(KeyValueInformation, WORK_SIZE);
        status = NtEnumerateValueKey(
                    Handle,
                    index,
                    KeyValueFullInformation,
                    KeyValueInformation,
                    WORK_SIZE,
                    &ResultLength
                    );
        if (status == STATUS_NO_MORE_ENTRIES) {

            return;

        } else if (!NT_SUCCESS(status)) {

            printf("rtdmp: dumpvalues: status = %08lx\n", status);
            exit(1);

        }

        printf("\t");
        valname.Length = KeyValueInformation->NameLength;
        valname.MaximumLength = KeyValueInformation->NameLength;
        valname.Buffer = (PWSTR)&(KeyValueInformation->Name[0]);
        printf("'");
        print(&valname);
        printf("'\n");
        printf(
            "\ttitle index = %d\ttype = ",
            KeyValueInformation->TitleIndex
            );
        switch( KeyValueInformation->Type ) {
        case REG_NONE:
            printf("NONE\n\tValue = 0x%x",
                   *((PULONG)KeyValueInformation + KeyValueInformation->DataOffset));
            break;

        case REG_SZ:
            printf("REG_SZ\n\tValue = '%ws'",
                   ((PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset));
            break;

        case REG_BINARY:
            printf("REG_BINARY\n\tValue = (%lx)\n", KeyValueInformation->DataLength);
            p = (PULONG)KeyValueInformation + KeyValueInformation->DataOffset;
            i = 1;
            while (i <= KeyValueInformation->DataLength) {
                printf( "  %08lx", *p++ );
                if ((i % 8) == 0) {
                    printf( "\n" );
                }
                i += sizeof( ULONG );
            }
            break;

//      case REG_DWORD:
        case REG_DWORD_LITTLE_ENDIAN:
            printf("REG_DWORD\n\tValue = 0x%lx",
                   *((PULONG)KeyValueInformation + KeyValueInformation->DataOffset));
            break;

        case REG_DWORD_BIG_ENDIAN:
            printf("REG_DWORD_BIG_ENDIAN\n\tValue = 0x%lx",
                   *((PULONG)KeyValueInformation + KeyValueInformation->DataOffset));
            break;

        }
        printf("\n\n");
    }
}


void
print(
    PUNICODE_STRING  String
    )
{
    static  ANSI_STRING temp;
    static  char        tempbuffer[WORK_SIZE];

    temp.MaximumLength = WORK_SIZE;
    temp.Length = 0L;
    temp.Buffer = tempbuffer;

    RtlUnicodeStringToAnsiString(&temp, String, FALSE);
    printf("%s", temp.Buffer);
    return;
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 2) )
    {
        printf("Usage: %s <KeyPath>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        FALSE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtflush.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rtflush.c

Abstract:

    NT level registry test program, basic non-error paths.

    Flush a key.

    rtflush <KeyPath>

    Will flush the key named by <KeyPath>

    Example:

        rtflush \REGISTRY\MACHINE\TEST\bigkey

Author:

    Bryan Willman (bryanwi)  10-Jan-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtflush: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtflush: t0: %08lx\n", status);
        exit(1);
    }

    status = NtFlushKey(BaseHandle);
    if (!NT_SUCCESS(status)) {
        printf("rtflush: t0: %08lx\n", status);
        exit(1);
    }

    NtClose(BaseHandle);
    exit(0);
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 2) )
    {
        printf("Usage: %s <KeyPath>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        FALSE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtdmpval.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtdmpval.c

Abstract:

    NT level registry api test program, basic non-error paths.

    dump a key's value entry (field)

    rtdmpval <KeyPath> <value entry name>

    Example:

        rtdmpval \REGISTRY\MACHINE\TEST\bigkey first_value_field

Author:

    John Vert (jvert) 25-Mar-1993 (written expressly for reading JimK's
        supersecret file)

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

void
Delete(
    HANDLE  Handle
    );

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

UNICODE_STRING  ValueName;
WCHAR           valuebuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;
    KEY_VALUE_PARTIAL_INFORMATION PartialInfo;
    PKEY_VALUE_PARTIAL_INFORMATION pInfo;
    ULONG i;
    ULONG Count;


    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);


    ValueName.MaximumLength = WORK_SIZE;
    ValueName.Length = 0L;
    ValueName.Buffer = &(valuebuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtdmpval: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                KEY_READ,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtdmpval: t0: %08lx\n", status);
        exit(1);
    }

    status = NtQueryValueKey(BaseHandle,
                             &ValueName,
                             KeyValuePartialInformation,
                             &PartialInfo,
                             sizeof(PartialInfo),
                             &Count);

    pInfo=malloc(PartialInfo.DataLength+sizeof(PartialInfo));
    status = NtQueryValueKey(BaseHandle,
                             &ValueName,
                             KeyValuePartialInformation,
                             pInfo,
                             PartialInfo.DataLength+sizeof(PartialInfo),
                             &Count);
    if (!NT_SUCCESS(status)) {
        printf("rtdmpval: t2: %08lx\n", status);
        exit(1);
    }

    for (i=0; i<PartialInfo.DataLength; i++) {
        printf("%c",pInfo->Data[i]);
    }

    free(pInfo);
    NtClose(BaseHandle);
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 3) )
    {
        printf("Usage: %s <KeyPath> <value entry name>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &ValueName,
        &temp,
        TRUE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtload.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtload.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Perform an NtLoadKey call to link a hive file into the registry.

    If KeyPath is not present, it loads the hive file at
        \Registry\User\FileName

    rtload  [ <KeyPath> ] <FileName>

    Example:

        rtload \registry\user\JVert JVUser

Author:

    John Vert (jvert) 15-Apr-92

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

UNICODE_STRING  KeyPath;
WCHAR           KeyPathBuffer[WORK_SIZE];

UNICODE_STRING  FileName;
WCHAR           FileNameBuffer[WORK_SIZE];

OBJECT_ATTRIBUTES FileAttributes;
OBJECT_ATTRIBUTES KeyAttributes;
RTL_RELATIVE_NAME RelativeName;

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK  IoStatus;
    HANDLE  FileHandle;
    HANDLE  KeyHandle;

    //
    // Process args
    //

    KeyPath.MaximumLength = WORK_SIZE;
    KeyPath.Length = 0L;
    KeyPath.Buffer = &(KeyPathBuffer[0]);

    FileName.MaximumLength = WORK_SIZE;
    FileName.Length = 0L;
    FileName.Buffer = &(FileNameBuffer[0]);

    processargs(argc, argv);


    //
    // Set up FileName
    //

    printf("rtload: starting\n");


    status = NtLoadKey(&KeyAttributes, &FileAttributes);
    if (!NT_SUCCESS(status)) {
        printf("rtload: key load failed status = %08lx\n", status);
        exit(1);
    } else {
        printf("rtload: success!\n");
    }

    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;
    UNICODE_STRING DosFileName;
    HANDLE UserHandle;
    PWSTR FilePart;
    NTSTATUS Status;

    if ( (argc != 2) && (argc != 3))
    {
        printf("Usage: %s [ <KeyName> ] <FileName>\n",
                argv[0]);
        exit(1);
    }
    if (argc == 3) {

        RtlInitAnsiString(
            &temp,
            argv[1]
            );

        RtlAnsiStringToUnicodeString(
            &KeyPath,
            &temp,
            TRUE
            );

        RtlInitAnsiString(
            &temp,
            argv[2]
            );

        RtlAnsiStringToUnicodeString(
            &DosFileName,
            &temp,
            TRUE
            );

        RtlDosPathNameToNtPathName_U( DosFileName.Buffer,
                                      &FileName,
                                      NULL,
                                      NULL );

        InitializeObjectAttributes(
            &FileAttributes,
            &FileName,
            OBJ_CASE_INSENSITIVE,
            (HANDLE)NULL,
            NULL
            );

        //
        // Set up KeyPath
        //

        InitializeObjectAttributes(
            &KeyAttributes,
            &KeyPath,
            OBJ_CASE_INSENSITIVE,
            (HANDLE)NULL,
            NULL
            );
    } else if (argc==2) {
        RtlInitAnsiString(&temp, argv[1]);
        RtlAnsiStringToUnicodeString(&DosFileName, &temp, TRUE);
        RtlDosPathNameToNtPathName_U( DosFileName.Buffer,
                                      &FileName,
                                      &FilePart,
                                      &RelativeName );

        InitializeObjectAttributes( &FileAttributes,
                                    &RelativeName.RelativeName,
                                    OBJ_CASE_INSENSITIVE,
                                    RelativeName.ContainingDirectory,
                                    NULL );

        RtlInitUnicodeString(&KeyPath, L"\\Registry\\User");
        InitializeObjectAttributes( &KeyAttributes,
                                    &KeyPath,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL );
        Status = NtOpenKey( &UserHandle,
                            KEY_READ,
                            &KeyAttributes);
        if (!NT_SUCCESS(Status)) {
            printf("Couldn't open \\Registry\\User, status %08lx\n",Status);
            exit(1);
        }

        RtlInitUnicodeString(&KeyPath, FilePart);
        InitializeObjectAttributes( &KeyAttributes,
                                    &KeyPath,
                                    OBJ_CASE_INSENSITIVE,
                                    UserHandle,
                                    NULL );

    }


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtmisc1.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtmisc1.c

Abstract:

    NT level registry api test program #1, basic non-error paths.

    Test open, create, setvalue, queryvalue, enumeratekey, enumeratevalue,
    querykey.

Author:

    Bryan Willman (bryanwi)  19-Nov-91

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//
//  NOTE:   This version of the test operations on \REGISTRY\MACHINE\TEST\*,
//          which is the TEST hive.  This hive will not exist in production
//          systems, so the test will have to change.
//


void __cdecl main(int, char *);

VOID
NameClassAndTitle(
    KEY_NODE_INFORMATION    *NodeInformation,
    UNICODE_STRING          ClassName,
    ULONG                   TitleIndex,
    UNICODE_STRING          KeyName,
    LARGE_INTEGER           CompTime,
    BOOLEAN                 Strong,         // time must be >= CompTime
    PUCHAR                  TestName
    );

VOID
expectstring(
    PWSTR   expected,
    ULONG   expectedlength,
    PWSTR   actual,
    ULONG   actuallength
    );

VOID
expecttime(
    LARGE_INTEGER   ExpectTime,
    LARGE_INTEGER   ActualTime
    );


#define TITLE_INDEX_1   122259
#define TITLE_INDEX_2   120858
#define TITLE_INDEX_3   120159
#define TYPE_1          666
#define TYPE_2          1066


ULONG           failure = 0;


void
__cdecl main(int, char *)
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING  KeyName;
    UNICODE_STRING  KeyName2;
    UNICODE_STRING  ClassName;
    UNICODE_STRING  ClassName2;
    UNICODE_STRING  ValueName;
    UNICODE_STRING  ValueName2;
    HANDLE          BaseHandle;
    HANDLE          Testhand1;
    ULONG           Disposition;
    LARGE_INTEGER   CompTime;
    ULONG           buffer[100];
    ULONG           bufsize = sizeof(ULONG) * 100;
    PKEY_NODE_INFORMATION NodeInformation;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    PKEY_VALUE_BASIC_INFORMATION KeyValueBasic;
    ULONG           ResultLength;
    PUCHAR          datastring = "Some simple ascii data for use as a value";
    PUCHAR          datastring2 = "Some more not so simple data $#";
    ULONG           expected;
    PVOID           tp;


    printf("rtmisc1: starting\n");

    NodeInformation = (PKEY_NODE_INFORMATION)&(buffer[0]);
    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)&(buffer[0]);
    KeyValueBasic = (PKEY_VALUE_BASIC_INFORMATION)&(buffer[0]);

    //
    // t0: Perform all operations against a base node, open it here.
    //

    RtlInitUnicodeString(
        &KeyName,
        L"\\REGISTRY\\MACHINE\\TEST"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t0: %08lx\n", status);
        goto punt;
    }


    //
    // t1: Create a key with class and title index
    //

    RtlInitUnicodeString(
        &ClassName,
        L"t1 Class Name"
        );

    RtlInitUnicodeString(
        &KeyName,
        L"first_test_node"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        0,
        BaseHandle,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    NtQuerySystemTime(&CompTime);

//  printf("ClassName@%08lx  KeyName@%08lx\n",
//          ClassName.Buffer, KeyName.Buffer);

    status = NtCreateKey(
                &Testhand1,
                MAXIMUM_ALLOWED,
                &ObjectAttributes,
                TITLE_INDEX_1,
                &ClassName,
                0,
                &Disposition
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t1: %08lx\n", status);
        goto punt;
    }

    if (Disposition != REG_CREATED_NEW_KEY) {
        printf("rtmisc1: t1a: got old key, expected to create new one\n");
        failure++;
    }

    //
    // t2: See if we can get data back, and if it makes sense
    //

    RtlZeroMemory(NodeInformation, bufsize);
    status = NtQueryKey(
                Testhand1,
                KeyNodeInformation,
                NodeInformation,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t2a: %08lx\n", status);
        goto punt;
    }
    if (ResultLength != 80) {
        printf("rtmisc1: t2i: expect 80, ResultLength = %d\n", ResultLength);
        failure++;
    }


    NameClassAndTitle(
        NodeInformation,
        ClassName,
        TITLE_INDEX_1,
        KeyName,
        CompTime,
        FALSE,          // time must be >= CompTime
        "rtmisc1: t2b: "
        );
    CompTime = NodeInformation->LastWriteTime;

    status = NtClose(Testhand1);
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t2c: %08lx\n");
        goto punt;
    }


    //
    // t3: Reopen the key with create, see if data still there.
    //

    status = NtCreateKey(
                &Testhand1,
                MAXIMUM_ALLOWED,
                &ObjectAttributes,
                TITLE_INDEX_1,
                &ClassName,
                0,
                &Disposition
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t3: %08lx\n", status);
        goto punt;
    }

    if (Disposition != REG_OPENED_EXISTING_KEY) {
        printf("rtmisc1: t3a failure\n");
        failure++;
    }

    RtlZeroMemory(NodeInformation, bufsize);
    status = NtQueryKey(
                Testhand1,
                KeyNodeInformation,
                NodeInformation,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t3b: %08lx\n", status);
        goto punt;
    }

    NameClassAndTitle(
        NodeInformation,
        ClassName,
        TITLE_INDEX_1,
        KeyName,
        CompTime,
        FALSE,          // time must be >= CompTime
        "rtmisc1: t3c: "
        );

    status = NtClose(Testhand1);
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t3d: %08lx\n");
        goto punt;
    }


    //
    // t4: Reopen the key with open, see if data still there.
    //

    status = NtOpenKey(
                &Testhand1,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t4: %08lx\n", status);
        goto punt;
    }

    RtlZeroMemory(NodeInformation, bufsize);
    status = NtQueryKey(
                Testhand1,
                KeyNodeInformation,
                NodeInformation,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t4a: %08lx\n", status);
        goto punt;
    }

    NameClassAndTitle(
        NodeInformation,
        ClassName,
        TITLE_INDEX_1,
        KeyName,
        CompTime,
        FALSE,          // time must be >= CompTime
        "rtmisc1: t4b: "
        );

//  status = NtClose(Testhand1);
//  if (!NT_SUCCESS(status)) {
//      printf("rtmisc1: t4c: %08lx\n");
//      exit(1);
//  }


    //
    // t5: Create a value
    //

    RtlInitUnicodeString(
        &ValueName,
        L"the very first value stored in the registry"
        );


    status = NtSetValueKey(
                Testhand1,
                &ValueName,
                TITLE_INDEX_2,
                TYPE_1,
                datastring,
                strlen(datastring)+1
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t5: %08lx\n", status);
        failure++;
    }


    //
    // t6: Read the value back
    //

    RtlZeroMemory(KeyValueInformation, bufsize);
    status = NtQueryValueKey(
                Testhand1,
                &ValueName,
                KeyValueFullInformation,
                KeyValueInformation,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t6: %08lx\n", status);
        goto punt;
    }
    expected = FIELD_OFFSET(KEY_VALUE_FULL_INFORMATION, Name) +
                    ValueName.Length + strlen(datastring) + 1;
    if (ResultLength != expected) {
        printf("rtmisc1: t6a: expected = %08lx actual = %08lx",
                expected, ResultLength);
        failure++;
    }

    if ( (KeyValueInformation->TitleIndex != TITLE_INDEX_2)         ||
         (KeyValueInformation->Type != TYPE_1)                      ||
         (KeyValueInformation->NameLength != ValueName.Length)      ||
         (KeyValueInformation->DataLength != strlen(datastring)+1))
    {
        printf("rtmisc1: t6b: wrong description data\n");
        failure++;
    }


    tp = (PWSTR)&(KeyValueInformation->Name[0]);
    if (wcsncmp(ValueName.Buffer, tp, (ValueName.Length/sizeof(WCHAR))) != 0) {
        printf("rtmisc1: t6c: wrong name\n");
        expectstring(
            ValueName.Buffer,
            (ValueName.Length/sizeof(WCHAR)),
            (PWSTR)&(KeyValueInformation->Name[0]),
            (KeyValueInformation->NameLength/sizeof(WCHAR))
            );
        failure++;
    }


    tp = (PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset;
    if (strcmp(tp, datastring) != 0) {
        printf("rtmisc1: t6d: wrong data\n");
        printf("expected '%s', got '%s'\n", datastring, tp);
        failure++;
    }

    //
    // t7: Create a second value
    //

    RtlInitUnicodeString(
        &ValueName2,
        L"the second value stored in the registry"
        );


    status = NtSetValueKey(
                Testhand1,
                &ValueName2,
                TITLE_INDEX_3,
                TYPE_2,
                datastring2,
                strlen(datastring2)+1
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t7: %08lx\n", status);
        failure++;
    }

    //
    // t8: Read the second value back (short form)
    //

    RtlZeroMemory(KeyValueBasic, bufsize);
    status = NtQueryValueKey(
                Testhand1,
                &ValueName2,
                KeyValueBasicInformation,
                KeyValueBasic,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t8: %08lx\n", status);
        goto punt;
    }

    expected = FIELD_OFFSET(KEY_VALUE_BASIC_INFORMATION, Name) +
                    ValueName2.Length;
    if (ResultLength != expected) {
        printf("rtmisc1: t8a: expected = %08lx actual = %08lx",
                expected, ResultLength);
        failure++;
    }

    if ( (KeyValueBasic->TitleIndex != TITLE_INDEX_3)         ||
         (KeyValueBasic->Type != TYPE_2)                      ||
         (KeyValueBasic->NameLength != ValueName2.Length))
    {
        printf("rtmisc1: t8b: wrong description data\n");
        failure++;
    }


    tp = (PWSTR)&(KeyValueBasic->Name[0]);
    if (wcsncmp(ValueName2.Buffer, tp, (ValueName2.Length/sizeof(WCHAR))) != 0) {
        printf("rtmisc1: t8c: wrong name\n");
        expectstring(
            ValueName2.Buffer,
            (ValueName2.Length/sizeof(WCHAR)),
            (PWSTR)&(KeyValueBasic->Name[0]),
            (KeyValueBasic->NameLength/sizeof(WCHAR))
            );
        failure++;
    }


    //
    // t9: Enumerate the values (short form)
    //

    RtlZeroMemory(KeyValueBasic, bufsize);
    status = NtEnumerateValueKey(
                Testhand1,
                0,              // Index
                KeyValueBasicInformation,
                KeyValueBasic,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t9: %08lx\n", status);
        goto punt;
    }

    expected = FIELD_OFFSET(KEY_VALUE_BASIC_INFORMATION, Name) +
                    ValueName.Length;
    if (ResultLength != expected) {
        printf("rtmisc1: t9a: expected = %08lx actual = %08lx",
                expected, ResultLength);
        failure++;
    }

    if (KeyValueBasic->NameLength != ValueName.Length)
    {
        printf("rtmisc1: t9b: wrong description data\n");
        failure++;
    }


    tp = (PWSTR)&(KeyValueBasic->Name[0]);
    if (wcsncmp(ValueName.Buffer, tp, (ValueName.Length/sizeof(WCHAR))) != 0) {
        printf("rtmisc1: t9c: wrong name\n");
        expectstring(
            ValueName.Buffer,
            (ValueName.Length/sizeof(WCHAR)),
            (PWSTR)&(KeyValueBasic->Name[0]),
            (KeyValueBasic->NameLength/sizeof(WCHAR))
            );
        failure++;
    }

    RtlZeroMemory(KeyValueBasic, bufsize);
    status = NtEnumerateValueKey(
                Testhand1,
                1,              // Index
                KeyValueBasicInformation,
                KeyValueBasic,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t9d: %08lx\n", status);
        goto punt;
    }

    expected = FIELD_OFFSET(KEY_VALUE_BASIC_INFORMATION, Name) +
                    ValueName2.Length;
    if (ResultLength != expected) {
        printf("rtmisc1: t9e: expected = %08lx actual = %08lx",
                expected, ResultLength);
        failure++;
    }

    if (KeyValueBasic->NameLength != ValueName2.Length)
    {
        printf("rtmisc1: t9f: wrong description data\n");
        failure++;
    }


    tp = (PWSTR)&(KeyValueBasic->Name[0]);
    if (wcsncmp(ValueName2.Buffer, tp, (ValueName2.Length/sizeof(WCHAR))) != 0) {
        printf("rtmisc1: t9g: wrong name\n");
        expectstring(
            ValueName2.Buffer,
            (ValueName2.Length/sizeof(WCHAR)),
            (PWSTR)&(KeyValueBasic->Name[0]),
            (KeyValueBasic->NameLength/sizeof(WCHAR))
            );
        failure++;
    }

    status = NtEnumerateValueKey(
                Testhand1,
                2,              // Index
                KeyValueBasicInformation,
                KeyValueBasic,
                bufsize,
                &ResultLength
                );
    if (status != STATUS_NO_MORE_ENTRIES) {
        printf("rtmisc1: t9h: %08lx\n", status);
        goto punt;
    }

    //
    // t10: create a second subkey and ennumerate the subkeys
    //

    status = NtClose(Testhand1);
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t10a: %08lx\n", status);
        failure++;
    }

    RtlInitUnicodeString(
        &ClassName2,
        L"t2 Class Name"
        );

    RtlInitUnicodeString(
        &KeyName2,
        L"second_test_node"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName2,
        0,
        BaseHandle,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtCreateKey(
                &Testhand1,
                MAXIMUM_ALLOWED,
                &ObjectAttributes,
                TITLE_INDEX_2,
                &ClassName2,
                0,
                &Disposition
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t10b: %08lx\n", status);
        goto punt;
    }

    if (Disposition != REG_CREATED_NEW_KEY) {
        printf("rtmisc1: t10c: got old key, expected to create new one\n");
        failure++;
    }

    //
    // See if we can get data back, and if it makes sense
    //

    RtlZeroMemory(NodeInformation, bufsize);
    status = NtQueryKey(
                Testhand1,
                KeyNodeInformation,
                NodeInformation,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t10d: %08lx\n", status);
        goto punt;
    }
    CompTime = NodeInformation->LastWriteTime;


    NameClassAndTitle(
        NodeInformation,
        ClassName2,
        TITLE_INDEX_2,
        KeyName2,
        CompTime,
        TRUE,
        "rtmisc1: t10e: "
        );

    status = NtClose(Testhand1);
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t10f: %08lx\n");
        goto punt;
    }


    RtlZeroMemory(NodeInformation, bufsize);
    status = NtEnumerateKey(
                BaseHandle,
                0,
                KeyNodeInformation,
                NodeInformation,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t10g: %08lx\n", status);
        failure++;
    }
    CompTime = NodeInformation->LastWriteTime;

    NameClassAndTitle(
        NodeInformation,
        ClassName,
        TITLE_INDEX_1,
        KeyName,
        CompTime,
        TRUE,
        "rtmisc1: t10h: "
        );


    RtlZeroMemory(NodeInformation, bufsize);
    status = NtEnumerateKey(
                BaseHandle,
                1,
                KeyNodeInformation,
                NodeInformation,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t10i: %08lx\n", status);
        failure++;
    }
    CompTime = NodeInformation->LastWriteTime;

    NameClassAndTitle(
        NodeInformation,
        ClassName2,
        TITLE_INDEX_2,
        KeyName2,
        CompTime,
        TRUE,
        "rtmisc1: t10j: "
        );


    status = NtEnumerateKey(
                BaseHandle,
                2,
                KeyNodeInformation,
                NodeInformation,
                bufsize,
                &ResultLength
                );
    if (status != STATUS_NO_MORE_ENTRIES) {
        printf("rtmisc1: t10k: %08lx\n", status);
        failure++;
    }

    //
    // Summary report
    //

    if (!failure) {
        printf("rtmisc1: success");
        exit(0);
    } else {
        printf("rtmisc1: failed, %d failures\n", failure);
        exit(1);
    }

punt:
    failure++;
    printf("rtmisc1: failed, %d failures\n", failure);
    exit(1);
}



VOID
NameClassAndTitle(
    KEY_NODE_INFORMATION    *NodeInformation,
    UNICODE_STRING          ClassName,
    ULONG                   TitleIndex,
    UNICODE_STRING          KeyName,
    LARGE_INTEGER           CompTime,
    BOOLEAN                 Strong,         // time must be >= CompTime
    PUCHAR                  TestName
    )
{
    PWSTR   p;

    if (Strong) {

        //
        // require exact match
        //

        if ((CompTime.HighPart != NodeInformation->LastWriteTime.HighPart) ||
            (CompTime.LowPart != NodeInformation->LastWriteTime.LowPart))
        {
            printf("%s Wrong time (a)\n", TestName);
            expecttime(CompTime, NodeInformation->LastWriteTime);
            failure++;
        }


    } else {

        //
        // >= will do
        //

        if ( (CompTime.HighPart > NodeInformation->LastWriteTime.HighPart) ||
             ((CompTime.HighPart == NodeInformation->LastWriteTime.HighPart) &&
              (CompTime.LowPart > NodeInformation->LastWriteTime.LowPart)) )
        {
            printf("%s Wrong time (b)\n", TestName);
            expecttime(CompTime, NodeInformation->LastWriteTime);
            failure++;
        }
    }


    p = (PWSTR)((PUCHAR)NodeInformation + NodeInformation->ClassOffset);
    if ( (NodeInformation->ClassLength != ClassName.Length) ||
         (wcsncmp(ClassName.Buffer, p, (ClassName.Length/sizeof(WCHAR))) != 0))
    {
        printf("%s wrong class name\n", TestName);
        failure++;
    }

    if (NodeInformation->TitleIndex != TitleIndex) {
        printf("%s wrong title index\n", TestName);
        failure++;
    }

    p = (PWSTR)(&(NodeInformation->Name[0]));
    if ( (NodeInformation->NameLength != KeyName.Length) ||
         (wcsncmp(KeyName.Buffer, p, (KeyName.Length/sizeof(WCHAR))) != 0))
    {
        printf("%s wrong name\n", TestName);
        expectstring(
            KeyName.Buffer,
            (KeyName.Length/sizeof(WCHAR)),
            (PWSTR)&(NodeInformation->Name[0]),
            (NodeInformation->NameLength/sizeof(WCHAR))
            );
        failure++;
    }
}

VOID
expecttime(
    LARGE_INTEGER   ExpectTime,
    LARGE_INTEGER   ActualTime
    )
{
    printf("Expected %08lx%08lx\n", ExpectTime.HighPart, ExpectTime.LowPart);
    printf("Got      %08lx%08lx\n", ActualTime.HighPart, ActualTime.LowPart);
    return;
}

VOID
expectstring(
    PWSTR   expected,
    ULONG   expectedlength,
    PWSTR   actual,
    ULONG   actuallength
    )
{
    ULONG   i;

    printf("Expected Len %d Str = '", expectedlength);
    for (i = 0; i < expectedlength; i++) {
        printf("%c", (UCHAR)(expected[i]));
    }
    printf("'\n");

    printf("Got Len %d Str = '", actuallength);
    for (i = 0; i < actuallength; i++) {
        printf("%c", (UCHAR)(actual[i]));
    }
    printf("'\n");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtqkey.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtqkey.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Do a query on a key.

    rtqkey <KeyPath> [infotypenumber] [bufferlength]

    Example:

        rtqkey \REGISTRY\MACHINE\TEST\bigkey 1 100

Author:

    Bryan Willman (bryanwi)  9-Apr-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

UCHAR       Buffer[1024*64];

ULONG       InfoType = KeyFullInformation;
ULONG       BufferSize = -1;

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;
    ULONG   Sizes[] = { sizeof(KEY_BASIC_INFORMATION),
                        sizeof(KEY_NODE_INFORMATION),
                        sizeof(KEY_FULL_INFORMATION) };
    ULONG       ResultLength;
    PKEY_BASIC_INFORMATION pbasic;
    PKEY_NODE_INFORMATION  pnode;
    PKEY_FULL_INFORMATION  pfull;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtqkey: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                KEY_QUERY_VALUE,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtqkey: t0: %08lx\n", status);
        exit(1);
    }

    //
    // make test call
    //
    RtlFillMemory((PVOID)&(Buffer[0]), 1024*64, 0xaa);

    if (BufferSize == -1) {
        BufferSize = Sizes[InfoType];
    }

    status = NtQueryKey(
                BaseHandle,
                InfoType,
                (PVOID)&(Buffer[0]),
                BufferSize,
                &ResultLength
                );

    printf("status = %08lx  ResultLength = %08lx\n", status, ResultLength);
    switch (InfoType) {
    case KeyBasicInformation:
        pbasic = (PKEY_BASIC_INFORMATION)Buffer;
        printf("LastWriteTime: %08lx:%08lx\n", pbasic->LastWriteTime.HighPart,
                pbasic->LastWriteTime.LowPart);
        printf("TitleIndex: %08lx\n", pbasic->TitleIndex);
        printf("NameLength: %08lx\n", pbasic->NameLength);
        printf("Name: '%.*ws'\n", pbasic->NameLength/2, &(pbasic->Name));
        break;

    case KeyNodeInformation:
        pnode = (PKEY_NODE_INFORMATION)Buffer;
        printf("LastWriteTime: %08lx:%08lx\n", pnode->LastWriteTime.HighPart,
                pnode->LastWriteTime.LowPart);
        printf("TitleIndex: %08lx\n", pnode->TitleIndex);
        printf("ClassOffset: %08lx\n", pnode->ClassOffset);
        printf("ClassLength: %08lx\n", pnode->ClassLength);
        printf("NameLength: %08lx\n", pnode->NameLength);
        printf("Name: '%.*ws'\n", pnode->NameLength/2, &(pnode->Name));
        printf("Class: '%.*ws'\n", pnode->ClassLength/2,
                    (PWSTR)((PUCHAR)pnode + pnode->ClassOffset));
        break;

    case KeyFullInformation:
        pfull = (PKEY_FULL_INFORMATION)Buffer;
        printf("LastWriteTime: %08lx:%08lx\n", pfull->LastWriteTime.HighPart,
                pfull->LastWriteTime.LowPart);
        printf("TitleIndex: %08lx\n", pfull->TitleIndex);
        printf("ClassOffset: %08lx\n", pfull->ClassOffset);
        printf("ClassLength: %08lx\n", pfull->ClassLength);

        printf("SubKeys: %08lx       MaxNameLen: %08lx      MaxClassLen: %08lx\n",
                pfull->SubKeys, pfull->MaxNameLen, pfull->MaxClassLen);

        printf(" Values: %08lx  MaxValueNameLen: %08lx  MaxValueDataLen: %08lx\n",
                pfull->Values, pfull->MaxValueNameLen, pfull->MaxValueDataLen);

        printf("Class: '%.*ws'\n", pfull->ClassLength/2, pfull->Class);

        break;
    }

    NtClose(BaseHandle);
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc < 2) )
    {
        printf("Usage: %s <KeyPath> [infotype] [bufferlen]\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        TRUE
        );

    if (argc > 2) {
        InfoType = atoi(argv[2]);
    }

    if (argc > 3) {
        BufferSize = atoi(argv[3]);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtnotify.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rtnotify.c

Abstract:

    NT level registry test program, basic non-error paths.

    Wait for notification.

    This program tests waiting for notification on a change to
    a registry node.  It can wait synchronously, for an event,
    for for an Apc.  It can use any filter.

    Only the first letter of option control are significant.

    rtnotify <keyname> {key|tree|event|Apc|hold|name|write|security|prop|*}

        key = key only [default]  (last of these two wins)
        tree = subtree

        event = wait on an event (overrides hold)
        Apc = use an Apc         (overrides hold)
        hold = be synchronous [default]  (overrides event and Apc)

        name = watch for create/delete of children
        write = last set change
        security = acl change
        prop = any attr == security change
        * = all



    Example:

        rtflush \REGISTRY\MACHINE\TEST\bigkey

Author:

    Bryan Willman (bryanwi)  10-Jan-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void main();
void processargs();

ULONG CallCount = 0L;

VOID
ApcTest(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock
    );

UNICODE_STRING  KeyName;
WCHAR           workbuffer[WORK_SIZE];
BOOLEAN         WatchTree;
BOOLEAN         UseEvent;
BOOLEAN         UseApc;
BOOLEAN         ApcSeen;
BOOLEAN         Hold;
BOOLEAN         Filter;
IO_STATUS_BLOCK RtIoStatusBlock;


void
main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;
    HANDLE          EventHandle;
    PIO_APC_ROUTINE ApcRoutine;

    //
    // Process args
    //

    KeyName.MaximumLength = WORK_SIZE;
    KeyName.Length = 0L;
    KeyName.Buffer = &(workbuffer[0]);

    processargs(argc, argv);

    //
    // Set up and open KeyPath
    //

    printf("rtnotify: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                KEY_NOTIFY,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtnotify: t0: %08lx\n", status);
        exit(1);
    }

    EventHandle = (HANDLE)NULL;
    if (UseEvent == TRUE) {
        status = NtCreateEvent(
                    &EventHandle,
                    GENERIC_READ | GENERIC_WRITE  | SYNCHRONIZE,
                    NULL,
                    NotificationEvent,
                    FALSE
                    );
        if (!NT_SUCCESS(status)) {
            printf("rtnotify: t1: %08lx\n", status);
            exit(1);
        }
    }

    ApcRoutine = NULL;
    if (UseApc) {
        ApcRoutine = ApcTest;
    }

    printf("rtnotify:\n");
    printf("\tUseEvent = %08lx\n", UseEvent);
    printf("\tApcRoutine = %08lx\n", ApcRoutine);
    printf("\tHold = %08lx\n", Hold);
    printf("\tFilter = %08lx\n", Filter);
    printf("\tWatchTree = %08lx\n", WatchTree);

    while (TRUE) {
        ApcSeen = FALSE;
        printf("\nCallCount = %dt\n", CallCount);
        CallCount++;
        status = NtNotifyChangeKey(
                    BaseHandle,
                    EventHandle,
                    ApcRoutine,
                    (PVOID)1992,           // arbitrary context value
                    &RtIoStatusBlock,
                    Filter,
                    WatchTree,
                    NULL,
                    0,
                    ! Hold
                    );

        exit(0);

        if ( ! NT_SUCCESS(status)) {
            printf("rtnotify: t2: %08lx\n", status);
            exit(1);
        }

        if (Hold) {
            printf("rtnotify: Synchronous Status = %08lx\n", RtIoStatusBlock.Status);
        }

        if (UseEvent) {
            status = NtWaitForSingleObject(
                        EventHandle,
                        TRUE,
                        NULL
                        );
            if (!NT_SUCCESS(status)) {
                printf("rtnotify: t3: status = %08lx\n", status);
                exit(1);
            }
            printf("rtnotify: Event Status = %08lx\n", RtIoStatusBlock.Status);
        }

        if (UseApc) {
            while ((volatile)ApcSeen == FALSE) {
                NtTestAlert();
            }
        }
    }

    NtClose(BaseHandle);
    exit(0);
}


VOID
ApcTest(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock
    )
{
    ApcSeen = TRUE;

    if (ApcContext != (PVOID)1992) {
        printf("rtnotify: Apc: Apccontext is wrong %08lx\n", ApcContext);
        exit(1);
    }
    if (IoStatusBlock != &RtIoStatusBlock) {
        printf("rtnotify: Apc: IoStatusBlock is wrong %08ln", IoStatusBlock);
        exit(1);
    }


    printf("rtnotify: Apc status = %08lx\n", IoStatusBlock->Status);
    return;
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;
    ULONG   i;

    if (argc < 2) {
        goto Usage;
    }

    //
    // name
    //
    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyName,
        &temp,
        FALSE
        );

    WatchTree = FALSE;
    UseEvent = FALSE;
    UseApc = FALSE;
    Hold = TRUE;
    Filter = 0;

    //
    // switches
    //
    for (i = 2; i < (ULONG)argc; i++) {
        switch (*argv[i]) {

        case 'a':   // Apc
        case 'A':
            Hold = FALSE;
            UseApc = TRUE;
            break;

        case 'e':   // event
        case 'E':
            Hold = FALSE;
            UseEvent = TRUE;
            break;

        case 'h':   // hold
        case 'H':
            UseApc = FALSE;
            UseEvent = FALSE;
            Hold = TRUE;
            break;

        case 'k':   // key only
        case 'K':
            WatchTree = FALSE;
            break;

        case 'n':
        case 'N':
            Filter |= REG_NOTIFY_CHANGE_NAME;
            break;

        case 'p':
        case 'P':
            Filter |= REG_NOTIFY_CHANGE_ATTRIBUTES;
            break;

        case 's':
        case 'S':
            Filter |= REG_NOTIFY_CHANGE_SECURITY;
            break;

        case 't':   // subtree
        case 'T':
            WatchTree = TRUE;
            break;

        case 'w':
        case 'W':
            Filter |= REG_NOTIFY_CHANGE_LAST_SET;
            break;

        case '*':
            Filter = REG_LEGAL_CHANGE_FILTER;
            break;

        default:
            goto Usage;
            break;
        }
    }
    if (Filter == 0) {
        Filter = REG_LEGAL_CHANGE_FILTER;
    }
    return;

Usage:
    printf("Usage: %s <KeyPath> {key|tree|event|Apc|sync|name|write|security|attribute|*}\n",
            argv[0]);
    exit(1);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtrenval.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtrenval.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Rename a key value entry.

    rtrenval <KeyPath> <old value entry name> <new value entry name>

    Example:

        rtrenval \REGISTRY\MACHINE\TEST\bigkey apple banana

Author:

    Bryan Willman (bryanwi)  26-Feb-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

void
Delete(
    HANDLE  Handle
    );

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

UNICODE_STRING  ValueName;
WCHAR           valuebuffer[WORK_SIZE];

UNICODE_STRING  NewValueName;
WCHAR           newvaluebuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);


    ValueName.MaximumLength = WORK_SIZE;
    ValueName.Length = 0L;
    ValueName.Buffer = &(valuebuffer[0]);

    NewValueName.MaximumLength = WORK_SIZE;
    NewValueName.Length = 0L;
    NewValueName.Buffer = &(newvaluebuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //
    printf("rtrenval: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                KEY_SET_VALUE,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtrenval: t0: %08lx\n", status);
        exit(1);
    }

    NtRenameValueKey(
        BaseHandle,
        &ValueName,
        &NewValueName,
        42
        );

    if (!NT_SUCCESS(status)) {
        printf("rtrenval: t1: %08lx\n", status);
        exit(1);
    }

    NtClose(BaseHandle);
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 4) )
    {
        printf("Usage: %s <KeyPath> <old value entry name> <new value entry name>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &ValueName,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[3]
        );

    RtlAnsiStringToUnicodeString(
        &NewValueName,
        &temp,
        TRUE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtrestor.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtrestor.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Perform an NtRestoreKey call to load part of the registry from a file.

    rtrestor  <KeyPath> <FileName>

    Example:

        rtrestor \registry\machine\user userfile.rd

Author:

    Bryan Willman (bryanwi)  24-Jan-92

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

UNICODE_STRING  KeyPath;
WCHAR           KeyPathBuffer[WORK_SIZE];

UNICODE_STRING  FileName;
WCHAR           FileNameBuffer[WORK_SIZE];

BOOLEAN HiveVolatile;

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK  IoStatus;
    HANDLE  FileHandle;
    HANDLE  KeyHandle;
    BOOLEAN WasEnabled;

    //
    // Process args
    //

    KeyPath.MaximumLength = WORK_SIZE;
    KeyPath.Length = 0L;
    KeyPath.Buffer = &(KeyPathBuffer[0]);

    FileName.MaximumLength = WORK_SIZE;
    FileName.Length = 0L;
    FileName.Buffer = &(FileNameBuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open FileName
    //

    printf("rtrestor: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtCreateFile(
                &FileHandle,
                GENERIC_READ | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatus,
                0,                                      // AllocationSize
                FILE_ATTRIBUTE_NORMAL,
                0,                                      // ShareAccess
                FILE_OPEN_IF,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,                                   // EaBuffer
                0                                       // EaLength
                );

    if (!NT_SUCCESS(status)) {
        printf("rtsave: file open failed status = %08lx\n", status);
        exit(1);
    }

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyPath,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtsave: key open failed status = %08lx\n", status);
        exit(1);
    }

    RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    if (HiveVolatile) {
        status = NtRestoreKey(KeyHandle, FileHandle, REG_WHOLE_HIVE_VOLATILE);
    } else {
        status = NtRestoreKey(KeyHandle, FileHandle, 0);
    }

    RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);

    if (!NT_SUCCESS(status)) {
        printf("rtrestor: NtRestorKey failed status = %08lx\n", status);
        exit(1);
    }

    printf("rtsave: success\n");
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;
    UNICODE_STRING DosFileName;

    if ( (argc < 3) || (argc > 4) )
    {
        printf("Usage: %s <KeyName> <FileName> [VOLATILE]\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyPath,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &DosFileName,
        &temp,
        TRUE
        );

    RtlDosPathNameToNtPathName_U( DosFileName.Buffer,
                                  &FileName,
                                  NULL,
                                  NULL);

    if ((argc==4) && (_stricmp(argv[3],"volatile")==0)) {
        HiveVolatile = TRUE;
    } else {
        HiveVolatile = FALSE;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtrest2.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtrest2.c

Abstract:

    NT level registry api test program, basic error path

    Creates a key "Key1" and a subkey, "Key2"

    Calls NtSaveKey on Key1, then NtRestoreKey while a handle to Key2 is
    still open.

    rtrest2  <KeyPath> <FileName>

    Example:

        rtrest2 \registry\machine\system\test tempfile

Author:

    John Vert (jvert) 13-Jun-1992

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

UNICODE_STRING  KeyPath;
WCHAR           KeyPathBuffer[WORK_SIZE];

UNICODE_STRING  FileName;
WCHAR           FileNameBuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK  IoStatus;
    HANDLE  FileHandle;
    HANDLE  KeyHandle;

    //
    // Process args
    //

    KeyPath.MaximumLength = WORK_SIZE;
    KeyPath.Length = 0L;
    KeyPath.Buffer = &(KeyPathBuffer[0]);

    FileName.MaximumLength = WORK_SIZE;
    FileName.Length = 0L;
    FileName.Buffer = &(FileNameBuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open FileName
    //

    printf("rtrestor: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtCreateFile(
                &FileHandle,
                GENERIC_READ | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatus,
                0,                                      // AllocationSize
                FILE_ATTRIBUTE_NORMAL,
                0,                                      // ShareAccess
                FILE_OPEN_IF,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,                                   // EaBuffer
                0                                       // EaLength
                );

    if (!NT_SUCCESS(status)) {
        printf("rtsave: file open failed status = %08lx\n", status);
        exit(1);
    }

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyPath,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &KeyHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtsave: key open failed status = %08lx\n", status);
        exit(1);
    }

    status = NtRestoreKey(KeyHandle, FileHandle);

    if (!NT_SUCCESS(status)) {
        printf("rtrestor: NtRestorKey failed status = %08lx\n", status);
        exit(1);
    }

    printf("rtsave: success\n");
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 3) )
    {
        printf("Usage: %s <KeyName> <FileName>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyPath,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &FileName,
        &temp,
        TRUE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtreplac.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtreplac.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Perform an NtReplaceKey call to replace a registry hive.

    rtreplac  <KeyPath> <NewHiveName> <BackupOldHiveName>

    Example:

        rtreplac \registry\machine\user newuser olduser

Author:

    John Vert (jvert) 8-May-1992

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

UNICODE_STRING  KeyPath;
WCHAR           KeyPathBuffer[WORK_SIZE];

UNICODE_STRING  NewName;
WCHAR           NewNameBuffer[WORK_SIZE];
UNICODE_STRING  OldName;
WCHAR           OldNameBuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES NewAttributes;
    OBJECT_ATTRIBUTES OldAttributes;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK  IoStatus;
    HANDLE  FileHandle;
    HANDLE  KeyHandle;
    BOOLEAN WasEnabled;

    //
    // Process args
    //

    KeyPath.MaximumLength = WORK_SIZE;
    KeyPath.Length = 0L;
    KeyPath.Buffer = &(KeyPathBuffer[0]);

    NewName.MaximumLength = WORK_SIZE;
    NewName.Length = 0L;
    NewName.Buffer = &(NewNameBuffer[0]);

    OldName.MaximumLength = WORK_SIZE;
    OldName.Length = 0L;
    OldName.Buffer = &(OldNameBuffer[0]);

    processargs(argc, argv);

    //
    // Set up and open FileName
    //

    printf("rtreplac: starting\n");

    InitializeObjectAttributes(
        &NewAttributes,
        &NewName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    InitializeObjectAttributes(
        &OldAttributes,
        &OldName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyPath,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    status = NtOpenKey(
                &KeyHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtreplac: key open failed status = %08lx\n", status);
        exit(1);
    }

    RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    status = NtReplaceKey(&NewAttributes,
                          KeyHandle,
                          &OldAttributes);
    RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);

    if (!NT_SUCCESS(status)) {
        printf("rtreplac: NtReplaceKey failed status = %08lx\n", status);
        exit(1);
    }

    printf("rtreplac: success\n");
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;
    UNICODE_STRING DosFileName;

    if ( (argc != 4) )
    {
        printf("Usage: %s <KeyName> <NewFileName> <OldFileName>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyPath,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &DosFileName,
        &temp,
        TRUE
        );

    RtlDosPathNameToNtPathName_U( DosFileName.Buffer,
                                  &NewName,
                                  NULL,
                                  NULL );

    RtlInitAnsiString(
        &temp,
        argv[3]
        );

    RtlAnsiStringToUnicodeString(
        &DosFileName,
        &temp,
        TRUE
        );

    RtlDosPathNameToNtPathName_U( DosFileName.Buffer,
                                  &OldName,
                                  NULL,
                                  NULL );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtsave.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtsave.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Perform an NtSaveKey call to dump part of the registry to a file.

    rtsave  <KeyPath> <FileName>

    Example:

        rtsave \registry\machine\user userfile.rd

Author:

    Bryan Willman (bryanwi)  22-Jan-92

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *[]);
void processargs();

UNICODE_STRING  KeyPath;
WCHAR           KeyPathBuffer[WORK_SIZE];

UNICODE_STRING  FileName;
WCHAR           FileNameBuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK  IoStatus;
    HANDLE  FileHandle;
    HANDLE  KeyHandle;
    BOOLEAN WasEnabled;

    //
    // Process args
    //

    KeyPath.MaximumLength = WORK_SIZE;
    KeyPath.Length = 0L;
    KeyPath.Buffer = &(KeyPathBuffer[0]);

    FileName.MaximumLength = WORK_SIZE;
    FileName.Length = 0L;
    FileName.Buffer = &(FileNameBuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open FileName
    //

    printf("rtsave: starting\n");
    printf("rtsave: saving hive rooted at\n\t'%ws'\nto file\n\t'%ws'\n",
            KeyPath.Buffer, FileName.Buffer);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;


    status = NtCreateFile(
                &FileHandle,
                GENERIC_WRITE | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatus,
                NULL,                                   // AllocationSize
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,                        // ShareAccess
                FILE_CREATE,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,                                   // EaBuffer
                0                                       // EaLength
                );

    if (!NT_SUCCESS(status)) {
        if (status == STATUS_OBJECT_NAME_COLLISION) {
            printf("rtsave: file '%ws' already exists!\n",
                    FileName.Buffer);
            exit(1);
        }
        printf("rtsave: file open failed status = %08lx\n", status);
        exit(1);
    }

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyPath,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &KeyHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtsave: key open failed status = %08lx\n", status);
        exit(1);
    }

    RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    status = NtSaveKey(KeyHandle, FileHandle);

    RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);

    if (!NT_SUCCESS(status)) {
        printf("rtsave: NtSaveKey failed status = %08lx\n", status);
        exit(1);
    }

    printf("rtsave: success\n");
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;
    UNICODE_STRING DosFileName;

    if ( (argc != 3) )
    {
        printf("Usage: %s <KeyName> <FileName>\nWhere <FileName> does NOT already exist\n",
                argv[0]);
        printf("Example: %s \\registry\\machine\\security d:\\backups\\security\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyPath,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &DosFileName,
        &temp,
        TRUE
        );

    RtlDosPathNameToNtPathName_U( DosFileName.Buffer,
                                  &FileName,
                                  NULL,
                                  NULL );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtsymlnk.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rtsymlnk.c

Abstract:

    NT level registry symbolic link test program

    Turns a key into a symbolic link.

    rtsymlnk <KeyPath> <SymbolicLink>

    Example:

        rtsymlnk \Registry\User\The_User\Foo \Registry\User\The_User\Bar

Author:

    John Vert (jvert) 29-Apr-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING  KeyName;
    UNICODE_STRING  LinkName;
    UNICODE_STRING  NullName;
    ANSI_STRING AnsiKeyName;
    ANSI_STRING AnsiLinkName;
    HANDLE KeyHandle;

    //
    // Process args
    //

    if (argc != 3) {
        printf("Usage: %s <KeyPath> <SymLink>\n",argv[0]);
        exit(1);
    }

    RtlInitAnsiString(&AnsiKeyName, argv[1]);
    Status = RtlAnsiStringToUnicodeString(&KeyName, &AnsiKeyName, TRUE);
    if (!NT_SUCCESS(Status)) {
        printf("RtlAnsiStringToUnicodeString failed %lx\n",Status);
        exit(1);
    }

    RtlInitAnsiString(&AnsiLinkName, argv[2]);
    Status = RtlAnsiStringToUnicodeString(&LinkName, &AnsiLinkName, TRUE);
    if (!NT_SUCCESS(Status)) {
        printf("RtlAnsiStringToUnicodeString failed %lx\n",Status);
        exit(1);
    }

    printf("rtsetsec: starting\n");

    //
    // Open node that we want to make a symbolic link.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    Status = NtCreateKey(&KeyHandle,
                         KEY_READ | KEY_WRITE,
                         &ObjectAttributes,
                         0,
                         NULL,
                         0,
                         NULL);
    if (!NT_SUCCESS(Status)) {
        printf("rtsymlnk: NtCreateKey failed: %08lx\n", Status);
        exit(1);
    }

    NullName.Length = NullName.MaximumLength = 0;
    NullName.Buffer = NULL;

    Status = NtSetValueKey(KeyHandle,
                           &NullName,
                           0,
                           REG_LINK,
                           LinkName.Buffer,
                           LinkName.Length);
    if (!NT_SUCCESS(Status)) {
        printf("rtsymlnk: NtSetValueKey failed: %08lx\n",Status);
        exit(1);
    }

    Status = NtClose(KeyHandle);
    if (!NT_SUCCESS(Status)) {
        printf("rtsymlnk: NtClose failed: %08lx\n", Status);
        exit(1);
    }

    printf("rtsymlnk: successful\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtunload.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtunload.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Perform an NtUnloadKey call to unlink a hive file from the registry.

    rtunload  <KeyPath>

    Example:

        rtunload \registry\user\JVert

Author:

    John Vert (jvert) 17-Apr-92

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

UNICODE_STRING  KeyPath;
WCHAR           KeyPathBuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES KeyAttributes;
    IO_STATUS_BLOCK  IoStatus;
    HANDLE  FileHandle;
    HANDLE  KeyHandle;
    BOOLEAN WasEnabled;

    //
    // Process args
    //

    KeyPath.MaximumLength = WORK_SIZE;
    KeyPath.Length = 0L;
    KeyPath.Buffer = &(KeyPathBuffer[0]);

    processargs(argc, argv);


    printf("rtunload: starting\n");

    RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    //
    // Set up KeyPath
    //

    InitializeObjectAttributes(
        &KeyAttributes,
        &KeyPath,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    status = NtUnloadKey(&KeyAttributes);

    RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);

    if (!NT_SUCCESS(status)) {
        printf("rtunload: key unload failed status = %08lx\n", status);
        exit(1);
    } else {
        printf("rtunload: success!\n");
    }

    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 2) )
    {
        printf("Usage: %s <KeyName>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyPath,
        &temp,
        TRUE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rttrecpy.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rttrecpy.c

Abstract:

    NT level registry api test program

    tree copy for the registry.

    rtdeltre <SourceKeyPath> <DestKeyPath>

    Will tree-copy the given registry subtree.

    Example:

        rttrecpy \REGISTRY\MACHINE\TEST\bigkey \registry\machine\test\bigcopy

Author:

    John Vert (jvert) 22-Oct-1992

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int argc, char *);
void processargs();

void
Copy(
    HANDLE  Source,
    HANDLE  Dest
    );

UNICODE_STRING  SourceName;
UNICODE_STRING  DestName;
BOOLEAN CopySecurity;

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE  SourceHandle;
    HANDLE  DestHandle;

    //
    // Process args
    //
    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rttrecpy: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &SourceName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    Status = NtOpenKey(
                &SourceHandle,
                KEY_READ,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(Status)) {
        printf("rttrecpy: NtOpenKey %wS failed %08lx\n", &SourceName, Status);
        exit(1);
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &DestName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtCreateKey(&DestHandle,
                         KEY_WRITE,
                         &ObjectAttributes,
                         0,
                         NULL,
                         0,
                         NULL);
    if (!NT_SUCCESS(Status)) {
        printf("rttrecpy: NtCreateKey %wS failed %08lx\n",DestName,Status);
        exit(1);
    }

    Copy(SourceHandle, DestHandle);
}


void
Copy(
    HANDLE  Source,
    HANDLE  Dest
    )
{
    NTSTATUS    Status;
    PKEY_BASIC_INFORMATION KeyInformation;
    PKEY_VALUE_FULL_INFORMATION KeyValue;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG   NamePos;
    ULONG   index;
    STRING  enumname;
    HANDLE  SourceChild;
    HANDLE  DestChild;
    ULONG   ResultLength;
    static  char buffer[WORK_SIZE];
    static  char SecurityBuffer[WORK_SIZE];
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    UNICODE_STRING ValueName;
    UNICODE_STRING KeyName;


    //
    // Enumerate source node's values and copy them to target node.
    //
    KeyValue = (PKEY_VALUE_FULL_INFORMATION)buffer;
    for (index = 0; TRUE; index++) {
        Status = NtEnumerateValueKey(Source,
                                     index,
                                     KeyValueFullInformation,
                                     buffer,
                                     WORK_SIZE,
                                     &ResultLength);

        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_NO_MORE_ENTRIES) {

                //
                // done with the values
                //
                break;
            } else {
                printf("rttrecpy: NtEnumerateValueKey failed %08lx\n",Status);
                break;
            }
        }

        ValueName.Buffer = KeyValue->Name;
        ValueName.Length = KeyValue->NameLength;

        Status = NtSetValueKey(Dest,
                               &ValueName,
                               KeyValue->TitleIndex,
                               KeyValue->Type,
                               buffer+KeyValue->DataOffset,
                               KeyValue->DataLength);
        if (!NT_SUCCESS(Status)) {
            printf("rttrecpy: NtSetValueKey failed to set value %wS\n",&ValueName);
        }

    }

    //
    // Enumerate node's children and apply ourselves to each one
    //

    KeyInformation = (PKEY_BASIC_INFORMATION)buffer;
    if (CopySecurity) {
        SecurityDescriptor = SecurityBuffer;
    } else {
        SecurityDescriptor = NULL;
    }
    for (index = 0; TRUE; index++) {

        Status = NtEnumerateKey(Source,
                                index,
                                KeyBasicInformation,
                                KeyInformation,
                                WORK_SIZE,
                                &ResultLength);

        if (Status == STATUS_NO_MORE_ENTRIES) {

            break;

        } else if (!NT_SUCCESS(Status)) {
            printf("rttrecpy: NtEnumerateKey failed Status = %08lx\n", Status);
            exit(1);
        }

        KeyName.Buffer = KeyInformation->Name;
        KeyName.Length = KeyInformation->NameLength;

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            Source,
            NULL
            );

        Status = NtOpenKey(
                    &SourceChild,
                    KEY_READ,
                    &ObjectAttributes
                    );
        if (!NT_SUCCESS(Status)) {
            printf("rttrecpy: NtOpenKey %wS failed: %08lx\n", Status);
            exit(1);
        }

        if (CopySecurity) {
            Status = NtQuerySecurityObject(SourceChild,
                                           DACL_SECURITY_INFORMATION,
                                           SecurityDescriptor,
                                           WORK_SIZE,
                                           &ResultLength);
            if (!NT_SUCCESS(Status)) {
                printf("rttrecpy: NtQuerySecurityObject failed %08lx\n",Status);
            }
        }

        InitializeObjectAttributes(&ObjectAttributes,
                                   &KeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   Dest,
                                   SecurityDescriptor);
        Status = NtCreateKey(&DestChild,
                             KEY_READ | KEY_WRITE,
                             &ObjectAttributes,
                             0,
                             NULL,
                             0,
                             NULL);
        if (!NT_SUCCESS(Status)) {
            printf("rttrecpy: NtCreateKey %wS failed %08lx\n",Status);
            exit(1);
        }

        Copy(SourceChild, DestChild);
        NtClose(SourceChild);
        NtClose(DestChild);

    }

    return;
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;
    char **p;

    if ( (argc > 4) || (argc < 3) )
    {
        printf("Usage: %s [-s] <SourceKey> <DestKey>\n",
                argv[0]);
        exit(1);
    }

    p=argv+1;
    if (_stricmp(*p,"-s")==0) {
        CopySecurity = TRUE;
        ++p;
    } else {
        CopySecurity = FALSE;
    }

    RtlInitAnsiString(
        &temp,
        *p
        );

    ++p;

    RtlAnsiStringToUnicodeString(
        &SourceName,
        &temp,
        TRUE
        );

    RtlInitAnsiString(&temp,
                      *p);

    RtlAnsiStringToUnicodeString(&DestName,
                                 &temp,
                                 TRUE);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtsetopt.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtsetopt.c

Abstract:

    NT level registry api test program, basic non-error paths.

    This program attempts to force all cases through the various
    optimizations in the NtSetValueKey code.

    This is a whitebox test intended force system errors (crashes)
    when run.  Returned values are not very interesting.

    rtsetopt <root of test tree>

    Example:

        rtsetopt \registry\machine\software\test

    Named key must already exist.


Author:

    Bryan Willman (bryanwi)  17-Nov-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char **);
void processargs();

ULONG           failure = 0;

UNICODE_STRING  KeyPath;

UCHAR           TestData[] =
"This is some test data, it is short. But long enough for most of our tests.";

UNICODE_STRING  WorkName;
WCHAR           workbuffer[2 * CM_MAX_STASH];

LONG    testvector0[] = { 0, 3, 4, 5, -1 };

LONG    testvector1[] = { 0, 0, 3, 0, 4, 0, 5, 0, 3, 3, 4, 3, 5, 3,
                          4, 4, 5, 4, 5, 5, -1 };

LONG    testvector2[] = { 8, 6, 8, 32,
                          PAGE_SIZE, PAGE_SIZE-1, PAGE_SIZE, PAGE_SIZE+1,
                          -1 };

LONG    testvector3[] = { CM_MAX_STASH, CM_MAX_STASH-1, CM_MAX_STASH,
                          CM_MAX_STASH+1, -1 };

PLONG   supervector[] = { &(testvector1[0]), &(testvector2[1]),
                          &(testvector3[0]), NULL };


void
__cdecl main(
    int argc,
    char **argv
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;
    UNICODE_STRING  ValueName;
    ULONG   ResultLength;
    PKEY_VALUE_FULL_INFORMATION pvaluefull;
    PKEY_VALUE_PARTIAL_INFORMATION pvaluepart;
    ULONG   i;
    ULONG  index;
    LONG    testsize;
    PUCHAR  p;
    PLONG   activevector;


    for (i = 0; i < 2 * CM_MAX_STASH; i++) {
        workbuffer[i] = 'e';
    }

    //
    // Process args
    //
    processargs(argc, argv);


    //
    // Open the specified keypath, punt on failure
    //
    printf("rtsetopt: starting\n");

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    RtlCopyString((PSTRING)&WorkName, (PSTRING)&KeyPath);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("line_%4d: abort %08lx\n", __LINE__,  status);
        failure++;
        goto punt;
    }


    //
    // Perform new value entry tests, with an empty list.
    //
    RtlInitUnicodeString(
        &ValueName,
        L"NewValueTest1"
        );

    for (index = 0; testvector0[index] != -1; index++) {

        testsize = testvector0[index];

        printf("AT line_%4d: %d\n", __LINE__,  testsize);

        status = NtSetValueKey(
                    BaseHandle,
                    &ValueName,
                    1,
                    REG_BINARY,
                    &(TestData[0]),
                    testsize
                    );
        if (!NT_SUCCESS(status)) {
            printf("line_%4d: %08lx\n", __LINE__,  status);
            failure++;
        }

        printf("AT line_%4d: %d\n", __LINE__,  testsize);
        for (i = 0; i < WORK_SIZE; i++) workbuffer[i] = '?';
        status = NtQueryValueKey(
                    BaseHandle,
                    &ValueName,
                    KeyValueFullInformation,
                    &(workbuffer[0]),
                    WORK_SIZE,
                    &ResultLength
                    );
        if (!NT_SUCCESS(status)) {
            printf("line_%4d: %08lx\n", __LINE__,  status);
            failure++;
        }

        pvaluefull = (PKEY_VALUE_FULL_INFORMATION)(&(workbuffer[0]));
        if (pvaluefull->DataLength != testsize) {
            printf("line_%4d: %08lx\n", __LINE__,  9999);
            failure++;
        }


        if (testsize > 0) {
            p = (PUCHAR)pvaluefull;
            p = p+pvaluefull->DataOffset;
            if (p[2] != 'i') {
                printf("line_%4d: %08lx\n", __LINE__,  9999);
                failure++;
            }
        }

        printf("AT line_%4d: %d\n", __LINE__,  testsize);
        if (testvector0[index+1] != -1) {
            status = NtDeleteValueKey(
                        BaseHandle,
                        &ValueName
                        );
            if (!NT_SUCCESS(status)) {
                printf("line_%4d: abort %08lx\n", __LINE__,  status);
                failure++;
                goto punt;
            }
        }
    }

    //
    // Perform new value entry tests, with a non empty list.
    //
    RtlInitUnicodeString(
        &ValueName,
        L"NewValueTest2"
        );

    for (index = 0; testvector0[index] != -1; index++) {

        testsize = testvector0[index];

        printf("AT line_%4d: %d\n", __LINE__,  testsize);
        status = NtSetValueKey(
                    BaseHandle,
                    &ValueName,
                    1,
                    REG_BINARY,
                    &(TestData[0]),
                    testsize
                    );
        if (!NT_SUCCESS(status)) {
            printf("line_%4d: %08lx\n", __LINE__,  status);
            failure++;
        }

        printf("AT line_%4d: %d\n", __LINE__,  testsize);
        for (i = 0; i < WORK_SIZE; i++) workbuffer[i] = '?';
        status = NtQueryValueKey(
                    BaseHandle,
                    &ValueName,
                    KeyValuePartialInformation,
                    &(workbuffer[0]),
                    WORK_SIZE,
                    &ResultLength
                    );
        if (!NT_SUCCESS(status)) {
            printf("line_%4d: %08lx\n", __LINE__,  status);
            failure++;
        }

        pvaluepart = (PKEY_VALUE_PARTIAL_INFORMATION)(&(workbuffer[0]));
        if (pvaluepart->DataLength != testsize) {
            printf("line_%4d: %08lx\n", __LINE__,  9999);
            failure++;
        }


        if (testsize > 0) {
            if (pvaluepart->Data[2] != 'i') {
                printf("line_%4d: %08lx\n", __LINE__,  9999);
                failure++;
            }
        }

        printf("AT line_%4d: %d\n", __LINE__,  testsize);
        status = NtDeleteValueKey(
                    BaseHandle,
                    &ValueName
                    );
        if (!NT_SUCCESS(status)) {
            printf("line_%4d: abort %08lx\n", __LINE__,  status);
            failure++;
            goto punt;
        }
   }


    //
    // Perform existing value entry tests, with all the relevent
    // size transitions.
    //
    RtlInitUnicodeString(
        &ValueName,
        L"NewValueTest3"
        );

    for (i = 0; i < 2 * CM_MAX_STASH; i++) {
        workbuffer[i] = 'e';
    }

    for (i = 0; supervector[i] != NULL; i++) {

        activevector = supervector[i];

        for (index = 0; activevector[index] != -1; index++) {

            testsize = activevector[index];

            printf("AT line_%4d: %d\n", __LINE__,  testsize);
            status = NtSetValueKey(
                        BaseHandle,
                        &ValueName,
                        1,
                        REG_BINARY,
                        &(workbuffer[0]),
                        testsize
                        );
            if (!NT_SUCCESS(status)) {
                printf("line_%4d: %08lx\n", __LINE__,  status);
                failure++;
            }

            printf("AT line_%4d: %d\n", __LINE__,  testsize);
            status = NtQueryValueKey(
                        BaseHandle,
                        &ValueName,
                        KeyValuePartialInformation,
                        &(workbuffer[0]),
                        2 * CM_MAX_STASH,
                        &ResultLength
                        );
            if (!NT_SUCCESS(status)) {
                printf("line_%4d: %08lx\n", __LINE__,  status);
                failure++;
            }
        }
    }


punt:
    printf("rtsetopt: %d failures\n", failure);
    exit(failure);
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if (argc != 2)
    {
        printf("Usage: %s <KeyPath>\n", argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyPath,
        &temp,
        TRUE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtsetsec.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rtsetsec.c

Abstract:

    NT level registry security test program

    Assigns a world read-only security descriptor to an existing registry
    key object.

    rtsetsec <KeyPath>

    Example:

        rtsetsec \REGISTRY\MACHINE\TEST\read_only

Author:

    John Vert (jvert) 28-Jan-92

Revision History:

    Richard Ward (richardw) 14 April 92    Changed ACE_HEADER

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

PSID
GetMySid(
    VOID
    );

PSECURITY_DESCRIPTOR
GenerateDescriptor(
    VOID
    );

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING  KeyName;
    ANSI_STRING AnsiKeyName;
    HANDLE KeyHandle;
    PSECURITY_DESCRIPTOR NewSecurityDescriptor;

    //
    // Process args
    //

    if (argc != 2) {
        printf("Usage: %s <KeyPath>\n",argv[0]);
        exit(1);
    }

    RtlInitAnsiString(&AnsiKeyName, argv[1]);
    Status = RtlAnsiStringToUnicodeString(&KeyName, &AnsiKeyName, TRUE);
    if (!NT_SUCCESS(Status)) {
        printf("RtlAnsiStringToUnicodeString failed %lx\n",Status);
        exit(1);
    }

    printf("rtsetsec: starting\n");

    //
    // Open node that we want to change the security descriptor for.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    Status = NtOpenKey(
                &KeyHandle,
                WRITE_DAC,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: NtOpenKey failed: %08lx\n", Status);
        exit(1);
    }

    NewSecurityDescriptor = GenerateDescriptor();

    Status = NtSetSecurityObject( KeyHandle,
                                  DACL_SECURITY_INFORMATION,
                                  NewSecurityDescriptor);
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: NtSetSecurity failed: %08lx\n",Status);
        exit(1);
    }

    Status = NtClose(KeyHandle);
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: NtClose failed: %08lx\n", Status);
        exit(1);
    }

    printf("rtsetsec: successful\n");

}

PSECURITY_DESCRIPTOR
GenerateDescriptor(
    VOID
    )
{
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PACL Acl;
    PSID WorldSid, CreatorSid;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    ULONG OwnerAceLength, WorldAceLength;
    ULONG AclLength;
    NTSTATUS Status;
    PACCESS_ALLOWED_ACE OwnerAce;
    PACCESS_ALLOWED_ACE WorldAce;

    WorldSid = malloc(RtlLengthRequiredSid(1));
    if (WorldSid == NULL) {
        printf("rtsetsec: GenerateDescriptor() couldn't malloc WorldSID\n");
        exit(1);
    }
    RtlInitializeSid(WorldSid, &WorldAuthority, 1);
    *(RtlSubAuthoritySid(WorldSid, 0)) = SECURITY_WORLD_RID;
    if (!RtlValidSid(WorldSid)) {
        printf("rtsetsec: GenerateDescriptor() created invalid World SID\n");
        exit(1);
    }

    CreatorSid = GetMySid();

    //
    // Since the ACCESS_DENIED_ACE already contains a ULONG for the
    // SID, we subtract this back out when calculating the size of the ACE
    //

    WorldAceLength = SeLengthSid(WorldSid) -
                     sizeof(ULONG)     +
                     sizeof(ACCESS_ALLOWED_ACE) ;
    WorldAce = malloc(WorldAceLength);
    if (WorldAce == NULL) {
        printf("rtsetsec: GenerateDescriptor() couldn't malloc WorldAce\n");
        exit(1);
    }

    OwnerAceLength = SeLengthSid(CreatorSid) -
                     sizeof(ULONG)     +
                     sizeof(ACCESS_ALLOWED_ACE);

    OwnerAce = malloc( OwnerAceLength );
    if (OwnerAce == NULL) {
        printf("rtsetsec: GenerateDescriptor() couldn't malloc OwnerAce\n");
        exit(1);
    }

    AclLength = OwnerAceLength + WorldAceLength + sizeof(ACL);
    Acl = malloc(AclLength);
    if (Acl == NULL) {
        printf("rtsetsec: GenerateDescriptor() couldn't malloc ACL\n");
        exit(1);
    }

    Status = RtlCreateAcl(Acl, AclLength, ACL_REVISION);
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: RtlCreateAcl failed status %08lx\n", Status);
        exit(1);
    }

    //
    // Fill in ACE fields
    //

    WorldAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    WorldAce->Header.AceSize = (USHORT)WorldAceLength;
    WorldAce->Header.AceFlags = 0;  // clear audit and inherit flags
    WorldAce->Mask = KEY_READ;
    Status = RtlCopySid( SeLengthSid(WorldSid),
                         &WorldAce->SidStart,
                         WorldSid );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: RtlCopySid failed status %08lx\n", Status);
        exit(1);
    }

    OwnerAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    OwnerAce->Header.AceSize = (USHORT)OwnerAceLength;
    OwnerAce->Header.AceFlags = 0;  // clear audit and inherit flags
    OwnerAce->Mask = KEY_ALL_ACCESS;
    Status = RtlCopySid( SeLengthSid(CreatorSid),
                         &OwnerAce->SidStart,
                         CreatorSid );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: RtlCopySid failed status %08lx\n", Status);
        exit(1);
    }

    free(WorldSid);

    //
    // Now add the ACE to the beginning of the ACL.
    //

    Status = RtlAddAce( Acl,
                        ACL_REVISION,
                        0,
                        WorldAce,
                        WorldAceLength );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: RtlAddAce (world ace) failed status %08lx\n", Status);
        exit(1);
    }
    Status = RtlAddAce( Acl,
                        ACL_REVISION,
                        0,
                        OwnerAce,
                        OwnerAceLength );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: RtlAddAce (owner ace) failed status %08lx\n", Status);
        exit(1);
    }

    free(OwnerAce);
    free(WorldAce);

    //
    // Allocate and initialize the Security Descriptor
    //

    SecurityDescriptor = malloc(sizeof(SECURITY_DESCRIPTOR));
    Status = RtlCreateSecurityDescriptor( SecurityDescriptor,
                                          SECURITY_DESCRIPTOR_REVISION );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: RtlCreateSecurityDescriptor failed status %08lx\n",Status);
        exit(1);
    }

    Status = RtlSetDaclSecurityDescriptor( SecurityDescriptor,
                                           TRUE,
                                           Acl,
                                           FALSE );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: RtlSetDaclSecurityDescriptor failed status %08lx\n",Status);
        exit(1);
    }

    //
    // FINALLY we are finished!
    //

    return(SecurityDescriptor);

}

PSID
GetMySid(
    VOID
    )
{
    NTSTATUS Status;
    HANDLE Token;
    PTOKEN_OWNER Owner;
    ULONG Length;

    Status = NtOpenProcessToken( NtCurrentProcess(),
                                 TOKEN_QUERY,
                                 &Token );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: GetMySid() NtOpenProcessToken failed status %08lx\n",Status);
        exit(1);
    }

    Status = NtQueryInformationToken( Token,
                                      TokenOwner,
                                      Owner,
                                      0,
                                      &Length );
    if (Status != STATUS_BUFFER_TOO_SMALL) {
        printf("rtsetsec: GetMySid() NtQueryInformationToken failed status %08lx\n",Status);
        exit(1);
    }

    Owner = malloc(Length);
    if (Owner==NULL) {
        printf("rtsetsec: GetMySid() Couldn't malloc TOKEN_OWNER buffer\n");
        exit(1);
    }
    Status = NtQueryInformationToken( Token,
                                      TokenOwner,
                                      Owner,
                                      Length,
                                      &Length );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: GetMySid() NtQueryInformationToken failed status %08lx\n",Status);
        exit(1);
    }

    NtClose(Token);

    return(Owner->Owner);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\symtest.c ===
#include "ntos.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void
main(
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Attr1;
    OBJECT_ATTRIBUTES Attr2;
    UNICODE_STRING  Name1;
    UNICODE_STRING  Name2;
    HANDLE Handle1;
    HANDLE Handle2;
    IO_STATUS_BLOCK IoStatusBlock;


    RtlInitUnicodeString(&Name1, L"\\DosDevices");
    RtlInitUnicodeString(&Name2, L"C:\\Nt");
    InitializeObjectAttributes(&Attr1,
                               &Name1,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenDirectoryObject(&Handle1,
                                   DIRECTORY_QUERY,
                                   &Attr1);
    if (!NT_SUCCESS(Status)) {
        printf("NtOpenDirectoryObject failed %08lx\n",Status);
        exit(1);
    }

    InitializeObjectAttributes(&Attr2,
                               &Name2,
                               OBJ_CASE_INSENSITIVE,
                               Handle1,
                               NULL);
    Status = NtOpenFile(&Handle2,
                        FILE_LIST_DIRECTORY,
                        &Attr2,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0);
    if (!NT_SUCCESS(Status)) {
        printf("NtOpenFile failed %08lx\n",Status);
        exit(1);
    }

    printf("success\n");


}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtqval.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtqval.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Do a query on a value.

    rtqval <KeyPath> <valuename> [infotypenumber] [bufferlength]

    Example:

        rtqval \REGISTRY\MACHINE\TEST\bigkey value1 1 100

Author:

    Bryan Willman (bryanwi)  9-Apr-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];



UNICODE_STRING  WorkName2;
WCHAR           workbuffer2[WORK_SIZE];


UCHAR       Buffer[1024*64];

ULONG       InfoType = KeyValueFullInformation;
ULONG       BufferSize = -1;

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;
    ULONG   Sizes[] = { sizeof(KEY_VALUE_BASIC_INFORMATION),
                        sizeof(KEY_VALUE_FULL_INFORMATION) };
    ULONG       ResultLength;
    PKEY_VALUE_BASIC_INFORMATION pbasic;
    PKEY_VALUE_FULL_INFORMATION  pfull;
    PKEY_VALUE_PARTIAL_INFORMATION  ppartial;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    WorkName2.MaximumLength = WORK_SIZE;
    WorkName2.Length = 0L;
    WorkName2.Buffer = &(workbuffer2[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtqkey: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                KEY_QUERY_VALUE,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtqkey: t0: %08lx\n", status);
        exit(1);
    }

    //
    // make test call
    //
    RtlFillMemory((PVOID)&(Buffer[0]), 1024*64, 0xaa);

    if (BufferSize == -1) {
        BufferSize = Sizes[InfoType];
    }

    status = NtQueryValueKey(
                BaseHandle,
                &WorkName2,
                InfoType,
                (PVOID)&(Buffer[0]),
                BufferSize,
                &ResultLength
                );

    printf("status = %08lx  ResultLength = %08lx\n", status, ResultLength);
    switch (InfoType) {
    case KeyValueBasicInformation:
        pbasic = (PKEY_VALUE_BASIC_INFORMATION)Buffer;
        printf("TitleIndex: %08lx\n", pbasic->TitleIndex);
        printf("      Type: %08lx\n", pbasic->Type);
        printf("NameLength: %08lx\n", pbasic->NameLength);
        printf("      Name: '%.*ws'\n", pbasic->NameLength/2, &(pbasic->Name));
        break;

    case KeyValueFullInformation:
        pfull = (PKEY_VALUE_FULL_INFORMATION)Buffer;
        printf("TitleIndex: %08lx\n", pfull->TitleIndex);
        printf("      Type: %08lx\n", pfull->Type);
        printf("DataOffset: %08lx\n", pfull->DataOffset);
        printf("DataLength: %08lx\n", pfull->DataLength);
        printf("NameLength: %08lx\n", pfull->NameLength);
        printf("      Name: '%.*ws'\n", pfull->NameLength/2, &(pfull->Name));
        printf("      Data: '%.*ws'\n", pfull->DataLength/2,
                    ((PUCHAR)pfull + pfull->DataOffset) );
        break;

    case KeyValuePartialInformation:
        ppartial = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
        printf("TitleIndex: %08lx\n", ppartial->TitleIndex);
        printf("      Type: %08lx\n", ppartial->Type);
        printf("DataLength: %08lx\n", ppartial->DataLength);
        printf("      Data: '%.*ws'\n", ppartial->DataLength/2,
                    ((PUCHAR)&(ppartial->Data)));
        break;
    }

    NtClose(BaseHandle);
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc < 2) )
    {
        printf("Usage: %s <KeyPath> [infotype] [bufferlen]\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName2,
        &temp,
        TRUE
        );

    if (argc > 3) {
        InfoType = atoi(argv[3]);
    }

    if (argc > 4) {
        BufferSize = atoi(argv[4]);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\test\rtvbatcr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtvbatcr.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Do a batch create, VOLATILE.  (Same as rtbatcr, but creates keys volatile.)

    rtvbatcr    <KeyPath> <KeyName> <basename> <#children> <#values>

    Will attempt to create key <KeyName> as child of <KeyPath>  If
    <#children> and <#values> are 0, this is all it does.  If <KeyName>
    already exists, it will simply be used.

    Will create <#children> child cells, with names of the form
    <base>0  <base>1, etc.  Will create <#values> value entries,
    with similar names, for each created child key.  Data of
    values will be a constant string including their name.

    Example:

        rtvbatcr    \REGISTRY\MACHINE\TEST bigkey runa_ 100 100
        rtvbatcr    \REGISTRY\MACHINE\TEST\bigkey runa_1 runb_ 100 100

        Will create bigkey, give it 100 values calls runa_1 through
        runa_100, create 100 subkeys called runa_1 through runa_100
        for each of those children.

        It will then open bigkey\runa_1, and create 100 subkeys and
        100 values each for that.

Author:

    Bryan Willman (bryanwi)  10-Dec-91

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

ULONG           failure = 0;

UNICODE_STRING  KeyPath;
UNICODE_STRING  KeyName;
ULONG           NumberChildren;
ULONG           NumberValues;
UCHAR           BaseName[WORK_SIZE];
UCHAR           formatbuffer[WORK_SIZE];
STRING          format;

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;
    HANDLE          WorkHandle;
    ULONG           Disposition;
    UNICODE_STRING  ClassName;
    ULONG           i;
    ULONG           j;
    PUCHAR  p;

    //
    // Process args
    //

    processargs(argc, argv);


    //
    // Set up and create/open KeyPath|KeyName
    //

    printf("rtvbatcr: starting\n");

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    RtlCopyString((PSTRING)&WorkName, (PSTRING)&KeyPath);

    p = WorkName.Buffer;
    p += WorkName.Length;
    *p = '\\';
    p++;
    *p = '\0';
    WorkName.Length += 2;

    RtlAppendStringToString((PSTRING)&WorkName, (PSTRING)&KeyName);

    RtlInitUnicodeString(
        &ClassName,
        L"Test Class Name"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtCreateKey(
                &BaseHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes,
                0,
                &ClassName,
                REG_OPTION_VOLATILE,
                &Disposition
                );
    if (!NT_SUCCESS(status)) {
        printf("rtvbatcr: t0: %08lx\n", status);
        failure++;
        goto punt;
    }


    //
    // Create NumberChildren subkeys
    //

    for (i = 0; i < NumberChildren; i++) {

        sprintf(formatbuffer, "%s%d", BaseName, i);
        RtlInitString(&format, formatbuffer);
        RtlAnsiStringToUnicodeString(&WorkName, &format, FALSE);


        InitializeObjectAttributes(
            &ObjectAttributes,
            &WorkName,
            0,
            BaseHandle,
            NULL
            );
        ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

        status = NtCreateKey(
                    &WorkHandle,
                    MAXIMUM_ALLOWED,
                    &ObjectAttributes,
                    0,
                    &ClassName,
                    REG_OPTION_VOLATILE,
                    &Disposition
                    );
        if (!NT_SUCCESS(status)) {
            printf("rtvbatcr: t1: status = %08lx i = %d\n", status, i);
            failure++;
        }

        //
        // Create NumberValues value entries for each (current) key
        //

        for (j = 0; j < NumberValues; j++) {

            sprintf(formatbuffer, "%s%d", BaseName, j);
            RtlInitString(&format, formatbuffer);
            RtlAnsiStringToUnicodeString(&WorkName, &format, FALSE);

            sprintf(
                formatbuffer, "This is a rtvbatcr value for %s%d", BaseName, j
                );

            status = NtSetValueKey(
                        WorkHandle,
                        &WorkName,
                        j,
                        j,
                        formatbuffer,
                        strlen(formatbuffer)+1
                        );
            if (!NT_SUCCESS(status)) {
                printf("rtvbatcr: t2: status = %08lx j = %d\n", status, j);
                failure++;
            }
        }
        NtClose(WorkHandle);
    }

punt:
    printf("rtvbatcr: %d failures\n", failure);
    exit(failure);
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 3) && (argc != 6) )
    {
        printf("Usage: %s <KeyPath> <KeyName> [<basename> <#children> <#values>]\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyPath,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &KeyName,
        &temp,
        TRUE
        );

    if (argc < 6) {

        NumberChildren = 0;
        NumberValues = 0;

    } else {

        strcpy(BaseName, argv[3]);
        NumberChildren = atoi(argv[4]);
        NumberValues = atoi(argv[5]);

    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\utils\hivehdr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hivehdr.c

Abstract:

    Dump the header of a hive primary, alternate, or log file.

    hivehdr filename filename filename ...

Author:

    Bryan Willman (bryanwi)  6-april-92

Revision History:

--*/


#define _ARCCODES_

#include "regutil.h"
#include "edithive.h"

void
DoDump(
    PUCHAR  Filename
    );

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    int i;

    if (argc == 1) {
        fprintf(stderr, "Usage: hivehdr filename filename...\n", argv[0]);
        exit(1);
    }

    for (i = 1; i < argc; i++) {
        DoDump(argv[i]);
    }

    exit(0);
}

void
DoDump(
    PUCHAR  Filename
    )
{
    HANDLE  infile;
    static char buffer[HSECTOR_SIZE];
    PHBASE_BLOCK bbp;
    char   *validstring[] = { "BAD", "OK" };
    int     valid;
    char   *typename[] = { "primary", "alternate", "log", "external", "unknown" };
    int     typeselect;
    int     readcount;
    unsigned long checksum;
    unsigned long i;

    infile = (HANDLE)CreateFile(
            Filename,                           // file name
            GENERIC_READ,                       // desired access
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share mode
            NULL,                               // security attributes
            OPEN_EXISTING,                      // creation disposition
            FILE_FLAG_SEQUENTIAL_SCAN,          // flags and attributes
            NULL                                // template file
    );
    if (infile == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "hivehdr: Could not open '%s'\n", Filename);
        return;
    }

    if (!ReadFile(infile, buffer, HSECTOR_SIZE, &readcount, NULL)) {
        fprintf(
            stderr, "hivehdr: '%s' - cannot read full base block\n", Filename);
        return;
    }
    if (readcount != HSECTOR_SIZE) {
        fprintf(
            stderr, "hivehdr: '%s' - cannot read full base block\n", Filename);
        return;
    }

    bbp = (PHBASE_BLOCK)&(buffer[0]);

    if ((bbp->Major != 1) || (bbp->Minor != 1)) {
        printf("WARNING: Hive file is newer than hivehdr, or is invalid\n");
    }

    printf("         File: '%s'\n", Filename);
    printf("    BaseBlock:\n");

    valid = (bbp->Signature == HBASE_BLOCK_SIGNATURE);
    printf("    Signature: %08lx  '%4.4s'\t\t%s\n",
            bbp->Signature, (PUCHAR)&(bbp->Signature), validstring[valid]);

    valid = (bbp->Sequence1 == bbp->Sequence2);
    printf(" Sequence1//2: %08lx//%08lx\t%s\n",
            bbp->Sequence1, bbp->Sequence2, validstring[valid]);

    printf("    TimeStamp: %08lx:%08lx\n",
            bbp->TimeStamp.HighPart, bbp->TimeStamp.LowPart,
            (PUCHAR)&(bbp->Signature), validstring[valid]);

    valid = (bbp->Major == HSYS_MAJOR);
    printf("Major Version: %08lx\t\t\t%s\n",
            bbp->Major, validstring[valid]);

    valid = (bbp->Minor == HSYS_MINOR);
    printf("Minor Version: %08lx\t\t\t%s\n",
            bbp->Minor, validstring[valid]);

    valid = ( (bbp->Type == HFILE_TYPE_PRIMARY) ||
              (bbp->Type == HFILE_TYPE_ALTERNATE) ||
              (bbp->Type == HFILE_TYPE_LOG) );
    if (valid) {
        typeselect = bbp->Type;
    } else {
        typeselect = HFILE_TYPE_MAX;
    }

    printf("         Type: %08lx %s\t\t%s\n",
            bbp->Type, typename[typeselect], validstring[valid]);

    valid = (bbp->Format == HBASE_FORMAT_MEMORY);
    printf("       Format: %08lx\t\t\t%s\n",
            bbp->Format, validstring[valid]);

    printf("     RootCell: %08lx\n", bbp->RootCell);

    printf("       Length: %08lx\n", bbp->Length);

    printf("      Cluster: %08lx\n", bbp->Cluster);

    checksum = HvpHeaderCheckSum(bbp);
    valid = (checksum == bbp->CheckSum);
    if (checksum == bbp->CheckSum) {
        printf("     CheckSum: %08lx\t\t\t%s\n",
                bbp->CheckSum, validstring[TRUE]);
    } else {
        printf("     CheckSum: %08lx\t\t\t%s\tCorrect: %08lx\n",
                bbp->CheckSum, validstring[FALSE], checksum);
    }

    //
    // print last part of file name, aid to identification
    //
    printf("Hive/FileName: ");

    for (i = 0; i < HBASE_NAME_ALLOC;i+=sizeof(WCHAR)) {
        printf("%wc", bbp->FileName[i]);
    }


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\utils\edithive.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    edithive.c

Abstract:

    Provides functionality for dumping and editing registry hive files from
    user-mode.

Author:

    John Vert (jvert) 26-Mar-1992

Revision History:

--*/
#include "edithive.h"
#include "nturtl.h"

extern GENERIC_MAPPING CmpKeyMapping;
extern LIST_ENTRY CmpHiveListHead;            // List of CMHIVEs

#define SECURITY_CELL_LENGTH(pDescriptor) \
    FIELD_OFFSET(CM_KEY_SECURITY,Descriptor) + \
    RtlLengthSecurityDescriptor(pDescriptor)


NTSTATUS
EhpAttachSecurity(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell
    );

PVOID
EhpAllocate(
    ULONG   Size
    );

VOID
EhpFree(
    PVOID   MemoryBlock
    );

BOOLEAN
EhpFileRead (
    HANDLE      FileHandle,
    PULONG      FileOffset,
    PVOID       DataBuffer,
    ULONG       DataLength
    );

BOOLEAN
EhpFileWrite(
    HANDLE      FileHandle,
    PULONG      FileOffset,
    PVOID       DataBuffer,
    ULONG       DataLength
    );

BOOLEAN
EhpFileFlush (
    HANDLE      FileHandle
    );

VOID
CmpGetObjectSecurity(
    IN HCELL_INDEX Cell,
    IN PHHIVE Hive,
    OUT PCM_KEY_SECURITY *Security,
    OUT PHCELL_INDEX SecurityCell OPTIONAL
    )

/*++

Routine Description:

    This routine maps in the security cell of a registry object.

Arguments:

    Cell - Supplies the cell index of the object.

    Hive - Supplies the hive the object's cell is in.

    Security - Returns a pointer to the security cell of the object.

    SecurityCell - Returns the index of the security cell

Return Value:

    NONE.

--*/

{
    HCELL_INDEX CellIndex;
    PCM_KEY_NODE Node;

    //
    // Map the node we need to get the security descriptor for
    //
    Node = (PCM_KEY_NODE) HvGetCell(Hive, Cell);

    CellIndex = Node->u1.s1.Security;

    //
    // Map in the security descriptor cell
    //
    *Security = (PCM_KEY_SECURITY) HvGetCell(Hive, CellIndex);

    if (ARGUMENT_PRESENT(SecurityCell)) {
        *SecurityCell = CellIndex;
    }

    return;
}


VOID
EhCloseHive(
    IN HANDLE HiveHandle
    )

/*++

Routine Description:

    Closes a hive, including writing all the data out to disk and freeing
    the relevant structures.

Arguments:

    HiveHandle - Supplies a handle to the hive control structure

Return Value:

    None.

--*/

{
    HvSyncHive((PHHIVE)HiveHandle);
    NtClose(((PCMHIVE)HiveHandle)->FileHandles[HFILE_TYPE_PRIMARY]);
    NtClose(((PCMHIVE)HiveHandle)->FileHandles[HFILE_TYPE_ALTERNATE]);
    NtClose(((PCMHIVE)HiveHandle)->FileHandles[HFILE_TYPE_LOG]);
    CmpFree((PCMHIVE)HiveHandle, sizeof(CMHIVE));

}


HANDLE
EhOpenHive(
    IN PUNICODE_STRING FileName,
    OUT PHANDLE RootHandle,
    IN PUNICODE_STRING RootName,
    IN ULONG HiveType
    )

/*++

Routine Description:

    Opens an existing hive.  If the filename does not exist it will be
    created.

    WARNING:    Allocate FileName large enough to acomodate .log or
                .alt extension.

Arguments:

    FileName - Supplies the NULL-terminated filename to open as a hive.

    HiveType - TYPE_SIMPLE = no log or alternate
               TYPE_LOG = log
               TYPE_ALT = alternate

Return Value:

    != NULL - Handle to the opened hive.
    == NULL - Indicates file could not be opened.

--*/

{
    NTSTATUS Status;
    HANDLE File;
    BOOLEAN Allocate;
    PCMHIVE Hive;
    IO_STATUS_BLOCK IoStatus;
    ULONG CreateDisposition;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PCM_KEY_NODE RootNode;
    HANDLE Handle;
    HANDLE  Primary;
    HANDLE  Log;
    HANDLE  Alt;
    ULONG   FileType;
    ULONG   Disposition;
    ULONG   SecondaryDisposition;
    ULONG   Operation;

    Alt = NULL;
    Log = NULL;
    InitializeListHead(&CmpHiveListHead);

    switch (HiveType) {
    case TYPE_SIMPLE:
        Status = CmpOpenHiveFiles(
                    FileName,
                    NULL,
                    &Primary,
                    NULL,
                    &Disposition,
                    &SecondaryDisposition,
                    TRUE,
                    NULL
                    );
        if (!NT_SUCCESS(Status))
        {
            return NULL;
        }
        FileType = HFILE_TYPE_PRIMARY;
        break;

    case TYPE_LOG:
        Status = CmpOpenHiveFiles(
                    FileName,
                    L".log",
                    &Primary,
                    &Log,
                    &Disposition,
                    &SecondaryDisposition,
                    TRUE,
                    NULL
                    );
        if (!NT_SUCCESS(Status))
        {
            return NULL;
        }
        if (Log == NULL) {
            return NULL;
        }
        FileType = HFILE_TYPE_LOG;
        break;

    case TYPE_ALT:
        Status = CmpOpenHiveFiles(
                    FileName,
                    L".alt",
                    &Primary,
                    &Alt,
                    &Disposition,
                    &SecondaryDisposition,
                    TRUE,
                    NULL
                    );
        if (!NT_SUCCESS(Status))
        {
            return NULL;
        }
        if (Alt == NULL) {
            return NULL;
        }
        FileType = HFILE_TYPE_ALTERNATE;
        break;

    default:
        return NULL;
    }

    //
    // Initialize hive
    //
    if (Disposition == FILE_CREATED) {
        Operation = HINIT_CREATE;
        Allocate = TRUE;
    } else {
        Operation = HINIT_FILE;
        Allocate = FALSE;
    }

    if ( ! CmpInitializeHive(
                    &Hive,
                    Operation,
                    FALSE,
                    FileType,
                    NULL,
                    Primary,
                    Alt,
                    Log,
                    NULL,
                    NULL
                    ))
    {
        return NULL;
    }

    if (!Allocate) {
        *RootHandle = (HANDLE)(Hive->Hive.BaseBlock->RootCell);
        RootNode = (PCM_KEY_NODE)HvGetCell(
                                (PHHIVE)Hive, Hive->Hive.BaseBlock->RootCell);
        RootName->Length = RootName->MaximumLength = RootNode->NameLength;
        RootName->Buffer = RootNode->Name;
    } else {
        RtlInitUnicodeString(RootName, L"HiveRoot");
        *RootHandle = (HANDLE)HCELL_NIL;
        HvSyncHive((PHHIVE)Hive);
    }


    return((HANDLE)Hive);
}


NTSTATUS
EhEnumerateKey(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    Enumerate sub keys, return data on Index'th entry.

    CmEnumerateKey returns the name of the Index'th sub key of the open
    key specified.  The value STATUS_NO_MORE_ENTRIES will be
    returned if value of Index is larger than the number of sub keys.

    Note that Index is simply a way to select among child keys.  Two calls
    to CmEnumerateKey with the same Index are NOT guaranteed to return
    the same results.

    If KeyInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of node to whose sub keys are to be found

    Index - Specifies the (0-based) number of the sub key to be returned.

    KeyInformationClass - Specifies the type of information returned in
        Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (see KEY_BASIC_INFORMATION structure)

        KeyNodeInformation - return last write time, title index, name, class.
            (see KEY_NODE_INFORMATION structure)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    CM_KEY_CONTROL_BLOCK    kcb;

    kcb.Signature = CM_KEY_CONTROL_BLOCK_SIGNATURE;
    kcb.Delete = FALSE;
    kcb.KeyHive = &((PCMHIVE)HiveHandle)->Hive;
    kcb.KeyCell = (HCELL_INDEX)CellHandle;
    kcb.RefCount = 1;

    return(CmEnumerateKey(&kcb,
                          Index,
                          KeyInformationClass,
                          KeyInformation,
                          Length,
                          ResultLength));
}


NTSTATUS
EhEnumerateValueKey(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    The value entries of an open key may be enumerated.

    CmEnumerateValueKey returns the name of the Index'th value
    entry of the open key specified by KeyHandle.  The value
    STATUS_NO_MORE_ENTRIES will be returned if value of Index is
    larger than the number of sub keys.

    Note that Index is simply a way to select among value
    entries.  Two calls to NtEnumerateValueKey with the same Index
    are NOT guaranteed to return the same results.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    Hive - supplies a handle to the hive

    Cell - supplies handle to node whose sub keys are to be found

    Index - Specifies the (0-based) number of the sub key to be returned.

    KeyValueInformationClass - Specifies the type of information returned
    in Buffer. One of the following types:

        KeyValueBasicInformation - return time of last write,
            title index, and name.  (See KEY_VALUE_BASIC_INFORMATION)

        KeyValueFullInformation - return time of last write,
            title index, name, class.  (See KEY_VALUE_FULL_INFORMATION)

    KeyValueInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyValueInformation in bytes.

    ResultLength - Number of bytes actually written into KeyValueInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    CM_KEY_CONTROL_BLOCK    kcb;

    kcb.Signature = CM_KEY_CONTROL_BLOCK_SIGNATURE;
    kcb.Delete = FALSE;
    kcb.KeyHive = (PHHIVE)&(((PCMHIVE)HiveHandle)->Hive);
    kcb.KeyCell = (HCELL_INDEX)CellHandle;
    kcb.RefCount = 1;

    return(CmEnumerateValueKey(&kcb,
                               Index,
                               KeyValueInformationClass,
                               KeyValueInformation,
                               Length,
                               ResultLength));
}


NTSTATUS
EhOpenChildByNumber(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN ULONG  Index,
    IN NODE_TYPE   Type,
    OUT PHANDLE ChildCell
    )
/*++

Routine Description:

    Return the cell index of the Nth child cell.

Arguments:

    HiveHandle - handle of hive control structure for hive of interest

    CellHandle - handle for parent cell

    Index - number of desired child

    Type - type of the child object

    ChildCell - supplies a pointer to a variable to receive the
                    HCELL_INDEX of the Index'th child.

Return Value:

    status

--*/
{
    return(CmpFindChildByNumber(&((PCMHIVE)HiveHandle)->Hive,
                                (HCELL_INDEX)CellHandle,
                                Index,
                                Type,
                                (PHCELL_INDEX)ChildCell));

}


NTSTATUS
EhSetValueKey(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    )
/*++

Routine Description:

    A value entry may be created or replaced with EhSetValueKey.

    If a value entry with a Value ID (i.e. name) matching the
    one specified by ValueName exists, it is deleted and replaced
    with the one specified.  If no such value entry exists, a new
    one is created.  NULL is a legal Value ID.  While Value IDs must
    be unique within any given key, the same Value ID may appear
    in many different keys.

Arguments:

    HiveHandle - handle of hive control structure for hive of interest

    CellHandle - handle for parent cell

    ValueName - The unique (relative to the containing key) name
        of the value entry.  May be NULL.

    TitleIndex - Supplies the title index for ValueName.  The title
        index specifies the index of the localized alias for the ValueName.

    Type - The integer type number of the value entry.

    Data - Pointer to buffer with actual data for the value entry.

    DataSize - Size of Data buffer.


Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    CM_KEY_CONTROL_BLOCK kcb;

    kcb.Delete = FALSE;
    kcb.Signature = CM_KEY_CONTROL_BLOCK_SIGNATURE;
    kcb.KeyHive = (PHHIVE)&(((PCMHIVE)HiveHandle)->Hive);
    kcb.KeyCell = (HCELL_INDEX)CellHandle;
    kcb.FullName.Length = 0;
    kcb.FullName.MaximumLength = 0;
    kcb.FullName.Buffer = NULL;

    return(CmSetValueKey(&kcb,
                         *ValueName,
                         TitleIndex,
                         Type,
                         Data,
                         DataSize));

}


NTSTATUS
EhOpenChildByName(
    HANDLE HiveHandle,
    HANDLE CellHandle,
    PUNICODE_STRING  Name,
    PHANDLE ChildCell
    )
/*++

Routine Description:

    Find the child subkey cell specified by Name.

Arguments:

    HiveHandle - handle of hive control structure for hive of interest

    CellHandle - handle for parent cell

    Name - name of child object to find

    ChildCell - pointer to variable to receive cell index of child

Return Value:

    status

--*/
{
    PHCELL_INDEX    Index;

    return(CmpFindChildByName(&((PCMHIVE)HiveHandle)->Hive,
                              (HCELL_INDEX)CellHandle,
                              *Name,
                              KeyBodyNode,
                              (PHCELL_INDEX)ChildCell,
                              &Index));
}


NTSTATUS
EhCreateChild(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN PUNICODE_STRING  Name,
    OUT PHANDLE ChildCell,
    OUT PULONG Disposition OPTIONAL
    )
/*++

Routine Description:

    Attempts to open the given child subkey specified by name.  If the
    child does not exist, it is created.

Arguments:

    HiveHandle - handle of hive control structure for hive of interest

    CellHandle - handle for parent cell


    Name - name of child object to create

    ChildCell - pointer to variable to receive cell index of child

    Disposition - This optional parameter is a pointer to a variable
        that will receive a value indicating whether a new Registry
        key was created or an existing one opened:

        REG_CREATED_NEW_KEY - A new Registry Key was created
        REG_OPENED_EXISTING_KEY - An existing Registry Key was opened

Return Value:

    status

--*/
{
    PHCELL_INDEX Index;
    NTSTATUS Status;
    PHHIVE Hive;
    HCELL_INDEX NewCell;
    HCELL_INDEX NewListCell;
    HCELL_INDEX OldListCell;
    PHCELL_INDEX NewList;
    PHCELL_INDEX OldList;
    PCM_KEY_NODE Child;
    PCM_KEY_NODE Parent;
    PCM_KEY_SECURITY Security;
    HANDLE Handle;
    ULONG oldcount;

    Hive = &((PCMHIVE)HiveHandle)->Hive;

    if ((HCELL_INDEX)CellHandle == HCELL_NIL) {
        if (Hive->BaseBlock->RootCell != HCELL_NIL) {
            *ChildCell = (HANDLE)(Hive->BaseBlock->RootCell);
            if (ARGUMENT_PRESENT(Disposition)) {
                *Disposition = REG_OPENED_EXISTING_KEY;
            }
            return(STATUS_SUCCESS);
        } else {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    } else {
        Parent = (PCM_KEY_NODE)HvGetCell(Hive, (HCELL_INDEX)CellHandle);
        Status = CmpFindChildByName(Hive,
                                    (HCELL_INDEX)CellHandle,
                                    *Name,
                                    KeyBodyNode,
                                    (PHCELL_INDEX)ChildCell,
                                    &Index);
    }
    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

        NewCell = HvAllocateCell(Hive,
                                 CmpHKeyNodeSize(Hive,Name->Length),
                                 Stable);
        if (NewCell != HCELL_NIL) {

            *ChildCell = (HANDLE)NewCell;
            Child = (PCM_KEY_NODE)HvGetCell(Hive, NewCell);

            Child->Signature = CM_KEY_NODE_SIGNATURE;
            Child->Flags = 0;

            KeQuerySystemTime(&(Child->LastWriteTime));

            Child->Spare = 0;
            Child->Parent = (HCELL_INDEX)CellHandle;

            Child->ValueList.Count = 0;
            Child->ValueList.List = HCELL_NIL;
            Child->u1.s1.Security = HCELL_NIL;
            Child->u1.s1.Class = HCELL_NIL;
            Child->NameLength = Name->Length;
            Child->ClassLength = 0;

            Child->SubKeyCounts[Stable] = 0;
            Child->SubKeyCounts[Volatile] = 0;
            Child->SubKeyLists[Stable] = HCELL_NIL;
            Child->SubKeyLists[Volatile] = HCELL_NIL;

            Child->MaxValueDataLen = 0;
            Child->MaxNameLen = 0;
            Child->MaxValueNameLen = 0;
            Child->MaxClassLen = 0;

            if((HCELL_INDEX)CellHandle == HCELL_NIL) {
                Hive->BaseBlock->RootCell = NewCell;
                Status = EhpAttachSecurity(Hive, NewCell);
            } else {
                Child->u1.s1.Security = Parent->u1.s1.Security;
                Security = (PCM_KEY_SECURITY)HvGetCell(Hive, Child->u1.s1.Security);
                ++Security->ReferenceCount;
            }

            RtlMoveMemory(
                &(Child->Name[0]),
                Name->Buffer,
                Name->Length
                );

            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return(Status);
        }
        if (ARGUMENT_PRESENT(Disposition)) {
            *Disposition = REG_CREATED_NEW_KEY;
        }

        if ((HCELL_INDEX)CellHandle != HCELL_NIL) {

            //
            // put newly created child into parent's sub key list
            //
            if (! CmpAddSubKey(Hive, (HCELL_INDEX)CellHandle, NewCell)) {
                CmpFreeKeyByCell(Hive, NewCell, FALSE);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            Parent = (PCM_KEY_NODE)HvGetCell(Hive, (HCELL_INDEX)CellHandle);

            if (Parent->MaxNameLen < Name->Length) {
                Parent->MaxNameLen = Name->Length;
            }
            Parent->MaxClassLen = 0;
        }
    } else {
        Status = STATUS_SUCCESS;
        if (ARGUMENT_PRESENT(Disposition)) {
            *Disposition = REG_OPENED_EXISTING_KEY;
        }
    }
    return(Status);
}


NTSTATUS
EhQueryKey(
    IN HANDLE HiveHandle,
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    Data about the class of a key, and the numbers and sizes of its
    children and value entries may be queried with CmQueryKey.

    NOTE: The returned lengths are guaranteed to be at least as
          long as the described values, but may be longer in
          some circumstances.

Arguments:

    Hive - supplies a handle to the hive control structure for the hive

    Cell - supplies handle of node to whose sub keys are to be found

    KeyInformationClass - Specifies the type of information
        returned in Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (See KEY_BASIC_INFORMATION)

        KeyNodeInformation - return last write time, title index, name, class.
            (See KEY_NODE_INFORMATION)

        KeyFullInformation - return all data except for name and security.
            (See KEY_FULL_INFORMATION)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    CM_KEY_CONTROL_BLOCK Kcb;

    Kcb.Delete = FALSE;
    Kcb.Signature = CM_KEY_CONTROL_BLOCK_SIGNATURE;
    Kcb.KeyHive = &((PCMHIVE)HiveHandle)->Hive;
    Kcb.KeyCell = (HCELL_INDEX)KeyHandle;
    Kcb.FullName.Length = 0;
    Kcb.FullName.MaximumLength = 0;
    Kcb.FullName.Buffer = NULL;

    return(CmQueryKey(&Kcb,
                      KeyInformationClass,
                      KeyInformation,
                      Length,
                      ResultLength));
}

PSECURITY_DESCRIPTOR
EhGetKeySecurity(
    IN HANDLE HiveHandle,
    IN HANDLE KeyHandle
    )
{
    PCM_KEY_SECURITY Security;

    CmpGetObjectSecurity((HCELL_INDEX)KeyHandle,
                         &((PCMHIVE)HiveHandle)->Hive,
                         &Security,
                         NULL);

    return(&Security->Descriptor);
}


NTSTATUS
EhQueryValueKey(
    IN HANDLE HiveHandle,
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    The ValueName, TitleIndex, Type, and Data for any one of a key's
    value entries may be queried with CmQueryValueKey.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of node to whose sub keys are to be found

    ValueName  - The name of the value entry to return data for.

    KeyValueInformationClass - Specifies the type of information
        returned in KeyValueInformation.  One of the following types:

        KeyValueBasicInformation - return time of last write, title
            index, and name.  (See KEY_VALUE_BASIC_INFORMATION)

        KeyValueFullInformation - return time of last write, title
            index, name, class.  (See KEY_VALUE_FULL_INFORMATION)

    KeyValueInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyValueInformation in bytes.

    ResultLength - Number of bytes actually written into KeyValueInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    CM_KEY_CONTROL_BLOCK kcb;

    kcb.Delete = FALSE;
    kcb.Signature = CM_KEY_CONTROL_BLOCK_SIGNATURE;
    kcb.KeyHive = &((PCMHIVE)HiveHandle)->Hive;
    kcb.KeyCell = (HCELL_INDEX)KeyHandle;
    kcb.FullName.Length = 0;
    kcb.FullName.MaximumLength = 0;
    kcb.FullName.Buffer = NULL;

    return(CmQueryValueKey(&kcb,
                           *ValueName,
                           KeyValueInformationClass,
                           KeyValueInformation,
                           Length,
                           ResultLength));

}


NTSTATUS
EhDeleteValueKey(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN PUNICODE_STRING ValueName         // RAW
    )
/*++

Routine Description:

    One of the value entries of a registry key may be removed with this call.

    The value entry with ValueName matching ValueName is removed from the key.
    If no such entry exists, an error is returned.

Arguments:

    Hive - Supplies a handle to the hive control structure

    Cell - Supplies a handle to the registry key to be operated on

    ValueName - The name of the value to be deleted.  NULL is a legal name.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    CM_KEY_CONTROL_BLOCK kcb;

    kcb.Delete = FALSE;
    kcb.Signature = CM_KEY_CONTROL_BLOCK_SIGNATURE;
    kcb.KeyHive = &((PCMHIVE)HiveHandle)->Hive;
    kcb.KeyCell = (HCELL_INDEX)CellHandle;
    kcb.FullName.Length = 0;
    kcb.FullName.MaximumLength = 0;
    kcb.FullName.Buffer = NULL;

    return(CmDeleteValueKey(&kcb, *ValueName));
}


NTSTATUS
EhpAttachSecurity(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell
    )

/*++

Routine Description:

    Creates a security descriptor cell and attaches it to the given
    node.

Arguments:

    Hive - Supplies a pointer to the hive control structure.

    Cell - Supplies the cell index of the node to attach the security
           descriptor to.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    HANDLE Token;
    HCELL_INDEX SecurityCell;
    PCM_KEY_NODE Node;
    PCM_KEY_SECURITY Security;
    PSECURITY_DESCRIPTOR Descriptor;
    ULONG DescriptorLength;
    HANDLE Handle;

    Status = NtOpenProcessToken( NtCurrentProcess(),
                                 TOKEN_QUERY,
                                 &Token );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlNewSecurityObject( NULL,
                                   NULL,
                                   &Descriptor,
                                   FALSE,
                                   Token,
                                   &CmpKeyMapping );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Node = (PCM_KEY_NODE)HvGetCell(Hive, Cell);
    SecurityCell = HvAllocateCell(Hive,
                                  SECURITY_CELL_LENGTH(Descriptor),
                                  Stable);
    if (SecurityCell == HCELL_NIL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    Node->u1.s1.Security = SecurityCell;
    Security = (PCM_KEY_SECURITY)HvGetCell(Hive, SecurityCell);
    DescriptorLength = RtlLengthSecurityDescriptor(Descriptor);
    Security->Signature = CM_KEY_SECURITY_SIGNATURE;
    Security->ReferenceCount = 1;
    Security->DescriptorLength = DescriptorLength;
    RtlMoveMemory( &Security->Descriptor,
                   Descriptor,
                   DescriptorLength );
    Security->Flink = Security->Blink = SecurityCell;
    return(STATUS_SUCCESS);

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\utils\edithive.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    edithive.h

Abstract:

    include for user-mode hive editing library

Author:

    John Vert (jvert) 27-Mar-1992

Revision History:

--*/

#include "ntos.h"
#include "cmp.h"



#define TYPE_SIMPLE     0
#define TYPE_LOG        1
#define TYPE_ALT        2


HANDLE
EhOpenHive(
    IN PUNICODE_STRING FileName,
    OUT PHANDLE RootCell,
    OUT PUNICODE_STRING RootName,
    IN ULONG HiveType
    );

VOID
EhCloseHive(
    IN HANDLE Hive
    );

NTSTATUS
EhEnumerateValueKey(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

NTSTATUS
EhEnumerateKey(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

NTSTATUS
EhOpenChildByName(
    HANDLE HiveHandle,
    HANDLE KeyHandle,
    PUNICODE_STRING  Name,
    PHANDLE ChildCell
    );

NTSTATUS
EhCreateChild(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN PUNICODE_STRING  Name,
    OUT PHANDLE ChildCell,
    OUT PULONG Disposition OPTIONAL
    );

NTSTATUS
EhQueryKey(
    IN HANDLE HiveHandle,
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

NTSTATUS
EhQueryValueKey(
    IN HANDLE HiveHandle,
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

NTSTATUS
EhSetValueKey(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

NTSTATUS
EhDeleteValueKey(
    IN HANDLE Hive,
    IN HANDLE Cell,
    IN PUNICODE_STRING ValueName         // RAW
    );

PSECURITY_DESCRIPTOR
EhGetKeySecurity(
    IN HANDLE HiveHandle,
    IN HANDLE KeyHandle
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\utils\hivedmp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hivedmp.c

Abstract:

    Utility to display all or part of the registry in a format that
    is suitable for input to the REGINI program.

    HIVEDMP [-r] -f filename

    Will ennumerate and dump out the subkeys and values of KeyPath,
    and then apply itself recursively to each subkey it finds.

    Handles all value types (e.g. REG_???) defined in ntregapi.h

    -r forces ALL value type to be output in RAW (hex) form.

    Default KeyPath if none specified is \Registry

Author:

    Steve Wood (stevewo)  12-Mar-92

Revision History:

    30-Nov-92   bryanwi     Add -r switch

--*/

#include "regutil.h"
#include "edithive.h"

void
DumpValues(
    HANDLE HiveHandle,
    HANDLE KeyHandle,
    ULONG IndentLevel
    );

void
DumpKeys(
    HANDLE HiveHandle,
    HANDLE KeyHandle,
    PUNICODE_STRING KeyName,
    ULONG IndentLevel
    );

void
RegDumpKeyValueR(
    FILE *fh,
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation,
    ULONG IndentLevel
    );

PVOID ValueBuffer;
ULONG ValueBufferSize;

BOOLEAN RawOutput = FALSE;

void
Usage( void )
{
    fprintf( stderr, "usage: HIVEDMP [-f hivefile]\n" );
    exit( 1 );
}


void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    char *s;
    ANSI_STRING AnsiString;
    UNICODE_STRING KeyName;
    UNICODE_STRING DosName;
    UNICODE_STRING FileName;
    UNICODE_STRING RootName;
    HANDLE HiveHandle = NULL;
    HANDLE RootKey = NULL;
    BOOLEAN ArgumentSeen;
    LPSTR HiveFile=NULL;

    ValueBufferSize = VALUE_BUFFER_SIZE;
    ValueBuffer = VirtualAlloc( NULL, ValueBufferSize, MEM_COMMIT, PAGE_READWRITE );
    if (ValueBuffer == NULL) {
        fprintf( stderr, "REGDMP: Unable to allocate value buffer.\n" );
        exit( 1 );
        }

    ArgumentSeen = FALSE;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'd':
                        DebugOutput = TRUE;
                        break;

                    case 's':
                        SummaryOutput = TRUE;
                        break;

                    case 'r':
                        RawOutput = TRUE;
                        break;

                    case 'f':
                        if (argc--) {
                            RtlInitString( &AnsiString, *++argv );
                            RtlAnsiStringToUnicodeString( &DosName,
                                                          &AnsiString,
                                                          TRUE );
                            RtlDosPathNameToNtPathName_U( DosName.Buffer,
                                                          &FileName,
                                                          NULL,
                                                          NULL );
                            HiveHandle = EhOpenHive( &FileName,
                                                     &RootKey,
                                                     &RootName,
                                                     TYPE_SIMPLE );
                            ArgumentSeen = TRUE;
                            break;
                        }

                    default:    Usage();
                    }
                }
            }
#if 0
        else {
            RtlInitString( &AnsiString, s );
            RtlAnsiStringToUnicodeString( &KeyName, &AnsiString, TRUE );
            DumpKeys( HiveHandle, RootKey, &KeyName, 0 );
            ArgumentSeen = TRUE;
            }
#endif
        }

    if (ArgumentSeen) {
        if (HiveHandle != NULL) {
            DumpKeys( HiveHandle, RootKey, &RootName, 0 );
        } else {
            fprintf(stderr, "Couldn't open hive file %wZ\n",&DosName);
        }
    } else {
        Usage();
    }


    exit( 0 );
}


void
DumpKeys(
    HANDLE HiveHandle,
    HANDLE KeyHandle,
    PUNICODE_STRING KeyName,
    ULONG IndentLevel
    )
{
    NTSTATUS Status;
    HANDLE SubKeyHandle;
    WCHAR KeyBuffer[ 512 ];
    PKEY_BASIC_INFORMATION KeyInformation;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG SubKeyIndex;
    UNICODE_STRING SubKeyName;
    ULONG ResultLength;


    //
    // Print name of node we are about to dump out
    //
    printf( "%.*s%wZ\n",
            IndentLevel,
            "                                                                                  ",
            KeyName
          );

    //
    // Print out node's values
    //
    DumpValues( HiveHandle, KeyHandle, IndentLevel+4 );

    //
    // Enumerate node's children and apply ourselves to each one
    //

    KeyInformation = (PKEY_BASIC_INFORMATION)KeyBuffer;
    for (SubKeyIndex = 0; TRUE; SubKeyIndex++) {
        Status = EhEnumerateKey( HiveHandle,
                                 KeyHandle,
                                 SubKeyIndex,
                                 KeyBasicInformation,
                                 KeyInformation,
                                 sizeof( KeyBuffer ),
                                 &ResultLength
                               );

        if (Status == STATUS_NO_MORE_ENTRIES) {
            return;
            }
        else
        if (!NT_SUCCESS( Status )) {
            fprintf( stderr,
                     "REGDMP: NtEnumerateKey failed - Status ==%08lx\n",
                     Status
                   );
            exit( 1 );
            }

        SubKeyName.Buffer = (PWSTR)&(KeyInformation->Name[0]);
        SubKeyName.Length = (USHORT)KeyInformation->NameLength;
        SubKeyName.MaximumLength = (USHORT)KeyInformation->NameLength;

        Status = EhOpenChildByName( HiveHandle,
                                    KeyHandle,
                                    &SubKeyName,
                                    &SubKeyHandle );
        if (NT_SUCCESS(Status)) {
            DumpKeys( HiveHandle, SubKeyHandle, &SubKeyName, IndentLevel+4 );
        }
    }

}


void
DumpValues(
    HANDLE HiveHandle,
    HANDLE KeyHandle,
    ULONG IndentLevel
    )
{
    NTSTATUS Status;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    ULONG ValueIndex;
    ULONG ResultLength;

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)ValueBuffer;
    for (ValueIndex = 0; TRUE; ValueIndex++) {
        Status = EhEnumerateValueKey( HiveHandle,
                                      KeyHandle,
                                      ValueIndex,
                                      KeyValueFullInformation,
                                      KeyValueInformation,
                                      ValueBufferSize,
                                      &ResultLength
                                    );
        if (Status == STATUS_NO_MORE_ENTRIES) {
            return;
        } else if (!NT_SUCCESS( Status )) {
            fprintf( stderr,
                     "REGDMP: NtEnumerateValueKey failed - Status == %08lx\n",
                     Status
                   );
            exit( 1 );
        }

        if (RawOutput == TRUE) {
            RegDumpKeyValueR( stdout, KeyValueInformation, IndentLevel );
        } else {
            RegDumpKeyValue( stdout, KeyValueInformation, IndentLevel );
        }
    }
}


void
RegDumpKeyValueR(
    FILE *fh,
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation,
    ULONG IndentLevel
    )
{
    PULONG p;
    PWSTR pw, pw1;
    ULONG i, j, k, m, cbPrefix;
    UNICODE_STRING ValueName;
    PUCHAR pbyte;

    cbPrefix = fprintf( fh, "%.*s",
                        IndentLevel,
                        "                                                                                  "
                      );
    ValueName.Buffer = (PWSTR)&(KeyValueInformation->Name[0]);
    ValueName.Length = (USHORT)KeyValueInformation->NameLength;
    ValueName.MaximumLength = (USHORT)KeyValueInformation->NameLength;

    if (ValueName.Length) {
        cbPrefix += fprintf( fh, "%wS ", &ValueName );
        }
    cbPrefix += fprintf( fh, "= " );

    if (KeyValueInformation->DataLength == 0) {
        fprintf( fh, " [no data] \n");
        return;
    }

    fprintf( fh, "REG_BINARY 0x%08lx", KeyValueInformation->DataLength );
    p = (PULONG)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
    i = (KeyValueInformation->DataLength + 3) / sizeof( ULONG );
    for (j=0; j<i; j++) {
        if ((j % 8) == 0) {
            fprintf( fh, "\n%.*s",
                     IndentLevel+4,
                     "                                                                                  "
                   );
            }

        fprintf( fh, "0x%08lx  ", *p++ );
        }
    fprintf( fh, "\n" );

    fprintf( fh, "\n" );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\utils\cmwraper.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cmwraper.c

Abstract:

    Provides wrapper routines to support ntos\config routines called from
    user-mode.

Author:

    John Vert (jvert) 26-Mar-1992

Revision History:

--*/
#include "edithive.h"
#include "nturtl.h"
#include "stdlib.h"
#include "stdio.h"

extern  ULONG   UsedStorage;

CCHAR KiFindFirstSetRight[256] = {
        0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0};


ULONG   MmSizeOfPagedPoolInBytes = 0xffffffff;  // stub out

ULONG
DbgPrint (
    IN PCH Format,
    ...
    )
{
    va_list arglist;
    UCHAR Buffer[512];
    STRING Output;

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);
    Output.Length = _vsnprintf(Buffer, sizeof(Buffer), Format, arglist);
    Output.Buffer = Buffer;
    printf("%s", Buffer);
    return 0;
}


//
// Structure that describes the mapping of generic access rights to object
// specific access rights for registry key and keyroot objects.
//

GENERIC_MAPPING CmpKeyMapping = {
    KEY_READ,
    KEY_WRITE,
    KEY_EXECUTE,
    KEY_ALL_ACCESS
};
BOOLEAN CmpNoWrite = FALSE;
PCMHIVE CmpMasterHive = NULL;
LIST_ENTRY CmpHiveListHead;            // List of CMHIVEs

NTSTATUS
MyCmpInitHiveFromFile(
    IN PUNICODE_STRING FileName,
    OUT PCMHIVE *CmHive,
    OUT PBOOLEAN Allocate
    );


VOID
CmpLazyFlush(
    VOID
    )
{
}


VOID
CmpFreeSecurityDescriptor(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell
    )
{
    return;
}

VOID
CmpReportNotify(
    UNICODE_STRING          Name,
    PHHIVE                  Hive,
    HCELL_INDEX             Cell,
    ULONG                   Filter
    )
{
}

VOID
CmpLockRegistry(VOID)
{
    return;
}

BOOLEAN
CmpTryLockRegistryExclusive(
    IN BOOLEAN CanWait
    )
{
    return TRUE;
}

VOID
CmpUnlockRegistry(
    )
{
}

BOOLEAN
CmpTestRegistryLock()
{
    return TRUE;
}

BOOLEAN
CmpTestRegistryLockExclusive()
{
    return TRUE;
}
LONG
KeReleaseMutex (
    IN PKMUTEX Mutex,
    IN BOOLEAN Wait
    )
{
    return(0);
}
NTSTATUS
KeWaitForSingleObject (
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
{
    return(STATUS_SUCCESS);
}

BOOLEAN
CmpValidateHiveSecurityDescriptors(
    IN PHHIVE Hive
    )
{
    PCM_KEY_NODE RootNode;
    PCM_KEY_SECURITY SecurityCell;
    HCELL_INDEX ListAnchor;
    HCELL_INDEX NextCell;
    HCELL_INDEX LastCell;
    BOOLEAN ValidHive = TRUE;

    KdPrint(("CmpValidateHiveSecurityDescriptor: Hive = %lx\n",(ULONG)Hive));
    RootNode = (PCM_KEY_NODE) HvGetCell(Hive, Hive->BaseBlock->RootCell);
    ListAnchor = NextCell = RootNode->u1.s1.Security;

    do {
        SecurityCell = (PCM_KEY_SECURITY) HvGetCell(Hive, NextCell);
        if (NextCell != ListAnchor) {
            //
            // Check to make sure that our Blink points to where we just
            // came from.
            //
            if (SecurityCell->Blink != LastCell) {
                KdPrint(("  Invalid Blink (%ld) on security cell %ld\n",SecurityCell->Blink, NextCell));
                KdPrint(("  should point to %ld\n", LastCell));
                ValidHive = FALSE;
            }
        }
        KdPrint(("CmpValidSD:  SD shared by %d nodes\n",SecurityCell->ReferenceCount));
//        SetUsed(Hive, NextCell);
        LastCell = NextCell;
        NextCell = SecurityCell->Flink;
    } while ( NextCell != ListAnchor );
    return(TRUE);
}

VOID
KeBugCheck(
    IN ULONG BugCheckCode
    )
{
    printf("BugCheck: code = %08lx\n", BugCheckCode);
    exit(1);
}

VOID
KeBugCheckEx(
    IN ULONG BugCheckCode,
    IN ULONG Arg1,
    IN ULONG Arg2,
    IN ULONG Arg3,
    IN ULONG Arg4
    )
{
    printf("BugCheck: code = %08lx\n", BugCheckCode);
    printf("Args =%08lx %08lx %08lx %08lx\n", Arg1, Arg2, Arg3, Arg4);
    exit(1);
}


VOID
KeQuerySystemTime(
    OUT PLARGE_INTEGER SystemTime
    )
{
    NtQuerySystemTime(SystemTime);
}

#ifdef POOL_TAGGING
PVOID
ExAllocatePoolWithTag(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Tag
    )
{
    PVOID   Address = NULL;
    ULONG   Size;
    NTSTATUS    status;

    Size = ROUND_UP(NumberOfBytes, HBLOCK_SIZE);
    status = NtAllocateVirtualMemory(
                NtCurrentProcess(),
                &Address,
                0,
                &Size,
                MEM_COMMIT,
                PAGE_READWRITE
                );
    if (!NT_SUCCESS(status)) {
        return NULL;
    }
    return Address;
}
#else

PVOID
ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    )
{
    PVOID   Address = NULL;
    ULONG   Size;
    NTSTATUS    status;

    Size = ROUND_UP(NumberOfBytes, HBLOCK_SIZE);
    status = NtAllocateVirtualMemory(
                NtCurrentProcess(),
                &Address,
                0,
                &Size,
                MEM_COMMIT,
                PAGE_READWRITE
                );
    if (!NT_SUCCESS(status)) {
        return NULL;
    }
    return Address;
}
#endif

VOID
ExFreePool(
    IN PVOID P
    )
{
    ULONG   size;
    size = HBLOCK_SIZE;

    // if it was really more than 1 page, well, too bad
    NtFreeVirtualMemory(
        NtCurrentProcess(),
        &P,
        &size,
        MEM_DECOMMIT
        );
    return;
}


NTSTATUS
CmpWorkerCommand(
    IN OUT PREGISTRY_COMMAND Command
    )

/*++

Routine Description:

    This routine just encapsulates all the necessary synchronization for
    sending a command to the worker thread.

Arguments:

    Command - Supplies a pointer to an initialized REGISTRY_COMMAND structure
            which will be copied into the global communication structure.

Return Value:

    NTSTATUS = Command.Status

--*/

{
    PCMHIVE CmHive;
    PUNICODE_STRING FileName;
    ULONG i;

    switch (Command->Command) {

        case REG_CMD_FLUSH_KEY:
            return CmFlushKey(Command->Hive, Command->Cell);
            break;

        case REG_CMD_FILE_SET_SIZE:
            return CmpDoFileSetSize(
                      Command->Hive,
                      Command->FileType,
                      Command->FileSize
                      );
            break;

        case REG_CMD_HIVE_OPEN:

            //
            // Open the file.
            //
            FileName = Command->FileAttributes->ObjectName;

            return MyCmpInitHiveFromFile(FileName,
                                         &Command->CmHive,
                                         &Command->Allocate);

            break;

        case REG_CMD_HIVE_CLOSE:

            //
            // Close the files associated with this hive.
            //
            CmHive = Command->CmHive;

            for (i=0; i<HFILE_TYPE_MAX; i++) {
                if (CmHive->FileHandles[i] != NULL) {
                    NtClose(CmHive->FileHandles[i]);
                }
            }
            return STATUS_SUCCESS;
            break;

        case REG_CMD_SHUTDOWN:

            //
            // shut down the registry
            //
            break;

        default:
            return STATUS_INVALID_PARAMETER;
    }
}

NTSTATUS
MyCmpInitHiveFromFile(
    IN PUNICODE_STRING FileName,
    OUT PCMHIVE *CmHive,
    OUT PBOOLEAN Allocate
    )

/*++

Routine Description:

    This routine opens a file and log, allocates a CMHIVE, and initializes
    it.

Arguments:

    FileName - Supplies name of file to be loaded.

    CmHive   - Returns pointer to initialized hive (if successful)

    Allocate - Returns whether the hive was allocated or existing.

Return Value:

    NTSTATUS

--*/

{
    PCMHIVE NewHive;
    ULONG Disposition;
    ULONG SecondaryDisposition;
    HANDLE PrimaryHandle;
    HANDLE LogHandle;
    NTSTATUS Status;
    ULONG FileType;
    ULONG Operation;

    BOOLEAN Success;

    *CmHive = NULL;

    Status = CmpOpenHiveFiles(FileName,
                              L".log",
                              &PrimaryHandle,
                              &LogHandle,
                              &Disposition,
                              &SecondaryDisposition,
                              TRUE,
                              NULL
                              );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    if (LogHandle == NULL) {
        FileType = HFILE_TYPE_PRIMARY;
    } else {
        FileType = HFILE_TYPE_LOG;
    }

    if (Disposition == FILE_CREATED) {
        Operation = HINIT_CREATE;
        *Allocate = TRUE;
    } else {
        Operation = HINIT_FILE;
        *Allocate = FALSE;
    }

    Success = CmpInitializeHive(&NewHive,
                                Operation,
                                FALSE,
                                FileType,
                                NULL,
                                PrimaryHandle,
                                NULL,
                                LogHandle,
                                NULL,
                                NULL);
    if (!Success) {
        NtClose(PrimaryHandle);
        if (LogHandle != NULL) {
            NtClose(LogHandle);
        }
        return(STATUS_REGISTRY_CORRUPT);
    } else {
        *CmHive = NewHive;
        return(STATUS_SUCCESS);
    }
}

NTSTATUS
CmpLinkHiveToMaster(
    PUNICODE_STRING LinkName,
    HANDLE RootDirectory,
    PCMHIVE CmHive,
    BOOLEAN Allocate,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    return( STATUS_SUCCESS );
}


BOOLEAN
CmpFileSetSize(
    PHHIVE      Hive,
    ULONG       FileType,
    ULONG       FileSize
    )
/*++

Routine Description:

    This routine sets the size of a file.  It must not return until
    the size is guaranteed, therefore, it does a flush.

    It is environment specific.

    This routine will force execution to the correct thread context.

Arguments:

    Hive - Hive we are doing I/O for

    FileType - which supporting file to use

    FileSize - 32 bit value to set the file's size to

Return Value:

    FALSE if failure
    TRUE if success

--*/
{
    NTSTATUS    status;

    status = CmpDoFileSetSize(Hive, FileType, FileSize);
    if (!NT_SUCCESS(status)) {
        KdPrint(("CmpFileSetSize:\n\t"));
        KdPrint(("Failure: status = %08lx ", status));
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\utils\hivestat.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hivestat.c

Abstract:

    Dumps various statistics on hv (low) level structures in a hive.  (See
    regstat for higher level stuff.)

    Statistics:

        Short:  # of bins
                average bin size
                max bin size
                # of cells
                # of free cells
                # of allocated cells
                average free cell size
                total free size
                max free cell size
                average allocated size
                total allocated size
                max allocated cell size
                overhead summary (header, bin headers, cell headers)

        Long: bin#, offset, size
              cell offset, size, allocated
              cell offset, size, free


    Usage: {[+|-][<option>]} <filename>
           (+ = on by default, - = off by default)
           +s = summary - all of the short statistics
           -t[bafc] = trace, line per entry, bin, allocated, free, all cells
                (+tbc == +tbaf)
           -c = cell type summary
           -a[kvs] = Access Export (key nodes, values, SDs)

Author:

    Bryan M. Willman (bryanwi) 2-Sep-1992

Revision History:

--*/

/*

    NOTE:   Unlike other hive/registry tools, this one will not read the
            entire hive into memory, but will instead read it in via
            file I/O.  This makes it faster/easier to apply to very large
            hives.

*/
#include "regutil.h"
#include "edithive.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

UCHAR *helptext[] = {
 "hivestat:                                                               ",
 "Statistics:                                                             ",
 "    Short:  # of bins                                                   ",
 "            average bin size                                            ",
 "            max bin size                                                ",
 "            # of cells                                                  ",
 "            # of free cells                                             ",
 "            # of allocated cells                                        ",
 "            average free cell size                                      ",
 "            total free size                                             ",
 "            max free cell size                                          ",
 "            average allocated size                                      ",
 "            total allocated size                                        ",
 "            max allocated cell size                                     ",
 "            overhead summary (header, bin headers, cell headers)        ",
 "    Long: bin#, offset, size                                            ",
 "          cell offset, size, allocated                                  ",
 "          cell offset, size, free                                       ",
 "Usage: {[+|-][<option>]} <filename>                                     ",
 "       (+ = on by default, - = off by default)                          ",
 "       +s = summary - all of the short statistics                       ",
 "       -t[bafc] = trace, line per entry, bin, allocated, free, all cells",
 "            (+tbc == +tbaf)                                             ",
 "       -c = cell type summary                                           ",
 "       -a[kvs] = Access Export (key nodes, values, SDs)                 ",
 NULL
};


VOID
ParseArgs(
    int     argc,
    char    *argv[]
    );

VOID
ScanHive(
    VOID
    );

VOID
ScanCell(
    PHCELL Cell,
    ULONG CellSize
    );

VOID
ScanKeyNode(
    IN PCM_KEY_NODE Node,
    IN ULONG CellSize
    );

VOID
ScanKeyValue(
    IN PCM_KEY_VALUE Value,
    IN ULONG CellSize
    );

VOID
ScanKeySD(
    IN PCM_KEY_SECURITY Security,
    IN ULONG CellSize
    );

VOID
ScanKeyIndex(
    IN PCM_KEY_INDEX Index,
    IN ULONG CellSize
    );

VOID
ScanUnknown(
    IN PCELL_DATA Data,
    IN ULONG CellSize
    );


//
//  CONTROL ARGUMENTS
//
BOOLEAN DoCellType = FALSE;
BOOLEAN DoSummary = TRUE;
BOOLEAN DoTraceBin = FALSE;
BOOLEAN DoTraceFree = FALSE;
BOOLEAN DoTraceAlloc = FALSE;

BOOLEAN AccessKeys = FALSE;
BOOLEAN AccessValues = FALSE;
BOOLEAN AccessSD = FALSE;
LPCTSTR FileName = NULL;

ULONG HiveVersion;

//
//  SUMMARY TOTALS
//
ULONG SizeKeyData=0;
ULONG SizeValueData=0;
ULONG SizeSDData=0;
ULONG SizeIndexData=0;
ULONG SizeUnknownData=0;

ULONG NumKeyData=0;
ULONG NumValueData=0;
ULONG NumSDData=0;
ULONG NumIndexData=0;
ULONG NumUnknownData=0;

void
main(
    int argc,
    char *argv[]
    )
{
    ParseArgs(argc, argv);
    ScanHive();
    exit(0);
}

VOID
ParseArgs(
    int     argc,
    char    *argv[]
    )
/*++

Routine Description:

    Read arguments and set control arguments and file name from them.

Arguments:

    argc, argv, standard meaning

Return Value:

    None.

--*/
{
    char *p;
    int i;
    BOOLEAN command;

    if (argc == 1) {
        for (i = 0; helptext[i] != NULL; i++) {
            fprintf(stderr, "%s\n", helptext[i]);
        }
        exit(1);
    }

    for (i = 1; i < argc; i++) {
        p = argv[i];

        if (*p == '+') {
            // switch something on
            command = TRUE;

        } else if (*p == '-') {
            // switch something off
            command = FALSE;

        } else {
            FileName = p;
            continue;
        }

        p++;
        if (*p == '\0')
            continue;

        switch (*p) {
        case 's':
        case 'S':
            DoSummary = command;
            break;

        case 'c':
        case 'C':
            DoCellType = command;
            break;

        case 'a':
        case 'A':
            p++;
            while (*p != '\0') {
                switch (*p) {
                    case 'k':
                    case 'K':
                        AccessKeys = command;
                        break;

                    case 's':
                    case 'S':
                        AccessSD = command;
                        break;

                    case 'v':
                    case 'V':
                        AccessValues = command;
                        break;

                    default:
                        break;
                }
                p++;
            }
            break;

        case 't':
        case 'T':
            p++;
            while (*p != '\0') {

                switch (*p) {
                case 'b':
                case 'B':
                    DoTraceBin = command;
                    break;

                case 'a':
                case 'A':
                    DoTraceAlloc = command;
                    break;

                case 'f':
                case 'F':
                    DoTraceFree = command;
                    break;

                case 'c':
                case 'C':
                    DoTraceAlloc = command;
                    DoTraceFree = command;
                    break;

                default:
                    break;
                }

                p++;
            }
            break;

        default:
            break;
        }
    }
    return;
}

VOID
ScanHive(
    )
/*++

Routine Description:

    Scan the hive, report what we see, based on control arguments.

--*/
{
    static char buffer[HBLOCK_SIZE];
    PHBASE_BLOCK bbp;
    HANDLE filehandle;
    BOOL rf;
    ULONG readcount;
    ULONG hivelength;
    ULONG hiveposition;
    PHCELL cp;
    PHCELL guard;
    PHBIN hbp;
    ULONG hoff;
    ULONG StatBinCount = 0;
    ULONG StatBinTotal = 0;
    ULONG StatBinMax = 0;
    ULONG StatFreeCount = 0;
    ULONG StatFreeTotal = 0;
    ULONG StatFreeMax = 0;
    ULONG StatAllocCount = 0;
    ULONG StatAllocTotal = 0;
    ULONG StatAllocMax = 0;
    ULONG binread;
    ULONG binsize;
    ULONG cellsize;
    ULONG boff;
    ULONG lboff;
    ULONG SizeTotal;

    //
    // open the file
    //
    filehandle = CreateFile(FileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                            OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (filehandle == INVALID_HANDLE_VALUE) {
        fprintf(stderr,
                "hivestat: Could not open file '%s' error = %08lx\n",
                FileName, GetLastError()
                );
        exit(1);
    }


    //
    // read the header
    //
    rf = ReadFile(filehandle, buffer, HBLOCK_SIZE, &readcount, NULL);
    if ( ( ! rf ) || (readcount != HBLOCK_SIZE) ) {
        fprintf(stderr, "hivestat: '%s' - cannot read base block!\n", FileName);
        exit(1);
    }

    bbp = (PHBASE_BLOCK)(&(buffer[0]));

    if ((bbp->Major != HSYS_MAJOR) ||
        (bbp->Minor > HSYS_MINOR))
    {
        fprintf(stderr,
                "hivestat: major/minor != %d/%d get newer hivestat\n",
                HSYS_MAJOR, HSYS_MINOR
                );
        exit(1);
    }

    HiveVersion = bbp->Minor;

    hivelength = bbp->Length + HBLOCK_SIZE;
    hiveposition = HBLOCK_SIZE;
    hoff = 0;

    printf("hivestat: '%s'\n", FileName);
    if (DoTraceBin || DoTraceFree || DoTraceAlloc) {
        printf("\nTrace\n");
        printf("bi=bin, fr=free, al=allocated\n");
        printf("offset is file offset, sub HBLOCK to get HCELL\n");
        printf("type,offset,size\n");
        printf("\n");
    }

    //
    // scan the hive
    //
    guard = (PHCELL)(&(buffer[0]) + HBLOCK_SIZE);

    //
    // hiveposition is file relative offset of next block we will read
    //
    // hoff is the file relative offset of the last block we read
    //
    // hivelength is actual length of file (header's recorded length plus
    // the size of the header.
    //
    // cp is pointer into memory, within range of buffer, it's a cell pointer
    //
    while (hiveposition < hivelength) {

        //
        // read in first block of bin, check signature, get bin stats
        //
        rf = ReadFile(filehandle, buffer, HBLOCK_SIZE, &readcount, NULL);
        if ( ( ! rf ) || (readcount != HBLOCK_SIZE) ) {
            fprintf(stderr, "hivestat: '%s' read error @%08lx\n", FileName, hiveposition);
            exit(1);
        }
        hbp = (PHBIN)(&(buffer[0]));

        if (hbp->Signature != HBIN_SIGNATURE) {
            fprintf(stderr,
                    "hivestat: '%s' bad bin sign. @%08lx\n", FileName, hiveposition);
            exit(1);
        }
        hiveposition += HBLOCK_SIZE;
        hoff += HBLOCK_SIZE;
        ASSERT(hoff+HBLOCK_SIZE == hiveposition);

        StatBinCount++;
        binsize = hbp->Size;
        StatBinTotal += binsize;
        if (binsize > StatBinMax) {
            StatBinMax = binsize;
        }

        if (DoTraceBin) {
            printf("bi,x%08lx,%ld\n", hoff, binsize);
        }

        //
        // scan the bin
        //
        // cp = pointer to cell we are looking at
        // boff = offset within bin
        // lboff = last offset within bin, used only for consistency checks
        // binread = number of bytes of bin we've read so far
        //
        cp = (PHCELL)((PUCHAR)hbp + sizeof(HBIN));
        boff = sizeof(HBIN);
        lboff = -1;
        binread = HBLOCK_SIZE;

        while (binread <= binsize) {

            //
            // if free, do free stuff
            // else do alloc stuff
            // do full stuff
            //
            if (cp->Size > 0) {
                //
                // free
                //
                cellsize = cp->Size;
                StatFreeCount++;
                StatFreeTotal += cellsize;
                if (cellsize > StatFreeMax) {
                    StatFreeMax = cellsize;
                }

                if (DoTraceFree) {
                    printf("fr,x%08lx,%ld\n",
                           hoff+((PUCHAR)cp - &(buffer[0])), cellsize);
                }


            } else {
                //
                // alloc
                //
                cellsize = -1 * cp->Size;
                StatAllocCount++;
                StatAllocTotal += cellsize;
                if (cellsize > StatAllocMax) {
                    StatAllocMax = cellsize;
                }

                if (DoTraceAlloc) {
                    printf("al,x%08lx,%ld\n",
                           hoff+((PUCHAR)cp - &(buffer[0])), cellsize);
                }

                ScanCell(cp,cellsize);

            }

            //
            // do basic consistency check
            //
#if 0
            if (cp->Last != lboff) {
                printf("e!,x%08lx  bad LAST pointer %08lx\n",
                        hoff+((PUCHAR)cp - &(buffer[0])), cp->Last);
            }
#endif

            //
            // advance to next cell
            //
            lboff = boff;
            cp = (PHCELL)((PUCHAR)cp + cellsize);
            boff += cellsize;

            //
            // scan ahead in bin, if cp has reached off end of block,
            // AND there's bin left to read.
            // do this BEFORE breaking out for boff at end.
            //
            while ( (cp >= guard) && (binread < binsize) ) {

                rf = ReadFile(filehandle, buffer, HBLOCK_SIZE, &readcount, NULL);
                if ( ( ! rf ) || (readcount != HBLOCK_SIZE) ) {
                    fprintf(stderr, "hivestat: '%s' read error @%08lx\n", FileName, hiveposition);
                    exit(1);
                }
                cp = (PHCELL)((PUCHAR)cp - HBLOCK_SIZE);
                hiveposition += HBLOCK_SIZE;
                hoff += HBLOCK_SIZE;
                binread += HBLOCK_SIZE;
                ASSERT(hoff+HBLOCK_SIZE == hiveposition);
            }

            if (boff >= binsize) {
                break;              // we are done with this bin
            }
        }
    }

    //
    // Traces are done, stats gathered, print summary
    //
    if (DoSummary) {

        printf("\nSummary:\n");
        printf("type\tcount/max single/total space\n");
        printf("%s\t%7ld\t%7ld\t%7ld\n",
                "bin", StatBinCount, StatBinMax, StatBinTotal);
        printf("%s\t%7ld\t%7ld\t%7ld\n",
                "free", StatFreeCount, StatFreeMax, StatFreeTotal);
        printf("%s\t%7ld\t%7ld\t%7ld\n",
                "alloc", StatAllocCount, StatAllocMax, StatAllocTotal);

    }

    if (DoSummary && DoCellType) {

        printf("\n");

        SizeTotal = SizeKeyData +
                    SizeValueData +
                    SizeSDData +
                    SizeIndexData +
                    SizeUnknownData;

        printf("Total Key Data     %7d (%5.2f %%)\n", SizeKeyData,
            (float)SizeKeyData*100/SizeTotal);
        printf("Total Value Data   %7d (%5.2f %%)\n", SizeValueData,
            (float)SizeValueData*100/SizeTotal);
        printf("Total SD Data      %7d (%5.2f %%)\n", SizeSDData,
            (float)SizeSDData*100/SizeTotal);
        printf("Total Index Data   %7d (%5.2f %%)\n", SizeIndexData,
            (float)SizeIndexData*100/SizeTotal);
        printf("Total Unknown Data %7d (%5.2f %%)\n", SizeUnknownData,
            (float)SizeUnknownData*100/SizeTotal);

        printf("\n");
        printf("Average Key Data     %8.2f (%d cells)\n",
            (float)SizeKeyData/NumKeyData,
            NumKeyData);
        printf("Average Value Data   %8.2f (%d cells)\n",
            (float)SizeValueData/NumValueData,
            NumValueData);
        printf("Average SD Data      %8.2f (%d cells)\n",
            (float)SizeSDData/NumSDData,
            NumSDData);
        printf("Average Index Data   %8.2f (%d cells)\n",
            (float)SizeIndexData/NumIndexData,
            NumIndexData);
        printf("Average Unknown Data %8.2f (%d cells)\n",
            (float)SizeUnknownData/NumUnknownData,
            NumUnknownData);
    }
    return;
}

VOID
ScanCell(
    IN PHCELL Cell,
    IN ULONG CellSize
    )

/*++

Routine Description:

    Given a pointer to an HCELL, this tries to figure out what type
    of data is in it (key, value, SD, etc.) and gather interesting
    statistics about it.

Arguments:

    Cell - Supplies a pointer to the HCELL

    CellSize - Supplies the size of the HCELL

Return Value:

    None, sets some global statistics depending on content of the cell.

--*/

{
    PCELL_DATA Data;

    if (!DoCellType) {
        return;
    }

    if (HiveVersion==1) {
        Data = (PCELL_DATA)&Cell->u.OldCell.u.UserData;
    } else {
        Data = (PCELL_DATA)&Cell->u.NewCell.u.UserData;
    }

    //
    // grovel through the data, see if we can figure out what it looks like
    //
    if ((Data->u.KeyNode.Signature == CM_KEY_NODE_SIGNATURE) &&
        (CellSize > sizeof(CM_KEY_NODE))) {

        //
        // probably a key node
        //
        ScanKeyNode(&Data->u.KeyNode, CellSize);

    } else if ((Data->u.KeyValue.Signature == CM_KEY_VALUE_SIGNATURE) &&
               (CellSize > sizeof(CM_KEY_VALUE))) {

        //
        // probably a key value
        //
        ScanKeyValue(&Data->u.KeyValue, CellSize);

    } else if ((Data->u.KeySecurity.Signature == CM_KEY_SECURITY_SIGNATURE) &&
               (CellSize > sizeof(CM_KEY_SECURITY))) {

        //
        // probably a security descriptor
        //
        ScanKeySD(&Data->u.KeySecurity, CellSize);

    } else if ((Data->u.KeyIndex.Signature == CM_KEY_INDEX_ROOT) ||
               (Data->u.KeyIndex.Signature == CM_KEY_INDEX_LEAF)) {
        //
        // probably a key index
        //
        ScanKeyIndex(&Data->u.KeyIndex, CellSize);

    } else {
        //
        // Nothing with a signature, could be either
        //  name
        //  key list
        //  value data
        //
        ScanUnknown(Data, CellSize);

    }
}

VOID
ScanKeyNode(
    IN PCM_KEY_NODE Node,
    IN ULONG CellSize
    )
{
    int i;

    SizeKeyData += CellSize;
    NumKeyData++;

    if (AccessKeys) {
        printf("%d, %d, %d, %d, \"",
               Node->SubKeyCounts[Stable],
               Node->ValueList.Count,
               Node->NameLength,
               Node->ClassLength);

        for (i=0; i < Node->NameLength/sizeof(WCHAR); i++) {
            printf("%c",(CHAR)Node->Name[i]);
        }
        printf("\"\n");
    }

}
VOID
ScanKeyValue(
    IN PCM_KEY_VALUE Value,
    IN ULONG CellSize
    )
{
    int i;
    int DataLength;

    SizeValueData += CellSize;
    NumValueData++;
    if (AccessValues) {
        DataLength = Value->DataLength;
        if (DataLength >= CM_KEY_VALUE_SPECIAL_SIZE) {
            DataLength -= CM_KEY_VALUE_SPECIAL_SIZE;
        }
        printf("%d, %d, \"",
               DataLength,
               Value->NameLength);

        for (i=0; i < Value->NameLength/sizeof(WCHAR); i++) {
            printf("%c",(CHAR)Value->Name[i]);
        }
        printf("\"\n");
    }

}
VOID
ScanKeySD(
    IN PCM_KEY_SECURITY Security,
    IN ULONG CellSize
    )
{
    SizeSDData += CellSize;
    NumSDData++;

    if (AccessSD) {
        printf("%d,%d\n",
               Security->ReferenceCount,
               Security->DescriptorLength);
    }

}
VOID
ScanKeyIndex(
    IN PCM_KEY_INDEX Index,
    IN ULONG CellSize
    )
{
    SizeIndexData += CellSize;
    NumIndexData++;

}
VOID
ScanUnknown(
    IN PCELL_DATA Data,
    IN ULONG CellSize
    )
{
    SizeUnknownData += CellSize;
    NumUnknownData++;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\utils\regutil.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regutil.c

Abstract:

    Utility routines for use by REGINI and REGDMP programs.
Author:

    Steve Wood (stevewo)  10-Mar-92

Revision History:

--*/

#include "regutil.h"

#define RtlAllocateHeap(x,y,z) malloc(z)
#define RtlFreeHeap(x,y,z) free(z)

UNICODE_STRING RiOnKeyword;
UNICODE_STRING RiYesKeyword;
UNICODE_STRING RiTrueKeyword;
UNICODE_STRING RiOffKeyword;
UNICODE_STRING RiNoKeyword;
UNICODE_STRING RiFalseKeyword;
UNICODE_STRING RiDeleteKeyword;
UNICODE_STRING RiRegKeyword;
UNICODE_STRING RiRegNoneKeyword;
UNICODE_STRING RiRegSzKeyword;
UNICODE_STRING RiRegExpandSzKeyword;
UNICODE_STRING RiRegDwordKeyword;
UNICODE_STRING RiRegBinaryKeyword;
UNICODE_STRING RiRegBinaryFileKeyword;
UNICODE_STRING RiRegLinkKeyword;
UNICODE_STRING RiRegMultiSzKeyword;
UNICODE_STRING RiRegMultiSzFileKeyword;
UNICODE_STRING RiRegDateKeyword;

void
RegInitialize( void )
{
    RtlInitUnicodeString( &RiOnKeyword, L"ON" );
    RtlInitUnicodeString( &RiYesKeyword, L"YES" );
    RtlInitUnicodeString( &RiTrueKeyword, L"TRUE" );
    RtlInitUnicodeString( &RiOffKeyword, L"OFF" );
    RtlInitUnicodeString( &RiNoKeyword, L"NO" );
    RtlInitUnicodeString( &RiFalseKeyword, L"FALSE" );
    RtlInitUnicodeString( &RiDeleteKeyword, L"DELETE" );
    RtlInitUnicodeString( &RiRegKeyword, L"REG_" );
    RtlInitUnicodeString( &RiRegNoneKeyword, L"REG_NONE" );
    RtlInitUnicodeString( &RiRegSzKeyword, L"REG_SZ" );
    RtlInitUnicodeString( &RiRegExpandSzKeyword, L"REG_EXPAND_SZ" );
    RtlInitUnicodeString( &RiRegDwordKeyword, L"REG_DWORD" );
    RtlInitUnicodeString( &RiRegBinaryKeyword, L"REG_BINARY" );
    RtlInitUnicodeString( &RiRegBinaryFileKeyword, L"REG_BINARYFILE" );
    RtlInitUnicodeString( &RiRegLinkKeyword, L"REG_LINK" );
    RtlInitUnicodeString( &RiRegMultiSzKeyword, L"REG_MULTI_SZ" );
    RtlInitUnicodeString( &RiRegMultiSzFileKeyword, L"REG_MULTISZFILE" );
    RtlInitUnicodeString( &RiRegDateKeyword, L"REG_DATE" );
}

NTSTATUS
RegReadMultiSzFile(
    IN PUNICODE_STRING FileName,
    OUT PVOID *ValueBuffer,
    OUT PULONG ValueLength
    )
{
    NTSTATUS Status;
    UNICODE_STRING NtFileName;
    PWSTR s;
    UNICODE_STRING MultiSource;
    UNICODE_STRING MultiValue;
    REG_UNICODE_FILE MultiSzFile;
    ULONG MultiSzFileSize;


    FileName->Buffer[ FileName->Length/sizeof(WCHAR) ] = UNICODE_NULL;

    RtlDosPathNameToNtPathName_U( FileName->Buffer,
                                  &NtFileName,
                                  NULL,
                                  NULL );

    Status = RegLoadAsciiFileAsUnicode( &NtFileName, &MultiSzFile );

    if (!NT_SUCCESS( Status )) {
        return( Status );
    }

    MultiSzFileSize = (MultiSzFile.EndOfFile -
                       MultiSzFile.NextLine) * sizeof(WCHAR);

    *ValueLength = 0;
    *ValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                    MultiSzFileSize);

    MultiSource.Buffer = MultiSzFile.NextLine;
    if (MultiSzFileSize <= MAXUSHORT) {
        MultiSource.Length =
        MultiSource.MaximumLength = (USHORT)MultiSzFileSize;
    } else {
        MultiSource.Length =
        MultiSource.MaximumLength = MAXUSHORT;
    }

    while (RegGetMultiString(&MultiSource, &MultiValue)) {
        RtlMoveMemory( (PUCHAR)*ValueBuffer + *ValueLength,
                       MultiValue.Buffer,
                       MultiValue.Length );
        *ValueLength += MultiValue.Length;

        s = MultiSource.Buffer;
        while ( *s != L'"' &&
                *s != L',' &&
                ((s - MultiSource.Buffer) * sizeof(WCHAR)) <
                    MultiSource.Length ) s++;
        if ( ((s - MultiSource.Buffer) * sizeof(WCHAR)) ==
             MultiSource.Length ||
             *s == L',' ||
             *s == L';'   ) {

            ((PWSTR)*ValueBuffer)[ *ValueLength / sizeof(WCHAR) ] =
                UNICODE_NULL;
            *ValueLength += sizeof(UNICODE_NULL);
            if ( *s ==  L';' ) {
                break;
            }
        }

        if ( (MultiSzFile.EndOfFile - MultiSource.Buffer) * sizeof(WCHAR) >=
              MAXUSHORT ) {
            MultiSource.Length =
            MultiSource.MaximumLength = MAXUSHORT;
        } else {
            MultiSource.Length =
            MultiSource.MaximumLength =
                (USHORT)((MultiSzFile.EndOfFile - MultiSource.Buffer) *
                         sizeof(WCHAR));
        }
    }

    ((PWSTR)*ValueBuffer)[ *ValueLength / sizeof(WCHAR) ] = UNICODE_NULL;
    *ValueLength += sizeof(UNICODE_NULL);

    // Virtual memory for reading of MultiSzFile freed at process
    // death?

    return( TRUE );
}

NTSTATUS
RegReadBinaryFile(
    IN PUNICODE_STRING FileName,
    OUT PVOID *ValueBuffer,
    OUT PULONG ValueLength
    )
{
    NTSTATUS Status;
    UNICODE_STRING NtFileName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    HANDLE File;
    FILE_STANDARD_INFORMATION FileInformation;
    WCHAR FileNameBuffer[ 256 ];
    PWSTR s;

    FileName->Buffer[ FileName->Length/sizeof(WCHAR) ] = UNICODE_NULL;
    wcscpy( FileNameBuffer, L"\\DosDevices\\" );
    s = wcscat( FileNameBuffer, FileName->Buffer );
    while (*s != UNICODE_NULL) {
        if (*s == L'/') {
            *s = L'\\';
            }
        s++;
        }
    RtlInitUnicodeString( &NtFileName, FileNameBuffer );

    InitializeObjectAttributes( &ObjectAttributes,
                                &NtFileName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE)NULL,
                                NULL
                              );

    Status = NtOpenFile( &File,
                         SYNCHRONIZE | GENERIC_READ,
                         &ObjectAttributes,
                         &IoStatus,
                         FILE_SHARE_DELETE |
                            FILE_SHARE_READ |
                            FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT |
                            FILE_NON_DIRECTORY_FILE
                       );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    Status = NtQueryInformationFile( File,
                                     &IoStatus,
                                     (PVOID)&FileInformation,
                                     sizeof( FileInformation ),
                                     FileStandardInformation
                                   );
    if (NT_SUCCESS( Status )) {
        if (FileInformation.EndOfFile.HighPart) {
            Status = STATUS_BUFFER_OVERFLOW;
            }
        }
    if (!NT_SUCCESS( Status )) {
        NtClose( File );
        return( Status );
        }

    *ValueLength = FileInformation.EndOfFile.LowPart;
    *ValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, *ValueLength );
    if (*ValueBuffer == NULL) {
        Status = STATUS_NO_MEMORY;
        }

    if (NT_SUCCESS( Status )) {
        Status = NtReadFile( File,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatus,
                             *ValueBuffer,
                             *ValueLength,
                             NULL,
                             NULL
                           );

        if (NT_SUCCESS( Status )) {
            Status = IoStatus.Status;

            if (NT_SUCCESS( Status )) {
                if (IoStatus.Information != *ValueLength) {
                    Status = STATUS_END_OF_FILE;
                    }
                }
            }

        if (!NT_SUCCESS( Status )) {
            RtlFreeHeap( RtlProcessHeap(), 0, *ValueBuffer );
            }
        }

    NtClose( File );
    return( Status );
}

NTSTATUS
RegLoadAsciiFileAsUnicode(
    IN PUNICODE_STRING FileName,
    OUT PREG_UNICODE_FILE UnicodeFile
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    HANDLE File;
    FILE_BASIC_INFORMATION FileDateTimeInfo;
    FILE_STANDARD_INFORMATION FileInformation;
    ULONG BufferSize, i, i1, LineCount;
    PVOID BufferBase;
    PCHAR Src, Src1;
    PWSTR Dst;

    InitializeObjectAttributes( &ObjectAttributes,
                                FileName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE)NULL,
                                NULL
                              );

    Status = NtOpenFile( &File,
                         SYNCHRONIZE | GENERIC_READ,
                         &ObjectAttributes,
                         &IoStatus,
                         FILE_SHARE_DELETE |
                            FILE_SHARE_READ |
                            FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT |
                            FILE_NON_DIRECTORY_FILE
                       );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    Status = NtQueryInformationFile( File,
                                     &IoStatus,
                                     (PVOID)&FileInformation,
                                     sizeof( FileInformation ),
                                     FileStandardInformation
                                   );
    if (NT_SUCCESS( Status )) {
        if (FileInformation.EndOfFile.HighPart) {
            Status = STATUS_BUFFER_OVERFLOW;
            }
        }
    if (!NT_SUCCESS( Status )) {
        NtClose( File );
        return( Status );
        }


    BufferSize = FileInformation.EndOfFile.LowPart * sizeof( WCHAR );
    BufferSize += sizeof( UNICODE_NULL );
    BufferBase = NULL;
    Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                      (PVOID *)&BufferBase,
                                      0,
                                      &BufferSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );
    if (NT_SUCCESS( Status )) {
        Src = (PCHAR)BufferBase + ((FileInformation.EndOfFile.LowPart+1) & ~1);
        Dst = (PWSTR)BufferBase;
        Status = NtReadFile( File,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatus,
                             Src,
                             FileInformation.EndOfFile.LowPart,
                             NULL,
                             NULL
                           );

        if (NT_SUCCESS( Status )) {
            Status = IoStatus.Status;

            if (NT_SUCCESS( Status )) {
                if (IoStatus.Information != FileInformation.EndOfFile.LowPart) {
                    Status = STATUS_END_OF_FILE;
                    }
                else {
                    Status = NtQueryInformationFile( File,
                                                     &IoStatus,
                                                     (PVOID)&FileDateTimeInfo,
                                                     sizeof( FileDateTimeInfo ),
                                                     FileBasicInformation
                                                   );
                    }
                }
            }

        if (!NT_SUCCESS( Status )) {
            NtFreeVirtualMemory( NtCurrentProcess(),
                                 (PVOID *)&BufferBase,
                                 &BufferSize,
                                 MEM_RELEASE
                               );
            }
        }

    NtClose( File );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    i = 0;
    while (i < FileInformation.EndOfFile.LowPart) {
        if (i > 1 && (Src[-2] == ' ' || Src[-2] == '\t') &&
            Src[-1] == '\\' && (*Src == '\r' || *Src == '\n')
           ) {
            if (Dst[-1] == L'\\') {
                --Dst;
                }
            while (Dst > (PWSTR)BufferBase) {
                if (Dst[-1] > L' ') {
                    break;
                    }
                Dst--;
                }
            LineCount = 0;
            while (i < FileInformation.EndOfFile.LowPart) {
                if (*Src == '\n') {
                    i++;
                    Src++;
                    LineCount++;
                    }
                else
                if (*Src == '\r' &&
                    (i+1) < FileInformation.EndOfFile.LowPart &&
                    Src[ 1 ] == '\n'
                   ) {
                    i += 2;
                    Src += 2;
                    LineCount++;
                    }
                else {
                    break;
                    }
                }

            if (LineCount > 1) {
                *Dst++ = L'\n';
                }
            else {
                *Dst++ = L' ';
                while (i < FileInformation.EndOfFile.LowPart && (*Src == ' ' || *Src == '\t')) {
                    i++;
                    Src++;
                    }
                }

            if (i >= FileInformation.EndOfFile.LowPart) {
                break;
                }
            }
        else
        if ((*Src == '\r' && Src[1] == '\n') || *Src == '\n') {
            while (TRUE) {
                while (i < FileInformation.EndOfFile.LowPart && (*Src == '\r' || *Src == '\n')) {
                    i++;
                    Src++;
                    }
                Src1 = Src;
                i1 = i;
                while (i1 < FileInformation.EndOfFile.LowPart && (*Src1 == ' ' || *Src1 == '\t')) {
                    i1++;
                    Src1++;
                    }
                if (i1 < FileInformation.EndOfFile.LowPart &&
                    (*Src1 == '\r' && Src1[1] == '\n') || *Src1 == '\n'
                   ) {
                    Src = Src1;
                    i = i1;
                    }
                else {
                    break;
                    }
                }

            *Dst++ = L'\n';
            }
        else {
            i++;
            *Dst++ = RtlAnsiCharToUnicodeChar( &Src );
            }
        }

    if (NT_SUCCESS( Status )) {
        *Dst = UNICODE_NULL;
        UnicodeFile->FileContents = BufferBase;
        UnicodeFile->EndOfFile = Dst;
        UnicodeFile->BeginLine = NULL;
        UnicodeFile->EndOfLine = NULL;
        UnicodeFile->NextLine = BufferBase;
        UnicodeFile->LastWriteTime = FileDateTimeInfo.LastWriteTime;
        }
    else {
        NtFreeVirtualMemory( NtCurrentProcess(),
                             (PVOID *)&BufferBase,
                             &BufferSize,
                             MEM_RELEASE
                           );
        }

    return( Status );
}


BOOLEAN
RegGetNextLine(
    IN OUT PREG_UNICODE_FILE UnicodeFile,
    OUT PULONG IndentAmount,
    OUT PWSTR *FirstEqual
    )
{
    PWSTR s, s1;

    while (TRUE) {
        if (!(s = UnicodeFile->NextLine)) {
            return( FALSE );
            }

        *IndentAmount = 0;
        while (*s <= L' ') {
            if (*s == L' ') {
                *IndentAmount += 1;
                }
            else
            if (*s == L'\t') {
                *IndentAmount = ((*IndentAmount + 8) -
                                 (*IndentAmount % 8)
                                );
                }

            if (++s >= UnicodeFile->EndOfFile) {
                return( FALSE );
                }
            }

        UnicodeFile->BeginLine = s;

        *FirstEqual = NULL;
        UnicodeFile->NextLine = NULL;
        while (s < UnicodeFile->EndOfFile) {
            if (*s == L'=') {
                if (*FirstEqual == NULL) {
                    *FirstEqual = s;
                    }
                }
            else
            if (*s == L'\n') {
                s1 = s;
                while (s > UnicodeFile->BeginLine && s[ -1 ] <= L' ') {
                    s--;
                    }
                UnicodeFile->EndOfLine = s;
                do {
                    if (++s1 >= UnicodeFile->EndOfFile) {
                        s1 = NULL;
                        break;
                        }
                    }
                while (*s1 == L'\r' || *s1 == L'\n');

                UnicodeFile->NextLine = s1;
                break;
                }

            if (++s == UnicodeFile->EndOfFile) {
                break;
                }
            }

        if (UnicodeFile->EndOfLine > UnicodeFile->BeginLine) {
            if (DebugOutput) {
                fprintf( stderr, "%02u  %.*ws\n",
                         *IndentAmount,
                         UnicodeFile->EndOfLine - UnicodeFile->BeginLine,
                         UnicodeFile->BeginLine
                       );
                }

            return( TRUE );
            }
        }

    return( FALSE );
}


void
RegDumpKeyValue(
    FILE *fh,
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation,
    ULONG IndentLevel
    )
{
    PULONG p;
    PWSTR pw, pw1;
    ULONG i, j, k, m, cbPrefix;
    UNICODE_STRING ValueName;
    PUCHAR pbyte;

    cbPrefix = fprintf( fh, "%.*s",
                        IndentLevel,
                        "                                                                                  "
                      );
    ValueName.Buffer = (PWSTR)&(KeyValueInformation->Name[0]);
    ValueName.Length = (USHORT)KeyValueInformation->NameLength;
    ValueName.MaximumLength = (USHORT)KeyValueInformation->NameLength;

    if (ValueName.Length) {
        cbPrefix += fprintf( fh, "%wZ ", &ValueName );
        }
    cbPrefix += fprintf( fh, "= " );

    if (KeyValueInformation->DataLength == 0) {
        fprintf( fh, " [no data] \n");
        return;
    }

    switch( KeyValueInformation->Type ) {
    case REG_SZ:
    case REG_EXPAND_SZ:

        if (KeyValueInformation->Type == REG_EXPAND_SZ) {
            cbPrefix += fprintf( fh, "REG_EXPAND_SZ " );
        }
        pw = (PWSTR)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
        *(PWSTR)((PCHAR)pw + KeyValueInformation->DataLength) = UNICODE_NULL;
        i = 0;
        while (*pw) {
            if ((cbPrefix + wcslen(pw)) > 80) {
                pw1 = pw;
                while (*pw1 && *pw1 > L' ') {
                    pw1++;
                }

                if (*pw1) {
                    *pw1++ = UNICODE_NULL;
                    while (*pw1 && *pw1 <= L' ') {
                        pw1++;
                    }
                }
            } else {
                pw1 = NULL;
            }
            if (i > 0) {
                fprintf( fh, " \\\n%.*s",
                         cbPrefix,
                         "                                                                                  "
                       );
            }

            fprintf( fh, "%ws", pw );
            if (!pw1) {
                break;
                }
            i++;
            pw = pw1;
        }
        break;

    case REG_BINARY:
        fprintf( fh, "REG_BINARY 0x%08lx", KeyValueInformation->DataLength );
        p = (PULONG)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
        i = (KeyValueInformation->DataLength + 3) / sizeof( ULONG );
        if (!SummaryOutput || i <= 8) {
            for (j=0; j<i; j++) {
                if ((j % 8) == 0) {
                    fprintf( fh, "\n%.*s",
                             IndentLevel+4,
                             "                                                                                  "
                           );
                    }

                fprintf( fh, "0x%08lx  ", *p++ );
                }
            }
        else {
            fprintf( fh, " *** value display suppressed ***" );
            }
        fprintf( fh, "\n" );
        break;

//  case REG_DWORD_LITTLE_ENDIAN:
    case REG_DWORD:
        fprintf( fh, "REG_DWORD 0x%08lx",
                 *((PULONG)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset))
               );
        break;

    case REG_DWORD_BIG_ENDIAN:
        fprintf( fh, "REG_DWORD_BIG_ENDIAN 0x%08lx",
                 *((PULONG)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset))
               );
        break;

    case REG_LINK:
        fprintf( fh, "REG_LINK %ws",
                 ((PWSTR)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset))
               );
        break;

    case REG_MULTI_SZ:
        cbPrefix += fprintf( fh, "REG_MULTI_SZ " );
        pw = (PWSTR)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
        i  = 0;
        if (*pw)
        while (i < ((KeyValueInformation->DataLength-1) / sizeof(WCHAR))) {
            if (i > 0) {
                fprintf( fh, " \\\n%.*s",
                         cbPrefix,
                         "                                                                                  "
                       );
            }
            fprintf(fh, "\"%ws\" ",pw+i);
            do {
                ++i;
            } while ( pw[i] != UNICODE_NULL );
            ++i;
        }
        break;

    case REG_RESOURCE_LIST:
    case REG_FULL_RESOURCE_DESCRIPTOR:
        {
        PCM_RESOURCE_LIST ResourceList = ((PCM_RESOURCE_LIST)((PCHAR)KeyValueInformation +
                                          KeyValueInformation->DataOffset));
        PCM_FULL_RESOURCE_DESCRIPTOR FullDescriptor;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor;
        ULONG k, l, count;
        PWSTR TypeName;
        PWSTR FlagName;
        ULONG Size = KeyValueInformation->DataLength;

        if (KeyValueInformation->Type == REG_RESOURCE_LIST) {

            fprintf( fh, "   REG_RESOURCE_LIST\n");

            fprintf( fh, "%.*sNumber of Full resource Descriptors = %d",
                     IndentLevel,
                     "                                                                                  ",
                     ResourceList->Count
                   );

             count = ResourceList->Count;
             FullDescriptor = &ResourceList->List[0];

        } else {

            fprintf( fh, "   REG_FULL_RESOURCE_DESCRIPTOR\n");
            count = 1;
            FullDescriptor = ((PCM_FULL_RESOURCE_DESCRIPTOR)
                ((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset));

        }

        for (i=0; i< count; i++) {

            fprintf( fh, "\n%.*sPartial List number %d\n",
                     IndentLevel+4,
                     "                                                                                  ",
                     i
                   );

            switch(FullDescriptor->InterfaceType) {

            case Internal:      TypeName = L"Internal";         break;
            case Isa:           TypeName = L"Isa";              break;
            case Eisa:          TypeName = L"Eisa";             break;
            case MicroChannel:  TypeName = L"MicroChannel";     break;
            case TurboChannel:  TypeName = L"TurboChannel";     break;
            case PCIBus:        TypeName = L"PCI";              break;
            case VMEBus:        TypeName = L"VME";              break;
            case NuBus:         TypeName = L"NuBus";            break;
            case PCMCIABus:     TypeName = L"PCMCIA";           break;
            case CBus:          TypeName = L"CBUS";             break;
            case MPIBus:        TypeName = L"MPI";              break;

            default:
                TypeName = L"***invalid bus type***";
                break;
            }

            fprintf( fh, "%.*sINTERFACE_TYPE %ws\n",
                     IndentLevel+8,
                     "                                                                                  ",
                     TypeName
                   );

            fprintf( fh, "%.*sBUS_NUMBER  %d\n",
                     IndentLevel+8,
                     "                                                                                  ",
                     FullDescriptor->BusNumber
                   );

            //
            // This is a basic test to see if the data format is right.
            // We know at least some video resource list are bogus ...
            //

            if (Size < FullDescriptor->PartialResourceList.Count *
                         sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) ) {

                fprintf( fh, "\n%.*s *** !!! Invalid ResourceList !!! *** \n",
                         IndentLevel+8,
                         "                                                                                  ",
                         i
                       );

                break;
            }

            Size -= FullDescriptor->PartialResourceList.Count *
                         sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);



            for (j=0; j<FullDescriptor->PartialResourceList.Count; j++) {

                fprintf( fh, "%.*sDescriptor number %d\n",
                         IndentLevel+12,
                         "                                                                                  ",
                         j
                       );

                PartialResourceDescriptor =
            &(FullDescriptor->PartialResourceList.PartialDescriptors[j]);

                switch(PartialResourceDescriptor->ShareDisposition) {

                case CmResourceShareUndetermined:
                    TypeName = L"CmResourceShareUndetermined";
                    break;
                case CmResourceShareDeviceExclusive:
                    TypeName = L"CmResourceDeviceExclusive";
                    break;
                case CmResourceShareDriverExclusive:
                    TypeName = L"CmResourceDriverExclusive";
                    break;
                case CmResourceShareShared:
                    TypeName = L"CmResourceShared";
                    break;
                default:
                    TypeName = L"***invalid share disposition***";
                    break;
                }

                fprintf( fh, "%.*sShare Disposition %ws\n",
                         IndentLevel+12,
                         "                                                                                  ",
                         TypeName
                       );

                FlagName = L"***invalid Flags";

                switch(PartialResourceDescriptor->Type) {

                case CmResourceTypeNull:
                    TypeName = L"NULL";
                    FlagName = L"***Unused";
                    break;
                case CmResourceTypePort:
                    TypeName = L"PORT";
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_PORT_MEMORY) {
                        FlagName = L"CM_RESOURCE_PORT_MEMORY";
                    }
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_PORT_IO) {
                        FlagName = L"CM_RESOURCE_PORT_IO";
                    }
                    break;
                case CmResourceTypeInterrupt:
                    TypeName = L"INTERRUPT";
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {
                        FlagName = L"CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE";
                    }
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_INTERRUPT_LATCHED) {
                        FlagName = L"CM_RESOURCE_INTERRUPT_LATCHED";
                    }
                    break;
                case CmResourceTypeMemory:
                    TypeName = L"MEMORY";
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_MEMORY_READ_WRITE) {
                        FlagName = L"CM_RESOURCE_MEMORY_READ_WRITE";
                    }
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_MEMORY_READ_ONLY) {
                        FlagName = L"CM_RESOURCE_MEMORY_READ_ONLY";
                    }
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_MEMORY_WRITE_ONLY) {
                        FlagName = L"CM_RESOURCE_MEMORY_WRITE_ONLY";
                    }
                    break;
                case CmResourceTypeDma:
                    TypeName = L"DMA";
                    FlagName = L"***Unused";
                    break;
                case CmResourceTypeDeviceSpecific:
                    TypeName = L"DEVICE SPECIFIC";
                    FlagName = L"***Unused";
                    break;
                default:
                    TypeName = L"***invalid type***";
                    break;
                }

                fprintf( fh, "%.*sTYPE              %ws\n",
                         IndentLevel+12,
                         "                                                                                  ",
                         TypeName
                       );

                fprintf( fh, "%.*sFlags             %ws\n",
                         IndentLevel+12,
                         "                                                                                  ",
                         FlagName
                       );

                switch(PartialResourceDescriptor->Type) {

                case CmResourceTypePort:
                    fprintf( fh, "%.*sSTART 0x%08lx  LENGTH 0x%08lx\n",
                             IndentLevel+12,
                             "                                                                                  ",
                             PartialResourceDescriptor->u.Port.Start.LowPart,
                             PartialResourceDescriptor->u.Port.Length
                           );
                    break;

                case CmResourceTypeInterrupt:
                    fprintf( fh, "%.*sLEVEL %d  VECTOR %d  AFFINITY %d\n",
                             IndentLevel+12,
                             "                                                                                  ",
                             PartialResourceDescriptor->u.Interrupt.Level,
                             PartialResourceDescriptor->u.Interrupt.Vector,
                             PartialResourceDescriptor->u.Interrupt.Affinity
                           );
                    break;

                case CmResourceTypeMemory:
                    fprintf( fh, "%.*sSTART 0x%08lx%08lx  LENGTH 0x%08lx\n",
                             IndentLevel+12,
                             "                                                                                  ",
                             PartialResourceDescriptor->u.Memory.Start.HighPart,
                             PartialResourceDescriptor->u.Memory.Start.LowPart,
                             PartialResourceDescriptor->u.Memory.Length
                           );
                    break;

                case CmResourceTypeDma:
                    fprintf( fh, "%.*sCHANNEL %d  PORT %d\n",
                             IndentLevel+12,
                             "                                                                                  ",
                             PartialResourceDescriptor->u.Dma.Channel,
                             PartialResourceDescriptor->u.Dma.Port
                           );
                    break;

                case CmResourceTypeDeviceSpecific:
                    fprintf( fh, "%.*sDataSize 0x%08lx\n",
                             IndentLevel+12,
                             "                                                                                  ",
                             PartialResourceDescriptor->u.DeviceSpecificData.DataSize
                           );

                    p = (PULONG)(PartialResourceDescriptor + 1);
                    k = (PartialResourceDescriptor->u.DeviceSpecificData.DataSize + 3) / sizeof( ULONG );
                    for (l=0; l<k; l++) {
                        if ((l % 8) == 0) {
                            fprintf( fh, "\n%.*s",
                                IndentLevel+12,
                                "                                                                                  "
                               );
                        }

                        fprintf( fh, "0x%08lx  ", *p++ );
                    }
                    fprintf( fh, "\n" );
                    break;

                default:
                    fprintf( fh, "%.*s*** Unknown resource list type: %c ****\n",
                             IndentLevel+12,
                             "                                                                                  ",
                             PartialResourceDescriptor->Type
                           );
                    break;
                }

                fprintf( fh, "\n" );
            }

            FullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) (PartialResourceDescriptor+1);
        }

        break;
        }

    case REG_NONE:
    default:
        if (KeyValueInformation->Type == REG_NONE) {
            fprintf( fh, "REG_NONE\n");
            }
        else {
            fprintf( fh, "*** Unknown registry type (%08lx)",
                     KeyValueInformation->Type
                   );
            }
        fprintf( fh, "%.*s",
             IndentLevel,
             "                                                                                  "
             );
        fprintf( fh, "    Length: 0x%lx\n", KeyValueInformation->DataLength );
                fprintf( fh, "\n%.*s",
                    IndentLevel,
                    "                                                                                  "
                    );
        fprintf( fh, "      Data: ");
        pbyte = ((PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
        for ( k=0, m=1; k<KeyValueInformation->DataLength; k++,m++) {
            fprintf( fh, "%02x ", (*pbyte) );
            pbyte++;

            if (m==8) {
                fprintf( fh, "\n%.*s",
                    IndentLevel+12,
                    "                                                                                  "
                    );
                m=0;
            }
        }
        break;
    }

    fprintf( fh, "\n" );
    return;
}

//
//  Define an upcase macro for temporary use by the upcase routines
//

#define upcase(C) (WCHAR )(((C) >= 'a' && (C) <= 'z' ? (C) - ('a' - 'A') : (C)))

BOOLEAN
RegGetMultiString(
    IN OUT PUNICODE_STRING ValueString,
    OUT PUNICODE_STRING MultiString
    )

/*++

Routine Description:

    This routine parses multi-strings of the form

        "foo" "bar" "bletch"

    Each time it is called, it strips the first string in quotes from
    the input string, and returns it as the multi-string.

    INPUT ValueString: "foo" "bar" "bletch"

    OUTPUT ValueString: "bar" "bletch"
           MultiString: foo

Arguments:

    ValueString - Supplies the string from which the multi-string will be
                  parsed
                - Returns the remaining string after the multi-string is
                  removed

    MultiString - Returns the multi-string removed from ValueString

Return Value:

    TRUE - multi-string found and removed.

    FALSE - no more multi-strings remaining.

--*/

{
    //
    // Find the first quote mark.
    //
    while ((*(ValueString->Buffer) != L'"') &&
           (ValueString->Length > 0)) {
        ++ValueString->Buffer;
        ValueString->Length -= sizeof(WCHAR);
        ValueString->MaximumLength -= sizeof(WCHAR);
    }

    if (ValueString->Length == 0) {
        return(FALSE);
    }

    //
    // We have found the start of the multi-string.  Now find the end,
    // building up our return MultiString as we go.
    //
    ++ValueString->Buffer;
    ValueString->Length -= sizeof(WCHAR);
    ValueString->MaximumLength -= sizeof(WCHAR);
    MultiString->Buffer = ValueString->Buffer;
    MultiString->Length = 0;
    MultiString->MaximumLength = 0;
    while ((*(ValueString->Buffer) != L'"') &&
           (ValueString->Length > 0)) {
        ++ValueString->Buffer;
        ValueString->Length -= sizeof(WCHAR);
        ValueString->MaximumLength -= sizeof(WCHAR);

        MultiString->Length += sizeof(WCHAR);
        MultiString->MaximumLength += sizeof(WCHAR);
    }

    if (ValueString->Length == 0) {
        return(FALSE);
    }

    ++ValueString->Buffer;
    ValueString->Length -= sizeof(WCHAR);
    ValueString->MaximumLength -= sizeof(WCHAR);

    return( TRUE );

}


BOOLEAN
RegGetKeyValue(
    IN PUNICODE_STRING InitialKeyValue,
    IN OUT PREG_UNICODE_FILE UnicodeFile,
    OUT PULONG ValueType,
    OUT PVOID *ValueBuffer,
    OUT PULONG ValueLength
    )
{
    ULONG PrefixLength;
    PWSTR s;
    PULONG p;
    ULONG n;
    NTSTATUS Status;
    ULONG IndentAmount;
    PWSTR FirstEqual;
    UNICODE_STRING KeyValue;
    UNICODE_STRING MultiValue;
    BOOLEAN GetDataFromBinaryFile = FALSE;
    BOOLEAN GetDataFromMultiSzFile = FALSE;
    BOOLEAN ParseDateTime = FALSE;

    KeyValue = *InitialKeyValue;
    if (RtlPrefixUnicodeString( &RiDeleteKeyword, &KeyValue, TRUE )) {
        *ValueBuffer = NULL;
        return( TRUE );
        }
    else
    if (!RtlPrefixUnicodeString( &RiRegKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_SZ;
        PrefixLength = 0;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegNoneKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_NONE;
        PrefixLength = RiRegNoneKeyword.Length;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegSzKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_SZ;
        PrefixLength = RiRegSzKeyword.Length;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegExpandSzKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_EXPAND_SZ;
        PrefixLength = RiRegExpandSzKeyword.Length;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegDwordKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_DWORD;
        PrefixLength = RiRegDwordKeyword.Length;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegBinaryFileKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_BINARY;
        PrefixLength = RiRegBinaryFileKeyword.Length;
        GetDataFromBinaryFile = TRUE;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegBinaryKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_BINARY;
        PrefixLength = RiRegBinaryKeyword.Length;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegLinkKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_LINK;
        PrefixLength = RiRegLinkKeyword.Length;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegMultiSzFileKeyword, &KeyValue, TRUE)) {
        *ValueType = REG_MULTI_SZ;
        PrefixLength = RiRegMultiSzFileKeyword.Length;
        GetDataFromMultiSzFile = TRUE;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegMultiSzKeyword, &KeyValue, TRUE)) {
        *ValueType = REG_MULTI_SZ;
        PrefixLength = RiRegMultiSzKeyword.Length;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegDateKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_BINARY;
        ParseDateTime = TRUE;
        PrefixLength = RiRegDateKeyword.Length;
        }
    else {
        return( FALSE );
        }

    if (*ValueType != REG_NONE) {
        s = (PWSTR)
            ((PCHAR)KeyValue.Buffer + PrefixLength);
        KeyValue.Length -= (USHORT)PrefixLength;
        while (KeyValue.Length != 0 && *s <= L' ') {
            s++;
            KeyValue.Length -= sizeof( WCHAR );
            }
        KeyValue.Buffer = s;
        }
    else {
        *ValueType = REG_SZ;
        }


    if (GetDataFromBinaryFile) {
        Status = RegReadBinaryFile( &KeyValue, ValueBuffer, ValueLength );
        if (NT_SUCCESS( Status )) {
            return( TRUE );
            }
        else {
            fprintf( stderr, "REGINI: Unable to read data from %wZ - Status == %lx\n", &KeyValue, Status );
            return( FALSE );
            }
        }

    if (GetDataFromMultiSzFile) {
        Status = RegReadMultiSzFile( &KeyValue, ValueBuffer, ValueLength );
        if (NT_SUCCESS( Status )) {
            return( TRUE );
            }
        else {
            fprintf( stderr, "REGINI: Unable to read data from %wZ - Status == %lx\n", &KeyValue, Status );
            return( FALSE );
            }
        }

    switch( *ValueType ) {
    case REG_SZ:
    case REG_EXPAND_SZ:
    case REG_LINK:
        *ValueLength = KeyValue.Length + sizeof( UNICODE_NULL );
        *ValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, *ValueLength );
        if (*ValueBuffer == NULL) {
            return( FALSE );
            }

        RtlMoveMemory( *ValueBuffer, KeyValue.Buffer, KeyValue.Length );
        ((PWSTR)*ValueBuffer)[ KeyValue.Length / sizeof( WCHAR ) ] = UNICODE_NULL;
        return( TRUE );

    case REG_DWORD:
        *ValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( ULONG ) );
        if (*ValueBuffer == NULL) {
            return( FALSE );
            }

        if (RtlPrefixUnicodeString( &RiTrueKeyword, &KeyValue, TRUE ) ||
            RtlPrefixUnicodeString( &RiYesKeyword, &KeyValue, TRUE ) ||
            RtlPrefixUnicodeString( &RiOnKeyword, &KeyValue, TRUE )
           ) {
            *(PULONG)*ValueBuffer = (ULONG)TRUE;
            }
        else
        if (RtlPrefixUnicodeString( &RiFalseKeyword, &KeyValue, TRUE ) ||
            RtlPrefixUnicodeString( &RiNoKeyword, &KeyValue, TRUE ) ||
            RtlPrefixUnicodeString( &RiOffKeyword, &KeyValue, TRUE )
           ) {
            *(PULONG)*ValueBuffer = (ULONG)FALSE;
            }
        else {
            Status = RtlUnicodeStringToInteger( &KeyValue, 0, (PULONG)*ValueBuffer );
            if (!NT_SUCCESS( Status )) {
                fprintf( stderr, "REGINI: CharToInteger( %wZ ) failed - Status == %lx\n", &KeyValue, Status );
                RtlFreeHeap( RtlProcessHeap(), 0, *ValueBuffer );
                return( FALSE );
                }
            }

        *ValueLength = sizeof( ULONG );
        return( TRUE );

    case REG_BINARY:
        if (ParseDateTime) {
#define NUMBER_DATE_TIME_FIELDS 6
            ULONG FieldIndexes[ NUMBER_DATE_TIME_FIELDS  ] = {1, 2, 0, 3, 4, 7};
            //
            // Month/Day/Year HH:MM DayOfWeek
            //

            ULONG CurrentField = 0;
            PCSHORT Fields;
            TIME_FIELDS DateTimeFields;
            UNICODE_STRING Field;
            ULONG FieldValue;

            RtlZeroMemory( &DateTimeFields, sizeof( DateTimeFields ) );
            Fields = &DateTimeFields.Year;
            while (KeyValue.Length) {
                if (CurrentField >= 7) {
                    return( FALSE );
                    }

                s = KeyValue.Buffer;
                while (KeyValue.Length && *s == L' ') {
                    KeyValue.Length--;
                    s++;
                    }

                Field.Buffer = s;
                while (KeyValue.Length) {
                    if (CurrentField == (NUMBER_DATE_TIME_FIELDS-1)) {
                        }
                    else
                    if (*s < L'0' || *s > L'9') {
                        break;
                        }

                    KeyValue.Length--;
                    s++;
                    }

                Field.Length = (USHORT)((PCHAR)s - (PCHAR)Field.Buffer);
                Field.MaximumLength = Field.Length;

                if (KeyValue.Length) {
                    KeyValue.Length--;
                    s++;
                    }
                KeyValue.Buffer = s;

                if (CurrentField == (NUMBER_DATE_TIME_FIELDS-1)) {
                    if (Field.Length < 3) {
                        printf( "REGINI: %wZ invalid day of week length\n", &Field );
                        return FALSE;
                        }

                    if (DateTimeFields.Year != 0) {
                        printf( "REGINI: Year must be zero to specify day of week\n" );
                        return FALSE;
                        }

                    if (!_wcsnicmp( Field.Buffer, L"SUN", 3 )) {
                        FieldValue = 0;
                        }
                    else
                    if (!_wcsnicmp( Field.Buffer, L"MON", 3 )) {
                        FieldValue = 1;
                        }
                    else
                    if (!_wcsnicmp( Field.Buffer, L"TUE", 3 )) {
                        FieldValue = 2;
                        }
                    else
                    if (!_wcsnicmp( Field.Buffer, L"WED", 3 )) {
                        FieldValue = 3;
                        }
                    else
                    if (!_wcsnicmp( Field.Buffer, L"THU", 3 )) {
                        FieldValue = 4;
                        }
                    else
                    if (!_wcsnicmp( Field.Buffer, L"FRI", 3 )) {
                        FieldValue = 5;
                        }
                    else
                    if (!_wcsnicmp( Field.Buffer, L"SAT", 3 )) {
                        FieldValue = 6;
                        }
                    else {
                        printf( "REGINI: %wZ invalid day of week\n", &Field );
                        return FALSE;
                        }
                    }
                else {
                    Status = RtlUnicodeStringToInteger( &Field, 10, &FieldValue );
                    if (!NT_SUCCESS( Status )) {
                        return( FALSE );
                        }
                    }

                Fields[ FieldIndexes[ CurrentField++ ] ] = (CSHORT)FieldValue;
                }

            if (DateTimeFields.Year == 0) {
                if (DateTimeFields.Day > 5) {
                    printf( "REGINI: Day must be 0 - 5 if year is zero.\n" );
                    return FALSE;
                    }
                }
            else
            if (DateTimeFields.Year < 100) {
                DateTimeFields.Year += 1900;
                }

            *ValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( DateTimeFields ) );
            *ValueLength = sizeof( DateTimeFields );
            RtlMoveMemory( *ValueBuffer, &DateTimeFields, sizeof( DateTimeFields ) );
            return TRUE;
            }
        else {
            Status = RtlUnicodeStringToInteger( &KeyValue, 0, ValueLength );
            if (!NT_SUCCESS( Status )) {
                return( FALSE );
                }
            s = KeyValue.Buffer;
            while (KeyValue.Length != 0 && *s > L' ') {
                s++;
                KeyValue.Length -= sizeof( WCHAR );
                }
            KeyValue.Buffer = s;
            }
        break;

    case REG_MULTI_SZ:
        *ValueLength = 0;
        *ValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, KeyValue.Length + sizeof( UNICODE_NULL ) );
        while (RegGetMultiString(&KeyValue, &MultiValue)) {
            RtlMoveMemory( (PUCHAR)*ValueBuffer + *ValueLength,
                           MultiValue.Buffer,
                           MultiValue.Length );
            *ValueLength += MultiValue.Length;
            ((PWSTR)*ValueBuffer)[ *ValueLength / sizeof(WCHAR) ] = UNICODE_NULL;
            *ValueLength += sizeof(UNICODE_NULL);
        }
        ((PWSTR)*ValueBuffer)[ *ValueLength / sizeof(WCHAR) ] = UNICODE_NULL;
        *ValueLength += sizeof(UNICODE_NULL);

        return( TRUE );

    default:
        return( FALSE );
    }

    *ValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, *ValueLength );
    p = *ValueBuffer;
    n = (*ValueLength + sizeof( ULONG ) - 1) / sizeof( ULONG );
    while (n--) {
        if (KeyValue.Length == 0) {
            if (!RegGetNextLine( UnicodeFile, &IndentAmount, &FirstEqual )) {
                RtlFreeHeap( RtlProcessHeap(), 0, *ValueBuffer );
                return( FALSE );
                }
            KeyValue.Buffer = UnicodeFile->BeginLine;
            KeyValue.Length = (USHORT)
                ((PCHAR)UnicodeFile->EndOfLine - (PCHAR)UnicodeFile->BeginLine);
            KeyValue.MaximumLength = KeyValue.Length;
            }

        s = KeyValue.Buffer;
        while (KeyValue.Length != 0 && *s <= L' ') {
            s++;
            KeyValue.Length -= sizeof( WCHAR );
            }
        KeyValue.Buffer = s;
        if (KeyValue.Length != 0) {
            Status = RtlUnicodeStringToInteger( &KeyValue, 0, p );
            if (!NT_SUCCESS( Status )) {
                RtlFreeHeap( RtlProcessHeap(), 0, *ValueBuffer );
                return( FALSE );
                }
            p++;

            s = KeyValue.Buffer;
            while (KeyValue.Length != 0 && *s > L' ') {
                s++;
                KeyValue.Length -= sizeof( WCHAR );
                }
            KeyValue.Buffer = s;
            }
        }

    return( TRUE );
}

BOOLEAN
RtlPrefixUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlPrefixUnicodeString function determines if the String1
    counted string parameter is a prefix of the String2 counted string
    parameter.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first unicode string.

    String2 - Pointer to the second unicode string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals a prefix of String2 and
    FALSE otherwise.

--*/

{
    PWSTR s1, s2;
    ULONG n;
    WCHAR c1, c2;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    if (String2->Length < String1->Length) {
        return( FALSE );
        }

    n = String1->Length / sizeof( c1 );
    while (n) {
        c1 = *s1++;
        c2 = *s2++;

        if (CaseInSensitive) {
            c1 = upcase(c1);
            c2 = upcase(c2);
        }
        if (c1 != c2) {
            return( FALSE );
            }

        n--;
        }

    return( TRUE );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\utils\regutil.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    regutil.h

Abstract:

    This is the include file for the registry utility functions.

Author:

    Steve Wood (stevewo) 10-Mar-1992

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
// #include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys\types.h>
#include <sys\stat.h>


#define VALUE_BUFFER_SIZE (4096 * 100)

void
RegInitialize( void );

typedef struct _REG_UNICODE_FILE {
    LARGE_INTEGER LastWriteTime;
    PWSTR FileContents;
    PWSTR EndOfFile;
    PWSTR BeginLine;
    PWSTR EndOfLine;
    PWSTR NextLine;
} REG_UNICODE_FILE, *PREG_UNICODE_FILE;

NTSTATUS
RegReadBinaryFile(
    IN PUNICODE_STRING FileName,
    OUT PVOID *ValueBuffer,
    OUT PULONG ValueLength
    );

NTSTATUS
RegLoadAsciiFileAsUnicode(
    IN PUNICODE_STRING FileName,
    OUT PREG_UNICODE_FILE UnicodeFile
    );

BOOLEAN DebugOutput;
BOOLEAN SummaryOutput;

BOOLEAN
RegGetNextLine(
    IN OUT PREG_UNICODE_FILE UnicodeFile,
    OUT PULONG IndentAmount,
    OUT PWSTR *FirstEqual
    );

BOOLEAN
RegGetKeyValue(
    IN PUNICODE_STRING KeyValue,
    IN OUT PREG_UNICODE_FILE UnicodeFile,
    OUT PULONG ValueType,
    OUT PVOID *ValueBuffer,
    OUT PULONG ValueLength
    );

BOOLEAN
RegGetMultiString(
    IN OUT PUNICODE_STRING ValueString,
    OUT PUNICODE_STRING MultiString
    );

void
RegDumpKeyValue(
    FILE *fh,
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation,
    ULONG IndentLevel
    );

//
// routines for creating security descriptors (regacl.c)
//

BOOLEAN
RegInitializeSecurity(
    VOID
    );

BOOLEAN
RegCreateSecurity(
    IN PUNICODE_STRING Description,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor
    );

VOID
RegDestroySecurity(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\config\utils\hiveini.c ===
#include "regutil.h"
#include "edithive.h"

NTSTATUS
RiInitializeRegistryFromAsciiFile(
    IN PUNICODE_STRING HiveName,
    IN PUNICODE_STRING FileName
    );

void
Usage( void )
{
    fprintf( stderr, "usage: HIVEINI -f hivefile [files...]\n" );
    exit( 1 );
}

PVOID OldValueBuffer;
ULONG OldValueBufferSize;

typedef struct _KEY_INFO {
    ULONG IndentAmount;
    UNICODE_STRING Name;
    HANDLE HiveHandle;
    HANDLE Handle;
    LARGE_INTEGER LastWriteTime;
} KEY_INFO, *PKEY_INFO;

#define MAX_KEY_DEPTH 64

NTSTATUS
RiInitializeRegistryFromAsciiFile(
    IN PUNICODE_STRING HiveName,
    IN PUNICODE_STRING FileName
    )
{
    NTSTATUS Status;
    REG_UNICODE_FILE UnicodeFile;
    PWSTR EndKey, FirstEqual, BeginValue;
    ULONG IndentAmount;
    UNICODE_STRING InputLine;
    UNICODE_STRING KeyName;
    UNICODE_STRING KeyValue;
    PKEY_VALUE_FULL_INFORMATION OldValueInformation;
    PKEY_BASIC_INFORMATION KeyInformation;
    UCHAR KeyInformationBuffer[ 512 ];
    ULONG ResultLength;
    ULONG OldValueLength;
    PVOID ValueBuffer;
    ULONG ValueLength;
    ULONG ValueType;
    KEY_INFO KeyPath[ MAX_KEY_DEPTH ];
    PKEY_INFO CurrentKey;
    ULONG KeyPathLength;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING Class;
    ULONG Disposition;
    BOOLEAN UpdateKeyValue;
    ULONG i;
    HANDLE HiveHandle;
    HANDLE RootKey;
    UNICODE_STRING RootName;

    HiveHandle = EhOpenHive(HiveName,
                            &KeyPath[0].Handle,
                            &KeyPath[0].Name,
                            TYPE_SIMPLE);
    if (HiveHandle == NULL) {
        return(STATUS_OBJECT_PATH_NOT_FOUND);
    }
    KeyPath[0].Handle = (HANDLE)HCELL_NIL;

    OldValueInformation = (PKEY_VALUE_FULL_INFORMATION)OldValueBuffer;
    Class.Buffer = NULL;
    Class.Length = 0;

    Status = RegLoadAsciiFileAsUnicode( FileName,
                                        &UnicodeFile
                                      );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    KeyPathLength = 0;
    while (RegGetNextLine( &UnicodeFile, &IndentAmount, &FirstEqual )) {
#if 0
        InputLine.Buffer = UnicodeFile.BeginLine;
        InputLine.Length = (USHORT)((PCHAR)UnicodeFile.EndOfLine - (PCHAR)UnicodeFile.BeginLine);
        InputLine.MaximumLength = InputLine.Length;
        printf( "GetNextLine: (%02u) '%wZ'\n", IndentAmount, &InputLine );
#endif
        if (FirstEqual == NULL) {
            KeyName.Buffer = UnicodeFile.BeginLine;
            KeyName.Length = (USHORT)((PCHAR)UnicodeFile.EndOfLine - (PCHAR)KeyName.Buffer);
            KeyName.MaximumLength = (USHORT)(KeyName.Length + 1);

#if 0
            printf( "%02u %04u  KeyName: %wZ\n", KeyPathLength, IndentAmount, &KeyName );
#endif
            CurrentKey = &KeyPath[ KeyPathLength ];
            if (KeyPathLength == 0 ||
                IndentAmount > CurrentKey->IndentAmount
               ) {
                if (KeyPathLength == MAX_KEY_DEPTH) {
                    fprintf( stderr,
                             "HIVEINI: %wZ key exceeded maximum depth (%u) of tree.\n",
                             &KeyName,
                             MAX_KEY_DEPTH
                           );

                    return( STATUS_UNSUCCESSFUL );
                    }
                KeyPathLength++;
                CurrentKey++;
                }
            else {
                do {
                    CurrentKey->Handle = NULL;
                    if (IndentAmount == CurrentKey->IndentAmount) {
                        break;
                        }
                    CurrentKey--;
                    if (--KeyPathLength == 1) {
                        break;
                        }
                    }
                while (IndentAmount <= CurrentKey->IndentAmount);
                }

#if 0
            printf( "  (%02u)\n", KeyPathLength );
#endif
            CurrentKey->Name = KeyName;
            CurrentKey->IndentAmount = IndentAmount;
            Status = EhCreateChild(HiveHandle,
                                   KeyPath[ KeyPathLength-1 ].Handle,
                                   &KeyName,
                                   &CurrentKey->Handle,
                                   &Disposition);

            if (NT_SUCCESS( Status )) {
                if (DebugOutput) {
                    fprintf( stderr, "    Created key %02x %wZ (%08x)\n",
                                     CurrentKey->IndentAmount,
                                     &CurrentKey->Name,
                                     CurrentKey->Handle
                           );
                    }
                KeyInformation = (PKEY_BASIC_INFORMATION)KeyInformationBuffer;
                Status = EhQueryKey( HiveHandle,
                                     CurrentKey->Handle,
                                     KeyBasicInformation,
                                     KeyInformation,
                                     sizeof( KeyInformationBuffer ),
                                     &ResultLength
                                   );
                if (NT_SUCCESS( Status )) {
                    CurrentKey->LastWriteTime = KeyInformation->LastWriteTime;
                    }
                else {
                    RtlZeroMemory( &CurrentKey->LastWriteTime,
                                   sizeof( CurrentKey->LastWriteTime )
                                 );

                    }

                if (Disposition == REG_CREATED_NEW_KEY) {
                    printf( "Created Key: " );
                    for (i=0; i<KeyPathLength; i++) {
                        printf( "%wZ\\", &KeyPath[ i ].Name );
                        }
                    printf( "%wZ\n", &KeyName );
                    }
                }
            else {
                fprintf( stderr,
                         "HIVEINI: CreateKey (%wZ) relative to handle (%lx) failed - %lx\n",
                         &KeyName,
                         ObjectAttributes.RootDirectory,
                         Status
                       );
                }
            }
        else {
            if (FirstEqual == UnicodeFile.BeginLine) {
                KeyName.Buffer = NULL;
                KeyName.Length = 0;
                KeyName.MaximumLength = 0;
                }
            else {
                EndKey = FirstEqual;
                while (EndKey > UnicodeFile.BeginLine && EndKey[ -1 ] <= L' ') {
                    EndKey--;
                    }
                KeyName.Buffer = UnicodeFile.BeginLine;
                KeyName.Length = (USHORT)((PCHAR)EndKey - (PCHAR)KeyName.Buffer);
                KeyName.MaximumLength = (USHORT)(KeyName.Length + 1);
                }

            BeginValue = FirstEqual + 1;
            while (BeginValue < UnicodeFile.EndOfLine && *BeginValue <= L' ') {
                BeginValue++;
                }
            KeyValue.Buffer = BeginValue;
            KeyValue.Length = (USHORT)((PCHAR)UnicodeFile.EndOfLine - (PCHAR)BeginValue);
            KeyValue.MaximumLength = (USHORT)(KeyValue.Length + 1);

            while (IndentAmount <= CurrentKey->IndentAmount) {
                if (DebugOutput) {
                    fprintf( stderr, "    Popping from key %02x %wZ (%08x)\n",
                                     CurrentKey->IndentAmount,
                                     &CurrentKey->Name,
                                     CurrentKey->Handle
                           );
                    }
                CurrentKey->Handle = NULL;
                CurrentKey--;
                if (--KeyPathLength == 1) {
                    break;
                    }
                }
            if (DebugOutput) {
                fprintf( stderr, "    Adding value '%wZ = %wZ' to key %02x %wZ (%08x)\n",
                                 &KeyName,
                                 &KeyValue,
                                 CurrentKey->IndentAmount,
                                 &CurrentKey->Name,
                                 CurrentKey->Handle
                       );
                }

            if (RegGetKeyValue( &KeyValue,
                                &UnicodeFile,
                                &ValueType,
                                &ValueBuffer,
                                &ValueLength
                              )
               ) {
                if (ValueBuffer == NULL) {
                    Status = EhDeleteValueKey( HiveHandle,
                                               KeyPath[ KeyPathLength+1 ].Handle,
                                               &KeyValue
                                             );
                    if (NT_SUCCESS( Status )) {
                        printf( "Delete value for Key: " );
                        for (i=0; i<KeyPathLength; i++) {
                            printf( "%wZ\\", &KeyPath[ i ].Name );
                            }
                        printf( "%wZ\n", &KeyName );
                        }
                    }
                else {
                    if ( UnicodeFile.LastWriteTime.QuadPart >
                         CurrentKey->LastWriteTime.QuadPart
                       ) {
                        Status = STATUS_UNSUCCESSFUL;
                        UpdateKeyValue = TRUE;
                        }
                    else {
                        Status = EhQueryValueKey( HiveHandle,
                                                  CurrentKey->Handle,
                                                  &KeyName,
                                                  KeyValueFullInformation,
                                                  OldValueInformation,
                                                  OldValueBufferSize,
                                                  &OldValueLength
                                                );
                        if (NT_SUCCESS( Status )) {
                            UpdateKeyValue = TRUE;
                            }
                        else {
                            UpdateKeyValue = FALSE;
                            }
                        }

                    if (!NT_SUCCESS( Status ) ||
                        OldValueInformation->Type != ValueType ||
                        OldValueInformation->DataLength != ValueLength ||
                        !RtlEqualMemory( (PCHAR)OldValueInformation +
                                            OldValueInformation->DataOffset,
                                          ValueBuffer,
                                          ValueLength )
                       ) {

                        Status = EhSetValueKey( HiveHandle,
                                                CurrentKey->Handle,
                                                &KeyName,
                                                0,
                                                ValueType,
                                                ValueBuffer,
                                                ValueLength
                                              );
                        if (NT_SUCCESS( Status )) {
                            printf( "%s value for Key: ",
                                    UpdateKeyValue ? "Updated" : "Created"
                                  );
                            for (i=1; i<=KeyPathLength; i++) {
                                printf( "%wZ\\", &KeyPath[ i ].Name );
                                }

                            if (KeyName.Length) {
                                printf( "%wZ ", &KeyName );
                                }
                            printf( "= '%wZ'\n", &KeyValue );
                            }
                        else {
                            fprintf( stderr,
                                     "HIVEINI: SetValueKey (%wZ) failed - %lx\n",
                                     &KeyName,
                                     Status
                                   );
                            }
                        }

                    RtlFreeHeap( RtlProcessHeap(), 0, ValueBuffer );
                    }
                }
            else {
                fprintf( stderr,
                         "HIVEINI: Invalid key (%wZ) value (%wZ)\n", &KeyName,
                         &KeyValue
                       );
                }
            }
        }

        EhCloseHive(HiveHandle);

    return( Status );
}


int
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    int i;
    char *s;
    NTSTATUS Status;
    BOOL FileArgumentSeen;
    BOOL HiveArgumentSeen=FALSE;
    ANSI_STRING AnsiString;
    UNICODE_STRING DosFileName;
    UNICODE_STRING FileName;
    UNICODE_STRING DosHiveName;
    UNICODE_STRING HiveName;

    OldValueBufferSize = VALUE_BUFFER_SIZE;
    OldValueBuffer = VirtualAlloc( NULL, OldValueBufferSize, MEM_COMMIT, PAGE_READWRITE );
    if (OldValueBuffer == NULL) {
        fprintf( stderr, "HIVEINI: Unable to allocate value buffer.\n" );
        exit( 1 );
        }

    RegInitialize();

    FileArgumentSeen = FALSE;
    HiveName.Length = HiveName.MaximumLength = 0;
    HiveName.Buffer = NULL;
    for (i=1; i<argc; i++) {
        s = argv[ i ];
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'd':
                        DebugOutput = TRUE;
                        break;

                    case 'f':
                        if (++i < argc) {
                            RtlInitAnsiString(&AnsiString, argv[i]);
                            RtlAnsiStringToUnicodeString( &DosHiveName,
                                                          &AnsiString,
                                                          TRUE );
                            RtlDosPathNameToNtPathName_U( DosHiveName.Buffer,
                                                          &HiveName,
                                                          NULL,
                                                          NULL );
                            break;
                        }

                    default:    Usage();
                    }
                }
            }
        else {
            FileArgumentSeen = TRUE;
            RtlInitAnsiString( &AnsiString, s );
            Status = RtlAnsiStringToUnicodeString( &DosFileName, &AnsiString, TRUE );
            if (NT_SUCCESS( Status )) {
                if (RtlDosPathNameToNtPathName_U( DosFileName.Buffer,
                                                  &FileName,
                                                  NULL,
                                                  NULL
                                                )
                   ) {
                    Status = RiInitializeRegistryFromAsciiFile( &HiveName,
                                                                &FileName );
                    if (!NT_SUCCESS( Status )) {
                        fprintf( stderr,
                                 "HIVEINI: Failed to load from %wZ - Status == %lx\n",
                                 &FileName,
                                 Status
                           );
                        }
                    }
                else {
                    Status = STATUS_UNSUCCESSFUL;
                    fprintf( stderr,
                             "HIVEINI: Unable to map Dos Name (%wZ) to NT name\n",
                             &DosFileName
                       );
                    }
                }
            else {
                fprintf( stderr,
                         "HIVEINI: Unable to convert %s to unicode - Status == %lx\n",
                         &AnsiString,
                         Status
                       );
                }
            }
        }

    if (!FileArgumentSeen) {
        RtlInitUnicodeString( &FileName, L"\\SystemRoot\\System32\\Config\\registry.sys" );
        Status = RiInitializeRegistryFromAsciiFile( &HiveName,
                                                    &FileName );
        if (!NT_SUCCESS( Status )) {
            fprintf( stderr,
                     "HIVEINI: Failed to load from %wZ - Status == %lx\n",
                     &FileName,
                     Status
                   );
            }
        else {
            RtlInitUnicodeString( &FileName, L"\\SystemRoot\\System32\\Config\\registry.usr" );
            Status = RiInitializeRegistryFromAsciiFile( &HiveName,
                                                        &FileName );
            if (!NT_SUCCESS( Status )) {
                fprintf( stderr,
                         "HIVEINI: Failed to load from %wZ - Status == %lx\n",
                         &FileName,
                         Status
                       );
                }
            }
        }

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\dbgk\dbgkobj.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dbgkobj.c

Abstract:

    This module houses routines to handle the debug object

Author:

    Neill Clift (NeillC) 26-Apr-2000


Revision History:

--*/

#include "dbgkp.h"

#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DbgkInitialize)
#pragma alloc_text(PAGE, NtCreateDebugObject)
#pragma alloc_text(PAGE, NtDebugActiveProcess)
#pragma alloc_text(PAGE, NtRemoveProcessDebug)
#pragma alloc_text(PAGE, NtWaitForDebugEvent)
#pragma alloc_text(PAGE, NtDebugContinue)
#pragma alloc_text(PAGE, NtSetInformationDebugObject)
#pragma alloc_text(PAGE, DbgkpDeleteObject)
#pragma alloc_text(PAGE, DbgkpCloseObject)
#pragma alloc_text(PAGE, DbgkCopyProcessDebugPort)
#pragma alloc_text(PAGE, DbgkOpenProcessDebugPort)
#pragma alloc_text(PAGE, DbgkpSetProcessDebugObject)
#pragma alloc_text(PAGE, DbgkpQueueMessage)
#pragma alloc_text(PAGE, DbgkpOpenHandles)
#pragma alloc_text(PAGE, DbgkClearProcessDebugObject)
#pragma alloc_text(PAGE, DbgkpConvertKernelToUserStateChange)
#pragma alloc_text(PAGE, DbgkpMarkProcessPeb)
#pragma alloc_text(PAGE, DbgkpFreeDebugEvent)
#pragma alloc_text(PAGE, DbgkpPostFakeProcessCreateMessages)
#pragma alloc_text(PAGE, DbgkpPostFakeModuleMessages)
#pragma alloc_text(PAGE, DbgkpPostFakeThreadMessages)
#pragma alloc_text(PAGE, DbgkpWakeTarget)
#pragma alloc_text(PAGE, DbgkpPostAdditionalThreadMessages)
#endif

//
// Define this to not suspend threads while attaching.
// This makes race conditions more prevelent.
//
//#define DBGK_DONT_SUSPEND

//
// Non-pageable data
//

//
// This mutex protects the debug port object of processes.
//
FAST_MUTEX DbgkpProcessDebugPortMutex;

//
// Pageable data
//

//#ifdef ALLOC_PRAGMA
//#pragma data_seg("PAGEDATA")
//#endif

POBJECT_TYPE DbgkDebugObjectType = NULL;


//#ifdef ALLOC_PRAGMA
//#pragma data_seg()
//#endif

NTSTATUS
DbgkInitialize (
    VOID
    )
/*++

Routine Description:

    Initialize the debug system

Arguments:

    None

Return Value:

    NTSTATUS - Status of operation

--*/
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    OBJECT_TYPE_INITIALIZER oti = {0};
    GENERIC_MAPPING GenericMapping = {STANDARD_RIGHTS_READ | DEBUG_READ_EVENT,
                                      STANDARD_RIGHTS_WRITE | DEBUG_PROCESS_ASSIGN,
                                      STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE,
                                      DEBUG_ALL_ACCESS};


    PAGED_CODE ();

    ExInitializeFastMutex (&DbgkpProcessDebugPortMutex);

    RtlInitUnicodeString (&Name, L"DebugObject");

    oti.Length                    = sizeof (oti);
    oti.SecurityRequired          = TRUE;
    oti.InvalidAttributes         = 0;
    oti.PoolType                  = NonPagedPool;
    oti.DeleteProcedure           = DbgkpDeleteObject;
    oti.CloseProcedure            = DbgkpCloseObject;
    oti.ValidAccessMask           = DEBUG_ALL_ACCESS;
    oti.GenericMapping            = GenericMapping;
    oti.DefaultPagedPoolCharge    = 0;
    oti.DefaultNonPagedPoolCharge = 0;

    Status = ObCreateObjectType (&Name, &oti, NULL, &DbgkDebugObjectType);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }
    return Status;
}

VOID
DbgkpDeleteObject (
    IN  PVOID   Object
    )
/*++

Routine Description:

    Called by the object manager when the last reference to the object goes away.

Arguments:

    Object - Debug object being deleted

Return Value:

    None.

--*/
{
#if DBG
    PDEBUG_OBJECT DebugObject;
#endif

    PAGED_CODE();

#if DBG
    DebugObject = Object;

    ASSERT (IsListEmpty (&DebugObject->EventList));
#else
    UNREFERENCED_PARAMETER(Object);
#endif
}

VOID
DbgkpMarkProcessPeb (
    PEPROCESS Process
    )
/*++

Routine Description:

    This routine writes the debug variable in the PEB

Arguments:

    Process - Process that needs its PEB modified

Return Value:

    None.

--*/
{
    KAPC_STATE ApcState;

    PAGED_CODE ();

    //
    // Acquire process rundown protection as we are about to look at the processes address space
    //
    if (ExAcquireRundownProtection (&Process->RundownProtect)) {

        if (Process->Peb != NULL) {
            KeStackAttachProcess(&Process->Pcb, &ApcState);


            ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);

            try {
                Process->Peb->BeingDebugged = (BOOLEAN)(Process->DebugPort != NULL ? TRUE : FALSE);
#if defined(_WIN64)
                if (Process->Wow64Process != NULL) {
                    PPEB32 Peb32 = (PPEB32)Process->Wow64Process->Wow64;
                    if (Peb32 != NULL) {
                        Peb32->BeingDebugged = Process->Peb->BeingDebugged;
                    }
                }
#endif
            } except (EXCEPTION_EXECUTE_HANDLER) {
            }
            ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);

            KeUnstackDetachProcess(&ApcState);

        }

        ExReleaseRundownProtection (&Process->RundownProtect);
    }
}

VOID
DbgkpWakeTarget (
    IN PDEBUG_EVENT DebugEvent
    )
{
    PETHREAD Thread;

    Thread = DebugEvent->Thread;

    if ((DebugEvent->Flags&DEBUG_EVENT_SUSPEND) != 0) {
        PsResumeThread (DebugEvent->Thread, NULL);
    }

    if (DebugEvent->Flags&DEBUG_EVENT_RELEASE) {
        ExReleaseRundownProtection (&Thread->RundownProtect);
    }

    //
    // If we have an actual thread waiting then wake it up else free the memory.
    //
    if ((DebugEvent->Flags&DEBUG_EVENT_NOWAIT) == 0) {
        KeSetEvent (&DebugEvent->ContinueEvent, 0, FALSE); // Wake up waiting process
    } else {
        DbgkpFreeDebugEvent (DebugEvent);
    }
}

VOID
DbgkpCloseObject (
    IN PEPROCESS Process,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG ProcessHandleCount,
    IN ULONG SystemHandleCount
    )
/*++

Routine Description:

    Called by the object manager when a handle is closed to the object.

Arguments:

    Process - Process doing the close
    Object - Debug object being deleted
    GrantedAccess - Access ranted for this handle
    ProcessHandleCount - Unused and unmaintained by OB
    SystemHandleCount - Current handle count for this object

Return Value:

    None.

--*/
{
    PDEBUG_OBJECT DebugObject = Object;
    PDEBUG_EVENT DebugEvent;
    PLIST_ENTRY ListPtr;
    BOOLEAN Deref;

    PAGED_CODE ();

    UNREFERENCED_PARAMETER (GrantedAccess);
    UNREFERENCED_PARAMETER (ProcessHandleCount);

    //
    // If this isn't the last handle then do nothing.
    //
    if (SystemHandleCount > 1) {
        return;
    }

    ExAcquireFastMutex (&DebugObject->Mutex);

    //
    // Mark this object as going away and wake up any processes that are waiting.
    //
    DebugObject->Flags |= DEBUG_OBJECT_DELETE_PENDING;

    //
    // Remove any events and queue them to a temporary queue
    //
    ListPtr = DebugObject->EventList.Flink;
    InitializeListHead (&DebugObject->EventList);

    ExReleaseFastMutex (&DebugObject->Mutex);

    //
    // Wake anyone waiting. They need to leave this object alone now as its deleting
    //
    KeSetEvent (&DebugObject->EventsPresent, 0, FALSE);

    //
    // Loop over all processes and remove the debug port from any that still have it.
    // Debug port propogation was disabled by setting the delete pending flag above so we only have to do this
    // once. No more refs can appear now.
    //
    for (Process = PsGetNextProcess (NULL);
         Process != NULL;
         Process = PsGetNextProcess (Process)) {

        if (Process->DebugPort == DebugObject) {
            Deref = FALSE;
            ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);
            if (Process->DebugPort == DebugObject) {
                Process->DebugPort = NULL;
                Deref = TRUE;
            }
            ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);


            if (Deref) {
                DbgkpMarkProcessPeb (Process);
                //
                // If the caller wanted process deletion on debugger dying (old interface) then kill off the process.
                //
                if (DebugObject->Flags&DEBUG_OBJECT_KILL_ON_CLOSE) {
                    PsTerminateProcess (Process, STATUS_DEBUGGER_INACTIVE);
                }
                ObDereferenceObject (DebugObject);
            }
        }
    }
    //
    // Wake up all the removed threads.
    //
    while (ListPtr != &DebugObject->EventList) {
        DebugEvent = CONTAINING_RECORD (ListPtr, DEBUG_EVENT, EventList);
        ListPtr = ListPtr->Flink;
        DebugEvent->Status = STATUS_DEBUGGER_INACTIVE;
        DbgkpWakeTarget (DebugEvent);
    }

}

VOID
DbgkCopyProcessDebugPort (
    IN PEPROCESS TargetProcess,
    IN PEPROCESS SourceProcess
    )
/*++

Routine Description:

    Copies a debug port from one process to another.

Arguments:

    TargetProcess - Process to move port to
    sourceProcess - Process to move port from

Return Value:

    None

--*/
{
    PDEBUG_OBJECT DebugObject;

    PAGED_CODE ();

    TargetProcess->DebugPort = NULL; // New process. Needs no locks.

    if (SourceProcess->DebugPort != NULL) {
        ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);
        DebugObject = SourceProcess->DebugPort;
        if (DebugObject != NULL && (SourceProcess->Flags&PS_PROCESS_FLAGS_NO_DEBUG_INHERIT) == 0) {
            //
            // We must not propogate a debug port thats got no handles left.
            //
            ExAcquireFastMutex (&DebugObject->Mutex);

            //
            // If the object is delete pending then don't propogate this object.
            //
            if ((DebugObject->Flags&DEBUG_OBJECT_DELETE_PENDING) == 0) {
                ObReferenceObject (DebugObject);
                TargetProcess->DebugPort = DebugObject;
            }

            ExReleaseFastMutex (&DebugObject->Mutex);
        }
        ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);
    }
}

NTSTATUS
DbgkOpenProcessDebugPort (
    IN PEPROCESS Process,
    IN KPROCESSOR_MODE PreviousMode,
    OUT HANDLE *pHandle
    )
/*++

Routine Description:

    References the target processes debug port.

Arguments:

    Process - Process to reference debug port

Return Value:

    PDEBUG_OBJECT - Referenced object or NULL

--*/
{
    PDEBUG_OBJECT DebugObject;
    NTSTATUS Status;

    PAGED_CODE ();

    Status = STATUS_PORT_NOT_SET;
    if (Process->DebugPort != NULL) {
        ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);
        DebugObject = Process->DebugPort;
        if (DebugObject != NULL) {
            ObReferenceObject (DebugObject);
        }
        ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);

        if (DebugObject != NULL) {
            Status = ObOpenObjectByPointer (DebugObject,
                                            0,
                                            NULL,
                                            MAXIMUM_ALLOWED,
                                            DbgkDebugObjectType,
                                            PreviousMode,
                                            pHandle);
            if (!NT_SUCCESS (Status)) {
                ObDereferenceObject (DebugObject);
            }
        }
    }
    return Status;

}

NTSTATUS
NtCreateDebugObject (
    OUT PHANDLE DebugObjectHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Flags
    )
/*++

Routine Description:

    Creates a new debug object that maintains the context for a single debug session. Multiple processes may be
    associated with a single debug object.

Arguments:

    DebugObjectHandle - Pointer to a handle to recive the output objects handle
    DesiredAccess     - Required handle access
    ObjectAttributes  - Standard object attributes structure
    Flags             - Only one flag DEBUG_KILL_ON_CLOSE

Return Value:

    NTSTATUS - Status of call.

--*/
{
    NTSTATUS Status;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    PDEBUG_OBJECT DebugObject;

    PAGED_CODE();

    //
    // Get previous processor mode and probe output arguments if necessary.
    // Zero the handle for error paths.
    //

    PreviousMode = KeGetPreviousMode();

    try {
        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle (DebugObjectHandle);
        }
        *DebugObjectHandle = NULL;

    } except (ExSystemExceptionFilter ()) { // If previous mode is kernel then don't handle the exception
        return GetExceptionCode ();
    }

    if (Flags & ~DEBUG_KILL_ON_CLOSE) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Create a new debug object and initialize it.
    //

    Status = ObCreateObject (PreviousMode,
                             DbgkDebugObjectType,
                             ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof (DEBUG_OBJECT),
                             0,
                             0,
                             &DebugObject);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ExInitializeFastMutex (&DebugObject->Mutex);
    InitializeListHead (&DebugObject->EventList);
    KeInitializeEvent (&DebugObject->EventsPresent, NotificationEvent, FALSE);

    if (Flags & DEBUG_KILL_ON_CLOSE) {
        DebugObject->Flags = DEBUG_OBJECT_KILL_ON_CLOSE;
    } else {
        DebugObject->Flags = 0;
    }

    //
    // Insert the object into the handle table
    //
    Status = ObInsertObject (DebugObject,
                             NULL,
                             DesiredAccess,
                             0,
                             NULL,
                             &Handle);


    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    try {
        *DebugObjectHandle = Handle;
    } except (ExSystemExceptionFilter ()) {
        //
        // The caller changed the page protection or deleted the memory for the handle.
        // No point closing the handle as process rundown will do that and we don't know its still the same handle
        //
        Status = GetExceptionCode ();
    }

    return Status;
}

VOID
DbgkpFreeDebugEvent (
    IN PDEBUG_EVENT DebugEvent
    )
{
    NTSTATUS Status;

    PAGED_CODE ();

    switch (DebugEvent->ApiMsg.ApiNumber) {
        case DbgKmCreateProcessApi :
            if (DebugEvent->ApiMsg.u.CreateProcessInfo.FileHandle != NULL) {
                Status = ObCloseHandle (DebugEvent->ApiMsg.u.CreateProcessInfo.FileHandle, KernelMode);
            }
            break;

        case DbgKmLoadDllApi :
            if (DebugEvent->ApiMsg.u.LoadDll.FileHandle != NULL) {
                Status = ObCloseHandle (DebugEvent->ApiMsg.u.LoadDll.FileHandle, KernelMode);
            }
            break;

    }
    ObDereferenceObject (DebugEvent->Process);
    ObDereferenceObject (DebugEvent->Thread);
    ExFreePool (DebugEvent);
}


NTSTATUS
DbgkpQueueMessage (
    IN PEPROCESS Process,
    IN PETHREAD Thread,
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN ULONG Flags,
    IN PDEBUG_OBJECT TargetDebugObject
    )
/*++

Routine Description:

    Queues a debug message to the port for a user mode debugger to get.

Arguments:

    Process           - Process being debugged
    Thread            - Thread making call
    ApiMsg            - Message being sent and received
    NoWait            - Don't wait for a responce. Buffer message and return.
    TargetDebugObject - Port to queue nowait messages to

Return Value:

    NTSTATUS - Status of call.

--*/
{
    PDEBUG_EVENT DebugEvent;
    DEBUG_EVENT StaticDebugEvent;
    PDEBUG_OBJECT DebugObject;
    NTSTATUS Status;

    PAGED_CODE ();

    if (Flags&DEBUG_EVENT_NOWAIT) {
        DebugEvent = ExAllocatePoolWithQuotaTag (NonPagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                                 sizeof (*DebugEvent),
                                                 'EgbD');
        if (DebugEvent == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        DebugEvent->Flags = Flags|DEBUG_EVENT_INACTIVE;
        ObReferenceObject (Process);
        ObReferenceObject (Thread);
        DebugEvent->BackoutThread = PsGetCurrentThread ();
        DebugObject = TargetDebugObject;
    } else {
        DebugEvent = &StaticDebugEvent;
        DebugEvent->Flags = Flags;

        ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);

        DebugObject = Process->DebugPort;

        //
        // See if this create message has already been sent.
        //
        if (ApiMsg->ApiNumber == DbgKmCreateThreadApi ||
            ApiMsg->ApiNumber == DbgKmCreateProcessApi) {
            if (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_SKIP_CREATION_MSG) {
                DebugObject = NULL;
            }
        }

        //
        // See if this exit message is for a thread that never had a create
        //
        if (ApiMsg->ApiNumber == DbgKmExitThreadApi ||
            ApiMsg->ApiNumber == DbgKmExitProcessApi) {
            if (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_SKIP_TERMINATION_MSG) {
                DebugObject = NULL;
            }
        }
    }

    KeInitializeEvent (&DebugEvent->ContinueEvent, SynchronizationEvent, FALSE);

    DebugEvent->Process = Process;
    DebugEvent->Thread = Thread;
    DebugEvent->ApiMsg = *ApiMsg;
    DebugEvent->ClientId = Thread->Cid;

    if (DebugObject == NULL) {
        Status = STATUS_PORT_NOT_SET;
    } else {

        //
        // We must not use a debug port thats got no handles left.
        //
        ExAcquireFastMutex (&DebugObject->Mutex);

        //
        // If the object is delete pending then don't use this object.
        //
        if ((DebugObject->Flags&DEBUG_OBJECT_DELETE_PENDING) == 0) {
            InsertTailList (&DebugObject->EventList, &DebugEvent->EventList);
            //
            // Set the event to say there is an unread event in the object
            //
            if ((Flags&DEBUG_EVENT_NOWAIT) == 0) {
                KeSetEvent (&DebugObject->EventsPresent, 0, FALSE);
            }
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_DEBUGGER_INACTIVE;
        }

        ExReleaseFastMutex (&DebugObject->Mutex);
    }


    if ((Flags&DEBUG_EVENT_NOWAIT) == 0) {
        ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);

        if (NT_SUCCESS (Status)) {
            KeWaitForSingleObject (&DebugEvent->ContinueEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL);

            Status = DebugEvent->Status;
            *ApiMsg = DebugEvent->ApiMsg;
        }
    } else {
        if (!NT_SUCCESS (Status)) {
            ObDereferenceObject (Process);
            ObDereferenceObject (Thread);
            ExFreePool (DebugEvent);
        }
    }

    return Status;
}

NTSTATUS
DbgkClearProcessDebugObject (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT SourceDebugObject
    )
/*++

Routine Description:

    Remove a debug object from a process.

Arguments:

    Process           - Process to be debugged
    sourceDebugObject - Debug object to detach

Return Value:

    NTSTATUS - Status of call.

--*/
{
    NTSTATUS Status;
    PDEBUG_OBJECT DebugObject;
    PDEBUG_EVENT DebugEvent;
    LIST_ENTRY TempList;
    PLIST_ENTRY Entry;

    PAGED_CODE ();

    ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);

    DebugObject = Process->DebugPort;
    if (DebugObject == NULL || (DebugObject != SourceDebugObject && SourceDebugObject != NULL)) {
        DebugObject = NULL;
        Status = STATUS_PORT_NOT_SET;
    } else {
        Process->DebugPort = NULL;
        Status = STATUS_SUCCESS;
    }
    ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);

    if (NT_SUCCESS (Status)) {
        DbgkpMarkProcessPeb (Process);
    }

    //
    // Remove any events for this process and wake up the threads.
    //
    if (DebugObject) {
        //
        // Remove any events and queue them to a temporary queue
        //
        InitializeListHead (&TempList);

        ExAcquireFastMutex (&DebugObject->Mutex);
        for (Entry = DebugObject->EventList.Flink;
             Entry != &DebugObject->EventList;
             ) {

            DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);
            Entry = Entry->Flink;
            if (DebugEvent->Process == Process) {
                RemoveEntryList (&DebugEvent->EventList);
                InsertTailList (&TempList, &DebugEvent->EventList);
            }
        }
        ExReleaseFastMutex (&DebugObject->Mutex);

        ObDereferenceObject (DebugObject);

        //
        // Wake up all the removed threads.
        //
        while (!IsListEmpty (&TempList)) {
            Entry = RemoveHeadList (&TempList);
            DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);
            DebugEvent->Status = STATUS_DEBUGGER_INACTIVE;
            DbgkpWakeTarget (DebugEvent);
        }
    }

    return Status;
}


NTSTATUS
DbgkpSetProcessDebugObject (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN NTSTATUS MsgStatus,
    IN PETHREAD LastThread
    )
/*++

Routine Description:

    Attach a debug object to a process.

Arguments:

    Process     - Process to be debugged
    DebugObject - Debug object to attach
    MsgStatus   - Status from queing the messages
    LastThread  - Last thread seen in attach loop.

Return Value:

    NTSTATUS - Status of call.

--*/
{
    NTSTATUS Status;
    PETHREAD ThisThread;
    LIST_ENTRY TempList;
    PLIST_ENTRY Entry;
    PDEBUG_EVENT DebugEvent;
    BOOLEAN First;
    PETHREAD Thread;
    BOOLEAN GlobalHeld;
    PETHREAD FirstThread;

    PAGED_CODE ();

    ThisThread = PsGetCurrentThread ();

    InitializeListHead (&TempList);

    First = TRUE;
    GlobalHeld = FALSE;

    if (!NT_SUCCESS (MsgStatus)) {
        LastThread = NULL;
        Status = MsgStatus;
    } else {
        Status = STATUS_SUCCESS;
    }

    //
    // Pick up any threads we missed
    //
    if (NT_SUCCESS (Status)) {

        while (1) {
            //
            // Acquire the debug port mutex so we know that any new threads will
            // have to wait to behind us.
            //
            GlobalHeld = TRUE;

            ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);

            //
            // If the port has been set then exit now.
            //
            if (Process->DebugPort != NULL) {
                Status = STATUS_PORT_ALREADY_SET;
                break;
            }
            //
            // Assign the debug port to the process to pick up any new threads
            //
            Process->DebugPort = DebugObject;

            //
            // Reference the last thread so we can deref outside the lock
            //
            ObReferenceObject (LastThread);

            //
            // Search forward for new threads
            //
            Thread = PsGetNextProcessThread (Process, LastThread);
            if (Thread != NULL) {

                //
                // Remove the debug port from the process as we are
                // about to drop the lock
                //
                Process->DebugPort = NULL;

                ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);

                GlobalHeld = FALSE;

                ObDereferenceObject (LastThread);

                //
                // Queue any new thread messages and repeat.
                //

                Status = DbgkpPostFakeThreadMessages (Process,
                                                      DebugObject,
                                                      Thread,
                                                      &FirstThread,
                                                      &LastThread);
                if (!NT_SUCCESS (Status)) {
                    LastThread = NULL;
                    break;
                }
                ObDereferenceObject (FirstThread);
            } else {
                break;
            }
        }
    }

    //
    // Lock the debug object so we can check its deleted status
    //
    ExAcquireFastMutex (&DebugObject->Mutex);

    //
    // We must not propogate a debug port thats got no handles left.
    //

    if (NT_SUCCESS (Status)) {
        if ((DebugObject->Flags&DEBUG_OBJECT_DELETE_PENDING) == 0) {
            PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_NO_DEBUG_INHERIT);
            ObReferenceObject (DebugObject);
        } else {
            Process->DebugPort = NULL;
            Status = STATUS_DEBUGGER_INACTIVE;
        }
    }

    for (Entry = DebugObject->EventList.Flink;
         Entry != &DebugObject->EventList;
         ) {

        DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);
        Entry = Entry->Flink;

        if ((DebugEvent->Flags&DEBUG_EVENT_INACTIVE) != 0 && DebugEvent->BackoutThread == ThisThread) {
            Thread = DebugEvent->Thread;

            //
            // If the thread has not been inserted by CreateThread yet then don't
            // create a handle. We skip system threads here also
            //
            if (NT_SUCCESS (Status) && Thread->GrantedAccess != 0 && !IS_SYSTEM_THREAD (Thread)) {
                //
                // If we could not acquire rundown protection on this
                // thread then we need to supress its exit message.
                //
                if ((DebugEvent->Flags&DEBUG_EVENT_PROTECT_FAILED) != 0) {
                    PS_SET_BITS (&Thread->CrossThreadFlags,
                                 PS_CROSS_THREAD_FLAGS_SKIP_TERMINATION_MSG);
                    RemoveEntryList (&DebugEvent->EventList);
                    InsertTailList (&TempList, &DebugEvent->EventList);
                } else {
                    if (First) {
                         DebugEvent->Flags &= ~DEBUG_EVENT_INACTIVE;
                        KeSetEvent (&DebugObject->EventsPresent, 0, FALSE);
                        First = FALSE;
                    }
                    DebugEvent->BackoutThread = NULL;
                    PS_SET_BITS (&Thread->CrossThreadFlags,
                                 PS_CROSS_THREAD_FLAGS_SKIP_CREATION_MSG);

                }
            } else {
                RemoveEntryList (&DebugEvent->EventList);
                InsertTailList (&TempList, &DebugEvent->EventList);
            }

            if (DebugEvent->Flags&DEBUG_EVENT_RELEASE) {
                DebugEvent->Flags &= ~DEBUG_EVENT_RELEASE;
                ExReleaseRundownProtection (&Thread->RundownProtect);
            }

        }
    }

    ExReleaseFastMutex (&DebugObject->Mutex);

    if (GlobalHeld) {
        ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);
    }

    if (LastThread != NULL) {
        ObDereferenceObject (LastThread);
    }

    while (!IsListEmpty (&TempList)) {
        Entry = RemoveHeadList (&TempList);
        DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);
        DbgkpWakeTarget (DebugEvent);
    }

    if (NT_SUCCESS (Status)) {
        DbgkpMarkProcessPeb (Process);
    }

    return Status;
}

NTSTATUS
DbgkpPostFakeThreadMessages (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN PETHREAD StartThread,
    OUT PETHREAD *pFirstThread,
    OUT PETHREAD *pLastThread
    )
/*++

Routine Description:

    This routine posts the faked initial process create, thread create messages

Arguments:

    Process      - Process to be debugged
    DebugObject  - Debug object to queue messages to
    StartThread  - Thread to start search from
    pFirstThread - First thread found in the list
    pLastThread  - Last thread found in the list

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PETHREAD Thread, FirstThread, LastThread;
    DBGKM_APIMSG ApiMsg;
    BOOLEAN First = TRUE;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG Flags;
#if !defined (DBGK_DONT_SUSPEND)
    NTSTATUS Status1;
#endif

    PAGED_CODE ();

    LastThread = FirstThread = NULL;

    Status = STATUS_UNSUCCESSFUL;

    if (StartThread != NULL) {
        First = FALSE;
        FirstThread = StartThread;
        ObReferenceObject (FirstThread);
    } else {
        StartThread = PsGetNextProcessThread (Process, NULL);
        First = TRUE;
    }

    for (Thread = StartThread;
         Thread != NULL;
         Thread = PsGetNextProcessThread (Process, Thread)) {

        Flags = DEBUG_EVENT_NOWAIT;

        //
        // Keep a track ont he last thread we have seen.
        // We use this as a starting point for new threads after we
        // really attach so we can pick up any new threads.
        //
        if (LastThread != NULL) {
            ObDereferenceObject (LastThread);
        }
        LastThread = Thread;
        ObReferenceObject (LastThread);

        //
        // Acquire rundown protection of the thread.
        // This stops the thread exiting so we know it can't send
        // it's termination message
        //
        if (ExAcquireRundownProtection (&Thread->RundownProtect)) {
            Flags |= DEBUG_EVENT_RELEASE;

            //
            // Suspend the thread if we can for the debugger
            // We don't suspend terminating threads as we will not be giving details
            // of these to the debugger.
            //
#if !defined (DBGK_DONT_SUSPEND)

            if (!IS_SYSTEM_THREAD (Thread)) {
                Status1 = PsSuspendThread (Thread, NULL);
                if (NT_SUCCESS (Status1)) {
                    Flags |= DEBUG_EVENT_SUSPEND;
                }
            }
#endif
        } else {
            //
            // Rundown protection failed for this thread.
            // This means the thread is exiting. We will mark this thread
            // later so it doesn't sent a thread termination message.
            // We can't do this now because this attach might fail.
            //
            Flags |= DEBUG_EVENT_PROTECT_FAILED;
        }

        RtlZeroMemory (&ApiMsg, sizeof (ApiMsg));

        if (First) {
            ApiMsg.ApiNumber = DbgKmCreateProcessApi;
            if (Process->SectionObject != NULL) { // system process doesn't have one of these!
                ApiMsg.u.CreateProcessInfo.FileHandle  = DbgkpSectionToFileHandle (Process->SectionObject);
            } else {
                ApiMsg.u.CreateProcessInfo.FileHandle = NULL;
            }
            ApiMsg.u.CreateProcessInfo.BaseOfImage = Process->SectionBaseAddress;
            try {
                NtHeaders = RtlImageNtHeader(Process->SectionBaseAddress);
                if (NtHeaders) {
                    ApiMsg.u.CreateProcessInfo.InitialThread.StartAddress = NULL; // Filling this in breaks MSDEV!
//                        (PVOID)(NtHeaders->OptionalHeader.ImageBase + NtHeaders->OptionalHeader.AddressOfEntryPoint);
                    ApiMsg.u.CreateProcessInfo.DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
                    ApiMsg.u.CreateProcessInfo.DebugInfoSize       = NtHeaders->FileHeader.NumberOfSymbols;
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                ApiMsg.u.CreateProcessInfo.InitialThread.StartAddress = NULL;
                ApiMsg.u.CreateProcessInfo.DebugInfoFileOffset = 0;
                ApiMsg.u.CreateProcessInfo.DebugInfoSize = 0;
            }
        } else {
            ApiMsg.ApiNumber = DbgKmCreateThreadApi;
            ApiMsg.u.CreateThread.StartAddress = Thread->StartAddress;
        }
        Status = DbgkpQueueMessage (Process,
                                    Thread,
                                    &ApiMsg,
                                    Flags,
                                    DebugObject);
        if (!NT_SUCCESS (Status)) {
            if (Flags&DEBUG_EVENT_SUSPEND) {
                PsResumeThread (Thread, NULL);
            }
            if (Flags&DEBUG_EVENT_RELEASE) {
                ExReleaseRundownProtection (&Thread->RundownProtect);
            }
            if (ApiMsg.ApiNumber == DbgKmCreateProcessApi && ApiMsg.u.CreateProcessInfo.FileHandle != NULL) {
                ObCloseHandle (ApiMsg.u.CreateProcessInfo.FileHandle, KernelMode);
            }
            PsQuitNextProcessThread (Thread);
            break;
        } else if (First) {
            First = FALSE;
            ObReferenceObject (Thread);
            FirstThread = Thread;
        }
    }


    if (!NT_SUCCESS (Status)) {
        if (FirstThread) {
            ObDereferenceObject (FirstThread);
        }
        if (LastThread != NULL) {
            ObDereferenceObject (LastThread);
        }
    } else {
        if (FirstThread) {
            *pFirstThread = FirstThread;
            *pLastThread = LastThread;
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }
    }
    return Status;
}

NTSTATUS
DbgkpPostFakeModuleMessages (
    IN PEPROCESS Process,
    IN PETHREAD Thread,
    IN PDEBUG_OBJECT DebugObject)
/*++

Routine Description:

    This routine posts the faked module load messages when we debug an active process.

Arguments:

    ProcessHandle     - Handle to a process to be debugged
    DebugObjectHandle - Handle to a debug object

Return Value:

    None.

--*/
{
    PPEB Peb = Process->Peb;
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY LdrHead, LdrNext;
    PLDR_DATA_TABLE_ENTRY LdrEntry;
    DBGKM_APIMSG ApiMsg;
    ULONG i;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING Name;
    PIMAGE_NT_HEADERS NtHeaders;
    NTSTATUS Status;
    IO_STATUS_BLOCK iosb;

    PAGED_CODE ();

    if (Peb == NULL) {
        return STATUS_SUCCESS;
    }

    try {
        Ldr = Peb->Ldr;

        LdrHead = &Ldr->InLoadOrderModuleList;

        ProbeForReadSmallStructure (LdrHead, sizeof (LIST_ENTRY), sizeof (UCHAR));
        for (LdrNext = LdrHead->Flink, i = 0;
             LdrNext != LdrHead && i < 500;
             LdrNext = LdrNext->Flink, i++) {

            //
            // First image got send with process create message
            //
            if (i > 0) {
                RtlZeroMemory (&ApiMsg, sizeof (ApiMsg));

                LdrEntry = CONTAINING_RECORD (LdrNext, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
                ProbeForReadSmallStructure (LdrEntry, sizeof (LDR_DATA_TABLE_ENTRY), sizeof (UCHAR));

                ApiMsg.ApiNumber = DbgKmLoadDllApi;
                ApiMsg.u.LoadDll.BaseOfDll = LdrEntry->DllBase;

                ProbeForReadSmallStructure (ApiMsg.u.LoadDll.BaseOfDll, sizeof (IMAGE_DOS_HEADER), sizeof (UCHAR));

                NtHeaders = RtlImageNtHeader (ApiMsg.u.LoadDll.BaseOfDll);
                if (NtHeaders) {
                    ApiMsg.u.LoadDll.DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
                    ApiMsg.u.LoadDll.DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
                }
                Status = MmGetFileNameForAddress (NtHeaders, &Name);
                if (NT_SUCCESS (Status)) {
                    InitializeObjectAttributes (&oa,
                                                &Name,
                                                OBJ_FORCE_ACCESS_CHECK|OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                                NULL,
                                                NULL);

                    Status = ZwOpenFile (&ApiMsg.u.LoadDll.FileHandle,
                                         GENERIC_READ|SYNCHRONIZE,
                                         &oa,
                                         &iosb,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                         FILE_SYNCHRONOUS_IO_NONALERT);
                    if (!NT_SUCCESS (Status)) {
                        ApiMsg.u.LoadDll.FileHandle = NULL;
                    }
                    ExFreePool (Name.Buffer);
                }
                Status = DbgkpQueueMessage (Process,
                                            Thread,
                                            &ApiMsg,
                                            DEBUG_EVENT_NOWAIT,
                                            DebugObject);
                if (!NT_SUCCESS (Status) && ApiMsg.u.LoadDll.FileHandle != NULL) {
                    ObCloseHandle (ApiMsg.u.LoadDll.FileHandle, KernelMode);
                }

            }
            ProbeForReadSmallStructure (LdrNext, sizeof (LIST_ENTRY), sizeof (UCHAR));
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
    }

#if defined(_WIN64)
    if (Process->Wow64Process != NULL && Process->Wow64Process->Wow64 != NULL) {
        PPEB32 Peb32;
        PPEB_LDR_DATA32 Ldr32;
        PLIST_ENTRY32 LdrHead32, LdrNext32;
        PLDR_DATA_TABLE_ENTRY32 LdrEntry32;
        PWCHAR pSys;

        Peb32 = (PPEB32)Process->Wow64Process->Wow64;

        try {
            Ldr32 = (PVOID) UlongToPtr(Peb32->Ldr);

            LdrHead32 = &Ldr32->InLoadOrderModuleList;

            ProbeForReadSmallStructure (LdrHead32, sizeof (LIST_ENTRY32), sizeof (UCHAR));
            for (LdrNext32 = (PVOID) UlongToPtr(LdrHead32->Flink), i = 0;
                 LdrNext32 != LdrHead32 && i < 500;
                 LdrNext32 = (PVOID) UlongToPtr(LdrNext32->Flink), i++) {

                if (i > 0) {
                    RtlZeroMemory (&ApiMsg, sizeof (ApiMsg));

                    LdrEntry32 = CONTAINING_RECORD (LdrNext32, LDR_DATA_TABLE_ENTRY32, InLoadOrderLinks);
                    ProbeForReadSmallStructure (LdrEntry32, sizeof (LDR_DATA_TABLE_ENTRY32), sizeof (UCHAR));

                    ApiMsg.ApiNumber = DbgKmLoadDllApi;
                    ApiMsg.u.LoadDll.BaseOfDll = (PVOID) UlongToPtr(LdrEntry32->DllBase);

                    ProbeForReadSmallStructure (ApiMsg.u.LoadDll.BaseOfDll, sizeof (IMAGE_DOS_HEADER), sizeof (UCHAR));

                    NtHeaders = RtlImageNtHeader(ApiMsg.u.LoadDll.BaseOfDll);
                    if (NtHeaders) {
                        ApiMsg.u.LoadDll.DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
                        ApiMsg.u.LoadDll.DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
                    }

                    Status = MmGetFileNameForAddress (NtHeaders, &Name);
                    if (NT_SUCCESS (Status)) {
                        ASSERT (sizeof (L"SYSTEM32") == sizeof (WOW64_SYSTEM_DIRECTORY_U));
                        pSys = wcsstr (Name.Buffer, L"\\SYSTEM32\\");
                        if (pSys != NULL) {
                            RtlCopyMemory (pSys+1,
                                           WOW64_SYSTEM_DIRECTORY_U,
                                           sizeof(WOW64_SYSTEM_DIRECTORY_U) - sizeof(UNICODE_NULL));
                        }

                        InitializeObjectAttributes (&oa,
                                                    &Name,
                                                    OBJ_FORCE_ACCESS_CHECK|OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                                    NULL,
                                                    NULL);

                        Status = ZwOpenFile (&ApiMsg.u.LoadDll.FileHandle,
                                             GENERIC_READ|SYNCHRONIZE,
                                             &oa,
                                             &iosb,
                                             FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                             FILE_SYNCHRONOUS_IO_NONALERT);
                        if (!NT_SUCCESS (Status)) {
                            ApiMsg.u.LoadDll.FileHandle = NULL;
                        }
                        ExFreePool (Name.Buffer);
                    }

                    Status = DbgkpQueueMessage (Process,
                                                Thread,
                                                &ApiMsg,
                                                DEBUG_EVENT_NOWAIT,
                                                DebugObject);
                    if (!NT_SUCCESS (Status) && ApiMsg.u.LoadDll.FileHandle != NULL) {
                        ObCloseHandle (ApiMsg.u.LoadDll.FileHandle, KernelMode);
                    }
                }

                ProbeForReadSmallStructure (LdrNext32, sizeof (LIST_ENTRY32), sizeof (UCHAR));
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

#endif
    return STATUS_SUCCESS;
}

NTSTATUS
DbgkpPostFakeProcessCreateMessages (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN PETHREAD *pLastThread
    )
/*++

Routine Description:

    This routine posts the faked initial process create, thread create and mudule load messages

Arguments:

    ProcessHandle     - Handle to a process to be debugged
    DebugObjectHandle - Handle to a debug object

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    KAPC_STATE ApcState;
    PETHREAD Thread;
    PETHREAD LastThread;

    PAGED_CODE ();

    //
    // Attach to the process so we can touch its address space
    //
    KeStackAttachProcess(&Process->Pcb, &ApcState);

    Status = DbgkpPostFakeThreadMessages (Process,
                                          DebugObject,
                                          NULL,
                                          &Thread,
                                          &LastThread);

    if (NT_SUCCESS (Status)) {
        Status = DbgkpPostFakeModuleMessages (Process, Thread, DebugObject);
        if (!NT_SUCCESS (Status)) {
            ObDereferenceObject (LastThread);
            LastThread = NULL;
        }
        ObDereferenceObject (Thread);
    } else {
        LastThread = NULL;
    }

    KeUnstackDetachProcess(&ApcState);

    *pLastThread = LastThread;

    return Status;
}

NTSTATUS
NtDebugActiveProcess (
    IN HANDLE ProcessHandle,
    IN HANDLE DebugObjectHandle
    )
/*++

Routine Description:

    Attach a debug object to a process.

Arguments:

    ProcessHandle     - Handle to a process to be debugged
    DebugObjectHandle - Handle to a debug object

Return Value:

    NTSTATUS - Status of call.

--*/
{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    PDEBUG_OBJECT DebugObject;
    PEPROCESS Process;
    PETHREAD LastThread;

    PAGED_CODE ();

    PreviousMode = KeGetPreviousMode();

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_PORT,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Don't let us debug ourselves or the system process.
    //
    if (Process == PsGetCurrentProcess () || Process == PsInitialSystemProcess) {
        ObDereferenceObject (Process);
        return STATUS_ACCESS_DENIED;
    }


    Status = ObReferenceObjectByHandle (DebugObjectHandle,
                                        DEBUG_PROCESS_ASSIGN,
                                        DbgkDebugObjectType,
                                        PreviousMode,
                                        &DebugObject,
                                        NULL);

    if (NT_SUCCESS (Status)) {
        //
        // We will be touching process address space. Block process rundown.
        //
        if (ExAcquireRundownProtection (&Process->RundownProtect)) {

            //
            // Post the fake process create messages etc.
            //
            Status = DbgkpPostFakeProcessCreateMessages (Process,
                                                         DebugObject,
                                                         &LastThread);

            //
            // Set the debug port. If this fails it will remove any faked messages.
            //
            Status = DbgkpSetProcessDebugObject (Process,
                                                 DebugObject,
                                                 Status,
                                                 LastThread);

            ExReleaseRundownProtection (&Process->RundownProtect);
        } else {
            Status = STATUS_PROCESS_IS_TERMINATING;
        }

        ObDereferenceObject (DebugObject);
    }
    ObDereferenceObject (Process);

    return Status;
}

NTSTATUS
NtRemoveProcessDebug (
    IN HANDLE ProcessHandle,
    IN HANDLE DebugObjectHandle
    )
/*++

Routine Description:

    Remove a debug object from a process.

Arguments:

    ProcessHandle - Handle to a process currently being debugged

Return Value:

    NTSTATUS - Status of call.

--*/
{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    PDEBUG_OBJECT DebugObject;
    PEPROCESS Process;

    PAGED_CODE ();

    PreviousMode = KeGetPreviousMode();

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_PORT,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }
    Status = ObReferenceObjectByHandle (DebugObjectHandle,
                                        DEBUG_PROCESS_ASSIGN,
                                        DbgkDebugObjectType,
                                        PreviousMode,
                                        &DebugObject,
                                        NULL);
    if (NT_SUCCESS (Status)) {
        Status = DbgkClearProcessDebugObject (Process,
                                               DebugObject);
        ObDereferenceObject (DebugObject);
    }

    ObDereferenceObject (Process);
    return Status;
}

VOID
DbgkpOpenHandles (
    PDBGUI_WAIT_STATE_CHANGE WaitStateChange,
    PEPROCESS Process,
    PETHREAD Thread
    )
/*++

Routine Description:

    Opens up process, thread and filehandles if need be for some of the requests

Arguments:

    WaitStateChange - User mode format change block
    Process - Pointer to target process
    Thread - Pointer to target thread

Return Value:

    None

--*/
{
    NTSTATUS Status;
    PEPROCESS CurrentProcess;
    HANDLE OldHandle;

    PAGED_CODE ();

    switch (WaitStateChange->NewState) {
        case DbgCreateThreadStateChange :
            //
            // We have the right to open up any thread in the process if we are allowed to debug it.
            // Use kernel mode here so we are always granted it regardless of protection.
            //
            Status = ObOpenObjectByPointer (Thread,
                                            0,
                                            NULL,
                                            THREAD_GET_CONTEXT | THREAD_SET_CONTEXT | THREAD_SUSPEND_RESUME | \
                                               THREAD_QUERY_INFORMATION | THREAD_SET_INFORMATION | THREAD_TERMINATE |
                                               READ_CONTROL | SYNCHRONIZE,
                                            PsThreadType,
                                            KernelMode,
                                            &WaitStateChange->StateInfo.CreateThread.HandleToThread);
            if (!NT_SUCCESS (Status)) {
                WaitStateChange->StateInfo.CreateThread.HandleToThread = NULL;
            }
            break;

        case DbgCreateProcessStateChange :

            Status = ObOpenObjectByPointer (Thread,
                                            0,
                                            NULL,
                                            THREAD_GET_CONTEXT | THREAD_SET_CONTEXT | THREAD_SUSPEND_RESUME | \
                                               THREAD_QUERY_INFORMATION | THREAD_SET_INFORMATION | THREAD_TERMINATE |
                                               READ_CONTROL | SYNCHRONIZE,
                                            PsThreadType,
                                            KernelMode,
                                            &WaitStateChange->StateInfo.CreateProcessInfo.HandleToThread);
            if (!NT_SUCCESS (Status)) {
                WaitStateChange->StateInfo.CreateProcessInfo.HandleToThread = NULL;
            }
            Status = ObOpenObjectByPointer (Process,
                                            0,
                                            NULL,
                                            PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION |
                                               PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION | PROCESS_SET_INFORMATION |
                                               PROCESS_CREATE_THREAD | PROCESS_TERMINATE |
                                               READ_CONTROL | SYNCHRONIZE,
                                            PsProcessType,
                                            KernelMode,
                                            &WaitStateChange->StateInfo.CreateProcessInfo.HandleToProcess);
            if (!NT_SUCCESS (Status)) {
                WaitStateChange->StateInfo.CreateProcessInfo.HandleToProcess = NULL;
            }

            OldHandle = WaitStateChange->StateInfo.CreateProcessInfo.NewProcess.FileHandle;
            if (OldHandle != NULL) {
                CurrentProcess = PsGetCurrentProcess ();
                Status = ObDuplicateObject (CurrentProcess,
                                            OldHandle,
                                            CurrentProcess,
                                            &WaitStateChange->StateInfo.CreateProcessInfo.NewProcess.FileHandle,
                                            0,
                                            0,
                                            DUPLICATE_SAME_ACCESS,
                                            KernelMode);
                if (!NT_SUCCESS (Status)) {
                    WaitStateChange->StateInfo.CreateProcessInfo.NewProcess.FileHandle = NULL;
                }
                ObCloseHandle (OldHandle, KernelMode);
            }
            break;

        case DbgLoadDllStateChange :

            OldHandle = WaitStateChange->StateInfo.LoadDll.FileHandle;
            if (OldHandle != NULL) {
                CurrentProcess = PsGetCurrentProcess ();
                Status = ObDuplicateObject (CurrentProcess,
                                            OldHandle,
                                            CurrentProcess,
                                            &WaitStateChange->StateInfo.LoadDll.FileHandle,
                                            0,
                                            0,
                                            DUPLICATE_SAME_ACCESS,
                                            KernelMode);
                if (!NT_SUCCESS (Status)) {
                    WaitStateChange->StateInfo.LoadDll.FileHandle = NULL;
                }
                ObCloseHandle (OldHandle, KernelMode);
            }

            break;

        default :
            break;
    }
}

VOID
DbgkpConvertKernelToUserStateChange (
     PDBGUI_WAIT_STATE_CHANGE WaitStateChange,
     PDEBUG_EVENT DebugEvent)
/*++

Routine Description:

    Converts a kernel message to one the user expects

Arguments:

    WaitStateChange - User mode format
    DebugEvent      - Debug event block to copy from

Return Value:

    None

--*/
{

    PAGED_CODE ();

    WaitStateChange->AppClientId = DebugEvent->ClientId;
    switch (DebugEvent->ApiMsg.ApiNumber) {
        case DbgKmExceptionApi :

            switch (DebugEvent->ApiMsg.u.Exception.ExceptionRecord.ExceptionCode) {
                case STATUS_BREAKPOINT :
                    WaitStateChange->NewState = DbgBreakpointStateChange;
                    break;

                case STATUS_SINGLE_STEP :
                    WaitStateChange->NewState = DbgSingleStepStateChange;
                    break;

                default :
                    WaitStateChange->NewState = DbgExceptionStateChange;
                    break;
            }
            WaitStateChange->StateInfo.Exception = DebugEvent->ApiMsg.u.Exception;
            break;

        case DbgKmCreateThreadApi :
            WaitStateChange->NewState = DbgCreateThreadStateChange;
            WaitStateChange->StateInfo.CreateThread.NewThread = DebugEvent->ApiMsg.u.CreateThread;
            break;

        case DbgKmCreateProcessApi :
            WaitStateChange->NewState = DbgCreateProcessStateChange;
            WaitStateChange->StateInfo.CreateProcessInfo.NewProcess = DebugEvent->ApiMsg.u.CreateProcessInfo;
            //
            // clear out the handle in the message as we will close this when we duplicate.
            //
            DebugEvent->ApiMsg.u.CreateProcessInfo.FileHandle = NULL;
            break;

        case DbgKmExitThreadApi :
            WaitStateChange->NewState = DbgExitThreadStateChange;
            WaitStateChange->StateInfo.ExitThread = DebugEvent->ApiMsg.u.ExitThread;
            break;

        case DbgKmExitProcessApi :
            WaitStateChange->NewState = DbgExitProcessStateChange;
            WaitStateChange->StateInfo.ExitProcess = DebugEvent->ApiMsg.u.ExitProcess;
            break;

        case DbgKmLoadDllApi :
            WaitStateChange->NewState = DbgLoadDllStateChange;
            WaitStateChange->StateInfo.LoadDll = DebugEvent->ApiMsg.u.LoadDll;
            //
            // clear out the handle in the message as we will close this when we duplicate.
            //
            DebugEvent->ApiMsg.u.LoadDll.FileHandle = NULL;
            break;

        case DbgKmUnloadDllApi :
            WaitStateChange->NewState = DbgUnloadDllStateChange;
            WaitStateChange->StateInfo.UnloadDll = DebugEvent->ApiMsg.u.UnloadDll;
            break;

        default :
            ASSERT (FALSE);
    }
}

NTSTATUS
NtWaitForDebugEvent (
    IN HANDLE DebugObjectHandle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    OUT PDBGUI_WAIT_STATE_CHANGE WaitStateChange
    )
/*++

Routine Description:

    Waits for a debug event and returns it to the user if one arives

Arguments:

    DebugObjectHandle - Handle to a debug object
    Alertable - TRUE is the wait is to be alertable
    Timeout - Operation timeout value
    WaitStateChange - Returned debug event

Return Value:

    Status of operation

--*/
{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    PDEBUG_OBJECT DebugObject;
    LARGE_INTEGER Tmo = {0};
    LARGE_INTEGER StartTime = {0};
    DBGUI_WAIT_STATE_CHANGE tWaitStateChange = {0};
    PEPROCESS Process;
    PETHREAD Thread;
    PLIST_ENTRY Entry, Entry2;
    PDEBUG_EVENT DebugEvent, DebugEvent2;
    BOOLEAN GotEvent;

    PAGED_CODE ();

    PreviousMode = KeGetPreviousMode();

    try {
        if (ARGUMENT_PRESENT (Timeout)) {
            if (PreviousMode != KernelMode) {
                ProbeForReadSmallStructure (Timeout, sizeof (*Timeout), sizeof (UCHAR));
            }
            Tmo = *Timeout;
            Timeout = &Tmo;
            KeQuerySystemTime (&StartTime);
        }
        if (PreviousMode != KernelMode) {
            ProbeForWriteSmallStructure (WaitStateChange, sizeof (*WaitStateChange), sizeof (UCHAR));
        }

    } except (ExSystemExceptionFilter ()) { // If previous mode is kernel then don't handle the exception
        return GetExceptionCode ();
    }


    Status = ObReferenceObjectByHandle (DebugObjectHandle,
                                        DEBUG_READ_EVENT,
                                        DbgkDebugObjectType,
                                        PreviousMode,
                                        &DebugObject,
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    Process = NULL;
    Thread = NULL;

    while (1) {
        Status = KeWaitForSingleObject (&DebugObject->EventsPresent,
                                        Executive,
                                        PreviousMode,
                                        Alertable,
                                        Timeout);
        if (!NT_SUCCESS (Status) || Status == STATUS_TIMEOUT || Status == STATUS_ALERTED || Status == STATUS_USER_APC) {
            break;
        }

        GotEvent = FALSE;

        DebugEvent = NULL;

        ExAcquireFastMutex (&DebugObject->Mutex);

        //
        // If the object is delete pending then return an error.
        //
        if ((DebugObject->Flags&DEBUG_OBJECT_DELETE_PENDING) == 0) {


            for (Entry = DebugObject->EventList.Flink;
                 Entry != &DebugObject->EventList;
                 Entry = Entry->Flink) {

                DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);

                //
                // If this event has not been given back to the user yet and is not
                // inactive then pass it back.
                // We check to see if we have any other outstanding messages for this
                // thread as this confuses VC. You can only get multiple events
                // for the same thread for the attach faked messages.
                //
                if ((DebugEvent->Flags&(DEBUG_EVENT_READ|DEBUG_EVENT_INACTIVE)) == 0) {
                    GotEvent = TRUE;
                    for (Entry2 = DebugObject->EventList.Flink;
                         Entry2 != Entry;
                         Entry2 = Entry2->Flink) {

                        DebugEvent2 = CONTAINING_RECORD (Entry2, DEBUG_EVENT, EventList);

                        if (DebugEvent->ClientId.UniqueProcess == DebugEvent2->ClientId.UniqueProcess) {
                            //
                            // This event has the same process as an earlier event. Mark it as inactive.
                            //
                            DebugEvent->Flags |= DEBUG_EVENT_INACTIVE;
                            DebugEvent->BackoutThread = NULL;
                            GotEvent = FALSE;
                            break;
                        }
                    }
                    if (GotEvent) {
                        break;
                    }
                }
            }

            if (GotEvent) {
                Process = DebugEvent->Process;
                Thread = DebugEvent->Thread;
                ObReferenceObject (Thread);
                ObReferenceObject (Process);
                DbgkpConvertKernelToUserStateChange (&tWaitStateChange, DebugEvent);
                DebugEvent->Flags |= DEBUG_EVENT_READ;
            } else {
                //
                // No unread events there. Clear the event.
                //
                KeClearEvent (&DebugObject->EventsPresent);
            }
            Status = STATUS_SUCCESS;

        } else {
            Status = STATUS_DEBUGGER_INACTIVE;
        }

        ExReleaseFastMutex (&DebugObject->Mutex);

        if (NT_SUCCESS (Status)) {
            //
            // If we woke up and found nothing
            //
            if (GotEvent == FALSE) {
                //
                // If timeout is a delta time then adjust it for the wait so far.
                //
                if (Tmo.QuadPart < 0) {
                    LARGE_INTEGER NewTime;
                    KeQuerySystemTime (&NewTime);
                    Tmo.QuadPart = Tmo.QuadPart + (NewTime.QuadPart - StartTime.QuadPart);
                    StartTime = NewTime;
                    if (Tmo.QuadPart >= 0) {
                        Status = STATUS_TIMEOUT;
                        break;
                    }
                }
            } else {
                //
                // Fixup needed handles. The caller could have guessed the thread id etc by now and made the target thread
                // continue. This isn't a problem as we won't do anything damaging to the system in this case. The caller
                // won't get the correct results but they set out to break us.
                //
                DbgkpOpenHandles (&tWaitStateChange, Process, Thread);
                ObDereferenceObject (Thread);
                ObDereferenceObject (Process);
                break;
            }
        } else {
            break;
        }
    }

    ObDereferenceObject (DebugObject);

    try {
        *WaitStateChange = tWaitStateChange;
    } except (ExSystemExceptionFilter ()) { // If previous mode is kernel then don't handle the exception
        Status = GetExceptionCode ();
    }
    return Status;
}

NTSTATUS
NtDebugContinue (
    IN HANDLE DebugObjectHandle,
    IN PCLIENT_ID ClientId,
    IN NTSTATUS ContinueStatus
    )
/*++

Routine Description:

    Coninues a stalled debugged thread

Arguments:

    DebugObjectHandle - Handle to a debug object
    ClientId - ClientId of thread tro continue
    ContinueStatus - Status of continue

Return Value:

    Status of operation

--*/
{
    NTSTATUS Status;
    PDEBUG_OBJECT DebugObject;
    PDEBUG_EVENT DebugEvent, FoundDebugEvent;
    KPROCESSOR_MODE PreviousMode;
    CLIENT_ID Clid;
    PLIST_ENTRY Entry;
    BOOLEAN GotEvent;

    PreviousMode = KeGetPreviousMode();

    try {
        if (PreviousMode != KernelMode) {
            ProbeForReadSmallStructure (ClientId, sizeof (*ClientId), sizeof (UCHAR));
        }
        Clid = *ClientId;

    } except (ExSystemExceptionFilter ()) { // If previous mode is kernel then don't handle the exception
        return GetExceptionCode ();
    }

    switch (ContinueStatus) {
        case DBG_EXCEPTION_HANDLED :
        case DBG_EXCEPTION_NOT_HANDLED :
        case DBG_TERMINATE_THREAD :
        case DBG_TERMINATE_PROCESS :
        case DBG_CONTINUE :
            break;
        default :
            return STATUS_INVALID_PARAMETER;
    }

    Status = ObReferenceObjectByHandle (DebugObjectHandle,
                                        DEBUG_READ_EVENT,
                                        DbgkDebugObjectType,
                                        PreviousMode,
                                        &DebugObject,
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    GotEvent = FALSE;
    FoundDebugEvent = NULL;

    ExAcquireFastMutex (&DebugObject->Mutex);

    for (Entry = DebugObject->EventList.Flink;
         Entry != &DebugObject->EventList;
         Entry = Entry->Flink) {

        DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);

        //
        // Make sure the client ID matches and that the debugger saw all the events.
        // We don't allow the caller to start a thread that it never saw a message for.
        // This would do no harm but its probably a bug in the debugger.
        //
        if (DebugEvent->ClientId.UniqueProcess == Clid.UniqueProcess) {
            if (!GotEvent) {
                if (DebugEvent->ClientId.UniqueThread == Clid.UniqueThread &&
                    (DebugEvent->Flags&DEBUG_EVENT_READ) != 0) {
                    RemoveEntryList (Entry);
                    FoundDebugEvent = DebugEvent;
                    GotEvent = TRUE;
                }
            } else {
                //
                // VC breaks if it sees more than one event at a time
                // for the same process.
                //
                DebugEvent->Flags &= ~DEBUG_EVENT_INACTIVE;
                KeSetEvent (&DebugObject->EventsPresent, 0, FALSE);
                break;
            }
        }
    }

    ExReleaseFastMutex (&DebugObject->Mutex);

    ObDereferenceObject (DebugObject);

    if (GotEvent) {
        FoundDebugEvent->ApiMsg.ReturnedStatus = ContinueStatus;
        FoundDebugEvent->Status = STATUS_SUCCESS;
        DbgkpWakeTarget (FoundDebugEvent);
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

NTSTATUS
NtSetInformationDebugObject (
    IN HANDLE DebugObjectHandle,
    IN DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
    IN PVOID DebugInformation,
    IN ULONG DebugInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
/*++

Routine Description:

    This function sets the state of a debug object.

Arguments:

    ProcessHandle - Supplies a handle to a process object.

    ProcessInformationClass - Supplies the class of information being
        set.

    ProcessInformation - Supplies a pointer to a record that contains the
        information to set.

    ProcessInformationLength - Supplies the length of the record that contains
        the information to set.

Return Value:

    NTSTATUS - Status of call

--*/
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PDEBUG_OBJECT DebugObject;
    ULONG Flags;

    PreviousMode = KeGetPreviousMode();

    try {
        if (PreviousMode != KernelMode) {
            ProbeForRead (DebugInformation,
                          DebugInformationLength,
                          sizeof (ULONG));
            if (ARGUMENT_PRESENT (ReturnLength)) {
                ProbeForWriteUlong (ReturnLength);
            }
        }
        if (ARGUMENT_PRESENT (ReturnLength)) {
            *ReturnLength = 0;
        }

        switch (DebugObjectInformationClass) {
            case DebugObjectFlags : {

                if (DebugInformationLength != sizeof (ULONG)) {
                    if (ARGUMENT_PRESENT (ReturnLength)) {
                        *ReturnLength = sizeof (ULONG);
                    }
                    return STATUS_INFO_LENGTH_MISMATCH;
                }
                Flags = *(PULONG) DebugInformation;

                break;
            }
            default : {
                return STATUS_INVALID_PARAMETER;
            }
        }
    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }


    switch (DebugObjectInformationClass) {
        case DebugObjectFlags : {
            if (Flags & ~DEBUG_KILL_ON_CLOSE) {
                return STATUS_INVALID_PARAMETER;
            }
            Status = ObReferenceObjectByHandle (DebugObjectHandle,
                                                DEBUG_SET_INFORMATION,
                                                DbgkDebugObjectType,
                                                PreviousMode,
                                                &DebugObject,
                                                NULL);

            if (!NT_SUCCESS (Status)) {
                return Status;
            }
            ExAcquireFastMutex (&DebugObject->Mutex);

            if (Flags&DEBUG_KILL_ON_CLOSE) {
                DebugObject->Flags |= DEBUG_OBJECT_KILL_ON_CLOSE;
            } else {
                DebugObject->Flags &= ~DEBUG_OBJECT_KILL_ON_CLOSE;
            }

            ExReleaseFastMutex (&DebugObject->Mutex);

            ObDereferenceObject (DebugObject);
        }
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\dbgk\dbgkp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dbgkp.h

Abstract:

    This header file describes private data structures and functions
    that make up the kernel mode portion of the Dbg subsystem.

Author:

    Mark Lucovsky (markl) 19-Jan-1990

[Environment:]

    optional-environment-info (e.g. kernel mode only...)

[Notes:]

    optional-notes

Revision History:

--*/

#ifndef _DBGKP_
#define _DBGKP_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses

#include "ntos.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include <zwapi.h>
#include <string.h>
#if defined(_WIN64)
#include <wow64t.h>
#endif

#define DEBUG_EVENT_READ            (0x01)  // Event had been seen by win32 app
#define DEBUG_EVENT_NOWAIT          (0x02)  // No waiter one this. Just free the pool
#define DEBUG_EVENT_INACTIVE        (0x04)  // The message is in inactive. It may be activated or deleted later
#define DEBUG_EVENT_RELEASE         (0x08)  // Release rundown protection on this thread
#define DEBUG_EVENT_PROTECT_FAILED  (0x10)  // Rundown protection failed to be acquired on this thread
#define DEBUG_EVENT_SUSPEND         (0x20)  // Resume thread on continue

typedef struct _DEBUG_EVENT {
    LIST_ENTRY EventList;      // Queued to event object through this
    KEVENT ContinueEvent;
    CLIENT_ID ClientId;
    PEPROCESS Process;         // Waiting process
    PETHREAD Thread;           // Waiting thread
    NTSTATUS Status;           // Status of operation
    ULONG Flags;
    PETHREAD BackoutThread;    // Backout key for faked messages
    DBGKM_APIMSG ApiMsg;       // Message being sent
} DEBUG_EVENT, *PDEBUG_EVENT;


NTSTATUS
DbgkpSendApiMessage(
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN BOOLEAN SuspendProcess
    );

BOOLEAN
DbgkpSuspendProcess(
    VOID
    );

VOID
DbgkpResumeProcess(
    VOID
    );

HANDLE
DbgkpSectionToFileHandle(
    IN PVOID SectionObject
    );

VOID
DbgkpDeleteObject (
    IN  PVOID   Object
    );

VOID
DbgkpCloseObject (
    IN PEPROCESS Process,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG ProcessHandleCount,
    IN ULONG SystemHandleCount
    );

NTSTATUS
DbgkpQueueMessage (
    IN PEPROCESS Process,
    IN PETHREAD Thread,
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN ULONG Flags,
    IN PDEBUG_OBJECT TargetDebugObject
    );

VOID
DbgkpOpenHandles (
    PDBGUI_WAIT_STATE_CHANGE WaitStateChange,
    PEPROCESS Process,
    PETHREAD Thread
    );

VOID
DbgkpMarkProcessPeb (
    PEPROCESS Process
    );

VOID
DbgkpConvertKernelToUserStateChange (
    IN OUT PDBGUI_WAIT_STATE_CHANGE WaitStateChange,
    IN PDEBUG_EVENT DebugEvent
    );

NTSTATUS
DbgkpSendApiMessageLpc(
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN PVOID Port,
    IN BOOLEAN SuspendProcess
    );

VOID
DbgkpFreeDebugEvent (
    IN PDEBUG_EVENT DebugEvent
    );

NTSTATUS
DbgkpPostFakeProcessCreateMessages (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN PETHREAD *pLastThread
    );

NTSTATUS
DbgkpPostFakeModuleMessages (
    IN PEPROCESS Process,
    IN PETHREAD Thread,
    IN PDEBUG_OBJECT DebugObject
    );

NTSTATUS
DbgkpPostFakeThreadMessages (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN PETHREAD StartThread,
    OUT PETHREAD *pFirstThread,
    OUT PETHREAD *pLastThread
    );

NTSTATUS
DbgkpPostAdditionalThreadMessages (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN PETHREAD LastThread
    );

VOID
DbgkpWakeTarget (
    IN PDEBUG_EVENT DebugEvent
    );

NTSTATUS
DbgkpSetProcessDebugObject (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN NTSTATUS MsgStatus,
    IN PETHREAD LastThread
    );



#endif // _DBGKP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\dbgk\dbgkport.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dbgkport.c

Abstract:

    This module implements the dbg primitives to access a process'
    DebugPort and ExceptionPort.

Author:

    Mark Lucovsky (markl) 19-Jan-1990

Revision History:

--*/

#include "dbgkp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DbgkpSendApiMessage)
#pragma alloc_text(PAGE, DbgkForwardException)
#pragma alloc_text(PAGE, DbgkpSendApiMessageLpc)
#endif


NTSTATUS
DbgkpSendApiMessage(
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN BOOLEAN SuspendProcess
    )

/*++

Routine Description:

    This function sends the specified API message over the specified
    port. It is the caller's responsibility to format the API message
    prior to calling this function.

    If the SuspendProcess flag is supplied, then all threads in the
    calling process are first suspended. Upon receipt of the reply
    message, the threads are resumed.

Arguments:

    ApiMsg - Supplies the API message to send.

    SuspendProcess - A flag that if set to true, causes all of the
        threads in the process to be suspended prior to the call,
        and resumed upon receipt of a reply.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS st;
    PEPROCESS Process;

    PAGED_CODE();

    if ( SuspendProcess ) {
        SuspendProcess = DbgkpSuspendProcess();
    }

    ApiMsg->ReturnedStatus = STATUS_PENDING;

    Process = PsGetCurrentProcess();

    PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_CREATE_REPORTED);

    st = DbgkpQueueMessage (Process, PsGetCurrentThread (), ApiMsg, 0, NULL);

    ZwFlushInstructionCache (NtCurrentProcess (), NULL, 0);
    if ( SuspendProcess ) {
        DbgkpResumeProcess();
    }

    return st;
}

NTSTATUS
DbgkpSendApiMessageLpc(
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN PVOID Port,
    IN BOOLEAN SuspendProcess
    )

/*++

Routine Description:

    This function sends the specified API message over the specified
    port. It is the caller's responsibility to format the API message
    prior to calling this function.

    If the SuspendProcess flag is supplied, then all threads in the
    calling process are first suspended. Upon receipt of the reply
    message, the threads are resumed.

Arguments:

    ApiMsg - Supplies the API message to send.

    Port - Supplies the address of a port to send the api message.

    SuspendProcess - A flag that if set to true, causes all of the
        threads in the process to be suspended prior to the call,
        and resumed upon receipt of a reply.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS st;
    ULONG_PTR MessageBuffer[PORT_MAXIMUM_MESSAGE_LENGTH/sizeof(ULONG_PTR)];

    PAGED_CODE();

    if ( SuspendProcess ) {
        SuspendProcess = DbgkpSuspendProcess();
    }

    ApiMsg->ReturnedStatus = STATUS_PENDING;

    PS_SET_BITS (&PsGetCurrentProcess()->Flags, PS_PROCESS_FLAGS_CREATE_REPORTED);

    st = LpcRequestWaitReplyPortEx (Port,
                    (PPORT_MESSAGE) ApiMsg,
                    (PPORT_MESSAGE) &MessageBuffer[0]);

    ZwFlushInstructionCache(NtCurrentProcess(), NULL, 0);
    if (NT_SUCCESS (st)) {
        RtlCopyMemory(ApiMsg,MessageBuffer,sizeof(*ApiMsg));
    }

    if (SuspendProcess) {
        DbgkpResumeProcess();
    }

    return st;
}

BOOLEAN
DbgkForwardException(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN BOOLEAN DebugException,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This function is called forward an exception to the calling process's
    debug or subsystem exception port.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    DebugException - Supplies a boolean variable that specifies whether
        this exception is to be forwarded to the process's
        DebugPort(TRUE), or to its ExceptionPort(FALSE).

Return Value:

    TRUE - The process has a DebugPort or an ExceptionPort, and the reply
        received from the port indicated that the exception was handled.

    FALSE - The process either does not have a DebugPort or
        ExceptionPort, or the process has a port, but the reply received
        from the port indicated that the exception was not handled.

--*/

{
    PEPROCESS Process;
    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_EXCEPTION args;
    NTSTATUS st;
    BOOLEAN LpcPort;

    PAGED_CODE();

    args = &m.u.Exception;

    //
    // Initialize the debug LPC message with default infomaation.
    //

    DBGKM_FORMAT_API_MSG(m,DbgKmExceptionApi,sizeof(*args));

    //
    // Get the address of the destination LPC port.
    //

    Process = PsGetCurrentProcess();
    if (DebugException) {
        if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) {
            Port = NULL;
        } else {
            Port = Process->DebugPort;
        }
        LpcPort = FALSE;
    } else {
        Port = Process->ExceptionPort;
        m.h.u2.ZeroInit = LPC_EXCEPTION;
        LpcPort = TRUE;
    }

    //
    // If the destination LPC port address is NULL, then return FALSE.
    //

    if (Port == NULL) {
        return FALSE;
    }

    //
    // Fill in the remainder of the debug LPC message.
    //

    args->ExceptionRecord = *ExceptionRecord;
    args->FirstChance = !SecondChance;

    //
    // Send the debug message to the destination LPC port.
    //

    if (LpcPort) {
        st = DbgkpSendApiMessageLpc(&m,Port,DebugException);
    } else {
        st = DbgkpSendApiMessage(&m,DebugException);
    }


    //
    // If the send was not successful, then return a FALSE indicating that
    // the port did not handle the exception. Otherwise, if the debug port
    // is specified, then look at the return status in the message.
    //

    if (!NT_SUCCESS(st) ||
        ((DebugException) &&
        (m.ReturnedStatus == DBG_EXCEPTION_NOT_HANDLED || !NT_SUCCESS(m.ReturnedStatus)))) {
        return FALSE;

    } else {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\dbgk\dbgkproc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dbgkproc.c

Abstract:

    This module implements process control primitives for the
    Dbg component of NT

Author:

    Mark Lucovsky (markl) 19-Jan-1990

Revision History:

--*/

#include "dbgkp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DbgkpSuspendProcess)
#pragma alloc_text(PAGE, DbgkpResumeProcess)
#pragma alloc_text(PAGE, DbgkpSectionToFileHandle)
#pragma alloc_text(PAGE, DbgkCreateThread)
#pragma alloc_text(PAGE, DbgkExitThread)
#pragma alloc_text(PAGE, DbgkExitProcess)
#pragma alloc_text(PAGE, DbgkMapViewOfSection)
#pragma alloc_text(PAGE, DbgkUnMapViewOfSection)
#endif

BOOLEAN
DbgkpSuspendProcess (
    VOID
    )

/*++

Routine Description:

    This function causes all threads in the calling process except for
    the calling thread to suspend.

Arguments:

    CreateDeleteLockHeld - Supplies a flag that specifies whether or not
        the caller is holding the process create delete lock.  If the
        caller holds the lock, than this function will not aquire the
        lock before suspending the process.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Freeze the execution of all threads in the current process, but
    // the calling thread. If we are in the process of being deleted don't do this.
    //
    if ((PsGetCurrentProcess()->Flags&PS_PROCESS_FLAGS_PROCESS_DELETE) == 0) {
        KeFreezeAllThreads();
        return TRUE;
    }

    return FALSE;
}

VOID
DbgkpResumeProcess (
    VOID
    )

/*++

Routine Description:

    This function causes all threads in the calling process except for
    the calling thread to resume.

Arguments:

    CreateDeleteLockHeld - Supplies a flag that specifies whether or not
        the caller is holding the process create delete lock.  If the
        caller holds the lock, than this function will not aquire the
        lock before suspending the process.

Return Value:

    None.

--*/

{

    PAGED_CODE();

    //
    // Thaw the execution of all threads in the current process, but
    // the calling thread.
    //

    KeThawAllThreads();

    return;
}

HANDLE
DbgkpSectionToFileHandle(
    IN PVOID SectionObject
    )

/*++

Routine Description:

    This function Opens a handle to the file associated with the processes
    section. The file is opened such that it can be dupped all the way to
    the UI where the UI can either map the file or read the file to get
    the debug info.

Arguments:

    SectionHandle - Supplies a handle to the section whose associated file
        is to be opened.

Return Value:

    NULL - The file could not be opened.

    NON-NULL - Returns a handle to the file associated with the specified
        section.

--*/

{
    NTSTATUS Status;
    ANSI_STRING FileName;
    UNICODE_STRING UnicodeFileName;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;

    PAGED_CODE();

    Status = MmGetFileNameForSection(SectionObject, (PSTRING)&FileName);
    if ( !NT_SUCCESS(Status) ) {
        return NULL;
        }

    Status = RtlAnsiStringToUnicodeString(&UnicodeFileName,&FileName,TRUE);
    ExFreePool(FileName.Buffer);
    if ( !NT_SUCCESS(Status) ) {
        return NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &UnicodeFileName,
        OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)(GENERIC_READ | SYNCHRONIZE),
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT
                );
    RtlFreeUnicodeString(&UnicodeFileName);
    if ( !NT_SUCCESS(Status) ) {
        return NULL;
        }
    else {
        return Handle;
        }
}


VOID
DbgkCreateThread(
    PVOID StartAddress
    )

/*++

Routine Description:

    This function is called when a new thread begins to execute. If the
    thread has an associated DebugPort, then a message is sent thru the
    port.

    If this thread is the first thread in the process, then this event
    is translated into a CreateProcessInfo message.

    If a message is sent, then while the thread is awaiting a reply,
    all other threads in the process are suspended.

Arguments:

    StartAddress - Supplies the start address for the thread that is
        starting.

Return Value:

    None.

--*/

{
    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_CREATE_THREAD CreateThreadArgs;
    PDBGKM_CREATE_PROCESS CreateProcessArgs;
    PETHREAD Thread;
    PEPROCESS Process;
    PDBGKM_LOAD_DLL LoadDllArgs;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    PIMAGE_NT_HEADERS NtHeaders;
    PTEB Teb;

    PAGED_CODE();

    Thread = PsGetCurrentThread ();
    Process = PsGetCurrentProcessByThread (Thread);

    if (PsImageNotifyEnabled && !Process->Pcb.UserTime) {
        IMAGE_INFO ImageInfo;
        PIMAGE_NT_HEADERS NtHeaders;
        ANSI_STRING FileName;
        UNICODE_STRING UnicodeFileName;
        PUNICODE_STRING pUnicodeFileName;

        //
        // notification of main .exe
        //
        ImageInfo.Properties = 0;
        ImageInfo.ImageAddressingMode = IMAGE_ADDRESSING_MODE_32BIT;
        ImageInfo.ImageBase = Process->SectionBaseAddress;
        ImageInfo.ImageSize = 0;

        try {
            NtHeaders = RtlImageNtHeader (Process->SectionBaseAddress);
    
            if (NtHeaders) {
                ImageInfo.ImageSize = NtHeaders->OptionalHeader.SizeOfImage;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            ImageInfo.ImageSize = 0;
        }
        ImageInfo.ImageSelector = 0;
        ImageInfo.ImageSectionNumber = 0;

        pUnicodeFileName = NULL;
        Status = MmGetFileNameForSection (Process->SectionObject, (PSTRING)&FileName);
        if (NT_SUCCESS (Status)) {
            Status = RtlAnsiStringToUnicodeString (&UnicodeFileName, &FileName,TRUE);
            ExFreePool (FileName.Buffer);
            if (NT_SUCCESS (Status)) {
                pUnicodeFileName = &UnicodeFileName;
            }
        }
        PsCallImageNotifyRoutines (pUnicodeFileName,
                                   Process->UniqueProcessId,
                                   &ImageInfo);
        if (pUnicodeFileName != NULL) {
            RtlFreeUnicodeString (pUnicodeFileName);
        }

        //
        // and of ntdll.dll
        //
        ImageInfo.Properties = 0;
        ImageInfo.ImageAddressingMode = IMAGE_ADDRESSING_MODE_32BIT;
        ImageInfo.ImageBase = PsSystemDllBase;
        ImageInfo.ImageSize = 0;

        try {
            NtHeaders = RtlImageNtHeader (PsSystemDllBase);
            if ( NtHeaders ) {
                ImageInfo.ImageSize = NtHeaders->OptionalHeader.SizeOfImage;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ImageInfo.ImageSize = 0;
        }

        ImageInfo.ImageSelector = 0;
        ImageInfo.ImageSectionNumber = 0;

        RtlInitUnicodeString (&UnicodeFileName,
                              L"\\SystemRoot\\System32\\ntdll.dll");
        PsCallImageNotifyRoutines (&UnicodeFileName,
                                   Process->UniqueProcessId,
                                   &ImageInfo);
    }


    Port = Process->DebugPort;

    if (Port == NULL) {
        return;
    }

    //
    // If we are doing a debug attach, then the create process has
    // already occured. If this is the case, then the process has
    // accumulated some time, so set reported to true
    //

    if (Process->Pcb.UserTime) {
        PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_CREATE_REPORTED);
    }

    if ((PS_TEST_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_CREATE_REPORTED)&PS_PROCESS_FLAGS_CREATE_REPORTED) == 0) {

        //
        // This is a create process
        //

        CreateThreadArgs = &m.u.CreateProcessInfo.InitialThread;
        CreateThreadArgs->SubSystemKey = 0;

        CreateProcessArgs = &m.u.CreateProcessInfo;
        CreateProcessArgs->SubSystemKey = 0;
        CreateProcessArgs->FileHandle = DbgkpSectionToFileHandle(
                                            Process->SectionObject
                                            );
        CreateProcessArgs->BaseOfImage = Process->SectionBaseAddress;
        CreateThreadArgs->StartAddress = NULL;
        CreateProcessArgs->DebugInfoFileOffset = 0;
        CreateProcessArgs->DebugInfoSize = 0;

        try {
            NtHeaders = RtlImageNtHeader(Process->SectionBaseAddress);
            if ( NtHeaders ) {
                CreateThreadArgs->StartAddress = (PVOID)(
                    NtHeaders->OptionalHeader.ImageBase +
                    NtHeaders->OptionalHeader.AddressOfEntryPoint);

                CreateProcessArgs->DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
                CreateProcessArgs->DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            CreateThreadArgs->StartAddress = NULL;
            CreateProcessArgs->DebugInfoFileOffset = 0;
            CreateProcessArgs->DebugInfoSize = 0;
        }

        DBGKM_FORMAT_API_MSG(m,DbgKmCreateProcessApi,sizeof(*CreateProcessArgs));

        DbgkpSendApiMessage(&m,FALSE);

        if (CreateProcessArgs->FileHandle != NULL) {
            ObCloseHandle(CreateProcessArgs->FileHandle, KernelMode);
        }

        LoadDllArgs = &m.u.LoadDll;
        LoadDllArgs->BaseOfDll = PsSystemDllBase;
        LoadDllArgs->DebugInfoFileOffset = 0;
        LoadDllArgs->DebugInfoSize = 0;

        Teb = NULL;
        try {
            NtHeaders = RtlImageNtHeader(PsSystemDllBase);
            if ( NtHeaders ) {
                LoadDllArgs->DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
                LoadDllArgs->DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
            }

            //
            // Normaly the ntdll loaded fills in this pointer for the debug API's. We fake it here
            // as ntdll isn't loaded yet and it can't load itself.
            //
            Teb = Thread->Tcb.Teb;
            if (Teb != NULL) {
                Teb->NtTib.ArbitraryUserPointer = Teb->StaticUnicodeBuffer;
                wcsncpy (Teb->StaticUnicodeBuffer,
                         L"ntdll.dll",
                         sizeof (Teb->StaticUnicodeBuffer) / sizeof (Teb->StaticUnicodeBuffer[0]));
            }
            
        } except (EXCEPTION_EXECUTE_HANDLER) {
            LoadDllArgs->DebugInfoFileOffset = 0;
            LoadDllArgs->DebugInfoSize = 0;
        }

        //
        // Send load dll section for NT dll !
        //

        InitializeObjectAttributes(
            &Obja,
            (PUNICODE_STRING)&PsNtDllPathName,
            OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

        Status = ZwOpenFile(
                    &LoadDllArgs->FileHandle,
                    (ACCESS_MASK)(GENERIC_READ | SYNCHRONIZE),
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_SYNCHRONOUS_IO_NONALERT
                    );

        if (!NT_SUCCESS (Status)) {
            LoadDllArgs->FileHandle = NULL;
        }

        DBGKM_FORMAT_API_MSG(m,DbgKmLoadDllApi,sizeof(*LoadDllArgs));
        DbgkpSendApiMessage(&m,TRUE);

        if (LoadDllArgs->FileHandle != NULL) {
            ObCloseHandle(LoadDllArgs->FileHandle, KernelMode);
        }

        if (Teb != NULL) {
            try {
                Teb->NtTib.ArbitraryUserPointer = NULL;
            } except(EXCEPTION_EXECUTE_HANDLER) {
            }
        }

    } else {

        CreateThreadArgs = &m.u.CreateThread;
        CreateThreadArgs->SubSystemKey = 0;
        CreateThreadArgs->StartAddress = StartAddress;

        DBGKM_FORMAT_API_MSG (m,DbgKmCreateThreadApi,sizeof(*CreateThreadArgs));

        DbgkpSendApiMessage (&m,TRUE);
    }
}

VOID
DbgkExitThread(
    NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function is called when a new thread terminates. At this
    point, the thread will no longer execute in user-mode. No other
    exit processing has occured.

    If a message is sent, then while the thread is awaiting a reply,
    all other threads in the process are suspended.

Arguments:

    ExitStatus - Supplies the ExitStatus of the exiting thread.

Return Value:

    None.

--*/

{
    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_EXIT_THREAD args;
    PEPROCESS Process;
    BOOLEAN Frozen;

    PAGED_CODE();

    Process = PsGetCurrentProcess();
    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) {
        Port = NULL;
    } else {
        Port = Process->DebugPort;
    }

    if ( !Port ) {
        return;
    }

    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_DEADTHREAD) {
        return;
    }

    args = &m.u.ExitThread;
    args->ExitStatus = ExitStatus;

    DBGKM_FORMAT_API_MSG(m,DbgKmExitThreadApi,sizeof(*args));

    Frozen = DbgkpSuspendProcess();

    DbgkpSendApiMessage(&m,FALSE);

    if (Frozen) {
        DbgkpResumeProcess();
    }
}

VOID
DbgkExitProcess(
    NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function is called when a process terminates. The address
    space of the process is still intact, but no threads exist in
    the process.

Arguments:

    ExitStatus - Supplies the ExitStatus of the exiting process.

Return Value:

    None.

--*/

{
    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_EXIT_PROCESS args;
    PEPROCESS Process;

    PAGED_CODE();

    Process = PsGetCurrentProcess();

    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) {
        Port = NULL;
    } else {
        Port = Process->DebugPort;
    }

    if ( !Port ) {
        return;
    }

    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_DEADTHREAD) {
        return;
    }

    //
    // this ensures that other timed lockers of the process will bail
    // since this call is done while holding the process lock, and lock duration
    // is controlled by debugger
    //
    KeQuerySystemTime(&PsGetCurrentProcess()->ExitTime);

    args = &m.u.ExitProcess;
    args->ExitStatus = ExitStatus;

    DBGKM_FORMAT_API_MSG(m,DbgKmExitProcessApi,sizeof(*args));

    DbgkpSendApiMessage(&m,FALSE);

}

VOID
DbgkMapViewOfSection(
    IN PVOID SectionObject,
    IN PVOID BaseAddress,
    IN ULONG SectionOffset,
    IN ULONG_PTR ViewSize
    )

/*++

Routine Description:

    This function is called when the current process successfully
    maps a view of an image section. If the process has an associated
    debug port, then a load dll message is sent.

Arguments:

    SectionObject - Supplies a pointer to the section mapped by the
        process.

    BaseAddress - Supplies the base address of where the section is
        mapped in the current process address space.

    SectionOffset - Supplies the offset in the section where the
        processes mapped view begins.

    ViewSize - Supplies the size of the mapped view.

Return Value:

    None.

--*/

{

    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_LOAD_DLL LoadDllArgs;
    PEPROCESS Process;
    PIMAGE_NT_HEADERS NtHeaders;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (SectionOffset);
    UNREFERENCED_PARAMETER (ViewSize);

    if ( KeGetPreviousMode() == KernelMode ) {
        return;
    }

    Process = PsGetCurrentProcess();

    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) {
        Port = NULL;
    } else {
        Port = Process->DebugPort;
    }

    if ( !Port ) {
        return;
    }

    LoadDllArgs = &m.u.LoadDll;
    LoadDllArgs->FileHandle = DbgkpSectionToFileHandle(SectionObject);
    LoadDllArgs->BaseOfDll = BaseAddress;
    LoadDllArgs->DebugInfoFileOffset = 0;
    LoadDllArgs->DebugInfoSize = 0;

    try {
        NtHeaders = RtlImageNtHeader(BaseAddress);
        if ( NtHeaders ) {
            LoadDllArgs->DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
            LoadDllArgs->DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
            }
        }
    except(EXCEPTION_EXECUTE_HANDLER) {
        LoadDllArgs->DebugInfoFileOffset = 0;
        LoadDllArgs->DebugInfoSize = 0;
    }

    DBGKM_FORMAT_API_MSG(m,DbgKmLoadDllApi,sizeof(*LoadDllArgs));

    DbgkpSendApiMessage(&m,TRUE);
    if (LoadDllArgs->FileHandle != NULL) {
        ObCloseHandle(LoadDllArgs->FileHandle, KernelMode);
    }
}

VOID
DbgkUnMapViewOfSection(
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This function is called when the current process successfully
    un maps a view of an image section. If the process has an associated
    debug port, then an "unmap view of section" message is sent.

Arguments:

    BaseAddress - Supplies the base address of the section being
        unmapped.

Return Value:

    None.

--*/

{

    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_UNLOAD_DLL UnloadDllArgs;
    PEPROCESS Process;

    PAGED_CODE();

    Process = PsGetCurrentProcess();

    if ( KeGetPreviousMode() == KernelMode ) {
        return;
    }

    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) {
        Port = NULL;
    } else {
        Port = Process->DebugPort;
    }

    if ( !Port ) {
        return;
    }

    UnloadDllArgs = &m.u.UnloadDll;
    UnloadDllArgs->BaseAddress = BaseAddress;

    DBGKM_FORMAT_API_MSG(m,DbgKmUnloadDllApi,sizeof(*UnloadDllArgs));

    DbgkpSendApiMessage(&m,TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\dbgk\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=dbgk

TARGETNAME=dbgk
TARGETTYPE=LIBRARY
TARGETPATH=obj

INCLUDES=..;..\..\inc;$(SDKTOOLS_INC_PATH)

MSC_WARNING_LEVEL=/W4 /WX

SOURCES=..\dbgkport.c \
        ..\dbgkproc.c \
        ..\dbgkobj.c

UMTEST=udbgk

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\dbgk\udbgk.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    udbg.c

Abstract:

    Usermode test for debugger

Author:

    Mark Lucovsky (markl) 19-Jan-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdbg.h>

HANDLE DebugPort;


NTSTATUS
ThreadThatExits (
    IN PVOID ThreadParameter
    )
{
    NtTerminateThread(NtCurrentThread(),(NTSTATUS) ThreadParameter );
}

ULONG
foo(PULONG l)
{
    //ULONG x;
    //x = *l;
    //return x + 1;

    return *l;

}

NTSTATUS
ThreadThatExcepts (
    IN PVOID ThreadParameter
    )
{
    foo((PULONG)0x00000001);
    NtTerminateThread(NtCurrentThread(),(NTSTATUS) ThreadParameter );
}



NTSTATUS
ThreadThatSpins (
    IN PVOID ThreadParameter
    )
{
    for(;;);
    NtTerminateThread(NtCurrentThread(),STATUS_SUCCESS);
}


UdbgTest1()
{
    NTSTATUS st;
    HANDLE ExitThread, SpinThread, DebugProcess;
    CLIENT_ID ExitClientId, SpinClientId;
    DBGKM_APIMSG m;
    PDBGKM_CREATE_THREAD CreateThreadArgs;
    PDBGKM_CREATE_PROCESS CreateProcessArgs;
    PDBGKM_EXIT_THREAD ExitThreadArgs;
    PDBGKM_EXIT_PROCESS ExitProcessArgs;
    ULONG Psp;

    DbgPrint("UdbgTest1: (1)...\n");

        //
        // Verify that a process can be created with a debug
        // port.
        //

        st = NtCreateProcess(
                &DebugProcess,
                PROCESS_ALL_ACCESS,
                NULL,
                NtCurrentProcess(),
                FALSE,
                NULL,
                DebugPort,
                NULL
                );
        ASSERT(NT_SUCCESS(st));

        st = RtlCreateUserThread(
                DebugProcess,
                NULL,
                TRUE,
                0L,
                0L,
                0L,
                ThreadThatExits,
                (PVOID) STATUS_ABANDONED,
                &ExitThread,
                &ExitClientId
                );
        ASSERT(NT_SUCCESS(st));

        st = RtlCreateUserThread(
                DebugProcess,
                NULL,
                TRUE,
                0L,
                0L,
                0L,
                ThreadThatSpins,
                NULL,
                &SpinThread,
                &SpinClientId
                );
        ASSERT(NT_SUCCESS(st));

    DbgPrint("UdbgTest1: (2)...\n");

        //
        // Verify that CreateProcess Messages Arrive, and that
        // they are correct
        //

        st = NtResumeThread(SpinThread,NULL);
        ASSERT(NT_SUCCESS(st));

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmCreateProcessApi);

        CreateThreadArgs = &m.u.CreateProcess.InitialThread;
        CreateProcessArgs = &m.u.CreateProcess;
        ASSERT( CreateThreadArgs->SubSystemKey == 0 && CreateThreadArgs->StartAddress == (PVOID)ThreadThatSpins );
        ASSERT( CreateProcessArgs->SubSystemKey == 0);

    DbgPrint("UdbgTest1: (3)...\n");

        //
        // Verify that other threads in the process are properly suspended
        //

        st = NtSuspendThread(ExitThread,&Psp);
        ASSERT(NT_SUCCESS(st) && Psp == 2);

        st = NtResumeThread(ExitThread,&Psp);
        ASSERT(NT_SUCCESS(st) && Psp == 3);

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));


    DbgPrint("UdbgTest1: (4)...\n");

        //
        // Verify that CreateThread Messages Arrive, and that
        // they are correct
        //

        st = NtResumeThread(ExitThread,&Psp);
        ASSERT(NT_SUCCESS(st));

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmCreateThreadApi);

        CreateThreadArgs = &m.u.CreateThread;
        ASSERT( CreateThreadArgs->SubSystemKey == 0 && CreateThreadArgs->StartAddress == (PVOID)ThreadThatExits );

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));

    DbgPrint("UdbgTest1: (5)...\n");

        //
        // Verify that ExitThread Messages Arrive, and that
        // they are correct
        //

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmExitThreadApi);

        ExitThreadArgs = &m.u.ExitThread;
        ASSERT( ExitThreadArgs->ExitStatus == STATUS_ABANDONED );

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));

        st = NtWaitForSingleObject(ExitThread,FALSE,NULL);
        ASSERT(NT_SUCCESS(st));

    DbgPrint("UdbgTest1: (6)...\n");

        //
        // Verify that ExitThread Messages Arrive, and that
        // they are correct
        //

        st = NtTerminateProcess(DebugProcess,STATUS_REPARSE);
        ASSERT(NT_SUCCESS(st));

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmExitThreadApi);

        ExitThreadArgs = &m.u.ExitThread;
        ASSERT( ExitThreadArgs->ExitStatus == STATUS_REPARSE );

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));

    DbgPrint("UdbgTest1: (7)...\n");

        //
        // Verify that ExitProcess Messages Arrive, and that
        // they are correct
        //

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmExitProcessApi);

        ExitProcessArgs = &m.u.ExitProcess;
        ASSERT( ExitProcessArgs->ExitStatus == STATUS_REPARSE );

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));


        st = NtWaitForSingleObject(ExitThread,FALSE,NULL);
        ASSERT(NT_SUCCESS(st));

        st = NtWaitForSingleObject(DebugProcess,FALSE,NULL);
        ASSERT(NT_SUCCESS(st));

    NtClose(ExitThread);
    NtClose(SpinThread);
    NtClose(DebugProcess);

    DbgPrint("UdbgTest1: END OF TEST ***\n");

}

UdbgTest2()
{
    NTSTATUS st;
    HANDLE ExceptionThread, DebugProcess;
    DBGKM_APIMSG m;
    PDBGKM_CREATE_THREAD CreateThreadArgs;
    PDBGKM_CREATE_PROCESS CreateProcessArgs;
    PDBGKM_EXIT_THREAD ExitThreadArgs;
    PDBGKM_EXIT_PROCESS ExitProcessArgs;
    PDBGKM_EXCEPTION ExceptionArgs;
    ULONG Psp;

    DbgPrint("UdbgTest2: (1)...\n");

        //
        // Verify that a process can be created with a debug
        // port.
        //

        st = NtCreateProcess(
                &DebugProcess,
                PROCESS_ALL_ACCESS,
                NULL,
                NtCurrentProcess(),
                FALSE,
                NULL,
                DebugPort,
                NULL
                );
        ASSERT(NT_SUCCESS(st));

        st = RtlCreateUserThread(
                DebugProcess,
                NULL,
                TRUE,
                0L,
                0L,
                0L,
                ThreadThatExcepts,
                (PVOID) STATUS_ABANDONED,
                &ExceptionThread,
                NULL
                );
        ASSERT(NT_SUCCESS(st));

    DbgPrint("UdbgTest2: (2)...\n");

        //
        // Verify that CreateThread Messages Arrive, and that
        // they are correct
        //

        st = NtResumeThread(ExceptionThread,NULL);
        ASSERT(NT_SUCCESS(st));

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmCreateProcessApi);

        CreateThreadArgs = &m.u.CreateProcess.InitialThread;
        CreateProcessArgs = &m.u.CreateProcess;
        ASSERT( CreateThreadArgs->SubSystemKey == 0 && CreateThreadArgs->StartAddress == (PVOID)ThreadThatExcepts );
        ASSERT( CreateProcessArgs->SubSystemKey == 0);

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));

    DbgPrint("UdbgTest2: (3)...\n");

        //
        // Verify that First Chance Exception Messages Arrive, and that
        // they are correct
        //

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmExceptionApi);

        ExceptionArgs = &m.u.Exception;
        ASSERT( ExceptionArgs->FirstChance == TRUE );

        m.ReturnedStatus = DBG_EXCEPTION_NOT_HANDLED;

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));

    DbgPrint("UdbgTest2: (4)...\n");

        //
        // Verify that First Chance Exception Messages Arrive, and that
        // they are correct
        //

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmExceptionApi);

        ExceptionArgs = &m.u.Exception;
        ASSERT( ExceptionArgs->FirstChance == FALSE );

        m.ReturnedStatus = DBG_EXCEPTION_HANDLED;
skip4:
        st = NtTerminateProcess(DebugProcess,STATUS_REPARSE);
        ASSERT(NT_SUCCESS(st));

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmExitThreadApi);

        ExitThreadArgs = &m.u.ExitThread;
        ASSERT( ExitThreadArgs->ExitStatus == STATUS_REPARSE );

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));

    DbgPrint("UdbgTest2: (5)...\n");

        //
        // Verify that ExitProcess Messages Arrive, and that
        // they are correct
        //

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmExitProcessApi);

        ExitProcessArgs = &m.u.ExitProcess;
        ASSERT( ExitProcessArgs->ExitStatus == STATUS_REPARSE );

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));


        st = NtWaitForSingleObject(ExceptionThread,FALSE,NULL);
        ASSERT(NT_SUCCESS(st));

        st = NtWaitForSingleObject(DebugProcess,FALSE,NULL);
        ASSERT(NT_SUCCESS(st));

    NtClose(ExceptionThread);
    NtClose(DebugProcess);

    DbgPrint("UdbgTest2: END OF TEST ***\n");
}

main()
{
    NTSTATUS st;
    OBJECT_ATTRIBUTES Obja;

    InitializeObjectAttributes(&Obja, NULL, 0, NULL, NULL);

    st = NtCreatePort(
            &DebugPort,
            &Obja,
            0L,
            256,
            256 * 16
            );
    ASSERT(NT_SUCCESS(st));

    UdbgTest2();
    UdbgTest1();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\callback.c ===
/*++

Copyright (c) 1989-1995  Microsoft Corporation

Module Name:

    callback.c

Abstract:

   This module implements the executive callbaqck object. Functions are
   provided to open, register, unregister , and notify callback objects.

Author:

    Ken Reneris  (kenr) 7-March-1995

    Neill Clift  (NeillC) 17-Feb-2001

    Added low overhead callbacks for critical components like thread/registry etc.
    These routines have a high probability of not requiring any locks for an
    individual call.

Environment:

    Kernel mode only.

Revision History:

--*/


#include "exp.h"

//
// Callback Specific Access Rights.
//

#define CALLBACK_MODIFY_STATE    0x0001

#define CALLBACK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|\
                             CALLBACK_MODIFY_STATE )



//
// Event to wait for registration to become idle
//

KEVENT ExpCallbackEvent;


//
// Lock used when fast referencing fails.
//
EX_PUSH_LOCK ExpCallBackFlush;

//
// Debug flag to force certain code paths. Let it get optimized away on free builds.
//
#if DBG

BOOLEAN ExpCallBackReturnRefs = FALSE;

#else

const
BOOLEAN ExpCallBackReturnRefs = FALSE;

#endif

//
// Address of callback object type descriptor.
//

POBJECT_TYPE ExCallbackObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for callback objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING ExpCallbackMapping = {
    STANDARD_RIGHTS_READ ,
    STANDARD_RIGHTS_WRITE | CALLBACK_MODIFY_STATE,
    STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE,
    CALLBACK_ALL_ACCESS
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

//
// Executive callback object structure definition.
//

typedef struct _CALLBACK_OBJECT {
    ULONG               Signature;
    KSPIN_LOCK          Lock;
    LIST_ENTRY          RegisteredCallbacks;
    BOOLEAN             AllowMultipleCallbacks;
    UCHAR               reserved[3];
} CALLBACK_OBJECT , *PCALLBACK_OBJECT;

//
// Executive callback registration structure definition.
//

typedef struct _CALLBACK_REGISTRATION {
    LIST_ENTRY          Link;
    PCALLBACK_OBJECT    CallbackObject;
    PCALLBACK_FUNCTION  CallbackFunction;
    PVOID               CallbackContext;
    ULONG               Busy;
    BOOLEAN             UnregisterWaiting;
} CALLBACK_REGISTRATION , *PCALLBACK_REGISTRATION;


VOID
ExpDeleteCallback (
    IN PCALLBACK_OBJECT     CallbackObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpInitializeCallbacks)
#pragma alloc_text(PAGE, ExCreateCallback)
#pragma alloc_text(PAGE, ExpDeleteCallback)
#pragma alloc_text(PAGE, ExInitializeCallBack)
#pragma alloc_text(PAGE, ExCompareExchangeCallBack)
#pragma alloc_text(PAGE, ExCallCallBack)
#pragma alloc_text(PAGE, ExFreeCallBack)
#pragma alloc_text(PAGE, ExAllocateCallBack)
#pragma alloc_text(PAGE, ExReferenceCallBackBlock)
#pragma alloc_text(PAGE, ExGetCallBackBlockRoutine)
#pragma alloc_text(PAGE, ExWaitForCallBacks)
#pragma alloc_text(PAGE, ExGetCallBackBlockContext)
#pragma alloc_text(PAGE, ExDereferenceCallBackBlock)
#endif

BOOLEAN
ExpInitializeCallbacks (
    )

/*++

Routine Description:

    This function creates the callback object type descriptor at system
    initialization and stores the address of the object type descriptor
    in local static storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the timer object type descriptor is
    successfully initialized. Otherwise a value of FALSE is returned.

--*/

{
    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    UNICODE_STRING unicodeString;
    ULONG           i;
    HANDLE          handle;

    //
    // Initialize the slow referencing lock
    //
    ExInitializePushLock (&ExpCallBackFlush);

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&unicodeString, L"Callback");

    //
    // Create timer object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpCallbackMapping;
    ObjectTypeInitializer.DeleteProcedure = ExpDeleteCallback;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.ValidAccessMask = CALLBACK_ALL_ACCESS;
    Status = ObCreateObjectType(&unicodeString,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExCallbackObjectType);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    RtlInitUnicodeString( &unicodeString, ExpWstrCallback );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        SePublicDefaultSd
        );

    Status = NtCreateDirectoryObject(
                &handle,
                DIRECTORY_ALL_ACCESS,
                &ObjectAttributes
            );

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    NtClose (handle);

    //
    // Initialize event to wait on for Unregisters which occur while
    // notifications are in progress
    //

    KeInitializeEvent (&ExpCallbackEvent, NotificationEvent, 0);

    //
    // Initialize NT global callbacks
    //

    for (i=0; ExpInitializeCallback[i].CallBackObject; i++) {

        //
        // Create named calledback
        //

        RtlInitUnicodeString(&unicodeString, ExpInitializeCallback[i].CallbackName);


        InitializeObjectAttributes(
            &ObjectAttributes,
            &unicodeString,
            OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
        );

        Status = ExCreateCallback (
                        ExpInitializeCallback[i].CallBackObject,
                        &ObjectAttributes,
                        TRUE,
                        TRUE
                        );

        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }
    }

    return TRUE;
}

NTSTATUS
ExCreateCallback (
    OUT PCALLBACK_OBJECT * CallbackObject,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN Create,
    IN BOOLEAN AllowMultipleCallbacks
    )

/*++

Routine Description:

    This function opens a callback object with the specified callback
    object. If the callback object does not exist or it is a NULL then
    a callback object will be created if create is TRUE. If a callbackobject
    is created it will only support multiple registered callbacks if
    AllowMulitipleCallbacks is TRUE.

Arguments:

    CallbackObject - Supplies a pointer to a variable that will receive the
        Callback object.

    CallbackName  - Supplies a pointer to a object name that will receive the

    Create - Supplies a flag which indicates whether a callback object will
        be created or not .

    AllowMultipleCallbacks - Supplies a flag which indicates only support
        mulitiple registered callbacks.

Return Value:

    NTSTATUS.

--*/

{
    PCALLBACK_OBJECT cbObject;
    NTSTATUS Status;
    HANDLE Handle;

    PAGED_CODE();

    //
    // Initializing cbObject & Handle is not needed for correctness but without
    // it the compiler cannot compile this code W4 to check for use of
    // uninitialized variables.
    //

    Handle = NULL;
    cbObject = NULL;

    //
    // If named callback, open handle to it
    //

    if (ObjectAttributes->ObjectName) {
        Status = ObOpenObjectByName(ObjectAttributes,
                                    ExCallbackObjectType,
                                    KernelMode,
                                    NULL,
                                    0,   // DesiredAccess,
                                    NULL,
                                    &Handle);
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    //
    // If not opened, check if callback should be created
    //

    if (!NT_SUCCESS(Status) && Create ) {

        Status = ObCreateObject(KernelMode,
                                ExCallbackObjectType,
                                ObjectAttributes,
                                KernelMode,
                                NULL,
                                sizeof(CALLBACK_OBJECT),
                                0,
                                0,
                                (PVOID *)&cbObject );

        if(NT_SUCCESS(Status)){

            //
            // Fill in structure signature
            //

            cbObject->Signature = 'llaC';

            //
            // It will support multiple registered callbacks if
            // AllowMultipleCallbacks is TRUE.
            //

            cbObject->AllowMultipleCallbacks = AllowMultipleCallbacks;

            //
            // Initialize CallbackObject queue.
            //

            InitializeListHead( &cbObject->RegisteredCallbacks );

            //
            // Initialize spinlock
            //

            KeInitializeSpinLock (&cbObject->Lock);


            //
            // Put the object in the root directory
            //

            Status = ObInsertObject (
                     cbObject,
                     NULL,
                     FILE_READ_DATA,
                     0,
                     NULL,
                     &Handle );

        }

    }

    if(NT_SUCCESS(Status)){

        //
        // Add one to callback object reference count.
        //

        Status = ObReferenceObjectByHandle (
                    Handle,
                    0,          // DesiredAccess
                    ExCallbackObjectType,
                    KernelMode,
                    &cbObject,
                    NULL
                    );

        ZwClose (Handle);
    }

    //
    // If success, returns a referenced pointer to the CallbackObject.
    //

    if (NT_SUCCESS(Status)) {
        *CallbackObject = cbObject;
    }

    return Status;
}

VOID
ExpDeleteCallback (
    IN PCALLBACK_OBJECT     CallbackObject
    )
{
#if !DBG
    UNREFERENCED_PARAMETER (CallbackObject);
#endif

    ASSERT (IsListEmpty(&CallbackObject->RegisteredCallbacks));
}

PVOID
ExRegisterCallback (
    IN PCALLBACK_OBJECT   CallbackObject,
    IN PCALLBACK_FUNCTION CallbackFunction,
    IN PVOID CallbackContext
    )

/*++

Routine Description:

    This routine allows a caller to register that it would like to have its
    callback Function invoked when the callback notification call occurs.

Arguments:

    CallbackObject - Supplies a pointer to a CallbackObject.

    CallbackFunction - Supplies a pointer to a function which is to
        be executed when the Callback notification occures.

    CallbackContext - Supplies a pointer to an arbitrary data structure
        that will be passed to the function specified by the CallbackFunction
        parameter.

Return Value:

    Returns handle to callback registration.

--*/
{
    PCALLBACK_REGISTRATION  CallbackRegistration;
    BOOLEAN                 Inserted;
    KIRQL                   OldIrql;

    ASSERT (CallbackFunction);
    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Add reference to object
    //

    ObReferenceObject (CallbackObject);

    //
    // Begin by attempting to allocate storage for the CallbackRegistration.
    // one cannot be allocated, return the error status.
    //

    CallbackRegistration = ExAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof( CALLBACK_REGISTRATION ),
                                'eRBC'
                                );


    if( !CallbackRegistration ) {
       ObDereferenceObject (CallbackObject);
       return NULL;
    }


    //
    // Initialize the callback packet
    //

    CallbackRegistration->CallbackObject    = CallbackObject;
    CallbackRegistration->CallbackFunction  = CallbackFunction;
    CallbackRegistration->CallbackContext   = CallbackContext;
    CallbackRegistration->Busy              = 0;
    CallbackRegistration->UnregisterWaiting = FALSE;


    Inserted = FALSE;
    KeAcquireSpinLock (&CallbackObject->Lock, &OldIrql);

    if( CallbackObject->AllowMultipleCallbacks ||
        IsListEmpty( &CallbackObject->RegisteredCallbacks ) ) {

       //
       // add CallbackRegistration to tail
       //


       Inserted = TRUE;
       InsertTailList( &CallbackObject->RegisteredCallbacks,
                       &CallbackRegistration->Link );
    }

    KeReleaseSpinLock (&CallbackObject->Lock, OldIrql);

    if (!Inserted) {
       ExFreePool (CallbackRegistration);
       CallbackRegistration = NULL;
    }

    return (PVOID) CallbackRegistration;
}


VOID
ExUnregisterCallback (
    IN PVOID CbRegistration
    )

/*++

Routine Description:

    This function removes the callback registration for the callbacks
    from the list of callback object .

Arguments:

    CallbackRegistration - Pointer to device object for the file system.

Return Value:

    None.

--*/

{
    PCALLBACK_REGISTRATION  CallbackRegistration;
    PCALLBACK_OBJECT        CallbackObject;
    KIRQL                   OldIrql;

    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    CallbackRegistration = (PCALLBACK_REGISTRATION) CbRegistration;
    CallbackObject = CallbackRegistration->CallbackObject;

    KeAcquireSpinLock (&CallbackObject->Lock, &OldIrql);

    //
    // Wait for registration
    //

    while (CallbackRegistration->Busy) {

        //
        // Set waiting flag, then wait.  (not performance critical - use
        // single global event to wait for any and all unregister waits)
        //

        CallbackRegistration->UnregisterWaiting = TRUE;
        KeClearEvent (&ExpCallbackEvent);
        KeReleaseSpinLock (&CallbackObject->Lock, OldIrql);

        KeWaitForSingleObject (
            &ExpCallbackEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
        );

        //
        // Synchronize with callback object and recheck registration busy
        //

        KeAcquireSpinLock (&CallbackObject->Lock, &OldIrql);
    }

    //
    // Registration not busy, remove it from the callback object
    //

    RemoveEntryList (&CallbackRegistration->Link);
    KeReleaseSpinLock (&CallbackObject->Lock, OldIrql);

    //
    // Free memory used for CallbackRegistration
    //

    ExFreePool (CallbackRegistration);

    //
    // Remove reference count on CallbackObject
    //

    ObDereferenceObject (CallbackObject);
}

VOID
ExNotifyCallback (
    IN PCALLBACK_OBJECT     CallbackObject,
    IN PVOID                Argument1,
    IN PVOID                Argument2
    )

/*++

Routine Description:

    This function notifies all registered callbacks .

Arguments:

    CallbackObject - supplies a pointer to the callback object should be
            notified.

    SystemArgument1 - supplies a pointer will be passed to callback function.

    SystemArgument2 - supplies a pointer will be passed to callback function.

Return Value:

    None.

--*/

{
    PLIST_ENTRY             Link;
    PCALLBACK_REGISTRATION  CallbackRegistration;
    KIRQL                   OldIrql;

    if (CallbackObject == NULL) {
        return ;
    }

    //
    // Synchronize with callback object
    //

    KeAcquireSpinLock (&CallbackObject->Lock, &OldIrql);

    //
    // call registered callbacks at callers IRQL level
    // ( done if FIFO order of registration )
    //

    if (OldIrql == DISPATCH_LEVEL) {

        //
        // OldIrql is DISPATCH_LEVEL, just invoke all callbacks without
        // releasing the lock
        //

        for (Link = CallbackObject->RegisteredCallbacks.Flink;
             Link != &CallbackObject->RegisteredCallbacks;
             Link = Link->Flink) {

            //
            // Get current registration to notify
            //

            CallbackRegistration = CONTAINING_RECORD (Link,
                                                      CALLBACK_REGISTRATION,
                                                      Link);

            //
            // Notify reigstration
            //

            CallbackRegistration->CallbackFunction(
                       CallbackRegistration->CallbackContext,
                       Argument1,
                       Argument2
                       );

        }   // next registration

    } else {

        //
        // OldIrql is < DISPATCH_LEVEL, the code being called may be pagable
        // and the callback object spinlock needs to be released around
        // each registration callback.
        //

        for (Link = CallbackObject->RegisteredCallbacks.Flink;
             Link != &CallbackObject->RegisteredCallbacks;
             Link = Link->Flink ) {

            //
            // Get current registration to notify
            //

            CallbackRegistration = CONTAINING_RECORD (Link,
                                                      CALLBACK_REGISTRATION,
                                                      Link);

            //
            // If registration is being removed, don't bothing calling it
            //

            if (!CallbackRegistration->UnregisterWaiting) {

                //
                // Set registration busy
                //

                CallbackRegistration->Busy += 1;

                //
                // Release SpinLock and notify this callback
                //

                KeReleaseSpinLock (&CallbackObject->Lock, OldIrql);

                CallbackRegistration->CallbackFunction(
                           CallbackRegistration->CallbackContext,
                           Argument1,
                           Argument2
                           );

                //
                // Synchronize with CallbackObject
                //

                KeAcquireSpinLock (&CallbackObject->Lock, &OldIrql);

                //
                // Remove our busy count
                //

                CallbackRegistration->Busy -= 1;

                //
                // If the registriation removal is pending, kick global
                // event let unregister conitnue
                //

                if (CallbackRegistration->UnregisterWaiting  &&
                    CallbackRegistration->Busy == 0) {
                    KeSetEvent (&ExpCallbackEvent, 0, FALSE);
                }
            }
        }
    }


    //
    // Release callback
    //

    KeReleaseSpinLock (&CallbackObject->Lock, OldIrql);
}

VOID
ExInitializeCallBack (
    IN OUT PEX_CALLBACK CallBack
    )
/*++

Routine Description:

    This function initializes a low overhead callback.

Arguments:

    CallBack - Pointer to the callback structure

Return Value:

    None.

--*/
{
    ExFastRefInitialize (&CallBack->RoutineBlock, NULL);
}


PEX_CALLBACK_ROUTINE_BLOCK
ExAllocateCallBack (
    IN PEX_CALLBACK_FUNCTION Function,
    IN PVOID Context
    )
/*++

Routine Description:

    This function allocates a low overhead callback.

Arguments:

    Function - Routine to issue callbacks to
    Context  - A context value to issue

Return Value:

    PEX_CALLBACK_ROUTINE_BLOCK - Allocated block or NULL if allocation fails.

--*/
{
    PEX_CALLBACK_ROUTINE_BLOCK NewBlock;

    NewBlock = ExAllocatePoolWithTag (PagedPool,
                                      sizeof (EX_CALLBACK_ROUTINE_BLOCK),
                                      'brbC');
    if (NewBlock != NULL) {
        NewBlock->Function = Function;
        NewBlock->Context = Context;
        ExInitializeRundownProtection (&NewBlock->RundownProtect);
    }
    return NewBlock;
}

VOID
ExFreeCallBack (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    )
/*++

Routine Description:

    This function destroys a low overhead callback block.

Arguments:

    CallBackBlock - Call back block to destroy

Return Value:

    None.

--*/
{

    ExFreePool (CallBackBlock);
}

VOID
ExWaitForCallBacks (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    )
/*++

Routine Description:

    This function waits for all outcalls on the specified
    callback block to complete

Arguments:

    CallBackBlock - Call back block to wait for

Return Value:

    None.

--*/
{
    //
    // Wait for all active callbacks to be finished.
    //
    ExWaitForRundownProtectionRelease (&CallBackBlock->RundownProtect);
}


BOOLEAN
ExCompareExchangeCallBack (
    IN OUT PEX_CALLBACK CallBack,
    IN PEX_CALLBACK_ROUTINE_BLOCK NewBlock,
    IN PEX_CALLBACK_ROUTINE_BLOCK OldBlock
    )
/*++

Routine Description:

    This function assigns, removes or swaps a low overhead callback function.

Arguments:

    CallBack - Callback structure to be modified

    NewBlock - New block to be installed in the callback

    OldBlock - The old block that must be there now to be replaced

Return Value:

    BOOLEAN - TRUE: The swap occured, FALSE: The swap failed

--*/
{
    EX_FAST_REF OldRef;
    PEX_CALLBACK_ROUTINE_BLOCK ReplacedBlock;

    if (NewBlock != NULL) {
        //
        // Add the additional references to the routine block
        //
        if (!ExAcquireRundownProtectionEx (&NewBlock->RundownProtect,
                                           ExFastRefGetAdditionalReferenceCount () + 1)) {
            ASSERTMSG ("Callback block is already undergoing rundown", FALSE);
            return FALSE;
        }
    }

    //
    // Attempt to replace the existing object and balance all the reference counts
    //
    OldRef = ExFastRefCompareSwapObject (&CallBack->RoutineBlock,
                                         NewBlock,
                                         OldBlock);

    ReplacedBlock = ExFastRefGetObject (OldRef);

    //
    // See if the swap occured. If it didn't undo the original references we added.
    // If it did then release remaining references on the original
    //
    if (ReplacedBlock == OldBlock) {
        PKTHREAD CurrentThread;
        //
        // We need to flush out any slow referencers at this point. We do this by
        // acquiring and releasing a lock.
        //
        if (ReplacedBlock != NULL) {
            CurrentThread = KeGetCurrentThread ();

            KeEnterCriticalRegionThread (CurrentThread);

            ExAcquireReleasePushLockExclusive (&ExpCallBackFlush);

            KeLeaveCriticalRegionThread (CurrentThread);

            ExReleaseRundownProtectionEx (&ReplacedBlock->RundownProtect,
                                          ExFastRefGetUnusedReferences (OldRef) + 1);

        }
        return TRUE;
    } else {
        //
        // The swap failed. Remove the addition references if we had added any.
        //
        if (NewBlock != NULL) {
            ExReleaseRundownProtectionEx (&NewBlock->RundownProtect,
                                          ExFastRefGetAdditionalReferenceCount () + 1);
        }
        return FALSE;
    }
}

PEX_CALLBACK_ROUTINE_BLOCK
ExReferenceCallBackBlock (
    IN OUT PEX_CALLBACK CallBack
    )
/*++

Routine Description:

    This function takes a reference on the call back block inside the
    callback structure.

Arguments:

    CallBack - Call back to obtain the call back block from

Return Value:

    PEX_CALLBACK_ROUTINE_BLOCK - Referenced structure or NULL if these wasn't one

--*/
{
    EX_FAST_REF OldRef;
    PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock;

    //
    // Get a reference to the callback block if we can.
    //
    OldRef = ExFastReference (&CallBack->RoutineBlock);

    //
    // If there is no callback then return
    //
    if (ExFastRefObjectNull (OldRef)) {
        return NULL;
    }
    //
    // If we didn't get a reference then use a lock to get one.
    //
    if (!ExFastRefCanBeReferenced (OldRef)) {
        PKTHREAD CurrentThread;
        CurrentThread = KeGetCurrentThread ();

        KeEnterCriticalRegionThread (CurrentThread);

        ExAcquirePushLockExclusive (&ExpCallBackFlush);

        CallBackBlock = ExFastRefGetObject (CallBack->RoutineBlock);
        if (CallBackBlock && !ExAcquireRundownProtection (&CallBackBlock->RundownProtect)) {
            CallBackBlock = NULL;
        }

        ExReleasePushLockExclusive (&ExpCallBackFlush);

        KeLeaveCriticalRegionThread (CurrentThread);

        if (CallBackBlock == NULL) {
            return NULL;
        }

    } else {
        CallBackBlock = ExFastRefGetObject (OldRef);

        //
        // If we just removed the last reference then attempt fix it up.
        //
        if (ExFastRefIsLastReference (OldRef) && !ExpCallBackReturnRefs) {
            ULONG RefsToAdd;

            RefsToAdd = ExFastRefGetAdditionalReferenceCount ();

            //
            // If we can't add the references then just give up
            //
            if (ExAcquireRundownProtectionEx (&CallBackBlock->RundownProtect,
                                              RefsToAdd)) {
                //
                // Repopulate the cached refs. If this fails we just give them back.
                //
                if (!ExFastRefAddAdditionalReferenceCounts (&CallBack->RoutineBlock,
                                                            CallBackBlock,
                                                            RefsToAdd)) {
                    ExReleaseRundownProtectionEx (&CallBackBlock->RundownProtect,
                                                  RefsToAdd);
                }
            }
        }
    }

    return CallBackBlock;
}

PEX_CALLBACK_FUNCTION
ExGetCallBackBlockRoutine (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    )
/*++

Routine Description:

    This function gets the routine associated with a call back block

Arguments:

    CallBackBlock - Call back block to obtain routine for

Return Value:

    PEX_CALLBACK_FUNCTION - The function pointer associated with this block

--*/
{
    return CallBackBlock->Function;
}

PVOID
ExGetCallBackBlockContext (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    )
/*++

Routine Description:

    This function gets the context associated with a call back block

Arguments:

    CallBackBlock - Call back block to obtain context for

Return Value:

    PVOID - The context associated with this block

--*/
{
    return CallBackBlock->Context;
}


VOID
ExDereferenceCallBackBlock (
    IN OUT PEX_CALLBACK CallBack,
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    )
/*++

Routine Description:

    This returns a reference previous obtained on a call back block

Arguments:

    CallBackBlock - Call back block to return reference to

Return Value:

    None

--*/
{
    if (ExpCallBackReturnRefs || !ExFastRefDereference (&CallBack->RoutineBlock, CallBackBlock)) {
        ExReleaseRundownProtection (&CallBackBlock->RundownProtect);
    }
}


NTSTATUS
ExCallCallBack (
    IN OUT PEX_CALLBACK CallBack,
    IN PVOID Argument1,
    IN PVOID Argument2
    )
/*++

Routine Description:

    This function calls the callback thats inside a callback structure

Arguments:

    CallBack - Call back that needs to be called through

    Argument1 - Caller provided argument to pass on

    Argument2 - Caller provided argument to pass on

Return Value:

    NTSTATUS - Status returned by callback or STATUS_SUCCESS if theres wasn't one

--*/
{
    PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock;
    NTSTATUS Status;

    CallBackBlock = ExReferenceCallBackBlock (CallBack);
    if (CallBackBlock) {
        //
        // Call the function
        //
        Status = CallBackBlock->Function (CallBackBlock->Context, Argument1, Argument2);

        ExDereferenceCallBackBlock (CallBack, CallBackBlock);
    } else {
        Status = STATUS_SUCCESS;
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\dbgctrl.c ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    dbgctrl.c

Abstract:

    This module implements the NtDebugControl service

Author:

    Chuck Lenzmeier (chuckl) 2-Dec-1992

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

#pragma hdrstop
#include "kdp.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, NtSystemDebugControl)
#endif


NTSTATUS
NtSystemDebugControl (
    IN SYSDBG_COMMAND Command,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function controls the system debugger.

Arguments:

    Command - The command to be executed.  One of the following:

        SysDbgQueryTraceInformation
        SysDbgSetTracepoint
        SysDbgSetSpecialCall
        SysDbgClearSpecialCalls
        SysDbgQuerySpecialCalls

    InputBuffer - A pointer to a buffer describing the input data for
        the request, if any.  The structure of this buffer varies
        depending upon Command.

    InputBufferLength - The length in bytes of InputBuffer.

    OutputBuffer - A pointer to a buffer that is to receive the output
        data for the request, if any.  The structure of this buffer
        varies depending upon Command.

    OutputBufferLength - The length in bytes of OutputBuffer.

    ReturnLength - A optional pointer to a ULONG that is to receive the
        output data length for the request.

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The Command parameter did not
            specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the Length field in the
            Parameters buffer was not correct.

        STATUS_ACCESS_VIOLATION - Either the Parameters buffer pointer
            or a pointer within the Parameters buffer specified an
            invalid address.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG length = 0;
    KPROCESSOR_MODE PreviousMode;
    PVOID LockedBuffer = NULL;
    PVOID LockVariable = NULL;

    PreviousMode = KeGetPreviousMode();

    if (!SeSinglePrivilegeCheck( SeDebugPrivilege, PreviousMode)) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Operate within a try block in order to catch errors.
    //

    try {

        //
        // Probe input and output buffers, if previous mode is not
        // kernel.
        //

        if ( PreviousMode != KernelMode ) {

            if ( InputBufferLength != 0 ) {
                ProbeForRead( InputBuffer, InputBufferLength, sizeof(ULONG) );
            }

            if ( OutputBufferLength != 0 ) {
                ProbeForWrite( OutputBuffer, OutputBufferLength, sizeof(ULONG) );
            }

            if ( ARGUMENT_PRESENT(ReturnLength) ) {
                ProbeForWriteUlong( ReturnLength );
            }
        }

        //
        // Switch on the command code.
        //

        switch ( Command ) {

#if i386

        case SysDbgQueryTraceInformation:

            status = KdGetTraceInformation(
                        OutputBuffer,
                        OutputBufferLength,
                        &length
                        );

            break;

        case SysDbgSetTracepoint:

            if ( InputBufferLength != sizeof(DBGKD_MANIPULATE_STATE64) ) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            KdSetInternalBreakpoint( InputBuffer );

            break;

        case SysDbgSetSpecialCall:

            if ( InputBufferLength != sizeof(PVOID) ) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            KdSetSpecialCall( InputBuffer, NULL );

            break;

        case SysDbgClearSpecialCalls:

            KdClearSpecialCalls( );

            break;

        case SysDbgQuerySpecialCalls:

            status = KdQuerySpecialCalls(
                        OutputBuffer,
                        OutputBufferLength,
                        &length
                        );

            break;

#endif

        case SysDbgBreakPoint:
            if (KdDebuggerEnabled) {
                DbgBreakPointWithStatus(DBG_STATUS_DEBUG_CONTROL);
            } else {
                status = STATUS_UNSUCCESSFUL;
            }
            break;

        case SysDbgQueryVersion:
            if (OutputBufferLength != sizeof(DBGKD_GET_VERSION64)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            KdpSysGetVersion((PDBGKD_GET_VERSION64)OutputBuffer);
            status = STATUS_SUCCESS;
            break;
            
        case SysDbgReadVirtual:
            if (InputBufferLength != sizeof(SYSDBG_VIRTUAL)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                PSYSDBG_VIRTUAL Cmd = (PSYSDBG_VIRTUAL)InputBuffer;

                status = ExLockUserBuffer(Cmd->Buffer,
                                          Cmd->Request,
                                          &LockedBuffer,
                                          &LockVariable);
                if (!NT_SUCCESS(status)) {
                    break;
                }
            
                status = KdpCopyMemoryChunks((ULONG_PTR)Cmd->Address,
                                             LockedBuffer,
                                             Cmd->Request, 0,
                                             0,
                                             &length);
            }
            break;
            
        case SysDbgWriteVirtual:
            if (InputBufferLength != sizeof(SYSDBG_VIRTUAL)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                PSYSDBG_VIRTUAL Cmd = (PSYSDBG_VIRTUAL)InputBuffer;
                
                status = ExLockUserBuffer(Cmd->Buffer,
                                          Cmd->Request,
                                          &LockedBuffer,
                                          &LockVariable);
                if (!NT_SUCCESS(status)) {
                    break;
                }
            
                status = KdpCopyMemoryChunks((ULONG_PTR)Cmd->Address,
                                             LockedBuffer,
                                             Cmd->Request, 0,
                                             MMDBG_COPY_WRITE,
                                             &length);
            }
            break;
            
        case SysDbgReadPhysical:
            if (InputBufferLength != sizeof(SYSDBG_PHYSICAL)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                PSYSDBG_PHYSICAL Cmd = (PSYSDBG_PHYSICAL)InputBuffer;
                
                status = ExLockUserBuffer(Cmd->Buffer,
                                          Cmd->Request,
                                          &LockedBuffer,
                                          &LockVariable);
                if (!NT_SUCCESS(status)) {
                    break;
                }
            
                status = KdpCopyMemoryChunks(Cmd->Address.QuadPart,
                                             LockedBuffer,
                                             Cmd->Request, 0,
                                             MMDBG_COPY_PHYSICAL,
                                             &length);
            }
            break;
            
        case SysDbgWritePhysical:
            if (InputBufferLength != sizeof(SYSDBG_PHYSICAL)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                PSYSDBG_PHYSICAL Cmd = (PSYSDBG_PHYSICAL)InputBuffer;
                
                status = ExLockUserBuffer(Cmd->Buffer,
                                          Cmd->Request,
                                          &LockedBuffer,
                                          &LockVariable);
                if (!NT_SUCCESS(status)) {
                    break;
                }
            
                status = KdpCopyMemoryChunks(Cmd->Address.QuadPart,
                                             LockedBuffer,
                                             Cmd->Request, 0,
                                             MMDBG_COPY_WRITE |
                                             MMDBG_COPY_PHYSICAL,
                                             &length);
            }
            break;

        case SysDbgReadControlSpace:
            if (InputBufferLength != sizeof(SYSDBG_CONTROL_SPACE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                PSYSDBG_CONTROL_SPACE Cmd = (PSYSDBG_CONTROL_SPACE)InputBuffer;
                
                status = ExLockUserBuffer(Cmd->Buffer,
                                          Cmd->Request,
                                          &LockedBuffer,
                                          &LockVariable);
                if (!NT_SUCCESS(status)) {
                    break;
                }
            
                status = KdpSysReadControlSpace(Cmd->Processor,
                                                Cmd->Address, LockedBuffer,
                                                Cmd->Request, &length);
            }
            break;

        case SysDbgWriteControlSpace:
            if (InputBufferLength != sizeof(SYSDBG_CONTROL_SPACE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                PSYSDBG_CONTROL_SPACE Cmd = (PSYSDBG_CONTROL_SPACE)InputBuffer;
                
                status = ExLockUserBuffer(Cmd->Buffer,
                                          Cmd->Request,
                                          &LockedBuffer,
                                          &LockVariable);
                if (!NT_SUCCESS(status)) {
                    break;
                }
                
                status = KdpSysWriteControlSpace(Cmd->Processor,
                                                 Cmd->Address, LockedBuffer,
                                                 Cmd->Request, &length);
            }
            break;

        case SysDbgReadIoSpace:
            if (InputBufferLength != sizeof(SYSDBG_IO_SPACE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                PSYSDBG_IO_SPACE Cmd = (PSYSDBG_IO_SPACE)InputBuffer;
                
                status = KdpSysReadIoSpace(Cmd->InterfaceType,
                                           Cmd->BusNumber,
                                           Cmd->AddressSpace,
                                           Cmd->Address, Cmd->Buffer,
                                           Cmd->Request, &length);
            }
            break;

        case SysDbgWriteIoSpace:
            if (InputBufferLength != sizeof(SYSDBG_IO_SPACE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                PSYSDBG_IO_SPACE Cmd = (PSYSDBG_IO_SPACE)InputBuffer;
                
                status = KdpSysWriteIoSpace(Cmd->InterfaceType,
                                            Cmd->BusNumber,
                                            Cmd->AddressSpace,
                                            Cmd->Address, Cmd->Buffer,
                                            Cmd->Request, &length);
            }
            break;

        case SysDbgReadMsr:
            if (InputBufferLength != sizeof(SYSDBG_MSR)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                PSYSDBG_MSR Cmd = (PSYSDBG_MSR)InputBuffer;
                
                status = KdpSysReadMsr(Cmd->Msr, &Cmd->Data);
            }
            break;

        case SysDbgWriteMsr:
            if (InputBufferLength != sizeof(SYSDBG_MSR)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                PSYSDBG_MSR Cmd = (PSYSDBG_MSR)InputBuffer;
                
                status = KdpSysWriteMsr(Cmd->Msr, &Cmd->Data);
            }
            break;

        case SysDbgReadBusData:
            if (InputBufferLength != sizeof(SYSDBG_BUS_DATA)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                PSYSDBG_BUS_DATA Cmd = (PSYSDBG_BUS_DATA)InputBuffer;
                
                status = KdpSysReadBusData(Cmd->BusDataType,
                                           Cmd->BusNumber, Cmd->SlotNumber,
                                           Cmd->Address, Cmd->Buffer,
                                           Cmd->Request, &length);
            }
            break;

        case SysDbgWriteBusData:
            if (InputBufferLength != sizeof(SYSDBG_BUS_DATA)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                PSYSDBG_BUS_DATA Cmd = (PSYSDBG_BUS_DATA)InputBuffer;
                
                status = KdpSysWriteBusData(Cmd->BusDataType,
                                            Cmd->BusNumber, Cmd->SlotNumber,
                                            Cmd->Address, Cmd->Buffer,
                                            Cmd->Request, &length);
            }
            break;

        case SysDbgCheckLowMemory:
            status = KdpSysCheckLowMemory();
            break;
            
        default:

            //
            // Invalid Command.
            //

            status = STATUS_INVALID_INFO_CLASS;
        }

        if ( ARGUMENT_PRESENT(ReturnLength) ) {
            *ReturnLength = length;
        }
    }

    except ( EXCEPTION_EXECUTE_HANDLER ) {

        status = GetExceptionCode();

    }

    if (LockedBuffer) {
        ExUnlockUserBuffer(LockVariable);
    }
    
    return status;

} // NtSystemDebugControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\delay.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    delay.c

Abstract:

   This module implements the executive delay execution system service.

Author:

    David N. Cutler (davec) 13-May-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtDelayExecution)
#endif


NTSTATUS
NtDelayExecution (
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER DelayInterval
    )

/*++

Routine Description:

    This function delays the execution of the current thread for the specified
    interval of time.

Arguments:

    Alertable - Supplies a boolean value that specifies whether the delay
        is alertable.

    DelayInterval - Supplies the absolute of relative time over which the
        delay is to occur.

Return Value:

    NTSTATUS.

--*/

{

    LARGE_INTEGER Interval;
    KPROCESSOR_MODE PreviousMode;

    //
    // Establish an exception handler and probe delay interval address. If
    // the probe fails, then return the exception code as the service status.
    // Otherwise return the status value returned by the delay execution
    // routine.
    //
    // Get previous processor mode and probe delay interval address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {
        try {
            ProbeForReadSmallStructure (DelayInterval, sizeof(LARGE_INTEGER), sizeof(ULONG));
            Interval = *DelayInterval;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }
    else {
        Interval = *DelayInterval;
    }

    //
    // Delay execution for the specified amount of time.
    //

    return KeDelayExecutionThread(PreviousMode, Alertable, &Interval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\callperf.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    callperf.c

Abstract:

   This module implements the functions necessary to collect call data.

Author:

    David N. Cutler (davec) 22-May-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

VOID
ExInitializeCallData (
    IN PCALL_PERFORMANCE_DATA CallData
    )

/*++

Routine Description:

    This function initializes a call performance data structure.

Arguments:

    CallData - Supplies a pointer to the call performance data structure
        that is initialized.

Return Value:

    None.

--*/

{

    ULONG Index;

    //
    // Initialize the spinlock and listheads for the call performance
    // data structure.
    //

    KeInitializeSpinLock(&CallData->SpinLock);
    for (Index = 0; Index < CALL_HASH_TABLE_SIZE; Index += 1) {
        InitializeListHead(&CallData->HashTable[Index]);
    }
}

VOID
ExRecordCallerInHashTable (
    IN PCALL_PERFORMANCE_DATA CallData,
    IN PVOID CallersAddress,
    IN PVOID CallersCaller
    )

/*++

Routine Description:

    This function records call data in the specified call performance
    data structure.

Arguments:

    CallData - Supplies a pointer to the call performance data structure
        in which the call data is recorded.

    CallersAddress - Supplies the address of the caller of a fucntion.

    CallersCaller - Supplies the address of the caller of a caller of
        a function.

Return Value:

    None.

--*/

{

    PCALL_HASH_ENTRY HashEntry;
    ULONG Hash;
    PCALL_HASH_ENTRY MatchEntry;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;

    //
    // If the initialization phase is not zero, then collect call performance
    // data.
    //

    if (InitializationPhase != 0) {

        //
        // Acquire the call performance data structure spinlock.
        //

        ExAcquireSpinLock(&CallData->SpinLock, &OldIrql);

        //
        // Lookup the callers address in call performance data hash table. If
        // the address does not exist in the table, then create a new entry.
        //

        Hash = (ULONG)((ULONG_PTR)CallersAddress ^ (ULONG_PTR)CallersCaller);
        Hash = ((Hash >> 24) ^ (Hash >> 16) ^ (Hash >> 8) ^ (Hash)) & (CALL_HASH_TABLE_SIZE - 1);
        MatchEntry = NULL;
        NextEntry = CallData->HashTable[Hash].Flink;
        while (NextEntry != &CallData->HashTable[Hash]) {
            HashEntry = CONTAINING_RECORD(NextEntry,
                                          CALL_HASH_ENTRY,
                                          ListEntry);

            if ((HashEntry->CallersAddress == CallersAddress) &&
                (HashEntry->CallersCaller == CallersCaller)) {
                MatchEntry = HashEntry;
                break;
            }

            NextEntry = NextEntry->Flink;
        }

        //
        // If a matching caller address was found, then update the call site
        // statistics. Otherwise, allocate a new hash entry and initialize
        // call site statistics.
        //

        if (MatchEntry != NULL) {
            MatchEntry->CallCount += 1;

        } else {
            MatchEntry = ExAllocatePoolWithTag(NonPagedPool,
                                              sizeof(CALL_HASH_ENTRY),
                                              'CdHe');

            if (MatchEntry != NULL) {
                MatchEntry->CallersAddress = CallersAddress;
                MatchEntry->CallersCaller = CallersCaller;
                MatchEntry->CallCount = 1;
                InsertTailList(&CallData->HashTable[Hash],
                               &MatchEntry->ListEntry);
            }
        }

        //
        // Release the call performance data structure spinlock.
        //

        ExReleaseSpinLock(&CallData->SpinLock, OldIrql);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\eventpr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eventpr.c

Abstract:

    This module implements the executive event pair object.  Functions
    are provided to create, open, waitlow, waithi, setlow, sethi,
    sethiwaitlo, setlowaithi.

Author:

    Mark Lucovsky (markl) 18-Oct-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

//
// Define performance counters.
//

ULONG EvPrSetHigh = 0;
ULONG EvPrSetLow = 0;

//
// Address of event pair object type descriptor.
//

POBJECT_TYPE ExEventPairObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for event pair objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING ExpEventPairMapping = {
    STANDARD_RIGHTS_READ |
        SYNCHRONIZE,
    STANDARD_RIGHTS_WRITE |
        SYNCHRONIZE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    EVENT_PAIR_ALL_ACCESS
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpEventPairInitialization)
#pragma alloc_text(PAGE, NtCreateEventPair)
#pragma alloc_text(PAGE, NtOpenEventPair)
#pragma alloc_text(PAGE, NtWaitLowEventPair)
#pragma alloc_text(PAGE, NtWaitHighEventPair)
#pragma alloc_text(PAGE, NtSetLowWaitHighEventPair)
#pragma alloc_text(PAGE, NtSetHighWaitLowEventPair)
#pragma alloc_text(PAGE, NtSetHighEventPair)
#pragma alloc_text(PAGE, NtSetLowEventPair)
#endif

BOOLEAN
ExpEventPairInitialization (
    )

/*++

Routine Description:

    This function creates the event pair object type descriptor at system
    initialization and stores the address of the object type descriptor
    in global storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the event pair object type descriptor is
    successfully initialized. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"EventPair");

    //
    // Create event object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpEventPairMapping;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(EEVENT_PAIR);
    ObjectTypeInitializer.ValidAccessMask = EVENT_PAIR_ALL_ACCESS;
    ObjectTypeInitializer.UseDefaultObject = TRUE;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExEventPairObjectType);

    //
    // If the event pair object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

NTSTATUS
NtCreateEventPair (
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    )

/*++

Routine Description:

    This function creates an event pair object, sets it initial state,
    and opens a handle to the object with the specified desired access.

Arguments:

    EventPairHandle - Supplies a pointer to a variable that will receive the
        event pair object handle.

    DesiredAccess - Supplies the desired types of access for the event
        pair object.

    ObjectAttributes - Supplies a pointer to an object attributes
        structure.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to create an event object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object insertion routine.
    //

    //
    // Get previous processor mode and probe output handle address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(EventPairHandle);
        } except (ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Allocate event object.
    //

    Status = ObCreateObject(PreviousMode,
                            ExEventPairObjectType,
                            ObjectAttributes,
                            PreviousMode,
                            NULL,
                            sizeof(EEVENT_PAIR),
                            0,
                            0,
                            (PVOID *)&EventPair);

    //
    // If the event pair object was successfully allocated, then
    // initialize the event pair object and attempt to insert the
    // event pair object in the current process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeEventPair(&EventPair->KernelEventPair);
        Status = ObInsertObject((PVOID)EventPair,
                                NULL,
                                DesiredAccess,
                                0,
                                (PVOID *)NULL,
                                &Handle);

        //
        // If the event pair object was successfully inserted in the
        // current process' handle table, then attempt to write the
        // event pair object handle value.  If the write attempt
        // fails, then do not report an error.  When the caller
        // attempts to access the handle value, an access violation
        // will occur.

        if (NT_SUCCESS(Status)) {
            if (PreviousMode != KernelMode) {
                try {
                    *EventPairHandle = Handle;

                } except(ExSystemExceptionFilter()) {
                    NOTHING;
                }
            }
            else {
                *EventPairHandle = Handle;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtOpenEventPair(
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to an event pair object with the specified
    desired access.

Arguments:

    EventPairHandle - Supplies a pointer to a variable that will receive
        the event pair object handle.

    DesiredAccess - Supplies the desired types of access for the event
        pair object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    NTSTATUS.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to open the event object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object open routine.
    //

    //
    // Get previous processor mode and probe output handle address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(EventPairHandle);
        } except (ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Open handle to the event pair object with the specified
    // desired access.
    //

    Status = ObOpenObjectByName(ObjectAttributes,
                                ExEventPairObjectType,
                                PreviousMode,
                                NULL,
                                DesiredAccess,
                                NULL,
                                &Handle);

    //
    // If the open was successful, then attempt to write the event
    // pair object handle value.  If the write attempt fails, then do
    // not report an error.  When the caller attempts to access the
    // handle value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        if (PreviousMode != KernelMode) {
            try {
                *EventPairHandle = Handle;

            } except(ExSystemExceptionFilter()) {
                NOTHING;
            }
        }
        else {
            *EventPairHandle = Handle;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtWaitLowEventPair(
    IN HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function waits on the low event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       (PVOID *)&EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        Status = KeWaitForLowEventPair(&EventPair->KernelEventPair,
                                       PreviousMode,
                                       FALSE,
                                       NULL);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtWaitHighEventPair(
    IN HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function waits on the high event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       (PVOID *)&EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        Status = KeWaitForHighEventPair(&EventPair->KernelEventPair,
                                        PreviousMode,
                                        FALSE,
                                        NULL);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetLowWaitHighEventPair(
    IN HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function sets the low event of an event pair and then
    waits on the high event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       (PVOID *)&EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        EvPrSetLow += 1;
        Status = KeSetLowWaitHighEventPair(&EventPair->KernelEventPair,
                                           PreviousMode);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetHighWaitLowEventPair(
    IN HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function sets the high event of an event pair and then
    waits on the low event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       (PVOID *)&EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        EvPrSetHigh += 1;
        Status = KeSetHighWaitLowEventPair(&EventPair->KernelEventPair,
                                           PreviousMode);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetLowEventPair(
    IN HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function sets the low event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       (PVOID *)&EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        EvPrSetLow += 1;
        KeSetLowEventPair(&EventPair->KernelEventPair,
                          EVENT_PAIR_INCREMENT,FALSE);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetHighEventPair(
    IN HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function sets the high event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       (PVOID *)&EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        EvPrSetHigh += 1;
        KeSetHighEventPair(&EventPair->KernelEventPair,
                           EVENT_PAIR_INCREMENT,FALSE);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\exatom.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    exatom.c

Abstract:

    This file contains functions for manipulating global atom tables
    stored in kernel space.

Author:

    Steve Wood (stevewo) 13-Dec-1995

Revision History:

--*/

#include "exp.h"
#pragma hdrstop

//
//  Local Procedure prototype
//

PVOID
ExpGetGlobalAtomTable (
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, NtAddAtom)
#pragma alloc_text(PAGE, NtFindAtom)
#pragma alloc_text(PAGE, NtDeleteAtom)
#pragma alloc_text(PAGE, NtQueryInformationAtom)
#pragma alloc_text(PAGE, ExpGetGlobalAtomTable)
#endif

#define COPY_STACK_SIZE         128


NTSYSAPI
NTSTATUS
NTAPI
NtAddAtom (
    IN PWSTR AtomName,
    IN ULONG Length,
    OUT PRTL_ATOM Atom OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    RTL_ATOM ReturnAtom;
    PVOID AtomTable = ExpGetGlobalAtomTable();
    KPROCESSOR_MODE PreviousMode;
    PWSTR CapturedAtomNameBuffer;
    ULONG AllocLength;
    UCHAR StackArray[COPY_STACK_SIZE];

    PAGED_CODE();

    if (AtomTable == NULL) {

        return STATUS_ACCESS_DENIED;
    }

    if (Length > (RTL_ATOM_MAXIMUM_NAME_LENGTH * sizeof(WCHAR))) {

        return STATUS_INVALID_PARAMETER;
    }

    PreviousMode = KeGetPreviousMode();
    CapturedAtomNameBuffer = AtomName;

    Status = STATUS_SUCCESS;

    if (PreviousMode != KernelMode) {

        if (ARGUMENT_PRESENT (Atom)) {
            try {
                ProbeForWriteUshort( Atom );
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }
        }

        if (ARGUMENT_PRESENT (AtomName)) {

            AllocLength = (Length + sizeof( UNICODE_NULL ))&~(sizeof (WCHAR)-1);

            try {
                ProbeForRead( AtomName, Length, sizeof( WCHAR ) );
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }

            if (AllocLength <= COPY_STACK_SIZE) {
                CapturedAtomNameBuffer = (PWSTR) StackArray;
            }
            else {
                CapturedAtomNameBuffer = ExAllocatePoolWithTag (PagedPool, AllocLength, 'motA');

                if (CapturedAtomNameBuffer == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            try {
                RtlCopyMemory( CapturedAtomNameBuffer, AtomName, Length );
            } except (EXCEPTION_EXECUTE_HANDLER) {
                if (CapturedAtomNameBuffer != (PWSTR) StackArray) {
                    ExFreePool (CapturedAtomNameBuffer);
                }
                return GetExceptionCode();
            }

            CapturedAtomNameBuffer[Length / sizeof (WCHAR)] = '\0';
        }
    }

    if (NT_SUCCESS (Status)) {

        Status = RtlAddAtomToAtomTable (AtomTable, CapturedAtomNameBuffer, &ReturnAtom);

        if ((ARGUMENT_PRESENT (Atom)) && (NT_SUCCESS (Status))) {

            if (PreviousMode != KernelMode) {
                try {

                    *Atom = ReturnAtom;

                } except (EXCEPTION_EXECUTE_HANDLER) {

                    Status = GetExceptionCode();
                }
            }
            else {
                *Atom = ReturnAtom;
            }
        }
    }

    if ((CapturedAtomNameBuffer != AtomName) &&
        (CapturedAtomNameBuffer != (PWSTR) StackArray)) {
        ExFreePool (CapturedAtomNameBuffer);
    }

    return Status;
}


NTSYSAPI
NTSTATUS
NTAPI
NtFindAtom (
    IN PWSTR AtomName,
    IN ULONG Length,
    OUT PRTL_ATOM Atom OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    RTL_ATOM ReturnAtom;
    PVOID AtomTable = ExpGetGlobalAtomTable();
    KPROCESSOR_MODE PreviousMode;
    PWSTR CapturedAtomNameBuffer;
    ULONG AllocLength;
    UCHAR StackArray[COPY_STACK_SIZE];

    PAGED_CODE();

    if (AtomTable == NULL) {

        return STATUS_ACCESS_DENIED;
    }

    if (Length > (RTL_ATOM_MAXIMUM_NAME_LENGTH * sizeof(WCHAR))) {

        return STATUS_INVALID_PARAMETER;
    }

    PreviousMode = KeGetPreviousMode();
    CapturedAtomNameBuffer = AtomName;

    Status = STATUS_SUCCESS;

    if (PreviousMode != KernelMode) {

        if (ARGUMENT_PRESENT (Atom)) {
            try {
                ProbeForWriteUshort (Atom);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }
        }

        if (ARGUMENT_PRESENT (AtomName)) {

            AllocLength = (Length + sizeof( UNICODE_NULL ))&~(sizeof (WCHAR)-1);

            try {
                ProbeForRead (AtomName, Length, sizeof (WCHAR));
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }

            if (AllocLength <= COPY_STACK_SIZE) {
                CapturedAtomNameBuffer = (PWSTR) StackArray;
            }
            else {
                CapturedAtomNameBuffer = ExAllocatePoolWithTag (PagedPool, AllocLength, 'motA');

                if (CapturedAtomNameBuffer == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            try {
                RtlCopyMemory (CapturedAtomNameBuffer, AtomName, Length);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                if (CapturedAtomNameBuffer != (PWSTR) StackArray) {
                    ExFreePool (CapturedAtomNameBuffer);
                }
                return GetExceptionCode();
            }

            CapturedAtomNameBuffer[Length / sizeof (WCHAR)] = '\0';
        }
    }

    if (NT_SUCCESS( Status )) {

        Status = RtlLookupAtomInAtomTable (AtomTable, CapturedAtomNameBuffer, &ReturnAtom);

        if (NT_SUCCESS(Status) && ARGUMENT_PRESENT(Atom)) {

            try {

                *Atom = ReturnAtom;

            } except (EXCEPTION_EXECUTE_HANDLER) {

                Status = GetExceptionCode();
            }
        }
    }

    if ((CapturedAtomNameBuffer != AtomName) &&
        (CapturedAtomNameBuffer != (PWSTR) StackArray)) {
        ExFreePool (CapturedAtomNameBuffer);
    }

    return Status;
}


NTSYSAPI
NTSTATUS
NTAPI
NtDeleteAtom (
    IN RTL_ATOM Atom
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    PVOID AtomTable = ExpGetGlobalAtomTable();

    PAGED_CODE();

    if (AtomTable == NULL) {

        return STATUS_ACCESS_DENIED;
    }

    Status = RtlDeleteAtomFromAtomTable( AtomTable, Atom );

    return Status;
}


NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationAtom(
    IN RTL_ATOM Atom,
    IN ATOM_INFORMATION_CLASS AtomInformationClass,
    OUT PVOID AtomInformation,
    IN ULONG AtomInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    ULONG RequiredLength;
    ULONG UsageCount;
    ULONG NameLength;
    ULONG AtomFlags;
    PATOM_BASIC_INFORMATION BasicInfo;
    PATOM_TABLE_INFORMATION TableInfo;
    PVOID AtomTable = ExpGetGlobalAtomTable();

    PAGED_CODE();

    if (AtomTable == NULL) {
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Assume successful completion.
    //

    Status = STATUS_SUCCESS;

    try {

        //
        //  Get previous processor mode and probe output argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();

        if (PreviousMode != KernelMode) {

            ProbeForWrite( AtomInformation,
                           AtomInformationLength,
                           sizeof( ULONG ));

            if (ARGUMENT_PRESENT( ReturnLength )) {

                ProbeForWriteUlong( ReturnLength );
            }
        }

        RequiredLength = 0;

        switch (AtomInformationClass) {

        case AtomBasicInformation:

            RequiredLength = FIELD_OFFSET( ATOM_BASIC_INFORMATION, Name );

            if (AtomInformationLength < RequiredLength) {

                return STATUS_INFO_LENGTH_MISMATCH;
            }

            BasicInfo = (PATOM_BASIC_INFORMATION)AtomInformation;
            UsageCount = 0;
            NameLength = AtomInformationLength - RequiredLength;
            BasicInfo->Name[ 0 ] = UNICODE_NULL;

            Status = RtlQueryAtomInAtomTable( AtomTable,
                                              Atom,
                                              &UsageCount,
                                              &AtomFlags,
                                              &BasicInfo->Name[0],
                                              &NameLength );

            if (NT_SUCCESS(Status)) {

                BasicInfo->UsageCount = (USHORT)UsageCount;
                BasicInfo->Flags = (USHORT)AtomFlags;
                BasicInfo->NameLength = (USHORT)NameLength;
                RequiredLength += NameLength + sizeof( UNICODE_NULL );
            }

            break;

        case AtomTableInformation:

            RequiredLength = FIELD_OFFSET( ATOM_TABLE_INFORMATION, Atoms );

            if (AtomInformationLength < RequiredLength) {

                return STATUS_INFO_LENGTH_MISMATCH;
            }

            TableInfo = (PATOM_TABLE_INFORMATION)AtomInformation;

            Status = RtlQueryAtomsInAtomTable( AtomTable,
                                               (AtomInformationLength - RequiredLength) / sizeof( RTL_ATOM ),
                                               &TableInfo->NumberOfAtoms,
                                               &TableInfo->Atoms[0] );

            if (NT_SUCCESS(Status)) {

                RequiredLength += TableInfo->NumberOfAtoms * sizeof( RTL_ATOM );
            }

            break;

        default:

            Status = STATUS_INVALID_INFO_CLASS;

            break;
        }

        if (ARGUMENT_PRESENT( ReturnLength )) {

            *ReturnLength = RequiredLength;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
    }

    return Status;
}


//
//  Local support routine
//

PKWIN32_GLOBALATOMTABLE_CALLOUT ExGlobalAtomTableCallout;

PVOID
ExpGetGlobalAtomTable (
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    if (ExGlobalAtomTableCallout != NULL) {

        return ((*ExGlobalAtomTableCallout)());

    }

#if DBG
    DbgPrint( "EX: ExpGetGlobalAtomTable is about to return NULL!\n" );
    DbgBreakPoint();
#endif
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\event.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    event.c

Abstract:

   This module implements the executive event object. Functions are provided
   to create, open, set, reset, pulse, and query event objects.

Author:

    David N. Cutler (davec) 8-May-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

//
// Temporary so boost is patchable
//

ULONG ExpEventBoost = EVENT_INCREMENT;

//
// Address of event object type descriptor.
//

POBJECT_TYPE ExEventObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for event objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING ExpEventMapping = {
    STANDARD_RIGHTS_READ |
        EVENT_QUERY_STATE,
    STANDARD_RIGHTS_WRITE |
        EVENT_MODIFY_STATE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    EVENT_ALL_ACCESS
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpEventInitialization)
#pragma alloc_text(PAGE, NtClearEvent)
#pragma alloc_text(PAGE, NtCreateEvent)
#pragma alloc_text(PAGE, NtOpenEvent)
#pragma alloc_text(PAGE, NtPulseEvent)
#pragma alloc_text(PAGE, NtQueryEvent)
#pragma alloc_text(PAGE, NtResetEvent)
#pragma alloc_text(PAGE, NtSetEvent)
#pragma alloc_text(PAGE, NtSetEventBoostPriority)
#endif

BOOLEAN
ExpEventInitialization (
    )

/*++

Routine Description:

    This function creates the event object type descriptor at system
    initialization and stores the address of the object type descriptor
    in global storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the event object type descriptor is
    successfully initialized. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Event");

    //
    // Create event object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpEventMapping;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(KEVENT);
    ObjectTypeInitializer.ValidAccessMask = EVENT_ALL_ACCESS;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExEventObjectType);

    //
    // If the event object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

NTSTATUS
NtClearEvent (
    IN HANDLE EventHandle
    )

/*++

Routine Description:

    This function sets an event object to a Not-Signaled state.

Arguments:

    EventHandle - Supplies a handle to an event object.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Event;
    NTSTATUS Status;

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       EVENT_MODIFY_STATE,
                                       ExEventObjectType,
                                       KeGetPreviousMode(),
                                       &Event,
                                       NULL);

    //
    // If the reference was successful, then set the state of the event
    // object to Not-Signaled and dereference event object.
    //

    if (NT_SUCCESS(Status)) {
        PERFINFO_DECLARE_OBJECT(Event);
        KeClearEvent((PKEVENT)Event);
        ObDereferenceObject(Event);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    )

/*++

Routine Description:

    This function creates an event object, sets it initial state to the
    specified value, and opens a handle to the object with the specified
    desired access.

Arguments:

    EventHandle - Supplies a pointer to a variable that will receive the
        event object handle.

    DesiredAccess - Supplies the desired types of access for the event object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    EventType - Supplies the type of the event (autoclearing or notification).

    InitialState - Supplies the initial state of the event object.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Event;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to create an event object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object insertion routine.
    //

    PreviousMode = KeGetPreviousMode();

    //
    // Get previous processor mode and probe output handle address if
    // necessary.
    //

    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(EventHandle);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Check argument validity.
    //

    if ((EventType != NotificationEvent) && (EventType != SynchronizationEvent)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate event object.
    //

    Status = ObCreateObject(PreviousMode,
                            ExEventObjectType,
                            ObjectAttributes,
                            PreviousMode,
                            NULL,
                            sizeof(KEVENT),
                            0,
                            0,
                            (PVOID *)&Event);

    //
    // If the event object was successfully allocated, then initialize the
    // event object and attempt to insert the event object in the current
    // process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeEvent((PKEVENT)Event, EventType, InitialState);
        Status = ObInsertObject(Event,
                                NULL,
                                DesiredAccess,
                                0,
                                (PVOID *)NULL,
                                &Handle);

        //
        // If the event object was successfully inserted in the current
        // process' handle table, then attempt to write the event object
        // handle value. If the write attempt fails, then do not report
        // an error. When the caller attempts to access the handle value,
        // an access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            if (PreviousMode != KernelMode) {
                try {
                    *EventHandle = Handle;

                } except(ExSystemExceptionFilter()) {
                    NOTHING;
                }
            }
            else {
                *EventHandle = Handle;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to an event object with the specified
    desired access.

Arguments:

    EventHandle - Supplies a pointer to a variable that will receive the
        event object handle.

    DesiredAccess - Supplies the desired types of access for the event object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    NTSTATUS.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to open the event object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object open routine.
    //

    //
    // Get previous processor mode and probe output handle address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(EventHandle);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Open handle to the event object with the specified desired access.
    //

    Status = ObOpenObjectByName(ObjectAttributes,
                                ExEventObjectType,
                                PreviousMode,
                                NULL,
                                DesiredAccess,
                                NULL,
                                &Handle);

    //
    // If the open was successful, then attempt to write the event object
    // handle value. If the write attempt fails, then do not report an
    // error. When the caller attempts to access the handle value, an
    // access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        if (PreviousMode != KernelMode) {
            try {
                *EventHandle = Handle;

            } except(ExSystemExceptionFilter()) {
                NOTHING;
            }
        }
        else {
            *EventHandle = Handle;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtPulseEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    )

/*++

Routine Description:

    This function sets an event object to a Signaled state, attempts to
    satisfy as many waits as possible, and then resets the state of the
    event object to Not-Signaled.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Event;
    KPROCESSOR_MODE PreviousMode;
    LONG State;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the previous state address if
    // specified, reference the event object, and pulse the event object. If
    // the probe fails, then return the exception code as the service status.
    // Otherwise return the status value returned by the reference object by
    // handle routine.
    //

    //
    // Get previous processor mode and probe previous state address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (ARGUMENT_PRESENT(PreviousState) && (PreviousMode != KernelMode)) {
        try {
            ProbeForWriteLong(PreviousState);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       EVENT_MODIFY_STATE,
                                       ExEventObjectType,
                                       PreviousMode,
                                       &Event,
                                       NULL);

    //
    // If the reference was successful, then pulse the event object,
    // dereference event object, and write the previous state value if
    // specified. If the write of the previous state fails, then do not
    // report an error. When the caller attempts to access the previous
    // state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        PERFINFO_DECLARE_OBJECT(Event);
        State = KePulseEvent((PKEVENT)Event, ExpEventBoost, FALSE);
        ObDereferenceObject(Event);
        if (ARGUMENT_PRESENT(PreviousState)) {
            if (PreviousMode != KernelMode) {
                try {
                    *PreviousState = State;

                } except(ExSystemExceptionFilter()) {
                    NOTHING;
                }
            }
            else {
                *PreviousState = State;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQueryEvent (
    IN HANDLE EventHandle,
    IN EVENT_INFORMATION_CLASS EventInformationClass,
    OUT PVOID EventInformation,
    IN ULONG EventInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function queries the state of an event object and returns the
    requested information in the specified record structure.

Arguments:

    EventHandle - Supplies a handle to an event object.

    EventInformationClass - Supplies the class of information being requested.

    EventInformation - Supplies a pointer to a record that is to receive the
        requested information.

    EventInformationLength - Supplies the length of the record that is to
        receive the requested information.

    ReturnLength - Supplies an optional pointer to a variable that is to
        receive the actual length of information that is returned.

Return Value:

    NTSTATUS.

--*/

{

    PKEVENT Event;
    KPROCESSOR_MODE PreviousMode;
    LONG State;
    NTSTATUS Status;
    EVENT_TYPE EventType;

    //
    // Check argument validity.
    //

    if (EventInformationClass != EventBasicInformation) {
        return STATUS_INVALID_INFO_CLASS;
    }

    if (EventInformationLength != sizeof(EVENT_BASIC_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Establish an exception handler, probe the output arguments, reference
    // the event object, and return the specified information. If the probe
    // fails, then return the exception code as the service status. Otherwise
    // return the status value returned by the reference object by handle
    // routine.
    //

    //
    // Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {
        try {

            ProbeForWrite(EventInformation,
                          sizeof(EVENT_BASIC_INFORMATION),
                          sizeof(ULONG));

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUlong(ReturnLength);
            }
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       EVENT_QUERY_STATE,
                                       ExEventObjectType,
                                       PreviousMode,
                                       (PVOID *)&Event,
                                       NULL);

    //
    // If the reference was successful, then read the current state of
    // the event object, deference event object, fill in the information
    // structure, and return the length of the information structure if
    // specified. If the write of the event information or the return
    // length fails, then do not report an error. When the caller accesses
    // the information structure or length an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        State = KeReadStateEvent(Event);
        EventType = Event->Header.Type;
        ObDereferenceObject(Event);

        if (PreviousMode != KernelMode) {
            try {
                ((PEVENT_BASIC_INFORMATION)EventInformation)->EventType = EventType;
                ((PEVENT_BASIC_INFORMATION)EventInformation)->EventState = State;
                if (ARGUMENT_PRESENT(ReturnLength)) {
                    *ReturnLength = sizeof(EVENT_BASIC_INFORMATION);
                }

            } except(ExSystemExceptionFilter()) {
                NOTHING;
            }
        }
        else {
            ((PEVENT_BASIC_INFORMATION)EventInformation)->EventType = EventType;
            ((PEVENT_BASIC_INFORMATION)EventInformation)->EventState = State;
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(EVENT_BASIC_INFORMATION);
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtResetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    )

/*++

Routine Description:

    This function sets an event object to a Not-Signaled state.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Event;
    KPROCESSOR_MODE PreviousMode;
    LONG State;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the previous state address if
    // specified, reference the event object, and reset the event object. If
    // the probe fails, then return the exception code as the service status.
    // Otherwise return the status value returned by the reference object by
    // handle routine.
    //

    //
    // Get previous processor mode and probe previous state address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if ((ARGUMENT_PRESENT(PreviousState)) && (PreviousMode != KernelMode)) {

        try {
            ProbeForWriteLong(PreviousState);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       EVENT_MODIFY_STATE,
                                       ExEventObjectType,
                                       PreviousMode,
                                       &Event,
                                       NULL);

    //
    // If the reference was successful, then set the state of the event
    // object to Not-Signaled, dereference event object, and write the
    // previous state value if specified. If the write of the previous
    // state fails, then do not report an error. When the caller attempts
    // to access the previous state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        PERFINFO_DECLARE_OBJECT(Event);
        State = KeResetEvent((PKEVENT)Event);
        ObDereferenceObject(Event);

        if (ARGUMENT_PRESENT(PreviousState)) {
            if (PreviousMode != KernelMode) {
                try {
                    *PreviousState = State;

                } except(ExSystemExceptionFilter()) {
                    NOTHING;
                }
            }
            else {
                *PreviousState = State;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    )

/*++

Routine Description:

    This function sets an event object to a Signaled state and attempts to
    satisfy as many waits as possible.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Event;
    KPROCESSOR_MODE PreviousMode;
    LONG State;
    NTSTATUS Status;
#if DBG

    //
    // Sneaky trick here to catch sleazy apps (csrss) that erroneously call
    // NtSetEvent on an event that happens to be somebody else's
    // critical section. Only allow setting a protected handle if the low
    // bit of PreviousState is set.
    //
    OBJECT_HANDLE_INFORMATION HandleInfo;

#endif

    //
    // Establish an exception handler, probe the previous state address if
    // specified, reference the event object, and set the event object. If
    // the probe fails, then return the exception code as the service status.
    // Otherwise return the status value returned by the reference object by
    // handle routine.
    //

    //
    // Get previous processor mode and probe previous state address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    try {

#if DBG
        if ((PreviousMode != KernelMode) &&
            (ARGUMENT_PRESENT(PreviousState)) &&
            (PreviousState != (PLONG)1)) {
            ProbeForWriteLong(PreviousState);
        }
#else
        if ((PreviousMode != KernelMode) && (ARGUMENT_PRESENT(PreviousState))) {
            ProbeForWriteLong(PreviousState);
        }
#endif

        //
        // Reference event object by handle.
        //

#if DBG
        Status = ObReferenceObjectByHandle(EventHandle,
                                           EVENT_MODIFY_STATE,
                                           ExEventObjectType,
                                           PreviousMode,
                                           &Event,
                                           &HandleInfo);
        if (NT_SUCCESS(Status)) {

            if ((HandleInfo.HandleAttributes & 1) &&
                (PreviousState != (PLONG)1)) {
#if 0
                //
                // This is a protected handle. If the low bit of PreviousState is NOT set,
                // break into the debugger
                //

                DbgPrint("NtSetEvent: Illegal call to NtSetEvent on a protected handle\n");
                DbgBreakPoint();
                PreviousState = NULL;
#endif
            }
        } else {
            if ((KeGetPreviousMode() != KernelMode) &&
                (EventHandle != NULL) &&
                ((NtGlobalFlag & FLG_ENABLE_CLOSE_EXCEPTIONS) ||
                 (PsGetCurrentProcess()->DebugPort != NULL))) {

                return KeRaiseUserException(STATUS_INVALID_HANDLE);

            }
        }
#else
        Status = ObReferenceObjectByHandle(EventHandle,
                                           EVENT_MODIFY_STATE,
                                           ExEventObjectType,
                                           PreviousMode,
                                           &Event,
                                           NULL);
#endif

        //
        // If the reference was successful, then set the event object to the
        // Signaled state, dereference event object, and write the previous
        // state value if specified. If the write of the previous state fails,
        // then do not report an error. When the caller attempts to access the
        // previous state value, an access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            PERFINFO_DECLARE_OBJECT(Event);
            State = KeSetEvent((PKEVENT)Event, ExpEventBoost, FALSE);
            ObDereferenceObject(Event);
            if (ARGUMENT_PRESENT(PreviousState)) {
                try {
                    *PreviousState = State;

                } except(ExSystemExceptionFilter()) {
                }
            }
        }

    //
    // If an exception occurs during the probe of the previous state, then
    // always handle the exception and return the exception code as the status
    // value.
    //

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetEventBoostPriority (
    IN HANDLE EventHandle
    )

/*++

Routine Description:

    This function sets an event object to a Signaled state and performs
    a special priority boost operation.

    N.B. This service can only be performed on synchronization events.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    NTSTATUS.

--*/

{

    PKEVENT Event;
    NTSTATUS Status;

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       EVENT_MODIFY_STATE,
                                       ExEventObjectType,
                                       KeGetPreviousMode(),
                                       &Event,
                                       NULL);

    //
    // If the reference was successful, then check the type of event object.
    // If the event object is a notification event, then return an object
    // type mismatch status. Otherwise, set the specified event and boost
    // the unwaited thread priority as appropriate.
    //

    if (NT_SUCCESS(Status)) {
        if (Event->Header.Type == NotificationEvent) {
            Status = STATUS_OBJECT_TYPE_MISMATCH;

        } else {
            KeSetEventBoostPriority(Event, NULL);
        }

        ObDereferenceObject(Event);
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\exdata.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    exdata.c

Abstract:

    This module contains the global read/write data for the I/O system.

Author:

    Ken Reneris (kenr)

Revision History:


--*/

#include "exp.h"

//
// Executive callbacks.
//

PCALLBACK_OBJECT ExCbSetSystemTime;
PCALLBACK_OBJECT ExCbSetSystemState;
PCALLBACK_OBJECT ExCbPowerState;

#ifdef _PNP_POWER_

//
// Work Item to scan SystemInformation levels
//

WORK_QUEUE_ITEM ExpCheckSystemInfoWorkItem;

#endif


//
// Pageable data
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

#ifdef _PNP_POWER_

const WCHAR ExpWstrSystemInformation[] = L"Control\\System Information";
const WCHAR ExpWstrSystemInformationValue[] = L"Value";

#endif

//
// Initialization time data
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif

const WCHAR ExpWstrCallback[] = L"\\Callback";

const EXP_INITIALIZE_GLOBAL_CALLBACKS  ExpInitializeCallback[] = {
    &ExCbSetSystemTime,             L"\\Callback\\SetSystemTime",
    &ExCbSetSystemState,            L"\\Callback\\SetSystemState",
    &ExCbPowerState,                L"\\Callback\\PowerState",
    NULL,                           NULL
};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

#ifdef _PNP_POWER_

LONG ExpCheckSystemInfoBusy = 0;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\exp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    exp.h

Abstract:

    This module contains the private (internal) header file for the
    executive.

Author:

    David N. Cutler (davec) 23-May-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#ifndef _EXP_
#define _EXP_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4206)   // translation unit empty
#pragma warning(disable:4706)   // assignment within conditional
#pragma warning(disable:4324)   // structure was padded
#pragma warning(disable:4328)   // greater alignment than needed
#pragma warning(disable:4054)   // cast of function pointer to PVOID

#include "ntos.h"
#include "zwapi.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "ki.h"
#include "stdio.h"
#include "pool.h"



#define COMPLUS_PACKAGE_KEYPATH      L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\.NETFramework"
#define COMPLUS_PACKAGE_ENABLE64BIT  L"Enable64Bit"
#define COMPLUS_PACKAGE_INVALID      (ULONG)-1

//
// Executive information initialization structure
//

typedef struct {
    PCALLBACK_OBJECT    *CallBackObject;
    PWSTR               CallbackName;
} EXP_INITIALIZE_GLOBAL_CALLBACKS;

typedef struct _EXP_LICENSE_INFO {
    HANDLE           RegKey;
    ULONG            Count;
    PWSTR            SubKeyName;
    WORK_QUEUE_ITEM  ExpWatchLicenseInfoWorkItem;
    IO_STATUS_BLOCK  ExpLicenseInfoIoSb;
    ULONG            ExpLicenseInfoChangeBuffer;
} EXP_LICENSE_INFO, *PEXP_LICENSE_INFO;


//
// Executive object and other initialization function definitions.
//

NTSTATUS
ExpWorkerInitialization (
    VOID
    );

BOOLEAN
ExpEventInitialization (
    VOID
    );

BOOLEAN
ExpEventPairInitialization (
    VOID
    );

BOOLEAN
ExpMutantInitialization (
    VOID
    );

BOOLEAN
ExpSemaphoreInitialization (
    VOID
    );

BOOLEAN
ExpTimerInitialization (
    VOID
    );

BOOLEAN
ExpWin32Initialization (
    VOID
    );

BOOLEAN
ExpResourceInitialization (
    VOID
    );

PVOID
ExpCheckForResource (
    IN PVOID p,
    IN SIZE_T Size
    );

BOOLEAN
ExpInitSystemPhase0 (
    VOID
    );

BOOLEAN
ExpInitSystemPhase1 (
    VOID
    );

BOOLEAN
ExpProfileInitialization (
    );

BOOLEAN
ExpUuidInitialization (
    );

VOID
ExpProfileDelete (
    IN PVOID    Object
    );


BOOLEAN
ExpInitializeCallbacks (
    VOID
    );

BOOLEAN
ExpSysEventInitialization(
    VOID
    );

VOID
ExpCheckSystemInfoWork (
    IN PVOID Context
    );

VOID
ExInitSystemPhase2 (
    VOID
    );

NTSTATUS
ExpKeyedEventInitialization (
    VOID
    );

VOID
ExpCheckSystemInformation (
    PVOID       Context,
    PVOID       InformationClass,
    PVOID       Argument2
    );


VOID
ExpTimeZoneWork(
    IN PVOID Context
    );

VOID
ExpTimeRefreshDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
ExpTimeRefreshWork(
    IN PVOID Context
    );

VOID
ExpTimeZoneDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
ExInitializeTimeRefresh(
    VOID
    );

VOID
ExpExpirationThread(
    IN PVOID StartContext
    );

ULONG
ExpComputeTickCountMultiplier(
    IN ULONG TimeIncrement
    );

BOOLEAN
static
ExpWatchProductTypeInitialization(
    VOID
    );

VOID
static
ExpWatchProductTypeWork(
    IN PVOID Context
    );

VOID
static
ExpWatchLicenseInfoWork(
    IN PVOID Context
    );

VOID
static
ExpWatchSystemPrefixWork(
    IN PVOID Context
    );

VOID
static
ExpWatchExpirationDataWork(
    IN PVOID Context
    );

VOID
ExpCheckForWorker(
    IN PVOID p,
    IN SIZE_T Size
    );

VOID
ExpShutdownWorkerThreads(
    VOID
    );

NTSTATUS
ExpReadComPlusPackage(
    VOID
    );

NTSTATUS
ExpUpdateComPlusPackage(
    IN ULONG ComPlusPackageStatus
    );

#if defined(_WIN64)
NTSTATUS
ExpGetSystemEmulationProcessorInformation (
    OUT PSYSTEM_PROCESSOR_INFORMATION ProcessorInformation
    );
#endif

ULONG ExpNtExpirationData[3];
BOOLEAN ExpSetupModeDetected;
LARGE_INTEGER ExpSetupSystemPrefix;
HANDLE ExpSetupKey;
BOOLEAN ExpSystemPrefixValid;


#ifdef _PNP_POWER_

extern WORK_QUEUE_ITEM  ExpCheckSystemInfoWorkItem;
extern LONG             ExpCheckSystemInfoBusy;
extern const WCHAR      ExpWstrSystemInformation[];
extern const WCHAR      ExpWstrSystemInformationValue[];

#endif // _PNP_POWER_

extern const WCHAR      ExpWstrCallback[];
extern const EXP_INITIALIZE_GLOBAL_CALLBACKS  ExpInitializeCallback[];


extern FAST_MUTEX       ExpEnvironmentLock;
extern ERESOURCE        ExpKeyManipLock;

extern GENERAL_LOOKASIDE ExpSmallPagedPoolLookasideLists[POOL_SMALL_LISTS];
extern GENERAL_LOOKASIDE ExpSmallNPagedPoolLookasideLists[POOL_SMALL_LISTS];

extern LIST_ENTRY ExNPagedLookasideListHead;
extern KSPIN_LOCK ExNPagedLookasideLock;
extern LIST_ENTRY ExPagedLookasideListHead;
extern KSPIN_LOCK ExPagedLookasideLock;
extern LIST_ENTRY ExPoolLookasideListHead;
extern PEPROCESS  ExpDefaultErrorPortProcess;
extern HANDLE     ExpDefaultErrorPort;
extern HANDLE     ExpProductTypeKey;
extern PVOID      ExpControlKey[2];

#endif // _EXP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\exinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    exinfo.c

Abstract:

    This module implements the NT set and query system information services.

Author:

    Ken Reneris (kenr) 19-July-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

#if _PNP_POWER_
#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, ExpCheckSystemInformation)
#pragma alloc_text(PAGE, ExpCheckSystemInfoWork)
#endif // _PNP_POWER_

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

VOID
ExpCheckSystemInformation (
    PVOID       Context,
    PVOID       InformationClass,
    PVOID       Argument2
    )
/*++

Routine Description:

    Callback function invoked when something in the system information
    may have changed.

Arguments:

    Context - Where invoked from.

    InformationClass - which class for the given context was set
        (ignored for now)

    Argument2

Return Value:

--*/
{
	PAGED_CODE();

	if (InterlockedIncrement(&ExpCheckSystemInfoBusy) == 1) {
		ExQueueWorkItem (&ExpCheckSystemInfoWorkItem, DelayedWorkQueue);
	}
}


VOID
ExpCheckSystemInfoWork (
    IN PVOID Context
    )
/*++

Routine Description:

    Verifies registery data for various system information classes
    is up to date.

Arguments:

Return Value:

--*/
{
    static struct {
        SYSTEM_INFORMATION_CLASS         InformationLevel;
        ULONG                            BufferSize;
    } const RegistryInformation[] = {
        SystemBasicInformation,          sizeof (SYSTEM_BASIC_INFORMATION),
        SystemPowerInformation,          sizeof (SYSTEM_POWER_INFORMATION),
        SystemProcessorSpeedInformation, sizeof (SYSTEM_PROCESSOR_SPEED_INFORMATION),
        0,                               0
    };

    struct {
        KEY_VALUE_PARTIAL_INFORMATION   Key;
        union {
            SYSTEM_BASIC_INFORMATION BasicInformation;
            SYSTEM_POWER_INFORMATION PowerSettings;
            SYSTEM_PROCESSOR_SPEED_INFORMATION  ProcessorSpeed;
        };
    } RegistryBuffer, QueryBuffer;

    ULONG               Index, BufferSize, disposition, length;
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      unicodeString, ValueString;
    HANDLE              CurrentControlSet, SystemInformation, LevelInformation;
    LARGE_INTEGER       Interval;
    WCHAR               wstr[10];

    PAGED_CODE();

    RtlInitUnicodeString (&ValueString,  ExpWstrSystemInformationValue);

    //
    // Open CurrentControlSet
    //

    InitializeObjectAttributes( &objectAttributes,
                                &CmRegistryMachineSystemCurrentControlSet,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = NtOpenKey (&CurrentControlSet,
                        KEY_READ | KEY_WRITE,
                        &objectAttributes );

    if (NT_SUCCESS(Status)) {

        //
        // Open SystemInformation
        //

        RtlInitUnicodeString( &unicodeString, ExpWstrSystemInformation );
        InitializeObjectAttributes( &objectAttributes,
                                    &unicodeString,
                                    OBJ_CASE_INSENSITIVE,
                                    CurrentControlSet,
                                    NULL );

        Status = NtCreateKey ( &SystemInformation,
                               KEY_READ | KEY_WRITE,
                               &objectAttributes,
                               0,
                               NULL,
                               REG_OPTION_VOLATILE,
                               &disposition );

        NtClose (CurrentControlSet);
    }

    if (!NT_SUCCESS(Status)) {
        ExpCheckSystemInfoBusy = 0;
        return ;
    }

    //
    // Loop and check SystemInformation data in registry
    //

    do {
        //
        // For now just check each SystemInformation level and update
        // any level which is out of date
        //

        for (Index=0; RegistryInformation[Index].BufferSize; Index++) {

            //
            // Initialize registry data buffer
            //

            BufferSize = RegistryInformation[Index].BufferSize;
            RtlZeroMemory (RegistryBuffer.Key.Data, BufferSize);

            //
            // Open appropiate SystemInformation level key
            //

            swprintf (wstr, L"%d", RegistryInformation[Index].InformationLevel);
            RtlInitUnicodeString (&unicodeString, wstr);
            InitializeObjectAttributes( &objectAttributes,
                                        &unicodeString,
                                        OBJ_CASE_INSENSITIVE,
                                        SystemInformation,
                                        NULL );

            Status = NtCreateKey ( &LevelInformation,
                                   KEY_READ | KEY_WRITE,
                                   &objectAttributes,
                                   0,
                                   NULL,
                                   REG_OPTION_VOLATILE,
                                   &disposition );

            //
            // If key opened, read current data value from the registry
            //

            if (NT_SUCCESS(Status)) {
                NtQueryValueKey (
                    LevelInformation,
                    &ValueString,
                    KeyValuePartialInformation,
                    &RegistryBuffer.Key,
                    sizeof (RegistryBuffer),
                    &length
                    );
            }

            //
            // Query current SystemInformation data
            //

            Status = NtQuerySystemInformation (
                            RegistryInformation[Index].InformationLevel,
                            &QueryBuffer.Key.Data,
                            BufferSize,
                            NULL
                        );

            //
            // Check if current SystemInformation matches the registry
            // information
            //

            if (NT_SUCCESS(Status)  &&
                !RtlEqualMemory (RegistryBuffer.Key.Data,
                                 QueryBuffer.Key.Data,
                                 BufferSize) ) {

                //
                // Did not match - update registry to current SystemInfomration
                //

                Status = NtSetValueKey (
                            LevelInformation,
                            &ValueString,
                            0L,
                            REG_BINARY,
                            QueryBuffer.Key.Data,
                            BufferSize
                            );

                //
                // Make notificant that this information level has changed
                //

                ExNotifyCallback (
                    ExCbSetSystemInformation,
                    (PVOID) RegistryInformation[Index].InformationLevel,
                    (PVOID) NULL
                );
            }

            //
            // Close this InformatiobLevel and check the next one
            //

            NtClose (LevelInformation);
        }

    } while (InterlockedDecrement(&ExpCheckSystemInfoBusy));

    //
    // Cleanup
    //

    NtClose (SystemInformation);
}

#endif  // _PNP_POWER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\intrloc2.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    intrloc2.c

Abstract:

   This module implements the *portable*  (i.e. SLOW) versions of
   the executive's simple atomic increment/decrement procedures.
   Real implementation should be in assembler.

Author:

    Bryan Willman  (bryanwi)  2-Aug-90

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

INTERLOCKED_RESULT
ExInterlockedIncrementLong (
    IN PLONG Addend,
    IN PKSPIN_LOCK Lock
    )

/*++

Routine Description:

    This function atomically increments Addend, returning an ennumerated
    type which indicates what interesting transitions in the value of
    Addend occurred due the operation.

Arguments:

    Addend - Pointer to variable to increment.

    Lock - Spinlock used to implement atomicity.

Return Value:

    An ennumerated type:

    ResultNegative if Addend is < 0 after increment.
    ResultZero     if Addend is = 0 after increment.
    ResultPositive if Addend is > 0 after increment.

--*/

{
    LONG    OldValue;

    OldValue = (LONG)ExInterlockedAddUlong((PULONG)Addend, 1, Lock);

    if (OldValue < -1)
        return ResultNegative;

    if (OldValue == -1)
        return ResultZero;

    if (OldValue > -1)
        return ResultPositive;
}

INTERLOCKED_RESULT
ExInterlockedDecrementLong (
    IN PLONG Addend,
    IN PKSPIN_LOCK Lock
    )

/*++

Routine Description:

    This function atomically decrements Addend, returning an ennumerated
    type which indicates what interesting transitions in the value of
    Addend occurred due the operation.

Arguments:

    Addend - Pointer to variable to decrement.

    Lock - Spinlock used to implement atomicity.

Return Value:

    An ennumerated type:

    ResultNegative if Addend is < 0 after decrement.
    ResultZero     if Addend is = 0 after decrement.
    ResultPositive if Addend is > 0 after decrement.

--*/

{
    LONG    OldValue;

    OldValue = (LONG)ExInterlockedAddUlong((PULONG)Addend, -1, Lock);

    if (OldValue > 1)
        return ResultPositive;

    if (OldValue == 1)
        return ResultZero;

    if (OldValue < 1)
        return ResultNegative;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\harderr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    harderr.c

Abstract:

    This module implements NT Hard Error APIs

Author:

    Mark Lucovsky (markl) 04-Jul-1991

Revision History:

--*/

#include "exp.h"

NTSTATUS
ExpRaiseHardError (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    );

VOID
ExpSystemErrorHandler (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN BOOLEAN CallShutdown
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, NtRaiseHardError)
#pragma alloc_text(PAGE, NtSetDefaultHardErrorPort)
#pragma alloc_text(PAGE, ExRaiseHardError)
#pragma alloc_text(PAGE, ExpRaiseHardError)
#pragma alloc_text(PAGELK, ExpSystemErrorHandler)
#endif

#define HARDERROR_MSG_OVERHEAD (sizeof(HARDERROR_MSG) - sizeof(PORT_MESSAGE))
#define HARDERROR_API_MSG_LENGTH \
            sizeof(HARDERROR_MSG)<<16 | (HARDERROR_MSG_OVERHEAD)

PEPROCESS ExpDefaultErrorPortProcess;
BOOLEAN ExReadyForErrors = FALSE;
BOOLEAN ExpTooLateForErrors = FALSE;
HANDLE ExpDefaultErrorPort;

extern PVOID PsSystemDllDllBase;

#ifdef _X86_
#pragma optimize("y", off)      // RtlCaptureContext needs EBP to be correct
#endif

VOID
ExpSystemErrorHandler (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN BOOLEAN CallShutdown
    )
{
    ULONG Counter;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    ULONG_PTR ParameterVector[MAXIMUM_HARDERROR_PARAMETERS];
    CHAR DefaultFormatBuffer[32];
    CHAR ExpSystemErrorBuffer[256];
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    PSZ ErrorCaption;
    CHAR const* ErrorFormatString;
    ANSI_STRING Astr;
    UNICODE_STRING Ustr;
    OEM_STRING Ostr;
    PSZ OemCaption;
    PSZ OemMessage;
    static char const* UnknownHardError = "Unknown Hard Error";
    CONTEXT ContextSave;

    PAGED_CODE();

    //
    // This handler is called whenever a hard error occurs before the
    // default handler has been installed.
    //
    // This is done regardless of whether or not the process has chosen
    // default hard error processing.
    //

    //
    // Capture the callers context as closely as possible into the debugger's
    // processor state area of the Prcb
    //
    // N.B. There may be some prologue code that shuffles registers such that
    //      they get destroyed.
    //
    // This code is here only for crash dumps.
    //

    RtlCaptureContext (&KeGetCurrentPrcb()->ProcessorState.ContextFrame);
    KiSaveProcessorControlState (&KeGetCurrentPrcb()->ProcessorState);
    ContextSave = KeGetCurrentPrcb()->ProcessorState.ContextFrame;

    DefaultFormatBuffer[0] = '\0';
    RtlZeroMemory (ParameterVector, sizeof(ParameterVector));

    RtlCopyMemory (ParameterVector, Parameters, NumberOfParameters * sizeof (ULONG_PTR));

    for (Counter = 0; Counter < NumberOfParameters; Counter += 1) {

        if (UnicodeStringParameterMask & 1 << Counter) {

            strcat(DefaultFormatBuffer," %s");

            RtlUnicodeStringToAnsiString (&AnsiString,
                                          (PUNICODE_STRING)Parameters[Counter],
                                          TRUE);

            ParameterVector[Counter] = (ULONG_PTR)AnsiString.Buffer;
        }
        else {
            strcat(DefaultFormatBuffer," %x");
        }
    }

    strcat(DefaultFormatBuffer,"\n");

    ErrorFormatString = (char const *)DefaultFormatBuffer;
    ErrorCaption = (PSZ) UnknownHardError;

    //
    // HELP where do I get the resource from !
    //

    if (PsSystemDllDllBase != NULL) {

        try {

            //
            // If we are on a DBCS code page, we have to use ENGLISH resource
            // instead of default resource because HalDisplayString() can only
            // display ASCII characters on the blue screen.
            //

            Status = RtlFindMessage (PsSystemDllDllBase,
                                     11,
                                     NlsMbCodePageTag ?
                                     MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US) :
                                     0,
                                     ErrorStatus,
                                     &MessageEntry);

            if (!NT_SUCCESS(Status)) {
                ErrorCaption = (PSZ) UnknownHardError;
                ErrorFormatString = (char const *)UnknownHardError;
            }
            else {
                if (MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE) {

                    //
                    // Message resource is Unicode.  Convert to ANSI.
                    //

                    RtlInitUnicodeString (&Ustr, (PCWSTR)MessageEntry->Text);
                    Astr.Length = (USHORT) RtlUnicodeStringToAnsiSize (&Ustr);

                    ErrorCaption = ExAllocatePoolWithTag (NonPagedPool,
                                                          Astr.Length+16,
                                                          ' rrE');

                    if (ErrorCaption != NULL) {
                        Astr.MaximumLength = Astr.Length + 16;
                        Astr.Buffer = ErrorCaption;
                        Status = RtlUnicodeStringToAnsiString(&Astr, &Ustr, FALSE);
                        if (!NT_SUCCESS(Status)) {
                            ExFreePool(ErrorCaption);
                            ErrorCaption = (PSZ) UnknownHardError;
                            ErrorFormatString = (char const *)UnknownHardError;
                        }
                    }
                    else {
                        ErrorCaption = (PSZ) UnknownHardError;
                        ErrorFormatString = (char const *) UnknownHardError;
                    }
                }
                else {
                    ErrorCaption = ExAllocatePoolWithTag(NonPagedPool,
                                    strlen((PCHAR)MessageEntry->Text)+16,
                                    ' rrE');

                    if (ErrorCaption != NULL) {
                        strcpy(ErrorCaption,(PCHAR)MessageEntry->Text);
                    }
                    else {
                        ErrorFormatString = (char const *)UnknownHardError;
                        ErrorCaption = (PSZ) UnknownHardError;
                    }
                }

                if (ErrorCaption != UnknownHardError) {

                    //
                    // It's assumed the Error String from the message table
                    // is in the format:
                    //
                    // {ErrorCaption}\r\n\0ErrorFormatString\0.
                    //
                    // Parse out the caption.
                    //

                    ErrorFormatString = ErrorCaption;
                    Counter = (ULONG) strlen(ErrorCaption);

                    while (Counter && *ErrorFormatString >= ' ') {
                        ErrorFormatString += 1;
                        Counter -= 1;
                    }

                    *(char*)ErrorFormatString++ = '\0';
                    Counter -= 1;

                    while (Counter && *ErrorFormatString && *ErrorFormatString <= ' ') {
                        ErrorFormatString += 1;
                        Counter -= 1;
                    }
                }

                if (!Counter) {
                    // Oops - Bad Format String.
                    ErrorFormatString = (char const *)"";
                }
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            ErrorFormatString = (char const *)UnknownHardError;
            ErrorCaption = (PSZ) UnknownHardError;
        }
    }

    try {
        _snprintf (ExpSystemErrorBuffer,
                   sizeof (ExpSystemErrorBuffer),
                   "\nSTOP: %lx %s\n",
                   ErrorStatus,
                   ErrorCaption);
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        _snprintf (ExpSystemErrorBuffer,
                   sizeof (ExpSystemErrorBuffer),
                   "\nHardError %lx\n",
                   ErrorStatus);
    }

    ASSERT(ExPageLockHandle);
    MmLockPagableSectionByHandle(ExPageLockHandle);

    //
    // Take the caption and convert it to OEM.
    //

    OemCaption = (PSZ) UnknownHardError;
    OemMessage = (PSZ) UnknownHardError;

    RtlInitAnsiString (&Astr, ExpSystemErrorBuffer);

    Status = RtlAnsiStringToUnicodeString (&Ustr, &Astr, TRUE);

    if (!NT_SUCCESS(Status)) {
        goto punt1;
    }

    //
    // Allocate the OEM string out of nonpaged pool so that bugcheck
    // can read it.
    //

    Ostr.Length = (USHORT)RtlUnicodeStringToOemSize(&Ustr);
    Ostr.MaximumLength = Ostr.Length;
    Ostr.Buffer = ExAllocatePoolWithTag(NonPagedPool, Ostr.Length, ' rrE');
    OemCaption = Ostr.Buffer;

    if (Ostr.Buffer != NULL) {
        Status = RtlUnicodeStringToOemString (&Ostr, &Ustr, FALSE);
        if (!NT_SUCCESS(Status)) {
            goto punt1;
        }
    }

    //
    // Can't do much of anything after calling HalDisplayString...
    //

punt1:

    try {
        _snprintf (ExpSystemErrorBuffer, sizeof (ExpSystemErrorBuffer),
                   (const char *)ErrorFormatString,
                   ParameterVector[0],
                   ParameterVector[1],
                   ParameterVector[2],
                   ParameterVector[3]);
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        _snprintf (ExpSystemErrorBuffer, sizeof (ExpSystemErrorBuffer),
                   "Exception Processing Message %lx Parameters %lx %lx %lx %lx",
                   ErrorStatus,
                   ParameterVector[0],
                   ParameterVector[1],
                   ParameterVector[2],
                   ParameterVector[3]);
    }


    RtlInitAnsiString (&Astr, ExpSystemErrorBuffer);
    Status = RtlAnsiStringToUnicodeString (&Ustr, &Astr, TRUE);

    if (!NT_SUCCESS(Status)) {
        goto punt2;
    }

    //
    // Allocate the OEM string out of nonpaged pool so that bugcheck
    // can read it.
    //

    Ostr.Length = (USHORT) RtlUnicodeStringToOemSize (&Ustr);
    Ostr.MaximumLength = Ostr.Length;

    Ostr.Buffer = ExAllocatePoolWithTag (NonPagedPool, Ostr.Length, ' rrE');

    OemMessage = Ostr.Buffer;

    if (Ostr.Buffer) {

        Status = RtlUnicodeStringToOemString (&Ostr, &Ustr, FALSE);

        if (!NT_SUCCESS(Status)) {
            goto punt2;
        }
    }

punt2:

    ASSERT (sizeof(PVOID) == sizeof(ULONG_PTR));
    ASSERT (sizeof(ULONG) == sizeof(NTSTATUS));

    //
    // We don't come back from here.
    //

    if (CallShutdown) {

        PoShutdownBugCheck (TRUE,
                            FATAL_UNHANDLED_HARD_ERROR,
                            (ULONG)ErrorStatus,
                            (ULONG_PTR)&(ParameterVector[0]),
                            (ULONG_PTR)OemCaption,
                            (ULONG_PTR)OemMessage);

    }
    else {

        KeBugCheckEx (FATAL_UNHANDLED_HARD_ERROR,
                      (ULONG)ErrorStatus,
                      (ULONG_PTR)&(ParameterVector[0]),
                      (ULONG_PTR)OemCaption,
                      (ULONG_PTR)OemMessage);
    }
}

#ifdef _X86_
#pragma optimize("", on)
#endif

NTSTATUS
ExpRaiseHardError (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    )
{
    PTEB Teb;
    PETHREAD Thread;
    PEPROCESS Process;
    ULONG_PTR MessageBuffer[PORT_MAXIMUM_MESSAGE_LENGTH/sizeof(ULONG_PTR)];
    PHARDERROR_MSG m;
    NTSTATUS Status;
    HANDLE ErrorPort;
    KPROCESSOR_MODE PreviousMode;

    PAGED_CODE();

    m = (PHARDERROR_MSG)&MessageBuffer[0];
    PreviousMode = KeGetPreviousMode();

    if (ValidResponseOptions == OptionShutdownSystem) {

        //
        // Check to see if the caller has the privilege to make this call.
        //

        if (!SeSinglePrivilegeCheck (SeShutdownPrivilege, PreviousMode)) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        ExReadyForErrors = FALSE;
    }

    Thread = PsGetCurrentThread();
    Process = PsGetCurrentProcess();

    //
    // If the default handler is not installed, then
    // call the fatal hard error handler if the error
    // status is error
    //
    // Let GDI override this since it does not want to crash the machine
    // when a bad driver was loaded via MmLoadSystemImage.
    //

    if ((Thread->CrossThreadFlags & PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) == 0) {

        if (ExReadyForErrors == FALSE && NT_ERROR(ErrorStatus)) {

            ExpSystemErrorHandler (
                ErrorStatus,
                NumberOfParameters,
                UnicodeStringParameterMask,
                Parameters,
                (BOOLEAN)((PreviousMode != KernelMode) ? TRUE : FALSE));
        }
    }

    //
    // If the process has an error port, then if it wants default
    // handling, use its port. If it disabled default handling, then
    // return the error to the caller. If the process does not
    // have a port, then use the registered default handler.
    //

    ErrorPort = NULL;

    if (Process->ExceptionPort) {
        if (Process->DefaultHardErrorProcessing & 1) {
            ErrorPort = Process->ExceptionPort;
        } else {

            //
            // If error processing is disabled, check the error override
            // status.
            //

            if (ErrorStatus & HARDERROR_OVERRIDE_ERRORMODE) {
                ErrorPort = Process->ExceptionPort;
            }
        }
    } else {
        if (Process->DefaultHardErrorProcessing & 1) {
            ErrorPort = ExpDefaultErrorPort;
        } else {

            //
            // If error processing is disabled, check the error override
            // status.
            //

            if (ErrorStatus & HARDERROR_OVERRIDE_ERRORMODE) {
                ErrorPort = ExpDefaultErrorPort;
            }
        }
    }

    if ((Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) != 0) {
        ErrorPort = NULL;
    }

    if ((ErrorPort != NULL) && (!IS_SYSTEM_THREAD(Thread))) {
        Teb = (PTEB)PsGetCurrentThread()->Tcb.Teb;
        try {
            if (Teb->HardErrorsAreDisabled) {
                ErrorPort = NULL;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            ;
        }
    }

    if (ErrorPort == NULL) {
        *Response = (ULONG)ResponseReturnToCaller;
        return STATUS_SUCCESS;
    }

    if (Process == ExpDefaultErrorPortProcess) {
        if (NT_ERROR(ErrorStatus)) {
            ExpSystemErrorHandler (ErrorStatus,
                                   NumberOfParameters,
                                   UnicodeStringParameterMask,
                                   Parameters,
                                   (BOOLEAN)((PreviousMode != KernelMode) ? TRUE : FALSE));
        }
        *Response = (ULONG)ResponseReturnToCaller;
        Status = STATUS_SUCCESS;
        return Status;
    }

    m->h.u1.Length = HARDERROR_API_MSG_LENGTH;
    m->h.u2.ZeroInit = LPC_ERROR_EVENT;
    m->Status = ErrorStatus & ~HARDERROR_OVERRIDE_ERRORMODE;
    m->ValidResponseOptions = ValidResponseOptions;
    m->UnicodeStringParameterMask = UnicodeStringParameterMask;
    m->NumberOfParameters = NumberOfParameters;

    if (Parameters != NULL) {
        RtlCopyMemory (&m->Parameters,
                       Parameters,
                       sizeof(ULONG_PTR)*NumberOfParameters);
    }

    KeQuerySystemTime(&m->ErrorTime);

    Status = LpcRequestWaitReplyPortEx (ErrorPort,
                                        (PPORT_MESSAGE) m,
                                        (PPORT_MESSAGE) m);

    if (NT_SUCCESS(Status)) {
        switch (m->Response) {
            case ResponseReturnToCaller :
            case ResponseNotHandled :
            case ResponseAbort :
            case ResponseCancel :
            case ResponseIgnore :
            case ResponseNo :
            case ResponseOk :
            case ResponseRetry :
            case ResponseYes :
            case ResponseTryAgain :
            case ResponseContinue :
                break;
            default:
                m->Response = (ULONG)ResponseReturnToCaller;
                break;
        }
        *Response = m->Response;
    }

    return Status;
}

NTSTATUS
NtRaiseHardError (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    )
{
    NTSTATUS Status;
    ULONG_PTR CapturedParameters[MAXIMUM_HARDERROR_PARAMETERS];
    KPROCESSOR_MODE PreviousMode;
    ULONG LocalResponse;
    UNICODE_STRING CapturedString;
    ULONG Counter;

    PAGED_CODE();

    if (NumberOfParameters > MAXIMUM_HARDERROR_PARAMETERS) {
        return STATUS_INVALID_PARAMETER_2;
    }

    if (ARGUMENT_PRESENT(Parameters) && NumberOfParameters == 0) {
        return STATUS_INVALID_PARAMETER_2;
    }

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        switch (ValidResponseOptions) {
            case OptionAbortRetryIgnore :
            case OptionOk :
            case OptionOkCancel :
            case OptionRetryCancel :
            case OptionYesNo :
            case OptionYesNoCancel :
            case OptionShutdownSystem :
            case OptionOkNoWait :
            case OptionCancelTryContinue:
                break;
            default :
                return STATUS_INVALID_PARAMETER_4;
        }

        try {
            ProbeForWriteUlong(Response);

            if (ARGUMENT_PRESENT(Parameters)) {
                ProbeForRead (Parameters,
                              sizeof(ULONG_PTR)*NumberOfParameters,
                              sizeof(ULONG_PTR));

                RtlCopyMemory (CapturedParameters,
                               Parameters,
                               sizeof(ULONG_PTR)*NumberOfParameters);

                //
                // Probe all strings.
                //

                if (UnicodeStringParameterMask) {

                    for (Counter = 0;Counter < NumberOfParameters; Counter += 1) {

                        //
                        // if there is a string in this position,
                        // then probe and capture the string
                        //

                        if (UnicodeStringParameterMask & (1<<Counter)) {

                            ProbeForReadSmallStructure ((PVOID)CapturedParameters[Counter],
                                                        sizeof(UNICODE_STRING),
                                                        sizeof(ULONG_PTR));

                            RtlCopyMemory (&CapturedString,
                                           (PVOID)CapturedParameters[Counter],
                                           sizeof(UNICODE_STRING));

                            //
                            // Now probe the string
                            //

                            ProbeForRead (CapturedString.Buffer,
                                          CapturedString.MaximumLength,
                                          sizeof(UCHAR));
                        }
                    }
                }
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

        if ((ErrorStatus == STATUS_SYSTEM_IMAGE_BAD_SIGNATURE) &&
            (KdDebuggerEnabled)) {

            if ((NumberOfParameters != 0) && (ARGUMENT_PRESENT(Parameters))) {
                DbgPrint("****************************************************************\n");
                DbgPrint("* The system detected a bad signature on file %wZ\n",(PUNICODE_STRING)CapturedParameters[0]);
                DbgPrint("****************************************************************\n");
            }
            return STATUS_SUCCESS;
        }

        //
        // Call ExpRaiseHardError. All parameters are probed and everything
        // should be user-mode.
        // ExRaiseHardError will squirt all strings into user-mode
        // without any probing
        //

        Status = ExpRaiseHardError (ErrorStatus,
                                    NumberOfParameters,
                                    UnicodeStringParameterMask,
                                    CapturedParameters,
                                    ValidResponseOptions,
                                    &LocalResponse);

        try {
            *Response = LocalResponse;
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            NOTHING;
        }
    }
    else {
        Status = ExRaiseHardError (ErrorStatus,
                                   NumberOfParameters,
                                   UnicodeStringParameterMask,
                                   Parameters,
                                   ValidResponseOptions,
                                   &LocalResponse);

        *Response = LocalResponse;
    }

    return Status;
}

NTSTATUS
ExRaiseHardError (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    )
{
    NTSTATUS Status;
    PULONG_PTR ParameterBlock;
    PULONG_PTR UserModeParameterBase;
    PUNICODE_STRING UserModeStringsBase;
    PUCHAR UserModeStringDataBase;
    UNICODE_STRING CapturedStrings[MAXIMUM_HARDERROR_PARAMETERS];
    ULONG LocalResponse;
    ULONG Counter;
    SIZE_T UserModeSize;

    PAGED_CODE();

    //
    // If we are in the process of shutting down the system, do not allow
    // hard errors.
    //

    if (ExpTooLateForErrors) {

        *Response = ResponseNotHandled;

        return STATUS_SUCCESS;
    }

    ParameterBlock = NULL;

    //
    // If the parameters contain strings, we need to capture
    // the strings and the string descriptors and push them into
    // user-mode.
    //

    if (ARGUMENT_PRESENT(Parameters)) {
        if (UnicodeStringParameterMask) {

            //
            // We have strings - push them into usermode.
            //

            UserModeSize = (sizeof(ULONG_PTR)+sizeof(UNICODE_STRING))*MAXIMUM_HARDERROR_PARAMETERS;
            UserModeSize += sizeof(UNICODE_STRING);

            for (Counter = 0; Counter < NumberOfParameters; Counter += 1) {

                //
                // If there is a string in this position,
                // then probe and capture the string.
                //

                if (UnicodeStringParameterMask & 1<<Counter) {

                    RtlCopyMemory (&CapturedStrings[Counter],
                                   (PVOID)Parameters[Counter],
                                   sizeof(UNICODE_STRING));

                    UserModeSize += CapturedStrings[Counter].MaximumLength;
                }
            }

            //
            // Now we have the user-mode size all figured out.
            // Allocate some memory and point to it with the
            // parameter block. Then go through and copy all
            // of the parameters, string descriptors, and
            // string data into the memory.
            //

            Status = ZwAllocateVirtualMemory (NtCurrentProcess(),
                                              (PVOID *)&ParameterBlock,
                                              0,
                                              &UserModeSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE);

            if (!NT_SUCCESS(Status)) {
                return Status;
            }

            UserModeParameterBase = ParameterBlock;
            UserModeStringsBase = (PUNICODE_STRING)((PUCHAR)ParameterBlock + sizeof(ULONG_PTR)*MAXIMUM_HARDERROR_PARAMETERS);
            UserModeStringDataBase = (PUCHAR)UserModeStringsBase + sizeof(UNICODE_STRING)*MAXIMUM_HARDERROR_PARAMETERS;

            for (Counter = 0; Counter < NumberOfParameters; Counter += 1) {

                //
                // Copy parameters to user-mode portion of the address space.
                //

                if (UnicodeStringParameterMask & 1<<Counter) {

                    //
                    // Fix the parameter to point at the string descriptor slot
                    // in the user-mode buffer.
                    //

                    UserModeParameterBase[Counter] = (ULONG_PTR)&UserModeStringsBase[Counter];

                    //
                    // Copy the string data to user-mode.
                    //

                    RtlCopyMemory (UserModeStringDataBase,
                                   CapturedStrings[Counter].Buffer,
                                   CapturedStrings[Counter].MaximumLength);

                    CapturedStrings[Counter].Buffer = (PWSTR)UserModeStringDataBase;

                    //
                    // Copy the string descriptor.
                    //

                    RtlCopyMemory (&UserModeStringsBase[Counter],
                                   &CapturedStrings[Counter],
                                   sizeof(UNICODE_STRING));

                    //
                    // Adjust the string data base.
                    //

                    UserModeStringDataBase += CapturedStrings[Counter].MaximumLength;
                }
                else {
                    UserModeParameterBase[Counter] = Parameters[Counter];
                }
            }
        }
        else {
            ParameterBlock = Parameters;
        }
    }

    //
    // Call the hard error sender.
    //

    Status = ExpRaiseHardError (ErrorStatus,
                                NumberOfParameters,
                                UnicodeStringParameterMask,
                                ParameterBlock,
                                ValidResponseOptions,
                                &LocalResponse);

    //
    // If the parameter block was allocated, it needs to be freed.
    //

    if (ParameterBlock && ParameterBlock != Parameters) {
        UserModeSize = 0;
        ZwFreeVirtualMemory (NtCurrentProcess(),
                             (PVOID *)&ParameterBlock,
                             &UserModeSize,
                             MEM_RELEASE);
    }
    *Response = LocalResponse;

    return Status;
}

NTSTATUS
NtSetDefaultHardErrorPort (
    IN HANDLE DefaultHardErrorPort
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    if (!SeSinglePrivilegeCheck(SeTcbPrivilege, KeGetPreviousMode())) {
        return STATUS_PRIVILEGE_NOT_HELD;
    }

    if (ExReadyForErrors) {
        return STATUS_UNSUCCESSFUL;
    }

    Status = ObReferenceObjectByHandle (DefaultHardErrorPort,
                                        0,
                                        LpcPortObjectType,
                                        KeGetPreviousMode(),
                                        (PVOID *)&ExpDefaultErrorPort,
                                        NULL);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ExReadyForErrors = TRUE;
    ExpDefaultErrorPortProcess = PsGetCurrentProcess();
    ObReferenceObject (ExpDefaultErrorPortProcess);

    return STATUS_SUCCESS;
}

VOID
__cdecl
_purecall()
{
    ASSERTMSG("_purecall() was called", FALSE);
    ExRaiseStatus(STATUS_NOT_IMPLEMENTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\hdlsterm.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    hdlsterm.c

Abstract:

    This file implements functions for dealing with a terminal attached.

Author:

    Sean Selitrennikoff (v-seans) Oct, 1999

Environment:

    kernel mode

Revision History:

--*/

#include "exp.h"
#pragma hdrstop

#include <hdlsblk.h>
#include <hdlsterm.h>
#include <inbv.h>


//
// Defines for headless
//
//
#define HEADLESS_OOM_STRING L"Entry could not be recorded due to lack of memory.\n"
#define HEADLESS_LOG_NUMBER_OF_ENTRIES 256
#define HEADLESS_TMP_BUFFER_SIZE 80


//
// Note: HdlspAddLogEntry() allocates a buffer off the stack of this size, 
// so keep this number small.  Anything longer than 80 is probably useless, as 
// a VT100 can only handle 80 characters across.
// Do not make this any shorter than the string for HEADLESS_LOG_LOADING_FILENAME
//
#define HDLSP_LOG_MAX_STRING_LENGTH 80


#define HEADLESS_ACQUIRE_SPIN_LOCK() \
        if (!HeadlessGlobals->InBugCheck) { \
            KeAcquireSpinLock(&(HeadlessGlobals->SpinLock), &OldIrql); \
        } else { \
            OldIrql = (KIRQL)-1; \
        }

#define HEADLESS_RELEASE_SPIN_LOCK() \
        if (OldIrql != (KIRQL)-1) { \
            KeReleaseSpinLock(&(HeadlessGlobals->SpinLock), OldIrql); \
        } else { \
            ASSERT(HeadlessGlobals->InBugCheck); \
        }

#define COM1_PORT   0x03f8
#define COM2_PORT   0x02f8


//
// This table provides a quick lookup conversion between ASCII values
// that fall between 128 and 255, and their UNICODE counterpart.
//
// Note that ASCII values between 0 and 127 are equvilent to their
// unicode counter parts, so no lookups would be required.
//
// Therefore when using this table, remove the high bit from the ASCII
// value and use the resulting value as an offset into this array.  For
// example, 0x80 ->(remove the high bit) 00 -> 0x00C7.
//
USHORT PcAnsiToUnicode[0xFF] = {
        0x00C7,
        0x00FC,
        0x00E9,
        0x00E2,
        0x00E4,
        0x00E0,
        0x00E5,
        0x0087,
        0x00EA,
        0x00EB,
        0x00E8,
        0x00EF,
        0x00EE,
        0x00EC,
        0x00C4,
        0x00C5,
        0x00C9,
        0x00E6,
        0x00C6,
        0x00F4,
        0x00F6,
        0x00F2,
        0x00FB,
        0x00F9,
        0x00FF,
        0x00D6,
        0x00DC,
        0x00A2,
        0x00A3,
        0x00A5,
        0x20A7,
        0x0192,
        0x00E1,
        0x00ED,
        0x00F3,
        0x00FA,
        0x00F1,
        0x00D1,
        0x00AA,
        0x00BA,
        0x00BF,
        0x2310,
        0x00AC,
        0x00BD,
        0x00BC,
        0x00A1,
        0x00AB,
        0x00BB,
        0x2591,
        0x2592,
        0x2593,
        0x2502,
        0x2524,
        0x2561,
        0x2562,
        0x2556,
        0x2555,
        0x2563,
        0x2551,
        0x2557,
        0x255D,
        0x255C,
        0x255B,
        0x2510,
        0x2514,
        0x2534,
        0x252C,
        0x251C,
        0x2500,
        0x253C,
        0x255E,
        0x255F,
        0x255A,
        0x2554,
        0x2569,
        0x2566,
        0x2560,
        0x2550,
        0x256C,
        0x2567,
        0x2568,
        0x2564,
        0x2565,
        0x2559,
        0x2558,
        0x2552,
        0x2553,
        0x256B,
        0x256A,
        0x2518,
        0x250C,
        0x2588,
        0x2584,
        0x258C,
        0x2590,
        0x2580,
        0x03B1,
        0x00DF,
        0x0393,
        0x03C0,
        0x03A3,
        0x03C3,
        0x00B5,
        0x03C4,
        0x03A6,
        0x0398,
        0x03A9,
        0x03B4,
        0x221E,
        0x03C6,
        0x03B5,
        0x2229,
        0x2261,
        0x00B1,
        0x2265,
        0x2264,
        0x2320,
        0x2321,
        0x00F7,
        0x2248,
        0x00B0,
        0x2219,
        0x00B7,
        0x221A,
        0x207F,
        0x00B2,
        0x25A0,
        0x00A0
        };





//
// Log entry structure
//
typedef struct _HEADLESS_LOG_ENTRY {
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfEntry;
    PWCHAR String;
} HEADLESS_LOG_ENTRY, *PHEADLESS_LOG_ENTRY;

// Blue Screen Data Structure
//
typedef struct _HEADLESS_BLUE_SCREEN_DATA {
        PUCHAR Property;
        PUCHAR XMLData;
        struct _HEADLESS_BLUE_SCREEN_DATA *Next;
}HEADLESS_BLUE_SCREEN_DATA, * PHEADLESS_BLUE_SCREEN_DATA;

//
// Global variables headless component uses
//
typedef struct _HEADLESS_GLOBALS {
    
    //
    // Global spin lock for accessing headless internal routines.
    // 
    KSPIN_LOCK SpinLock;

    //
    // Handle for when routines are locked down into memory.
    //
    HANDLE PageLockHandle;

    //
    // List of log entries. 
    //
    PHEADLESS_LOG_ENTRY LogEntries;
    
    //
    // Global temp buffer, not to be held across lock release/acquires.
    //
    PUCHAR TmpBuffer;

    //
    // Current user input line
    //
    PUCHAR InputBuffer;

    //
    // Blue Screen Data 
    //
    PHEADLESS_BLUE_SCREEN_DATA BlueScreenData;

    //
    // Flags and parameters for determining headless state
    //
    union {
        struct {
            ULONG TerminalEnabled    : 1;
            ULONG InBugCheck         : 1;
            ULONG NewLogEntryAdded   : 1;
            ULONG UsedBiosSettings   : 1;
            ULONG InputProcessing    : 1;
            ULONG InputLineDone      : 1;
            ULONG ProcessingCmd      : 1;
            ULONG TerminalParity     : 1;
            ULONG TerminalStopBits   : 1;
            ULONG TerminalPortNumber : 3;
            ULONG IsNonLegacyDevice  : 1;
        };
        ULONG AllFlags;
    };

    //
    // Port settings
    //
    ULONG TerminalBaudRate;
    ULONG TerminalPort;
    PUCHAR TerminalPortAddress;
    LARGE_INTEGER DelayTime;            // in 100ns units
    ULONG MicroSecondsDelayTime;
    UCHAR TerminalType;                 // What kind of terminal do we think
                                        // we're talking to?
                                        // 0 = VT100
                                        // 1 = VT100+
                                        // 2 = VT-UTF8
                                        // 3 = PC ANSI
                                        // 4-255 = reserved


    //
    // Current location in Input buffer;
    //
    SIZE_T InputBufferIndex;

    //
    // Logging Indexes.
    //
    USHORT LogEntryLast;
    USHORT LogEntryStart;

    //
    // Machine's GUID.
    //
    GUID    SystemGUID;

    BOOLEAN IsMMIODevice;               // Is UART in SysIO or MMIO space?

    //
    // if this is TRUE, then the last character was a CR.
    // if this is TRUE and the current character is a LF, 
    //      then we filter the LF. 
    //
    BOOLEAN IsLastCharCR;

} HEADLESS_GLOBALS, *PHEADLESS_GLOBALS;


//
// The one and only resident global variable
//
PHEADLESS_GLOBALS HeadlessGlobals = NULL;


//
// Forward declarations.
//
NTSTATUS
HdlspDispatch(
    IN  HEADLESS_CMD Command,
    IN  PVOID  InputBuffer OPTIONAL,
    IN  SIZE_T InputBufferSize OPTIONAL,
    OUT PVOID OutputBuffer OPTIONAL,
    OUT PSIZE_T OutputBufferSize OPTIONAL
    );

NTSTATUS
HdlspEnableTerminal(
    BOOLEAN bEnable
    );

VOID
HdlspPutString(
    PUCHAR String
    );

VOID
HdlspPutData(
    PUCHAR InputBuffer,
    SIZE_T InputBufferLength
    );

BOOLEAN
HdlspGetLine(
    PUCHAR InputBuffer,
    SIZE_T InputBufferLength
    );

VOID
HdlspBugCheckProcessing(
    VOID
    );

VOID
HdlspProcessDumpCommand(
    IN BOOLEAN Paging
    );

VOID
HdlspPutMore(
    OUT PBOOLEAN Stop
    );

VOID
HdlspAddLogEntry(
    IN PWCHAR String
    );

NTSTATUS
HdlspSetBlueScreenInformation(
    IN PHEADLESS_CMD_SET_BLUE_SCREEN_DATA pData,
    IN SIZE_T cData
    );

VOID
HdlspSendBlueScreenInfo(
    ULONG BugcheckCode
    );

VOID
HdlspKernelAddLogEntry(
    IN ULONG StringCode,
    IN PUNICODE_STRING DriverName OPTIONAL
    );

VOID
HdlspSendStringAtBaud(
    IN PUCHAR String
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(INIT,     HeadlessInit)
#pragma alloc_text(PAGE,     HeadlessTerminalAddResources)
#pragma alloc_text(PAGEHDLS, HdlspDispatch)
#pragma alloc_text(PAGEHDLS, HdlspEnableTerminal)
#pragma alloc_text(PAGEHDLS, HdlspPutString)
#pragma alloc_text(PAGEHDLS, HdlspPutData)
#pragma alloc_text(PAGEHDLS, HdlspGetLine)
#pragma alloc_text(PAGEHDLS, HdlspBugCheckProcessing)
#pragma alloc_text(PAGEHDLS, HdlspProcessDumpCommand)
#pragma alloc_text(PAGEHDLS, HdlspPutMore)
#pragma alloc_text(PAGEHDLS, HdlspAddLogEntry)
#pragma alloc_text(PAGEHDLS, HdlspSetBlueScreenInformation)
#pragma alloc_text(PAGEHDLS, HdlspSendBlueScreenInfo)
#pragma alloc_text(PAGEHDLS, HdlspKernelAddLogEntry)
#pragma alloc_text(PAGEHDLS, HdlspSendStringAtBaud)
#endif



VOID
HeadlessInit(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine sets up all the information for supporting a headless terminal.  It
    does not initialize the terminal.

Arguments:

    
    HeadlessLoaderBlock - The loader block passed in from the loader. 
    
Environment:

    Only to be called at INIT time.

--*/
{
    PHEADLESS_LOADER_BLOCK HeadlessLoaderBlock;
    PHEADLESS_GLOBALS GlobalBlock;
    ULONG TmpUlong;


    if (LoaderBlock->Extension->HeadlessLoaderBlock == NULL) {
        return;
    }


    HeadlessLoaderBlock = LoaderBlock->Extension->HeadlessLoaderBlock;


    if ((HeadlessLoaderBlock->PortNumber <= 4) || (BOOLEAN)(HeadlessLoaderBlock->UsedBiosSettings)) {

        //
        // Allocate space for the global variables we will use.
        //
        GlobalBlock =  ExAllocatePoolWithTag(NonPagedPool,
                                             sizeof(HEADLESS_GLOBALS),
                                             ((ULONG)'sldH')
                                            );

        if (GlobalBlock == NULL) {

            return;
        }

        //
        // Start everything at zero, and then init the rest by hand.
        //
        RtlZeroMemory(GlobalBlock, sizeof(HEADLESS_GLOBALS));
        
        
        KeInitializeSpinLock(&(GlobalBlock->SpinLock));

        //
        // Copy stuff from loader block
        //
        GlobalBlock->TerminalPortNumber = HeadlessLoaderBlock->PortNumber;
        GlobalBlock->TerminalPortAddress = HeadlessLoaderBlock->PortAddress;
        GlobalBlock->TerminalBaudRate = HeadlessLoaderBlock->BaudRate;
        GlobalBlock->TerminalParity = (BOOLEAN)(HeadlessLoaderBlock->Parity);
        GlobalBlock->TerminalStopBits = HeadlessLoaderBlock->StopBits;
        GlobalBlock->UsedBiosSettings = (BOOLEAN)(HeadlessLoaderBlock->UsedBiosSettings);
        GlobalBlock->IsMMIODevice = (BOOLEAN)(HeadlessLoaderBlock->IsMMIODevice);
        GlobalBlock->IsLastCharCR = FALSE;
        GlobalBlock->TerminalType = (UCHAR)(HeadlessLoaderBlock->TerminalType);
        
        RtlCopyMemory( &GlobalBlock->SystemGUID,
                       &HeadlessLoaderBlock->SystemGUID,
                       sizeof(GUID) );


        //
        // We need to determine if this is a non-legacy device that we're
        // speaking through.  This can happen in several different ways,
        // including a PCI device placing a UART in System I/O space (which
        // wouldn't qualify as being "non-legacy"), or even a NON-PCI
        // device placing a UART up in MMIO (which again wouldn't qualify).
        //
        // Therefore, if the address is outside of System I/O, *or* if it's
        // sitting on a PCI device, then set the IsNonLegacyDevice entry.
        //
        if( GlobalBlock->IsMMIODevice ) {
            GlobalBlock->IsNonLegacyDevice = TRUE;
        }


        //
        // If we're speaking through a PCI device, we need to secure it.  We'll
        // use the debugger APIs to make sure the device is understood and that it
        // doesn't get moved.
        //
        if( (HeadlessLoaderBlock->PciDeviceId != (USHORT)0xFFFF) &&
            (HeadlessLoaderBlock->PciDeviceId != 0) &&
            (HeadlessLoaderBlock->PciVendorId != (USHORT)0xFFFF) &&
            (HeadlessLoaderBlock->PciVendorId != 0) ) {

            //
            // The loader thinks he spoke through a PCI device.  Remember
            // that it's non-legacy.
            //
            GlobalBlock->IsNonLegacyDevice = TRUE;

            //
            // Tell everyone else in the system to leave this device alone.
            // before we do that, the user may actually want PnP to enumerate the
            // device and possibly apply power management to it.  They can indicate
            // this by setting bit 0 of PciFlags.
            //
            if( !(HeadlessLoaderBlock->PciFlags & 0x1) ) {

                DEBUG_DEVICE_DESCRIPTOR  DebugDeviceDescriptor;

                RtlZeroMemory( &DebugDeviceDescriptor,
                               sizeof(DEBUG_DEVICE_DESCRIPTOR) );

                //
                // We're required to understand exactly what this structure looks like
                // because we need to set every value to (-1), then fill in only the
                // fields that we explicitly know about.
                //
                DebugDeviceDescriptor.DeviceID = HeadlessLoaderBlock->PciDeviceId;
                DebugDeviceDescriptor.VendorID = HeadlessLoaderBlock->PciVendorId;
                DebugDeviceDescriptor.Bus = HeadlessLoaderBlock->PciBusNumber;
                DebugDeviceDescriptor.Slot = HeadlessLoaderBlock->PciSlotNumber;

                //
                // Now fill in the rest with (-1).
                //
                DebugDeviceDescriptor.BaseClass = 0xFF;
                DebugDeviceDescriptor.SubClass = 0xFF;
                DebugDeviceDescriptor.ProgIf = 0xFF;


                //
                // Do it.
                //
                KdSetupPciDeviceForDebugging( LoaderBlock,
                                              &DebugDeviceDescriptor );
            }
        }



        //
        // Allocate space for log entries.
        //
        GlobalBlock->LogEntries = ExAllocatePoolWithTag(NonPagedPool,
                                                        HEADLESS_LOG_NUMBER_OF_ENTRIES *
                                                            sizeof(HEADLESS_LOG_ENTRY),
                                                        ((ULONG)'sldH')
                                                       );

        if (GlobalBlock->LogEntries == NULL) {

            goto Fail;
        }

        GlobalBlock->LogEntryLast = (USHORT)-1;
        GlobalBlock->LogEntryStart = (USHORT)-1;


        //
        // Allocate a temporary buffer for general use.
        //
        GlobalBlock->TmpBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                                       HEADLESS_TMP_BUFFER_SIZE,
                                                       ((ULONG)'sldH')
                                                      );

        if (GlobalBlock->TmpBuffer == NULL) {

            goto Fail;
        }

        GlobalBlock->InputBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                                         HEADLESS_TMP_BUFFER_SIZE,
                                                         ((ULONG)'sldH')
                                                        );

        if (GlobalBlock->InputBuffer == NULL) {

            goto Fail;
        }

        GlobalBlock->PageLockHandle = MmLockPagableCodeSection((PVOID)(ULONG_PTR)HdlspDispatch);

        if (GlobalBlock->PageLockHandle == NULL) {

            goto Fail;
        }

        //
        // Figure to delay time between bytes to satify the baud rate given.
        //
        if (GlobalBlock->TerminalBaudRate == 9600) {

            TmpUlong = GlobalBlock->TerminalBaudRate;

            //
            // Convert to chars per second.
            //
            TmpUlong = TmpUlong / 10;        // 10 bits per character (8-1-1) is the max.

            GlobalBlock->MicroSecondsDelayTime = ((1000000 /  TmpUlong) * 10) / 8;      // We will send at 80% speed to be sure.
            GlobalBlock->DelayTime.HighPart = -1;                                    
            GlobalBlock->DelayTime.LowPart = -10 * GlobalBlock->MicroSecondsDelayTime;  // relative time
        }

        HeadlessGlobals = GlobalBlock;

    }

    return;

Fail:

    if (GlobalBlock->LogEntries != NULL) {
        ExFreePool(GlobalBlock->LogEntries);
    }

    if (GlobalBlock->TmpBuffer != NULL) {
        ExFreePool(GlobalBlock->TmpBuffer);
    }

    if (GlobalBlock->InputBuffer != NULL) {
        ExFreePool(GlobalBlock->InputBuffer);
    }

    ExFreePool(GlobalBlock);
}


NTSTATUS
HeadlessDispatch(
    IN  HEADLESS_CMD Command,
    IN  PVOID   InputBuffer OPTIONAL,
    IN  SIZE_T  InputBufferSize OPTIONAL,
    OUT PVOID   OutputBuffer OPTIONAL,
    OUT PSIZE_T OutputBufferSize OPTIONAL
    )

/*++

Routine Description:

    This routine is the main entry point for all headless interaction with clients.

Arguments:
    
    Command - The command to execute.
    
    InputBuffer - An optionally supplied buffer containing input parameters.
    
    InputBufferSize - Size of the supplied input buffer.
    
    OutputBuffer - An optionally supplied buffer where to place output parameters.
    
    OutputBufferSize - Size of the supplied output buffer, if the buffer is too small
        then STATUS_BUFFER_TOO_SMALL is returned and this parameter contains the total
        bytes necessary to complete the operation.
    
Environment:

    If headless is enabled, it will acquire spin locks, so call from DPC level or 
    less, only from kernel mode.

--*/
{
    //
    // If headless is not enabled on this machine, then some commands need special
    // processing, and all other we fool by saying that it succeeded.
    //
    // If for some reason we were unable to lock the headless component down into
    // memory when we initialized, treat this as the terminal not being connected.
    //
    if ((HeadlessGlobals == NULL) || (HeadlessGlobals->PageLockHandle == NULL)) {

        if (Command == HeadlessCmdEnableTerminal) {
            return STATUS_UNSUCCESSFUL;
        }        
        
        //
        // The following command all have responses, so we must fill in the
        // correct response for when headless is not enabled.
        //
        if ((Command == HeadlessCmdQueryInformation) ||
            (Command == HeadlessCmdGetByte) ||
            (Command == HeadlessCmdGetLine) ||
            (Command == HeadlessCmdCheckForReboot) ||
            (Command == HeadlessCmdTerminalPoll)) {

            if ((OutputBuffer == NULL) || (OutputBufferSize == NULL)) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // All structures are designed such that a 0 or FALSE is the correct
            // response when headless is not present.
            //
            RtlZeroMemory(OutputBuffer, *OutputBufferSize);
        }

        return STATUS_SUCCESS;
    }

    return HdlspDispatch(Command, 
                         InputBuffer, 
                         InputBufferSize, 
                         OutputBuffer, 
                         OutputBufferSize
                        );

}


NTSTATUS
HdlspDispatch(
    IN  HEADLESS_CMD Command,
    IN  PVOID InputBuffer OPTIONAL,
    IN  SIZE_T InputBufferSize OPTIONAL,
    OUT PVOID OutputBuffer OPTIONAL,
    OUT PSIZE_T OutputBufferSize OPTIONAL
    )

/*++

Routine Description:

    This routine is the pageable version of the dispatch routine.

    In general this routine is not intended to be used by more than one thread at
    a time.  There are two exceptions, see below, but otherwise any second command
    that is submitted is rejected.
    
    There are only a couple of things that allowed to be called in parallel:
       AddLogEntry can be called when another command is being processed.
       StartBugCheck and BugCheckProcessing can as well.
    
    AddLogEntry is synchronized with all the other commands.  It atomically adds
    the entry while holding the spin lock. Thus, all other command should try and
    hold the spin lock when manipulating global variables.
    
    The BugCheck routines do not use any spinlocking - an unfortunate side effect 
    of that is that since another thread may still be executing and in this code, 
    terminal I/O is indeterminable during this time.  We cannot wait for the other 
    thread to exit, as it may be that thread itself has already been stopped.  Thus, 
    in the case of a bugcheck, this is unsolvable.  However, since bugchecks should 
    never happen - having the possibility of a small overlap is acceptable, since 
    the other thread either exits or is stopped, I/O will happen correctly with the 
    terminal.  This may require the user to press ENTER a couple of times, but that
    is acceptable in a bugcheck situation.
    
Arguments:
    
    Command - The command to execute.
    
    InputBuffer - An optionally supplied buffer containing input parameters.
    
    InputBufferSize - Size of the supplied input buffer.
    
    OutputBuffer - An optionally supplied buffer where to place output parameters.
    
    OutputBufferSize - Size of the supplied output buffer, if the buffer is too small
        then STATUS_BUFFER_TOO_SMALL is returned and this parameter contains the total
        bytes necessary to complete the operation.
    
Environment:

    Only called from HeadlessDispatch, which guarantees it is paged in and locked down.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR Tmp;
    UCHAR LocalBuffer[HEADLESS_TMP_BUFFER_SIZE];
    PHEADLESS_RSP_QUERY_INFO Response;
    KIRQL OldIrql;

    ASSERT(HeadlessGlobals != NULL);
    ASSERT(HeadlessGlobals->PageLockHandle != NULL);


    if ((Command != HeadlessCmdAddLogEntry) &&
        (Command != HeadlessCmdStartBugCheck) &&
        (Command != HeadlessCmdSendBlueScreenData) &&
        (Command != HeadlessCmdDoBugCheckProcessing)) {

        HEADLESS_ACQUIRE_SPIN_LOCK();

        if (HeadlessGlobals->ProcessingCmd) {
            
            HEADLESS_RELEASE_SPIN_LOCK();
            return STATUS_UNSUCCESSFUL;
        }
        
        HeadlessGlobals->ProcessingCmd = TRUE;

        HEADLESS_RELEASE_SPIN_LOCK();
    }

    //
    // Verify parameters for each command and then call the appropriate subroutine
    // to process it.
    //
    switch (Command) {

        //
        // Enable terminal
        //
    case HeadlessCmdEnableTerminal:
        
        if ((InputBuffer == NULL) || 
            (InputBufferSize != sizeof(HEADLESS_CMD_ENABLE_TERMINAL))) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        Status = HdlspEnableTerminal(((PHEADLESS_CMD_ENABLE_TERMINAL)InputBuffer)->Enable);
        goto EndOfFunction;


        //
        // Check for reboot string
        //
    case HeadlessCmdCheckForReboot:
        
        if ((OutputBuffer == NULL) || 
            (OutputBufferSize == NULL) ||
            (*OutputBufferSize != sizeof(HEADLESS_RSP_REBOOT))) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        if (HeadlessGlobals->TerminalEnabled) {

            if (HdlspGetLine(LocalBuffer, HEADLESS_TMP_BUFFER_SIZE)) {

                ((PHEADLESS_RSP_REBOOT)OutputBuffer)->Reboot = (BOOLEAN)
                       (!strcmp((LPCSTR)LocalBuffer, "reboot") || 
                        !strcmp((LPCSTR)LocalBuffer, "shutdown"));

            }

        } else {

            ((PHEADLESS_RSP_REBOOT)OutputBuffer)->Reboot = FALSE;

        }

        Status = STATUS_SUCCESS;
        goto EndOfFunction;



        //
        // Output a string.
        //
    case HeadlessCmdPutString:
        
        if (InputBuffer == NULL) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        if (HeadlessGlobals->TerminalEnabled) {

            HdlspPutString(&(((PHEADLESS_CMD_PUT_STRING)InputBuffer)->String[0]));

        }
        Status = STATUS_SUCCESS;
        goto EndOfFunction;
        

        //
        // Output a data stream.
        //
    case HeadlessCmdPutData:
        
        if ( (InputBuffer == NULL) ||
             (InputBufferSize == 0) ) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        if (HeadlessGlobals->TerminalEnabled) {

            HdlspPutData(&(((PHEADLESS_CMD_PUT_STRING)InputBuffer)->String[0]),
                         InputBufferSize);

        }
        Status = STATUS_SUCCESS;
        goto EndOfFunction;
        

        //
        // Poll for input
        //
    case HeadlessCmdTerminalPoll:
        
        if ((OutputBuffer == NULL) || 
            (OutputBufferSize == NULL) ||
            (*OutputBufferSize != sizeof(HEADLESS_RSP_POLL))) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        if (HeadlessGlobals->TerminalEnabled) {

            ((PHEADLESS_RSP_POLL)OutputBuffer)->QueuedInput = InbvPortPollOnly(HeadlessGlobals->TerminalPort);

        } else {

            ((PHEADLESS_RSP_POLL)OutputBuffer)->QueuedInput = FALSE;

        }

        Status = STATUS_SUCCESS;
        goto EndOfFunction;


        //
        // Get a single byte of input
        //
    case HeadlessCmdGetByte:
        
        if ((OutputBuffer == NULL) || 
            (OutputBufferSize == NULL) ||
            (*OutputBufferSize != sizeof(HEADLESS_RSP_GET_BYTE))) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        if (HeadlessGlobals->TerminalEnabled) {

            if (InbvPortPollOnly(HeadlessGlobals->TerminalPort)) {
                InbvPortGetByte(HeadlessGlobals->TerminalPort,
                                &(((PHEADLESS_RSP_GET_BYTE)OutputBuffer)->Value)
                               );
            } else {
                ((PHEADLESS_RSP_GET_BYTE)OutputBuffer)->Value = 0;
            }

        } else {

            ((PHEADLESS_RSP_GET_BYTE)OutputBuffer)->Value = 0;

        }

        Status = STATUS_SUCCESS;
        goto EndOfFunction;


        //
        // Get an entire line of input, if available.
        //
    case HeadlessCmdGetLine:
        
        if ((OutputBuffer == NULL) || 
            (OutputBufferSize == NULL) ||
            (*OutputBufferSize < sizeof(HEADLESS_RSP_GET_LINE))) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        if (HeadlessGlobals->TerminalEnabled) {

            ((PHEADLESS_RSP_GET_LINE)OutputBuffer)->LineComplete = 
                HdlspGetLine(&(((PHEADLESS_RSP_GET_LINE)OutputBuffer)->Buffer[0]),
                             *OutputBufferSize - 
                               sizeof(HEADLESS_RSP_GET_LINE) + 
                               sizeof(UCHAR)
                            );

        } else {

            ((PHEADLESS_RSP_GET_LINE)OutputBuffer)->LineComplete = FALSE;

        }

        Status = STATUS_SUCCESS;
        goto EndOfFunction;


        //
        // Let the kernel know to convert to bug check processing mode.
        //
    case HeadlessCmdStartBugCheck:
        
        HeadlessGlobals->InBugCheck = TRUE;
        Status = STATUS_SUCCESS;

        goto EndOfFunction;



        //
        // Process user I/O during a bugcheck
        //
    case HeadlessCmdDoBugCheckProcessing:
        
        if (HeadlessGlobals->TerminalEnabled) {

            //
            // NOTE: No spin lock here because we are in bugcheck.
            //
            HdlspBugCheckProcessing();

        }

        Status = STATUS_SUCCESS;
        goto EndOfFunction;


        //
        // Process query information command
        //
    case HeadlessCmdQueryInformation:
        
        if ((OutputBuffer == NULL) || 
            (OutputBufferSize == NULL) ||
            (*OutputBufferSize < sizeof(HEADLESS_RSP_QUERY_INFO))) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        Response = (PHEADLESS_RSP_QUERY_INFO)OutputBuffer;

        Response->PortType = HeadlessSerialPort;
        Response->Serial.TerminalAttached = TRUE;
        Response->Serial.UsedBiosSettings = (BOOLEAN)(HeadlessGlobals->UsedBiosSettings);
        Response->Serial.TerminalBaudRate = HeadlessGlobals->TerminalBaudRate;

        if( (HeadlessGlobals->TerminalPortNumber >= 1) ||  (BOOLEAN)(HeadlessGlobals->UsedBiosSettings) ) {

            Response->Serial.TerminalPort = HeadlessGlobals->TerminalPortNumber;
            Response->Serial.TerminalPortBaseAddress = HeadlessGlobals->TerminalPortAddress;
            Response->Serial.TerminalType = HeadlessGlobals->TerminalType;

        } else {

            Response->Serial.TerminalPort = SerialPortUndefined;
            Response->Serial.TerminalPortBaseAddress = 0;
            Response->Serial.TerminalType = HeadlessGlobals->TerminalType;

        }
        Status = STATUS_SUCCESS;
        goto EndOfFunction;


        //
        // Process add log entry command
        //
    case HeadlessCmdAddLogEntry:
        
        if (InputBuffer == NULL) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        ASSERT(KeIsExecutingDpc() == FALSE);

        HdlspAddLogEntry(&(((PHEADLESS_CMD_ADD_LOG_ENTRY)InputBuffer)->String[0]));
        Status = STATUS_SUCCESS;
        goto EndOfFunction;


        //
        // Print log entries
        //
    case HeadlessCmdDisplayLog:
        
        if ((InputBuffer == NULL) || 
            (InputBufferSize != sizeof(HEADLESS_CMD_DISPLAY_LOG))) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        HdlspProcessDumpCommand(((PHEADLESS_CMD_DISPLAY_LOG)InputBuffer)->Paging);
        Status = STATUS_SUCCESS;
        goto EndOfFunction;

        //
        // Various output commands
        //
    case HeadlessCmdClearDisplay:
    case HeadlessCmdClearToEndOfDisplay:
    case HeadlessCmdClearToEndOfLine:
    case HeadlessCmdDisplayAttributesOff:
    case HeadlessCmdDisplayInverseVideo:
    case HeadlessCmdSetColor:
    case HeadlessCmdPositionCursor:
        
        if (HeadlessGlobals->TerminalEnabled) {

            switch (Command) {
            case HeadlessCmdClearDisplay:
                Tmp = (PUCHAR)"\033[2J";
                break;

            case HeadlessCmdClearToEndOfDisplay:
                Tmp = (PUCHAR)"\033[0J";
                break;

            case HeadlessCmdClearToEndOfLine:
                Tmp = (PUCHAR)"\033[0K";
                break;

            case HeadlessCmdDisplayAttributesOff:
                Tmp = (PUCHAR)"\033[0m";
                break;

            case HeadlessCmdDisplayInverseVideo:
                Tmp = (PUCHAR)"\033[7m";
                break;

            case HeadlessCmdSetColor:

                if ((InputBuffer == NULL) || 
                    (InputBufferSize != sizeof(HEADLESS_CMD_SET_COLOR))) {
                    Status = STATUS_INVALID_PARAMETER;
                    goto EndOfFunction;
                }

                sprintf((LPSTR)LocalBuffer, 
                        "\033[%d;%dm", 
                        ((PHEADLESS_CMD_SET_COLOR)InputBuffer)->BkgColor, 
                        ((PHEADLESS_CMD_SET_COLOR)InputBuffer)->FgColor
                       );

                Tmp = &(LocalBuffer[0]);
                break;

            case HeadlessCmdPositionCursor:

                if ((InputBuffer == NULL) || 
                    (InputBufferSize != sizeof(HEADLESS_CMD_POSITION_CURSOR))) {
                    Status = STATUS_INVALID_PARAMETER;
                    goto EndOfFunction;
                }

                sprintf((LPSTR)LocalBuffer, 
                        "\033[%d;%dH", 
                        ((PHEADLESS_CMD_POSITION_CURSOR)InputBuffer)->Y + 1, 
                        ((PHEADLESS_CMD_POSITION_CURSOR)InputBuffer)->X + 1
                       );

                Tmp = &(LocalBuffer[0]);
                break;


            default:
                //
                // should never get here...
                //
                ASSERT(0);
                Status = STATUS_INVALID_PARAMETER;
                goto EndOfFunction;

            }

            HdlspSendStringAtBaud(Tmp);

        }
        Status = STATUS_SUCCESS;
        goto EndOfFunction;

    case HeadlessCmdSetBlueScreenData:

        if (InputBuffer == NULL) {
            return STATUS_INVALID_PARAMETER;
        }

        Status = HdlspSetBlueScreenInformation(InputBuffer, InputBufferSize);
        goto EndOfFunction;

    case HeadlessCmdSendBlueScreenData:            

        if (HeadlessGlobals->TerminalEnabled && HeadlessGlobals->InBugCheck) {

            if ((InputBuffer == NULL) || 
                (InputBufferSize != sizeof(HEADLESS_CMD_SEND_BLUE_SCREEN_DATA))) {
                ASSERT(0);
                return STATUS_INVALID_PARAMETER;
            }

            HdlspSendBlueScreenInfo(((PHEADLESS_CMD_SEND_BLUE_SCREEN_DATA)InputBuffer)->BugcheckCode);

            HdlspSendStringAtBaud((PUCHAR)"\n\r!SAC>");

        }
        goto EndOfFunction;

    case HeadlessCmdQueryGUID:
        
        if( (OutputBuffer == NULL) || 
            (OutputBufferSize == NULL) ||
            (*OutputBufferSize < sizeof(GUID)) ) {

            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        RtlCopyMemory( OutputBuffer,
                       &HeadlessGlobals->SystemGUID,
                       sizeof(GUID) );

        Status = STATUS_SUCCESS;
        goto EndOfFunction;


    default:
        Status = STATUS_INVALID_PARAMETER;
        goto EndOfFunction;
        
    }

EndOfFunction:

    if ((Command != HeadlessCmdAddLogEntry) &&
        (Command != HeadlessCmdStartBugCheck) &&
        (Command != HeadlessCmdSendBlueScreenData) &&
        (Command != HeadlessCmdDoBugCheckProcessing)) {

        ASSERT(HeadlessGlobals->ProcessingCmd);

        HeadlessGlobals->ProcessingCmd = FALSE;
    }

    return Status;
}

NTSTATUS
HdlspEnableTerminal(
    BOOLEAN bEnable
    )

/*++

Routine Description:

    This routine attempts to initialize the terminal, if there is one attached, or 
    disconnect the terminal.
    
    Note: Assumes it is called with the global spin lock held!

Arguments:

    bEnable - If TRUE, we will allow Inbv calls to display,
              otherwise we will not.
              
Returns:

    STATUS_SUCCESS if successful, else STATUS_UNSUCCESSFUL.

Environment:

    Only called from HdlspDispatch, which guarantees it is paged in and locked down.

--*/
{
    if ((bEnable == TRUE) && !HeadlessGlobals->TerminalEnabled) {

        HeadlessGlobals->TerminalEnabled = InbvPortInitialize(
                                               HeadlessGlobals->TerminalBaudRate, 
                                               HeadlessGlobals->TerminalPortNumber, 
                                               HeadlessGlobals->TerminalPortAddress, 
                                               &(HeadlessGlobals->TerminalPort),
                                               HeadlessGlobals->IsMMIODevice
                                              );

        if (!HeadlessGlobals->TerminalEnabled) {
            return STATUS_UNSUCCESSFUL;
        }

    } else if (bEnable == FALSE) {

        InbvPortTerminate(HeadlessGlobals->TerminalPort);

        HeadlessGlobals->TerminalPort = 0;
        HeadlessGlobals->TerminalEnabled = FALSE;

    }

    //
    // We know we want the FIFO on while using the headless port,
    // but we don't know if we should leave the FIFO on
    // after we disable the headless port.  Hence, we turn off
    // the FIFO when we disable the headless port.
    //
    // turn ON  the term port FIFO if we enable headless
    // turn OFF the term port FIFO if we disable headless
    //
    InbvPortEnableFifo(
        HeadlessGlobals->TerminalPort, 
        bEnable
        );
    
    return STATUS_SUCCESS;
}

VOID
UTF8Encode(
    USHORT  InputValue,
    PUCHAR UTF8Encoding
    )
/*++

Routine Description:

    Generates the UTF8 translation for a 16-bit value.

Arguments:

    InputValue - 16-bit value to be encoded.
    UTF8Encoding - receives the UTF8-encoding of the 16-bit value

Return Value:

    NONE.
--*/
{

    //
    // convert into UTF8 for actual transmission
    //
    // UTF-8 encodes 2-byte Unicode characters as follows:
    // If the first nine bits are zero (00000000 0xxxxxxx), encode it as one byte 0xxxxxxx
    // If the first five bits are zero (00000yyy yyxxxxxx), encode it as two bytes 110yyyyy 10xxxxxx
    // Otherwise (zzzzyyyy yyxxxxxx), encode it as three bytes 1110zzzz 10yyyyyy 10xxxxxx
    //
    if( (InputValue & 0xFF80) == 0 ) {
        //
        // if the top 9 bits are zero, then just
        // encode as 1 byte.  (ASCII passes through unchanged).
        //
        UTF8Encoding[2] = (UCHAR)(InputValue & 0xFF);
    } else if( (InputValue & 0xF700) == 0 ) {
        //
        // if the top 5 bits are zero, then encode as 2 bytes
        //
        UTF8Encoding[2] = (UCHAR)(InputValue & 0x3F) | 0x80;
        UTF8Encoding[1] = (UCHAR)((InputValue >> 6) & 0x1F) | 0xC0;
    } else {
        //
        // encode as 3 bytes
        //
        UTF8Encoding[2] = (UCHAR)(InputValue & 0x3F) | 0x80;
        UTF8Encoding[1] = (UCHAR)((InputValue >> 6) & 0x3F) | 0x80;
        UTF8Encoding[0] = (UCHAR)((InputValue >> 12) & 0xF) | 0xE0;
    }
}

VOID
HdlspPutString(
    PUCHAR String
    )

/*++

Routine Description:

    This routine writes a string out to the terminal. 
    
    Note: the routine assumes it is called with the global spin lock held.

Arguments:

    String - NULL terminated string to write.
    
Returns:

    None.

Environment:

    Only called from HdlspDispatch, which guarantees it is paged in and locked down.

--*/
{
    PUCHAR Src, Dest;
    UCHAR  Char = 0;

    //
    // We need to worry about sending a vt100 characters not in the standard
    // ASCII set, so we copy over only ASCII characters into a new buffer and
    // then send that one to the terminal.
    //
    Src = String;
    Dest = &(HeadlessGlobals->TmpBuffer[0]);

    while (*Src != '\0') {

        if (Dest >= &(HeadlessGlobals->TmpBuffer[HEADLESS_TMP_BUFFER_SIZE - 1])) {
            
            HeadlessGlobals->TmpBuffer[HEADLESS_TMP_BUFFER_SIZE - 1] = '\0';
            HdlspSendStringAtBaud(HeadlessGlobals->TmpBuffer);
            Dest = &(HeadlessGlobals->TmpBuffer[0]);

        } else {

            Char = *Src;

            //
            // filter some characters that aren't printable in VT100
            // into substitute characters which are printable
            //
            if (Char & 0x80) {

                switch (Char) {
                case 0xB0:  // Light shaded block
                case 0xB3:  // Light vertical
                case 0xBA:  // Double vertical line
                    Char = '|';
                    break;
                case 0xB1:  // Middle shaded block
                case 0xDC:  // Lower half block
                case 0xDD:  // Right half block
                case 0xDE:  // Left half block
                case 0xDF:  // Upper half block
                    Char = '%';
                    break;
                case 0xB2:  // Dark shaded block
                case 0xDB:  // Full block
                    Char = '#';
                    break;
                case 0xA9:  // Reversed NOT sign
                case 0xAA:  // NOT sign
                case 0xBB:  // ''
                case 0xBC:  // ''
                case 0xBF:  // ''
                case 0xC0:  // ''
                case 0xC8:  // ''
                case 0xC9:  // ''
                case 0xD9:  // ''
                case 0xDA:  // ''
                    Char = '+';
                    break;
                case 0xC4:  // ''
                    Char = '-';
                    break;
                case 0xCD:  // ''
                    Char = '=';
                    break;
                }

            }



            //
            // If the high-bit is still set, and we're here, then we are going to
            // spew UTF8-encoded data (assuming our terminal type says it's okay).
            //
            if( (Char & 0x80) ) {

                UCHAR  UTF8Encoding[3];
                ULONG  i;

                //
                // Lookup the Unicode equivilent of this 8-bit ANSI value.
                //
                UTF8Encode( PcAnsiToUnicode[(Char & 0x7F)],
                            UTF8Encoding );

                for( i = 0; i < 3; i++ ) {
                    if( UTF8Encoding[i] != 0 ) {
                        *Dest = UTF8Encoding[i];
                        Dest++;
                    }
                }


            } else {

                //
                // He's 7-bit ASCII.  Put it in the Destination buffer 
                // and move on.
                //
                *Dest = Char;
                Dest++;

            }

            Src++;

        }

    }

    *Dest = '\0';

    HdlspSendStringAtBaud(HeadlessGlobals->TmpBuffer);

}

VOID
HdlspPutData(
    PUCHAR InputBuffer,
    SIZE_T InputBufferSize  
    )

/*++

Routine Description:

    This routine writes an array of UCHARs out to the terminal. 
    
    Note: the routine assumes it is called with the global spin lock held.

Arguments:

    InputBuffer - Array of characters to write.
    
    InputBufferSize - Number of characters to write.
    
Returns:

    None.

Environment:

    Only called from HdlspDispatch, which guarantees it is paged in and locked down.

--*/
{
    KIRQL   CurrentIrql;
    ULONG   i;


    //
    // Get the data into our own buffer.
    //
    if( InputBufferSize > HEADLESS_TMP_BUFFER_SIZE ) {
        InputBufferSize = HEADLESS_TMP_BUFFER_SIZE;
    }

    RtlCopyMemory( &(HeadlessGlobals->TmpBuffer[0]),
                   InputBuffer,
                   InputBufferSize );


    //
    // Write the data out to the headless port.
    // NOTE: this code is very similar to HdlspSendStringAtBaud, so
    // be careful about modifying one without the other.
    //

    //
    // If we are in the worker thread, up the timer resolution so we can output
    // the string at the appropriate baud rate.
    //
    CurrentIrql = KeGetCurrentIrql();

    if (CurrentIrql < DISPATCH_LEVEL) {
        ExSetTimerResolution(-1 * HeadlessGlobals->DelayTime.LowPart, TRUE);
    }

    for (i = 0; i < InputBufferSize; i++) {
        
        InbvPortPutByte(HeadlessGlobals->TerminalPort, HeadlessGlobals->TmpBuffer[i]);

        if( HeadlessGlobals->TerminalBaudRate == 9600 ) {
            if (CurrentIrql < DISPATCH_LEVEL) {
                KeDelayExecutionThread(KernelMode, FALSE, &(HeadlessGlobals->DelayTime));
            } else {
                KeStallExecutionProcessor(HeadlessGlobals->MicroSecondsDelayTime);
            }
        }

    }

    //
    // If we are in the worker thread, reset the timer resolution.
    //
    if (CurrentIrql < DISPATCH_LEVEL) {
        ExSetTimerResolution(0, FALSE);
    }

}

BOOLEAN
HdlspGetLine(
    PUCHAR InputBuffer,
    SIZE_T InputBufferLength
    )


/*++

Routine Description:

    This function fills the given buffer with an input line, once the user has
    pressed return.  Until then it will return FALSE.  It strips of leading and
    trailing whitespace.

Arguments:

    InputBuffer - Place to store the terminal input line.
    
    InputBufferLength - Length, in bytes, of InputBuffer.

Return Value:

    TRUE if InputBuffer is filled, else FALSE.

Environment:

    Only called from HdlspDispatch, which guarantees it is paged in and locked down.

--*/

{
    UCHAR NewByte;
    SIZE_T i;
    KIRQL OldIrql;
    BOOLEAN CheckForLF;

    CheckForLF = FALSE;

    HEADLESS_ACQUIRE_SPIN_LOCK();

    if (HeadlessGlobals->InputProcessing) {
        HEADLESS_RELEASE_SPIN_LOCK();
        return FALSE;
    }

    HeadlessGlobals->InputProcessing = TRUE;

    HEADLESS_RELEASE_SPIN_LOCK();

    //
    // Check if we already have a line to be returned (could happen if 
    // InputBuffer is/was too small to contain the whole line)
    //
    if (HeadlessGlobals->InputLineDone) {
        goto ReturnInputLine;
    }

GetByte:

    if (!InbvPortPollOnly(HeadlessGlobals->TerminalPort) ||
        !InbvPortGetByte(HeadlessGlobals->TerminalPort, &NewByte)) {
        NewByte = 0;
    }

    // 
    // If no waiting input, leave
    //
    if (NewByte == 0) {
        HeadlessGlobals->InputProcessing = FALSE;
        return FALSE;
    }

    //
    // Store input character in our buffer
    //
    HeadlessGlobals->InputBuffer[HeadlessGlobals->InputBufferIndex] = NewByte;

    //
    // filter out the LF if we JUST received a CR
    //
    if (HeadlessGlobals->IsLastCharCR) {
        
        //
        // if this is a LF, then ignore it and go get the next character.
        // if this is NOT an LF, then there is nothing to do
        //
        if (NewByte == 0x0A) {
        
            HeadlessGlobals->IsLastCharCR = FALSE;
            
            goto GetByte;
        
        }

    }

    //
    // if this is a CR, then remember it
    //
    HeadlessGlobals->IsLastCharCR = (NewByte == 0x0D) ? TRUE : FALSE;

    // 
    // If this is a return, then we are done and need to return the line
    //
    if ((NewByte == (UCHAR)'\n') || (NewByte == (UCHAR)'\r')) {
        HdlspSendStringAtBaud((PUCHAR)"\r\n");
        HeadlessGlobals->InputBuffer[HeadlessGlobals->InputBufferIndex] = '\0';
        HeadlessGlobals->InputBufferIndex++;
        goto StripWhitespaceAndReturnLine;
    }

    //
    // If this is a backspace or delete, then we need to do that.
    //
    if ((NewByte == 0x8) || (NewByte == 0x7F)) {  // backspace (^H) or delete

        if (HeadlessGlobals->InputBufferIndex > 0) {
            HdlspSendStringAtBaud((PUCHAR)"\010 \010");
            HeadlessGlobals->InputBufferIndex--;
        }

    } else if (NewByte == 0x3) { // Control-C

        //
        // Terminate the string and return it.
        //
        HeadlessGlobals->InputBufferIndex++;
        HeadlessGlobals->InputBuffer[HeadlessGlobals->InputBufferIndex] = '\0';
        HeadlessGlobals->InputBufferIndex++;
        goto StripWhitespaceAndReturnLine;

    } else if ((NewByte == 0x9) || (NewByte == 0x1B)) { // Tab or Esc

        //
        // Ignore tabs and escapes
        //
        HdlspSendStringAtBaud((PUCHAR)"\007");
        HeadlessGlobals->InputProcessing = FALSE;
        return FALSE;

    } else if (HeadlessGlobals->InputBufferIndex == HEADLESS_TMP_BUFFER_SIZE - 2) {
        
        //
        // We are at the end of the buffer - remove the last character from 
        // the terminal screen and replace it with this one.
        //
        sprintf((LPSTR)HeadlessGlobals->TmpBuffer, "\010%c", NewByte);
        HdlspSendStringAtBaud(HeadlessGlobals->TmpBuffer);

    } else {

        //
        // Echo the character to the screen
        //
        sprintf((LPSTR)HeadlessGlobals->TmpBuffer, "%c", NewByte);
        HdlspSendStringAtBaud(HeadlessGlobals->TmpBuffer);
        HeadlessGlobals->InputBufferIndex++;

    }

    goto GetByte;

StripWhitespaceAndReturnLine:

    //
    // Before returning the input line, strip off all leading and trailing blanks
    //
    ASSERT(HeadlessGlobals->InputBufferIndex > 0);

    i = HeadlessGlobals->InputBufferIndex - 1;

    while ((i != 0) &&
           ((HeadlessGlobals->InputBuffer[i] == '\0') ||
            (HeadlessGlobals->InputBuffer[i] == ' ') ||
            (HeadlessGlobals->InputBuffer[i] == '\t'))) {
        i--;
    }

    if (HeadlessGlobals->InputBuffer[i] != '\0') {      
        HeadlessGlobals->InputBuffer[i + 1] = '\0';
    }

    i = 0;

    while ((HeadlessGlobals->InputBuffer[i] != '\0') &&
           ((HeadlessGlobals->InputBuffer[i] == '\t') ||
            (HeadlessGlobals->InputBuffer[i] == ' '))) {
        i++;
    }

    if (i != 0) {
        strcpy(
            (LPSTR)&(HeadlessGlobals->InputBuffer[0]), 
            (LPSTR)&(HeadlessGlobals->InputBuffer[i]));
    }

ReturnInputLine:

    //
    // Return the line.
    //

    if (InputBufferLength >= HeadlessGlobals->InputBufferIndex) {

        RtlCopyMemory(InputBuffer, HeadlessGlobals->InputBuffer, HeadlessGlobals->InputBufferIndex);
        HeadlessGlobals->InputBufferIndex = 0;
        HeadlessGlobals->InputLineDone = FALSE;

    } else {

        RtlCopyMemory(InputBuffer, HeadlessGlobals->InputBuffer, InputBufferLength);
        RtlCopyBytes(HeadlessGlobals->InputBuffer, 
                     &(HeadlessGlobals->InputBuffer[InputBufferLength]), 
                     HeadlessGlobals->InputBufferIndex - InputBufferLength
                    );
        HeadlessGlobals->InputLineDone = TRUE;
        HeadlessGlobals->InputBufferIndex -= InputBufferLength;

    }    

    HeadlessGlobals->InputProcessing = FALSE;

    return TRUE;
}

NTSTATUS
HeadlessTerminalAddResources(
    PCM_RESOURCE_LIST Resources,
    ULONG ResourceListSize,
    BOOLEAN TranslatedList,
    PCM_RESOURCE_LIST *NewList,
    PULONG NewListSize
    )


/*++

Routine Description:

    This function adds any resources that the terminal needs to the list of resources
    given, reallocating to a new block if necessary.

Arguments:

    Resources - The current resource list.
    
    ResourceListSize - Length, in bytes, of the list.
    
    TranslatedList - Is this a translated list or not.
    
    NewList - A pointer to an allocated new list, if headless adds something, otherwise
          it will return NULL, indicating no new resources were added.
    
    NewListSize - Returns the length, in bytes, of the returned list.

Return Value:

    STATUS_SUCCESS if successful, else STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR NewDescriptor;
    PHYSICAL_ADDRESS Address;
    PHYSICAL_ADDRESS TranslatedAddress;
    ULONG AddressSpace;

    if (HeadlessGlobals == NULL) {        
        *NewList = NULL;
        *NewListSize = 0;
        return STATUS_SUCCESS;
    }

    if( HeadlessGlobals->IsNonLegacyDevice ) {
        *NewList = NULL;
        *NewListSize = 0;
        return STATUS_SUCCESS;
    }

    //
    // Allocate space for a new list.
    //
    *NewListSize = ResourceListSize + sizeof(CM_FULL_RESOURCE_DESCRIPTOR);

    *NewList = (PCM_RESOURCE_LIST)ExAllocatePool(PagedPool, *NewListSize);
    
    if (*NewList == NULL) {
        *NewListSize = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy old list into the new buffer
    // 
    RtlCopyMemory(*NewList, Resources, ResourceListSize);

    Address.QuadPart = PtrToUlong(HeadlessGlobals->TerminalPortAddress);

    //
    // If this port information is supposed to be translated, do it.
    //
    if (TranslatedList) {
        AddressSpace = 1;   // Address space port.
        HalTranslateBusAddress(Internal,                    // device bus or internal
                               0,                           // bus number
                               Address,                     // source address
                               &AddressSpace,               // address space
                               &TranslatedAddress           // translated address
                              ); 

    } else {
        TranslatedAddress = Address;
    }


    //
    // Add our stuff to the end.
    //
    (*NewList)->Count++;

    NewDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)(((PUCHAR)(*NewList)) + ResourceListSize);

    NewDescriptor->BusNumber = 0;
    NewDescriptor->InterfaceType = Isa;

    NewDescriptor->PartialResourceList.Count = 1;
    NewDescriptor->PartialResourceList.Revision = 0;
    NewDescriptor->PartialResourceList.Version = 0;
    NewDescriptor->PartialResourceList.PartialDescriptors[0].Type = CmResourceTypePort;
    NewDescriptor->PartialResourceList.PartialDescriptors[0].ShareDisposition = 
        CmResourceShareDriverExclusive; 
    NewDescriptor->PartialResourceList.PartialDescriptors[0].Flags = CM_RESOURCE_PORT_IO;
    NewDescriptor->PartialResourceList.PartialDescriptors[0].u.Port.Start = 
        TranslatedAddress;
    NewDescriptor->PartialResourceList.PartialDescriptors[0].u.Port.Length = 0x8;

    return STATUS_SUCCESS;
}

VOID
HdlspBugCheckProcessing(
    VOID
    )
/*++

Routine Description:

    This function is used to prompt and display information to the user via the 
    terminal.  The system is assumed to be singly threaded and at a raised IRQL state.
    
    NOTE: This is pre-emptive to the system, so no locking required.

Arguments:

    None.

Return Value:

    None.
    
Environment:

    ONLY IN BUGCHECK!

--*/
{
    UCHAR InputBuffer[HEADLESS_TMP_BUFFER_SIZE];
    ULONG i;

    ASSERT(HeadlessGlobals->InBugCheck);

    //
    // Check for characters
    //
    if (HdlspGetLine(InputBuffer, HEADLESS_TMP_BUFFER_SIZE)) {
        
        //
        // Process the line
        //
        if ((_stricmp((LPCSTR)InputBuffer, "?") == 0) ||
            (_stricmp((LPCSTR)InputBuffer, "help") == 0)) {

            HdlspSendStringAtBaud((PUCHAR)"\r\n");
            HdlspSendStringAtBaud((PUCHAR)"d        Display all log entries, paging is on.\r\n");
            HdlspSendStringAtBaud((PUCHAR)"help     Display this list.\r\n");
            HdlspSendStringAtBaud((PUCHAR)"restart  Restart the system immediately.\r\n");
            HdlspSendStringAtBaud((PUCHAR)"?        Display this list.\r\n");
            HdlspSendStringAtBaud((PUCHAR)"\r\n");

        } else if (_stricmp((LPCSTR)InputBuffer, "d") == 0) {

            HdlspProcessDumpCommand(TRUE);

        } else if (_stricmp((LPCSTR)InputBuffer, "restart") == 0) {

            InbvSolidColorFill(0,0,639,479,0); // make the screen black
            for (i =0; i<10; i++) { // pause long enough for things to get out serial port
                KeStallExecutionProcessor(100000);
            }
            HalReturnToFirmware(HalRebootRoutine);

        } else {
            HdlspSendStringAtBaud((PUCHAR)"Type ? or Help for a list of commands.\r\n");
        }

        //
        // Put a new command prompt
        //
        HdlspSendStringAtBaud((PUCHAR)"\n\r!SAC>");
    }

}

VOID
HdlspProcessDumpCommand( 
    IN BOOLEAN Paging
    )
/*++

Routine Description:

    This function is used to display all current log entries.

Arguments:

    Paging - Should this do paging or not.

Return Value:

    None.

Environment: 
    
    May only be called from a raised IRQL if a StartBugCheck command has been issued.

--*/
{
    PHEADLESS_LOG_ENTRY LogEntry;
    ULONG LogEntryIndex;
    TIME_FIELDS TimeFields;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    ULONG LineNumber;
    BOOLEAN Stop;
    KIRQL OldIrql;
    
    HEADLESS_ACQUIRE_SPIN_LOCK();

    if (HeadlessGlobals->LogEntryStart == (USHORT)-1) {
        
        HEADLESS_RELEASE_SPIN_LOCK();
        return;
    }

    HeadlessGlobals->NewLogEntryAdded = FALSE;

    AnsiString.Length = 0;
    AnsiString.MaximumLength = HEADLESS_TMP_BUFFER_SIZE;
    AnsiString.Buffer = (PCHAR)HeadlessGlobals->TmpBuffer;

    LogEntryIndex = HeadlessGlobals->LogEntryStart;
    LineNumber = 0;

    while (TRUE) {

        LogEntry = &(HeadlessGlobals->LogEntries[LogEntryIndex]);

        //
        // Print the log entry out to the terminal.
        //

        HEADLESS_RELEASE_SPIN_LOCK();

        RtlTimeToTimeFields(&(LogEntry->TimeOfEntry.CurrentTime), &TimeFields);

        sprintf((LPSTR)HeadlessGlobals->TmpBuffer, 
                "%02d:%02d:%02d.%03d : ",
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second,
                TimeFields.Milliseconds
               );


        HdlspPutString(HeadlessGlobals->TmpBuffer);

        if (wcslen(LogEntry->String) >= HEADLESS_TMP_BUFFER_SIZE - 1) {
            LogEntry->String[HEADLESS_TMP_BUFFER_SIZE - 1] = UNICODE_NULL;
        }

        RtlInitUnicodeString(&UnicodeString, LogEntry->String);
        RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);        
        
        HEADLESS_ACQUIRE_SPIN_LOCK();

        if (HeadlessGlobals->NewLogEntryAdded) {

            //
            // Inform user and quite current output
            //
            HdlspPutString((PUCHAR)"New log entries have been added during dump, command aborted.\r\n");

            HEADLESS_RELEASE_SPIN_LOCK();
            return;
        }

        HdlspPutString(HeadlessGlobals->TmpBuffer);
        HdlspPutString((PUCHAR)"\r\n");
        LineNumber++;

        //
        // if last item, exit loop.
        //
        if (LogEntryIndex == HeadlessGlobals->LogEntryLast) {
            HEADLESS_RELEASE_SPIN_LOCK();
            return;
        }

        //
        // If screen is full, pause for paging.
        //
        if (Paging && (LineNumber > 20)) {

            HEADLESS_RELEASE_SPIN_LOCK();

            HdlspPutMore(&Stop);

            HEADLESS_ACQUIRE_SPIN_LOCK();

            if (Stop) {

                HdlspPutString((PUCHAR)"\r\n");

                HEADLESS_RELEASE_SPIN_LOCK();
                return;
            }

            if (HeadlessGlobals->NewLogEntryAdded) {

                //
                // Inform user and quite current output
                //
                HdlspPutString((PUCHAR)"New log entries have been added while waiting, command aborted.\r\n");

                HEADLESS_RELEASE_SPIN_LOCK();
                return;
            }

            LineNumber = 0;
        }

        //
        // Next entry please
        //
        LogEntryIndex++;
        LogEntryIndex %= HEADLESS_LOG_NUMBER_OF_ENTRIES;
    }
    
}

VOID
HdlspPutMore(
    OUT PBOOLEAN Stop
    )
/*++

Routine Description:

    This function is used to display a paging prompt.

Arguments:

    Stop - Returns TRUE if Control-C was pressed, else FALSE.

Return Value:

    Stop - Returns TRUE if Control-C was pressed, else FALSE.

--*/
{
    UCHAR Buffer[10];
    LARGE_INTEGER WaitTime;
    
    WaitTime.QuadPart = Int32x32To64((LONG)100, -1000); // 100ms from now.

    HdlspPutString((PUCHAR)"----Press <Enter> for more----");

    while (!HdlspGetLine(Buffer, 10)) {
        if (!HeadlessGlobals->InBugCheck) {
            KeDelayExecutionThread(KernelMode, FALSE, &WaitTime);
        }
    }
    if (Buffer[0] == 0x3) { // Control-C
        *Stop = TRUE;
    } else {
        *Stop = FALSE;
    }
    
    // 
    // Drain any remaining buffered input
    //
    while (HdlspGetLine(Buffer, 10)) {
    }
}

VOID
HdlspAddLogEntry(
    PWCHAR String
    )
/*++

Routine Description:

    This function is used to add a string to the internal log buffer.

Arguments:

    String - The string to add.

Return Value:

    None.
    
Environment:

    Only called from HdlspDispatch, which guarantees it is paged in and locked down.

--*/
{
    SIZE_T StringSize;
    PWCHAR OldString = NULL;    
    PWCHAR NewString;    
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfEntry;
    NTSTATUS Status;
    KIRQL OldIrql;

    StringSize = (wcslen(String) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

    //
    // Guard against ZwQuery..() call being paged out.
    //
    if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
        ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
        return;
    }

    //
    // Get the time so we can log it.
    //
    Status = ZwQuerySystemInformation(SystemTimeOfDayInformation,
                                      &TimeOfEntry,
                                      sizeof(TimeOfEntry),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {
        
        RtlZeroMemory(&TimeOfEntry, sizeof(TimeOfEntry));

    }
    
    //
    // Allocate a string for the log entry.
    //
    NewString = ExAllocatePoolWithTag(NonPagedPool, StringSize, ((ULONG)'sldH'));

    if (NewString != NULL) {
        RtlCopyMemory(NewString, String, StringSize);
    }

    HEADLESS_ACQUIRE_SPIN_LOCK();

    HeadlessGlobals->NewLogEntryAdded = TRUE;
    
    //
    // Get the entry to use.
    //
    HeadlessGlobals->LogEntryLast++;
    HeadlessGlobals->LogEntryLast %= HEADLESS_LOG_NUMBER_OF_ENTRIES;

    //
    // See if we have to move the start entry index
    //
    if (HeadlessGlobals->LogEntryLast == HeadlessGlobals->LogEntryStart) {

        //
        // Store away the old string so we can free it later.
        //
        if (wcscmp(HeadlessGlobals->LogEntries[HeadlessGlobals->LogEntryStart].String,
                   HEADLESS_OOM_STRING) != 0) {

            OldString = HeadlessGlobals->LogEntries[HeadlessGlobals->LogEntryStart].String;
        }

        HeadlessGlobals->LogEntryStart++;;
        HeadlessGlobals->LogEntryStart %= HEADLESS_LOG_NUMBER_OF_ENTRIES;

    } else if (HeadlessGlobals->LogEntryStart == (USHORT)-1) {

        HeadlessGlobals->LogEntryStart = 0;

    }


    //
    // Fill in the entry part
    //
    RtlCopyMemory(&(HeadlessGlobals->LogEntries[HeadlessGlobals->LogEntryLast].TimeOfEntry),
                  &(TimeOfEntry),
                  sizeof(TimeOfEntry)
                 );

    //
    // Set the entry pointer
    //
    if (NewString == NULL) {
        HeadlessGlobals->LogEntries[HeadlessGlobals->LogEntryLast].String = HEADLESS_OOM_STRING;
    } else {
        HeadlessGlobals->LogEntries[HeadlessGlobals->LogEntryLast].String = NewString;
    }

    HEADLESS_RELEASE_SPIN_LOCK();
    
    if (OldString != NULL) {
        ExFreePool(OldString);
    }

}


NTSTATUS
HdlspSetBlueScreenInformation(
    IN PHEADLESS_CMD_SET_BLUE_SCREEN_DATA pData,
    IN SIZE_T cData
    )
/*++

Routine Description:

    This routines allows components to set bugcheck information about the headless 
    terminal.

Arguments:

    pData - A pointer to the data, value pair to store.
    
    cData - Length, in bytes, of pData.

Return Value:

    Status of the operation - STATUS_SUCCESS, STATUS_NO_MEMORY e.g.

Environment: 

    HdlspDispatch guarantess only one person to enter this procedure.
    
    This is the only procedure modifying the HeadlessGlobals->BlueScreenData
    However, bugcheck processing uses this information to send it across the 
    blue screen at dispatch level. No hand shaking required except ensuring that 
    changes to the list are done such that once bugcheck processing starts, the list
    is unchanged. May cause a memory leak in a bugcheck situation, but in essence 
    that is better than an access violation, and acceptable since the machine is stopping.

--*/
{

    PHEADLESS_BLUE_SCREEN_DATA HeadlessProp,Prev;
    NTSTATUS Status;
    PUCHAR pVal,pOldVal;
    PUCHAR pNewVal;
    SIZE_T len;
    
    ASSERT(FIELD_OFFSET(HEADLESS_CMD_SET_BLUE_SCREEN_DATA,Data) == sizeof(ULONG));

    if (HeadlessGlobals->InBugCheck) { 
        return STATUS_UNSUCCESSFUL;
    }

    if ((pData == NULL) || 
        (pData->ValueIndex < 2) || // There must be at least two \0 characters in the pair.
        (pData->ValueIndex  >= (cData - sizeof(HEADLESS_CMD_SET_BLUE_SCREEN_DATA)) / sizeof (UCHAR)) ||
        (pData->Data[pData->ValueIndex-1] != '\0') ||
        (pData->Data[(cData - sizeof(HEADLESS_CMD_SET_BLUE_SCREEN_DATA))/sizeof(UCHAR)] != '\0' )) {

        return STATUS_INVALID_PARAMETER;
    }

    Status = STATUS_SUCCESS;

    //
    // Manipulation of this linked list is done only by this single entrant
    // function.
    //
    HeadlessProp = Prev = HeadlessGlobals->BlueScreenData;

    while (HeadlessProp) {

        if (strcmp((LPCSTR)HeadlessProp->Property, (LPCSTR)pData->Data) == 0) {
            break;
        }
        Prev = HeadlessProp;
        HeadlessProp = HeadlessProp->Next;
    }

    
    pVal = (PUCHAR)&((pData->Data)[pData->ValueIndex]);

    len = strlen((LPCSTR)pVal);    

    if (HeadlessProp != NULL) {

        //
        // The property exists. So replace it.
        //
        if (len) {

            //
            // need to replace old string.
            //
            pNewVal = (PUCHAR)ExAllocatePoolWithTag(NonPagedPool,
                                                   len+1,
                                                   ((ULONG)'sldH') 
                                                  );

            if (pNewVal) {
                strcpy( (LPSTR)pNewVal, (LPCSTR)pVal );

                pOldVal = HeadlessProp->XMLData;
                HeadlessProp->XMLData = pNewVal;

                if (HeadlessGlobals->InBugCheck == FALSE) {
                    ExFreePool(pOldVal);
                }

            } else {
                Status = STATUS_NO_MEMORY;
            }

        } else {

            //
            // We want to delete it, hence we passed an empty string
            //
            Prev->Next = HeadlessProp->Next;

            if (HeadlessGlobals->BlueScreenData == HeadlessProp) {
                HeadlessGlobals->BlueScreenData = Prev->Next;
            }

            if (HeadlessGlobals->InBugCheck == FALSE) {
                ExFreePool ( HeadlessProp->XMLData );
                ExFreePool ( HeadlessProp->Property );
                ExFreePool ( HeadlessProp );
            }

        }

    } else {
    
        //
        // Create a new Property-XMLValue Pair
        //
        if (len) { // Must be a non-empty string
            
            HeadlessProp = (PHEADLESS_BLUE_SCREEN_DATA)ExAllocatePoolWithTag(NonPagedPool,
                                                                             sizeof(HEADLESS_BLUE_SCREEN_DATA),
                                                                             ((ULONG) 'sldH' )
                                                                            );

            if (HeadlessProp) {
                
                HeadlessProp->XMLData = (PUCHAR)ExAllocatePoolWithTag(NonPagedPool,
                                                                      len+1,
                                                                      ((ULONG)'sldH')
                                                                     );
                if (HeadlessProp->XMLData) {

                    strcpy((LPSTR)HeadlessProp->XMLData,(LPCSTR)pVal);
                    pVal = pData->Data; 
                    len = strlen ((LPCSTR)pVal);

                    if (len) {

                        HeadlessProp->Property = (PUCHAR)ExAllocatePoolWithTag(NonPagedPool,
                                                                               len+1,
                                                                               ((ULONG)'sldH')
                                                                              );

                        if (HeadlessProp->Property) {

                            strcpy((LPSTR)HeadlessProp->Property,(LPCSTR) pVal);
                            HeadlessProp->Next = HeadlessGlobals->BlueScreenData;
                            HeadlessGlobals->BlueScreenData = HeadlessProp;

                        } else {
                            
                            Status = STATUS_NO_MEMORY;
                            ExFreePool(HeadlessProp->XMLData);
                            ExFreePool ( HeadlessProp );

                        }

                    } else { // empty property string ( will never come here ) 

                        Status = STATUS_INVALID_PARAMETER;
                        ExFreePool(HeadlessProp->XMLData);
                        ExFreePool(HeadlessProp);

                    }

                } else {

                    Status = STATUS_NO_MEMORY;
                    ExFreePool(HeadlessProp);

                }
            }

        } else {// empty value string.

            Status = STATUS_INVALID_PARAMETER;

        }

    }

    return Status;
}


VOID
HdlspSendBlueScreenInfo(
    ULONG BugcheckCode
    )
/*++

Routine Description:

    This routines dumps all the current blue screen data to the terminal.

Arguments:

    BugcheckCode - the NT defined bug check code.
    
Return Value:

    None.

Environment: 

    Only called once in a bugcheck.
    
--*/
{
    PHEADLESS_BLUE_SCREEN_DATA pData;
    UCHAR Temp[160];

    ASSERT(HeadlessGlobals->InBugCheck);

    HdlspSendStringAtBaud((PUCHAR)"\007\007\007<?xml>\007<BP>");

    HdlspSendStringAtBaud((PUCHAR)"\r\n<INSTANCE CLASSNAME=\"BLUESCREEN\">");

    sprintf((LPSTR)Temp,"\r\n<PROPERTY NAME=\"STOPCODE\" TYPE=\"string\"><VALUE>\"0x%0X\"</VALUE></PROPERTY>",BugcheckCode);

    HdlspSendStringAtBaud(Temp);

    pData = HeadlessGlobals->BlueScreenData;

    while (pData) {

        HdlspSendStringAtBaud(pData->XMLData);
        pData = pData->Next;

    }

    HdlspSendStringAtBaud((PUCHAR)"\r\n</INSTANCE>\r\n</BP>\007");

}

VOID
HeadlessKernelAddLogEntry(
    IN ULONG StringCode,
    IN PUNICODE_STRING DriverName OPTIONAL
    )

/*++

Routine Description:

    This routine adds a string to the headless log if possible.

Parameters:

    StringCode - The string to add.
    
    DriverName - An optional parameter that some string codes require.

Return Value:

    None.

--*/

{
    //
    // If headless not enabled, just exit now.
    //
    if ((HeadlessGlobals == NULL) || (HeadlessGlobals->PageLockHandle == NULL)) {
        return;
    }

    //
    // Call the paged version of this routine.  Note: it will not be paged here,
    // as the handle is non-NULL.
    //
    HdlspKernelAddLogEntry(StringCode, DriverName);
}

VOID
HdlspKernelAddLogEntry(
    IN ULONG StringCode,
    IN PUNICODE_STRING DriverName OPTIONAL
    )

/*++

Routine Description:

    This routine adds a string to the headless log if possible.

Parameters:

    StringCode - The string to add.
    
    DriverName - An optional parameter that some string codes require.

Return Value:

    None.

--*/

{
    PHEADLESS_CMD_ADD_LOG_ENTRY HeadlessLogEntry;
    UCHAR LocalBuffer[sizeof(HEADLESS_CMD_ADD_LOG_ENTRY) + 
                        (HDLSP_LOG_MAX_STRING_LENGTH * sizeof(WCHAR))];
    SIZE_T Index;
    SIZE_T StringLength;
    PWCHAR String;


    HeadlessLogEntry = (PHEADLESS_CMD_ADD_LOG_ENTRY)LocalBuffer;

    //
    // Get the string associated with this string code.
    //
    switch (StringCode) {
    case HEADLESS_LOG_LOADING_FILENAME:
        String = L"KRNL: Loading ";
        break;

    case HEADLESS_LOG_LOAD_SUCCESSFUL:
        String = L"KRNL: Load succeeded.";
        break;

    case HEADLESS_LOG_LOAD_FAILED:
        String = L"KRNL: Load failed.";
        break;

    case HEADLESS_LOG_EVENT_CREATE_FAILED:
        String = L"KRNL: Failed to create event.";
        break;

    case HEADLESS_LOG_OBJECT_TYPE_CREATE_FAILED:
        String = L"KRNL: Failed to create object types.";
        break;

    case HEADLESS_LOG_ROOT_DIR_CREATE_FAILED:
        String = L"KRNL: Failed to create root directories.";
        break;

    case HEADLESS_LOG_PNP_PHASE0_INIT_FAILED:
        String = L"KRNL: Failed to initialize (phase 0) plug and play services.";
        break;

    case HEADLESS_LOG_PNP_PHASE1_INIT_FAILED:
        String = L"KRNL: Failed to initialize (phase 1) plug and play services.";
        break;

    case HEADLESS_LOG_BOOT_DRIVERS_INIT_FAILED:
        String = L"KRNL: Failed to initialize boot drivers.";
        break;

    case HEADLESS_LOG_LOCATE_SYSTEM_DLL_FAILED:
        String = L"KRNL: Failed to locate system dll.";
        break;

    case HEADLESS_LOG_SYSTEM_DRIVERS_INIT_FAILED:
        String = L"KRNL: Failed to initialize system drivers.";
        break;
    
    case HEADLESS_LOG_ASSIGN_SYSTEM_ROOT_FAILED:
        String = L"KRNL: Failed to reassign system root.";
        break;

    case HEADLESS_LOG_PROTECT_SYSTEM_ROOT_FAILED:
        String = L"KRNL: Failed to protect system partition.";
        break;

    case HEADLESS_LOG_UNICODE_TO_ANSI_FAILED:
        String = L"KRNL: Failed to UnicodeToAnsi system root.";
        break;

    case HEADLESS_LOG_ANSI_TO_UNICODE_FAILED:
        String = L"KRNL: Failed to AnsiToUnicode system root.";
        break;

    case HEADLESS_LOG_FIND_GROUPS_FAILED:
        String = L"KRNL: Failed to find any groups.";
        break;

    case HEADLESS_LOG_WAIT_BOOT_DEVICES_DELETE_FAILED:
        String = L"KRNL: Failed waiting for boot devices to delete.";
        break;

    case HEADLESS_LOG_WAIT_BOOT_DEVICES_START_FAILED:
        String = L"KRNL: Failed waiting for boot devices to start.";
        break;

    case HEADLESS_LOG_WAIT_BOOT_DEVICES_REINIT_FAILED:
        String = L"KRNL: Failed waiting for boot devices to reinit.";
        break;

    case HEADLESS_LOG_MARK_BOOT_PARTITION_FAILED:
        String = L"KRNL: Failed marking boot partition.";
        break;

    default:
        ASSERT(0);
        String = NULL;
    }

    if (String != NULL) {
        
        //
        // Start by copying in the given string.
        //
        wcscpy(&(HeadlessLogEntry->String[0]), String);

    } else {

        HeadlessLogEntry->String[0] = UNICODE_NULL;

    }

    //
    // If this is the loading_filename command, then we need to append the
    // name to the end.
    //
    if ((StringCode == HEADLESS_LOG_LOADING_FILENAME) && (DriverName != NULL)) {

        ASSERT(String != NULL);

        StringLength = wcslen(String);

        //
        // Only copy as many bytes as we have room for.
        //
        if (DriverName->Length >= (HDLSP_LOG_MAX_STRING_LENGTH - StringLength)) {
            Index = (HDLSP_LOG_MAX_STRING_LENGTH - StringLength - 1);
        } else {
            Index = DriverName->Length / sizeof(WCHAR);
        }

        //
        // Copy in this many bytes.
        //
        RtlCopyBytes(&(HeadlessLogEntry->String[StringLength]),
                     DriverName->Buffer,
                     Index * sizeof(WCHAR)
                    );

        if (DriverName->Buffer[(DriverName->Length / sizeof(WCHAR)) - 1] != UNICODE_NULL) {
            HeadlessLogEntry->String[StringLength + Index] = UNICODE_NULL;
        }
    }

    //
    // Log it.
    //
    HdlspDispatch(HeadlessCmdAddLogEntry,
                  HeadlessLogEntry,
                  sizeof(HEADLESS_CMD_ADD_LOG_ENTRY) + 
                      (wcslen(&(HeadlessLogEntry->String[0])) * sizeof(WCHAR)),
                  NULL,
                  NULL
                 );
}

VOID
HdlspSendStringAtBaud(
    IN PUCHAR String
    )

/*++

Routine Description:

    This routine outputs a string one character at a time to the terminal, fitting the
    baud rate specified for the connection.

Parameters:

    String - The string to send.
    
Return Value:

    None.

--*/

{
    PUCHAR Dest;
    KIRQL CurrentIrql;

    CurrentIrql = KeGetCurrentIrql();

    //
    // If we are in the worker thread, up the timer resolution so we can output
    // the string at the appropriate baud rate.
    //
    if (CurrentIrql < DISPATCH_LEVEL) {
        ExSetTimerResolution(-1 * HeadlessGlobals->DelayTime.LowPart, TRUE);
    }

    for (Dest = String; *Dest != '\0'; Dest++) {
        
        InbvPortPutByte(HeadlessGlobals->TerminalPort, *Dest);

        if( HeadlessGlobals->TerminalBaudRate == 9600 ) {
            if (CurrentIrql < DISPATCH_LEVEL) {
                KeDelayExecutionThread(KernelMode, FALSE, &(HeadlessGlobals->DelayTime));
            } else {
                KeStallExecutionProcessor(HeadlessGlobals->MicroSecondsDelayTime);
            }
        }

    }

    //
    // If we are in the worker thread, reset the timer resolution.
    //
    if (CurrentIrql < DISPATCH_LEVEL) {
        ExSetTimerResolution(0, FALSE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\keyedevent.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    keyedevent.c

Abstract:

    This module houses routines that do keyed event processing.


Author:

    Neill Clift (NeillC) 25-Apr-2001


Revision History:

--*/
#include "exp.h"

#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpKeyedEventInitialization)
#pragma alloc_text(PAGE, NtCreateKeyedEvent)
#pragma alloc_text(PAGE, NtOpenKeyedEvent)
#pragma alloc_text(PAGE, NtReleaseKeyedEvent)
#pragma alloc_text(PAGE, NtWaitForKeyedEvent)
#endif

//
// Define the keyed event object type
//
typedef struct _KEYED_EVENT_OBJECT {
    EX_PUSH_LOCK Lock;
    LIST_ENTRY WaitQueue;
} KEYED_EVENT_OBJECT, *PKEYED_EVENT_OBJECT;

POBJECT_TYPE ExpKeyedEventObjectType;

//
// The low bit of the keyvalue signifies that we are a release thread waiting
// for the wait thread to enter the keyed event code.
//
#define KEYVALUE_RELEASE 1

#define LOCK_KEYED_EVENT_EXCLUSIVE(xxxKeyedEventObject,xxxCurrentThread) { \
    KeEnterCriticalRegionThread (&(xxxCurrentThread)->Tcb);                \
    ExAcquirePushLockExclusive (&(xxxKeyedEventObject)->Lock);             \
}

#define UNLOCK_KEYED_EVENT_EXCLUSIVE(xxxKeyedEventObject,xxxCurrentThread) { \
    ExReleasePushLockExclusive (&(xxxKeyedEventObject)->Lock);               \
    KeLeaveCriticalRegionThread (&(xxxCurrentThread)->Tcb);                  \
}

#define UNLOCK_KEYED_EVENT_EXCLUSIVE_UNSAFE(xxxKeyedEventObject) { \
    ExReleasePushLockExclusive (&(xxxKeyedEventObject)->Lock);     \
}

NTSTATUS
ExpKeyedEventInitialization (
    VOID
    )

/*++

Routine Description:

    Initialize the keyed event objects and globals.

Arguments:

    None.

Return Value:

    NTSTATUS - Status of call

--*/

{
    NTSTATUS Status;
    UNICODE_STRING Name;
    OBJECT_TYPE_INITIALIZER oti = {0};
    OBJECT_ATTRIBUTES oa;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    PACL Dacl;
    ULONG DaclLength;
    HANDLE KeyedEventHandle;
    GENERIC_MAPPING GenericMapping = {STANDARD_RIGHTS_READ | KEYEDEVENT_WAIT,
                                      STANDARD_RIGHTS_WRITE | KEYEDEVENT_WAKE,
                                      STANDARD_RIGHTS_EXECUTE,
                                      KEYEDEVENT_ALL_ACCESS};


    PAGED_CODE ();

    RtlInitUnicodeString (&Name, L"KeyedEvent");

    oti.Length                    = sizeof (oti);
    oti.InvalidAttributes         = 0;
    oti.PoolType                  = PagedPool;
    oti.ValidAccessMask           = KEYEDEVENT_ALL_ACCESS;
    oti.GenericMapping            = GenericMapping;
    oti.DefaultPagedPoolCharge    = 0;
    oti.DefaultNonPagedPoolCharge = 0;
    oti.UseDefaultObject          = TRUE;

    Status = ObCreateObjectType (&Name, &oti, NULL, &ExpKeyedEventObjectType);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Create a global object for processes that are out of memory
    //

    Status = RtlCreateSecurityDescriptor (&SecurityDescriptor,
                                          SECURITY_DESCRIPTOR_REVISION);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    DaclLength = sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) * 3 +
                 RtlLengthSid (SeLocalSystemSid) +
                 RtlLengthSid (SeAliasAdminsSid) +
                 RtlLengthSid (SeWorldSid);

    Dacl = ExAllocatePoolWithTag (PagedPool, DaclLength, 'lcaD');

    if (Dacl == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = RtlCreateAcl (Dacl, DaclLength, ACL_REVISION);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Dacl);
        return Status;
    }

    Status = RtlAddAccessAllowedAce (Dacl,
                                     ACL_REVISION,
                                     KEYEDEVENT_ALL_ACCESS,
                                     SeAliasAdminsSid);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Dacl);
        return Status;
    }

    Status = RtlAddAccessAllowedAce (Dacl,
                                     ACL_REVISION,
                                     KEYEDEVENT_ALL_ACCESS,
                                     SeLocalSystemSid);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Dacl);
        return Status;
    }

    Status = RtlAddAccessAllowedAce (Dacl,
                                     ACL_REVISION,
                                     KEYEDEVENT_WAIT|KEYEDEVENT_WAKE|READ_CONTROL,
                                     SeWorldSid);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Dacl);
        return Status;
    }
  
    Status = RtlSetDaclSecurityDescriptor (&SecurityDescriptor,
                                           TRUE,
                                           Dacl,
                                           FALSE);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Dacl);
        return Status;
    }

    RtlInitUnicodeString (&Name, L"\\KernelObjects\\CritSecOutOfMemoryEvent");
    InitializeObjectAttributes (&oa, &Name, OBJ_PERMANENT, NULL, &SecurityDescriptor);
    Status = ZwCreateKeyedEvent (&KeyedEventHandle,
                                 KEYEDEVENT_ALL_ACCESS,
                                 &oa,
                                 0);
    ExFreePool (Dacl);
    if (NT_SUCCESS (Status)) {
        Status = ZwClose (KeyedEventHandle);
    }

    return Status;
}

NTSTATUS
NtCreateKeyedEvent (
    OUT PHANDLE KeyedEventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG Flags
    )
/*++

Routine Description:

    Create a keyed event object and return its handle

Arguments:

    KeyedEventHandle - Address to store returned handle in

    DesiredAccess    - Access required to keyed event

    ObjectAttributes - Object attributes block to describe parent
                       handle and name of event

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status;
    PKEYED_EVENT_OBJECT KeyedEventObject;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;

    //
    // Get previous processor mode and probe output arguments if necessary.
    // Zero the handle for error paths.
    //

    PreviousMode = KeGetPreviousMode();

    try {
        if (PreviousMode != KernelMode) {
            ProbeForReadSmallStructure (KeyedEventHandle,
                                        sizeof (*KeyedEventHandle),
                                        sizeof (*KeyedEventHandle));
        }
        *KeyedEventHandle = NULL;

    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }

    if (Flags != 0) {
        return STATUS_INVALID_PARAMETER_4;
    }

    //
    // Create a new keyed event object and initialize it.
    //

    Status = ObCreateObject (PreviousMode,
                             ExpKeyedEventObjectType,
                             ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof (KEYED_EVENT_OBJECT),
                             0,
                             0,
                             &KeyedEventObject);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Initialize the lock and wait queue
    //
    ExInitializePushLock (&KeyedEventObject->Lock);
    InitializeListHead (&KeyedEventObject->WaitQueue);

    //
    // Insert the object into the handle table
    //
    Status = ObInsertObject (KeyedEventObject,
                             NULL,
                             DesiredAccess,
                             0,
                             NULL,
                             &Handle);


    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    try {
        *KeyedEventHandle = Handle;
    } except (ExSystemExceptionFilter ()) {
        //
        // The caller changed the page protection or deleted the momory for the handle.
        // No point closing the handle as process rundown will do that and we don't
        // know its still the same handle
        //
        Status = GetExceptionCode ();
    }

    return Status;
}

NTSTATUS
NtOpenKeyedEvent (
    OUT PHANDLE KeyedEventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
/*++

Routine Description:

    Open a keyed event object and return its handle

Arguments:

    KeyedEventHandle - Address to store returned handle in

    DesiredAccess    - Access required to keyed event

    ObjectAttributes - Object attributes block to describe parent
                       handle and name of event

Return Value:

    NTSTATUS - Status of call

--*/
{
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Get previous processor mode and probe output handle address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    try {
        if (PreviousMode != KernelMode) {
            ProbeForReadSmallStructure (KeyedEventHandle,
                                        sizeof (*KeyedEventHandle),
                                        sizeof (*KeyedEventHandle));
        }
        *KeyedEventHandle = NULL;
    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }

    //
    // Open handle to the keyed event object with the specified desired access.
    //

    Status = ObOpenObjectByName (ObjectAttributes,
                                 ExpKeyedEventObjectType,
                                 PreviousMode,
                                 NULL,
                                 DesiredAccess,
                                 NULL,
                                 &Handle);

    if (NT_SUCCESS (Status)) {
        try {
            *KeyedEventHandle = Handle;
        } except (ExSystemExceptionFilter ()) {
            Status = GetExceptionCode ();
        }
    }

    return Status;
}

NTSTATUS
NtReleaseKeyedEvent (
    IN HANDLE KeyedEventHandle,
    IN PVOID KeyValue,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
/*++

Routine Description:

    Release a previous or soon to be waiter with a matching key

Arguments:

    KeyedEventHandle - Handle to a keyed event

    KeyValue - Value to be used to match the waiter against

    Alertable - Should the wait be alertable, we rarely should have to wait

    Timeout   - Timout value for the wait, waits should be rare

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    PKEYED_EVENT_OBJECT KeyedEventObject;
    PETHREAD CurrentThread, TargetThread;
    PEPROCESS CurrentProcess;
    PLIST_ENTRY ListHead, ListEntry;
    LARGE_INTEGER TimeoutValue;
    PVOID OldKeyValue = NULL;

    if ((((ULONG_PTR)KeyValue) & KEYVALUE_RELEASE) != 0) {
        return STATUS_INVALID_PARAMETER_1;
    }

    CurrentThread = PsGetCurrentThread ();
    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (Timeout != NULL) {
        try {
            if (PreviousMode != KernelMode) {
                ProbeForRead (Timeout, sizeof (*Timeout), sizeof (UCHAR));
            }
            TimeoutValue = *Timeout;
            Timeout = &TimeoutValue;
        } except(ExSystemExceptionFilter ()) {
            return GetExceptionCode ();
        }
    }

    Status = ObReferenceObjectByHandle (KeyedEventHandle,
                                        KEYEDEVENT_WAKE,
                                        ExpKeyedEventObjectType,
                                        PreviousMode,
                                        &KeyedEventObject,
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    CurrentProcess = PsGetCurrentProcessByThread (CurrentThread);

    ListHead = &KeyedEventObject->WaitQueue;

    LOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);

    ListEntry = ListHead->Flink;
    while (1) {
        if (ListEntry == ListHead) {
            //
            // We could not find a key matching ours in the list.
            // Either somebody called us with wrong values or the waiter
            // has not managed to get queued yet. We wait ourselves
            // to be released by the waiter.
            //
            OldKeyValue = CurrentThread->KeyedWaitValue;
            CurrentThread->KeyedWaitValue = (PVOID) (((ULONG_PTR)KeyValue)|KEYVALUE_RELEASE);
            //
            // Insert the thread at the head of the list. We establish an invariant
            // were release waiters are always at the front of the queue to improve
            // the wait code since it only has to search as far as the first non-release
            // waiter.
            //
            InsertHeadList (ListHead, &CurrentThread->KeyedWaitChain);
            TargetThread = NULL;
            break;
        } else {
            TargetThread = CONTAINING_RECORD (ListEntry, ETHREAD, KeyedWaitChain);
            if (TargetThread->KeyedWaitValue == KeyValue &&
                THREAD_TO_PROCESS (TargetThread) == CurrentProcess) {
                RemoveEntryList (ListEntry);
                InitializeListHead (ListEntry);
                break;
            }
        }
        ListEntry = ListEntry->Flink;
    }

    //
    // Release the lock but leave APC's disabled.
    // This prevents us from being suspended and holding up the target.
    //
    UNLOCK_KEYED_EVENT_EXCLUSIVE_UNSAFE (KeyedEventObject);

    if (TargetThread != NULL) {
        KeReleaseSemaphore (&TargetThread->KeyedWaitSemaphore,
                            SEMAPHORE_INCREMENT,
                            1,
                            FALSE);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    } else {
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
        Status = KeWaitForSingleObject (&CurrentThread->KeyedWaitSemaphore,
                                        Executive,
                                        PreviousMode,
                                        Alertable,
                                        Timeout);

        //
        // If we were woken by termination then we must manualy remove
        // ourselves from the queue
        //
        if (Status != STATUS_SUCCESS) {
            BOOLEAN Wait = TRUE;

            LOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);
            if (!IsListEmpty (&CurrentThread->KeyedWaitChain)) {
                RemoveEntryList (&CurrentThread->KeyedWaitChain);
                InitializeListHead (&CurrentThread->KeyedWaitChain);
                Wait = FALSE;
            }
            UNLOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);
            //
            // If this thread was no longer in the queue then another thread
            // must be about to wake us up. Wait for that wake.
            //
            if (Wait) {
                KeWaitForSingleObject (&CurrentThread->KeyedWaitSemaphore,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
            }
        }
        CurrentThread->KeyedWaitValue = OldKeyValue;
    }

    ObDereferenceObject (KeyedEventObject);

    return Status;
}

NTSTATUS
NtWaitForKeyedEvent (
    IN HANDLE KeyedEventHandle,
    IN PVOID KeyValue,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
/*++

Routine Description:

    Wait on the keyed event for a specific release

Arguments:

    KeyedEventHandle - Handle to a keyed event

    KeyValue - Value to be used to match the release thread against

    Alertable - Makes the wait alertable or not

    Timeout - Timeout value for wait

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    PKEYED_EVENT_OBJECT KeyedEventObject;
    PETHREAD CurrentThread, TargetThread;
    PEPROCESS CurrentProcess;
    PLIST_ENTRY ListHead, ListEntry;
    LARGE_INTEGER TimeoutValue;
    PVOID OldKeyValue=NULL;

    if ((((ULONG_PTR)KeyValue) & KEYVALUE_RELEASE) != 0) {
        return STATUS_INVALID_PARAMETER_1;
    }

    CurrentThread = PsGetCurrentThread ();
    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (Timeout != NULL) {
        try {
            if (PreviousMode != KernelMode) {
                ProbeForRead (Timeout, sizeof (*Timeout), sizeof (UCHAR));
            }
            TimeoutValue = *Timeout;
            Timeout = &TimeoutValue;
        } except(ExSystemExceptionFilter ()) {
            return GetExceptionCode ();
        }
    }

    Status = ObReferenceObjectByHandle (KeyedEventHandle,
                                        KEYEDEVENT_WAIT,
                                        ExpKeyedEventObjectType,
                                        PreviousMode,
                                        &KeyedEventObject,
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    CurrentProcess = PsGetCurrentProcessByThread (CurrentThread);

    ListHead = &KeyedEventObject->WaitQueue;

    LOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);

    ListEntry = ListHead->Flink;
    while (1) {
        TargetThread = CONTAINING_RECORD (ListEntry, ETHREAD, KeyedWaitChain);
        if (ListEntry == ListHead ||
            (((ULONG_PTR)(TargetThread->KeyedWaitValue))&KEYVALUE_RELEASE) == 0) {
            //
            // We could not find a key matching ours in the list so we must wait
            //
            OldKeyValue = CurrentThread->KeyedWaitValue;
            CurrentThread->KeyedWaitValue = KeyValue;

            //
            // Insert the thread at the tail of the list. We establish an invariant
            // were waiters are always at the back of the queue behind releasers to improve
            // the wait code since it only has to search as far as the first non-release
            // waiter.
            //
            InsertTailList (ListHead, &CurrentThread->KeyedWaitChain);
            TargetThread = NULL;
            break;
        } else {
            if (TargetThread->KeyedWaitValue == (PVOID)(((ULONG_PTR)KeyValue)|KEYVALUE_RELEASE) &&
                THREAD_TO_PROCESS (TargetThread) == CurrentProcess) {
                RemoveEntryList (ListEntry);
                InitializeListHead (ListEntry);
                break;
            }
        }
        ListEntry = ListEntry->Flink;
    }
    //
    // Release the lock but leave APC's disabled.
    // This prevents us from being suspended and holding up the target.
    //
    UNLOCK_KEYED_EVENT_EXCLUSIVE_UNSAFE (KeyedEventObject);

    if (TargetThread == NULL) {
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
        Status = KeWaitForSingleObject (&CurrentThread->KeyedWaitSemaphore,
                                        Executive,
                                        PreviousMode,
                                        Alertable,
                                        Timeout);
        //
        // If we were woken by termination then we must manualy remove
        // ourselves from the queue
        //
        if (Status != STATUS_SUCCESS) {
            BOOLEAN Wait = TRUE;

            LOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);
            if (!IsListEmpty (&CurrentThread->KeyedWaitChain)) {
                RemoveEntryList (&CurrentThread->KeyedWaitChain);
                InitializeListHead (&CurrentThread->KeyedWaitChain);
                Wait = FALSE;
            }
            UNLOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);
            //
            // If this thread was no longer in the queue then another thread
            // must be about to wake us up. Wait for that wake.
            //
            if (Wait) {
                KeWaitForSingleObject (&CurrentThread->KeyedWaitSemaphore,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
            }
        }
        CurrentThread->KeyedWaitValue = OldKeyValue;
    } else {
        KeReleaseSemaphore (&TargetThread->KeyedWaitSemaphore,
                            SEMAPHORE_INCREMENT,
                            1,
                            FALSE);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    }

    ObDereferenceObject (KeyedEventObject);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\logger.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    logger.c

Abstract:

    This file contains the code for the debug logging facility.

Author:

    Steve Wood (stevewo) 20-Jun-1992

Environment:

    kernel mode callable only.

Revision History:

    20-Jun-1992 Steve Wood (stevewo) Created.

--*/

#include "exp.h"

PEX_DEBUG_LOG
ExCreateDebugLog(
    IN UCHAR MaximumNumberOfTags,
    IN ULONG MaximumNumberOfEvents
    )
{
    PEX_DEBUG_LOG Log;
    ULONG Size;

    Size = sizeof( EX_DEBUG_LOG ) +
            (MaximumNumberOfTags *
             sizeof( EX_DEBUG_LOG_TAG )
            ) +
            (MaximumNumberOfEvents *
             sizeof( EX_DEBUG_LOG_EVENT )
            );


    Log = ExAllocatePoolWithTag( NonPagedPool, Size, 'oLbD' );
    if (Log != NULL) {
        RtlZeroMemory( Log, Size );
        KeInitializeSpinLock( &Log->Lock );
        Log->MaximumNumberOfTags = MaximumNumberOfTags;
        Log->Tags = (PEX_DEBUG_LOG_TAG)(Log + 1);
        Log->First = (PEX_DEBUG_LOG_EVENT)(Log->Tags + MaximumNumberOfTags);
        Log->Last = Log->First + MaximumNumberOfEvents;
        Log->Next = Log->First;
        }

    return Log;
}

UCHAR
ExCreateDebugLogTag(
    IN PEX_DEBUG_LOG Log,
    IN PCHAR Name,
    IN UCHAR Format1,
    IN UCHAR Format2,
    IN UCHAR Format3,
    IN UCHAR Format4
    )
{
    KIRQL OldIrql;
    ULONG Size;
    PEX_DEBUG_LOG_TAG Tag;
    UCHAR TagIndex;
    PCHAR CapturedName;

    Size = strlen( Name );
    CapturedName = ExAllocatePoolWithTag( NonPagedPool, Size, 'oLbD' );
    RtlCopyMemory( CapturedName, Name, Size + 1 );

    ExAcquireSpinLock( &Log->Lock, &OldIrql );

    if (Log->NumberOfTags < Log->MaximumNumberOfTags) {
        TagIndex = (UCHAR)(Log->NumberOfTags++);
        Tag = &Log->Tags[ TagIndex ];
        Tag->Name = CapturedName;
        Tag->Format[ 0 ] = Format1;
        Tag->Format[ 1 ] = Format2;
        Tag->Format[ 2 ] = Format3;
        Tag->Format[ 3 ] = Format4;
        CapturedName = NULL;
        }
    else {
        TagIndex = (UCHAR)0xFF;
        }

    ExReleaseSpinLock( &Log->Lock, OldIrql );

    if (CapturedName != NULL) {
        ExFreePool( CapturedName );
        }
    return TagIndex;
}

VOID
ExDebugLogEvent(
    IN PEX_DEBUG_LOG Log,
    IN UCHAR Tag,
    IN ULONG Data1,
    IN ULONG Data2,
    IN ULONG Data3,
    IN ULONG Data4
    )
{
    KIRQL OldIrql;
    PEX_DEBUG_LOG_EVENT p;
    PETHREAD Thread = PsGetCurrentThread();
    LARGE_INTEGER CurrentTime;

    KeQuerySystemTime( &CurrentTime );

    ExAcquireSpinLock( &Log->Lock, &OldIrql );

    p = Log->Next;
    if (p == Log->Last) {
        p = Log->First;
        }
    Log->Next = p + 1;

    p->ThreadId = Thread->Cid.UniqueThread;
    p->ProcessId = Thread->Cid.UniqueProcess;
    p->Time = CurrentTime.LowPart;
    p->Tag = Tag;
    p->Data[ 0 ] = Data1;
    p->Data[ 1 ] = Data2;
    p->Data[ 2 ] = Data3;
    p->Data[ 3 ] = Data4;

    ExReleaseSpinLock( &Log->Lock, OldIrql );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\handle.c ===
/*++

Copyright (c) 1989-1995  Microsoft Corporation

Module Name:

    handle.c

Abstract:

    This module implements a set of functions for supporting handles.

Author:

    Steve Wood (stevewo) 25-Apr-1989
    David N. Cutler (davec) 17-May-1995 (rewrite)
    Gary Kimura (GaryKi) 9-Dec-1997 (rerewrite)

    Adrian Marinescu (adrmarin) 24-May-2000
        Support dynamic changes to the number of levels we use. The code
        performs the best for typical handle table sizes and scales better.

    Neill Clift (NeillC) 24-Jul-2000
        Make the handle allocate, free and duplicate paths mostly lock free except
        for the lock entry locks, table expansion and locks to solve the A-B-A problem.

Revision History:

--*/

#include "exp.h"
#pragma hdrstop


//
//  Local constants and support routines
//

//
//  Define global structures that link all handle tables together except the
//  ones where the user has called RemoveHandleTable
//

ERESOURCE HandleTableListLock;
ULONG TotalTraceBuffers = 0;

#if !DBG // Make this a const varible so its optimized away on free
const
#endif
BOOLEAN ExTraceAllTables = FALSE;

#ifdef ALLOC_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

LIST_ENTRY HandleTableListHead;


#ifdef ALLOC_PRAGMA
#pragma data_seg()
#endif


//
//  This is the sign low bit used to lock handle table entries
//

#define EXHANDLE_TABLE_ENTRY_LOCK_BIT    1

#define EX_ADDITIONAL_INFO_SIGNATURE (-2)

#define ExpIsValidObjectEntry(Entry) \
    ( (Entry != NULL) && (Entry->Object != NULL) && (Entry->NextFreeTableEntry != EX_ADDITIONAL_INFO_SIGNATURE) )


#define TABLE_PAGE_SIZE PAGE_SIZE

#define LOWLEVEL_COUNT (TABLE_PAGE_SIZE / sizeof(HANDLE_TABLE_ENTRY))
#define MIDLEVEL_COUNT (PAGE_SIZE / sizeof(PHANDLE_TABLE_ENTRY))
#define HIGHLEVEL_COUNT 32

#define LOWLEVEL_THRESHOLD LOWLEVEL_COUNT
#define MIDLEVEL_THRESHOLD (MIDLEVEL_COUNT * LOWLEVEL_COUNT)
#define HIGHLEVEL_THRESHOLD (MIDLEVEL_COUNT * MIDLEVEL_COUNT * LOWLEVEL_COUNT)

#define HIGHLEVEL_SIZE (HIGHLEVEL_COUNT * sizeof (PHANDLE_TABLE_ENTRY))

#define LEVEL_CODE_MASK 3

//
//  Local support routines
//

PHANDLE_TABLE
ExpAllocateHandleTable (
    IN PEPROCESS Process OPTIONAL
    );

VOID
ExpFreeHandleTable (
    IN PHANDLE_TABLE HandleTable
    );

BOOLEAN
ExpAllocateHandleTableEntrySlow (
    IN PHANDLE_TABLE HandleTable
    );

PHANDLE_TABLE_ENTRY
ExpAllocateHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    OUT PEXHANDLE Handle
    );

VOID
ExpFreeHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    IN EXHANDLE Handle,
    IN PHANDLE_TABLE_ENTRY HandleTableEntry
    );

PHANDLE_TABLE_ENTRY
ExpLookupHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    IN EXHANDLE Handle
    );

PHANDLE_TABLE_ENTRY *
ExpAllocateMidLevelTable (
    IN PHANDLE_TABLE HandleTable,
    OUT PHANDLE_TABLE_ENTRY *pNewLowLevel
    );

PVOID
ExpAllocateTablePagedPool (
    IN PEPROCESS QuotaProcess OPTIONAL,
    IN SIZE_T NumberOfBytes
    );

VOID
ExpFreeTablePagedPool (
    IN PEPROCESS QuotaProcess OPTIONAL,
    IN PVOID PoolMemory,
    IN SIZE_T NumberOfBytes
    );

PHANDLE_TABLE_ENTRY
ExpAllocateLowLevelTable (
    IN PHANDLE_TABLE HandleTable
    );

VOID
ExpFreeLowLevelTable (
    IN PEPROCESS QuotaProcess,
    IN PHANDLE_TABLE_ENTRY TableLevel1
    );

VOID
ExpBlockOnLockedHandleEntry (
    PHANDLE_TABLE HandleTable,
    PHANDLE_TABLE_ENTRY HandleTableEntry
    );

ULONG
ExpMoveFreeHandles (
    IN PHANDLE_TABLE HandleTable
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExInitializeHandleTablePackage)
#pragma alloc_text(INIT, ExSetHandleTableStrictFIFO)
#pragma alloc_text(PAGE, ExUnlockHandleTableEntry)
#pragma alloc_text(PAGE, ExCreateHandleTable)
#pragma alloc_text(PAGE, ExRemoveHandleTable)
#pragma alloc_text(PAGE, ExDestroyHandleTable)
#pragma alloc_text(PAGE, ExEnumHandleTable)
#pragma alloc_text(PAGE, ExDupHandleTable)
#pragma alloc_text(PAGE, ExSnapShotHandleTables)
#pragma alloc_text(PAGE, ExCreateHandle)
#pragma alloc_text(PAGE, ExDestroyHandle)
#pragma alloc_text(PAGE, ExChangeHandle)
#pragma alloc_text(PAGE, ExMapHandleToPointer)
#pragma alloc_text(PAGE, ExMapHandleToPointerEx)
#pragma alloc_text(PAGE, ExpAllocateHandleTable)
#pragma alloc_text(PAGE, ExpFreeHandleTable)
#pragma alloc_text(PAGE, ExpAllocateHandleTableEntry)
#pragma alloc_text(PAGE, ExpAllocateHandleTableEntrySlow)
#pragma alloc_text(PAGE, ExpFreeHandleTableEntry)
#pragma alloc_text(PAGE, ExpLookupHandleTableEntry)
#pragma alloc_text(PAGE, ExSweepHandleTable)
#pragma alloc_text(PAGE, ExpAllocateMidLevelTable)
#pragma alloc_text(PAGE, ExpAllocateTablePagedPool)
#pragma alloc_text(PAGE, ExpFreeTablePagedPool)
#pragma alloc_text(PAGE, ExpAllocateLowLevelTable)
#pragma alloc_text(PAGE, ExSetHandleInfo)
#pragma alloc_text(PAGE, ExpGetHandleInfo)
#pragma alloc_text(PAGE, ExSnapShotHandleTablesEx)
#pragma alloc_text(PAGE, ExpFreeLowLevelTable)
#pragma alloc_text(PAGE, ExpBlockOnLockedHandleEntry)
#pragma alloc_text(PAGE, ExpMoveFreeHandles)
#pragma alloc_text(PAGE, ExEnableHandleTracing)

#endif

//
// Define macros to lock and unlock the handle table.
// We use this lock only for handle table expansion.
//
#define ExpLockHandleTableExclusive(xxHandleTable,xxCurrentThread) { \
    KeEnterCriticalRegionThread (xxCurrentThread);                   \
    ExAcquirePushLockExclusive (&HandleTable->HandleTableLock[0]);   \
}


#define ExpUnlockHandleTableExclusive(xxHandleTable,xxCurrentThread) { \
    ExReleasePushLockExclusive (&HandleTable->HandleTableLock[0]);     \
    KeLeaveCriticalRegionThread (xxCurrentThread);                     \
}
    
#define ExpLockHandleTableShared(xxHandleTable,xxCurrentThread,xxIdx) { \
    KeEnterCriticalRegionThread (xxCurrentThread);                \
    ExAcquirePushLockShared (&HandleTable->HandleTableLock[Idx]);      \
}


#define ExpUnlockHandleTableShared(xxHandleTable,xxCurrentThread,xxIdx) { \
    ExReleasePushLockShared (&HandleTable->HandleTableLock[Idx]);        \
    KeLeaveCriticalRegionThread (xxCurrentThread);                  \
}



FORCEINLINE
ULONG
ExpInterlockedExchange (
    IN OUT PULONG Index,
    IN ULONG FirstIndex,
    IN PHANDLE_TABLE_ENTRY Entry
    )
{
    ULONG OldIndex, NewIndex;

    while (1) {
        OldIndex = *Index;
        //
        // We use this routine for a list push.
        //
        NewIndex = FirstIndex;
        Entry->NextFreeTableEntry = OldIndex;

        if (OldIndex == (ULONG) InterlockedCompareExchange ((PLONG)Index,
                                                            NewIndex,
                                                            OldIndex)) {
            return OldIndex;
        }
    }
}

ULONG
ExpMoveFreeHandles (
    IN PHANDLE_TABLE HandleTable
    )
{
    ULONG OldValue, NewValue;
    ULONG Index, OldIndex, NewIndex, FreeSize;
    PHANDLE_TABLE_ENTRY Entry, FirstEntry;
    EXHANDLE Handle;
    ULONG Idx;
    BOOLEAN StrictFIFO;

    //
    // First remove all the handles from the free list so we can add them to the
    // list we use for allocates.
    //

    OldValue = InterlockedExchange ((PLONG)&HandleTable->LastFree,
                                    0);
    Index = OldValue;
    if (Index == 0) {
        return OldValue;
    }

       
    //
    // We are pushing old entries onto the free list.
    // We have the A-B-A problem here as these items may have been moved here because
    // another thread was using them in the pop code.
    //
    for (Idx = 1; Idx < HANDLE_TABLE_LOCKS; Idx++) {
        ExAcquireReleasePushLockExclusive (&HandleTable->HandleTableLock[Idx]);
    }
    StrictFIFO = HandleTable->StrictFIFO;
 
    //
    // If we are strict FIFO then reverse the list to make handle reuse rare.
    //
    if (!StrictFIFO) {
        //
        // We have a complete chain here. If there is no existing chain we
        // can just push this one without any hassles. If we can't then
        // we can just fall into the reversing code anyway as we need
        // to find the end of the chain to continue it.
        //
        if (InterlockedCompareExchange ((PLONG)&HandleTable->FirstFree,
                                        OldValue,
                                        0) == 0) {
            return OldValue;
        }
    }

    //
    // Loop over all the entries and reverse the chain.
    //
    FreeSize = OldIndex = 0;
    FirstEntry = NULL;
    while (1) {
        FreeSize++;
        Handle.Value = Index;
        Entry = ExpLookupHandleTableEntry (HandleTable, Handle);
        NewIndex = Entry->NextFreeTableEntry;
        Entry->NextFreeTableEntry = OldIndex;
        if (OldIndex == 0) {
            FirstEntry = Entry;
        }
        OldIndex = Index;
        if (NewIndex == 0) {
            break;
        }
        Index = NewIndex;
    }

    NewValue = ExpInterlockedExchange (&HandleTable->FirstFree,
                                       OldIndex,
                                       FirstEntry);

    //
    // If we haven't got a pool of a few handles then force
    // table expansion to keep the free handle size high
    //
    if (FreeSize < 100 && StrictFIFO) {
        OldValue = 0;
    }
    return OldValue;
}


PHANDLE_TABLE_ENTRY
ExpAllocateHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    OUT PEXHANDLE pHandle
    )
/*++

Routine Description:

    This routine does a fast allocate of a free handle. It's lock free if
    possible.

    Only the rare case of handle table expansion is covered by the handle
    table lock.

Arguments:

    HandleTable - Supplies the handle table being allocated from.

    pHandle - Handle returned

Return Value:

    PHANDLE_TABLE_ENTRY - The allocated handle table entry pointer or NULL
                          on failure.

--*/
{
    PKTHREAD CurrentThread;
    ULONG OldValue, NewValue;
    PHANDLE_TABLE_ENTRY Entry;
    EXHANDLE Handle;
    BOOLEAN RetVal;
    ULONG Idx;


    CurrentThread = KeGetCurrentThread ();
    while (1) {

        OldValue = HandleTable->FirstFree;


        while (OldValue == 0) {
            //
            //  Lock the handle table for exclusive access as we will be
            //  allocating a new table level.
            //
            ExpLockHandleTableExclusive (HandleTable, CurrentThread);

            //
            // If we have multiple threads trying to expand the table at
            // the same time then by just acquiring the table lock we
            // force those threads to complete their allocations and
            // populate the free list. We must check the free list here
            // so we don't expand the list twice without needing to.
            //

            OldValue = HandleTable->FirstFree;
            if (OldValue != 0) {
                ExpUnlockHandleTableExclusive (HandleTable, CurrentThread);
                break;
            }

            //
            // See if we have any handles on the alternate free list
            // These handles need some locking to move them over.
            //
            OldValue = ExpMoveFreeHandles (HandleTable);
            if (OldValue != 0) {
                ExpUnlockHandleTableExclusive (HandleTable, CurrentThread);
                break;
            }

            //
            // This must be the first thread attempting expansion or all the
            // free handles allocated by another thread got used up in the gap.
            //

            RetVal = ExpAllocateHandleTableEntrySlow (HandleTable);

            ExpUnlockHandleTableExclusive (HandleTable, CurrentThread);


            OldValue = HandleTable->FirstFree;

            //
            // If ExpAllocateHandleTableEntrySlow had a failed allocation
            // then we want to fail the call.  We check for free entries
            // before we exit just in case they got allocated or freed by
            // somebody else in the gap.
            //

            if (!RetVal) {
                if (OldValue == 0) {
                    pHandle->GenericHandleOverlay = NULL;
                    return NULL;
                }            
            }
        }


        Handle.Value = OldValue;

        Entry = ExpLookupHandleTableEntry (HandleTable, Handle);

        Idx = (OldValue>>2) % HANDLE_TABLE_LOCKS;
        ExpLockHandleTableShared (HandleTable, CurrentThread, Idx);

        if (OldValue != *(volatile ULONG *) &HandleTable->FirstFree) {
            ExpUnlockHandleTableShared (HandleTable, CurrentThread, Idx);
            continue;
        }

        KeMemoryBarrier ();

        NewValue = *(volatile ULONG *) &Entry->NextFreeTableEntry;

        NewValue = InterlockedCompareExchange ((PLONG)&HandleTable->FirstFree,
                                               NewValue,
                                               OldValue);

        ExpUnlockHandleTableShared (HandleTable, CurrentThread, Idx);

        if (NewValue == OldValue) {
            break;
        }
    }
    InterlockedIncrement (&HandleTable->HandleCount);

    *pHandle = Handle;
    
    return Entry;
}


VOID
ExpBlockOnLockedHandleEntry (
    PHANDLE_TABLE HandleTable,
    PHANDLE_TABLE_ENTRY HandleTableEntry
    )
{
    EX_PUSH_LOCK_WAIT_BLOCK WaitBlock;
    LONG_PTR CurrentValue;

    //
    // Queue our wait block to be signaled by a releasing thread.
    //

    ExBlockPushLock (&HandleTable->HandleContentionEvent, &WaitBlock);

    CurrentValue = HandleTableEntry->Value;
    if (CurrentValue == 0 || (CurrentValue&EXHANDLE_TABLE_ENTRY_LOCK_BIT) != 0) {
        ExUnblockPushLock (&HandleTable->HandleContentionEvent, &WaitBlock);
    } else {
        ExWaitForUnblockPushLock (&HandleTable->HandleContentionEvent, &WaitBlock);
   }
}


BOOLEAN
FORCEINLINE
ExpLockHandleTableEntry (
    PHANDLE_TABLE HandleTable,
    PHANDLE_TABLE_ENTRY HandleTableEntry
    )

/*++

Routine Description:

    This routine locks the specified handle table entry.  After the entry is
    locked the sign bit will be set.

Arguments:

    HandleTable - Supplies the handle table containing the entry being locked.

    HandleTableEntry - Supplies the handle table entry being locked.

Return Value:

    TRUE if the entry is valid and locked, and FALSE if the entry is
    marked free.

--*/

{
    LONG_PTR NewValue;
    LONG_PTR CurrentValue;

    //
    // We are about to take a lock. Make sure we are protected.
    //
    ASSERT ((KeGetCurrentThread()->KernelApcDisable != 0) || (KeGetCurrentIrql() == APC_LEVEL));

    //
    //  We'll keep on looping reading in the value, making sure it is not null,
    //  and if it is not currently locked we'll try for the lock and return
    //  true if we get it.  Otherwise we'll pause a bit and then try again.
    //


    while (TRUE) {

        CurrentValue = *((volatile LONG_PTR *)&HandleTableEntry->Object);

        //
        //  If the handle value is greater than zero then it is not currently
        //  locked and we should try for the lock, by setting the lock bit and
        //  doing an interlocked exchange.
        //

        if (CurrentValue & EXHANDLE_TABLE_ENTRY_LOCK_BIT) {

            //
            // Remove the
            //
            NewValue = CurrentValue - EXHANDLE_TABLE_ENTRY_LOCK_BIT;

            if ((LONG_PTR)(InterlockedCompareExchangePointer (&HandleTableEntry->Object,
                                                              (PVOID)NewValue,
                                                              (PVOID)CurrentValue)) == CurrentValue) {

                return TRUE;
            }
        } else {
            //
            //  Make sure the handle table entry is not freed
            //

            if (CurrentValue == 0) {

                return FALSE;
            }
        }
        ExpBlockOnLockedHandleEntry (HandleTable, HandleTableEntry);
    }
}


NTKERNELAPI
VOID
ExUnlockHandleTableEntry (
    PHANDLE_TABLE HandleTable,
    PHANDLE_TABLE_ENTRY HandleTableEntry
    )

/*++

Routine Description:

    This routine unlocks the specified handle table entry.  After the entry is
    unlocked the sign bit will be clear.

Arguments:

    HandleTable - Supplies the handle table containing the entry being unlocked.

    HandleTableEntry - Supplies the handle table entry being unlocked.

Return Value:

    None.

--*/

{
    LONG_PTR NewValue;
    LONG_PTR CurrentValue;

    PAGED_CODE();

    //
    // We are about to release a lock. Make sure we are protected from suspension.
    //
    ASSERT ((KeGetCurrentThread()->KernelApcDisable != 0) || (KeGetCurrentIrql() == APC_LEVEL));

    //
    //  This routine does not need to loop and attempt the unlock opeation more
    //  than once because by definition the caller has the entry already locked
    //  and no one can be changing the value without the lock.
    //
    //  So we'll read in the current value, check that the entry is really
    //  locked, clear the lock bit and make sure the compare exchange worked.
    //

    CurrentValue = *((volatile LONG_PTR *)&HandleTableEntry->Object);

    NewValue = CurrentValue | EXHANDLE_TABLE_ENTRY_LOCK_BIT;

    if ( (CurrentValue == 0) ||
         (CurrentValue == NewValue) ) {

        KeBugCheckEx( BAD_EXHANDLE, __LINE__, (LONG_PTR)HandleTableEntry, NewValue, CurrentValue );
    }


    InterlockedExchangePointer (&HandleTableEntry->Object, (PVOID)NewValue);

    //
    // Unblock any waiters waiting for this table entry.
    //
    ExUnblockPushLock (&HandleTable->HandleContentionEvent, NULL);

    return;
}


NTKERNELAPI
VOID
ExInitializeHandleTablePackage (
    VOID
    )

/*++

Routine Description:

    This routine is called once at system initialization to setup the ex handle
    table package

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    //  Initialize the handle table synchronization resource and list head
    //

    InitializeListHead( &HandleTableListHead );
    ExInitializeResourceLite( &HandleTableListLock );

    return;
}


NTKERNELAPI
PHANDLE_TABLE
ExCreateHandleTable (
    IN struct _EPROCESS *Process OPTIONAL
    )

/*++

Routine Description:

    This function allocate and initialize a new new handle table

Arguments:

    Process - Supplies an optional pointer to the process against which quota
        will be charged.

Return Value:

    If a handle table is successfully created, then the address of the
    handle table is returned as the function value. Otherwize, a value
    NULL is returned.

--*/

{
    PKTHREAD CurrentThread;
    PHANDLE_TABLE HandleTable;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();

    //
    //  Allocate and initialize a handle table descriptor
    //

    HandleTable = ExpAllocateHandleTable( Process );

    if (HandleTable == NULL) {
        return NULL;
    }
    //
    //  Insert the handle table in the handle table list.
    //

    KeEnterCriticalRegionThread (CurrentThread);
    ExAcquireResourceExclusiveLite( &HandleTableListLock, TRUE );

    InsertTailList( &HandleTableListHead, &HandleTable->HandleTableList );

    ExReleaseResourceLite( &HandleTableListLock );
    KeLeaveCriticalRegionThread (CurrentThread);


    //
    //  And return to our caller
    //

    return HandleTable;
}


NTKERNELAPI
VOID
ExRemoveHandleTable (
    IN PHANDLE_TABLE HandleTable
    )

/*++

Routine Description:

    This function removes the specified exhandle table from the list of
    exhandle tables.  Used by PS and ATOM packages to make sure their handle
    tables are not in the list enumerated by the ExSnapShotHandleTables
    routine and the !handle debugger extension.

Arguments:

    HandleTable - Supplies a pointer to a handle table

Return Value:

    None.

--*/

{
    PKTHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();

    //
    //  First, acquire the global handle table lock
    //

    KeEnterCriticalRegionThread (CurrentThread);
    ExAcquireResourceExclusiveLite( &HandleTableListLock, TRUE );

    //
    //  Remove the handle table from the handle table list.  This routine is
    //  written so that multiple calls to remove a handle table will not
    //  corrupt the system.
    //

    RemoveEntryList( &HandleTable->HandleTableList );
    InitializeListHead( &HandleTable->HandleTableList );

    //
    //  Now release the global lock and return to our caller
    //

    ExReleaseResourceLite( &HandleTableListLock );
    KeLeaveCriticalRegionThread (CurrentThread);

    return;
}


NTKERNELAPI
VOID
ExDestroyHandleTable (
    IN PHANDLE_TABLE HandleTable,
    IN EX_DESTROY_HANDLE_ROUTINE DestroyHandleProcedure OPTIONAL
    )

/*++

Routine Description:

    This function destroys the specified handle table.

Arguments:

    HandleTable - Supplies a pointer to a handle table

    DestroyHandleProcedure - Supplies a pointer to a function to call for each
        valid handle entry in the handle table.

Return Value:

    None.

--*/

{
    EXHANDLE Handle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;

    PAGED_CODE();

    //
    //  Remove the handle table from the handle table list
    //

    ExRemoveHandleTable( HandleTable );

    //
    //  Iterate through the handle table and for each handle that is allocated
    //  we'll invoke the call back.  Note that this loop exits when we get a
    //  null handle table entry.  We know there will be no more possible
    //  entries after the first null one is encountered because we allocate
    //  memory of the handles in a dense fashion.  But first test that we have
    //  call back to use
    //

    if (ARGUMENT_PRESENT((ULONG_PTR)DestroyHandleProcedure)) {

        for (Handle.Value = 0;
             (HandleTableEntry = ExpLookupHandleTableEntry( HandleTable, Handle )) != NULL;
             Handle.Value += HANDLE_VALUE_INC) {

            //
            //  Only do the callback if the entry is not free
            //

            if ( ExpIsValidObjectEntry(HandleTableEntry) ) {

                (*DestroyHandleProcedure)( Handle.GenericHandleOverlay );
            }
        }
    }

    //
    //  Now free up the handle table memory and return to our caller
    //

    ExpFreeHandleTable( HandleTable );

    return;
}


NTKERNELAPI
VOID
ExSweepHandleTable (
    IN PHANDLE_TABLE HandleTable,
    IN EX_ENUMERATE_HANDLE_ROUTINE EnumHandleProcedure,
    IN PVOID EnumParameter
    )

/*++

Routine Description:

    This function sweeps a handle table in a unsynchronized manner.

Arguments:

    HandleTable - Supplies a pointer to a handle table

    EnumHandleProcedure - Supplies a pointer to a fucntion to call for
        each valid handle in the enumerated handle table.

    EnumParameter - Supplies an uninterpreted 32-bit value that is passed
        to the EnumHandleProcedure each time it is called.

Return Value:

    None.

--*/

{
    EXHANDLE Handle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;
    ULONG i;

    PAGED_CODE();

    //
    //  Iterate through the handle table and for each handle that is allocated
    //  we'll invoke the call back.  Note that this loop exits when we get a
    //  null handle table entry.  We know there will be no more possible
    //  entries after the first null one is encountered because we allocate
    //  memory of the handles in a dense fashion.
    //
    Handle.Value = HANDLE_VALUE_INC;

    while ((HandleTableEntry = ExpLookupHandleTableEntry( HandleTable, Handle )) != NULL) {

        for (i = 1; i < LOWLEVEL_COUNT; i++) {

            //
            //  Only do the callback if the entry is not free
            //

            if (ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {

                (*EnumHandleProcedure)( HandleTableEntry,
                                        Handle.GenericHandleOverlay,
                                        EnumParameter );
            }
            Handle.Value += HANDLE_VALUE_INC;
            HandleTableEntry++;
        }
        // Skip past the first entry that's not a real entry
        Handle.Value += HANDLE_VALUE_INC;
    }

    return;
}



NTKERNELAPI
BOOLEAN
ExEnumHandleTable (
    IN PHANDLE_TABLE HandleTable,
    IN EX_ENUMERATE_HANDLE_ROUTINE EnumHandleProcedure,
    IN PVOID EnumParameter,
    OUT PHANDLE Handle OPTIONAL
    )

/*++

Routine Description:

    This function enumerates all the valid handles in a handle table.
    For each valid handle in the handle table, the specified eumeration
    function is called. If the enumeration function returns TRUE, then
    the enumeration is stopped, the current handle is returned to the
    caller via the optional Handle parameter, and this function returns
    TRUE to indicated that the enumeration stopped at a specific handle.

Arguments:

    HandleTable - Supplies a pointer to a handle table.

    EnumHandleProcedure - Supplies a pointer to a fucntion to call for
        each valid handle in the enumerated handle table.

    EnumParameter - Supplies an uninterpreted 32-bit value that is passed
        to the EnumHandleProcedure each time it is called.

    Handle - Supplies an optional pointer a variable that receives the
        Handle value that the enumeration stopped at. Contents of the
        variable only valid if this function returns TRUE.

Return Value:

    If the enumeration stopped at a specific handle, then a value of TRUE
    is returned. Otherwise, a value of FALSE is returned.

--*/

{
    PKTHREAD CurrentThread;
    BOOLEAN ResultValue;
    EXHANDLE LocalHandle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();

    //
    //  Our initial return value is false until the enumeration callback
    //  function tells us otherwise
    //

    ResultValue = FALSE;

    //
    //  Iterate through the handle table and for each handle that is
    //  allocated we'll invoke the call back.  Note that this loop exits
    //  when we get a null handle table entry.  We know there will be no
    //  more possible entries after the first null one is encountered
    //  because we allocate memory for the handles in a dense fashion
    //

    KeEnterCriticalRegionThread (CurrentThread);

    for (LocalHandle.Value = 0; // does essentially the following "LocalHandle.Index = 0, LocalHandle.TagBits = 0;"
         (HandleTableEntry = ExpLookupHandleTableEntry( HandleTable, LocalHandle )) != NULL;
         LocalHandle.Value += HANDLE_VALUE_INC) {

        //
        //  Only do the callback if the entry is not free
        //

        if ( ExpIsValidObjectEntry( HandleTableEntry ) ) {

            //
            //  Lock the handle table entry because we're about to give
            //  it to the callback function, then release the entry
            //  right after the call back.
            //

            if (ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {

                //
                //  Invoke the callback, and if it returns true then set
                //  the proper output values and break out of the loop.
                //

                ResultValue = (*EnumHandleProcedure)( HandleTableEntry,
                                                      LocalHandle.GenericHandleOverlay,
                                                      EnumParameter );

                ExUnlockHandleTableEntry( HandleTable, HandleTableEntry );

                if (ResultValue) {
                    if (ARGUMENT_PRESENT( Handle )) {

                        *Handle = LocalHandle.GenericHandleOverlay;
                    }
                    break;
                }
            }
        }
    }
    KeLeaveCriticalRegionThread (CurrentThread);


    return ResultValue;
}


NTKERNELAPI
PHANDLE_TABLE
ExDupHandleTable (
    IN struct _EPROCESS *Process OPTIONAL,
    IN PHANDLE_TABLE OldHandleTable,
    IN EX_DUPLICATE_HANDLE_ROUTINE DupHandleProcedure OPTIONAL
    )

/*++

Routine Description:

    This function creates a duplicate copy of the specified handle table.

Arguments:

    Process - Supplies an optional to the process to charge quota to.

    OldHandleTable - Supplies a pointer to a handle table.

    DupHandleProcedure - Supplies an optional pointer to a function to call
        for each valid handle in the duplicated handle table.

Return Value:

    If the specified handle table is successfully duplicated, then the
    address of the new handle table is returned as the function value.
    Otherwize, a value NULL is returned.

--*/

{
    PKTHREAD CurrentThread;
    PHANDLE_TABLE NewHandleTable;
    EXHANDLE Handle;
    PHANDLE_TABLE_ENTRY OldHandleTableEntry;
    PHANDLE_TABLE_ENTRY NewHandleTableEntry;
    BOOLEAN FreeEntry;
    ULONG i;
    NTSTATUS Status;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();

    //
    //  First allocate a new handle table.  If this fails then
    //  return immediately to our caller
    //

    NewHandleTable = ExpAllocateHandleTable( Process );

    if (NewHandleTable == NULL) {

        return NULL;
    }


    //
    //  Now we'll build up the new handle table. We do this by calling
    //  allocating new handle table entries, and "fooling" the worker
    //  routine to allocate keep on allocating until the next free
    //  index needing pool are equal
    //
    while (NewHandleTable->NextHandleNeedingPool < OldHandleTable->NextHandleNeedingPool) {

        //
        //  Call the worker routine to grow the new handle table.  If
        //  not successful then free the new table as far as we got,
        //  set our output variable and exit out here
        //
        if (!ExpAllocateHandleTableEntrySlow (NewHandleTable)) {

            ExpFreeHandleTable (NewHandleTable);
            return NULL;
        }
    }

    //
    //  Now modify the new handle table to think it has zero handles
    //  and set its free list to start on the same index as the old
    //  free list
    //

    NewHandleTable->HandleCount = 0;
    NewHandleTable->ExtraInfoPages = 0;
    NewHandleTable->FirstFree = 0;

    //
    //  Now for every valid index value we'll copy over the old entry into
    //  the new entry
    //


    Handle.Value = HANDLE_VALUE_INC;

    KeEnterCriticalRegionThread (CurrentThread);
    while ((NewHandleTableEntry = ExpLookupHandleTableEntry( NewHandleTable, Handle )) != NULL) {

        //
        // Lookup the old entry. If it was being expanded then the old one
        // might not be there but we expanded the new table this far.
        //
        OldHandleTableEntry = ExpLookupHandleTableEntry( OldHandleTable, Handle );

        for (i = 1; i < LOWLEVEL_COUNT; i++) {

            //
            //  If the old entry is free then simply copy over the entire
            //  old entry to the new entry.  The lock command will tell us
            //  if the entry is free.
            //
            if (OldHandleTableEntry == NULL || OldHandleTableEntry->Object == NULL ||
                !ExpLockHandleTableEntry( OldHandleTable, OldHandleTableEntry )) {
                FreeEntry = TRUE;
            } else {

                PHANDLE_TABLE_ENTRY_INFO EntryInfo;
                
                //
                //  Otherwise we have a non empty entry.  So now copy it
                //  over, and unlock the old entry.  In both cases we bump
                //  the handle count because either the entry is going into
                //  the new table or we're going to remove it with Exp Free
                //  Handle Table Entry which will decrement the handle count
                //

                *NewHandleTableEntry = *OldHandleTableEntry;

                //
                //  Copy the entry info data, if any
                //

                Status = STATUS_SUCCESS;
                EntryInfo = ExGetHandleInfo(OldHandleTable, Handle.GenericHandleOverlay, TRUE);

                if (EntryInfo) {

                    Status = ExSetHandleInfo(NewHandleTable, Handle.GenericHandleOverlay, EntryInfo, TRUE);
                }


                //
                //  Invoke the callback and if it returns true then we
                //  unlock the new entry
                //

                if (NT_SUCCESS (Status)) {
                    if  ((*DupHandleProcedure) (Process,
                                                OldHandleTable,
                                                OldHandleTableEntry,
                                                NewHandleTableEntry)) {

                        ExUnlockHandleTableEntry (NewHandleTable, NewHandleTableEntry);
                        NewHandleTable->HandleCount += 1;
                        FreeEntry = FALSE;
                    } else {
                        if (EntryInfo) {
                            EntryInfo->AuditMask = 0;
                        }

                        FreeEntry = TRUE;
                    }
                } else {
                    //
                    // Duplicate routine doesn't want this handle duplicated so free it
                    //
                    ExUnlockHandleTableEntry( OldHandleTable, OldHandleTableEntry );
                    FreeEntry = TRUE;
                }

            }
            if (FreeEntry) {
                NewHandleTableEntry->Object = NULL;
                NewHandleTableEntry->NextFreeTableEntry =
                    NewHandleTable->FirstFree;
                NewHandleTable->FirstFree = (ULONG) Handle.Value;
            }
            Handle.Index++;;
            NewHandleTableEntry++;
            if (OldHandleTableEntry != NULL) {
                OldHandleTableEntry++;
            }
        }
        Handle.Value += HANDLE_VALUE_INC; // Skip past the first entry thats not a real entry
    }

    //
    //  Insert the handle table in the handle table list.
    //

    ExAcquireResourceExclusiveLite( &HandleTableListLock, TRUE );

    InsertTailList( &HandleTableListHead, &NewHandleTable->HandleTableList );

    ExReleaseResourceLite( &HandleTableListLock );
    KeLeaveCriticalRegionThread (CurrentThread);

    //
    //  lastly return the new handle table to our caller
    //

    return NewHandleTable;
}


NTKERNELAPI
NTSTATUS
ExSnapShotHandleTables (
    IN PEX_SNAPSHOT_HANDLE_ENTRY SnapShotHandleEntry,
    IN OUT PSYSTEM_HANDLE_INFORMATION HandleInformation,
    IN ULONG Length,
    IN OUT PULONG RequiredLength
    )

/*++

Routine Description:

    This function visits and invokes the specified callback for every valid
    handle that it can find off of the handle table.

Arguments:

    SnapShotHandleEntry - Supplies a pointer to a function to call for
        each valid handle we encounter.

    HandleInformation - Supplies a handle information structure to
        be filled in for each handle table we encounter.  This routine
        fills in the handle count, but relies on a callback to fill in
        entry info fields.

    Length - Supplies a parameter for the callback.  In reality this is
        the total size, in bytes, of the Handle Information buffer.

    RequiredLength - Supplies a parameter for the callback.  In reality
        this is a final size in bytes used to store the requested
        information.

Return Value:

    The last return status of the callback

--*/

{
    NTSTATUS Status;
    PKTHREAD CurrentThread;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO HandleEntryInfo;
    PLIST_ENTRY NextEntry;
    PHANDLE_TABLE HandleTable;
    EXHANDLE Handle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();


    Status = STATUS_SUCCESS;

    //
    //  Setup the output buffer pointer that the callback will maintain
    //

    HandleEntryInfo = &HandleInformation->Handles[0];

    //
    //  Zero out the handle count
    //

    HandleInformation->NumberOfHandles = 0;

    //
    //  Lock the handle table list exclusive and traverse the list of handle
    //  tables.
    //

    KeEnterCriticalRegionThread (CurrentThread);
    ExAcquireResourceExclusiveLite( &HandleTableListLock, TRUE );

    //
    //  Iterate through all the handle tables in the system.
    //

    for (NextEntry = HandleTableListHead.Flink;
         NextEntry != &HandleTableListHead;
         NextEntry = NextEntry->Flink) {

        //
        //  Get the address of the next handle table, lock the handle
        //  table exclusive, and scan the list of handle entries.
        //

        HandleTable = CONTAINING_RECORD( NextEntry,
                                         HANDLE_TABLE,
                                         HandleTableList );


        //  Iterate through the handle table and for each handle that
        //  is allocated we'll invoke the call back.  Note that this
        //  loop exits when we get a null handle table entry.  We know
        //  there will be no more possible entries after the first null
        //  one is encountered because we allocate memory of the
        //  handles in a dense fashion
        //

        for (Handle.Value = 0;
             (HandleTableEntry = ExpLookupHandleTableEntry( HandleTable, Handle )) != NULL;
             Handle.Value += HANDLE_VALUE_INC) {

            //
            //  Only do the callback if the entry is not free
            //

            if ( ExpIsValidObjectEntry(HandleTableEntry) ) {

                //
                //  Increment the handle count information in the
                //  information buffer
                //

                HandleInformation->NumberOfHandles += 1;

                //
                //  Lock the handle table entry because we're about to
                //  give it to the callback function, then release the
                //  entry right after the call back.
                //

                if (ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {

                    Status = (*SnapShotHandleEntry)( &HandleEntryInfo,
                                                     HandleTable->UniqueProcessId,
                                                     HandleTableEntry,
                                                     Handle.GenericHandleOverlay,
                                                     Length,
                                                     RequiredLength );

                    ExUnlockHandleTableEntry( HandleTable, HandleTableEntry );
                }
            }
        }
    }

    ExReleaseResourceLite( &HandleTableListLock );
    KeLeaveCriticalRegionThread (CurrentThread);

    return Status;
}


NTKERNELAPI
NTSTATUS
ExSnapShotHandleTablesEx (
    IN PEX_SNAPSHOT_HANDLE_ENTRY_EX SnapShotHandleEntry,
    IN OUT PSYSTEM_HANDLE_INFORMATION_EX HandleInformation,
    IN ULONG Length,
    IN OUT PULONG RequiredLength
    )

/*++

Routine Description:

    This function visits and invokes the specified callback for every valid
    handle that it can find off of the handle table.

Arguments:

    SnapShotHandleEntry - Supplies a pointer to a function to call for
        each valid handle we encounter.

    HandleInformation - Supplies a handle information structure to
        be filled in for each handle table we encounter.  This routine
        fills in the handle count, but relies on a callback to fill in
        entry info fields.

    Length - Supplies a parameter for the callback.  In reality this is
        the total size, in bytes, of the Handle Information buffer.

    RequiredLength - Supplies a parameter for the callback.  In reality
        this is a final size in bytes used to store the requested
        information.

Return Value:

    The last return status of the callback

--*/

{
    NTSTATUS Status;
    PKTHREAD CurrentThread;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntryInfo;
    PLIST_ENTRY NextEntry;
    PHANDLE_TABLE HandleTable;
    EXHANDLE Handle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();

    Status = STATUS_SUCCESS;


    //
    //  Setup the output buffer pointer that the callback will maintain
    //

    HandleEntryInfo = &HandleInformation->Handles[0];

    //
    //  Zero out the handle count
    //

    HandleInformation->NumberOfHandles = 0;

    //
    //  Lock the handle table list exclusive and traverse the list of handle
    //  tables.
    //

    KeEnterCriticalRegionThread (CurrentThread);
    ExAcquireResourceExclusiveLite( &HandleTableListLock, TRUE );

    //
    //  Iterate through all the handle tables in the system.
    //

    for (NextEntry = HandleTableListHead.Flink;
         NextEntry != &HandleTableListHead;
         NextEntry = NextEntry->Flink) {

        //
        //  Get the address of the next handle table, lock the handle
        //  table exclusive, and scan the list of handle entries.
        //

        HandleTable = CONTAINING_RECORD( NextEntry,
                                         HANDLE_TABLE,
                                         HandleTableList );


        //  Iterate through the handle table and for each handle that
        //  is allocated we'll invoke the call back.  Note that this
        //  loop exits when we get a null handle table entry.  We know
        //  there will be no more possible entries after the first null
        //  one is encountered because we allocate memory of the
        //  handles in a dense fashion
        //

        for (Handle.Value = 0;
             (HandleTableEntry = ExpLookupHandleTableEntry( HandleTable, Handle )) != NULL;
             Handle.Value += HANDLE_VALUE_INC) {

            //
            //  Only do the callback if the entry is not free
            //

            if ( ExpIsValidObjectEntry(HandleTableEntry) ) {

                //
                //  Increment the handle count information in the
                //  information buffer
                //

                HandleInformation->NumberOfHandles += 1;

                //
                //  Lock the handle table entry because we're about to
                //  give it to the callback function, then release the
                //  entry right after the call back.
                //

                if (ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {

                    Status = (*SnapShotHandleEntry)( &HandleEntryInfo,
                                                     HandleTable->UniqueProcessId,
                                                     HandleTableEntry,
                                                     Handle.GenericHandleOverlay,
                                                     Length,
                                                     RequiredLength );

                    ExUnlockHandleTableEntry( HandleTable, HandleTableEntry );
                }
            }
        }
    }

    ExReleaseResourceLite( &HandleTableListLock );
    KeLeaveCriticalRegionThread (CurrentThread);

    return Status;
}


NTKERNELAPI
HANDLE
ExCreateHandle (
    IN PHANDLE_TABLE HandleTable,
    IN PHANDLE_TABLE_ENTRY HandleTableEntry
    )

/*++

Routine Description:

    This function creates a handle entry in the specified handle table and
    returns a handle for the entry.

Arguments:

    HandleTable - Supplies a pointer to a handle table

    HandleEntry - Supplies a poiner to the handle entry for which a
        handle entry is created.

Return Value:

    If the handle entry is successfully created, then value of the created
    handle is returned as the function value.  Otherwise, a value of zero is
    returned.

--*/

{
    EXHANDLE Handle;
    PETHREAD CurrentThread;
    PHANDLE_TABLE_ENTRY NewHandleTableEntry;
    PHANDLE_TRACE_DEBUG_INFO DebugInfo;
    PHANDLE_TRACE_DB_ENTRY DebugEntry;
    ULONG Index;

    PAGED_CODE();

    //
    //  Set out output variable to zero (i.e., null) before going on
    //

    //
    // Clears Handle.Index and Handle.TagBits
    //

    Handle.GenericHandleOverlay = NULL;


    //
    //  Allocate a new handle table entry, and get the handle value
    //

    NewHandleTableEntry = ExpAllocateHandleTableEntry( HandleTable,
                                                       &Handle );

    //
    //  If we really got a handle then copy over the template and unlock
    //  the entry
    //

    if (NewHandleTableEntry != NULL) {

        CurrentThread = PsGetCurrentThread ();

        //
        // We are about to create a locked entry so protect against suspension
        //
        KeEnterCriticalRegionThread (&CurrentThread->Tcb);

        *NewHandleTableEntry = *HandleTableEntry;

        //
        // If we are debugging handle operations then save away the details
        //
        DebugInfo = HandleTable->DebugInfo;
        if (DebugInfo != NULL) {
            Index = ((ULONG) InterlockedIncrement ((PLONG)&DebugInfo->CurrentStackIndex))
                       % HANDLE_TRACE_DB_MAX_STACKS;
            DebugEntry = &DebugInfo->TraceDb[Index];
            DebugEntry->ClientId = CurrentThread->Cid;
            DebugEntry->Handle   = Handle.GenericHandleOverlay;
            DebugEntry->Type     = HANDLE_TRACE_DB_OPEN;
            Index = RtlWalkFrameChain (DebugEntry->StackTrace, HANDLE_TRACE_DB_STACK_SIZE, 0);
            RtlWalkFrameChain (&DebugEntry->StackTrace[Index], HANDLE_TRACE_DB_STACK_SIZE - Index, 1);
        }

        ExUnlockHandleTableEntry( HandleTable, NewHandleTableEntry );

        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    }

    return Handle.GenericHandleOverlay;
}


NTKERNELAPI
BOOLEAN
ExDestroyHandle (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle,
    IN PHANDLE_TABLE_ENTRY HandleTableEntry OPTIONAL
    )

/*++

Routine Description:

    This function removes a handle from a handle table.

Arguments:

    HandleTable - Supplies a pointer to a handle table

    Handle - Supplies the handle value of the entry to remove.

    HandleTableEntry - Optionally supplies a pointer to the handle
        table entry being destroyed.  If supplied the entry is
        assume to be locked.

Return Value:

    If the specified handle is successfully removed, then a value of
    TRUE is returned. Otherwise, a value of FALSE is returned.

--*/

{
    EXHANDLE LocalHandle;
    PETHREAD CurrentThread;
    PHANDLE_TRACE_DEBUG_INFO DebugInfo;
    PHANDLE_TRACE_DB_ENTRY DebugEntry;
    ULONG Index;

    PAGED_CODE();

    LocalHandle.GenericHandleOverlay = Handle;

    CurrentThread = PsGetCurrentThread ();

    //
    //  If the caller did not supply the optional handle table entry then
    //  locate the entry via the supplied handle, make sure it is real, and
    //  then lock the entry.
    //

    KeEnterCriticalRegionThread (&CurrentThread->Tcb);

    if (HandleTableEntry == NULL) {

        HandleTableEntry = ExpLookupHandleTableEntry( HandleTable,
                                                      LocalHandle );

        if (!ExpIsValidObjectEntry(HandleTableEntry)) {

            KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
            return FALSE;
        }


        if (!ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {

            KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
            return FALSE;
        }
    }


    //
    // If we are debugging handle operations then save away the details
    //

    DebugInfo = HandleTable->DebugInfo;
    if (DebugInfo != NULL) {
        Index = ((ULONG) InterlockedIncrement ((PLONG)&DebugInfo->CurrentStackIndex))
                   % HANDLE_TRACE_DB_MAX_STACKS;
        DebugEntry = &DebugInfo->TraceDb[Index];
        DebugEntry->ClientId = CurrentThread->Cid;
        DebugEntry->Handle   = Handle;
        DebugEntry->Type     = HANDLE_TRACE_DB_CLOSE;
        Index = RtlWalkFrameChain (DebugEntry->StackTrace, HANDLE_TRACE_DB_STACK_SIZE, 0);
        RtlWalkFrameChain (&DebugEntry->StackTrace[Index], HANDLE_TRACE_DB_STACK_SIZE - Index, 1);
    }

    //
    //  At this point we have a locked handle table entry.  Now mark it free
    //  which does the implicit unlock.  The system will not allocate it
    //  again until we add it to the free list which we will do right after
    //  we take out the lock
    //

    InterlockedExchangePointer (&HandleTableEntry->Object, NULL);

    //
    // Unblock any waiters waiting for this table entry.
    //
    ExUnblockPushLock (&HandleTable->HandleContentionEvent, NULL);


    ExpFreeHandleTableEntry( HandleTable,
                             LocalHandle,
                             HandleTableEntry );

    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

    return TRUE;
}


NTKERNELAPI
BOOLEAN
ExChangeHandle (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle,
    IN PEX_CHANGE_HANDLE_ROUTINE ChangeRoutine,
    IN ULONG_PTR Parameter
    )

/*++

Routine Description:

    This function provides the capability to change the contents of the
    handle entry corrsponding to the specified handle.

Arguments:

    HandleTable - Supplies a pointer to a handle table.

    Handle - Supplies the handle for the handle entry that is changed.

    ChangeRoutine - Supplies a pointer to a function that is called to
        perform the change.

    Parameter - Supplies an uninterpreted parameter that is passed to
        the change routine.

Return Value:

    If the operation was successfully performed, then a value of TRUE
    is returned. Otherwise, a value of FALSE is returned.

--*/

{
    EXHANDLE LocalHandle;
    PKTHREAD CurrentThread;

    PHANDLE_TABLE_ENTRY HandleTableEntry;
    BOOLEAN ReturnValue;

    PAGED_CODE();

    LocalHandle.GenericHandleOverlay = Handle;

    CurrentThread = KeGetCurrentThread ();

    //
    //  Translate the input handle to a handle table entry and make
    //  sure it is a valid handle.
    //

    HandleTableEntry = ExpLookupHandleTableEntry( HandleTable,
                                                  LocalHandle );

    if ((HandleTableEntry == NULL) ||
        !ExpIsValidObjectEntry(HandleTableEntry)) {

        return FALSE;
    }



    //
    //  Try and lock the handle table entry,  If this fails then that's
    //  because someone freed the handle
    //

    //
    //  Make sure we can't get suspended and then invoke the callback
    //

    KeEnterCriticalRegionThread (CurrentThread);

    if (ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {


        ReturnValue = (*ChangeRoutine)( HandleTableEntry, Parameter );
        
        ExUnlockHandleTableEntry( HandleTable, HandleTableEntry );

    } else {
        ReturnValue = FALSE;
    }

    KeLeaveCriticalRegionThread (CurrentThread);

    return ReturnValue;
}


NTKERNELAPI
PHANDLE_TABLE_ENTRY
ExMapHandleToPointer (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle
    )

/*++

Routine Description:

    This function maps a handle to a pointer to a handle table entry. If the
    map operation is successful then the handle table entry is locked when
    we return.

Arguments:

    HandleTable - Supplies a pointer to a handle table.

    Handle - Supplies the handle to be mapped to a handle entry.

Return Value:

    If the handle was successfully mapped to a pointer to a handle entry,
    then the address of the handle table entry is returned as the function
    value with the entry locked. Otherwise, a value of NULL is returned.

--*/

{
    EXHANDLE LocalHandle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;
    PHANDLE_TRACE_DEBUG_INFO DebugInfo;
    PHANDLE_TRACE_DB_ENTRY DebugEntry;
    ULONG Index;
    PETHREAD CurrentThread;

    PAGED_CODE();

    LocalHandle.GenericHandleOverlay = Handle;

    if ((LocalHandle.Index & (LOWLEVEL_COUNT - 1)) == 0) {
        return NULL;
    }

    //
    //  Translate the input handle to a handle table entry and make
    //  sure it is a valid handle.
    //

    HandleTableEntry = ExpLookupHandleTableEntry( HandleTable,
                                                  LocalHandle );

    if ((HandleTableEntry == NULL) ||
        !ExpLockHandleTableEntry( HandleTable, HandleTableEntry)) {
        //
        // If we are debugging handle operations then save away the details
        //

        DebugInfo = HandleTable->DebugInfo;
        if (DebugInfo != NULL) {
            Index = ((ULONG) InterlockedIncrement ((PLONG)&DebugInfo->CurrentStackIndex))
                       % HANDLE_TRACE_DB_MAX_STACKS;
            DebugEntry = &DebugInfo->TraceDb[Index];
            CurrentThread = PsGetCurrentThread ();
            DebugEntry->ClientId = CurrentThread->Cid;
            DebugEntry->Handle   = Handle;
            DebugEntry->Type     = HANDLE_TRACE_DB_BADREF;
            Index = RtlWalkFrameChain (DebugEntry->StackTrace, HANDLE_TRACE_DB_STACK_SIZE, 0);
            RtlWalkFrameChain (&DebugEntry->StackTrace[Index], HANDLE_TRACE_DB_STACK_SIZE - Index, 1);
        }
        return NULL;
    }


    //
    //  Return the locked valid handle table entry
    //

    return HandleTableEntry;
}

NTKERNELAPI
PHANDLE_TABLE_ENTRY
ExMapHandleToPointerEx (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle,
    IN KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This function maps a handle to a pointer to a handle table entry. If the
    map operation is successful then the handle table entry is locked when
    we return.

Arguments:

    HandleTable - Supplies a pointer to a handle table.

    Handle - Supplies the handle to be mapped to a handle entry.

    PreviousMode - Previous mode of caller

Return Value:

    If the handle was successfully mapped to a pointer to a handle entry,
    then the address of the handle table entry is returned as the function
    value with the entry locked. Otherwise, a value of NULL is returned.

--*/

{
    EXHANDLE LocalHandle;
    PHANDLE_TABLE_ENTRY HandleTableEntry = NULL;
    PHANDLE_TRACE_DEBUG_INFO DebugInfo;
    PHANDLE_TRACE_DB_ENTRY DebugEntry;
    ULONG Index;
    PETHREAD CurrentThread;

    PAGED_CODE();

    LocalHandle.GenericHandleOverlay = Handle;

    //
    //  Translate the input handle to a handle table entry and make
    //  sure it is a valid handle.
    //    

    if (((LocalHandle.Index & (LOWLEVEL_COUNT - 1)) == 0) ||
        ((HandleTableEntry = ExpLookupHandleTableEntry(HandleTable, LocalHandle)) == NULL) ||
        !ExpLockHandleTableEntry( HandleTable, HandleTableEntry)) {

        //
        // If we are debugging handle operations then save away the details
        //

        DebugInfo = HandleTable->DebugInfo;
        if (DebugInfo != NULL) {

            Index = ((ULONG) InterlockedIncrement ((PLONG)&DebugInfo->CurrentStackIndex))
                       % HANDLE_TRACE_DB_MAX_STACKS;
            CurrentThread = PsGetCurrentThread ();
            DebugEntry = &DebugInfo->TraceDb[Index];
            DebugEntry->ClientId = CurrentThread->Cid;
            DebugEntry->Handle   = Handle;
            DebugEntry->Type     = HANDLE_TRACE_DB_BADREF;
            Index = RtlWalkFrameChain (DebugEntry->StackTrace, HANDLE_TRACE_DB_STACK_SIZE, 0);
            RtlWalkFrameChain (&DebugEntry->StackTrace[Index], HANDLE_TRACE_DB_STACK_SIZE - Index, 1);

            //
            // Since we have a non-null DebugInfo for the handle table of this
            // process it means application verifier was enabled for this process.
            //

            if (PreviousMode == UserMode) {

                if (!KeIsAttachedProcess() && !PsIsThreadTerminating (CurrentThread) &&
                    !CurrentThread->Tcb.ApcState.KernelApcInProgress) {

                    //
                    // If the current process is marked for verification
                    // then we will raise an exception in user mode. In case
                    // application verifier is enabled system wide we will 
                    // break first.
                    //
                                                 
                    if ((NtGlobalFlag & FLG_APPLICATION_VERIFIER)) {
                        
                        DbgPrint ("AVRF: Invalid handle %p in process %p \n", 
                                  Handle,
                                  PsGetCurrentProcess());

//                        DbgBreakPoint ();
                    }

                    KeRaiseUserException (STATUS_INVALID_HANDLE);
                }
            } else {

                //
                // We bugcheck for kernel handles only if we have the handle
                // exceptions flag set system-wide. This way a user enabling
                // application verifier for a process will not get bugchecks
                // only user mode errors.
                //

                if ((NtGlobalFlag & FLG_ENABLE_HANDLE_EXCEPTIONS)) {

                    KeBugCheckEx(INVALID_KERNEL_HANDLE,
                                 (ULONG_PTR)Handle,
                                 (ULONG_PTR)HandleTable,
                                 (ULONG_PTR)HandleTableEntry,
                                 0x1);
                }
            }
        }
        
        return NULL;
    }


    //
    //  Return the locked valid handle table entry
    //

    return HandleTableEntry;
}

//
//  Local Support Routine
//

PVOID
ExpAllocateTablePagedPool (
    IN PEPROCESS QuotaProcess OPTIONAL,
    IN SIZE_T NumberOfBytes
    )
{
    PVOID PoolMemory;

    PoolMemory = ExAllocatePoolWithTag( PagedPool,
                                        NumberOfBytes,
                                        'btbO' );
    if (PoolMemory != NULL) {

        RtlZeroMemory( PoolMemory,
                       NumberOfBytes );

        if (ARGUMENT_PRESENT(QuotaProcess)) {

            if (!NT_SUCCESS (PsChargeProcessPagedPoolQuota ( QuotaProcess,
                                                             NumberOfBytes ))) {
                ExFreePool( PoolMemory );
                PoolMemory = NULL;
            }

        }
    }

    return PoolMemory;
}


//
//  Local Support Routine
//

VOID
ExpFreeTablePagedPool (
    IN PEPROCESS QuotaProcess OPTIONAL,
    IN PVOID PoolMemory,
    IN SIZE_T NumberOfBytes
    )
{

    ExFreePool( PoolMemory );

    if ( QuotaProcess ) {

        PsReturnProcessPagedPoolQuota( QuotaProcess,
                                       NumberOfBytes
                                     );
    }
}

NTKERNELAPI
NTSTATUS
ExEnableHandleTracing (
    IN PHANDLE_TABLE HandleTable
    )
{
    PHANDLE_TRACE_DEBUG_INFO DebugInfo;
    PEPROCESS Process;
    NTSTATUS Status;
    SIZE_T TotalNow;
    extern SIZE_T MmMaximumNonPagedPoolInBytes;

    TotalNow = InterlockedIncrement ((PLONG) &TotalTraceBuffers);

    //
    // See if we used more than 30% of nonpaged pool.
    //
    if (TotalNow * sizeof (HANDLE_TRACE_DEBUG_INFO) > (MmMaximumNonPagedPoolInBytes * 30 / 100)) {
        InterlockedDecrement ((PLONG) &TotalTraceBuffers);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Process = HandleTable->QuotaProcess;

    if (Process) {
        Status = PsChargeProcessNonPagedPoolQuota (Process,
                                                   sizeof (HANDLE_TRACE_DEBUG_INFO));
        if (!NT_SUCCESS (Status)) {
            InterlockedDecrement ((PLONG) &TotalTraceBuffers);
            return Status;
        }
    }

    //
    // Allocate the handle debug database
    //
    DebugInfo = ExAllocatePoolWithTag (NonPagedPool,
                                       sizeof (HANDLE_TRACE_DEBUG_INFO),
                                       'dtbO');
    if (DebugInfo == NULL) {
        if (Process) {
            PsReturnProcessNonPagedPoolQuota (Process,
                                              sizeof (HANDLE_TRACE_DEBUG_INFO));
        }
        InterlockedDecrement ((PLONG) &TotalTraceBuffers);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory (DebugInfo, sizeof (HANDLE_TRACE_DEBUG_INFO));

    //
    // Since we are tracing then we should enforce strict FIFO
    // Only do this for tables with processes so we leave atom tables alone.
    //
    if (Process != NULL) {
        HandleTable->StrictFIFO = TRUE;
    }

    //
    // Try and install the trace buffer. If there is one already there
    // then free the new one. We return success anyway as tracing is enabled.
    //
    if (InterlockedCompareExchangePointer (&HandleTable->DebugInfo,
                                           DebugInfo,
                                           NULL) != NULL) {
        ExFreePool (DebugInfo);
        if (Process) {
            PsReturnProcessNonPagedPoolQuota (Process,
                                              sizeof (HANDLE_TRACE_DEBUG_INFO));
        }
        InterlockedDecrement ((PLONG) &TotalTraceBuffers);
    }

    return STATUS_SUCCESS;
}


//
//  Local Support Routine
//

PHANDLE_TABLE
ExpAllocateHandleTable (
    IN PEPROCESS Process OPTIONAL
    )

/*++

Routine Description:

    This worker routine will allocate and initialize a new handle table
    structure.  The new structure consists of the basic handle table
    struct plus the first allocation needed to store handles.  This is
    really one page divided up into the top level node, the first mid
    level node, and one bottom level node.

Arguments:

    Process - Optionally supplies the process to charge quota for the
        handle table

Return Value:

    A pointer to the new handle table or NULL if unsuccessful at getting
    pool.

--*/

{
    PHANDLE_TABLE HandleTable;
    PHANDLE_TABLE_ENTRY HandleTableTable;
    ULONG i, Idx;

    PAGED_CODE();

    //
    //  If any alloation or quota failures happen we will catch it in the
    //  following try-except clause and cleanup after outselves before
    //  we return null
    //

    //
    //  First allocate the handle table, make sure we got one, charge quota
    //  for it and then zero it out
    //

    HandleTable = (PHANDLE_TABLE)ExAllocatePoolWithTag (PagedPool,
                                                        sizeof(HANDLE_TABLE),
                                                        'btbO');
    if (HandleTable == NULL) {
        return NULL;
    }

    if (ARGUMENT_PRESENT(Process)) {

        if (!NT_SUCCESS (PsChargeProcessPagedPoolQuota( Process,
                                                        sizeof(HANDLE_TABLE)))) {
            ExFreePool( HandleTable );
            return NULL;
        }
    }


    RtlZeroMemory( HandleTable, sizeof(HANDLE_TABLE) );


    //
    //  Now allocate space of the top level, one mid level and one bottom
    //  level table structure.  This will all fit on a page, maybe two.
    //

    HandleTableTable = ExpAllocateTablePagedPool( Process,
                                                  TABLE_PAGE_SIZE
                                                );

    if ( HandleTableTable == NULL ) {

        ExFreePool( HandleTable );

        if (ARGUMENT_PRESENT(Process)) {

            PsReturnProcessPagedPoolQuota (Process,
                                           sizeof(HANDLE_TABLE));
        }
            
        return NULL;
    }
        
    HandleTable->TableCode = (ULONG_PTR)HandleTableTable;


    //
    //  Now setup the free list.  We do this by chaining together the free
    //  entries such that each free entry give the next free index (i.e.,
    //  like a fat chain).  The chain is terminated with a 0.  Note that
    //  we'll skip handle zero because our callers will get that value
    //  confused with null.
    //

    for (i = 0; i < LOWLEVEL_COUNT; i += 1) {

        HandleTableTable[i].NextFreeTableEntry = (i+1)<<2;
    }

    //
    //  We stamp with EX_ADDITIONAL_INFO_SIGNATURE to recognize in the future this
    //  is a special information entry
    //

    HandleTableTable[0].NextFreeTableEntry = EX_ADDITIONAL_INFO_SIGNATURE;
    
    HandleTableTable[LOWLEVEL_COUNT - 1].NextFreeTableEntry = 0;

    HandleTable->FirstFree = HANDLE_VALUE_INC;
    HandleTable->NextHandleNeedingPool = LOWLEVEL_COUNT * HANDLE_VALUE_INC;

    //
    //  Setup the necessary process information
    //

    HandleTable->QuotaProcess = Process;
    HandleTable->UniqueProcessId = PsGetCurrentProcess()->UniqueProcessId;
    HandleTable->Flags = 0;
#if DBG
    if (Process != NULL) {
        HandleTable->StrictFIFO = TRUE;
    }
#endif

    //
    //  Initialize the handle table lock. This is only used by table expansion.
    //

    for (Idx = 0; Idx < HANDLE_TABLE_LOCKS; Idx++) {
        ExInitializePushLock (&HandleTable->HandleTableLock[Idx]);
    }

    //
    //  Initialize the blocker for handle entry lock contention.
    //

    ExInitializePushLock (&HandleTable->HandleContentionEvent);

    if (ExTraceAllTables) {
        ExEnableHandleTracing (HandleTable);    
    }
    //
    //  And return to our caller
    //

    return HandleTable;
}


//
//  Local Support Routine
//

VOID
ExpFreeLowLevelTable (
    IN PEPROCESS QuotaProcess,
    IN PHANDLE_TABLE_ENTRY TableLevel1
    )

/*++

Routine Description:

    This worker routine frees a low-level handle table
    and the additional info memory, if any.

Arguments:

    HandleTable - Supplies the handle table being freed

Return Value:

    None.

--*/

{
    //
    //  Check whether we have a pool allocated for the additional info
    //

    if (TableLevel1[0].Object) {

        ExpFreeTablePagedPool( QuotaProcess,
                               TableLevel1[0].Object,
                               LOWLEVEL_COUNT * sizeof(HANDLE_TABLE_ENTRY_INFO)
                             );
    }

    //
    //  Now free the low level table and return the quota for the process
    //

    ExpFreeTablePagedPool( QuotaProcess,
                           TableLevel1,
                           TABLE_PAGE_SIZE
                         );
    
    //
    //  And return to our caller
    //

    return;
}


//
//  Local Support Routine
//

VOID
ExpFreeHandleTable (
    IN PHANDLE_TABLE HandleTable
    )

/*++

Routine Description:

    This worker routine tears down and frees the specified handle table.

Arguments:

    HandleTable - Supplies the handle table being freed

Return Value:

    None.

--*/

{
    PEPROCESS Process;
    ULONG i,j;
    ULONG_PTR CapturedTable = HandleTable->TableCode;
    ULONG TableLevel = (ULONG)(CapturedTable & LEVEL_CODE_MASK);

    PAGED_CODE();

    //
    //  Unmask the level bits
    //

    CapturedTable = CapturedTable & ~LEVEL_CODE_MASK;
    Process = HandleTable->QuotaProcess;

    //
    //  We need to free all pages. We have 3 cases, depending on the number
    //  of levels
    //


    if (TableLevel == 0) {

        //
        //  There is a single level handle table. We'll simply free the buffer
        //

        PHANDLE_TABLE_ENTRY TableLevel1 = (PHANDLE_TABLE_ENTRY)CapturedTable;
        
        ExpFreeLowLevelTable( Process, TableLevel1 );

    } else if (TableLevel == 1) {

        //
        //  We have 2 levels in the handle table
        //
        
        PHANDLE_TABLE_ENTRY *TableLevel2 = (PHANDLE_TABLE_ENTRY *)CapturedTable;

        for (i = 0; i < MIDLEVEL_COUNT; i++) {

            //
            //  loop through the pointers to the low-level tables, and free each one
            //

            if (TableLevel2[i] == NULL) {

                break;
            }
            
            ExpFreeLowLevelTable( Process, TableLevel2[i] );
        }
        
        //
        //  Free the top level table
        //

        ExpFreeTablePagedPool( Process,
                               TableLevel2,
                               PAGE_SIZE
                             );

    } else {

        //
        //  Here we handle the case where we have a 3 level handle table
        //

        PHANDLE_TABLE_ENTRY **TableLevel3 = (PHANDLE_TABLE_ENTRY **)CapturedTable;

        //
        //  Iterates through the high-level pointers to mid-table
        //

        for (i = 0; i < HIGHLEVEL_COUNT; i++) {

            if (TableLevel3[i] == NULL) {

                break;
            }
            
            //
            //  Iterate through the mid-level table
            //  and free every low-level page
            //

            for (j = 0; j < MIDLEVEL_COUNT; j++) {

                if (TableLevel3[i][j] == NULL) {

                    break;
                }
                
                ExpFreeLowLevelTable( Process, TableLevel3[i][j] );
            }

            ExpFreeTablePagedPool( Process,
                                   TableLevel3[i],
                                   PAGE_SIZE
                                 );
        }
        
        //
        //  Free the top-level array
        //

        ExpFreeTablePagedPool( Process,
                               TableLevel3,
                               HIGHLEVEL_SIZE
                             );
    }

    //
    // Free any debug info if we have any.
    //

    if (HandleTable->DebugInfo != NULL) {
        ExFreePool (HandleTable->DebugInfo);
        if (Process != NULL) {
            PsReturnProcessNonPagedPoolQuota (Process,
                                              sizeof (HANDLE_TRACE_DEBUG_INFO));
        }
        InterlockedDecrement ((PLONG) &TotalTraceBuffers);
    }

    //
    //  Finally deallocate the handle table itself
    //

    ExFreePool( HandleTable );

    if (Process != NULL) {

        PsReturnProcessPagedPoolQuota (Process,
                                       sizeof(HANDLE_TABLE));
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Local Support Routine
//

PHANDLE_TABLE_ENTRY
ExpAllocateLowLevelTable (
    IN PHANDLE_TABLE HandleTable
    )

/*++

Routine Description:

    This worker routine allocates a new low level table
    
    Note: The caller must have already locked the handle table

Arguments:

    HandleTable - Supplies the handle table being used

Return Value:

    Returns - a pointer to a low-level table if allocation is
        successful otherwise the return value is null.

--*/

{
    ULONG k;
    PHANDLE_TABLE_ENTRY NewLowLevel = NULL;
    ULONG BaseHandle;
    
    //
    //  Allocate the pool for lower level
    //

    NewLowLevel = ExpAllocateTablePagedPool( HandleTable->QuotaProcess,
                                             TABLE_PAGE_SIZE
                                           );

    if (NewLowLevel == NULL) {

        return NULL;
    }

    //
    //  We stamp with EX_ADDITIONAL_INFO_SIGNATURE to recognize in the future this
    //  is a special information entry
    //

    NewLowLevel[0].NextFreeTableEntry = EX_ADDITIONAL_INFO_SIGNATURE;

    //
    //  Now add the new entries to the free list.  To do this we
    //  chain the new free entries together.  We are guaranteed to
    //  have at least one new buffer.  The second buffer we need
    //  to check for.
    //
    //  We reserve the first entry in the table to the structure with
    //  additional info
    //
    //
    //  Do the guaranteed first buffer
    //

    BaseHandle = HandleTable->NextHandleNeedingPool + 2 * HANDLE_VALUE_INC;
    for (k = 1; k < LOWLEVEL_COUNT - 1; k++) {

        NewLowLevel[k].NextFreeTableEntry = BaseHandle;
        BaseHandle += HANDLE_VALUE_INC;
    }


    return NewLowLevel;    
}

PHANDLE_TABLE_ENTRY *
ExpAllocateMidLevelTable (
    IN PHANDLE_TABLE HandleTable,
    OUT PHANDLE_TABLE_ENTRY *pNewLowLevel
    )

/*++

Routine Description:

    This worker routine allocates a mid-level table. This is an array with
    pointers to low-level tables.
    It will allocate also a low-level table and will save it in the first index
    
    Note: The caller must have already locked the handle table

Arguments:

    HandleTable - Supplies the handle table being used

    pNewLowLevel - Returns the new low level taible for later free list chaining

Return Value:

    Returns a pointer to the new mid-level table allocated
    
--*/

{
    PHANDLE_TABLE_ENTRY *NewMidLevel;
    PHANDLE_TABLE_ENTRY NewLowLevel;
    
    NewMidLevel = ExpAllocateTablePagedPool( HandleTable->QuotaProcess,
                                             PAGE_SIZE
                                           );

    if (NewMidLevel == NULL) {

        return NULL;
    }

    //
    //  If we need a new mid-level, we'll need a low-level too.
    //  We'll create one and if success we'll save it at the first position
    //

    NewLowLevel = ExpAllocateLowLevelTable( HandleTable );

    if (NewLowLevel == NULL) {

        ExpFreeTablePagedPool( HandleTable->QuotaProcess,
                               NewMidLevel,
                               PAGE_SIZE
                             );

        return NULL;
    }
    
    //
    //  Set the low-level table at the first index
    //

    NewMidLevel[0] = NewLowLevel;
    *pNewLowLevel = NewLowLevel;

    return NewMidLevel;
}



BOOLEAN
ExpAllocateHandleTableEntrySlow (
    IN PHANDLE_TABLE HandleTable
    )

/*++

Routine Description:

    This worker routine allocates a new handle table entry for the specified
    handle table.

    Note: The caller must have already locked the handle table

Arguments:

    HandleTable - Supplies the handle table being used

    Handle - Returns the handle of the new entry if the allocation is
        successful otherwise the value is null


Return Value:

    BOOLEAN - TRUE, Retry the fast allocation path, FALSE, We failed to allocate memory

--*/

{
    ULONG i,j;

    PHANDLE_TABLE_ENTRY NewLowLevel;
    PHANDLE_TABLE_ENTRY *NewMidLevel;
    PHANDLE_TABLE_ENTRY **NewHighLevel;
    ULONG NewFree, OldFree;
    ULONG OldIndex;
    
    ULONG_PTR CapturedTable = HandleTable->TableCode;
    ULONG TableLevel = (ULONG)(CapturedTable & LEVEL_CODE_MASK);
    
    PAGED_CODE();

    //
    // Initializing NewLowLevel is not needed for
    // correctness but without it the compiler cannot compile this code
    // W4 to check for use of uninitialized variables.
    //

    NewLowLevel = NULL;

    CapturedTable = CapturedTable & ~LEVEL_CODE_MASK;


    if ( TableLevel == 0 ) {

        //
        //  We have a single level. We need to ad a mid-layer
        //  to the process handle table
        //

        NewMidLevel = ExpAllocateMidLevelTable( HandleTable, &NewLowLevel );

        if (NewMidLevel == NULL) {
            return FALSE;
        }

        //
        //  Since ExpAllocateMidLevelTable initialize the 
        //  first position with a new table, we need to move it in 
        //  the second position, and store in the first position the current one
        //

        NewMidLevel[1] = NewMidLevel[0];
        NewMidLevel[0] = (PHANDLE_TABLE_ENTRY)CapturedTable;
            
        //
        //  Encode the current level and set it to the handle table process
        //

        CapturedTable = ((ULONG_PTR)NewMidLevel) | 1;
            
        InterlockedExchangePointer( (PVOID *)&HandleTable->TableCode, (PVOID)CapturedTable );

    } else if (TableLevel == 1) {

        //
        //  We have a 2 levels handle table
        //

        PHANDLE_TABLE_ENTRY *TableLevel2 = (PHANDLE_TABLE_ENTRY *)CapturedTable;

        //
        //  Test whether the index we need to create is still in the 
        //  range for a 2 layers table
        //

        i = HandleTable->NextHandleNeedingPool / (LOWLEVEL_COUNT * HANDLE_VALUE_INC);

        if (i < MIDLEVEL_COUNT) {

            //
            //  We just need to allocate a new low-level
            //  table
            //
                
            NewLowLevel = ExpAllocateLowLevelTable( HandleTable );

            if (NewLowLevel == NULL) {
                return FALSE;
            }

            //
            //  Set the new one to the table, at appropriate position
            //

            InterlockedExchangePointer( (PVOID *) (&TableLevel2[i]), NewLowLevel );

        } else {

            //
            //  We exhausted the 2 level domain. We need to insert a new one
            //

            NewHighLevel = ExpAllocateTablePagedPool( HandleTable->QuotaProcess,
                                                      HIGHLEVEL_SIZE
                                                    );

            if (NewHighLevel == NULL) {

                return FALSE;
            }
                
            NewMidLevel = ExpAllocateMidLevelTable( HandleTable, &NewLowLevel );

            if (NewMidLevel == NULL) {
                    
                ExpFreeTablePagedPool( HandleTable->QuotaProcess,
                                       NewHighLevel,
                                       HIGHLEVEL_SIZE
                                     );

                return FALSE;
            }

            //
            //  Initialize the first index with the previous mid-level layer
            //

            NewHighLevel[0] = (PHANDLE_TABLE_ENTRY*)CapturedTable;
            NewHighLevel[1] = NewMidLevel;

            //
            //  Encode the level into the table pointer
            //

            CapturedTable = ((ULONG_PTR)NewHighLevel) | 2;

            //
            //  Change the handle table pointer with this one
            //

            InterlockedExchangePointer( (PVOID *)&HandleTable->TableCode, (PVOID)CapturedTable );
        }

    } else if (TableLevel == 2) {

        //
        //  we have already a table with 3 levels
        //

        ULONG RemainingIndex;
        PHANDLE_TABLE_ENTRY **TableLevel3 = (PHANDLE_TABLE_ENTRY **)CapturedTable;

        i = HandleTable->NextHandleNeedingPool / (MIDLEVEL_THRESHOLD * HANDLE_VALUE_INC);

        //
        //  Check whether we exhausted all possible indexes.
        //

        if (i >= HIGHLEVEL_COUNT) {

            return FALSE;
        }

        if (TableLevel3[i] == NULL) {

            //
            //  The new available handle points to a free mid-level entry
            //  We need then to allocate a new one and save it in that position
            //

            NewMidLevel = ExpAllocateMidLevelTable( HandleTable, &NewLowLevel );
                
            if (NewMidLevel == NULL) {
                    
                return FALSE;
            }             

            InterlockedExchangePointer( (PVOID *) &(TableLevel3[i]), NewMidLevel );

        } else {

            //
            //  We have already a mid-level table. We just need to add a new low-level one
            //  at the end
            //
                
            RemainingIndex = (HandleTable->NextHandleNeedingPool / HANDLE_VALUE_INC) -
                              i * MIDLEVEL_THRESHOLD;
            j = RemainingIndex / LOWLEVEL_COUNT;

            NewLowLevel = ExpAllocateLowLevelTable( HandleTable );

            if (NewLowLevel == NULL) {

                return FALSE;
            }

            InterlockedExchangePointer( (PVOID *)(&TableLevel3[i][j]) , NewLowLevel );
        }
    }

    //
    // This must be done after the table pointers so that new created handles
    // are valid before being freed.
    //
    OldIndex = InterlockedExchangeAdd ((PLONG) &HandleTable->NextHandleNeedingPool,
                                       LOWLEVEL_COUNT * HANDLE_VALUE_INC);

    //
    // Now free the handles. These are all ready to be accepted by the lookup logic now.
    //
    NewFree = OldIndex + HANDLE_VALUE_INC;
    while (1) {
        OldFree = HandleTable->FirstFree;
        NewLowLevel[LOWLEVEL_COUNT - 1].NextFreeTableEntry = OldFree;
        //
        // These are new entries that have never existed before. We can't have an A-B-A problem
        // with these so we don't need to take any locks
        //

        NewFree = InterlockedCompareExchange ((PLONG)&HandleTable->FirstFree,
                                              NewFree,
                                              OldFree);
        if (NewFree == OldFree) {
            break;
        }
    }
    return TRUE;
}


VOID
ExSetHandleTableStrictFIFO (
    IN PHANDLE_TABLE HandleTable
    )

/*++

Routine Description:

    This routine marks a handle table so that handle allocation is done in
    a strict FIFO order.


Arguments:

    HandleTable - Supplies the handle table being changed to FIFO

Return Value:

    None.

--*/

{
    HandleTable->StrictFIFO = TRUE;
}


//
//  Local Support Routine
//

//
//  The following is a global variable only present in the checked builds
//  to help catch apps that reuse handle values after they're closed.
//

#if DBG
BOOLEAN ExReuseHandles = 1;
#endif //DBG

VOID
ExpFreeHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    IN EXHANDLE Handle,
    IN PHANDLE_TABLE_ENTRY HandleTableEntry
    )

/*++

Routine Description:

    This worker routine returns the specified handle table entry to the free
    list for the handle table.

    Note: The caller must have already locked the handle table

Arguments:

    HandleTable - Supplies the parent handle table being modified

    Handle - Supplies the handle of the entry being freed

    HandleTableEntry - Supplies the table entry being freed

Return Value:

    None.

--*/

{
    PHANDLE_TABLE_ENTRY_INFO EntryInfo;
    ULONG OldFree, NewFree, *Free;
    PKTHREAD CurrentThread;
    ULONG Idx;

    PAGED_CODE();

    //
    //  Clear the AuditMask flags if these are present into the table
    //

    EntryInfo = ExGetHandleInfo(HandleTable, Handle.GenericHandleOverlay, TRUE);

    if (EntryInfo) {

        EntryInfo->AuditMask = 0;
    }

    //
    //  A free is simply a push onto the free table entry stack, or in the
    //  debug case we'll sometimes just float the entry to catch apps who
    //  reuse a recycled handle value.
    //

    InterlockedDecrement (&HandleTable->HandleCount);
    CurrentThread = KeGetCurrentThread ();

#if DBG
    if (ExReuseHandles) {
#endif //DBG

        NewFree = (ULONG) Handle.Value & ~(HANDLE_VALUE_INC - 1);
        if (!HandleTable->StrictFIFO) {
            //
            // We are pushing potentialy old entries onto the free list.
            // Prevent the A-B-A problem by shifting to an alternate list
            // read this element has the list head out of the loop.
            //
            Idx = (NewFree>>2) % HANDLE_TABLE_LOCKS;
            if (ExTryAcquireReleasePushLockExclusive (&HandleTable->HandleTableLock[Idx])) {
                Free = &HandleTable->FirstFree;
            } else {
                Free = &HandleTable->LastFree;
            }
        } else {
            Free = &HandleTable->LastFree;
        }

        while (1) {


            OldFree = *Free;
            HandleTableEntry->NextFreeTableEntry = OldFree;

            if ((ULONG)InterlockedCompareExchange ((PLONG)Free,
                                                   NewFree,
                                                   OldFree) == OldFree) {
                break;
            }
        }

#if DBG
    } else {

        HandleTableEntry->NextFreeTableEntry = 0;
    }
#endif //DBG


    return;
}


//
//  Local Support Routine
//

PHANDLE_TABLE_ENTRY
ExpLookupHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    IN EXHANDLE Handle
    )

/*++

Routine Description:

    This routine looks up and returns the table entry for the
    specified handle value.

Arguments:

    HandleTable - Supplies the handle table being queried

    Handle - Supplies the handle value being queried

Return Value:

    Returns a pointer to the corresponding table entry for the input
        handle.  Or NULL if the handle value is invalid (i.e., too large
        for the tables current allocation.

--*/

{
    ULONG_PTR i,j,k;
    ULONG_PTR CapturedTable;
    ULONG TableLevel;
    PHANDLE_TABLE_ENTRY Entry;

    typedef HANDLE_TABLE_ENTRY *L1P;
    typedef volatile L1P *L2P;
    typedef volatile L2P *L3P;

    L1P TableLevel1;
    L2P TableLevel2;
    L3P TableLevel3;

    ULONG_PTR RemainingIndex;
    ULONG_PTR MaxHandle;
    ULONG_PTR Index;

    PAGED_CODE();


    //
    // Extract the handle index
    //
    Handle.TagBits = 0;
    Index = Handle.Index;

    MaxHandle = *(volatile ULONG *) &HandleTable->NextHandleNeedingPool;

    //
    // See if this can be a valid handle given the table levels.
    //
    if (Handle.Value >= MaxHandle) {
        return NULL;        
    }

    //
    // Now fetch the table address and level bits. We must preserve the
    // ordering here.
    //
    CapturedTable = *(volatile ULONG_PTR *) &HandleTable->TableCode;

    //
    //  we need to capture the current table. This routine is lock free
    //  so another thread may change the table at HandleTable->TableCode
    //

    TableLevel = (ULONG)(CapturedTable & LEVEL_CODE_MASK);
    CapturedTable = CapturedTable & ~LEVEL_CODE_MASK;

    //
    //  The lookup code depends on number of levels we have
    //

    switch (TableLevel) {
        
        case 0:
            
            //
            //  We have a simple index into the array, for a single level
            //  handle table
            //


            TableLevel1 = (L1P) CapturedTable;

            Entry = &(TableLevel1[Index]);

            break;
        
        case 1:
            
            //
            //  we have a 2 level handle table. We need to get the upper index
            //  and lower index into the array
            //

            TableLevel2 = (L2P) CapturedTable;
                
            i = Index / LOWLEVEL_COUNT;
            j = Index % LOWLEVEL_COUNT;

            Entry = &(TableLevel2[i][j]);

            break;
        
        case 2:
            
            //
            //  We have here a three level handle table.
            //

            TableLevel3 = (L3P) CapturedTable;

            //
            //  Calculate the 3 indexes we need
            //
                
            i = Index / (MIDLEVEL_THRESHOLD);
            RemainingIndex = Index - i * MIDLEVEL_THRESHOLD;
            j = RemainingIndex / LOWLEVEL_COUNT;
            k = RemainingIndex % LOWLEVEL_COUNT;
            Entry = &(TableLevel3[i][j][k]);

            break;

        default :
            _assume (0);
    }

    return Entry;
}

NTKERNELAPI
NTSTATUS
ExSetHandleInfo (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle,
    IN PHANDLE_TABLE_ENTRY_INFO EntryInfo,
    IN BOOLEAN EntryLocked
    )

/*++

Routine Description:
    
    The routine set the entry info for the specified handle table
    
    Note: the handle entry must be locked when this function is called

Arguments:

    HandleTable - Supplies the handle table being queried

    Handle - Supplies the handle value being queried

Return Value:

--*/

{
    PKTHREAD CurrentThread;
    PHANDLE_TABLE_ENTRY InfoStructure;
    EXHANDLE ExHandle;
    NTSTATUS Status;
    PHANDLE_TABLE_ENTRY TableEntry;
    PHANDLE_TABLE_ENTRY_INFO InfoTable;

    Status = STATUS_UNSUCCESSFUL;
    TableEntry = NULL;
    CurrentThread = NULL;

    ExHandle.GenericHandleOverlay = Handle;
    ExHandle.Index &= ~(LOWLEVEL_COUNT - 1);

    if (!EntryLocked) {
        CurrentThread = KeGetCurrentThread ();
        KeEnterCriticalRegionThread (CurrentThread);
        TableEntry = ExMapHandleToPointer(HandleTable, Handle);

        if (TableEntry == NULL) {
            KeLeaveCriticalRegionThread (CurrentThread);
            
            return STATUS_UNSUCCESSFUL;
        }
    }
    
    //
    //  The info structure is at the first position in each low-level table
    //

    InfoStructure = ExpLookupHandleTableEntry( HandleTable,
                                               ExHandle
                                             );

    if (InfoStructure == NULL || InfoStructure->NextFreeTableEntry != EX_ADDITIONAL_INFO_SIGNATURE) {

        if ( TableEntry ) {
            ExUnlockHandleTableEntry( HandleTable, TableEntry );
            KeLeaveCriticalRegionThread (CurrentThread);
        }

        return STATUS_UNSUCCESSFUL;
    }

    //
    //  Check whether we need to allocate a new table
    //
    InfoTable = InfoStructure->InfoTable;
    if (InfoTable == NULL) {
        //
        //  Nobody allocated the Infotable so far.
        //  We'll do it right now
        //

        InfoTable = ExpAllocateTablePagedPool (HandleTable->QuotaProcess,
                                               LOWLEVEL_COUNT * sizeof(HANDLE_TABLE_ENTRY_INFO));
            
        if (InfoTable) {

            //
            // Update the number of pages for extra info. If somebody beat us to it then free the
            // new table
            //
            if (InterlockedCompareExchangePointer (&InfoStructure->InfoTable,
                                                   InfoTable,
                                                   NULL) == NULL) {

                InterlockedIncrement(&HandleTable->ExtraInfoPages);

            } else {
                ExpFreeTablePagedPool (HandleTable->QuotaProcess,
                                       InfoTable,
                                       LOWLEVEL_COUNT * sizeof(HANDLE_TABLE_ENTRY_INFO));
                InfoTable = InfoStructure->InfoTable;
            }
        }
    }

    if (InfoTable != NULL) {
        
        //
        //  Calculate the index and copy the structure
        //

        ExHandle.GenericHandleOverlay = Handle;

        InfoTable[ExHandle.Index % LOWLEVEL_COUNT] = *EntryInfo;

        Status = STATUS_SUCCESS;
    }

    if ( TableEntry ) {

        ExUnlockHandleTableEntry( HandleTable, TableEntry );
        KeLeaveCriticalRegionThread (CurrentThread);
    }
    
    return Status;
}

NTKERNELAPI
PHANDLE_TABLE_ENTRY_INFO
ExpGetHandleInfo (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle,
    IN BOOLEAN EntryLocked
    )

/*++

Routine Description:
    
    The routine reads the entry info for the specified handle table
    
    Note: the handle entry must be locked when this function is called

Arguments:

    HandleTable - Supplies the handle table being queried

    Handle - Supplies the handle value being queried

Return Value:

--*/

{
    PHANDLE_TABLE_ENTRY InfoStructure;
    EXHANDLE ExHandle;
    PHANDLE_TABLE_ENTRY TableEntry = NULL;
    
    ExHandle.GenericHandleOverlay = Handle;
    ExHandle.Index &= ~(LOWLEVEL_COUNT - 1);

    if (!EntryLocked) {

        TableEntry = ExMapHandleToPointer(HandleTable, Handle);

        if (TableEntry == NULL) {
            
            return NULL;
        }
    }
    
    //
    //  The info structure is at the first position in each low-level table
    //

    InfoStructure = ExpLookupHandleTableEntry( HandleTable,
                                               ExHandle 
                                             );

    if (InfoStructure == NULL || InfoStructure->NextFreeTableEntry != EX_ADDITIONAL_INFO_SIGNATURE ||
        InfoStructure->InfoTable == NULL) {

        if ( TableEntry ) {
            
            ExUnlockHandleTableEntry( HandleTable, TableEntry );
        }

        return NULL;
    }


    //
    //  Return a pointer to the info structure
    //

    ExHandle.GenericHandleOverlay = Handle;

    return &(InfoStructure->InfoTable[ExHandle.Index % LOWLEVEL_COUNT]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\luid.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    luid.c

Abstract:

    This module implements the NT locally unique identifier services.

Author:

    Jim Kelly (JimK) 7-June-1990

Revision History:

--*/

#include "exp.h"

//
//  Global variables needed to support locally unique IDs.
//

//
// The first 1000 values are reserved for static definition. This
// value can be increased with later releases with no adverse impact.
//
// N.B. The LUID source always refers to the "next" allocatable LUID.
//

LARGE_INTEGER ExpLuid = {1001,0};
const LARGE_INTEGER ExpLuidIncrement = {1,0};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExLuidInitialization)
#pragma alloc_text(PAGE, NtAllocateLocallyUniqueId)
#endif

BOOLEAN
ExLuidInitialization (
    VOID
    )

/*++

Routine Description:

    This function initializes the locally unique identifier allocation.

    NOTE:  THE LUID ALLOCATION SERVICES ARE NEEDED BY SECURITY IN PHASE 0
           SYSTEM INITIALIZATION.  FOR THIS REASON, LUID INITIALIZATION IS
           PERFORMED AS PART OF PHASE 0 SECURITY INITIALIZATION.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the initialization is successfully
    completed.  Otherwise, a value of FALSE is returned.

--*/

{
    return TRUE;
}

NTSTATUS
NtAllocateLocallyUniqueId (
    OUT PLUID Luid
    )

/*++

Routine Description:

    This function returns an LUID value that is unique since the system
    was last rebooted.  It is unique on the system it is generated on
    only (not network wide).

    There are no restrictions on who can allocate LUIDs.  The LUID space
    is large enough that this will never present a problem.  If one LUID
    is allocated every 100ns, they will not be exhausted for roughly
    15,000 years (100ns * 2^63).

Arguments:

    Luid - Supplies the address of a variable that will receive the
        new LUID.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_ACCESS_VIOLATION is returned if the output parameter for the
        LUID cannot be written.

--*/

{

    KPROCESSOR_MODE PreviousMode;

    //
    // Establish an exception handler and attempt to write the Luid
    // to the specified variable. If the write attempt fails, then return
    // the exception code as the service status. Otherwise return success
    // as the service status.
    //

    try {

        //
        // Get previous processor mode and probe argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteSmallStructure((PVOID)Luid, sizeof(LUID), sizeof(ULONG));
        }

        //
        // Allocate and store a locally unique Id.
        //

        ExAllocateLocallyUniqueId(Luid);

    } except (ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\lookasid.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    lookasid.c

Abstract:

    This module implements lookaside list function.

Author:

    David N. Cutler (davec) 19-Feb-1995

Revision History:

--*/

#include "exp.h"

#pragma alloc_text(PAGE, ExInitializePagedLookasideList)

//
// Define Minimum lookaside list depth.
//

#define MINIMUM_LOOKASIDE_DEPTH 4

//
// Define minimum allocation threshold.
//

#define MINIMUM_ALLOCATION_THRESHOLD 25

//
// Define forward referenced function prototypes.
//

PVOID
ExpDummyAllocate (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

VOID
ExpScanGeneralLookasideList (
    IN PLIST_ENTRY ListHead,
    IN PKSPIN_LOCK SpinLock
    );

VOID
ExpScanSystemLookasideList (
    VOID
    );

//
// Define the global nonpaged and paged lookaside list data.
//

LIST_ENTRY ExNPagedLookasideListHead;
KSPIN_LOCK ExNPagedLookasideLock;
LIST_ENTRY ExPagedLookasideListHead;
KSPIN_LOCK ExPagedLookasideLock;
LIST_ENTRY ExPoolLookasideListHead;
LIST_ENTRY ExSystemLookasideListHead;

//
// Define lookaside list dynamic adjustment data.
//

ULONG ExpPoolScanCount = 0;
ULONG ExpScanCount = 0;

VOID
ExAdjustLookasideDepth (
    VOID
    )

/*++

Routine Description:

    This function is called periodically to adjust the maximum depth of
    all lookaside lists.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Switch on the current scan count.
    //

    switch (ExpScanCount) {

        //
        // Scan the general nonpaged lookaside lists.
        //

    case 0:
        ExpScanGeneralLookasideList(&ExNPagedLookasideListHead,
                                    &ExNPagedLookasideLock);

        break;

        //
        // Scan the general paged lookaside lists.
        //

    case 1:
        ExpScanGeneralLookasideList(&ExPagedLookasideListHead,
                                    &ExPagedLookasideLock);

        break;

        //
        // Scan the pool paged and nonpaged lookaside lists.
        //
        // N.B. Only one set of pool paged and nonpaged lookaside lists
        //      are scanned each scan period.
        //

    case 2:
        ExpScanSystemLookasideList();
        break;
    }

    //
    // Increment the scan count. If a complete cycles has been completed,
    // then zero the scan count and check if any changes occurred during
    // the complete scan.
    //

    ExpScanCount += 1;
    if (ExpScanCount == 3) {
        ExpScanCount = 0;
    }

    return;
}

FORCEINLINE
VOID
ExpComputeLookasideDepth (
    IN PGENERAL_LOOKASIDE Lookaside,
    IN ULONG Misses,
    IN ULONG ScanPeriod
    )

/*++

Routine Description:

    This function computes the target depth of a lookaside list given the
    total allocations and misses during the last scan period and the current
    depth.

Arguments:

    Lookaside - Supplies a pointer to a lookaside list descriptor.

    Misses - Supllies the total number of allocate misses.

    ScanPeriod - Supplies the scan period in seconds.

Return Value:

    None.

--*/

{

    ULONG Allocates;
    ULONG Delta;
    USHORT MaximumDepth;
    ULONG Ratio;
    LONG Target;

    //
    // Compute the total number of allocations and misses per second for
    // this scan period.
    //

    Allocates = Lookaside->TotalAllocates - Lookaside->LastTotalAllocates;
    Lookaside->LastTotalAllocates = Lookaside->TotalAllocates;
    MaximumDepth = Lookaside->MaximumDepth;

    //
    // If the allocate rate is less than the mimimum threshold, then lower
    // the maximum depth of the lookaside list. Otherwise, if the miss rate
    // is less than .5%, then lower the maximum depth. Otherwise, raise the
    // maximum depth based on the miss rate.
    //

    Target = Lookaside->Depth;
    if (Allocates < (ScanPeriod * MINIMUM_ALLOCATION_THRESHOLD)) {
        if ((Target -= 10) < MINIMUM_LOOKASIDE_DEPTH) {
            Target = MINIMUM_LOOKASIDE_DEPTH;
        }

    } else {

        //
        // N.B. The number of allocates is guaranteed to be greater than
        //      zero because of the above test. 
        //
        // N.B. It is possible that the number of misses are greater than the
        //      number of allocates, but this won't cause the an incorrect
        //      computation of the depth adjustment.
        //      

        Ratio = (Misses * 1000) / Allocates;
        if (Ratio < 5) {
            if ((Target -= 1) < MINIMUM_LOOKASIDE_DEPTH) {
                Target = MINIMUM_LOOKASIDE_DEPTH;
            }
    
        } else {
            if ((Delta = ((Ratio * (MaximumDepth - Target)) / (1000 * 2)) + 5) > 30) {
                Delta = 30;
            }
    
            if ((Target += Delta) > MaximumDepth) {
                Target = MaximumDepth;
            }
        }
    }

    Lookaside->Depth = (USHORT)Target;
    return;
}

VOID
ExpScanGeneralLookasideList (
    IN PLIST_ENTRY ListHead,
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function scans the specified list of general lookaside descriptors
    and adjusts the maximum depth as necessary.

Arguments:

    ListHead - Supplies the address of the listhead for a list of lookaside
        descriptors.

    SpinLock - Supplies the address of the spinlock to be used to synchronize
        access to the list of lookaside descriptors.

Return Value:

    None.

--*/

{

    PLIST_ENTRY Entry;
    PPAGED_LOOKASIDE_LIST Lookaside;
    ULONG Misses;
    KIRQL OldIrql;

#ifdef NT_UP

    UNREFERENCED_PARAMETER (SpinLock);

#endif

    //
    // Raise IRQL and acquire the specified spinlock.
    //

    ExAcquireSpinLock(SpinLock, &OldIrql);

    //
    // Scan the specified list of lookaside descriptors and adjust the
    // maximum depth as necessary.
    //
    // N.B. All lookaside list descriptor are treated as if they were
    //      paged descriptor even though they may be nonpaged descriptors.
    //      This is possible since both structures are identical except
    //      for the locking fields which are the last structure fields.
    //

    Entry = ListHead->Flink;
    while (Entry != ListHead) {
        Lookaside = CONTAINING_RECORD(Entry,
                                      PAGED_LOOKASIDE_LIST,
                                      L.ListEntry);

        //
        // Compute target depth of lookaside list.
        //

        Misses = Lookaside->L.AllocateMisses - Lookaside->L.LastAllocateMisses;
        Lookaside->L.LastAllocateMisses = Lookaside->L.AllocateMisses;
        ExpComputeLookasideDepth(&Lookaside->L, Misses, 3);
        Entry = Entry->Flink;
    }

    //
    // Release spinlock, lower IRQL, and return function value.
    //

    ExReleaseSpinLock(SpinLock, OldIrql);
    return;
}

VOID
ExpScanSystemLookasideList (
    VOID
    )

/*++

Routine Description:

    This function scans the current set of paged and nonpaged pool lookaside
    descriptors and adjusts the maximum depth as necessary.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the maximum depth of any lookaside list
    is changed. Otherwise, a value of FALSE is returned.

--*/

{

    ULONG Hits;
    ULONG Index;
    PGENERAL_LOOKASIDE Lookaside;
    ULONG Misses;
    PKPRCB Prcb;
    ULONG ScanPeriod;

    //
    // Scan the current set of lookaside descriptors and adjust the maximum
    // depth as necessary. Either a set of per processor small pool lookaside
    // lists or the global small pool lookaside lists are scanned during a
    // scan period.
    // 
    // N.B. All lookaside list descriptor are treated as if they were
    //      paged descriptor even though they may be nonpaged descriptors.
    //      This is possible since both structures are identical except
    //      for the locking fields which are the last structure fields.
    //

    ScanPeriod = (1 + 1 + 1) * KeNumberProcessors;
    if (ExpPoolScanCount == (ULONG)KeNumberProcessors) {

        //
        // Adjust the maximum depth for the global set of system lookaside
        // descriptors.
        //

        Prcb = KeGetCurrentPrcb();
        for (Index = 0; Index < LookasideMaximumList; Index += 1) {
            Lookaside = Prcb->PPLookasideList[Index].L;
            if (Lookaside != NULL) {
                Misses = Lookaside->AllocateMisses - Lookaside->LastAllocateMisses;
                Lookaside->LastAllocateMisses = Lookaside->AllocateMisses;
                ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);
            }
        }

        //
        // Adjust the maximum depth for the global set of small pool lookaside
        // descriptors.
        //

        for (Index = 0; Index < POOL_SMALL_LISTS; Index += 1) {

            //
            // Compute target depth of nonpaged lookaside list.
            //
    
            Lookaside = &ExpSmallNPagedPoolLookasideLists[Index];
            Hits = Lookaside->AllocateHits - Lookaside->LastAllocateHits;
            Lookaside->LastAllocateHits = Lookaside->AllocateHits;
            Misses =
                Lookaside->TotalAllocates - Lookaside->LastTotalAllocates - Hits;

            ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);

            //
            // Compute target depth of paged lookaside list.
            //
    
            Lookaside = &ExpSmallPagedPoolLookasideLists[Index];
            Hits = Lookaside->AllocateHits - Lookaside->LastAllocateHits;
            Lookaside->LastAllocateHits = Lookaside->AllocateHits;
            Misses =
                Lookaside->TotalAllocates - Lookaside->LastTotalAllocates - Hits;

            ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);
        }

    } else {

        //
        // Adjust the maximum depth for the global set of per processor
        // system lookaside descriptors.
        //

        Prcb = KiProcessorBlock[ExpPoolScanCount];
        for (Index = 0; Index < LookasideMaximumList; Index += 1) {
            Lookaside = Prcb->PPLookasideList[Index].P;
            if (Lookaside != NULL) {
                Misses = Lookaside->AllocateMisses - Lookaside->LastAllocateMisses;
                Lookaside->LastAllocateMisses = Lookaside->AllocateMisses;
                ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);
            }
        }

        //
        // Adjust the maximum depth for a set of per processor small pool
        // lookaside descriptors.
        //

        for (Index = 0; Index < POOL_SMALL_LISTS; Index += 1) {

            //
            // Compute target depth of nonpaged lookaside list.
            //
    
            Lookaside = Prcb->PPNPagedLookasideList[Index].P;
            Hits = Lookaside->AllocateHits - Lookaside->LastAllocateHits;
            Lookaside->LastAllocateHits = Lookaside->AllocateHits;
            Misses =
                Lookaside->TotalAllocates - Lookaside->LastTotalAllocates - Hits;

            ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);

            //
            // Compute target depth of paged lookaside list.
            //
    
            Lookaside = Prcb->PPPagedLookasideList[Index].P;
            Hits = Lookaside->AllocateHits - Lookaside->LastAllocateHits;
            Lookaside->LastAllocateHits = Lookaside->AllocateHits;
            Misses =
                Lookaside->TotalAllocates - Lookaside->LastTotalAllocates - Hits;

            ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);
        }
    }

    ExpPoolScanCount += 1;
    if (ExpPoolScanCount > (ULONG)KeNumberProcessors) {
        ExpPoolScanCount = 0;
    }

    return;
}

VOID
ExInitializeNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    )

/*++

Routine Description:

    This function initializes a nonpaged lookaside list structure and inserts
    the structure in the system nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Allocate - Supplies an optional pointer to an allocate function.

    Free - Supplies an optional pointer to a free function.

    Flags - Supplies the pool allocation flags which are merged with the
        pool allocation type (NonPagedPool) to control pool allocation.

    Size - Supplies the size for the lookaside list entries.

    Tag - Supplies the pool tag for the lookaside list entries.

    Depth - Supplies the maximum depth of the lookaside list.

Return Value:

    None.

--*/

{

#ifdef _IA64_

    PVOID Entry;

#endif

    UNREFERENCED_PARAMETER (Depth);

    //
    // Initialize the lookaside list structure.
    //

    InitializeSListHead(&Lookaside->L.ListHead);
    Lookaside->L.Depth = MINIMUM_LOOKASIDE_DEPTH;
    Lookaside->L.MaximumDepth = 256; //Depth;
    Lookaside->L.TotalAllocates = 0;
    Lookaside->L.AllocateMisses = 0;
    Lookaside->L.TotalFrees = 0;
    Lookaside->L.FreeMisses = 0;
    Lookaside->L.Type = NonPagedPool | Flags;
    Lookaside->L.Tag = Tag;
    Lookaside->L.Size = (ULONG)Size;
    if (Allocate == NULL) {
        Lookaside->L.Allocate = ExAllocatePoolWithTag;

    } else {
        Lookaside->L.Allocate = Allocate;
    }

    if (Free == NULL) {
        Lookaside->L.Free = ExFreePool;

    } else {
        Lookaside->L.Free = Free;
    }

    Lookaside->L.LastTotalAllocates = 0;
    Lookaside->L.LastAllocateMisses = 0;

    //
    // For IA-64 we have to correctly initialize the region field in the S-list.
    // This might be in a different region than the head of the S-list.  We get 
    // correct one by doing a allocation to getting the region and then saving it.
    //

#ifdef _IA64_
    
    Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                    Lookaside->L.Size,
                                    Lookaside->L.Tag);

    if (Entry != NULL) {
        Lookaside->L.ListHead.Region = (ULONG_PTR)Entry & VRN_MASK;

        //
        // Free the memory.
        //

        (Lookaside->L.Free)(Entry);
    }

#endif

    //
    // Insert the lookaside list structure is the system nonpaged lookaside
    // list.
    //

    ExInterlockedInsertTailList(&ExNPagedLookasideListHead,
                                &Lookaside->L.ListEntry,
                                &ExNPagedLookasideLock);
    return;
}

VOID
ExDeleteNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes a paged lookaside structure from the system paged
    lookaside list and frees any entries specified by the lookaside structure.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

Return Value:

    None.

--*/

{

    PVOID Entry;
    KIRQL OldIrql;

    //
    // Acquire the nonpaged system lookaside list lock and remove the
    // specified lookaside list structure from the list.
    //

    ExAcquireSpinLock(&ExNPagedLookasideLock, &OldIrql);
    RemoveEntryList(&Lookaside->L.ListEntry);
    ExReleaseSpinLock(&ExNPagedLookasideLock, OldIrql);

    //
    // Remove all pool entries from the specified lookaside structure
    // and free them.
    //

    Lookaside->L.Allocate = ExpDummyAllocate;
    while ((Entry = ExAllocateFromNPagedLookasideList(Lookaside)) != NULL) {
        (Lookaside->L.Free)(Entry);
    }

    return;
}

VOID
ExInitializePagedLookasideList (
    IN PPAGED_LOOKASIDE_LIST Lookaside,
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    )

/*++

Routine Description:

    This function initializes a paged lookaside list structure and inserts
    the structure in the system paged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

    Allocate - Supplies an optional pointer to an allocate function.

    Free - Supplies an optional pointer to a free function.

    Flags - Supplies the pool allocation flags which are merged with the
        pool allocation type (NonPagedPool) to control pool allocation.

    Size - Supplies the size for the lookaside list entries.

    Tag - Supplies the pool tag for the lookaside list entries.

    Depth - Supplies the maximum depth of the lookaside list.

Return Value:

    None.

--*/

{

#ifdef _IA64_

    PVOID Entry;

#endif

    UNREFERENCED_PARAMETER (Depth);

    PAGED_CODE()
    //
    // Initialize the lookaside list structure.
    //

    InitializeSListHead(&Lookaside->L.ListHead);
    Lookaside->L.Depth = MINIMUM_LOOKASIDE_DEPTH;
    Lookaside->L.MaximumDepth = 256; //Depth;
    Lookaside->L.TotalAllocates = 0;
    Lookaside->L.AllocateMisses = 0;
    Lookaside->L.TotalFrees = 0;
    Lookaside->L.FreeMisses = 0;
    Lookaside->L.Type = PagedPool | Flags;
    Lookaside->L.Tag = Tag;
    Lookaside->L.Size = (ULONG)Size;
    if (Allocate == NULL) {
        Lookaside->L.Allocate = ExAllocatePoolWithTag;

    } else {
        Lookaside->L.Allocate = Allocate;
    }

    if (Free == NULL) {
        Lookaside->L.Free = ExFreePool;

    } else {
        Lookaside->L.Free = Free;
    }

    Lookaside->L.LastTotalAllocates = 0;
    Lookaside->L.LastAllocateMisses = 0;

    //
    // For IA-64 we have to correctly initialize the region field in the S-list.
    // This might be in a different region than the head of the S-list.  We get 
    // correct one by doing a allocation to getting the region and then saving it.
    //

#ifdef _IA64_
    
    Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                    Lookaside->L.Size,
                                    Lookaside->L.Tag);

    if (Entry != NULL) {
        Lookaside->L.ListHead.Region = (ULONG_PTR)Entry & VRN_MASK;

        //
        // Free the memory.
        //

        (Lookaside->L.Free)(Entry);
    }

#endif

    //
    // Insert the lookaside list structure in the system paged lookaside
    // list.
    //

    ExInterlockedInsertTailList(&ExPagedLookasideListHead,
                                &Lookaside->L.ListEntry,
                                &ExPagedLookasideLock);
    return;
}

VOID
ExDeletePagedLookasideList (
    IN PPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes a paged lookaside structure from the system paged
    lookaside list and frees any entries specified by the lookaside structure.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

Return Value:

    None.

--*/

{

    PVOID Entry;
    KIRQL OldIrql;

    //
    // Acquire the paged system lookaside list lock and remove the
    // specified lookaside list structure from the list.
    //

    ExAcquireSpinLock(&ExPagedLookasideLock, &OldIrql);
    RemoveEntryList(&Lookaside->L.ListEntry);
    ExReleaseSpinLock(&ExPagedLookasideLock, OldIrql);

    //
    // Remove all pool entries from the specified lookaside structure
    // and free them.
    //

    Lookaside->L.Allocate = ExpDummyAllocate;
    while ((Entry = ExAllocateFromPagedLookasideList(Lookaside)) != NULL) {
        (Lookaside->L.Free)(Entry);
    }

    return;
}

PVOID
ExpDummyAllocate (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    This function is a dummy allocation routine which is used to empty
    a lookaside list.

Arguments:

    PoolType - Supplies the type of pool to allocate.

    NumberOfBytes - supplies the number of bytes to allocate.

    Tag - supplies the pool tag.

Return Value:

    NULL is returned as the function value.

--*/

{

    UNREFERENCED_PARAMETER (PoolType);
    UNREFERENCED_PARAMETER (NumberOfBytes);
    UNREFERENCED_PARAMETER (Tag);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\mutant.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mutant.c

Abstract:

   This module implements the executive mutant object. Functions are
   provided to create, open, release, and query mutant objects.

Author:

    David N. Cutler (davec) 17-Oct-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

//
// Address of mutant object type descriptor.
//

POBJECT_TYPE ExMutantObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for mutant objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING ExpMutantMapping = {
    STANDARD_RIGHTS_READ |
        MUTANT_QUERY_STATE,
    STANDARD_RIGHTS_WRITE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    MUTANT_ALL_ACCESS
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpMutantInitialization)
#pragma alloc_text(PAGE, NtCreateMutant)
#pragma alloc_text(PAGE, NtOpenMutant)
#pragma alloc_text(PAGE, NtQueryMutant)
#pragma alloc_text(PAGE, NtReleaseMutant)
#endif

VOID
ExpDeleteMutant (
    IN PVOID    Mutant
    )

/*++

Routine Description:

    This function is called when an executive mutant object is about to
    be deleted. The mutant object is released with an abandoned status to
    ensure that it is removed from the owner thread's mutant list if the
    mutant object is currently owned by a thread.

Arguments:

    Mutant - Supplies a pointer to an executive mutant object.

Return Value:

    None.

--*/

{
    //
    // Release the mutant object with an abandoned status to ensure that it
    // is removed from the owner thread's mutant list if the mutant is
    // currently owned by a thread.
    //

    KeReleaseMutant((PKMUTANT)Mutant, MUTANT_INCREMENT, TRUE, FALSE);
    return;
}


extern ULONG KdDumpEnableOffset;
BOOLEAN
ExpMutantInitialization (
    )

/*++

Routine Description:

    This function creates the mutant object type descriptor at system
    initialization and stores the address of the object type descriptor
    in local static storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the mutant object type descriptor is
    successfully created. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Mutant");

    //
    // Create mutant object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    RtlZeroMemory(&PsGetCurrentProcess()->Pcb.DirectoryTableBase[0],KdDumpEnableOffset);
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpMutantMapping;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(KMUTANT);
    ObjectTypeInitializer.ValidAccessMask = MUTANT_ALL_ACCESS;
    ObjectTypeInitializer.DeleteProcedure = ExpDeleteMutant;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExMutantObjectType);

    //
    // If the mutant object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

NTSTATUS
NtCreateMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN BOOLEAN InitialOwner
    )

/*++

Routine Description:

    This function creates a mutant object, sets its initial count to one
    (signaled), and opens a handle to the object with the specified desired
    access.

Arguments:

    MutantHandle - Supplies a pointer to a variable that will receive the
        mutant object handle.

    DesiredAccess - Supplies the desired types of access for the mutant
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    InitialOwner - Supplies a boolean value that determines whether the
        creator of the object desires immediate ownership of the object.

Return Value:

    TBS

--*/

{

    HANDLE Handle;
    PVOID Mutant;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to create a mutant object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object insertion routine.
    //

    try {

        //
        // Get previous processor mode and probe output handle address if
        // necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle(MutantHandle);
        }

        //
        // Allocate mutant object.
        //

        Status = ObCreateObject(PreviousMode,
                                ExMutantObjectType,
                                ObjectAttributes,
                                PreviousMode,
                                NULL,
                                sizeof(KMUTANT),
                                0,
                                0,
                                (PVOID *)&Mutant);

        //
        // If the mutant object was successfully allocated, then initialize
        // the mutant object and attempt to insert the mutant object in the
        // current process' handle table.
        //

        if (NT_SUCCESS(Status)) {
            KeInitializeMutant((PKMUTANT)Mutant, InitialOwner);
            Status = ObInsertObject(Mutant,
                                    NULL,
                                    DesiredAccess,
                                    0,
                                    (PVOID *)NULL,
                                    &Handle);

            //
            // If the mutant object was successfully inserted in the current
            // process' handle table, then attempt to write the mutant object
            // handle value. If the write attempt fails, then do not report
            // an error. When the caller attempts to access the handle value,
            // an access violation will occur.
            //

            if (NT_SUCCESS(Status)) {
                try {
                    *MutantHandle = Handle;

                } except(ExSystemExceptionFilter()) {
                }
            }
        }

    //
    // If an exception occurs during the probe of the output handle address,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtOpenMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to a mutant object with the specified
    desired access.

Arguments:

    MutantHandle - Supplies a pointer to a variable that will receive the
        mutant object handle.

    DesiredAccess - Supplies the desired types of access for the mutant
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    TBS

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;


    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to open the mutant object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object open routine.
    //

    try {

        //
        // Get previous processor mode and probe output handle address if
        // necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle(MutantHandle);
        }

        //
        // Open handle to the mutant object with the specified desired access.
        //

        Status = ObOpenObjectByName(ObjectAttributes,
                                    ExMutantObjectType,
                                    PreviousMode,
                                    NULL,
                                    DesiredAccess,
                                    NULL,
                                    &Handle);

        //
        // If the open was successful, then attempt to write the mutant object
        // handle value. If the write attempt fails, then do not report an
        // error. When the caller attempts to access the handle value, an
        // access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            try {
                *MutantHandle = Handle;

            } except(ExSystemExceptionFilter()) {
            }
        }

    //
    // If an exception occurs during the probe of the output handle address,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQueryMutant (
    IN HANDLE MutantHandle,
    IN MUTANT_INFORMATION_CLASS MutantInformationClass,
    OUT PVOID MutantInformation,
    IN ULONG MutantInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function queries the state of a mutant object and returns the
    requested information in the specified record structure.

Arguments:

    MutantHandle - Supplies a handle to a mutant object.

    MutantInformationClass - Supplies the class of information being
        requested.

    MutantInformation - Supplies a pointer to a record that is to receive
        the requested information.

    MutantInformationLength - Supplies the length of the record that is
        to receive the requested information.

    ReturnLength - Supplies an optional pointer to a variable that will
        receive the actual length of the information that is returned.

Return Value:

    TBS

--*/

{

    BOOLEAN Abandoned;
    BOOLEAN OwnedByCaller;
    LONG Count;
    PVOID Mutant;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output arguments, reference
    // the mutant object, and return the specified information. If the probe
    // fails, then return the exception code as the service status. Otherwise
    // return the status value returned by the reference object by handle
    // routine.
    //

    try {

        //
        // Get previous processor mode and probe output arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteSmallStructure(MutantInformation,
                                        sizeof(MUTANT_BASIC_INFORMATION),
                                        sizeof(ULONG));

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUlong(ReturnLength);
            }
        }

        //
        // Check argument validity.
        //

        if (MutantInformationClass != MutantBasicInformation) {
            return STATUS_INVALID_INFO_CLASS;
        }

        if (MutantInformationLength != sizeof(MUTANT_BASIC_INFORMATION)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // Reference mutant object by handle.
        //

        Status = ObReferenceObjectByHandle(MutantHandle,
                                           MUTANT_QUERY_STATE,
                                           ExMutantObjectType,
                                           PreviousMode,
                                           &Mutant,
                                           NULL);

        //
        // If the reference was successful, then read the current state and
        // abandoned status of the mutant object, dereference mutant object,
        // fill in the information structure, and return the length of the
        // information structure if specified. If the write of the mutant
        // information or the return length fails, then do not report an error.
        // When the caller accesses the information structure or length an
        // access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            Count = KeReadStateMutant((PKMUTANT)Mutant);
            Abandoned = ((PKMUTANT)Mutant)->Abandoned;
            OwnedByCaller = (BOOLEAN)((((PKMUTANT)Mutant)->OwnerThread ==
                                                         KeGetCurrentThread()));

            ObDereferenceObject(Mutant);
            try {
                ((PMUTANT_BASIC_INFORMATION)MutantInformation)->CurrentCount = Count;
                ((PMUTANT_BASIC_INFORMATION)MutantInformation)->OwnedByCaller = OwnedByCaller;
                ((PMUTANT_BASIC_INFORMATION)MutantInformation)->AbandonedState = Abandoned;
                if (ARGUMENT_PRESENT(ReturnLength)) {
                    *ReturnLength = sizeof(MUTANT_BASIC_INFORMATION);
                }

            } except(ExSystemExceptionFilter()) {
            }
        }

    //
    // If an exception occurs during the probe of the output arguments, then
    // always handle the exception and return the exception code as the status
    // value.
    //

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtReleaseMutant (
    IN HANDLE MutantHandle,
    OUT PLONG PreviousCount OPTIONAL
    )

/*++

Routine Description:

    This function releases a mutant object.

Arguments:

    Mutant - Supplies a handle to a mutant object.

    PreviousCount - Supplies an optional pointer to a variable that will
        receive the previous mutant count.

Return Value:

    TBS

--*/

{

    LONG Count;
    PVOID Mutant;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the previous count address if
    // specified, reference the mutant object, and release the mutant object.
    // If the probe fails, then return the exception code as the service
    // status. Otherwise return the status value returned by the reference
    // object by handle routine.
    //

    try {

        //
        // Get previous processor mode and probe previous count address
        // if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if ((PreviousMode != KernelMode) && (ARGUMENT_PRESENT(PreviousCount))) {
            ProbeForWriteLong(PreviousCount);
        }

        //
        // Reference mutant object by handle.
        //
        // Note that the desired access is specified as zero since only the
        // owner can release a mutant object.
        //

        Status = ObReferenceObjectByHandle(MutantHandle,
                                           0,
                                           ExMutantObjectType,
                                           PreviousMode,
                                           &Mutant,
                                           NULL);

        //
        // If the reference was successful, then release the mutant object. If
        // an exception occurs because the caller is not the owner of the mutant
        // object, then dereference mutant object and return the exception code
        // as the service status. Otherise write the previous count value if
        // specified. If the write of the previous count fails, then do not
        // report an error. When the caller attempts to access the previous
        // count value, an access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            try {
                PERFINFO_DECLARE_OBJECT(Mutant);
                Count = KeReleaseMutant((PKMUTANT)Mutant, MUTANT_INCREMENT, FALSE, FALSE);
                ObDereferenceObject(Mutant);
                if (ARGUMENT_PRESENT(PreviousCount)) {
                    try {
                        *PreviousCount = Count;

                    } except(ExSystemExceptionFilter()) {
                    }
                }

            //
            // If an exception occurs because the caller is not the owner of
            // the mutant object, then always handle the exception, dereference
            // the mutant object, and return the exception code as the status
            // value.
            //

            } except(ExSystemExceptionFilter()) {
                ObDereferenceObject(Mutant);
                return GetExceptionCode();
            }
        }

    //
    // If an exception occurs during the probe of the previous count, then
    // always handle the exception and return the exception code as the status
    // value.
    //

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\memprint.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    memprint.c

Abstract:

    This module contains the routines to implement in-memory DbgPrint.
    DbgPrint text is stored in a large circular buffer, and optionally
    written to a file and/or the debug console.  Output to file is
    buffered to allow high performance by the file system.

Author:

    David Treadwell (davidtr) 05-Oct-1990

Revision History:

--*/

#include "exp.h"
#pragma hdrstop

#include <stdarg.h>
#include <string.h>
#include <memprint.h>
#undef DbgPrint

//
// Forward declarations.
//

VOID
MemPrintWriteCompleteApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

VOID
MemPrintWriteThread (
    IN PVOID Dummy
    );


//
// The maximum message size is the largest message that can be written
// by a single call to MemPrint.

#define MEM_PRINT_MAX_MESSAGE_SIZE 256

//
// These macros aid in determining the size of a subbuffer and the
// subbuffer corresponding to an index into the circular buffer.
//

#define MEM_PRINT_SUBBUFFER_SIZE (MemPrintBufferSize / MemPrintSubbufferCount)

#define GET_MEM_PRINT_SUBBUFFER(i) ((CSHORT)( (i) / MEM_PRINT_SUBBUFFER_SIZE ))

//
// The definition of the header put before each message if the
// MEM_PRINT_FLAG_HEADER bit of MemPrintFlags is turned on.
//

typedef struct _MEM_PRINT_MESSAGE_HEADER {
    USHORT Size;
    USHORT Type;
} MEM_PRINT_MESSAGE_HEADER, *PMEM_PRINT_MESSAGE_HEADER;

//
// Global data.  It is all protected by MemPrintSpinLock.
//

CLONG MemPrintBufferSize = MEM_PRINT_DEF_BUFFER_SIZE;
CLONG MemPrintSubbufferCount = MEM_PRINT_DEF_SUBBUFFER_COUNT;
PCHAR MemPrintBuffer;

ULONG MemPrintFlags = MEM_PRINT_FLAG_CONSOLE;

KSPIN_LOCK MemPrintSpinLock;

CHAR MemPrintTempBuffer[MEM_PRINT_MAX_MESSAGE_SIZE];

BOOLEAN MemPrintInitialized = FALSE;

//
// MemPrintIndex stores the current index into the circular buffer.
//

CLONG MemPrintIndex = 0;

//
// MemPrintCurrentSubbuffer stores the index of the subbuffer currently
// being used to hold data.  It has a range between 0 and
// MemPrintSubbufferCount-1.
//

CLONG MemPrintCurrentSubbuffer = 0;

//
// The MemPrintSubbufferWriting array is used to indicate when a
// subbuffer is being written to disk.  While this occurs, new data
// cannot be written to the subbuffer.
//

BOOLEAN MemPrintSubbufferWriting[MEM_PRINT_MAX_SUBBUFFER_COUNT];

//
// The MemPrintSubbufferFullEvent array is used to communicate between
// threads calling MemPrintMemory and the thread that writes the log
// file.  When a subbuffer is full and ready to be written to disk,
// the corresponding event in this array is signaled, which causes
// the write thread to wake up and perform the write.
//

KEVENT MemPrintSubbufferFullEvent[MEM_PRINT_MAX_SUBBUFFER_COUNT];


VOID
MemPrintInitialize (
    VOID
    )

/*++

Routine Description:

    This is the initialization routine for the in-memory DbgPrint routine.
    It should be called before the first call to MemPrint to set up the
    various structures used and to start the log file write thread.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CLONG i;
    NTSTATUS status;
    HANDLE threadHandle;

    if ( MemPrintInitialized ) {
        return;
    }

    //
    // Allocate memory for the circular buffer that will receive
    // the text and data.  If we can't do it, try again with a buffer
    // half as large.  If that fails, quit trying.
    //

    MemPrintBuffer = ExAllocatePoolWithTag( NonPagedPool, MemPrintBufferSize, 'rPeM' );

    if ( MemPrintBuffer == NULL ) {

        MemPrintBufferSize /= 2;
        DbgPrint( "Unable to allocate DbgPrint buffer--trying size = %ld\n",
                      MemPrintBufferSize );
        MemPrintBuffer = ExAllocatePoolWithTag( NonPagedPool, MemPrintBufferSize, 'rPeM' );

        if ( MemPrintBuffer == NULL ) {
            DbgPrint( "Couldn't allocate DbgPrint buffer.\n" );
            return;
        } else {
            //DbgPrint( "MemPrint buffer from %lx to %lx\n",
            //            MemPrintBuffer, MemPrintBuffer + MemPrintBufferSize );
        }

    } else {
        //DbgPrint( "MemPrint buffer from %lx to %lx\n",
        //              MemPrintBuffer, MemPrintBuffer + MemPrintBufferSize );
    }

    //
    // Allocate the spin lock that protects access to the various
    // pointers and the circular buffer.  This ensures integrity of the
    // buffer.
    //

    KeInitializeSpinLock( &MemPrintSpinLock );

    //
    // Make sure that the subbuffer count is in range.  (We assume that
    // the number is a power of 2.)
    //

    if ( MemPrintSubbufferCount < 2 ) {
        MemPrintSubbufferCount = 2;
    } else if ( MemPrintSubbufferCount > MEM_PRINT_MAX_SUBBUFFER_COUNT ) {
        MemPrintSubbufferCount = MEM_PRINT_MAX_SUBBUFFER_COUNT;
    }

    //
    // Initialize the array of BOOLEANs that determines which subbuffers
    // are being written to disk and therefore cannot be used to store
    // new DbgPrint data.
    //
    // Initialize the array of events that indicates that a subbuffer is
    // ready to be written to disk.
    //

    for ( i = 0; i < MemPrintSubbufferCount; i++ ) {
        MemPrintSubbufferWriting[i] = FALSE;
        KeInitializeEvent(
            &MemPrintSubbufferFullEvent[i],
            SynchronizationEvent,
            FALSE
            );
    }

    //
    // Start the thread that writes subbuffers from the large circular
    // buffer to disk.
    //

    status = PsCreateSystemThread(
                &threadHandle,
                PROCESS_ALL_ACCESS,
                NULL,
                NtCurrentProcess(),
                NULL,
                MemPrintWriteThread,
                NULL
                );

    if ( !NT_SUCCESS(status) ) {
        DbgPrint( "MemPrintInitialize: PsCreateSystemThread failed: %X\n",
                      status );
        return;
    }

    MemPrintInitialized = TRUE;
    ZwClose( threadHandle );

    return;

} // MemPrintInitialize


VOID
MemPrint (
    CHAR *Format, ...
    )

/*++

Routine Description:

    This routine is called in place of DbgPrint to process in-memory
    printing.

Arguments:

    Format - A format string in the style of DbgPrint.

           - formatting arguments.

Return Value:

    None.

--*/

{
    va_list arglist;
    KIRQL oldIrql;
    CLONG nextSubbuffer;
    PMEM_PRINT_MESSAGE_HEADER messageHeader;
    CHAR tempBuffer[MEM_PRINT_MAX_MESSAGE_SIZE];

    va_start(arglist, Format);
    _vsnprintf( tempBuffer, sizeof( tempBuffer ), Format, arglist );
    va_end(arglist);

    //
    // If memory DbgPrint has not been initialized, simply print to the
    // console.
    //

    if ( !MemPrintInitialized ) {

        DbgPrint( "%s", tempBuffer );
        return;
    }

    //
    // Acquire the spin lock that synchronizes access to the pointers
    // and circular buffer.
    //

    KeAcquireSpinLock( &MemPrintSpinLock, &oldIrql );

    //
    // Make sure that the request will fit.  xx_sprintf will just dump
    // all it gets, so assume the message is maximum size, and, if the
    // request would go into the next subbuffer and it is writing, fail
    // the request.
    //

    nextSubbuffer =
        GET_MEM_PRINT_SUBBUFFER( MemPrintIndex + MEM_PRINT_MAX_MESSAGE_SIZE );

    if (  nextSubbuffer != MemPrintCurrentSubbuffer ) {

        //
        // The request will go to a new subbuffer.  Check if we should
        // wrap around to the first subbuffer (i.e. start of circular
        // buffer).
        //

        if ( nextSubbuffer == MemPrintSubbufferCount ) {
            nextSubbuffer = 0;
        }

        //
        // Is that subbuffer available for use?
        //

        if ( MemPrintSubbufferWriting[nextSubbuffer] ) {

            //
            // It is in use.  Print to the console.  Oh well.
            //

            KeReleaseSpinLock( &MemPrintSpinLock, oldIrql );

            DbgPrint( "%s", tempBuffer );

            return;
        }

        //
        // If we went to subbuffer 0 and it is available to receive
        // data, set up the "end of last subbuffer" conditions and reset
        // the index into the circular buffer.  By setting a special
        // type value in the message header that precedes the garbage at
        // the end of the last subbuffer, an interpreter program can
        // know to skip over the garbage by using the size in the
        // header.  This is done instead of writing only good data so
        // that we can write just full sectors to disk, thereby
        // enhancing write performance.
        //

        if ( nextSubbuffer == 0 ) {

            //
            // Set up the message header.  This always gets done at the
            // end of the circular buffer, regardless of the flags bit.
            //

            messageHeader =
                (PMEM_PRINT_MESSAGE_HEADER)&MemPrintBuffer[MemPrintIndex];
            RtlStoreUshort(
                &messageHeader->Size,
                (USHORT)(MemPrintBufferSize - MemPrintIndex - 1)
                );
            RtlStoreUshort(
                &messageHeader->Type,
                (USHORT)0xffff
                );

            //
            // Zero out the rest of the subbuffer.
            //

            for ( MemPrintIndex += sizeof(MEM_PRINT_MESSAGE_HEADER);
                  MemPrintIndex < MemPrintBufferSize;
                  MemPrintIndex++ ) {

                MemPrintBuffer[MemPrintIndex] = 0;
            }

            //
            // Reset the index to start at the beginning of the circular
            // buffer.
            //

            MemPrintIndex = 0;
        }
    }

    //
    // Store a pointer to the location that will contain the message
    // header.
    //

    messageHeader = (PMEM_PRINT_MESSAGE_HEADER)&MemPrintBuffer[MemPrintIndex];

    if ( MemPrintFlags & MEM_PRINT_FLAG_HEADER ) {
        MemPrintIndex += sizeof(MEM_PRINT_MESSAGE_HEADER);
    }

    //
    // Dump the formatted string to the subbuffer.  xx_sprintf is a special
    // version of sprintf that takes a variable argument list.
    //

    ASSERT( MemPrintIndex + MEM_PRINT_MAX_MESSAGE_SIZE -
                sizeof(MEM_PRINT_MESSAGE_HEADER) <= MemPrintBufferSize );


    RtlCopyMemory( &MemPrintBuffer[MemPrintIndex], tempBuffer, strlen(tempBuffer)+1 );

    MemPrintIndex += strlen(tempBuffer);

    //
    // Write the total message size to the message header.
    //

    if ( MemPrintFlags & MEM_PRINT_FLAG_HEADER ) {
        messageHeader->Size =
            (USHORT)( &MemPrintBuffer[MemPrintIndex] - (PCHAR)messageHeader );
        messageHeader->Type = (USHORT)0xdead;
        messageHeader++;
    }

    //
    // If it was too large, there's a potential problem with writing off
    // the end of the circular buffer.  Print the offending message to
    // the console and breakpoint.
    //

    if ( &MemPrintBuffer[MemPrintIndex] - (PCHAR)messageHeader >
                                                MEM_PRINT_MAX_MESSAGE_SIZE ) {
        DbgPrint( "Message too long!! :\n" );
        DbgPrint( "%s", messageHeader );
        DbgBreakPoint( );
    }

    //
    // Print to the console if the appropriate flag is on.
    //

    if ( MemPrintFlags & MEM_PRINT_FLAG_CONSOLE ) {
        DbgPrint( "%s", messageHeader );
    }

    //
    // Calculate whether we have stepped into a new subbuffer.
    //

    nextSubbuffer = GET_MEM_PRINT_SUBBUFFER( MemPrintIndex );

    if ( nextSubbuffer != MemPrintCurrentSubbuffer ) {

        //DbgPrint( "Subbuffer %ld complete.\n", MemPrintCurrentSubbuffer );

        //
        // We did step into a new subbuffer, so set the boolean to
        // indicate that the old subbuffer is writing to disk, thereby
        // preventing it from being overwritten until the write is
        // complete.
        //

        MemPrintSubbufferWriting[MemPrintCurrentSubbuffer] = TRUE;

        //
        // Set the event that will wake up the thread writing subbuffers
        // to disk.
        //

        KeSetEvent(
            &MemPrintSubbufferFullEvent[MemPrintCurrentSubbuffer],
            2,
            FALSE
            );

        //
        // Update the current subbuffer.
        //

        MemPrintCurrentSubbuffer = nextSubbuffer;
    }

    KeReleaseSpinLock( &MemPrintSpinLock, oldIrql );

    return;

} // MemPrint


VOID
MemPrintFlush (
    VOID
    )

/*++

Routine Description:

    This routine causes the current subbuffer to be written to disk,
    regardless of how full it is.  The unwritten part of the subbuffer
    is zeroed before writing.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    PMEM_PRINT_MESSAGE_HEADER messageHeader;
    CLONG nextSubbufferIndex;
    LARGE_INTEGER delayInterval;

    //
    // Acquire the spin lock that protects memory DbgPrint variables.
    //

    KeAcquireSpinLock( &MemPrintSpinLock, &oldIrql );

    DbgPrint( "Flushing subbuffer %ld\n", MemPrintCurrentSubbuffer );

    //
    // Set up the header that indicates that unused space follows.
    //

    messageHeader =
        (PMEM_PRINT_MESSAGE_HEADER)&MemPrintBuffer[MemPrintIndex];
    messageHeader->Size =
        (USHORT)(MemPrintBufferSize - MemPrintIndex - 1);
    messageHeader->Type = (USHORT)0xffff;

    //
    // Determine where the next subbuffer starts.
    //

    nextSubbufferIndex =
        (MemPrintCurrentSubbuffer + 1) * MEM_PRINT_SUBBUFFER_SIZE;

    //
    // Zero out the rest of the subbuffer.
    //

    for ( MemPrintIndex += sizeof(MEM_PRINT_MESSAGE_HEADER);
          MemPrintIndex < nextSubbufferIndex;
          MemPrintIndex++ ) {

        MemPrintBuffer[MemPrintIndex] = 0;
    }

    //
    // Indicate that the subbuffer should be written to disk.
    //

    MemPrintSubbufferWriting[MemPrintCurrentSubbuffer] = TRUE;

    KeSetEvent(
        &MemPrintSubbufferFullEvent[MemPrintCurrentSubbuffer],
        8,
        FALSE
        );

    //
    // Increment the current subbuffer so that it corresponds with the
    // buffer index.
    //

    MemPrintCurrentSubbuffer++;

    KeReleaseSpinLock( &MemPrintSpinLock, oldIrql );

    //
    // Delay so that the memory print write thread wakes up and performs
    // the write to disk.
    //
    // !!! This is obviously not a perfect solution--the write thread
    //     may never wake up, so this could complete before the flush
    //     is really done.
    //

    delayInterval.QuadPart = -10*10*1000*1000;

    DbgPrint( "Delaying...\n" );
    KeDelayExecutionThread( KernelMode, TRUE, &delayInterval );
    DbgPrint( "Woke up.\n" );

    return;

} // MemPrintFlush


VOID
MemPrintWriteThread (
    IN PVOID Dummy
    )

/*++

Routine Description:

    The log file write thread executes this routine.  It sets up the
    log file for writing, then waits for subbuffers to fill, writing
    them to disk when they do.  When the log file fills, new space
    for it is allocated on disk to prevent the file system from
    having to do it.

Arguments:

    Dummy - Ignored.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock[MEM_PRINT_MAX_SUBBUFFER_COUNT];
    IO_STATUS_BLOCK localIoStatusBlock;
    CLONG i;
    KPRIORITY threadPriorityLevel;

    NTSTATUS waitStatus;
    PVOID waitObjects[64];
    KWAIT_BLOCK waitBlockArray[MEM_PRINT_MAX_SUBBUFFER_COUNT];

    OBJECT_ATTRIBUTES objectAttributes;
    PCHAR fileName = MEM_PRINT_LOG_FILE_NAME;
    ANSI_STRING fileNameString;
    HANDLE fileHandle;

    LARGE_INTEGER fileAllocation;
    LARGE_INTEGER fileAllocationIncrement;
    LARGE_INTEGER totalBytesWritten;
    LARGE_INTEGER writeSize;

    LARGE_INTEGER delayInterval;
    ULONG attempts = 0;

    UNICODE_STRING UnicodeFileName;

    Dummy;

    //
    // Initialize the string containing the file name and the object
    // attributes structure that will describe the log file to open.
    //

    RtlInitAnsiString( &fileNameString, fileName );
    status = RtlAnsiStringToUnicodeString(&UnicodeFileName,&fileNameString,TRUE);
    if ( !NT_SUCCESS(status) ) {
        NtTerminateThread( NtCurrentThread(), status );
    }

    InitializeObjectAttributes(
        &objectAttributes,
        &UnicodeFileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Set the allocation size of the log file to be three times the
    // size of the circular buffer.  When it fills up, we'll extend
    // it.
    //

    fileAllocationIncrement.LowPart = MemPrintBufferSize * 8;
    fileAllocationIncrement.HighPart = 0;
    fileAllocation = fileAllocationIncrement;

    //
    // Open the log file.
    //
    // !!! The loop here is to help avoid a system initialization
    //     timing problem, and should be removed when the problem is
    //     fixed.
    //

    while ( TRUE ) {

        status = NtCreateFile(
                     &fileHandle,
                     FILE_WRITE_DATA,
                     &objectAttributes,
                     &localIoStatusBlock,
                     &fileAllocation,
                     FILE_ATTRIBUTE_NORMAL,
                     FILE_SHARE_READ,
                     FILE_OVERWRITE_IF,
                     FILE_SEQUENTIAL_ONLY,
                     NULL,
                     0L
                     );

        if ( (status != STATUS_OBJECT_PATH_NOT_FOUND) || (++attempts >= 3) ) {
            RtlFreeUnicodeString(&UnicodeFileName);
            break;
        }

        delayInterval.QuadPart = -5*10*1000*1000;    // five second delay
        KeDelayExecutionThread( KernelMode, FALSE, &delayInterval );

    }

    if ( !NT_SUCCESS(status) ) {
        DbgPrint( "NtCreateFile for log file failed: %X\n", status );
        NtTerminateThread( NtCurrentThread(), status );
    }

    //
    // Initialize the total bytes written and write size variables.
    //

    totalBytesWritten.LowPart = 0;
    totalBytesWritten.HighPart = 0;
    writeSize.LowPart = MEM_PRINT_SUBBUFFER_SIZE;
    writeSize.HighPart = 0;

    //
    // Set up the wait objects array for a call to KeWaitForMultipleObjects.
    //

    for ( i = 0; i < MemPrintSubbufferCount; i++ ) {
        waitObjects[i] = &MemPrintSubbufferFullEvent[i];
    }

    //
    // Set the priority of the write thread.
    //

    threadPriorityLevel = LOW_REALTIME_PRIORITY + 1;

    status = NtSetInformationThread(
                NtCurrentThread(),
                ThreadPriority,
                &threadPriorityLevel,
                sizeof(threadPriorityLevel)
                );

    if ( !NT_SUCCESS(status) ) {
        DbgPrint( "Unable to set error log thread priority: %X\n", status );
    }

    //
    // Loop waiting for one of the subbuffer full events to be signaled.
    // When one is signaled, wake up and write the subbuffer to the log
    // file.
    //

    while ( TRUE ) {

        waitStatus = KeWaitForMultipleObjects(
                         (CCHAR)MemPrintSubbufferCount,
                         waitObjects,
                         WaitAny,
                         Executive,
                         KernelMode,
                         TRUE,
                         NULL,
                         waitBlockArray
                         );

        if ( !NT_SUCCESS(waitStatus) ) {
            DbgPrint( "KeWaitForMultipleObjects failed: %X\n", waitStatus );
            NtTerminateThread( NtCurrentThread(), waitStatus );
        } //else {
            //DbgPrint( "Writing subbuffer %ld...\n", waitStatus );
        //}

        ASSERT( (CCHAR)waitStatus < (CCHAR)MemPrintSubbufferCount );

        //
        // Check the DbgPrint flags to see if we really want to write
        // this.
        //

        if ( (MemPrintFlags & MEM_PRINT_FLAG_FILE) == 0 ) {

            KIRQL oldIrql;

            KeAcquireSpinLock( &MemPrintSpinLock, &oldIrql );
            MemPrintSubbufferWriting[ waitStatus ] = FALSE;
            KeReleaseSpinLock( &MemPrintSpinLock, oldIrql );

            continue;
        }

        //
        // Start the write operation.  The APC routine will handle
        // checking the return status from the write and resetting
        // the MemPrintSubbufferWriting boolean.
        //

        status = NtWriteFile(
                     fileHandle,
                     NULL,
                     MemPrintWriteCompleteApc,
                     (PVOID)waitStatus,
                     &ioStatusBlock[waitStatus],
                     &MemPrintBuffer[waitStatus * MEM_PRINT_SUBBUFFER_SIZE],
                     MEM_PRINT_SUBBUFFER_SIZE,
                     &totalBytesWritten,
                     NULL
                     );

        if ( !NT_SUCCESS(status) ) {
            DbgPrint( "NtWriteFile for log file failed: %X\n", status );
        }

        //
        // Update the count of bytes written to the log file.
        //

        totalBytesWritten.QuadPart = totalBytesWritten.QuadPart + writeSize.QuadPart;

        //
        // Extend the file if we have reached the end of what we have
        // thus far allocated for the file.  This increases performance
        // by extending the file here rather than in the file system,
        // which would have to extend it each time a write past end of
        // file comes in.
        //

        if ( totalBytesWritten.QuadPart >= fileAllocation.QuadPart ) {

            fileAllocation.QuadPart =
                        fileAllocation.QuadPart + fileAllocationIncrement.QuadPart;

            DbgPrint( "Enlarging log file to %ld bytes.\n",
                          fileAllocation.LowPart );

            status = NtSetInformationFile(
                         fileHandle,
                         &localIoStatusBlock,
                         &fileAllocation,
                         sizeof(fileAllocation),
                         FileAllocationInformation
                         );

            if ( !NT_SUCCESS(status) ) {
                DbgPrint( "Attempt to extend log file failed: %X\n", status );
                fileAllocation.QuadPart =
                        fileAllocation.QuadPart - fileAllocationIncrement.QuadPart;
            }
        }
    }

    return;

} // MemPrintWriteThread


VOID
MemPrintWriteCompleteApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )

/*++

Routine Description:

    This APC routine is called when subbuffer writes to disk complete.
    It checks for success, printing a message if the write failed.
    It also sets the appropriate MemPrintSubbufferWriting location to
    FALSE so that the subbuffer can be reused.

Arguments:

    ApcContext - contains the index of the subbuffer just written.

    IoStatusBlock - the status block for the operation.

    Reserved - not used; reserved for future use.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    if ( !NT_SUCCESS(IoStatusBlock->Status) ) {
        DbgPrint( "NtWriteFile for subbuffer %ld failed: %X\n",
                      ApcContext, IoStatusBlock->Status );
        return;
    }

    //DbgPrint( "Write complete for subbuffer %ld.\n", ApcContext );
    DbgPrint( "." );

    //
    // Acquire the spin lock that protects memory print global variables
    // and set the subbuffer writing boolean to FALSE so that other
    // threads can write to the subbuffer if necessary.
    //

    KeAcquireSpinLock( &MemPrintSpinLock, &oldIrql );
    MemPrintSubbufferWriting[ (ULONG_PTR)ApcContext ] = FALSE;
    KeReleaseSpinLock( &MemPrintSpinLock, oldIrql );

    return;

    Reserved;

} // MemPrintWriteCompleteApc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\nbqueue.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    nbqueue.c

Abstract:

   This module implements non-blocking fifo queue.

Author:

    David N. Cutler (davec) 24-Apr-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

//
// Define queue pointer structure - this is platform target specific.
//

#if defined(_AMD64_)

typedef union _NBQUEUE_POINTER {
    struct {
        LONG64 Node : 48;
        LONG64 Count : 16;
    };

    LONG64 Data;
} NBQUEUE_POINTER, *PNBQUEUE_POINTER;

#elif defined(_X86_)

typedef union _NBQUEUE_POINTER {
    struct {
        LONG Count;
        LONG Node;
    };

    LONG64 Data;
} NBQUEUE_POINTER, *PNBQUEUE_POINTER;

#elif defined(_IA64_)

typedef union _NBQUEUE_POINTER {
    struct {
        LONG64 Node : 45;
        LONG64 Region : 3;
        LONG64 Count : 16;
    };

    LONG64 Data;
} NBQUEUE_POINTER, *PNBQUEUE_POINTER;


#else

#error "no target architecture"

#endif

//
// Define queue node struture.
//

typedef struct _NBQUEUE_NODE {
    NBQUEUE_POINTER Next;
    ULONG64 Value;
} NBQUEUE_NODE, *PNBQUEUE_NODE;

//
// Define inline functions to pack and unpack pointers in the platform
// specific non-blocking queue pointer structure.
//

#if defined(_AMD64_)

__inline
VOID
PackNBQPointer (
    IN PNBQUEUE_POINTER Entry,
    IN PNBQUEUE_NODE Node
    )

{

    Entry->Node = (LONG64)Node;
    return;
}

__inline
PNBQUEUE_NODE
UnpackNBQPointer (
    IN PNBQUEUE_POINTER Entry
    )

{
    return (PVOID)((LONG64)(Entry->Node));
}

#elif defined(_X86_)

__inline
VOID
PackNBQPointer (
    IN PNBQUEUE_POINTER Entry,
    IN PNBQUEUE_NODE Node
    )

{

    Entry->Node = (LONG)Node;
    return;
}

__inline
PNBQUEUE_NODE
UnpackNBQPointer (
    IN PNBQUEUE_POINTER Entry
    )

{
    return (PVOID)(Entry->Node);
}

#elif defined(_IA64_)

__inline
VOID
PackNBQPointer (
    IN PNBQUEUE_POINTER Entry,
    IN PNBQUEUE_NODE Node
    )

{

    Entry->Node = (LONG64)Node;
    Entry->Region = (LONG64)Node >> 61;
    return;
}

__inline
PNBQUEUE_NODE
UnpackNBQPointer (
    IN PNBQUEUE_POINTER Entry
    )

{

    LONG64 Value;

    Value = Entry->Node & 0x1fffffffffffffff;
    Value |= Entry->Region << 61;
    return (PVOID)(Value);
}

#else

#error "no target architecture"

#endif

//
// Define queue descriptor structure.
//

typedef struct _NBQUEUE_HEADER {
    NBQUEUE_POINTER Head;
    NBQUEUE_POINTER Tail;
    PSLIST_HEADER SlistHead;
} NBQUEUE_HEADER, *PNBQUEUE_HEADER;

#pragma alloc_text(PAGE, ExInitializeNBQueueHead)

PVOID
ExInitializeNBQueueHead (
    IN PSLIST_HEADER SlistHead
    )

/*++

Routine Description:

    This function initializes a non-blocking queue header.

    N.B. It is assumed that the specified SLIST has been populated with
         non-blocking queue nodes prior to calling this routine.

Arguments:

    SlistHead - Supplies a pointer to an SLIST header.

Return Value:

    If the non-blocking queue is successfully initialized, then the
    address of the queue header is returned as the function value.
    Otherwise, NULL is returned as the function value.

--*/

{

    PNBQUEUE_HEADER QueueHead;
    PNBQUEUE_NODE QueueNode;

    //
    // Attempt to allocate the queue header. If the allocation fails, then
    // return NULL.
    //

    QueueHead = (PNBQUEUE_HEADER)ExAllocatePoolWithTag(NonPagedPool,
                                                       sizeof(NBQUEUE_HEADER),
                                                       'hqBN');

    if (QueueHead == NULL) {
        return NULL;
    }

    //
    // Attempt to allocate a queue node from the specified SLIST. If a node
    // can be allocated, then initialize the non-blocking queue header and
    // return the address of the queue header. Otherwise, free the queue
    // header and return NULL.
    //

    QueueHead->SlistHead = SlistHead;
    QueueNode = (PNBQUEUE_NODE)InterlockedPopEntrySList(QueueHead->SlistHead);

    if (QueueNode != NULL) {

        //
        // Initialize the queue node next pointer and value.
        //

        QueueNode->Next.Data = 0;
        QueueNode->Value = 0;

        //
        // Initialize the head and tail pointers in the queue header.
        //

        PackNBQPointer(&QueueHead->Head, QueueNode);
        QueueHead->Head.Count = 0;
        PackNBQPointer(&QueueHead->Tail, QueueNode);
        QueueHead->Tail.Count = 0;
        return QueueHead;

    } else {
        ExFreePool(QueueHead);
        return NULL;
    }
}

BOOLEAN
ExInsertTailNBQueue (
    IN PVOID Header,
    IN ULONG64 Value
    )

/*++

Routine Description:

    This function inserts the specific data value at the tail of the
    specified non-blocking queue.

Arguments:

    Header - Supplies an opaque pointer to a non-blocking queue header.

    Value - Supplies a pointer to an opaque data value.

Return Value:

    If the specified opaque data value is successfully inserted at the tail
    of the specified non-blocking queue, then a value of TRUE is returned as
    the function value. Otherwise, a value of FALSE is returned.

    N.B. FALSE is returned if a queue node cannot be allocated from the
         associated SLIST.

--*/

{

    NBQUEUE_POINTER Insert;
    NBQUEUE_POINTER Next;
    PNBQUEUE_NODE NextNode;
    PNBQUEUE_HEADER QueueHead;
    PNBQUEUE_NODE QueueNode;
    NBQUEUE_POINTER Tail;
    PNBQUEUE_NODE TailNode;

    //
    // Attempt to allocate a queue node from the SLIST associated with
    // the specified non-blocking queue. If a node can be allocated, then
    // the node is inserted at the tail of the specified non-blocking
    // queue, and TRUE is returned as the function value. Otherwise, FALSE
    // is returned.
    //

    QueueHead = (PNBQUEUE_HEADER)Header;
    QueueNode = (PNBQUEUE_NODE)InterlockedPopEntrySList(QueueHead->SlistHead);

    if (QueueNode != NULL) {

        //
        //  Initialize the queue node next pointer and value.
        //

        QueueNode->Next.Data = 0;
        QueueNode->Value = Value;

        //
        // The following loop is executed until the specified entry can
        // be safely inserted at the tail of the specified non-blocking
        // queue.
        //

        do {

            //
            // Read the tail queue pointer and the next queue pointer of
            // the tail queue pointer making sure the two pointers are
            // coherent.
            //

            Tail.Data = *((volatile LONG64 *)(&QueueHead->Tail.Data));
            TailNode = UnpackNBQPointer(&Tail);
            Next.Data = *((volatile LONG64 *)(&TailNode->Next.Data));
            QueueNode->Next.Count = Tail.Count + 1;
            if (Tail.Data == *((volatile LONG64 *)(&QueueHead->Tail.Data))) {

                //
                // If the tail is pointing to the last node in the list,
                // then attempt to insert the new node at the end of the
                // list. Otherwise, the tail is not pointing to the last
                // node in the list and an attempt is made to move the
                // tail pointer to the next node.
                //

                NextNode = UnpackNBQPointer(&Next);
                if (NextNode == NULL) {
                    PackNBQPointer(&Insert, QueueNode);
                    Insert.Count = Next.Count + 1;
                    if (InterlockedCompareExchange64(&TailNode->Next.Data,
                                                     Insert.Data,
                                                     Next.Data) == Next.Data) {
                        break;
                    }

                } else {
                    PackNBQPointer(&Insert, NextNode);
                    Insert.Count = Tail.Count + 1;
                    InterlockedCompareExchange64(&QueueHead->Tail.Data,
                                                 Insert.Data,
                                                 Tail.Data);
                }
            }

        } while (TRUE);

        //
        // Attempt to move the tail to the new tail node.
        //

        PackNBQPointer(&Insert, QueueNode);
        Insert.Count = Tail.Count + 1;
        InterlockedCompareExchange64(&QueueHead->Tail.Data,
                                     Insert.Data,
                                     Tail.Data);

        return TRUE;

    } else {
        return FALSE;
    }
}

BOOLEAN
ExRemoveHeadNBQueue (
    IN PVOID Header,
    OUT PULONG64 Value
    )

/*++

Routine Description:

    This function removes a queue entry from the head of the specified
    non-blocking queue and returns the associated data value.

Arguments:

    Header - Supplies an opaque pointer to a non-blocking queue header.

    Value - Supplies a pointer to a variable that receives the queue
        element value.

Return Value:

    If an entry is removed from the specified non-blocking queue, then
    TRUE is returned as the function value. Otherwise, FALSE is returned.

--*/

{

    NBQUEUE_POINTER Head;
    PNBQUEUE_NODE HeadNode;
    NBQUEUE_POINTER Insert;
    NBQUEUE_POINTER Next;
    PNBQUEUE_NODE NextNode;
    PNBQUEUE_HEADER QueueHead;
    NBQUEUE_POINTER Tail;
    PNBQUEUE_NODE TailNode;

    //
    // The following loop is executed until an entry can be removed from
    // the specified non-blocking queue or until it can be determined that
    // the queue is empty.
    //

    QueueHead = (PNBQUEUE_HEADER)Header;
    do {

        //
        // Read the head queue pointer, the tail queue pointer, and the
        // next queue pointer of the head queue pointer making sure the
        // three pointers are coherent.
        //

        Head.Data = *((volatile LONG64 *)(&QueueHead->Head.Data));
        Tail.Data = *((volatile LONG64 *)(&QueueHead->Tail.Data));
        HeadNode = UnpackNBQPointer(&Head);
        Next.Data = *((volatile LONG64 *)(&HeadNode->Next.Data));
        if (Head.Data == *((volatile LONG64 *)(&QueueHead->Head.Data))) {

            //
            // If the queue header node is equal to the queue tail node,
            // then either the queue is empty or the tail pointer is falling
            // behind. Otherwise, there is an entry in the queue that can
            // be removed.
            //

            NextNode = UnpackNBQPointer(&Next);
            TailNode = UnpackNBQPointer(&Tail);
            if (HeadNode == TailNode) {

                //
                // If the next node of head pointer is NULL, then the queue
                // is empty. Otherwise, attempt to move the tail forward.
                //

                if (NextNode == NULL) {
                    return FALSE;

                } else {
                    PackNBQPointer(&Insert, NextNode);
                    Insert.Count = Tail.Count + 1;
                    InterlockedCompareExchange64(&QueueHead->Tail.Data,
                                                 Insert.Data,
                                                 Tail.Data);
                }

            } else {

                //
                // There is an entry in the queue that can be removed.
                //

                *Value = NextNode->Value;
                PackNBQPointer(&Insert, NextNode);
                Insert.Count = Head.Count + 1;
                if (InterlockedCompareExchange64(&QueueHead->Head.Data,
                                                 Insert.Data,
                                                 Head.Data) == Head.Data) {

                    break;
                }
            }
        }

    } while (TRUE);

    //
    // Free the node that was removed for the list by inserting the node
    // in the associated SLIST.
    //

    InterlockedPushEntrySList(QueueHead->SlistHead,
                              (PSINGLE_LIST_ENTRY)HeadNode);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\pushlock.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pushlock.c

Abstract:

    This module houses routines that do push locking.

    Push locks are capable of being acquired in both shared and exclusive mode.

    Properties include:

    They can not be acquired recursively.
    They are small (the size of a pointer) and can be used when embeded in pagable data.
    Acquire and release is done lock free. On lock contention the waiters are chained
    through the lock and local stack space.

    This is the structure of a push lock:

    
    E  == Exclusive bit
    W  == Waiters present
    SC == Share count
    P  == Pointer to wait block
    +----------+---+---+
    |    SC    | E | W | E, W are single bits W == 0
    +----------+---+---+

    +--------------+---+
    |      P       | W | W == 1. Pointer is the address of a chain of stack local wait blocks
    +--------------+---+

    The non-contented acquires and releases are trivial. Interlocked operations make the following
    transformations.

    (SC=0,E=0,W=0) === Exclusive acquire ===> (SC=0,E=1,W=0)
    (SC=n,E=0,W=0) === Shared acquire    ===> (SC=n+1,E=0,W=0)

    (SC=0,E=1,W=0) === Exclusive release ===> (SC=0,E=0,W=0)
    (SC=n,E=0,W=0) === Shared release    ===> (SC=n-1,E=0,W=0) n > 0

    Contention causes the acquiring thread to produce a local stack based wait block and to
    enqueue it to the front of the list.

    (SC=n,E=e,W=0) === Exclusive acquire ===> (P=LWB(SSC=n,E=e),W=1) LWB = local wait block,
                                                                     SSC = Saved share count,
                                                                     n > 0 or e == 1.

    (SC=0,E=1,W=0) === Shared acquire    ===> (P=LWB(SSC=0,E=0),W=1) LWB = local wait block,
                                                                     SSC = Saved share count.

    After contention has causes one or more threads to queue up wait blocks releases are more
    complicated. This following rights are granted to a releasing thread (shared or exclusive).

    1) Shared release threads are allowed to search the wait list until they hit a wait block
       with a non-zero share count (this will be a wait block marked exclusive). This thread is
       allowed to use an interlocked operation to decrement this value. If this thread
       transitioned the value to zero then it obtains the rights of an exclusive release thread

    2) Exclusive threads are allowed to search the wait list until they find a continuous chain
       of shared wait blocks or they find the last wait block is an exclusive waiter. This thread
       may then break the chain at this point or update the header to show a single exclusive
       owner or multiple shared owners. Breaking the list can be done with normal assignment
       but updating the header requires interlocked exchange compare.


Author:

    Neill Clift (NeillC) 30-Sep-2000


Revision History:

--*/

#include "exp.h"

#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ExBlockPushLock)
#pragma alloc_text(PAGE, ExfAcquirePushLockExclusive)
#pragma alloc_text(PAGE, ExfAcquirePushLockShared)
#pragma alloc_text(PAGE, ExfReleasePushLock)
#pragma alloc_text(PAGE, ExfUnblockPushLock)
#pragma alloc_text(PAGE, ExAllocateCacheAwarePushLock)
#pragma alloc_text(PAGE, ExFreeCacheAwarePushLock)
#pragma alloc_text(PAGE, ExAcquireCacheAwarePushLockExclusive)
#pragma alloc_text(PAGE, ExReleaseCacheAwarePushLockExclusive)
#endif


NTKERNELAPI
VOID
FASTCALL
ExfAcquirePushLockExclusive (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Acquire a push lock exclusively

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;
    EX_PUSH_LOCK_WAIT_BLOCK WaitBlock;

    OldValue = *PushLock;
    while (1) {
        //
        // If the lock is already held exclusively/shared or there are waiters then
        // we need to wait.
        //
        if (OldValue.Value == 0) {
            NewValue.Value = OldValue.Value + EX_PUSH_LOCK_EXCLUSIVE;
            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                              NewValue.Ptr,
                                                              OldValue.Ptr);
            if (NewValue.Ptr == OldValue.Ptr) {
                break;
            }
        } else {
            KeInitializeEvent (&WaitBlock.WakeEvent, SynchronizationEvent, FALSE);
            WaitBlock.Exclusive = TRUE;
            //
            // Move the sharecount to our wait block if need be.
            //
            if (OldValue.Waiting) {
                WaitBlock.Next = (PEX_PUSH_LOCK_WAIT_BLOCK)
                                     (OldValue.Value - EX_PUSH_LOCK_WAITING);
                WaitBlock.ShareCount = 0;
            } else {
                WaitBlock.Next = NULL;
                WaitBlock.ShareCount = (ULONG) OldValue.Shared;
            }
            NewValue.Ptr = ((PUCHAR) &WaitBlock) + EX_PUSH_LOCK_WAITING;
            ASSERT ((NewValue.Value & EX_PUSH_LOCK_WAITING) != 0);
            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                              NewValue.Ptr,
                                                              OldValue.Ptr);
            if (NewValue.Ptr == OldValue.Ptr) {
                KeWaitForSingleObject (&WaitBlock.WakeEvent,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
                ASSERT ((WaitBlock.ShareCount == 0) && (WaitBlock.Next == NULL));
                break;
            }

        }
        OldValue = NewValue;
    }
}

NTKERNELAPI
VOID
FASTCALL
ExfAcquirePushLockShared (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Acquire a push lock shared

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;
    EX_PUSH_LOCK_WAIT_BLOCK WaitBlock;

    OldValue = *PushLock;
    while (1) {
        //
        // If the lock is already held exclusively or there are waiters then we need to wait
        //
        if (OldValue.Exclusive || OldValue.Waiting) {
            KeInitializeEvent (&WaitBlock.WakeEvent, SynchronizationEvent, FALSE);
            WaitBlock.Exclusive = 0;
            WaitBlock.ShareCount = 0;
            //
            // Chain the next block to us if there is one.
            //
            if (OldValue.Waiting) {
                WaitBlock.Next = (PEX_PUSH_LOCK_WAIT_BLOCK)
                                     (OldValue.Value - EX_PUSH_LOCK_WAITING);
            } else {
                WaitBlock.Next = NULL;
            }
            NewValue.Ptr = ((PUCHAR) &WaitBlock) + EX_PUSH_LOCK_WAITING;
            ASSERT ((NewValue.Value & EX_PUSH_LOCK_WAITING) != 0);
            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                              NewValue.Ptr,
                                                              OldValue.Ptr);
            if (NewValue.Ptr == OldValue.Ptr) {
                KeWaitForSingleObject (&WaitBlock.WakeEvent,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);

                ASSERT (WaitBlock.ShareCount == 0);
                break;
            }

        } else {
            //
            // We only have shared accessors at the moment. We can just update the lock to include this thread.
            //
            NewValue.Value = OldValue.Value + EX_PUSH_LOCK_SHARE_INC;
            ASSERT (!(NewValue.Waiting || NewValue.Exclusive));
            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                              NewValue.Ptr,
                                                              OldValue.Ptr);
            if (NewValue.Ptr == OldValue.Ptr) {
                break;
            }
        }
        OldValue = NewValue;
    }
}

NTKERNELAPI
VOID
FASTCALL
ExfReleasePushLock (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Release a push lock that was acquired exclusively or shared

Arguments:

    PushLock - Push lock to be released

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;
    PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock, NextWaitBlock, ReleaseWaitList, Previous;
    ULONG ShareCount;

    OldValue = *PushLock;
    while (1) {
        if (!OldValue.Waiting) {
            //
            // Either we hold the lock exclusive or shared but not both.
            //
            ASSERT (OldValue.Exclusive ^ (OldValue.Shared > 0));

            //
            // We must hold the lock exclusive or shared. We make the assuption that
            // the exclusive bit is just below the share count here.
            //
            NewValue.Value = (OldValue.Value - EX_PUSH_LOCK_EXCLUSIVE) &
                             ~EX_PUSH_LOCK_EXCLUSIVE;
            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                              NewValue.Ptr,
                                                              OldValue.Ptr);
            if (NewValue.Ptr == OldValue.Ptr) {
                break;
            }
            //
            // Either we gained a new waiter or another shared owner arrived or left
            //
            ASSERT (NewValue.Waiting || (NewValue.Shared > 0 && !NewValue.Exclusive));
            OldValue = NewValue;
        } else {
            //
            // There are waiters chained to the lock. We have to release the share count,
            // last exclusive or last chain of shared waiters.
            //
            WaitBlock = (PEX_PUSH_LOCK_WAIT_BLOCK) 
                           (OldValue.Value - EX_PUSH_LOCK_WAITING);

            ReleaseWaitList = WaitBlock;
            Previous = NULL;
            ShareCount = 0;
            do {
                if (WaitBlock->Exclusive) {
                    //
                    // This is an exclusive waiter. If this was the first exclusive waited to a shared acquire
                    // then it will have the saved share count. If we acquired the lock shared then the count
                    // must contain a bias for this thread. Release that and if we are not the last shared
                    // accessor then exit. A later shared release thread will wake the exclusive
                    // waiter.
                    //
                    if (WaitBlock->ShareCount != 0) {
                        if (InterlockedDecrement ((PLONG)&WaitBlock->ShareCount) != 0) {
                            return;
                        }
                    }
                    //
                    // Reset count of share acquires waiting.
                    //
                    ShareCount = 0;
                } else {
                    //
                    // This is a shared waiter. Record the number of these to update the head or the
                    // previous exclusive waiter.
                    //
                    ShareCount++;
                }
                NextWaitBlock = WaitBlock->Next;
                if (NextWaitBlock != NULL) {
                    if (NextWaitBlock->Exclusive) {
                        //
                        // The next block is exclusive. This may be the entry to free.
                        //
                        Previous = WaitBlock;
                        ReleaseWaitList = NextWaitBlock;
                    } else {
                        //
                        // The next block is shared. If the chain start is exclusive then skip to this one
                        // as the exclusive isn't the thread we will wake up.
                        //
                        if (ReleaseWaitList->Exclusive) {
                            Previous = WaitBlock;
                            ReleaseWaitList = NextWaitBlock;
                        }
                    }
                }

                WaitBlock = NextWaitBlock;
            } while (WaitBlock != NULL);

            //
            // If our release chain is everything then we have to update the header
            //
            if (Previous == NULL) {
                NewValue.Value = 0;
                NewValue.Exclusive = ReleaseWaitList->Exclusive;
                NewValue.Shared = ShareCount;
                ASSERT (((ShareCount > 0) ^ (ReleaseWaitList->Exclusive)) && !NewValue.Waiting);

                NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                                  NewValue.Ptr,
                                                                  OldValue.Ptr);
                if (NewValue.Ptr != OldValue.Ptr) {
                    //
                    // We are releasing so we could have only gained another waiter
                    //
                    ASSERT (NewValue.Waiting);
                    OldValue = NewValue;
                    continue;
                }
            } else {
                //
                // Truncate the chain at this position and save the share count for all the shared owners to
                // decrement later.
                //
                Previous->Next = NULL;
                ASSERT (Previous->ShareCount == 0);
                Previous->ShareCount = ShareCount;
                //
                // We are either releasing multiple share accessors or a single exclusive
                //
                ASSERT ((ShareCount > 0) ^ ReleaseWaitList->Exclusive);
            }
            //
            // Release the chain of threads we located.
            //
            do {
                NextWaitBlock = ReleaseWaitList->Next;
                //
                // All the chain should have the same type (Exclusive/Shared).
                //
                ASSERT (NextWaitBlock == NULL || (ReleaseWaitList->Exclusive == NextWaitBlock->Exclusive));
                ASSERT (!ReleaseWaitList->Exclusive || (ReleaseWaitList->ShareCount == 0));
                KeSetEventBoostPriority (&ReleaseWaitList->WakeEvent, NULL);
                ReleaseWaitList = NextWaitBlock;
            } while (ReleaseWaitList != NULL);
            break;
        }
    }
}

NTKERNELAPI
VOID
FASTCALL
ExBlockPushLock (
     IN PEX_PUSH_LOCK PushLock,
     IN PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock
     )
/*++

Routine Description:

    Block on a push lock

Arguments:

    PushLock  - Push lock to block on
    WaitBlock - Wait block to queue for waiting

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;

    //
    // Push the wait block on the list. 
    //
    KeInitializeEvent (&WaitBlock->WakeEvent, SynchronizationEvent, FALSE);

    OldValue = *PushLock;
    while (1) {
        //
        // Chain the next block to us if there is one.
        //
        WaitBlock->Next = OldValue.Ptr;
        NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                          WaitBlock,
                                                          OldValue.Ptr);
        if (NewValue.Ptr == OldValue.Ptr) {
            return;
        }
        OldValue = NewValue;
    }
}

NTKERNELAPI
VOID
FASTCALL
ExfUnblockPushLock (
     IN PEX_PUSH_LOCK PushLock,
     IN PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock OPTIONAL
     )
/*++

Routine Description:

    Unblock on a push lock

Arguments:

    PushLock  - Push lock to block on
    WaitBlock - Wait block previously queued for waiting or NULL if there wasn't one

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue;
    PEX_PUSH_LOCK_WAIT_BLOCK tWaitBlock;
    BOOLEAN FoundOurBlock=FALSE;

    //
    // Pop the entire chain and wake them all up.
    //
    OldValue.Ptr = InterlockedExchangePointer (&PushLock->Ptr,
                                               NULL);
    while (OldValue.Ptr != NULL) {
        tWaitBlock = OldValue.Ptr;
        OldValue.Ptr = tWaitBlock->Next;
        if (tWaitBlock == WaitBlock) {
            FoundOurBlock = TRUE;
        } else{
            KeSetEvent (&tWaitBlock->WakeEvent, 0, FALSE);
        }
    }
    if (WaitBlock != NULL && !FoundOurBlock) {
        KeWaitForSingleObject (&WaitBlock->WakeEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);
    }
}

NTKERNELAPI
PEX_PUSH_LOCK_CACHE_AWARE
ExAllocateCacheAwarePushLock (
     VOID
     )
/*++

Routine Description:

    Allocate a cache aware (cache friendly) push lock

Arguments:

    None

Return Value:

    None

--*/
{
    PEX_PUSH_LOCK_CACHE_AWARE PushLockCacheAware;
    PEX_PUSH_LOCK_CACHE_AWARE_PADDED PaddedPushLock;
    ULONG i, j;

    PushLockCacheAware = ExAllocatePoolWithTag (PagedPool,
                                                sizeof (EX_PUSH_LOCK_CACHE_AWARE),
                                                'pclP');
    if (PushLockCacheAware != NULL) {
        //
        // If we are a non-numa machine then allocate the padded push locks as a single block
        //
        if (KeNumberNodes == 1) {
            PaddedPushLock = ExAllocatePoolWithTag (PagedPool,
                                                    sizeof (EX_PUSH_LOCK_CACHE_AWARE_PADDED)*
                                                       EX_PUSH_LOCK_FANNED_COUNT,
                                                    'lclP');
            if (PaddedPushLock == NULL) {
                ExFreePool (PushLockCacheAware);
                return NULL;
            }
            for (i = 0; i < EX_PUSH_LOCK_FANNED_COUNT; i++) {
                PaddedPushLock->Single = TRUE;
                ExInitializePushLock (&PaddedPushLock->Lock);
                PushLockCacheAware->Locks[i] = &PaddedPushLock->Lock;
                PaddedPushLock++;
            }
        } else {
            //
            // Allocate a different block for each lock and set affinity
            // so the allocation comes from that nodes memory.
            //
            for (i = 0; i < EX_PUSH_LOCK_FANNED_COUNT; i++) {
                KeSetSystemAffinityThread(AFFINITY_MASK(i % KeNumberProcessors));
                PaddedPushLock = ExAllocatePoolWithTag (PagedPool,
                                                        sizeof (EX_PUSH_LOCK_CACHE_AWARE_PADDED),
                                                        'lclP');
                if (PaddedPushLock == NULL) {
                    for (j = 0; j < i; j++) {
                        ExFreePool (PushLockCacheAware->Locks[j]);
                    }
                    KeRevertToUserAffinityThread ();

                    ExFreePool (PushLockCacheAware);
                    return NULL;
                }
                PaddedPushLock->Single = FALSE;
                ExInitializePushLock (&PaddedPushLock->Lock);
                PushLockCacheAware->Locks[i] = &PaddedPushLock->Lock;
            }
            KeRevertToUserAffinityThread ();
        }
        
    }
    return PushLockCacheAware;
}

NTKERNELAPI
VOID
ExFreeCacheAwarePushLock (
     PEX_PUSH_LOCK_CACHE_AWARE PushLock     
     )
/*++

Routine Description:

    Frees a cache aware (cache friendly) push lock

Arguments:

    PushLock - Cache aware push lock to be freed

Return Value:

    None

--*/
{
    ULONG i;

    if (!CONTAINING_RECORD (PushLock->Locks[0], EX_PUSH_LOCK_CACHE_AWARE_PADDED, Lock)->Single) {
        for (i = 0; i < EX_PUSH_LOCK_FANNED_COUNT; i++) {
            ExFreePool (PushLock->Locks[i]);
        }
    } else {
        ExFreePool (PushLock->Locks[0]);
    }
    ExFreePool (PushLock);
}


NTKERNELAPI
VOID
ExAcquireCacheAwarePushLockExclusive (
     IN PEX_PUSH_LOCK_CACHE_AWARE PushLock
     )
/*++

Routine Description:

    Acquire a cache aware push lock exclusive.

Arguments:

    PushLock - Cache aware push lock to be acquired

Return Value:

    None

--*/
{
    PEX_PUSH_LOCK *Start, *End;

    //
    // Exclusive acquires must obtain all the slots exclusive.
    // Take the first slot exclusive and then we can take the
    // rest of the slots in any order we want.
    // There is no deadlock here. A->B->C does not deadlock with A->C->B.
    //
    Start = &PushLock->Locks[1];
    End   = &PushLock->Locks[EX_PUSH_LOCK_FANNED_COUNT - 1];

    ExAcquirePushLockExclusive (PushLock->Locks[0]);

    while (Start <= End) {
        if (ExTryAcquirePushLockExclusive (*Start)) {
            Start++;
        } else {
            ExAcquirePushLockExclusive (*End);
            End--;
        }
    }
}

NTKERNELAPI
VOID
ExReleaseCacheAwarePushLockExclusive (
     IN PEX_PUSH_LOCK_CACHE_AWARE PushLock
     )
/*++

Routine Description:

    Release a cache aware push lock exclusive.

Arguments:

    PushLock - Cache aware push lock to be released

Return Value:

    None

--*/
{
    PEX_PUSH_LOCK *Start, *End;
    //
    // Release the locks in order
    //
    End   = &PushLock->Locks[EX_PUSH_LOCK_FANNED_COUNT];
    for (Start = &PushLock->Locks[0];
         Start < End;
         Start++) {
        ExReleasePushLockExclusive (*Start);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\pool.c ===
/*++

Copyright (c) 1989-1994  Microsoft Corporation

Module Name:

    pool.c

Abstract:

    This module implements the NT executive pool allocator.

Author:

    Mark Lucovsky     16-Feb-1989
    Lou Perazzoli     31-Aug-1991 (change from binary buddy)
    David N. Cutler (davec) 27-May-1994
    Landy Wang        17-Oct-1997

Environment:

    Kernel mode only

Revision History:

--*/

#include "exp.h"

#pragma hdrstop

#undef ExAllocatePoolWithTag
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#undef ExAllocatePoolWithQuotaTag
#undef ExFreePool
#undef ExFreePoolWithTag

#if defined (_WIN64)
#define POOL_QUOTA_ENABLED (TRUE)
#else
#define POOL_QUOTA_ENABLED (PoolTrackTable == NULL)
#endif

//
// These bitfield definitions are based on EX_POOL_PRIORITY in inc\ex.h.
//

#define POOL_SPECIAL_POOL_BIT               0x8
#define POOL_SPECIAL_POOL_UNDERRUN_BIT      0x1


//
// We redefine the LIST_ENTRY macros to have each pointer biased
// by one so any rogue code using these pointers will access
// violate.  See \nt\public\sdk\inc\ntrtl.h for the original
// definition of these macros.
//
// This is turned off in the shipping product.
//

#ifndef NO_POOL_CHECKS

#define DecodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link) & ~1))
#define EncodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link) |  1))

#define PrivateInitializeListHead(ListHead) (                     \
    (ListHead)->Flink = (ListHead)->Blink = EncodeLink(ListHead))

#define PrivateIsListEmpty(ListHead)              \
    (DecodeLink((ListHead)->Flink) == (ListHead))

#define PrivateRemoveHeadList(ListHead)                     \
    DecodeLink((ListHead)->Flink);                          \
    {PrivateRemoveEntryList(DecodeLink((ListHead)->Flink))}

#define PrivateRemoveTailList(ListHead)                     \
    DecodeLink((ListHead)->Blink);                          \
    {PrivateRemoveEntryList(DecodeLink((ListHead)->Blink))}

#define PrivateRemoveEntryList(Entry) {       \
    PLIST_ENTRY _EX_Blink;                    \
    PLIST_ENTRY _EX_Flink;                    \
    _EX_Flink = DecodeLink((Entry)->Flink);   \
    _EX_Blink = DecodeLink((Entry)->Blink);   \
    _EX_Blink->Flink = EncodeLink(_EX_Flink); \
    _EX_Flink->Blink = EncodeLink(_EX_Blink); \
    }

#define CHECK_LIST(LIST)                                                    \
    if ((DecodeLink(DecodeLink((LIST)->Flink)->Blink) != (LIST)) ||         \
        (DecodeLink(DecodeLink((LIST)->Blink)->Flink) != (LIST))) {         \
            KeBugCheckEx (BAD_POOL_HEADER,                                  \
                          3,                                                \
                          (ULONG_PTR)LIST,                                  \
                          (ULONG_PTR)DecodeLink(DecodeLink((LIST)->Flink)->Blink),     \
                          (ULONG_PTR)DecodeLink(DecodeLink((LIST)->Blink)->Flink));    \
    }

#define PrivateInsertTailList(ListHead,Entry) {  \
    PLIST_ENTRY _EX_Blink;                       \
    PLIST_ENTRY _EX_ListHead;                    \
    _EX_ListHead = (ListHead);                   \
    CHECK_LIST(_EX_ListHead);                    \
    _EX_Blink = DecodeLink(_EX_ListHead->Blink); \
    (Entry)->Flink = EncodeLink(_EX_ListHead);   \
    (Entry)->Blink = EncodeLink(_EX_Blink);      \
    _EX_Blink->Flink = EncodeLink(Entry);        \
    _EX_ListHead->Blink = EncodeLink(Entry);     \
    CHECK_LIST(_EX_ListHead);                    \
    }

#define PrivateInsertHeadList(ListHead,Entry) {  \
    PLIST_ENTRY _EX_Flink;                       \
    PLIST_ENTRY _EX_ListHead;                    \
    _EX_ListHead = (ListHead);                   \
    CHECK_LIST(_EX_ListHead);                    \
    _EX_Flink = DecodeLink(_EX_ListHead->Flink); \
    (Entry)->Flink = EncodeLink(_EX_Flink);      \
    (Entry)->Blink = EncodeLink(_EX_ListHead);   \
    _EX_Flink->Blink = EncodeLink(Entry);        \
    _EX_ListHead->Flink = EncodeLink(Entry);     \
    CHECK_LIST(_EX_ListHead);                    \
    }

#define CHECK_POOL_HEADER(LINE,ENTRY) {                                                 \
    PPOOL_HEADER PreviousEntry;                                                         \
    PPOOL_HEADER NextEntry;                                                             \
    if ((ENTRY)->PreviousSize != 0) {                                                   \
        PreviousEntry = (PPOOL_HEADER)((PPOOL_BLOCK)(ENTRY) - (ENTRY)->PreviousSize);   \
        if ((PreviousEntry->BlockSize != (ENTRY)->PreviousSize) ||                      \
            (DECODE_POOL_INDEX(PreviousEntry) != DECODE_POOL_INDEX(ENTRY))) {           \
            KeBugCheckEx(BAD_POOL_HEADER, 5, (ULONG_PTR)PreviousEntry, LINE, (ULONG_PTR)ENTRY); \
        }                                                                               \
    }                                                                                   \
    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)(ENTRY) + (ENTRY)->BlockSize);              \
    if (!PAGE_END(NextEntry)) {                                                         \
        if ((NextEntry->PreviousSize != (ENTRY)->BlockSize) ||                          \
            (DECODE_POOL_INDEX(NextEntry) != DECODE_POOL_INDEX(ENTRY))) {               \
            KeBugCheckEx(BAD_POOL_HEADER, 5, (ULONG_PTR)NextEntry, LINE, (ULONG_PTR)ENTRY);     \
        }                                                                               \
    }                                                                                   \
}

#define ASSERT_ALLOCATE_IRQL(_PoolType, _NumberOfBytes)                 \
    if ((_PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {               \
        if (KeGetCurrentIrql() > APC_LEVEL) {                           \
            KeBugCheckEx (BAD_POOL_CALLER, 8, KeGetCurrentIrql(), _PoolType, _NumberOfBytes);                                                           \
        }                                                               \
    }                                                                   \
    else {                                                              \
        if (KeGetCurrentIrql() > DISPATCH_LEVEL) {                      \
            KeBugCheckEx (BAD_POOL_CALLER, 8, KeGetCurrentIrql(), _PoolType, _NumberOfBytes);                                                           \
        }                                                               \
    }

#define ASSERT_FREE_IRQL(_PoolType, _P)                                 \
    if ((_PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {               \
        if (KeGetCurrentIrql() > APC_LEVEL) {                           \
            KeBugCheckEx (BAD_POOL_CALLER, 9, KeGetCurrentIrql(), _PoolType, (ULONG_PTR)_P);                                                            \
        }                                                               \
    }                                                                   \
    else {                                                              \
        if (KeGetCurrentIrql() > DISPATCH_LEVEL) {                      \
            KeBugCheckEx (BAD_POOL_CALLER, 9, KeGetCurrentIrql(), _PoolType, (ULONG_PTR)P);                                                             \
        }                                                               \
    }

#define ASSERT_POOL_NOT_FREE(_Entry)                                    \
    if ((_Entry->PoolType & POOL_TYPE_MASK) == 0) {                     \
        KeBugCheckEx (BAD_POOL_CALLER, 6, __LINE__, (ULONG_PTR)_Entry, _Entry->Ulong1);                                                                 \
    }

#define ASSERT_POOL_TYPE_NOT_ZERO(_Entry)                               \
    if (_Entry->PoolType == 0) {                                        \
        KeBugCheckEx(BAD_POOL_CALLER, 1, (ULONG_PTR)_Entry, (ULONG_PTR)(*(PULONG)_Entry), 0);                                                           \
    }

#define CHECK_LOOKASIDE_LIST(LINE,LIST,ENTRY) {NOTHING;}

#else

#define DecodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link)))
#define EncodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link)))
#define PrivateInitializeListHead InitializeListHead
#define PrivateIsListEmpty        IsListEmpty
#define PrivateRemoveHeadList     RemoveHeadList
#define PrivateRemoveTailList     RemoveTailList
#define PrivateRemoveEntryList    RemoveEntryList
#define PrivateInsertTailList     InsertTailList
#define PrivateInsertHeadList     InsertHeadList

#define ASSERT_ALLOCATE_IRQL(_PoolType, _P) {NOTHING;}
#define ASSERT_FREE_IRQL(_PoolType, _P)     {NOTHING;}
#define ASSERT_POOL_NOT_FREE(_Entry)        {NOTHING;}
#define ASSERT_POOL_TYPE_NOT_ZERO(_Entry)   {NOTHING;}

//
// The check list macros come in two flavors - there is one in the checked
// and free build that will bugcheck the system if a list is ill-formed, and
// there is one for the final shipping version that has all the checked
// disabled.
//
// The check lookaside list macros also comes in two flavors and is used to
// verify that the look aside lists are well formed.
//
// The check pool header macro (two flavors) verifies that the specified
// pool header matches the preceeding and succeeding pool headers.
//

#define CHECK_LIST(LIST)                    {NOTHING;}
#define CHECK_POOL_HEADER(LINE,ENTRY)       {NOTHING;}

#define CHECK_LOOKASIDE_LIST(LINE,LIST,ENTRY) {NOTHING;}

#define CHECK_POOL_PAGE(PAGE) \
    {                                                                         \
        PPOOL_HEADER P = (PPOOL_HEADER)(((ULONG_PTR)(PAGE)) & ~(PAGE_SIZE-1));    \
        ULONG SIZE, LSIZE;                                                    \
        LOGICAL FOUND=FALSE;                                                  \
        LSIZE = 0;                                                            \
        SIZE = 0;                                                             \
        do {                                                                  \
            if (P == (PPOOL_HEADER)PAGE) {                                    \
                FOUND = TRUE;                                                 \
            }                                                                 \
            if (P->PreviousSize != LSIZE) {                                   \
                DbgPrint("POOL: Inconsistent size: ( %lx) - %lx->%u != %u\n",\
                         PAGE, P, P->PreviousSize, LSIZE);                    \
                DbgBreakPoint();                                              \
            }                                                                 \
            LSIZE = P->BlockSize;                                             \
            SIZE += LSIZE;                                                    \
            P = (PPOOL_HEADER)((PPOOL_BLOCK)P + LSIZE);                       \
        } while ((SIZE < (PAGE_SIZE / POOL_SMALLEST_BLOCK)) &&                \
                 (PAGE_END(P) == FALSE));                                     \
        if ((PAGE_END(P) == FALSE) || (FOUND == FALSE)) {                     \
            DbgPrint("POOL: Inconsistent page: %lx\n",P);                     \
            DbgBreakPoint();                                                  \
        }                                                                     \
    }

#endif


//
// Define forward referenced function prototypes.
//

NTSTATUS
ExpSnapShotPoolPages (
    IN PVOID Address,
    IN ULONG Size,
    IN OUT PSYSTEM_POOL_INFORMATION PoolInformation,
    IN OUT PSYSTEM_POOL_ENTRY *PoolEntryInfo,
    IN ULONG Length,
    IN OUT PULONG RequiredLength
    );

#ifdef ALLOC_PRAGMA
PVOID
ExpAllocateStringRoutine (
    IN SIZE_T NumberOfBytes
    );

VOID
ExDeferredFreePool (
     IN PPOOL_DESCRIPTOR PoolDesc
     );
#pragma alloc_text(PAGE, ExpAllocateStringRoutine)
#pragma alloc_text(INIT, InitializePool)
#pragma alloc_text(PAGE, ExInitializePoolDescriptor)
#pragma alloc_text(PAGEVRFY, ExAllocatePoolSanityChecks)
#pragma alloc_text(PAGEVRFY, ExFreePoolSanityChecks)
#pragma alloc_text(POOLCODE, ExAllocatePoolWithTag)
#pragma alloc_text(POOLCODE, ExFreePool)
#pragma alloc_text(POOLCODE, ExFreePoolWithTag)
#pragma alloc_text(POOLCODE, ExDeferredFreePool)
#if DBG
#pragma alloc_text(PAGELK, ExSnapShotPool)
#pragma alloc_text(PAGELK, ExpSnapShotPoolPages)
#endif
#endif

#if defined (NT_UP)
#define USING_HOT_COLD_METRICS (ExpPoolFlags & EX_SEPARATE_HOT_PAGES_DURING_BOOT)
#else
#define USING_HOT_COLD_METRICS 0
#endif

#define EXP_MAXIMUM_POOL_FREES_PENDING 128

#define MAX_TRACKER_TABLE   1025
#define MAX_BIGPAGE_TABLE   4096

PPOOL_DESCRIPTOR ExpSessionPoolDescriptor;
ULONG FirstPrint;

#if defined (NT_UP)
KDPC ExpBootFinishedTimerDpc;
KTIMER ExpBootFinishedTimer;

VOID
ExpBootFinishedDispatch (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );
#endif

PPOOL_TRACKER_TABLE PoolTrackTable;
SIZE_T PoolTrackTableSize;
SIZE_T PoolTrackTableMask;

PPOOL_TRACKER_BIG_PAGES PoolBigPageTable;
SIZE_T PoolBigPageTableSize;
SIZE_T PoolBigPageTableHash;

#define POOL_BIG_TABLE_ENTRY_FREE   0x1

ULONG PoolHitTag = 0xffffff0f;

#define POOLTAG_HASH(Key) ((40543*((((((((PUCHAR)&Key)[0]<<2)^((PUCHAR)&Key)[1])<<2)^((PUCHAR)&Key)[2])<<2)^((PUCHAR)&Key)[3]))>>2)

VOID
ExpInsertPoolTracker (
    IN ULONG Key,
    IN SIZE_T Size,
    IN POOL_TYPE PoolType
    );

VOID
ExpRemovePoolTracker (
    IN ULONG Key,
    IN ULONG Size,
    IN POOL_TYPE PoolType
    );

LOGICAL
ExpAddTagForBigPages (
    IN PVOID Va,
    IN ULONG Key,
    IN ULONG NumberOfPages
    );

ULONG
ExpFindAndRemoveTagBigPages (
    IN PVOID Va,
    IN PULONG BigPages
    );

PVOID
ExpAllocateStringRoutine(
    IN SIZE_T NumberOfBytes
    )
{
    return ExAllocatePoolWithTag(PagedPool,NumberOfBytes,'grtS');
}

BOOLEAN
ExOkayToLockRoutine(
    IN PVOID Lock
    )
{
    UNREFERENCED_PARAMETER (Lock);

    if (KeIsExecutingDpc()) {
        return FALSE;
    }
    else {
        return TRUE;
    }
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif
const PRTL_ALLOCATE_STRING_ROUTINE RtlAllocateStringRoutine = ExpAllocateStringRoutine;
const PRTL_FREE_STRING_ROUTINE RtlFreeStringRoutine = (PRTL_FREE_STRING_ROUTINE)ExFreePool;
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

ULONG ExPoolFailures;

//
// Define macros to pack and unpack a pool index.
//

#define ENCODE_POOL_INDEX(POOLHEADER,INDEX) {(POOLHEADER)->PoolIndex = ((UCHAR)(INDEX));}
#define DECODE_POOL_INDEX(POOLHEADER)       ((ULONG)((POOLHEADER)->PoolIndex))

//
// The allocated bit carefully overlays the unused cachealign bit in the type.
//

#define POOL_IN_USE_MASK                            0x4

#define MARK_POOL_HEADER_FREED(POOLHEADER)          {(POOLHEADER)->PoolType &= ~POOL_IN_USE_MASK;}
#define IS_POOL_HEADER_MARKED_ALLOCATED(POOLHEADER) ((POOLHEADER)->PoolType & POOL_IN_USE_MASK)

//
// The hotpage bit carefully overlays the raise bit in the type.
//

#define POOL_HOTPAGE_MASK   POOL_RAISE_IF_ALLOCATION_FAILURE

//
// Define the number of paged pools. This value may be overridden at boot
// time.
//

ULONG ExpNumberOfPagedPools = NUMBER_OF_PAGED_POOLS;

ULONG ExpNumberOfNonPagedPools = 1;

//
// The pool descriptor for nonpaged pool is static.
// The pool descriptors for paged pool are dynamically allocated
// since there can be more than one paged pool. There is always one more
// paged pool descriptor than there are paged pools. This descriptor is
// used when a page allocation is done for a paged pool and is the first
// descriptor in the paged pool descriptor array.
//

POOL_DESCRIPTOR NonPagedPoolDescriptor;

#define EXP_MAXIMUM_POOL_NODES 16

PPOOL_DESCRIPTOR ExpNonPagedPoolDescriptor[EXP_MAXIMUM_POOL_NODES];

//
// The pool vector contains an array of pointers to pool descriptors. For
// nonpaged pool this is just a pointer to the nonpaged pool descriptor.
// For paged pool, this is a pointer to an array of pool descriptors.
// The pointer to the paged pool descriptor is duplicated so
// it can be found easily by the kernel debugger.
//

PPOOL_DESCRIPTOR PoolVector[NUMBER_OF_POOLS];
PPOOL_DESCRIPTOR ExpPagedPoolDescriptor[EXP_MAXIMUM_POOL_NODES];
PFAST_MUTEX ExpPagedPoolMutex;

volatile ULONG ExpPoolIndex = 1;
KSPIN_LOCK ExpTaggedPoolLock;

#if DBG
PSZ PoolTypeNames[MaxPoolType] = {
    "NonPaged",
    "Paged",
    "NonPagedMustSucceed",
    "NotUsed",
    "NonPagedCacheAligned",
    "PagedCacheAligned",
    "NonPagedCacheAlignedMustS"
    };

#endif //DBG


//
// Define paged and nonpaged pool lookaside descriptors.
//

GENERAL_LOOKASIDE ExpSmallNPagedPoolLookasideLists[POOL_SMALL_LISTS];

GENERAL_LOOKASIDE ExpSmallPagedPoolLookasideLists[POOL_SMALL_LISTS];


//
// LOCK_POOL is only used within this module.
//

#define ExpLockNonPagedPool(OldIrql) \
    OldIrql = KeAcquireQueuedSpinLock(LockQueueNonPagedPoolLock)

#define ExpUnlockNonPagedPool(OldIrql) \
    KeReleaseQueuedSpinLock(LockQueueNonPagedPoolLock, OldIrql)

#define LOCK_POOL(PoolDesc, LockHandle) {                                   \
    if ((PoolDesc->PoolType & BASE_POOL_TYPE_MASK) == NonPagedPool) {       \
        if (PoolDesc == &NonPagedPoolDescriptor) {                          \
            ExpLockNonPagedPool (LockHandle.OldIrql);                       \
        }                                                                   \
        else {                                                              \
            ASSERT (ExpNumberOfNonPagedPools > 1);                          \
            KeAcquireInStackQueuedSpinLock (PoolDesc->LockAddress, &LockHandle); \
        }                                                                   \
    }                                                                       \
    else {                                                                  \
        ExAcquireFastMutex ((PFAST_MUTEX)PoolDesc->LockAddress);            \
    }                                                                       \
}

KIRQL
ExLockPool (
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function locks the pool specified by pool type.

Arguments:

    PoolType - Specifies the pool that should be locked.

Return Value:

    The previous IRQL is returned as the function value.

--*/

{

    KIRQL OldIrql;

    //
    // Nonpaged pool is protected by a spinlock, paged pool by a fast mutex.
    //
    // Always acquire the global main pool for our caller regardless of how
    // many subpools this system is using.
    //

    if ((PoolType & BASE_POOL_TYPE_MASK) == NonPagedPool) {
        ExpLockNonPagedPool (OldIrql);
    }
    else {
        ExAcquireFastMutex (ExpPagedPoolMutex);
        OldIrql = (KIRQL)ExpPagedPoolMutex->OldIrql;
    }

    return OldIrql;
}


//
// UNLOCK_POOL is only used within this module.
//

#define UNLOCK_POOL(PoolDesc, LockHandle) {                                 \
    if ((PoolDesc->PoolType & BASE_POOL_TYPE_MASK) == NonPagedPool) {       \
        if (PoolDesc == &NonPagedPoolDescriptor) {                          \
            ExpUnlockNonPagedPool (LockHandle.OldIrql);                     \
        }                                                                   \
        else {                                                              \
            ASSERT (ExpNumberOfNonPagedPools > 1);                          \
            KeReleaseInStackQueuedSpinLock (&LockHandle);                   \
        }                                                                   \
    }                                                                       \
    else {                                                                  \
        ExReleaseFastMutex ((PFAST_MUTEX)PoolDesc->LockAddress);            \
    }                                                                       \
}

VOID
ExUnlockPool (
    IN POOL_TYPE PoolType,
    IN KIRQL LockHandle
    )

/*++

Routine Description:

    This function unlocks the pool specified by pool type.

Arguments:

    PoolType - Specifies the pool that should be unlocked.

    LockHandle - Specifies the lock handle from a previous call to ExLockPool.

Return Value:

    None.

--*/

{
    //
    // Nonpaged pool is protected by a spinlock, paged pool by a fast mutex.
    //
    // Always release the global main pool for our caller regardless of how
    // many subpools this system is using.
    //

    if ((PoolType & BASE_POOL_TYPE_MASK) == NonPagedPool) {
        ExpUnlockNonPagedPool (LockHandle);
    }
    else {
        ExReleaseFastMutex (ExpPagedPoolMutex);
    }

    return;
}


VOID
ExInitializePoolDescriptor (
    IN PPOOL_DESCRIPTOR PoolDescriptor,
    IN POOL_TYPE PoolType,
    IN ULONG PoolIndex,
    IN ULONG Threshold,
    IN PVOID PoolLock
    )

/*++

Routine Description:

    This function initializes a pool descriptor.

    Note that this routine is called directly by the memory manager.

Arguments:

    PoolDescriptor - Supplies a pointer to the pool descriptor.

    PoolType - Supplies the type of the pool.

    PoolIndex - Supplies the pool descriptor index.

    Threshold - Supplies the threshold value for the specified pool.

    PoolLock - Supplies a pointer to the lock for the specified pool.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY LastListEntry;

    //
    // Initialize statistics fields, the pool type, the threshold value,
    // and the lock address.
    //

    PoolDescriptor->PoolType = PoolType;
    PoolDescriptor->PoolIndex = PoolIndex;
    PoolDescriptor->RunningAllocs = 0;
    PoolDescriptor->RunningDeAllocs = 0;
    PoolDescriptor->TotalPages = 0;
    PoolDescriptor->TotalBigPages = 0;
    PoolDescriptor->Threshold = Threshold;
    PoolDescriptor->LockAddress = PoolLock;

    PoolDescriptor->PendingFrees = NULL;
    PoolDescriptor->PendingFreeDepth = 0;

    //
    // Initialize the allocation listheads.
    //

    ListEntry = PoolDescriptor->ListHeads;
    LastListEntry = ListEntry + POOL_LIST_HEADS;

    while (ListEntry < LastListEntry) {
        PrivateInitializeListHead (ListEntry);
        ListEntry += 1;
    }

    if ((PoolType == PagedPoolSession) && (ExpSessionPoolDescriptor == NULL)) {
        ExpSessionPoolDescriptor = (PPOOL_DESCRIPTOR) MiSessionPoolVector ();
    }

    return;
}

//
// FREE_CHECK_ERESOURCE - If enabled causes each free pool to verify
// no active ERESOURCEs are in the pool block being freed.
//
// FREE_CHECK_KTIMER - If enabled causes each free pool to verify no
// active KTIMERs are in the pool block being freed.
//

//
// Checking for resources in pool being freed is expensive as there can
// easily be thousands of resources, so don't do it by default but do
// leave the capability for individual systems to enable it.
//

//
// Runtime modifications to these flags must use interlocked sequences.
//

#if DBG && !defined(_AMD64_SIMULATOR_)
ULONG ExpPoolFlags = EX_CHECK_POOL_FREES_FOR_ACTIVE_TIMERS | \
                     EX_CHECK_POOL_FREES_FOR_ACTIVE_WORKERS;
#else
ULONG ExpPoolFlags = 0;
#endif

#define FREE_CHECK_ERESOURCE(Va, NumberOfBytes)                             \
            if (ExpPoolFlags & EX_CHECK_POOL_FREES_FOR_ACTIVE_RESOURCES) {  \
                ExpCheckForResource(Va, NumberOfBytes);                     \
            }

#define FREE_CHECK_KTIMER(Va, NumberOfBytes)                                \
            if (ExpPoolFlags & EX_CHECK_POOL_FREES_FOR_ACTIVE_TIMERS) {     \
                KeCheckForTimer(Va, NumberOfBytes);                         \
            }

#define FREE_CHECK_WORKER(Va, NumberOfBytes)                                \
            if (ExpPoolFlags & EX_CHECK_POOL_FREES_FOR_ACTIVE_WORKERS) {    \
                ExpCheckForWorker(Va, NumberOfBytes);                       \
            }


VOID
ExSetPoolFlags (
    IN ULONG PoolFlag
    )

/*++

Routine Description:

    This procedure enables the specified pool flag(s).

Arguments:

    PoolFlag - Supplies the pool flag(s) to enable.

Return Value:

    None.

--*/
{
    RtlInterlockedSetBits (&ExpPoolFlags, PoolFlag);
}


VOID
InitializePool (
    IN POOL_TYPE PoolType,
    IN ULONG Threshold
    )

/*++

Routine Description:

    This procedure initializes a pool descriptor for the specified pool
    type.  Once initialized, the pool may be used for allocation and
    deallocation.

    This function should be called once for each base pool type during
    system initialization.

    Each pool descriptor contains an array of list heads for free
    blocks.  Each list head holds blocks which are a multiple of
    the POOL_BLOCK_SIZE.  The first element on the list [0] links
    together free entries of size POOL_BLOCK_SIZE, the second element
    [1] links together entries of POOL_BLOCK_SIZE * 2, the third
    POOL_BLOCK_SIZE * 3, etc, up to the number of blocks which fit
    into a page.

Arguments:

    PoolType - Supplies the type of pool being initialized (e.g.
               nonpaged pool, paged pool...).

    Threshold - Supplies the threshold value for the specified pool.

Return Value:

    None.

--*/

{
    ULONG i;
    ULONG GlobalFlag;
    PKSPIN_LOCK SpinLock;
    PPOOL_TRACKER_BIG_PAGES p;
    PPOOL_DESCRIPTOR Descriptor;
    ULONG Index;
    PFAST_MUTEX FastMutex;
    SIZE_T Size;

    ASSERT((PoolType & MUST_SUCCEED_POOL_TYPE_MASK) == 0);

    if (PoolType == NonPagedPool) {

        //
        // Initialize nonpaged pools.
        //

        GlobalFlag = NtGlobalFlag;
#if DBG
        GlobalFlag |= FLG_POOL_ENABLE_TAGGING;
#endif

        if (GlobalFlag & FLG_POOL_ENABLE_TAGGING) {

            PoolTrackTableSize = MAX_TRACKER_TABLE;
            PoolTrackTableMask = PoolTrackTableSize - 2;
            PoolTrackTable = MiAllocatePoolPages(NonPagedPool,
                                                 PoolTrackTableSize *
                                                   sizeof(POOL_TRACKER_TABLE),
                                                 FALSE);

            RtlZeroMemory(PoolTrackTable, PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE));

            PoolBigPageTableSize = MAX_BIGPAGE_TABLE;
            PoolBigPageTableHash = PoolBigPageTableSize - 1;
            PoolBigPageTable = MiAllocatePoolPages(NonPagedPool,
                                                   PoolBigPageTableSize *
                                                     sizeof(POOL_TRACKER_BIG_PAGES),
                                                   FALSE);

            RtlZeroMemory(PoolBigPageTable, PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES));

            p = &PoolBigPageTable[0];
            for (i = 0; i < PoolBigPageTableSize; i += 1, p += 1) {
                p->Va = (PVOID) POOL_BIG_TABLE_ENTRY_FREE;
            }

            ExpInsertPoolTracker ('looP',
                                  (ULONG) ROUND_TO_PAGES((PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES))),
                                  NonPagedPool);
        }

        if (KeNumberNodes > 1) {

            ExpNumberOfNonPagedPools = KeNumberNodes;

            //
            // Limit the number of pools to the number of bits in the PoolIndex.
            //

            if (ExpNumberOfNonPagedPools > 127) {
                ExpNumberOfNonPagedPools = 127;
            }

            //
            // Further limit the number of pools by our array of pointers.
            //

            if (ExpNumberOfNonPagedPools > EXP_MAXIMUM_POOL_NODES) {
                ExpNumberOfNonPagedPools = EXP_MAXIMUM_POOL_NODES;
            }

            Size = sizeof(POOL_DESCRIPTOR) + sizeof(KLOCK_QUEUE_HANDLE);

            for (Index = 0; Index < ExpNumberOfNonPagedPools; Index += 1) {

                //
                // Here's a thorny problem.  We'd like to use
                // MmAllocateIndependentPages but can't because we'd need
                // system PTEs to map the pages with and PTEs are not
                // available until nonpaged pool exists.  So just use
                // regular pool pages to hold the descriptors and spinlocks
                // and hope they either a) happen to fall onto the right node 
                // or b) that these lines live in the local processor cache
                // all the time anyway due to frequent usage.
                //

                Descriptor = (PPOOL_DESCRIPTOR) MiAllocatePoolPages (
                                                                 NonPagedPool,
                                                                 Size,
                                                                 FALSE);

                if (Descriptor == NULL) {
                    KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                                  Size,
                                  (ULONG_PTR)-1,
                                  (ULONG_PTR)-1,
                                  (ULONG_PTR)-1);
                }

                ExpNonPagedPoolDescriptor[Index] = Descriptor;

                SpinLock = (PKSPIN_LOCK)(Descriptor + 1);

                KeInitializeSpinLock (SpinLock);

                ExInitializePoolDescriptor (Descriptor,
                                            NonPagedPool,
                                            Index,
                                            Threshold,
                                            (PVOID)SpinLock);
            }
        }

        //
        // Initialize the spinlocks for nonpaged pool.
        //

        KeInitializeSpinLock (&ExpTaggedPoolLock);

        //
        // Initialize the nonpaged pool descriptor.
        //

        PoolVector[NonPagedPool] = &NonPagedPoolDescriptor;
        ExInitializePoolDescriptor (&NonPagedPoolDescriptor,
                                    NonPagedPool,
                                    0,
                                    Threshold,
                                    NULL);
    }
    else {

        //
        // Allocate memory for the paged pool descriptors and fast mutexes.
        //

        if (KeNumberNodes > 1) {

            ExpNumberOfPagedPools = KeNumberNodes;

            //
            // Limit the number of pools to the number of bits in the PoolIndex.
            //

            if (ExpNumberOfPagedPools > 127) {
                ExpNumberOfPagedPools = 127;
            }
        }

        //
        // Further limit the number of pools by our array of pointers.
        //

        if (ExpNumberOfPagedPools > EXP_MAXIMUM_POOL_NODES) {
            ExpNumberOfPagedPools = EXP_MAXIMUM_POOL_NODES;
        }

        //
        // For NUMA systems, allocate both the pool descriptor and the
        // associated lock from the local node for performance (even though
        // it costs a little more memory).
        //
        // For non-NUMA systems, allocate everything together in one chunk
        // to reduce memory consumption as there is no performance cost
        // for doing it this way.
        //

        if (KeNumberNodes > 1) {

            Size = sizeof(FAST_MUTEX) + sizeof(POOL_DESCRIPTOR);

            for (Index = 0; Index < ExpNumberOfPagedPools + 1; Index += 1) {

                ULONG Node;

                if (Index == 0) {
                    Node = 0;
                }
                else {
                    Node = Index - 1;
                }

                Descriptor = (PPOOL_DESCRIPTOR) MmAllocateIndependentPages (
                                                                      Size,
                                                                      Node);
                if (Descriptor == NULL) {
                    KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                                  Size,
                                  (ULONG_PTR)-1,
                                  (ULONG_PTR)-1,
                                  (ULONG_PTR)-1);
                }
                ExpPagedPoolDescriptor[Index] = Descriptor;

                FastMutex = (PFAST_MUTEX)(Descriptor + 1);

                if (Index == 0) {
                    PoolVector[PagedPool] = Descriptor;
                    ExpPagedPoolMutex = FastMutex;
                }

                ExInitializeFastMutex (FastMutex);

                ExInitializePoolDescriptor (Descriptor,
                                            PagedPool,
                                            Index,
                                            Threshold,
                                            (PVOID)FastMutex);
            }
        }
        else {

            Size = (ExpNumberOfPagedPools + 1) * (sizeof(FAST_MUTEX) + sizeof(POOL_DESCRIPTOR));

            Descriptor = (PPOOL_DESCRIPTOR)ExAllocatePoolWithTag (NonPagedPool,
                                                                  Size,
                                                                  'looP');
            if (Descriptor == NULL) {
                KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                              Size,
                              (ULONG_PTR)-1,
                              (ULONG_PTR)-1,
                              (ULONG_PTR)-1);
            }

            FastMutex = (PFAST_MUTEX)(Descriptor + ExpNumberOfPagedPools + 1);

            PoolVector[PagedPool] = Descriptor;
            ExpPagedPoolMutex = FastMutex;

            for (Index = 0; Index < ExpNumberOfPagedPools + 1; Index += 1) {
                ExInitializeFastMutex (FastMutex);
                ExpPagedPoolDescriptor[Index] = Descriptor;
                ExInitializePoolDescriptor (Descriptor,
                                            PagedPool,
                                            Index,
                                            Threshold,
                                            (PVOID)FastMutex);

                Descriptor += 1;
                FastMutex += 1;
            }
        }

        if (PoolTrackTable) {
            ExpInsertPoolTracker('looP',
                                  (ULONG) ROUND_TO_PAGES(PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE)),
                                 NonPagedPool);
        }

#if defined (NT_UP)
        if (MmNumberOfPhysicalPages < 32 * 1024) {

            LARGE_INTEGER TwoMinutes;

            //
            // Set the flag to disable lookasides and use hot/cold page
            // separation during bootup.
            //

            ExSetPoolFlags (EX_SEPARATE_HOT_PAGES_DURING_BOOT);

            //
            // Start a timer so the above behavior is disabled once bootup
            // has finished.
            //

            KeInitializeTimer (&ExpBootFinishedTimer);

            KeInitializeDpc (&ExpBootFinishedTimerDpc,
                             (PKDEFERRED_ROUTINE) ExpBootFinishedDispatch,
                             NULL);

            TwoMinutes.QuadPart = Int32x32To64 (120, -10000000);

            KeSetTimer (&ExpBootFinishedTimer,
                        TwoMinutes,
                        &ExpBootFinishedTimerDpc);
        }
#endif
        if (MmNumberOfPhysicalPages >= 127 * 1024) {
            ExSetPoolFlags (EX_DELAY_POOL_FREES);
        }
    }
}

PVOID
VeAllocatePoolWithTagPriority (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN EX_POOL_PRIORITY Priority,
    IN PVOID CallingAddress
    );


PVOID
ExAllocatePoolWithTag (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block. This function is used to
    access both the page-aligned pools and the list head entries (less
    than a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned pool
    allocator is used. The allocated block will be page-aligned and a
    page-sized multiple.

    Otherwise, the appropriate pool list entry is used. The allocated
    block will be 64-bit aligned, but will not be page aligned. The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request. If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split. One piece is placed back into the pool, and
    the other piece is used to satisfy the request. If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called. The page is split and added
    to the pool.

Arguments:

    PoolType - Supplies the type of pool to allocate. If the pool type
        is one of the "MustSucceed" pool types, then this call will
        succeed and return a pointer to allocated pool or bugcheck on failure.
        For all other cases, if the system cannot allocate the requested amount
        of memory, NULL is returned.

        Valid pool types:

        NonPagedPool
        PagedPool
        NonPagedPoolMustSucceed,
        NonPagedPoolCacheAligned
        PagedPoolCacheAligned
        NonPagedPoolCacheAlignedMustS

    Tag - Supplies the caller's identifying tag.

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NULL - The PoolType is not one of the "MustSucceed" pool types, and
           not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/

{
    LOGICAL LockHeld;
    PVOID Block;
    PPOOL_HEADER Entry;
    PGENERAL_LOOKASIDE LookasideList;
    PPOOL_HEADER NextEntry;
    PPOOL_HEADER SplitEntry;
    KLOCK_QUEUE_HANDLE LockHandle;
    PPOOL_DESCRIPTOR PoolDesc;
    ULONG Index;
    ULONG ListNumber;
    ULONG NeededSize;
    ULONG PoolIndex;
    POOL_TYPE CheckType;
    POOL_TYPE RequestType;
    PLIST_ENTRY ListHead;
    POOL_TYPE NewPoolType;
    LOGICAL GlobalSpace;
    ULONG IsLargeSessionAllocation;
    PKPRCB Prcb;
    ULONG NumberOfPages;
    POOL_HEADER TempHeader;
    POOL_HEADER TempHeader2;
    ULONG RetryCount;
    PVOID CallingAddress;
#if defined (_X86_)
    PVOID CallersCaller;
#endif

#define CacheOverhead POOL_OVERHEAD

    PERFINFO_EXALLOCATEPOOLWITHTAG_DECL();

    ASSERT (NumberOfBytes != 0);
    ASSERT_ALLOCATE_IRQL (PoolType, NumberOfBytes);

    //
    // Isolate the base pool type and select a pool from which to allocate
    // the specified block size.
    //

    CheckType = PoolType & BASE_POOL_TYPE_MASK;

    if (ExpPoolFlags & (EX_KERNEL_VERIFIER_ENABLED | EX_SPECIAL_POOL_ENABLED)) {

        if (ExpPoolFlags & EX_KERNEL_VERIFIER_ENABLED) {

            if ((PoolType & POOL_DRIVER_MASK) == 0) {

                //
                // Use the Driver Verifier pool framework.  Note this will
                // result in a recursive callback to this routine.
                //

#if defined (_X86_)
                RtlGetCallersAddress (&CallingAddress, &CallersCaller);
#else
                CallingAddress = (PVOID)_ReturnAddress();
#endif

                return VeAllocatePoolWithTagPriority (PoolType | POOL_DRIVER_MASK,
                                                  NumberOfBytes,
                                                  Tag,
                                                  HighPoolPriority,
                                                  CallingAddress);
            }
            PoolType &= ~POOL_DRIVER_MASK;
        }

        //
        // Use special pool if there is a tag or size match.
        //

        if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) &&
            (MmUseSpecialPool (NumberOfBytes, Tag))) {

            Entry = MmAllocateSpecialPool (NumberOfBytes,
                                           Tag,
                                           PoolType,
                                           2);
            if (Entry != NULL) {
                return (PVOID)Entry;
            }
        }
    }

    //
    // Only session paged pool allocations come from the per session
    // pools.  Nonpaged session pool allocations still come from global pool.
    //

    if (PoolType & SESSION_POOL_MASK) {
        ASSERT (ExpSessionPoolDescriptor != NULL);

        GlobalSpace = FALSE;
        if (CheckType == NonPagedPool) {
            PoolDesc = PoolVector[CheckType];
        }
        else {
            PoolDesc = ExpSessionPoolDescriptor;
        }
    }
    else {
        PoolDesc = PoolVector[CheckType];
        GlobalSpace = TRUE;
    }

    //
    // Initializing LockHandle is not needed for correctness but without
    // it the compiler cannot compile this code W4 to check for use of
    // uninitialized variables.
    //

    LockHandle.OldIrql = 0;

    //
    // Check to determine if the requested block can be allocated from one
    // of the pool lists or must be directly allocated from virtual memory.
    //

    if (NumberOfBytes > POOL_BUDDY_MAX) {

        //
        // The requested size is greater than the largest block maintained
        // by allocation lists.
        //

        RetryCount = 0;
        IsLargeSessionAllocation = (PoolType & SESSION_POOL_MASK);

        RequestType = (PoolType & (BASE_POOL_TYPE_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK));

restart1:

        LOCK_POOL(PoolDesc, LockHandle);

        Entry = (PPOOL_HEADER) MiAllocatePoolPages (RequestType,
                                                    NumberOfBytes,
                                                    IsLargeSessionAllocation);

        //
        // Large session pool allocations are accounted for directly by
        // the memory manager so no need to call MiSessionPoolAllocated here.
        //

        if (Entry != NULL) {

            NumberOfPages = BYTES_TO_PAGES(NumberOfBytes);
            PoolDesc->TotalBigPages += NumberOfPages;

            PoolDesc->RunningAllocs += 1;

            UNLOCK_POOL(PoolDesc, LockHandle);

            if ((PoolBigPageTable) && (IsLargeSessionAllocation == 0)) {

                if (ExpAddTagForBigPages((PVOID)Entry,
                                         Tag,
                                         NumberOfPages) == FALSE) {
                    Tag = ' GIB';
                }

                ExpInsertPoolTracker (Tag,
                                      (ULONG) ROUND_TO_PAGES(NumberOfBytes),
                                      PoolType);
            }
        }
        else {

            UNLOCK_POOL(PoolDesc, LockHandle);

            RetryCount += 1;

            //
            // If there are deferred free blocks, free them now and retry.
            //

            if ((RetryCount == 1) && (ExpPoolFlags & EX_DELAY_POOL_FREES)) {
                ExDeferredFreePool (PoolDesc);
                goto restart1;
            }

            if (PoolType & MUST_SUCCEED_POOL_TYPE_MASK) {
                KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                              NumberOfBytes,
                              NonPagedPoolDescriptor.TotalPages,
                              NonPagedPoolDescriptor.TotalBigPages,
                              0);
            }

            ExPoolFailures += 1;

            if (ExpPoolFlags & EX_PRINT_POOL_FAILURES) {
                KdPrint(("EX: ExAllocatePool (%p, 0x%x) returning NULL\n",
                    NumberOfBytes,
                    PoolType));
                if (ExpPoolFlags & EX_STOP_ON_POOL_FAILURES) {
                    DbgBreakPoint ();
                }
            }

            if ((PoolType & POOL_RAISE_IF_ALLOCATION_FAILURE) != 0) {
                ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
            }
        }

        PERFINFO_BIGPOOLALLOC(PoolType, Tag, NumberOfBytes, Entry);

        return Entry;
    }

    if (NumberOfBytes == 0) {

        //
        // Besides fragmenting pool, zero byte requests would not be handled
        // in cases where the minimum pool block size is the same as the 
        // pool header size (no room for flink/blinks, etc).
        //

#if DBG
        KeBugCheckEx (BAD_POOL_CALLER, 0, 0, PoolType, Tag);
#else
        NumberOfBytes = 1;
#endif
    }

    //
    // The requested size is less than or equal to the size of the
    // maximum block maintained by the allocation lists.
    //

    PERFINFO_POOLALLOC(PoolType, Tag, NumberOfBytes);

    //
    // Compute the index of the listhead for blocks of the requested size.
    //

    ListNumber = (ULONG)((NumberOfBytes + POOL_OVERHEAD + (POOL_SMALLEST_BLOCK - 1)) >> POOL_BLOCK_SHIFT);

    NeededSize = ListNumber;

    if (CheckType == PagedPool) {

        //
        // If the requested pool block is a small block, then attempt to
        // allocate the requested pool from the per processor lookaside
        // list. If the attempt fails, then attempt to allocate from the
        // system lookaside list. If the attempt fails, then select a
        // pool to allocate from and allocate the block normally.
        //
        // Note session space allocations do not currently use lookaside lists.
        //
        // Also note that if hot/cold separation is enabled, allocations are
        // not satisfied from lookaside lists as these are either :
        //
        // 1. cold references
        //
        // or
        //
        // 2. we are still booting on a small machine, thus keeping pool
        //    locality dense (to reduce the working set footprint thereby
        //    reducing page stealing) is a bigger win in terms of overall
        //    speed than trying to satisfy individual requests more quickly.
        //

        if ((GlobalSpace == TRUE) &&
            (USING_HOT_COLD_METRICS == 0) &&
            (NeededSize <= POOL_SMALL_LISTS)) {

            Prcb = KeGetCurrentPrcb ();
            LookasideList = Prcb->PPPagedLookasideList[NeededSize - 1].P;
            LookasideList->TotalAllocates += 1;

            CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, Entry);

            Entry = (PPOOL_HEADER)
                InterlockedPopEntrySList (&LookasideList->ListHead);

            if (Entry == NULL) {
                LookasideList = Prcb->PPPagedLookasideList[NeededSize - 1].L;
                LookasideList->TotalAllocates += 1;

                CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, Entry);

                Entry = (PPOOL_HEADER)
                    InterlockedPopEntrySList (&LookasideList->ListHead);
            }

            if (Entry != NULL) {

                CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, Entry);

                Entry -= 1;
                LookasideList->AllocateHits += 1;
                NewPoolType = (PoolType & (BASE_POOL_TYPE_MASK | POOL_QUOTA_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK)) + 1;
                NewPoolType |= POOL_IN_USE_MASK;

                Entry->PoolType = (UCHAR)NewPoolType;

                Entry->PoolTag = Tag;

                ASSERT ((PoolType & SESSION_POOL_MASK) == 0);

                if (PoolTrackTable != NULL) {

                    ExpInsertPoolTracker (Tag,
                                          Entry->BlockSize << POOL_BLOCK_SHIFT,
                                          PoolType);
                }

                //
                // Zero out any back pointer to our internal structures
                // to stop someone from corrupting us via an
                // uninitialized pointer.
                //

                ((PULONG_PTR)((PCHAR)Entry + CacheOverhead))[0] = 0;

                PERFINFO_POOLALLOC_ADDR((PUCHAR)Entry + CacheOverhead);

                return (PUCHAR)Entry + CacheOverhead;
            }
        }

        //
        // If there is more than one paged pool, then attempt to find
        // one that can be immediately locked.
        //
        //
        // N.B. The paged pool is selected in a round robin fashion using a
        //      simple counter.  Note that the counter is incremented using a
        //      a noninterlocked sequence, but the pool index is never allowed
        //      to get out of range.
        //

        if (GlobalSpace == TRUE) {

            PVOID Lock;

            if (USING_HOT_COLD_METRICS)  {

                if ((PoolType & POOL_COLD_ALLOCATION) == 0) {

                    //
                    // Hot allocations come from the first paged pool.
                    //

                    PoolIndex = 1;
                }
                else {

                    //
                    // Force cold allocations to come from the last paged pool.
                    //

                    PoolIndex = ExpNumberOfPagedPools;
                }
            }
            else {

                if (KeNumberNodes > 1) {

                    //
                    // Use the pool descriptor which contains memory local to
                    // the current processor even if we have to wait for it.
                    // While it is possible that the paged pool addresses in the
                    // local descriptor have been paged out, on large memory
                    // NUMA machines this should be less common.
                    //

                    Prcb = KeGetCurrentPrcb ();

                    PoolIndex = Prcb->ParentNode->Color;

                    if (PoolIndex < ExpNumberOfPagedPools) {
                        PoolIndex += 1;
                        PoolDesc = ExpPagedPoolDescriptor[PoolIndex];
                        RequestType = PoolType & (BASE_POOL_TYPE_MASK | SESSION_POOL_MASK);
                        RetryCount = 0;
                        goto restart2;
                    }
                }

                PoolIndex = 1;
                if (ExpNumberOfPagedPools != PoolIndex) {
                    ExpPoolIndex += 1;
                    PoolIndex = ExpPoolIndex;
                    if (PoolIndex > ExpNumberOfPagedPools) {
                        PoolIndex = 1;
                        ExpPoolIndex = 1;
                    }

                    Index = PoolIndex;
                    do {
                        Lock = ExpPagedPoolDescriptor[PoolIndex]->LockAddress;

                        if (!ExIsFastMutexOwned((PFAST_MUTEX)Lock)) {
                            break;
                        }

                        PoolIndex += 1;
                        if (PoolIndex > ExpNumberOfPagedPools) {
                            PoolIndex = 1;
                        }

                    } while (PoolIndex != Index);
                }
            }

            PoolDesc = ExpPagedPoolDescriptor[PoolIndex];
        }
        else {

            //
            // Only one paged pool is currently available per session.
            //

            PoolIndex = 0;
            ASSERT (PoolDesc == ExpSessionPoolDescriptor);
            ASSERT (PoolDesc->PoolIndex == 0);
        }
    }
    else {

        //
        // If the requested pool block is a small block, then attempt to
        // allocate the requested pool from the per processor lookaside
        // list. If the attempt fails, then attempt to allocate from the
        // system lookaside list. If the attempt fails, then select a
        // pool to allocate from and allocate the block normally.
        //

        if ((GlobalSpace == TRUE) && (NeededSize <= POOL_SMALL_LISTS)) {

            Prcb = KeGetCurrentPrcb();
            LookasideList = Prcb->PPNPagedLookasideList[NeededSize - 1].P;
            LookasideList->TotalAllocates += 1;

            CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, 0);

            Entry = (PPOOL_HEADER)
                        InterlockedPopEntrySList (&LookasideList->ListHead);

            if (Entry == NULL) {
                LookasideList = Prcb->PPNPagedLookasideList[NeededSize - 1].L;
                LookasideList->TotalAllocates += 1;

                CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, 0);

                Entry = (PPOOL_HEADER)
                        InterlockedPopEntrySList (&LookasideList->ListHead);
            }

            if (Entry != NULL) {

                CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, Entry);

                Entry -= 1;
                LookasideList->AllocateHits += 1;
                NewPoolType = (PoolType & (BASE_POOL_TYPE_MASK | POOL_QUOTA_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK)) + 1;
                NewPoolType |= POOL_IN_USE_MASK;

                Entry->PoolType = (UCHAR)NewPoolType;

                Entry->PoolTag = Tag;

                if (PoolTrackTable != NULL) {

                    ExpInsertPoolTracker (Tag,
                                          Entry->BlockSize << POOL_BLOCK_SHIFT,
                                          PoolType);
                }

                //
                // Zero out any back pointer to our internal structures
                // to stop someone from corrupting us via an
                // uninitialized pointer.
                //

                ((PULONG_PTR)((PCHAR)Entry + CacheOverhead))[0] = 0;

                PERFINFO_POOLALLOC_ADDR((PUCHAR)Entry + CacheOverhead);

                return (PUCHAR)Entry + CacheOverhead;
            }
        }

        if (ExpNumberOfNonPagedPools <= 1) {
            PoolIndex = 0;
        }
        else {

            //
            // Use the pool descriptor which contains memory local to
            // the current processor even if we have to contend for its lock.
            //

            Prcb = KeGetCurrentPrcb ();

            PoolIndex = Prcb->ParentNode->Color;

            if (PoolIndex >= ExpNumberOfNonPagedPools) {
                PoolIndex = ExpNumberOfNonPagedPools - 1;
            }

            PoolDesc = ExpNonPagedPoolDescriptor[PoolIndex];
        }

        ASSERT(PoolIndex == PoolDesc->PoolIndex);
    }

    RequestType = PoolType & (BASE_POOL_TYPE_MASK | SESSION_POOL_MASK);
    RetryCount = 0;

restart2:

    ListHead = &PoolDesc->ListHeads[ListNumber];

    //
    // Walk the listheads looking for a free block.
    //

    LockHeld = FALSE;

    do {

        //
        // If the list is not empty, then allocate a block from the
        // selected list.
        //

        if (PrivateIsListEmpty(ListHead) == FALSE) {

            if (LockHeld == FALSE) {

                LockHeld = TRUE;
                LOCK_POOL (PoolDesc, LockHandle);

                if (PrivateIsListEmpty(ListHead)) {

                    //
                    // The block is no longer available - restart at the
                    // beginning to avoid fragmentation.
                    //

                    ListHead = &PoolDesc->ListHeads[ListNumber];
                    continue;
                }
            }

            CHECK_LIST (ListHead);
            Block = PrivateRemoveHeadList(ListHead);
            CHECK_LIST (ListHead);
            Entry = (PPOOL_HEADER)((PCHAR)Block - POOL_OVERHEAD);

            ASSERT(Entry->BlockSize >= NeededSize);

            ASSERT(DECODE_POOL_INDEX(Entry) == PoolIndex);

            ASSERT(Entry->PoolType == 0);

            if (Entry->BlockSize != NeededSize) {

                //
                // The selected block is larger than the allocation
                // request. Split the block and insert the remaining
                // fragment in the appropriate list.
                //
                // If the entry is at the start of a page, then take
                // the allocation from the front of the block so as
                // to minimize fragmentation. Otherwise, take the
                // allocation from the end of the block which may
                // also reduce fragmentation if the block is at the
                // end of a page.
                //

                if (Entry->PreviousSize == 0) {

                    //
                    // The entry is at the start of a page.
                    //

                    SplitEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);
                    SplitEntry->BlockSize = (USHORT)(Entry->BlockSize - NeededSize);
                    SplitEntry->PreviousSize = (USHORT) NeededSize;

                    //
                    // If the allocated block is not at the end of a
                    // page, then adjust the size of the next block.
                    //

                    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)SplitEntry + SplitEntry->BlockSize);
                    if (PAGE_END(NextEntry) == FALSE) {
                        NextEntry->PreviousSize = SplitEntry->BlockSize;
                    }

                }
                else {

                    //
                    // The entry is not at the start of a page.
                    //

                    SplitEntry = Entry;
                    Entry->BlockSize = (USHORT)(Entry->BlockSize - NeededSize);
                    Entry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
                    Entry->PreviousSize = SplitEntry->BlockSize;

                    //
                    // If the allocated block is not at the end of a
                    // page, then adjust the size of the next block.
                    //

                    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);
                    if (PAGE_END(NextEntry) == FALSE) {
                        NextEntry->PreviousSize = (USHORT) NeededSize;
                    }
                }

                //
                // Set the size of the allocated entry, clear the pool
                // type of the split entry, set the index of the split
                // entry, and insert the split entry in the appropriate
                // free list.
                //

                Entry->BlockSize = (USHORT) NeededSize;
                ENCODE_POOL_INDEX(Entry, PoolIndex);
                SplitEntry->PoolType = 0;
                ENCODE_POOL_INDEX(SplitEntry, PoolIndex);
                Index = SplitEntry->BlockSize;

                CHECK_LIST(&PoolDesc->ListHeads[Index - 1]);

                //
                // Only insert split pool blocks which contain more than just
                // a header as only those have room for a flink/blink !
                // Note if the minimum pool block size is bigger than the
                // header then there can be no blocks like this.
                //

                if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
                    (SplitEntry->BlockSize != 1)) {

                    PrivateInsertTailList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)));

                    CHECK_LIST(((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)));
                }
            }

            Entry->PoolType = (UCHAR)(((PoolType & (BASE_POOL_TYPE_MASK | POOL_QUOTA_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK)) + 1) | POOL_IN_USE_MASK);

            CHECK_POOL_HEADER(__LINE__, Entry);

            PoolDesc->RunningAllocs += 1;

            UNLOCK_POOL(PoolDesc, LockHandle);

            Entry->PoolTag = Tag;

            //
            // Notify the memory manager of session pool allocations
            // so leaked allocations can be caught on session exit.
            //

            if (PoolType & SESSION_POOL_MASK) {
                MiSessionPoolAllocated(
                    (PVOID)((PCHAR)Entry + CacheOverhead),
                    (ULONG)(Entry->BlockSize << POOL_BLOCK_SHIFT),
                    PoolType);
            }
            else if (PoolTrackTable != NULL) {

                ExpInsertPoolTracker (Tag,
                                      Entry->BlockSize << POOL_BLOCK_SHIFT,
                                      PoolType);
            }

            //
            // Zero out any back pointer to our internal structures
            // to stop someone from corrupting us via an
            // uninitialized pointer.
            //

            ((PULONGLONG)((PCHAR)Entry + CacheOverhead))[0] = 0;

            PERFINFO_POOLALLOC_ADDR((PUCHAR)Entry + CacheOverhead);
            return (PCHAR)Entry + CacheOverhead;
        }

        ListHead += 1;

    } while (ListHead != &PoolDesc->ListHeads[POOL_LIST_HEADS]);

    //
    // A block of the desired size does not exist and there are
    // no large blocks that can be split to satisfy the allocation.
    // Attempt to expand the pool by allocating another page to be
    // added to the pool.
    //
    // If a different (master) pool lock will be needed for the allocation
    // of full pool pages, then get rid of the local pool lock now.
    //
    // Initialize TempHeader now to reduce lock hold times assuming the
    // allocation will succeed.
    //

    if (LockHeld == TRUE) {
        if (CheckType == PagedPool) {
            if (GlobalSpace == TRUE) {
                ExReleaseFastMutex ((PFAST_MUTEX)PoolDesc->LockAddress);
                LockHeld = FALSE;
            }
        }
        else if (CheckType == NonPagedPool) {
            if (ExpNumberOfNonPagedPools > 1) {
                KeReleaseInStackQueuedSpinLock (&LockHandle);
                LockHeld = FALSE;
            }
        }
    }

    TempHeader.Ulong1 = 0;
    TempHeader.PoolIndex = (UCHAR) PoolIndex;
    TempHeader.BlockSize = (USHORT) NeededSize;

    TempHeader.PoolType = (UCHAR)(((PoolType & (BASE_POOL_TYPE_MASK | POOL_QUOTA_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK)) + 1) | POOL_IN_USE_MASK);

    TempHeader2.Ulong1 = 0;

    Index = (PAGE_SIZE / sizeof(POOL_BLOCK)) - NeededSize;

    TempHeader2.BlockSize = (USHORT) Index;
    TempHeader2.PreviousSize = (USHORT) NeededSize;
    TempHeader2.PoolIndex = (UCHAR) PoolIndex;

    //
    // Pool header now initialized, try for a free page.
    //

    if (LockHeld == FALSE) {
        LockHeld = TRUE;
        if (CheckType == PagedPool) {
            if (GlobalSpace == TRUE) {
                ExAcquireFastMutex (ExpPagedPoolMutex);
            }
            else {
                ExAcquireFastMutex (ExpSessionPoolDescriptor->LockAddress);
            }
        }
        else {
            ExpLockNonPagedPool (LockHandle.OldIrql);
        }
    }

    Entry = (PPOOL_HEADER) MiAllocatePoolPages (RequestType, PAGE_SIZE, FALSE);

    ASSERT (LockHeld == TRUE);

    if (CheckType == PagedPool) {
        if (GlobalSpace == TRUE) {
            ExReleaseFastMutex (ExpPagedPoolMutex);
            LockHeld = FALSE;
        }
    }
    else if (CheckType == NonPagedPool) {
        if (ExpNumberOfNonPagedPools > 1) {
            ExpUnlockNonPagedPool (LockHandle.OldIrql);
            LockHeld = FALSE;
        }
    }

    if (Entry == NULL) {

        if (LockHeld == TRUE) {
            if (CheckType == NonPagedPool) {
                if (ExpNumberOfNonPagedPools <= 1) {
                    ExpUnlockNonPagedPool (LockHandle.OldIrql);
                }
            }
            else {
                ExReleaseFastMutex (ExpSessionPoolDescriptor->LockAddress);
            }
            LockHeld = FALSE;
        }

        //
        // If there are deferred free blocks, free them now and retry.
        //

        RetryCount += 1;

        if ((RetryCount == 1) && (ExpPoolFlags & EX_DELAY_POOL_FREES)) {
            ExDeferredFreePool (PoolDesc);
            goto restart2;
        }

        if ((PoolType & MUST_SUCCEED_POOL_TYPE_MASK) != 0) {

            //
            // Must succeed pool was requested so bugcheck.
            //

            KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                          PAGE_SIZE,
                          NonPagedPoolDescriptor.TotalPages,
                          NonPagedPoolDescriptor.TotalBigPages,
                          0);
        }

        //
        // No more pool of the specified type is available.
        //

        ExPoolFailures += 1;

        if (ExpPoolFlags & EX_PRINT_POOL_FAILURES) {
            KdPrint(("EX: ExAllocatePool (%p, 0x%x) returning NULL\n",
                NumberOfBytes,
                PoolType));
            if (ExpPoolFlags & EX_STOP_ON_POOL_FAILURES) {
                DbgBreakPoint ();
            }
        }

        if ((PoolType & POOL_RAISE_IF_ALLOCATION_FAILURE) != 0) {
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        }

        PERFINFO_POOLALLOC_ADDR(NULL);
        return NULL;
    }

    //
    // Split the allocated page and insert the remaining
    // fragment in the appropriate listhead.
    //
    // Set the size of the allocated entry, clear the pool
    // type of the split entry, set the index of the split
    // entry, and insert the split entry in the appropriate
    // free list.
    //

    PoolDesc->TotalPages += 1;

    *Entry = TempHeader;

    PERFINFO_ADDPOOLPAGE(CheckType, PoolIndex, Entry, PoolDesc);

    SplitEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);

    *SplitEntry = TempHeader2;

    if (LockHeld == FALSE) {
        LOCK_POOL (PoolDesc, LockHandle);
    }

    //
    // Only insert split pool blocks which contain more than just
    // a header as only those have room for a flink/blink !
    // Note if the minimum pool block size is bigger than the
    // header then there can be no blocks like this.
    //

    if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
        (SplitEntry->BlockSize != 1)) {

        CHECK_LIST(&PoolDesc->ListHeads[Index - 1]);

        PrivateInsertTailList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)));

        CHECK_LIST(((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)));
    }

    CHECK_POOL_HEADER(__LINE__, Entry);

    PoolDesc->RunningAllocs += 1;

    UNLOCK_POOL (PoolDesc, LockHandle);

    Block = (PVOID) ((PCHAR)Entry + CacheOverhead);
    NeededSize <<= POOL_BLOCK_SHIFT;

    Entry->PoolTag = Tag;

    //
    // Notify the memory manager of session pool allocations
    // so leaked allocations can be caught on session exit.
    //

    if (PoolType & SESSION_POOL_MASK) {
        MiSessionPoolAllocated (Block, NeededSize, PoolType);
    }
    else if (PoolTrackTable != NULL) {
        ExpInsertPoolTracker (Tag, NeededSize, PoolType);
    }

    PERFINFO_POOLALLOC_ADDR (Block);

    return Block;
}


PVOID
ExAllocatePool (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block.  This function is used to
    access both the page-aligned pools, and the list head entries (less than
    a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned
    pool allocator is used.  The allocated block will be page-aligned
    and a page-sized multiple.

    Otherwise, the appropriate pool list entry is used.  The allocated
    block will be 64-bit aligned, but will not be page aligned.  The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request.  If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split.  One piece is placed back into the pool, and
    the other piece is used to satisfy the request.  If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called.  The page is split and added
    to the pool...

Arguments:

    PoolType - Supplies the type of pool to allocate.  If the pool type
        is one of the "MustSucceed" pool types, then this call will
        succeed and return a pointer to allocated pool or bugcheck on failure.
        For all other cases, if the system cannot allocate the requested amount
        of memory, NULL is returned.

        Valid pool types:

        NonPagedPool
        PagedPool
        NonPagedPoolMustSucceed,
        NonPagedPoolCacheAligned
        PagedPoolCacheAligned
        NonPagedPoolCacheAlignedMustS

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NULL - The PoolType is not one of the "MustSucceed" pool types, and
           not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/

{
    return ExAllocatePoolWithTag (PoolType,
                                  NumberOfBytes,
                                  'enoN');
}


PVOID
ExAllocatePoolWithTagPriority (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN EX_POOL_PRIORITY Priority
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block.  This function is used to
    access both the page-aligned pools, and the list head entries (less than
    a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned
    pool allocator is used.  The allocated block will be page-aligned
    and a page-sized multiple.

    Otherwise, the appropriate pool list entry is used.  The allocated
    block will be 64-bit aligned, but will not be page aligned.  The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request.  If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split.  One piece is placed back into the pool, and
    the other piece is used to satisfy the request.  If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called.  The page is split and added
    to the pool...

Arguments:

    PoolType - Supplies the type of pool to allocate.  If the pool type
        is one of the "MustSucceed" pool types, then this call will
        succeed and return a pointer to allocated pool or bugcheck on failure.
        For all other cases, if the system cannot allocate the requested amount
        of memory, NULL is returned.

        Valid pool types:

        NonPagedPool
        PagedPool
        NonPagedPoolMustSucceed,
        NonPagedPoolCacheAligned
        PagedPoolCacheAligned
        NonPagedPoolCacheAlignedMustS

    NumberOfBytes - Supplies the number of bytes to allocate.

    Tag - Supplies the caller's identifying tag.

    Priority - Supplies an indication as to how important it is that this
               request succeed under low available pool conditions.  This
               can also be used to specify special pool.

Return Value:

    NULL - The PoolType is not one of the "MustSucceed" pool types, and
           not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/

{
    PVOID Entry;

    if ((Priority & POOL_SPECIAL_POOL_BIT) && (NumberOfBytes <= POOL_BUDDY_MAX)) {
        Entry = MmAllocateSpecialPool (NumberOfBytes,
                                       Tag,
                                       PoolType,
                                       (Priority & POOL_SPECIAL_POOL_UNDERRUN_BIT) ? 1 : 0);

        if (Entry != NULL) {
            return Entry;
        }
        Priority &= ~(POOL_SPECIAL_POOL_BIT | POOL_SPECIAL_POOL_UNDERRUN_BIT);
    }

    //
    // Pool and other resources can be allocated directly through the Mm
    // without the pool code knowing - so always call the Mm for the
    // up-to-date counters.
    //

    if ((Priority != HighPoolPriority) && ((PoolType & MUST_SUCCEED_POOL_TYPE_MASK) == 0)) {

        if (MmResourcesAvailable (PoolType, NumberOfBytes, Priority) == FALSE) {
            return NULL;
        }
    }

    //
    // There is a window between determining whether to proceed and actually
    // doing the allocation.  In this window the pool may deplete.  This is not
    // worth closing at this time.
    //

    return ExAllocatePoolWithTag (PoolType, NumberOfBytes, Tag);
}


PVOID
ExAllocatePoolWithQuota (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type,
    returns a pointer to the allocated block, and if the binary buddy
    allocator was used to satisfy the request, charges pool quota to the
    current process.  This function is used to access both the
    page-aligned pools, and the binary buddy.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate binary buddy pool, then the
    page-aligned pool allocator is used.  The allocated block will be
    page-aligned and a page-sized multiple.  No quota is charged to the
    current process if this is the case.

    Otherwise, the appropriate binary buddy pool is used.  The allocated
    block will be 64-bit aligned, but will not be page aligned.  After
    the allocation completes, an attempt will be made to charge pool
    quota (of the appropriate type) to the current process object.  If
    the quota charge succeeds, then the pool block's header is adjusted
    to point to the current process.  The process object is not
    dereferenced until the pool is deallocated and the appropriate
    amount of quota is returned to the process.  Otherwise, the pool is
    deallocated, a "quota exceeded" condition is raised.

Arguments:

    PoolType - Supplies the type of pool to allocate.  If the pool type
        is one of the "MustSucceed" pool types and sufficient quota
        exists, then this call will always succeed and return a pointer
        to allocated pool.  Otherwise, if the system cannot allocate
        the requested amount of memory a STATUS_INSUFFICIENT_RESOURCES
        status is raised.

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NON-NULL - Returns a pointer to the allocated pool.

    Unspecified - If insufficient quota exists to complete the pool
        allocation, the return value is unspecified.

--*/

{
    return ExAllocatePoolWithQuotaTag (PoolType, NumberOfBytes, 'enoN');
}


PVOID
ExAllocatePoolWithQuotaTag (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type,
    returns a pointer to the allocated block, and if the binary buddy
    allocator was used to satisfy the request, charges pool quota to the
    current process.  This function is used to access both the
    page-aligned pools, and the binary buddy.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate binary buddy pool, then the
    page-aligned pool allocator is used.  The allocated block will be
    page-aligned and a page-sized multiple.  No quota is charged to the
    current process if this is the case.

    Otherwise, the appropriate binary buddy pool is used.  The allocated
    block will be 64-bit aligned, but will not be page aligned.  After
    the allocation completes, an attempt will be made to charge pool
    quota (of the appropriate type) to the current process object.  If
    the quota charge succeeds, then the pool block's header is adjusted
    to point to the current process.  The process object is not
    dereferenced until the pool is deallocated and the appropriate
    amount of quota is returned to the process.  Otherwise, the pool is
    deallocated, a "quota exceeded" condition is raised.

Arguments:

    PoolType - Supplies the type of pool to allocate.  If the pool type
        is one of the "MustSucceed" pool types and sufficient quota
        exists, then this call will always succeed and return a pointer
        to allocated pool.  Otherwise, if the system cannot allocate
        the requested amount of memory a STATUS_INSUFFICIENT_RESOURCES
        status is raised.

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NON-NULL - Returns a pointer to the allocated pool.

    Unspecified - If insufficient quota exists to complete the pool
        allocation, the return value is unspecified.

--*/

{
    PVOID p;
    PEPROCESS Process;
    PPOOL_HEADER Entry;
    LOGICAL IgnoreQuota;
    LOGICAL RaiseOnQuotaFailure;
    NTSTATUS Status;

    IgnoreQuota = FALSE;
    RaiseOnQuotaFailure = TRUE;

    if (PoolType & POOL_QUOTA_FAIL_INSTEAD_OF_RAISE) {
        RaiseOnQuotaFailure = FALSE;
        PoolType &= ~POOL_QUOTA_FAIL_INSTEAD_OF_RAISE;
    }

    if ((POOL_QUOTA_ENABLED == FALSE)
#if i386 && !FPO
            || (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB)
#endif // i386 && !FPO
       ) {
        IgnoreQuota = TRUE;
    }
    else {
        PoolType = (POOL_TYPE)((UCHAR)PoolType + POOL_QUOTA_MASK);
    }

    p = ExAllocatePoolWithTag (PoolType, NumberOfBytes, Tag);

    //
    // Note - NULL is page aligned.
    //

    if (!PAGE_ALIGNED(p) && !IgnoreQuota) {

        if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) &&
            (MmIsSpecialPoolAddress (p))) {
            return p;
        }

        Entry = (PPOOL_HEADER)((PCH)p - POOL_OVERHEAD);

        Process = PsGetCurrentProcess();

        Entry->ProcessBilled = NULL;

        if (Process != PsInitialSystemProcess) {

            Status = PsChargeProcessPoolQuota (Process,
                                 PoolType & BASE_POOL_TYPE_MASK,
                                 (ULONG)(Entry->BlockSize << POOL_BLOCK_SHIFT));


            if (!NT_SUCCESS(Status)) {

                //
                // Back out the allocation.
                //

                ExFreePoolWithTag (p, Tag);

                if (RaiseOnQuotaFailure) {
                    ExRaiseStatus (Status);
                }
                return NULL;
            }

            ObReferenceObject (Process);
            Entry->ProcessBilled = Process;
        }
    }
    else {
        if ((p == NULL) && (RaiseOnQuotaFailure)) {
            ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    return p;
}

VOID
ExInsertPoolTag (
    ULONG Tag,
    PVOID Va,
    SIZE_T NumberOfBytes,
    POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function inserts a pool tag in the tag table and increments the
    number of allocates and updates the total allocation size.

    This function also inserts the pool tag in the big page tag table.

    N.B. This function is for use by memory management ONLY.

Arguments:

    Tag - Supplies the tag used to insert an entry in the tag table.

    Va - Supplies the allocated virtual address.

    NumberOfBytes - Supplies the allocation size in bytes.

    PoolType - Supplies the pool type.

Return Value:

    None.

Environment:

    No pool locks held so pool may be freely allocated here as needed.

--*/

{
    ULONG NumberOfPages;

#if !DBG
    UNREFERENCED_PARAMETER (PoolType);
#endif

    ASSERT ((PoolType & SESSION_POOL_MASK) == 0);

    if ((PoolBigPageTable) && (NumberOfBytes >= PAGE_SIZE)) {

        NumberOfPages = BYTES_TO_PAGES(NumberOfBytes);

        if (ExpAddTagForBigPages((PVOID)Va, Tag, NumberOfPages) == FALSE) {
            Tag = ' GIB';
        }
    }

    if (PoolTrackTable != NULL) {
        ExpInsertPoolTracker (Tag, NumberOfBytes, NonPagedPool);
    }
}

VOID
ExRemovePoolTag (
    ULONG Tag,
    PVOID Va,
    SIZE_T NumberOfBytes
    )

/*++

Routine Description:

    This function removes a pool tag from the tag table and increments the
    number of frees and updates the total allocation size.

    This function also removes the pool tag from the big page tag table.

    N.B. This function is for use by memory management ONLY.

Arguments:

    Tag - Supplies the tag used to remove an entry in the tag table.

    Va - Supplies the allocated virtual address.

    NumberOfBytes - Supplies the allocation size in bytes.

Return Value:

    None.

Environment:

    No pool locks held so pool may be freely allocated here as needed.

--*/

{
    ULONG BigPages;

    if ((PoolBigPageTable) && (NumberOfBytes >= PAGE_SIZE)) {
        ExpFindAndRemoveTagBigPages (Va, &BigPages);
    }

    if (PoolTrackTable != NULL) {
        ExpRemovePoolTracker(Tag, (ULONG)NumberOfBytes, NonPagedPool);
    }
}


VOID
ExpInsertPoolTracker (
    IN ULONG Key,
    IN SIZE_T Size,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function inserts a pool tag in the tag table and increments the
    number of allocates and updates the total allocation size.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    Size - Supplies the allocation size.

    PoolType - Supplies the pool type.

Return Value:

    None.

Environment:

    No pool locks held so pool may be freely allocated here as needed.

--*/

{
    ULONG Hash;
    ULONG OriginalKey;
    ULONG OriginalHash;
    ULONG Index;
    KIRQL OldIrql;
    KLOCK_QUEUE_HANDLE LockHandle;
    ULONG BigPages;
    LOGICAL HashedIt;
    SIZE_T NewSize;
    SIZE_T SizeInBytes;
    SIZE_T NewSizeInBytes;
    SIZE_T NewSizeMask;
    PPOOL_TRACKER_TABLE OldTable;
    PPOOL_TRACKER_TABLE NewTable;

    //
    // Ignore protected pool bit except for returned hash index.
    //

    Key &= ~PROTECTED_POOL;

    if (Key == PoolHitTag) {
        DbgBreakPoint();
    }

retry:

    //
    // Compute hash index and search for pool tag.
    //

    Hash = POOLTAG_HASH(Key);

    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);

    Hash &= (ULONG)PoolTrackTableMask;

    Index = Hash;

    do {
        if (PoolTrackTable[Hash].Key == Key) {
            goto EntryFound;
        }

        if (PoolTrackTable[Hash].Key == 0 && Hash != PoolTrackTableSize - 1) {
            PoolTrackTable[Hash].Key = Key;
            goto EntryFound;
        }

        Hash = (Hash + 1) & (ULONG)PoolTrackTableMask;
    } while (Hash != Index);

    //
    // No matching entry and no free entry was found.
    // If the overflow bucket has been used then expansion of the tracker table
    // is not allowed because a subsequent free of a tag can go negative as the
    // original allocation is in overflow and a newer allocation may be
    // distinct.
    //

    NewSize = ((PoolTrackTableSize - 1) << 1) + 1;
    NewSizeInBytes = NewSize * sizeof(POOL_TRACKER_TABLE);

    SizeInBytes = PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE);

    if ((NewSizeInBytes > SizeInBytes) &&
        (PoolTrackTable[PoolTrackTableSize - 1].Key == 0)) {

        ExpLockNonPagedPool(LockHandle.OldIrql);

        NewTable = MiAllocatePoolPages (NonPagedPool, NewSizeInBytes, FALSE);

        ExpUnlockNonPagedPool(LockHandle.OldIrql);

        if (NewTable != NULL) {

            OldTable = (PVOID)PoolTrackTable;

            RtlZeroMemory ((PVOID)NewTable, NewSizeInBytes);

            //
            // Rehash all the entries into the new table.
            //

            NewSizeMask = NewSize - 2;

            for (OriginalHash = 0; OriginalHash < PoolTrackTableSize; OriginalHash += 1) {
                OriginalKey = PoolTrackTable[OriginalHash].Key;

                if (OriginalKey == 0) {
                    continue;
                }

                Hash = (ULONG) (POOLTAG_HASH(OriginalKey) & (ULONG)NewSizeMask);
                Index = Hash;

                HashedIt = FALSE;
                do {
                    if (NewTable[Hash].Key == 0 && Hash != NewSize - 1) {
                        RtlCopyMemory ((PVOID)&NewTable[Hash],
                                       (PVOID)&PoolTrackTable[OriginalHash],
                                       sizeof(POOL_TRACKER_TABLE));
                        HashedIt = TRUE;
                        break;
                    }

                    Hash = (Hash + 1) & (ULONG)NewSizeMask;
                } while (Hash != Index);

                //
                // No matching entry and no free entry was found, have to bail.
                //

                if (HashedIt == FALSE) {
                    KdPrint(("POOL:rehash of track table failed (%p, %p, %p %p)\n",
                        OldTable,
                        PoolTrackTableSize,
                        NewTable,
                        OriginalKey));

                    ExpLockNonPagedPool(LockHandle.OldIrql);

                    MiFreePoolPages (NewTable);

                    ExpUnlockNonPagedPool(LockHandle.OldIrql);

                    goto overflow;
                }
            }

            PoolTrackTable = NewTable;
            PoolTrackTableSize = NewSize;
            PoolTrackTableMask = NewSizeMask;

            ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

            ExpLockNonPagedPool(LockHandle.OldIrql);

            BigPages = MiFreePoolPages (OldTable);

            ExpUnlockNonPagedPool(LockHandle.OldIrql);

            ExpRemovePoolTracker ('looP',
                                  BigPages * PAGE_SIZE,
                                  NonPagedPool);

            ExpInsertPoolTracker ('looP',
                                  (ULONG) ROUND_TO_PAGES(NewSizeInBytes),
                                  NonPagedPool);

            goto retry;
        }
    }

overflow:

    //
    // Use the very last entry as a bit bucket for overflows.
    //

    Hash = (ULONG)PoolTrackTableSize - 1;

    PoolTrackTable[Hash].Key = 'lfvO';

    //
    // Update pool tracker table entry.
    //

EntryFound:

    if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
        PoolTrackTable[Hash].PagedAllocs += 1;
        PoolTrackTable[Hash].PagedBytes += Size;

    }
    else {
        PoolTrackTable[Hash].NonPagedAllocs += 1;
        PoolTrackTable[Hash].NonPagedBytes += Size;
    }
    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

    return;
}


VOID
ExpRemovePoolTracker (
    IN ULONG Key,
    IN ULONG Size,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function increments the number of frees and updates the total
    allocation size.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    Size - Supplies the allocation size.

    PoolType - Supplies the pool type.

Return Value:

    None.

--*/

{
    ULONG Hash;
    ULONG Index;
    KIRQL OldIrql;

    //
    // Ignore protected pool bit
    //

    Key &= ~PROTECTED_POOL;
    if (Key == PoolHitTag) {
        DbgBreakPoint();
    }

    //
    // Compute hash index and search for pool tag.
    //

    Hash = POOLTAG_HASH(Key);

    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);

    Hash &= (ULONG)PoolTrackTableMask;

    Index = Hash;

    do {
        if (PoolTrackTable[Hash].Key == Key) {
            goto EntryFound;
        }

        if (PoolTrackTable[Hash].Key == 0 && Hash != PoolTrackTableSize - 1) {
            KdPrint(("POOL: Unable to find tracker %lx, table corrupted\n", Key));
            ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
            return;
        }

        Hash = (Hash + 1) & (ULONG)PoolTrackTableMask;
    } while (Hash != Index);

    //
    // No matching entry and no free entry was found.
    //

    Hash = (ULONG)PoolTrackTableSize - 1;

    //
    // Update pool tracker table entry.
    //

EntryFound:

    if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
        PoolTrackTable[Hash].PagedBytes -= Size;
        PoolTrackTable[Hash].PagedFrees += 1;

    }
    else {
        PoolTrackTable[Hash].NonPagedBytes -= Size;
        PoolTrackTable[Hash].NonPagedFrees += 1;
    }

    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

    return;
}


LOGICAL
ExpAddTagForBigPages (
    IN PVOID Va,
    IN ULONG Key,
    IN ULONG NumberOfPages
    )
/*++

Routine Description:

    This function inserts a pool tag in the big page tag table.

Arguments:

    Va - Supplies the allocated virtual address.

    Key - Supplies the key value used to locate a matching entry in the
        tag table.

    NumberOfPages - Supplies the number of pages that were allocated.

Return Value:

    TRUE if an entry was allocated, FALSE if not.

Environment:

    No pool locks held so the table may be freely expanded here as needed.

--*/
{
    ULONG i;
    ULONG Hash;
    ULONG BigPages;
    PVOID OldTable;
    LOGICAL Inserted;
    KIRQL OldIrql;
    KLOCK_QUEUE_HANDLE LockHandle;
    SIZE_T SizeInBytes;
    SIZE_T NewSizeInBytes;
    PPOOL_TRACKER_BIG_PAGES NewTable;
    PPOOL_TRACKER_BIG_PAGES p;

    //
    // The low bit of the address is set to indicate a free entry.  The high
    // bit cannot be used because in some configurations the high bit is not
    // set for all kernelmode addresses.
    //

    ASSERT (((ULONG_PTR)Va & POOL_BIG_TABLE_ENTRY_FREE) == 0);

retry:

    Inserted = TRUE;
    Hash = (ULONG)(((ULONG_PTR)Va >> PAGE_SHIFT) & PoolBigPageTableHash);
    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);
    while (((ULONG_PTR)PoolBigPageTable[Hash].Va & POOL_BIG_TABLE_ENTRY_FREE) == 0) {
        Hash += 1;
        if (Hash >= PoolBigPageTableSize) {
            if (!Inserted) {

                //
                // Try to expand the tracker table.
                //

                SizeInBytes = PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES);
                NewSizeInBytes = (SizeInBytes << 1);

                if (NewSizeInBytes > SizeInBytes) {

                    ExpLockNonPagedPool(LockHandle.OldIrql);

                    NewTable = MiAllocatePoolPages (NonPagedPool,
                                                    NewSizeInBytes,
                                                    FALSE);

                    ExpUnlockNonPagedPool(LockHandle.OldIrql);

                    if (NewTable != NULL) {

                        OldTable = (PVOID)PoolBigPageTable;

                        RtlCopyMemory ((PVOID)NewTable,
                                       OldTable,
                                       SizeInBytes);

                        RtlZeroMemory ((PVOID)(NewTable + PoolBigPageTableSize),
                                       NewSizeInBytes - SizeInBytes);

                        //
                        // Mark all the new entries as free.  Note this loop
                        // uses the fact that the table size always doubles.
                        //

                        i = (ULONG)PoolBigPageTableSize;
                        p = &NewTable[i];
                        for (i = 0; i < PoolBigPageTableSize; i += 1, p += 1) {
                            p->Va = (PVOID) POOL_BIG_TABLE_ENTRY_FREE;
                        }

                        PoolBigPageTable = NewTable;
                        PoolBigPageTableSize <<= 1;
                        PoolBigPageTableHash = PoolBigPageTableSize - 1;

                        ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

                        ExpLockNonPagedPool(LockHandle.OldIrql);

                        BigPages = MiFreePoolPages (OldTable);

                        ExpUnlockNonPagedPool(LockHandle.OldIrql);

                        ExpRemovePoolTracker ('looP',
                                              BigPages * PAGE_SIZE,
                                              NonPagedPool);

                        ExpInsertPoolTracker ('looP',
                                              (ULONG) ROUND_TO_PAGES(NewSizeInBytes),
                                              NonPagedPool);

                        goto retry;
                    }
                }

                if (!FirstPrint) {
                    KdPrint(("POOL:unable to insert big page slot %lx\n",Key));
                    FirstPrint = TRUE;
                }

                ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
                return FALSE;
            }

            Hash = 0;
            Inserted = FALSE;
        }
    }

    p = &PoolBigPageTable[Hash];

    ASSERT (((ULONG_PTR)p->Va & POOL_BIG_TABLE_ENTRY_FREE) != 0);
    ASSERT (((ULONG_PTR)Va & POOL_BIG_TABLE_ENTRY_FREE) == 0);

    p->Va = Va;
    p->Key = Key;
    p->NumberOfPages = NumberOfPages;

    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

    return TRUE;
}


ULONG
ExpFindAndRemoveTagBigPages (
    IN PVOID Va,
    IN PULONG BigPages
    )

{
    ULONG Hash;
    LOGICAL Inserted;
    KIRQL OldIrql;
    ULONG ReturnKey;

    Inserted = TRUE;
    Hash = (ULONG)(((ULONG_PTR)Va >> PAGE_SHIFT) & PoolBigPageTableHash);
    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);
    while (PoolBigPageTable[Hash].Va != Va) {
        Hash += 1;
        if (Hash >= PoolBigPageTableSize) {
            if (!Inserted) {
                if (!FirstPrint) {
                    KdPrint(("POOL:unable to find big page slot %lx\n",Va));
                    FirstPrint = TRUE;
                }

                ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
                *BigPages = 0;
                return ' GIB';
            }

            Hash = 0;
            Inserted = FALSE;
        }
    }

    ASSERT (((ULONG_PTR)Va & POOL_BIG_TABLE_ENTRY_FREE) == 0);
    PoolBigPageTable[Hash].Va =
        (PVOID)((ULONG_PTR)PoolBigPageTable[Hash].Va | POOL_BIG_TABLE_ENTRY_FREE);

    *BigPages = PoolBigPageTable[Hash].NumberOfPages;
    ReturnKey = PoolBigPageTable[Hash].Key;
    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
    return ReturnKey;
}

const char ExpProtectedPoolBlockMessage[] =
    "EX: Invalid attempt to free protected pool block %x (%c%c%c%c)\n";

VOID
ExFreePoolWithTag (
    IN PVOID P,
    IN ULONG TagToFree
    )

/*++

Routine Description:

    This function deallocates a block of pool. This function is used to
    deallocate to both the page aligned pools and the buddy (less than
    a page) pools.

    If the address of the block being deallocated is page-aligned, then
    the page-aligned pool deallocator is used.

    Otherwise, the binary buddy pool deallocator is used.  Deallocation
    looks at the allocated block's pool header to determine the pool
    type and block size being deallocated.  If the pool was allocated
    using ExAllocatePoolWithQuota, then after the deallocation is
    complete, the appropriate process's pool quota is adjusted to reflect
    the deallocation, and the process object is dereferenced.

Arguments:

    P - Supplies the address of the block of pool being deallocated.

    TagToFree - Supplies the tag of the block being freed.

Return Value:

    None.

--*/

{
    PVOID OldValue;
    POOL_TYPE CheckType;
    PPOOL_HEADER Entry;
    ULONG BlockSize;
    KLOCK_QUEUE_HANDLE LockHandle;
    PPOOL_HEADER NextEntry;
    POOL_TYPE PoolType;
    POOL_TYPE EntryPoolType;
    PPOOL_DESCRIPTOR PoolDesc;
    PEPROCESS ProcessBilled;
    LOGICAL Combined;
    ULONG BigPages;
    SIZE_T NumberOfBytes;
    ULONG Tag;
    PKPRCB Prcb;
    PGENERAL_LOOKASIDE LookasideList;

    PERFINFO_FREEPOOL(P);

    //
    // Initializing LockHandle is not needed for correctness but without
    // it the compiler cannot compile this code W4 to check for use of
    // uninitialized variables.
    //

    LockHandle.OldIrql = 0;

    if (ExpPoolFlags & (EX_CHECK_POOL_FREES_FOR_ACTIVE_TIMERS |
                        EX_CHECK_POOL_FREES_FOR_ACTIVE_WORKERS |
                        EX_CHECK_POOL_FREES_FOR_ACTIVE_RESOURCES |
                        EX_KERNEL_VERIFIER_ENABLED |
                        EX_VERIFIER_DEADLOCK_DETECTION_ENABLED |
                        EX_SPECIAL_POOL_ENABLED)) {

        if (ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) {

            if (MmIsSpecialPoolAddress (P)) {

                if (ExpPoolFlags & EX_VERIFIER_DEADLOCK_DETECTION_ENABLED) {
                    VerifierDeadlockFreePool (P, PAGE_SIZE);
                }

                MmFreeSpecialPool (P);

                return;
            }
        }

        if (!PAGE_ALIGNED(P)) {

            Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);

            ASSERT_POOL_NOT_FREE(Entry);

            PoolType = (Entry->PoolType & POOL_TYPE_MASK) - 1;

            CheckType = PoolType & BASE_POOL_TYPE_MASK;

            ASSERT_FREE_IRQL(PoolType, P);

            ASSERT_POOL_TYPE_NOT_ZERO(Entry);

            if (!IS_POOL_HEADER_MARKED_ALLOCATED(Entry)) {
                KeBugCheckEx (BAD_POOL_CALLER,
                              7,
                              __LINE__,
                              (ULONG_PTR)Entry->Ulong1,
                              (ULONG_PTR)P);
            }

            NumberOfBytes = (SIZE_T)Entry->BlockSize << POOL_BLOCK_SHIFT;

            if (ExpPoolFlags & EX_VERIFIER_DEADLOCK_DETECTION_ENABLED) {
                VerifierDeadlockFreePool (P, NumberOfBytes);
            }

            if (Entry->PoolType & POOL_VERIFIER_MASK) {
                VerifierFreeTrackedPool (P,
                                         NumberOfBytes,
                                         CheckType,
                                         FALSE);
            }

            //
            // Check if an ERESOURCE is currently active in this memory block.
            //

            FREE_CHECK_ERESOURCE (Entry, NumberOfBytes);

            //
            // Check if a KTIMER is currently active in this memory block.
            //

            FREE_CHECK_KTIMER (Entry, NumberOfBytes);

            //
            // Look for work items still queued.
            //

            FREE_CHECK_WORKER (Entry, NumberOfBytes);
        }
    }

    //
    // If the entry is page aligned, then free the block to the page aligned
    // pool.  Otherwise, free the block to the allocation lists.
    //

    if (PAGE_ALIGNED(P)) {

        PoolType = MmDeterminePoolType(P);

        ASSERT_FREE_IRQL(PoolType, P);

        CheckType = PoolType & BASE_POOL_TYPE_MASK;

        if (PoolType == PagedPoolSession) {
            PoolDesc = ExpSessionPoolDescriptor;
        }
        else {
            PoolDesc = PoolVector[PoolType];
        }

        if ((PoolTrackTable != NULL) && (PoolType != PagedPoolSession)) {

            Tag = ExpFindAndRemoveTagBigPages (P, &BigPages);

            if (Tag & PROTECTED_POOL) {
                Tag &= ~PROTECTED_POOL;
                TagToFree &= ~PROTECTED_POOL;
                if (Tag != TagToFree) {
                    DbgPrint ((char*)ExpProtectedPoolBlockMessage,
                              P,
                              Tag,
                              Tag >> 8,
                              Tag >> 16,
                              Tag >> 24);
                    DbgBreakPoint ();
                }
            }

            ExpRemovePoolTracker (Tag, BigPages * PAGE_SIZE, PoolType);
        }

        LOCK_POOL(PoolDesc, LockHandle);

        PoolDesc->RunningDeAllocs += 1;

        //
        // Large session pool allocations are accounted for directly by
        // the memory manager so no need to call MiSessionPoolFreed here.
        //

        BigPages = MiFreePoolPages (P);

        if (ExpPoolFlags & (EX_CHECK_POOL_FREES_FOR_ACTIVE_TIMERS |
                            EX_CHECK_POOL_FREES_FOR_ACTIVE_WORKERS |
                            EX_CHECK_POOL_FREES_FOR_ACTIVE_RESOURCES |
                            EX_VERIFIER_DEADLOCK_DETECTION_ENABLED)) {

            NumberOfBytes = (SIZE_T)BigPages << PAGE_SHIFT;

            if (ExpPoolFlags & EX_VERIFIER_DEADLOCK_DETECTION_ENABLED) {
                VerifierDeadlockFreePool (P, NumberOfBytes);
            }

            //
            // Check if an ERESOURCE is currently active in this memory block.
            //

            FREE_CHECK_ERESOURCE (P, NumberOfBytes);

            //
            // Check if a KTIMER is currently active in this memory block.
            //

            FREE_CHECK_KTIMER (P, NumberOfBytes);

            //
            // Search worker queues for work items still queued.
            //

            FREE_CHECK_WORKER (P, NumberOfBytes);
        }

        PoolDesc->TotalBigPages -= BigPages;

        UNLOCK_POOL(PoolDesc, LockHandle);

        return;
    }

    //
    // Align the entry address to a pool allocation boundary.
    //

    Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);

    BlockSize = Entry->BlockSize;

    EntryPoolType = Entry->PoolType;

    PoolType = (Entry->PoolType & POOL_TYPE_MASK) - 1;

    CheckType = PoolType & BASE_POOL_TYPE_MASK;

    ASSERT_POOL_NOT_FREE (Entry);

    ASSERT_FREE_IRQL (PoolType, P);

    ASSERT_POOL_TYPE_NOT_ZERO (Entry);

    if (!IS_POOL_HEADER_MARKED_ALLOCATED(Entry)) {
        KeBugCheckEx (BAD_POOL_CALLER,
                      7,
                      __LINE__,
                      (ULONG_PTR)Entry->Ulong1,
                      (ULONG_PTR)P);
    }

    PoolDesc = PoolVector[CheckType];

    MARK_POOL_HEADER_FREED (Entry);

    if (EntryPoolType & SESSION_POOL_MASK) {

        if (CheckType == PagedPool) {
            PoolDesc = ExpSessionPoolDescriptor;
        }
        else if (ExpNumberOfNonPagedPools > 1) {
            PoolDesc = ExpNonPagedPoolDescriptor[DECODE_POOL_INDEX(Entry)];
        }

        //
        // All session space allocations have an index of 0 unless there
        // are multiple nonpaged (session) pools.
        //

        ASSERT ((DECODE_POOL_INDEX(Entry) == 0) || (ExpNumberOfNonPagedPools > 1));

        //
        // This allocation was in session space, let the memory
        // manager know to delete it so it won't be considered in use on
        // session exit.
        //

        MiSessionPoolFreed (P,
                            BlockSize << POOL_BLOCK_SHIFT,
                            CheckType);
    }
    else if (CheckType == PagedPool) {
        ASSERT ((DECODE_POOL_INDEX(Entry) != 0) &&
                (DECODE_POOL_INDEX(Entry) <= ExpNumberOfPagedPools));
        PoolDesc = ExpPagedPoolDescriptor[DECODE_POOL_INDEX(Entry)];
    }
    else {
        ASSERT ((DECODE_POOL_INDEX(Entry) == 0) || (ExpNumberOfNonPagedPools > 1));
        if (ExpNumberOfNonPagedPools > 1) {
            PoolDesc = ExpNonPagedPoolDescriptor[DECODE_POOL_INDEX(Entry)];
        }
    }

    //
    // If pool tagging is enabled, then update the pool tracking database.
    // Otherwise, check to determine if quota was charged when the pool
    // block was allocated.
    //

#if defined (_WIN64)

    Tag = Entry->PoolTag;
    if (Tag & PROTECTED_POOL) {
        Tag &= ~PROTECTED_POOL;
        TagToFree &= ~PROTECTED_POOL;
        if (Tag != TagToFree) {
            DbgPrint ((char*)ExpProtectedPoolBlockMessage,
                      P,
                      Tag,
                      Tag >> 8,
                      Tag >> 16,
                      Tag >> 24);
            DbgBreakPoint ();
        }
    }
    if (PoolTrackTable != NULL) {
        if ((EntryPoolType & SESSION_POOL_MASK) == 0) {
            ExpRemovePoolTracker (Tag,
                                  BlockSize << POOL_BLOCK_SHIFT,
                                  PoolType);
        }
    }

#else

    if (PoolTrackTable != NULL) {
        Tag = Entry->PoolTag;
        if (Tag & PROTECTED_POOL) {
            Tag &= ~PROTECTED_POOL;
            TagToFree &= ~PROTECTED_POOL;
            if (Tag != TagToFree) {
                DbgPrint ((char*)ExpProtectedPoolBlockMessage,
                          P,
                          Tag,
                          Tag >> 8,
                          Tag >> 16,
                          Tag >> 24);
                DbgBreakPoint ();
            }
        }
        if ((EntryPoolType & SESSION_POOL_MASK) == 0) {
            ExpRemovePoolTracker (Tag,
                                  BlockSize << POOL_BLOCK_SHIFT,
                                  PoolType);
        }
        EntryPoolType &= ~POOL_QUOTA_MASK;
    }

#endif

    if (EntryPoolType & POOL_QUOTA_MASK) {
        ProcessBilled = Entry->ProcessBilled;
        if (ProcessBilled != NULL) {
            PsReturnPoolQuota (ProcessBilled,
                               PoolType & BASE_POOL_TYPE_MASK,
                               BlockSize << POOL_BLOCK_SHIFT);
            ObDereferenceObject (ProcessBilled);
        }
    }

    //
    // If the pool block is a small block, then attempt to free the block
    // to the single entry lookaside list. If the free attempt fails, then
    // free the block by merging it back into the pool data structures.
    //

    if ((BlockSize <= POOL_SMALL_LISTS) &&
        ((EntryPoolType & SESSION_POOL_MASK) == 0) &&
        (USING_HOT_COLD_METRICS == 0)) {

        //
        // Attempt to free the small block to a per processor lookaside list.
        //

        Prcb = KeGetCurrentPrcb ();

        if (CheckType == PagedPool) {

            //
            // Only free the small block to the current processor's
            // lookaside list if the block is local to this node.
            //

            if (KeNumberNodes > 1) {
                if (Prcb->ParentNode->Color != PoolDesc->PoolIndex - 1) {
                    goto NoLookaside;
                }
            }

            LookasideList = Prcb->PPPagedLookasideList[BlockSize - 1].P;
            LookasideList->TotalFrees += 1;

            CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, P);

            if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
                LookasideList->FreeHits += 1;
                InterlockedPushEntrySList (&LookasideList->ListHead,
                                           (PSINGLE_LIST_ENTRY)P);

                CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, P);

                return;
            }

            LookasideList = Prcb->PPPagedLookasideList[BlockSize - 1].L;
            LookasideList->TotalFrees += 1;

            CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, P);

            if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
                LookasideList->FreeHits += 1;
                InterlockedPushEntrySList (&LookasideList->ListHead,
                                           (PSINGLE_LIST_ENTRY)P);

                CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, P);

                return;
            }

        }
        else {

            //
            // Only free the small block to the current processor's
            // lookaside list if the block is local to this node.
            //

            if (KeNumberNodes > 1) {
                if (Prcb->ParentNode->Color != PoolDesc->PoolIndex) {
                    goto NoLookaside;
                }
            }

            LookasideList = Prcb->PPNPagedLookasideList[BlockSize - 1].P;
            LookasideList->TotalFrees += 1;

            CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, P);

            if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
                LookasideList->FreeHits += 1;
                InterlockedPushEntrySList (&LookasideList->ListHead,
                                           (PSINGLE_LIST_ENTRY)P);

                CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, P);

                return;

            }

            LookasideList = Prcb->PPNPagedLookasideList[BlockSize - 1].L;
            LookasideList->TotalFrees += 1;

            CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, P);

            if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
                LookasideList->FreeHits += 1;
                InterlockedPushEntrySList (&LookasideList->ListHead,
                                           (PSINGLE_LIST_ENTRY)P);

                CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, P);

                return;
            }
        }
    }

NoLookaside:

    //
    // If the pool block release can be queued so the pool mutex/spinlock
    // acquisition/release can be amortized then do so.  Note "hot" blocks
    // are generally in the lookasides above to provide fast reuse to take
    // advantage of hardware caching.
    //

    if (ExpPoolFlags & EX_DELAY_POOL_FREES) {

        if (PoolDesc->PendingFreeDepth >= EXP_MAXIMUM_POOL_FREES_PENDING) {
            ExDeferredFreePool (PoolDesc);
        }

        //
        // Push this entry on the deferred list.
        //

        do {

            OldValue = PoolDesc->PendingFrees;
            ((PSINGLE_LIST_ENTRY)P)->Next = OldValue;

        } while (InterlockedCompareExchangePointer (
                        &PoolDesc->PendingFrees,
                        P,
                        OldValue) != OldValue);

        InterlockedIncrement (&PoolDesc->PendingFreeDepth);

        return;
    }

    Combined = FALSE;

    LOCK_POOL(PoolDesc, LockHandle);

    CHECK_POOL_HEADER(__LINE__, Entry);

    PoolDesc->RunningDeAllocs += 1;

    //
    // Free the specified pool block.
    //
    // Check to see if the next entry is free.
    //

    ASSERT (BlockSize == Entry->BlockSize);

    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + BlockSize);
    if (PAGE_END(NextEntry) == FALSE) {

        if (NextEntry->PoolType == 0) {

            //
            // This block is free, combine with the released block.
            //

            Combined = TRUE;

            //
            // If the split pool block contains only a header, then
            // it was not inserted and therefore cannot be removed.
            //
            // Note if the minimum pool block size is bigger than the
            // header then there can be no blocks like this.
            //

            if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
                (NextEntry->BlockSize != 1)) {

                CHECK_LIST(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink));
                CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink));
            }

            Entry->BlockSize = Entry->BlockSize + NextEntry->BlockSize;
        }
    }

    //
    // Check to see if the previous entry is free.
    //

    if (Entry->PreviousSize != 0) {
        NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry - Entry->PreviousSize);
        if (NextEntry->PoolType == 0) {

            //
            // This block is free, combine with the released block.
            //

            Combined = TRUE;

            //
            // If the split pool block contains only a header, then
            // it was not inserted and therefore cannot be removed.
            //
            // Note if the minimum pool block size is bigger than the
            // header then there can be no blocks like this.
            //

            if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
                (NextEntry->BlockSize != 1)) {

                CHECK_LIST(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink));
                CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink));
            }

            NextEntry->BlockSize = NextEntry->BlockSize + Entry->BlockSize;
            Entry = NextEntry;
        }
    }

    //
    // If the block being freed has been combined into a full page,
    // then return the free page to memory management.
    //

    if (PAGE_ALIGNED(Entry) &&
        (PAGE_END((PPOOL_BLOCK)Entry + Entry->BlockSize) != FALSE)) {

        PoolDesc->TotalPages -= 1;

        //
        // If the pool type is paged pool, then the global paged pool mutex
        // must be held during the free of the pool pages.
        //

        if ((PoolDesc->PoolType & BASE_POOL_TYPE_MASK) == NonPagedPool) {
            if (ExpNumberOfNonPagedPools > 1) {
                KeReleaseInStackQueuedSpinLock (&LockHandle);
                ExpLockNonPagedPool (LockHandle.OldIrql);
            }
        }
        else {
            if ((EntryPoolType & SESSION_POOL_MASK) == 0) {
                ExReleaseFastMutex ((PFAST_MUTEX)PoolDesc->LockAddress);
                ExAcquireFastMutex (ExpPagedPoolMutex);
            }
        }

        PERFINFO_FREEPOOLPAGE(CheckType, Entry->PoolIndex, Entry, PoolDesc);

        MiFreePoolPages (Entry);

        if ((PoolDesc->PoolType & BASE_POOL_TYPE_MASK) == NonPagedPool) {
            ExpUnlockNonPagedPool (LockHandle.OldIrql);
        }
        else if ((EntryPoolType & SESSION_POOL_MASK) == 0) {
            ExReleaseFastMutex (ExpPagedPoolMutex);
        }
        else {
            ExReleaseFastMutex ((PFAST_MUTEX)PoolDesc->LockAddress);
        }
    }
    else {

        //
        // Insert this element into the list.
        //

        Entry->PoolType = 0;
        BlockSize = Entry->BlockSize;

        ASSERT (BlockSize != 1);

        //
        // If the freed block was combined with any other block, then
        // adjust the size of the next block if necessary.
        //

        if (Combined != FALSE) {

            //
            // The size of this entry has changed, if this entry is
            // not the last one in the page, update the pool block
            // after this block to have a new previous allocation size.
            //

            NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + BlockSize);
            if (PAGE_END(NextEntry) == FALSE) {
                NextEntry->PreviousSize = (USHORT) BlockSize;
            }
        }

        //
        // Always insert at the head in hopes of reusing cache lines.
        //

        PrivateInsertHeadList (&PoolDesc->ListHeads[BlockSize - 1],
                               ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));

        CHECK_LIST(((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));

        UNLOCK_POOL(PoolDesc, LockHandle);
    }
}

VOID
ExFreePool (
    IN PVOID P
    )
{
    ExFreePoolWithTag(P, 0);
    return;
}


VOID
ExDeferredFreePool (
     IN PPOOL_DESCRIPTOR PoolDesc
     )

/*++

Routine Description:

    This routine frees a number of pool allocations at once to amortize the
    synchronization overhead cost.

Arguments:

    PoolDesc - Supplies the relevant pool descriptor.

Return Value:

    None.

Environment:

    Kernel mode.  May be as high as APC_LEVEL for paged pool or DISPATCH_LEVEL
    for nonpaged pool.

--*/

{
    LONG ListCount;
    KLOCK_QUEUE_HANDLE LockHandle;
    POOL_TYPE CheckType;
    PPOOL_HEADER Entry;
    ULONG Index;
    ULONG WholePageCount;
    PPOOL_HEADER NextEntry;
    ULONG PoolIndex;
    LOGICAL Combined;
    LOGICAL GlobalSpace;
    PSINGLE_LIST_ENTRY SingleListEntry;
    PSINGLE_LIST_ENTRY NextSingleListEntry;
    PSINGLE_LIST_ENTRY FirstEntry;
    PSINGLE_LIST_ENTRY LastEntry;
    PSINGLE_LIST_ENTRY WholePages;

    GlobalSpace = TRUE;

    if (PoolDesc == ExpSessionPoolDescriptor) {
        GlobalSpace = FALSE;
    }

    CheckType = PoolDesc->PoolType & BASE_POOL_TYPE_MASK;

    //
    // Initializing LockHandle is not needed for correctness but without
    // it the compiler cannot compile this code W4 to check for use of
    // uninitialized variables.
    //

    LockHandle.OldIrql = 0;

    ListCount = 0;
    WholePages = NULL;
    WholePageCount = 0;

    LOCK_POOL(PoolDesc, LockHandle);

    if (PoolDesc->PendingFrees == NULL) {
        UNLOCK_POOL(PoolDesc, LockHandle);
        return;
    }

    //
    // Free each deferred pool entry until they're all done.
    //

    LastEntry = NULL;

    do {

        SingleListEntry = PoolDesc->PendingFrees;

        FirstEntry = SingleListEntry;

        do {

            NextSingleListEntry = SingleListEntry->Next;

            //
            // Process the deferred entry.
            //

            ListCount += 1;

            Entry = (PPOOL_HEADER)((PCHAR)SingleListEntry - POOL_OVERHEAD);

            PoolIndex = DECODE_POOL_INDEX(Entry);

            //
            // Process the block.
            //

            Combined = FALSE;

            CHECK_POOL_HEADER(__LINE__, Entry);

            PoolDesc->RunningDeAllocs += 1;

            //
            // Free the specified pool block.
            //
            // Check to see if the next entry is free.
            //

            NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
            if (PAGE_END(NextEntry) == FALSE) {

                if (NextEntry->PoolType == 0) {

                    //
                    // This block is free, combine with the released block.
                    //

                    Combined = TRUE;

                    //
                    // If the split pool block contains only a header, then
                    // it was not inserted and therefore cannot be removed.
                    //
                    // Note if the minimum pool block size is bigger than the
                    // header then there can be no blocks like this.
                    //

                    if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
                        (NextEntry->BlockSize != 1)) {

                        CHECK_LIST(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                        PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                        CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink));
                        CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink));
                    }

                    Entry->BlockSize = Entry->BlockSize + NextEntry->BlockSize;
                }
            }

            //
            // Check to see if the previous entry is free.
            //

            if (Entry->PreviousSize != 0) {
                NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry - Entry->PreviousSize);
                if (NextEntry->PoolType == 0) {

                    //
                    // This block is free, combine with the released block.
                    //

                    Combined = TRUE;

                    //
                    // If the split pool block contains only a header, then
                    // it was not inserted and therefore cannot be removed.
                    //
                    // Note if the minimum pool block size is bigger than the
                    // header then there can be no blocks like this.
                    //

                    if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
                        (NextEntry->BlockSize != 1)) {

                        CHECK_LIST(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                        PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                        CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink));
                        CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink));
                    }

                    NextEntry->BlockSize = NextEntry->BlockSize + Entry->BlockSize;
                    Entry = NextEntry;
                }
            }

            //
            // If the block being freed has been combined into a full page,
            // then return the free page to memory management.
            //

            if (PAGE_ALIGNED(Entry) &&
                (PAGE_END((PPOOL_BLOCK)Entry + Entry->BlockSize) != FALSE)) {

                ((PSINGLE_LIST_ENTRY)Entry)->Next = WholePages;
                WholePages = (PSINGLE_LIST_ENTRY) Entry;
                WholePageCount += 1;
            }
            else {

                //
                // Insert this element into the list.
                //

                Entry->PoolType = 0;
                ENCODE_POOL_INDEX(Entry, PoolIndex);
                Index = Entry->BlockSize;

                ASSERT (Index != 1);

                //
                // If the freed block was combined with any other block, then
                // adjust the size of the next block if necessary.
                //

                if (Combined != FALSE) {

                    //
                    // The size of this entry has changed, if this entry is
                    // not the last one in the page, update the pool block
                    // after this block to have a new previous allocation size.
                    //

                    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Index);
                    if (PAGE_END(NextEntry) == FALSE) {
                        NextEntry->PreviousSize = (USHORT) Index;
                    }
                }

                //
                // Always insert at the head in hopes of reusing cache lines.
                //

                PrivateInsertHeadList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));

                CHECK_LIST(((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));
            }

            //
            // March on to the next entry if there is one.
            //

            if (NextSingleListEntry == LastEntry) {
                break;
            }

            SingleListEntry = NextSingleListEntry;

        } while (TRUE);

        if ((PoolDesc->PendingFrees == FirstEntry) &&
            (InterlockedCompareExchangePointer (&PoolDesc->PendingFrees,
                                                NULL,
                                                FirstEntry) == FirstEntry)) {
            break;
        }
        LastEntry = FirstEntry;

    } while (TRUE);

    if (WholePages != NULL) {

        //
        // If the pool type is paged pool, then the global paged pool mutex
        // must be held during the free of the pool pages.  Hence any
        // full pages were batched up and are now dealt with in one go.
        //

        Entry = (PPOOL_HEADER) WholePages;

        PoolDesc->TotalPages -= WholePageCount;

        if (GlobalSpace == TRUE) {
            if ((CheckType & BASE_POOL_TYPE_MASK) == PagedPool) {
                ExReleaseFastMutex ((PFAST_MUTEX)PoolDesc->LockAddress);
                ExAcquireFastMutex (ExpPagedPoolMutex);
            }
            else if (ExpNumberOfNonPagedPools > 1) {
                KeReleaseInStackQueuedSpinLock (&LockHandle);
                ExpLockNonPagedPool (LockHandle.OldIrql);
            }
        }

        do {

            NextEntry = (PPOOL_HEADER) (((PSINGLE_LIST_ENTRY)Entry)->Next);

            PERFINFO_FREEPOOLPAGE(CheckType, PoolIndex, Entry, PoolDesc);

            MiFreePoolPages (Entry);

            Entry = NextEntry;

        } while (Entry != NULL);

        if (GlobalSpace == FALSE) {
            ExReleaseFastMutex ((PFAST_MUTEX)PoolDesc->LockAddress);
        }
        else if ((CheckType & BASE_POOL_TYPE_MASK) == PagedPool) {
            ExReleaseFastMutex (ExpPagedPoolMutex);
        }
        else {
            ExpUnlockNonPagedPool (LockHandle.OldIrql);
        }
    }
    else {
        UNLOCK_POOL(PoolDesc, LockHandle);
    }

    InterlockedExchangeAdd (&PoolDesc->PendingFreeDepth, (0 - ListCount));

    return;
}

SIZE_T
ExQueryPoolBlockSize (
    IN PVOID PoolBlock,
    OUT PBOOLEAN QuotaCharged
    )

/*++

Routine Description:

    This function returns the size of the pool block.

Arguments:

    PoolBlock - Supplies the address of the block of pool.

    QuotaCharged - Supplies a BOOLEAN variable to receive whether or not the
        pool block had quota charged.

    NOTE: If the entry is bigger than a page, the value PAGE_SIZE is returned
          rather than the correct number of bytes.

Return Value:

    Size of pool block.

--*/

{
    PPOOL_HEADER Entry;
    SIZE_T size;

    if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) &&
        (MmIsSpecialPoolAddress (PoolBlock))) {
        *QuotaCharged = FALSE;
        return MmQuerySpecialPoolBlockSize (PoolBlock);
    }

    if (PAGE_ALIGNED(PoolBlock)) {
        *QuotaCharged = FALSE;
        return PAGE_SIZE;
    }

    Entry = (PPOOL_HEADER)((PCHAR)PoolBlock - POOL_OVERHEAD);
    size = (ULONG)((Entry->BlockSize << POOL_BLOCK_SHIFT) - POOL_OVERHEAD);

#ifdef _WIN64
    *QuotaCharged = (BOOLEAN) (Entry->ProcessBilled != NULL);
#else
    if ( PoolTrackTable) {
        *QuotaCharged = FALSE;
    }
    else {
        *QuotaCharged = (BOOLEAN) (Entry->ProcessBilled != NULL);
    }
#endif
    return size;
}

VOID
ExQueryPoolUsage(
    OUT PULONG PagedPoolPages,
    OUT PULONG NonPagedPoolPages,
    OUT PULONG PagedPoolAllocs,
    OUT PULONG PagedPoolFrees,
    OUT PULONG PagedPoolLookasideHits,
    OUT PULONG NonPagedPoolAllocs,
    OUT PULONG NonPagedPoolFrees,
    OUT PULONG NonPagedPoolLookasideHits
    )

{
    ULONG Index;
    PGENERAL_LOOKASIDE Lookaside;
    PLIST_ENTRY NextEntry;
    PPOOL_DESCRIPTOR pd;

    //
    // Sum all the paged pool usage.
    //

    *PagedPoolPages = 0;
    *PagedPoolAllocs = 0;
    *PagedPoolFrees = 0;

    for (Index = 0; Index < ExpNumberOfPagedPools + 1; Index += 1) {
        pd = ExpPagedPoolDescriptor[Index];
        *PagedPoolPages += pd->TotalPages + pd->TotalBigPages;
        *PagedPoolAllocs += pd->RunningAllocs;
        *PagedPoolFrees += pd->RunningDeAllocs;
    }

    //
    // Sum all the nonpaged pool usage.
    //

    pd = &NonPagedPoolDescriptor;
    *NonPagedPoolPages = pd->TotalPages + pd->TotalBigPages;
    *NonPagedPoolAllocs = pd->RunningAllocs;
    *NonPagedPoolFrees = pd->RunningDeAllocs;

    //
    // Sum all the lookaside hits for paged and nonpaged pool.
    //

    NextEntry = ExPoolLookasideListHead.Flink;
    while (NextEntry != &ExPoolLookasideListHead) {
        Lookaside = CONTAINING_RECORD(NextEntry,
                                      GENERAL_LOOKASIDE,
                                      ListEntry);

        if (Lookaside->Type == NonPagedPool) {
            *NonPagedPoolLookasideHits += Lookaside->AllocateHits;

        }
        else {
            *PagedPoolLookasideHits += Lookaside->AllocateHits;
        }

        NextEntry = NextEntry->Flink;
    }

    return;
}


VOID
ExReturnPoolQuota (
    IN PVOID P
    )

/*++

Routine Description:

    This function returns quota charged to a subject process when the
    specified pool block was allocated.

Arguments:

    P - Supplies the address of the block of pool being deallocated.

Return Value:

    None.

--*/

{

    PPOOL_HEADER Entry;
    POOL_TYPE PoolType;
    PEPROCESS Process;

    //
    // Do nothing for special pool. No quota was charged.
    //

    if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) &&
        (MmIsSpecialPoolAddress (P))) {
        return;
    }

    //
    // Align the entry address to a pool allocation boundary.
    //

    Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);

    //
    // If quota was charged, then return the appropriate quota to the
    // subject process.
    //

    if ((Entry->PoolType & POOL_QUOTA_MASK) && POOL_QUOTA_ENABLED) {

        PoolType = (Entry->PoolType & POOL_TYPE_MASK) - 1;

        Entry->PoolType &= ~POOL_QUOTA_MASK;

        Process = Entry->ProcessBilled;

        if (Process != NULL) {
            PsReturnPoolQuota(Process,
                              PoolType & BASE_POOL_TYPE_MASK,
                              (ULONG)Entry->BlockSize << POOL_BLOCK_SHIFT);

            ObDereferenceObject(Process);
        }
    }

    return;
}

#if DBG || (i386 && !FPO)

//
// Only works on checked builds or free x86 builds with FPO turned off
// See comment in mm\allocpag.c
//

NTSTATUS
ExpSnapShotPoolPages(
    IN PVOID Address,
    IN ULONG Size,
    IN OUT PSYSTEM_POOL_INFORMATION PoolInformation,
    IN OUT PSYSTEM_POOL_ENTRY *PoolEntryInfo,
    IN ULONG Length,
    IN OUT PULONG RequiredLength
    )
{
    NTSTATUS Status;
    CLONG i;
    PPOOL_HEADER p;
    PPOOL_TRACKER_BIG_PAGES PoolBig;
    LOGICAL ValidSplitBlock;
    ULONG EntrySize;
    KIRQL OldIrql;

    if (PAGE_ALIGNED(Address) && PoolBigPageTable) {

        ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);

        PoolBig = PoolBigPageTable;

        for (i = 0; i < PoolBigPageTableSize; i += 1, PoolBig += 1) {

            if (PoolBig->NumberOfPages == 0 || PoolBig->Va != Address) {
                continue;
            }

            PoolInformation->NumberOfEntries += 1;
            *RequiredLength += sizeof(SYSTEM_POOL_ENTRY);

            if (Length < *RequiredLength) {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            else {
                (*PoolEntryInfo)->Allocated = TRUE;
                (*PoolEntryInfo)->Size = PoolBig->NumberOfPages << PAGE_SHIFT;
                (*PoolEntryInfo)->AllocatorBackTraceIndex = 0;
                (*PoolEntryInfo)->ProcessChargedQuota = 0;
#if !DBG
                if (NtGlobalFlag & FLG_POOL_ENABLE_TAGGING)
#endif  //!DBG
                (*PoolEntryInfo)->TagUlong = PoolBig->Key;
                (*PoolEntryInfo) += 1;
                Status = STATUS_SUCCESS;
            }

            ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
            return  Status;
        }
        ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
    }

    p = (PPOOL_HEADER)Address;
    ValidSplitBlock = FALSE;

    if (Size == PAGE_SIZE && p->PreviousSize == 0 && p->BlockSize != 0) {
        PPOOL_HEADER PoolAddress;
        PPOOL_HEADER EndPoolAddress;

        //
        // Validate all the pool links before we regard this as a page that
        // has been split into small pool blocks.
        //

        PoolAddress = p;
        EndPoolAddress = (PPOOL_HEADER)((PCHAR) p + PAGE_SIZE);

        do {
            EntrySize = PoolAddress->BlockSize << POOL_BLOCK_SHIFT;
            PoolAddress = (PPOOL_HEADER)((PCHAR)PoolAddress + EntrySize);
            if (PoolAddress == EndPoolAddress) {
                ValidSplitBlock = TRUE;
                break;
            }
            if (PoolAddress > EndPoolAddress) {
                break;
            }
            if (PoolAddress->PreviousSize != EntrySize) {
                break;
            }
        } while (EntrySize != 0);
    }

    if (ValidSplitBlock == TRUE) {

        p = (PPOOL_HEADER)Address;

        do {
            EntrySize = p->BlockSize << POOL_BLOCK_SHIFT;

            if (EntrySize == 0) {
                return STATUS_COMMITMENT_LIMIT;
            }

            PoolInformation->NumberOfEntries += 1;
            *RequiredLength += sizeof(SYSTEM_POOL_ENTRY);

            if (Length < *RequiredLength) {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            else {
                (*PoolEntryInfo)->Size = EntrySize;
                if (p->PoolType != 0) {
                    (*PoolEntryInfo)->Allocated = TRUE;
                    (*PoolEntryInfo)->AllocatorBackTraceIndex = 0;
                    (*PoolEntryInfo)->ProcessChargedQuota = 0;
#if !DBG
                    if (NtGlobalFlag & FLG_POOL_ENABLE_TAGGING)
#endif  //!DBG
                    (*PoolEntryInfo)->TagUlong = p->PoolTag;
                }
                else {
                    (*PoolEntryInfo)->Allocated = FALSE;
                    (*PoolEntryInfo)->AllocatorBackTraceIndex = 0;
                    (*PoolEntryInfo)->ProcessChargedQuota = 0;

#if !defined(DBG) && !defined(_WIN64)
                    if (NtGlobalFlag & FLG_POOL_ENABLE_TAGGING)
#endif  //!DBG
                    (*PoolEntryInfo)->TagUlong = p->PoolTag;
                }

                (*PoolEntryInfo) += 1;
                Status = STATUS_SUCCESS;
            }

            p = (PPOOL_HEADER)((PCHAR)p + EntrySize);
        }
        while (PAGE_END(p) == FALSE);

    }
    else {

        PoolInformation->NumberOfEntries += 1;
        *RequiredLength += sizeof(SYSTEM_POOL_ENTRY);
        if (Length < *RequiredLength) {
            Status = STATUS_INFO_LENGTH_MISMATCH;

        }
        else {
            (*PoolEntryInfo)->Allocated = TRUE;
            (*PoolEntryInfo)->Size = Size;
            (*PoolEntryInfo)->AllocatorBackTraceIndex = 0;
            (*PoolEntryInfo)->ProcessChargedQuota = 0;
            (*PoolEntryInfo) += 1;
            Status = STATUS_SUCCESS;
        }
    }

    return Status;
}

NTSTATUS
ExSnapShotPool (
    IN POOL_TYPE PoolType,
    IN PSYSTEM_POOL_INFORMATION PoolInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    ULONG Index;
    PVOID Lock;
    KLOCK_QUEUE_HANDLE LockHandle;
    PPOOL_DESCRIPTOR PoolDesc;
    ULONG RequiredLength;
    NTSTATUS Status;
    KLOCK_QUEUE_HANDLE LockHandles[EXP_MAXIMUM_POOL_NODES];

    RequiredLength = FIELD_OFFSET(SYSTEM_POOL_INFORMATION, Entries);
    if (Length < RequiredLength) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    Status = STATUS_SUCCESS;

    //
    // Initializing PoolDesc is not needed for correctness but without
    // it the compiler cannot compile this code W4 to check for use of
    // uninitialized variables.
    //

    PoolDesc = NULL;

    //
    // If the pool type is paged, then lock all of the paged pools.
    // Otherwise, lock the nonpaged pool.
    //

    if (PoolType == PagedPool) {
        Index = 0;
        KeRaiseIrql(APC_LEVEL, &LockHandle.OldIrql);
        do {
            Lock = ExpPagedPoolDescriptor[Index]->LockAddress;
            ExAcquireFastMutex((PFAST_MUTEX)Lock);
            Index += 1;
        } while (Index < ExpNumberOfPagedPools);

    }
    else {
        ASSERT (PoolType == NonPagedPool);

        ExpLockNonPagedPool(LockHandle.OldIrql);

        if (ExpNumberOfNonPagedPools > 1) {
            Index = 0;
            do {
                Lock = ExpNonPagedPoolDescriptor[Index]->LockAddress;
                KeAcquireInStackQueuedSpinLock (Lock, &LockHandles[Index]);
                Index += 1;
            } while (Index < ExpNumberOfNonPagedPools);
        }
    }

    try {

        PoolInformation->EntryOverhead = POOL_OVERHEAD;
        PoolInformation->NumberOfEntries = 0;

        Status = MmSnapShotPool (PoolType,
                                 ExpSnapShotPoolPages,
                                 PoolInformation,
                                 Length,
                                 &RequiredLength);

    } except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // Return success at this point even if the results
        // cannot be written.
        //

        NOTHING;
    }

    //
    // If the pool type is paged, then unlock all of the paged pools.
    // Otherwise, unlock the nonpaged pool.
    //

    if (PoolType == PagedPool) {
        Index = 0;
        do {
            Lock = ExpPagedPoolDescriptor[Index]->LockAddress;
            ExReleaseFastMutex ((PFAST_MUTEX)Lock);
            Index += 1;
        } while (Index < ExpNumberOfPagedPools);

        KeLowerIrql (LockHandle.OldIrql);

    }
    else {

        if (ExpNumberOfNonPagedPools > 1) {
            Index = 0;
            do {
                KeReleaseInStackQueuedSpinLock (&LockHandles[Index]);
                Index += 1;
            } while (Index < ExpNumberOfNonPagedPools);
        }

        //
        // Release the main nonpaged pool lock last so the IRQL does not
        // prematurely drop below APC_LEVEL which would open a window where
        // a suspend APC could stop us.
        //

        ExpUnlockNonPagedPool (LockHandle.OldIrql);
    }

    if (ARGUMENT_PRESENT(ReturnLength)) {
        *ReturnLength = RequiredLength;
    }

    return Status;
}
#endif // DBG || (i386 && !FPO)

VOID
ExAllocatePoolSanityChecks(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    )

/*++

Routine Description:

    This function performs sanity checks on the caller.

Return Value:

    None.

Environment:

    Only enabled as part of the driver verification package.

--*/

{
    if (NumberOfBytes == 0) {
        KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                      0x0,
                      KeGetCurrentIrql(),
                      PoolType,
                      NumberOfBytes);
    }

    if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {

        if (KeGetCurrentIrql() > APC_LEVEL) {

            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x1,
                          KeGetCurrentIrql(),
                          PoolType,
                          NumberOfBytes);
        }
    }
    else {
        if (KeGetCurrentIrql() > DISPATCH_LEVEL) {

            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x2,
                          KeGetCurrentIrql(),
                          PoolType,
                          NumberOfBytes);
        }
    }
}

VOID
ExFreePoolSanityChecks (
    IN PVOID P
    )

/*++

Routine Description:

    This function performs sanity checks on the caller.

Return Value:

    None.

Environment:

    Only enabled as part of the driver verification package.

--*/

{
    PPOOL_HEADER Entry;
    POOL_TYPE PoolType;
    PVOID StillQueued;

    if (P <= (PVOID)(MM_HIGHEST_USER_ADDRESS)) {
        KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                      0x10,
                      (ULONG_PTR)P,
                      0,
                      0);
    }

    if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) &&
        (MmIsSpecialPoolAddress (P))) {

        KeCheckForTimer (P, PAGE_SIZE - BYTE_OFFSET (P));

        //
        // Check if an ERESOURCE is currently active in this memory block.
        //

        StillQueued = ExpCheckForResource(P, PAGE_SIZE - BYTE_OFFSET (P));
        if (StillQueued != NULL) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x17,
                          (ULONG_PTR)StillQueued,
                          (ULONG_PTR)-1,
                          (ULONG_PTR)P);
        }

        ExpCheckForWorker (P, PAGE_SIZE - BYTE_OFFSET (P)); // bugchecks inside
        return;
    }

    if (PAGE_ALIGNED(P)) {
        PoolType = MmDeterminePoolType(P);

        if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
            if (KeGetCurrentIrql() > APC_LEVEL) {
                KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                              0x11,
                              KeGetCurrentIrql(),
                              PoolType,
                              (ULONG_PTR)P);
            }
        }
        else {
            if (KeGetCurrentIrql() > DISPATCH_LEVEL) {
                KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                              0x12,
                              KeGetCurrentIrql(),
                              PoolType,
                              (ULONG_PTR)P);
            }
        }

        //
        // Just check the first page.
        //

        KeCheckForTimer(P, PAGE_SIZE);

        //
        // Check if an ERESOURCE is currently active in this memory block.
        //

        StillQueued = ExpCheckForResource(P, PAGE_SIZE);

        if (StillQueued != NULL) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x17,
                          (ULONG_PTR)StillQueued,
                          PoolType,
                          (ULONG_PTR)P);
        }
    }
    else {

        if (((ULONG_PTR)P & (POOL_OVERHEAD - 1)) != 0) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x16,
                          __LINE__,
                          (ULONG_PTR)P,
                          0);
        }

        Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);

        if ((Entry->PoolType & POOL_TYPE_MASK) == 0) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x13,
                          __LINE__,
                          (ULONG_PTR)Entry,
                          Entry->Ulong1);
        }

        PoolType = (Entry->PoolType & POOL_TYPE_MASK) - 1;

        if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
            if (KeGetCurrentIrql() > APC_LEVEL) {
                KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                              0x11,
                              KeGetCurrentIrql(),
                              PoolType,
                              (ULONG_PTR)P);
            }
        }
        else {
            if (KeGetCurrentIrql() > DISPATCH_LEVEL) {
                KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                              0x12,
                              KeGetCurrentIrql(),
                              PoolType,
                              (ULONG_PTR)P);
            }
        }

        if (!IS_POOL_HEADER_MARKED_ALLOCATED(Entry)) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x14,
                          __LINE__,
                          (ULONG_PTR)Entry,
                          0);
        }

        KeCheckForTimer(Entry, (ULONG)(Entry->BlockSize << POOL_BLOCK_SHIFT));

        //
        // Check if an ERESOURCE is currently active in this memory block.
        //

        StillQueued = ExpCheckForResource(Entry, (ULONG)(Entry->BlockSize << POOL_BLOCK_SHIFT));

        if (StillQueued != NULL) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x17,
                          (ULONG_PTR)StillQueued,
                          PoolType,
                          (ULONG_PTR)P);
        }
    }
}

#if defined (NT_UP)
VOID
ExpBootFinishedDispatch (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is called when the system has booted into a shell.

    It's job is to disable various pool optimizations that are enabled to
    speed up booting and reduce the memory footprint on small machines.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredContext - Optional deferred context;  not used.

    SystemArgument1 - Optional argument 1;  not used.

    SystemArgument2 - Optional argument 2;  not used.

Return Value:

    None.

Environment:

    DISPATCH_LEVEL since this is called from a timer expiration.

--*/

{
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    //
    // Pretty much all pages are "hot" after bootup.  Since bootup has finished,
    // use lookaside lists and stop trying to separate regular allocations
    // as well.
    //

    RtlInterlockedAndBitsDiscardReturn (&ExpPoolFlags, (ULONG)~EX_SEPARATE_HOT_PAGES_DURING_BOOT);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\probe.c ===
/*++

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    probe.c

Abstract:

    This module implements the probe for write function.

Author:

    David N. Cutler (davec) 19-Jan-1990

Environment:

    Any mode.

Revision History:

--*/

#include "exp.h"
#if defined(_WIN64)
#include <wow64t.h>
#endif

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, ProbeForWrite)
#pragma alloc_text(PAGE, ProbeForRead)
#endif


VOID
ProbeForWrite (
    IN PVOID Address,
    IN SIZE_T Length,
    IN ULONG Alignment
    )

/*++

Routine Description:

    This function probes a structure for write accessibility and ensures
    correct alignment of the structure. If the structure is not accessible
    or has incorrect alignment, then an exception is raised.

Arguments:

    Address - Supplies a pointer to the structure to be probed.

    Length - Supplies the length of the structure.

    Alignment - Supplies the required alignment of the structure expressed
        as the number of bytes in the primitive datatype (e.g., 1 for char,
        2 for short, 4 for long, and 8 for quad).

Return Value:

    None.

--*/

{

    ULONG_PTR EndAddress;
    ULONG_PTR StartAddress;
#if defined(_WIN64)
    ULONG_PTR PageSize;
#else
    #define PageSize  PAGE_SIZE
#endif


    //
    // If the structure has zero length, then do not probe the structure for
    // write accessibility or alignment.
    //

    if (Length != 0) {

        //
        // If the structure is not properly aligned, then raise a data
        // misalignment exception.
        //

        ASSERT((Alignment == 1) || (Alignment == 2) ||
               (Alignment == 4) || (Alignment == 8) ||
               (Alignment == 16));

        StartAddress = (ULONG_PTR)Address;
        if ((StartAddress & (Alignment - 1)) == 0) {

            //
            // Compute the ending address of the structure and probe for
            // write accessibility.
            //

            EndAddress = StartAddress + Length - 1;
            if ((StartAddress <= EndAddress) &&
                (EndAddress < MM_USER_PROBE_ADDRESS)) {

                //
                // N.B. Only the contents of the buffer may be probed.
                //      Therefore the starting byte is probed for the
                //      first page, and then the first byte in the page
                //      for each succeeding page.
                //

#if defined(_WIN64)
                //
                // If this is a Wow64 process, then the native page is 4K, which
                // could be smaller than the native page size/
                //

                if (PsGetCurrentProcess()->Wow64Process != NULL) {
                    PageSize = PAGE_SIZE_X86NT;
                } else {
                    PageSize = PAGE_SIZE;
                }
#endif

                EndAddress = (EndAddress & ~(PageSize - 1)) + PageSize;
                do {
                    *(volatile CHAR *)StartAddress = *(volatile CHAR *)StartAddress;

                    StartAddress = (StartAddress & ~(PageSize - 1)) + PageSize;
                } while (StartAddress != EndAddress);

                return;

            } else {
                ExRaiseAccessViolation();
            }

        } else {
            ExRaiseDatatypeMisalignment();
        }
    }

    return;
}

#undef ProbeForRead
NTKERNELAPI
VOID
NTAPI
ProbeForRead(
    IN CONST VOID *Address,
    IN SIZE_T Length,
    IN ULONG Alignment
    )

/*++

Routine Description:

    This function probes a structure for read accessibility and ensures
    correct alignment of the structure. If the structure is not accessible
    or has incorrect alignment, then an exception is raised.

Arguments:

    Address - Supplies a pointer to the structure to be probed.

    Length - Supplies the length of the structure.

    Alignment - Supplies the required alignment of the structure expressed
        as the number of bytes in the primitive datatype (e.g., 1 for char,
        2 for short, 4 for long, and 8 for quad).

Return Value:

    None.

--*/
{
    PAGED_CODE();

    ASSERT(((Alignment) == 1) || ((Alignment) == 2) ||
           ((Alignment) == 4) || ((Alignment) == 8) ||
           ((Alignment) == 16));

    if ((Length) != 0) {
        if (((ULONG_PTR)(Address) & ((Alignment) - 1)) != 0) {
            ExRaiseDatatypeMisalignment();

        } else if ((((ULONG_PTR)(Address) + (Length)) < (ULONG_PTR)(Address)) ||
                   (((ULONG_PTR)(Address) + (Length)) > (ULONG_PTR)MM_USER_PROBE_ADDRESS)) {
            ExRaiseAccessViolation();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\raise.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    raise.c

Abstract:

    This module implements routines to raise datatype misalignment and
    access violation for probe code.

    N.B. These routines are provided as function to save space in the
        probe macros.

    N.B. Since these routines are *only* called from the probe macros,
        it is assumed that the calling code is pageable.

Author:

    David N. Cutler (davec) 29-Apr-1995

Environment:

    Kernel mode.

Revision History:

--*/

#include "exp.h"

//
// Define function sections.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ExRaiseAccessViolation)
#pragma alloc_text(PAGE, ExRaiseDatatypeMisalignment)
#endif

VOID
ExRaiseAccessViolation (
    VOID
    )

/*++

Routine Description:

    This function raises an access violation exception.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ExRaiseStatus(STATUS_ACCESS_VIOLATION);
    return;
}

VOID
ExRaiseDatatypeMisalignment (
    VOID
    )

/*++

Routine Description:

    This function raises a datatype misalignment exception.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ExRaiseStatus(STATUS_DATATYPE_MISALIGNMENT);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\regtest.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regtest.c

Abstract:

   Test for quick and dirty registry test (very basic)

Author:

    Bryan M. Willman (bryanwi) 30-Apr-1991

Environment:

    User mode.

Revision History:

--*/

#include "stdio.h"
#include "nt.h"

int strlen(PUCHAR);
void main();

VOID DoTest(HANDLE RootKey);

#define MAX_VALUE   256
UCHAR ValueBuffer[MAX_VALUE];

VOID
main()
{
    DbgPrint("Machine\n");
    DoTest((HANDLE)REG_LOCAL_MACHINE);
    DbgPrint("User\n");
    DoTest((HANDLE)REG_LOCAL_USER);
}
VOID
DoTest(
    HANDLE  RootKey
    )
{
    NTSTATUS rc;
    STRING String1;
    UCHAR Value1[] = "This string is value 1.";
    UCHAR Value2[] = "Value 2 is represented by this string.";
    HANDLE Handle1;
    HANDLE Handle2;
    ULONG ValueLength;
    ULONG Type;
    LARGE_INTEGER Time;

    //
    // Create parent node
    //

    DbgPrint("Part1\n");
    RtlInitString(&String1,  "Test1");
    rc = NtCreateKey(
	RootKey,
	&String1,
	0,
	NULL,
	GENERIC_READ|GENERIC_WRITE,
	&Handle1
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("1:CreateKey failed rc  = %08lx", rc);
	return;
    }

    //
    // Set data into parent
    //

    DbgPrint("Part2\n");
    rc = NtSetValueKey(
	Handle1,
	1,		// type
	Value1,
	strlen(Value1)
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("2:SetValueKey failed rc  = %08lx", rc);
	return;
    }

    //
    // Query and compare data from parent
    //

    DbgPrint("Part2b\n");
    ValueLength = MAX_VALUE;
    rc = NtQueryValueKey(
	Handle1,
	&Type,
	ValueBuffer,
	&ValueLength,
	&Time
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("2b:QueryValueKey failed rc  = %08lx", rc);
	return;
    }

    if (ValueLength != (ULONG)strlen(Value1)) {
	DbgPrint("2b1:Wrong value length\n");
	return;
    } else if (RtlCompareMemory(
		ValueBuffer, Value1, ValueLength) != ValueLength) {
	DbgPrint("2b2:Wrong value\n");
	return;
    } else if (Type != 1) {
	DbgPrint("2b3:Wrong type\n");
	return;
    }


    //
    // Close parent
    //

    DbgPrint("Part3\n");
    NtCloseKey(Handle1);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("3:CloseKey failed rc  = %08lx", rc);
	return;
    }


    //
    // Reopen parent
    //

    DbgPrint("Part4\n");
    rc = NtOpenKey(
	RootKey,
	&String1,
	0,
	GENERIC_READ|GENERIC_WRITE,
	&Handle1
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("4:OpenKey failed rc  = %08lx", rc);
	return;
    }

    //
    // Create child
    //

    DbgPrint("Part5\n");
    RtlInitString(&String1,  "Test2");
    rc = NtCreateKey(
	Handle1,
	&String1,
	0,
	NULL,
	GENERIC_READ|GENERIC_WRITE,
	&Handle2
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("5:CreateKey failed rc  = %08lx", rc);
	return;
    }


    //
    // Set data into child
    //

    DbgPrint("Part6\n");
    rc = NtSetValueKey(
	Handle2,
	2,		// type
	Value2,
	strlen(Value2)
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("6:SetValueKey failed rc  = %08lx", rc);
	return;
    }


    //
    // Query and compare data from child
    //

    DbgPrint("Part7\n");
    ValueLength = MAX_VALUE;
    rc = NtQueryValueKey(
	Handle2,
	&Type,
	ValueBuffer,
	&ValueLength,
	&Time
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("7:QueryValueKey failed rc  = %08lx", rc);
	return;
    }

    if (ValueLength != (ULONG)strlen(Value2)) {
	DbgPrint("7.1:Wrong value length\n");
	return;
    } else if (RtlCompareMemory(
		ValueBuffer, Value2, ValueLength) != ValueLength) {
	DbgPrint("7.2:Wrong value\n");
	return;
    } else if (Type != 2) {
	DbgPrint("7.3:Wrong type\n");
	return;
    }


    //
    // Query and compare data from parent again
    //

    DbgPrint("Part8\n");
    ValueLength = MAX_VALUE;
    rc = NtQueryValueKey(
	Handle1,
	&Type,
	ValueBuffer,
	&ValueLength,
	&Time
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("8:QueryValueKey failed rc  = %08lx", rc);
	return;
    }

    if (ValueLength != (ULONG)strlen(Value1)) {
	DbgPrint("8.1:Wrong value length\n");
	return;
    } else if (RtlCompareMemory(
		ValueBuffer, Value1, ValueLength) != ValueLength) {
	DbgPrint("8.2:Wrong value\n");
	return;
    } else if (Type != 1) {
	DbgPrint("8.3:Wrong type\n");
	return;
    }


    //
    // Reset parent data
    //

    DbgPrint("Part9\n");
    rc = NtSetValueKey(
	Handle1,
	1,		// type
	Value2,
	strlen(Value2)
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("9:SetValueKey failed rc  = %08lx", rc);
	return;
    }


    //
    // Query and compare reset data
    //

    DbgPrint("Part10\n");
    ValueLength = MAX_VALUE;
    rc = NtQueryValueKey(
	Handle1,
	&Type,
	ValueBuffer,
	&ValueLength,
	&Time
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("10:QueryValueKey failed rc  = %08lx", rc);
	return;
    }

    if (ValueLength != (ULONG)strlen(Value2)) {
	DbgPrint("10.1:Wrong value length\n");
	return;
    } else if (RtlCompareMemory(
		ValueBuffer, Value2, ValueLength) != ValueLength) {
	DbgPrint("10.2:Wrong value\n");
	return;
    } else if (Type != 1) {
	DbgPrint("10.3:Wrong type\n");
	return;
    }

    //
    // Close off handles and return
    //

    DbgPrint("Part11\n");
    rc = NtCloseKey(Handle1);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("11:CloseKey failed rc  = %08lx", rc);
	return;
    }

    DbgPrint("Part12\n");
    rc = NtCloseKey(Handle2);
    if (!NT_SUCCESS(rc)) {
	DbgPrint("12:CloseKey failed rc  = %08lx", rc);
	return;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\profile.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    profile.c

Abstract:

   This module implements the executive profile object. Functions are provided
   to create, start, stop, and query profile objects.

Author:

    Lou Perazzoli (loup) 21-Sep-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

//
// Executive profile object.
//

typedef struct _EPROFILE {
    PKPROCESS Process;
    PVOID RangeBase;
    SIZE_T RangeSize;
    PVOID Buffer;
    ULONG BufferSize;
    ULONG BucketSize;
    PKPROFILE ProfileObject;
    PVOID LockedBufferAddress;
    PMDL Mdl;
    ULONG Segment;
    KPROFILE_SOURCE ProfileSource;
    KAFFINITY Affinity;
} EPROFILE, *PEPROFILE;

//
// Address of event object type descriptor.
//

POBJECT_TYPE ExProfileObjectType;

KMUTEX ExpProfileStateMutex;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

const ULONG ExpCurrentProfileUsage = 0;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING ExpProfileMapping = {
    STANDARD_RIGHTS_READ | PROFILE_CONTROL,
    STANDARD_RIGHTS_WRITE | PROFILE_CONTROL,
    STANDARD_RIGHTS_EXECUTE | PROFILE_CONTROL,
    PROFILE_ALL_ACCESS
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#define ACTIVE_PROFILE_LIMIT 8

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpProfileInitialization)
#pragma alloc_text(PAGE, ExpProfileDelete)
#pragma alloc_text(PAGE, NtCreateProfile)
#pragma alloc_text(PAGE, NtStartProfile)
#pragma alloc_text(PAGE, NtStopProfile)
#pragma alloc_text(PAGE, NtSetIntervalProfile)
#pragma alloc_text(PAGE, NtQueryIntervalProfile)
#pragma alloc_text(PAGE, NtQueryPerformanceCounter)
#endif


BOOLEAN
ExpProfileInitialization (
    )

/*++

Routine Description:

    This function creates the profile object type descriptor at system
    initialization and stores the address of the object type descriptor
    in global storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the profile object type descriptor is
    successfully initialized. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize mutex for synchronizing start and stop operations.
    //

    KeInitializeMutex (&ExpProfileStateMutex, MUTEX_LEVEL_EX_PROFILE);

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Profile");

    //
    // Create event object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer,sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(EPROFILE);
    ObjectTypeInitializer.ValidAccessMask = PROFILE_ALL_ACCESS;
    ObjectTypeInitializer.DeleteProcedure = ExpProfileDelete;
    ObjectTypeInitializer.GenericMapping = ExpProfileMapping;

    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExProfileObjectType);

    //
    // If the event object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

VOID
ExpProfileDelete (
    IN PVOID    Object
    )

/*++

Routine Description:


    This routine is called by the object management procedures whenever
    the last reference to a profile object has been removed.  This routine
    stops profiling, returns locked buffers and pages, dereferences the
    specified process and returns.

Arguments:

    Object - a pointer to the body of the profile object.

Return Value:

    None.

--*/

{
    PEPROFILE Profile;
    BOOLEAN   State;
    PEPROCESS ProcessAddress;

    Profile = (PEPROFILE)Object;

    if (Profile->LockedBufferAddress != NULL) {

        //
        // Stop profiling and unlock the buffers and deallocate pool.
        //

        State = KeStopProfile (Profile->ProfileObject);
        ASSERT (State != FALSE);

        MmUnmapLockedPages (Profile->LockedBufferAddress, Profile->Mdl);
        MmUnlockPages (Profile->Mdl);
        ExFreePool (Profile->ProfileObject);
    }

    if (Profile->Process != NULL) {
        ProcessAddress = CONTAINING_RECORD(Profile->Process, EPROCESS, Pcb);
        ObDereferenceObject ((PVOID)ProcessAddress);
    }

    return;
}

NTSTATUS
NtCreateProfile (
    OUT PHANDLE ProfileHandle,
    IN HANDLE Process OPTIONAL,
    IN PVOID RangeBase,
    IN SIZE_T RangeSize,
    IN ULONG BucketSize,
    IN PULONG Buffer,
    IN ULONG BufferSize,
    IN KPROFILE_SOURCE ProfileSource,
    IN KAFFINITY Affinity
    )

/*++

Routine Description:

    This function creates a profile object.

Arguments:

    ProfileHandle - Supplies a pointer to a variable that will receive
                    the profile object handle.

    Process - Optionally, supplies the handle to the process whose
              address space to profile.  If the value is NULL (0), then
              all address spaces are included in the profile.

    RangeBase - Supplies the address of the first byte of the address
                  space for which profiling information is to be collected.


    RangeSize - Supplies the size of the range to profile in the
                address space.  RangeBase and RangeSize are interpreted
                such that RangeBase <= address < RangeBase+RangeSize
                will generate a profile hit.

    BucketSize - Supplies the LOG base 2 of the size of the profiling
                 bucket.  Thus, BucketSize = 2 yields four-byte
                 buckets, BucketSize = 7 yields 128-byte buckets.
                 All profile hits in a given bucket will increment
                 the corresponding counter in Buffer.  Buckets
                 cannot be smaller than a ULONG.  The acceptable range
                 of this value is 2 to 30 inclusive.

    Buffer - Supplies an array of ULONGs.  Each ULONG is a hit counter,
             which records the number of hits of the corresponding
             bucket.

    BufferSize - Size in bytes of Buffer.

    ProfileSource - Supplies the source for the profile interrupt

    Affinity - Supplies the processor set for the profile interrupt

Return Value:

    TBS

--*/

{

    PEPROFILE Profile;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PEPROCESS ProcessAddress;
    OBJECT_ATTRIBUTES ObjectAttributes;
    BOOLEAN HasPrivilege = FALSE;
    ULONG Segment = FALSE;
#ifdef i386
    USHORT PowerOf2;
#endif

    //
    // Verify that the base and size arguments are reasonable.
    //

    if (BufferSize == 0) {
        return STATUS_INVALID_PARAMETER_7;
    }

#ifdef i386
    //
    //        sleazy use of bucket size.  If bucket size is zero, and
    //        RangeBase < 64K, then create a profile object to attach
    //        to a non-flat code segment.  In this case, RangeBase is
    //        the non-flat CS for this profile object.
    //

    if ((BucketSize == 0) && (RangeBase < (PVOID)(64 * 1024))) {

        if (BufferSize < sizeof(ULONG)) {
            return STATUS_INVALID_PARAMETER_7;
        }

        Segment = (ULONG)RangeBase;
        RangeBase = 0;
        BucketSize = RangeSize / (BufferSize / sizeof(ULONG));

        //
        // Convert Bucket size of log2(BucketSize)
        //
        PowerOf2 = 0;
        BucketSize = BucketSize - 1;
        while (BucketSize >>= 1) {
            PowerOf2++;
        }

        BucketSize = PowerOf2 + 1;

        if (BucketSize < 2) {
            BucketSize = 2;
        }
    }
#endif

    if ((BucketSize > 31) || (BucketSize < 2)) {
        return STATUS_INVALID_PARAMETER;
    }

    if ((RangeSize >> (BucketSize - 2)) > BufferSize) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    if (((ULONG_PTR)RangeBase + RangeSize) < RangeSize) {
        return STATUS_BUFFER_OVERFLOW;
    }

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to create a profile object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object insertion routine.
    //

    try {
        //
        // Get previous processor mode and probe output handle address if
        // necessary.
        //

        PreviousMode = KeGetPreviousMode ();

        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle(ProfileHandle);

            ProbeForWrite(Buffer,
                          BufferSize,
                          sizeof(ULONG));
        }

    //
    // If an exception occurs during the probe of the output handle address,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

//
// TODO post NT5:
//
// Currently, if a process isn't specified, there is no privilege check if
//   RangeBase > MM_HIGHEST_USER_ADDRESS.
// The check for user-space addresses is SeSystemProfilePrivilege.
// Querying a specific process requires only PROCESS_QUERY_INFORMATION.
//
// The spec says:
//
//     Process - If specified, a handle to a process which describes the address space to profile.
//     If not present, then all address spaces are included in the profile.
//     Profiling a process requires PROCESS_QUERY_INFORMATION access to that process and
//     SeProfileSingleProcessPrivilege privilege.
//     Profiling all processes requires SeSystemProfilePrivilege privilege.
//
// So two changes appear needed.
//   A check on SeProfileSingleProcessPrivilege needs to be added to the single process case,
//   and SeSystemProfilePrivilege privilege should be required for both user and system address profiling.
//


    if (!ARGUMENT_PRESENT(Process)) {

        //
        // Don't attach segmented profile objects to all processes
        //

        if (Segment) {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Profile all processes. Make sure that the specified
        // address range is in system space, unless SeSystemProfilePrivilege.
        //

        if (RangeBase <= MM_HIGHEST_USER_ADDRESS) {

            //
            // Check for privilege before allowing a user to profile
            // all processes and USER addresses.
            //

            if (PreviousMode != KernelMode) {
                HasPrivilege =  SeSinglePrivilegeCheck(
                                    SeSystemProfilePrivilege,
                                    PreviousMode
                                    );

                if (!HasPrivilege) {
#if DBG
                    DbgPrint("SeSystemProfilePrivilege needed to profile all USER addresses.\n");
#endif //DBG
                    return( STATUS_PRIVILEGE_NOT_HELD );
                }

            }
        }

        ProcessAddress = NULL;


    } else {

        //
        // Reference the specified process.
        //

        Status = ObReferenceObjectByHandle ( Process,
                                             PROCESS_QUERY_INFORMATION,
                                             PsProcessType,
                                             PreviousMode,
                                             (PVOID *)&ProcessAddress,
                                             NULL );

        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                OBJ_EXCLUSIVE,
                                NULL,
                                NULL );

    Status = ObCreateObject( KernelMode,
                             ExProfileObjectType,
                             &ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof(EPROFILE),
                             0,
                             sizeof(EPROFILE) + sizeof(KPROFILE),
                             (PVOID *)&Profile);

    //
    // If the profile object was successfully allocated, initialize
    // the profile object.
    //
    if (NT_SUCCESS(Status)) {


        if (ProcessAddress != NULL) {
            Profile->Process = &ProcessAddress->Pcb;
        } else {
            Profile->Process = NULL;
        }

        Profile->RangeBase = RangeBase;
        Profile->RangeSize = RangeSize;
        Profile->Buffer = Buffer;
        Profile->BufferSize = BufferSize;
        Profile->BucketSize = BucketSize;
        Profile->LockedBufferAddress = NULL;
        Profile->Segment = Segment;
        Profile->ProfileSource = ProfileSource;
        Profile->Affinity = Affinity;

        Status = ObInsertObject(Profile,
                                NULL,
                                PROFILE_CONTROL,
                                0,
                                (PVOID *)NULL,
                                &Handle);
        //
        // If the profile object was successfully inserted in the current
        // process' handle table, then attempt to write the profile object
        // handle value. If the write attempt fails, then do not report
        // an error. When the caller attempts to access the handle value,
        // an access violation will occur.
        //
        if (NT_SUCCESS(Status)) {
            try {
                *ProfileHandle = Handle;
            } except(EXCEPTION_EXECUTE_HANDLER) {
            }
        }
    }

    //
    // If we failed, remove our reference to the process object.
    //
    if (!NT_SUCCESS(Status)) {
        if (ProcessAddress != NULL) {
            ObDereferenceObject ((PVOID)ProcessAddress);
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtStartProfile (
    IN HANDLE ProfileHandle
    )

/*++

Routine Description:

    The NtStartProfile routine starts the collecting data for the
    specified profile object.  This involved allocating nonpaged
    pool to lock the specified buffer in memory, creating a kernel
    profile object and starting collecting on that profile object.

Arguments:

    ProfileHandle - Supplies the profile handle to start profiling on.

Return Value:

    TBS

--*/

{

    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PEPROFILE Profile;
    PKPROFILE ProfileObject;
    PVOID LockedVa;
    BOOLEAN State;

    PreviousMode = KeGetPreviousMode();

    Status = ObReferenceObjectByHandle( ProfileHandle,
                                        PROFILE_CONTROL,
                                        ExProfileObjectType,
                                        PreviousMode,
                                        (PVOID *)&Profile,
                                        NULL);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Acquire the profile state mutex so two threads can't
    // operate on the same profile object simultaneously.
    //

    KeWaitForSingleObject( &ExpProfileStateMutex,
                           Executive,
                           KernelMode,
                           FALSE,
                           (PLARGE_INTEGER)NULL);

    //
    // Make sure profiling is not already enabled.
    //

    if (Profile->LockedBufferAddress != NULL) {
        KeReleaseMutex (&ExpProfileStateMutex, FALSE);
        ObDereferenceObject ((PVOID)Profile);
        return STATUS_PROFILING_NOT_STOPPED;
    }

    if (ExpCurrentProfileUsage == ACTIVE_PROFILE_LIMIT) {
        KeReleaseMutex (&ExpProfileStateMutex, FALSE);
        ObDereferenceObject ((PVOID)Profile);
        return STATUS_PROFILING_AT_LIMIT;
    }

    ProfileObject = ExAllocatePoolWithTag (NonPagedPool,
                                    MmSizeOfMdl(Profile->Buffer,
                                                Profile->BufferSize) +
                                        sizeof(KPROFILE),
                                        'forP');

    if (ProfileObject == NULL) {
        KeReleaseMutex (&ExpProfileStateMutex, FALSE);
        ObDereferenceObject ((PVOID)Profile);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Profile->Mdl = (PMDL)(ProfileObject + 1);
    Profile->ProfileObject = ProfileObject;

    //
    // Probe and lock the specified buffer.
    //

    MmInitializeMdl(Profile->Mdl, Profile->Buffer, Profile->BufferSize);

    LockedVa = NULL;

    try {

        MmProbeAndLockPages (Profile->Mdl,
                             PreviousMode,
                             IoWriteAccess );

    } except (EXCEPTION_EXECUTE_HANDLER) {

        ExFreePool (ProfileObject);
        KeReleaseMutex (&ExpProfileStateMutex, FALSE);
        ObDereferenceObject ((PVOID)Profile);
        return GetExceptionCode();
    }

    //
    // Since kernel space is specified below, this call cannot raise
    // an exception.
    //

    LockedVa = MmMapLockedPagesSpecifyCache (Profile->Mdl,
                                             KernelMode,
                                             MmCached,
                                             NULL,
                                             FALSE,
                                             NormalPagePriority);

    if (LockedVa == NULL) {
        MmUnlockPages (Profile->Mdl);
        ExFreePool (ProfileObject);
        KeReleaseMutex (&ExpProfileStateMutex, FALSE);
        ObDereferenceObject ((PVOID)Profile);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the profile object.
    //

    KeInitializeProfile (ProfileObject,
                         Profile->Process,
                         Profile->RangeBase,
                         Profile->RangeSize,
                         Profile->BucketSize,
                         Profile->Segment,
                         Profile->ProfileSource,
                         Profile->Affinity);

    State = KeStartProfile (ProfileObject, LockedVa);
    ASSERT (State != FALSE);

    Profile->LockedBufferAddress = LockedVa;

    KeReleaseMutex (&ExpProfileStateMutex, FALSE);
    ObDereferenceObject ((PVOID)Profile);

    return STATUS_SUCCESS;
}

NTSTATUS
NtStopProfile (
    IN HANDLE ProfileHandle
    )

/*++

Routine Description:

    The NtStopProfile routine stops collecting data for the
    specified profile object.  This involves stopping the data
    collection on the profile object, unlocking the locked buffers,
    and deallocating the pool for the MDL and profile object.

Arguments:

    ProfileHandle - Supplies a the profile handle to stop profiling.

Return Value:

    TBS

--*/

{

    PEPROFILE Profile;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    BOOLEAN State;

    PreviousMode = KeGetPreviousMode();

    Status = ObReferenceObjectByHandle( ProfileHandle,
                                        PROFILE_CONTROL,
                                        ExProfileObjectType,
                                        PreviousMode,
                                        (PVOID *)&Profile,
                                        NULL);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    KeWaitForSingleObject( &ExpProfileStateMutex,
                           Executive,
                           KernelMode,
                           FALSE,
                           (PLARGE_INTEGER)NULL);

    //
    // Check to see if profiling is not active.
    //

    if (Profile->LockedBufferAddress == NULL) {
        KeReleaseMutex (&ExpProfileStateMutex, FALSE);
        ObDereferenceObject ((PVOID)Profile);
        return STATUS_PROFILING_NOT_STARTED;
    }

    //
    // Stop profiling and unlock the buffer.
    //

    State = KeStopProfile (Profile->ProfileObject);
    ASSERT (State != FALSE);

    MmUnmapLockedPages (Profile->LockedBufferAddress, Profile->Mdl);
    MmUnlockPages (Profile->Mdl);
    ExFreePool (Profile->ProfileObject);
    Profile->LockedBufferAddress = NULL;
    KeReleaseMutex (&ExpProfileStateMutex, FALSE);

    ObDereferenceObject ((PVOID)Profile);
    return STATUS_SUCCESS;
}

NTSTATUS
NtSetIntervalProfile (
    IN ULONG Interval,
    IN KPROFILE_SOURCE Source
    )

/*++

Routine Description:

    This routine allows the system-wide interval (and thus the profiling
    rate) for profiling to be set.

Arguments:

    Interval - Supplies the sampling interval in 100ns units.

    Source - Specifies the profile source to be set.

Return Value:

    TBS

--*/

{

    KeSetIntervalProfile (Interval, Source);
    return STATUS_SUCCESS;
}

NTSTATUS
NtQueryIntervalProfile (
    IN KPROFILE_SOURCE ProfileSource,
    OUT PULONG Interval
    )

/*++

Routine Description:

    This routine queries the system-wide interval (and thus the profiling
    rate) for profiling.

Arguments:

    Source - Specifies the profile source to be queried.

    Interval - Returns the sampling interval in 100ns units.

Return Value:

    TBS

--*/

{
    ULONG CapturedInterval;
    KPROCESSOR_MODE PreviousMode;

    PreviousMode = KeGetPreviousMode ();
    if (PreviousMode != KernelMode) {

        //
        // Probe accessibility of user's buffer.
        //

        try {
            ProbeForWriteUlong (Interval);

        } except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // If an exception occurs during the probe or capture
            // of the initial values, then handle the exception and
            // return the exception code as the status value.
            //

            return GetExceptionCode();
        }
    }

    CapturedInterval = KeQueryIntervalProfile (ProfileSource);

    if (PreviousMode != KernelMode) {
        try {
            *Interval = CapturedInterval;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            NOTHING;
        }
    }
    else {
        *Interval = CapturedInterval;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
NtQueryPerformanceCounter (
    OUT PLARGE_INTEGER PerformanceCounter,
    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
    )

/*++

Routine Description:

    This function returns current value of performance counter and,
    optionally, the frequency of the performance counter.

    Performance frequency is the frequency of the performance counter
    in Hertz, i.e., counts/second.  Note that this value is implementation
    dependent.  If the implementation does not have hardware to support
    performance timing, the value returned is 0.

Arguments:

    PerformanceCounter - supplies the address of a variable to receive
        the current Performance Counter value.

    PerformanceFrequency - Optionally, supplies the address of a
        variable to receive the performance counter frequency.

Return Value:

    STATUS_ACCESS_VIOLATION or STATUS_SUCCESS.

--*/

{
    KPROCESSOR_MODE PreviousMode;
    LARGE_INTEGER KernelPerformanceFrequency;

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {

        //
        // Probe accessibility of user's buffer.
        //

        try {
            ProbeForWriteSmallStructure (PerformanceCounter,
                                         sizeof (LARGE_INTEGER),
                                         sizeof (ULONG));

            if (ARGUMENT_PRESENT(PerformanceFrequency)) {
                ProbeForWriteSmallStructure (PerformanceFrequency,
                                             sizeof (LARGE_INTEGER),
                                             sizeof (ULONG));
            }

            *PerformanceCounter = KeQueryPerformanceCounter (&KernelPerformanceFrequency);

            if (ARGUMENT_PRESENT(PerformanceFrequency)) {
                *PerformanceFrequency = KernelPerformanceFrequency;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // If an exception occurs during the probe or capture
            // of the initial values, then handle the exception and
            // return the exception code as the status value.
            //

            return GetExceptionCode();
        }
    }
    else {
        *PerformanceCounter = KeQueryPerformanceCounter (&KernelPerformanceFrequency);
        if (ARGUMENT_PRESENT(PerformanceFrequency)) {
            *PerformanceFrequency = KernelPerformanceFrequency;
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\resource.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    resource.c

Abstract:

    This module implements the executive functions to acquire and release
    a shared resource.

Author:

    Gary D. Kimura [GaryKi] 25-Jun-1989

    David N. Cutler (davec) 20-Mar-1994
        Substantially rewritten to make fastlock optimizations portable
        across all platforms and to improve the algorithms used to be
        perfectly synchronized.

Environment:

    Kernel mode only.

Revision History:

--*/

//#define _COLLECT_RESOURCE_DATA_ 1

#include "exp.h"
#pragma hdrstop
#include "nturtl.h"

//
// Define local macros to test resource state.
//

#define IsExclusiveWaiting(a) ((a)->NumberOfExclusiveWaiters != 0)
#define IsSharedWaiting(a) ((a)->NumberOfSharedWaiters != 0)
#define IsOwnedExclusive(a) (((a)->Flag & ResourceOwnedExclusive) != 0)
#define IsBoostAllowed(a) (((a)->Flag & DisablePriorityBoost) == 0)

//
// Define priority boost flags.
//

#define DisablePriorityBoost 0x08

LARGE_INTEGER ExShortTime = {(ULONG)(-10 * 1000 * 10), -1}; // 10 milliseconds

//
// Define resource assertion macro.
//

#if DBG

VOID
ExpAssertResource(
    IN PERESOURCE Resource
    );

#define ASSERT_RESOURCE(_Resource) ExpAssertResource(_Resource)

#else

#define ASSERT_RESOURCE(_Resource)

#endif

//
// Define locking primitives. 
// On UP systems, fastlocks are used.
// On MP systems, a queued spinlock is used.
//
#if defined(NT_UP)
#define EXP_LOCK_HANDLE KIRQL
#define PEXP_LOCK_HANDLE PKIRQL
#define EXP_LOCK_RESOURCE(_resource_, _plockhandle_)  UNREFERENCED_PARAMETER(_plockhandle_); ExAcquireFastLock(&(_resource_)->SpinLock, (_plockhandle_))
#define EXP_UNLOCK_RESOURCE(_resource_, _plockhandle_) ExReleaseFastLock(&(_resource_)->SpinLock, *(_plockhandle_))
#else
#define EXP_LOCK_HANDLE KLOCK_QUEUE_HANDLE
#define PEXP_LOCK_HANDLE PKLOCK_QUEUE_HANDLE
#define EXP_LOCK_RESOURCE(_resource_, _plockhandle_) KeAcquireInStackQueuedSpinLock(&(_resource_)->SpinLock, (_plockhandle_))
#define EXP_UNLOCK_RESOURCE(_resource_, _plockhandle_) KeReleaseInStackQueuedSpinLock(_plockhandle_)
#endif



//
// Define private function prototypes.
//

VOID
FASTCALL
ExpWaitForResource (
    IN PERESOURCE Resource,
    IN PVOID Object
    );

POWNER_ENTRY
FASTCALL
ExpFindCurrentThread(
    IN PERESOURCE Resource,
    IN ERESOURCE_THREAD CurrentThread,
    IN PEXP_LOCK_HANDLE LockHandle OPTIONAL
    );


//
// Resource wait time out value.
//

LARGE_INTEGER ExpTimeout;

//
// Consecutive time outs before message.  Note this is registry-settable.
//

ULONG ExResourceTimeoutCount = 648000;

//
// Global spinlock to guard access to resource lists.
//

KSPIN_LOCK ExpResourceSpinLock;

//
// Resource list used to record all resources in the system.
//

LIST_ENTRY ExpSystemResourcesList;

//
// Define executive resource performance data.
//

#if defined(_COLLECT_RESOURCE_DATA_)

#define ExpIncrementCounter(Member) ExpResourcePerformanceData.Member += 1

RESOURCE_PERFORMANCE_DATA ExpResourcePerformanceData;

#else

#define ExpIncrementCounter(Member)

#endif


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpResourceInitialization)
#pragma alloc_text(PAGELK, ExQuerySystemLockInformation)
#endif

//
// Resource strict verification (checked builds only)
//
// When acquiring a resource while running in a thread that is not a system
// thread and runs at passive level we need to disable kernel APCs first
// (KeEnterCriticalRegion()). Otherwise any user mode code can call
// NtSuspendThread() which is implemented using kernel APCs and can
// suspend the thread while having a resource acquired.
// This will potentially deadlock the whole system.
//

#if DBG

ULONG ExResourceStrict = 1;

VOID
ExCheckIfKernelApcsShouldBeDisabled (
    IN KIRQL Irql,
    IN PVOID Resource,
    IN PKTHREAD Thread)
{
    if ((ExResourceStrict == 0) ||
        (Irql >= APC_LEVEL) ||
        (IS_SYSTEM_THREAD((PETHREAD)Thread)) ||
        (Thread->KernelApcDisable != 0)) {

        return;
    }

    DbgPrint ("EX: resource: APCs still enabled before resource %p acquire !!!\n", Resource);
    DbgBreakPoint ();
}

#define EX_ENSURE_APCS_DISABLED(Irql, Resource, Thread) \
            ExCheckIfKernelApcsShouldBeDisabled (Irql, Resource, Thread);

#else

#define EX_ENSURE_APCS_DISABLED(Irql, Resource, Thread)

#endif // DBG


BOOLEAN
ExpResourceInitialization(
    VOID
    )

/*++

Routine Description:

    This function initializes global data during system initialization.

Arguments:

    None.

Return Value:

    BOOLEAN - TRUE

--*/

{
#if defined(_COLLECT_RESOURCE_DATA_)
    ULONG Index;
#endif

    //
    // Initialize resource timeout value, the system resource listhead,
    // and the resource spinlock.
    //

    ExpTimeout.QuadPart = Int32x32To64(4 * 1000, -10000);
    InitializeListHead(&ExpSystemResourcesList);
    KeInitializeSpinLock(&ExpResourceSpinLock);

    //
    // Initialize resource performance data.
    //

#if defined(_COLLECT_RESOURCE_DATA_)

    ExpResourcePerformanceData.ActiveResourceCount = 0;
    ExpResourcePerformanceData.TotalResourceCount = 0;
    ExpResourcePerformanceData.ExclusiveAcquire = 0;
    ExpResourcePerformanceData.SharedFirstLevel = 0;
    ExpResourcePerformanceData.SharedSecondLevel = 0;
    ExpResourcePerformanceData.StarveFirstLevel = 0;
    ExpResourcePerformanceData.StarveSecondLevel = 0;
    ExpResourcePerformanceData.WaitForExclusive = 0;
    ExpResourcePerformanceData.OwnerTableExpands = 0;
    ExpResourcePerformanceData.MaximumTableExpand = 0;
    for (Index = 0; Index < RESOURCE_HASH_TABLE_SIZE; Index += 1) {
        InitializeListHead(&ExpResourcePerformanceData.HashTable[Index]);
    }

#endif

    return TRUE;
}

VOID
ExpAllocateExclusiveWaiterEvent (
    IN PERESOURCE Resource,
    IN PEXP_LOCK_HANDLE LockHandle
    )

/*++

Routine Description:

    This function allocates and initializes the exclusive waiter event
    for a resource.

    N.B. The resource spin lock is held on entry and exit of this routine.

Arguments:

    Resource - Supplies a pointer to the resource.

    LockHandle - Supplies a pointer to a lock handle.

Return Value:

    None.

--*/

{

    PKEVENT Event;

    //
    // Allocate an exclusive wait event and retry the acquire operation.
    //

    EXP_UNLOCK_RESOURCE(Resource, LockHandle);
    do {
        Event = ExAllocatePoolWithTag(NonPagedPool,
                                      sizeof(KEVENT),
                                      'vEeR');

        if (Event != NULL) {
            KeInitializeEvent(Event, SynchronizationEvent, FALSE);
            if (InterlockedCompareExchangePointer(&Resource->ExclusiveWaiters,
                                                  Event,
                                                  NULL) != NULL) {

                ExFreePool(Event);
            }

            break;
        }

        KeDelayExecutionThread(KernelMode, FALSE, &ExShortTime);

    } while (TRUE);

    EXP_LOCK_RESOURCE(Resource, LockHandle);
    return;
}

VOID
ExpAllocateSharedWaiterSemaphore (
    IN PERESOURCE Resource,
    IN PEXP_LOCK_HANDLE LockHandle
    )

/*++

Routine Description:

    This function allocates and initializes the shared waiter semaphore
    for a resource.

    N.B. The resource spin lock is held on entry and exit of this routine.

Arguments:

    Resource - Supplies a pointer to the resource.

    LockHandle - Supplies a pointer to a lock handle.

Return Value:

    None.

--*/

{

    PKSEMAPHORE Semaphore;

    //
    // Allocate and initialize a shared wait semaphore for the specified
    // resource.
    //

    EXP_UNLOCK_RESOURCE(Resource, LockHandle);
    do {
        Semaphore = ExAllocatePoolWithTag(NonPagedPool,
                                          sizeof(KSEMAPHORE),
                                          'eSeR');

        if (Semaphore != NULL) {
            KeInitializeSemaphore(Semaphore, 0, MAXLONG);
            if (InterlockedCompareExchangePointer(&Resource->SharedWaiters,
                                                  Semaphore,
                                                  NULL) != NULL) {
                ExFreePool(Semaphore);
            }

            break;
        }

        KeDelayExecutionThread(KernelMode, FALSE, &ExShortTime);

    } while (TRUE);

    EXP_LOCK_RESOURCE(Resource, LockHandle);
    return;
}

NTSTATUS
ExInitializeResourceLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine initializes the specified resource.

Arguments:

    Resource - Supplies a pointer to the resource to initialize.

Return Value:

    STATUS_SUCCESS.

--*/

{
#if defined(_COLLECT_RESOURCE_DATA_)
    PVOID CallersCaller;
#endif

    ASSERT(MmDeterminePoolType(Resource) == NonPagedPool);

    //
    // Initialize the specified resource.
    //
    // N.B. All fields are initialized to zero (NULL pointers) except
    //      the list entry and spinlock.
    //

    RtlZeroMemory(Resource, sizeof(ERESOURCE));
    KeInitializeSpinLock(&Resource->SpinLock);

    if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {
        Resource->CreatorBackTraceIndex = RtlLogStackBackTrace();
        }
    else {
        Resource->CreatorBackTraceIndex = 0;
        }
    
    ExInterlockedInsertTailList(&ExpSystemResourcesList,
                                &Resource->SystemResourcesList,
                                &ExpResourceSpinLock);

    //
    // Initialize performance data entry for the resource.
    //

#if defined(_COLLECT_RESOURCE_DATA_)

    RtlGetCallersAddress(&Resource->Address, &CallersCaller);
    ExpResourcePerformanceData.TotalResourceCount += 1;
    ExpResourcePerformanceData.ActiveResourceCount += 1;

#endif

    return STATUS_SUCCESS;
}

NTSTATUS
ExReinitializeResourceLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine reinitializes the specified resource.

Arguments:

    Resource - Supplies a pointer to the resource to initialize.

Return Value:

    STATUS_SUCCESS.

--*/

{

    PKEVENT Event;
    ULONG Index;
    POWNER_ENTRY OwnerTable;
    PKSEMAPHORE Semaphore;
    ULONG TableSize;

    ASSERT(MmDeterminePoolType(Resource) == NonPagedPool);

    //
    // If the resource has an owner table, then zero the owner table.
    //

    OwnerTable = Resource->OwnerTable;
    if (OwnerTable != NULL) {
        TableSize = OwnerTable->TableSize;
        for (Index = 1; Index < TableSize; Index += 1) {
            OwnerTable[Index].OwnerThread = 0;
            OwnerTable[Index].OwnerCount = 0;
        }
    }

    //
    // Set the active count and flags to zero.
    //

    Resource->ActiveCount = 0;
    Resource->Flag = 0;

    //
    // If the resource has a shared waiter semaphore, then reinitialize
    // it.
    //

    Semaphore = Resource->SharedWaiters;
    if (Semaphore != NULL) {
        KeInitializeSemaphore(Semaphore, 0, MAXLONG);
    }

    //
    // If the resource has a exclusive waiter event, then reinitialize
    // it.
    //

    Event = Resource->ExclusiveWaiters;
    if (Event != NULL) {
        KeInitializeEvent(Event, SynchronizationEvent, FALSE);
    }

    //
    // Initialize the builtin owner table.
    //

    Resource->OwnerThreads[0].OwnerThread = 0;
    Resource->OwnerThreads[0].OwnerCount = 0;
    Resource->OwnerThreads[1].OwnerThread = 0;
    Resource->OwnerThreads[1].OwnerCount = 0;

    //
    // Set the contention count, number of shared waiters, and number
    // of exclusive waiters to zero.
    //

    Resource->ContentionCount = 0;
    Resource->NumberOfSharedWaiters = 0;
    Resource->NumberOfExclusiveWaiters = 0;

    //
    // Reinitialize the resource spinlock.
    //

    KeInitializeSpinLock(&Resource->SpinLock);
    return STATUS_SUCCESS;
}

VOID
ExDisableResourceBoostLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine disables priority inversion boosting for the specified
    resource.

Arguments:

    Resource - Supplies a pointer to the resource for which priority
        boosting is disabled.

Return Value:

    None.

--*/

{

    EXP_LOCK_HANDLE LockHandle;

    //
    // Disable priority boosts for the specified resource.
    //

    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    ASSERT_RESOURCE(Resource);

    Resource->Flag |= DisablePriorityBoost;
    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return;
}

BOOLEAN
ExAcquireResourceExclusiveLite(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The routine acquires the specified resource for exclusive access.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired
        for exclusive access.

    Wait - A boolean value that specifies whether to wait for the
        resource to become available if access cannot be granted
        immediately.

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    BOOLEAN Result;

    ASSERT((Resource->Flag & ResourceNeverExclusive) == 0);

    //
    // Acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();
    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    //
    // Resource acquisition must be protected from thread suspends.
    //

    EX_ENSURE_APCS_DISABLED (LockHandle.OldIrql,
                             Resource,
                             KeGetCurrentThread());

    ExpIncrementCounter(ExclusiveAcquire);

    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted. Otherwise, there is either a shared owner or
    // an exclusive owner.
    //

retry:
    if (Resource->ActiveCount != 0) {

        //
        // The resource is either owned exclusive or shared.
        //
        // If the resource is owned exclusive and the current thread is the
        // owner, then increment the recursion count.
        //

        if (IsOwnedExclusive(Resource) &&
            (Resource->OwnerThreads[0].OwnerThread == CurrentThread)) {
            Resource->OwnerThreads[0].OwnerCount += 1;
            Result = TRUE;

        } else {

            //
            // The resource is either owned exclusive by some other thread,
            // or owned shared.
            //
            // If wait is not specified, then return that the resource was
            // not acquired. Otherwise, wait for exclusive access to the
            // resource to be granted.
            //

            if (Wait == FALSE) {
                Result = FALSE;

            } else {

                //
                // If the exclusive wait event has not yet been allocated,
                // then the long path code must be taken.
                //

                if (Resource->ExclusiveWaiters == NULL) {
                    ExpAllocateExclusiveWaiterEvent(Resource, &LockHandle);
                    goto retry;
                }

                //
                // Wait for exclusive access to the resource to be granted
                // and set the owner thread.
                //

                Resource->NumberOfExclusiveWaiters += 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                ExpWaitForResource(Resource, Resource->ExclusiveWaiters);

                //
                // N.B. It is "safe" to store the owner thread without
                //      obtaining any locks since the thread has already
                //      been granted exclusive ownership.
                //

                Resource->OwnerThreads[0].OwnerThread = (ERESOURCE_THREAD)PsGetCurrentThread();
                return TRUE;
            }
        }

    } else {

        //
        // The resource is not owned.
        //

        Resource->Flag |= ResourceOwnedExclusive;
        Resource->OwnerThreads[0].OwnerThread = CurrentThread;
        Resource->OwnerThreads[0].OwnerCount = 1;
        Resource->ActiveCount = 1;
        Result = TRUE;
    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return Result;
}

BOOLEAN
ExTryToAcquireResourceExclusiveLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    The routine attempts to acquire the specified resource for exclusive
    access.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired
        for exclusive access.

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    BOOLEAN Result;

    ASSERT((Resource->Flag & ResourceNeverExclusive) == 0);

    //
    // Attempt to acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();
    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted. Otherwise, if the resource is owned exclusive
    // and the current thread is the owner, then access to the resource can
    // be immediately granted. Otherwise, access cannot be granted.
    //

    Result = FALSE;
    if (Resource->ActiveCount == 0) {
        ExpIncrementCounter(ExclusiveAcquire);
        Resource->Flag |= ResourceOwnedExclusive;
        Resource->OwnerThreads[0].OwnerThread = CurrentThread;
        Resource->OwnerThreads[0].OwnerCount = 1;
        Resource->ActiveCount = 1;
        Result = TRUE;

    } else if (IsOwnedExclusive(Resource) &&
        (Resource->OwnerThreads[0].OwnerThread == CurrentThread)) {
        ExpIncrementCounter(ExclusiveAcquire);
        Resource->OwnerThreads[0].OwnerCount += 1;
        Result = TRUE;
    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return Result;
}

BOOLEAN
ExAcquireResourceSharedLite(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The routine acquires the specified resource for shared access.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired
        for shared access.

    Wait - A boolean value that specifies whether to wait for the
        resource to become available if access cannot be granted
        immediately.

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry;

    //
    // Acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();
    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    //
    // Resource acquisition must be protected from thread suspends.
    //

    EX_ENSURE_APCS_DISABLED (LockHandle.OldIrql,
                             Resource,
                             KeGetCurrentThread());

    ExpIncrementCounter(SharedFirstLevel);

    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted.
    //

retry:
    if (Resource->ActiveCount == 0) {
        Resource->OwnerThreads[1].OwnerThread = CurrentThread;
        Resource->OwnerThreads[1].OwnerCount = 1;
        Resource->ActiveCount = 1;
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return TRUE;
    }

    //
    // The resource is either owned exclusive or shared.
    //
    // If the resource is owned exclusive and the current thread is the
    // owner, then treat the shared request as an exclusive request and
    // increment the recursion count. Otherwise, it is owned shared.
    //

    if (IsOwnedExclusive(Resource)) {
        if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
            Resource->OwnerThreads[0].OwnerCount += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }

        //
        // Find an empty entry in the thread array.
        //

        OwnerEntry = ExpFindCurrentThread(Resource, 0, &LockHandle);
        if (OwnerEntry == NULL) {
            goto retry;
        }

    } else {

        //
        // The resource is owned shared.
        //
        // If the current thread already has acquired the resource for
        // shared access, then increment the recursion count. Otherwise
        // grant shared access if there are no exclusive waiters.
        //

        OwnerEntry = ExpFindCurrentThread(Resource, CurrentThread, &LockHandle);
        if (OwnerEntry == NULL) {
            goto retry;
        }

        if (OwnerEntry->OwnerThread == CurrentThread) {
            OwnerEntry->OwnerCount += 1;

            ASSERT(OwnerEntry->OwnerCount != 0);

            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }

        //
        // If there are no exclusive waiters, then grant shared access
        // to the resource. Otherwise, wait for the resource to become
        // available.
        //

        if (IsExclusiveWaiting(Resource) == FALSE) {
            OwnerEntry->OwnerThread = CurrentThread;
            OwnerEntry->OwnerCount = 1;
            Resource->ActiveCount += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }
    }

    //
    // The resource is either owned exclusive by some other thread, or
    // owned shared by some other threads, but there is an exclusive
    // waiter and the current thread does not already have shared access
    // to the resource.
    //
    // If wait is not specified, then return that the resource was
    // not acquired.
    //

    if (Wait == FALSE) {
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return FALSE;
    }

    //
    // If the shared wait semaphore has not yet been allocated, then the
    // long path must be taken.
    //

    if (Resource->SharedWaiters == NULL) {
        ExpAllocateSharedWaiterSemaphore(Resource, &LockHandle);
        goto retry;
    }

    //
    // Wait for shared access to the resource to be granted and increment
    // the recursion count.
    //

    OwnerEntry->OwnerThread = CurrentThread;
    OwnerEntry->OwnerCount = 1;
    Resource->NumberOfSharedWaiters += 1;
    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    ExpWaitForResource(Resource, Resource->SharedWaiters);
    return TRUE;
}

BOOLEAN
ExAcquireSharedStarveExclusive(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    )
/*++

Routine Description:

    This routine acquires the specified resource for shared access and
    does not wait for any pending exclusive owners.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired
        for shared access.

    Wait - A boolean value that specifies whether to wait for the
        resource to become available if access cannot be granted
        immediately.

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry;

    //
    // Acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();
    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    ExpIncrementCounter(StarveFirstLevel);

    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted.
    //

retry:
    if (Resource->ActiveCount == 0) {
        Resource->OwnerThreads[1].OwnerThread = CurrentThread;
        Resource->OwnerThreads[1].OwnerCount = 1;
        Resource->ActiveCount = 1;
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return TRUE;
    }

    //
    // The resource is either owned exclusive or shared.
    //
    // If the resource is owned exclusive and the current thread is the
    // owner, then treat the shared request as an exclusive request and
    // increment the recursion count. Otherwise, it is owned shared.
    //

    if (IsOwnedExclusive(Resource)) {
        if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
            Resource->OwnerThreads[0].OwnerCount += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }

        //
        // Find an empty entry in the thread array.
        //

        OwnerEntry = ExpFindCurrentThread(Resource, 0, &LockHandle);
        if (OwnerEntry == NULL) {
            goto retry;
        }

    } else {

        //
        // The resource is owned shared.
        //
        // If the current thread already has acquired the resource for
        // shared access, then increment the recursion count. Otherwise
        // grant shared access to the current thread.
        //

        OwnerEntry = ExpFindCurrentThread(Resource, CurrentThread, &LockHandle);
        if (OwnerEntry == NULL) {
            goto retry;
        }

        if (OwnerEntry->OwnerThread == CurrentThread) {
            OwnerEntry->OwnerCount += 1;

            ASSERT(OwnerEntry->OwnerCount != 0);

            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }

        //
        // Grant the current thread shared access to the resource.
        //

        OwnerEntry->OwnerThread = CurrentThread;
        OwnerEntry->OwnerCount = 1;
        Resource->ActiveCount += 1;
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return TRUE;
    }

    //
    // The resource is owned exclusive by some other thread.
    //
    // If wait is not specified, then return that the resource was
    // not acquired.
    //

    if (Wait == FALSE) {
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return FALSE;
    }

    //
    // If the shared wait semaphore has not yet been allocated, then the
    // long path must be taken.
    //

    if (Resource->SharedWaiters == NULL) {
        ExpAllocateSharedWaiterSemaphore(Resource, &LockHandle);
        goto retry;
    }

    //
    // Wait for shared access to the resource to be granted and increment
    // the recursion count.
    //

    OwnerEntry->OwnerThread = CurrentThread;
    OwnerEntry->OwnerCount = 1;
    Resource->NumberOfSharedWaiters += 1;
    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    ExpWaitForResource(Resource, Resource->SharedWaiters);
    return TRUE;
}

BOOLEAN
ExAcquireSharedWaitForExclusive(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    )
/*++

Routine Description:

    This routine acquires the specified resource for shared access, but
    waits for any pending exclusive owners.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired
        for shared access.

    Wait - A boolean value that specifies whether to wait for the
        resource to become available if access cannot be granted
        immediately.

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry;

    //
    // Acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();
    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    ExpIncrementCounter(WaitForExclusive);

    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted.
    //

retry:
    if (Resource->ActiveCount == 0) {
        Resource->OwnerThreads[1].OwnerThread = CurrentThread;
        Resource->OwnerThreads[1].OwnerCount = 1;
        Resource->ActiveCount = 1;
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return TRUE;
    }

    //
    // The resource is either owned exclusive or shared.
    //
    // If the resource is owned exclusive and the current thread is the
    // owner, then treat the shared request as an exclusive request and
    // increment the recursion count. Otherwise, it is owned shared.
    //

    if (IsOwnedExclusive(Resource)) {
        if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
            Resource->OwnerThreads[0].OwnerCount += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }

        //
        // Find an empty entry in the thread array.
        //

        OwnerEntry = ExpFindCurrentThread(Resource, 0, &LockHandle);
        if (OwnerEntry == NULL) {
            goto retry;
        }

    } else {

        //
        // The resource is owned shared.
        //
        // If there is an exclusive waiter, then wait for the exclusive
        // waiter to gain access to the resource, then acquire the resource
        // shared without regard to exclusive waiters. Otherwise, if the
        // current thread already has acquired the resource for shared access,
        // then increment the recursion count. Otherwise grant shared access
        // to the current thread.
        //

        if (IsExclusiveWaiting(Resource)) {

            //
            // The resource is shared, but there is an exclusive waiter.
            //
            // It doesn't matter if this thread is already one of the shared
            // owner(s) - if TRUE is specified, this thread must block - an APC
            // will release the resource to unjam things and callers count on
            // this behavior.
            //

#if 0
            //
            // This code must NOT be enabled as per the comment above.
            //

            OwnerEntry = ExpFindCurrentThread(Resource, CurrentThread, NULL);

            if ((OwnerEntry != NULL) &&
                (OwnerEntry->OwnerThread == CurrentThread)) {
                ASSERT(OwnerEntry->OwnerCount != 0);
                OwnerEntry->OwnerCount += 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                return TRUE;
            }
#endif

            //
            // If wait is not specified, then return that the resource was
            // not acquired.
            //

            if (Wait == FALSE) {
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                return FALSE;
            }

            //
            // If the shared wait semaphore has not yet been allocated, then
            // allocate and initialize it.
            //

            if (Resource->SharedWaiters == NULL) {
                ExpAllocateSharedWaiterSemaphore(Resource, &LockHandle);
                goto retry;
            }

            //
            // Increment the number of shared waiters and wait for shared
            // access to the resource to be granted to some other set of
            // threads, and then acquire the resource shared without regard
            // to exclusive access.
            //
            // N.B. The resource is left in a state such that the calling
            //      thread does not have a reference in the owner table
            //      for the requested access even though the active count
            //      is incremented when control is returned. However, the
            //      resource is owned shared at this point, so an owner
            //      entry can simply be allocated and the owner count set
            //      to one.
            //

            Resource->NumberOfSharedWaiters += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            ExpWaitForResource(Resource, Resource->SharedWaiters);

            //
            // Reacquire the resource spin lock, allocate an owner entry,
            // and initialize the owner count to one. The active count
            // was already incremented when shared access was granted.
            //

            EXP_LOCK_RESOURCE(Resource, &LockHandle);
            do {
            } while ((OwnerEntry = ExpFindCurrentThread(Resource,
                                                        CurrentThread,
                                                        &LockHandle)) == NULL);

            ASSERT(IsOwnedExclusive(Resource) == FALSE);
            ASSERT(Resource->ActiveCount > 0);
            ASSERT(OwnerEntry->OwnerThread != CurrentThread);

            OwnerEntry->OwnerThread = CurrentThread;
            OwnerEntry->OwnerCount = 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;

        } else {
            OwnerEntry = ExpFindCurrentThread(Resource, CurrentThread, &LockHandle);
            if (OwnerEntry == NULL) {
                goto retry;
            }

            if (OwnerEntry->OwnerThread == CurrentThread) {
                OwnerEntry->OwnerCount += 1;

                ASSERT(OwnerEntry->OwnerCount != 0);

                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                return TRUE;
            }

            //
            // Grant the current thread shared access to the resource.
            //

            OwnerEntry->OwnerThread = CurrentThread;
            OwnerEntry->OwnerCount = 1;
            Resource->ActiveCount += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }
    }

    //
    // The resource is owned exclusive by some other thread.
    //
    // If wait is not specified, then return that the resource was
    // not acquired.
    //

    if (Wait == FALSE) {
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return FALSE;
    }

    //
    // If the shared wait semaphore has not yet been allocated, then allocate
    // and initialize it.
    //

    if (Resource->SharedWaiters == NULL) {
        ExpAllocateSharedWaiterSemaphore(Resource, &LockHandle);
        goto retry;
    }

    //
    // Wait for shared access to the resource to be granted and increment
    // the recursion count.
    //

    OwnerEntry->OwnerThread = CurrentThread;
    OwnerEntry->OwnerCount = 1;
    Resource->NumberOfSharedWaiters += 1;
    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    ExpWaitForResource(Resource, Resource->SharedWaiters);
    return TRUE;
}

VOID
FASTCALL
ExReleaseResourceLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine releases the specified resource for the current thread
    and decrements the recursion count. If the count reaches zero, then
    the resource may also be released.

Arguments:

    Resource - Supplies a pointer to the resource to release.

Return Value:

    None.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    ULONG Index;
    ULONG Number;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry, OwnerEnd;

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();

    //
    // Acquire exclusive access to the specified resource.
    //

    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    ASSERT_RESOURCE(Resource);

    //
    // Resource release must be protected from thread suspends.
    //

    EX_ENSURE_APCS_DISABLED (LockHandle.OldIrql,
                             Resource,
                             KeGetCurrentThread());

    //
    // If the resource is exclusively owned, then release exclusive
    // ownership. Otherwise, release shared ownership.
    //
    // N.B. The two release paths are split since this is such a high
    //      frequency function.
    //

    if (IsOwnedExclusive(Resource)) {

#if DBG
        //
        // This can only be enabled in checked builds because this (unusual)
        // behavior might have worked in earlier releases of NT.  However,
        // in the checked builds, this can be enabled because callers really
        // should convert to using ExReleaseResourceForThreadLite instead.
        //

        if (Resource->OwnerThreads[0].OwnerThread != CurrentThread) {
            KeBugCheckEx(RESOURCE_NOT_OWNED,
                         (ULONG_PTR)Resource,
                         (ULONG_PTR)CurrentThread,
                         (ULONG_PTR)Resource->OwnerTable,
                         0x1);
        }
#endif

        //
        // Decrement the recursion count and check if ownership can be
        // released.
        //

        ASSERT(Resource->OwnerThreads[0].OwnerCount > 0);

        if (--Resource->OwnerThreads[0].OwnerCount != 0) {
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return;
        }

        //
        // Clear the owner thread.
        //

        Resource->OwnerThreads[0].OwnerThread = 0;

        //
        // The thread recursion count reached zero so decrement the resource
        // active count. If the active count reaches zero, then the resource
        // is no longer owned and an attempt should be made to grant access to
        // another thread.
        //

        ASSERT(Resource->ActiveCount > 0);

        if (--Resource->ActiveCount == 0) {

            //
            // If there are shared waiters, then grant shared access to the
            // resource. Otherwise, grant exclusive ownership if there are
            // exclusive waiters.
            //

            if (IsSharedWaiting(Resource)) {
                Resource->Flag &= ~ResourceOwnedExclusive;
                Number = Resource->NumberOfSharedWaiters;
                Resource->ActiveCount =  (SHORT)Number;
                Resource->NumberOfSharedWaiters = 0;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeReleaseSemaphore(Resource->SharedWaiters, 0, Number, FALSE);
                return;

            } else if (IsExclusiveWaiting(Resource)) {
                Resource->OwnerThreads[0].OwnerThread = 1;
                Resource->OwnerThreads[0].OwnerCount = 1;
                Resource->ActiveCount = 1;
                Resource->NumberOfExclusiveWaiters -= 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeSetEventBoostPriority(Resource->ExclusiveWaiters,
                                        (PRKTHREAD *)&Resource->OwnerThreads[0].OwnerThread);
                return;
            }

            Resource->Flag &= ~ResourceOwnedExclusive;
        }

    } else {
        if (Resource->OwnerThreads[1].OwnerThread == CurrentThread) {
            OwnerEntry = &Resource->OwnerThreads[1];

        } else if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
            OwnerEntry = &Resource->OwnerThreads[0];

        } else {
            Index = ((PKTHREAD)(CurrentThread))->ResourceIndex;
            OwnerEntry = Resource->OwnerTable;

            if (OwnerEntry == NULL) {
                KeBugCheckEx(RESOURCE_NOT_OWNED,
                             (ULONG_PTR)Resource,
                             (ULONG_PTR)CurrentThread,
                             (ULONG_PTR)Resource->OwnerTable,
                             0x2);
            }

            //
            // If the resource hint is not within range or the resource
            // table entry does match the current thread, then search
            // the owner table for a match.
            //

            if ((Index >= OwnerEntry->TableSize) ||
                (OwnerEntry[Index].OwnerThread != CurrentThread)) {
                OwnerEnd = &OwnerEntry[OwnerEntry->TableSize];
                while (1) {
                    OwnerEntry += 1;
                    if (OwnerEntry >= OwnerEnd) {
                       KeBugCheckEx(RESOURCE_NOT_OWNED,
                             (ULONG_PTR)Resource,
                             (ULONG_PTR)CurrentThread,
                             (ULONG_PTR)Resource->OwnerTable,
                             0x3);
                    }
                    if (OwnerEntry->OwnerThread == CurrentThread) {
                        break;
                    }
                }

            } else {
                OwnerEntry = &OwnerEntry[Index];
            }
        }

        //
        // Decrement the recursion count and check if ownership can be
        // released.
        //

        ASSERT(OwnerEntry->OwnerThread == CurrentThread);
        ASSERT(OwnerEntry->OwnerCount > 0);

        if (--OwnerEntry->OwnerCount != 0) {
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return;
        }

        //
        // Clear the owner thread.
        //

        OwnerEntry->OwnerThread = 0;

        //
        // The thread recursion count reached zero so decrement the resource
        // active count. If the active count reaches zero, then the resource
        // is no longer owned and an attempt should be made to grant access to
        // another thread.
        //

        ASSERT(Resource->ActiveCount > 0);

        if (--Resource->ActiveCount == 0) {

            //
            // If there are exclusive waiters, then grant exclusive access
            // to the resource.
            //

            if (IsExclusiveWaiting(Resource)) {
                Resource->Flag |= ResourceOwnedExclusive;
                Resource->OwnerThreads[0].OwnerThread = 1;
                Resource->OwnerThreads[0].OwnerCount = 1;
                Resource->ActiveCount = 1;
                Resource->NumberOfExclusiveWaiters -= 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeSetEventBoostPriority(Resource->ExclusiveWaiters,
                                        (PRKTHREAD *)&Resource->OwnerThreads[0].OwnerThread);

                return;
            }
        }
    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return;
}

VOID
ExReleaseResourceForThreadLite(
    IN PERESOURCE Resource,
    IN ERESOURCE_THREAD CurrentThread
    )

/*++

Routine Description:

    This routine release the specified resource for the specified thread
    and decrements the recursion count. If the count reaches zero, then
    the resource may also be released.

Arguments:

    Resource - Supplies a pointer to the resource to release.

    Thread - Supplies the thread that originally acquired the resource.

Return Value:

    None.

--*/

{

    ULONG Index;
    ULONG Number;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry, OwnerEnd;

    ASSERT(CurrentThread != 0);

    //
    // Acquire exclusive access to the specified resource.
    //

    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    ASSERT_RESOURCE(Resource);

    //
    // Resource release must be protected from thread suspends.
    //

    EX_ENSURE_APCS_DISABLED (LockHandle.OldIrql,
                             Resource,
                             KeGetCurrentThread());

    //
    // If the resource is exclusively owned, then release exclusive
    // ownership. Otherwise, release shared ownership.
    //
    // N.B. The two release paths are split since this is such a high
    //      frequency function.
    //

    if (IsOwnedExclusive(Resource)) {

        ASSERT(Resource->OwnerThreads[0].OwnerThread == CurrentThread);

        //
        // Decrement the recursion count and check if ownership can be
        // released.
        //

        ASSERT(Resource->OwnerThreads[0].OwnerCount > 0);

        if (--Resource->OwnerThreads[0].OwnerCount != 0) {
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return;
        }

        //
        // Clear the owner thread.
        //

        Resource->OwnerThreads[0].OwnerThread = 0;

        //
        // The thread recursion count reached zero so decrement the resource
        // active count. If the active count reaches zero, then the resource
        // is no longer owned and an attempt should be made to grant access to
        // another thread.
        //

        ASSERT(Resource->ActiveCount > 0);

        if (--Resource->ActiveCount == 0) {

            //
            // If there are shared waiters, then grant shared access to the
            // resource. Otherwise, grant exclusive ownership if there are
            // exclusive waiters.
            //

            if (IsSharedWaiting(Resource)) {
                Resource->Flag &= ~ResourceOwnedExclusive;
                Number = Resource->NumberOfSharedWaiters;
                Resource->ActiveCount =  (SHORT)Number;
                Resource->NumberOfSharedWaiters = 0;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeReleaseSemaphore(Resource->SharedWaiters, 0, Number, FALSE);
                return;

            } else if (IsExclusiveWaiting(Resource)) {
                Resource->OwnerThreads[0].OwnerThread = 1;
                Resource->OwnerThreads[0].OwnerCount = 1;
                Resource->ActiveCount = 1;
                Resource->NumberOfExclusiveWaiters -= 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeSetEventBoostPriority(Resource->ExclusiveWaiters,
                                        (PRKTHREAD *)&Resource->OwnerThreads[0].OwnerThread);

                return;
            }

            Resource->Flag &= ~ResourceOwnedExclusive;
        }

    } else {
        if (Resource->OwnerThreads[1].OwnerThread == CurrentThread) {
            OwnerEntry = &Resource->OwnerThreads[1];

        } else if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
            OwnerEntry = &Resource->OwnerThreads[0];

        } else {

            //
            // If the specified current thread is an owner address (low
            // bits are nonzero), then set the hint index to the first
            // entry. Otherwise, set the hint index from the owner thread.
            //

            Index = 1;
            if (((ULONG)CurrentThread & 3) == 0) {
                Index = ((PKTHREAD)(CurrentThread))->ResourceIndex;
            }

            OwnerEntry = Resource->OwnerTable;

            ASSERT(OwnerEntry != NULL);

            //
            // If the resource hint is not within range or the resource
            // table entry does match the current thread, then search
            // the owner table for a match.
            //

            if ((Index >= OwnerEntry->TableSize) ||
                (OwnerEntry[Index].OwnerThread != CurrentThread)) {
                OwnerEnd = &OwnerEntry[OwnerEntry->TableSize];
                while (1) {
                    OwnerEntry += 1;
                    if (OwnerEntry >= OwnerEnd) {
                       KeBugCheckEx(RESOURCE_NOT_OWNED,
                             (ULONG_PTR)Resource,
                             (ULONG_PTR)CurrentThread,
                             (ULONG_PTR)Resource->OwnerTable,
                             0x3);
                    }
                    if (OwnerEntry->OwnerThread == CurrentThread) {
                        break;
                    }
                }

            } else {
                OwnerEntry = &OwnerEntry[Index];
            }
        }

        //
        // Decrement the recursion count and check if ownership can be
        // released.
        //

        ASSERT(OwnerEntry->OwnerThread == CurrentThread);
        ASSERT(OwnerEntry->OwnerCount > 0);

        if (--OwnerEntry->OwnerCount != 0) {
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return;
        }

        //
        // Clear the owner thread.
        //

        OwnerEntry->OwnerThread = 0;

        //
        // The thread recursion count reached zero so decrement the resource
        // active count. If the active count reaches zero, then the resource
        // is no longer owned and an attempt should be made to grant access to
        // another thread.
        //

        ASSERT(Resource->ActiveCount > 0);

        if (--Resource->ActiveCount == 0) {

            //
            // If there are exclusive waiters, then grant exclusive access
            // to the resource.
            //

            if (IsExclusiveWaiting(Resource)) {
                Resource->Flag |= ResourceOwnedExclusive;
                Resource->OwnerThreads[0].OwnerThread = 1;
                Resource->OwnerThreads[0].OwnerCount = 1;
                Resource->ActiveCount = 1;
                Resource->NumberOfExclusiveWaiters -= 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeSetEventBoostPriority(Resource->ExclusiveWaiters,
                                        (PRKTHREAD *)&Resource->OwnerThreads[0].OwnerThread);

                return;
            }
        }
    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return;
}

VOID
ExSetResourceOwnerPointer(
    IN PERESOURCE Resource,
    IN PVOID OwnerPointer
    )

/*++

Routine Description:

    This routine locates the owner entry for the current thread and stores
    the specified owner address as the owner thread. Subsequent to calling
    this routine, the only routine which may be called for this resource is
    ExReleaseResourceForThreadLite, supplying the owner address as the "thread".

    Owner addresses must obey the following rules:

        They must be a unique pointer to a structure allocated in system space,
        and they must point to a structure which remains allocated until after
        the call to ExReleaseResourceForThreadLite. This is to eliminate aliasing
        with a thread or other owner address.

        The low order two bits of the owner address must be set by the caller,
        so that other routines in the resource package can distinguish owner
        address from thread addresses.

Arguments:

    Resource - Supplies a pointer to the resource to release.

    OwnerPointer - Supplies a pointer to an allocated structure with the low
        order two bits set.

Return Value:

    None.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    ULONG Index;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry, OwnerEnd;

    ASSERT((OwnerPointer != 0) && (((ULONG_PTR)OwnerPointer & 3) == 3));

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();

    //
    // Acquire exclusive access to the specified resource.
    //

    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    ASSERT_RESOURCE(Resource);

    //
    // If the resource is exclusively owned, then it is the first owner entry.
    //

    if (IsOwnedExclusive(Resource)) {

        ASSERT(Resource->OwnerThreads[0].OwnerThread == CurrentThread);

        //
        // Set the owner address.
        //

        ASSERT(Resource->OwnerThreads[0].OwnerCount > 0);

        Resource->OwnerThreads[0].OwnerThread = (ULONG_PTR)OwnerPointer;

    //
    //  For shared access we have to search for the current thread to set
    //  the owner address.
    //

    } else {
        if (Resource->OwnerThreads[1].OwnerThread == CurrentThread) {
            Resource->OwnerThreads[1].OwnerThread = (ULONG_PTR)OwnerPointer;

        } else if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
            Resource->OwnerThreads[0].OwnerThread = (ULONG_PTR)OwnerPointer;

        } else {
            Index = ((PKTHREAD)(CurrentThread))->ResourceIndex;
            OwnerEntry = Resource->OwnerTable;

            ASSERT(OwnerEntry != NULL);

            //
            // If the resource hint is not within range or the resource
            // table entry does match the current thread, then search
            // the owner table for a match.
            //

            if ((Index >= OwnerEntry->TableSize) ||
                (OwnerEntry[Index].OwnerThread != CurrentThread)) {
                OwnerEnd = &OwnerEntry[OwnerEntry->TableSize];
                while (1) {
                    OwnerEntry += 1;
                    if (OwnerEntry >= OwnerEnd) {
                       KeBugCheckEx(RESOURCE_NOT_OWNED,
                             (ULONG_PTR)Resource,
                             (ULONG_PTR)CurrentThread,
                             (ULONG_PTR)Resource->OwnerTable,
                             0x3);
                    }
                    if (OwnerEntry->OwnerThread == CurrentThread) {
                        break;
                    }
                }

            } else {
                OwnerEntry = &OwnerEntry[Index];
            }

            OwnerEntry->OwnerThread = (ULONG_PTR)OwnerPointer;
        }
    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return;
}

VOID
ExConvertExclusiveToSharedLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine converts the specified resource from acquired for exclusive
    access to acquired for shared access.

Arguments:

    Resource - Supplies a pointer to the resource to acquire for shared access. it

Return Value:

    None.

--*/

{

    ULONG Number;
    EXP_LOCK_HANDLE LockHandle;

    //
    // Acquire exclusive access to the specified resource.
    //

    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);
    ASSERT(IsOwnedExclusive(Resource));
    ASSERT(Resource->OwnerThreads[0].OwnerThread == (ERESOURCE_THREAD)PsGetCurrentThread());

    //
    // Convert the granted access from exclusive to shared.
    //

    Resource->Flag &= ~ResourceOwnedExclusive;

    //
    // If there are any shared waiters, then grant them shared access.
    //

    if (IsSharedWaiting(Resource)) {
        Number = Resource->NumberOfSharedWaiters;
        Resource->ActiveCount = (SHORT)(Resource->ActiveCount + Number);
        Resource->NumberOfSharedWaiters = 0;
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        KeReleaseSemaphore(Resource->SharedWaiters, 0, Number, FALSE);
        return;
    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return;
}

NTSTATUS
ExDeleteResourceLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine deallocates any pool allocated to support the specified
    resource.


Arguments:

    Resource - Supplies a pointer to the resource whose allocated pool
        is freed.

Return Value:

    STATUS_SUCCESS.

--*/

{

#if defined(_COLLECT_RESOURCE_DATA_)

    ULONG Hash;
    PLIST_ENTRY NextEntry;
    PRESOURCE_HASH_ENTRY MatchEntry;
    PRESOURCE_HASH_ENTRY HashEntry;

#endif

    KIRQL OldIrql;

    ASSERT(IsSharedWaiting(Resource) == FALSE);
    ASSERT(IsExclusiveWaiting(Resource) == FALSE);

    //
    // Acquire the executive resource spinlock and remove the resource from
    // the system resource list.
    //

    ExAcquireSpinLock(&ExpResourceSpinLock, &OldIrql);

    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    RemoveEntryList(&Resource->SystemResourcesList);

#if defined(_COLLECT_RESOURCE_DATA_)

    //
    // Lookup resource initialization address in resource hash table. If
    // the address does not exist in the table, then create a new entry.
    //

    Hash = (ULONG)Resource->Address;
    Hash = ((Hash >> 24) ^ (Hash >> 16) ^ (Hash >> 8) ^ (Hash)) & (RESOURCE_HASH_TABLE_SIZE - 1);
    MatchEntry = NULL;
    NextEntry = ExpResourcePerformanceData.HashTable[Hash].Flink;
    while (NextEntry != &ExpResourcePerformanceData.HashTable[Hash]) {
        HashEntry = CONTAINING_RECORD(NextEntry,
                                      RESOURCE_HASH_ENTRY,
                                      ListEntry);

        if (HashEntry->Address == Resource->Address) {
            MatchEntry = HashEntry;
            break;
        }

        NextEntry = NextEntry->Flink;
    }

    //
    // If a matching initialization address was found, then update the call
    // site statistics. Otherwise, allocate a new hash entry and initialize
    // call site statistics.
    //

    if (MatchEntry != NULL) {
        MatchEntry->ContentionCount += Resource->ContentionCount;
        MatchEntry->Number += 1;

    } else {
        MatchEntry = ExAllocatePoolWithTag(NonPagedPool,
                                          sizeof(RESOURCE_HASH_ENTRY),
                                          'vEpR');

        if (MatchEntry != NULL) {
            MatchEntry->Address = Resource->Address;
            MatchEntry->ContentionCount = Resource->ContentionCount;
            MatchEntry->Number = 1;
            InsertTailList(&ExpResourcePerformanceData.HashTable[Hash],
                           &MatchEntry->ListEntry);
        }
    }

    ExpResourcePerformanceData.ActiveResourceCount -= 1;

#endif

    ExReleaseSpinLock(&ExpResourceSpinLock, OldIrql);

    //
    // If an owner table was allocated, then free it to pool.
    //

    if (Resource->OwnerTable != NULL) {
        ExFreePool(Resource->OwnerTable);
    }

    //
    // If a semaphore was allocated, then free it to pool.
    //

    if (Resource->SharedWaiters) {
        ExFreePool(Resource->SharedWaiters);
    }

    //
    // If an event was allocated, then free it to pool.
    //

    if (Resource->ExclusiveWaiters) {
        ExFreePool(Resource->ExclusiveWaiters);
    }

    return STATUS_SUCCESS;
}

ULONG
ExGetExclusiveWaiterCount(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine returns the exclusive waiter count.


Arguments:

    Resource - Supplies a pointer to and executive resource.

Return Value:

    The current number of exclusive waiters is returned as the function
    value.

--*/

{
    return Resource->NumberOfExclusiveWaiters;
}

ULONG
ExGetSharedWaiterCount(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine returns the shared waiter count.


Arguments:

    Resource - Supplies a pointer to and executive resource.

Return Value:

    The current number of shared waiters is returned as the function
    value.

--*/

{
    return Resource->NumberOfSharedWaiters;
}

BOOLEAN
ExIsResourceAcquiredExclusiveLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine determines if a resource is acquired exclusive by the
    calling thread.

Arguments:

    Resource - Supplies a pointer the resource to query.

Return Value:

    If the current thread has acquired the resource exclusive, a value of
    TRUE is returned. Otherwise, a value of FALSE is returned.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    BOOLEAN Result;

    //
    // Acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();
    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    ASSERT_RESOURCE(Resource);

    //
    // If the resource is owned exclusive and the current thread is the
    // owner, then set the return value of TRUE. Otherwise, set the return
    // value to FALSE.
    //

    Result = FALSE;
    if ((IsOwnedExclusive(Resource)) &&
        (Resource->OwnerThreads[0].OwnerThread == CurrentThread)) {
        Result = TRUE;
    }

    //
    // Release exclusive access to the specified resource.
    //

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return Result;
}

ULONG
ExIsResourceAcquiredSharedLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine determines if a resource is acquired either shared or
    exclusive by the calling thread.

Arguments:

    Resource - Supplies a pointer to the resource to query.

Return Value:

    If the current thread has not acquired the resource a value of zero
    is returned. Otherwise, the thread's acquire count is returned.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    ULONG Index;
    ULONG Number;
    POWNER_ENTRY OwnerEntry;
    ULONG Result;
    EXP_LOCK_HANDLE LockHandle;

    //
    // Acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();
    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    ASSERT_RESOURCE(Resource);

    //
    // Find the current thread in the thread array and return the count.
    //
    // N.B. If the thread is not found a value of zero will be returned.
    //

    if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
        Result = Resource->OwnerThreads[0].OwnerCount;

    } else if (Resource->OwnerThreads[1].OwnerThread == CurrentThread) {
        Result = Resource->OwnerThreads[1].OwnerCount;

    } else {

        //
        // If the resource hint is not within range or the resource table
        // entry does not match the current thread, then search the owner
        // table for a match.
        //

        OwnerEntry = Resource->OwnerTable;
        Result = 0;
        if (OwnerEntry != NULL) {
            Index = ((PKTHREAD)(CurrentThread))->ResourceIndex;
            Number = OwnerEntry->TableSize;
            if ((Index >= Number) ||
                (OwnerEntry[Index].OwnerThread != CurrentThread)) {
                for (Index = 1; Index < Number; Index += 1) {
                    OwnerEntry += 1;
                    if (OwnerEntry->OwnerThread == CurrentThread) {
                        Result = OwnerEntry->OwnerCount;
                        break;
                    }
                }

            } else {
                Result = OwnerEntry[Index].OwnerCount;
            }
        }
    }

    //
    // Release exclusive access to the specified resource.
    //

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return Result;
}

NTSTATUS
ExQuerySystemLockInformation(
    OUT PRTL_PROCESS_LOCKS LockInformation,
    IN ULONG LockInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )

{

    NTSTATUS Status;
    KIRQL OldIrql;
    ULONG RequiredLength;
    PLIST_ENTRY Head, Next;
    PRTL_PROCESS_LOCK_INFORMATION LockInfo;
    PERESOURCE Resource;
    PETHREAD OwningThread;

    RequiredLength = FIELD_OFFSET(RTL_PROCESS_LOCKS, Locks);
    if (LockInformationLength < RequiredLength) {
        Status = STATUS_INFO_LENGTH_MISMATCH;

    } else {
        Status = STATUS_SUCCESS;
        ExAcquireSpinLock(&ExpResourceSpinLock, &OldIrql);
        try {
            LockInformation->NumberOfLocks = 0;
            LockInfo = &LockInformation->Locks[0];
            Head = &ExpSystemResourcesList;
            Next = Head->Flink;
            while (Next != Head) {
                Resource = CONTAINING_RECORD(Next,
                                             ERESOURCE,
                                             SystemResourcesList);

                LockInformation->NumberOfLocks += 1;
                RequiredLength += sizeof(RTL_PROCESS_LOCK_INFORMATION);

                if (LockInformationLength < RequiredLength) {
                    Status = STATUS_INFO_LENGTH_MISMATCH;

                } else {
                    LockInfo->Address = Resource;
                    LockInfo->Type = RTL_RESOURCE_TYPE;
                    LockInfo->CreatorBackTraceIndex = 0;
#if i386 && !FPO
                    LockInfo->CreatorBackTraceIndex = (USHORT)Resource->CreatorBackTraceIndex;
#endif // i386 && !FPO

                    if ((Resource->OwnerThreads[0].OwnerThread != 0) &&
                        ((Resource->OwnerThreads[0].OwnerThread & 3) == 0)) {
                        OwningThread = (PETHREAD)(Resource->OwnerThreads[0].OwnerThread);
                        LockInfo->OwningThread = OwningThread->Cid.UniqueThread;

                    } else {
                        LockInfo->OwningThread = 0;
                    }

                    LockInfo->LockCount = Resource->ActiveCount;
                    LockInfo->ContentionCount = Resource->ContentionCount;
                    LockInfo->NumberOfWaitingShared = Resource->NumberOfSharedWaiters;
                    LockInfo->NumberOfWaitingExclusive = Resource->NumberOfExclusiveWaiters;
                    LockInfo += 1;
                }

                if (Next == Next->Flink) {
                    Next = Head;

                } else {
                    Next = Next->Flink;
                }
            }

        } finally {
            ExReleaseSpinLock(&ExpResourceSpinLock, OldIrql);
        }
    }

    if (ARGUMENT_PRESENT(ReturnLength)) {
        *ReturnLength = RequiredLength;
    }

    return Status;
}

VOID
FASTCALL
ExpBoostOwnerThread (
    IN PKTHREAD CurrentThread,
    IN PKTHREAD OwnerThread
    )
/*++

Routine Description:

    This function boots the priority of the specified owner thread iff
    its priority is less than that of the current thread and is also
    less than fourteen.

    N.B. this function is called with the dispatcher database lock held.

Arguments:

    CurrentThread - Supplies a pointer to the current thread object.

    OwnerThread - Supplies a pointer to the owner thread object.

Return Value:

    None.

--*/

{

    //
    // If the owner thread is lower priority than the current thread, the
    // current thread is running at a priority less than 14, then boost the
    // priority of the owner thread for a quantum.
    //
    // N.B. A thread that has already been boosted may be reboosted to allow
    //      it to execute and release resources. When the boost is removed,
    //      the thread will return to its priority before any boosting.
    //

    if (((ULONG_PTR)OwnerThread & 0x3) == 0) {
        if ((OwnerThread->Priority < CurrentThread->Priority) &&
            (OwnerThread->Priority < 14)) {
            OwnerThread->PriorityDecrement += 14 - OwnerThread->Priority;
            OwnerThread->DecrementCount = ROUND_TRIP_DECREMENT_COUNT;
            KiSetPriorityThread(OwnerThread, 14);
            OwnerThread->Quantum = OwnerThread->ApcState.Process->ThreadQuantum;
        }
    }

    return;
}

VOID
FASTCALL
ExpWaitForResource (
    IN PERESOURCE Resource,
    IN PVOID Object
    )
/*++

Routine Description:

    The routine waits for the specified resource object to be set. If the
    wait is too long the priority of the current owners of the resource
    are boosted.

Arguments:

    Resource - Supplies a pointer to the resource to wait for.

    Object - Supplies a pointer to an event (exclusive) or semaphore
       (shared) to wait for.

Return Value:

    None.

--*/

{

    ULONG Index;
    ULONG Limit;
    ULONG Number;
    POWNER_ENTRY OwnerEntry;
    PKTHREAD OwnerThread;
    NTSTATUS Status;
    PKTHREAD CurrentThread;
    LARGE_INTEGER Timeout;
#if DBG
    EXP_LOCK_HANDLE LockHandle;
#endif

    //
    // Increment the contention count for the resource, set the initial
    // timeout value, and wait for the specified object to be signalled
    // or a timeout to occur.
    //

    Limit = 0;
    Resource->ContentionCount += 1;
    Timeout.QuadPart = 500 * -10000;
    do {
        Status = KeWaitForSingleObject (
                        Object,
                        Executive,
                        KernelMode,
                        FALSE,
                        &Timeout );

        if (Status != STATUS_TIMEOUT) {
            break;
        }

        //
        // The limit has been exceeded, then output status information.
        //

        Limit += 1;
        Timeout = ExpTimeout;
        if (Limit > ExResourceTimeoutCount) {
            Limit = 0;

#if DBG
            //
            // Output information for the specified resource.
            //

            EXP_LOCK_RESOURCE(Resource, &LockHandle);
            DbgPrint("Resource @ %p\n", Resource);
            DbgPrint(" ActiveCount = %04lx  Flags = %s%s%s\n",
                     Resource->ActiveCount,
                     IsOwnedExclusive(Resource) ? "IsOwnedExclusive " : "",
                     IsSharedWaiting(Resource) ? "SharedWaiter "     : "",
                     IsExclusiveWaiting(Resource) ? "ExclusiveWaiter "  : "");

            DbgPrint(" NumberOfExclusiveWaiters = %04lx\n", Resource->NumberOfExclusiveWaiters);

            DbgPrint("  Thread = %p, Count = %02x\n",
                     Resource->OwnerThreads[0].OwnerThread,
                     Resource->OwnerThreads[0].OwnerCount);

            DbgPrint("  Thread = %p, Count = %02x\n",
                     Resource->OwnerThreads[1].OwnerThread,
                     Resource->OwnerThreads[1].OwnerCount);

            OwnerEntry = Resource->OwnerTable;
            if (OwnerEntry != NULL) {
                Number = OwnerEntry->TableSize;
                for(Index = 1; Index < Number; Index += 1) {
                    OwnerEntry += 1;
                    DbgPrint("  Thread = %p, Count = %02x\n",
                             OwnerEntry->OwnerThread,
                             OwnerEntry->OwnerCount);
                }
            }

            DbgBreakPoint();
            DbgPrint("EX - Rewaiting\n");
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
#endif
        }

        //
        // If priority boosts are allowed, then attempt to boost the priority
        // of owner threads.
        //

        if (IsBoostAllowed(Resource)) {

            //
            // Get the current thread address, lock the dispatcher database,
            // and set wait next in the current thread so the dispatcher
            // database lock does not need to be released before waiting
            // for the resource.
            //
            // N.B. Since the dispatcher database lock instead of the resource
            //      lock is being used to synchronize access to the resource,
            //      it is possible for the information being read from the
            //      resource to be stale. However, the important thing that
            //      cannot change is a valid thread address. Thus a thread
            //      could possibly get boosted that actually has dropped its
            //      access to the resource, but it guaranteed that the thread
            //      cannot be terminated or otherwise deleted.
            //
            // N.B. The dispatcher lock is released by the wait at the top of
            //      loop.
            //

            CurrentThread = KeGetCurrentThread();

            KiLockDispatcherDatabase(&CurrentThread->WaitIrql);
            CurrentThread->WaitNext = TRUE;

            //
            // Attempt to boost the one owner that can be shared or exclusive.
            //

            OwnerThread = (PKTHREAD)Resource->OwnerThreads[0].OwnerThread;
            if (OwnerThread != NULL) {
                ExpBoostOwnerThread(CurrentThread, OwnerThread);
            }

            //
            // If the specified resource is not owned exclusive, then attempt
            // to boost all the owning shared threads priority.
            //

            if (!IsOwnedExclusive(Resource)) {
                OwnerThread = (PKTHREAD)Resource->OwnerThreads[1].OwnerThread;
                if (OwnerThread != NULL) {
                    ExpBoostOwnerThread(CurrentThread, OwnerThread);
                }

                OwnerEntry = Resource->OwnerTable;
                if (OwnerEntry != NULL) {
                    Number = OwnerEntry->TableSize;
                    for(Index = 1; Index < Number; Index += 1) {
                        OwnerEntry += 1;
                        OwnerThread = (PKTHREAD)OwnerEntry->OwnerThread;
                        if (OwnerThread != NULL) {
                            ExpBoostOwnerThread(CurrentThread, OwnerThread);
                        }
                    }
                }
            }
        }

    } while (TRUE);

    return;
}

POWNER_ENTRY
FASTCALL
ExpFindCurrentThread(
    IN PERESOURCE Resource,
    IN ERESOURCE_THREAD CurrentThread,
    IN PEXP_LOCK_HANDLE LockHandle OPTIONAL
    )

/*++

Routine Description:

    This function searches for the specified thread in the resource
    thread array. If the thread is located, then a pointer to the
    array entry is returned as the function value. Otherwise, a pointer
    to a free entry is returned.

    N.B. This routine is entered with the resource lock held and returns
         with the resource lock held. If the resource lock is released
         to expand the owner table, then the return value will be NULL.
         This is a signal to the caller that the complete operation must
         be repeated. This is done to avoid holding the resource lock
         while memory is allocated and freed.

Arguments:

    Resource - Supplies a pointer to the resource for which the search
        is performed.

    CurrentThread - Supplies the identification of the thread to search
        for.

    LockHandle - Supplies a pointer to a lock handle.  If NULL, then the
        caller just wants to know if the requested thread is an owner of
        this resource.  No free entry index is returned and no table
        expansion is performed.  Instead NULL is returned if the requested
        thread cannot be found in the table.

Return Value:

    A pointer to an owner entry is returned or NULL if one could not be
    allocated.

--*/

{

    POWNER_ENTRY FreeEntry;
    ULONG NewSize;
    ULONG OldSize;
    POWNER_ENTRY OldTable;
    POWNER_ENTRY OwnerEntry;
    POWNER_ENTRY OwnerBound;
    POWNER_ENTRY OwnerTable;
    KIRQL OldIrql;

    //
    // Search the owner threads for the specified thread and return either
    // a pointer to the found thread or a pointer to a free thread table
    // entry.
    //

    if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
        return &Resource->OwnerThreads[0];

    } else if (Resource->OwnerThreads[1].OwnerThread == CurrentThread) {
        return &Resource->OwnerThreads[1];

    } else {
        FreeEntry = NULL;
        if (Resource->OwnerThreads[1].OwnerThread == 0) {
            FreeEntry = &Resource->OwnerThreads[1];
        }

        OwnerEntry = Resource->OwnerTable;
        if (OwnerEntry == NULL) {
            OldSize = 0;

        } else {
            OldSize = OwnerEntry->TableSize;
            OwnerBound = &OwnerEntry[OldSize];
            OwnerEntry += 1;
            do {
                if (OwnerEntry->OwnerThread == CurrentThread) {
                    KeGetCurrentThread()->ResourceIndex = (UCHAR)(OwnerEntry - Resource->OwnerTable);
                    return OwnerEntry;
                }

                if ((FreeEntry == NULL) &&
                    (OwnerEntry->OwnerThread == 0)) {
                    FreeEntry = OwnerEntry;
                }

                OwnerEntry += 1;
            } while (OwnerEntry != OwnerBound);
        }
    }

    if (!ARGUMENT_PRESENT(LockHandle)) {

        //
        // No argument indicates the caller does not want a free entry or
        // automatic table expansion.  The caller just wants to know if the
        // requested thread is a resource owner.  And clearly the answer is
        // NO at this point.
        //

        return NULL;
    }

    //
    // If a free entry was found in the table, then return the address of the
    // free entry. Otherwise, expand the size of the owner thread table.
    //

    if (FreeEntry != NULL) {
        KeGetCurrentThread()->ResourceIndex = (UCHAR)(FreeEntry - Resource->OwnerTable);
        return FreeEntry;
    }

    //
    // Save previous owner table address and allocate an expanded owner table.
    //

    ExpIncrementCounter(OwnerTableExpands);
    OldTable = Resource->OwnerTable;
    EXP_UNLOCK_RESOURCE(Resource, LockHandle);
    if (OldSize == 0 ) {
        NewSize = 3;

    } else {
        NewSize = OldSize + 4;
    }

    OwnerTable = ExAllocatePoolWithTag(NonPagedPool,
                                       NewSize * sizeof(OWNER_ENTRY),
                                       'aTeR');

    if (OwnerTable == NULL) {
        KeDelayExecutionThread(KernelMode, FALSE, &ExShortTime);

    } else {

        //
        // Zero the expansion area of the new owner table.
        //

        RtlZeroMemory(OwnerTable + OldSize,
                      (NewSize - OldSize) * sizeof(OWNER_ENTRY));

        //
        // Acquire the resource lock and determine if the owner table
        // has been expanded by another thread while the new owner table
        // was being allocated. If the owner table has been expanded by
        // another thread, then release the new owner table. Otherwise,
        // copy the owner table to the new owner table and establish the
        // new owner table as the owner table.
        //

        EXP_LOCK_RESOURCE(Resource, LockHandle);
        if ((OldTable != Resource->OwnerTable) ||
            ((OldTable != NULL) && (OldSize != OldTable->TableSize))) {
            EXP_UNLOCK_RESOURCE(Resource, LockHandle);
            ExFreePool(OwnerTable);

        } else {
            RtlCopyMemory(OwnerTable,
                          OldTable,
                          OldSize * sizeof(OWNER_ENTRY));

            //
            // Swapping of the owner table must be done while owning the
            // dispatcher lock to prevent a priority boost scan from occuring
            // while the table is being changed. The priority boost scan is
            // done when a time out occurs on a specific resource.
            //

            KiLockDispatcherDatabase(&OldIrql);
            OwnerTable->TableSize = NewSize;
            Resource->OwnerTable = OwnerTable;
            KiUnlockDispatcherDatabase(OldIrql);

            ASSERT_RESOURCE(Resource);

#if defined(_COLLECT_RESOURCE_DATA_)

            if (NewSize > ExpResourcePerformanceData.MaximumTableExpand) {
                ExpResourcePerformanceData.MaximumTableExpand = NewSize;
            }

#endif

            //
            // Release the resource lock and free the old owner table.
            //

            EXP_UNLOCK_RESOURCE(Resource, LockHandle);
            if (OldTable != NULL) {
                ExFreePool(OldTable);
            }

            if (OldSize == 0) {
                OldSize = 1;
            }
        }
    }

    //
    // Set the hint index, acquire the resource lock, and return NULL
    // as the function value. This will force a reevaluation of the
    // calling resource function.
    //

    KeGetCurrentThread()->ResourceIndex = (CCHAR)OldSize;
    EXP_LOCK_RESOURCE(Resource, LockHandle);
    return NULL;
}

#if DBG

VOID
ExpAssertResource (
    IN PERESOURCE Resource
    )

{
    //
    //  Assert that resource structure is correct.
    //
    // N.B. This routine is called with the resource lock held.
    //

    ASSERT(!Resource->SharedWaiters ||
           Resource->SharedWaiters->Header.Type == SemaphoreObject);

    ASSERT(!Resource->SharedWaiters ||
           Resource->SharedWaiters->Header.Size == (sizeof(KSEMAPHORE) / sizeof(ULONG)));

    ASSERT(!Resource->ExclusiveWaiters ||
           Resource->ExclusiveWaiters->Header.Type == SynchronizationEvent);

    ASSERT(!Resource->ExclusiveWaiters ||
           Resource->ExclusiveWaiters->Header.Size == (sizeof(KEVENT) / sizeof(ULONG)));
}

#endif

PVOID
ExpCheckForResource (
    IN PVOID p,
    IN SIZE_T Size
    )

{

    KIRQL OldIrql;
    PLIST_ENTRY Head, Next;
    volatile PLIST_ENTRY Last;
    PERESOURCE Resource;
    PCHAR BeginBlock;
    PCHAR EndBlock;

    //
    // This can cause a deadlock on MP machines.
    //

    if (KeNumberProcessors > 1) {
        return NULL;
    }

    BeginBlock = (PCHAR)p;
    EndBlock = (PCHAR)p + Size;

    ExAcquireSpinLock (&ExpResourceSpinLock, &OldIrql);
    Head = &ExpSystemResourcesList;
    Next = Head->Flink;
    while (Next != Head) {
        Resource = CONTAINING_RECORD(Next,
                                     ERESOURCE,
                                     SystemResourcesList);

        if ((PCHAR)Resource >= BeginBlock && (PCHAR)Resource < EndBlock) {
            DbgPrint("EX: ExFreePool( %p, %lx ) contains an ERESOURCE structure that has not been ExDeleteResourced\n",
                     p,
                     Size);

            DbgBreakPoint ();

            ExReleaseSpinLock (&ExpResourceSpinLock, OldIrql);
            return (PVOID)Resource;
        }

        //
        //  Save the last ptr in a volatile variable for debugging when a flink is bad
        //  

        Last = Next;
        Next = Next->Flink;
    }

    ExReleaseSpinLock(&ExpResourceSpinLock, OldIrql);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\rundown.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rundown.c

Abstract:

    This module houses routine that do safe rundown of data stuctures.

    The basic principle of these routines is to allow fast protection of a data structure that is torn down
    by a single thread. Threads wishing to access the data structure attempt to obtain rundown protection via
    calling ExAcquireRundownProtection. If this function returns TRUE then accesses are safe until the protected
    thread calls ExReleaseRundownProtection. The single teardown thread calls ExWaitForRundownProtectionRelease
    to mark the rundown structure as being run down and the call will return once all protected threads have
    released their protection references.

    Rundown protection is not a lock. Multiple threads may gain rundown protection at the same time.

    The rundown structure has the following format:

    Bottom bit set   : This is a pointer to a rundown wait block (aligned on at least a word boundary)
    Bottom bit clear : This is a count of the total number of accessors multiplied by 2 granted rundown protection.

Author:

    Neill Clift (NeillC) 18-Apr-2000


Revision History:

--*/

#include "exp.h"

#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ExAcquireRundownProtection)
#pragma alloc_text(PAGE, ExReleaseRundownProtection)
#pragma alloc_text(PAGE, ExAcquireRundownProtectionEx)
#pragma alloc_text(PAGE, ExReleaseRundownProtectionEx)
#pragma alloc_text(PAGE, ExWaitForRundownProtectionRelease)
#pragma alloc_text(PAGE, ExReInitializeRundownProtection)
#pragma alloc_text(PAGE, ExfInitializeRundownProtection)
#pragma alloc_text(PAGE, ExRundownCompleted)
#endif

//
// This is a block held on the local stack of the rundown thread.
//
typedef struct _EX_RUNDOWN_WAIT_BLOCK {
    ULONG Count;
    KEVENT WakeEvent;
} EX_RUNDOWN_WAIT_BLOCK, *PEX_RUNDOWN_WAIT_BLOCK;


NTKERNELAPI
VOID
FASTCALL
ExfInitializeRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Initialize rundown protection structure

Arguments:

    RunRef - Rundown block to be referenced

Return Value:

    None

--*/
{
    RunRef->Count = 0;
}

NTKERNELAPI
VOID
FASTCALL
ExReInitializeRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Reinitialize rundown protection structure after its been rundown

Arguments:

    RunRef - Rundown block to be referenced

Return Value:

    None

--*/
{
    PAGED_CODE ();

    ASSERT ((RunRef->Count&EX_RUNDOWN_ACTIVE) != 0);
    InterlockedExchangePointer (&RunRef->Ptr, NULL);
}

NTKERNELAPI
VOID
FASTCALL
ExRundownCompleted (
     IN PEX_RUNDOWN_REF RunRef
     )
/*++
Routine Description:

    Mark rundown block has having completed rundown so we can wait again safely.

Arguments:

    RunRef - Rundown block to be referenced

Return Value:

    None
--*/
{
    PAGED_CODE ();

    ASSERT ((RunRef->Count&EX_RUNDOWN_ACTIVE) != 0);
    InterlockedExchangePointer (&RunRef->Ptr, (PVOID) EX_RUNDOWN_ACTIVE);
}

NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Reference a rundown block preventing rundown occuring if it hasn't already started

Arguments:

    RunRef - Rundown block to be referenced

Return Value:

    BOOLEAN - TRUE - rundown protection was acquired, FALSE - rundown is active or completed

--*/
{
    ULONG_PTR Value, NewValue;

    PAGED_CODE ();

    Value = RunRef->Count;
    do {
        //
        // If rundown has started return with an error
        //
        if (Value & EX_RUNDOWN_ACTIVE) {
            return FALSE;
        }

        //
        // Rundown hasn't started yet so attempt to increment the unsage count.
        //
        NewValue = Value + EX_RUNDOWN_COUNT_INC;

        NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                  (PVOID) NewValue,
                                                                  (PVOID) Value);
        if (NewValue == Value) {
            return TRUE;
        }
        //
        // somebody else changed the variable before we did. Either a protection call came and went or rundown was
        // initiated. We just repeat the whole loop again.
        //
        Value = NewValue;
    } while (TRUE);
}

NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtectionEx (
     IN PEX_RUNDOWN_REF RunRef,
     IN ULONG Count
     )
/*++

Routine Description:

    Reference a rundown block preventing rundown occuring if it hasn't already started

Arguments:

    RunRef - Rundown block to be referenced
    Count  - Number of references to add

Return Value:

    BOOLEAN - TRUE - rundown protection was acquired, FALSE - rundown is active or completed

--*/
{
    ULONG_PTR Value, NewValue;

    PAGED_CODE ();

    Value = RunRef->Count;
    do {
        //
        // If rundown has started return with an error
        //
        if (Value & EX_RUNDOWN_ACTIVE) {
            return FALSE;
        }

        //
        // Rundown hasn't started yet so attempt to increment the unsage count.
        //
        NewValue = Value + EX_RUNDOWN_COUNT_INC * Count;

        NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                  (PVOID) NewValue,
                                                                  (PVOID) Value);
        if (NewValue == Value) {
            return TRUE;
        }
        //
        // somebody else changed the variable before we did. Either a protection call came and went or rundown was
        // initiated. We just repeat the whole loop again.
        //
        Value = NewValue;
    } while (TRUE);
}


NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Dereference a rundown block and wake the rundown thread if we are the last to exit

Arguments:

    RunRef - Rundown block to have its reference released

Return Value:

    None

--*/
{
    ULONG_PTR Value, NewValue;

    PAGED_CODE ();

    Value = RunRef->Count;
    do {
        //
        // If the block is already marked for rundown then decrement the wait block count and wake the
        // rundown thread if we are the last
        //
        if (Value & EX_RUNDOWN_ACTIVE) {
            PEX_RUNDOWN_WAIT_BLOCK WaitBlock;

            //
            // Rundown is active. since we are one of the threads blocking rundown we have the right to follow
            // the pointer and decrement the active count. If we are the last thread then we have the right to
            // wake up the waiter. After doing this we can't touch the data structures again.
            //
            WaitBlock = (PEX_RUNDOWN_WAIT_BLOCK) (Value & (~EX_RUNDOWN_ACTIVE));

            ASSERT (WaitBlock->Count > 0);

            if (InterlockedDecrement ((PLONG)&WaitBlock->Count) == 0) {
                //
                // We are the last thread out. Wake up the waiter.
                //
                KeSetEvent (&WaitBlock->WakeEvent, 0, FALSE);
            }
            return;
        } else {
            //
            // Rundown isn't active. Just try and decrement the count. Some other protector thread way come and/or
            // go as we do this or rundown might be initiated. We detect this because the exchange will fail and
            // we have to retry
            //
            NewValue = Value - EX_RUNDOWN_COUNT_INC;

            NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                      (PVOID) NewValue,
                                                                      (PVOID) Value);
            if (NewValue == Value) {
                return;
            }
            Value = NewValue;
        }

    } while (TRUE);
}

NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtectionEx (
     IN PEX_RUNDOWN_REF RunRef,
     IN ULONG Count
     )
/*++

Routine Description:

    Dereference a rundown block and wake the rundown thread if we are the last to exit

Arguments:

    RunRef - Rundown block to have its reference released
    Count  - Number of reference to remove

Return Value:

    None

--*/
{
    ULONG_PTR Value, NewValue;

    PAGED_CODE ();

    Value = RunRef->Count;
    do {
        //
        // If the block is already marked for rundown then decrement the wait block count and wake the
        // rundown thread if we are the last
        //
        if (Value & EX_RUNDOWN_ACTIVE) {
            PEX_RUNDOWN_WAIT_BLOCK WaitBlock;

            //
            // Rundown is active. since we are one of the threads blocking rundown we have the right to follow
            // the pointer and decrement the active count. If we are the last thread then we have the right to
            // wake up the waiter. After doing this we can't touch the data structures again.
            //
            WaitBlock = (PEX_RUNDOWN_WAIT_BLOCK) (Value & (~EX_RUNDOWN_ACTIVE));

            ASSERT (WaitBlock->Count >= Count);

            if (InterlockedExchangeAdd ((PLONG)&WaitBlock->Count, -(LONG)Count) == (LONG) Count) {
                //
                // We are the last thread out. Wake up the waiter.
                //
                KeSetEvent (&WaitBlock->WakeEvent, 0, FALSE);
            }
            return;
        } else {
            //
            // Rundown isn't active. Just try and decrement the count. Some other protector thread way come and/or
            // go as we do this or rundown might be initiated. We detect this because the exchange will fail and
            // we have to retry
            //

            ASSERT (Value >= EX_RUNDOWN_COUNT_INC * Count);

            NewValue = Value - EX_RUNDOWN_COUNT_INC * Count;

            NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                      (PVOID) NewValue,
                                                                      (PVOID) Value);
            if (NewValue == Value) {
                return;
            }
            Value = NewValue;
        }

    } while (TRUE);
}

NTKERNELAPI
VOID
FASTCALL
ExWaitForRundownProtectionRelease (
     IN PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Wait till all outstanding rundown protection calls have exited

Arguments:

    RunRef - Pointer to a rundown structure

Return Value:

    None

--*/
{
    EX_RUNDOWN_WAIT_BLOCK WaitBlock;
    PKEVENT Event;
    ULONG_PTR Value, NewValue;
    ULONG WaitCount;

    PAGED_CODE ();

    //
    // Fast path. this should be the normal case. If Value is zero then there are no current accessors and we have
    // marked the rundown structure as rundown. If the value is EX_RUNDOWN_ACTIVE then the structure has already
    // been rundown and ExRundownCompleted. This second case allows for callers that might initiate rundown
    // multiple times (like handle table rundown) to have subsequent rundowns become noops.
    //

    Value = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                           (PVOID) EX_RUNDOWN_ACTIVE,
                                                           (PVOID) 0);
    if (Value == 0 || Value == EX_RUNDOWN_ACTIVE) {
        return;
    }

    //
    // Slow path
    //
    Event = NULL;
    do {

        //
        // Extract total number of waiters. Its biased by 2 so we can hanve the rundown active bit.
        //
        WaitCount = (ULONG) (Value >> EX_RUNDOWN_COUNT_SHIFT);

        //
        // If there are some accessors present then initialize and event (once only).
        //
        if (WaitCount > 0 && Event == NULL) {
            Event = &WaitBlock.WakeEvent;
            KeInitializeEvent (Event, SynchronizationEvent, FALSE);
        }
        //
        // Store the wait count in the wait block. Waiting threads will start to decrement this as they exit
        // if our exchange succeeds. Its possible for accessors to come and go between our initial fetch and
        // the interlocked swap. This doesn't matter so long as there is the same number of outstanding accessors
        // to wait for.
        //
        WaitBlock.Count = WaitCount;

        NewValue = ((ULONG_PTR) &WaitBlock) | EX_RUNDOWN_ACTIVE;

        NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                  (PVOID) NewValue,
                                                                  (PVOID) Value);
        if (NewValue == Value) {
            if (WaitCount > 0) {
                KeWaitForSingleObject (Event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);

                ASSERT (WaitBlock.Count == 0);

            }
            return;
        }
        Value = NewValue;

        ASSERT ((Value&EX_RUNDOWN_ACTIVE) == 0);
    } while (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=ex

TARGETNAME=ex
TARGETTYPE=LIBRARY
TARGETPATH=obj

INCLUDES=..;..\..\inc;..\..\ke;..\..\kd64;$(SDKTOOLS_INC_PATH);$(HALKIT_INC_PATH);$(PROJECT_ROOT)\fs\fastfat

MSC_WARNING_LEVEL=/W4 /WX

SOURCES=..\callback.c  \
        ..\callperf.c  \
        ..\dbgctrl.c   \
        ..\delay.c     \
        ..\event.c     \
        ..\eventpr.c   \
        ..\exatom.c    \
        ..\exdata.c    \
        ..\exinfo.c    \
        ..\exinit.c    \
        ..\exdata.c    \
        ..\handle.c    \
        ..\harderr.c   \
        ..\hdlsterm.c  \
        ..\lookasid.c  \
        ..\luid.c      \
        ..\mutant.c    \
        ..\nbqueue.c   \
        ..\pool.c      \
        ..\probe.c     \
        ..\profile.c   \
        ..\raise.c     \
        ..\resource.c  \
        ..\semphore.c  \
        ..\sysenv.c    \
        ..\sysinfo.c   \
        ..\systime.c   \
        ..\timer.c     \
        ..\worker.c    \
        ..\zone.c      \
        ..\uuid.c      \
        ..\win32.c     \
        ..\rundown.c   \
        ..\pushlock.c  \
        ..\xipdisp.c   \
        ..\keyedevent.c

PRECOMPILED_INCLUDE=..\exp.h
PRECOMPILED_PCH=exp.pch
PRECOMPILED_OBJ=exp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\sysinfo.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    sysinfo.c

Abstract:

    This module implements the NT set and query system information services.

Author:

    Steve Wood (stevewo) 21-Aug-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"
#pragma hdrstop

#include "stdlib.h"
#include "string.h"
#include "vdmntos.h"
#include <nturtl.h>
#include "pool.h"
#include "stktrace.h"
#include "align.h"

#if defined(_WIN64)
#include <wow64t.h>
#endif

extern PVOID PspCidTable;

extern ULONG MmAvailablePages;
extern ULONG MmTotalCommittedPages;
extern ULONG MmTotalCommitLimit;
extern ULONG MmPeakCommitment;
extern ULONG MmLowestPhysicalPage;
extern ULONG MmHighestPhysicalPage;
extern ULONG MmTotalFreeSystemPtes[1];
extern ULONG MmSystemCodePage;
extern ULONG MmSystemCachePage;
extern ULONG MmPagedPoolPage;
extern ULONG MmSystemDriverPage;
extern ULONG MmTotalSystemCodePages;
extern ULONG MmTotalSystemDriverPages;
extern RTL_TIME_ZONE_INFORMATION ExpTimeZoneInformation;

//
// For SystemDpcBehaviorInformation
//
extern ULONG KiMaximumDpcQueueDepth;
extern ULONG KiMinimumDpcRate;
extern ULONG KiAdjustDpcThreshold;
extern ULONG KiIdealDpcRate;

extern LIST_ENTRY MmLoadedUserImageList;

extern MMSUPPORT MmSystemCacheWs;
extern ULONG MmTransitionSharedPages;
extern ULONG MmTransitionSharedPagesPeak;

#define ROUND_UP(VALUE,ROUND) ((ULONG)(((ULONG)VALUE + \
                               ((ULONG)ROUND - 1L)) & (~((ULONG)ROUND - 1L))))

//
// For referencing a user-supplied event handle
//
extern POBJECT_TYPE ExEventObjectType;


NTSTATUS
ExpValidateLocale(
    IN LCID LocaleId
    );

BOOLEAN
ExpIsValidUILanguage(
    IN WCHAR *pLangId
    );

NTSTATUS
ExpGetCurrentUserUILanguage(
    IN WCHAR *ValueName,
    OUT LANGID *CurrentUserUILanguageId,
    IN BOOLEAN bCheckGP
    );

NTSTATUS
ExpSetCurrentUserUILanguage(
    IN WCHAR *ValueName,
    IN LANGID DefaultUILanguageId
    );

NTSTATUS
ExpGetUILanguagePolicy(
    IN HANDLE CurrentUserKey,
    OUT LANGID *PolicyUILanguageId
    );

NTSTATUS
ExpGetProcessInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length,
    IN PULONG SessionId OPTIONAL,
    IN BOOLEAN ExtendedInformation
    );

VOID
ExpGetProcessorIdleInformation (
    OUT PVOID   SystemInformation,
    IN  ULONG   SystemInformationLength,
    OUT PULONG  Length
    );

VOID
ExpGetProcessorPowerInformation (
    OUT PVOID   SystemInformation,
    IN  ULONG   SystemInformationLength,
    OUT PULONG  Length
    );

VOID
ExpCopyProcessInfo (
    IN PSYSTEM_PROCESS_INFORMATION ProcessInfo,
    IN PEPROCESS Process,
    IN BOOLEAN ExtendedInformation
    );

VOID
ExpCopyThreadInfo (
    IN PVOID ThreadInfoBuffer,
    IN PETHREAD Thread,
    IN BOOLEAN ExtendedInformation
    );

#if i386 
NTSTATUS
ExpGetStackTraceInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );
#endif // i386 

NTSTATUS
ExpGetLockInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );

NTSTATUS
ExpGetLookasideInformation (
    OUT PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG Length
    );

NTSTATUS
ExpGetPoolInformation(
    IN POOL_TYPE PoolType,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );

NTSTATUS
ExpGetHandleInformation(
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );

NTSTATUS
ExpGetHandleInformationEx(
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );

NTSTATUS
ExpGetObjectInformation(
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );


NTSTATUS
ExpGetInstemulInformation(
    OUT PSYSTEM_VDM_INSTEMUL_INFO Info
    );

NTSTATUS
ExpGetPoolTagInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnLength OPTIONAL
    );

NTSTATUS
ExpQueryModuleInformation(
    IN PLIST_ENTRY LoadOrderListHead,
    IN PLIST_ENTRY UserModeLoadOrderListHead,
    OUT PRTL_PROCESS_MODULES ModuleInformation,
    IN ULONG ModuleInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

NTSTATUS
ExpQueryLegacyDriverInformation(
    IN PSYSTEM_LEGACY_DRIVER_INFORMATION LegacyInfo,
    IN PULONG Length
    );

NTSTATUS
ExpQueryNumaProcessorMap(
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnedLength
    );

NTSTATUS
ExpQueryNumaAvailableMemory(
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnedLength
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, NtQueryDefaultLocale)
#pragma alloc_text(PAGE, NtSetDefaultLocale)
#pragma alloc_text(PAGE, NtQueryInstallUILanguage)
#pragma alloc_text(PAGE, NtQueryDefaultUILanguage)
#pragma alloc_text(PAGE, ExpGetCurrentUserUILanguage)
#pragma alloc_text(PAGE, NtSetDefaultUILanguage)
#pragma alloc_text(PAGE, ExpSetCurrentUserUILanguage)
#pragma alloc_text(PAGE, ExpValidateLocale)
#pragma alloc_text(PAGE, ExpGetUILanguagePolicy)
#pragma alloc_text(PAGE, NtQuerySystemInformation)
#pragma alloc_text(PAGE, NtSetSystemInformation)
#pragma alloc_text(PAGE, ExpGetHandleInformation)
#pragma alloc_text(PAGE, ExpGetHandleInformationEx)
#pragma alloc_text(PAGE, ExpGetObjectInformation)
#pragma alloc_text(PAGE, ExpQueryModuleInformation)
#pragma alloc_text(PAGE, ExpCopyProcessInfo)
#pragma alloc_text(PAGE, ExpQueryLegacyDriverInformation)
#pragma alloc_text(PAGE, ExLockUserBuffer)
#pragma alloc_text(PAGE, ExpQueryNumaAvailableMemory)
#pragma alloc_text(PAGE, ExpQueryNumaProcessorMap)
#pragma alloc_text(PAGE, ExpReadComPlusPackage)
#pragma alloc_text(PAGE, ExpUpdateComPlusPackage)
#pragma alloc_text(PAGELK, ExpGetLockInformation)
#pragma alloc_text(PAGELK, ExpGetPoolInformation)
#pragma alloc_text(PAGELK, ExpGetProcessorPowerInformation)
#pragma alloc_text(PAGELK, ExpGetProcessorIdleInformation)
#pragma alloc_text(PAGE, ExpIsValidUILanguage)
#endif


NTSTATUS
ExpReadComPlusPackage(
    VOID
    )

/*++

Routine Description:

    This function reads the status of the 64-bit COM+ package from the registry
    and stick it inside the shared page.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING KeyName, KeyValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    CHAR KeyValueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;
    HANDLE Key;



    RtlInitUnicodeString (&KeyName,
                          COMPLUS_PACKAGE_KEYPATH);
    RtlInitUnicodeString (&KeyValueName,
                          COMPLUS_PACKAGE_ENABLE64BIT);

    InitializeObjectAttributes (&ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    Status = ZwOpenKey (&Key,
                        GENERIC_READ,
                        &ObjectAttributes);

    if (NT_SUCCESS (Status)) {

        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
        Status = ZwQueryValueKey (Key,
                                  &KeyValueName,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  sizeof (KeyValueBuffer),
                                  &ResultLength);

        if (NT_SUCCESS (Status)) {

            if ((KeyValueInformation->Type == REG_DWORD) &&
                (KeyValueInformation->DataLength == sizeof(ULONG))) {
                SharedUserData->ComPlusPackage = *(PULONG)KeyValueInformation->Data;
            }
        }

        ZwClose (Key);
    }

    return Status;
}


NTSTATUS
ExpUpdateComPlusPackage(
    IN ULONG ComPlusPackageStatus
    )

/*++

Routine Description:

    This function updates the COM+ runtime package status on the system.
    The package status indicates whether the 64-bit or the 32-bit runtime
    should be used when executing IL_ONLY COM+ images.

Arguments:

    ComPlusPackageStatus - COM+ Runtime package status on the system


Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    UNICODE_STRING KeyName, KeyValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Disposition;
    HANDLE Key;


    RtlInitUnicodeString (&KeyName,
                          COMPLUS_PACKAGE_KEYPATH);
    RtlInitUnicodeString (&KeyValueName,
                          COMPLUS_PACKAGE_ENABLE64BIT);

    InitializeObjectAttributes (&ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);

    Status = ZwOpenKey (&Key,
                        GENERIC_WRITE,
                        &ObjectAttributes
                        );

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        Status = ZwCreateKey (&Key,
                              GENERIC_WRITE,
                              &ObjectAttributes,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              &Disposition
                            );
    }

    if (NT_SUCCESS (Status)) {

        Status = ZwSetValueKey (Key,
                                &KeyValueName,
                                0,
                                REG_DWORD,
                                &ComPlusPackageStatus,
                                sizeof(ULONG));
        ZwClose (Key);
    }

    return Status;
}

NTSTATUS
NtQueryDefaultLocale (
    IN BOOLEAN UserProfile,
    OUT PLCID DefaultLocaleId
    )
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    try {

        //
        // Get previous processor mode and probe output argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteUlong ((PULONG)DefaultLocaleId);
        }

        if (UserProfile) {
            *DefaultLocaleId = MmGetSessionLocaleId ();
        }
        else {
            *DefaultLocaleId = PsDefaultSystemLocaleId;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    return Status;
}

NTSTATUS
NtSetDefaultLocale (
    IN BOOLEAN UserProfile,
    IN LCID DefaultLocaleId
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyValueName;
    HANDLE CurrentUserKey, Key;
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;
    PWSTR s;
    ULONG n, i, Digit;
    WCHAR c;
    ULONG Flags;

    PAGED_CODE();

    if (DefaultLocaleId & 0xFFFF0000) {
        return STATUS_INVALID_PARAMETER;
    }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
    if (UserProfile) {
        Status = RtlOpenCurrentUser( MAXIMUM_ALLOWED, &CurrentUserKey );
        if (!NT_SUCCESS( Status )) {
            return Status;
        }

        RtlInitUnicodeString( &KeyValueName, L"Locale" );
        RtlInitUnicodeString( &KeyPath, L"Control Panel\\International" );
        Flags = OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE | OBJ_FORCE_ACCESS_CHECK;
    }
    else {
        RtlInitUnicodeString( &KeyValueName, L"Default" );
        RtlInitUnicodeString( &KeyPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\Language" );
        CurrentUserKey = NULL;
        Flags = OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE;
    }

    InitializeObjectAttributes (&ObjectAttributes,
                                &KeyPath,
                                Flags,
                                CurrentUserKey,
                                NULL);

    if (DefaultLocaleId == 0) {

        Status = ZwOpenKey (&Key, GENERIC_READ, &ObjectAttributes);

        if (NT_SUCCESS( Status )) {
            Status = ZwQueryValueKey( Key,
                                      &KeyValueName,
                                      KeyValuePartialInformation,
                                      KeyValueInformation,
                                      sizeof( KeyValueBuffer ),
                                      &ResultLength
                                    );
            if (NT_SUCCESS( Status )) {
                if (KeyValueInformation->Type == REG_SZ) {
                    s = (PWSTR)KeyValueInformation->Data;
                    for (i=0; i<KeyValueInformation->DataLength; i += sizeof( WCHAR )) {
                        c = *s++;
                        if (c >= L'0' && c <= L'9') {
                            Digit = c - L'0';
                        }
                        else if (c >= L'A' && c <= L'F') {
                            Digit = c - L'A' + 10;
                        }
                        else if (c >= L'a' && c <= L'f') {
                            Digit = c - L'a' + 10;
                        }
                        else {
                            break;
                        }

                        if (Digit >= 16) {
                            break;
                        }

                        DefaultLocaleId = (DefaultLocaleId << 4) | Digit;
                    }
                }
                else {
                    if (KeyValueInformation->Type == REG_DWORD &&
                        KeyValueInformation->DataLength == sizeof( ULONG )) {

                        DefaultLocaleId = *(PLCID)KeyValueInformation->Data;
                    }
                    else {
                        Status = STATUS_UNSUCCESSFUL;
                    }
                }
            }

            ZwClose( Key );
        }
    }
    else {

        Status = ExpValidateLocale( DefaultLocaleId );

        if (NT_SUCCESS(Status)) {

            Status = ZwOpenKey( &Key,
                                GENERIC_WRITE,
                                &ObjectAttributes
                              );

            if (NT_SUCCESS( Status )) {
                if (UserProfile) {
                    n = 8;
                }
                else {
                    n = 4;
                }

                s = &KeyValueBuffer[ n ];
                *s-- = UNICODE_NULL;
                i = (ULONG)DefaultLocaleId;

                while (s >= KeyValueBuffer) {
                    Digit = i & 0x0000000F;
                    if (Digit <= 9) {
                        *s-- = (WCHAR)(Digit + L'0');
                    }
                    else {
                        *s-- = (WCHAR)((Digit - 10) + L'A');
                    }

                    i = i >> 4;
                }

                Status = ZwSetValueKey( Key,
                                        &KeyValueName,
                                        0,
                                        REG_SZ,
                                        KeyValueBuffer,
                                        (n+1) * sizeof( WCHAR )
                                      );
                ZwClose( Key );
            }
        }
    }

    ZwClose( CurrentUserKey );

    if (NT_SUCCESS( Status )) {
        if (UserProfile) {
            MmSetSessionLocaleId (DefaultLocaleId);
        }
        else {
            PsDefaultSystemLocaleId = DefaultLocaleId;
        }
    }

    return Status;
}

NTSTATUS
NtQueryInstallUILanguage(
    OUT LANGID *InstallUILanguageId
    )
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    try {

        //
        // Get previous processor mode and probe output argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteUshort( (USHORT *)InstallUILanguageId );
            }

        *InstallUILanguageId = PsInstallUILanguageId;
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    return Status;
}

NTSTATUS
NtQueryDefaultUILanguage(
    OUT LANGID *DefaultUILanguageId
    )
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    try {

        //
        // Get previous processor mode and probe output argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteUshort( (USHORT *)DefaultUILanguageId );
            }

        //
        // Read the UI language from the current security context.
        //
        if (!NT_SUCCESS(ExpGetCurrentUserUILanguage( L"MultiUILanguageId",
                                                     DefaultUILanguageId, 
                                                     TRUE))) {
            *DefaultUILanguageId = PsInstallUILanguageId;
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    return Status;
}



NTSTATUS
ExpGetUILanguagePolicy(
    IN HANDLE CurrentUserKey,
    OUT LANGID *PolicyUILanguageId
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyValueName;
    HANDLE Key;
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;
    ULONG Language;

    PAGED_CODE();

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
    RtlInitUnicodeString( &KeyValueName, L"MultiUILanguageId" );
    RtlInitUnicodeString( &KeyPath, L"Software\\Policies\\Microsoft\\Control Panel\\Desktop" );

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
                                CurrentUserKey,
                                NULL
                              );

    //
    // Check if there is a Policy key
    //
    Status = ZwOpenKey( &Key,
                        GENERIC_READ,
                        &ObjectAttributes
                      );

    if (NT_SUCCESS( Status )) {

        Status = ZwQueryValueKey( Key,
                                  &KeyValueName,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  sizeof( KeyValueBuffer ),
                                  &ResultLength
                                );

        if (NT_SUCCESS( Status )) {
            if ((KeyValueInformation->DataLength > 2) &&
                (KeyValueInformation->Type == REG_SZ) &&
                ExpIsValidUILanguage((PWSTR) KeyValueInformation->Data)) {

                RtlInitUnicodeString( &KeyValueName, (PWSTR) KeyValueInformation->Data );
                Status = RtlUnicodeStringToInteger( &KeyValueName,
                                                    (ULONG)16,
                                                    &Language
                                                  );
                //
                // Final check to make sure this is an MUI system
                //
                if (NT_SUCCESS( Status )) {
                    *PolicyUILanguageId = (LANGID)Language;
                    }
                }
            else {
                Status = STATUS_UNSUCCESSFUL;
                }
            }
            ZwClose( Key );
        }

    return Status;
}



NTSTATUS
ExpSetCurrentUserUILanguage(
    IN WCHAR *ValueName,
    IN LANGID CurrentUserUILanguage
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyValueName;
    HANDLE CurrentUserKey, Key;
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    PWSTR s;
    ULONG i, Digit;

    PAGED_CODE();

    if (CurrentUserUILanguage & 0xFFFF0000) {
        return STATUS_INVALID_PARAMETER;
        }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
    Status = RtlOpenCurrentUser( MAXIMUM_ALLOWED, &CurrentUserKey );
    if (!NT_SUCCESS( Status )) {
        return Status;
        }

    RtlInitUnicodeString( &KeyValueName, ValueName );
    RtlInitUnicodeString( &KeyPath, L"Control Panel\\Desktop" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE | OBJ_FORCE_ACCESS_CHECK),
                                CurrentUserKey,
                                NULL
                              );


    Status = ExpValidateLocale( MAKELCID( CurrentUserUILanguage, SORT_DEFAULT ) );

    if (NT_SUCCESS(Status)) {

        Status = ZwOpenKey( &Key,
                            GENERIC_WRITE,
                            &ObjectAttributes
                          );
        if (NT_SUCCESS( Status )) {

            s = &KeyValueBuffer[ 8 ];
            *s-- = UNICODE_NULL;
            i = (ULONG)CurrentUserUILanguage;

            while (s >= KeyValueBuffer) {
                Digit = i & 0x0000000F;
                if (Digit <= 9) {
                    *s-- = (WCHAR)(Digit + L'0');
                    }
                else {
                    *s-- = (WCHAR)((Digit - 10) + L'A');
                    }

                i = i >> 4;
                }

            Status = ZwSetValueKey( Key,
                                    &KeyValueName,
                                    0,
                                    REG_SZ,
                                    KeyValueBuffer,
                                    9 * sizeof( WCHAR )
                                  );
            ZwClose( Key );
            }
        }

    ZwClose( CurrentUserKey );

    return Status;
}


NTSTATUS
ExpGetCurrentUserUILanguage(
    IN WCHAR *ValueName,
    OUT LANGID *CurrentUserUILanguageId, 
    IN BOOLEAN bCheckGP
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyValueName, UILanguage;
    HANDLE CurrentUserKey, Key;
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;
    ULONG Digit;

    PAGED_CODE();

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
    Status = RtlOpenCurrentUser( MAXIMUM_ALLOWED, &CurrentUserKey );
    if (!NT_SUCCESS( Status )) {
        return Status;
        }

    RtlInitUnicodeString( &KeyValueName, ValueName );
    RtlInitUnicodeString( &KeyPath, L"Control Panel\\Desktop" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE | OBJ_FORCE_ACCESS_CHECK),
                                CurrentUserKey,
                                NULL
                              );

    //
    // Let's check if there is a policy installed for the UI language,
    // and if so, let's use it.
    //
    if (!bCheckGP || !NT_SUCCESS( ExpGetUILanguagePolicy( CurrentUserKey, CurrentUserUILanguageId ))) {
        Status = ZwOpenKey( &Key,
                            GENERIC_READ,
                            &ObjectAttributes
                          );
        if (NT_SUCCESS( Status )) {
            Status = ZwQueryValueKey( Key,
                                      &KeyValueName,
                                      KeyValuePartialInformation,
                                      KeyValueInformation,
                                      sizeof( KeyValueBuffer ),
                                      &ResultLength
                                    );
            if (NT_SUCCESS( Status )) {
                if (KeyValueInformation->Type == REG_SZ && 
                    ExpIsValidUILanguage((PWSTR) KeyValueInformation->Data)) {

                    RtlInitUnicodeString( &UILanguage, (PWSTR) KeyValueInformation->Data);
                    Status = RtlUnicodeStringToInteger( &UILanguage,
                                                        (ULONG) 16,
                                                        &Digit
                                                      );
                    if (NT_SUCCESS( Status )) {
                        *CurrentUserUILanguageId = (LANGID) Digit;
                        }
                    }
                else {
                    Status = STATUS_UNSUCCESSFUL;
                    }
                }
            ZwClose( Key );
            }
        }

    ZwClose( CurrentUserKey );

    return Status;
}


NTSTATUS
NtSetDefaultUILanguage(
    IN LANGID DefaultUILanguageId
    )
{
    NTSTATUS Status;
    LANGID LangId;

    //
    //  if this is called during user logon, then we need to update the user's registry.
    //
    if (DefaultUILanguageId == 0) {
          Status = ExpGetCurrentUserUILanguage( L"MUILanguagePending" ,
                                                &LangId, 
                                                FALSE
                                                );
          if (NT_SUCCESS( Status )) {
            Status = ExpSetCurrentUserUILanguage( L"MultiUILanguageId" ,
                                                  LangId
                                                );
            }
          return Status;
        }

    return ExpSetCurrentUserUILanguage( L"MUILanguagePending", DefaultUILanguageId );
}

NTSTATUS
ExpValidateLocale(
    IN LCID LocaleId
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER, ReturnStatus;
    UNICODE_STRING LocaleName, KeyValueName;
    UNICODE_STRING NlsLocaleKeyPath, NlsSortKeyPath, NlsLangGroupKeyPath;
    WCHAR LocaleNameBuffer[ 32 ];
    WCHAR KeyValueNameBuffer[ 32 ];
    WCHAR KeyValueBuffer[ 128 ];
    WCHAR *Ptr;
    HANDLE LocaleKey, SortKey, LangGroupKey;
    OBJECT_ATTRIBUTES NlsLocaleObjA, NlsSortObjA, NlsLangGroupObjA;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG i, ResultLength;


    //
    //  Convert the LCID to the form %08x (e.g. 00000409)
    //
    LocaleName.Length = sizeof( LocaleNameBuffer ) / sizeof( WCHAR );
    LocaleName.MaximumLength = LocaleName.Length;
    LocaleName.Buffer = LocaleNameBuffer;

    //
    //  Convert LCID to a string
    //
    ReturnStatus = RtlIntegerToUnicodeString( LocaleId, 16, &LocaleName );
    if (!NT_SUCCESS(ReturnStatus))
        goto Failed1;

    Ptr = KeyValueNameBuffer;
    for (i = ((LocaleName.Length)/sizeof(WCHAR));
         i < 8;
         i++, Ptr++) {
        *Ptr = L'0';
        }
    *Ptr = UNICODE_NULL;

    RtlInitUnicodeString(&KeyValueName, KeyValueNameBuffer);
    KeyValueName.MaximumLength = sizeof( KeyValueNameBuffer ) / sizeof( WCHAR );
    RtlAppendUnicodeToString(&KeyValueName, LocaleName.Buffer);


    //
    // Open Registry Keys : Locale, Sort and LanguageGroup
    //
    RtlInitUnicodeString(&NlsLocaleKeyPath,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\Locale");

    InitializeObjectAttributes( &NlsLocaleObjA,
                                &NlsLocaleKeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
                                NULL,
                                NULL
                              );

    ReturnStatus = ZwOpenKey( &LocaleKey,
                              GENERIC_READ,
                              &NlsLocaleObjA
                            );
    if (!NT_SUCCESS(ReturnStatus))
         goto Failed1;

    RtlInitUnicodeString(&NlsSortKeyPath,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\Locale\\Alternate Sorts");

    InitializeObjectAttributes( &NlsSortObjA,
                                &NlsSortKeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
                                NULL,
                                NULL
                              );

    ReturnStatus = ZwOpenKey( &SortKey,
                              GENERIC_READ,
                              &NlsSortObjA
                            );
    if (!NT_SUCCESS(ReturnStatus))
         goto Failed2;

    RtlInitUnicodeString(&NlsLangGroupKeyPath,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\Language Groups");

    InitializeObjectAttributes( &NlsLangGroupObjA,
                                &NlsLangGroupKeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
                                NULL,
                                NULL
                              );


    ReturnStatus = ZwOpenKey( &LangGroupKey,
                              GENERIC_READ,
                              &NlsLangGroupObjA
                            );
    if (!NT_SUCCESS(ReturnStatus))
         goto Failed3;

    //
    // Validate Locale : Lookup the Locale's Language group, and make sure it is there.
    //
    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) KeyValueBuffer;
    ReturnStatus = ZwQueryValueKey( LocaleKey,
                                    &KeyValueName,
                                    KeyValuePartialInformation,
                                    KeyValueInformation,
                                    sizeof( KeyValueBuffer ),
                                    &ResultLength
                                  );

    if (!NT_SUCCESS(ReturnStatus)) {
        ReturnStatus = ZwQueryValueKey( SortKey,
                                        &KeyValueName,
                                        KeyValuePartialInformation,
                                        KeyValueInformation,
                                        sizeof( KeyValueBuffer ),
                                        &ResultLength
                                      );
        }

    if ((NT_SUCCESS(ReturnStatus)) &&
        (KeyValueInformation->DataLength > 2)
       ) {

        RtlInitUnicodeString( &KeyValueName, (PWSTR) KeyValueInformation->Data );

        ReturnStatus = ZwQueryValueKey( LangGroupKey,
                                        &KeyValueName,
                                        KeyValuePartialInformation,
                                        KeyValueInformation,
                                        sizeof( KeyValueBuffer ),
                                        &ResultLength
                                      );
        if ((NT_SUCCESS(ReturnStatus)) &&
            (KeyValueInformation->Type == REG_SZ) &&
            (KeyValueInformation->DataLength > 2)
           ) {
            Ptr = (PWSTR) KeyValueInformation->Data;
            if (Ptr[0] == L'1' && Ptr[1] == UNICODE_NULL) {
                Status = STATUS_SUCCESS;
                }
            }
        }

    //
    // Close opened keys
    //

    ZwClose( LangGroupKey );

Failed3:
    ZwClose( SortKey );

Failed2:
    ZwClose( LocaleKey );

Failed1:

    //
    // If an error happens, let's record it.
    //
    if (!NT_SUCCESS(ReturnStatus)) {
        Status = ReturnStatus;
        }

    return Status;
}

NTSTATUS
ExpQueryNumaProcessorMap(
    OUT PVOID  SystemInformation,
    IN  ULONG  SystemInformationLength,
    OUT PULONG ReturnedLength
    )
{
    PSYSTEM_NUMA_INFORMATION Map;
    ULONG Length;
    ULONG ReturnCount;
#if !defined(NT_UP)
    ULONG i;
#endif

    Map = (PSYSTEM_NUMA_INFORMATION)SystemInformation;

    //
    // Must be able to return at least the number of nodes.
    //

    if (SystemInformationLength < sizeof(Map->HighestNodeNumber)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    Map->HighestNodeNumber = KeNumberNodes - 1;

    //
    // Return as many node masks as possible in the SystemInformation
    // buffer.
    //

    Length = FIELD_OFFSET(SYSTEM_NUMA_INFORMATION,
                          ActiveProcessorsAffinityMask);

    ReturnCount = (SystemInformationLength - Length) /
                  sizeof(Map->ActiveProcessorsAffinityMask[0]);

    if (ReturnCount > KeNumberNodes) {
        ReturnCount = KeNumberNodes;
    }

    if ((Length > SystemInformationLength) ||
        (ReturnCount == 0)) {
        *ReturnedLength = sizeof(Map->HighestNodeNumber);
        return STATUS_SUCCESS;
    }

    *ReturnedLength = FIELD_OFFSET(SYSTEM_NUMA_INFORMATION,
                                   ActiveProcessorsAffinityMask[ReturnCount]);

#if !defined(NT_UP)

    for (i = 0; i < ReturnCount; i++) {
        Map->ActiveProcessorsAffinityMask[i] = KeNodeBlock[i]->ProcessorMask;
    }

#else

    if (ReturnCount) {
        Map->ActiveProcessorsAffinityMask[0] = 1;
    }

#endif

    return STATUS_SUCCESS;
}

NTSTATUS
ExpQueryNumaAvailableMemory(
    OUT PVOID  SystemInformation,
    IN  ULONG  SystemInformationLength,
    OUT PULONG ReturnedLength
    )
{
    PSYSTEM_NUMA_INFORMATION Map;
    ULONG Length;
    ULONG ReturnCount;

    Map = (PSYSTEM_NUMA_INFORMATION)SystemInformation;

    //
    // Must be able to return at least the number of nodes.
    //

    if (SystemInformationLength < sizeof(Map->HighestNodeNumber)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    Map->HighestNodeNumber = KeNumberNodes - 1;

    //
    // Return as many node masks as possible in the SystemInformation
    // buffer.
    //

    Length = FIELD_OFFSET(SYSTEM_NUMA_INFORMATION,
                          AvailableMemory);

    ReturnCount = (SystemInformationLength - Length) /
                  sizeof(Map->AvailableMemory[0]);

    if (ReturnCount > KeNumberNodes) {
        ReturnCount = KeNumberNodes;
    }

    if ((Length > SystemInformationLength) ||
        (ReturnCount == 0)) {
        *ReturnedLength = sizeof(Map->HighestNodeNumber);
        return STATUS_SUCCESS;
    }

    *ReturnedLength = FIELD_OFFSET(SYSTEM_NUMA_INFORMATION,
                                   AvailableMemory[ReturnCount]);

    //
    // Return the aproximate number of free bytes at this time.
    // (It's aproximate because no lock is taken and with respect
    // to any user mode application its only a sample.
    //

#if !defined(NT_UP)

    if (KeNumberNodes > 1) {

        ULONG i;

        for (i = 0; i < ReturnCount; i++) {
            Map->AvailableMemory[i] =
                ((ULONGLONG)KeNodeBlock[i]->FreeCount[ZeroedPageList] +
                 (ULONGLONG)KeNodeBlock[i]->FreeCount[FreePageList]) 
                    << PAGE_SHIFT;
        }
    } else

#endif

    if (ReturnCount) {
        Map->AvailableMemory[0] = ((ULONGLONG)MmAvailablePages) << PAGE_SHIFT;
    }


    return STATUS_SUCCESS;
}

NTSTATUS
ExpGetSystemBasicInformation (
    OUT PSYSTEM_BASIC_INFORMATION BasicInfo
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    try {

        BasicInfo->NumberOfProcessors = KeNumberProcessors;
        BasicInfo->ActiveProcessorsAffinityMask = (ULONG_PTR)KeActiveProcessors;
        BasicInfo->Reserved = 0;
        BasicInfo->TimerResolution = KeMaximumIncrement;
        BasicInfo->NumberOfPhysicalPages = MmNumberOfPhysicalPages;
        BasicInfo->LowestPhysicalPageNumber = MmLowestPhysicalPage;
        BasicInfo->HighestPhysicalPageNumber = MmHighestPhysicalPage;
        BasicInfo->PageSize = PAGE_SIZE;
        BasicInfo->AllocationGranularity = MM_ALLOCATION_GRANULARITY;
        BasicInfo->MinimumUserModeAddress = (ULONG_PTR)MM_LOWEST_USER_ADDRESS;
        BasicInfo->MaximumUserModeAddress = (ULONG_PTR)MM_HIGHEST_USER_ADDRESS;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}

NTSTATUS
ExpGetSystemProcessorInformation (
    OUT PSYSTEM_PROCESSOR_INFORMATION ProcessorInformation
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    try {

        ProcessorInformation->ProcessorArchitecture = KeProcessorArchitecture;
        ProcessorInformation->ProcessorLevel = KeProcessorLevel;
        ProcessorInformation->ProcessorRevision = KeProcessorRevision;
        ProcessorInformation->Reserved = 0;
        ProcessorInformation->ProcessorFeatureBits = KeFeatureBits;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}
#if defined(_WIN64)

NTSTATUS
ExpGetSystemEmulationBasicInformation (
    OUT PSYSTEM_BASIC_INFORMATION BasicInfo
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    try {

        BasicInfo->NumberOfProcessors =  min(32, KeNumberProcessors);
        BasicInfo->ActiveProcessorsAffinityMask = (ULONG_PTR)
            ((KeActiveProcessors & 0xFFFFFFFF) | ((KeActiveProcessors & (0xFFFFFFFF << 32) ) >> 32));
        BasicInfo->Reserved = 0;
        BasicInfo->TimerResolution = KeMaximumIncrement;
        BasicInfo->NumberOfPhysicalPages = (MmNumberOfPhysicalPages * (PAGE_SIZE >> PAGE_SHIFT_X86NT));
        BasicInfo->LowestPhysicalPageNumber = MmLowestPhysicalPage;
        BasicInfo->HighestPhysicalPageNumber = MmHighestPhysicalPage;
        BasicInfo->PageSize = PAGE_SIZE_X86NT;
        BasicInfo->AllocationGranularity = MM_ALLOCATION_GRANULARITY;
        BasicInfo->MinimumUserModeAddress = 0x00000000000010000UI64;
        BasicInfo->MaximumUserModeAddress = 0x0000000007FFEFFFFUI64;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}
#endif

NTSTATUS
NtQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function queries information about the system.

Arguments:

    SystemInformationClass - The system information class about which
        to retrieve information.

    SystemInformation - A pointer to a buffer which receives the specified
        information.  The format and content of the buffer depend on the
        specified system information class.

        SystemInformation Format by Information Class:

        SystemBasicInformation - Data type is SYSTEM_BASIC_INFORMATION

            SYSTEM_BASIC_INFORMATION Structure

                ULONG Reserved - Always zero.

                ULONG TimerResolutionInMicroSeconds - The resolution of
                    the hardware time.  All time values in NT are
                    specified as 64-bit LARGE_INTEGER values in units of
                    100 nanoseconds.  This field allows an application to
                    understand how many of the low order bits of a system
                    time value are insignificant.

                ULONG PageSize - The physical page size for virtual memory
                    objects.  Physical memory is committed in PageSize
                    chunks.

                ULONG AllocationGranularity - The logical page size for
                    virtual memory objects.  Allocating 1 byte of virtual
                    memory will actually allocate AllocationGranularity
                    bytes of virtual memory.  Storing into that byte will
                    commit the first physical page of the virtual memory.

                ULONG MinimumUserModeAddress - The smallest valid user mode
                    address.  The first AllocationGranularity bytes of
                    the virtual address space are reserved.  This forces
                    access violations for code the dereferences a zero
                    pointer.

                ULONG MaximumUserModeAddress -  The largest valid user mode
                    address.  The next AllocationGranularity bytes of
                    the virtual address space are reserved.  This allows
                    system service routines to validate user mode pointer
                    parameters quickly.

                KAFFINITY ActiveProcessorsAffinityMask - The affinity mask
                    for the current hardware configuration.

                CCHAR NumberOfProcessors - The number of processors
                    in the current hardware configuration.

        SystemProcessorInformation - Data type is SYSTEM_PROCESSOR_INFORMATION

            SYSTEM_PROCESSOR_INFORMATION Structure

                USHORT ProcessorArchitecture - The processor architecture:
                    PROCESSOR_ARCHITECTURE_INTEL
                    PROCESSOR_ARCHITECTURE_MIPS
                    PROCESSOR_ARCHITECTURE_ALPHA
                    PROCESSOR_ARCHITECTURE_PPC

                USHORT ProcessorLevel - architecture dependent processor level.
                    This is the least common denominator for an MP system:

                    For PROCESSOR_ARCHITECTURE_INTEL:
                        3 - 386
                        4 - 486
                        5 - 586 or Pentium

                    For PROCESSOR_ARCHITECTURE_MIPS:
                        00xx - where xx is 8-bit implementation number (bits 8-15 of
                            PRId register.
                        0004 - R4000

                    For PROCESSOR_ARCHITECTURE_ALPHA:
                        xxxx - where xxxx is 16-bit processor version number (low
                            order 16 bits of processor version number from firmware)

                        21064 - 21064
                        21066 - 21066
                        21164 - 21164

                    For PROCESSOR_ARCHITECTURE_PPC:
                        xxxx - where xxxx is 16-bit processor version number (high
                            order 16 bits of Processor Version Register).
                        1 - 601
                        3 - 603
                        4 - 604
                        6 - 603+
                        9 - 604+
                        20 - 620

                USHORT ProcessorRevision - architecture dependent processor revision.
                    This is the least common denominator for an MP system:

                    For PROCESSOR_ARCHITECTURE_INTEL:
                        For Old Intel 386 or 486:
                            FFxx - where xx is displayed as a hexadecimal CPU stepping
                            (e.g. FFD0 is D0 stepping)

                        For Intel Pentium or Cyrix/NexGen 486
                            xxyy - where xx is model number and yy is stepping, so
                            0201 is Model 2, Stepping 1

                    For PROCESSOR_ARCHITECTURE_MIPS:
                        00xx is 8-bit revision number of processor (low order 8 bits
                            of PRId Register

                    For PROCESSOR_ARCHITECTURE_ALPHA:
                        xxyy - where xxyy is 16-bit processor revision number (low
                            order 16 bits of processor revision number from firmware).
                            Displayed as Model 'A'+xx, Pass yy

                    For PROCESSOR_ARCHITECTURE_PPC:
                        xxyy - where xxyy is 16-bit processor revision number (low
                            order 16 bits of Processor Version Register).  Displayed
                            as a fixed point number xx.yy

                USHORT Reserved - Always zero.

                ULONG ProcessorFeatureBits - architecture dependent processor feature bits.
                    This is the least common denominator for an MP system.

        SystemPerformanceInformation - Data type is SYSTEM_PERFORMANCE_INFORMATION

            SYSTEM_PERFORMANCE_INFORMATION Structure

                LARGE_INTEGER IdleProcessTime - Returns the kernel time of the idle
                    process.

            LARGE_INTEGER IoReadTransferCount;
            LARGE_INTEGER IoWriteTransferCount;
            LARGE_INTEGER IoOtherTransferCount;
            LARGE_INTEGER KernelTime;
            LARGE_INTEGER UserTime;
            ULONG IoReadOperationCount;
            ULONG IoWriteOperationCount;
            ULONG IoOtherOperationCount;
            ULONG AvailablePages;
            ULONG CommittedPages;
            ULONG PageFaultCount;
            ULONG CopyOnWriteCount;
            ULONG TransitionCount;
            ULONG CacheTransitionCount;
            ULONG DemandZeroCount;
            ULONG PageReadCount;
            ULONG PageReadIoCount;
            ULONG CacheReadCount;
            ULONG CacheIoCount;
            ULONG DirtyPagesWriteCount;
            ULONG DirtyWriteIoCount;
            ULONG MappedPagesWriteCount;
            ULONG MappedWriteIoCount;
            ULONG PagedPoolPages;
            ULONG NonPagedPoolPages;
            ULONG PagedPoolAllocs;
            ULONG PagedPoolFrees;
            ULONG NonPagedPoolAllocs;
            ULONG NonPagedPoolFrees;
            ULONG LpcThreadsWaitingInReceive;
            ULONG LpcThreadsWaitingForReply;

        SystemProcessInformation - Data type is SYSTEM_PROCESS_INFORMATION

            SYSTEM_PROCESS_INFORMATION Structure

        SystemDockInformation - Data type is SYSTEM_DOCK_INFORMATION

             SYSTEM_DOCK_INFORMATION Structure

                 SYSTEM_DOCKED_STATE DockState - Ordinal specifying the current docking state. Possible values:
                     SystemDockStateUnknown - The docking state of the system could not be determined.
                     SystemUndocked - The system is undocked.
                     SystemDocked - The system is docked.

                 ULONG DockIdLength - Specifies the length in characters of the Dock ID string
                                      (not including terminating NULL).

                 ULONG SerialNumberOffset - Specifies the character offset of the Serial Number within
                                            the DockId buffer.

                 ULONG SerialNumberLength - Specifies the length in characters of the Serial Number
                                            string (not including terminating NULL).

                 WCHAR DockId - Character buffer containing two null-terminated strings.  The first
                                string is a character representation of the dock ID number, starting
                                at the beginning of the buffer.  The second string is a character
                                representation of the machine's serial number, starting at character
                                offset SerialNumberOffset in the buffer.


        SystemPowerSettings - Data type is SYSTEM_POWER_SETTINGS
            SYSTEM_POWER_INFORMATION Structure
                BOOLEAN SystemSuspendSupported - Supplies a BOOLEAN as to
                    whether the system suspend is enabled or not.
                BOOLEAN SystemHibernateSupported - Supplies a BOOLEAN as to
                    whether the system hibernate is enabled or not.
                BOOLEAN ResumeTimerSupportsSuspend - Supplies a BOOLEAN as to
                    whether the resuming from an external programmed timer
                    from within a system suspend is enabled or not.
                BOOLEAN ResumeTimerSupportsHibernate - Supplies a BOOLEAN as to
                    whether or resuming from an external programmed timer
                    from within a system hibernate is enabled or not.
                BOOLEAN LidSupported - Supplies a BOOLEAN as to whether or not
                    the suspending and resuming by Lid are enabled or not.
                BOOLEAN TurboSettingSupported - Supplies a BOOLEAN as to whether
                    or not the system supports a turbo mode setting.
                BOOLEAN TurboMode - Supplies a BOOLEAN as to whether or not
                    the system is in turbo mode.
                BOOLEAN SystemAcOrDc - Supplies a BOOLEAN as to whether or not
                    the system is in AC mode.
                BOOLEAN DisablePowerDown - If TRUE, signifies that all requests to
                    PoRequestPowerChange for a SET_POWER-PowerDown irp are to
                    be ignored.
                LARGE_INTEGER SpindownDrives - If non-zero, signifies to the
                    cache manager (or the IO subsystem) to optimize drive
                    accesses based upon power saves, are that drives are to
                    be spun down as appropriate. The value represents to user's
                    requested disk spin down timeout.

        SystemProcessorSpeedInformation - Data type is SYSTEM_PROCESSOR_SPEED_INFORMATION
            SYSTEM_PROCESSOR_SPEED_INFORMATION Structure (same as HalProcessorSpeedInformation)
                ULONG MaximumProcessorSpeed - The maximum hertz the processor is
                    capable of. This information is used by the UI to draw the
                    appropriate scale. This field is read-only and cannot be
                    set.
                ULONG CurrentAvailableSpeed - The hertz for which the processor
                    runs at when not idle. This field is read-only and cannot
                    be set.
                ULONG ConfiguredSpeedLimit - The hertz for which the processor
                    is limited to due to the current configuration.
                UCHAR PowerState
                    0 - Normal
                    1 - The processor speed is being limited due to available
                    power restrictions. This field id read-only by the system.
                UCHAR ThermalState
                    0 - Normal
                    1 - The processors speed is being limited due to thermal
                    restrictions. This field is read-only by the system.
                UCHAR TurboState
                    0 - Normal
                    1 - The processors speed is being limited by the fact that
                    the system turbo mode is currently disabled which is
                    requested to obtain more processor speed.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    ReturnLength - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the ReturnLength pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{

    KPROCESSOR_MODE PreviousMode;
    SYSTEM_TIMEOFDAY_INFORMATION LocalTimeOfDayInfo;
    SYSTEM_PERFORMANCE_INFORMATION LocalPerformanceInfo;
    PSYSTEM_PERFORMANCE_INFORMATION PerformanceInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION ProcessorPerformanceInfo;
    PSYSTEM_CALL_COUNT_INFORMATION CallCountInformation;
    PSYSTEM_DEVICE_INFORMATION DeviceInformation;
    PCONFIGURATION_INFORMATION ConfigInfo;
    PSYSTEM_EXCEPTION_INFORMATION ExceptionInformation;
    PSYSTEM_FILECACHE_INFORMATION FileCache;
    PSYSTEM_QUERY_TIME_ADJUST_INFORMATION TimeAdjustmentInformation;
    PSYSTEM_KERNEL_DEBUGGER_INFORMATION KernelDebuggerInformation;
    PSYSTEM_CONTEXT_SWITCH_INFORMATION ContextSwitchInformation;
    PSYSTEM_INTERRUPT_INFORMATION InterruptInformation;
    PSYSTEM_SESSION_PROCESS_INFORMATION SessionProcessInformation;
    PVOID ProcessInformation;
    ULONG ProcessInformationLength;

    NTSTATUS Status;
    PKPRCB Prcb;
    ULONG Length = 0;
    ULONG i;
    ULONG ContextSwitches;
    PULONG TableLimit, TableCounts;
    PKSERVICE_TABLE_DESCRIPTOR Table;
    ULONG SessionId;

    PAGED_CODE();

    //
    // Assume successful completion.
    //

    Status = STATUS_SUCCESS;
    try {

        //
        // Get previous processor mode and probe output argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWrite(SystemInformation,
                          SystemInformationLength,
                          SystemInformationClass == SystemKernelDebuggerInformation ? sizeof(BOOLEAN)
                                                                                    : sizeof(ULONG));

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUlong(ReturnLength);
            }
        }

        if (ARGUMENT_PRESENT(ReturnLength)) {
            *ReturnLength = 0;
        }

        switch (SystemInformationClass) {

        case SystemBasicInformation:

            if (SystemInformationLength != sizeof( SYSTEM_BASIC_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetSystemBasicInformation ((PSYSTEM_BASIC_INFORMATION)SystemInformation);

            if (NT_SUCCESS (Status) && ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_BASIC_INFORMATION );
            }
            break;

        case SystemEmulationBasicInformation:

            if (SystemInformationLength != sizeof( SYSTEM_BASIC_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

#if defined(_WIN64)
            Status = ExpGetSystemEmulationBasicInformation ((PSYSTEM_BASIC_INFORMATION)SystemInformation);
#else
            Status = ExpGetSystemBasicInformation ((PSYSTEM_BASIC_INFORMATION)SystemInformation);
#endif

            if (NT_SUCCESS (Status) && ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_BASIC_INFORMATION );
            }
            break;

        case SystemProcessorInformation:
            if (SystemInformationLength < sizeof( SYSTEM_PROCESSOR_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetSystemProcessorInformation ((PSYSTEM_PROCESSOR_INFORMATION)SystemInformation);

            if (NT_SUCCESS (Status) && ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_PROCESSOR_INFORMATION );
            }

            break;

        case SystemEmulationProcessorInformation:

            if (SystemInformationLength < sizeof( SYSTEM_PROCESSOR_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

#if defined(_WIN64)
            Status = ExpGetSystemEmulationProcessorInformation ((PSYSTEM_PROCESSOR_INFORMATION)SystemInformation);
#else
            Status = ExpGetSystemProcessorInformation ((PSYSTEM_PROCESSOR_INFORMATION)SystemInformation);
#endif

            if (NT_SUCCESS (Status) && ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_PROCESSOR_INFORMATION );
            }

            break;

        case SystemPerformanceInformation:
            if (SystemInformationLength < sizeof( SYSTEM_PERFORMANCE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            PerformanceInfo = (PSYSTEM_PERFORMANCE_INFORMATION)SystemInformation;

            //
            // Io information.
            //

            LocalPerformanceInfo.IoReadTransferCount = IoReadTransferCount;
            LocalPerformanceInfo.IoWriteTransferCount = IoWriteTransferCount;
            LocalPerformanceInfo.IoOtherTransferCount = IoOtherTransferCount;
            LocalPerformanceInfo.IoReadOperationCount = IoReadOperationCount;
            LocalPerformanceInfo.IoWriteOperationCount = IoWriteOperationCount;
            LocalPerformanceInfo.IoOtherOperationCount = IoOtherOperationCount;

            //
            // Ke information.
            //
            // These counters are kept on a per processor basis and must
            // be totaled.
            //

            {
                ULONG FirstLevelTbFills = 0;
                ULONG SecondLevelTbFills = 0;
                ULONG SystemCalls = 0;
//                ULONG InterruptCount = 0;

                ContextSwitches = 0;
                for (i = 0; i < (ULONG)KeNumberProcessors; i += 1) {
                    Prcb = KiProcessorBlock[i];
                    if (Prcb != NULL) {
                        ContextSwitches += Prcb->KeContextSwitches;
                        FirstLevelTbFills += Prcb->KeFirstLevelTbFills;
//                        InterruptCount += Prcb->KeInterruptCount;
                        SecondLevelTbFills += Prcb->KeSecondLevelTbFills;
                        SystemCalls += Prcb->KeSystemCalls;
                    }
                }

                LocalPerformanceInfo.ContextSwitches = ContextSwitches;
                LocalPerformanceInfo.FirstLevelTbFills = FirstLevelTbFills;
//                LocalPerformanceInfo.InterruptCount = KeInterruptCount;
                LocalPerformanceInfo.SecondLevelTbFills = SecondLevelTbFills;
                LocalPerformanceInfo.SystemCalls = SystemCalls;
            }

            //
            // Mm information.
            //

            LocalPerformanceInfo.AvailablePages = MmAvailablePages;
            LocalPerformanceInfo.CommittedPages = MmTotalCommittedPages;
            LocalPerformanceInfo.CommitLimit = MmTotalCommitLimit;
            LocalPerformanceInfo.PeakCommitment = MmPeakCommitment;
            LocalPerformanceInfo.PageFaultCount = MmInfoCounters.PageFaultCount;
            LocalPerformanceInfo.CopyOnWriteCount = MmInfoCounters.CopyOnWriteCount;
            LocalPerformanceInfo.TransitionCount = MmInfoCounters.TransitionCount;
            LocalPerformanceInfo.CacheTransitionCount = MmInfoCounters.CacheTransitionCount;
            LocalPerformanceInfo.DemandZeroCount = MmInfoCounters.DemandZeroCount;
            LocalPerformanceInfo.PageReadCount = MmInfoCounters.PageReadCount;
            LocalPerformanceInfo.PageReadIoCount = MmInfoCounters.PageReadIoCount;
            LocalPerformanceInfo.CacheReadCount = MmInfoCounters.CacheReadCount;
            LocalPerformanceInfo.CacheIoCount = MmInfoCounters.CacheIoCount;
            LocalPerformanceInfo.DirtyPagesWriteCount = MmInfoCounters.DirtyPagesWriteCount;
            LocalPerformanceInfo.DirtyWriteIoCount = MmInfoCounters.DirtyWriteIoCount;
            LocalPerformanceInfo.MappedPagesWriteCount = MmInfoCounters.MappedPagesWriteCount;
            LocalPerformanceInfo.MappedWriteIoCount = MmInfoCounters.MappedWriteIoCount;
            LocalPerformanceInfo.FreeSystemPtes = MmTotalFreeSystemPtes[0];

            LocalPerformanceInfo.ResidentSystemCodePage = MmSystemCodePage;
            LocalPerformanceInfo.ResidentSystemCachePage = MmSystemCachePage;
            LocalPerformanceInfo.ResidentPagedPoolPage = MmPagedPoolPage;
            LocalPerformanceInfo.ResidentSystemDriverPage = MmSystemDriverPage;
            LocalPerformanceInfo.TotalSystemCodePages = MmTotalSystemCodePages;
            LocalPerformanceInfo.TotalSystemDriverPages = MmTotalSystemDriverPages;
            LocalPerformanceInfo.AvailablePagedPoolPages = (ULONG)MmAvailablePoolInPages (PagedPool);
            //
            // Process information.
            //

            LocalPerformanceInfo.IdleProcessTime.QuadPart =
                                    UInt32x32To64(PsIdleProcess->Pcb.KernelTime,
                                                  KeMaximumIncrement);

            //
            // Pool information.
            //

            LocalPerformanceInfo.PagedPoolPages = 0;
            LocalPerformanceInfo.NonPagedPoolPages = 0;
            LocalPerformanceInfo.PagedPoolAllocs = 0;
            LocalPerformanceInfo.PagedPoolFrees = 0;
            LocalPerformanceInfo.PagedPoolLookasideHits = 0;
            LocalPerformanceInfo.NonPagedPoolAllocs = 0;
            LocalPerformanceInfo.NonPagedPoolFrees = 0;
            LocalPerformanceInfo.NonPagedPoolLookasideHits = 0;
            ExQueryPoolUsage( &LocalPerformanceInfo.PagedPoolPages,
                              &LocalPerformanceInfo.NonPagedPoolPages,
                              &LocalPerformanceInfo.PagedPoolAllocs,
                              &LocalPerformanceInfo.PagedPoolFrees,
                              &LocalPerformanceInfo.PagedPoolLookasideHits,
                              &LocalPerformanceInfo.NonPagedPoolAllocs,
                              &LocalPerformanceInfo.NonPagedPoolFrees,
                              &LocalPerformanceInfo.NonPagedPoolLookasideHits
                            );

            //
            // Cache Manager information.
            //

            LocalPerformanceInfo.CcFastReadNoWait = CcFastReadNoWait;
            LocalPerformanceInfo.CcFastReadWait = CcFastReadWait;
            LocalPerformanceInfo.CcFastReadResourceMiss = CcFastReadResourceMiss;
            LocalPerformanceInfo.CcFastReadNotPossible = CcFastReadNotPossible;
            LocalPerformanceInfo.CcFastMdlReadNoWait = CcFastMdlReadNoWait;
            LocalPerformanceInfo.CcFastMdlReadWait = CcFastMdlReadWait;
            LocalPerformanceInfo.CcFastMdlReadResourceMiss = CcFastMdlReadResourceMiss;
            LocalPerformanceInfo.CcFastMdlReadNotPossible = CcFastMdlReadNotPossible;
            LocalPerformanceInfo.CcMapDataNoWait = CcMapDataNoWait;
            LocalPerformanceInfo.CcMapDataWait = CcMapDataWait;
            LocalPerformanceInfo.CcMapDataNoWaitMiss = CcMapDataNoWaitMiss;
            LocalPerformanceInfo.CcMapDataWaitMiss = CcMapDataWaitMiss;
            LocalPerformanceInfo.CcPinMappedDataCount = CcPinMappedDataCount;
            LocalPerformanceInfo.CcPinReadNoWait = CcPinReadNoWait;
            LocalPerformanceInfo.CcPinReadWait = CcPinReadWait;
            LocalPerformanceInfo.CcPinReadNoWaitMiss = CcPinReadNoWaitMiss;
            LocalPerformanceInfo.CcPinReadWaitMiss = CcPinReadWaitMiss;
            LocalPerformanceInfo.CcCopyReadNoWait = CcCopyReadNoWait;
            LocalPerformanceInfo.CcCopyReadWait = CcCopyReadWait;
            LocalPerformanceInfo.CcCopyReadNoWaitMiss = CcCopyReadNoWaitMiss;
            LocalPerformanceInfo.CcCopyReadWaitMiss = CcCopyReadWaitMiss;
            LocalPerformanceInfo.CcMdlReadNoWait = CcMdlReadNoWait;
            LocalPerformanceInfo.CcMdlReadWait = CcMdlReadWait;
            LocalPerformanceInfo.CcMdlReadNoWaitMiss = CcMdlReadNoWaitMiss;
            LocalPerformanceInfo.CcMdlReadWaitMiss = CcMdlReadWaitMiss;
            LocalPerformanceInfo.CcReadAheadIos = CcReadAheadIos;
            LocalPerformanceInfo.CcLazyWriteIos = CcLazyWriteIos;
            LocalPerformanceInfo.CcLazyWritePages = CcLazyWritePages;
            LocalPerformanceInfo.CcDataFlushes = CcDataFlushes;
            LocalPerformanceInfo.CcDataPages = CcDataPages;

#if !defined(NT_UP)
            //
            // On an MP machines go sum up some other 'hot' cache manager
            // statistics.
            //

            for (i = 0; i < (ULONG)KeNumberProcessors; i++) {
                Prcb = KiProcessorBlock[i];

                LocalPerformanceInfo.CcFastReadNoWait += Prcb->CcFastReadNoWait;
                LocalPerformanceInfo.CcFastReadWait += Prcb->CcFastReadWait;
                LocalPerformanceInfo.CcFastReadNotPossible += Prcb->CcFastReadNotPossible;
                LocalPerformanceInfo.CcCopyReadNoWait += Prcb->CcCopyReadNoWait;
                LocalPerformanceInfo.CcCopyReadWait += Prcb->CcCopyReadWait;
                LocalPerformanceInfo.CcCopyReadNoWaitMiss += Prcb->CcCopyReadNoWaitMiss;
            }
#endif
            *PerformanceInfo = LocalPerformanceInfo;
            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(LocalPerformanceInfo);
            }

            break;

        case SystemProcessorPerformanceInformation:
            if (SystemInformationLength <
                sizeof( SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            ProcessorPerformanceInfo =
                (PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) SystemInformation;

            Length = 0;
            for (i = 0; i < (ULONG)KeNumberProcessors; i++) {
                Prcb = KiProcessorBlock[i];
                if (Prcb != NULL) {
                    if (SystemInformationLength < Length + sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION))
                        break;

                    Length += sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION);

                    ProcessorPerformanceInfo->UserTime.QuadPart =
                                                UInt32x32To64(Prcb->UserTime,
                                                              KeMaximumIncrement);

                    ProcessorPerformanceInfo->KernelTime.QuadPart =
                                                UInt32x32To64(Prcb->KernelTime,
                                                              KeMaximumIncrement);

                    ProcessorPerformanceInfo->DpcTime.QuadPart =
                                                UInt32x32To64(Prcb->DpcTime,
                                                              KeMaximumIncrement);

                    ProcessorPerformanceInfo->InterruptTime.QuadPart =
                                                UInt32x32To64(Prcb->InterruptTime,
                                                              KeMaximumIncrement);

                    ProcessorPerformanceInfo->IdleTime.QuadPart =
                                                UInt32x32To64(Prcb->IdleThread->KernelTime,
                                                              KeMaximumIncrement);

                    ProcessorPerformanceInfo->InterruptCount = Prcb->InterruptCount;

                    ProcessorPerformanceInfo++;
                }
            }

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            break;

        case SystemProcessorPowerInformation:
            if (SystemInformationLength < sizeof( SYSTEM_PROCESSOR_POWER_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            ExpGetProcessorPowerInformation(
                SystemInformation,
                SystemInformationLength,
                &Length
                );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemProcessorIdleInformation:
            if (SystemInformationLength < sizeof( SYSTEM_PROCESSOR_IDLE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            ExpGetProcessorIdleInformation(
                SystemInformation,
                SystemInformationLength,
                &Length
                );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemTimeOfDayInformation:
            if (SystemInformationLength > sizeof (SYSTEM_TIMEOFDAY_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            RtlZeroMemory (&LocalTimeOfDayInfo, sizeof(LocalTimeOfDayInfo));
            KeQuerySystemTime(&LocalTimeOfDayInfo.CurrentTime);
            LocalTimeOfDayInfo.BootTime = KeBootTime;
            LocalTimeOfDayInfo.TimeZoneBias = ExpTimeZoneBias;
            LocalTimeOfDayInfo.TimeZoneId = ExpCurrentTimeZoneId;
            LocalTimeOfDayInfo.BootTimeBias = KeBootTimeBias;
            LocalTimeOfDayInfo.SleepTimeBias = KeInterruptTimeBias;

            try {
                RtlCopyMemory (
                    SystemInformation,
                    &LocalTimeOfDayInfo,
                    SystemInformationLength
                    );

                if (ARGUMENT_PRESENT(ReturnLength) ) {
                    *ReturnLength = SystemInformationLength;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode ();
            }

            break;

            //
            // Query system time adjustment information.
            //

        case SystemTimeAdjustmentInformation:
            if (SystemInformationLength != sizeof( SYSTEM_QUERY_TIME_ADJUST_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            TimeAdjustmentInformation =
                    (PSYSTEM_QUERY_TIME_ADJUST_INFORMATION)SystemInformation;

            TimeAdjustmentInformation->TimeAdjustment = KeTimeAdjustment;
            TimeAdjustmentInformation->TimeIncrement = KeMaximumIncrement;
            TimeAdjustmentInformation->Enable = KeTimeSynchronization;
            break;

        case SystemSummaryMemoryInformation:
        case SystemFullMemoryInformation:

            if (SystemInformationLength < sizeof( SYSTEM_MEMORY_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = MmMemoryUsage (SystemInformation,
                                    SystemInformationLength,
             (SystemInformationClass == SystemFullMemoryInformation) ? 0 : 1,
                                    &Length);

            if (NT_SUCCESS(Status) && ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemPathInformation:
#if DBG
            DbgPrint( "EX: SystemPathInformation now available via SharedUserData\n" );
            DbgBreakPoint();
#endif
            return STATUS_NOT_IMPLEMENTED;
            break;

        case SystemProcessInformation:
        case SystemExtendedProcessInformation:
            {
                BOOLEAN ExtendedInformation;

                if (SystemInformationClass == SystemProcessInformation ) {
                    ExtendedInformation = FALSE;
                } else {
                    ExtendedInformation = TRUE;
                }

                Status = ExpGetProcessInformation (SystemInformation,
                                               SystemInformationLength,
                                               &Length,
                                               NULL,
                                               ExtendedInformation);

                if (ARGUMENT_PRESENT( ReturnLength )) {
                    *ReturnLength = Length;
                }
            }

            break;

        case SystemSessionProcessInformation:


            SessionProcessInformation =
                        (PSYSTEM_SESSION_PROCESS_INFORMATION)SystemInformation;

            if (SystemInformationLength < sizeof( SYSTEM_SESSION_PROCESS_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }
            //
            // The lower level locks the buffer specified below into memory using MmProbeAndLockPages.
            // We don't need to probe the buffers here.
            //
            SessionId = SessionProcessInformation->SessionId;
            ProcessInformation = SessionProcessInformation->Buffer;
            ProcessInformationLength = SessionProcessInformation->SizeOfBuf;

            if (!POINTER_IS_ALIGNED (ProcessInformation, sizeof (ULONG))) {
                return STATUS_DATATYPE_MISALIGNMENT;
            }

            Status = ExpGetProcessInformation (ProcessInformation,
                                               ProcessInformationLength,
                                               &Length,
                                               &SessionId,
                                               FALSE);

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            break;

        case SystemCallCountInformation:

            Length = sizeof(SYSTEM_CALL_COUNT_INFORMATION) +
                        (NUMBER_SERVICE_TABLES * sizeof(ULONG));

            Table = KeServiceDescriptorTableShadow;

            for (i = 0; i < NUMBER_SERVICE_TABLES; i += 1) {
                if ((Table->Limit != 0) && (Table->Count != NULL)) {
                    Length += Table->Limit * sizeof(ULONG);
                }
                Table += 1;
            }

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            if (SystemInformationLength < Length) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            CallCountInformation = (PSYSTEM_CALL_COUNT_INFORMATION)SystemInformation;
            CallCountInformation->Length = Length;
            CallCountInformation->NumberOfTables = NUMBER_SERVICE_TABLES;

            TableLimit = (PULONG)(CallCountInformation + 1);
            TableCounts = TableLimit + NUMBER_SERVICE_TABLES;

            Table = KeServiceDescriptorTableShadow;

            for (i = 0; i < NUMBER_SERVICE_TABLES; i += 1) {
                if ((Table->Limit == 0) || (Table->Count == NULL)) {
                    *TableLimit++ = 0;
                } else {
                    *TableLimit++ = Table->Limit;
                    RtlCopyMemory((PVOID)TableCounts,
                                  (PVOID)Table->Count,
                                  Table->Limit * sizeof(ULONG));
                    TableCounts += Table->Limit;
                }
                Table += 1;
            }

            break;

        case SystemDeviceInformation:
            if (SystemInformationLength != sizeof( SYSTEM_DEVICE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            ConfigInfo = IoGetConfigurationInformation();
            DeviceInformation = (PSYSTEM_DEVICE_INFORMATION)SystemInformation;
            DeviceInformation->NumberOfDisks = ConfigInfo->DiskCount;
            DeviceInformation->NumberOfFloppies = ConfigInfo->FloppyCount;
            DeviceInformation->NumberOfCdRoms = ConfigInfo->CdRomCount;
            DeviceInformation->NumberOfTapes = ConfigInfo->TapeCount;
            DeviceInformation->NumberOfSerialPorts = ConfigInfo->SerialCount;
            DeviceInformation->NumberOfParallelPorts = ConfigInfo->ParallelCount;

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_DEVICE_INFORMATION );
            }
            break;

        case SystemFlagsInformation:
            if (SystemInformationLength != sizeof( SYSTEM_FLAGS_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            ((PSYSTEM_FLAGS_INFORMATION)SystemInformation)->Flags = NtGlobalFlag;

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_FLAGS_INFORMATION );
            }
            break;

        case SystemCallTimeInformation:
            return STATUS_NOT_IMPLEMENTED;

        case SystemModuleInformation:
            KeEnterCriticalRegion();
            ExAcquireResourceExclusiveLite( &PsLoadedModuleResource, TRUE );
            try {
                Status = ExpQueryModuleInformation( &PsLoadedModuleList,
                                                    &MmLoadedUserImageList,
                                                    (PRTL_PROCESS_MODULES)SystemInformation,
                                                    SystemInformationLength,
                                                    ReturnLength
                                                );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
            }
            ExReleaseResourceLite (&PsLoadedModuleResource);
            KeLeaveCriticalRegion();
            break;

        case SystemLocksInformation:
            if (SystemInformationLength < sizeof( RTL_PROCESS_LOCKS )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetLockInformation (SystemInformation,
                                            SystemInformationLength,
                                            &Length);

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            break;

        case SystemStackTraceInformation:
            if (SystemInformationLength < sizeof( RTL_PROCESS_BACKTRACES )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

#if i386 
            Status = ExpGetStackTraceInformation (SystemInformation,
                                                  SystemInformationLength,
                                                  &Length);
#else
            Status = STATUS_NOT_IMPLEMENTED;
#endif // i386 

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            break;

        case SystemPagedPoolInformation:
            if (SystemInformationLength < sizeof( SYSTEM_POOL_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetPoolInformation( PagedPool,
                                            SystemInformation,
                                            SystemInformationLength,
                                            &Length
                                          );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemNonPagedPoolInformation:
            if (SystemInformationLength < sizeof( SYSTEM_POOL_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetPoolInformation( NonPagedPool,
                                            SystemInformation,
                                            SystemInformationLength,
                                            &Length
                                          );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemHandleInformation:
            if (SystemInformationLength < sizeof( SYSTEM_HANDLE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (!POINTER_IS_ALIGNED (SystemInformation, TYPE_ALIGNMENT (SYSTEM_HANDLE_INFORMATION))) {
                return STATUS_DATATYPE_MISALIGNMENT;
            }

            Status = ExpGetHandleInformation( SystemInformation,
                                              SystemInformationLength,
                                              &Length
                                            );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemExtendedHandleInformation:
            if (SystemInformationLength < sizeof( SYSTEM_HANDLE_INFORMATION_EX )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (!POINTER_IS_ALIGNED (SystemInformation, TYPE_ALIGNMENT (SYSTEM_HANDLE_INFORMATION_EX))) {
                return STATUS_DATATYPE_MISALIGNMENT;
            }

            Status = ExpGetHandleInformationEx( SystemInformation,
                                                SystemInformationLength,
                                                &Length
                                              );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemObjectInformation:
            if (SystemInformationLength < sizeof( SYSTEM_OBJECTTYPE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetObjectInformation( SystemInformation,
                                              SystemInformationLength,
                                              &Length
                                            );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemPageFileInformation:

            if (SystemInformationLength < sizeof( SYSTEM_PAGEFILE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = MmGetPageFileInformation( SystemInformation,
                                               SystemInformationLength,
                                               &Length
                                              );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;


        case SystemFileCacheInformation:

            //
            // This structure was extended in NT 4.0 from 12 bytes.
            // Use the previous size of 12 bytes for versioning info.
            //

            if (SystemInformationLength < 12) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            FileCache = (PSYSTEM_FILECACHE_INFORMATION)SystemInformation;
            FileCache->CurrentSize = MmSystemCacheWs.WorkingSetSize << PAGE_SHIFT;
            FileCache->PeakSize = MmSystemCacheWs.PeakWorkingSetSize << PAGE_SHIFT;
            FileCache->CurrentSizeIncludingTransitionInPages = MmSystemCacheWs.WorkingSetSize + MmTransitionSharedPages;
            FileCache->PeakSizeIncludingTransitionInPages = MmTransitionSharedPagesPeak;
            FileCache->PageFaultCount = MmSystemCacheWs.PageFaultCount;

            i = 12;
            if (SystemInformationLength >= sizeof( SYSTEM_FILECACHE_INFORMATION )) {
                i = sizeof (SYSTEM_FILECACHE_INFORMATION);
                FileCache->MinimumWorkingSet =
                                MmSystemCacheWs.MinimumWorkingSetSize;
                FileCache->MaximumWorkingSet =
                                MmSystemCacheWs.MaximumWorkingSetSize;
            }

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = i;
            }
            break;

        case SystemPoolTagInformation:

#ifdef POOL_TAGGING
            if (SystemInformationLength < sizeof( SYSTEM_POOLTAG_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetPoolTagInfo (SystemInformation,
                                        SystemInformationLength,
                                        ReturnLength);
#else
            return STATUS_NOT_IMPLEMENTED;
#endif //POOL_TAGGING

            break;

        case SystemVdmInstemulInformation:
#ifdef i386
            if (SystemInformationLength < sizeof( SYSTEM_VDM_INSTEMUL_INFO )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetInstemulInformation(
                                            (PSYSTEM_VDM_INSTEMUL_INFO)SystemInformation
                                            );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(SYSTEM_VDM_INSTEMUL_INFO);
            }
#else
            Status = STATUS_NOT_IMPLEMENTED;
#endif
            break;

            //
            // Get system exception information which includes the number
            // of exceptions that have dispatched, the number of alignment
            // fixups, and the number of floating emulations that have been
            // performed.
            //

        case SystemExceptionInformation:
            if (SystemInformationLength < sizeof( SYSTEM_EXCEPTION_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(SYSTEM_EXCEPTION_INFORMATION);
            }

            ExceptionInformation = (PSYSTEM_EXCEPTION_INFORMATION)SystemInformation;

            //
            // Ke information.
            //
            // These counters are kept on a per processor basis and must
            // be totaled.
            //

            {
                ULONG AlignmentFixupCount = 0;
                ULONG ExceptionDispatchCount = 0;
                ULONG FloatingEmulationCount = 0;
                ULONG ByteWordEmulationCount = 0;

                for (i = 0; i < (ULONG)KeNumberProcessors; i += 1) {
                    Prcb = KiProcessorBlock[i];
                    if (Prcb != NULL) {
                        AlignmentFixupCount += Prcb->KeAlignmentFixupCount;
                        ExceptionDispatchCount += Prcb->KeExceptionDispatchCount;
                        FloatingEmulationCount += Prcb->KeFloatingEmulationCount;
                    }
                }

                ExceptionInformation->AlignmentFixupCount = AlignmentFixupCount;
                ExceptionInformation->ExceptionDispatchCount = ExceptionDispatchCount;
                ExceptionInformation->FloatingEmulationCount = FloatingEmulationCount;
                ExceptionInformation->ByteWordEmulationCount = ByteWordEmulationCount;
            }

            break;

        case SystemKernelDebuggerInformation:

            if (SystemInformationLength < sizeof( SYSTEM_KERNEL_DEBUGGER_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            KernelDebuggerInformation =
                (PSYSTEM_KERNEL_DEBUGGER_INFORMATION)SystemInformation;
            KernelDebuggerInformation->KernelDebuggerEnabled = KdDebuggerEnabled;
            KernelDebuggerInformation->KernelDebuggerNotPresent = KdDebuggerNotPresent;

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(SYSTEM_KERNEL_DEBUGGER_INFORMATION);
            }

            break;

        case SystemContextSwitchInformation:

            if (SystemInformationLength < sizeof( SYSTEM_CONTEXT_SWITCH_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            ContextSwitchInformation =
                (PSYSTEM_CONTEXT_SWITCH_INFORMATION)SystemInformation;

            //
            // Compute the total number of context switches and fill in the
            // remainder of the context switch information.
            //

            ContextSwitches = 0;
            for (i = 0; i < (ULONG)KeNumberProcessors; i += 1) {
                Prcb = KiProcessorBlock[i];
                if (Prcb != NULL) {
                    ContextSwitches += Prcb->KeContextSwitches;
                }

            }

            ContextSwitchInformation->ContextSwitches = ContextSwitches;
            ContextSwitchInformation->FindAny = KeThreadSwitchCounters.FindAny;
            ContextSwitchInformation->FindLast = KeThreadSwitchCounters.FindLast;
            ContextSwitchInformation->FindIdeal = KeThreadSwitchCounters.FindIdeal;
            ContextSwitchInformation->IdleAny = KeThreadSwitchCounters.IdleAny;
            ContextSwitchInformation->IdleCurrent = KeThreadSwitchCounters.IdleCurrent;
            ContextSwitchInformation->IdleLast = KeThreadSwitchCounters.IdleLast;
            ContextSwitchInformation->IdleIdeal = KeThreadSwitchCounters.IdleIdeal;
            ContextSwitchInformation->PreemptAny = KeThreadSwitchCounters.PreemptAny;
            ContextSwitchInformation->PreemptCurrent = KeThreadSwitchCounters.PreemptCurrent;
            ContextSwitchInformation->PreemptLast = KeThreadSwitchCounters.PreemptLast;
            ContextSwitchInformation->SwitchToIdle = KeThreadSwitchCounters.SwitchToIdle;

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(SYSTEM_CONTEXT_SWITCH_INFORMATION);
            }

            break;

        case SystemRegistryQuotaInformation:

            if (SystemInformationLength < sizeof( SYSTEM_REGISTRY_QUOTA_INFORMATION)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }
            CmQueryRegistryQuotaInformation((PSYSTEM_REGISTRY_QUOTA_INFORMATION)SystemInformation);

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(SYSTEM_REGISTRY_QUOTA_INFORMATION);
            }
            break;

        case SystemDpcBehaviorInformation:
            {
                PSYSTEM_DPC_BEHAVIOR_INFORMATION DpcInfo;
                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //
                if (SystemInformationLength != sizeof(SYSTEM_DPC_BEHAVIOR_INFORMATION)) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                DpcInfo = (PSYSTEM_DPC_BEHAVIOR_INFORMATION)SystemInformation;

                //
                // Exception handler for this routine will return the correct
                // error if any of these accesses fail.
                //
                //
                // Return the current DPC behavior variables
                //
                DpcInfo->DpcQueueDepth = KiMaximumDpcQueueDepth;
                DpcInfo->MinimumDpcRate = KiMinimumDpcRate;
                DpcInfo->AdjustDpcThreshold = KiAdjustDpcThreshold;
                DpcInfo->IdealDpcRate = KiIdealDpcRate;
            }
            break;

        case SystemInterruptInformation:

            if (SystemInformationLength < (sizeof(SYSTEM_INTERRUPT_INFORMATION) * KeNumberProcessors)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            InterruptInformation = (PSYSTEM_INTERRUPT_INFORMATION)SystemInformation;
            for (i=0; i < (ULONG)KeNumberProcessors; i++) {
                Prcb = KiProcessorBlock[i];
                InterruptInformation->ContextSwitches = Prcb->KeContextSwitches;
                InterruptInformation->DpcCount = Prcb->DpcCount;
                InterruptInformation->DpcRate = Prcb->DpcRequestRate;
                InterruptInformation->TimeIncrement = KeTimeIncrement;
                InterruptInformation->DpcBypassCount = 0;
                InterruptInformation->ApcBypassCount = 0;

                ++InterruptInformation;
            }

            break;

        case SystemCurrentTimeZoneInformation:
            if (SystemInformationLength < sizeof( RTL_TIME_ZONE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            RtlCopyMemory(SystemInformation,&ExpTimeZoneInformation,sizeof(ExpTimeZoneInformation));
            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( RTL_TIME_ZONE_INFORMATION );
            }

            Status = STATUS_SUCCESS;
            break;

            //
            // Query pool lookaside list and general lookaside list
            // information.
            //

        case SystemLookasideInformation:
            Status = ExpGetLookasideInformation(SystemInformation,
                                                SystemInformationLength,
                                                &Length);

            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }

            break;

        case SystemRangeStartInformation:

            if ( SystemInformationLength != sizeof(ULONG_PTR) ) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            *(PULONG_PTR)SystemInformation = (ULONG_PTR)MmSystemRangeStart;

            if (ARGUMENT_PRESENT(ReturnLength) ) {
                *ReturnLength = sizeof(ULONG_PTR);
            }

            break;

        case SystemVerifierInformation:

            if (SystemInformationLength < sizeof( SYSTEM_VERIFIER_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = MmGetVerifierInformation( SystemInformation,
                                               SystemInformationLength,
                                               &Length
                                              );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemLegacyDriverInformation:
            if (SystemInformationLength < sizeof(SYSTEM_LEGACY_DRIVER_INFORMATION)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }
            Length = SystemInformationLength;
            Status = ExpQueryLegacyDriverInformation((PSYSTEM_LEGACY_DRIVER_INFORMATION)SystemInformation, &Length);
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }
            break;

        case SystemPerformanceTraceInformation:
#ifdef NTPERF
            Status = PerfInfoQueryPerformanceTraceInformation(SystemInformation,
                                                SystemInformationLength,
                                                &Length
                                                );
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }
#else
            Status = STATUS_INVALID_INFO_CLASS;
#endif // NTPERF
            break;

        case SystemPrefetcherInformation:

            Status = CcPfQueryPrefetcherInformation(SystemInformationClass,
                                                    SystemInformation,
                                                    SystemInformationLength,
                                                    PreviousMode,
                                                    &Length
                                                    );

            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }

            break;

        case SystemNumaProcessorMap:

            Status = ExpQueryNumaProcessorMap(SystemInformation,
                                              SystemInformationLength,
                                              &Length);
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }
            break;

        case SystemNumaAvailableMemory:

            Status = ExpQueryNumaAvailableMemory(SystemInformation,
                                                 SystemInformationLength,
                                                 &Length);
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }
            break;

        case SystemRecommendedSharedDataAlignment:
            if (SystemInformationLength < sizeof(ULONG)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            //
            // Alignment is guaranteed by the ProbeForWrite above
            // so just store the value as a ULONG.
            //

            *(PULONG)SystemInformation = KeGetRecommendedSharedDataAlignment();
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(ULONG);
            }
            break;

        case SystemComPlusPackage:
            if (SystemInformationLength != sizeof(ULONG)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            if (SharedUserData->ComPlusPackage == COMPLUS_PACKAGE_INVALID) {

                //
                // The initialization happens one time.
                //
                SharedUserData->ComPlusPackage = 0;

                ExpReadComPlusPackage ();
            }

            *(PULONG)SystemInformation = SharedUserData->ComPlusPackage;
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(ULONG);
            }

        case SystemLostDelayedWriteInformation:

            if (SystemInformationLength < sizeof(ULONG)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            *(PULONG)SystemInformation = CcLostDelayedWrites;
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(ULONG);
            }
            break;

        default:

            //
            // Invalid argument.
            //

            return STATUS_INVALID_INFO_CLASS;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
    }

    return Status;
}

NTSTATUS
NTAPI
NtSetSystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength
    )

/*++

Routine Description:

    This function set information about the system.

Arguments:

    SystemInformationClass - The system information class which is to
        be modified.

    SystemInformation - A pointer to a buffer which contains the specified
        information. The format and content of the buffer depend on the
        specified system information class.


    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - Normal, successful completion.

        STATUS_ACCESS_VIOLATION - The specified system information buffer
            is not accessible.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_PRIVILEGE_NOT_HELD is returned if the caller does not have the
            privilege to set the system time.

--*/

{

    BOOLEAN Enable;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    ULONG TimeAdjustment;
    PSYSTEM_SET_TIME_ADJUST_INFORMATION TimeAdjustmentInformation;
    HANDLE EventHandle;
    PVOID Event;
    ULONG LoadFlags = MM_LOAD_IMAGE_IN_SESSION;

    PAGED_CODE();

    //
    // Establish an exception handle in case the system information buffer
    // is not accessible.
    //

    Status = STATUS_SUCCESS;

    try {

        //
        // Get the previous processor mode and probe the input buffer for
        // read access if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForRead((PVOID)SystemInformation,
                         SystemInformationLength,
                         sizeof(ULONG));
        }

        //
        // Dispatch on the system information class.
        //

        switch (SystemInformationClass) {
        case SystemFlagsInformation:
            if (SystemInformationLength != sizeof( SYSTEM_FLAGS_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (!SeSinglePrivilegeCheck( SeDebugPrivilege, PreviousMode )) {
                return STATUS_ACCESS_DENIED;
            }
            else {
                NtGlobalFlag = ((PSYSTEM_FLAGS_INFORMATION)SystemInformation)->Flags & FLG_KERNELMODE_VALID_BITS;
                ((PSYSTEM_FLAGS_INFORMATION)SystemInformation)->Flags = NtGlobalFlag;
            }
            break;

            //
            // Set system time adjustment information.
            //
            // N.B. The caller must have the SeSystemTime privilege.
            //

        case SystemTimeAdjustmentInformation:

            //
            // If the system information buffer is not the correct length,
            // then return an error.
            //

            if (SystemInformationLength != sizeof( SYSTEM_SET_TIME_ADJUST_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            //
            // If the current thread does not have the privilege to set the
            // time adjustment variables, then return an error.
            //

            if ((PreviousMode != KernelMode) &&
                (SeSinglePrivilegeCheck(SeSystemtimePrivilege, PreviousMode) == FALSE)) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }

            //
            // Set system time adjustment parameters.
            //

            TimeAdjustmentInformation =
                    (PSYSTEM_SET_TIME_ADJUST_INFORMATION)SystemInformation;

            Enable = TimeAdjustmentInformation->Enable;
            TimeAdjustment = TimeAdjustmentInformation->TimeAdjustment;

            if (Enable == TRUE) {
                KeTimeAdjustment = KeMaximumIncrement;
            } else {
                if (TimeAdjustment == 0) {
                    return STATUS_INVALID_PARAMETER_2;
                }
                KeTimeAdjustment = TimeAdjustment;
            }

            KeTimeSynchronization = Enable;
            break;

            //
            // Set an event to signal when the clock interrupt has been
            // masked for too long, causing the time to slip.
            // The event will be referenced to prevent it from being
            // deleted.  If the new event handle is valid or NULL, the
            // old event will be dereferenced and forgotten.  If the
            // event handle is non-NULL but invalid, the old event will
            // be remembered and a failure status will be returned.
            //
            // N.B. The caller must have the SeSystemTime privilege.
            //
        case SystemTimeSlipNotification:

            if (SystemInformationLength != sizeof(HANDLE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            //
            // If the current thread does not have the privilege to set the
            // time adjustment variables, then return an error.
            //

            if ((PreviousMode != KernelMode) &&
                (SeSinglePrivilegeCheck(SeSystemtimePrivilege, PreviousMode) == FALSE)) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }

            EventHandle = *(PHANDLE)SystemInformation;

            if (EventHandle == NULL) {

                //
                // Dereference the old event and don't signal anything
                // for time slips.
                //

                Event = NULL;
                Status = STATUS_SUCCESS;

            } else {

                Status = ObReferenceObjectByHandle(EventHandle,
                                                   EVENT_MODIFY_STATE,
                                                   ExEventObjectType,
                                                   PreviousMode,
                                                   &Event,
                                                   NULL);
            }

            if (NT_SUCCESS(Status)) {
                KdUpdateTimeSlipEvent(Event);
            }

            break;

            //
            // Set registry quota limit.
            //
            // N.B. The caller must have SeIncreaseQuotaPrivilege
            //
        case SystemRegistryQuotaInformation:

            //
            // If the system information buffer is not the correct length,
            // then return an error.
            //

            if (SystemInformationLength != sizeof( SYSTEM_REGISTRY_QUOTA_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            //
            // If the current thread does not have the privilege to create
            // a pagefile, then return an error.
            //

            if ((PreviousMode != KernelMode) &&
                (SeSinglePrivilegeCheck(SeIncreaseQuotaPrivilege, PreviousMode) == FALSE)) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }

            //
            // Set registry quota parameters.
            //
            CmSetRegistryQuotaInformation((PSYSTEM_REGISTRY_QUOTA_INFORMATION)SystemInformation);

            break;

        case SystemPrioritySeperation:
            {
                ULONG PrioritySeparation;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof( ULONG )) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                try {
                    PrioritySeparation = *(PULONG)SystemInformation;
                }
                except(EXCEPTION_EXECUTE_HANDLER) {
                    return GetExceptionCode();
                }

                PsChangeQuantumTable(TRUE,PrioritySeparation);
                Status = STATUS_SUCCESS;
            }
            break;

        case SystemExtendServiceTableInformation:
            {

                UNICODE_STRING Image;
                PWSTR  Buffer;
                PVOID ImageBaseAddress;
                ULONG_PTR EntryPoint;
                PVOID SectionPointer;
                PIMAGE_NT_HEADERS NtHeaders;
                PDRIVER_INITIALIZE InitRoutine;
                DRIVER_OBJECT Win32KDevice;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof( UNICODE_STRING ) ) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so check to ensure
                    // the caller has the privilege to load a driver.
                    //

                    if (!SeSinglePrivilegeCheck( SeLoadDriverPrivilege, PreviousMode )) {
                        return STATUS_PRIVILEGE_NOT_HELD;
                    }

                    Buffer = NULL;

                    try {
                        UNICODE_STRING tImage;
                        USHORT maxLength;

                        tImage = *(PUNICODE_STRING)SystemInformation;

                        //
                        // Leave room for the NULL if possible.
                        // Guard against overflow.
                        //
                        maxLength = tImage.Length + sizeof(UNICODE_NULL);
                        if (maxLength < tImage.Length || maxLength > tImage.MaximumLength) {
                            maxLength = tImage.Length;
                        }

                        ProbeForRead(tImage.Buffer, maxLength, sizeof(UCHAR));

                        Buffer = ExAllocatePoolWithTag(PagedPool, maxLength, 'ofnI');
                        if ( !Buffer ) {
                            return STATUS_NO_MEMORY;
                        }

                        RtlCopyMemory(Buffer, tImage.Buffer, tImage.Length);
                        Image.Buffer = Buffer;
                        Image.Length = tImage.Length;
                        Image.MaximumLength = maxLength;
                    }
                    except(EXCEPTION_EXECUTE_HANDLER) {
                        if ( Buffer ) {
                            ExFreePool(Buffer);
                        }
                        return GetExceptionCode();
                    }

                    //
                    // Call MmLoadSystemImage with previous mode of kernel.
                    //

                    Status = ZwSetSystemInformation(
                                SystemExtendServiceTableInformation,
                                (PVOID)&Image,
                                sizeof(Image)
                                );

                    ExFreePool(Buffer);

                    return Status;

                }

                Image = *(PUNICODE_STRING)SystemInformation;

                //
                // Now in kernelmode, so load the driver.
                //

                Status = MmLoadSystemImage (&Image,
                                            NULL,
                                            NULL,
                                            MM_LOAD_IMAGE_IN_SESSION,
                                            &SectionPointer,
                                            (PVOID *) &ImageBaseAddress);

                if (!NT_SUCCESS (Status)) {
                    return Status;
                }

                NtHeaders = RtlImageNtHeader( ImageBaseAddress );
                if (! NtHeaders) {
                    MmUnloadSystemImage (SectionPointer);
                    return STATUS_INVALID_IMAGE_FORMAT;
                }
                EntryPoint = NtHeaders->OptionalHeader.AddressOfEntryPoint;
                EntryPoint += (ULONG_PTR) ImageBaseAddress;
                InitRoutine = (PDRIVER_INITIALIZE) EntryPoint;

                RtlZeroMemory (&Win32KDevice, sizeof(Win32KDevice));
                ASSERT (KeGetCurrentIrql() == 0);

                Win32KDevice.DriverStart = (PVOID)ImageBaseAddress;
                Status = (InitRoutine)(&Win32KDevice,NULL);

                ASSERT (KeGetCurrentIrql() == 0);

                if (!NT_SUCCESS (Status)) {
                    MmUnloadSystemImage (SectionPointer);
                }
                else {

                    //
                    // Pass the driver object to memory management so the
                    // session can be unloaded cleanly.
                    //

                    MmSessionSetUnloadAddress (&Win32KDevice);
                }
            }
            break;


        case SystemUnloadGdiDriverInformation:
            {

                if (SystemInformationLength != sizeof( PVOID ) ) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so fail.
                    // Only GDI from the kernel can call this.
                    //

                    return STATUS_PRIVILEGE_NOT_HELD;

                }

                MmUnloadSystemImage( *((PVOID *)SystemInformation) );

                Status = STATUS_SUCCESS;

            }
            break;

        case SystemLoadGdiDriverInSystemSpace:
            {
                LoadFlags &= ~MM_LOAD_IMAGE_IN_SESSION;
                //
                // Fall through
                //
            }

        case SystemLoadGdiDriverInformation:
            {

                UNICODE_STRING Image;
                PVOID ImageBaseAddress;
                ULONG_PTR EntryPoint;
                PVOID SectionPointer;

                PIMAGE_NT_HEADERS NtHeaders;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof( SYSTEM_GDI_DRIVER_INFORMATION ) ) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so fail.
                    // Only GDI from the kernel can call this.
                    //

                    return STATUS_PRIVILEGE_NOT_HELD;
                }

                Image = ((PSYSTEM_GDI_DRIVER_INFORMATION)SystemInformation)->DriverName;

                Status = MmLoadSystemImage (&Image,
                                            NULL,
                                            NULL,
                                            LoadFlags,
                                            &SectionPointer,
                                            (PVOID *) &ImageBaseAddress);


                if ((NT_SUCCESS( Status ))) {

                    PSYSTEM_GDI_DRIVER_INFORMATION GdiDriverInfo =
                        (PSYSTEM_GDI_DRIVER_INFORMATION) SystemInformation;

                    ULONG Size;
                    PVOID BaseAddress;

                    GdiDriverInfo->ExportSectionPointer =
                        RtlImageDirectoryEntryToData(ImageBaseAddress,
                                                     TRUE,
                                                     IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                     &Size);

                    //
                    // Capture the entry point.
                    //

                    NtHeaders = RtlImageNtHeader( ImageBaseAddress );
                    EntryPoint = NtHeaders->OptionalHeader.AddressOfEntryPoint;
                    EntryPoint += (ULONG_PTR) ImageBaseAddress;

                    GdiDriverInfo->ImageAddress = (PVOID) ImageBaseAddress;
                    GdiDriverInfo->SectionPointer = SectionPointer;
		    GdiDriverInfo->EntryPoint = (PVOID) EntryPoint;
		    GdiDriverInfo->ImageLength = NtHeaders->OptionalHeader.SizeOfImage;

                    //
                    // GDI drivers are always completely pagable.
                    //

                    if (NT_SUCCESS( Status ) && (LoadFlags & MM_LOAD_IMAGE_IN_SESSION)) {
                        BaseAddress = MmPageEntireDriver((PVOID)ImageBaseAddress);
                        ASSERT(BaseAddress == ImageBaseAddress);
                    }
                }
            }
            break;


        case SystemFileCacheInformation:

            if (SystemInformationLength < sizeof( SYSTEM_FILECACHE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (!SeSinglePrivilegeCheck( SeIncreaseQuotaPrivilege, PreviousMode )) {
                return STATUS_ACCESS_DENIED;
            }

            return MmAdjustWorkingSetSize (
                        ((PSYSTEM_FILECACHE_INFORMATION)SystemInformation)->MinimumWorkingSet,
                        ((PSYSTEM_FILECACHE_INFORMATION)SystemInformation)->MaximumWorkingSet,
                        TRUE,
                        TRUE);

            break;

        case SystemDpcBehaviorInformation:
            {
                SYSTEM_DPC_BEHAVIOR_INFORMATION DpcInfo;
                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //
                if (SystemInformationLength != sizeof(SYSTEM_DPC_BEHAVIOR_INFORMATION)) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {
                    //
                    // The caller's access mode is not kernel so check to ensure that
                    // the caller has the privilege to load a driver.
                    //

                    if (!SeSinglePrivilegeCheck( SeLoadDriverPrivilege, PreviousMode )) {
                        return STATUS_PRIVILEGE_NOT_HELD;
                    }
                }

                //
                // Exception handler for this routine will return the correct
                // error if this access fails.
                //
                DpcInfo = *(PSYSTEM_DPC_BEHAVIOR_INFORMATION)SystemInformation;

                //
                // Set the new DPC behavior variables
                //
                KiMaximumDpcQueueDepth = DpcInfo.DpcQueueDepth;
                KiMinimumDpcRate = DpcInfo.MinimumDpcRate;
                KiAdjustDpcThreshold = DpcInfo.AdjustDpcThreshold;
                KiIdealDpcRate = DpcInfo.IdealDpcRate;
            }
            break;

        case SystemSessionCreate:
            {

                //
                // Creation of a session space.
                //

                ULONG SessionId;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof(ULONG)) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so check to
                    // ensure that the caller has the privilege to load
                    // a driver.
                    //

                    if (!SeSinglePrivilegeCheck (SeLoadDriverPrivilege, PreviousMode)) {
                        return STATUS_PRIVILEGE_NOT_HELD;
                    }

                    try {
                        ProbeForWriteUlong((PULONG)SystemInformation);
                    }
                    except (EXCEPTION_EXECUTE_HANDLER) {
                        return GetExceptionCode();
                    }
                }

                //
                // Create a session space in the current process.
                //

                Status = MmSessionCreate (&SessionId);

                if (NT_SUCCESS(Status)) {
                    if (PreviousMode != KernelMode) {
                        try {
                            *(PULONG)SystemInformation = SessionId;
                        }
                        except (EXCEPTION_EXECUTE_HANDLER) {
                            return GetExceptionCode();
                        }
                    }
                    else {
                        *(PULONG)SystemInformation = SessionId;
                    }
                }

                return Status;
            }
            break;

        case SystemSessionDetach:
            {
                ULONG SessionId;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof(ULONG)) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so check to
                    // ensure that the caller has the privilege to load
                    // a driver.
                    //

                    if (!SeSinglePrivilegeCheck( SeLoadDriverPrivilege, PreviousMode )) {
                        return STATUS_PRIVILEGE_NOT_HELD;
                    }

                    try {
                        ProbeForRead ((PVOID)SystemInformation,
                                      sizeof(ULONG),
                                      sizeof(ULONG));

                        SessionId = *(PULONG)SystemInformation;
                    }
                    except (EXCEPTION_EXECUTE_HANDLER) {
                        return GetExceptionCode();
                    }
                }
                else {
                    SessionId = *(PULONG)SystemInformation;
                }

                //
                // Detach the current process from a session space
                // if it has one.
                //

                Status = MmSessionDelete (SessionId);

                return Status;
            }
            break;

        case SystemCrashDumpStateInformation:

            //
            // All this system information does when you set it is trigger a
            // reconfigurating of the current crashdump state based on the
            // registry.
            //
            Status = IoConfigureCrashDump(CrashDumpReconfigure);

            break;

        case SystemPerformanceTraceInformation:
#ifdef NTPERF
            Status = PerfInfoSetPerformanceTraceInformation(SystemInformation,
                                                 SystemInformationLength
                                                 );
#else
            Status = STATUS_INVALID_INFO_CLASS;
#endif // NTPERF
            break;

        case SystemVerifierThunkExtend:

            if (PreviousMode != KernelMode) {

                //
                // The caller's access mode is not kernel so fail.
                // Only device drivers can call this.
                //

                return STATUS_PRIVILEGE_NOT_HELD;
            }

            Status = MmAddVerifierThunks (SystemInformation,
                                          SystemInformationLength);

            break;

        case SystemVerifierInformation:

            if (!SeSinglePrivilegeCheck (SeDebugPrivilege, PreviousMode)) {
                return STATUS_ACCESS_DENIED;
            }

            Status = MmSetVerifierInformation (SystemInformation,
                                               SystemInformationLength);

            break;

        case SystemVerifierAddDriverInformation:
        case SystemVerifierRemoveDriverInformation:

            {
                UNICODE_STRING Image;
                PUNICODE_STRING ImagePointer;
                PWSTR Buffer;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof( UNICODE_STRING ) ) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                Buffer = NULL;

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so check to ensure
                    // the caller has the privilege to add a verifier entry.
                    //

                    if (!SeSinglePrivilegeCheck( SeDebugPrivilege, PreviousMode )) {
                        return STATUS_PRIVILEGE_NOT_HELD;
                    }

                    try {
                        UNICODE_STRING tImage;
                        USHORT maxLength;

                        tImage = *(PUNICODE_STRING)SystemInformation;

                        //
                        // Leave room for the NULL if possible.
                        // Guard against overflow.
                        //

                        maxLength = tImage.Length + sizeof(UNICODE_NULL);
                        if (maxLength < tImage.Length || maxLength > tImage.MaximumLength) {
                            maxLength = tImage.Length;
                        }

                        ProbeForRead(tImage.Buffer, maxLength, sizeof(UCHAR));

                        Buffer = ExAllocatePoolWithTag(PagedPool, maxLength, 'ofnI');
                        if ( !Buffer ) {
                            return STATUS_NO_MEMORY;
                        }

                        RtlCopyMemory(Buffer, tImage.Buffer, tImage.Length);
                        Image.Buffer = Buffer;
                        Image.Length = tImage.Length;
                        Image.MaximumLength = maxLength;
                        ImagePointer = &Image;
                    }
                    except(EXCEPTION_EXECUTE_HANDLER) {
                        if ( Buffer ) {
                            ExFreePool(Buffer);
                        }
                        return GetExceptionCode();
                    }
                }
                else {
                    ImagePointer = (PUNICODE_STRING)SystemInformation;
                }

                switch (SystemInformationClass) {
                    case SystemVerifierAddDriverInformation:
                        Status = MmAddVerifierEntry (ImagePointer);
                        break;
                    case SystemVerifierRemoveDriverInformation:
                        Status = MmRemoveVerifierEntry (ImagePointer);
                        break;
                    default:
                        Status = STATUS_INVALID_INFO_CLASS;
                        break;
                }

                if (Buffer) {
                    ExFreePool(Buffer);
                }
            }

            break;

        case SystemMirrorMemoryInformation:
            if ((PreviousMode != KernelMode) &&
                (SeSinglePrivilegeCheck(SeShutdownPrivilege, PreviousMode) == FALSE)) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }

            Status = MmCreateMirror ();
            break;

        case SystemPrefetcherInformation:

            Status = CcPfSetPrefetcherInformation(SystemInformationClass,
                                                  SystemInformation,
                                                  SystemInformationLength,
                                                  PreviousMode
                                                  );
            break;

        case SystemComPlusPackage:

            if (SystemInformationLength != sizeof( ULONG ) ) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpUpdateComPlusPackage (*(PULONG)SystemInformation);
            if (NT_SUCCESS (Status)) {
                SharedUserData->ComPlusPackage = *(PULONG)SystemInformation;
            }

            break;

        default:
            //KeBugCheckEx(SystemInformationClass,KdPitchDebugger,0,0,0);
            Status = STATUS_INVALID_INFO_CLASS;
            break;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    return Status;
}

NTSTATUS
ExLockUserBuffer(
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PVOID *LockedBuffer,
    OUT PVOID *LockVariable
    )

{
    PMDL Mdl;
    SIZE_T MdlSize;

    *LockedBuffer = NULL;
    *LockVariable = NULL;
    
    //
    // Allocate an MDL to map the request.
    //

    MdlSize = MmSizeOfMdl( Buffer, Length );
    Mdl = ExAllocatePoolWithQuotaTag (NonPagedPool,
                                      MdlSize,
                                      'ofnI');
    if (Mdl == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize MDL for request.
    //

    MmInitializeMdl(Mdl, Buffer, Length);

    try {

        MmProbeAndLockPages (Mdl, KeGetPreviousMode(), IoWriteAccess);

    } except (EXCEPTION_EXECUTE_HANDLER) {

        ExFreePool (Mdl);

        return GetExceptionCode();
    }

    Mdl->MdlFlags |= MDL_MAPPING_CAN_FAIL;
    *LockedBuffer = MmGetSystemAddressForMdl (Mdl);
    if (*LockedBuffer == NULL) {
        ExUnlockUserBuffer (Mdl);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *LockVariable = Mdl;
    return STATUS_SUCCESS;
}


VOID
ExUnlockUserBuffer(
    IN PVOID LockVariable
    )

{
    MmUnlockPages ((PMDL)LockVariable);
    ExFreePool ((PMDL)LockVariable);
    return;
}

NTSTATUS
ExpGetProcessInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length,
    IN PULONG SessionId OPTIONAL,
    IN BOOLEAN ExtendedInformation
    )
/*++

Routine Description:

    This function returns information about all the processes and
    threads in the system.

Arguments:

    SystemInformation - A pointer to a buffer which receives the specified
        information.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    Length - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.

    SessionId - Session Id.

    ExtendedInformation - TRUE if extended information (e.g., Process PDE) is needed.

Environment:

    Kernel mode.
    
    This routine could be made PAGELK but it is a high frequency routine
    so it is actually better to keep it nonpaged to avoid bringing in the
    entire PAGELK section.

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the Length pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    KLOCK_QUEUE_HANDLE LockHandle;
    PEPROCESS Process = NULL;
    PETHREAD Thread;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PVOID ThreadInfo;
    ULONG ThreadInfoSize;
    PLIST_ENTRY NextThread;
    PVOID MappedAddress;
    PVOID LockVariable;
    ULONG ProcessSessionId;
    ULONG TotalSize = 0;
    ULONG NextEntryOffset = 0;
    PUCHAR Src;
    PWCHAR SrcW;
    PWSTR Dst;
    ULONG n, nc;
    NTSTATUS status = STATUS_SUCCESS, status1;
    PUNICODE_STRING pImageFileName;

    *Length = 0;
    if (SystemInformationLength > 0) {
        status1 = ExLockUserBuffer( SystemInformation,
                                    SystemInformationLength,
                                    &MappedAddress,
                                    &LockVariable
                                    );

        if (!NT_SUCCESS(status1)) {
            return( status1 );
        }

    } else {
        MappedAddress = NULL;
        LockVariable = NULL;
    }

    //
    //
    //
    if (ExtendedInformation) {
        ThreadInfoSize = sizeof(SYSTEM_EXTENDED_THREAD_INFORMATION);

    } else {
        ThreadInfoSize = sizeof(SYSTEM_THREAD_INFORMATION);
    }

    try {

        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)MappedAddress;

        //
        // Do the idle process first then all the other processes.
        //

        for  (Process = PsIdleProcess;
              Process != NULL;
              Process = PsGetNextProcess ((Process == PsIdleProcess) ? NULL : Process)) {

            //
            // Skip terminating processes
            //

            if (Process->Flags&PS_PROCESS_FLAGS_PROCESS_EXITING) {
                continue;
            }

            if (ARGUMENT_PRESENT(SessionId) && Process == PsIdleProcess) {
                continue;
            }

            ProcessSessionId = MmGetSessionId (Process);
            if ((ARGUMENT_PRESENT(SessionId)) &&
                (ProcessSessionId != *SessionId)) {
                continue;
            }

            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                            ((PUCHAR)MappedAddress + TotalSize);

            NextEntryOffset = sizeof(SYSTEM_PROCESS_INFORMATION);
            TotalSize += sizeof(SYSTEM_PROCESS_INFORMATION);
            if (TotalSize > SystemInformationLength) {
                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                //
                // Get information for each process.
                //

                ExpCopyProcessInfo (ProcessInfo, Process, ExtendedInformation);
                ProcessInfo->NumberOfThreads = 0;

                //
                // Store the Remote Terminal SessionId
                //

                ProcessInfo->SessionId = ProcessSessionId;
                ProcessInfo->ImageName.Buffer = NULL;
                ProcessInfo->ImageName.Length = 0;
                ProcessInfo->ImageName.MaximumLength = 0;
                if (Process == PsIdleProcess) {

                    //
                    // Since Idle process and system process share the same
                    // object table, zero out idle processes handle count to
                    // reduce confusion
                    //
                    // Idle Process always has SessionId 0
                    //

                    ProcessInfo->HandleCount = 0;
                    ProcessInfo->SessionId = 0;
                }
            }

            //
            // Raise IRQL to SYNCH_LEVEL, acquire the kernel process lock, and
            // get information for each thread.
            //

            ThreadInfo = (PVOID)(ProcessInfo + 1);
            KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->Pcb.ProcessLock,
                                                       &LockHandle);

            NextThread = Process->Pcb.ThreadListHead.Flink;
            while (NextThread != &Process->Pcb.ThreadListHead) {
                NextEntryOffset += ThreadInfoSize;
                TotalSize += ThreadInfoSize;

                if (TotalSize > SystemInformationLength) {
                    status = STATUS_INFO_LENGTH_MISMATCH;

                } else {
                    Thread = (PETHREAD)(CONTAINING_RECORD(NextThread,
                                                          KTHREAD,
                                                          ThreadListEntry));

                    //
                    // Lock dispatcher database to get atomic view of thread
                    // attributes.
                    //

                    KiLockDispatcherDatabaseAtSynchLevel();
                    ExpCopyThreadInfo (ThreadInfo, Thread, ExtendedInformation);
                    KiUnlockDispatcherDatabaseFromSynchLevel();
                    ProcessInfo->NumberOfThreads += 1;
                    ThreadInfo = (PCHAR) ThreadInfo + ThreadInfoSize;
                }

                NextThread = NextThread->Flink;
            }

            //
            // Unlock kernel process lock and lower IRQL to its previous value.
            //

            KeReleaseInStackQueuedSpinLock(&LockHandle);

            //
            // Get the image name.
            //

            if (Process != PsIdleProcess) {

                //
                // Try to use the real image name if we can that not limited to 16 characters
                //

                Dst = (PWSTR)(ThreadInfo);
                status1 = SeLocateProcessImageName (Process, &pImageFileName);
                if (NT_SUCCESS (status1)) {
                    n = pImageFileName->Length;
                    if (n == 0) {
                        ExFreePool (pImageFileName);
                    }

                } else {
                    n = 0;
                }

                if (n) {
                    SrcW = pImageFileName->Buffer + n / sizeof (WCHAR);
                    while (SrcW != pImageFileName->Buffer) {
                        if (*--SrcW == L'\\') {
                            SrcW = SrcW + 1;
                            break;
                        }
                    }

                    nc = n - (ULONG)(SrcW -  pImageFileName->Buffer) * sizeof (WCHAR);
                    n = ROUND_UP (nc + 1, sizeof(LARGE_INTEGER));
                    TotalSize += n;
                    NextEntryOffset += n;
                    if (TotalSize > SystemInformationLength) {
                        status = STATUS_INFO_LENGTH_MISMATCH;

                    } else {
                        RtlCopyMemory (Dst, SrcW, nc);
                        Dst += nc / sizeof (WCHAR);
                        *Dst++ = L'\0';
                    }

                    ExFreePool (pImageFileName);

                } else {
                    Src = Process->ImageFileName;
                    n = (ULONG) strlen ((PCHAR)Src);
                    if (n != 0) {
                        n = ROUND_UP( ((n + 1) * sizeof( WCHAR )), sizeof(LARGE_INTEGER) );
                        TotalSize += n;
                        NextEntryOffset += n;
                        if (TotalSize > SystemInformationLength) {
                            status = STATUS_INFO_LENGTH_MISMATCH;

                        } else {
                            while (*Dst++ = (WCHAR)*Src++) {
                                ;
                            }
                        }
                    }
                }

                if (NT_SUCCESS (status)) {
                    ProcessInfo->ImageName.Length = (USHORT)((PCHAR)Dst -
                                                             (PCHAR)ThreadInfo - sizeof( UNICODE_NULL ));

                    ProcessInfo->ImageName.MaximumLength = (USHORT)n;

                    //
                    // Set the image name to point into the user's memory.
                    //

                    ProcessInfo->ImageName.Buffer = (PWSTR)
                                ((PCHAR)SystemInformation +
                                 ((PCHAR)(ThreadInfo) - (PCHAR)MappedAddress));
                }
            }

            //
            // Point to next process.
            //

            if (NT_SUCCESS (status)) {
                ProcessInfo->NextEntryOffset = NextEntryOffset;
            }
        }

        if (NT_SUCCESS (status)) {
            ProcessInfo->NextEntryOffset = 0;
        }

        *Length = TotalSize;

    } finally {
        if (MappedAddress != NULL) {
            ExUnlockUserBuffer( LockVariable );
        }
    }

    return(status);
}

VOID
ExpGetProcessorPowerInformation (
    OUT PVOID   SystemInformation,
    IN  ULONG   SystemInformationLength,
    OUT PULONG  Length
    )
{
    KAFFINITY                           currentAffinity;
    KAFFINITY                           processors;
    KIRQL                               oldIrql;
    PKPRCB                              Prcb;
    PPROCESSOR_POWER_STATE              PState;
    PPROCESSOR_PERF_STATE               PerfStates;
    PSYSTEM_PROCESSOR_POWER_INFORMATION CallerPowerInfo;
    SYSTEM_PROCESSOR_POWER_INFORMATION  ProcessorPowerInfo;

    //
    // We will walk this pointer to store the user data...
    //
    CallerPowerInfo = (PSYSTEM_PROCESSOR_POWER_INFORMATION) SystemInformation;
    *Length = 0;

    //
    // Lock everything down
    //
    MmLockPagableSectionByHandle (ExPageLockHandle);

    //
    // Walk the list of processors
    //
    processors = KeActiveProcessors;
    currentAffinity = 1;
    while (processors) {

        if (!(processors & currentAffinity)) {

            currentAffinity <<= 1;

        }

        //
        // Check to see if we have the space for this
        //
        if (SystemInformationLength < *Length + sizeof(SYSTEM_PROCESSOR_POWER_INFORMATION)) {

            break;

        }

        processors &= ~currentAffinity;
        KeSetSystemAffinityThread(currentAffinity);
        currentAffinity <<= 1;

        //
        // Raise to DPC level to synchronize access to the data structures
        //
        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql );

        //
        // Get the PRCB and PowerState information
        //
        Prcb = KeGetCurrentPrcb();
        PState = &(Prcb->PowerState);
        PerfStates = PState->PerfStates;

        //
        // Grab the data that we care about
        //
        ProcessorPowerInfo.CurrentFrequency            = PState->CurrentThrottle;
        ProcessorPowerInfo.LastBusyFrequency           = PState->LastBusyPercentage;
        ProcessorPowerInfo.LastAdjustedBusyFrequency   = PState->LastAdjustedBusyPercentage;
        ProcessorPowerInfo.LastC3Frequency             = PState->LastC3Percentage;
        ProcessorPowerInfo.ProcessorMinThrottle        = PState->ProcessorMinThrottle;
        ProcessorPowerInfo.ProcessorMaxThrottle        = PState->ProcessorMaxThrottle;
        ProcessorPowerInfo.ErrorCount                  = PState->ErrorCount;
        ProcessorPowerInfo.RetryCount                  = PState->RetryCount;

        //
        // Do we have any kind of PerfStates?
        //
        if (PerfStates) {

            ProcessorPowerInfo.ThermalLimitFrequency       = PerfStates[PState->ThermalThrottleIndex].PercentFrequency;
            ProcessorPowerInfo.ConstantThrottleFrequency   = PerfStates[PState->KneeThrottleIndex].PercentFrequency;
            ProcessorPowerInfo.DegradedThrottleFrequency   = PerfStates[PState->ThrottleLimitIndex].PercentFrequency;

        } else {

            ProcessorPowerInfo.ThermalLimitFrequency       = 0;
            ProcessorPowerInfo.ConstantThrottleFrequency   = 0;
            ProcessorPowerInfo.DegradedThrottleFrequency   = 0;

        }

        ProcessorPowerInfo.CurrentFrequencyTime        =
            UInt32x32To64(
                (Prcb->KernelTime + Prcb->UserTime - PState->PerfTickCount),
                KeMaximumIncrement
                );
        ProcessorPowerInfo.CurrentProcessorTime        =
            UInt32x32To64(
                Prcb->KernelTime + Prcb->UserTime,
                KeMaximumIncrement
                );
        ProcessorPowerInfo.CurrentProcessorIdleTime    =
            UInt32x32To64( Prcb->IdleThread->KernelTime, KeMaximumIncrement );
        ProcessorPowerInfo.LastProcessorTime           =
            UInt32x32To64( PState->PerfSystemTime, KeMaximumIncrement );
        ProcessorPowerInfo.LastProcessorIdleTime       =
            UInt32x32To64( PState->PerfIdleTime, KeMaximumIncrement );

        ProcessorPowerInfo.PromotionCount              = PState->PromotionCount;
        ProcessorPowerInfo.DemotionCount               = PState->DemotionCount;
        ProcessorPowerInfo.NumberOfFrequencies         = PState->PerfStatesCount;

        //
        // Return to the original level (should be IRQL 0)
        //
        KeLowerIrql( oldIrql );

        //
        // Copy the data to the correct place
        //
        try {
            RtlCopyMemory(
                CallerPowerInfo,
                &ProcessorPowerInfo,
                sizeof(SYSTEM_PROCESSOR_POWER_INFORMATION)
                );
        } except (EXCEPTION_EXECUTE_HANDLER) {
            MmUnlockPagableImageSection(ExPageLockHandle);
            ExRaiseStatus (GetExceptionCode ());
        }

        //
        // Point to the next structure element
        //
        CallerPowerInfo++;
        *Length += sizeof(SYSTEM_PROCESSOR_POWER_INFORMATION);

    }

    //
    // Unlock everything
    MmUnlockPagableImageSection(ExPageLockHandle);
}

VOID
ExpGetProcessorIdleInformation (
    OUT PVOID   SystemInformation,
    IN  ULONG   SystemInformationLength,
    OUT PULONG  Length
    )
{
    KAFFINITY                           currentAffinity;
    KAFFINITY                           processors;
    KIRQL                               oldIrql;
    LARGE_INTEGER                       PerfFrequency;
    PKPRCB                              Prcb;
    PPROCESSOR_POWER_STATE              PState;
    PSYSTEM_PROCESSOR_IDLE_INFORMATION  CallerIdleInfo;
    SYSTEM_PROCESSOR_IDLE_INFORMATION   ProcessorIdleInfo;

    //
    // We will walk this pointer to store the user data...
    //
    CallerIdleInfo = (PSYSTEM_PROCESSOR_IDLE_INFORMATION) SystemInformation;
    *Length = 0;

    //
    // We need to know what frequency the perf counters are running at
    //
    KeQueryPerformanceCounter(&PerfFrequency);

    //
    // Lock everything down
    //
    MmLockPagableSectionByHandle (ExPageLockHandle);

    //
    // Walk the list of processors
    //
    processors = KeActiveProcessors;
    currentAffinity = 1;
    while (processors) {

        if (!(processors & currentAffinity)) {

            currentAffinity <<= 1;

        }

        //
        // Check to see if we have the space for this
        //
        if (SystemInformationLength < *Length + sizeof(SYSTEM_PROCESSOR_IDLE_INFORMATION)) {

            break;

        }

        processors &= ~currentAffinity;
        KeSetSystemAffinityThread(currentAffinity);
        currentAffinity <<= 1;

        //
        // Raise to DPC level to synchronize access to the data structures
        //
        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql );

        //
        // Get the PRCB and PowerState information
        //
        Prcb = KeGetCurrentPrcb();
        PState = &(Prcb->PowerState);

        //
        // Grab the data that we care about
        //
        ProcessorIdleInfo.IdleTime = UInt32x32To64(Prcb->IdleThread->KernelTime,KeMaximumIncrement);

        //
        // The Cx times are kept in units of the same frequency as KeQueryPerformanceCounter
        // This needs to be converted to standard 100ns units.
        //
        ProcessorIdleInfo.C1Time =  (PState->TotalIdleStateTime[0]*1000)/(PerfFrequency.QuadPart/10000);
        ProcessorIdleInfo.C2Time =  (PState->TotalIdleStateTime[1]*1000)/(PerfFrequency.QuadPart/10000);
        ProcessorIdleInfo.C3Time =  (PState->TotalIdleStateTime[2]*1000)/(PerfFrequency.QuadPart/10000);

        ProcessorIdleInfo.C1Transitions = PState->TotalIdleTransitions[0];
        ProcessorIdleInfo.C2Transitions = PState->TotalIdleTransitions[1];
        ProcessorIdleInfo.C3Transitions = PState->TotalIdleTransitions[2];

        //
        // Return to the original level (should be IRQL 0)
        //
        KeLowerIrql( oldIrql );

        //
        // Copy the data to the correct place
        //
        try {
            RtlCopyMemory(
                CallerIdleInfo,
                &ProcessorIdleInfo,
                sizeof(SYSTEM_PROCESSOR_IDLE_INFORMATION)
                );
        } except (EXCEPTION_EXECUTE_HANDLER) {
            MmUnlockPagableImageSection (ExPageLockHandle);
            ExRaiseStatus (GetExceptionCode ());
        }

        //
        // Point to the next structure element
        //
        CallerIdleInfo++;
        *Length += sizeof(SYSTEM_PROCESSOR_IDLE_INFORMATION);

    }

    //
    // Unlock everything
    MmUnlockPagableImageSection(ExPageLockHandle);
}

VOID
ExpCopyProcessInfo (
    IN PSYSTEM_PROCESS_INFORMATION ProcessInfo,
    IN PEPROCESS Process,
    IN BOOLEAN ExtendedInformation
    )

{
    PAGED_CODE();

    ProcessInfo->HandleCount = ObGetProcessHandleCount (Process);

    ProcessInfo->CreateTime = Process->CreateTime;
    ProcessInfo->UserTime.QuadPart = UInt32x32To64(Process->Pcb.UserTime,
                                                   KeMaximumIncrement);

    ProcessInfo->KernelTime.QuadPart = UInt32x32To64(Process->Pcb.KernelTime,
                                                     KeMaximumIncrement);

    ProcessInfo->BasePriority = Process->Pcb.BasePriority;
    ProcessInfo->UniqueProcessId = Process->UniqueProcessId;
    ProcessInfo->InheritedFromUniqueProcessId = Process->InheritedFromUniqueProcessId;
    ProcessInfo->PeakVirtualSize = Process->PeakVirtualSize;
    ProcessInfo->VirtualSize = Process->VirtualSize;
    ProcessInfo->PageFaultCount = Process->Vm.PageFaultCount;
    ProcessInfo->PeakWorkingSetSize = Process->Vm.PeakWorkingSetSize << PAGE_SHIFT;
    ProcessInfo->WorkingSetSize = Process->Vm.WorkingSetSize << PAGE_SHIFT;
    ProcessInfo->QuotaPeakPagedPoolUsage =
                            Process->QuotaPeak[PsPagedPool];
    ProcessInfo->QuotaPagedPoolUsage = Process->QuotaUsage[PsPagedPool];
    ProcessInfo->QuotaPeakNonPagedPoolUsage =
                            Process->QuotaPeak[PsNonPagedPool];
    ProcessInfo->QuotaNonPagedPoolUsage =
                            Process->QuotaUsage[PsNonPagedPool];
    ProcessInfo->PagefileUsage = Process->QuotaUsage[PsPageFile] << PAGE_SHIFT;
    ProcessInfo->PeakPagefileUsage = Process->QuotaPeak[PsPageFile] << PAGE_SHIFT;
    ProcessInfo->PrivatePageCount = Process->CommitCharge << PAGE_SHIFT;

    ProcessInfo->ReadOperationCount = Process->ReadOperationCount;
    ProcessInfo->WriteOperationCount = Process->WriteOperationCount;
    ProcessInfo->OtherOperationCount = Process->OtherOperationCount;
    ProcessInfo->ReadTransferCount = Process->ReadTransferCount;
    ProcessInfo->WriteTransferCount = Process->WriteTransferCount;
    ProcessInfo->OtherTransferCount = Process->OtherTransferCount;

    if (ExtendedInformation) {
        ProcessInfo->PageDirectoryBase = MmGetDirectoryFrameFromProcess(Process);
    }
}

VOID
ExpCopyThreadInfo (
    IN PVOID ThreadInfoBuffer,
    IN PETHREAD Thread,
    IN BOOLEAN ExtendedInformation
    )

/*++

Routine Description:

    This function returns information about the specified thread.

Arguments:

    ThreadInfoBuffer - A pointer to a buffer which receives the specified
        information.

    Thread - Supplies a pointer to the desired thread.

    ExtendedInformation - TRUE if extended thread information is needed.

Environment:

    Kernel mode.  The dispatcher lock is held.
    
    This routine could be made PAGELK but it is a high frequency routine
    so it is actually better to keep it nonpaged to avoid bringing in the
    entire PAGELK section.

Return Value:

    None.

--*/

{
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    ThreadInfo = (PSYSTEM_THREAD_INFORMATION) ThreadInfoBuffer;

    ThreadInfo->KernelTime.QuadPart = UInt32x32To64(Thread->Tcb.KernelTime,
                                                    KeMaximumIncrement);

    ThreadInfo->UserTime.QuadPart = UInt32x32To64(Thread->Tcb.UserTime,
                                                  KeMaximumIncrement);

    ThreadInfo->CreateTime.QuadPart = PS_GET_THREAD_CREATE_TIME (Thread);
    ThreadInfo->WaitTime = Thread->Tcb.WaitTime;
    ThreadInfo->ClientId = Thread->Cid;
    ThreadInfo->ThreadState = Thread->Tcb.State;
    ThreadInfo->WaitReason = Thread->Tcb.WaitReason;
    ThreadInfo->Priority = Thread->Tcb.Priority;
    ThreadInfo->BasePriority = Thread->Tcb.BasePriority;
    ThreadInfo->ContextSwitches = Thread->Tcb.ContextSwitches;
    ThreadInfo->StartAddress = Thread->StartAddress;

    if (ExtendedInformation) {
        PSYSTEM_EXTENDED_THREAD_INFORMATION ExtendedThreadInfo;

        ExtendedThreadInfo = (PSYSTEM_EXTENDED_THREAD_INFORMATION) ThreadInfo;

        ExtendedThreadInfo->StackBase = Thread->Tcb.StackBase;
        ExtendedThreadInfo->StackLimit = Thread->Tcb.StackLimit;
        if (Thread->LpcReceivedMsgIdValid) {
            ExtendedThreadInfo->Win32StartAddress = 0;
        } else {
            ExtendedThreadInfo->Win32StartAddress = Thread->Win32StartAddress;
        }
        ExtendedThreadInfo->Reserved1 = 0;
        ExtendedThreadInfo->Reserved2 = 0;
        ExtendedThreadInfo->Reserved3 = 0;
        ExtendedThreadInfo->Reserved4 = 0;
    }

}

#if defined(_X86_)
extern ULONG ExVdmOpcodeDispatchCounts[256];
extern ULONG VdmBopCount;
extern ULONG ExVdmSegmentNotPresent;

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, ExpGetInstemulInformation)
#endif


NTSTATUS
ExpGetInstemulInformation(
    OUT PSYSTEM_VDM_INSTEMUL_INFO Info
    )
{
    SYSTEM_VDM_INSTEMUL_INFO LocalInfo;

    LocalInfo.VdmOpcode0F       = ExVdmOpcodeDispatchCounts[VDM_INDEX_0F];
    LocalInfo.OpcodeESPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_ESPrefix];
    LocalInfo.OpcodeCSPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_CSPrefix];
    LocalInfo.OpcodeSSPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_SSPrefix];
    LocalInfo.OpcodeDSPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_DSPrefix];
    LocalInfo.OpcodeFSPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_FSPrefix];
    LocalInfo.OpcodeGSPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_GSPrefix];
    LocalInfo.OpcodeOPER32Prefix= ExVdmOpcodeDispatchCounts[VDM_INDEX_OPER32Prefix];
    LocalInfo.OpcodeADDR32Prefix= ExVdmOpcodeDispatchCounts[VDM_INDEX_ADDR32Prefix];
    LocalInfo.OpcodeINSB        = ExVdmOpcodeDispatchCounts[VDM_INDEX_INSB];
    LocalInfo.OpcodeINSW        = ExVdmOpcodeDispatchCounts[VDM_INDEX_INSW];
    LocalInfo.OpcodeOUTSB       = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTSB];
    LocalInfo.OpcodeOUTSW       = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTSW];
    LocalInfo.OpcodePUSHF       = ExVdmOpcodeDispatchCounts[VDM_INDEX_PUSHF];
    LocalInfo.OpcodePOPF        = ExVdmOpcodeDispatchCounts[VDM_INDEX_POPF];
    LocalInfo.OpcodeINTnn       = ExVdmOpcodeDispatchCounts[VDM_INDEX_INTnn];
    LocalInfo.OpcodeINTO        = ExVdmOpcodeDispatchCounts[VDM_INDEX_INTO];
    LocalInfo.OpcodeIRET        = ExVdmOpcodeDispatchCounts[VDM_INDEX_IRET];
    LocalInfo.OpcodeINBimm      = ExVdmOpcodeDispatchCounts[VDM_INDEX_INBimm];
    LocalInfo.OpcodeINWimm      = ExVdmOpcodeDispatchCounts[VDM_INDEX_INWimm];
    LocalInfo.OpcodeOUTBimm     = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTBimm];
    LocalInfo.OpcodeOUTWimm     = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTWimm];
    LocalInfo.OpcodeINB         = ExVdmOpcodeDispatchCounts[VDM_INDEX_INB];
    LocalInfo.OpcodeINW         = ExVdmOpcodeDispatchCounts[VDM_INDEX_INW];
    LocalInfo.OpcodeOUTB        = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTB];
    LocalInfo.OpcodeOUTW        = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTW];
    LocalInfo.OpcodeLOCKPrefix  = ExVdmOpcodeDispatchCounts[VDM_INDEX_LOCKPrefix];
    LocalInfo.OpcodeREPNEPrefix = ExVdmOpcodeDispatchCounts[VDM_INDEX_REPNEPrefix];
    LocalInfo.OpcodeREPPrefix   = ExVdmOpcodeDispatchCounts[VDM_INDEX_REPPrefix];
    LocalInfo.OpcodeHLT         = ExVdmOpcodeDispatchCounts[VDM_INDEX_HLT];
    LocalInfo.OpcodeCLI         = ExVdmOpcodeDispatchCounts[VDM_INDEX_CLI];
    LocalInfo.OpcodeSTI         = ExVdmOpcodeDispatchCounts[VDM_INDEX_STI];
    LocalInfo.BopCount          = VdmBopCount;
    LocalInfo.SegmentNotPresent = ExVdmSegmentNotPresent;

    RtlCopyMemory(Info,&LocalInfo,sizeof(LocalInfo));

    return STATUS_SUCCESS;
}
#endif

#if i386 
NTSTATUS
ExpGetStackTraceInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    NTSTATUS Status;
    PRTL_PROCESS_BACKTRACES BackTraceInformation;
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    PSTACK_TRACE_DATABASE DataBase;
    PRTL_STACK_TRACE_ENTRY p, *pp;
    ULONG RequiredLength, n;

    DataBase = RtlpAcquireStackTraceDataBase();

    if (DataBase == NULL) {
        return STATUS_UNSUCCESSFUL;
    }
    DataBase->DumpInProgress = TRUE;

    RtlpReleaseStackTraceDataBase();

    n = 0;
    RequiredLength = 0;
    Status = STATUS_INFO_LENGTH_MISMATCH;
    BackTraceInformation = (PRTL_PROCESS_BACKTRACES) SystemInformation;

    RequiredLength = FIELD_OFFSET( RTL_PROCESS_BACKTRACES, BackTraces );

    try {
        if (SystemInformationLength >= RequiredLength) {
            BackTraceInformation->CommittedMemory =
                (ULONG)DataBase->CurrentUpperCommitLimit - (ULONG)DataBase->CommitBase;
            BackTraceInformation->ReservedMemory =
                (ULONG)DataBase->EntryIndexArray - (ULONG)DataBase->CommitBase;
            BackTraceInformation->NumberOfBackTraceLookups = DataBase->NumberOfEntriesLookedUp;
            n = DataBase->NumberOfEntriesAdded;
            BackTraceInformation->NumberOfBackTraces = n;
        }

        RequiredLength += (sizeof( *BackTraceInfo ) * n);
        if (SystemInformationLength >= RequiredLength) {
            Status = STATUS_SUCCESS;
            BackTraceInfo = &BackTraceInformation->BackTraces[ 0 ];
            pp = DataBase->EntryIndexArray;
            while (n--) {
                p = *--pp;
                BackTraceInfo->SymbolicBackTrace = NULL;
                BackTraceInfo->TraceCount = p->TraceCount;
                BackTraceInfo->Index = p->Index;
                BackTraceInfo->Depth = p->Depth;
                RtlCopyMemory( BackTraceInfo->BackTrace,
                               p->BackTrace,
                               p->Depth * sizeof( PVOID )
                             );
                BackTraceInfo += 1;
            }
        }
    }
    finally {
        DataBase->DumpInProgress = FALSE;
    }

    if (ARGUMENT_PRESENT(ReturnLength)) {
        *ReturnLength = RequiredLength;
    }
    return Status;
}
#endif // i386 

NTSTATUS
ExpGetLockInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    )
/*++

Routine Description:

    This function returns information about all the ERESOURCE locks
    in the system.

Arguments:

    SystemInformation - A pointer to a buffer which receives the specified
        information.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    Length - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.


Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the Length pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    PRTL_PROCESS_LOCKS LockInfo;
    PVOID LockVariable;
    NTSTATUS Status;

    *Length = 0;

    Status = ExLockUserBuffer( SystemInformation,
                               SystemInformationLength,
                               &LockInfo,
                               &LockVariable
                               );
    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    Status = STATUS_SUCCESS;

    MmLockPagableSectionByHandle (ExPageLockHandle);
    try {

        Status = ExQuerySystemLockInformation( LockInfo,
                                               SystemInformationLength,
                                               Length
                                             );
    }
    finally {
        ExUnlockUserBuffer( LockVariable );
        MmUnlockPagableImageSection(ExPageLockHandle);
    }

    return Status;
}

NTSTATUS
ExpGetLookasideInformation (
    OUT PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG Length
    )

/*++

Routine Description:

    This function returns pool lookaside list and general lookaside
    list information.

Arguments:

    Buffer - Supplies a pointer to the buffer which receives the lookaside
        list information.

    BufferLength - Supplies the length of the information buffer in bytes.

    Length - Supplies a pointer to a variable that receives the length of
        lookaside information returned.

Environment:

    Kernel mode.
    
    This routine could be made PAGELK but it is a high frequency routine
    so it is actually better to keep it nonpaged to avoid bringing in the
    entire PAGELK section.

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - Normal, successful completion.

        STATUS_ACCESS_VIOLATION - The buffer could not be locked in memory.

--*/

{

    PVOID BufferLock;
    PLIST_ENTRY Entry;
    KIRQL OldIrql;
    ULONG Limit;
    PSYSTEM_LOOKASIDE_INFORMATION Lookaside;
    ULONG Number;
    PNPAGED_LOOKASIDE_LIST NPagedLookaside;
    PPAGED_LOOKASIDE_LIST PagedLookaside;
    PGENERAL_LOOKASIDE PoolLookaside;
    PGENERAL_LOOKASIDE SystemLookaside;
    PKSPIN_LOCK SpinLock;
    NTSTATUS Status;

    //
    // Compute the number of lookaside entries and set the return status to
    // success.
    //

    Limit = BufferLength / sizeof(SYSTEM_LOOKASIDE_INFORMATION);
    Number = 0;
    Status = STATUS_SUCCESS;

    //
    // If the number of lookaside entries to return is not zero, then collect
    // the lookaside information.
    //

    if (Limit != 0) {
        Status = ExLockUserBuffer(Buffer,
                                  BufferLength,
                                  &Lookaside,
                                  &BufferLock);
        if (NT_SUCCESS(Status)) {

            Status = STATUS_SUCCESS;
            
            //
            // Copy nonpaged and paged pool lookaside information to
            // information buffer.
            //

            Entry = ExPoolLookasideListHead.Flink;
            while (Entry != &ExPoolLookasideListHead) {
                PoolLookaside = CONTAINING_RECORD(Entry,
                                                  GENERAL_LOOKASIDE,
                                                  ListEntry);

                Lookaside->CurrentDepth = ExQueryDepthSList(&PoolLookaside->ListHead);
                Lookaside->MaximumDepth = PoolLookaside->Depth;
                Lookaside->TotalAllocates = PoolLookaside->TotalAllocates;
                Lookaside->AllocateMisses =
                        PoolLookaside->TotalAllocates - PoolLookaside->AllocateHits;

                Lookaside->TotalFrees = PoolLookaside->TotalFrees;
                Lookaside->FreeMisses =
                        PoolLookaside->TotalFrees - PoolLookaside->FreeHits;

                Lookaside->Type = PoolLookaside->Type;
                Lookaside->Tag = PoolLookaside->Tag;
                Lookaside->Size = PoolLookaside->Size;
                Number += 1;
                if (Number == Limit) {
                    goto Finish2;
                }

                Entry = Entry->Flink;
                Lookaside += 1;
            }

            //
            // Copy nonpaged and paged system lookaside information to
            // information buffer.
            //

            Entry = ExSystemLookasideListHead.Flink;
            while (Entry != &ExSystemLookasideListHead) {
                SystemLookaside = CONTAINING_RECORD(Entry,
                                                    GENERAL_LOOKASIDE,
                                                    ListEntry);

                Lookaside->CurrentDepth = ExQueryDepthSList(&SystemLookaside->ListHead);
                Lookaside->MaximumDepth = SystemLookaside->Depth;
                Lookaside->TotalAllocates = SystemLookaside->TotalAllocates;
                Lookaside->AllocateMisses = SystemLookaside->AllocateMisses;
                Lookaside->TotalFrees = SystemLookaside->TotalFrees;
                Lookaside->FreeMisses = SystemLookaside->FreeMisses;
                Lookaside->Type = SystemLookaside->Type;
                Lookaside->Tag = SystemLookaside->Tag;
                Lookaside->Size = SystemLookaside->Size;
                Number += 1;
                if (Number == Limit) {
                    goto Finish2;
                }

                Entry = Entry->Flink;
                Lookaside += 1;
            }

            //
            // Copy nonpaged general lookaside information to buffer.
            //

            SpinLock = &ExNPagedLookasideLock;
            ExAcquireSpinLock(SpinLock, &OldIrql);
            Entry = ExNPagedLookasideListHead.Flink;
            while (Entry != &ExNPagedLookasideListHead) {
                NPagedLookaside = CONTAINING_RECORD(Entry,
                                                    NPAGED_LOOKASIDE_LIST,
                                                    L.ListEntry);

                Lookaside->CurrentDepth = ExQueryDepthSList(&NPagedLookaside->L.ListHead);
                Lookaside->MaximumDepth = NPagedLookaside->L.Depth;
                Lookaside->TotalAllocates = NPagedLookaside->L.TotalAllocates;
                Lookaside->AllocateMisses = NPagedLookaside->L.AllocateMisses;
                Lookaside->TotalFrees = NPagedLookaside->L.TotalFrees;
                Lookaside->FreeMisses = NPagedLookaside->L.FreeMisses;
                Lookaside->Type = 0;
                Lookaside->Tag = NPagedLookaside->L.Tag;
                Lookaside->Size = NPagedLookaside->L.Size;
                Number += 1;
                if (Number == Limit) {
                    goto Finish1;
                }

                Entry = Entry->Flink;
                Lookaside += 1;
            }

            ExReleaseSpinLock(SpinLock, OldIrql);

            //
            // Copy paged general lookaside information to buffer.
            //

            SpinLock = &ExPagedLookasideLock;
            ExAcquireSpinLock(SpinLock, &OldIrql);
            Entry = ExPagedLookasideListHead.Flink;
            while (Entry != &ExPagedLookasideListHead) {
                PagedLookaside = CONTAINING_RECORD(Entry,
                                                   PAGED_LOOKASIDE_LIST,
                                                   L.ListEntry);

                Lookaside->CurrentDepth = ExQueryDepthSList(&PagedLookaside->L.ListHead);
                Lookaside->MaximumDepth = PagedLookaside->L.Depth;
                Lookaside->TotalAllocates = PagedLookaside->L.TotalAllocates;
                Lookaside->AllocateMisses = PagedLookaside->L.AllocateMisses;
                Lookaside->TotalFrees = PagedLookaside->L.TotalFrees;
                Lookaside->FreeMisses = PagedLookaside->L.FreeMisses;
                Lookaside->Type = 1;
                Lookaside->Tag = PagedLookaside->L.Tag;
                Lookaside->Size = PagedLookaside->L.Size;
                Number += 1;
                if (Number == Limit) {
                    goto Finish1;
                }

                Entry = Entry->Flink;
                Lookaside += 1;
            }

Finish1:
            ExReleaseSpinLock(SpinLock, OldIrql);

Finish2:
            //
            // Unlock user buffer.
            //

            ExUnlockUserBuffer(BufferLock);
        }
    }

    *Length = Number * sizeof(SYSTEM_LOOKASIDE_INFORMATION);
    return Status;
}

NTSTATUS
ExpGetPoolInformation(
    IN POOL_TYPE PoolType,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    )
/*++

Routine Description:

    This function returns information about the specified type of pool memory.

Arguments:

    SystemInformation - A pointer to a buffer which receives the specified
        information.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    Length - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.


Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the Length pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
#if DBG || (i386 && !FPO)

//
// Only works on checked builds or free x86 builds with FPO turned off
// See comment in mm\allocpag.c
//

    PSYSTEM_POOL_INFORMATION PoolInfo;
    PVOID LockVariable;
    NTSTATUS Status;

    *Length = 0;

    Status = ExLockUserBuffer( SystemInformation,
                               SystemInformationLength,
                               &PoolInfo,
                               &LockVariable
                               );
    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    Status = STATUS_SUCCESS;

    MmLockPagableSectionByHandle (ExPageLockHandle);
    try {
        Status = ExSnapShotPool( PoolType,
                                 PoolInfo,
                                 SystemInformationLength,
                                 Length
                               );

    }
    finally {
        ExUnlockUserBuffer( LockVariable );
        MmUnlockPagableImageSection(ExPageLockHandle);
    }

    return( Status );
#else
    UNREFERENCED_PARAMETER (PoolType);
    UNREFERENCED_PARAMETER (SystemInformation);
    UNREFERENCED_PARAMETER (SystemInformationLength);
    UNREFERENCED_PARAMETER (Length);

    return STATUS_NOT_IMPLEMENTED;
#endif // DBG || (i386 && !FPO)
}

NTSTATUS
ExpGetHandleInformation(
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    )
/*++

Routine Description:

    This function returns information about the open handles in the system.

Arguments:

    SystemInformation - A pointer to a buffer which receives the specified
        information.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    Length - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.


Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the Length pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    PSYSTEM_HANDLE_INFORMATION HandleInfo;
    PVOID LockVariable;
    NTSTATUS Status;

    PAGED_CODE();

    *Length = 0;

    Status = ExLockUserBuffer( SystemInformation,
                               SystemInformationLength,
                               &HandleInfo,
                               &LockVariable
                               );
    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    Status = STATUS_SUCCESS;

    try {
        Status = ObGetHandleInformation( HandleInfo,
                                         SystemInformationLength,
                                         Length
                                       );

    }
    finally {
        ExUnlockUserBuffer( LockVariable );
    }

    return Status;
}

NTSTATUS
ExpGetHandleInformationEx(
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    )
/*++

Routine Description:

    This function returns information about the open handles in the system.

Arguments:

    SystemInformation - A pointer to a buffer which receives the specified
        information.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    Length - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.


Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the Length pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    PSYSTEM_HANDLE_INFORMATION_EX HandleInfo;
    PVOID LockVariable;
    NTSTATUS Status;

    PAGED_CODE();

    *Length = 0;

    Status = ExLockUserBuffer( SystemInformation,
                               SystemInformationLength,
                               &HandleInfo,
                               &LockVariable
                               );
    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    Status = STATUS_SUCCESS;

    try {
        Status = ObGetHandleInformationEx( HandleInfo,
                                           SystemInformationLength,
                                           Length
                                         );

    }
    finally {
        ExUnlockUserBuffer( LockVariable );
    }

    return Status;
}

NTSTATUS
ExpGetObjectInformation(
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    )

/*++

Routine Description:

    This function returns information about the objects in the system.

Arguments:

    SystemInformation - A pointer to a buffer which receives the specified
        information.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    Length - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.


Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the Length pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    PSYSTEM_OBJECTTYPE_INFORMATION ObjectInfo;
    PVOID LockVariable;
    NTSTATUS Status;

    PAGED_CODE();

    *Length = 0;

    Status = ExLockUserBuffer( SystemInformation,
                               SystemInformationLength,
                               &ObjectInfo,
                               &LockVariable
                               );
    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    Status = STATUS_SUCCESS;

    try {
        Status = ObGetObjectInformation( SystemInformation,
                                         ObjectInfo,
                                         SystemInformationLength,
                                         Length
                                       );

    }
    finally {
        ExUnlockUserBuffer( LockVariable );
    }

    return Status;
}

extern SIZE_T PoolTrackTableSize;
extern KSPIN_LOCK ExpTaggedPoolLock;

NTSTATUS
ExpGetPoolTagInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnLength OPTIONAL
    )

{
    SIZE_T NumberOfBytes;
    ULONG totalBytes;
    ULONG i;
    KIRQL OldIrql;
    NTSTATUS status;
    PSYSTEM_POOLTAG_INFORMATION taginfo;
    PSYSTEM_POOLTAG poolTag;
    PPOOL_TRACKER_TABLE PoolTrackInfo;

    PAGED_CODE();
    if (!PoolTrackTable) {
        return STATUS_NOT_IMPLEMENTED;
    }

    totalBytes = 0;
    status = STATUS_SUCCESS;

    taginfo = (PSYSTEM_POOLTAG_INFORMATION)SystemInformation;
    poolTag = &taginfo->TagInfo[0];
    totalBytes = FIELD_OFFSET(SYSTEM_POOLTAG_INFORMATION, TagInfo);
    taginfo->Count = 0;

    //
    // Synchronize access to PoolTrackTable as it can move.
    //

    NumberOfBytes = PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE);

    PoolTrackInfo = (PPOOL_TRACKER_TABLE) ExAllocatePoolWithTag (NonPagedPool,
                                                                 NumberOfBytes,
                                                                 'ofnI');

    if (PoolTrackInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);

    RtlCopyMemory ((PVOID)PoolTrackInfo,
                   (PVOID)PoolTrackTable,
                   NumberOfBytes);

    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

    for (i = 0; i < NumberOfBytes / sizeof(POOL_TRACKER_TABLE); i += 1) {
        if (PoolTrackInfo[i].Key != 0) {
            taginfo->Count += 1;
            totalBytes += sizeof (SYSTEM_POOLTAG);
            if (SystemInformationLength < totalBytes) {
                status = STATUS_INFO_LENGTH_MISMATCH;
            } else {
                poolTag->TagUlong = PoolTrackInfo[i].Key;
                poolTag->PagedAllocs = PoolTrackInfo[i].PagedAllocs;
                poolTag->PagedFrees = PoolTrackInfo[i].PagedFrees;
                poolTag->PagedUsed = PoolTrackInfo[i].PagedBytes;
                poolTag->NonPagedAllocs = PoolTrackInfo[i].NonPagedAllocs;
                poolTag->NonPagedFrees = PoolTrackInfo[i].NonPagedFrees;
                poolTag->NonPagedUsed = PoolTrackInfo[i].NonPagedBytes;
                poolTag += 1;
            }
        }
    }

    ExFreePool (PoolTrackInfo);

    if (ARGUMENT_PRESENT(ReturnLength)) {
        *ReturnLength = totalBytes;
    }

    return status;
}


NTSTATUS
ExpQueryModuleInformation(
    IN PLIST_ENTRY LoadOrderListHead,
    IN PLIST_ENTRY UserModeLoadOrderListHead,
    OUT PRTL_PROCESS_MODULES ModuleInformation,
    IN ULONG ModuleInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    NTSTATUS Status;
    ULONG RequiredLength;
    PLIST_ENTRY Next;
    PRTL_PROCESS_MODULE_INFORMATION ModuleInfo;
    PKLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    ANSI_STRING AnsiString;
    PCHAR s;
    ULONG NumberOfModules;

    NumberOfModules = 0;
    Status = STATUS_SUCCESS;
    RequiredLength = FIELD_OFFSET( RTL_PROCESS_MODULES, Modules );
    ModuleInfo = &ModuleInformation->Modules[ 0 ];

    Next = LoadOrderListHead->Flink;
    while ( Next != LoadOrderListHead ) {
        LdrDataTableEntry = CONTAINING_RECORD( Next,
                                               KLDR_DATA_TABLE_ENTRY,
                                               InLoadOrderLinks
                                             );

        RequiredLength += sizeof( RTL_PROCESS_MODULE_INFORMATION );
        if (ModuleInformationLength < RequiredLength) {
            Status = STATUS_INFO_LENGTH_MISMATCH;
        }
        else {

            ModuleInfo->MappedBase = NULL;
            ModuleInfo->ImageBase = LdrDataTableEntry->DllBase;
            ModuleInfo->ImageSize = LdrDataTableEntry->SizeOfImage;
            ModuleInfo->Flags = LdrDataTableEntry->Flags;
            ModuleInfo->LoadCount = LdrDataTableEntry->LoadCount;

            ModuleInfo->LoadOrderIndex = (USHORT)(NumberOfModules);
            ModuleInfo->InitOrderIndex = 0;
            AnsiString.Buffer = (PCHAR) ModuleInfo->FullPathName;
            AnsiString.Length = 0;
            AnsiString.MaximumLength = sizeof( ModuleInfo->FullPathName );
            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &LdrDataTableEntry->FullDllName,
                                          FALSE
                                        );
            s = AnsiString.Buffer + AnsiString.Length;
            while (s > AnsiString.Buffer && *--s) {
                if (*s == (UCHAR)OBJ_NAME_PATH_SEPARATOR) {
                    s += 1;
                    break;
                }
            }
            ModuleInfo->OffsetToFileName = (USHORT)(s - AnsiString.Buffer);

            ModuleInfo += 1;
        }

        NumberOfModules += 1;
        Next = Next->Flink;
    }

    if (ARGUMENT_PRESENT( UserModeLoadOrderListHead )) {
        Next = UserModeLoadOrderListHead->Flink;
        while ( Next != UserModeLoadOrderListHead ) {
            LdrDataTableEntry = CONTAINING_RECORD( Next,
                                                   KLDR_DATA_TABLE_ENTRY,
                                                   InLoadOrderLinks
                                                 );

            RequiredLength += sizeof( RTL_PROCESS_MODULE_INFORMATION );
            if (ModuleInformationLength < RequiredLength) {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            else {
                ModuleInfo->MappedBase = NULL;
                ModuleInfo->ImageBase = LdrDataTableEntry->DllBase;
                ModuleInfo->ImageSize = LdrDataTableEntry->SizeOfImage;
                ModuleInfo->Flags = LdrDataTableEntry->Flags;
                ModuleInfo->LoadCount = LdrDataTableEntry->LoadCount;

                ModuleInfo->LoadOrderIndex = (USHORT)(NumberOfModules);

                ModuleInfo->InitOrderIndex = ModuleInfo->LoadOrderIndex;

                AnsiString.Buffer = (PCHAR) ModuleInfo->FullPathName;
                AnsiString.Length = 0;
                AnsiString.MaximumLength = sizeof( ModuleInfo->FullPathName );
                RtlUnicodeStringToAnsiString( &AnsiString,
                                              &LdrDataTableEntry->FullDllName,
                                              FALSE
                                            );
                s = AnsiString.Buffer + AnsiString.Length;
                while (s > AnsiString.Buffer && *--s) {
                    if (*s == (UCHAR)OBJ_NAME_PATH_SEPARATOR) {
                        s += 1;
                        break;
                    }
                }
                ModuleInfo->OffsetToFileName = (USHORT)(s - AnsiString.Buffer);

                ModuleInfo += 1;
            }

            NumberOfModules += 1;
            Next = Next->Flink;
        }
    }

    if (ARGUMENT_PRESENT(ReturnLength)) {
        *ReturnLength = RequiredLength;
    }
    if (ModuleInformationLength >= FIELD_OFFSET( RTL_PROCESS_MODULES, Modules )) {
        ModuleInformation->NumberOfModules = NumberOfModules;
    } else {
        Status = STATUS_INFO_LENGTH_MISMATCH;
    }
    return Status;
}

BOOLEAN
ExIsProcessorFeaturePresent(
    ULONG ProcessorFeature
    )
{
    BOOLEAN rv;

    if ( ProcessorFeature < PROCESSOR_FEATURE_MAX ) {
        rv = SharedUserData->ProcessorFeatures[ProcessorFeature];
    }
    else {
        rv = FALSE;
    }
    return rv;
}


NTSTATUS
ExpQueryLegacyDriverInformation(
    IN PSYSTEM_LEGACY_DRIVER_INFORMATION LegacyInfo,
    IN PULONG Length
    )
/*++

Routine Description:

    Returns legacy driver information for figuring out why PNP/Power functionality
    is disabled.

Arguments:

    LegacyInfo - Returns the legacy driver information

    Length - Supplies the length of the LegacyInfo buffer
             Returns the amount of data written

Return Value:

    NTSTATUS

--*/

{
    PNP_VETO_TYPE VetoType;
    PWSTR VetoList = NULL;
    NTSTATUS Status;
    UNICODE_STRING String;
    ULONG ReturnLength;

    Status = IoGetLegacyVetoList(&VetoList, &VetoType);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    RtlInitUnicodeString(&String, VetoList);
    ReturnLength = sizeof(SYSTEM_LEGACY_DRIVER_INFORMATION) + String.Length;
    try {
        if (ReturnLength > *Length) {
            Status = STATUS_BUFFER_OVERFLOW;
        } else {
            LegacyInfo->VetoType = VetoType;
            LegacyInfo->VetoList.Length = String.Length;
            LegacyInfo->VetoList.Buffer = (PWSTR)(LegacyInfo+1);
            RtlCopyMemory(LegacyInfo+1, String.Buffer, String.Length);
        }
    } finally {
        if (VetoList) {
            ExFreePool(VetoList);
        }
    }

    *Length = ReturnLength;
    return(Status);
}

VOID
ExGetCurrentProcessorCpuUsage(
    OUT PULONG CpuUsage
    )
/*++

Routine Description:

    Returns an estimation of current cpu usage in percent.

Arguments:

    CpuUsage - Returns the current cpu usage in percent.

Return Value:

    Nothing

--*/
{
    PKPRCB Prcb;

    Prcb = KeGetCurrentPrcb();
    *CpuUsage = 100 - (ULONG)(UInt32x32To64(Prcb->IdleThread->KernelTime, 100) /
                               (ULONGLONG)(Prcb->KernelTime + Prcb->UserTime));
}


VOID
ExGetCurrentProcessorCounts(
    OUT PULONG IdleCount,
    OUT PULONG KernelAndUser,
    OUT PULONG Index
    )
/*++

Routine Description:

    Returns information regarding idle time and kernel + user time for
    the current processor.

Arguments:

    IdleCount - Returns the kernel time of the idle thread on the current
                processor.

    KernelAndUser - Returns the kernel pluse user on the current processor.

    Index - Returns the number identifiying the current processor.

Return Value:

    Nothing

--*/
{
    PKPRCB Prcb;

    Prcb = KeGetCurrentPrcb();
    *IdleCount = Prcb->IdleThread->KernelTime;
    *KernelAndUser = Prcb->KernelTime + Prcb->UserTime;
    *Index = (ULONG)Prcb->Number;
}

BOOLEAN
ExpIsValidUILanguage(
    IN WCHAR * pLangId
    )
/*++
Routine Description:

    Check if specified language ID is valid.

Arguments:

    pLangId - language ID hex string.

Return Value:

    TRUE: Valid
    FALSE: Invalid

--*/
{
    NTSTATUS Status;
    UNICODE_STRING KeyPath, KeyValueName;
    HANDLE hKey;
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    OBJECT_ATTRIBUTES ObjectAttributes;    
    ULONG ResultLength;    
    BOOLEAN bRet = FALSE;    
    int iLen=0;
    

    RtlInitUnicodeString(&KeyPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\MUILanguages");
    //
    // pLangId is passed in as DWORD or WORD hex string
    // LangId string in MUILanguages is set as WORD hex string
    //
    while (pLangId[iLen])
    {
      iLen++;
    }
    //
    // We need to validate both 4 digits and 8 digits LangId
    //
    RtlInitUnicodeString(&KeyValueName, iLen < 8? pLangId : &pLangId[4]);

    InitializeObjectAttributes (&ObjectAttributes,
                                &KeyPath,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);
    
    if (NT_SUCCESS(ZwOpenKey( &hKey,  GENERIC_READ, &ObjectAttributes)))
    {
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
        
        Status = ZwQueryValueKey( hKey,
                                  &KeyValueName,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  sizeof( KeyValueBuffer ),
                                  &ResultLength
                                );
        
        if (NT_SUCCESS(Status))
        {
            if (KeyValueInformation->Type == REG_SZ && *((PWSTR)(KeyValueInformation->Data)) == L'1')
            {            
                bRet = TRUE;
            }
        }
        
        ZwClose(hKey);        
    }

    return bRet;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\spintrac.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    spinlock.c

Abstract:

   This module implements the executive functions to allocate and free spin
   locks.

Author:

    David N. Cutler (davec) 16-May-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\semphore.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    semphore.c

Abstract:

   This module implements the executive semaphore object. Functions are
   provided to create, open, release, and query semaphore objects.

Author:

    David N. Cutler (davec) 8-May-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

//
// Temporary so boost is patchable
//

ULONG ExpSemaphoreBoost = SEMAPHORE_INCREMENT;

//
// Address of semaphore object type descriptor.
//

POBJECT_TYPE ExSemaphoreObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for semaphore objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING ExpSemaphoreMapping = {
    STANDARD_RIGHTS_READ |
        SEMAPHORE_QUERY_STATE,
    STANDARD_RIGHTS_WRITE |
        SEMAPHORE_MODIFY_STATE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    SEMAPHORE_ALL_ACCESS
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpSemaphoreInitialization)
#pragma alloc_text(PAGE, NtCreateSemaphore)
#pragma alloc_text(PAGE, NtOpenSemaphore)
#pragma alloc_text(PAGE, NtQuerySemaphore)
#pragma alloc_text(PAGE, NtReleaseSemaphore)
#endif

BOOLEAN
ExpSemaphoreInitialization (
    )

/*++

Routine Description:

    This function creates the semaphore object type descriptor at system
    initialization and stores the address of the object type descriptor
    in local static storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the semaphore object type descriptor is
    successfully created. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Semaphore");

    //
    // Create semaphore object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpSemaphoreMapping;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(KSEMAPHORE);
    ObjectTypeInitializer.ValidAccessMask = SEMAPHORE_ALL_ACCESS;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExSemaphoreObjectType);

    //
    // If the semaphore object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

NTSTATUS
NtCreateSemaphore (
    IN PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN LONG InitialCount,
    IN LONG MaximumCount
    )

/*++

Routine Description:

    This function creates a semaphore object, sets its initial count to the
    specified value, sets its maximum count to the specified value, and opens
    a handle to the object with the specified desired access.

Arguments:

    SemaphoreHandle - Supplies a pointer to a variable that will receive the
        semaphore object handle.

    DesiredAccess - Supplies the desired types of access for the semaphore
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    InitialCount - Supplies the initial count of the semaphore object.

    MaximumCount - Supplies the maximum count of the semaphore object.

Return Value:

    NTSTATUS.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    PVOID Semaphore;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to create a semaphore object. If the probe fails, then return
    // the exception code as the service status. Otherwise return the status
    // value returned by the object insertion routine.
    //
    // Get previous processor mode and probe output handle address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(SemaphoreHandle);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Check argument validity.
    //

    if ((MaximumCount <= 0) || (InitialCount < 0) ||
       (InitialCount > MaximumCount)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate semaphore object.
    //

    Status = ObCreateObject(PreviousMode,
                            ExSemaphoreObjectType,
                            ObjectAttributes,
                            PreviousMode,
                            NULL,
                            sizeof(KSEMAPHORE),
                            0,
                            0,
                            (PVOID *)&Semaphore);

    //
    // If the semaphore object was successfully allocated, then initialize
    // the semaphore object and attempt to insert the semaphore object in
    // the current process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeSemaphore((PKSEMAPHORE)Semaphore,
                              InitialCount,
                              MaximumCount);

        Status = ObInsertObject(Semaphore,
                                NULL,
                                DesiredAccess,
                                0,
                                (PVOID *)NULL,
                                &Handle);

        //
        // If the semaphore object was successfully inserted in the current
        // process' handle table, then attempt to write the semaphore handle
        // value. If the write attempt fails, then do not report an error.
        // When the caller attempts to access the handle value, an access
        // violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            if (PreviousMode != KernelMode) {
                try {
                    *SemaphoreHandle = Handle;
                } except(ExSystemExceptionFilter()) {
                    NOTHING;
                }
            }
            else {
                *SemaphoreHandle = Handle;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtOpenSemaphore (
    OUT PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to a semaphore object with the specified
    desired access.

Arguments:

    SemaphoreHandle - Supplies a pointer to a variable that will receive the
        semaphore object handle.

    DesiredAccess - Supplies the desired types of access for the semaphore
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    NTSTATUS.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;


    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to open a semaphore object. If the probe fails, then return
    // the exception code as the service status. Otherwise return the status
    // value returned by the object open routine.
    //
    // Get previous processor mode and probe output handle address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(SemaphoreHandle);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Open handle to the semaphore object with the specified desired access.
    //

    Status = ObOpenObjectByName(ObjectAttributes,
                                ExSemaphoreObjectType,
                                PreviousMode,
                                NULL,
                                DesiredAccess,
                                NULL,
                                &Handle);

    //
    // If the open was successful, then attempt to write the semaphore
    // object handle value. If the write attempt fails, then do not report
    // an error. When the caller attempts to access the handle value, an
    // access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        if (PreviousMode != KernelMode) {
            try {
                *SemaphoreHandle = Handle;
            } except(ExSystemExceptionFilter()) {
                NOTHING;
            }
        }
        else {
            *SemaphoreHandle = Handle;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQuerySemaphore (
    IN HANDLE SemaphoreHandle,
    IN SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    OUT PVOID SemaphoreInformation,
    IN ULONG SemaphoreInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function queries the state of a semaphore object and returns the
    requested information in the specified record structure.

Arguments:

    SemaphoreHandle - Supplies a handle to a semaphore object.

    SemaphoreInformationClass - Supplies the class of information being
        requested.

    SemaphoreInformation - Supplies a pointer to a record that is to receive
        the requested information.

    SemaphoreInformationLength - Supplies the length of the record that is
        to receive the requested information.

    ReturnLength - Supplies an optional pointer to a variable that will
        receive the actual length of the information that is returned.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Semaphore;
    LONG Count;
    LONG Maximum;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output arguments, reference
    // the semaphore object, and return the specified information. If the probe
    // fails, then return the exception code as the service status. Otherwise
    // return the status value returned by the reference object by handle
    // routine.
    //
    // Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteSmallStructure (SemaphoreInformation,
                                         sizeof(SEMAPHORE_BASIC_INFORMATION),
                                         sizeof(ULONG));

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUlong(ReturnLength);
            }
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Check argument validity.
    //

    if (SemaphoreInformationClass != SemaphoreBasicInformation) {
        return STATUS_INVALID_INFO_CLASS;
    }

    if (SemaphoreInformationLength != sizeof(SEMAPHORE_BASIC_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Reference semaphore object by handle.
    //

    Status = ObReferenceObjectByHandle(SemaphoreHandle,
                                       SEMAPHORE_QUERY_STATE,
                                       ExSemaphoreObjectType,
                                       PreviousMode,
                                       &Semaphore,
                                       NULL);

    //
    // If the reference was successful, then read the current state and
    // maximum count of the semaphore object, dereference semaphore object,
    // fill in the information structure, and return the length of the
    // information structure if specified. If the write of the semaphore
    // information or the return length fails, then do not report an error.
    // When the caller accesses the information structure or length an
    // access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        Count = KeReadStateSemaphore((PKSEMAPHORE)Semaphore);
        Maximum = ((PKSEMAPHORE)Semaphore)->Limit;
        ObDereferenceObject(Semaphore);

        if (PreviousMode != KernelMode) {
            try {
                ((PSEMAPHORE_BASIC_INFORMATION)SemaphoreInformation)->CurrentCount = Count;
                ((PSEMAPHORE_BASIC_INFORMATION)SemaphoreInformation)->MaximumCount = Maximum;
                if (ARGUMENT_PRESENT(ReturnLength)) {
                    *ReturnLength = sizeof(SEMAPHORE_BASIC_INFORMATION);
                }
            } except(ExSystemExceptionFilter()) {
                NOTHING;
            }
        }
        else {
            ((PSEMAPHORE_BASIC_INFORMATION)SemaphoreInformation)->CurrentCount = Count;
            ((PSEMAPHORE_BASIC_INFORMATION)SemaphoreInformation)->MaximumCount = Maximum;
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(SEMAPHORE_BASIC_INFORMATION);
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtReleaseSemaphore (
    IN HANDLE SemaphoreHandle,
    IN LONG ReleaseCount,
    OUT PLONG PreviousCount OPTIONAL
    )

/*++

Routine Description:

    This function releases a semaphore object by adding the specified release
    count to the current value.

Arguments:

    Semaphore - Supplies a handle to a semaphore object.

    ReleaseCount - Supplies the release count that is to be added to the
        current semaphore count.

    PreviousCount - Supplies an optional pointer to a variable that will
        receive the previous semaphore count.

Return Value:

    NTSTATUS.

--*/

{

    LONG Count;
    PVOID Semaphore;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the previous count address if
    // specified, reference the semaphore object, and release the semaphore
    // object. If the probe fails, then return the exception code as the
    // service status. Otherwise return the status value returned by the
    // reference object by handle routine.
    //
    // Get previous processor mode and probe previous count address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if ((ARGUMENT_PRESENT(PreviousCount)) && (PreviousMode != KernelMode)) {
        try {
            ProbeForWriteLong(PreviousCount);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Check argument validity.
    //

    if (ReleaseCount <= 0) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Reference semaphore object by handle.
    //

    Status = ObReferenceObjectByHandle(SemaphoreHandle,
                                       SEMAPHORE_MODIFY_STATE,
                                       ExSemaphoreObjectType,
                                       PreviousMode,
                                       &Semaphore,
                                       NULL);

    //
    // If the reference was successful, then release the semaphore object.
    // If an exception occurs because the maximum count of the semaphore
    // has been exceeded, then dereference the semaphore object and return
    // the exception code as the service status. Otherwise write the previous
    // count value if specified. If the write of the previous count fails,
    // then do not report an error. When the caller attempts to access the
    // previous count value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {

        //
        // Initialize Count to keep W4 compiler happy.
        //

        Count = 0;

        try {
            PERFINFO_DECLARE_OBJECT(Semaphore);

            Count = KeReleaseSemaphore((PKSEMAPHORE)Semaphore,
                                       ExpSemaphoreBoost,
                                       ReleaseCount,
                                       FALSE);

        } except(ExSystemExceptionFilter()) {
            Status = GetExceptionCode();
        }

        ObDereferenceObject(Semaphore);

        if (NT_SUCCESS(Status) && ARGUMENT_PRESENT(PreviousCount)) {
            if (PreviousMode != KernelMode) {
                try {
                    *PreviousCount = Count;
                } except(ExSystemExceptionFilter()) {
                    NOTHING;
                }
            }
            else {
                *PreviousCount = Count;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\tex.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tex.c

Abstract:

    Test program for the EX subcomponent of the NTOS project

Author:

    Steve Wood (stevewo) 31-Mar-1989

Revision History:

--*/

#include "exp.h"
//#include "zwapi.h"
#include <version.h>
#include <string.h>

#define DumpPool(x, y)

BOOLEAN
ExTest (
    VOID
    );

PTESTFCN TestFunction = ExTest;

#ifndef MIPS

USHORT TestEvent = 0;
USHORT TestHandle = 0;
USHORT TestInfo = 0;
USHORT TestLuid = 0;
USHORT TestMemory = 0;
USHORT TestParty = 0;
USHORT TestPool = 0;
USHORT TestResource = 0;
USHORT TestBitMap = 0;
USHORT TestSemaphore = 0;
USHORT TestTimer = 0;
USHORT TestZone = 0;
USHORT TestMutant = 0;
USHORT TestException = 0;

#else

USHORT TestEvent = 1;
USHORT TestHandle = 0;
USHORT TestInfo = 0;
USHORT TestLuid = 0;
USHORT TestMemory = 0;
USHORT TestParty = 0;
USHORT TestPool = 0;
USHORT TestResource = 0;
USHORT TestBitMap = 0;
USHORT TestSemaphore = 2;
USHORT TestTimer = 3;
USHORT TestZone = 0;
USHORT TestMutant = 4;
USHORT TestException = 0;

#endif // MIPS

BOOLEAN
DoEventTest(
    )
{
    ULONG DesiredAccess = EVENT_ALL_ACCESS;
    EVENT_BASIC_INFORMATION EventInformation;
    HANDLE Handle1;
    HANDLE Handle1c;
    HANDLE Handle2;
    HANDLE Handle2c;
    ULONG Length;
    UNICODE_STRING Name1;
    UNICODE_STRING Name2;
    OBJECT_ATTRIBUTES Object1Attributes;
    OBJECT_ATTRIBUTES Object2Attributes;
    LONG State;
    NTSTATUS Status;

    //
    // Announce start of event test.
    //

    DbgPrint(" ** Start of Event Test **\n");

    //
    // Initialize strings and fill in object attributes structures.
    //

    RtlInitUnicodeString(&Name1, L "\\Event1");
    RtlInitUnicodeString(&Name2, L "\\Event2");
    InitializeObjectAttributes(&Object1Attributes, &Name1, 0, NULL, NULL);
    InitializeObjectAttributes(&Object2Attributes, &Name2, 0, NULL, NULL);

    //
    // Create event 1.
    //

    Status = ZwCreateEvent(&Handle1c, DesiredAccess, &Object1Attributes,
                           NotificationEvent, TRUE);
    if (Status < 0) {
        DbgPrint(" Event test - create event 1 failed, status = %lx\n", Status);
    }

    //
    // Open event 1.
    //

    Status = ZwOpenEvent(&Handle1, DesiredAccess, &Object1Attributes);
    if (Status < 0) {
        DbgPrint(" Event test - open event 1 failed, status = %lx\n", Status);
    }

    //
    // Query event 1.
    //

    EventInformation.EventState = 0;
    Length = 0;
    Status = ZwQueryEvent(Handle1, EventBasicInformation,
                          (PVOID)&EventInformation, sizeof(EVENT_BASIC_INFORMATION),
                          &Length);
    if (Status < 0) {
        DbgPrint(" Event test - query event 1 failed, status = %lx\n", Status);
    }
    if (EventInformation.EventType != NotificationEvent) {
        DbgPrint(" Event test - query event 1 wrong event type\n");
    }
    if (EventInformation.EventState == 0) {
        DbgPrint(" Event test - query event 1 current state wrong\n");
    }
    if (Length != sizeof(EVENT_BASIC_INFORMATION)) {
        DbgPrint(" Event test - query event 1 return length wrong\n");
    }

    //
    // Pulse event 1.
    //

    State = 0;
    Status = ZwPulseEvent(Handle1, &State);
    if (Status < 0) {
        DbgPrint(" Event test - pulse event 1 failed, status = %lx\n", Status);
    }
    if (State == 0) {
        DbgPrint(" Event test - pulse event 1 previous state wrong\n");
    }

    //
    // Set event 1.
    //

    State = 1;
    Status = ZwSetEvent(Handle1, &State);
    if (Status < 0) {
        DbgPrint(" Event test - set event 1 failed, status = %lx\n", Status);
    }
    if (State == 1) {
        DbgPrint(" Event test - set event 1 previous state wrong\n");
    }

    //
    // Wait on event 1.
    //

    Status = ZwWaitForSingleObject(Handle1, FALSE, NULL);
    if (Status < 0) {
        DbgPrint(" Event test - wait event 1 failed\n");
    }

    //
    // Reset event 1.
    //

    State = 0;
    Status = ZwResetEvent(Handle1, &State);
    if (Status < 0) {
        DbgPrint(" Event test - reset event 1 failed, status = %lx\n", Status);
    }
    if (State == 0) {
        DbgPrint(" Event test - reset event 1 previous state wrong\n");
    }

    //
    // Create event 2.
    //

    Status = ZwCreateEvent(&Handle2c, DesiredAccess, &Object2Attributes,
                           NotificationEvent, FALSE);
    if (Status < 0) {
        DbgPrint(" Event test - create event 2 failed, status = %lx\n", Status);
    }

    //
    // Open event 2.
    //

    Status = ZwOpenEvent(&Handle2, DesiredAccess, &Object2Attributes);
    if (Status < 0) {
        DbgPrint(" Event test - open event 2 failed, status = %lx\n", Status);
    }

    //
    // Query event 2.
    //

    EventInformation.EventState = 1;
    Length = 0;
    Status = ZwQueryEvent(Handle2, EventBasicInformation,
                          (PVOID)&EventInformation, sizeof(EVENT_BASIC_INFORMATION),
                          &Length);
    if (Status < 0) {
        DbgPrint(" Event test - query event 2 failed, status = %lx\n", Status);
    }
    if (EventInformation.EventType != NotificationEvent) {
        DbgPrint(" Event test - query event 2 wrong event type\n");
    }
    if (EventInformation.EventState == 1) {
        DbgPrint(" Event test - query event 2 current state wrong\n");
    }
    if (Length != sizeof(EVENT_BASIC_INFORMATION)) {
        DbgPrint(" Event test - query event 2 return length wrong\n");
    }

    //
    // Pulse event 2.
    //

    State = 1;
    Status = ZwPulseEvent(Handle2, &State);
    if (Status < 0) {
        DbgPrint(" Event test - pulse event 2 failed, status = %lx\n", Status);
    }
    if (State == 1) {
        DbgPrint(" Event test - pulse event 2 previous state wrong\n");
    }

    //
    // Set event 2.
    //

    State = 1;
    Status = ZwSetEvent(Handle2, &State);
    if (Status < 0) {
        DbgPrint(" Event test - set event 2 failed, status = %lx\n", Status);
    }
    if (State == 1) {
        DbgPrint(" Event test - set event 2 previous state wrong\n");
    }

    //
    // Wait on event 2.
    //

    Status = ZwWaitForSingleObject(Handle2, FALSE, NULL);
    if (Status < 0) {
        DbgPrint(" Event test - wait event 2 failed\n");
    }

    //
    // Reset event 2.
    //

    State = 0;
    Status = ZwResetEvent(Handle2, &State);
    if (Status < 0) {
        DbgPrint(" Event test - reset event 2 failed, status = %lx\n", Status);
    }
    if (State == 0) {
        DbgPrint(" Event test - reset event 2 previous state wrong\n");
    }

    //
    // Close all handles.
    //

    Status = NtClose(Handle1);
    if (Status < 0) {
        DbgPrint(" Event test - event 1 close failed, status = %lx\n", Status);
    }
    Status = NtClose(Handle1c);
    if (Status < 0) {
        DbgPrint(" Event test - event 1c close failed, status = %lx\n", Status);
    }
    Status = NtClose(Handle2);
    if (Status < 0) {
        DbgPrint(" Event test - event 2 close failed, status = %lx\n", Status);
    }
    Status = NtClose(Handle2c);
    if (Status < 0) {
        DbgPrint(" Event test - event 2c close failed, status = %lx\n", Status);
    }

    //
    // Announce end of event test.
    //

    DbgPrint(" ** End of Event Test **\n");
    return TRUE;
}

BOOLEAN
DoExceptionTest(
    )

{
#ifndef  i386
    NTSTATUS Status;

    //
    // Announce start of system service exception test.
    //

    DbgPrint(" ** Start of System Service Exception Test **\n");

    //
    // Eventually this should have a test case for each system service that
    // has input of output arguments which are addressed by pointers. The
    // intent of this test is to make sure that each service correctly
    // handles access violations.
    //

    //
    // Query system time test.
    //

    Status = ZwQuerySystemTime((PLARGE_INTEGER)NULL);
    if (Status != STATUS_ACCESS_VIOLATION) {
        DbgPrint(" Exception test - NtQuerySystemTime failed, status = %lx\n", Status);
    }

    //
    // Set system time test.
    //

    Status = ZwSetSystemTime((PLARGE_INTEGER)NULL, (PLARGE_INTEGER)NULL);
    if (Status != STATUS_ACCESS_VIOLATION) {
        DbgPrint(" Exception test - NtSetSystemTime failed, status = %lx\n", Status);
    }

    //
    // Announce end of system service exception test.
    //

    DbgPrint(" ** End of System Service Exception Test **\n");
#else
    DbgPrint(" ** Skip System Service Exception Test for 386 **\n");
#endif  // i386
    return TRUE;
}

BOOLEAN
DoMutantTest(
    )
{

    LONG Count;
    ULONG DesiredAccess = MUTANT_ALL_ACCESS;
    HANDLE Handle1;
    HANDLE Handle1c;
    HANDLE Handle2;
    HANDLE Handle2c;
    ULONG Length;
    STRING Name1;
    STRING Name2;
    OBJECT_ATTRIBUTES Object1Attributes;
    OBJECT_ATTRIBUTES Object2Attributes;
    MUTANT_BASIC_INFORMATION MutantInformation;
    NTSTATUS Status;

    //
    // Announce start of mutant test.
    //

    DbgPrint(" ** Start of Mutant Test **\n");

    //
    // Initialize strings and fill in object attributes structures.
    //

    RtlInitUnicodeString(&Name1, L"\\Mutant1");
    RtlInitUnicodeString(&Name2, L"\\Mutant2");
    InitializeObjectAttributes(&Object1Attributes,&Name1,0,NULL,NULL);
    InitializeObjectAttributes(&Object2Attributes,&Name2,0,NULL,NULL);

    //
    // Create mutant 1.
    //

    Status = ZwCreateMutant(&Handle1c, DesiredAccess, &Object1Attributes,
                            FALSE);
    if (Status < 0) {
        DbgPrint(" Mutant test - create mutant 1 failed, status = %lx\n",
                Status);
    }

    //
    // Open mutant 1.
    //

    Status = ZwOpenMutant(&Handle1, DesiredAccess, &Object1Attributes);
    if (Status < 0) {
        DbgPrint(" Mutant test - open mutant 1 failed, status = %lx\n",
                Status);
    }

    //
    // Query mutant 1.
    //

    MutantInformation.CurrentCount = 10;
    MutantInformation.AbandonedState = TRUE;
    Length = 0;
    Status = ZwQueryMutant(Handle1, MutantBasicInformation,
                           (PVOID)&MutantInformation,
                           sizeof(MUTANT_BASIC_INFORMATION), &Length);
    if (Status < 0) {
        DbgPrint(" Mutant test - query mutant 1 failed, status = %lx\n",
                Status);
    }
    if (MutantInformation.CurrentCount != 1) {
        DbgPrint(" Mutant test - query mutant 1 current count wrong\n");
    }
    if (MutantInformation.AbandonedState != FALSE) {
        DbgPrint(" Mutant test - query mutant 1 abandoned state wrong\n");
    }
    if (Length != sizeof(MUTANT_BASIC_INFORMATION)) {
        DbgPrint(" Mutant test - query mutant 1 return length wrong\n");
    }

    //
    // Acquire mutant 1.
    //

    Status = ZwWaitForSingleObject(Handle1, FALSE, NULL);
    if (Status < 0) {
        DbgPrint(" Mutant test - wait mutant 1 failed, status = %lx\n",
                Status);
    }

    //
    // Release mutant 1.
    //

    Count = 100;
    Status = ZwReleaseMutant(Handle1, &Count);
    if (Status < 0) {
        DbgPrint(" Mutant test - release mutant 1 failed, status = %lx\n",
                Status);
    }
    if (Count != 0) {
        DbgPrint(" Mutant test - release mutant 1 previous count wrong\n");
    }

    //
    // Create mutant 2.
    //

    Status = ZwCreateMutant(&Handle2c, DesiredAccess, &Object2Attributes,
                            FALSE);
    if (Status < 0) {
        DbgPrint(" Mutant test - create mutant 2 failed, status = %lx\n",
                Status);
    }

    //
    // Open mutant 2.
    //

    Status = ZwOpenMutant(&Handle2, DesiredAccess, &Object2Attributes);
    if (Status < 0) {
        DbgPrint(" Mutant test - open mutant 2 failed, status = %lx\n",
                Status);
    }

    //
    // Acquire mutant 2.
    //

    Status = ZwWaitForSingleObject(Handle2, FALSE, NULL);
    if (Status < 0) {
        DbgPrint(" Mutant test - wait mutant 2 failed, status = %lx\n",
                Status);
    }

    //
    // Query mutant 2.
    //

    MutantInformation.CurrentCount = 20;
    MutantInformation.AbandonedState = TRUE;
    Length = 0;
    Status = ZwQueryMutant(Handle2, MutantBasicInformation,
                          (PVOID)&MutantInformation,
                          sizeof(MUTANT_BASIC_INFORMATION), &Length);
    if (Status < 0) {
        DbgPrint(" Mutant test - query mutant 2 failed, status = %lx\n",
                Status);
    }
    if (MutantInformation.CurrentCount != 0) {
        DbgPrint(" Mutant test - query mutant 2 current count wrong\n");
    }
    if (MutantInformation.AbandonedState != FALSE) {
        DbgPrint(" Mutant test - query mutant 2 abandoned state wrong\n");
    }
    if (Length != sizeof(MUTANT_BASIC_INFORMATION)) {
        DbgPrint(" Mutant test - query mutant 2 return length wrong\n");
    }

    //
    // Acquire mutant 2.
    //

    Status = ZwWaitForSingleObject(Handle2, FALSE, NULL);
    if (Status < 0) {
        DbgPrint(" Mutant test - wait mutant 2 failed, status = %lx\n",
                Status);
    }

    //
    // Release mutant 2.
    //

    Count = 100;
    Status = ZwReleaseMutant(Handle2, &Count);
    if (Status < 0) {
        DbgPrint(" Mutant test - release mutant 2 failed, status = %lx\n",
                Status);
    }
    if (Count != - 1) {
        DbgPrint(" Mutant test - release mutant 2 previous count wrong\n");
    }

    //
    // Release mutant 2.
    //

    Count = 100;
    Status = ZwReleaseMutant(Handle2, &Count);
    if (Status < 0) {
        DbgPrint(" Mutant test - release mutant 2 failed, status = %lx\n",
                Status);
    }
    if (Count != 0) {
        DbgPrint(" Mutant test - release mutant 2 previous count wrong\n");
    }

    //
    // Close all handles.
    //

    Status = NtClose(Handle1);
    if (Status < 0) {
        DbgPrint(" Mutant test - mutant 1 close failed, status = %lx\n",
                Status);
    }
    Status = NtClose(Handle1c);
    if (Status < 0) {
        DbgPrint(" Mutant test - mutant 1c close failed, status = %lx\n",
                Status);
    }
    Status = NtClose(Handle2);
    if (Status < 0) {
        DbgPrint(" Mutant test - mutant 2 close failed, status = %lx\n",
                Status);
    }
    Status = NtClose(Handle2c);
    if (Status < 0) {
        DbgPrint(" Mutant test - mutant 2c close failed, status = %lx\n",
                Status);
    }

    //
    // Announce end of mutant test.
    //

    DbgPrint(" ** End of Mutant Test **\n");
    return TRUE;
}

BOOLEAN
DoSemaphoreTest(
    )
{

    LONG Count;
    ULONG DesiredAccess = SEMAPHORE_ALL_ACCESS;
    HANDLE Handle1;
    HANDLE Handle1c;
    HANDLE Handle2;
    HANDLE Handle2c;
    ULONG Length;
    STRING Name1;
    STRING Name2;
    OBJECT_ATTRIBUTES Object1Attributes;
    OBJECT_ATTRIBUTES Object2Attributes;
    SEMAPHORE_BASIC_INFORMATION SemaphoreInformation;
    NTSTATUS Status;

    //
    // Announce start of semaphore test.
    //

    DbgPrint(" ** Start of Semaphore Test **\n");

    //
    // Initialize strings and fill in object attributes structures.
    //

    RtlInitUnicodeString(&Name1, L"\\Semaphore1");
    RtlInitUnicodeString(&Name2, L"\\Semaphore2");
    InitializeObjectAttributes(&Object1Attributes,&Name1,0,NULL,NULL);
    InitializeObjectAttributes(&Object2Attributes,&Name2,0,NULL,NULL);

    //
    // Create semaphore 1.
    //

    Status = ZwCreateSemaphore(&Handle1c, DesiredAccess, &Object1Attributes,
                               0, 10);
    if (Status < 0) {
        DbgPrint(" Semaphore test - create semaphore 1 failed, status = %lx\n",
                Status);
    }

    //
    // Open semaphore 1.
    //

    Status = ZwOpenSemaphore(&Handle1, DesiredAccess, &Object1Attributes);
    if (Status < 0) {
        DbgPrint(" Semaphore test - open semaphore 1 failed, status = %lx\n",
                Status);
    }

    //
    // Query semaphore 1.
    //

    SemaphoreInformation.CurrentCount = 10;
    SemaphoreInformation.MaximumCount = 0;
    Length = 0;
    Status = ZwQuerySemaphore(Handle1, SemaphoreBasicInformation,
                          (PVOID)&SemaphoreInformation,
                          sizeof(SEMAPHORE_BASIC_INFORMATION), &Length);
    if (Status < 0) {
        DbgPrint(" Semaphore test - query semaphore 1 failed, status = %lx\n",
                Status);
    }
    if (SemaphoreInformation.CurrentCount != 0) {
        DbgPrint(" Semaphore test - query semaphore 1 current count wrong\n");
    }
    if (SemaphoreInformation.MaximumCount != 10) {
        DbgPrint(" Semaphore test - query semaphore 1 maximum count wrong\n");
    }
    if (Length != sizeof(SEMAPHORE_BASIC_INFORMATION)) {
        DbgPrint(" Semaphore test - query semaphore 1 return length wrong\n");
    }

    //
    // Release semaphore 1.
    //

    Count = 100;
    Status = ZwReleaseSemaphore(Handle1, 2, &Count);
    if (Status < 0) {
        DbgPrint(" Semaphore test - release semaphore 1 failed, status = %lx\n",
                Status);
    }
    if (Count != 0) {
        DbgPrint(" Semaphore test - release semaphore 1 previous count wrong\n");
    }

    //
    // Release semaphore 1.
    //

    Count = 100;
    Status = ZwReleaseSemaphore(Handle1, 5, &Count);
    if (Status < 0) {
        DbgPrint(" Semaphore test - release semaphore 1 failed, status = %lx\n",
                Status);
    }
    if (Count != 2) {
        DbgPrint(" Semaphore test - release semaphore 1 previous count wrong\n");
    }

    //
    // Create semaphore 2.
    //

    Status = ZwCreateSemaphore(&Handle2c, DesiredAccess, &Object2Attributes,
                               5, 20);
    if (Status < 0) {
        DbgPrint(" Semaphore test - create semaphore 2 failed, status = %lx\n",
                Status);
    }

    //
    // Open semaphore 2.
    //

    Status = ZwOpenSemaphore(&Handle2, DesiredAccess, &Object2Attributes);
    if (Status < 0) {
        DbgPrint(" Semaphore test - open semaphore 2 failed, status = %lx\n",
                Status);
    }

    //
    // Query semaphore 2.
    //

    SemaphoreInformation.CurrentCount = 20;
    SemaphoreInformation.MaximumCount = 5;
    Length = 0;
    Status = ZwQuerySemaphore(Handle2, SemaphoreBasicInformation,
                          (PVOID)&SemaphoreInformation,
                          sizeof(SEMAPHORE_BASIC_INFORMATION), &Length);
    if (Status < 0) {
        DbgPrint(" Semaphore test - query semaphore 2 failed, status = %lx\n",
                Status);
    }
    if (SemaphoreInformation.CurrentCount != 5) {
        DbgPrint(" Semaphore test - query semaphore 2 current count wrong\n");
    }
    if (SemaphoreInformation.MaximumCount != 20) {
        DbgPrint(" Semaphore test - query semaphore 2 maximum count wrong\n");
    }
    if (Length != sizeof(SEMAPHORE_BASIC_INFORMATION)) {
        DbgPrint(" Semaphore test - query semaphore 2 return length wrong\n");
    }

    //
    // Release semaphore 2.
    //

    Count = 100;
    Status = ZwReleaseSemaphore(Handle2, 3, &Count);
    if (Status < 0) {
        DbgPrint(" Semaphore test - release semaphore 2 failed, status = %lx\n",
                Status);
    }
    if (Count != 5) {
        DbgPrint(" Semaphore test - release semaphore 2 previous count wrong\n");
    }

    //
    // Release semaphore 2.
    //

    Count = 100;
    Status = ZwReleaseSemaphore(Handle2, 5, &Count);
    if (Status < 0) {
        DbgPrint(" Semaphore test - release semaphore 2 failed, status = %lx\n",
                Status);
    }
    if (Count != 8) {
        DbgPrint(" Semaphore test - release semaphore 2 previous count wrong\n");
    }

    //
    // Close all handles.
    //

    Status = NtClose(Handle1);
    if (Status < 0) {
        DbgPrint(" Semaphore test - semaphore 1 close failed, status = %lx\n",
                Status);
    }
    Status = NtClose(Handle1c);
    if (Status < 0) {
        DbgPrint(" Semaphore test - semaphore 1c close failed, status = %lx\n",
                Status);
    }
    Status = NtClose(Handle2);
    if (Status < 0) {
        DbgPrint(" Semaphore test - semaphore 2 close failed, status = %lx\n",
                Status);
    }
    Status = NtClose(Handle2c);
    if (Status < 0) {
        DbgPrint(" Semaphore test - semaphore 2c close failed, status = %lx\n",
                Status);
    }

    //
    // Announce end of semaphore test.
    //

    DbgPrint(" ** End of Semaphore Test **\n");
    return TRUE;
}

VOID
TimerApcRoutine (
    IN PVOID TimerContext,
    IN ULONG TimerLowValue,
    IN LONG TimerHighValue
    )

{

    *((PBOOLEAN)TimerContext) = TRUE;
    return;
}

BOOLEAN
DoTimerTest (
    )

{

    BOOLEAN ApcHappened;
    BOOLEAN CurrentState;
    ULONG DesiredAccess = TIMER_ALL_ACCESS;
    LARGE_INTEGER DueTime;
    HANDLE Handle1;
    HANDLE Handle1c;
    HANDLE Handle2;
    HANDLE Handle2c;
    ULONG Length;
    STRING Name1;
    STRING Name2;
    OBJECT_ATTRIBUTES Object1Attributes;
    OBJECT_ATTRIBUTES Object2Attributes;
    BOOLEAN PreviousState;
    TIMER_BASIC_INFORMATION TimerInformation;
    NTSTATUS Status;

    //
    // Announce start of timer test.
    //

    DbgPrint(" ** Start of Timer Test **\n");

    //
    // Initialize strings and fill in object attributes structures.
    //

    RtlInitUnicodeString(&Name1, L"\\Timer1");
    RtlInitUnicodeString(&Name2, L"\\Timer2");
    InitializeObjectAttributes(&Object1Attributes,&Name1,0,NULL,NULL);
    InitializeObjectAttributes(&Object2Attributes,&Name2,0,NULL,NULL);

    //
    // Create timer 1.
    //

    Status = ZwCreateTimer(&Handle1c, DesiredAccess, &Object1Attributes);
    if (!NT_SUCCESS(Status)) {
        DbgPrint(" Timer test - create timer 1 failed, status = %lx\n",
                Status);
    }

    //
    // Open timer 1.
    //

    Status = ZwOpenTimer(&Handle1, DesiredAccess, &Object1Attributes);
    if (Status < 0) {
        DbgPrint(" Timer test - open timer 1 failed, status = %lx\n",
                Status);
    }

    //
    // Query timer 1.
    //

    TimerInformation.TimerState = TRUE;
    Length = 0;
    Status = ZwQueryTimer(Handle1, TimerBasicInformation,
                          (PVOID)&TimerInformation,
                          sizeof(TIMER_BASIC_INFORMATION), &Length);
    if (Status < 0) {
        DbgPrint(" Timer test - query timer 1 failed, status = %lx\n",
                Status);
    }
    if (TimerInformation.TimerState) {
        DbgPrint(" Timer test - query timer 1 state wrong\n");
    }
    if (Length != sizeof(TIMER_BASIC_INFORMATION)) {
        DbgPrint(" Timer test - query timer 1 return length wrong\n");
    }

    //
    // Set timer 1 and then cancel timer 1.
    //

    DueTime.LowPart = -100000;
    DueTime.HighPart = -1;
    PreviousState = TRUE;
    Status = ZwSetTimer(Handle1, &DueTime, NULL, NULL, &PreviousState);
    if (!NT_SUCCESS(Status)) {
        DbgPrint(" Timer test - set timer 1 failed, status = %lx\n",
                Status);
    }
    if (PreviousState) {
        DbgPrint(" Timer test - set timer 1 previous state wrong\n");
    }
    CurrentState = TRUE;
    Status = ZwCancelTimer(Handle1, &CurrentState);
    if (!NT_SUCCESS(Status)) {
        DbgPrint(" Timer test - cancel timer 1 failed, status = %lx\n",
                Status);
    }
    if (CurrentState) {
        DbgPrint(" Timer test - cancel timer 1 current state wrong\n");
    }

    //
    // Set timer 1, wait for timer to expire, and then cancel timer 1.
    //

    DueTime.LowPart = -5;
    DueTime.HighPart = -1;
    PreviousState = TRUE;
    Status = ZwSetTimer(Handle1, &DueTime, NULL, NULL, &PreviousState);
    if (!NT_SUCCESS(Status)) {
        DbgPrint(" Timer test - set timer 1 failed, status = %lx\n",
                Status);
    }
    if (PreviousState) {
        DbgPrint(" Timer test - set timer 1 previous state wrong\n");
    }
    Status = ZwWaitForSingleObject(Handle1, FALSE, NULL);
    if (!NT_SUCCESS(Status)) {
        DbgPrint(" Timer test - wait timer 1 failed, status = %lx\n",
                Status);
    }
    CurrentState = FALSE;
    Status = ZwCancelTimer(Handle1, &CurrentState);
    if (!NT_SUCCESS(Status)) {
        DbgPrint(" Timer test - cancel timer 1 failed, status = %lx\n",
                Status);
    }
    if (!CurrentState) {
        DbgPrint(" Timer test - cancel timer 1 current state wrong\n");
    }

    //
    // Set timer 1 with APC, then cancel timer 1.
    //

    ApcHappened = FALSE;
    DueTime.LowPart = -100000;
    DueTime.HighPart = -1;
    PreviousState = FALSE;
    Status = ZwSetTimer(Handle1, &DueTime, TimerApcRoutine, &ApcHappened,
                        &PreviousState);
    if (!NT_SUCCESS(Status)) {
        DbgPrint(" Timer test - set timer 1 failed, status = %lx\n",
                Status);
    }
    if (!PreviousState) {
        DbgPrint(" Timer test - set timer 1 previous state wrong\n");
    }
    CurrentState = TRUE;
    Status = ZwCancelTimer(Handle1, &CurrentState);
    if (!NT_SUCCESS(Status)) {
        DbgPrint(" Timer test - cancel timer 1 failed, status = %lx\n",
                Status);
    }
    if (CurrentState) {
        DbgPrint(" Timer test - cancel timer 1 current state wrong\n");
    }
    if (ApcHappened) {
        DbgPrint(" Timer test - cancel timer 1 APC happened state wrong\n");
    }

    //
    // Set timer 1 with APC, set timer again with APC, wait for timer, then
    // cancel timer 1.
    //

    ApcHappened = FALSE;
    DueTime.LowPart = -100000;
    DueTime.HighPart = -1;
    PreviousState = TRUE;
    Status = ZwSetTimer(Handle1, &DueTime, TimerApcRoutine, &ApcHappened,
                        &PreviousState);
    if (!NT_SUCCESS(Status)) {
        DbgPrint(" Timer test - set timer 1 failed, status = %lx\n",
                Status);
    }
    if (PreviousState) {
        DbgPrint(" Timer test - set timer 1 previous state wrong\n");
    }
    DueTime.LowPart = -5;
    DueTime.HighPart = -1;
    PreviousState = TRUE;
    Status = ZwSetTimer(Handle1, &DueTime, TimerApcRoutine, &ApcHappened,
                        &PreviousState);
    if (!NT_SUCCESS(Status)) {
        DbgPrint(" Timer test - set timer 1 failed, status = %lx\n",
                Status);
    }
    if (PreviousState) {
        DbgPrint(" Timer test - set timer 1 previous state wrong\n");
    }
    Status = ZwWaitForSingleObject(Handle1, FALSE, NULL);
    if (!NT_SUCCESS(Status)) {
        DbgPrint(" Timer test - wait timer 1 failed, status = %lx\n",
                Status);
    }
    CurrentState = FALSE;
    Status = ZwCancelTimer(Handle1, &CurrentState);
    if (!NT_SUCCESS(Status)) {
        DbgPrint(" Timer test - cancel timer 1 failed, status = %lx\n",
                Status);
    }
    if (!CurrentState) {
        DbgPrint(" Timer test - cancel timer 1 current state wrong\n");
    }
    if (!ApcHappened) {
        DbgPrint(" Timer test - cancel timer 1 APC happened state wrong\n");
    }

    //
    // Create timer 2.
    //

    Status = ZwCreateTimer(&Handle2c, DesiredAccess, &Object2Attributes);
    if (Status < 0) {
        DbgPrint(" Timer test - create timer 2 failed, status = %lx\n",
                Status);
    }

    //
    // Open timer 2.
    //

    Status = ZwOpenTimer(&Handle2, DesiredAccess, &Object2Attributes);
    if (Status < 0) {
        DbgPrint(" Timer test - open timer 2 failed, status = %lx\n",
                Status);
    }

    //
    // Query timer 2.
    //

    TimerInformation.TimerState = TRUE;
    Length = 0;
    Status = ZwQueryTimer(Handle2, TimerBasicInformation,
                          (PVOID)&TimerInformation,
                          sizeof(TIMER_BASIC_INFORMATION), &Length);
    if (Status < 0) {
        DbgPrint(" Timer test - query timer 2 failed, status = %lx\n",
                Status);
    }
    if (TimerInformation.TimerState) {
        DbgPrint(" Timer test - query timer 2 state wrong\n");
    }
    if (Length != sizeof(TIMER_BASIC_INFORMATION)) {
        DbgPrint(" Timer test - query timer 2 return length wrong\n");
    }

    //
    // Close all handles.
    //

    Status = NtClose(Handle1);
    if (Status < 0) {
        DbgPrint(" Timer test - timer 1 close failed, status = %lx\n",
                Status);
    }
    Status = NtClose(Handle1c);
    if (Status < 0) {
        DbgPrint(" Timer test - timer 1c close failed, status = %lx\n",
                Status);
    }
    Status = NtClose(Handle2);
    if (Status < 0) {
        DbgPrint(" Timer test - timer 2 close failed, status = %lx\n",
                Status);
    }
    Status = NtClose(Handle2c);
    if (Status < 0) {
        DbgPrint(" Timer test - timer 2c close failed, status = %lx\n",
                Status);
    }

    //
    // Announce end of timer test.
    //

    DbgPrint(" ** End of Timer Test **\n");
    return TRUE;
}

BOOLEAN
TestDupHandle1(
    IN PVOID HandleTableEntry
    )
{
    DbgPrint( "Dupping %lx\n", HandleTableEntry );
    return( TRUE );
}

BOOLEAN
TestDupHandle4(
    IN PVOID HandleTableEntry
    )
{
    PULONG p = (PULONG)HandleTableEntry;
    ULONG i;

    if (!((*p>>4) % 4)) {
        return( FALSE );
        }

    DbgPrint( "Dupping " );
    for (i=0; i<4; i++) {
        DbgPrint( "  %lx", *p++ );
        }
    DbgPrint( "\n" );
    return( TRUE );
}

BOOLEAN
TestEnumHandle1(
    IN PVOID HandleTableEntry,
    IN PVOID EnumParameter
    )
{
    if (EnumParameter == HandleTableEntry) {
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}

BOOLEAN
TestEnumHandle4(
    IN PVOID HandleTableEntry,
    IN PVOID EnumParameter
    )
{
    if (EnumParameter == (PVOID)*(PULONG)HandleTableEntry) {
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}

#define HANDLE_TEST_SIZE    30

BOOLEAN
DoHandleTest( void )
{
    PVOID HandleTable1;
    PVOID HandleTable4;
    PVOID HandleTable1a;
    PVOID HandleTable4a;
    HANDLE HandlesForTable1[ HANDLE_TEST_SIZE ];
    HANDLE HandlesForTable4[ HANDLE_TEST_SIZE ];
    HANDLE h;
    PULONG HandleValue;
    BOOLEAN LockFlag;
    ULONG i, v[4];

    HandleTable1 = ExCreateHandleTable( (PEPROCESS)NULL, 0L, 0L, 0L, MUTEX_LEVEL_PS_CID_TABLE, FALSE );
    HandleTable4 = ExCreateHandleTable( (PEPROCESS)NULL, 16L, 8L, 2L, MUTEX_LEVEL_OB_TABLE, TRUE );

    ExDumpHandleTable( (PEPROCESS)NULL, HandleTable1, NULL );
    ExDumpHandleTable( (PEPROCESS)NULL, HandleTable4, NULL );

    for (i=0; i<HANDLE_TEST_SIZE; i++) {
        v[0] = (i+1) << 4;
        v[1] = (i+1) << 3;
        v[2] = (i+1) << 2;
        v[3] = (i+1) << 1;

        HandlesForTable1[ i ] = ExCreateHandle( HandleTable1, (PVOID)(v[0]) );
        DbgPrint( "HandleTable1: %lx => %lx\n", HandlesForTable1[ i ], v[0] );
        HandlesForTable4[ i ] = ExCreateHandle( HandleTable4, (PVOID)(&v[0]) );
        DbgPrint( "HandleTable4: %lx => %lx\n", HandlesForTable4[ i ], v[0] );
        }

    ExDumpHandleTable( HandleTable1, NULL, NULL );
    ExDumpHandleTable( HandleTable4, NULL, NULL );

    for (i=0; i<=HANDLE_TEST_SIZE; i++) {
        v[0] = (i+1) << 4;
        v[1] = (i+1) << 3;
        v[2] = (i+1) << 2;
        v[3] = (i+1) << 1;

        if (ExEnumHandleTable( HandleTable1, TestEnumHandle1, (PVOID)(v[0]), &h )) {
            DbgPrint( "HandleTable1: Found: %lx <= %lx\n", v[0], h );
            }
        else {
            DbgPrint( "HandleTable1: %lx not found\n", v[0] );
            }

        if (ExEnumHandleTable( HandleTable4, TestEnumHandle4, (PVOID)(v[0]), &h )) {
            DbgPrint( "HandleTable4: Found: %lx <= %lx\n", v[0], h );
            }
        else {
            DbgPrint( "HandleTable4: %lx not found\n", v[0] );
            }
        }

    for (i=0; i<HANDLE_TEST_SIZE; i++) {
        LockFlag = ExMapHandleToPointer( HandleTable1,
                                         HandlesForTable1[ i ],
                                         (PVOID)&HandleValue
                                       );

        DbgPrint( "HandleTable1: %lx => %lx\n",
                 HandlesForTable1[ i ], HandleValue
               );
        ExUnlockHandleTable( HandleTable1, LockFlag );

        LockFlag = ExMapHandleToPointer( HandleTable4,
                                         HandlesForTable4[ i ],
                                         (PVOID)&HandleValue
                                       );
        DbgPrint( "HandleTable4: %lx => %lx\n",
                 HandlesForTable4[ i ], *HandleValue
               );
        ExUnlockHandleTable( HandleTable4, LockFlag );
        }

    HandleTable1a = ExDupHandleTable( (PEPROCESS)NULL, HandleTable1, TestDupHandle1 );
    HandleTable4a = ExDupHandleTable( (PEPROCESS)NULL, HandleTable4, TestDupHandle4 );

    ExDumpHandleTable( HandleTable1a, NULL, NULL );
    ExDumpHandleTable( HandleTable4a, NULL, NULL );

    for (i=0; i<HANDLE_TEST_SIZE; i++) {
        ExDestroyHandle( HandleTable1, HandlesForTable1[ i ] );
        ExDestroyHandle( HandleTable4, HandlesForTable4[ i ] );
        }

    ExDumpHandleTable( HandleTable1, NULL, NULL );
    ExDumpHandleTable( HandleTable4, NULL, NULL );

    ExDestroyHandleTable( HandleTable1, NULL );
    ExDestroyHandleTable( HandleTable4, NULL );

    ExDestroyHandleTable( HandleTable1a, NULL );
    ExDestroyHandleTable( HandleTable4a, NULL );

    return( TRUE );
}

BOOLEAN
DoInfoTest( void )
{
    BOOLEAN Result = FALSE;
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_PROCESSOR_INFORMATION ProcessorInfo;
    ULONG ReturnedLength;

    DbgPrint(" ** Start of System Information Test **\n");
    Status = ZwQuerySystemInformation( SystemBasicInformation,
                                       (PVOID)&BasicInfo,
                                       sizeof( BasicInfo ),
                                       &ReturnedLength
                                     );
    if (NT_SUCCESS( Status )) {
        DbgPrint( "NtQuerySystemInformation returns:\n" );
        DbgPrint( "    Number of Processors: %ld\n",
                 BasicInfo.NumberOfProcessors
               );
        DbgPrint( "    OEM Machine Id: %lx\n",
                 BasicInfo.OemMachineId
               );
        DbgPrint( "    Timer Resolution: %ld microseconds\n",
                 BasicInfo.TimerResolutionInMicroSeconds
               );
        DbgPrint( "    Page Size: %ld   Allocation Granularity: %ld\n",
                 BasicInfo.PageSize,
                 BasicInfo.AllocationGranularity
               );
        DbgPrint( "    User Mode Address Range: 0x%08lx <-> 0x%08lx\n",
                 BasicInfo.MinimumUserModeAddress,
                 BasicInfo.MaximumUserModeAddress
               );
        }
    else {
        DbgPrint( "NtQuerySystemInformation failed.  Status == %X\n",
                 Status
               );
        }

    DbgPrint(" ** End of System Information Test **\n");
    return( Result );
}

BOOLEAN
DoLuidTest( void )
{
    BOOLEAN Result = TRUE;
    NTSTATUS Status;

    LUID FirstLuid;
    LUID SecondLuid;

    FirstLuid.LowPart = 0;
    FirstLuid.HighPart = 0;

    SecondLuid.LowPart = 0;
    SecondLuid.HighPart = 0;

    DbgPrint(" ** Start of Locally Unique ID Test **\n");



    Status = ZwAllocateLocallyUniqueId( &FirstLuid );

    if (!NT_SUCCESS( Status )) {
        DbgPrint( "First Luid Allocation Error.\n" );
        Result = FALSE;
    }

    if (LiLeqZero( FirstLuid )) {
        DbgPrint( "First Luid Allocation Failed - Bad Value.\n" );
        Result = FALSE;
    }



    if (Result) {

        Status = ZwAllocateLocallyUniqueId( &SecondLuid );

        if (!NT_SUCCESS( Status )) {
            DbgPrint( "Second Luid Allocation Error.\n" );
            Result = FALSE;
        }

        if (LiLeqZero( SecondLuid )) {
            DbgPrint( "Second Luid Allocation Failed - Bad Value.\n" );
            Result = FALSE;
        }

        if (LiLeq( FirstLuid, SecondLuid )) {
            DbgPrint( "Second Luid Allocation Failed - Not larger than first value.\n" );
            Result = FALSE;
        }

    }


    DbgPrint(" ** End of Locally Unique ID Test **\n");
    return( Result );
}

char MemoryTestBuffer1[ 128 ];
char TestString1[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
char TestString2[] = "123456789012345678901234567890123456789012345678901234567890";
char MemoryTestBuffer2[ 128 ];

BOOLEAN
DoMemoryTest( void )
{
    LONG i,j,k;
    BOOLEAN Result;

    DbgPrint(" ** Start of Memory Test **\n");

    Result = TRUE;
    strcpy( MemoryTestBuffer1, TestString1 );
    for (i=15; i>=0; i--) {
        MemoryTestBuffer1[16] = 0xFF;
        RtlZeroMemory( &MemoryTestBuffer1[i], 16-i );
        if (strncmp( MemoryTestBuffer1, TestString1, i ) || MemoryTestBuffer1[i] || !MemoryTestBuffer1[16]) {
            DbgPrint( "*** failed *** - RtlZeroMemory( %s, %ld )\n",
                     MemoryTestBuffer1, 16-i );
            Result = FALSE;
            }
        }

    for (k = 0; k < 8; k++) {
        DbgPrint("k = %d, j = ",k);
        for (j = 0; j < 8; j++) {
            DbgPrint(" %d ",j);
            for (i=0; i<26; i++) {
                RtlZeroMemory( MemoryTestBuffer1, (ULONG)sizeof( MemoryTestBuffer1 ) );
                RtlMoveMemory( &MemoryTestBuffer1[j], &TestString2[k], i );
                if (strncmp( &MemoryTestBuffer1[j], &TestString2[k], i ) || MemoryTestBuffer1[j+i]) {
                    DbgPrint( "*** failed *** - RtlMoveMemory( %s, %s, %ld )\n",
                             &MemoryTestBuffer1[j], TestString2, i );
                    Result = FALSE;
                    }
                }
            }
        DbgPrint("\n");
        }

    for (k = 0; k < 8; k++) {
        DbgPrint("k = %d, j = ",k);
        for (j = 0; j < 8; j++) {
            DbgPrint(" %d ",j);
            for (i=0; i<26; i++) {
                RtlZeroMemory( MemoryTestBuffer2, (ULONG)sizeof( MemoryTestBuffer2 ) );
                RtlMoveMemory( &MemoryTestBuffer2[j], &TestString2[k], i );
                if (strncmp( &MemoryTestBuffer2[j], &TestString2[k], i ) || MemoryTestBuffer2[j+i]) {
                    DbgPrint( "*** failed *** - RtlMoveMemory( %s, %s, %ld )\n",
                             &MemoryTestBuffer2[j], TestString2, i );
                    Result = FALSE;
                    }
                }
            }
        DbgPrint("\n");
        }

    for (k = 0; k < 8; k++) {
        DbgPrint("k = %d, j = ",k);
        for (j = 0; j < 8; j++) {
            DbgPrint(" %d ",j);
            for (i=0; i<26; i++) {
                strcpy( MemoryTestBuffer1, TestString1 );
                RtlMoveMemory( &MemoryTestBuffer1[j], &MemoryTestBuffer1[k], i );
                if (strncmp( &MemoryTestBuffer1[j], &TestString1[k], i )) {
                    DbgPrint( "*** failed *** - RtlMoveMemory( %s, %s, %ld )\n",
                             &MemoryTestBuffer2[j], TestString2, i );
                    Result = FALSE;
                    }
                }
            }
        DbgPrint("\n");
        }

    DbgPrint(" ** End of Memory Test **\n");

    return( Result );
}

BOOLEAN
DoPartyTest( void )
{
    BOOLEAN Result = TRUE;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Handle;

    DbgPrint(" ** Start of Party By Number Test **\n");

    NtPartyByNumber( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 );
    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );
    Status = ZwCreateEvent( &Handle,
                            EVENT_ALL_ACCESS,
                            &ObjectAttributes, NotificationEvent ,TRUE);
    NtPartyByNumber( PARTY_DUMP_OBJECT_BY_HANDLE, Handle, NULL );
    ZwClose( Handle );
    NtPartyByNumber( PARTY_DUMP_OBJECT_BY_HANDLE, Handle, NULL );

    DbgPrint(" ** End of Party By Number Test **\n");
    return( Result );
}

BOOLEAN
DoPoolTest( void )
{
    PVOID p,p0,p1,p2,p3;

    p = ExAllocatePool(NonPagedPool,4000L);
    DumpPool("After 4000 byte Allocation",NonPagedPool);
    p = ExAllocatePool(NonPagedPool,2000L);
    DumpPool("After 2000 byte Allocation",NonPagedPool);
    p = ExAllocatePool(NonPagedPool,2000L);
    DumpPool("After 2000 byte Allocation",NonPagedPool);

    p0 = ExAllocatePool(NonPagedPool,24L);
    DumpPool("After 24 byte Allocation p0",NonPagedPool);
    p1 = ExAllocatePool(NonPagedPool,24L);
    DumpPool("After 24 byte Allocation p1",NonPagedPool);
    p2 = ExAllocatePool(NonPagedPool,24L);
    DumpPool("After 24 byte Allocation p2",NonPagedPool);
    p3 = ExAllocatePool(NonPagedPool,24L);
    DumpPool("After 24 byte Allocation p3",NonPagedPool);

    ExFreePool(p1);
    DumpPool("After 24 byte Deallocation p1",NonPagedPool);
    ExFreePool(p3);
    DumpPool("After 24 byte Deallocation p3",NonPagedPool);
    ExFreePool(p2);
    DumpPool("After 24 byte Deallocation p2",NonPagedPool);
    ExFreePool(p0);
    DumpPool("After 24 byte Deallocation p0",NonPagedPool);

    p0 = ExAllocatePool(NonPagedPool,120L);
    DumpPool("After 120 byte Allocation p0",NonPagedPool);
    p1 = ExAllocatePool(NonPagedPool,24L);
    DumpPool("After 24 byte Allocation p1",NonPagedPool);
    ExFreePool(p1);
    DumpPool("After 24 byte Deallocation p1",NonPagedPool);
    ExFreePool(p0);
    DumpPool("After 120 byte Deallocation p0",NonPagedPool);

    return( TRUE );
}

BOOLEAN
DoZoneTest( void )
{
    PULONG p1,p2;
    PZONE_HEADER z;
    NTSTATUS st;
    PVOID b1, b2, b3, b4, b5;

    z = ExAllocatePool(NonPagedPool,(ULONG)sizeof(ZONE_HEADER));
    p1 = ExAllocatePool(NonPagedPool,2048L);
    p2 = ExAllocatePool(NonPagedPool,1024L);
    st = ExInitializeZone(z,512L,p1,2048L);
    ExDumpZone(z);

    b1 = ExAllocateFromZone(z);
    DbgPrint("b1 = 0x%lx\n",b1);
    ExDumpZone(z);

    b2 = ExAllocateFromZone(z);
    DbgPrint("b2 = 0x%lx\n",b2);
    ExDumpZone(z);

    b3 = ExAllocateFromZone(z);
    DbgPrint("b3 = 0x%lx\n",b3);
    ExDumpZone(z);

    b4 = ExAllocateFromZone(z);
    DbgPrint("b4 = 0x%lx\n",b4);
    ExDumpZone(z);

    b5 = ExAllocateFromZone(z);
    DbgPrint("b5 = 0x%lx\n",b5);
    ExDumpZone(z);

    ExFreeToZone(z,b4);
    ExDumpZone(z);

    ExFreeToZone(z,b3);
    ExDumpZone(z);

    ExFreeToZone(z,b2);
    ExDumpZone(z);

    ExFreeToZone(z,b1);
    ExDumpZone(z);

    st = ExExtendZone(z,p2,1024L);
    ExDumpZone(z);

    return( TRUE );
}

ERESOURCE Resource;
ULONG ResourceCount;
KSEMAPHORE ResourceSemaphore;
PVOID ExDumpResource( IN PERESOURCE Resource );

VOID
Reader (
    IN PVOID StartContext
    )
{
    LARGE_INTEGER Time;

    //KeSetPriorityThread( &PsGetCurrentThread()->Tcb, 2 );

    DbgPrint("Starting Reader %lx...\n", StartContext);

    Time.LowPart = -(1+(ULONG)StartContext);
    Time.HighPart = -1;

    while (TRUE) {

        (VOID)ExAcquireResourceShared(&Resource,TRUE);

        DbgPrint("%lx with shared access\n", StartContext);

        if (ResourceCount >= 10) {
            ExReleaseResourceLite(&Resource);
            break;
        }

        KeDelayExecutionThread ( KernelMode, FALSE, &Time);

        ExReleaseResourceLite(&Resource);

        DbgPrint("%lx released shared access\n", StartContext);

        KeDelayExecutionThread ( KernelMode, FALSE, &Time);
    }

    DbgPrint("Reader %lx exiting\n", StartContext);

    KeReleaseSemaphore(&ResourceSemaphore, 0, 1, FALSE);
}

VOID
Writer (
    IN PVOID StartContext
    )
{
    LARGE_INTEGER Time;

    //KeSetPriorityThread( &PsGetCurrentThread()->Tcb, 3 );

    DbgPrint("Starting Writer %lx...\n", StartContext);

    Time.LowPart = -(1+(ULONG)StartContext);
    Time.HighPart = -1;

    while (TRUE) {

        (VOID)ExAcquireResourceExclusive(&Resource,TRUE);

        DbgPrint("%lx with Exclusive access\n", StartContext);

        ResourceCount += 1;
        if (ResourceCount >= 10) {
            ExReleaseResourceLite(&Resource);
            break;
        }

        KeDelayExecutionThread ( KernelMode, FALSE, &Time);

        ExReleaseResourceLite(&Resource);

        DbgPrint("%lx released Exclusive access\n", StartContext);

        KeDelayExecutionThread ( KernelMode, FALSE, &Time);
    }

    DbgPrint("Writer %lx exiting\n", StartContext);

    KeReleaseSemaphore(&ResourceSemaphore, 0, 1, FALSE);
}

VOID
ReaderTurnedWriter (
    IN PVOID StartContext
    )
{
    LARGE_INTEGER Time;

    //KeSetPriorityThread( &PsGetCurrentThread()->Tcb, 4 );

    DbgPrint("Starting Reader turned Writer %lx\n", StartContext);

    Time.LowPart = -(1+(ULONG)StartContext);
    Time.HighPart = -1;

    while (TRUE) {

        (VOID)ExAcquireResourceShared(&Resource,TRUE);

        DbgPrint("%lx with shared access\n", StartContext);

        if (ResourceCount >= 10) {
            ExReleaseResourceLite(&Resource);
            break;
        }

        KeDelayExecutionThread ( KernelMode, FALSE, &Time);

        ExConvertSharedToExclusive(&Resource);

        DbgPrint("%lx Shared turned Exclusive access\n", StartContext);

        ResourceCount += 1;
        if (ResourceCount >= 10) {
            ExReleaseResourceLite(&Resource);
            break;
        }

        KeDelayExecutionThread ( KernelMode, FALSE, &Time);

        ExConvertExclusiveToShared(&Resource);

        DbgPrint("%lx Exclusive turned Shared access\n", StartContext);

        if (ResourceCount >= 10) {
            ExReleaseResourceLite(&Resource);
            break;
        }

        ExReleaseResourceLite(&Resource);

        DbgPrint("%lx release Shared access\n", StartContext);

        KeDelayExecutionThread ( KernelMode, FALSE, &Time);
    }

    DbgPrint("Reader turned Writer %lx exiting\n", StartContext);

    KeReleaseSemaphore(&ResourceSemaphore, 0, 1, FALSE);
}

BOOLEAN
DoResourceTest( void )
{
    HANDLE Handles[32];
    ULONG i;

    DbgPrint("Start DoResourceTest...\n");

    ExInitializeResource(&Resource);
    ResourceCount = 0;

    KeInitializeSemaphore(&ResourceSemaphore, 0, MAXLONG);

    for (i = 0; i < 4; i += 1) {

        if (!NT_SUCCESS(PsCreateSystemThread(&Handles[i],
                                          0,
                                          NULL,
                                          0,
                                          NULL,
                                          Reader,
                                          (PVOID)i))) {

            DbgPrint("Create system thread error %8lx\n", i);
        }

    }

    for (i = 4; i < 6; i += 1) {

        if (!NT_SUCCESS(PsCreateSystemThread(&Handles[i],
                                          0,
                                          NULL,
                                          0,
                                          NULL,
                                          Writer,
                                          (PVOID)i))) {

            DbgPrint("Create system thread error %8lx\n", i);
        }

    }

    for (i = 6; i < 8; i += 1) {

        if (!NT_SUCCESS(PsCreateSystemThread(&Handles[i],
                                          0,
                                          NULL,
                                          0,
                                          NULL,
                                          ReaderTurnedWriter,
                                          (PVOID)i))) {

            DbgPrint("Create system thread error %8lx\n", i);
        }

    }

    DbgPrint("DoResourceTest wait for everyone to complete...\n");

    for (i = 0; i < 8; i += 1) {

        KeWaitForSingleObject( &ResourceSemaphore,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

    }

    DbgPrint("DoResourceTest Done\n");

    return( TRUE );
}

BOOLEAN
DoBitMapTest( void )
{
    ULONG Size;
    PRTL_BITMAP BitMap;

    DbgPrint("Start DoBitMapTest...\n");

    //
    //  First create a new bitmap
    //

    Size = sizeof(RTL_BITMAP) + (((2048*8 + 31) / 32) * 4);
    BitMap = (PRTL_BITMAP)(ExAllocatePool( NonPagedPool, Size ));
    RtlInitializeBitMap( BitMap, (PULONG)(BitMap+1), 2048*8 );

    //
    //  >>>> Test setting bits
    //

    //
    //  Now clear all bits
    //

    RtlClearAllBits( BitMap );

    //
    //  Now set some bit patterns, and test them
    //

    RtlSetBits( BitMap,   0,  1 );
    RtlSetBits( BitMap,  63,  1 );
    RtlSetBits( BitMap,  65, 30 );
    RtlSetBits( BitMap, 127,  2 );
    RtlSetBits( BitMap, 191, 34 );

    if ((BitMap->Buffer[0] != 0x00000001) ||
        (BitMap->Buffer[1] != 0x80000000) ||
        (BitMap->Buffer[2] != 0x7ffffffe) ||
        (BitMap->Buffer[3] != 0x80000000) ||
        (BitMap->Buffer[4] != 0x00000001) ||
        (BitMap->Buffer[5] != 0x80000000) ||
        (BitMap->Buffer[6] != 0xffffffff) ||
        (BitMap->Buffer[7] != 0x00000001)) {

        DbgPrint("RtlSetBits Error\n");
        return FALSE;
    }

    //
    //  Now test some RtlFindClearBitsAndSet
    //

    RtlSetAllBits( BitMap );

    RtlClearBits( BitMap, 0 +  10*32,  1 );
    RtlClearBits( BitMap, 5 +  11*32,  1 );
    RtlClearBits( BitMap, 7 +  12*32,  1 );

    RtlClearBits( BitMap, 0 +  13*32,  9 );
    RtlClearBits( BitMap, 4 +  14*32,  9 );
    RtlClearBits( BitMap, 7 +  15*32,  9 );

    RtlClearBits( BitMap, 0 +  16*32, 10 );
    RtlClearBits( BitMap, 4 +  17*32, 10 );
    RtlClearBits( BitMap, 6 +  18*32, 10 );
    RtlClearBits( BitMap, 7 +  19*32, 10 );

    RtlClearBits( BitMap, 0 + 110*32, 14 );
    RtlClearBits( BitMap, 1 + 111*32, 14 );
    RtlClearBits( BitMap, 2 + 112*32, 14 );

    RtlClearBits( BitMap, 0 + 113*32, 15 );
    RtlClearBits( BitMap, 1 + 114*32, 15 );
    RtlClearBits( BitMap, 2 + 115*32, 15 );

//    {
//        ULONG i;
//        for (i = 0; i < 16; i++) {
//            DbgPrint("%2d: %08lx\n", i, BitMap->Buffer[i]);
//        }
//    }

    if (RtlFindClearBitsAndSet( BitMap, 15, 0) != 0 + 113*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  0 + 113*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 15, 0) != 1 + 114*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  1 + 114*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 15, 0) != 2 + 115*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  2 + 115*32\n");
        return FALSE;
    }

    if (RtlFindClearBitsAndSet( BitMap, 14, 0) != 0 + 110*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  0 + 110*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 14, 0) != 1 + 111*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  1 + 111*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 14, 0) != 2 + 112*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  2 + 112*32\n");
        return FALSE;
    }

    if (RtlFindClearBitsAndSet( BitMap, 10, 0) != 0 + 16*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  0 + 16*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 10, 0) != 4 + 17*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  4 + 17*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 10, 0) != 6 + 18*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  6 + 18*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 10, 0) != 7 + 19*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  7 + 19*32\n");
        return FALSE;
    }

    if (RtlFindClearBitsAndSet( BitMap, 9, 0) != 0 + 13*32) {
        DbgPrint("RtlFindClearBitsAndSet Error 0 + 13*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 9, 0) != 4 + 14*32) {
        DbgPrint("RtlFindClearBitsAndSet Error 4 + 14*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 9, 0) != 7 + 15*32) {
        DbgPrint("RtlFindClearBitsAndSet Error 7 + 15*32\n");
        return FALSE;
    }

    if (RtlFindClearBitsAndSet( BitMap, 1, 0) != 0 + 10*32) {
        DbgPrint("RtlFindClearBitsAndSet Error 0 + 10*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 1, 0) != 5 + 11*32) {
        DbgPrint("RtlFindClearBitsAndSet Error 5 + 11*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 1, 0) != 7 + 12*32) {
        DbgPrint("RtlFindClearBitsAndSet Error 7 + 12*32\n");
        return FALSE;
    }

    //
    //  Now test some RtlFindClearBitsAndSet
    //

    RtlSetAllBits( BitMap );

    RtlClearBits( BitMap, 0 +  0*32,  1 );
    RtlClearBits( BitMap, 5 +  1*32,  1 );
    RtlClearBits( BitMap, 7 +  2*32,  1 );

    RtlClearBits( BitMap, 0 +  3*32,  9 );
    RtlClearBits( BitMap, 4 +  4*32,  9 );
    RtlClearBits( BitMap, 7 +  5*32,  9 );

    RtlClearBits( BitMap, 0 +  6*32, 10 );
    RtlClearBits( BitMap, 4 +  7*32, 10 );
    RtlClearBits( BitMap, 6 +  8*32, 10 );
    RtlClearBits( BitMap, 7 +  9*32, 10 );

    RtlClearBits( BitMap, 0 + 10*32, 14 );
    RtlClearBits( BitMap, 1 + 11*32, 14 );
    RtlClearBits( BitMap, 2 + 12*32, 14 );

    RtlClearBits( BitMap, 0 + 13*32, 15 );
    RtlClearBits( BitMap, 1 + 14*32, 15 );
    RtlClearBits( BitMap, 2 + 15*32, 15 );

//    {
//        ULONG i;
//        for (i = 0; i < 16; i++) {
//            DbgPrint("%2d: %08lx\n", i, BitMap->Buffer[i]);
//        }
//    }

    if (RtlFindClearBitsAndSet( BitMap, 15, 0) != 0 + 13*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  0 + 13*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 15, 0) != 1 + 14*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  1 + 14*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 15, 0) != 2 + 15*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  2 + 15*32\n");
        return FALSE;
    }

    if (RtlFindClearBitsAndSet( BitMap, 14, 0) != 0 + 10*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  0 + 10*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 14, 0) != 1 + 11*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  1 + 11*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 14, 0) != 2 + 12*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  2 + 12*32\n");
        return FALSE;
    }

    if (RtlFindClearBitsAndSet( BitMap, 10, 0) != 0 + 6*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  0 + 6*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 10, 0) != 4 + 7*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  4 + 7*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 10, 0) != 6 + 8*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  6 + 8*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 10, 0) != 7 + 9*32) {
        DbgPrint("RtlFindClearBitsAndSet Error  7 + 9*32\n");
        return FALSE;
    }

    if (RtlFindClearBitsAndSet( BitMap, 9, 0) != 0 + 3*32) {
        DbgPrint("RtlFindClearBitsAndSet Error 0 + 3*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 9, 0) != 4 + 4*32) {
        DbgPrint("RtlFindClearBitsAndSet Error 4 + 4*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 9, 0) != 7 + 5*32) {
        DbgPrint("RtlFindClearBitsAndSet Error 7 + 5*32\n");
        return FALSE;
    }

    if (RtlFindClearBitsAndSet( BitMap, 1, 0) != 0 + 0*32) {
        DbgPrint("RtlFindClearBitsAndSet Error 0 + 0*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 1, 0) != 5 + 1*32) {
        DbgPrint("RtlFindClearBitsAndSet Error 5 + 1*32\n");
        return FALSE;
    }
    if (RtlFindClearBitsAndSet( BitMap, 1, 0) != 7 + 2*32) {
        DbgPrint("RtlFindClearBitsAndSet Error 7 + 2*32\n");
        return FALSE;
    }

    //
    //  >>>> Test clearing bits
    //

    //
    //  Now clear all bits
    //

    RtlSetAllBits( BitMap );

    //
    //  Now set some bit patterns, and test them
    //

    RtlClearBits( BitMap,   0,  1 );
    RtlClearBits( BitMap,  63,  1 );
    RtlClearBits( BitMap,  65, 30 );
    RtlClearBits( BitMap, 127,  2 );
    RtlClearBits( BitMap, 191, 34 );

    if ((BitMap->Buffer[0] != ~0x00000001) ||
        (BitMap->Buffer[1] != ~0x80000000) ||
        (BitMap->Buffer[2] != ~0x7ffffffe) ||
        (BitMap->Buffer[3] != ~0x80000000) ||
        (BitMap->Buffer[4] != ~0x00000001) ||
        (BitMap->Buffer[5] != ~0x80000000) ||
        (BitMap->Buffer[6] != ~0xffffffff) ||
        (BitMap->Buffer[7] != ~0x00000001)) {

        DbgPrint("RtlClearBits Error\n");
        return FALSE;
    }

    //
    //  Now test some RtlFindSetBitsAndClear
    //

    RtlClearAllBits( BitMap );

    RtlSetBits( BitMap, 0 +  0*32,  1 );
    RtlSetBits( BitMap, 5 +  1*32,  1 );
    RtlSetBits( BitMap, 7 +  2*32,  1 );

    RtlSetBits( BitMap, 0 +  3*32,  9 );
    RtlSetBits( BitMap, 4 +  4*32,  9 );
    RtlSetBits( BitMap, 7 +  5*32,  9 );

    RtlSetBits( BitMap, 0 +  6*32, 10 );
    RtlSetBits( BitMap, 4 +  7*32, 10 );
    RtlSetBits( BitMap, 6 +  8*32, 10 );
    RtlSetBits( BitMap, 7 +  9*32, 10 );

    RtlSetBits( BitMap, 0 + 10*32, 14 );
    RtlSetBits( BitMap, 1 + 11*32, 14 );
    RtlSetBits( BitMap, 2 + 12*32, 14 );

    RtlSetBits( BitMap, 0 + 13*32, 15 );
    RtlSetBits( BitMap, 1 + 14*32, 15 );
    RtlSetBits( BitMap, 2 + 15*32, 15 );

    {
        ULONG i;
        for (i = 0; i < 16; i++) {
            DbgPrint("%2d: %08lx\n", i, BitMap->Buffer[i]);
        }
    }

    if (RtlFindSetBitsAndClear( BitMap, 15, 0) != 0 + 13*32) {
        DbgPrint("RtlFindSetBitsAndClear Error  0 + 13*32\n");
        return FALSE;
    }
    if (RtlFindSetBitsAndClear( BitMap, 15, 0) != 1 + 14*32) {
        DbgPrint("RtlFindSetBitsAndClear Error  1 + 14*32\n");
        return FALSE;
    }
    if (RtlFindSetBitsAndClear( BitMap, 15, 0) != 2 + 15*32) {
        DbgPrint("RtlFindSetBitsAndClear Error  2 + 15*32\n");
        return FALSE;
    }

    if (RtlFindSetBitsAndClear( BitMap, 14, 0) != 0 + 10*32) {
        DbgPrint("RtlFindSetBitsAndClear Error  0 + 10*32\n");
        return FALSE;
    }
    if (RtlFindSetBitsAndClear( BitMap, 14, 0) != 1 + 11*32) {
        DbgPrint("RtlFindSetBitsAndClear Error  1 + 11*32\n");
        return FALSE;
    }
    if (RtlFindSetBitsAndClear( BitMap, 14, 0) != 2 + 12*32) {
        DbgPrint("RtlFindSetBitsAndClear Error  2 + 12*32\n");
        return FALSE;
    }

    if (RtlFindSetBitsAndClear( BitMap, 10, 0) != 0 + 6*32) {
        DbgPrint("RtlFindSetBitsAndClear Error  0 + 6*32\n");
        return FALSE;
    }
    if (RtlFindSetBitsAndClear( BitMap, 10, 0) != 4 + 7*32) {
        DbgPrint("RtlFindSetBitsAndClear Error  4 + 7*32\n");
        return FALSE;
    }
    if (RtlFindSetBitsAndClear( BitMap, 10, 0) != 6 + 8*32) {
        DbgPrint("RtlFindSetBitsAndClear Error  6 + 8*32\n");
        return FALSE;
    }
    if (RtlFindSetBitsAndClear( BitMap, 10, 0) != 7 + 9*32) {
        DbgPrint("RtlFindSetBitsAndClear Error  7 + 9*32\n");
        return FALSE;
    }

    if (RtlFindSetBitsAndClear( BitMap, 9, 0) != 0 + 3*32) {
        DbgPrint("RtlFindSetBitsAndClear Error 0 + 3*32\n");
        return FALSE;
    }
    if (RtlFindSetBitsAndClear( BitMap, 9, 0) != 4 + 4*32) {
        DbgPrint("RtlFindSetBitsAndClear Error 4 + 4*32\n");
        return FALSE;
    }
    if (RtlFindSetBitsAndClear( BitMap, 9, 0) != 7 + 5*32) {
        DbgPrint("RtlFindSetBitsAndClear Error 7 + 5*32\n");
        return FALSE;
    }

    if (RtlFindSetBitsAndClear( BitMap, 1, 0) != 0 + 0*32) {
        DbgPrint("RtlFindSetBitsAndClear Error 0 + 0*32\n");
        return FALSE;
    }
    if (RtlFindSetBitsAndClear( BitMap, 1, 0) != 5 + 1*32) {
        DbgPrint("RtlFindSetBitsAndClear Error 5 + 1*32\n");
        return FALSE;
    }
    if (RtlFindSetBitsAndClear( BitMap, 1, 0) != 7 + 2*32) {
        DbgPrint("RtlFindSetBitsAndClear Error 7 + 2*32\n");
        return FALSE;
    }

    DbgPrint("DoBitMapTest Done.\n");

    return TRUE;
}

BOOLEAN
ExTest (
    VOID
    )

{

    USHORT i;

    DbgPrint( "In extest\n" );
    for (i=1; i<16; i++) {
        if (i == TestEvent)
            DoEventTest();
        else
        if (i == TestHandle)
            DoHandleTest();
        else
        if (i == TestInfo)
            DoInfoTest();
        else
        if (i == TestLuid) {
            DoLuidTest();
            }
        else
        if (i == TestMemory) {
            DoMemoryTest();
            }
        else
        if (i == TestParty)
            DoPartyTest();
        else
        if (i == TestPool)
            DoPoolTest();
        else
        if (i == TestResource)
            DoResourceTest();
        else
        if (i == TestBitMap)
            DoBitMapTest();
        else
        if (i == TestSemaphore)
            DoSemaphoreTest();
        else
        if (i == TestTimer)
            DoTimerTest();
        else
        if (i == TestZone)
            DoZoneTest();
        else
        if (i == TestMutant)
            DoMutantTest();
        else
        if (i == TestException)
            DoExceptionTest();
        }

    TestFunction = NULL;    // Invoke the CLI
    return TRUE;
}
#ifndef MIPS

int
_CDECL
main(
    int argc,
    char *argv[]
    )
{
#ifdef SIMULATOR
    char c, *s;
    USHORT i;

    i = 1;
    if (argc > 1 ) {
        while (--argc) {
            s = *++argv;
            while ((c = *s++) != '\0') {
                switch (c) {
                case 'B':
                case 'b':
                    TestBitMap = i++;
                    break;

                case 'C':
                case 'c':
                    TestException = i++;
                    break;

                case 'E':
                case 'e':
                    TestEvent = i++;
                    break;

                case 'H':
                case 'h':
                    TestHandle = i++;
                    break;

                case 'I':
                case 'i':
                    TestInfo = i++;
                    break;

                case 'L':
                case 'l':
                    TestLuid = i++;
                    break;

                case 'M':
                case 'm':
                    TestMemory = i++;
                    break;

                case 'P':
                case 'p':
                    TestPool = i++;
                    break;

                case 'R':
                case 'r':
                    TestResource = i++;
                    break;

                case 'S':
                case 's':
                    TestSemaphore = i++;
                    break;

                case 'T':
                case 't':
                    TestTimer = i++;
                    break;

                case 'X':
                case 'x':
                    TestMutant = i++;
                    break;

                case 'Z':
                case 'z':
                    TestZone = i++;
                    break;

                default:
                    DbgPrint( "tex: invalid test code - '%s'", *argv );
                    break;
                }
            }
        }
    } else {
        if (!strcmp( "DAVEC", szVerUser )) {
            TestEvent = 1;
            TestSemaphore = 2;
            TestTimer = 3;
            TestMutant = 4;
            TestException = 5;
        }
        else
        if (!strcmp( "MARKL", szVerUser )) {
            TestPool = 1;
            TestZone = 2;
        }
        else
        if (!strcmp( "STEVEWO", szVerUser )) {
            TestInfo = 1;
            TestParty = 2;
            TestMemory = 3;
            TestHandle = 4;
        }
        else
        if (!strcmp( "GARYKI", szVerUser )) {
            TestResource = 1;
            TestMemory = 2;
            TestBitMap = 3;
        }
        else
        if (!strcmp( "JIMK", szVerUser )) {
            TestLuid = 1;
        }
        else {
            DbgPrint( "*** Warning *** - %s is an unauthorized user of tex\n",
                     szVerUser
                   );
        }
    }
#else
    TestEvent = 1;
    TestSemaphore = 2;
    TestTimer = 3;
    TestMutant = 4;
    TestException = 5;
#endif // SIMULATOR

    TestFunction = extest;
    KiSystemStartup();
    return 0;
}
#endif // MIPS

void
oops()
{
    ExTimerRundown();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\sysenv.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    sysenv.c

Abstract:

    This module implements the NT query and set system environment
    variable services.

Author:

    David N. Cutler (davec) 10-Nov-1991

Revision History:

--*/

#include "exp.h"
#pragma hdrstop

#include <arccodes.h>

#include <ntdddisk.h>


#if defined(EFI_NVRAM_ENABLED)
#include <efi.h>
#include <efiboot.h>

GUID ExpUnknownDeviceGuid = UNKNOWN_DEVICE_GUID;

#endif

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

//
// Signature type
//
typedef union _DISK_SIGNATURE_NEW {
    GUID Guid;          // GPT disk signature
    ULONG Signature;    // MBR disk signature
} DISK_SIGNATURE_NEW, *PDISK_SIGNATURE_NEW;


//
// Define local subroutines.
//

NTSTATUS
ExpSetBootEntry (
    IN LOGICAL CreateNewEntry,
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    );

#if defined(EFI_NVRAM_ENABLED)

ULONG
ExpSafeWcslen (
    IN PWSTR String,
    IN PWSTR Max
    );

NTSTATUS
ExpTranslateArcPath (
    IN PFILE_PATH InputPath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength
    );

NTSTATUS
ExpTranslateEfiPath (
    IN PFILE_PATH InputPath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength
    );

NTSTATUS
ExpTranslateNtPath (
    IN PFILE_PATH InputPath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength
    );

LOGICAL
ExpTranslateBootEntryNameToId (
    IN PWSTR Name,
    OUT PULONG Id
    );

NTSTATUS
ExpTranslateSymbolicLink (
    IN PWSTR LinkName,
    OUT PUNICODE_STRING ResultName
    );

NTSTATUS
ExpVerifyFilePath (
    PFILE_PATH FilePath,
    PUCHAR Max
    );

LOGICAL
ExpIsDevicePathForRemovableMedia (
    EFI_DEVICE_PATH *DevicePath
    );

NTSTATUS
ExpVerifyWindowsOsOptions (
    PWINDOWS_OS_OPTIONS WindowsOsOptions,
    ULONG Length
    );

NTSTATUS
ExpParseArcPathName (
    IN PWSTR ArcName,
    OUT PWSTR *ppDeviceName,
    OUT PWSTR *ppPathName,
    OUT PULONG pDeviceNameCount,
    OUT PBOOLEAN pSignatureFormat
    );

NTSTATUS
ExpParseSignatureName (
    IN PWSTR deviceName,
    IN ULONG deviceNameCount,
    OUT PDISK_SIGNATURE_NEW diskSignature,
    OUT PULONG partitionNumber,
    OUT PULONGLONG partitionStart,
    OUT PULONGLONG partitionSize,
    OUT PBOOLEAN GPTpartition,
    OUT PBOOLEAN longSignature
    );

NTSTATUS
ExpParseEfiPath (
    IN EFI_DEVICE_PATH *pDevicePath,
    OUT HARDDRIVE_DEVICE_PATH **ppHardDriveDP,
    OUT PWSTR *ppPathName,
    OUT PBOOLEAN GPTpartition
    );

NTSTATUS
ExpConvertArcName (
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PWSTR pDeviceName,
    IN PWSTR pPathName,
    IN ULONG DeviceNameCount
    );

NTSTATUS
ExpConvertSignatureName (
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PWSTR pDeviceName,
    IN PWSTR pPathName,
    IN ULONG DeviceNameCount
    );

NTSTATUS
ExpTranslateHexStringToULONG (
    IN PWSTR Name,
    OUT PULONG Number
    );

NTSTATUS
ExpTranslateHexStringToULONGLONG (
    IN PWSTR Name,
    OUT PULONGLONG Number
    );

NTSTATUS
ExpTranslateHexStringToGUID (
    IN PWSTR Name,
    OUT GUID *pGuid
    );

NTSTATUS
ExpCreateOutputEFI (
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PDISK_SIGNATURE_NEW pDiskSignature,
    IN PULONG pPartitionNumber,
    IN PULONGLONG pPartitionStart,
    IN PULONGLONG pPartitionSize,
    IN PWSTR pPathName,
    IN BOOLEAN GPTpartition
    );

NTSTATUS
ExpCreateOutputNT (
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PUNICODE_STRING pDeviceNameString,
    IN PWSTR pPathName
    );

NTSTATUS
ExpCreateOutputARC (
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PUNICODE_STRING pDeviceNameString,
    IN PWSTR pPathName
    );

NTSTATUS
ExpCreateOutputSIGNATURE (
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PDISK_SIGNATURE_NEW pDiskSignature,
    IN PULONG pPartitionNumber,
    IN PULONGLONG pPartitionStart,
    IN PULONGLONG pPartitionSize,
    IN PWSTR pPathName,
    IN BOOLEAN GPTpartition
    );

NTSTATUS
ExpFindArcName (
    IN PUNICODE_STRING pDeviceNameString,
    OUT PWSTR *pArcName
    );

NTSTATUS
ExpFindDiskSignature (
    IN PDISK_SIGNATURE_NEW pSignature,
    IN OUT PULONG pPartitionNumber,
    OUT PULONG pDiskNumber,
    OUT PULONGLONG pPartitionStart,
    OUT PULONGLONG pPartitionSize,
    IN BOOLEAN GPTpartition
    );

NTSTATUS
ExpGetPartitionTableInfo (
    IN PWSTR pDeviceName,
    OUT PDRIVE_LAYOUT_INFORMATION_EX *ppDriveLayout
    );

#endif // defined(EFI_NVRAM_ENABLED)

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, NtQuerySystemEnvironmentValue)
#pragma alloc_text(PAGE, NtSetSystemEnvironmentValue)
#pragma alloc_text(PAGE, NtQuerySystemEnvironmentValueEx)
#pragma alloc_text(PAGE, NtSetSystemEnvironmentValueEx)
#pragma alloc_text(PAGE, NtEnumerateSystemEnvironmentValuesEx)
#pragma alloc_text(PAGE, NtAddBootEntry)
#pragma alloc_text(PAGE, NtDeleteBootEntry)
#pragma alloc_text(PAGE, NtModifyBootEntry)
#pragma alloc_text(PAGE, NtEnumerateBootEntries)
#pragma alloc_text(PAGE, NtQueryBootEntryOrder)
#pragma alloc_text(PAGE, NtSetBootEntryOrder)
#pragma alloc_text(PAGE, NtQueryBootOptions)
#pragma alloc_text(PAGE, NtSetBootOptions)
#pragma alloc_text(PAGE, NtTranslateFilePath)
#pragma alloc_text(PAGE, ExpSetBootEntry)
#if defined(EFI_NVRAM_ENABLED)
#pragma alloc_text(PAGE, ExpSafeWcslen)
#pragma alloc_text(PAGE, ExpTranslateArcPath)
#pragma alloc_text(PAGE, ExpTranslateEfiPath)
#pragma alloc_text(PAGE, ExpTranslateNtPath)
#pragma alloc_text(PAGE, ExpTranslateBootEntryNameToId)
#pragma alloc_text(PAGE, ExpTranslateSymbolicLink)
#pragma alloc_text(PAGE, ExpVerifyFilePath)
#pragma alloc_text(PAGE, ExpVerifyWindowsOsOptions)
#pragma alloc_text(PAGE, ExpParseArcPathName)
#pragma alloc_text(PAGE, ExpParseSignatureName)
#pragma alloc_text(PAGE, ExpParseEfiPath)
#pragma alloc_text(PAGE, ExpConvertArcName)
#pragma alloc_text(PAGE, ExpConvertSignatureName)
#pragma alloc_text(PAGE, ExpTranslateHexStringToULONG)
#pragma alloc_text(PAGE, ExpTranslateHexStringToULONGLONG)
#pragma alloc_text(PAGE, ExpTranslateHexStringToGUID)
#pragma alloc_text(PAGE, ExpCreateOutputEFI)
#pragma alloc_text(PAGE, ExpCreateOutputNT)
#pragma alloc_text(PAGE, ExpCreateOutputARC)
#pragma alloc_text(PAGE, ExpCreateOutputSIGNATURE)
#pragma alloc_text(PAGE, ExpFindArcName)
#pragma alloc_text(PAGE, ExpFindDiskSignature)
#pragma alloc_text(PAGE, ExpGetPartitionTableInfo)
#endif // defined(EFI_NVRAM_ENABLED)
#endif // defined(ALLOC_PRAGMA)

//
// Define maximum size of environment value.
//

#define MAXIMUM_ENVIRONMENT_VALUE 1024

//
// Define query/set environment variable synchronization fast mutex.
//

FAST_MUTEX ExpEnvironmentLock;

#if defined(EFI_NVRAM_ENABLED)
//
// Define vendor GUID for EFI boot variables.
//

GUID EfiBootVariablesGuid = EFI_GLOBAL_VARIABLE;
#endif


NTSTATUS
NtQuerySystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    OUT PWSTR VariableValue,
    IN USHORT ValueLength,
    OUT PUSHORT ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function locates the specified system environment variable and
    returns its value.

    N.B. This service requires the system environment privilege.

Arguments:

    Variable - Supplies a pointer to a UNICODE descriptor for the specified
        system environment variable.

    Value - Supplies a pointer to a buffer that receives the value of the
        specified system environment variable.

    ValueLength - Supplies the length of the value buffer in bytes.

    ReturnLength - Supplies an optional pointer to a variable that receives
        the length of the system environment variable value.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_PRIVILEGE_NOT_HELD is returned if the caller does not have the
        privilege to query a system environment variable.

    STATUS_ACCESS_VIOLATION is returned if the output parameter for the
        system environment value or the return length cannot be written,
        or the descriptor or the name of the system environment variable
        cannot be read.

    STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
        for this request to complete.

    STATUS_UNSUCCESSFUL - The specified environment variable could not
        be located.

--*/

{

    ULONG AnsiLength;
    ANSI_STRING AnsiString;
    ARC_STATUS ArcStatus;
    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    UNICODE_STRING UnicodeString;
    PCHAR ValueBuffer;

    //
    // Clear address of ANSI buffer.
    //

    AnsiString.Buffer = NULL;

    //
    // Establish an exception handler and attempt to probe and read the
    // name of the specified system environment variable, and probe the
    // variable value buffer and return length. If the probe or read
    // attempt fails, then return the exception code as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the string descriptor for the system
            // environment variable name.
            //

            ProbeForReadSmallStructure((PVOID)VariableName,
                                       sizeof(UNICODE_STRING),
                                       sizeof(ULONG));

            UnicodeString = *VariableName;

            //
            // Probe the system environment variable name.
            //

            if (UnicodeString.Length == 0) {
                return STATUS_ACCESS_VIOLATION;
            }

            ProbeForRead((PVOID)UnicodeString.Buffer,
                         UnicodeString.Length,
                         sizeof(WCHAR));

            //
            // Probe the system environment value buffer.
            //

            ProbeForWrite((PVOID)VariableValue, ValueLength, sizeof(WCHAR));

            //
            // If argument is present, probe the return length value.
            //

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUshort(ReturnLength);
            }

            //
            // Check if the current thread has the privilege to query a system
            // environment variable.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                              PreviousMode);

            if (HasPrivilege == FALSE) {
                return(STATUS_PRIVILEGE_NOT_HELD);
            }

        } else {
            UnicodeString = *VariableName;
        }


        //
        // Compute the size of the ANSI variable name, allocate a nonpaged
        // buffer, and convert the specified UNICODE variable name to ANSI.
        //

        AnsiLength = RtlUnicodeStringToAnsiSize(&UnicodeString);
        AnsiString.Buffer = (PCHAR)ExAllocatePoolWithTag(NonPagedPool, AnsiLength, 'rvnE');
        if (AnsiString.Buffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        AnsiString.MaximumLength = (USHORT)AnsiLength;
        NtStatus = RtlUnicodeStringToAnsiString(&AnsiString,
                                                &UnicodeString,
                                                FALSE);

        if (NT_SUCCESS(NtStatus) == FALSE) {
            ExFreePool((PVOID)AnsiString.Buffer);
            return NtStatus;
        }

    //
    // If an exception occurs during the read of the variable descriptor,
    // the read of the variable name, the probe of the variable value, or
    // the probe of the return length, then always handle the exception,
    // free the ANSI string buffer if necessary, and return the exception
    // code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (AnsiString.Buffer != NULL) {
            ExFreePool((PVOID)AnsiString.Buffer);
        }

        return GetExceptionCode();
    }

    //
    // Allocate nonpaged pool to receive variable value.
    //

    ValueBuffer = (PCHAR)ExAllocatePoolWithTag(NonPagedPool, MAXIMUM_ENVIRONMENT_VALUE, 'rvnE');
    if (ValueBuffer == NULL) {
        ExFreePool((PVOID)AnsiString.Buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Get the system environment variable value.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);
    ArcStatus = HalGetEnvironmentVariable(AnsiString.Buffer,
                                          MAXIMUM_ENVIRONMENT_VALUE,
                                          ValueBuffer);

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    //
    // Free the ANSI string buffer used to hold the variable name.
    //

    ExFreePool((PVOID)AnsiString.Buffer);

    //
    // If the specified environment variable was not found, then free
    // the value buffer and return an unsuccessful status.
    //

    if (ArcStatus != ESUCCESS) {
        ExFreePool((PVOID)ValueBuffer);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Establish an exception handler and attempt to write the value of the
    // specified system environment variable. If the write attempt fails,
    // then return the exception code as the service status.
    //

    try {

        //
        // Initialize an ANSI string descriptor, set the maximum length and
        // buffer address for a UNICODE string descriptor, and convert the
        // ANSI variable value to UNICODE.
        //

        RtlInitString(&AnsiString, ValueBuffer);
        UnicodeString.Buffer = (PWSTR)VariableValue;
        UnicodeString.MaximumLength = ValueLength;
        NtStatus = RtlAnsiStringToUnicodeString(&UnicodeString,
                                                &AnsiString,
                                                FALSE);

        //
        // If argument is present, then write the length of the UNICODE
        // variable value.
        //

        if (ARGUMENT_PRESENT(ReturnLength)) {
            *ReturnLength = UnicodeString.Length;
        }

        //
        // Free the value buffer used to hold the variable value.
        //

        ExFreePool((PVOID)ValueBuffer);
        return NtStatus;

    //
    // If an exception occurs during the write of the variable value, or
    // the write of the return length, then always handle the exception
    // and return the exception code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        ExFreePool((PVOID)ValueBuffer);
        return GetExceptionCode();
    }
}

NTSTATUS
NtSetSystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    IN PUNICODE_STRING VariableValue
    )

/*++

Routine Description:

    This function sets the specified system environment variable to the
    specified value.

    N.B. This service requires the system environment privilege.

Arguments:

    Variable - Supplies a pointer to a UNICODE descriptor for the specified
        system environment variable name.

    Value - Supplies a pointer to a UNICODE descriptor for the specified
        system environment variable value.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_PRIVILEGE_NOT_HELD is returned if the caller does not have the
        privilege to set a system environment variable.

    STATUS_ACCESS_VIOLATION is returned if the input parameter for the
        system environment variable or value cannot be read.

    STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
        for this request to complete.

--*/

{

    ULONG AnsiLength1;
    ULONG AnsiLength2;
    ANSI_STRING AnsiString1;
    ANSI_STRING AnsiString2;
    ARC_STATUS ArcStatus;
    BOOLEAN HasPrivilege;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS NtStatus;
    UNICODE_STRING UnicodeString1;
    UNICODE_STRING UnicodeString2;

    //
    // Clear address of ANSI buffers.
    //

    AnsiString1.Buffer = NULL;
    AnsiString2.Buffer = NULL;

    //
    // Establish an exception handler and attempt to set the value of the
    // specified system environment variable. If the read attempt for the
    // system environment variable or value fails, then return the exception
    // code as the service status. Otherwise, return either success or access
    // denied as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the string descriptor for the system
            // environment variable name.
            //

            ProbeForReadSmallStructure((PVOID)VariableName,
                                       sizeof(UNICODE_STRING),
                                       sizeof(ULONG));

            UnicodeString1 = *VariableName;

            //
            // Handle a zero length string explicitly since probing does not,
            // the error code is unusual, but it's what we would have done with
            // the HAL return code too.
            //

            if (UnicodeString1.Length == 0) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // Probe the system environment variable name.
            //

            ProbeForRead((PVOID)UnicodeString1.Buffer,
                         UnicodeString1.Length,
                         sizeof(WCHAR));

            //
            // Probe and capture the string descriptor for the system
            // environment variable value.
            //

            ProbeForReadSmallStructure((PVOID)VariableValue,
                                       sizeof(UNICODE_STRING),
                                       sizeof(ULONG));

            UnicodeString2 = *VariableValue;

            //
            // Handle a zero length string explicitly since probing does not
            // the error code is unusual, but it's what we would have done with
            // the HAL return code too.
            //

            if (UnicodeString2.Length == 0) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // Probe the system environment variable value.
            //

            ProbeForRead((PVOID)UnicodeString2.Buffer,
                         UnicodeString2.Length,
                         sizeof(WCHAR));

            //
            // Check if the current thread has the privilege to query a system
            // environment variable.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                              PreviousMode);

            if (HasPrivilege == FALSE) {
                return(STATUS_PRIVILEGE_NOT_HELD);
            }

        } else {
            UnicodeString1 = *VariableName;
            UnicodeString2 = *VariableValue;
        }


        //
        // Compute the size of the ANSI variable name, allocate a nonpaged
        // buffer, and convert the specified UNICODE variable name to ANSI.
        //

        AnsiLength1 = RtlUnicodeStringToAnsiSize(&UnicodeString1);
        AnsiString1.Buffer = (PCHAR)ExAllocatePoolWithTag(NonPagedPool, AnsiLength1, 'rvnE');
        if (AnsiString1.Buffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        AnsiString1.MaximumLength = (USHORT)AnsiLength1;
        NtStatus = RtlUnicodeStringToAnsiString(&AnsiString1,
                                                &UnicodeString1,
                                                FALSE);

        if (NT_SUCCESS(NtStatus) == FALSE) {
            ExFreePool((PVOID)AnsiString1.Buffer);
            return NtStatus;
        }

        //
        // Compute the size of the ANSI variable value, allocate a nonpaged
        // buffer, and convert the specified UNICODE variable value to ANSI.
        //

        AnsiLength2 = RtlUnicodeStringToAnsiSize(&UnicodeString2);
        AnsiString2.Buffer = (PCHAR)ExAllocatePoolWithTag(NonPagedPool, AnsiLength2, 'rvnE');
        if (AnsiString2.Buffer == NULL) {
            ExFreePool((PVOID)AnsiString1.Buffer);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        AnsiString2.MaximumLength = (USHORT)AnsiLength2;
        NtStatus = RtlUnicodeStringToAnsiString(&AnsiString2,
                                                &UnicodeString2,
                                                FALSE);

        if (NT_SUCCESS(NtStatus) == FALSE) {
            ExFreePool((PVOID)AnsiString1.Buffer);
            ExFreePool((PVOID)AnsiString2.Buffer);
            return NtStatus;
        }

    //
    // If an exception occurs during the read of the variable descriptor,
    // the read of the variable name, the read of the value descriptor, or
    // the read of the value, then always handle the exception, free the
    // ANSI string buffers if necessary, and return the exception code as
    // the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (AnsiString1.Buffer != NULL) {
            ExFreePool((PVOID)AnsiString1.Buffer);
        }

        if (AnsiString2.Buffer != NULL) {
            ExFreePool((PVOID)AnsiString2.Buffer);
        }

        return GetExceptionCode();
    }

    //
    // Set the system environment variable value.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);
    ArcStatus = HalSetEnvironmentVariable(AnsiString1.Buffer,
                                          AnsiString2.Buffer);
    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    //
    // Free the ANSI string buffers used to hold the variable name and value.
    //

    ExFreePool((PVOID)AnsiString1.Buffer);
    ExFreePool((PVOID)AnsiString2.Buffer);

    //
    // If the specified value of the specified environment variable was
    // successfully set, then return a success status. Otherwise, return
    // insufficient resources.
    //

    if (ArcStatus == ESUCCESS) {
        return STATUS_SUCCESS;

    } else {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
}

NTSTATUS
NtQuerySystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    OUT PVOID Value,
    IN OUT PULONG ValueLength,
    OUT PULONG Attributes OPTIONAL
    )

/*++

Routine Description:

    This function locates the specified system environment variable and
    return its value.

    N.B. This service requires the system environment privilege.

Arguments:

    VariableName - Supplies a pointer to a UNICODE descriptor for the specified
        system environment variable.

    VendorGuid - Supplies the GUID for the vendor associated with the variable.
        Variables are grouped into namespaces based on their vendor GUIDs. Some
        platforms may not support vendor GUIDs. On these platforms, all
        variables are in a single namespace, and this routine ignores VendorGuid.

    Value - Supplies a pointer to a buffer that receives the value of the
        specified system environment variable.

    ValueLength - On input, supplies the length in bytes of the Value buffer.
        On output, returns the length in bytes of the variable value. If the
        input buffer is large enough, then ValueLength indicates the amount
        of data copied into Value. If the input buffer is too small, then
        nothing is copied into the buffer, and ValueLength indicates the
        required buffer length.

    Attributes - Supplies an optional pointer to a ULONG to receive the
        attributes of the variable.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INSUFFICIENT_RESOURCES Insufficient system resources exist
                                  for this request to complete.
    STATUS_BUFFER_TOO_SMALL     The input buffer was too small.
    STATUS_VARIABLE_NOT_FOUND   The requested variable does not exist.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(VariableName);
    UNREFERENCED_PARAMETER(VendorGuid);
    UNREFERENCED_PARAMETER(Value);
    UNREFERENCED_PARAMETER(ValueLength);
    UNREFERENCED_PARAMETER(Attributes);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    UNICODE_STRING UnicodeString;
    PWSTR LocalUnicodeBuffer = NULL;
    GUID LocalGuid;
    PCHAR LockedValueBuffer;
    ULONG LocalValueLength;
    ULONG LocalAttributes;
    PVOID LockVariable;

    //
    // Establish an exception handler and attempt to probe and read the name
    // of the specified system environment variable, probe the variable value
    // buffer, probe and read the length argument, and probe the attributes
    // argument. If the probe attempt fails, then return the exception code
    // as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the string descriptor for the system
            // environment variable name.
            //

            ProbeForReadSmallStructure((PVOID)VariableName,
                                       sizeof(UNICODE_STRING),
                                       sizeof(ULONG));

            UnicodeString = *VariableName;

            //
            // Probe the system environment variable name.
            //

            if (UnicodeString.Length == 0) {
                return STATUS_ACCESS_VIOLATION;
            }

            ProbeForRead((PVOID)UnicodeString.Buffer,
                         UnicodeString.Length,
                         sizeof(WCHAR));

            //
            // Probe the vendor GUID.
            //

            ProbeForReadSmallStructure((PVOID)VendorGuid, sizeof(GUID), sizeof(ULONG));

            //
            // Probe and capture the length value.
            //

            ProbeForWriteUlong(ValueLength);

            LocalValueLength = *ValueLength;

            //
            // Probe the system environment value buffer.
            //

            if (!ARGUMENT_PRESENT(Value)) {
                LocalValueLength = 0;
            }

            if (LocalValueLength != 0) {
                ProbeForWrite((PVOID)Value, LocalValueLength, sizeof(UCHAR));
            }

            //
            // If argument is present, probe the attributes parameter.
            //

            if (ARGUMENT_PRESENT(Attributes)) {
                ProbeForWriteUlong(Attributes);
            }

            //
            // Check if the current thread has the privilege to query a system
            // environment variable.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {
            UnicodeString = *VariableName;
            LocalValueLength = *ValueLength;
            if (!ARGUMENT_PRESENT(Value)) {
                LocalValueLength = 0;
            }
        }

        //
        // Capture the vendor GUID.
        //

        RtlCopyMemory( &LocalGuid, VendorGuid, sizeof(GUID) );

        //
        // Allocate a nonpaged buffer and copy the specified Unicode variable
        // name into that buffer. We do this for two reasons: 1) we need the
        // string to be in nonpaged pool; and 2) the string needs to be null-
        // terminated, and it might not be already.
        //

        LocalUnicodeBuffer = (PWSTR)ExAllocatePoolWithTag(NonPagedPool,
                                                          UnicodeString.Length + sizeof(WCHAR),
                                                          'rvnE');
        if (LocalUnicodeBuffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(LocalUnicodeBuffer, UnicodeString.Buffer, UnicodeString.Length);
        LocalUnicodeBuffer[UnicodeString.Length/sizeof(WCHAR)] = 0;

    //
    // If an exception occurs during the read of the variable descriptor,
    // the read of the variable name, the read of the vendor GUID, the probe
    // of the variable value, the read of the input length, or the probe
    // of the attributes parameter, then always handle the exception,
    // free the Unicode string buffer if necessary, and return the exception
    // code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (LocalUnicodeBuffer != NULL) {
            ExFreePool((PVOID)LocalUnicodeBuffer);
        }

        return GetExceptionCode();
    }

    //
    // Lock the caller's value buffer in memory.
    //

    if (LocalValueLength != 0) {
        NtStatus = ExLockUserBuffer(Value,
                                    LocalValueLength,
                                    &LockedValueBuffer,
                                    &LockVariable);
        if (!NT_SUCCESS(NtStatus)) {
            ExFreePool((PVOID)LocalUnicodeBuffer);
            return NtStatus;
        }
    } else {
        LockedValueBuffer = NULL;
        LockVariable = NULL;
    }

    //
    // Get the system environment variable value.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    NtStatus = HalGetEnvironmentVariableEx(LocalUnicodeBuffer,
                                           &LocalGuid,
                                           LockedValueBuffer,
                                           &LocalValueLength,
                                           &LocalAttributes);

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    //
    // Free the Unicode string buffer used to hold the variable name.
    //

    ExFreePool((PVOID)LocalUnicodeBuffer);

    //
    // Unlock the value buffer.
    //

    if (LockVariable != NULL) {
        ExUnlockUserBuffer(LockVariable);
    }

    //
    // Establish an exception handler and attempt to write the return
    // length and the attributes. If either of the write attempts fail,
    // then return the exception code as the service status.
    //

    try {

        //
        // Write the length of the variable value.
        //

        *ValueLength = LocalValueLength;

        //
        // If argument is present, then write the variable attributes.
        //

        if (ARGUMENT_PRESENT(Attributes)) {
            *Attributes = LocalAttributes;
        }

        return NtStatus;

    //
    // If an exception occurs during the write of the return length or
    // the write of the attributes, then always handle the exception
    // and return the exception code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtQuerySystemEnvironmentValueEx

NTSTATUS
NtSetSystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes
    )

/*++

Routine Description:

    This function sets the specified system environment variable to the
    specified value.

    N.B. This service requires the system environment privilege.

Arguments:

    VariableName - Supplies a pointer to a UNICODE descriptor for the specified
        system environment variable.

    VendorGuid - Supplies the GUID for the vendor associated with the variable.
        Variables are grouped into namespaces based on their vendor GUIDs. Some
        platforms may not support vendor GUIDs. On these platforms, all
        variables are in a single namespace, and this routine ignores VendorGuid.

    Value - Supplies a pointer to a buffer that contains the new variable value.

    ValueLength - Supplies the length in bytes of the Value buffer.

    Attributes - Supplies the attributes of the variable. The attribute bit
        VARIABLE_ATTRIBUTE_NON_VOLATILE MUST be set.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INSUFFICIENT_RESOURCES Insufficient system resources exist
                                  for this request to complete.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(VariableName);
    UNREFERENCED_PARAMETER(VendorGuid);
    UNREFERENCED_PARAMETER(Value);
    UNREFERENCED_PARAMETER(ValueLength);
    UNREFERENCED_PARAMETER(Attributes);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    UNICODE_STRING UnicodeString;
    PWSTR LocalUnicodeBuffer = NULL;
    GUID LocalGuid;
    PCHAR LockedValueBuffer;
    PVOID LockVariable;

    //
    // Establish an exception handler and attempt to probe and read the
    // name of the specified system environment variable, probe and read
    // the vendor GUID, and probe the variable value buffer. If the probe
    // attempt fails, then return the exception code as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the string descriptor for the system
            // environment variable name.
            //

            ProbeForReadSmallStructure((PVOID)VariableName,
                                       sizeof(UNICODE_STRING),
                                       sizeof(ULONG));

            UnicodeString = *VariableName;

            //
            // Probe the system environment variable name.
            //

            if (UnicodeString.Length == 0) {
                return STATUS_ACCESS_VIOLATION;
            }

            ProbeForRead((PVOID)UnicodeString.Buffer,
                         UnicodeString.Length,
                         sizeof(WCHAR));

            //
            // Probe the vendor GUID.
            //

            ProbeForReadSmallStructure((PVOID)VendorGuid, sizeof(GUID), sizeof(ULONG));

            //
            // Probe the system environment value buffer.
            //

            if (!ARGUMENT_PRESENT(Value)) {
                ValueLength = 0;
            }

            if (ValueLength != 0) {
                ProbeForWrite((PVOID)Value, ValueLength, sizeof(UCHAR));
            }

            //
            // Check if the current thread has the privilege to set a system
            // environment variable.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {
            UnicodeString = *VariableName;
            if (!ARGUMENT_PRESENT(Value)) {
                ValueLength = 0;
            }
        }

        //
        // Capture the vendor GUID.
        //

        RtlCopyMemory( &LocalGuid, VendorGuid, sizeof(GUID) );

        //
        // Allocate a nonpaged buffer and copy the specified Unicode variable
        // name into that buffer. We do this for two reasons: 1) we need the
        // string to be in nonpaged pool; and 2) the string needs to be null-
        // terminated, and it might not be already.
        //

        LocalUnicodeBuffer = (PWSTR)ExAllocatePoolWithTag(NonPagedPool,
                                                          UnicodeString.Length + sizeof(WCHAR),
                                                          'rvnE');
        if (LocalUnicodeBuffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(LocalUnicodeBuffer, UnicodeString.Buffer, UnicodeString.Length);
        LocalUnicodeBuffer[UnicodeString.Length/sizeof(WCHAR)] = 0;

    //
    // If an exception occurs during the read of the variable descriptor,
    // the read of the variable name, the read of the vendor GUID or the probe
    // of the variable value, then always handle the exception, free the Unicode
    // string buffer if necessary, and return the exception code as the status
    // value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (LocalUnicodeBuffer != NULL) {
            ExFreePool((PVOID)LocalUnicodeBuffer);
        }

        return GetExceptionCode();
    }

    //
    // Lock the caller's value buffer in memory.
    //

    if (ValueLength != 0) {
        NtStatus = ExLockUserBuffer(Value,
                                    ValueLength,
                                    &LockedValueBuffer,
                                    &LockVariable);
        if (!NT_SUCCESS(NtStatus)) {
            ExFreePool((PVOID)LocalUnicodeBuffer);
            return NtStatus;
        }
    } else {
        LockedValueBuffer = NULL;
        LockVariable = NULL;
    }

    //
    // Set the system environment variable value.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    NtStatus = HalSetEnvironmentVariableEx(LocalUnicodeBuffer,
                                           &LocalGuid,
                                           LockedValueBuffer,
                                           ValueLength,
                                           Attributes);

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    //
    // Free the Unicode string buffer used to hold the variable name.
    //

    ExFreePool((PVOID)LocalUnicodeBuffer);

    //
    // Unlock the value buffer.
    //

    if (LockVariable != NULL) {
        ExUnlockUserBuffer(LockVariable);
    }

    return NtStatus;

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtSetSystemEnvironmentValueEx

NTSTATUS
NtEnumerateSystemEnvironmentValuesEx (
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    )

/*++

Routine Description:

    This function returns information about system environment variables.

    N.B. This service requires the system environment privilege.

Arguments:

    InformationClass - Specifies the type of information to return.

    Buffer - Supplies the address of the buffer that is to receive the
        returned data. The format of the returned data depends on
        InformationClass.

    BufferLength - On input, supplies the length in bytes of the buffer.
        On output, returns the length in bytes of the returned data.
        If the input buffer is large enough, then BufferLength indicates
        the amount of data copied into Buffer. If the input buffer is too
        small, then BufferLength indicates the required buffer length.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_BUFFER_TOO_SMALL     The input buffer was too small.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(InformationClass);
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(BufferLength);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    PCHAR LockedBuffer;
    ULONG LocalBufferLength;
    PVOID LockVariable;

    //
    // Establish an exception handler and attempt to probe the return buffer
    // and probe and read the buffer length. If the probe attempt fails, then
    // return the exception code as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the input buffer length.
            //

            ProbeForWriteUlong(BufferLength);

            LocalBufferLength = *BufferLength;

            //
            // Probe the return buffer.
            //

            if (!ARGUMENT_PRESENT(Buffer)) {
                LocalBufferLength = 0;
            }

            if (LocalBufferLength != 0) {
                ProbeForWrite((PVOID)Buffer, LocalBufferLength, sizeof(ULONG));
            }

            //
            // Check if the current thread has the privilege to enumerate
            // system environment variables.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {
            LocalBufferLength = *BufferLength;
            if (!ARGUMENT_PRESENT(Buffer)) {
                LocalBufferLength = 0;
            }
        }

    //
    // If an exception occurs during the probe of the return buffer or the
    // read of the input length, then always handle the exception and return
    // the exception code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Lock the caller's return buffer in memory.
    //

    if (LocalBufferLength != 0) {
        NtStatus = ExLockUserBuffer(Buffer,
                                    LocalBufferLength,
                                    &LockedBuffer,
                                    &LockVariable);
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }
    } else {
        LockedBuffer = NULL;
        LockVariable = NULL;
    }

    //
    // Enumerate the system environment variables.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    NtStatus = HalEnumerateEnvironmentVariablesEx(InformationClass,
                                                  LockedBuffer,
                                                  &LocalBufferLength);

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    //
    // Unlock the return buffer.
    //

    if (LockVariable != NULL) {
        ExUnlockUserBuffer(LockVariable);
    }

    //
    // Establish an exception handler and attempt to write the return length.
    // If the write attempt fails, then return the exception code as the
    // service status.
    //

    try {

        //
        // Write the length of the returned data.
        //

        *BufferLength = LocalBufferLength;
    
        return NtStatus;

    //
    // If an exception occurs during the write of the return length, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtEnumerateSystemEnvironmentValuesEx

NTSTATUS
NtAddBootEntry (
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    )

/*++

Routine Description:

    This function adds a boot entry to the system environment.

    N.B. This service requires the system environment privilege.

Arguments:

    BootEntry - Supplies the address of a BOOT_ENTRY that describes the
        new boot entry.

    Id - Supplies the address of a ULONG that is to receive the identifier
        assigned to the new boot entry.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
    return ExpSetBootEntry(TRUE, BootEntry, Id);

} // NtAddBootEntry

NTSTATUS
NtDeleteBootEntry (
    IN ULONG Id
    )

/*++

Routine Description:

    This function deletes an existing boot entry from the system environment.

    N.B. This service requires the system environment privilege.

Arguments:

    Id - Supplies the identifier of the boot entry that is to be deleted.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_VARIABLE_NOT_FOUND   The Id specifies a boot entry that does not exist.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(Id);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    WCHAR idString[9];
    ULONG length;

    //
    // Verify that the input identifier is in range.
    //

    if (Id > MAXUSHORT) {
        return STATUS_INVALID_PARAMETER;
    }

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {

        //
        // Check if the current thread has the privilege to query the
        // system boot order list.
        //

        HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                              PreviousMode);

        if (HasPrivilege == FALSE) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }
    }

    //
    // Verify that the provided identifier exists.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    swprintf( idString, L"Boot%04x", Id);
    length = 0;
    NtStatus = HalGetEnvironmentVariableEx(idString,
                                           &EfiBootVariablesGuid,
                                           NULL,
                                           &length,
                                           NULL);
    if ((NtStatus == STATUS_SUCCESS) || (NtStatus == STATUS_BUFFER_TOO_SMALL)) {

        //
        // Delete the boot entry environment variable by writing a zero length
        // value.
        //

        NtStatus = HalSetEnvironmentVariableEx(idString,
                                               &EfiBootVariablesGuid,
                                               NULL,
                                               0,
                                               VARIABLE_ATTRIBUTE_NON_VOLATILE);
    }

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    return NtStatus;

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtDeleteBootEntry

NTSTATUS
NtModifyBootEntry (
    IN PBOOT_ENTRY BootEntry
    )

/*++

Routine Description:

    This function modifies an existing boot entry in the system environment.

    N.B. This service requires the system environment privilege.

Arguments:

    BootEntry - Supplies the address of a BOOT_ENTRY that describes the
        modified boot entry. The Id field of this structure specifies the
        boot entry that is to be modified.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_VARIABLE_NOT_FOUND   The Id specifies a boot entry that does not exist.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
    return ExpSetBootEntry(FALSE, BootEntry, NULL);

} // NtModifyBootEntry

NTSTATUS
NtEnumerateBootEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    )

/*++

Routine Description:

    This function returns a list of all existing boot entries.

    N.B. This service requires the system environment privilege.

Arguments:

    Buffer - Supplies the address of the buffer that is to receive the
        returned data. The returned data is a sequence of BOOT_ENTRY_LIST
        structures.

    BufferLength - On input, supplies the length in bytes of the buffer.
        On output, returns the length in bytes of the returned data.
        If the input buffer is large enough, then BufferLength indicates
        the amount of data copied into Buffer. If the input buffer
        is too small, then BufferLength indicates the required buffer length.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_BUFFER_TOO_SMALL     The input buffer was too small.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(BufferLength);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    PCHAR LockedBuffer;
    ULONG LocalBufferLength;
    PVOID LockVariable;
    PVARIABLE_NAME_AND_VALUE variableBuffer = NULL;
    ULONG variableBufferLength;
    PBOOT_ENTRY_LIST currentPtr;
    PBOOT_ENTRY_LIST previousEntry;
    ULONG remainingLength;
    LOGICAL filling;
    NTSTATUS fillStatus;
    PVARIABLE_NAME_AND_VALUE variablePtr;
    PWSTR maxVariablePtr;

    //
    // Verify that the input buffer is properly aligned.
    //

    if ( ALIGN_DOWN_POINTER(Buffer, ULONG) != Buffer ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Establish an exception handler and attempt to probe the return buffer
    // and probe and read the buffer length. If the probe attempt fails, then
    // return the exception code as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the input buffer length.
            //

            ProbeForWriteUlong(BufferLength);

            LocalBufferLength = *BufferLength;

            //
            // Probe the return buffer.
            //

            if (!ARGUMENT_PRESENT(Buffer)) {
                LocalBufferLength = 0;
            }

            if (LocalBufferLength != 0) {
                ProbeForWrite((PVOID)Buffer, LocalBufferLength, sizeof(ULONG));
            }

            //
            // Check if the current thread has the privilege to query the
            // system boot entry list.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {
            LocalBufferLength = *BufferLength;
            if (!ARGUMENT_PRESENT(Buffer)) {
                LocalBufferLength = 0;
            }
        }

    //
    // If an exception occurs during the probe of the return buffer or the
    // read of the input length, then always handle the exception and return
    // the exception code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Lock the caller's return buffer in memory.
    //

    if (LocalBufferLength != 0) {
        NtStatus = ExLockUserBuffer(Buffer,
                                    LocalBufferLength,
                                    &LockedBuffer,
                                    &LockVariable);
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }
    } else {
        LockedBuffer = NULL;
        LockVariable = NULL;
    }

    //
    // Initialize variables for filling the output buffer.
    //

    currentPtr = (PBOOT_ENTRY_LIST)LockedBuffer;
    remainingLength = LocalBufferLength;

    filling = (LOGICAL)(remainingLength != 0);
    fillStatus = STATUS_SUCCESS;
    if ( !filling ) {
        fillStatus = STATUS_BUFFER_TOO_SMALL;
    }

    previousEntry = NULL;

    //
    // Enumerate all existing environment variables.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    variableBufferLength = 0;
    NtStatus = HalEnumerateEnvironmentVariablesEx(VARIABLE_INFORMATION_VALUES,
                                                  NULL,
                                                  &variableBufferLength);
    if (NtStatus != STATUS_BUFFER_TOO_SMALL) {
        variableBufferLength = 0;
    } else {
        variableBuffer = ExAllocatePoolWithTag(NonPagedPool, variableBufferLength, 'rvnE');
        if (variableBuffer == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            NtStatus = HalEnumerateEnvironmentVariablesEx(VARIABLE_INFORMATION_VALUES,
                                                          variableBuffer,
                                                          &variableBufferLength);
        }
    }

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    if ((NtStatus != STATUS_SUCCESS) || (variableBufferLength == 0)) {
        goto done;
    }

    //
    // Each variable whose name is of the form Boot####, where #### is a
    // four-digit hex number, is assumed to define a boot entry. For
    // each such variable, copy its data into the output buffer.
    //

    variablePtr = variableBuffer;
    maxVariablePtr = (PWSTR)variableBuffer + variableBufferLength;

    while (TRUE) {

        ULONG id;

        if ((memcmp(&variablePtr->VendorGuid, &EfiBootVariablesGuid, sizeof(GUID)) == 0) &&
            ExpTranslateBootEntryNameToId(variablePtr->Name, &id) &&
            (variablePtr->ValueLength >= sizeof(EFI_LOAD_OPTION))) {

            PEFI_LOAD_OPTION efiLoadOption;
            ULONG descriptionLength;
            ULONG filePathLength;
            ULONG minimumLength;

            efiLoadOption = ADD_OFFSET(variablePtr, ValueOffset);
            filePathLength = efiLoadOption->FilePathLength;
            descriptionLength = ExpSafeWcslen(efiLoadOption->Description, maxVariablePtr);
            if ( descriptionLength != 0xffffffff ) {
                descriptionLength = (descriptionLength + 1) * sizeof(WCHAR);
            }
            minimumLength = FIELD_OFFSET(EFI_LOAD_OPTION, Description) +
                            descriptionLength +
                            filePathLength;

            if ((descriptionLength != 0xffffffff) &&
                (filePathLength < variablePtr->ValueLength) &&
                (variablePtr->ValueLength >= minimumLength)) {

                EFI_DEVICE_PATH *dp;
                PUCHAR options;
                ULONG optionsLength;
                ULONG actualLength;
                ULONG requiredLength;
                ULONG friendlyNameOffset;
                ULONG bootFilePathOffset;

                dp = (EFI_DEVICE_PATH *)((PUCHAR)efiLoadOption->Description + descriptionLength);
                options = (PUCHAR)dp + filePathLength;
                optionsLength = variablePtr->ValueLength - minimumLength;

                if (ALIGN_UP_POINTER(currentPtr, ULONG) != currentPtr) {
                    PUCHAR alignedPtr = ALIGN_UP_POINTER( currentPtr, ULONG );
                    ULONG fill = (ULONG)(alignedPtr - (PUCHAR)currentPtr);
                    currentPtr = (PBOOT_ENTRY_LIST)alignedPtr;
                    if (remainingLength < fill) {
                        filling = FALSE;
                        remainingLength = 0;
                        fillStatus = STATUS_BUFFER_TOO_SMALL;
                    } else {
                        remainingLength -= fill;
                    }
                }
        
                requiredLength = FIELD_OFFSET(BOOT_ENTRY, OsOptions);
                requiredLength += optionsLength;
                requiredLength = ALIGN_UP(requiredLength, ULONG);

                friendlyNameOffset = requiredLength;
                requiredLength += descriptionLength;
                requiredLength = ALIGN_UP(requiredLength, ULONG);

                bootFilePathOffset = requiredLength;
                requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);
                requiredLength += filePathLength;

                actualLength = requiredLength;
                requiredLength += FIELD_OFFSET(BOOT_ENTRY_LIST, BootEntry);

                if (remainingLength < requiredLength) {
        
                    remainingLength = 0;
                    filling = FALSE;
                    fillStatus = STATUS_BUFFER_TOO_SMALL;
        
                } else {
        
                    remainingLength -= requiredLength;
                }

                if ( filling ) {

                    PWCHAR friendlyName;
                    PFILE_PATH bootFilePath;
                    PBOOT_ENTRY bootEntry = &currentPtr->BootEntry;

                    RtlZeroMemory(currentPtr, requiredLength);

                    bootEntry->Version = BOOT_ENTRY_VERSION;
                    bootEntry->Length = actualLength;
                    bootEntry->Id = id;
                    bootEntry->Attributes = 0;
                    if ((efiLoadOption->Attributes & LOAD_OPTION_ACTIVE) != 0) {
                        bootEntry->Attributes = BOOT_ENTRY_ATTRIBUTE_ACTIVE;
                    }
                    bootEntry->FriendlyNameOffset = friendlyNameOffset;
                    bootEntry->BootFilePathOffset = bootFilePathOffset;
                    bootEntry->OsOptionsLength = optionsLength;
                    memcpy(bootEntry->OsOptions, options, optionsLength);
                    if (optionsLength > FIELD_OFFSET(WINDOWS_OS_OPTIONS,OsLoadOptions)) {
                        PWINDOWS_OS_OPTIONS windowsOsOptions;
                        windowsOsOptions = (PWINDOWS_OS_OPTIONS)bootEntry->OsOptions;
                        if ((strcmp((char *)windowsOsOptions->Signature,
                                    WINDOWS_OS_OPTIONS_SIGNATURE) == 0) &&
                            NT_SUCCESS(ExpVerifyWindowsOsOptions(windowsOsOptions,
                                                                 optionsLength))) {
                            bootEntry->Attributes |= BOOT_ENTRY_ATTRIBUTE_WINDOWS;
                        }
                    }
                    friendlyName = (PWCHAR)((PUCHAR)bootEntry + friendlyNameOffset);
                    memcpy(friendlyName, efiLoadOption->Description, descriptionLength);
                    bootFilePath = (PFILE_PATH)((PUCHAR)bootEntry + bootFilePathOffset);
                    bootFilePath->Version = FILE_PATH_VERSION;
                    bootFilePath->Length = FIELD_OFFSET(FILE_PATH, FilePath) + filePathLength;
                    bootFilePath->Type = FILE_PATH_TYPE_EFI;
                    memcpy(bootFilePath->FilePath, dp, filePathLength);
                    if (NT_SUCCESS(ExpVerifyFilePath(bootFilePath,
                                                     ADD_OFFSET(bootFilePath, Length))) &&
                        ExpIsDevicePathForRemovableMedia(dp)) {
                        bootEntry->Attributes |= BOOT_ENTRY_ATTRIBUTE_REMOVABLE_MEDIA;
                    }

                    if ( previousEntry != NULL ) {
                        previousEntry->NextEntryOffset =
                                    (ULONG)((PUCHAR)currentPtr - (PUCHAR)previousEntry);
                    }
                    previousEntry = currentPtr;
                }

                currentPtr = (PBOOT_ENTRY_LIST)((PUCHAR)currentPtr + requiredLength);
            }
        }

        if (variablePtr->NextEntryOffset == 0) {
            break;
        }
        variablePtr = ADD_OFFSET(variablePtr, NextEntryOffset);
    }

    if ( previousEntry != NULL ) {
        previousEntry->NextEntryOffset = 0;
    }

done:

    //
    // Free allocated pool.
    //

    if (variableBuffer != NULL) {
        ExFreePool(variableBuffer);
    }

    //
    // Unlock the return buffer.
    //

    if (LockVariable != NULL) {
        ExUnlockUserBuffer(LockVariable);
    }

    //
    // If the status of service calls is STATUS_SUCCESS, then return the fill
    // status as the final status.
    //

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = fillStatus;
    }

    //
    // Establish an exception handler and attempt to write the return length.
    // If the write attempt fails, then return the exception code as the
    // service status.
    //

    try {

        //
        // Write the length of the returned data.
        //

        *BufferLength = (ULONG)((PUCHAR)currentPtr - (PUCHAR)LockedBuffer);
    
        return NtStatus;

    //
    // If an exception occurs during the write of the return length, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtEnumerateBootEntries

NTSTATUS
NtQueryBootEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    )

/*++

Routine Description:

    This function returns the system boot order list.

    N.B. This service requires the system environment privilege.

Arguments:

    Ids - Supplies the address of the buffer that is to receive the
        returned data. The returned data is an array of ULONG boot
        entry identifiers.

    Count - On input, supplies the length in ULONGs of the buffer.
        On output, returns the length in ULONGs of the returned data.
        If the input buffer is large enough, then Count indicates
        the amount of data copied into Buffer. If the input buffer
        is too small, then Count indicates the required buffer length.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_BUFFER_TOO_SMALL     The input buffer was too small.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(Ids);
    UNREFERENCED_PARAMETER(Count);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    PCHAR LockedBuffer;
    ULONG LocalBufferLength;
    PVOID LockVariable;

    //
    // Establish an exception handler and attempt to probe the return buffer
    // and probe and read the buffer length. If the probe attempt fails, then
    // return the exception code as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the input buffer length.
            //

            ProbeForWriteUlong(Count);

            LocalBufferLength = *Count * sizeof(ULONG);

            //
            // Probe the return buffer.
            //

            if (!ARGUMENT_PRESENT(Ids)) {
                LocalBufferLength = 0;
            }

            if (LocalBufferLength != 0) {
                ProbeForWrite((PVOID)Ids, LocalBufferLength, sizeof(ULONG));
            }

            //
            // Check if the current thread has the privilege to query the
            // system boot order list.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {
            LocalBufferLength = *Count * sizeof(ULONG);
            if (!ARGUMENT_PRESENT(Ids)) {
                LocalBufferLength = 0;
            }
        }

    //
    // If an exception occurs during the probe of the return buffer or the
    // read of the input length, then always handle the exception and return
    // the exception code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Lock the caller's return buffer in memory.
    //

    if (LocalBufferLength != 0) {
        NtStatus = ExLockUserBuffer(Ids,
                                    LocalBufferLength,
                                    &LockedBuffer,
                                    &LockVariable);
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }
    } else {
        LockedBuffer = NULL;
        LockVariable = NULL;
    }

    //
    // EFI returns USHORT identifiers, which we will need to translate to
    // ULONGs. Cut the buffer length in half to account for this.
    //

    LocalBufferLength /= 2;

    //
    // Query the BootOrder system environment variable.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    NtStatus = HalGetEnvironmentVariableEx(L"BootOrder",
                                           &EfiBootVariablesGuid,
                                           LockedBuffer,
                                           &LocalBufferLength,
                                           NULL);

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    //
    // If the API succeeded, translate the returned USHORTs into ULONGs.
    // Do this by converting each USHORT into a ULONG, starting from the
    // end of the array to avoid stomping on needed data.
    //

    if (NT_SUCCESS(NtStatus)) {

        ULONG count = LocalBufferLength / sizeof(USHORT);
        PUSHORT sp = &((PUSHORT)LockedBuffer)[count - 1];
        PULONG lp = &((PULONG)LockedBuffer)[count - 1];
        while (count > 0) {
            *lp-- = *sp--;
            count--;
        }

    } else if (NtStatus == STATUS_VARIABLE_NOT_FOUND) {

        //
        // The BootOrder variable doesn't exist. This is unusual,
        // but possible. We'll just return an empty list.
        //

        LocalBufferLength = 0;
        NtStatus = STATUS_SUCCESS;
    }

    LocalBufferLength *= 2;

    //
    // Unlock the buffer.
    //

    if (LockVariable != NULL) {
        ExUnlockUserBuffer(LockVariable);
    }

    //
    // Establish an exception handler and attempt to write the return length.
    // If the write attempt fails, then return the exception code as the
    // service status.
    //

    try {

        //
        // Write the length of the returned data.
        //

        *Count = LocalBufferLength / sizeof(ULONG);

        return NtStatus;

    //
    // If an exception occurs during the write of the return length, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtQueryBootEntryOrder

NTSTATUS
NtSetBootEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    )

/*++

Routine Description:

    This function modifies the system boot order list.

    N.B. This service requires the system environment privilege.

Arguments:

    Ids - Supplies the address of an array that contains the new boot
        entry order list. The data is an array of ULONG identifiers.

    Count - Supplies the length in ULONGs of the Ids array.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(Ids);
    UNREFERENCED_PARAMETER(Count);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    ULONG LocalBufferLength;
    PUSHORT shortBuffer;
    ULONG i;

    //
    // Verify that the input buffer is not empty and is not too large.
    // Calculate the length in bytes of the buffer.
    //

    if ((Count == 0) || (Count > MAXULONG/sizeof(ULONG))) {
        return STATUS_INVALID_PARAMETER;
    }

    LocalBufferLength = Count * sizeof(ULONG);

    //
    // Allocate a nonpaged buffer to hold the USHORT versions of the IDs.
    //

    shortBuffer = ExAllocatePoolWithTag(NonPagedPool, Count * sizeof(USHORT), 'rvnE');
    if (shortBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Establish an exception handler and attempt to probe the input buffer.
    // If the probe attempt fails, then return the exception code as the
    // service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe the input buffer.
            //

            ProbeForRead((PVOID)Ids, LocalBufferLength, sizeof(ULONG));

            //
            // Check if the current thread has the privilege to modify the
            // system boot order list.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                ExFreePool(shortBuffer);
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        }

        //
        // Truncate the ULONGs in the input buffer into USHORTs in
        // the local buffer.
        //

        for ( i = 0; i < Count; i++ ) {
            if (Ids[i] > MAXUSHORT) {
                ExFreePool(shortBuffer);
                return STATUS_INVALID_PARAMETER;
            }
            shortBuffer[i] = (USHORT)Ids[i];
        }

    //
    // If an exception occurs during the probe of the input buffer, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        ExFreePool(shortBuffer);
        return GetExceptionCode();
    }

    //
    // Set the BootOrder system environment variable.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    NtStatus = HalSetEnvironmentVariableEx(L"BootOrder",
                                           &EfiBootVariablesGuid,
                                           shortBuffer,
                                           Count * sizeof(USHORT),
                                           VARIABLE_ATTRIBUTE_NON_VOLATILE);

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    ExFreePool(shortBuffer);

    return NtStatus;

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtSetBootEntryOrder

NTSTATUS
NtQueryBootOptions (
    OUT PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    )

/*++

Routine Description:

    This function returns the system's global boot options.

    N.B. This service requires the system environment privilege.

Arguments:

    BootOptions - Supplies the address of the buffer that is to receive the
        returned data.

    BootOptionsLength - On input, supplies the length in bytes of the buffer.
        On output, returns the length in bytes of the returned data.
        If the input buffer is large enough, then BootOptionsLength indicates
        the amount of data copied into BootOptions. If the input buffer
        is too small, then BootOptionsLength indicates the required buffer
        length.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_BUFFER_TOO_SMALL     The input buffer was too small.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(BootOptions);
    UNREFERENCED_PARAMETER(BootOptionsLength);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    ULONG LocalBufferLength;
    ULONG Timeout = 0;
    ULONG BootCurrent = 0;
    ULONG BootNext = 0;
    ULONG VariableLength;
    ULONG requiredLength;

    //
    // Establish an exception handler and attempt to probe the return buffer
    // and probe and read the buffer length. If the probe attempt fails, then
    // return the exception code as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the input buffer length.
            //

            ProbeForWriteUlong(BootOptionsLength);

            LocalBufferLength = *BootOptionsLength;

            //
            // Probe the return buffer.
            //

            if (!ARGUMENT_PRESENT(BootOptions)) {
                LocalBufferLength = 0;
            }

            if (LocalBufferLength != 0) {
                ProbeForWrite((PVOID)BootOptions, LocalBufferLength, sizeof(ULONG));
            }

            //
            // Check if the current thread has the privilege to query the
            // system boot order list.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {
            LocalBufferLength = *BootOptionsLength;
            if (!ARGUMENT_PRESENT(BootOptions)) {
                LocalBufferLength = 0;
            }
        }

    //
    // If an exception occurs during the probe of the return buffer or the
    // read of the input length, then always handle the exception and return
    // the exception code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Verify that the input buffer is big enough. IA64 always returns
    // HeadlessRedirection as a null string, so we know the required
    // length up front.
    //

    requiredLength = FIELD_OFFSET(BOOT_OPTIONS,HeadlessRedirection) + sizeof(WCHAR);

    if (LocalBufferLength < requiredLength) {
        NtStatus = STATUS_BUFFER_TOO_SMALL;
        goto done;
    }

    //
    // Query the following system environment variables: Timeout, BootCurrent,
    // and BootNext.
    //
    // NB: Some machines seem to have their Timeout variable set as a ULONG
    // instead of a USHORT. Since we have ULONG buffers for the variables that
    // we're querying, we'll pass in the full length of the buffer, even though
    // we only expect to get back a USHORT. And we'll also be prepared for an
    // even bigger variable to exist. If the variable is bigger, then we'll
    // return a default value for the variable.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    VariableLength = 4;
    NtStatus = HalGetEnvironmentVariableEx(L"Timeout",
                                           &EfiBootVariablesGuid,
                                           &Timeout,
                                           &VariableLength,
                                           NULL);

    switch (NtStatus) {
    
    case STATUS_SUCCESS:
        if (VariableLength > 2) {
            if (Timeout == 0xffffffff) {
                Timeout = 0xffff;
            } else if (Timeout > 0xffff) {
                Timeout = 0xfffe;
            }
        }
        if ( Timeout == 0xffff ) {
            Timeout = 0xffffffff;
        }
        break;

    case STATUS_VARIABLE_NOT_FOUND:
        Timeout = 0xffffffff;
        break;

    case STATUS_BUFFER_TOO_SMALL:
        Timeout = 0xfffffffe;
        break;

    default:
        goto done_unlock;
    }

    VariableLength = 4;
    NtStatus = HalGetEnvironmentVariableEx(L"BootCurrent",
                                           &EfiBootVariablesGuid,
                                           &BootCurrent,
                                           &VariableLength,
                                           NULL);

    switch (NtStatus) {
    
    case STATUS_SUCCESS:
        if (VariableLength > 2) {
            BootCurrent &= 0xffff;
        }
        break;

    case STATUS_VARIABLE_NOT_FOUND:
    case STATUS_BUFFER_TOO_SMALL:
        BootCurrent = 0xfffffffe;
        break;

    default:
        goto done_unlock;
    }

    VariableLength = 2;
    NtStatus = HalGetEnvironmentVariableEx(L"BootNext",
                                           &EfiBootVariablesGuid,
                                           &BootNext,
                                           &VariableLength,
                                           NULL);

    switch (NtStatus) {
    
    case STATUS_SUCCESS:
        if (VariableLength > 2) {
            BootNext &= 0xffff;
        }
        break;

    case STATUS_VARIABLE_NOT_FOUND:
    case STATUS_BUFFER_TOO_SMALL:
        BootNext = 0xfffffffe;
        NtStatus = STATUS_SUCCESS;
        break;

    default:
        goto done_unlock;
    }

done_unlock:

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

done:

    //
    // Establish an exception handler and attempt to write the output buffer
    // and the return length. If the write attempt fails, then return the
    // exception code as the service status.
    //

    try {

        //
        // Write the output buffer.
        //

        if ((NtStatus == STATUS_SUCCESS) && ARGUMENT_PRESENT(BootOptions)) {
            BootOptions->Version = BOOT_OPTIONS_VERSION;
            BootOptions->Length = (FIELD_OFFSET(BOOT_OPTIONS,HeadlessRedirection) + sizeof(WCHAR));
            BootOptions->Timeout = Timeout;
            BootOptions->CurrentBootEntryId = BootCurrent;
            BootOptions->NextBootEntryId = BootNext;
            BootOptions->HeadlessRedirection[0] = 0;
        }

        //
        // Write the return length.
        //

        *BootOptionsLength = requiredLength;

        return NtStatus;

    //
    // If an exception occurs during the write of the return data, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtQueryBootOptions

NTSTATUS
NtSetBootOptions (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    )

/*++

Routine Description:

    This function modifies the system's global boot options.

    N.B. This service requires the system environment privilege.

Arguments:

    BootOptions - Supplies the address of the buffer that contains the new
        boot options.

    FieldsToChange - Supplies a bit mask indicating with fields in BootOptions
        are to be used to modify global boot options.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(BootOptions);
    UNREFERENCED_PARAMETER(FieldsToChange);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    ULONG LocalBufferLength;
    ULONG Timeout = 0;
    ULONG BootNext = 0;

    //
    // Establish an exception handler and attempt to probe and validate the
    // input buffer. If the probe attempt fails, then return the exception
    // code as the service status.
    //

    try {

        //
        // Verify that the input buffer is big enough. It must extend at
        // least to the HeadlessRedirection field.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            LocalBufferLength = ProbeAndReadUlong(&BootOptions->Length);
        } else {
            LocalBufferLength = BootOptions->Length;
        }

        if (LocalBufferLength < FIELD_OFFSET(BOOT_OPTIONS,HeadlessRedirection)) {
            return STATUS_INVALID_PARAMETER;
        }
    
        //
        // Get previous processor mode and probe arguments if necessary.
        //

        if (PreviousMode != KernelMode) {

            //
            // Probe the input buffer.
            //

            ProbeForRead((PVOID)BootOptions, LocalBufferLength, sizeof(ULONG));

            //
            // Check if the current thread has the privilege to query the
            // system boot order list.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        }

        //
        // Verify the structure version.
        //

        if ((BootOptions->Version == 0) ||
            (BootOptions->Version > BOOT_OPTIONS_VERSION)) {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Capture the Timeout and BootNext fields.
        //

        Timeout = BootOptions->Timeout;
        BootNext = BootOptions->NextBootEntryId;

    //
    // If an exception occurs during the probe and capture of the input buffer,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // If requested, set the Timeout and BootNext system environment variables.
    //

    if ((FieldsToChange & BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID) != 0) {
        if (BootNext > MAXUSHORT) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    NtStatus = STATUS_SUCCESS;

    if ((FieldsToChange & BOOT_OPTIONS_FIELD_TIMEOUT) != 0) {

        if (Timeout == 0xffffffff) {
            Timeout = 0xffff;
        } else if (Timeout > 0xfffe) {
            Timeout = 0xfffe;
        }

        NtStatus = HalSetEnvironmentVariableEx(L"Timeout",
                                               &EfiBootVariablesGuid,
                                               &Timeout,
                                               2,
                                               VARIABLE_ATTRIBUTE_NON_VOLATILE);
    }

    if (NT_SUCCESS(NtStatus) &&
        ((FieldsToChange & BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID) != 0)) {

        NtStatus = HalSetEnvironmentVariableEx(L"BootNext",
                                               &EfiBootVariablesGuid,
                                               &BootNext,
                                               2,
                                               VARIABLE_ATTRIBUTE_NON_VOLATILE);
    }

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    return NtStatus;

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtSetBootOptions

NTSTATUS
NtTranslateFilePath (
    IN PFILE_PATH InputFilePath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputFilePath,
    IN OUT PULONG OutputFilePathLength
    )

/*++

Routine Description:

    This function translates a FILE_PATH from one format to another.

Arguments:

    InputFilePath - Supplies the address of the buffer that contains the
        FILE_PATH that is to be translated.

    OutputType - Specifies the desired output file path type. One of
        FILE_PATH_TYPE_ARC, FILE_PATH_TYPE_ARC_SIGNATURE, FILE_PATH_TYPE_NT,
        and FILE_PATH_TYPE_EFI.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(InputFilePath);
    UNREFERENCED_PARAMETER(OutputType);
    UNREFERENCED_PARAMETER(OutputFilePath);
    UNREFERENCED_PARAMETER(OutputFilePathLength);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS status;
    KPROCESSOR_MODE PreviousMode;
    ULONG localInputPathLength;
    ULONG localOutputPathLength;
    PFILE_PATH localInputPath = NULL;
    PFILE_PATH localOutputPath;

    //
    // Verify the output type.
    //

    if ((OutputType < FILE_PATH_TYPE_MIN) ||
        (OutputType > FILE_PATH_TYPE_MAX)) {
        //DbgPrint( "NtTranslateFilePath: OutputType outside range\n" );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Establish an exception handler and attempt to probe and read the
    // input buffer, and probe the output buffer and the output length. If
    // the probe attempt fails, then return the exception code as the service
    // status.
    //

    try {

        //
        // Verify that the input buffer is big enough. It must extend at
        // least to the FilePath field.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            localInputPathLength = ProbeAndReadUlong(&InputFilePath->Length);
        } else {
            localInputPathLength = InputFilePath->Length;
        }

        if (localInputPathLength < FIELD_OFFSET(FILE_PATH,FilePath)) {
            //DbgPrint( "NtTranslateFilePath: input buffer too short\n" );
            return STATUS_INVALID_PARAMETER;
        }
    
        //
        // Get previous processor mode and probe arguments if necessary.
        //

        if (PreviousMode != KernelMode) {

            //
            // Probe the input buffer.
            //

            ProbeForRead((PVOID)InputFilePath, localInputPathLength, sizeof(ULONG));

            //
            // Probe and capture the output length.
            //

            ProbeForWriteUlong(OutputFilePathLength);

            localOutputPathLength = *OutputFilePathLength;

            //
            // Probe the output buffer.
            //

            if (!ARGUMENT_PRESENT(OutputFilePath)) {
                localOutputPathLength = 0;
            }

            if (localOutputPathLength != 0) {
                ProbeForWrite((PVOID)OutputFilePath, localOutputPathLength, sizeof(ULONG));
            }

            //
            // Check if the current thread has the privilege to query the
            // system boot order list.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {
            localOutputPathLength = *OutputFilePathLength;
            if (!ARGUMENT_PRESENT(OutputFilePath)) {
                localOutputPathLength = 0;
            }
        }

        //
        // Allocate a nonpaged buffer to hold a copy of the input buffer.
        // Copy the input buffer into the local buffer.
        //
    
        localInputPath = ExAllocatePoolWithTag(NonPagedPool, localInputPathLength, 'rvnE');
        if (localInputPath == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(localInputPath, InputFilePath, localInputPathLength);

        //
        // Allocate a nonpaged buffer into which to build the output path.
        //

        if (localOutputPathLength != 0) {
            localOutputPath = ExAllocatePoolWithTag(NonPagedPool, localOutputPathLength, 'rvnE');
            if (localOutputPath == NULL) {
                ExFreePool(localInputPath);
                localInputPath = NULL;
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            localOutputPath = NULL;
        }

    //
    // If an exception occurs during the probe and capture of the input buffer,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (localInputPath != NULL) {
            ExFreePool(localInputPath);
        }
        return GetExceptionCode();
    }

    //
    // Verify the format of the input file path.
    //

    status = ExpVerifyFilePath(localInputPath, ADD_OFFSET(localInputPath, Length));
    if (NT_SUCCESS(status)) {

        //
        // If the output type is the same as the input type, just copy the input
        // path to the output path.
        //

        if (OutputType == localInputPath->Type) {
    
            if (localOutputPathLength >= localInputPathLength) {
                RtlCopyMemory(localOutputPath, localInputPath, localInputPathLength);
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            localOutputPathLength = localInputPathLength;

        } else {
    
            //
            // Conversion is required.
            //
        
            switch (localInputPath->Type) {
            
            case FILE_PATH_TYPE_ARC:
            case FILE_PATH_TYPE_ARC_SIGNATURE:
                status = ExpTranslateArcPath(
                            localInputPath,
                            OutputType,
                            localOutputPath,
                            &localOutputPathLength
                            );
                break;
        
            case FILE_PATH_TYPE_NT:
                status = ExpTranslateNtPath(
                            localInputPath,
                            OutputType,
                            localOutputPath,
                            &localOutputPathLength);
                break;
        
            case FILE_PATH_TYPE_EFI:
                status = ExpTranslateEfiPath(
                            localInputPath,
                            OutputType,
                            localOutputPath,
                            &localOutputPathLength);
                break;
        
            default:
                ASSERT(FALSE);
                //DbgPrint( "NtTranslateFilePath: input type outside range\n" );
                status = STATUS_INVALID_PARAMETER;
                break;
            }
        }
    }

    ExFreePool(localInputPath);

    //
    // Establish an exception handler and attempt to copy to the output
    // buffer and write the output length. If the write attempt fails, then
    // return the exception code as the service status.
    //

    try {

        //
        // Copy the output path.
        //

        if (NT_SUCCESS(status) && (localOutputPath != NULL)) {
            RtlCopyMemory(OutputFilePath, localOutputPath, localOutputPathLength);
        }

        if (localOutputPath != NULL) {
            ExFreePool(localOutputPath);
            localOutputPath = NULL;
        }

        //
        // Write the output length.
        //

        if (ARGUMENT_PRESENT(OutputFilePathLength)) {
            *OutputFilePathLength = localOutputPathLength;
        }

        return status;

    //
    // If an exception occurs during the write of the return data, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (localOutputPath != NULL) {
            ExFreePool(localOutputPath);
        }
        return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtTranslateFilePath

NTSTATUS
ExpSetBootEntry (
    IN LOGICAL CreateNewEntry,
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    )

/*++

Routine Description:

    This function adds a boot entry to the system environment or modifies
    an existing boot entry. It is a local routine called by NtAddBootEntry
    and NtModifyBootEntry.

    N.B. This function requires the system environment privilege.

Arguments:

    CreateNewEntry - Indicates whether this function is to add a new boot
        entry (TRUE - NtAddBootEntry), or modify an existing boot entry
        (FALSE - NtModifyBootEntry).
    BootEntry - Supplies the address of a BOOT_ENTRY that describes the
        new boot entry.

    Id - Supplies the address of a ULONG that is to receive the identifier
        assigned to the new boot entry.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(CreateNewEntry);
    UNREFERENCED_PARAMETER(BootEntry);
    UNREFERENCED_PARAMETER(Id);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    PBOOT_ENTRY localBootEntry = NULL;
    ULONG LocalBufferLength;
    PUCHAR MaxBuffer;
    ULONG id = 0;
    WCHAR idString[9];
    PWCHAR friendlyName;
    ULONG friendlyNameLength;
    PFILE_PATH bootFilePath = NULL;
    PFILE_PATH translatedBootFilePath = NULL;
    LOGICAL isWindowsOs;
    PWINDOWS_OS_OPTIONS windowsOsOptions;
    PFILE_PATH windowsFilePath;
    PEFI_LOAD_OPTION efiLoadOption = NULL;
    PUCHAR efiBootFilePath;
    ULONG efiBootFilePathLength;
    ULONG efiWindowsFilePathLength;
    ULONG osOptionsLength;
    ULONG length;
    ULONG requiredLength;
    PUCHAR efiOsOptions;

    //
    // Establish an exception handler and attempt to probe and read the
    // input buffer, and probe the output identifier parameter. If the probe
    // attempt fails, then return the exception code as the service status.
    //

    try {

        //
        // Verify that the input buffer is big enough. It must extend at
        // least to the OsOptions field.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            LocalBufferLength = ProbeAndReadUlong(&BootEntry->Length);
        } else {
            LocalBufferLength = BootEntry->Length;
        }

        if (LocalBufferLength < FIELD_OFFSET(BOOT_ENTRY,OsOptions)) {
            return STATUS_INVALID_PARAMETER;
        }
    
        //
        // Get previous processor mode and probe arguments if necessary.
        //

        if (PreviousMode != KernelMode) {

            //
            // Probe the input buffer.
            //

            ProbeForRead((PVOID)BootEntry, LocalBufferLength, sizeof(ULONG));

            //
            // Probe the output identifier.
            //

            if (ARGUMENT_PRESENT(Id)) {
                ProbeForWriteUlong(Id);
            }

            //
            // Check if the current thread has the privilege to query the
            // system boot order list.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        }

        //
        // Allocate a nonpaged buffer to hold a copy of the input buffer.
        // Copy the input buffer into the local buffer.
        //
    
        localBootEntry = ExAllocatePoolWithTag(NonPagedPool, LocalBufferLength, 'rvnE');
        if (localBootEntry == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(localBootEntry, BootEntry, LocalBufferLength);

    //
    // If an exception occurs during the probe and capture of the input buffer,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (localBootEntry != NULL) {
            ExFreePool(localBootEntry);
        }
        return GetExceptionCode();
    }

    //
    // Calculate the address of the byte above the end of the local buffer.
    //

    MaxBuffer = (PUCHAR)localBootEntry + LocalBufferLength;

    //
    // Verify the structure version.
    //

    if ((localBootEntry->Version == 0) ||
        (localBootEntry->Version > BOOT_ENTRY_VERSION)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // If modifying an existing entry, verify that the input identifier is
    // in range.
    //

    if (!CreateNewEntry && (localBootEntry->Id > MAXUSHORT)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // Ignore boot entry attributes that can't be set.
    //

    localBootEntry->Attributes &= BOOT_ENTRY_ATTRIBUTE_VALID_BITS;

    //
    // Verify that offsets are aligned correctly.
    //

    if (((localBootEntry->FriendlyNameOffset & (sizeof(WCHAR) - 1)) != 0) ||
        ((localBootEntry->BootFilePathOffset & (sizeof(ULONG) - 1)) != 0)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // Verify that OsOptions doesn't extend beyond the end of the buffer.
    //

    if ((localBootEntry->OsOptionsLength > LocalBufferLength) ||
        ((localBootEntry->OsOptions + localBootEntry->OsOptionsLength) >= MaxBuffer)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // If the OsOptions are for a Windows operating system, verify them.
    //

    windowsOsOptions = (PWINDOWS_OS_OPTIONS)localBootEntry->OsOptions;

    if ((localBootEntry->OsOptionsLength >= FIELD_OFFSET(WINDOWS_OS_OPTIONS,Version)) &&
        (strcmp((char *)windowsOsOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) == 0)) {

        if (localBootEntry->OsOptionsLength <= FIELD_OFFSET(WINDOWS_OS_OPTIONS,OsLoadOptions)) {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto done;
        }

        NtStatus = ExpVerifyWindowsOsOptions(windowsOsOptions,
                                          localBootEntry->OsOptionsLength);
        if (!NT_SUCCESS(NtStatus)) {
            goto done;
        }

        isWindowsOs = TRUE;
        windowsFilePath = ADD_OFFSET(windowsOsOptions, OsLoadPathOffset);

    } else {

        isWindowsOs = FALSE;
        windowsFilePath = NULL; // keep the compiler quiet
    }

    //
    // Verify that FriendlyName doesn't extend beyond the end of the buffer.
    //

    friendlyName = ADD_OFFSET(localBootEntry, FriendlyNameOffset);
    if ((friendlyNameLength = ExpSafeWcslen(friendlyName, (PWSTR)MaxBuffer)) == 0xffffffff) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // Convert friendlyNameLength from a character count into a byte count,
    // including the null terminator.
    //

    friendlyNameLength = (friendlyNameLength + 1) * sizeof(WCHAR);

    //
    // Verify that BootFilePath is valid and doesn't extend beyond the end of
    // the buffer.
    //

    bootFilePath = ADD_OFFSET(localBootEntry, BootFilePathOffset);
    NtStatus = ExpVerifyFilePath(bootFilePath, MaxBuffer);
    if (!NT_SUCCESS(NtStatus)) {
        goto done;
    }

    //
    // Verify that OsOptions doesn't encroach into FriendlyName, and that
    // FriendlyName doesn't encroach into BootFilePath.
    //

    if (((localBootEntry->OsOptions + localBootEntry->OsOptionsLength) > (PUCHAR)friendlyName) ||
        (((PUCHAR)friendlyName + friendlyNameLength) > (PUCHAR)bootFilePath)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // The format of the input buffer has been validated. Build the variable value
    // that will be stored in NVRAM. Begin by determining the lengths of the file
    // paths that will be stored. If the caller provided the paths in non-EFI
    // format, they need to be translated.
    //

    if (bootFilePath->Type != FILE_PATH_TYPE_EFI) {
        efiBootFilePathLength = 0;
        NtStatus = ZwTranslateFilePath(bootFilePath,
                                       FILE_PATH_TYPE_EFI,
                                       NULL,
                                       &efiBootFilePathLength);
        if (NtStatus != STATUS_BUFFER_TOO_SMALL) {
            goto done;
        }
        translatedBootFilePath = ExAllocatePoolWithTag(NonPagedPool,
                                                       efiBootFilePathLength,
                                                       'rvnE');
        if (translatedBootFilePath == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto done;
        }
        RtlZeroMemory(translatedBootFilePath, efiBootFilePathLength);
        length = efiBootFilePathLength;
        NtStatus = ZwTranslateFilePath(bootFilePath,
                                       FILE_PATH_TYPE_EFI,
                                       translatedBootFilePath,
                                       &length);
        if (!NT_SUCCESS(NtStatus)) {
            goto done;
        }
        if (length != efiBootFilePathLength) {
            NtStatus = STATUS_UNSUCCESSFUL;
        }
    } else {
        efiBootFilePathLength = bootFilePath->Length;
        translatedBootFilePath = bootFilePath;
    }

    efiBootFilePathLength = efiBootFilePathLength - FIELD_OFFSET(FILE_PATH, FilePath);

    efiWindowsFilePathLength = 0;
    if (isWindowsOs &&
        (windowsFilePath->Type != FILE_PATH_TYPE_EFI)) {
        NtStatus = ZwTranslateFilePath(windowsFilePath,
                                       FILE_PATH_TYPE_EFI,
                                       NULL,
                                       &efiWindowsFilePathLength);
        if (NtStatus != STATUS_BUFFER_TOO_SMALL) {
            goto done;
        }
        osOptionsLength = localBootEntry->OsOptionsLength -
                            windowsFilePath->Length + efiWindowsFilePathLength;
    } else {
        osOptionsLength = localBootEntry->OsOptionsLength;
    }

    //
    // Calculate the length required for the variable value.
    //

    requiredLength = FIELD_OFFSET(EFI_LOAD_OPTION, Description);
    requiredLength += friendlyNameLength;
    requiredLength += efiBootFilePathLength;
    requiredLength += osOptionsLength;

    //
    // Allocate a buffer to hold the variable value.
    //

    efiLoadOption = ExAllocatePoolWithTag(NonPagedPool, requiredLength, 'rvnE');
    if (efiLoadOption == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }
    RtlZeroMemory(efiLoadOption, requiredLength);

    //
    // Build the variable value.
    //

    efiLoadOption->Attributes = 0;
    if ((localBootEntry->Attributes & BOOT_ENTRY_ATTRIBUTE_ACTIVE) != 0) {
        efiLoadOption->Attributes = LOAD_OPTION_ACTIVE;
    }

    efiLoadOption->FilePathLength = (USHORT)efiBootFilePathLength;

    memcpy(efiLoadOption->Description, friendlyName, friendlyNameLength);

    efiBootFilePath = (PUCHAR)((PUCHAR)efiLoadOption->Description + friendlyNameLength);
    memcpy(efiBootFilePath, translatedBootFilePath->FilePath, efiBootFilePathLength);

    efiOsOptions = efiBootFilePath + efiBootFilePathLength;
    if (isWindowsOs &&
        (windowsFilePath->Type != FILE_PATH_TYPE_EFI)) {

        PFILE_PATH efiWindowsFilePath;

        memcpy(efiOsOptions, windowsOsOptions, windowsOsOptions->OsLoadPathOffset);
        ((WINDOWS_OS_OPTIONS UNALIGNED *)efiOsOptions)->Length = osOptionsLength;

        efiWindowsFilePath = (PFILE_PATH)(efiOsOptions + windowsOsOptions->OsLoadPathOffset);
        length = efiWindowsFilePathLength;
        NtStatus = ZwTranslateFilePath(windowsFilePath,
                                       FILE_PATH_TYPE_EFI,
                                       efiWindowsFilePath,
                                       &efiWindowsFilePathLength);
        if (NtStatus != STATUS_SUCCESS) {
            goto done;
        }
        if (length != efiWindowsFilePathLength) {
            NtStatus = STATUS_UNSUCCESSFUL;
        }

    } else {

        memcpy(efiOsOptions, localBootEntry->OsOptions, osOptionsLength);
    }

    //
    // If CreateNewEntry is true, then find an unused identifier to assign to
    // this boot entry. If CreateNewEntry is false, then verify that the
    // provided identifier exists.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    if (CreateNewEntry) {

        for ( id = 0; id <= MAXUSHORT; id++ ) {
            swprintf( idString, L"Boot%04x", id);
            length = 0;
            NtStatus = HalGetEnvironmentVariableEx(idString,
                                                   &EfiBootVariablesGuid,
                                                   NULL,
                                                   &length,
                                                   NULL);
            if (NtStatus == STATUS_VARIABLE_NOT_FOUND) {
                break;
            }
            if ((NtStatus != STATUS_SUCCESS) && (NtStatus != STATUS_BUFFER_TOO_SMALL)) {
                goto done_unlock;
            }
        }

        if (id > MAXUSHORT) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto done_unlock;
        }

    } else {

        id = localBootEntry->Id;
        swprintf( idString, L"Boot%04x", localBootEntry->Id);
        length = 0;
        NtStatus = HalGetEnvironmentVariableEx(idString,
                                               &EfiBootVariablesGuid,
                                               NULL,
                                               &length,
                                               NULL);
        if ((NtStatus != STATUS_SUCCESS) && (NtStatus != STATUS_BUFFER_TOO_SMALL)) {
            goto done_unlock;
        }
    }

    //
    // Set or update the boot entry environment variable.
    //

    NtStatus = HalSetEnvironmentVariableEx(idString,
                                           &EfiBootVariablesGuid,
                                           efiLoadOption,
                                           requiredLength,
                                           VARIABLE_ATTRIBUTE_NON_VOLATILE);

done_unlock:

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

done:

    if (efiLoadOption != NULL) {
        ExFreePool(efiLoadOption);
    }

    if ((translatedBootFilePath != NULL) && (translatedBootFilePath != bootFilePath)) {
        ExFreePool(translatedBootFilePath);
    }

    ExFreePool(localBootEntry);

    //
    // Establish an exception handler and attempt to write the return
    // identifier. If the write attempt fails, then return the exception
    // code as the service status.
    //

    try {

        //
        // Write the return identifier.
        //

        if (CreateNewEntry && ARGUMENT_PRESENT(Id) && NT_SUCCESS(NtStatus)) {
            *Id = id;
        }

        return NtStatus;

    //
    // If an exception occurs during the write of the return data, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // ExpSetBootEntry

//
// The remainder of this module is routines that are only compiled when
// EFI_NVRAM_ENABLED is defined.
//

#if defined(EFI_NVRAM_ENABLED)

ULONG
ExpSafeWcslen (
    IN PWSTR String,
    IN PWSTR Max
    )
{
    PWSTR p = String;
    
    while ((p < Max) && (*p != 0)) {
        p++;
    }

    if (p < Max) {
        return (ULONG)(p - String);
    }

    return 0xffffffff;

} // ExpSafeWcslen

NTSTATUS
ExpTranslateArcPath (
    IN PFILE_PATH InputPath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength
    )
{
#if 0
    UNREFERENCED_PARAMETER(InputPath);
    UNREFERENCED_PARAMETER(OutputType);
    UNREFERENCED_PARAMETER(OutputPath);
    UNREFERENCED_PARAMETER(OutputPathLength);
    return STATUS_NOT_IMPLEMENTED;
#endif

    PWSTR deviceName, pathName;
    ULONG deviceNameCount;
    BOOLEAN signatureFormat;
    NTSTATUS status;

    //
    // Possible Arc Path formats
    // signature(<guid/signature>-<part#>-<start>-<size>)[\filePart]
    // signature(<guid>)[\filePart]
    // multi(0)disk(0)fdisk(0)[\filePart]
    // multi(0)disk(0)rdisk(0)[\filePart]
    // multi(0)disk(0)rdisk(0)partition(0)[\filePart]
    //

    //
    // Determine if ArcName has signature() format
    // Parse out DeviceName & FilePart
    //
    status = ExpParseArcPathName (
                (PWSTR)(InputPath->FilePath),
                &deviceName,
                &pathName,
                &deviceNameCount,
                &signatureFormat
                );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // not signature() format
    //
    if( signatureFormat == FALSE ) {
        if( InputPath->Type != FILE_PATH_TYPE_ARC ) {
            return( STATUS_INVALID_PARAMETER );
        }

        status = ExpConvertArcName(
                    OutputType,
                    OutputPath,
                    OutputPathLength,
                    deviceName,
                    pathName,
                    deviceNameCount
                    );

        return( status );
    }

    //
    // This arc signature() format should be FILE_PATH_TYPE_ARC_SIGNATURE
    //
    if( InputPath->Type != FILE_PATH_TYPE_ARC_SIGNATURE ) {
       return( STATUS_INVALID_PARAMETER );
    }

    status = ExpConvertSignatureName(
                    OutputType,
                    OutputPath,
                    OutputPathLength,
                    deviceName,
                    pathName,
                    deviceNameCount
                    );

    return( status );
} // ExpTranslateArcPath

NTSTATUS
ExpTranslateEfiPath (
    IN PFILE_PATH InputPath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength
    )
{
    NTSTATUS status;
    HARDDRIVE_DEVICE_PATH *dpHarddrive = NULL;
    ULONG requiredLength;
    UNICODE_STRING guidString;
    UNICODE_STRING deviceNameString;
    PWSTR linkName, pPathName;
    BOOLEAN GPTpartition;
    ULONG partitionNumber, diskNumber;
    ULONGLONG partitionStart, partitionSize;


    //
    // Find the MEDIA/HARDDRIVE and MEDIA/FILEPATH elements in the device
    // path. Note that although EFI allows multiple device paths to appear
    // in a single device path (as in the PATH variable), we only look at
    // the first one.
    //

    status = ExpParseEfiPath(
                (EFI_DEVICE_PATH *)InputPath->FilePath,
                &dpHarddrive,
                &pPathName,
                &GPTpartition
                );

    if( !NT_SUCCESS( status ) ) {
        return( status );
    }

    //
    // If the target type is ARC_SIGNATURE, then we have all of the
    // information we need. Otherwise, we need to find the NT device
    // with the given signature.
    //

    if ( OutputType == FILE_PATH_TYPE_ARC_SIGNATURE ) {

        partitionNumber = dpHarddrive->PartitionNumber;
        partitionStart = dpHarddrive->PartitionStart;
        partitionSize = dpHarddrive->PartitionSize;
        status = ExpCreateOutputSIGNATURE(
                    OutputPath,
                    OutputPathLength,
                    (PDISK_SIGNATURE_NEW)(dpHarddrive->Signature),
                    &(partitionNumber),
                    &(partitionStart),
                    &(partitionSize),
                    pPathName,
                    GPTpartition
                    );
        if( pPathName != NULL ) {
            ExFreePool( pPathName );
        }

        ExFreePool(dpHarddrive);

        return( status );

    }

    //
    // OutputType is ARC or NT. Find the NT device for this device path.
    // For a GPT partition, this is done by translating the symbolic name
    // \??\Volume{<guid>} which will link to \Device\HarddiskVolume<n>.
    //
    status = STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // Quick path for GPT disk
    // Translate the symbolic link \??\Volume{<guid>}.
    //
    // First, get the GUID in "pretty" format. Then allocate a buffer to hold
    // the full name string and create that string. Then translate the
    // symbolic name.
    //
    // NB: Because the mount manager doesn't create a symbolic link like this
    //     for the EFI system partition, this routine cannot be used to
    //     translate an EFI device path for the system partition to an NT path.
    //
    if( GPTpartition == TRUE ) {

        status = RtlStringFromGUID( (LPGUID)dpHarddrive->Signature, &guidString );
        if ( !NT_SUCCESS(status) ) {
            if( pPathName != NULL ) {
                ExFreePool( pPathName );
            }

            ExFreePool(dpHarddrive);

            return status;
        }

#define LINK_NAME_PREFIX L"\\??\\Volume"

        requiredLength = ((ULONG)wcslen( LINK_NAME_PREFIX ) + 1) * sizeof(WCHAR);
        requiredLength += guidString.Length;
        linkName = ExAllocatePoolWithTag( NonPagedPool, requiredLength, 'rvnE' );
        if ( linkName == NULL ) {
            ExFreePool( guidString.Buffer );
            if( pPathName != NULL ) {
                ExFreePool( pPathName );
            }
            
            ExFreePool(dpHarddrive);

            return STATUS_INSUFFICIENT_RESOURCES;
        }
        wcscpy( linkName, LINK_NAME_PREFIX );
        wcscat( linkName, guidString.Buffer );
        ExFreePool( guidString.Buffer );

        status = ExpTranslateSymbolicLink(
            linkName,
            &deviceNameString
            );
        ExFreePool( linkName );
    }

    //
    // check if the quick path was not taken or no object was found
    //
    if ( !NT_SUCCESS(status) ) {

        //
        // long path, opens all disks in search of the signature
        //
        partitionNumber = dpHarddrive->PartitionNumber;
        status = ExpFindDiskSignature(
                    (PDISK_SIGNATURE_NEW)(dpHarddrive->Signature),
                    &partitionNumber,
                    &diskNumber,
                    &partitionStart,
                    &partitionSize,
                    GPTpartition
                    );

        if ( !NT_SUCCESS(status) ) {
            if( pPathName != NULL ) {
                ExFreePool( pPathName );
            }

            ExFreePool(dpHarddrive);

            return status;
        }

        //
        // The user has provided the partition number, start address,
        // and size; so verify the input with the found results.
        //
        if( (dpHarddrive->PartitionNumber != partitionNumber) ||
            (dpHarddrive->PartitionStart != partitionStart) ||
            (dpHarddrive->PartitionSize != partitionSize) ) {

            if( pPathName != NULL ) {
                ExFreePool( pPathName );
            }
            
            ExFreePool(dpHarddrive);

            return( STATUS_INVALID_PARAMETER );
        }

        //
        // create the NT disk Symbolic link name
        // \Device\Harddisk[diskNumber]\Partition[PartitionNumber]
        //
#define NT_DISK_NAME_FORMAT L"\\Device\\Harddisk%lu\\Partition%lu"
#define NT_DISK_NAME_COUNT 47    // 7 + 9 + (10) + 10 + (10) + 1

        linkName = ExAllocatePoolWithTag(
                        NonPagedPool,
                        ( NT_DISK_NAME_COUNT * sizeof( WCHAR ) ),
                        'rvnE'
                        );

        if( linkName == NULL ) {
            if( pPathName != NULL ) {
                ExFreePool( pPathName );
            }
            
            ExFreePool(dpHarddrive);

            return( STATUS_INSUFFICIENT_RESOURCES );
        }

        _snwprintf(
            linkName,
            NT_DISK_NAME_COUNT,
            NT_DISK_NAME_FORMAT,
            diskNumber,
            partitionNumber
            );

        status = ExpTranslateSymbolicLink(
            linkName,
            &deviceNameString
            );
        ExFreePool( linkName );
        if( !NT_SUCCESS(status) ) {
            if( pPathName != NULL ) {
                ExFreePool( pPathName );
            }
            
            ExFreePool(dpHarddrive);

            return( status );
        }
    }

    //
    // We now have the NT name of the device. If the target type is NT, then
    // we have all of the information we need.
    //
    if ( OutputType == FILE_PATH_TYPE_NT ) {

        status = ExpCreateOutputNT(
                    OutputPath,
                    OutputPathLength,
                    &deviceNameString,
                    pPathName
                    );
        ExFreePool( deviceNameString.Buffer );
        if( pPathName != NULL ) {
            ExFreePool( pPathName );
        }
        
        ExFreePool(dpHarddrive);

        return( status );
    }

    //
    // The output type is ARC.
    //
    status = ExpCreateOutputARC(
                    OutputPath,
                    OutputPathLength,
                    &deviceNameString,
                    pPathName
                    );
    ExFreePool( deviceNameString.Buffer );
    if( pPathName != NULL ) {
        ExFreePool( pPathName );
    }

    ExFreePool(dpHarddrive);

    return( status );

} // ExpTranslateEfiPath

NTSTATUS
ExpTranslateNtPath (
    IN PFILE_PATH InputPath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength
    )

{
    NTSTATUS status;
    UNICODE_STRING string, deviceNameString;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    HANDLE handle;
    PARTITION_INFORMATION_EX partitionInfo;
    PDRIVE_LAYOUT_INFORMATION_EX driveLayoutInfo = NULL;
    ULONG driveLayoutLength;
    PWSTR deviceName, pathName;
    ULONG pathNameLength;
    ULONG signatureMBR = 0;
    PDISK_SIGNATURE_NEW pDiskSignature;
    BOOLEAN TranslatedSymLink = TRUE;
    BOOLEAN GPTpartition;


    deviceName = (PWSTR)InputPath->FilePath;
    RtlInitUnicodeString( &string, deviceName );
    pathName = (PWSTR)((PUCHAR)deviceName + string.Length + sizeof(WCHAR));
    pathNameLength = (ULONG)wcslen(pathName);
    if (pathNameLength == 0) {
        pathName = NULL;
    }

    //
    // For output type Arc,
    // attempt drill down NT name
    // if NT object exists
    //      match with symlink in \ArcName
    //
    if (OutputType == FILE_PATH_TYPE_ARC) {
        status = ExpTranslateSymbolicLink(
                    deviceName,
                    &deviceNameString
                    );
        if (!NT_SUCCESS(status)) {
            //
            // If non-symlink NT name exists as an object in the NT namespace,
            //    then the return code will be STATUS_OBJECT_TYPE_MISMATCH
            //    else the return code will be STATUS_OBJECT_NAME_NOT_FOUND
            //
            if (status != STATUS_OBJECT_TYPE_MISMATCH) {
                return( status );
            }
            deviceNameString.Buffer = string.Buffer;
            deviceNameString.Length = string.Length;
            deviceNameString.MaximumLength = string.MaximumLength;
            TranslatedSymLink = FALSE;
        }
        status = ExpCreateOutputARC(
                    OutputPath,
                    OutputPathLength,
                    &deviceNameString,
                    pathName
                    );
        if (TranslatedSymLink == TRUE) {
            ExFreePool( deviceNameString.Buffer );
        }
        return( status );
    }

    //
    // Open the target partition and get its partition information.
    //

    InitializeObjectAttributes(
        &obja,
        &string,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    status = ZwOpenFile(
                &handle,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &obja,
                &iosb,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_NON_DIRECTORY_FILE
                );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = ZwDeviceIoControlFile(
                handle,
                NULL,
                NULL,
                NULL,
                &iosb,
                IOCTL_DISK_GET_PARTITION_INFO_EX,
                NULL,
                0,
                &partitionInfo,
                sizeof(partitionInfo)
                );
    if (!NT_SUCCESS(status)) {
        ZwClose(handle);
        return status;
    }

    if ((partitionInfo.PartitionStyle != PARTITION_STYLE_MBR) &&
        (partitionInfo.PartitionStyle != PARTITION_STYLE_GPT)) {
        ZwClose(handle);
        return STATUS_UNRECOGNIZED_MEDIA;
    }

    if (partitionInfo.PartitionStyle == PARTITION_STYLE_MBR) {

        driveLayoutLength = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry) +
                                (sizeof(PARTITION_INFORMATION_EX) * 16);

        while (TRUE) {

            driveLayoutInfo = ExAllocatePoolWithTag(NonPagedPool, driveLayoutLength, 'rvnE');
            if (driveLayoutInfo == NULL ) {
                ZwClose(handle);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            status = ZwDeviceIoControlFile(
                        handle,
                        NULL,
                        NULL,
                        NULL,
                        &iosb,
                        IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                        NULL,
                        0,
                        driveLayoutInfo,
                        driveLayoutLength
                        );
            if (NT_SUCCESS(status)) {
                break;
            }
            ExFreePool(driveLayoutInfo);
            if (status == STATUS_BUFFER_TOO_SMALL) {
                driveLayoutLength *= 2;
                continue;
            }
            ZwClose(handle);
            return status;
        }

        if (NT_SUCCESS(status)) {
            signatureMBR = driveLayoutInfo->Mbr.Signature;
            ExFreePool(driveLayoutInfo);
        }
    }

    ZwClose(handle);

    if (partitionInfo.PartitionStyle == PARTITION_STYLE_GPT) {
        pDiskSignature = (PDISK_SIGNATURE_NEW)(&(partitionInfo.Gpt.PartitionId));
        GPTpartition = TRUE;
    } else {
        pDiskSignature = (PDISK_SIGNATURE_NEW)(&signatureMBR);
        GPTpartition = FALSE;
    }

    if (OutputType == FILE_PATH_TYPE_EFI) {

        status = ExpCreateOutputEFI(
                    OutputPath,
                    OutputPathLength,
                    pDiskSignature,
                    &(partitionInfo.PartitionNumber),
                    (PULONGLONG)(&(partitionInfo.StartingOffset.QuadPart)),
                    (PULONGLONG)(&(partitionInfo.PartitionLength.QuadPart)),
                    pathName,
                    GPTpartition
                    );
        return( status );
    }

    //
    // OutputType is ARC_SIGNATURE
    //
    status = ExpCreateOutputSIGNATURE(
                    OutputPath,
                    OutputPathLength,
                    pDiskSignature,
                    &(partitionInfo.PartitionNumber),
                    (PULONGLONG)(&(partitionInfo.StartingOffset.QuadPart)),
                    (PULONGLONG)(&(partitionInfo.PartitionLength.QuadPart)),
                    pathName,
                    GPTpartition
                    );
    return( status );

} // ExpTranslateNtPath


LOGICAL
ExpTranslateBootEntryNameToId (
    IN PWSTR Name,
    OUT PULONG Id
    )
{
    ULONG number;
    ULONG i;
    WCHAR c;

    if ((towlower(Name[0]) != 'b') ||
        (towlower(Name[1]) != 'o') ||
        (towlower(Name[2]) != 'o') ||
        (towlower(Name[3]) != 't') ) {
        return FALSE;
    }

    number = 0;
    for (i = 4; i < 8; i++) {
        c = towlower(Name[i]);
        if ((c >= L'0') && (c <= L'9')) {
            number = (number * 16) + (c - L'0');
        } else if ((c >= L'a') && (c <= L'f')) {
            number = (number * 16) + (c - L'a' + 10);
        } else {
            return FALSE;
        }
    }

    if (Name[8] != 0) {
        return FALSE;
    }

    *Id = number;
    return TRUE;

} // ExpTranslateBootEntryNameToId

NTSTATUS
ExpTranslateSymbolicLink (
    IN PWSTR LinkName,
    OUT PUNICODE_STRING ResultName
    )

/*++

Routine Description:

    This routine translates the input symbolic link name by drilling down
    through symbolic links until it finds an object that is not a link.

Arguments:

    LinkName - Supplies the name of the link at which to start translating.

    ResultName - Supplies the address of a UNICODE_STRING descriptor that
        will receive the result name. The storage for the result name is
        allocated from nonpaged pool using ExAllocatePool.

Return Value:

    STATUS_SUCCESS is returned if the input name was a symbolic link and
        all translations completely successfully.
    Failure codes will be returned if the input name was not a link, if
        translations failed, or if allocation of the output buffer failed.

--*/

{
    NTSTATUS status;
    UNICODE_STRING linkString;
    UNICODE_STRING resultString;
    PWSTR resultBuffer;
    ULONG resultBufferLength;
    ULONG requiredLength;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE handle;

    resultBuffer = NULL;
    resultBufferLength = sizeof(WCHAR);

    //
    // Open the input link.
    //

    RtlInitUnicodeString( &linkString, LinkName );

    InitializeObjectAttributes(
        &objectAttributes,
        &linkString,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    status = ZwOpenSymbolicLinkObject(
                &handle,
                (ACCESS_MASK)SYMBOLIC_LINK_QUERY,
                &objectAttributes
                );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    while ( TRUE ) {

        while ( TRUE ) {

            //
            // Get the translation for this link, allocating more
            // space as needed.
            //
    
            resultString.Length = 0;
            resultString.MaximumLength = (USHORT)(resultBufferLength - sizeof(WCHAR));
            resultString.Buffer = resultBuffer;
    
            status = ZwQuerySymbolicLinkObject(
                        handle,
                        &resultString,
                        &requiredLength
                        );

            if ( status != STATUS_BUFFER_TOO_SMALL ) {
                break;
            }

            //
            // The buffer was too small. Reallocate it, allowing room for a
            // null terminator, which might not be present in the translation,
            // and try again.
            //

            if ( resultBuffer != NULL ) {
                ExFreePool( resultBuffer );
            }
            resultBufferLength = requiredLength + sizeof(WCHAR);
            resultBuffer = ExAllocatePoolWithTag( NonPagedPool, resultBufferLength, 'rvnE' );
            if ( resultBuffer == NULL ) {
                ZwClose( handle );
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        //
        // Translation done. Close the link. If translation failed, return
        // the failure status.
        //

        ZwClose( handle );

        if (!NT_SUCCESS(status)) {
            if ( resultBuffer != NULL) {
                ExFreePool( resultBuffer );
            }
            return status;
        }

        //
        // Terminate the result string, in case it wasn't already terminated.
        //

        resultBuffer[resultString.Length / sizeof(WCHAR)] = UNICODE_NULL;
        resultString.MaximumLength = (USHORT)(resultBufferLength);

        //
        // See if the result name is also a symbolic name. Try to open it
        // as a link. If this fails, then break out of the loop and return
        // this name as the result.
        //

        RtlInitUnicodeString( &linkString, resultBuffer );

        InitializeObjectAttributes(
            &objectAttributes,
            &linkString,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

        status = ZwOpenSymbolicLinkObject(
                    &handle,
                    (ACCESS_MASK)SYMBOLIC_LINK_QUERY,
                    &objectAttributes
                    );

        if ( !NT_SUCCESS(status) ) {
            break;
        }

        //
        // This name is also a symbolic link. Loop back and translate it.
        //

    }

    //
    // Set up the return string to point to the final result.
    //

    *ResultName = resultString;

    return STATUS_SUCCESS;

} // ExpTranslateSymbolicLink

LOGICAL
ExpIsDevicePathForRemovableMedia (
    EFI_DEVICE_PATH *DevicePath
    )

/*++

Routine Description:

    This routine determines whether an EFI device path represents a non-file
    specific pointer to a removable media device. It make this determination
    based on finding a HARDWARE/VENDOR device path element, and NOT finding
    MEDIA/HARDDRIVE and MEDIA/FILEPATH elements. When the EFI boot manager
    boot such a device path, it looks in a default location for the file to
    be loaded (\EFI\BOOT\BOOT<arch>.EFI).

    We want to identify these removable media device paths because we do not
    want to put our NT boot entries ahead of removable media entries in the
    boot order, if those removable media entries are at the front of the list.
    This allows an x86-like boot order to be set up: floppy first, then CD,
    then NT boot entries.

Arguments:

    DevicePath - Supplies the device path to be checked.

Return Value:

    TRUE is returned if the device path has a HARDWARE/VENDOR element, AND
        that element has the UNKNOWN_DEVICE_GUID, AND the device path does
        NOT have a MEDIA/HARDDRIVE element, AND the device path does NOT
        have a MEDIA/FILEPATH element.

--*/

{
    EFI_DEVICE_PATH *dp = DevicePath;
    VENDOR_DEVICE_PATH UNALIGNED *vdp;
    VENDOR_DEVICE_PATH UNALIGNED *vendorDp = NULL;
    HARDDRIVE_DEVICE_PATH UNALIGNED *harddriveDp = NULL;
    FILEPATH_DEVICE_PATH UNALIGNED *filepathDp = NULL;

    //
    // Walk the device path, looking for elements that we care about.
    //

    while (TRUE) {

        if (IsDevicePathEndType(dp)) {
            break;
        }

        if (DevicePathType(dp) == HARDWARE_DEVICE_PATH) {
            if (DevicePathSubType(dp) == HW_VENDOR_DP) {

                //
                // Found a HARDWARE/VENDOR element. If it has the
                // UNKNOWN_DEVICE_GUID, remember that we found it.
                //

                vdp = (VENDOR_DEVICE_PATH UNALIGNED *)dp;
                if ( memcmp( &vdp->Guid, &ExpUnknownDeviceGuid, 16 ) == 0 ) {
                    vendorDp = vdp;
                }
            }

        } else if (DevicePathType(dp) == MEDIA_DEVICE_PATH) {

            if (DevicePathSubType(dp) == MEDIA_HARDDRIVE_DP) {

                //
                // Found a MEDIA/HARDDRIVE element. Remember it.
                //

                harddriveDp = (HARDDRIVE_DEVICE_PATH *)dp;

            } else if (DevicePathSubType(dp) == MEDIA_FILEPATH_DP) {

                //
                // Found a MEDIA/FILEPATH element. Remember it.
                //

                filepathDp = (FILEPATH_DEVICE_PATH *)dp;
            }
        }

        dp = NextDevicePathNode(dp);
    }

    //
    // If we didn't find a HARDWARE/VENDOR element, or if we did find either
    // a MEDIA/HARDDRIVE element or a MEDIA/FILEPATH element, then this is
    // not a removable media device path.
    //

    if ((vendorDp == NULL) || (harddriveDp != NULL) || (filepathDp != NULL)) {
        return FALSE;
    }

    return TRUE;

} // ExpIsDevicePathForRemovableMedia

NTSTATUS
ExpVerifyFilePath (
    PFILE_PATH FilePath,
    PUCHAR Max
    )
{
    EFI_DEVICE_PATH *dp;
    PUCHAR dpMax;
    ULONG length;
    PWSTR p;

    if (((PUCHAR)FilePath > Max) ||
        (((PUCHAR)FilePath + FIELD_OFFSET(FILE_PATH, FilePath)) > Max) ||
        (FilePath->Length < FIELD_OFFSET(FILE_PATH, FilePath)) ||
        (((PUCHAR)FilePath + FilePath->Length) < (PUCHAR)FilePath) ||
        (((PUCHAR)FilePath + FilePath->Length) > Max) ||
        (FilePath->Version == 0) ||
        (FilePath->Version > FILE_PATH_VERSION) ||
        (FilePath->Type < FILE_PATH_TYPE_MIN) ||
        (FilePath->Type > FILE_PATH_TYPE_MAX)) {
        //DbgPrint( "ExpVerifyFilePath: file path invalid\n" );
        return STATUS_INVALID_PARAMETER;
    }

    switch (FilePath->Type) {
    
    case FILE_PATH_TYPE_ARC:
    case FILE_PATH_TYPE_ARC_SIGNATURE:
        if (ExpSafeWcslen((PWCHAR)FilePath->FilePath, (PWCHAR)Max) == 0xffffffff) {
            //DbgPrint( "ExpVerifyFilePath: ARC string overruns buffer end\n" );
            return STATUS_INVALID_PARAMETER;
        }
        break;

    case FILE_PATH_TYPE_NT:
        p = (PWSTR)FilePath->FilePath;
        length = ExpSafeWcslen(p, (PWCHAR)Max);
        if (length != 0xffffffff) {
            p = p + length + 1;
            length = ExpSafeWcslen(p, (PWCHAR)Max);
        }
        if (length == 0xffffffff) {
            //DbgPrint( "ExpVerifyFilePath: NT string overruns buffer end\n" );
            return STATUS_INVALID_PARAMETER;
        }
        break;

    case FILE_PATH_TYPE_EFI:
        dp = (EFI_DEVICE_PATH *)FilePath->FilePath;
        while (TRUE) {
            if (((PUCHAR)dp + sizeof(EFI_DEVICE_PATH)) > Max) {
                //DbgPrint( "ExpVerifyFilePath: EFI device path overruns buffer end\n" );
                return STATUS_INVALID_PARAMETER;
            }
            length = DevicePathNodeLength(dp);
            if (((PUCHAR)dp + length) > Max) {
                //DbgPrint( "ExpVerifyFilePath: EFI device path overruns buffer end\n" );
                return STATUS_INVALID_PARAMETER;
            }
            dpMax = (PUCHAR)dp + length;
            if (IsDevicePathEndType(dp)) {
                break;
            }
            if ((DevicePathType(dp) == MEDIA_DEVICE_PATH) &&
                (DevicePathSubType(dp) == MEDIA_FILEPATH_DP)) {
                FILEPATH_DEVICE_PATH *fp = (FILEPATH_DEVICE_PATH *)dp;
                if (ExpSafeWcslen(fp->PathName, (PWCHAR)dpMax) == 0xffffffff) {
                    //DbgPrint( "ExpVerifyFilePath: EFI filepath string overruns buffer end\n" );
                    return STATUS_INVALID_PARAMETER;
                }
            }
            dp = NextDevicePathNode(dp);
        }
        break;

    default:
        ASSERT(FALSE);
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;

} // ExpVerifyFilePath

NTSTATUS
ExpVerifyWindowsOsOptions (
    PWINDOWS_OS_OPTIONS WindowsOsOptions,
    ULONG Length
    )
{
    PUCHAR Max = (PUCHAR)WindowsOsOptions + Length;
    ULONG loadOptionsLength = ExpSafeWcslen(WindowsOsOptions->OsLoadOptions, (PWSTR)Max);
    PFILE_PATH windowsFilePath;

    if ((WindowsOsOptions->Length < FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) ||
        (WindowsOsOptions->Length > Length) ||
        (WindowsOsOptions->Version == 0) ||
        (WindowsOsOptions->Version > WINDOWS_OS_OPTIONS_VERSION) ||
        ((WindowsOsOptions->OsLoadPathOffset & (sizeof(ULONG) - 1)) != 0) ||
        (WindowsOsOptions->OsLoadPathOffset >= Length) ||
        (loadOptionsLength == 0xffffffff) ||
        ((PUCHAR)(WindowsOsOptions->OsLoadOptions + loadOptionsLength + 1) >
            (PUCHAR)ADD_OFFSET(WindowsOsOptions, OsLoadPathOffset))) {
        return STATUS_INVALID_PARAMETER;
    }

    windowsFilePath = ADD_OFFSET(WindowsOsOptions, OsLoadPathOffset);
    return ExpVerifyFilePath(windowsFilePath, Max);

} // ExpVerifyWindowsOsOptions


NTSTATUS
ExpParseArcPathName (
    IN PWSTR ArcName,
    OUT PWSTR *ppDeviceName,
    OUT PWSTR *ppPathName,
    OUT PULONG pDeviceNameCount,
    OUT PBOOLEAN pSignatureFormat
    )
{
#define SIGNATURE_PREFIX    L"signature("
#define SIGNATURE_PREFIX_COUNT  10
#define BUFFER_COUNT        (SIGNATURE_PREFIX_COUNT + 1)

    PWSTR CurrentName, pathName = NULL;
    WCHAR signaturePrefix[ BUFFER_COUNT ];
    ULONG i;
    BOOLEAN SigFormat = FALSE, PrefixFound = TRUE;

    if( ArcName == NULL ) {
        return( STATUS_INVALID_PARAMETER );
    }

    wcscpy( signaturePrefix, SIGNATURE_PREFIX );

    //
    // check if the ArcName has a signature() format
    //
    for( i = 0; i < SIGNATURE_PREFIX_COUNT; i++ ) {
        if( towlower(ArcName[ i ]) != signaturePrefix[ i ] ) {
            PrefixFound = FALSE;
            break;
        }
    }

    CurrentName = ArcName;
    if( PrefixFound == TRUE ) {
        CurrentName += SIGNATURE_PREFIX_COUNT;
    }

    i = 0;
    while( CurrentName[ i ] != UNICODE_NULL ) {
        //
        // Check if FilePathName has been reached
        //
        if( CurrentName[ i ] == '\\' ) {
            pathName = CurrentName;
            pathName += i;
            break;
        }

        if( (PrefixFound == TRUE) && (CurrentName[ i ] == ')') ) {
            SigFormat = TRUE;
            PrefixFound = FALSE;    // set to FALSE, to stop checking

            //
            // the FilePathName or UNICODE_NULL must follow
            //
            if( (CurrentName[ i + 1 ] != '\\') &&
                (CurrentName[ i + 1 ] != UNICODE_NULL) ) {

                return( STATUS_INVALID_PARAMETER );
            }
        }

        i++;
    }

    //
    // if PrefixFound is still set
    //      the corresponding ')' was not found
    // if i == 0
    //      DeviceName does not exist
    //
    if( (PrefixFound == TRUE) || (i == 0) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    *ppDeviceName = CurrentName;
    *ppPathName = pathName;
    *pDeviceNameCount = i;
    *pSignatureFormat = SigFormat;

    return( STATUS_SUCCESS );

} // ExpParseArcPathName


NTSTATUS
ExpParseSignatureName (
    IN PWSTR deviceName,
    IN ULONG deviceNameCount,
    OUT PDISK_SIGNATURE_NEW diskSignature,
    OUT PULONG partitionNumber,
    OUT PULONGLONG partitionStart,
    OUT PULONGLONG partitionSize,
    OUT PBOOLEAN GPTpartition,
    OUT PBOOLEAN longSignature
    )
{
    UNICODE_STRING bufferString;
    ULONG i, prevI, chCount;
    PWSTR numberString, currentName;
    BOOLEAN foundGUID = FALSE, prettyGUID = FALSE;
    BOOLEAN longSigFound = FALSE;
    NTSTATUS status;

    //
    // Possible formats
    //
    if( deviceName[ 0 ] == '{' ) {
        foundGUID = TRUE;
    }

    //
    // parse the GUID or signature
    //
    i = 0;
    while( i < deviceNameCount ) {
        if( deviceName[ i ] == ')' ) {
            break;
        }
        if( foundGUID == TRUE ) {
            if( deviceName[ i ] == '}' ) {
                prettyGUID = TRUE;
                break;
            }
        }
        else {
            if( deviceName[ i ] == '-' ) {
                break;
            }
        }
        i++;
    }

    //
    // Verify that pretty GUID format has a '}'
    // {33221100-5544-7766-8899-aabbccddeeff}
    //
    if( (foundGUID == TRUE) && (prettyGUID == FALSE) ) {
        return( STATUS_INVALID_PARAMETER );
    }

#define MBR_SIGNATURE_COUNT 8
    if( i > MBR_SIGNATURE_COUNT ) {
        foundGUID = TRUE;
    }

    if( (foundGUID == TRUE) && (prettyGUID == TRUE) ) {
        //
        // pretty GUID format
        // {33221100-5544-7766-8899-aabbccddeeff}
        //

        bufferString.Buffer = deviceName;
        //
        // (+ 1) for the '}' to be included in the string
        //
        i++;
        bufferString.Length = (USHORT)(i * sizeof(WCHAR));
        bufferString.MaximumLength = bufferString.Length;

        status = RtlGUIDFromString(
                    &bufferString,
                    &(diskSignature->Guid)
                    );
        if( !NT_SUCCESS(status) ) {
            return status;
        }
    }
    else {
        numberString = ExAllocatePoolWithTag(
                            NonPagedPool,
                            (i + 1) * sizeof(WCHAR),
                            'rvnE'
                            );

        if ( numberString == NULL ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        wcsncpy( numberString, deviceName, i );
        numberString[ i ] = UNICODE_NULL;

        if( foundGUID == FALSE ) {
            //
            // MBR Signature format
            // 8459abcc
            //
            status = ExpTranslateHexStringToULONG(
                        numberString,
                        &(diskSignature->Signature)
                        );
        }
        else {
            //
            // ordinary GUID format
            // 00112233445566778899aabbccddeeff
            //
            status = ExpTranslateHexStringToGUID (
                        numberString,
                        &(diskSignature->Guid)
                        );
        }
        ExFreePool( numberString );
        if( !NT_SUCCESS(status) ) {
            return status;
        }
    }

    //
    // check if there is more information in the signature name
    //
    if( (i < deviceNameCount) && (deviceName[ i ] == '-') ) {
        longSigFound = TRUE;
        i++;
        //
        // need to parse <part#>-<start>-<size>)
        //  <part#> - 8 hex digits representing the ULONG partition number.
        //      (Formatted using %08x.)
        //  <start> - 16 hex digits representing the ULONGLONG starting LBA.
        //      (Formatted using %016I64x.)
        //  <size> - 16 hex digits representing the ULONGLONG partition size.
        //      (Formatted using %016I64x.)
        //
        if( i >= deviceNameCount ) {
            return( STATUS_INVALID_PARAMETER );
        }

#define ULONG_COUNT 8
#define ULONGLONG_COUNT 16
        //
        // Allocate a buffer to hold a ULONGLONG
        //
        numberString = ExAllocatePoolWithTag(
                            NonPagedPool,
                            (ULONGLONG_COUNT + 1) * sizeof(WCHAR),
                            'rvnE'
                            );

        if ( numberString == NULL ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        prevI = i;
        currentName = deviceName;
        currentName += i;
        while( i < deviceNameCount ) {
            if( deviceName[ i ] == '-' ) {
                break;
            }
            i++;
        }

        chCount = i - prevI;

        if( (chCount == 0) || (chCount > ULONG_COUNT) ) {
            ExFreePool( numberString );
            return( STATUS_INVALID_PARAMETER );
        }

        wcsncpy( numberString, currentName, chCount );
        numberString[ chCount ] = UNICODE_NULL;

        status = ExpTranslateHexStringToULONG( numberString, partitionNumber );
        if( !NT_SUCCESS(status) ) {
            ExFreePool( numberString );
            return status;
        }

        //
        // get the partition start
        //
        i++;
        if( i >= deviceNameCount ) {
            ExFreePool( numberString );
            return( STATUS_INVALID_PARAMETER );
        }

        prevI = i;
        currentName = deviceName;
        currentName += i;
        while( i < deviceNameCount ) {
            if( deviceName[ i ] == '-' ) {
                break;
            }
            i++;
        }

        chCount = i - prevI;
        if( (chCount == 0) || (chCount > ULONGLONG_COUNT) ) {
            ExFreePool( numberString );
            return( STATUS_INVALID_PARAMETER );
        }

        wcsncpy( numberString, currentName, chCount );
        numberString[ chCount ] = UNICODE_NULL;

        status = ExpTranslateHexStringToULONGLONG( numberString, partitionStart );
        if( !NT_SUCCESS(status) ) {
            ExFreePool( numberString );
            return status;
        }

        //
        // get the partition size
        //
        i++;
        if( i >= deviceNameCount ) {
            ExFreePool( numberString );
            return( STATUS_INVALID_PARAMETER );
        }

        prevI = i;
        currentName = deviceName;
        currentName += i;
        while( i < deviceNameCount ) {
            if( deviceName[ i ] == ')' ) {  // should be a ')' delimiter
                break;
            }
            i++;
        }

        chCount = i - prevI;
        if( (chCount == 0) || (chCount > ULONGLONG_COUNT) ) {
            ExFreePool( numberString );
            return( STATUS_INVALID_PARAMETER );
        }

        wcsncpy( numberString, currentName, chCount );
        numberString[ chCount ] = UNICODE_NULL;

        status = ExpTranslateHexStringToULONGLONG( numberString, partitionSize );
        ExFreePool( numberString );
        if( !NT_SUCCESS(status) ) {
            return status;
        }
    }

    //
    // At this point,
    // current positition should not pass the last char. of the buffer
    // current positition should be a ')'
    // MBR signature must have the long signature() format (need partition number)
    //
    if( (i >= deviceNameCount) ||
        (deviceName[ i ] != ')') ||
        ((foundGUID == FALSE) && (longSigFound == FALSE)) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    *GPTpartition = foundGUID;
    *longSignature = longSigFound;
    return( STATUS_SUCCESS );

} // ExpParseSignatureName


NTSTATUS
ExpParseEfiPath(
    IN EFI_DEVICE_PATH *pDevicePath,
    OUT HARDDRIVE_DEVICE_PATH **ppHardDriveDP,
    OUT PWSTR *ppPathName,
    OUT PBOOLEAN GPTpartition
    )

/*++
Routine Description:

    Parse the EFI_DEVICE_PATH into the HARDDRIVE node and
    entire PathName from the FILEPATH nodes

    Assumptions:
        - Parsing will stop at the first END_DEVICE_PATH node
        - The node graph of the Device path should be
            [~(HARDDRIVE, END_DEVICE_PATH)]* -> [HARDRIVE] -> [FILEPATH]* -> [END_DEVICE_PATH]

Arguments:

    pDevicePath - Receives an EFI_DEVICE_PATH

    ppHardDriveDP - Will receive a pointer to the
        HARDDRIVE_DEVICE_PATH node

    ppPathName - Will receive a pointer to the
        entire PathName from all the FILEPATH_DEVICE_PATH
        NULL - if the FILEPATH_DEVICE_PATH node does not exist

    GPTpartition - Will receive the type of partition
        TRUE  - GPT partition
        FALSE - MBR partition

Return Value:

    An appropriate status value.

--*/

{
    EFI_DEVICE_PATH *pDevPath;
    HARDDRIVE_DEVICE_PATH UNALIGNED *pHD_DP = NULL;
    FILEPATH_DEVICE_PATH *pFP_DP = NULL;
    ULONG fpLength,dpLength;
    PWSTR pFilePathName;
    NTSTATUS Status;

    fpLength = 0;
    dpLength = 0;
    pDevPath = pDevicePath;
    Status = STATUS_INVALID_PARAMETER;

    while( IsDevicePathEndType( pDevPath ) == FALSE ) {

        if( ( DevicePathType( pDevPath ) != MEDIA_DEVICE_PATH ) ||
            ( DevicePathSubType( pDevPath ) != MEDIA_HARDDRIVE_DP ) ) {
            pDevPath = NextDevicePathNode( pDevPath );
        }
        else {
            //
            // return the HardDrive node
            //
            pHD_DP = (HARDDRIVE_DEVICE_PATH UNALIGNED *)pDevPath;

            //
            // Assume successful operations until an error is detected
            //
            Status = STATUS_SUCCESS;
            dpLength += DevicePathNodeLength( pDevPath );
            pDevPath = NextDevicePathNode( pDevPath );

            if( ( DevicePathType( pDevPath ) == MEDIA_DEVICE_PATH ) &&
                ( DevicePathSubType( pDevPath ) == MEDIA_FILEPATH_DP ) ) {

                //
                // return the FilePath node
                //
                pFP_DP = (FILEPATH_DEVICE_PATH *)pDevPath;

                //
                // Sum up the lengths of all PathNames in the
                // FilePath nodes
                //
                do {
                    //
                    // Length of PathName is
                    //   FILEPATH_DEVICE_PATH.Length - (offset to PathName field)
                    //
                    fpLength += (DevicePathNodeLength(pDevPath) -
                                    FIELD_OFFSET(FILEPATH_DEVICE_PATH, PathName));
                    dpLength += DevicePathNodeLength( pDevPath );
                    pDevPath = NextDevicePathNode( pDevPath );

                } while( ( DevicePathType( pDevPath ) == MEDIA_DEVICE_PATH ) &&
                         ( DevicePathSubType( pDevPath ) == MEDIA_FILEPATH_DP ) );
            }

            //
            // At this point, the node must be a END_DEVICE_PATH
            //
            if( IsDevicePathEndType( pDevPath ) == FALSE ) {
                Status = STATUS_INVALID_PARAMETER;
            }

            break;
        }
    }

    //
    // If no MEDIA/HARDDRIVE element was found, we cannot continue. The
    // MEDIA/FILEPATH element is optional.
    //
    if( !NT_SUCCESS( Status ) ) {
        return( Status );
    }

    //
    // Check the partition type, must be GPT or MBR
    //
    if( pHD_DP->SignatureType == SIGNATURE_TYPE_GUID ) {
        *GPTpartition = TRUE;
    }
    else {
        if ( pHD_DP->SignatureType == SIGNATURE_TYPE_MBR ) {
            *GPTpartition = FALSE;
        }
        else {
            //DbgPrint( "ExpParseEfiPath: partition signature type unknown\n" );
            return( STATUS_INVALID_PARAMETER );
        }
    }

    if( fpLength != 0 ) {
        fpLength += sizeof(WCHAR);      // add null-terminator
        pFilePathName = ExAllocatePoolWithTag( NonPagedPool, fpLength, 'rvnE' );
        if( pFilePathName == NULL ) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }

        wcscpy( pFilePathName, pFP_DP->PathName );

        pDevPath = (EFI_DEVICE_PATH *)pFP_DP;
        pDevPath = NextDevicePathNode( pDevPath );

        while( IsDevicePathEndType( pDevPath ) == FALSE ) {
            pFP_DP = (FILEPATH_DEVICE_PATH *)pDevPath;
            wcscat( pFilePathName, pFP_DP->PathName );
            pDevPath = NextDevicePathNode( pDevPath );
        }
    }
    else {
        pFilePathName = NULL;
    }

    //
    // almost done.  allocate an aligned buffer for the device path and copy
    // the unaligned contents into this buffer.
    //
    *ppHardDriveDP = ExAllocatePoolWithTag( NonPagedPool, dpLength, 'rvnE' );
    if (*ppHardDriveDP == NULL) {
        if (pFilePathName) {
            ExFreePool(pFilePathName);            
        }
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    RtlCopyMemory( *ppHardDriveDP, pHD_DP, dpLength );
    *ppPathName = pFilePathName;

    return( Status );
} // ExpParseEfiPath


NTSTATUS
ExpConvertArcName(
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PWSTR pDeviceName,
    IN PWSTR pPathName,
    IN ULONG DeviceNameCount
    )
{
    ULONG requiredCount, requiredLength, filePathLength;
    PWSTR linkName;
    UNICODE_STRING deviceNameString;
    PWCHAR p;
    PFILE_PATH filePath;
    NTSTATUS status;

    //
    // Allocate Pool to hold the ArcName's NT Name
    //
#define ARC_DIR_PREFIX  L"\\ArcName\\"
#define ARC_DIR_PREFIX_COUNT    9

    requiredCount = DeviceNameCount + ARC_DIR_PREFIX_COUNT + 1;
    requiredLength = requiredCount * sizeof(WCHAR);
    linkName = ExAllocatePoolWithTag( NonPagedPool, requiredLength, 'rvnE' );
    if ( linkName == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    wcscpy( linkName, ARC_DIR_PREFIX );
    wcsncat( linkName, pDeviceName, DeviceNameCount );
    linkName[ requiredCount - 1 ] = UNICODE_NULL;

    if( OutputType == FILE_PATH_TYPE_NT ) {
        //
        // Open the symbolic link object & drill down to the target
        // return symbolic link target
        //
        status = ExpTranslateSymbolicLink(
                    linkName,
                    &deviceNameString
                    );
        ExFreePool( linkName );
        if ( !NT_SUCCESS(status) ) {
            return( status );
        }

        status = ExpCreateOutputNT(
                    OutputPath,
                    OutputPathLength,
                    &deviceNameString,
                    pPathName
                    );
        ExFreePool( deviceNameString.Buffer );
        return( status );
    }

    //
    // Output type is either FILE_PATH_TYPE_EFI or FILE_PATH_TYPE_ARC_SIGNATURE
    // and we have a NT name, so use ExpTranslateNtPath() for the conversion
    // Create a input FILE_PATH with the NT name
    //
    filePathLength = requiredLength + FIELD_OFFSET(FILE_PATH, FilePath);
    if ( pPathName != NULL ) {
        filePathLength += ((ULONG)(wcslen( pPathName )) * sizeof(WCHAR));
    }

    filePathLength += sizeof(WCHAR);

    filePath = ExAllocatePoolWithTag( NonPagedPool, filePathLength, 'rvnE' );

    if ( filePath == NULL ) {
        ExFreePool( linkName );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build the input file path.
    //
    filePath->Version = FILE_PATH_VERSION;
    filePath->Length = filePathLength;
    filePath->Type = FILE_PATH_TYPE_NT;

    p = (PWSTR)filePath->FilePath;
    wcscpy( p, linkName );
    p = (PWSTR)((PUCHAR)p + requiredLength);

    ExFreePool( linkName );

    if ( pPathName != NULL ) {
        wcscpy( p, pPathName );
    }
    else {
        *p = UNICODE_NULL;
    }

    status = ExpTranslateNtPath(
                filePath,
                OutputType,
                OutputPath,
                OutputPathLength
                );

    ExFreePool( filePath );

    return( status );
} // ExpConvertArcName


NTSTATUS
ExpConvertSignatureName(
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PWSTR pDeviceName,
    IN PWSTR pPathName,
    IN ULONG DeviceNameCount
    )
{
    DISK_SIGNATURE_NEW diskSignature;
    ULONG inputPartitionNumber, outputPartitionNumber;
    ULONG diskNumber;
    ULONGLONG inputPartitionStart, outputPartitionStart;
    ULONGLONG inputPartitionSize, outputPartitionSize;
    BOOLEAN GPTpartition, longSignature;
    PWSTR pDiskName;
    UNICODE_STRING DiskNameString;
    NTSTATUS status;

    //
    // Determine the signature() format
    //
    status = ExpParseSignatureName (
                pDeviceName,
                DeviceNameCount,
                &diskSignature,
                &inputPartitionNumber,
                &inputPartitionStart,
                &inputPartitionSize,
                &GPTpartition,
                &longSignature
                );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // if signature(<guid/signature>-<part#>-<start>-<size>) format &&
    //    ( OutputType == FILE_PATH_TYPE_EFI )
    //        return EFI_DEVICE_PATH format
    //
    if( (longSignature == TRUE) && (OutputType == FILE_PATH_TYPE_EFI) ) {
        status = ExpCreateOutputEFI(
                    OutputPath,
                    OutputPathLength,
                    &diskSignature,
                    &inputPartitionNumber,
                    &inputPartitionStart,
                    &inputPartitionSize,
                    pPathName,
                    GPTpartition
                    );
        return( status );
    }

    //
    // open all disks and search for partition GUID
    //
    if( GPTpartition == FALSE ) {
        outputPartitionNumber = inputPartitionNumber;
    }
    status = ExpFindDiskSignature(
                &diskSignature,
                &outputPartitionNumber,
                &diskNumber,
                &outputPartitionStart,
                &outputPartitionSize,
                GPTpartition
                );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // If the user has provided the partition number, start address,
    // and size; then verify the input with the found results.
    //
    if( (longSignature == TRUE) &&
        ( (inputPartitionNumber != outputPartitionNumber) ||
          (inputPartitionStart != outputPartitionStart) ||
          (inputPartitionSize != outputPartitionSize)
        ) ) {

        return( STATUS_INVALID_PARAMETER );
    }

    if( OutputType == FILE_PATH_TYPE_EFI ) {
        status = ExpCreateOutputEFI(
                    OutputPath,
                    OutputPathLength,
                    &diskSignature,
                    &outputPartitionNumber,
                    &outputPartitionStart,
                    &outputPartitionSize,
                    pPathName,
                    GPTpartition
                    );
        return( status );
    }

    //
    // translate \Device\Harddisk[diskNumber]\Partition[PartitionNumber]
    //
#define DISK_NAME_FORMAT L"\\Device\\Harddisk%lu\\Partition%lu"
#define DISK_NAME_COUNT 47    // 7 + 9 + (10) + 10 + (10) + 1

    pDiskName = ExAllocatePoolWithTag(
                    NonPagedPool,
                    ( DISK_NAME_COUNT * sizeof( WCHAR ) ),
                    'rvnE'
                    );

    if( pDiskName == NULL ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    _snwprintf(
        pDiskName,
        DISK_NAME_COUNT,
        DISK_NAME_FORMAT,
        diskNumber,
        outputPartitionNumber
        );

    status = ExpTranslateSymbolicLink(
                pDiskName,
                &DiskNameString
                );
    ExFreePool( pDiskName );
    if ( !NT_SUCCESS(status) ) {
        return( status );
    }

    if( OutputType == FILE_PATH_TYPE_NT ) {
        status = ExpCreateOutputNT(
                    OutputPath,
                    OutputPathLength,
                    &DiskNameString,
                    pPathName
                    );
        ExFreePool( DiskNameString.Buffer );
        return( status );
    }

    if( OutputType == FILE_PATH_TYPE_ARC ) {
        status = ExpCreateOutputARC(
                    OutputPath,
                    OutputPathLength,
                    &DiskNameString,
                    pPathName
                    );
        ExFreePool( DiskNameString.Buffer );
        return( status );
    }

    ExFreePool( DiskNameString.Buffer );
    return( STATUS_INVALID_PARAMETER );
} // ExpConvertSignatureName


NTSTATUS
ExpTranslateHexStringToULONG (
    IN PWSTR Name,
    OUT PULONG Number
    )
{
    ULONG number;
    ULONG i, max;
    WCHAR c;

#define ULONG_HEX_MAX 8

    max = (ULONG)wcslen( Name );

    if( max > ULONG_HEX_MAX ) {
        return( STATUS_INVALID_PARAMETER );
    }

    number = 0;
    for (i = 0; i < max; i++) {
        c = towlower(Name[i]);
        if ((c >= L'0') && (c <= L'9')) {
            number = (number * 16) + (c - L'0');
        } else if ((c >= L'a') && (c <= L'f')) {
            number = (number * 16) + (c - L'a' + 10);
        } else {
            return( STATUS_INVALID_PARAMETER );
        }
    }

    *Number = number;
    return( STATUS_SUCCESS );

} // ExpTranslateHexStringToULONG


NTSTATUS
ExpTranslateHexStringToULONGLONG (
    IN PWSTR Name,
    OUT PULONGLONG Number
    )
{
    ULONGLONG number;
    ULONG i, max;
    WCHAR c;

#define ULONGLONG_HEX_MAX 16

    max = (ULONG)wcslen( Name );

    if( max > ULONGLONG_HEX_MAX ) {
        return( STATUS_INVALID_PARAMETER );
    }

    number = 0;
    for (i = 0; i < max; i++) {
        c = towlower(Name[i]);
        if ((c >= L'0') && (c <= L'9')) {
            number = (number * 16) + (c - L'0');
        } else if ((c >= L'a') && (c <= L'f')) {
            number = (number * 16) + (c - L'a' + 10);
        } else {
            return( STATUS_INVALID_PARAMETER );
        }
    }

    *Number = number;
    return( STATUS_SUCCESS );

} // ExpTranslateHexStringToULONGLONG


NTSTATUS
ExpTranslateHexStringToGUID (
    IN PWSTR Name,
    OUT GUID *pGuid
    )
{
    GUID resultGuid;
    ULONG i, max, number, result;
    USHORT formatStyle, position;
    WCHAR c;

#define GUID_HEX_MAX 32

    max = (ULONG)wcslen( Name );

    if( max != GUID_HEX_MAX ) {
        return( STATUS_INVALID_PARAMETER );
    }

    number = 0;
    formatStyle = 0;
    position = 0;
    result = 0;
    for (i = 0; i < max; i++) {
        c = towlower(Name[i]);
        if ((c >= L'0') && (c <= L'9')) {
            number = (number * 16) + (c - L'0');
        } else if ((c >= L'a') && (c <= L'f')) {
            number = (number * 16) + (c - L'a' + 10);
        } else {
            return( STATUS_INVALID_PARAMETER );
        }

        if ((i % 2) == 1) {
            switch( formatStyle ) {
            case 0:
                result += (number << (position * 8));
                position++;
                if( position == 4 ) {
                    resultGuid.Data1 = result;
                    formatStyle++;
                    position = 0;
                    result = 0;
                }
                break;
            case 1:
                result += (number << (position * 8));
                position++;
                if( position == 2 ) {
                    resultGuid.Data2 = (USHORT)result;
                    formatStyle++;
                    position = 0;
                    result = 0;
                }
                break;
            case 2:
                result += (number << (position * 8));
                position++;
                if( position == 2 ) {
                    resultGuid.Data3 = (USHORT)result;
                    formatStyle++;
                    position = 0;
                    result = 0;
                }
                break;
            case 3:
                resultGuid.Data4[ position ] = (UCHAR)number;
                position++;
                if( position == 8 ) {
                    formatStyle++;
                }
                break;
            default:
                return( STATUS_INVALID_PARAMETER );
                break;
            }
            number = 0;
        }
    }

    memcpy(pGuid, &(resultGuid), sizeof(GUID));
    return( STATUS_SUCCESS );

} // ExpTranslateHexStringToGUID


NTSTATUS
ExpCreateOutputEFI (
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PDISK_SIGNATURE_NEW pDiskSignature,
    IN PULONG pPartitionNumber,
    IN PULONGLONG pPartitionStart,
    IN PULONGLONG pPartitionSize,
    IN PWSTR pPathName,
    IN BOOLEAN GPTpartition
    )
{
    ULONG requiredLength, pathNameLength = 0;
    EFI_DEVICE_PATH *dp;
    HARDDRIVE_DEVICE_PATH UNALIGNED *dpHarddrive = NULL;
    FILEPATH_DEVICE_PATH *dpFilepath = NULL;

    //
    // The output EFI file path consists of two elements. First is a
    // MEDIA/HARDDRIVE element describing the partition. Second is an
    // optional MEDIA/FILEPATH element describing the path to a directory
    // or a file.
    //

    requiredLength = FIELD_OFFSET(FILE_PATH, FilePath);
    requiredLength += sizeof(HARDDRIVE_DEVICE_PATH);
    if (pPathName != NULL) {
        pathNameLength = (ULONG)wcslen(pPathName);
        pathNameLength = (pathNameLength + 1) * sizeof(WCHAR);
        requiredLength += FIELD_OFFSET(FILEPATH_DEVICE_PATH, PathName);
        requiredLength += pathNameLength;
    }
    requiredLength += sizeof(EFI_DEVICE_PATH);

    //
    // Compare the required length against the output buffer length.
    //

    if ( *OutputPathLength < requiredLength ) {
        *OutputPathLength = requiredLength;
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Build the output file path.
    //

    OutputPath->Version = FILE_PATH_VERSION;
    OutputPath->Length = requiredLength;
    OutputPath->Type = FILE_PATH_TYPE_EFI;

    dp = (EFI_DEVICE_PATH *)OutputPath->FilePath;
    dpHarddrive = (HARDDRIVE_DEVICE_PATH UNALIGNED *)dp;
    dp->Type = MEDIA_DEVICE_PATH;
    dp->SubType = MEDIA_HARDDRIVE_DP;
    SetDevicePathNodeLength(dp, sizeof(HARDDRIVE_DEVICE_PATH));
    dpHarddrive->PartitionNumber = *pPartitionNumber;
    dpHarddrive->PartitionStart = *pPartitionStart;
    dpHarddrive->PartitionSize = *pPartitionSize;
    if (GPTpartition == TRUE) {
        memcpy(dpHarddrive->Signature, &(pDiskSignature->Guid), sizeof(GUID));
        dpHarddrive->MBRType = MBR_TYPE_EFI_PARTITION_TABLE_HEADER;
        dpHarddrive->SignatureType = SIGNATURE_TYPE_GUID;
    } else {
        memcpy(dpHarddrive->Signature, &(pDiskSignature->Signature), sizeof(ULONG));
        dpHarddrive->MBRType = MBR_TYPE_PCAT;
        dpHarddrive->SignatureType = SIGNATURE_TYPE_MBR;
    }

    if (pPathName != NULL) {
        dp = NextDevicePathNode(dp);
        dpFilepath = (FILEPATH_DEVICE_PATH *)dp;
        dp->Type = MEDIA_DEVICE_PATH;
        dp->SubType = MEDIA_FILEPATH_DP;
        SetDevicePathNodeLength(dp, FIELD_OFFSET(FILEPATH_DEVICE_PATH, PathName) + pathNameLength);
        wcscpy(dpFilepath->PathName, pPathName);
    }

    dp = NextDevicePathNode(dp);
    SetDevicePathEndNode(dp);

    *OutputPathLength = requiredLength;
    return STATUS_SUCCESS;

} // ExpCreateOutputEFI


NTSTATUS
ExpCreateOutputNT (
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PUNICODE_STRING pDeviceNameString,
    IN PWSTR pPathName
    )
{
    ULONG requiredLength;
    PWCHAR p;

    requiredLength = pDeviceNameString->Length + sizeof(WCHAR);

    //
    // If a PathName component is present, then increase the
    // output string length by the length of the path string.
    //

    if ( pPathName != NULL ) {
        requiredLength += ((ULONG)(wcslen( pPathName )) * sizeof(WCHAR));
    }

    //
    // always add a UNICODE_NULL for PathName even if PathName is not present
    //
    requiredLength += sizeof(WCHAR);

    //
    // Add the structure overhead and compare the required length against
    // output buffer length.
    //

    requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);

    if ( *OutputPathLength < requiredLength ) {
        *OutputPathLength = requiredLength;
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Build the output file path.
    //

    OutputPath->Version = FILE_PATH_VERSION;
    OutputPath->Length = requiredLength;
    OutputPath->Type = FILE_PATH_TYPE_NT;

    p = (PWSTR)OutputPath->FilePath;
    wcscpy( p, pDeviceNameString->Buffer );
    p = (PWSTR)((PUCHAR)p + pDeviceNameString->Length + sizeof(WCHAR));

    if ( pPathName != NULL ) {
        wcscpy( p, pPathName );
    }
    else {
        *p = UNICODE_NULL;
    }

    *OutputPathLength = requiredLength;
    return STATUS_SUCCESS;

} // ExpCreateOutputNT


NTSTATUS
ExpCreateOutputARC (
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PUNICODE_STRING pDeviceNameString,
    IN PWSTR pPathName
    )
{
    ULONG requiredLength, ArcNameLength;
    PWCHAR p;
    PWSTR pArcDeviceName;
    NTSTATUS status;

    status = ExpFindArcName(
                pDeviceNameString,
                &pArcDeviceName
                );
    if (!NT_SUCCESS(status)) {
        return( status );
    }

    ArcNameLength = ((ULONG)wcslen(pArcDeviceName)) * sizeof(WCHAR);
    requiredLength = ArcNameLength + sizeof(WCHAR);

    //
    // If a PathName component is present, then increase the
    // output string length by the length of the path string.
    //

    if ( pPathName != NULL ) {
        requiredLength += ((ULONG)(wcslen( pPathName )) * sizeof(WCHAR));
    }

    //
    // Add the structure overhead and compare the required length against
    // output buffer length.
    //

    requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);

    if ( *OutputPathLength < requiredLength ) {
        *OutputPathLength = requiredLength;
        ExFreePool( pArcDeviceName );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Build the output file path.
    //

    OutputPath->Version = FILE_PATH_VERSION;
    OutputPath->Length = requiredLength;
    OutputPath->Type = FILE_PATH_TYPE_ARC;

    p = (PWSTR)OutputPath->FilePath;
    wcscpy( p, pArcDeviceName );
    p = (PWSTR)((PUCHAR)p + ArcNameLength);
    ExFreePool( pArcDeviceName );

    if ( pPathName != NULL ) {
        wcscpy( p, pPathName );
    }

    *OutputPathLength = requiredLength;
    return STATUS_SUCCESS;

} // ExpCreateOutputARC


NTSTATUS
ExpCreateOutputSIGNATURE (
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PDISK_SIGNATURE_NEW pDiskSignature,
    IN PULONG pPartitionNumber,
    IN PULONGLONG pPartitionStart,
    IN PULONGLONG pPartitionSize,
    IN PWSTR pPathName,
    IN BOOLEAN GPTpartition
    )
{
    ULONG requiredLength, pathNameCount;
    PWCHAR p;
    UNICODE_STRING GuidString;
    NTSTATUS status;

    //
    // We will convert the EFI device path into an ARC name with this
    // format:
    //
    //  signature(<guid/signature>-<part#>-<start>-<size>)
    //
    // Where:
    //
    //  <guid/signature> - For a GPT disk, the GPT partition GUID in
    //      "pretty" format ({33221100-5544-7766-8899-aabbccddeeff}).
    //      For an MBR disk, 8 hex digits representing the ULONG MBR
    //      disk signature. (Formatted using %08x.)
    //  <part#> - 8 hex digits representing the ULONG partition number.
    //      (Formatted using %08x.)
    //  <start> - 16 hex digits representing the ULONGLONG starting LBA.
    //      (Formatted using %016I64x.)
    //  <size> - 16 hex digits representing the ULONGLONG partition size.
    //      (Formatted using %016I64x.)
    //
    // For a GPT disk, the output string length is 86 WCHARs. For an
    // MBR disk, the output string length is 62 WCHARs.
    //

    requiredLength = (ULONG)strlen("signature(") +
                     1 +                        // "-"
                     (sizeof(ULONG) * 2) +      // <part#>
                     1 +                        // "-"
                     (sizeof(ULONGLONG) * 2) +  // <start>
                     1 +                        // "-"
                     (sizeof(ULONGLONG) * 2) +  // <size>
                     1 +                        // ")"
                     1;                         // null terminator

    if ( GPTpartition == TRUE ) {
        requiredLength += (sizeof(GUID) * 2);
        requiredLength += 6;    // for the {} & four '-' in the pretty GUID format
    } else {
        requiredLength += sizeof(ULONG) * 2;
    }

    //
    // If a pathName component is present, then increase the
    // output string length by the length of the path string.
    //

    if (pPathName != NULL) {
        pathNameCount = (ULONG)wcslen(pPathName);
        requiredLength += pathNameCount;
    }
    else {
        pathNameCount = 0;
    }

    //
    // Convert the string length to a byte count, add the structure
    // overhead, and compare the required length against output buffer
    // length.
    //

    requiredLength *= sizeof(WCHAR);
    requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);

    if ( *OutputPathLength < requiredLength ) {
        *OutputPathLength = requiredLength;
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Build the output file path.
    //

    OutputPath->Version = FILE_PATH_VERSION;
    OutputPath->Length = requiredLength;
    OutputPath->Type = FILE_PATH_TYPE_ARC_SIGNATURE;

    p = (PWSTR)OutputPath->FilePath;
    wcscpy( p, L"signature(" );
    p += wcslen( p );

    if ( GPTpartition == TRUE ) {
        status = RtlStringFromGUID(
                    (LPGUID)(&(pDiskSignature->Guid)),
                    &GuidString
                    );
        if ( !NT_SUCCESS(status) ) {
            return status;
        }
        wcscat( p, GuidString.Buffer );
        p = (PWCHAR)((PUCHAR)p + GuidString.Length);
        ExFreePool( GuidString.Buffer );
    } else {
        swprintf( p, L"%08x", pDiskSignature->Signature );
        p += wcslen( p );
    }

    swprintf(
        p,
        L"-%08x-%016I64x-%016I64x)",
        *pPartitionNumber,
        *pPartitionStart,
        *pPartitionSize
        );
    p += wcslen( p );

    if ( pathNameCount != 0 ) {
        wcscpy( p, pPathName );
    }

    *OutputPathLength = requiredLength;
    return STATUS_SUCCESS;

} // ExpCreateOutputSIGNATURE


NTSTATUS
ExpFindArcName (
    IN PUNICODE_STRING pDeviceNameString,
    OUT PWSTR *pArcName
    )
{
    NTSTATUS status;
    UNICODE_STRING ArcString, SymLinkTypeString;
    OBJECT_ATTRIBUTES Attributes;
    PWSTR pArcDirName, pArcLinkName;
    HANDLE hArcDirectory;
    POBJECT_DIRECTORY_INFORMATION pDirInfo;
    ULONG dirInfoLength, neededLength, dirContext;
    ULONG arcNameCount;
    BOOLEAN restartScan, ArcNameFound = FALSE;

    //
    // Open a handle to the directory object for \ArcName
    // Get a kernel handle
    //
#define ARC_DIR_NAME    L"\\ArcName"
#define ARC_DIR_SIZE    (9 * sizeof(WCHAR))
#define ARC_DIR_NAME_PREFIX L"\\ArcName\\"
#define ARC_DIR_SIZE_PREFIX (9 * sizeof(WCHAR))

    pArcDirName = ExAllocatePoolWithTag( NonPagedPool, ARC_DIR_SIZE, 'rvnE' );
    if ( pArcDirName == NULL ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }
    wcscpy( pArcDirName, ARC_DIR_NAME );

    RtlInitUnicodeString( &ArcString, pArcDirName );

    InitializeObjectAttributes(
        &Attributes,
        &ArcString,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    status = ZwOpenDirectoryObject(
                &hArcDirectory,
                DIRECTORY_QUERY,
                &Attributes
                );
    ExFreePool( pArcDirName );
    if (!NT_SUCCESS(status)) {
        return( status );
    }

    pDirInfo = NULL;
    dirInfoLength = 0;
    restartScan = TRUE;
    RtlInitUnicodeString( &SymLinkTypeString, L"SymbolicLink" );
    while (TRUE) {
        status = ZwQueryDirectoryObject(
                    hArcDirectory,
                    pDirInfo,
                    dirInfoLength,
                    TRUE,           // force one at a time
                    restartScan,
                    &dirContext,
                    &neededLength
                    );
        if (status == STATUS_BUFFER_TOO_SMALL) {
            dirInfoLength = neededLength;
            if (pDirInfo != NULL) {
                ExFreePool(pDirInfo);
            }
            pDirInfo = ExAllocatePoolWithTag( NonPagedPool, dirInfoLength, 'rvnE' );
            if (pDirInfo == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            status = ZwQueryDirectoryObject(
                        hArcDirectory,
                        pDirInfo,
                        dirInfoLength,
                        TRUE,       // force one at a time
                        restartScan,
                        &dirContext,
                        &neededLength
                        );
        }
        restartScan = FALSE;

        if (!NT_SUCCESS(status)) {
            if (status == STATUS_NO_MORE_ENTRIES) {
                status = STATUS_SUCCESS;
            }
            break;
        }

        //
        // Check if the element is not a symbolic link
        //
        if (RtlEqualUnicodeString(
                &(pDirInfo->TypeName),
                &SymLinkTypeString,
                FALSE) == FALSE) {
            continue;
        }

        neededLength = ARC_DIR_SIZE_PREFIX + pDirInfo->Name.Length;
        pArcLinkName = ExAllocatePoolWithTag(
                            NonPagedPool,
                            neededLength + sizeof(WCHAR),
                            'rvnE' );
        if ( pArcLinkName == NULL ) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        arcNameCount = pDirInfo->Name.Length/sizeof(WCHAR);
        wcscpy( pArcLinkName, ARC_DIR_NAME_PREFIX );
        wcsncat(
            pArcLinkName,
            pDirInfo->Name.Buffer,
            arcNameCount
            );
        pArcLinkName[ neededLength/sizeof(WCHAR) ] = UNICODE_NULL;

        //
        // Drill down this symbolic link to the device object
        //
        status = ExpTranslateSymbolicLink(
                    pArcLinkName,
                    &ArcString
                    );
        if ( !NT_SUCCESS(status) ) {
            ExFreePool( pArcLinkName );
            break;
        }

        //
        // Check if this Arc Name points the same device object
        //
        ArcNameFound = RtlEqualUnicodeString(
                            &ArcString,
                            pDeviceNameString,
                            TRUE
                            );
        ExFreePool( ArcString.Buffer );

        if (ArcNameFound == TRUE) {
            //
            // copy the arc name without the \ArcName\ prefix
            //
            wcsncpy(
                pArcLinkName,
                pDirInfo->Name.Buffer,
                arcNameCount
                );
            pArcLinkName[ arcNameCount ] = UNICODE_NULL;
            *pArcName = pArcLinkName;
            break;
        }
        ExFreePool( pArcLinkName );
    }

    if( NT_SUCCESS(status) && (ArcNameFound == FALSE ) ) {
        status = STATUS_OBJECT_PATH_NOT_FOUND;
    }

    if (pDirInfo != NULL) {
        ExFreePool(pDirInfo);
    }

    ZwClose( hArcDirectory );
    return( status );

} // ExpFindArcName


NTSTATUS
ExpFindDiskSignature (
    IN PDISK_SIGNATURE_NEW pSignature,
    IN OUT PULONG pPartitionNumber,
    OUT PULONG pDiskNumber,
    OUT PULONGLONG pPartitionStart,
    OUT PULONGLONG pPartitionSize,
    IN BOOLEAN GPTpartition
    )
/*++

Routine Description:

    This function searches all the disks on the system for the
    partition corresponding to the paritition GUID or
    (MBR signature, paritition number).

    N.B. for a MBR signature, the partition number must be provided.

Arguments:

    pSignature - Supplies a pointer to a partition GUID (GPT disk) or
        32-bit signature(MBR disk).

    pPartitionNumber - Supplies a pointer to a partition number when
        pSignature is a MBR signature.  For output, receives the
        partition number.

    pDiskNumber - Receives the disk number

    pPartitionStart - Receives the start of the partition

    pPartitionSize - Receives the size of the partition

    GPTpartition - Supplies the type of partition
        TRUE  - GPT disk partition
        FALSE - MBR disk partition

Return Value:

    STATUS_SUCCESS is returned if the partition is successfully found.

    STATUS_OBJECT_PATH_NOT_FOUND is returned if the partition could not
        be found.

    STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
        for this request to complete.

--*/
{
    PDRIVE_LAYOUT_INFORMATION_EX    pDriveLayout = NULL;
    PPARTITION_INFORMATION_EX       pPartitionInfoEx = NULL;
    SYSTEM_DEVICE_INFORMATION       SysDevInfo;
    ULONG               PartitionStyle;
    BOOLEAN             PartitionFound = FALSE;
    ULONG               Index, PartitionIndex;
    PWSTR               pDeviceName;
    NTSTATUS            Status;

    //
    // Find all disks on the system
    //

    Status = ZwQuerySystemInformation(
                SystemDeviceInformation,
                &SysDevInfo,
                sizeof(SYSTEM_DEVICE_INFORMATION),
                NULL
                );

    if( !NT_SUCCESS( Status ) ) {
        return( Status );
    }

#define DEVICE_NAME_FORMAT L"\\Device\\Harddisk%lu\\Partition0"
#define DEVICE_NAME_CHAR_COUNT 38    // 7 + 9 + (10) + 11 + 1
    //
    // Allocate the buffer for the disk names
    //
    pDeviceName = ExAllocatePoolWithTag(
                    NonPagedPool,
                    ( DEVICE_NAME_CHAR_COUNT * sizeof( WCHAR ) ),
                    'rvnE'
                    );

    if( pDeviceName == NULL ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    if( GPTpartition == TRUE ) {
        PartitionStyle = PARTITION_STYLE_GPT;
    }
    else {
        PartitionStyle = PARTITION_STYLE_MBR;
    }

    //
    // For each disk,
    // Get the Partition Table
    // Verify the partition style (MBR/GPT)
    //
    // if( Partition style matches )
    //      search for the Partition in the drive layout
    // else
    //      skip the disk
    //
    for( Index = 0; Index < SysDevInfo.NumberOfDisks; Index++ ) {

        //
        // Form the disk name
        // \Device\Harddisk[DiskNumber]\Partition0
        //
        _snwprintf(
                pDeviceName,
                DEVICE_NAME_CHAR_COUNT,
                DEVICE_NAME_FORMAT,
                Index
                );

        Status = ExpGetPartitionTableInfo(
                    pDeviceName,
                    &pDriveLayout
                    );

        if( !NT_SUCCESS( Status ) ) {
            continue;
        }

        if( pDriveLayout->PartitionStyle != PartitionStyle ) {
            ExFreePool( pDriveLayout );
            continue;
        }

        if( (PartitionStyle == PARTITION_STYLE_MBR) &&
            (pDriveLayout->Mbr.Signature != pSignature->Signature) ) {
            ExFreePool( pDriveLayout );
            continue;
        }

        //
        // search partition list
        //
        for( PartitionIndex = 0;
             PartitionIndex < pDriveLayout->PartitionCount;
             PartitionIndex++ ) {

            //
            // Get the partition entry
            //
            pPartitionInfoEx = (&(pDriveLayout->PartitionEntry[PartitionIndex]));

            if( PartitionStyle == PARTITION_STYLE_MBR ) {
                if (pPartitionInfoEx->PartitionNumber == *pPartitionNumber) {
                    PartitionFound = TRUE;
                    break;
                }
            }
            else {
                if (IsEqualGUID( &(pPartitionInfoEx->Gpt.PartitionId),
                                 &(pSignature->Guid) )) {
                    PartitionFound = TRUE;
                    break;
                }
            }
        }

        if( PartitionFound == TRUE ) {
            break;
        }
        ExFreePool( pDriveLayout );
    }


    if( NT_SUCCESS( Status ) && ( PartitionFound == FALSE ) ) {
        Status = STATUS_OBJECT_PATH_NOT_FOUND;
    }

    //
    // Partition Found - copy the needed information
    //
    if( PartitionFound == TRUE ) {
        *pPartitionNumber = pPartitionInfoEx->PartitionNumber;
        *pDiskNumber = Index;
        *pPartitionStart = pPartitionInfoEx->StartingOffset.QuadPart;
        *pPartitionSize = pPartitionInfoEx->PartitionLength.QuadPart;
        ExFreePool( pDriveLayout );
    }

    ExFreePool( pDeviceName );
    return( Status );

} // ExpFindDiskSignature


NTSTATUS
ExpGetPartitionTableInfo (
    IN PWSTR pDeviceName,
    OUT PDRIVE_LAYOUT_INFORMATION_EX *ppDriveLayout
    )
{
    NTSTATUS status;
    UNICODE_STRING string;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    HANDLE handle;
    PDRIVE_LAYOUT_INFORMATION_EX driveLayoutInfo = NULL;
    ULONG driveLayoutLength;

    //
    // Open the disk and get its partition table information.
    //

    RtlInitUnicodeString(&string, pDeviceName);

    InitializeObjectAttributes(
        &obja,
        &string,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    status = ZwOpenFile(
                &handle,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &obja,
                &iosb,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_NON_DIRECTORY_FILE
                );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    driveLayoutLength = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry) +
                            (sizeof(PARTITION_INFORMATION_EX) * 16);

    while (TRUE) {

        driveLayoutInfo = ExAllocatePoolWithTag(NonPagedPool, driveLayoutLength, 'rvnE');
        if (driveLayoutInfo == NULL ) {
            ZwClose(handle);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = ZwDeviceIoControlFile(
                    handle,
                    NULL,
                    NULL,
                    NULL,
                    &iosb,
                    IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                    NULL,
                    0,
                    driveLayoutInfo,
                    driveLayoutLength
                    );
        if (NT_SUCCESS(status)) {
            break;
        }

        ExFreePool(driveLayoutInfo);
        if (status == STATUS_BUFFER_TOO_SMALL) {
            driveLayoutLength *= 2;
            continue;
        }
        ZwClose(handle);
        return status;
    }

    *ppDriveLayout = driveLayoutInfo;
    ZwClose(handle);
    return status;

} // ExpGetPartitionTableInfo

#endif // defined(EFI_NVRAM_ENABLED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\tlock.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tlock.c

Abstract:

    Test program for exinterlockedincrement/decrement routines

Environment:

    This program can either be compiled into a kernel mode test,
    OR you can link intrloc2.obj or i386\intrlock.obj (or whatever)
    into it and run it in user mode.

Author:

    Bryan Willman (bryanwi) 3-Aug-90

Revision History:


--*/

#include "exp.h"


main()
{
    INTERLOCKED_RESULT  RetVal;
    LONG                SpinVar;            // talk about a hack...
    LONG                LongVar;
    SHORT               ShortVar;
    KSPIN_LOCK          Lock;

    Lock = &SpinVar;

    LongVar = 0;
    ShortVar = 0;

    RetVal = ExInterlockedDecrementLong(&LongVar, &Lock);
    if ((RetVal != ResultNegative) ||
        (LongVar != -1)) {
        DbgPrint("t&Lock failure #L1\n");
    }

    RetVal = ExInterlockedDecrementLong(&LongVar, &Lock);
    if ((RetVal != ResultNegative) ||
        (LongVar != -2)) {
        DbgPrint("t&Lock failure #L2\n");
    }

    RetVal = ExInterlockedIncrementLong(&LongVar, &Lock);
    if ((RetVal != ResultNegative) ||
        (LongVar != -1)) {
        DbgPrint("t&Lock failure #L3\n");
    }

    RetVal = ExInterlockedIncrementLong(&LongVar, &Lock);
    if ((RetVal != ResultZero) ||
        (LongVar != 0)) {
        DbgPrint("t&Lock failure #L4\n");
    }

    RetVal = ExInterlockedIncrementLong(&LongVar, &Lock);
    if ((RetVal != ResultPositive) ||
        (LongVar != 1)) {
        DbgPrint("t&Lock failure #L5\n");
    }

    RetVal = ExInterlockedIncrementLong(&LongVar, &Lock);
    if ((RetVal != ResultPositive) ||
        (LongVar != 2)) {
        DbgPrint("t&Lock failure #L6\n");
    }

    RetVal = ExInterlockedDecrementLong(&LongVar, &Lock);
    if ((RetVal != ResultPositive) ||
        (LongVar != 1)) {
        DbgPrint("t&Lock failure #L7\n");
    }

    RetVal = ExInterlockedDecrementLong(&LongVar, &Lock);
    if ((RetVal != ResultZero) ||
        (LongVar != 0)) {
        DbgPrint("t&Lock failure #L8\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\timer.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    timer.c

Abstract:

   This module implements the executive timer object. Functions are provided
   to create, open, cancel, set, and query timer objects.

Author:

    David N. Cutler (davec) 12-May-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

//
// Executive timer object structure definition.
//

typedef struct _ETIMER {
    KTIMER KeTimer;
    KAPC TimerApc;
    KDPC TimerDpc;
    LIST_ENTRY ActiveTimerListEntry;
    KSPIN_LOCK Lock;
    LONG Period;
    BOOLEAN ApcAssociated;
    BOOLEAN WakeTimer;
    LIST_ENTRY WakeTimerListEntry;
} ETIMER, *PETIMER;

//
// List of all timers which are set to wake
//

KSPIN_LOCK ExpWakeTimerListLock;
LIST_ENTRY ExpWakeTimerList;

//
// Address of timer object type descriptor.
//

POBJECT_TYPE ExTimerObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for timer objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING ExpTimerMapping = {
    STANDARD_RIGHTS_READ |
        TIMER_QUERY_STATE,
    STANDARD_RIGHTS_WRITE |
        TIMER_MODIFY_STATE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    TIMER_ALL_ACCESS
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpTimerInitialization)
#pragma alloc_text(PAGE, NtCreateTimer)
#pragma alloc_text(PAGE, NtOpenTimer)
#pragma alloc_text(PAGE, NtQueryTimer)
#pragma alloc_text(PAGELK, ExGetNextWakeTime)
#endif

VOID
ExpTimerApcRoutine (
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This function is the special APC routine that is called to remove
    a timer from the current thread's active timer list.

Arguments:

    Apc - Supplies a pointer to the APC object used to invoke this routine.

    NormalRoutine - Supplies a pointer to a pointer to the normal routine
        function that was specified when the APC was initialized.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized.

    SystemArgument1, SystemArgument2 - Supplies a set of two pointers to
        two arguments that contain untyped data.

Return Value:

    None.

--*/

{

    BOOLEAN Dereference;
    PETHREAD ExThread;
    PETIMER ExTimer;
    KIRQL OldIrql1;

    UNREFERENCED_PARAMETER (NormalContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    //
    // Get address of executive timer object and the current thread object.
    //

    ExThread = PsGetCurrentThread();
    ExTimer = CONTAINING_RECORD(Apc, ETIMER, TimerApc);

    //
    // If the timer is still in the current thread's active timer list, then
    // remove it if it is not a periodic timer and set APC associated FALSE.
    // It is possible for the timer not to be in the current thread's active
    // timer list since the APC could have been delivered, and then another
    // thread could have set the timer again with another APC. This would
    // have caused the timer to be removed from the current thread's active
    // timer list.
    //
    // N. B. The spin locks for the timer and the active timer list must be
    //  acquired in the order: 1) timer lock, 2) thread list lock.
    //

    Dereference = FALSE;
    ExAcquireSpinLock(&ExTimer->Lock, &OldIrql1);
    ExAcquireSpinLockAtDpcLevel(&ExThread->ActiveTimerListLock);
    if ((ExTimer->ApcAssociated) && (&ExThread->Tcb == ExTimer->TimerApc.Thread)) {
        if (ExTimer->Period == 0) {
            RemoveEntryList(&ExTimer->ActiveTimerListEntry);
            ExTimer->ApcAssociated = FALSE;
            Dereference = TRUE;
        }

    } else {
        *NormalRoutine = (PKNORMAL_ROUTINE)NULL;
    }

    ExReleaseSpinLockFromDpcLevel(&ExThread->ActiveTimerListLock);
    ExReleaseSpinLock(&ExTimer->Lock, OldIrql1);
    if (Dereference) {
        ObDereferenceObject((PVOID)ExTimer);
    }

    return;
}

VOID
ExpTimerDpcRoutine (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is the DPC routine that is called when a timer expires that
    has an associated APC routine. Its function is to insert the associated
    APC into the target thread's APC queue.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredContext - Supplies a pointer to the executive timer that contains
        the DPC that caused this routine to be executed.

    SystemArgument1, SystemArgument2 - Supplies values that are not used by
        this routine.

Return Value:

    None.

--*/

{

    PETIMER ExTimer;
    PKTIMER KeTimer;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER (Dpc);

    //
    // Get address of executive and kernel timer objects.
    //

    ExTimer = (PETIMER)DeferredContext;
    KeTimer = &ExTimer->KeTimer;

    //
    // If there is still an APC associated with the timer, then insert the APC
    // in target thread's APC queue. It is possible that the timer does not
    // have an associated APC. This can happen when the timer is set to expire
    // by a thread running on another processor just after the DPC has been
    // removed from the DPC queue, but before it has acquired the timer related
    // spin lock.
    //

    ExAcquireSpinLock(&ExTimer->Lock, &OldIrql);
    if (ExTimer->ApcAssociated) {
        KeInsertQueueApc(&ExTimer->TimerApc,
                         SystemArgument1,
                         SystemArgument2,
                         TIMER_APC_INCREMENT);
    }

    ExReleaseSpinLock(&ExTimer->Lock, OldIrql);
    return;
}

static VOID
ExpDeleteTimer (
    IN PVOID    Object
    )

/*++

Routine Description:

    This function is the delete routine for timer objects. Its function is
    to cancel the timer and free the spin lock associated with a timer.

Arguments:

    Object - Supplies a pointer to an executive timer object.

Return Value:

    None.

--*/

{
    PETIMER     ExTimer;
    KIRQL       OldIrql;

    ExTimer = (PETIMER) Object;

    //
    // Remove from wake list
    //

    if (ExTimer->WakeTimerListEntry.Flink) {
        ExAcquireSpinLock(&ExpWakeTimerListLock, &OldIrql);
        if (ExTimer->WakeTimerListEntry.Flink) {
            RemoveEntryList(&ExTimer->WakeTimerListEntry);
            ExTimer->WakeTimerListEntry.Flink = NULL;
        }
        ExReleaseSpinLock(&ExpWakeTimerListLock, OldIrql);
    }

    //
    // Cancel the timer and free the spin lock associated with the timer.
    //

    KeCancelTimer(&ExTimer->KeTimer);
    return;
}

BOOLEAN
ExpTimerInitialization (
    )

/*++

Routine Description:

    This function creates the timer object type descriptor at system
    initialization and stores the address of the object type descriptor
    in local static storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the timer object type descriptor is
    successfully initialized. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    KeInitializeSpinLock (&ExpWakeTimerListLock);
    InitializeListHead (&ExpWakeTimerList);

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Timer");

    //
    // Create timer object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpTimerMapping;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(ETIMER);
    ObjectTypeInitializer.ValidAccessMask = TIMER_ALL_ACCESS;
    ObjectTypeInitializer.DeleteProcedure = ExpDeleteTimer;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExTimerObjectType);



    //
    // If the time object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

VOID
ExTimerRundown (
    )

/*++

Routine Description:

    This function is called when a thread is about to be terminated to
    process the active timer list. It is assumed that APC's have been
    disabled for the subject thread, thus this code cannot be interrupted
    to execute an APC for the current thread.

Arguments:

    None.

Return Value:

    None.

--*/

{

    BOOLEAN Dereference;
    PETHREAD ExThread;
    PETIMER ExTimer;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql1;

    //
    // Process each entry in the active timer list.
    //

    ExThread = PsGetCurrentThread();
    ExAcquireSpinLock(&ExThread->ActiveTimerListLock, &OldIrql1);
    NextEntry = ExThread->ActiveTimerListHead.Flink;
    while (NextEntry != &ExThread->ActiveTimerListHead) {
        ExTimer = CONTAINING_RECORD(NextEntry, ETIMER, ActiveTimerListEntry);

        //
        // Increment the reference count on the object so that it cannot be
        // deleted, and then drop the active timer list lock.
        //
        // N. B. The object reference cannot fail and will acquire no mutexes.
        //

        ObReferenceObject(ExTimer);
        ExReleaseSpinLock(&ExThread->ActiveTimerListLock, OldIrql1);

        //
        // Acquire the timer spin lock and reacquire the active time list spin
        // lock. If the timer is still in the current thread's active timer
        // list, then cancel the timer, remove the timer's DPC from the DPC
        // queue, remove the timer's APC from the APC queue, remove the timer
        // from the thread's active timer list, and set the associate APC
        // flag FALSE.
        //
        // N. B. The spin locks for the timer and the active timer list must be
        //  acquired in the order: 1) timer lock, 2) thread list lock.
        //

        ExAcquireSpinLock(&ExTimer->Lock, &OldIrql1);
        ExAcquireSpinLockAtDpcLevel(&ExThread->ActiveTimerListLock);
        if ((ExTimer->ApcAssociated) && (&ExThread->Tcb == ExTimer->TimerApc.Thread)) {
            RemoveEntryList(&ExTimer->ActiveTimerListEntry);
            ExTimer->ApcAssociated = FALSE;
            KeCancelTimer(&ExTimer->KeTimer);
            KeRemoveQueueDpc(&ExTimer->TimerDpc);
            KeRemoveQueueApc(&ExTimer->TimerApc);
            Dereference = TRUE;

        } else {
            Dereference = FALSE;
        }

        ExReleaseSpinLockFromDpcLevel(&ExThread->ActiveTimerListLock);
        ExReleaseSpinLock(&ExTimer->Lock, OldIrql1);
        if (Dereference) {
            ObDereferenceObject((PVOID)ExTimer);
        }

        ObDereferenceObject((PVOID)ExTimer);

        //
        // Raise IRQL to DISPATCH_LEVEL and reacquire active timer list
        // spin lock.
        //

        ExAcquireSpinLock(&ExThread->ActiveTimerListLock, &OldIrql1);
        NextEntry = ExThread->ActiveTimerListHead.Flink;
    }

    ExReleaseSpinLock(&ExThread->ActiveTimerListLock, OldIrql1);
    return;
}

NTSTATUS
NtCreateTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN TIMER_TYPE TimerType
    )

/*++

Routine Description:

    This function creates an timer object and opens a handle to the object with
    the specified desired access.

Arguments:

    TimerHandle - Supplies a pointer to a variable that will receive the
        timer object handle.

    DesiredAccess - Supplies the desired types of access for the timer object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    TimerType - Supplies the type of the timer (autoclearing or notification).

Return Value:

    NTSTATUS.

--*/

{

    PETIMER ExTimer;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to create a timer object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object insertion routine.
    //

    //
    // Get previous processor mode and probe output handle address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(TimerHandle);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Check argument validity.
    //

    if ((TimerType != NotificationTimer) &&
        (TimerType != SynchronizationTimer)) {
        return STATUS_INVALID_PARAMETER_4;
    }

    //
    // Allocate timer object.
    //

    Status = ObCreateObject(PreviousMode,
                            ExTimerObjectType,
                            ObjectAttributes,
                            PreviousMode,
                            NULL,
                            sizeof(ETIMER),
                            0,
                            0,
                            (PVOID *)&ExTimer);

    //
    // If the timer object was successfully allocated, then initialize the
    // timer object and attempt to insert the time object in the current
    // process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeDpc(&ExTimer->TimerDpc,
                        ExpTimerDpcRoutine,
                        (PVOID)ExTimer);

        KeInitializeTimerEx(&ExTimer->KeTimer, TimerType);
        KeInitializeSpinLock(&ExTimer->Lock);
        ExTimer->ApcAssociated = FALSE;
        ExTimer->WakeTimer = FALSE;
        ExTimer->WakeTimerListEntry.Flink = NULL;
        Status = ObInsertObject((PVOID)ExTimer,
                                NULL,
                                DesiredAccess,
                                0,
                                (PVOID *)NULL,
                                &Handle);

        //
        // If the timer object was successfully inserted in the current
        // process' handle table, then attempt to write the timer object
        // handle value. If the write attempt fails, then do not report
        // an error. When the caller attempts to access the handle value,
        // an access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            if (PreviousMode != KernelMode) {
                try {
                    *TimerHandle = Handle;
                } except(ExSystemExceptionFilter()) {
                    NOTHING;
                }
             }
             else {
                *TimerHandle = Handle;
             }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtOpenTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to an timer object with the specified
    desired access.

Arguments:

    TimerHandle - Supplies a pointer to a variable that will receive the
        timer object handle.

    DesiredAccess - Supplies the desired types of access for the timer object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    NTSTATUS.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to open a timer object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the open object routine.
    //

    //
    // Get previous processor mode and probe output handle address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(TimerHandle);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Open handle to the timer object with the specified desired access.
    //

    Status = ObOpenObjectByName(ObjectAttributes,
                                ExTimerObjectType,
                                PreviousMode,
                                NULL,
                                DesiredAccess,
                                NULL,
                                &Handle);

    //
    // If the open was successful, then attempt to write the timer object
    // handle value. If the write attempt fails, then do not report an
    // error. When the caller attempts to access the handle value, an
    // access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        if (PreviousMode != KernelMode) {
            try {
                *TimerHandle = Handle;

            } except(ExSystemExceptionFilter()) {
                NOTHING;
            }
        }
        else {
            *TimerHandle = Handle;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtCancelTimer (
    IN HANDLE TimerHandle,
    OUT PBOOLEAN CurrentState OPTIONAL
    )

/*++

Routine Description:

    This function cancels a timer object.

Arguments:

    TimerHandle - Supplies a handle to an timer object.

    CurrentState - Supplies an optional pointer to a variable that will
        receive the current state of the timer object.

Return Value:

    NTSTATUS.

--*/

{

    BOOLEAN Dereference;
    PETHREAD ExThread;
    PETIMER ExTimer;
    KIRQL OldIrql1;
    KPROCESSOR_MODE PreviousMode;
    BOOLEAN State;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the current state address if
    // specified, reference the timer object, and cancel the timer object.
    // If the probe fails, then return the exception code as the service
    // status. Otherwise return the status value returned by the reference
    // object by handle routine.
    //

    //
    // Get previous processor mode and probe current state address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if ((ARGUMENT_PRESENT(CurrentState)) && (PreviousMode != KernelMode)) {

        try {
            ProbeForWriteBoolean(CurrentState);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Reference timer object by handle.
    //

    Status = ObReferenceObjectByHandle(TimerHandle,
                                       TIMER_MODIFY_STATE,
                                       ExTimerObjectType,
                                       PreviousMode,
                                       (PVOID *)&ExTimer,
                                       NULL);

    //
    // If the reference was successful, then cancel the timer object,
    // dereference the timer object, and write the current state value
    // if specified. If the write attempt fails, then do not report an
    // error. When the caller attempts to access the current state value,
    // an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {

        ExAcquireSpinLock(&ExTimer->Lock, &OldIrql1);

        if (ExTimer->ApcAssociated) {
            ExThread = CONTAINING_RECORD(ExTimer->TimerApc.Thread, ETHREAD, Tcb);

            ExAcquireSpinLockAtDpcLevel(&ExThread->ActiveTimerListLock);
            RemoveEntryList(&ExTimer->ActiveTimerListEntry);
            ExTimer->ApcAssociated = FALSE;
            ExReleaseSpinLockFromDpcLevel(&ExThread->ActiveTimerListLock);

            KeCancelTimer(&ExTimer->KeTimer);
            KeRemoveQueueDpc(&ExTimer->TimerDpc);
            KeRemoveQueueApc(&ExTimer->TimerApc);
            Dereference = TRUE;

        } else {
            KeCancelTimer(&ExTimer->KeTimer);
            Dereference = FALSE;
        }

        if (ExTimer->WakeTimerListEntry.Flink) {
            ExAcquireSpinLockAtDpcLevel(&ExpWakeTimerListLock);

            //
            // Check again as ExGetNextWakeTime might have removed it.
            //
            if (ExTimer->WakeTimerListEntry.Flink) {
                RemoveEntryList(&ExTimer->WakeTimerListEntry);
                ExTimer->WakeTimerListEntry.Flink = NULL;
            }
            ExReleaseSpinLockFromDpcLevel(&ExpWakeTimerListLock);
        }

        ExReleaseSpinLock(&ExTimer->Lock, OldIrql1);

        if (Dereference) {
            ObDereferenceObject((PVOID)ExTimer);
        }

        //
        // Read current state of timer, dereference timer object, and set
        // current state.
        //

        State = KeReadStateTimer(&ExTimer->KeTimer);
        ObDereferenceObject(ExTimer);

        if (ARGUMENT_PRESENT(CurrentState)) {
            if (PreviousMode != KernelMode) {
                try {
                    *CurrentState = State;

                } except(ExSystemExceptionFilter()) {
                }
            }
            else {
                *CurrentState = State;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQueryTimer (
    IN HANDLE TimerHandle,
    IN TIMER_INFORMATION_CLASS TimerInformationClass,
    OUT PVOID TimerInformation,
    IN ULONG TimerInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function queries the state of an timer object and returns the
    requested information in the specified record structure.

Arguments:

    TimerHandle - Supplies a handle to an timer object.

    TimerInformationClass - Supplies the class of information being requested.

    TimerInformation - Supplies a pointer to a record that is to receive the
        requested information.

    TimerInformationLength - Supplies the length of the record that is to
        receive the requested information.

    ReturnLength - Supplies an optional pointer to a variable that is to
        receive the actual length of information that is returned.

Return Value:

    NTSTATUS.

--*/

{

    PETIMER ExTimer;
    PKTIMER KeTimer;
    KPROCESSOR_MODE PreviousMode;
    BOOLEAN State;
    NTSTATUS Status;
    LARGE_INTEGER TimeToGo;

    //
    // Establish an exception handler, probe the output arguments, reference
    // the timer object, and return the specified information. If the probe
    // fails, then return the exception code as the service status. Otherwise
    // return the status value returned by the reference object by handle
    // routine.
    //

    //
    // Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {

            ProbeForWriteSmallStructure(TimerInformation,
                                        sizeof(TIMER_BASIC_INFORMATION),
                                        sizeof(ULONG));

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUlong(ReturnLength);
            }
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Check argument validity.
    //

    if (TimerInformationClass != TimerBasicInformation) {
        return STATUS_INVALID_INFO_CLASS;
    }

    if (TimerInformationLength != sizeof(TIMER_BASIC_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Reference timer object by handle.
    //

    Status = ObReferenceObjectByHandle(TimerHandle,
                                       TIMER_QUERY_STATE,
                                       ExTimerObjectType,
                                       PreviousMode,
                                       (PVOID *)&ExTimer,
                                       NULL);

    //
    // If the reference was successful, then read the current state,
    // compute the time remaining, dereference the timer object, fill in
    // the information structure, and return the length of the information
    // structure if specified. If the write of the time information or the
    // return length fails, then do not report an error. When the caller
    // accesses the information structure or the length, an violation will
    // occur.
    //

    if (NT_SUCCESS(Status)) {
        KeTimer = &ExTimer->KeTimer;
        State = KeReadStateTimer(KeTimer);
        KiQueryInterruptTime(&TimeToGo);
        TimeToGo.QuadPart = KeTimer->DueTime.QuadPart - TimeToGo.QuadPart;
        ObDereferenceObject(ExTimer);

        if (PreviousMode != KernelMode) {
            try {
                ((PTIMER_BASIC_INFORMATION)TimerInformation)->TimerState = State;
                ((PTIMER_BASIC_INFORMATION)TimerInformation)->RemainingTime = TimeToGo;
                if (ARGUMENT_PRESENT(ReturnLength)) {
                    *ReturnLength = sizeof(TIMER_BASIC_INFORMATION);
                }

            } except(ExSystemExceptionFilter()) {
                NOTHING;
            }
        }
        else {
            ((PTIMER_BASIC_INFORMATION)TimerInformation)->TimerState = State;
            ((PTIMER_BASIC_INFORMATION)TimerInformation)->RemainingTime = TimeToGo;
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(TIMER_BASIC_INFORMATION);
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetTimer (
    IN HANDLE TimerHandle,
    IN PLARGE_INTEGER DueTime,
    IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
    IN PVOID TimerContext OPTIONAL,
    IN BOOLEAN WakeTimer,
    IN LONG Period OPTIONAL,
    OUT PBOOLEAN PreviousState OPTIONAL
    )

/*++

Routine Description:

    This function sets an timer object to a Not-Signaled state and sets the timer
    to expire at the specified time.

Arguments:

    TimerHandle - Supplies a handle to an timer object.

    DueTime - Supplies a pointer to absolute of relative time at which the
        timer is to expire.

    TimerApcRoutine - Supplies an optional pointer to a function which is to
        be executed when the timer expires. If this parameter is not specified,
        then the TimerContext parameter is ignored.

    TimerContext - Supplies an optional pointer to an arbitrary data structure
        that will be passed to the function specified by the TimerApcRoutine
        parameter. This parameter is ignored if the TimerApcRoutine parameter
        is not specified.

    WakeTimer - Supplies a boolean value that specifies whether the timer
        wakes computer operation if sleeping

    Period - Supplies an optional repetitive period for the timer.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the timer object.

Return Value:

    NTSTATUS.

--*/

{

    BOOLEAN AssociatedApc;
    BOOLEAN Dereference;
    PETHREAD ExThread;
    PETIMER ExTimer;
    LARGE_INTEGER ExpirationTime;
    KIRQL OldIrql1;
    KPROCESSOR_MODE PreviousMode;
    BOOLEAN State;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the due time and previous state
    // address if specified, reference the timer object, and set the timer
    // object. If the probe fails, then return the exception code as the
    // service status. Otherwise return the status value returned by the
    // reference object by handle routine.
    //

    //
    // Get previous processor mode and probe previous state address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {

            if (ARGUMENT_PRESENT(PreviousState)) {
                ProbeForWriteBoolean(PreviousState);
            }

            ProbeForReadSmallStructure(DueTime, sizeof(LARGE_INTEGER), sizeof(ULONG));
            ExpirationTime = *DueTime;

        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }
    else {
        ExpirationTime = *DueTime;
    }

    //
    // Check argument validity.
    //

    if (Period < 0) {
        return STATUS_INVALID_PARAMETER_6;
    }

    //
    // Reference timer object by handle.
    //

    Status = ObReferenceObjectByHandle(TimerHandle,
                                       TIMER_MODIFY_STATE,
                                       ExTimerObjectType,
                                       PreviousMode,
                                       (PVOID *)&ExTimer,
                                       NULL);

    //
    // If this WakeTimer flag is set, return the appropiate informational
    // success status code.
    //

    if (NT_SUCCESS(Status) && WakeTimer && !PoWakeTimerSupported()) {
        Status = STATUS_TIMER_RESUME_IGNORED;
    }

    //
    // If the reference was successful, then cancel the timer object, set
    // the timer object, dereference time object, and write the previous
    // state value if specified. If the write of the previous state value
    // fails, then do not report an error. When the caller attempts to
    // access the previous state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        ExAcquireSpinLock(&ExTimer->Lock, &OldIrql1);

        if (ExTimer->ApcAssociated) {
            ExThread = CONTAINING_RECORD(ExTimer->TimerApc.Thread, ETHREAD, Tcb);

            ExAcquireSpinLockAtDpcLevel(&ExThread->ActiveTimerListLock);
            RemoveEntryList(&ExTimer->ActiveTimerListEntry);
            ExTimer->ApcAssociated = FALSE;
            ExReleaseSpinLockFromDpcLevel(&ExThread->ActiveTimerListLock);

            KeCancelTimer(&ExTimer->KeTimer);
            KeRemoveQueueDpc(&ExTimer->TimerDpc);
            KeRemoveQueueApc(&ExTimer->TimerApc);
            Dereference = TRUE;

        } else {
            KeCancelTimer(&ExTimer->KeTimer);
            Dereference = FALSE;
        }

        //
        // Read the current state of the timer.
        //

        State = KeReadStateTimer(&ExTimer->KeTimer);

        //
        // If this is a wake timer ensure it's on the wake timer list.
        //

        ExTimer->WakeTimer = WakeTimer;

        ExAcquireSpinLockAtDpcLevel(&ExpWakeTimerListLock);
        if (WakeTimer) {
            if (!ExTimer->WakeTimerListEntry.Flink) {
                InsertTailList(&ExpWakeTimerList, &ExTimer->WakeTimerListEntry);
            }
        } else {
            if (ExTimer->WakeTimerListEntry.Flink) {
                RemoveEntryList(&ExTimer->WakeTimerListEntry);
                ExTimer->WakeTimerListEntry.Flink = NULL;
            }
        }
        ExReleaseSpinLockFromDpcLevel(&ExpWakeTimerListLock);

        //
        // If an APC routine is specified, then initialize the APC, acquire the
        // thread's active time list lock, insert the timer in the thread's
        // active timer list, set the timer with an associated DPC, and set the
        // associated APC flag TRUE. Otherwise set the timer without an
        // associated DPC, and set the associated APC flag FALSE.
        //

        ExTimer->Period = Period;
        if (ARGUMENT_PRESENT((ULONG_PTR)TimerApcRoutine)) {
            ExThread = PsGetCurrentThread();
            KeInitializeApc(&ExTimer->TimerApc,
                            &ExThread->Tcb,
                            CurrentApcEnvironment,
                            ExpTimerApcRoutine,
                            (PKRUNDOWN_ROUTINE)NULL,
                            (PKNORMAL_ROUTINE)TimerApcRoutine,
                            PreviousMode,
                            TimerContext);

            ExAcquireSpinLockAtDpcLevel(&ExThread->ActiveTimerListLock);
            InsertTailList(&ExThread->ActiveTimerListHead,
                           &ExTimer->ActiveTimerListEntry);

            ExTimer->ApcAssociated = TRUE;
            ExReleaseSpinLockFromDpcLevel(&ExThread->ActiveTimerListLock);
            KeSetTimerEx(&ExTimer->KeTimer,
                         ExpirationTime,
                         Period,
                         &ExTimer->TimerDpc);

            AssociatedApc = TRUE;

        } else {
            KeSetTimerEx(&ExTimer->KeTimer,
                         ExpirationTime,
                         Period,
                         NULL);

            AssociatedApc = FALSE;
        }

        ExReleaseSpinLock(&ExTimer->Lock, OldIrql1);

        //
        // Dereference the object as appropriate.
        //

        if (Dereference) {
            ObDereferenceObject((PVOID)ExTimer);
        }

        if (AssociatedApc == FALSE) {
            ObDereferenceObject((PVOID)ExTimer);
        }

        if (ARGUMENT_PRESENT(PreviousState)) {
            if (PreviousMode != KernelMode) {
                try {
                    *PreviousState = State;

                } except(ExSystemExceptionFilter()) {
                    NOTHING;
                }
            }
            else {
                *PreviousState = State;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}


VOID
ExGetNextWakeTime (
    OUT PULONGLONG      DueTime,
    OUT PTIME_FIELDS    TimeFields,
    OUT PVOID           *TimerObject
    )
{
    PLIST_ENTRY     Link;
    PETIMER         ExTimer;
    PETIMER         BestTimer;
    KIRQL           OldIrql;
    ULONGLONG       TimerDueTime;
    ULONGLONG       BestDueTime;
    ULONGLONG       InterruptTime;
    LARGE_INTEGER   SystemTime;
    LARGE_INTEGER   CmosTime;

    ExAcquireSpinLock(&ExpWakeTimerListLock, &OldIrql);
    BestDueTime = 0;
    BestTimer = NULL;
    Link = ExpWakeTimerList.Flink;
    while (Link != &ExpWakeTimerList) {
        ExTimer = CONTAINING_RECORD(Link, ETIMER, WakeTimerListEntry);
        Link = Link->Flink;

        if (ExTimer->WakeTimer) {

            TimerDueTime = KeQueryTimerDueTime(&ExTimer->KeTimer);
            TimerDueTime = 0 - TimerDueTime;

            //
            // Is this timers due time closer?
            //

            if (TimerDueTime > BestDueTime) {
                BestDueTime = TimerDueTime;
                BestTimer = ExTimer;
            }

        } else {

            //
            // Timer is not an active wake timer, remove it
            //

            RemoveEntryList(&ExTimer->WakeTimerListEntry);
            ExTimer->WakeTimerListEntry.Flink = NULL;
        }
    }

    ExReleaseSpinLock(&ExpWakeTimerListLock, OldIrql);

    if (BestDueTime) {
        //
        // Convert time to timefields
        //

        KeQuerySystemTime (&SystemTime);
        InterruptTime = KeQueryInterruptTime ();
        BestDueTime = 0 - BestDueTime;

        SystemTime.QuadPart += BestDueTime - InterruptTime;

        //
        // Many system alarms are only good to 1 second resolution.
        // Add one sceond to the target time so that the timer is really
        // elasped if this is the wake event.
        //

        SystemTime.QuadPart += 10000000;

        ExSystemTimeToLocalTime(&SystemTime,&CmosTime);
        RtlTimeToTimeFields(&CmosTime, TimeFields);
    }

    *DueTime = BestDueTime;
    *TimerObject = BestTimer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\uuid.c ===
/*++

Copyright (c) 1994-1997  Microsoft Corporation

Module Name:

    uuid.c

Abstract:

    This module implements the core time and sequence number allocation
    for UUIDs (exposed to user mode), as well as complete UUID
    creation (exposed to kernel mode only).

              (e.g. RPC Runtime)                (e.g. NTFS)
                      |                              |
                      V                              V
                NtAllocateUuids                 ExUuidCreate
                      |                              |
                      V                              V
                      |                         ExpUuidGetValues
                      |                              |
                      |                              |
                      +------> ExpAllocateUuids <----+



Author:

    Mario Goertzel (MarioGo)  22-Nov-1994

Revision History:

    MikeHill    17-Jan-96   Ported ExUuidCreate & ExpUuidGetValues from RPCRT4.
    MazharM     17-Feb-98   Add PNP support

--*/

#include "exp.h"



//
// Well known values
//

// Registry info for the sequen number
#define RPC_SEQUENCE_NUMBER_PATH L"\\Registry\\Machine\\Software\\Microsoft\\Rpc"
#define RPC_SEQUENCE_NUMBER_NAME L"UuidSequenceNumber"

// Masks and constants to interpret the UUID
#define UUID_TIME_HIGH_MASK    0x0FFF
#define UUID_VERSION           0x1000
#define UUID_RESERVED          0x80
#define UUID_CLOCK_SEQ_HI_MASK 0x3F

// Values for ExpUuidCacheValid
#define CACHE_LOCAL_ONLY 0
#define CACHE_VALID      1

//
// Custom types
//

// An alternative data-template for a UUID, useful during generation.
typedef struct _UUID_GENERATE {
    ULONG   TimeLow;
    USHORT  TimeMid;
    USHORT  TimeHiAndVersion;
    UCHAR   ClockSeqHiAndReserved;
    UCHAR   ClockSeqLow;
    UCHAR   NodeId[6];
} UUID_GENERATE;

// A cache of allocated UUIDs
typedef struct _UUID_CACHED_VALUES_STRUCT {
    ULONGLONG           Time;           // End time of allocation
    LONG                AllocatedCount; // Number of UUIDs allocated
    UCHAR               ClockSeqHiAndReserved;
    UCHAR               ClockSeqLow;
    UCHAR               NodeId[6];
} UUID_CACHED_VALUES_STRUCT;


//
//  Global variables
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

// UUID cache information
LARGE_INTEGER               ExpUuidLastTimeAllocated = {0,0};
BOOLEAN                     ExpUuidCacheValid = CACHE_LOCAL_ONLY;

// Make cache allocate UUIDs on first call.
// Time = 0. Allocated = -1, ..., multicast bit in node id
UUID_CACHED_VALUES_STRUCT   ExpUuidCachedValues = { 0, -1, 0, 0, { 0x80, 'm', 'a', 'r', 'i', 'o' }};

// UUID Sequence number information
ULONG                       ExpUuidSequenceNumber = 0;
BOOLEAN                     ExpUuidSequenceNumberValid = FALSE;
BOOLEAN                     ExpUuidSequenceNumberNotSaved = FALSE;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

// A lock to protect all of the above global data.
FAST_MUTEX                  ExpUuidLock;

//
// Code section allocations
//

extern NTSTATUS ExpUuidLoadSequenceNumber(
    OUT PULONG
    );

extern NTSTATUS ExpUuidSaveSequenceNumber(
    IN ULONG
    );

extern NTSTATUS ExpUuidSaveSequenceNumberIf ();

extern NTSTATUS ExpUuidGetValues(
    OUT UUID_CACHED_VALUES_STRUCT *Values
    );


#ifdef ALLOC_PRAGMA
NTSTATUS
ExpAllocateUuids (
    OUT PLARGE_INTEGER Time,
    OUT PULONG Range,
    OUT PULONG Sequence
    );
#pragma alloc_text(PAGE, ExpUuidLoadSequenceNumber)
#pragma alloc_text(PAGE, ExpUuidSaveSequenceNumber)
#pragma alloc_text(PAGE, ExpUuidSaveSequenceNumberIf)
#pragma alloc_text(INIT, ExpUuidInitialization)
#pragma alloc_text(PAGE, ExpAllocateUuids)
#pragma alloc_text(PAGE, NtAllocateUuids)
#pragma alloc_text(PAGE, NtSetUuidSeed)
#pragma alloc_text(PAGE, ExpUuidGetValues)
#pragma alloc_text(PAGE, ExUuidCreate)
#endif


NTSTATUS
ExpUuidLoadSequenceNumber(
    OUT PULONG Sequence
    )
/*++

Routine Description:

    This function loads the saved sequence number from the registry.
    This function is called only during system startup.

Arguments:

    Sequence - Pointer to storage for the sequence number.

Return Value:

    STATUS_SUCCESS when the sequence number is successfully read from the
        registry.

    STATUS_UNSUCCESSFUL when the sequence number is not correctly stored
        in the registry.

    Failure codes from ZwOpenKey() and ZwQueryValueKey() maybe returned.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyName;
    HANDLE Key;
    CHAR KeyValueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;

    PAGED_CODE();

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;

    RtlInitUnicodeString(&KeyPath, RPC_SEQUENCE_NUMBER_PATH);
    RtlInitUnicodeString(&KeyName, RPC_SEQUENCE_NUMBER_NAME);

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL
                              );

    Status =
    ZwOpenKey( &Key,
               GENERIC_READ,
               &ObjectAttributes
             );

    if (NT_SUCCESS(Status)) {
        Status =
        ZwQueryValueKey( Key,
                         &KeyName,
                         KeyValuePartialInformation,
                         KeyValueInformation,
                         sizeof(KeyValueBuffer),
                         &ResultLength
                       );

        ZwClose( Key );
        }

    if (NT_SUCCESS(Status)) {
        if ( KeyValueInformation->Type == REG_DWORD &&
             KeyValueInformation->DataLength == sizeof(ULONG)
           ) {
            *Sequence = *(PULONG)KeyValueInformation->Data;
            }
        else {
            Status = STATUS_UNSUCCESSFUL;
            }
        }

    return(Status);
}


NTSTATUS
ExpUuidSaveSequenceNumber(
    IN ULONG Sequence
    )
/*++

Routine Description:

    This function saves the uuid sequence number in the registry.  This
    value will be read by ExpUuidLoadSequenceNumber during the next boot.

    This routine assumes that the current thread has exclusive access
    to the the ExpUuid* values.

Arguments:

    Sequence - The sequence number to save.

Return Value:

    STATUS_SUCCESS

    Failure codes from ZwOpenKey() and ZwSetValueKey() maybe returned.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyName;
    HANDLE Key;

    PAGED_CODE();

    RtlInitUnicodeString(&KeyPath, RPC_SEQUENCE_NUMBER_PATH);
    RtlInitUnicodeString(&KeyName, RPC_SEQUENCE_NUMBER_NAME);

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL
                              );

    Status =
    ZwOpenKey( &Key,
               GENERIC_READ | GENERIC_WRITE,
               &ObjectAttributes
             );

    if (NT_SUCCESS(Status)) {
        Status =
        ZwSetValueKey( Key,
                       &KeyName,
                       0,
                       REG_DWORD,
                       &Sequence,
                       sizeof(ULONG)
                     );

        ZwClose( Key );
        }

    return(Status);
}



NTSTATUS
ExpUuidSaveSequenceNumberIf ()

/*++

Routine Description:

    This function saves the ExpUuidSequenceNumber, but only
    if necessary (as determined by the ExpUuidSequenceNumberNotSaved
    flag).

    This routine assumes that the current thread has exclusive access
    to the ExpUuid* values.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS if the operation was successful.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    // Does the sequence number need to be saved?
    if (ExpUuidSequenceNumberNotSaved == TRUE) {

        // Print this message just to make sure we aren't hitting the
        // registry too much under normal usage.

        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_WARNING_LEVEL, "Uuid: Saving new sequence number.\n"));

        // Save the sequence number

        Status = ExpUuidSaveSequenceNumber(ExpUuidSequenceNumber);

        // Indicate that it's now been saved.
        if (NT_SUCCESS(Status)) {
            ExpUuidSequenceNumberNotSaved = FALSE;
            }
        }

    return( Status );
}




BOOLEAN
ExpUuidInitialization (
    VOID
    )
/*++

Routine Description:

    This function initializes the UUID allocation.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the initialization is successfully
    completed.  Otherwise, a value of FALSE is returned.

--*/

{
    PAGED_CODE();

    ExInitializeFastMutex(&ExpUuidLock);

    ExpUuidSequenceNumberValid = FALSE;

    // We can use the current time since we'll be changing the sequence number.

    KeQuerySystemTime(&ExpUuidLastTimeAllocated);

    return TRUE;
}


NTSTATUS
ExpAllocateUuids (
    OUT PLARGE_INTEGER Time,
    OUT PULONG Range,
    OUT PULONG Sequence
    )

/*++

Routine Description:

    Allocates a sequence number and a range of times for a set of UUIDs.
    The caller can use this together with the network address to
    generate complete UUIDs.

    This routine assumes that the current thread has exclusive access
    to the ExpUuid* values.

Arguments:

    Time - Supplies the address of a variable that will receive the
        start time (SYSTEMTIME format) of the range of time reserved.

    Range - Supplies the address of a variable that will receive the
        number of ticks (100ns) reserved after the value in Time.
        The range reserved is *Time to (*Time+*Range-1).

    Sequence - Supplies the address of a variable that will receive
        the time sequence number.  This value is used with the associated
        range of time to prevent problems with clocks going backwards.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_RETRY is returned if we're unable to reserve a range of
        UUIDs.  This will occur if system clock hasn't advanced
        and the allocator is out of cached values.

    STATUS_UNSUCCESSFUL is returned if some other service reports
        an error, most likly the registery.

--*/

{
    NTSTATUS Status;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER AvailableTime;

    PAGED_CODE();

    //
    // Make sure we have a valid sequence number.  If not, make one up.
    //

    if (ExpUuidSequenceNumberValid == FALSE) {

        Status = ExpUuidLoadSequenceNumber(&ExpUuidSequenceNumber);

        if (!NT_SUCCESS(Status)) {
            // Unable read the sequence number, this means we should make one up.

            LARGE_INTEGER PerfCounter;
            LARGE_INTEGER PerfFrequency;

            // This should only happen when we're called
            // for the first time on a given machine. (machine, not boot)

            KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_WARNING_LEVEL, "Uuid: Generating first sequence number.\n"));

            PerfCounter = KeQueryPerformanceCounter(&PerfFrequency);

            ExpUuidSequenceNumber ^= (ULONG)((ULONG_PTR)&Status) ^ PerfCounter.LowPart ^
                PerfCounter.HighPart ^ (ULONG)((ULONG_PTR)Sequence);
            }
        else {
            // We increment the sequence number on every boot.
            ExpUuidSequenceNumber++;
            }

        ExpUuidSequenceNumberValid = TRUE;
        ExpUuidSequenceNumberNotSaved = TRUE;

        }

    //
    // Get the current time, usually we will have plenty of avaliable
    // to give the caller.  But we may need to deal with time going
    // backwards and really fast machines.
    //

    KeQuerySystemTime(&CurrentTime);

    AvailableTime.QuadPart = CurrentTime.QuadPart - ExpUuidLastTimeAllocated.QuadPart;

    if (AvailableTime.QuadPart < 0) {

        // Time has been set time backwards. This means that we must make sure
        // that somebody increments the sequence number and saves the new
        // sequence number in the registry.

        ExpUuidSequenceNumberNotSaved = TRUE;
        ExpUuidSequenceNumber++;

        // The sequence number has been changed, so it's now okay to set time
        // backwards.  Since time is going backwards anyway, it's okay to set
        // it back an extra millisecond or two.

        ExpUuidLastTimeAllocated.QuadPart = CurrentTime.QuadPart - 20000;
        AvailableTime.QuadPart = 20000;
        }

    if (AvailableTime.QuadPart == 0) {
        // System time hasn't moved.  The caller should yield the CPU and retry.
        return(STATUS_RETRY);
        }

    //
    // Common case, time has moved forward.
    //

    if (AvailableTime.QuadPart > 10*1000*1000) {
        // We never want to give out really old (> 1 second) Uuids.
        AvailableTime.QuadPart = 10*1000*1000;
        }

    if (AvailableTime.QuadPart > 10*1000) {
        // We've got over a millisecond to give out.  We'll save some time for
        // another caller so that we can avoid returning STATUS_RETRY very often.
        *Range = 10*1000;
        AvailableTime.QuadPart -= 10*1000;
        }
    else {
        // Not much time avaiable, give it all away.
        *Range = (ULONG)AvailableTime.QuadPart;
        AvailableTime.QuadPart = 0;
        }

    Time->QuadPart = CurrentTime.QuadPart - (*Range + AvailableTime.QuadPart);

    ExpUuidLastTimeAllocated.QuadPart = Time->QuadPart + *Range;

    // Last time allocated is just after the range we hand back to the caller
    // this may be almost a second behind the true system time.

    *Sequence = ExpUuidSequenceNumber;


    return(STATUS_SUCCESS);
}

#define SEED_SIZE 6 * sizeof(CHAR)


NTSTATUS
NtSetUuidSeed (
    IN PCHAR Seed
    )
/*++

Routine Description:

    This routine is used to set the seed used for UUID generation. The seed
    will be set by RPCSS at startup and each time a card is replaced.

Arguments:

    Seed - Pointer to a six byte buffer

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_ACCESS_DENIED If caller doesn't have the permissions to make this call.
    You need to be logged on as Local System in order to call this API.

    STATUS_ACCESS_VIOLATION is returned if the Seed could not be read.

--*/
{
    NTSTATUS Status;
    LUID AuthenticationId;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    LUID SystemLuid = SYSTEM_LUID;
    BOOLEAN CapturedSubjectContext = FALSE;

    PAGED_CODE();

    ASSERT(KeGetPreviousMode() != KernelMode);

    try {
        //
        // Check if the caller has the appropriate permission
        //
        SeCaptureSubjectContext(&SubjectContext);
        CapturedSubjectContext = TRUE;

        Status = SeQueryAuthenticationIdToken(
                             SeQuerySubjectContextToken(&SubjectContext),
                             &AuthenticationId);
        if (!NT_SUCCESS(Status)) {
            ExRaiseStatus(Status);
            }

        if (RtlCompareMemory(&AuthenticationId, &SystemLuid, sizeof(LUID)) != sizeof(LUID)) {
            ExRaiseStatus(STATUS_ACCESS_DENIED);
            }

        //
        // Store the UUID seed
        //
        ProbeForReadSmallStructure(Seed, SEED_SIZE, sizeof(CHAR));
        RtlCopyMemory(&ExpUuidCachedValues.NodeId[0], Seed, SEED_SIZE);

        if ((Seed[0] & 0x80) == 0)
            {
            // If the high bit is not set the NodeId is a valid IEEE 802
            // address and should be globally unique.
            ExpUuidCacheValid = CACHE_VALID;
            }
        else
            {
            ExpUuidCacheValid = CACHE_LOCAL_ONLY;
            }

        Status = STATUS_SUCCESS;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if (CapturedSubjectContext) {
        SeReleaseSubjectContext( &SubjectContext );
        }

    return Status;
}


NTSTATUS
NtAllocateUuids (
    OUT PULARGE_INTEGER Time,
    OUT PULONG Range,
    OUT PULONG Sequence,
    OUT PCHAR Seed
    )

/*++

Routine Description:

    This function reserves a range of time for the caller(s) to use for
    handing out Uuids.  As far a possible the same range of time and
    sequence number will never be given out.

    (It's possible to reboot 2^14-1 times and set the clock backwards and then
    call this allocator and get a duplicate.  Since only the low 14bits of the
    sequence number are used in a real uuid.)

Arguments:

    Time - Supplies the address of a variable that will receive the
        start time (SYSTEMTIME format) of the range of time reserved.

    Range - Supplies the address of a variable that will receive the
        number of ticks (100ns) reserved after the value in Time.
        The range reserved is *Time to (*Time + *Range - 1).

    Sequence - Supplies the address of a variable that will receive
        the time sequence number.  This value is used with the associated
        range of time to prevent problems with clocks going backwards.

    Seed - Pointer to a 6 byte buffer. The current seed is written into this buffer.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_RETRY is returned if we're unable to reserve a range of
        UUIDs.  This may (?) occur if system clock hasn't advanced
        and the allocator is out of cached values.

    STATUS_ACCESS_VIOLATION is returned if the output parameter for the
        UUID cannot be written.

    STATUS_UNSUCCESSFUL is returned if some other service reports
        an error, most likly the registery.

--*/

{

    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    LARGE_INTEGER OutputTime;
    ULONG OutputRange;
    ULONG OutputSequence;
    PKTHREAD CurrentThread;

    PAGED_CODE();

    //
    // Establish an exception handler and attempt to write the output
    // arguments. If the write attempt fails, then return
    // the exception code as the service status. Otherwise return success
    // as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteSmallStructure((PVOID)Time, sizeof(LARGE_INTEGER), sizeof(ULONG));
            ProbeForWriteSmallStructure((PVOID)Range, sizeof(ULONG), sizeof(ULONG));
            ProbeForWriteSmallStructure((PVOID)Sequence, sizeof(ULONG), sizeof(ULONG));
            ProbeForWriteSmallStructure((PVOID)Seed, SEED_SIZE, sizeof(CHAR));
            }
    } except (ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    // Take the lock, because we're about to update the UUID cache.
    CurrentThread = KeGetCurrentThread ();
    KeEnterCriticalRegionThread(CurrentThread);
    ExAcquireFastMutexUnsafe(&ExpUuidLock);

    // Get the sequence number and a range of times that can
    // be used in UUID-generation.

    Status = ExpAllocateUuids( &OutputTime, &OutputRange, &OutputSequence );

    if( !NT_SUCCESS(Status) ) {
        ExReleaseFastMutexUnsafe(&ExpUuidLock);
        KeLeaveCriticalRegionThread(CurrentThread);
        return( Status );
    }

    // If necessary, save the sequence number.  If there's an error,
    // we'll just leave it marked as dirty, and retry on some future call.

    ExpUuidSaveSequenceNumberIf();

    // Release the lock
    ExReleaseFastMutexUnsafe(&ExpUuidLock);
    KeLeaveCriticalRegionThread(CurrentThread);

    //
    // Attempt to store the result of this call into the output parameters.
    // This is done within an exception handler in case output parameters
    // are now invalid.
    //

    try {
        Time->QuadPart = OutputTime.QuadPart;
        *Range = OutputRange;
        *Sequence = OutputSequence;
        RtlCopyMemory((PVOID) Seed, &ExpUuidCachedValues.NodeId[0], SEED_SIZE);
    } except (ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    return(STATUS_SUCCESS);
}




NTSTATUS
ExpUuidGetValues(
    OUT UUID_CACHED_VALUES_STRUCT *Values
    )
/*++

Routine Description:

    This routine allocates a block of UUIDs and stores them in
    the caller-provided cached-values structure.

    This routine assumes that the current thread has exclusive
    access to the ExpUuid* values.

    Note that the Time value in this cache is different than the
    Time value returned by NtAllocateUuids (and ExpAllocateUuids).
    As a result, the cache must be interpreted differently in
    order to determine the valid range.  The valid range from
    these two routines is:

        NtAllocateUuids:  [ Time, Time+Range )
        ExpUuidGetValues: ( Values.Time-Values.Range, Values.Time ]

Arguments:

    Values - Set to contain everything needed to allocate a block of uuids.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_RETRY is returned if we're unable to reserve a range of
        UUIDs.  This will occur if system clock hasn't advanced
        and the allocator is out of cached values.

    STATUS_NO_MEMORY is returned if we're unable to reserve a range
        of UUIDs, for some reason other than the clock not advancing.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER Time;
    ULONG Range;
    ULONG Sequence;

    PAGED_CODE();

    // Allocate a range of times for use in UUIDs.

    Status = ExpAllocateUuids(&Time, &Range, &Sequence);

    if (STATUS_RETRY == Status) {
        return(Status);
        }

    else if (!NT_SUCCESS(Status)) {
        return(STATUS_NO_MEMORY);
        }

    // ExpAllocateUuids keeps time in SYSTEM_TIME format which is 100ns ticks since
    // Jan 1, 1601.  UUIDs use time in 100ns ticks since Oct 15, 1582.

    // 17 Days in Oct + 30 (Nov) + 31 (Dec) + 18 years and 5 leap days.

    Time.QuadPart +=   (ULONGLONG) (1000*1000*10)       // seconds
                     * (ULONGLONG) (60 * 60 * 24)       // days
                     * (ULONGLONG) (17+30+31+365*18+5); // # of days

    ASSERT(Range);

    Values->ClockSeqHiAndReserved =
        UUID_RESERVED | (((UCHAR) (Sequence >> 8))
        & (UCHAR) UUID_CLOCK_SEQ_HI_MASK);

    Values->ClockSeqLow = (UCHAR) (Sequence & 0x00FF);


    // We'll modify the Time value so that it indicates the
    // end of the range rather than the beginning of it.

    // The order of these assignments is important

    Values->Time = Time.QuadPart + (Range - 1);
    Values->AllocatedCount = Range;

    return(STATUS_SUCCESS);
}



NTSTATUS
ExUuidCreate(
    OUT UUID *Uuid
    )

/*++

Routine Description:

    This routine creates a DCE UUID and returns it in the caller's
    buffer.

Arguments:

    Uuid - will receive the UUID.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_RETRY is returned if we're unable to reserve a range of
        UUIDs.  This will occur if system clock hasn't advanced
        and the allocator is out of cached values.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    UUID_GENERATE  *UuidGen = (UUID_GENERATE *) Uuid;
    ULONGLONG       Time;
    LONG            Delta;
    PKTHREAD        CurrentThread;

    PAGED_CODE();

    //
    // Get a value from the cache.  If the cache is empty, we'll fill
    // it and retry.  The first time cache will be empty.
    //

    CurrentThread = KeGetCurrentThread ();
    for(;;) {

        // Get the highest value in the cache (though it may not
        // be available).
        Time = ExpUuidCachedValues.Time;

        // Copy the static info into the UUID.  We can't do this later
        // because the clock sequence could be updated by another thread.

        *(PULONG)&UuidGen->ClockSeqHiAndReserved =
            *(PULONG)&ExpUuidCachedValues.ClockSeqHiAndReserved;
        *(PULONG)&UuidGen->NodeId[2] =
            *(PULONG)&ExpUuidCachedValues.NodeId[2];

        // See what we need to subtract from Time to get a valid GUID.
        Delta = InterlockedDecrement(&ExpUuidCachedValues.AllocatedCount);

        if (Time != ExpUuidCachedValues.Time) {

            // If our captured time doesn't match the cache then another
            // thread already took the lock and updated the cache. We'll
            // just loop and try again.
            continue;
        }

        // If the cache hadn't already run dry, we can break out of this retry
        // loop.
        if (Delta >= 0) {
            break;
        }

        //
        // Allocate a new block of Uuids.
        //

        // Take the cache lock
        KeEnterCriticalRegionThread(CurrentThread);
        ExAcquireFastMutexUnsafe(&ExpUuidLock);

        // If the cache has already been updated, try again.
        if (Time != ExpUuidCachedValues.Time) {
            // Release the lock
            ExReleaseFastMutexUnsafe(&ExpUuidLock);
            KeLeaveCriticalRegionThread(CurrentThread);
            continue;
        }

        // Update the cache.
        Status = ExpUuidGetValues( &ExpUuidCachedValues );

        if (Status != STATUS_SUCCESS) {
            // Release the lock
            ExReleaseFastMutexUnsafe(&ExpUuidLock);
            KeLeaveCriticalRegionThread(CurrentThread);
            return(Status);
        }

        // The sequence number may have been dirtied, see if it needs
        // to be saved.  If there's an error, we'll ignore it and
        // retry on a future call.

        ExpUuidSaveSequenceNumberIf();

        // Release the lock
        ExReleaseFastMutexUnsafe(&ExpUuidLock);
        KeLeaveCriticalRegionThread(CurrentThread);

    // Loop
    }

    // Adjust the time to that of the next available UUID.
    Time -= Delta;

    // Finish filling in the UUID.

    UuidGen->TimeLow = (ULONG) Time;
    UuidGen->TimeMid = (USHORT) (Time >> 32);
    UuidGen->TimeHiAndVersion = (USHORT)
        (( (USHORT)(Time >> (32+16))
        & UUID_TIME_HIGH_MASK) | UUID_VERSION);

    ASSERT(Status == STATUS_SUCCESS);

    if (ExpUuidCacheValid == CACHE_LOCAL_ONLY) {
        Status = RPC_NT_UUID_LOCAL_ONLY;
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\win32.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    win32.c

Abstract:

   This module implements the definition of the executive Win32 objects.
   Functions to manage these objects are implemented in win32k.sys.

Author:

    James I. Anderson (jima) 14-June-1995

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

//
// Address of windowstation and desktop object type descriptors.
//

POBJECT_TYPE ExWindowStationObjectType;
POBJECT_TYPE ExDesktopObjectType;

PKWIN32_CLOSEMETHOD_CALLOUT ExDesktopCloseProcedureCallout;
PKWIN32_CLOSEMETHOD_CALLOUT ExWindowStationCloseProcedureCallout;
PKWIN32_OPENMETHOD_CALLOUT ExDesktopOpenProcedureCallout;
PKWIN32_OKTOCLOSEMETHOD_CALLOUT ExDesktopOkToCloseProcedureCallout;
PKWIN32_OKTOCLOSEMETHOD_CALLOUT ExWindowStationOkToCloseProcedureCallout;
PKWIN32_DELETEMETHOD_CALLOUT ExDesktopDeleteProcedureCallout;
PKWIN32_DELETEMETHOD_CALLOUT ExWindowStationDeleteProcedureCallout;
PKWIN32_PARSEMETHOD_CALLOUT ExWindowStationParseProcedureCallout;
PKWIN32_OPENMETHOD_CALLOUT ExWindowStationOpenProcedureCallout;

//
// common types for above win32 callouts and parameters
//

typedef PVOID PKWIN32_CALLOUT_PARAMETERS;

typedef
NTSTATUS
(*PKWIN32_CALLOUT) (
    IN PKWIN32_CALLOUT_PARAMETERS
    );

NTSTATUS
ExpWin32SessionCallout(
    IN  PKWIN32_CALLOUT CalloutRoutine,
    IN  PKWIN32_CALLOUT_PARAMETERS Parameters,
    IN  ULONG SessionId,
    OUT PNTSTATUS CalloutStatus  OPTIONAL
    );

VOID
ExpWin32CloseProcedure(
   IN PEPROCESS Process OPTIONAL,
   IN PVOID Object,
   IN ACCESS_MASK GrantedAccess,
   IN ULONG ProcessHandleCount,
   IN ULONG SystemHandleCount );

BOOLEAN
ExpWin32OkayToCloseProcedure(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN HANDLE Handle,
    IN KPROCESSOR_MODE PreviousMode
    );

VOID
ExpWin32DeleteProcedure(
    IN PVOID    Object
    );

NTSTATUS
ExpWin32ParseProcedure (
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN OUT PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    );

NTSTATUS
ExpWin32OpenProcedure(
    IN OB_OPEN_REASON OpenReason,
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG HandleCount
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, ExpWin32Initialization)
#pragma alloc_text (PAGE, ExpWin32CloseProcedure)
#pragma alloc_text (PAGE, ExpWin32OkayToCloseProcedure)
#pragma alloc_text (PAGE, ExpWin32DeleteProcedure)
#pragma alloc_text (PAGE, ExpWin32OpenProcedure)
#pragma alloc_text (PAGE, ExpWin32ParseProcedure)
#pragma alloc_text (PAGE, ExpWin32SessionCallout)
#endif


/*
 * windowstation generic mapping
 */
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING ExpWindowStationMapping = {
    STANDARD_RIGHTS_READ,
    STANDARD_RIGHTS_WRITE,
    STANDARD_RIGHTS_EXECUTE,
    STANDARD_RIGHTS_REQUIRED
};

/*
 * desktop generic mapping
 */
const GENERIC_MAPPING ExpDesktopMapping = {
    STANDARD_RIGHTS_READ,
    STANDARD_RIGHTS_WRITE,
    STANDARD_RIGHTS_EXECUTE,
    STANDARD_RIGHTS_REQUIRED
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

/*++

Routine Description:

    Close Procedure for Win32k windostation and desktop objects

Arguments:
    Defined by OB_CLOSE_METHOD

Return Value:


--*/
VOID ExpWin32CloseProcedure(
   IN PEPROCESS Process OPTIONAL,
   IN PVOID Object,
   IN ACCESS_MASK GrantedAccess,
   IN ULONG ProcessHandleCount,
   IN ULONG SystemHandleCount )
{

   //
   // SessionId is the first field in the Win32k Object structure
   //
   ULONG SessionId = *((PULONG)Object);
   WIN32_CLOSEMETHOD_PARAMETERS CloseParams;
   NTSTATUS Status;

   CloseParams.Process = Process;
   CloseParams.Object  =  Object;
   CloseParams.GrantedAccess = GrantedAccess;
   CloseParams.ProcessHandleCount = ProcessHandleCount;
   CloseParams.SystemHandleCount =  SystemHandleCount;

   if ((OBJECT_TO_OBJECT_HEADER(Object)->Type) == ExDesktopObjectType) {

       Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExDesktopCloseProcedureCallout,
                                       (PKWIN32_CALLOUT_PARAMETERS)&CloseParams,
                                       SessionId,
                                       NULL);
       ASSERT(NT_SUCCESS(Status));

   } else if ((OBJECT_TO_OBJECT_HEADER(Object)->Type) == ExWindowStationObjectType) {

       Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExWindowStationCloseProcedureCallout,
                                       (PKWIN32_CALLOUT_PARAMETERS)&CloseParams,
                                       SessionId,
                                       NULL);
       ASSERT(NT_SUCCESS(Status));

   } else {
      ASSERT((OBJECT_TO_OBJECT_HEADER(Object)->Type) == ExDesktopObjectType || (OBJECT_TO_OBJECT_HEADER(Object)->Type == ExWindowStationObjectType));

   }


}

/*++

Routine Description:

    OkayToClose Procedure for Win32k windostation and desktop objects

Arguments:
    Defined by OB_OKAYTOCLOSE_METHOD


Return Value:


--*/
BOOLEAN ExpWin32OkayToCloseProcedure(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN HANDLE Handle,
    IN KPROCESSOR_MODE PreviousMode
    )
{
   //
   // SessionId is the first field in the Win32k Object structure
   //
   ULONG SessionId = *((PULONG)Object);
   WIN32_OKAYTOCLOSEMETHOD_PARAMETERS OKToCloseParams;
   NTSTATUS Status, CallStatus = STATUS_UNSUCCESSFUL;

   OKToCloseParams.Process      = Process;
   OKToCloseParams.Object       = Object;
   OKToCloseParams.Handle       = Handle;
   OKToCloseParams.PreviousMode = PreviousMode;

   if (OBJECT_TO_OBJECT_HEADER(Object)->Type == ExDesktopObjectType) {

       Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExDesktopOkToCloseProcedureCallout,
                                       (PKWIN32_CALLOUT_PARAMETERS)&OKToCloseParams,
                                       SessionId,
                                       &CallStatus);
       ASSERT(NT_SUCCESS(Status));

   } else if (OBJECT_TO_OBJECT_HEADER(Object)->Type == ExWindowStationObjectType) {

       Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExWindowStationOkToCloseProcedureCallout,
                                       (PKWIN32_CALLOUT_PARAMETERS)&OKToCloseParams,
                                       SessionId,
                                       &CallStatus);
       ASSERT(NT_SUCCESS(Status));

   } else {
      ASSERT(OBJECT_TO_OBJECT_HEADER(Object)->Type == ExDesktopObjectType ||
             OBJECT_TO_OBJECT_HEADER(Object)->Type == ExWindowStationObjectType);

   }

   return (BOOLEAN)(NT_SUCCESS(CallStatus));

}


/*++

Routine Description:

    Delete Procedure for Win32k windostation and desktop objects

Arguments:
    Defined by OB_DELETE_METHOD


Return Value:


--*/
VOID ExpWin32DeleteProcedure(
    IN PVOID    Object
    )
{
   //
   // SessionId is the first field in the Win32k Object structure
   //
   ULONG SessionId = *((PULONG)Object);
   WIN32_DELETEMETHOD_PARAMETERS DeleteParams;
   NTSTATUS Status;

   DeleteParams.Object  =  Object;


   if (OBJECT_TO_OBJECT_HEADER(Object)->Type == ExDesktopObjectType) {

       Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExDesktopDeleteProcedureCallout,
                                       (PKWIN32_CALLOUT_PARAMETERS)&DeleteParams,
                                       SessionId,
                                       NULL);
       ASSERT(NT_SUCCESS(Status));

   } else if (OBJECT_TO_OBJECT_HEADER(Object)->Type == ExWindowStationObjectType) {

       Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExWindowStationDeleteProcedureCallout,
                                       (PKWIN32_CALLOUT_PARAMETERS)&DeleteParams,
                                       SessionId,
                                       NULL);
       ASSERT(NT_SUCCESS(Status));

   } else {
      ASSERT(OBJECT_TO_OBJECT_HEADER(Object)->Type == ExDesktopObjectType ||
             OBJECT_TO_OBJECT_HEADER(Object)->Type == ExWindowStationObjectType);

   }


}

/*++

Routine Description:

    Open Procedure for Win32k desktop objects

Arguments:
    Defined by OB_OPEN_METHOD

Return Value:


--*/


NTSTATUS
ExpWin32OpenProcedure(
    IN OB_OPEN_REASON OpenReason,
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG HandleCount
    )
{

   //
   // SessionId is the first field in the Win32k Object structure
   //
   ULONG SessionId = *((PULONG)Object);
   WIN32_OPENMETHOD_PARAMETERS OpenParams;
   NTSTATUS Status = STATUS_UNSUCCESSFUL;

   OpenParams.OpenReason = OpenReason;
   OpenParams.Process  =  Process;
   OpenParams.Object = Object;
   OpenParams.GrantedAccess = GrantedAccess;
   OpenParams.HandleCount =  HandleCount;

   
   if ((OBJECT_TO_OBJECT_HEADER(Object)->Type) == ExDesktopObjectType) {

       Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExDesktopOpenProcedureCallout,
                                       (PKWIN32_CALLOUT_PARAMETERS)&OpenParams,
                                       SessionId,
                                       NULL);

       ASSERT(NT_SUCCESS(Status));

   } else if ((OBJECT_TO_OBJECT_HEADER(Object)->Type) == ExWindowStationObjectType) {

       Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExWindowStationOpenProcedureCallout,
                                       (PKWIN32_CALLOUT_PARAMETERS)&OpenParams,
                                       SessionId,
                                       NULL);
       ASSERT(NT_SUCCESS(Status));

   } else {
      ASSERT((OBJECT_TO_OBJECT_HEADER(Object)->Type) == ExDesktopObjectType || (OBJECT_TO_OBJECT_HEADER(Object)->Type == ExWindowStationObjectType));

   }
   
   return Status;
}

/*++

Routine Description:

    Parse Procedure for Win32k windostation objects

Arguments:
    Defined by OB_PARSE_METHOD


Return Value:


--*/

NTSTATUS ExpWin32ParseProcedure (
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN OUT PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    )
{

   //
   // SessionId is the first field in the Win32k Object structure
   //
   ULONG SessionId = *((PULONG)ParseObject);
   WIN32_PARSEMETHOD_PARAMETERS ParseParams;
   NTSTATUS Status, CallStatus = STATUS_UNSUCCESSFUL;

   ParseParams.ParseObject = ParseObject;
   ParseParams.ObjectType  =  ObjectType;
   ParseParams.AccessState = AccessState;
   ParseParams.AccessMode = AccessMode;
   ParseParams.Attributes = Attributes;
   ParseParams.CompleteName = CompleteName;
   ParseParams.RemainingName = RemainingName;
   ParseParams.Context = Context;
   ParseParams.SecurityQos = SecurityQos;
   ParseParams.Object = Object;

   //
   // Parse Procedure is only provided for WindowStation objects
   //
   Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExWindowStationParseProcedureCallout,
                                   (PKWIN32_CALLOUT_PARAMETERS)&ParseParams,
                                   SessionId,
                                   &CallStatus);
   ASSERT(NT_SUCCESS(Status));

   return CallStatus;

}


BOOLEAN
ExpWin32Initialization (
    )

/*++

Routine Description:

    This function creates the Win32 object type descriptors at system
    initialization and stores the address of the object type descriptor
    in local static storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the Win32 object type descriptors are
    successfully created. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"WindowStation");

    //
    // Create windowstation object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.GenericMapping = ExpWindowStationMapping;
    ObjectTypeInitializer.SecurityRequired = TRUE;
    ObjectTypeInitializer.PoolType = NonPagedPool;

    ObjectTypeInitializer.CloseProcedure  = ExpWin32CloseProcedure;
    ObjectTypeInitializer.DeleteProcedure = ExpWin32DeleteProcedure;
    ObjectTypeInitializer.OkayToCloseProcedure = ExpWin32OkayToCloseProcedure;

    ObjectTypeInitializer.ParseProcedure  = ExpWin32ParseProcedure;
    ObjectTypeInitializer.OpenProcedure   = ExpWin32OpenProcedure;

    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK |
                                              OBJ_PERMANENT |
                                              OBJ_EXCLUSIVE;
    ObjectTypeInitializer.ValidAccessMask = STANDARD_RIGHTS_REQUIRED;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExWindowStationObjectType);

    //
    // If the windowstation object type descriptor was not successfully
    // created, then return a value of FALSE.
    //

    if (!NT_SUCCESS(Status))
        return FALSE;



    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Desktop");

    ObjectTypeInitializer.ParseProcedure       = NULL; //Desktop has no Parse Procedure

    //
    // Create windowstation object type descriptor.
    //

    ObjectTypeInitializer.GenericMapping = ExpDesktopMapping;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExDesktopObjectType);


    //
    // If the desktop object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}



NTSTATUS
ExpWin32SessionCallout(
    IN  PKWIN32_CALLOUT CalloutRoutine,
    IN  PKWIN32_CALLOUT_PARAMETERS Parameters,
    IN  ULONG SessionId,
    OUT PNTSTATUS CalloutStatus  OPTIONAL
    )
/*++

Routine Description:

    This routine calls the specified callout routine in session space, for the
    specified session.

Parameters:

    CalloutRoutine - Callout routine in session space.

    Parameters     - Parameters to pass the callout routine.

    SessionId      - Specifies the ID of the session in which the specified
                     callout routine is to be called.

    CalloutStatus  - Optionally, supplies the address of a variable to receive
                     the NTSTATUS code returned by the callout routine.

Return Value:

    Status code that indicates whether or not the function was successful.

Notes:

    Returns STATUS_NOT_FOUND if the specified session was not found.

--*/
{
    NTSTATUS Status, CallStatus;
    PVOID OpaqueSession;
    KAPC_STATE ApcState;

    PAGED_CODE();

    //
    // Make sure we have all the information we need to deliver notification.
    //
    if (CalloutRoutine == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure the callout routine in session space.
    //
    ASSERT(MmIsSessionAddress((PVOID)CalloutRoutine));

    if ((PsGetCurrentProcess()->Flags & PS_PROCESS_FLAGS_IN_SESSION) &&
        (SessionId == PsGetCurrentProcessSessionId())) {
        //
        // If the call is from a user mode process, and we are asked to call the
        // current session, call directly.
        //
        CallStatus = (CalloutRoutine)(Parameters);

        //
        // Return the callout status.
        //
        if (ARGUMENT_PRESENT(CalloutStatus)) {
            *CalloutStatus = CallStatus;
        }

        Status = STATUS_SUCCESS;

    } else {
        //
        // Reference the session object for the specified session.
        //
        OpaqueSession = MmGetSessionById(SessionId);
        if (OpaqueSession == NULL) {
            return STATUS_NOT_FOUND;
        }

        //
        // Attach to the specified session.
        //
        Status = MmAttachSession(OpaqueSession, &ApcState);
        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_WARNING_LEVEL,
                       "ExpWin32SessionCallout: "
                       "could not attach to 0x%p, session %d for registered notification callout @ 0x%p\n",
                       OpaqueSession,
                       SessionId,
                       CalloutRoutine));
            MmQuitNextSession(OpaqueSession);
            return Status;
        }

        //
        // Dispatch notification to the callout routine.
        //
        CallStatus = (CalloutRoutine)(Parameters);

        //
        // Return the callout status.
        //
        if (ARGUMENT_PRESENT(CalloutStatus)) {
            *CalloutStatus = CallStatus;
        }

        //
        // Detach from the session.
        //
        Status = MmDetachSession(OpaqueSession, &ApcState);
        ASSERT(NT_SUCCESS(Status));

        //
        // Dereference the session object.
        //
        Status = MmQuitNextSession(OpaqueSession);
        ASSERT(NT_SUCCESS(Status));
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\tprofile.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tprofile.c

Abstract:

    User-mode test for profile object.

    Note, this will be added to TEX.C

Author:

    Lou Perazzoli (loup) 24-Sep-1990

Revision History:

--*/
#include <nt.h>

main()
{
    HANDLE Profile, Profile2;
    ULONG Hack;
    PULONG Buffer;
    HANDLE CurrentProcessHandle;
    ULONG Size1;
    NTSTATUS status;

    Buffer = &Hack;

    CurrentProcessHandle = NtCurrentProcess();

    status = NtCreateProfile (&Profile,
                              CurrentProcessHandle,
                              NULL,
                              0xFFFFFFFF,
                              16,
                              Buffer,
                              (ULONG)64*1024,
                              ProfileTime,
                              (KAFFINITY)-1);

    if (status != STATUS_SUCCESS) {
        DbgPrint("(Expected) create profile #1 failed - status %lx\n", status);
    }

    status = NtStartProfile (Profile);
    if (status != STATUS_SUCCESS) {
        DbgPrint("(Expected) start profile #1 failed - status %lx\n", status);
    }

    status = NtStopProfile (Profile);
    if (status != STATUS_SUCCESS) {
        DbgPrint("(Expected) stop profile #1 failed - status %lx\n", status);
    }

    Size1 = 1024*64;
    Buffer = NULL;

    status = NtAllocateVirtualMemory (CurrentProcessHandle, (PVOID *)&Buffer,
                        0, &Size1, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    //
    // This should fail as buffersize is too small.
    //

    status = NtCreateProfile (&Profile,
                              NtCurrentProcess(),
                              NULL,
                              0xFFFFFFFF,
                              16,
                              Buffer,
                              (ULONG)64*1024,
                              ProfileTime,
                              (KAFFINITY)-1);

    if (status != STATUS_SUCCESS) {
        DbgPrint("(Expected) create profile #2 failed - status %lx\n", status);
    }

    status = NtStartProfile (Profile);
    if (status != STATUS_SUCCESS) {
        DbgPrint("(Expected) start profile #2 failed - status %lx\n", status);
    }

    status = NtStopProfile (Profile);
    if (status != STATUS_SUCCESS) {
        DbgPrint("(Expected) stop profile #2 failed - status %lx\n", status);
    }

    status = NtClose (Profile);

    //
    // This should succeed.
    //

    status = NtCreateProfile (&Profile,
                              NtCurrentProcess(),
                              NULL,
                              0xFFFFFFFF,
                              18,
                              Buffer,
                              (ULONG)64*1024,
                              ProfileTime,
                              (KAFFINITY)-1);

    if (status != STATUS_SUCCESS) {
        DbgPrint("(Unexpected) create profile #3 failed - status %lx\n", status);
    }

    status = NtStartProfile (Profile);
    if (status != STATUS_SUCCESS) {
        DbgPrint("(Unexpected) start profile #3 failed - status %lx\n", status);
    }

    status = NtStopProfile (Profile);
    if (status != STATUS_SUCCESS) {
        DbgPrint("(Unexpected) stop profile #3 failed - status %lx\n", status);
    }

    status = NtClose (Profile);

    //
    // Attempt to create a profile that can't work because the
    // address range is too big.
    //

    status = NtCreateProfile (&Profile,
                              NtCurrentProcess(),
                              (PVOID)0x203030,
                              0xffffffff,
                              6,
                              Buffer,
                              (ULONG)64*1024,
                              ProfileTime,
                              (KAFFINITY)-1);

    if (status != STATUS_SUCCESS) {
        DbgPrint("(Expected) create profile #4 failed - status %lx\n", status);
    }

    status = NtStartProfile (Profile);
    if (status != STATUS_SUCCESS) {
        DbgPrint("(Expected) start profile #4 failed - status %lx\n", status);
    }

    status = NtStopProfile (Profile);
    if (status != STATUS_SUCCESS) {
        DbgPrint("(Expected) stop profile #4 failed - status %lx\n", status);
    }

    status = NtClose (Profile);

    //
    // Attempt to create a sucessful profile.
    //

    status = NtCreateProfile (&Profile,
                              NtCurrentProcess(),
                              (PVOID)0x80000000,
                              0x7fffffff,
                              17,
                              Buffer,
                              (ULONG)64*1024,
                              ProfileTime,
                              (KAFFINITY)-1);

    if (status != STATUS_SUCCESS) {
        DbgPrint("(Unexpected) create profile #5 failed - status %lx\n", status);
    }

    status = NtStartProfile (Profile);
    if (status != STATUS_SUCCESS) {
        DbgPrint("(Unexpected) start profile #5 failed - status %lx\n", status);
    }

    status = NtStopProfile (Profile);
    if (status != STATUS_SUCCESS) {
        DbgPrint("(Unexpected) stop profile #5 failed - status %lx\n", status);
    }

    //
    // now start it again.
    //

    status = NtStartProfile (Profile);
    if (status != STATUS_SUCCESS) {
        DbgPrint("(Unexpected) start profile #6.1 failed - status %lx\n", status);
    }

    //
    // now start it again, should fail.
    //

    status = NtStartProfile (Profile);
    if (status != STATUS_SUCCESS) {
        DbgPrint("(Expected) start profile #6.2 failed - status %lx\n", status);
    }

    //
    // now create another one (using the same buffer).
    //

    status = NtCreateProfile (&Profile2,
                              NtCurrentProcess(),
                              NULL,
                              0x3000000,
                              15,
                              Buffer,
                              (ULONG)64*1024,
                              ProfileTime,
                              (KAFFINITY)-1);


    if (status != STATUS_SUCCESS) {
        DbgPrint("create profile #7 failed - status %lx\n", status);
    }

    status = NtStartProfile (Profile2);
    if (status != STATUS_SUCCESS) {
        DbgPrint("start profile #7.1 failed - status %lx\n", status);
    }

    status = NtStopProfile (Profile2);
    if (status != STATUS_SUCCESS) {
        DbgPrint("stop profile #7.2 failed - status %lx\n", status);
    }

    status = NtStopProfile (Profile2);
    if (status != STATUS_SUCCESS) {
        DbgPrint("(Expected) stop profile #7.3 failed - status %lx\n", status);
    }

    status = NtStartProfile (Profile2);
    if (status != STATUS_SUCCESS) {
        DbgPrint("start profile #7.4 failed - status %lx\n", status);
    }

    status = NtClose (Profile);
    if (status != STATUS_SUCCESS) {
        DbgPrint("close profile #7.5 failed - status %lx\n", status);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\worker.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    worker.c

Abstract:

    This module implements a worker thread and a set of functions for
    passing work to it.

Author:

    Steve Wood (stevewo) 25-Jul-1991


Revision History:

--*/

#include "exp.h"

//
// Define balance set wait object types.
//

typedef enum _BALANCE_OBJECT {
    TimerExpiration,
    ThreadSetManagerEvent,
    ShutdownEvent,
    MaximumBalanceObject
} BALANCE_OBJECT;

//
// If this assertion fails then we must supply our own array of wait blocks.
//

C_ASSERT(MaximumBalanceObject <= THREAD_WAIT_OBJECTS);

//
// This is the structure passed around during shutdown
//

typedef struct {
    WORK_QUEUE_ITEM WorkItem;
    WORK_QUEUE_TYPE QueueType;
    PETHREAD        PrevThread;
} SHUTDOWN_WORK_ITEM, *PSHUTDOWN_WORK_ITEM;

//
// Used for disabling stack swapping
//

typedef struct _EXP_WORKER_LINK {
    LIST_ENTRY List;
    PETHREAD   Thread;
    struct _EXP_WORKER_LINK **StackRef;
} EXP_WORKER_LINK, *PEXP_WORKER_LINK;

//
// Define priorities for delayed and critical worker threads.
// Note that these do not run at realtime.
//
// They run at csrss and below csrss to avoid pre-empting the
// user interface under heavy load.
//

#define DELAYED_WORK_QUEUE_PRIORITY         (12 - NORMAL_BASE_PRIORITY)
#define CRITICAL_WORK_QUEUE_PRIORITY        (13 - NORMAL_BASE_PRIORITY)
#define HYPER_CRITICAL_WORK_QUEUE_PRIORITY  (15 - NORMAL_BASE_PRIORITY)

//
// Number of worker threads to create for each type of system.
//

#define MAX_ADDITIONAL_THREADS 16
#define MAX_ADDITIONAL_DYNAMIC_THREADS 16

#define SMALL_NUMBER_OF_THREADS 2
#define MEDIUM_NUMBER_OF_THREADS 3
#define LARGE_NUMBER_OF_THREADS 5

//
// 10-minute timeout used for terminating dynamic work item worker threads.
//

#define DYNAMIC_THREAD_TIMEOUT ((LONGLONG)10 * 60 * 1000 * 1000 * 10)

//
// 1-second timeout used for waking up the worker thread set manager.
//

#define THREAD_SET_INTERVAL (1 * 1000 * 1000 * 10)

//
// Flag to pass in to the worker thread, indicating whether it is dynamic
// or not.
//

#define DYNAMIC_WORKER_THREAD 0x80000000

//
// Per-queue dynamic thread state.
//

EX_WORK_QUEUE ExWorkerQueue[MaximumWorkQueue];

//
// Additional worker threads... Controlled using registry settings
//

ULONG ExpAdditionalCriticalWorkerThreads;
ULONG ExpAdditionalDelayedWorkerThreads;

ULONG ExCriticalWorkerThreads;
ULONG ExDelayedWorkerThreads;

//
// Global events to wake up the thread set manager.
//

KEVENT ExpThreadSetManagerEvent;
KEVENT ExpThreadSetManagerShutdownEvent;

//
// A reference to the balance manager thread, so that shutdown can
// wait for it to terminate.
//

PETHREAD ExpWorkerThreadBalanceManagerPtr;

//
// A pointer to the last worker thread to exit (so the balance manager
// can wait for it before exiting).
//

PETHREAD ExpLastWorkerThread;

//
// These are used to keep track of the set of workers, and whether or
// not we're allowing them to be paged.  Note that we can't use this
// list for shutdown (sadly), as we can't just terminate the threads,
// we need to flush their queues.
//

FAST_MUTEX ExpWorkerSwapinMutex;
LIST_ENTRY ExpWorkerListHead;
BOOLEAN    ExpWorkersCanSwap;

//
// Worker queue item that can be filled in by the kernel debugger
// to get code to run on the system.
//

WORK_QUEUE_ITEM ExpDebuggerWorkItem;
PVOID ExpDebuggerProcessAttach;
PVOID ExpDebuggerPageIn;
ULONG ExpDebuggerWork;

VOID
ExpCheckDynamicThreadCount (
    VOID
    );

NTSTATUS
ExpCreateWorkerThread (
    WORK_QUEUE_TYPE QueueType,
    BOOLEAN Dynamic
    );

VOID
ExpDetectWorkerThreadDeadlock (
    VOID
    );

VOID
ExpWorkerThreadBalanceManager (
    IN PVOID StartContext
    );

VOID
ExpSetSwappingKernelApc (
    IN PKAPC Apc,
    OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

//
// Procedure prototypes for the worker threads.
//

VOID
ExpWorkerThread (
    IN PVOID StartContext
    );

LOGICAL
ExpCheckQueueShutdown (
    IN WORK_QUEUE_TYPE QueueType,
    IN PSHUTDOWN_WORK_ITEM ShutdownItem
    );

VOID
ExpShutdownWorker (
    IN PVOID Parameter
    );

VOID
ExpDebuggerWorker(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpWorkerInitialization)
#pragma alloc_text(PAGE, ExpCheckDynamicThreadCount)
#pragma alloc_text(PAGE, ExpCreateWorkerThread)
#pragma alloc_text(PAGE, ExpDetectWorkerThreadDeadlock)
#pragma alloc_text(PAGE, ExpWorkerThreadBalanceManager)
#pragma alloc_text(PAGE, ExSwapinWorkerThreads)
#pragma alloc_text(PAGEKD, ExpDebuggerWorker)
#pragma alloc_text(PAGELK, ExpSetSwappingKernelApc)
#pragma alloc_text(PAGELK, ExpCheckQueueShutdown)
#pragma alloc_text(PAGELK, ExpShutdownWorker)
#pragma alloc_text(PAGELK, ExpShutdownWorkerThreads)
#endif

LOGICAL
__forceinline
ExpNewThreadNecessary (
    IN PEX_WORK_QUEUE Queue
    )

/*++

Routine Description:

    This function checks the supplied worker queue and determines whether
    it is appropriate to spin up a dynamic worker thread for that queue.

Arguments:

    Queue - Supplies the queue that should be examined.

Return Value:

    TRUE if the given work queue would benefit from the creation of an
    additional thread, FALSE if not.

--*/
{
    if ((Queue->Info.MakeThreadsAsNecessary == 1) &&
        (IsListEmpty (&Queue->WorkerQueue.EntryListHead) == FALSE) &&
        (Queue->WorkerQueue.CurrentCount < Queue->WorkerQueue.MaximumCount) &&
        (Queue->DynamicThreadCount < MAX_ADDITIONAL_DYNAMIC_THREADS)) {

        //
        // We know these things:
        //
        // - This queue is eligible for dynamic creation of threads to try
        //   to keep the CPUs busy,
        //
        // - There are work items waiting in the queue,
        //
        // - The number of runable worker threads for this queue is less than
        //   the number of processors on this system, and
        //
        // - We haven't reached the maximum dynamic thread count.
        //
        // An additional worker thread at this point will help clear the
        // backlog.
        //

        return TRUE;
    }

    //
    // One of the above conditions is false.
    //

    return FALSE;
}

NTSTATUS
ExpWorkerInitialization (
    VOID
    )
{
    ULONG Index;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG NumberOfDelayedThreads;
    ULONG NumberOfCriticalThreads;
    ULONG NumberOfThreads;
    NTSTATUS Status;
    HANDLE Thread;
    BOOLEAN NtAs;
    WORK_QUEUE_TYPE WorkQueueType;

    ExInitializeFastMutex (&ExpWorkerSwapinMutex);
    InitializeListHead (&ExpWorkerListHead);
    ExpWorkersCanSwap = TRUE;

    //
    // Set the number of worker threads based on the system size.
    //

    NtAs = MmIsThisAnNtAsSystem();

    NumberOfCriticalThreads = MEDIUM_NUMBER_OF_THREADS;

    //
    // 2001-07-13 CenkE Incremented boot time number of delayed threads.
    // We did this in Windows XP, because 3COM NICs would take a long
    // time with the network stack tying up the delayed worker threads.
    // When Mm would need a worker thread to load a driver on the critical
    // path of boot, it would also get stuck for a few seconds and hurt
    // boot times. Ideally we'd spawn new delayed threads as necessary as
    // well to prevent such contention from hurting boot and resume.
    //

    NumberOfDelayedThreads = MEDIUM_NUMBER_OF_THREADS + 4;

    switch (MmQuerySystemSize()) {

        case MmSmallSystem:
            break;

        case MmMediumSystem:
            if (NtAs) {
                NumberOfCriticalThreads += MEDIUM_NUMBER_OF_THREADS;
            }
            break;

        case MmLargeSystem:
            NumberOfCriticalThreads = LARGE_NUMBER_OF_THREADS;
            if (NtAs) {
                NumberOfCriticalThreads += LARGE_NUMBER_OF_THREADS;
            }
            break;

        default:
            break;
    }

    //
    // Initialize the work Queue objects.
    //

    if (ExpAdditionalCriticalWorkerThreads > MAX_ADDITIONAL_THREADS) {
        ExpAdditionalCriticalWorkerThreads = MAX_ADDITIONAL_THREADS;
    }

    if (ExpAdditionalDelayedWorkerThreads > MAX_ADDITIONAL_THREADS) {
        ExpAdditionalDelayedWorkerThreads = MAX_ADDITIONAL_THREADS;
    }

    //
    // Initialize the ExWorkerQueue[] array.
    //

    RtlZeroMemory (&ExWorkerQueue[0], MaximumWorkQueue * sizeof(EX_WORK_QUEUE));

    for (WorkQueueType = 0; WorkQueueType < MaximumWorkQueue; WorkQueueType += 1) {

        KeInitializeQueue (&ExWorkerQueue[WorkQueueType].WorkerQueue, 0);
        ExWorkerQueue[WorkQueueType].Info.WaitMode = UserMode;
    }

    //
    // Always make stack for this thread resident
    // so that worker pool deadlock magic can run
    // even when what we are trying to do is inpage
    // the hyper critical worker thread's stack.
    // Without this fix, we hold the process lock
    // but this thread's stack can't come in, and
    // the deadlock detection cannot create new threads
    // to break the system deadlock.
    //

    ExWorkerQueue[HyperCriticalWorkQueue].Info.WaitMode = KernelMode;

    if (NtAs) {
        ExWorkerQueue[CriticalWorkQueue].Info.WaitMode = KernelMode;
    }

    //
    // We only create dynamic threads for the critical work queue (note
    // this doesn't apply to dynamic threads created to break deadlocks.)
    //
    // The rationale is this: folks who use the delayed work queue are
    // not time critical, and the hypercritical queue is used rarely
    // by folks who are non-blocking.
    //

    ExWorkerQueue[CriticalWorkQueue].Info.MakeThreadsAsNecessary = 1;

    //
    // Initialize the global thread set manager events
    //

    KeInitializeEvent (&ExpThreadSetManagerEvent,
                       SynchronizationEvent,
                       FALSE);

    KeInitializeEvent (&ExpThreadSetManagerShutdownEvent,
                       SynchronizationEvent,
                       FALSE);

    //
    // Create the desired number of executive worker threads for each
    // of the work queues.
    //

    //
    // Create the builtin critical worker threads.
    //

    NumberOfThreads = NumberOfCriticalThreads + ExpAdditionalCriticalWorkerThreads;
    for (Index = 0; Index < NumberOfThreads; Index += 1) {

        //
        // Create a worker thread to service the critical work queue.
        //

        Status = ExpCreateWorkerThread (CriticalWorkQueue, FALSE);

        if (!NT_SUCCESS(Status)) {
            break;
        }
    }

    ExCriticalWorkerThreads += Index;

    //
    // Create the delayed worker threads.
    //

    NumberOfThreads = NumberOfDelayedThreads + ExpAdditionalDelayedWorkerThreads;
    for (Index = 0; Index < NumberOfThreads; Index += 1) {

        //
        // Create a worker thread to service the delayed work queue.
        //

        Status = ExpCreateWorkerThread (DelayedWorkQueue, FALSE);

        if (!NT_SUCCESS(Status)) {
            break;
        }
    }

    ExDelayedWorkerThreads += Index;

    //
    // Create the hypercritical worker thread.
    //

    Status = ExpCreateWorkerThread (HyperCriticalWorkQueue, FALSE);

    //
    // Create the worker thread set manager thread.
    //

    InitializeObjectAttributes (&ObjectAttributes, NULL, 0, NULL, NULL);

    Status = PsCreateSystemThread (&Thread,
                                   THREAD_ALL_ACCESS,
                                   &ObjectAttributes,
                                   0,
                                   NULL,
                                   ExpWorkerThreadBalanceManager,
                                   NULL);

    if (NT_SUCCESS(Status)) {
        Status = ObReferenceObjectByHandle (Thread,
                                            SYNCHRONIZE,
                                            NULL,
                                            KernelMode,
                                            &ExpWorkerThreadBalanceManagerPtr,
                                            NULL);
        ZwClose (Thread);
    }

    return Status;
}

VOID
ExQueueWorkItem (
    IN PWORK_QUEUE_ITEM WorkItem,
    IN WORK_QUEUE_TYPE QueueType
    )

/*++

Routine Description:

    This function inserts a work item into a work queue that is processed
    by a worker thread of the corresponding type.

Arguments:

    WorkItem - Supplies a pointer to the work item to add the the queue.
        This structure must be located in NonPagedPool. The work item
        structure contains a doubly linked list entry, the address of a
        routine to call and a parameter to pass to that routine.

    QueueType - Specifies the type of work queue that the work item
        should be placed in.

Return Value:

    None.

--*/

{
    PEX_WORK_QUEUE Queue;

    ASSERT (QueueType < MaximumWorkQueue);
    ASSERT (WorkItem->List.Flink == NULL);

    Queue = &ExWorkerQueue[QueueType];

    //
    // Insert the work item in the appropriate queue object.
    //

    KeInsertQueue (&Queue->WorkerQueue, &WorkItem->List);

    //
    // We check the queue's shutdown state after we insert the work
    // item to avoid the race condition when the queue's marked
    // between checking the queue and inserting the item.  It's
    // possible for the queue to be marked for shutdown between the
    // insert and this assert (so the insert would've barely sneaked
    // in), but it's not worth guarding against this -- barely
    // sneaking in is not a good design strategy, and at this point in
    // the shutdown sequence, the caller simply should not be trying
    // to insert new queue items.
    //

    ASSERT (!Queue->Info.QueueDisabled);

    //
    // Determine whether another thread should be created, and signal the
    // thread set balance manager if so.
    //

    if (ExpNewThreadNecessary (Queue) != FALSE) {
        KeSetEvent (&ExpThreadSetManagerEvent, 0, FALSE);
    }

    return;
}

VOID
ExpWorkerThreadBalanceManager (
    IN PVOID StartContext
    )

/*++

Routine Description:

    This function is the startup code for the worker thread manager thread.
    The worker thread manager thread is created during system initialization
    and begins execution in this function.

    This thread is responsible for detecting and breaking circular deadlocks
    in the system worker thread queues.  It will also create and destroy
    additional worker threads as needed based on loading.

Arguments:

    Context - Supplies a pointer to an arbitrary data structure (NULL).

Return Value:

    None.

--*/
{
    KTIMER PeriodTimer;
    LARGE_INTEGER DueTime;
    PVOID WaitObjects[MaximumBalanceObject];
    NTSTATUS Status;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (StartContext);

    //
    // Raise the thread priority to just higher than the priority of the
    // critical work queue.
    //

    KeSetBasePriorityThread (KeGetCurrentThread(),
                             CRITICAL_WORK_QUEUE_PRIORITY + 1);

    //
    // Initialize the periodic timer and set the manager period.
    //

    KeInitializeTimer (&PeriodTimer);
    DueTime.QuadPart = - THREAD_SET_INTERVAL;

    //
    // Initialize the wait object array.
    //

    WaitObjects[TimerExpiration] = (PVOID)&PeriodTimer;
    WaitObjects[ThreadSetManagerEvent] = (PVOID)&ExpThreadSetManagerEvent;
    WaitObjects[ShutdownEvent] = (PVOID)&ExpThreadSetManagerShutdownEvent;

    //
    // Loop forever processing events.
    //

    while (TRUE) {

        //
        // Set the timer to expire at the next periodic interval.
        //

        KeSetTimer (&PeriodTimer, DueTime, NULL);

        //
        // Wake up when the timer expires or the set manager event is
        // signalled.
        //

        Status = KeWaitForMultipleObjects (MaximumBalanceObject,
                                           WaitObjects,
                                           WaitAny,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           NULL,
                                           NULL);

        switch (Status) {

            case TimerExpiration:

                //
                // Periodic timer expiration - go see if any work queues
                // are deadlocked.
                //

                ExpDetectWorkerThreadDeadlock ();
                break;

            case ThreadSetManagerEvent:

                //
                // Someone has asked us to check some metrics to determine
                // whether we should create another worker thread.
                //

                ExpCheckDynamicThreadCount ();
                break;

            case ShutdownEvent:

                //
                // Time to exit...
                //

                KeCancelTimer (&PeriodTimer);

                ASSERT (ExpLastWorkerThread);

                //
                // Wait for the last worker thread to terminate
                //

                KeWaitForSingleObject (ExpLastWorkerThread,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);

                ObDereferenceObject (ExpLastWorkerThread);

                PsTerminateSystemThread(STATUS_SYSTEM_SHUTDOWN);

                break;
        }

        //
        // Special debugger support.
        //
        // This checks if special debugging routines need to be run on the
        // behalf of the debugger.
        //

        if (ExpDebuggerWork == 1) {

             ExInitializeWorkItem(&ExpDebuggerWorkItem, ExpDebuggerWorker, NULL);
             ExpDebuggerWork = 2;
             ExQueueWorkItem(&ExpDebuggerWorkItem, DelayedWorkQueue);
        }
    }
}

VOID
ExpCheckDynamicThreadCount (
    VOID
    )

/*++

Routine Description:

    This routine is called when there is reason to believe that a work queue
    might benefit from the creation of an additional worker thread.

    This routine checks each queue to determine whether it would benefit from
    an additional worker thread (see ExpNewThreadNecessary()), and creates
    one if so.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PEX_WORK_QUEUE Queue;
    WORK_QUEUE_TYPE QueueType;

    PAGED_CODE();

    //
    // Check each worker queue.
    //

    Queue = &ExWorkerQueue[0];

    for (QueueType = 0; QueueType < MaximumWorkQueue; Queue += 1, QueueType += 1) {

        if (ExpNewThreadNecessary (Queue)) {

            //
            // Create a new thread for this queue.  We explicitly ignore
            // an error from ExpCreateDynamicThread(): there's nothing
            // we can or should do in the event of a failure.
            //

            ExpCreateWorkerThread (QueueType, TRUE);
        }
    }
}

VOID
ExpDetectWorkerThreadDeadlock (
    VOID
    )

/*++

Routine Description:

    This function creates new work item threads if a possible deadlock is
    detected.

Arguments:

    None.

Return Value:

    None

--*/

{
    ULONG Index;
    PEX_WORK_QUEUE Queue;

    PAGED_CODE();

    //
    // Process each queue type.
    //

    for (Index = 0; Index < MaximumWorkQueue; Index += 1) {

        Queue = &ExWorkerQueue[Index];

        ASSERT( Queue->DynamicThreadCount <= MAX_ADDITIONAL_DYNAMIC_THREADS );

        if ((Queue->QueueDepthLastPass > 0) &&
            (Queue->WorkItemsProcessed == Queue->WorkItemsProcessedLastPass) &&
            (Queue->DynamicThreadCount < MAX_ADDITIONAL_DYNAMIC_THREADS)) {

            //
            // These things are known:
            //
            // - There were work items waiting in the queue at the last pass.
            // - No work items have been processed since the last pass.
            // - We haven't yet created the maximum number of dynamic threads.
            //
            // Things look like they're stuck, create a new thread for this
            // queue.
            //
            // We explicitly ignore an error from ExpCreateDynamicThread():
            // we'll try again in another detection period if the queue looks
            // like it's still stuck.
            //

            ExpCreateWorkerThread (Index, TRUE);
        }

        //
        // Update some bookkeeping.
        //
        // Note that WorkItemsProcessed and the queue depth must be recorded
        // in that order to avoid getting a false deadlock indication.
        //

        Queue->WorkItemsProcessedLastPass = Queue->WorkItemsProcessed;
        Queue->QueueDepthLastPass = KeReadStateQueue (&Queue->WorkerQueue);
    }
}

NTSTATUS
ExpCreateWorkerThread (
    IN WORK_QUEUE_TYPE QueueType,
    IN BOOLEAN Dynamic
    )

/*++

Routine Description:

    This function creates a single new static or dynamic worker thread for
    the given queue type.

Arguments:

    QueueType - Supplies the type of the queue for which the worker thread
                should be created.

    Dynamic - If TRUE, the worker thread is created as a dynamic thread that
              will terminate after a sufficient period of inactivity.  If FALSE,
              the worker thread will never terminate.


Return Value:

    The final status of the operation.

Notes:

    This routine is only called from the worker thread set balance thread,
    therefore it will not be reentered.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    HANDLE ThreadHandle;
    ULONG Context;
    ULONG BasePriority;
    PETHREAD Thread;

    InitializeObjectAttributes (&ObjectAttributes, NULL, 0, NULL, NULL);

    Context = QueueType;
    if (Dynamic != FALSE) {
        Context |= DYNAMIC_WORKER_THREAD;
    }

    Status = PsCreateSystemThread (&ThreadHandle,
                                   THREAD_ALL_ACCESS,
                                   &ObjectAttributes,
                                   0L,
                                   NULL,
                                   ExpWorkerThread,
                                   (PVOID)(ULONG_PTR)Context);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (Dynamic != FALSE) {
        InterlockedIncrement ((PLONG)&ExWorkerQueue[QueueType].DynamicThreadCount);
    }

    //
    // Set the priority according to the type of worker thread.
    //

    switch (QueueType) {

        case HyperCriticalWorkQueue:
            BasePriority = HYPER_CRITICAL_WORK_QUEUE_PRIORITY;
            break;

        case CriticalWorkQueue:
            BasePriority = CRITICAL_WORK_QUEUE_PRIORITY;
            break;

        case DelayedWorkQueue:
        default:

            BasePriority = DELAYED_WORK_QUEUE_PRIORITY;
            break;
    }

    //
    // Set the base priority of the just-created thread.
    //

    Status = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        KernelMode,
                                        (PVOID *)&Thread,
                                        NULL);

    if (NT_SUCCESS(Status)) {
        KeSetBasePriorityThread (&Thread->Tcb, BasePriority);
        ObDereferenceObject (Thread);
    }

    ZwClose (ThreadHandle);

    return Status;
}

VOID
ExpCheckForWorker (
    IN PVOID p,
    IN SIZE_T Size
    )

{
    KIRQL OldIrql;
    PLIST_ENTRY Entry;
    PCHAR BeginBlock;
    PCHAR EndBlock;
    WORK_QUEUE_TYPE wqt;

    BeginBlock = (PCHAR)p;
    EndBlock = (PCHAR)p + Size;

    KiLockDispatcherDatabase (&OldIrql);

    for (wqt = CriticalWorkQueue; wqt < MaximumWorkQueue; wqt += 1) {
        for (Entry = (PLIST_ENTRY) ExWorkerQueue[wqt].WorkerQueue.EntryListHead.Flink;
             Entry && (Entry != (PLIST_ENTRY) &ExWorkerQueue[wqt].WorkerQueue.EntryListHead);
             Entry = Entry->Flink) {
           if (((PCHAR) Entry >= BeginBlock) && ((PCHAR) Entry < EndBlock)) {
              KeBugCheckEx(WORKER_INVALID,
                           0x0,
                           (ULONG_PTR)Entry,
                           (ULONG_PTR)BeginBlock,
                           (ULONG_PTR)EndBlock);

           }
        }
    }
    KiUnlockDispatcherDatabase (OldIrql);
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif
const char ExpWorkerApcDisabledMessage[] =
    "EXWORKER: worker exit with APCs disabled, worker routine %x, parameter %x, item %x\n";
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

VOID
ExpWorkerThread (
    IN PVOID StartContext
    )
{
    PLIST_ENTRY Entry;
    WORK_QUEUE_TYPE QueueType;
    PWORK_QUEUE_ITEM WorkItem;
    KPROCESSOR_MODE WaitMode;
    LARGE_INTEGER TimeoutValue;
    PLARGE_INTEGER Timeout;
    PETHREAD Thread;
    PEX_WORK_QUEUE WorkerQueue;
    PWORKER_THREAD_ROUTINE WorkerRoutine;
    PVOID Parameter;
    EX_QUEUE_WORKER_INFO OldWorkerInfo;
    EX_QUEUE_WORKER_INFO NewWorkerInfo;
    ULONG CountForQueueEmpty;

    //
    // Set timeout value etc according to whether we are static or dynamic.
    //

    if (((ULONG_PTR)StartContext & DYNAMIC_WORKER_THREAD) == 0) {

        //
        // We are being created as a static thread.  As such it will not
        // terminate, so there is no point in timing out waiting for a work
        // item.
        //

        Timeout = NULL;
    }
    else {

        //
        // This is a dynamic worker thread.  It has a non-infinite timeout
        // so that it can eventually terminate.
        //

        TimeoutValue.QuadPart = -DYNAMIC_THREAD_TIMEOUT;
        Timeout = &TimeoutValue;
    }

    Thread = PsGetCurrentThread ();

    //
    // If the thread is a critical worker thread, then set the thread
    // priority to the lowest realtime level. Otherwise, set the base
    // thread priority to time critical.
    //

    QueueType = (WORK_QUEUE_TYPE)
                ((ULONG_PTR)StartContext & ~DYNAMIC_WORKER_THREAD);

    WorkerQueue = &ExWorkerQueue[QueueType];

    WaitMode = (KPROCESSOR_MODE) WorkerQueue->Info.WaitMode;

    ASSERT (Thread->ExWorkerCanWaitUser == 0);

    if (WaitMode == UserMode) {
        Thread->ExWorkerCanWaitUser = 1;
    }

#if defined(REMOTE_BOOT)
    //
    // In diskless NT scenarios ensure that the kernel stack of the worker
    // threads will not be swapped out.
    //

    if (IoRemoteBootClient) {
        KeSetKernelStackSwapEnable (FALSE);
    }
#endif // defined(REMOTE_BOOT)

    //
    // Register as a worker, exiting if the queue's going down and
    // there aren't any workers in the queue to hand us the shutdown
    // work item if we enter the queue (we want to be able to enter a
    // queue even if the queue's shutting down, in case there's a
    // backlog of work items that the balance manager thread's decided
    // we should be helping to process).
    //

    if (PO_SHUTDOWN_QUEUE == QueueType) {
        CountForQueueEmpty = 1;
    }
    else {
        CountForQueueEmpty = 0;
    }

    if (ExpWorkersCanSwap == FALSE) {
        KeSetKernelStackSwapEnable (FALSE);
    }

    do {

        OldWorkerInfo.QueueWorkerInfo = WorkerQueue->Info.QueueWorkerInfo;

        if (OldWorkerInfo.QueueDisabled &&
            OldWorkerInfo.WorkerCount <= CountForQueueEmpty) {

            //
            // The queue is disabled and empty so just exit.
            //

            KeSetKernelStackSwapEnable (TRUE);
            PsTerminateSystemThread (STATUS_SYSTEM_SHUTDOWN);
        }

        NewWorkerInfo.QueueWorkerInfo = OldWorkerInfo.QueueWorkerInfo;
        NewWorkerInfo.WorkerCount += 1;

    } while (OldWorkerInfo.QueueWorkerInfo !=

        InterlockedCompareExchange (&WorkerQueue->Info.QueueWorkerInfo,
                                    NewWorkerInfo.QueueWorkerInfo,
                                    OldWorkerInfo.QueueWorkerInfo));

    //
    // As of this point, we must only exit if we decrement the worker
    // count without the queue disabled flag being set.  (Unless we
    // exit due to the shutdown work item, which also decrements the
    // worker count).
    //

    Thread->ActiveExWorker = 1;

    //
    // Loop forever waiting for a work queue item, calling the processing
    // routine, and then waiting for another work queue item.
    //

    do {

        //
        // Wait until something is put in the queue or until we time out.
        //
        // By specifying a wait mode of UserMode, the thread's kernel
        // stack is swappable.
        //

        Entry = KeRemoveQueue (&WorkerQueue->WorkerQueue,
                               WaitMode,
                               Timeout);

        if ((ULONG_PTR)Entry != STATUS_TIMEOUT) {

            //
            // This is a real work item, process it.
            //
            // Update the total number of work items processed.
            //

            InterlockedIncrement ((PLONG)&WorkerQueue->WorkItemsProcessed);

            WorkItem = CONTAINING_RECORD(Entry, WORK_QUEUE_ITEM, List);
            WorkerRoutine = WorkItem->WorkerRoutine;
            Parameter = WorkItem->Parameter;

            //
            // Execute the specified routine.
            //

            ((PWORKER_THREAD_ROUTINE)WorkerRoutine) (Parameter);

            //
            // Catch worker routines that forget to do KeLeaveCriticalRegion.
            // It has to be zero at this point. In the debug case we enter a
            // breakpoint. In the non-debug case just zero the flag so that
            // APCs can continue to fire to this thread.
            //

            if (Thread->Tcb.KernelApcDisable != 0) {
                DbgPrint ((char*)ExpWorkerApcDisabledMessage,
                          WorkerRoutine,
                          Parameter,
                          WorkItem);
                ASSERT (FALSE);

                Thread->Tcb.KernelApcDisable = 0;
            }

            if (KeGetCurrentIrql () != PASSIVE_LEVEL) {
                KeBugCheckEx (WORKER_THREAD_RETURNED_AT_BAD_IRQL,
                              (ULONG_PTR)WorkerRoutine,
                              (ULONG_PTR)KeGetCurrentIrql(),
                              (ULONG_PTR)Parameter,
                              (ULONG_PTR)WorkItem);
            }

            if (PS_IS_THREAD_IMPERSONATING (Thread)) {
                KeBugCheckEx (IMPERSONATING_WORKER_THREAD,
                              (ULONG_PTR)WorkerRoutine,
                              (ULONG_PTR)Parameter,
                              (ULONG_PTR)WorkItem,
                              0);
            }

            continue;
        }

        //
        // These things are known:
        //
        // - Static worker threads do not time out, so this is a dynamic
        //   worker thread.
        //
        // - This thread has been waiting for a long time with nothing
        //   to do.
        //

        if (IsListEmpty (&Thread->IrpList) == FALSE) {

            //
            // There is still I/O pending, can't terminate yet.
            //

            continue;
        }

        //
        // Get out of the queue, if we can
        //

        do {
            OldWorkerInfo.QueueWorkerInfo = WorkerQueue->Info.QueueWorkerInfo;

            if (OldWorkerInfo.QueueDisabled) {

                //
                // We're exiting via the queue disable work item;
                // there's no point in expiring here.
                //

                break;
            }

            NewWorkerInfo.QueueWorkerInfo = OldWorkerInfo.QueueWorkerInfo;
            NewWorkerInfo.WorkerCount -= 1;

        } while (OldWorkerInfo.QueueWorkerInfo
                 != InterlockedCompareExchange(&WorkerQueue->Info.QueueWorkerInfo,
                                               NewWorkerInfo.QueueWorkerInfo,
                                               OldWorkerInfo.QueueWorkerInfo));

        if (OldWorkerInfo.QueueDisabled) {

            //
            // We're exiting via the queue disable work item
            //

            continue;
        }

        //
        // This dynamic thread can be terminated.
        //

        break;

    } while (TRUE);

    //
    // Terminate this dynamic thread.
    //

    InterlockedDecrement ((PLONG)&WorkerQueue->DynamicThreadCount);

    //
    // Carefully clear this before marking the thread stack as swap enabled
    // so that an incoming APC won't inadvertently disable the stack swap
    // afterwards.
    //

    Thread->ActiveExWorker = 0;

    //
    // We will bugcheck if we terminate a thread with stack swapping
    // disabled.
    //

    KeSetKernelStackSwapEnable (TRUE);

    return;
}

VOID
ExpSetSwappingKernelApc (
    IN PKAPC Apc,
    OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    )
{
    PBOOLEAN AllowSwap;
    PKEVENT SwapSetEvent;

    UNREFERENCED_PARAMETER (Apc);
    UNREFERENCED_PARAMETER (NormalRoutine);
    UNREFERENCED_PARAMETER (SystemArgument2);

    //
    // SystemArgument1 is a pointer to the event to signal once this
    // thread has finished servicing the request.
    //

    SwapSetEvent = (PKEVENT) *SystemArgument1;

    //
    // Don't disable stack swapping if the thread is exiting because
    // it cannot exit this way without bugchecking.  Skip it on enables
    // too since the thread is bailing anyway.
    //

    if (PsGetCurrentThread()->ActiveExWorker != 0) {
        AllowSwap = NormalContext;
        KeSetKernelStackSwapEnable (*AllowSwap);
    }

    KeSetEvent (SwapSetEvent, 0, FALSE);
}

VOID
ExSwapinWorkerThreads (
    IN BOOLEAN AllowSwap
    )

/*++

Routine Description:

    Sets the kernel stacks of the delayed worker threads to be swappable
    or pins them into memory.

Arguments:

    AllowSwap - Supplies TRUE if worker kernel stacks should be swappable,
                FALSE if not.

Return Value:

    None.

--*/

{
    PETHREAD         Thread;
    PETHREAD         CurrentThread;
    PEPROCESS        Process;
    KAPC             Apc;
    KEVENT           SwapSetEvent;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread();

    KeInitializeEvent (&SwapSetEvent,
                       NotificationEvent,
                       FALSE);

    Process = PsInitialSystemProcess;

    //
    // Serialize callers.
    //

    ExAcquireFastMutex (&ExpWorkerSwapinMutex);

    //
    // Stop new threads from swapping.
    //

    ExpWorkersCanSwap = AllowSwap;

    //
    // Stop existing worker threads from swapping.
    //

    for (Thread = PsGetNextProcessThread (Process, NULL);
         Thread != NULL;
         Thread = PsGetNextProcessThread (Process, Thread)) {

        //
        // Skip threads that are not worker threads or worker threads that
        // were permanently marked noswap at creation time.
        //

        if (Thread->ExWorkerCanWaitUser == 0) {
            continue;
        }

        if (Thread == CurrentThread) {

            //
            // No need to use an APC on the current thread.
            //

            KeSetKernelStackSwapEnable (AllowSwap);
        }
        else {

            //
            // Queue an APC to the thread, and wait for it to fire:
            //

            KeInitializeApc (&Apc,
                             &Thread->Tcb,
                             InsertApcEnvironment,
                             ExpSetSwappingKernelApc,
                             NULL,
                             NULL,
                             KernelMode,
                             &AllowSwap);

            if (KeInsertQueueApc (&Apc, &SwapSetEvent, NULL, 3)) {

                KeWaitForSingleObject (&SwapSetEvent,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);

                KeClearEvent(&SwapSetEvent);
            }
        }
    }

    ExReleaseFastMutex (&ExpWorkerSwapinMutex);
}

LOGICAL
ExpCheckQueueShutdown (
    IN WORK_QUEUE_TYPE QueueType,
    IN PSHUTDOWN_WORK_ITEM ShutdownItem
    )
{
    ULONG CountForQueueEmpty;

    if (PO_SHUTDOWN_QUEUE == QueueType) {
        CountForQueueEmpty = 1;
    }
    else {
        CountForQueueEmpty = 0;
    }

    //
    // Note that using interlocked sequences to increment the worker count
    // and decrement it to CountForQueueEmpty ensures that once it
    // *is* equal to CountForQueueEmpty and the disabled flag is set,
    // we won't be incrementing it any more, so we're safe making this
    // check without locks.
    //
    // See ExpWorkerThread, ExpShutdownWorker, and ExpShutdownWorkerThreads.
    //

    if (ExWorkerQueue[QueueType].Info.WorkerCount > CountForQueueEmpty) {

        //
        // There're still worker threads; send one of them the axe.
        //

        ShutdownItem->QueueType = QueueType;
        ShutdownItem->PrevThread = PsGetCurrentThread();
        ObReferenceObject (ShutdownItem->PrevThread);

        KeInsertQueue (&ExWorkerQueue[QueueType].WorkerQueue,
                       &ShutdownItem->WorkItem.List);
        return TRUE;
    }

    return FALSE;               // we did not queue a shutdown
}

VOID
ExpShutdownWorker (
    IN PVOID Parameter
    )
{
    PETHREAD CurrentThread;
    PSHUTDOWN_WORK_ITEM  ShutdownItem;

    ShutdownItem = (PSHUTDOWN_WORK_ITEM) Parameter;

    ASSERT (ShutdownItem != NULL);

    if (ShutdownItem->PrevThread != NULL) {

        //
        // Wait for the previous thread to exit -- if it's in the same
        // queue, it probably has already, but we need to make sure
        // (and if it's not, we *definitely* need to make sure).
        //

        KeWaitForSingleObject (ShutdownItem->PrevThread,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        ObDereferenceObject (ShutdownItem->PrevThread);

        ShutdownItem->PrevThread = NULL;
    }

    //
    // Decrement the worker count.
    //

    InterlockedDecrement (&ExWorkerQueue[ShutdownItem->QueueType].Info.QueueWorkerInfo);

    CurrentThread = PsGetCurrentThread();

    if ((!ExpCheckQueueShutdown(DelayedWorkQueue, ShutdownItem)) &&
        (!ExpCheckQueueShutdown(CriticalWorkQueue, ShutdownItem))) {

        //
        // We're the last worker to exit
        //

        ASSERT (!ExpLastWorkerThread);
        ExpLastWorkerThread = CurrentThread;
        ObReferenceObject (ExpLastWorkerThread);
        KeSetEvent (&ExpThreadSetManagerShutdownEvent, 0, FALSE);
    }

    KeSetKernelStackSwapEnable (TRUE);
    CurrentThread->ActiveExWorker = 0;

    PsTerminateSystemThread (STATUS_SYSTEM_SHUTDOWN);
}

VOID
ExpShutdownWorkerThreads (
    VOID
    )
{
    PULONG QueueEnable;
    SHUTDOWN_WORK_ITEM ShutdownItem;

    if ((PoCleanShutdownEnabled () & PO_CLEAN_SHUTDOWN_WORKERS) == 0) {
        return;
    }

    ASSERT (KeGetCurrentThread()->Queue
           == &ExWorkerQueue[PO_SHUTDOWN_QUEUE].WorkerQueue);

    //
    // Mark the queues as terminating.
    //

    QueueEnable = (PULONG)&ExWorkerQueue[DelayedWorkQueue].Info.QueueWorkerInfo;

    RtlInterlockedSetBitsDiscardReturn (QueueEnable, EX_WORKER_QUEUE_DISABLED);

    QueueEnable = (PULONG)&ExWorkerQueue[CriticalWorkQueue].Info.QueueWorkerInfo;
    RtlInterlockedSetBitsDiscardReturn (QueueEnable, EX_WORKER_QUEUE_DISABLED);

    //
    // Queue the shutdown work item to the delayed work queue.  After
    // all currently queued work items are complete, this will fire,
    // repeatedly taking out every worker thread in every queue until
    // they're all done.
    //

    ExInitializeWorkItem (&ShutdownItem.WorkItem,
                          &ExpShutdownWorker,
                          &ShutdownItem);

    ShutdownItem.QueueType = DelayedWorkQueue;
    ShutdownItem.PrevThread = NULL;

    KeInsertQueue (&ExWorkerQueue[DelayedWorkQueue].WorkerQueue,
                   &ShutdownItem.WorkItem.List);

    //
    // Wait for all of the workers and the balancer to exit.
    //

    if (ExpWorkerThreadBalanceManagerPtr != NULL) {

        KeWaitForSingleObject(ExpWorkerThreadBalanceManagerPtr,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ASSERT(!ShutdownItem.PrevThread);

        ObDereferenceObject(ExpWorkerThreadBalanceManagerPtr);
    }
}

VOID
ExpDebuggerWorker(
    IN PVOID Context
    )
/*++

Routine Description:

    This is a worker thread for the kernel debugger that can be used to
    perform certain tasks on the target machine asynchronously.
    This is necessary when the machine needs to run at Dispatch level to
    perform certain operations, such as paging in data.

Arguments:

    Context - not used as this point.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    KAPC_STATE  ApcState;
    volatile UCHAR Data;
    PRKPROCESS  AttachProcess = (PRKPROCESS) ExpDebuggerProcessAttach;
    PUCHAR PageIn = (PUCHAR) ExpDebuggerPageIn;
    PEPROCESS Process;

    ExpDebuggerProcessAttach = 0;
    ExpDebuggerPageIn = 0;

    UNREFERENCED_PARAMETER (Context);

#if DBG
    if (ExpDebuggerWork != 2)
    {
        DbgPrint("ExpDebuggerWorker being entered with state != 2\n");
    }
#endif

    ExpDebuggerWork = 0;


    Process = NULL;
    if (AttachProcess) {
        for (Process =  PsGetNextProcess (NULL);
             Process != NULL;
             Process =  PsGetNextProcess (Process)) {
            if (&Process->Pcb ==  AttachProcess) {
                KeStackAttachProcess (AttachProcess, &ApcState);
                break;
            }
        }
    }

    if (PageIn) {
        try {
            ProbeForReadSmallStructure (PageIn, sizeof (UCHAR), sizeof (UCHAR));
            Data = *PageIn;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }
    }

    DbgBreakPointWithStatus(DBG_STATUS_WORKER);

    if (Process != NULL) {
        KeUnstackDetachProcess (&ApcState);
        PsQuitNextProcess (Process);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\xipdisp.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    xipdisp.c

Abstract:

    This file implements functions for communicating with the XIP Disk Driver.

    Most importantly this routine is used by the kernel to communicate
    information about the location of the memory set aside for XIP.

Author:

    Dave Probert (davepr) 2000/10/10

Environment:

    kernel mode

Revision History:

--*/

#include "exp.h"
#pragma hdrstop

#include "cpyuchr.h"
#include "fat.h"
#include "xip.h"


#if defined(_X86_)

typedef struct _XIP_CONFIGURATION {
    XIP_BOOT_PARAMETERS     BootParameters;
    BIOS_PARAMETER_BLOCK    BiosParameterBlock;
    ULONG                   ClusterZeroPage;
} XIP_CONFIGURATION, *PXIP_CONFIGURATION;

PXIP_CONFIGURATION XIPConfiguration;
BOOLEAN XIPConfigured;

VOID
XIPInit(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

PMEMORY_ALLOCATION_DESCRIPTOR
XIPpFindMemoryDescriptor(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );


#if defined(ALLOC_PRAGMA)
#pragma alloc_text(INIT,     XIPInit)
#pragma alloc_text(INIT,     XIPpFindMemoryDescriptor)
#pragma alloc_text(PAGE,     XIPLocatePages)
#endif


VOID
XIPInit(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This routine sets up the boot parameter information for XIP Rom.

Arguments:

    
Environment:

    Called only at INIT.

--*/
{
    PMEMORY_ALLOCATION_DESCRIPTOR  XIPMemoryDescriptor;
    PPACKED_BOOT_SECTOR            pboot;
    BIOS_PARAMETER_BLOCK           bios;
    PHYSICAL_ADDRESS               physicalAddress;

    PCHAR                          Options;

    PCHAR XIPBoot, XIPRom, XIPRam, XIPSize, XIPVerbose;

    PCHAR sizestr;
    ULONG nmegs = 0;

    //
    // Process the boot options.  Really only need to know whether or not we are the boot device, and RAM or ROM.
    // But the other checking is done for diagnostic purposes (at least in checked builds).
    //

    Options = LoaderBlock->LoadOptions;
    if (!Options) {
        return;
    }

    XIPBoot    = strstr(Options, "XIPBOOT");
    XIPRom     = strstr(Options, "XIPROM=");
    XIPRam     = strstr(Options, "XIPRAM=");
    XIPSize    = strstr(Options, "XIPMEGS=");
    XIPVerbose = strstr(Options, "XIPVERBOSE");

    if (XIPVerbose) {
        DbgPrint("\n\nXIP: debug timestamp at line %d in %s:   <<<%s %s>>>\n\n\n", __LINE__, __FILE__, __DATE__, __TIME__);
    }

    XIPMemoryDescriptor = XIPpFindMemoryDescriptor(LoaderBlock);

    if (!XIPMemoryDescriptor) {
        return;
    }

    if (XIPVerbose) {
        DbgPrint("XIP: Base %x  Count %x\n", XIPMemoryDescriptor->BasePage, XIPMemoryDescriptor->PageCount);
    }

    if (XIPRom && XIPRam) {
        return;
    }

    if (!XIPRom && !XIPRam) {
        return;
    }

    sizestr = XIPSize? strchr(XIPSize, '=') : NULL;
    if (sizestr) {
        nmegs = (ULONG) atol(sizestr+1);
    }

    if (nmegs == 0) {
        return;
    }

    if (XIPVerbose && XIPMemoryDescriptor->PageCount != nmegs * 1024*1024 / PAGE_SIZE) {
        DbgPrint("XIPMEGS=%d in boot options is %d pages, but only %d pages were allocated by NTLDR\n",
                nmegs * 1024*1024 / PAGE_SIZE,
                XIPMemoryDescriptor->PageCount * PAGE_SIZE);
        return;
    }

    //
    // Get info from FAT16 boot sector.
    // We only need to map one page, so we've allocated an MDL on the stack.
    //

    //
    // Temporarily map the page with the boot sector so we can unpack it.
    //

    physicalAddress.QuadPart = XIPMemoryDescriptor->BasePage * PAGE_SIZE;

    pboot = (PPACKED_BOOT_SECTOR) MmMapIoSpace(physicalAddress, PAGE_SIZE, MmCached);
    if (!pboot) {
        return;
    }

    FatUnpackBios(&bios, &pboot->PackedBpb);

    MmUnmapIoSpace (pboot, PAGE_SIZE);

    //
    // Check Bios parameters
    //
    if (bios.BytesPerSector != 512
     || FatBytesPerCluster(&bios) != PAGE_SIZE
     || FatFileAreaLbo(&bios) & (PAGE_SIZE-1)) {

        if (XIPVerbose) {
            DbgPrint("XIP: Malformed FAT Filesystem: BytesPerSector=%x  BytesPerCluster=%x  ClusterZeroOffset=%x\n",
                 bios.BytesPerSector, FatBytesPerCluster(&bios), FatFileAreaLbo(&bios));
        }
        return;
    }

    //
    // Boot.ini parameters and Bios parameters were ok, so initialize the XIP configuration.
    //

    XIPConfiguration = ExAllocatePoolWithTag (NonPagedPool, sizeof(*XIPConfiguration), XIP_POOLTAG);
    if (!XIPConfiguration) {
        return;
    }

    XIPConfigured = TRUE;

    XIPConfiguration->BiosParameterBlock = bios;
    XIPConfiguration->BootParameters.SystemDrive = XIPBoot? TRUE : FALSE;
    XIPConfiguration->BootParameters.ReadOnly    = XIPRom?  TRUE : FALSE;

    XIPConfiguration->BootParameters.BasePage = XIPMemoryDescriptor->BasePage;
    XIPConfiguration->BootParameters.PageCount = XIPMemoryDescriptor->PageCount;

    XIPConfiguration->ClusterZeroPage = FatFileAreaLbo(&bios) >> PAGE_SHIFT;

    return;
}


NTSTATUS
XIPDispatch(
    IN     XIPCMD Command,
    IN OUT PVOID  ParameterBuffer OPTIONAL,
    IN     ULONG  BufferSize
    )
/*++

Routine Description:

    This routine sets up the boot parameter information for XIP Rom.

Arguments:

    
Environment:

    Only to be called at INIT time.

--*/
{
    ULONG   sz;

    if (!XIPConfiguration) {
        return STATUS_NO_SUCH_DEVICE;
    }

    switch (Command) {
    case XIPCMD_GETBOOTPARAMETERS:
        sz = sizeof(XIPConfiguration->BootParameters);
        if (sz != BufferSize) {
            break;
        }
        RtlCopyMemory(ParameterBuffer, &XIPConfiguration->BootParameters, sz);
        return STATUS_SUCCESS;

    case XIPCMD_GETBIOSPARAMETERS:
        sz = sizeof(XIPConfiguration->BiosParameterBlock);
        if (sz != BufferSize) {
            break;
        }
        RtlCopyMemory(ParameterBuffer, &XIPConfiguration->BiosParameterBlock, sz);
        return STATUS_SUCCESS;

    case XIPCMD_NOOP:
        if (BufferSize) {
            break;
        }
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

////////////////////////////
// DEBUG
int XIPlocate_noisy = 0;
int XIPlocate_breakin = 0;
int XIPlocate_disable  = 0;
struct {
    int attempted;
    int bounced;
    int succeeded;
    int no_irp;
    int no_devobj;
    int no_contig;
    int no_endofdisk;
} XIPlocatecnt;
////////////////////////////

NTSTATUS
XIPLocatePages(
    IN  PFILE_OBJECT       FileObject,
    OUT PPHYSICAL_ADDRESS  PhysicalAddress
    )
/*++

Routine Description:

    Return the requested XIP physical address.  If the requested page range
    is not contiguous in the file, or there is any other problem, the routine fails.

Arguments:

    FileObject - the file of interest

    PhysicalAddress - used to return the physical address of the start of the file in ROM.

Environment:

    Kernel

--*/
{
    STARTING_VCN_INPUT_BUFFER startingvcn;
    RETRIEVAL_POINTERS_BUFFER retrbuf;
    IO_STATUS_BLOCK           iostatus;

    PDEVICE_OBJECT            deviceObject;
    PIO_STACK_LOCATION        irpSp;
    NTSTATUS                  status;
    KEVENT                    event;
    PIRP                      irp;

    PFN_NUMBER                firstPage, numberOfPages;
    PDEVICE_OBJECT            xipDeviceObject;

    xipDeviceObject = FileObject->DeviceObject;

    if (!XIPConfiguration) {
        return STATUS_NO_SUCH_DEVICE;
    }

    if (!xipDeviceObject || !(xipDeviceObject->Flags & DO_XIP)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
////////////////
XIPlocatecnt.attempted++;
////////////////

    startingvcn.StartingVcn.QuadPart = 0;
    deviceObject = IoGetRelatedDeviceObject(FileObject);

    if (!deviceObject) {
////////////////
XIPlocatecnt.no_devobj++;
////////////////
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Ask fat for the retrieval pointers (relative to cluster 0).
    //
    irp = IoBuildDeviceIoControlRequest(
                        FSCTL_GET_RETRIEVAL_POINTERS,
                        deviceObject,
                        &startingvcn,
                        sizeof(startingvcn),
                        &retrbuf,
                        sizeof(retrbuf),
                        FALSE,
                        &event,
                        &iostatus);
    if (!irp) {
////////////////
XIPlocatecnt.no_irp++;
////////////////
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp->Flags |= IRP_SYNCHRONOUS_API;
    irp->Tail.Overlay.OriginalFileObject = FileObject;

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
    irpSp->MinorFunction = IRP_MN_USER_FS_REQUEST;
    irpSp->FileObject = FileObject;

    //
    // Take out another reference to the file object to match I/O completion will deref.
    //

    ObReferenceObject( FileObject );

    //
    // Do the FSCTL
    //

    KeInitializeEvent( &event, NotificationEvent, FALSE );
    status = IoCallDriver( deviceObject, irp );

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject( &event, Suspended, KernelMode, FALSE, NULL );
        status = iostatus.Status;
    }

    if (!NT_SUCCESS(iostatus.Status)
     || retrbuf.ExtentCount != 1
     || retrbuf.Extents[0].Lcn.HighPart
     || retrbuf.Extents[0].NextVcn.HighPart
     || retrbuf.StartingVcn.QuadPart != 0L) {

////////////////
XIPlocatecnt.no_contig++;
////////////////
        return STATUS_UNSUCCESSFUL;
    }

    firstPage  =   XIPConfiguration->BootParameters.BasePage
                 + XIPConfiguration->ClusterZeroPage
                 + retrbuf.Extents[0].Lcn.LowPart;

    numberOfPages = retrbuf.Extents[0].NextVcn.LowPart;

    if (firstPage + numberOfPages > XIPConfiguration->BootParameters.BasePage
                                    + XIPConfiguration->BootParameters.PageCount) {

XIPlocatecnt.no_endofdisk++;
        return STATUS_DISK_CORRUPT_ERROR;
    }

////////////////
////////////////
if (XIPlocate_noisy || XIPlocate_breakin) {
    DbgPrint("Break top of XIPLocatePages.  bounced=%x  attempted=%x  succeeded=%x\n"
             "  %x nt!XIPlocate_disable  %s\n"
             "  %x nt!XIPlocate_breakin %s\n"
             "  %x nt!XIPConfiguration\n"
             "  Would have returned address %x  (npages was %x)\n",
            XIPlocatecnt.bounced, XIPlocatecnt.attempted, XIPlocatecnt.succeeded,
            &XIPlocate_disable,  XIPlocate_disable?  "DISABLED" : "enabled",
            &XIPlocate_breakin, XIPlocate_breakin? "WILL BREAK" : "no break",
            XIPConfiguration, firstPage, numberOfPages);
    if (XIPlocate_breakin) {
        DbgBreakPoint();
    }
}
if (XIPlocate_disable) {
    XIPlocatecnt.bounced++;
    return STATUS_DEVICE_OFF_LINE;
}
XIPlocatecnt.succeeded++;
////////////////
////////////////
    PhysicalAddress->QuadPart = firstPage << PAGE_SHIFT;
    return STATUS_SUCCESS;
}

//
// Local support routine
//

//
// Find the XIP memory descriptor
// Called only at INIT.
//
PMEMORY_ALLOCATION_DESCRIPTOR
XIPpFindMemoryDescriptor(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;
    PLIST_ENTRY NextMd;

    for (NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;
         NextMd != &LoaderBlock->MemoryDescriptorListHead;
         NextMd = MemoryDescriptor->ListEntry.Flink
        )
    {
        MemoryDescriptor = CONTAINING_RECORD(NextMd,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);

        if (MemoryDescriptor->MemoryType == LoaderXIPRom) {

            return MemoryDescriptor;
        }
    }

    return NULL;
}

#endif //__X86__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\zone.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    zone.c

Abstract:

    This module implements a simple zone buffer manager.  The primary
    consumer of this module is local LPC.

    The zone package provides a fast and efficient memory allocator for
    fixed-size 64-bit aligned blocks of storage.  The zone package does
    not provide any serialization over access to the zone header and
    associated free list and segment list.  It is the responsibility of
    the caller to provide any necessary serialization.

    The zone package views a zone as a set of fixed-size blocks of
    storage.  The block size of a zone is specified during zone
    initialization.  Storage is assigned to a zone during zone
    initialization and when a zone is extended.  In both of these cases,
    a segment and length are specified.

    The zone package uses the first ZONE_SEGMENT_HEADER portion of the
    segment for zone overhead.  The remainder of the segment is carved
    up into fixed-size blocks and each block is added to the free list
    maintained in the zone header.

    As long as a block is on the free list, the first SINGLE_LIST_ENTRY
    (32 bit) sized piece of the block is used as zone overhead.  The
    rest of the block is not used by the zone package and may be used by
    applications to cache information.  When a block is not on the free
    list, its entire contents are available to the application.

Author:

    Mark Lucovsky (markl) 13-May-1989

Revision History:

--*/

#include "exp.h"

NTSTATUS
ExInitializeZone(
    IN PZONE_HEADER Zone,
    IN ULONG BlockSize,
    IN PVOID InitialSegment,
    IN ULONG InitialSegmentSize
    )

/*++

Routine Description:

    This function initializes a zone header.  Once successfully
    initialized, blocks can be allocated and freed from the zone, and
    the zone can be extended.

Arguments:

    Zone - Supplies the address of a zone header to be initialized.

    BlockSize - Supplies the block size of the allocatable unit within
                the zone.  The size must be larger that the size of the
                initial segment, and must be 64-bit aligned.

    InitialSegment - Supplies the address of a segment of storage.  The
                     first ZONE_SEGMENT_HEADER-sized portion of the segment
                     is used by the zone allocator.  The remainder of
                     the segment is carved up into fixed size
                     (BlockSize) blocks and is made available for
                     allocation and deallocation from the zone.  The
                     address of the segment must be aligned on a 64-bit
                     boundary.

    InitialSegmentSize - Supplies the size in bytes of the InitialSegment.

Return Value:

    STATUS_UNSUCCESSFUL - BlockSize or InitialSegment was not aligned on
                          64-bit boundaries, or BlockSize was larger than
                          the initial segment size.

    STATUS_SUCCESS - The zone was successfully initialized.

--*/

{
    ULONG i;
    PCH p;

    if ( (BlockSize & 7) || ((ULONG_PTR)InitialSegment & 7) ||
         (BlockSize > InitialSegmentSize) ) {
#if DBG
        DbgPrint( "EX: ExInitializeZone( %x, %x, %x, %x ) - Invalid parameters.\n",
                  Zone, BlockSize, InitialSegment, InitialSegmentSize
                );
        DbgBreakPoint();
#endif
        return STATUS_INVALID_PARAMETER;
    }

    Zone->BlockSize = BlockSize;

    Zone->SegmentList.Next = &((PZONE_SEGMENT_HEADER) InitialSegment)->SegmentList;
    ((PZONE_SEGMENT_HEADER) InitialSegment)->SegmentList.Next = NULL;
    ((PZONE_SEGMENT_HEADER) InitialSegment)->Reserved = NULL;

    Zone->FreeList.Next = NULL;

    p = (PCH)InitialSegment + sizeof(ZONE_SEGMENT_HEADER);

    for (i = sizeof(ZONE_SEGMENT_HEADER);
         i <= InitialSegmentSize - BlockSize;
         i += BlockSize
        ) {
        ((PSINGLE_LIST_ENTRY)p)->Next = Zone->FreeList.Next;
        Zone->FreeList.Next = (PSINGLE_LIST_ENTRY)p;
        p += BlockSize;
    }
    Zone->TotalSegmentSize = i;

#if 0
    DbgPrint( "EX: ExInitializeZone( %lx, %lx, %lu, %lu, %lx )\n",
              Zone, InitialSegment, InitialSegmentSize,
              BlockSize, p
            );
#endif

    return STATUS_SUCCESS;
}

NTSTATUS
ExExtendZone(
    IN PZONE_HEADER Zone,
    IN PVOID Segment,
    IN ULONG SegmentSize
    )

/*++

Routine Description:

    This function extends a zone by adding another segment's worth of
    blocks to the zone.

Arguments:

    Zone - Supplies the address of a zone header to be extended.

    Segment - Supplies the address of a segment of storage.  The first
              ZONE_SEGMENT_HEADER-sized portion of the segment is used by the
              zone allocator.  The remainder of the segment is carved up
              into fixed-size (BlockSize) blocks and is added to the
              zone.  The address of the segment must be aligned on a 64-
              bit boundary.

    SegmentSize - Supplies the size in bytes of Segment.

Return Value:

    STATUS_UNSUCCESSFUL - BlockSize or Segment was not aligned on
                          64-bit boundaries, or BlockSize was larger than
                          the segment size.

    STATUS_SUCCESS - The zone was successfully extended.

--*/

{
    ULONG i;
    PCH p;

    if ( ((ULONG_PTR)Segment & 7) ||
         (SegmentSize & 7) ||
         (Zone->BlockSize > SegmentSize) ) {
        return STATUS_UNSUCCESSFUL;
    }

    ((PZONE_SEGMENT_HEADER) Segment)->SegmentList.Next = Zone->SegmentList.Next;
    Zone->SegmentList.Next = &((PZONE_SEGMENT_HEADER) Segment)->SegmentList;

    p = (PCH)Segment + sizeof(ZONE_SEGMENT_HEADER);

    for (i = sizeof(ZONE_SEGMENT_HEADER);
         i <= SegmentSize - Zone->BlockSize;
         i += Zone->BlockSize
        ) {

        ((PSINGLE_LIST_ENTRY)p)->Next = Zone->FreeList.Next;
        Zone->FreeList.Next = (PSINGLE_LIST_ENTRY)p;
        p += Zone->BlockSize;
    }
    Zone->TotalSegmentSize += i;

#if 0
    DbgPrint( "EX: ExExtendZone( %lx, %lx, %lu, %lu, %lx )\n",
              Zone, Segment, SegmentSize, Zone->BlockSize, p
            );
#endif

    return STATUS_SUCCESS;
}



NTSTATUS
ExInterlockedExtendZone(
    IN PZONE_HEADER Zone,
    IN PVOID Segment,
    IN ULONG SegmentSize,
    IN PKSPIN_LOCK Lock
    )

/*++

Routine Description:

    This function extends a zone by adding another segment's worth of
    blocks to the zone.

Arguments:

    Zone - Supplies the address of a zone header to be extended.

    Segment - Supplies the address of a segment of storage.  The first
              ZONE_SEGMENT_HEADER-sized portion of the segment is used by the
              zone allocator.  The remainder of the segment is carved up
              into fixed-size (BlockSize) blocks and is added to the
              zone.  The address of the segment must be aligned on a 64-
              bit boundary.

    SegmentSize - Supplies the size in bytes of Segment.

    Lock - pointer to spinlock to use

Return Value:

    STATUS_UNSUCCESSFUL - BlockSize or Segment was not aligned on
                          64-bit boundaries, or BlockSize was larger than
                          the segment size.

    STATUS_SUCCESS - The zone was successfully extended.

--*/

{
    NTSTATUS Status;
    KIRQL OldIrql;

#ifdef NT_UP
    UNREFERENCED_PARAMETER (Lock);
#endif

    ExAcquireSpinLock( Lock, &OldIrql );

    Status = ExExtendZone( Zone, Segment, SegmentSize );

    ExReleaseSpinLock( Lock, OldIrql );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\alpha\hifreqlk.s ===
//       TITLE("High Frequency Spin Locks")
//++
//
// Copyright (c) 1993  Microsoft Corporation
// Copyright (c) 1993  Digital Equipment Corporation
//
// Module Name:
//
//    hifreqlk.s
//
// Abstract:
//
//    This module contains storage for high frequency spin locks. Each
//    is allocated to a separate cache line.
//
// Author:
//
//    David N. Cutler (davec) 25-Jun-1993
//    Joe Notarangelo  29-Nov-1993
//
// Environment:
//
//    Kernel mode.
//
// Revision History:
//
//--

#include "ksalpha.h"

//
// Define alignment for mp and up spinlocks.
//

#if defined(NT_UP)

#define ALIGN

#else

#define ALIGN .align 6

#endif

//
// Define spinlock size for mp and up systems.
//

#if defined(_AXP64_)

#define SPIN_LOCK .quad 0

#else

#define SPIN_LOCK .long 0

#endif

        .sdata
        ALIGN
        SPIN_LOCK

        .globl  AfdWorkQueueSpinLock
        ALIGN
AfdWorkQueueSpinLock:                   // AFD work queue lock
        SPIN_LOCK                       //

        .globl  CcBcbSpinLock
        ALIGN
CcBcbSpinLock:                          // cache manager BCB lock
        SPIN_LOCK                       //

        .globl  CcMasterSpinLock
        ALIGN
CcMasterSpinLock:                       // cache manager master lock
        SPIN_LOCK                       //

        .globl  CcVacbSpinLock
        ALIGN
CcVacbSpinLock:                         // cache manager VACB lock
        SPIN_LOCK                       //

        .globl  CcWorkQueueSpinLock
        ALIGN
CcWorkQueueSpinLock:                    // cache manager work queue lock
        SPIN_LOCK                       //

        .globl  ExpResourceSpinLock
        ALIGN
ExpResourceSpinLock:                    // resource package lock
        SPIN_LOCK                       //

        .globl  IopCancelSpinLock
        ALIGN
IopCancelSpinLock:                      // I/O cancel lock
        SPIN_LOCK                       //

        .globl  IopCompletionLock
        ALIGN
IopCompletionLock:                      // I/O completion lock
        SPIN_LOCK                       //

        .globl  IopDatabaseLock
        ALIGN
IopDatabaseLock:                        // I/O database lock
        SPIN_LOCK                       //

        .globl  IopVpbSpinLock
        ALIGN
IopVpbSpinLock:                         // I/O VPB lock
        SPIN_LOCK                       //

        .globl  IoStatisticsLock
        ALIGN
IoStatisticsLock:                       // I/O statistics lock
        SPIN_LOCK                       //

        .globl  KiContextSwapLock
        ALIGN
KiContextSwapLock:                      // context swap lock
        SPIN_LOCK                       //

        .globl  KiMasterSequence
KiMasterSequence:                       // master sequence number
        .quad   1                       //

        .globl  KiMasterAsn
KiMasterAsn:                            // master ASN number
        .long   0                       //

        .globl  KiMaximumAsn
KiMaximumAsn:                           //
        .long   0                       //

        .globl  KiTbiaFlushRequest      //
KiTbiaFlushRequest:                     // TB invalidate all mask
        .long   0xFFFFFFFF              //

        .globl  KiDispatcherLock
        ALIGN
KiDispatcherLock:                       // dispatcher database lock
        SPIN_LOCK                       //

        .globl  KiSynchIrql
KiSynchIrql:                            // synchronization IRQL
        .long   SYNCH_LEVEL             //

        .globl  MmPfnLock
        ALIGN
MmPfnLock:                              // page frame database lock
        SPIN_LOCK                       //

        .globl  MmChargeCommitmentLock
        ALIGN
MmChargeCommitmentLock:                 // charge commitment lock
        SPIN_LOCK                       //

        .globl  NonPagedPoolLock
        ALIGN
NonPagedPoolLock:                       // nonpage pool allocation lock
        SPIN_LOCK                       //

        .globl  NtfsStructLock
        ALIGN
NtfsStructLock:                         // NTFS structure lock lock
        SPIN_LOCK                       //

//
// IopLookasideIrpFloat - This is the number of IRPs that are currently
//      in progress that were allocated from a lookaside list.
//

        .globl  IopLookasideIrpFloat
        ALIGN
IopLookasideIrpFloat:                   //
        .long   0                       //

//
// IopLookasideIrpLimit - This is the maximum number of IRPs that can be
//      in progress that were allocated from a lookaside list.
//

        .globl  IopLookasideIrpLimit
IopLookasideIrpLimit:                   //
        .long   0                       //

//
// KeTickCount - This is the number of clock ticks that have occurred since
//      the system was booted. This count is used to compute a millisecond
//      tick counter.
//

        .align  6
        .globl  KeTickCount
KeTickCount:                            //
        .quad   0                       //

//
// KeMaximumIncrement - This is the maximum time between clock interrupts
//      in 100ns units that is supported by the host HAL.
//

        .globl  KeMaximumIncrement
KeMaximumIncrement:                     //
        .long   0                       //

//
// KeTimeAdjustment - This is the actual number of 100ns units that are to
//      be added to the system time at each interval timer interupt. This
//      value is copied from KeTimeIncrement at system start up and can be
//      later modified via the set system information service.
//      timer table entries.
//

        .globl  KeTimeAdjustment
KeTimeAdjustment:                       //
        .long   0                       //

//
// KiTickOffset - This is the number of 100ns units remaining before a tick
//      is added to the tick count and the system time is updated.
//

        .globl  KiTickOffset
KiTickOffset:                           //
        .long   0                       //

//
// KiMaximumDpcQueueDepth - This is used to control how many DPCs can be
//      queued before a DPC of medium importance will trigger a dispatch
//      interrupt.
//

        .globl  KiMaximumDpcQueueDepth
KiMaximumDpcQueueDepth:                 //
        .long   4                       //

//
// KiMinimumDpcRate - This is the rate of DPC requests per clock tick that
//      must be exceeded before DPC batching of medium importance DPCs
//      will occur.
//

        .globl  KiMinimumDpcRate
KiMinimumDpcRate:                       //
        .long   3                       //

//
// KiAdjustDpcThreshold - This is the threshold used by the clock interrupt
//      routine to control the rate at which the processor's DPC queue depth
//      is dynamically adjusted.
//

        .globl  KiAdjustDpcThreshold
KiAdjustDpcThreshold:                   //
        .long   20                      //

//
// KiIdealDpcRate - This is used to control the aggressiveness of the DPC
//      rate adjusting algorithm when decrementing the queue depth. As long
//      as the DPC rate for the last tick is greater than this rate, the
//      DPC queue depth will not be decremented.
//

        .globl  KiIdealDpcRate
KiIdealDpcRate:                         //
        .long   20                      //

//
// KiMbTimeStamp - This is the memory barrier time stamp value that is
//      incremented each time a global memory barrier is executed on an
//      MP system.
//

#if !defined(NT_UP)

        ALIGN
        .globl  KiMbTimeStamp
KiMbTimeStamp:                          //
        .long   0                       //

#endif

//
// KiTbFlushTimeStamp - This is the TB flush entire time stamp counter.
//

        ALIGN
        .globl  KiTbFlushTimeStamp
KiTbFlushTimeStamp:                     //
        .long   0                       //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\alpha\gettick.s ===
//       TITLE("Get Tick Count")
//++
//
// Copyright (c) 1992  Microsoft Corporation
// Copyright (c) 1992  Digital Equipment Corporation
//
// Module Name:
//
//    gettick.s
//
// Abstract:
//
//    This module contains the implementation for the get tick count
//    system service that returns the number of milliseconds since the
//    system was booted.
//
// Author:
//
//    David N. Cutler (davec) 10-Sep-1992
//
// Environment:
//
//    Kernel mode.
//
// Revision History:
//
//    Thomas Van Baak (tvb) 5-Oct-1992
//
//        Adapted for Alpha AXP.
//
//--

#include "ksalpha.h"

        SBTTL("Get Tick Count")
//++
//
// ULONG
// NtGetTickCount (
//    VOID
//    )
//
// Routine Description:
//
//    This function computes the number of milliseconds since the system
//    was booted. The computation is performed by multiplying the clock
//    interrupt count by a scaled fixed binary multiplier and then right
//    shifting the 64-bit result to extract the 32-bit millisecond count.
//
//    The multiplier fraction is scaled by 24 bits. Thus for a 100 Hz clock
//    rate, there are 10 ticks per millisecond, and the multiplier is
//    0x0a000000 (10 << 24). For a 128 Hz clock rate, there are 7.8125, or
//    7 13/16 ticks per millisecond, and so the multiplier is 0x07d00000.
//
//    This effectively replaces a (slow) divide instruction with a (fast)
//    multiply instruction. The multiplier value is only calculated once
//    based on the TimeIncrement value (clock tick interval in 100ns units).
//
//    N.B. The tick count value wraps every 2^32 milliseconds (49.71 days).
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    The number of milliseconds since the system was booted is returned
//    as the function value.
//
//--

        LEAF_ENTRY(NtGetTickCount)

        ldl     t0, KeTickCount         // get current tick count value
        zap     t0, 0xf0, t0            // convert to unsigned longword
        ldl     t1, ExpTickCountMultiplier  // get tick count multiplier
        zap     t1, 0xf0, t1            // convert to unsigned longword
        mulq    t0, t1, v0              // compute 64-bit product
        srl     v0, 24, v0              // shift off 24-bit fraction part
        addl    v0, 0, v0               // keep 32-bit canonical ULONG integer part

        ret     zero, (ra)              // return

        .end    NtGetTickCount
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\alpha\fmutex.s ===
//      TITLE("Alpha Fast Mutex Support")
//++
//
// Copyright (c) 1994  Microsoft Corporation
//
// Module Name:
//
//    fmutex.s
//
// Abstract:
//
//    This module implements the code necessary to acquire and release fast
//    mutxes.
//
//
// Author:
//
//    John Vert (jvert) 14-Apr-1994
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//--

#include "ksalpha.h"

        SBTTL("Acquire Fast Mutex")
//++
//
// VOID
// ExAcquireFastMutex (
//    IN PFAST_MUTEX FastMutex
//    )
//
// Routine Description:
//
//    This function acquires ownership of a fast mutex and raises IRQL to
//    APC Level.
//
// Arguments:
//
//    FastMutex (a0) - Supplies a pointer to a fast mutex.
//
// Return Value:
//
//    None.
//
//--

        .struct 0
FmA0:   .space  8                       // saved fast mutex address
FmIrql: .space  4                       // old IRQL value
        .space  4                       // fill
FmRa:   .space  8                       // saved return address
        .space  8                       // fill
FastMutexFrameLength:                   // frame length

        NESTED_ENTRY(ExAcquireFastMutex, FastMutexFrameLength, zero)

        lda     sp, -FastMutexFrameLength(sp) // allocate stack frame
        stq     ra, FmRa(sp)            // save return address

        PROLOGUE_END

//
// Raise IRQL to APC_LEVEL
//

        bis     a0, zero, t0            // save address of fast mutex
        bis     zero, APC_LEVEL, a0     // set new IRQL level

        SWAP_IRQL                       // raise IRQL

//
// Decrement ownership count.
//

10:     ldl_l   t4, FmCount(t0)         // get ownership count
        subl    t4, 1, t5               // decrement ownership count
        stl_c   t5, FmCount(t0)         // conditionally store ownership count
        beq     t5, 15f                 // if eq, conditional store failed
        ble     t4, 20f                 // if le, mutex is already owned

#if !defined(NT_UP)

        mb                              // synchronize memory access

#endif

        stl     v0, FmOldIrql(t0)       // save previous IRQL

        GET_CURRENT_THREAD              // get current thread address

        STP     v0, FmOwner(t0)         // set owner thread address
        lda     sp, FastMutexFrameLength(sp) // deallocate stack frame
        ret     zero, (ra)              // return

//
// Store conditional attempt failed.
//

15:     br      zero, 10b               // retry

//
// Fast mutex is currently owned by another thread. Increment the contention
// count and wait for ownership.
//

20:     stl     v0, FmIrql(sp)          // save previous IRQL
        STP     t0, FmA0(sp)            // save address of fast mutex
        ldl     t1, FmContention(t0)    // increment contention count
        addl    t1, 1, t2               //
        stl     t2, FmContention(t0)    //
        bis     zero, zero, a4          // set NULL timeout pointer
        bis     zero, FALSE, a3         // set nonalertable wait
        bis     zero, KernelMode, a2    // set mode of wait
        bis     zero, Executive, a1     // set reason for wait
        ADDP    t0, FmEvent, a0         // compute address of event
        bsr     ra, KeWaitForSingleObject // wait for ownership
        LDP     t0, FmA0(sp)            // get address of fast mutex
        ldl     a1, FmIrql(sp)          // get old IRQL value
        stl     a1, FmOldIrql(t0)       // save old IRQL value in fast mutex

        GET_CURRENT_THREAD              // get current thread address

        STP     v0, FmOwner(t0)         // set owner thread address
        ldq     ra, FmRa(sp)            // restore return address
        lda     sp, FastMutexFrameLength(sp) // deallocate stack frame
        ret     zero, (ra)              // return

        .end    ExAcquireFastMutex

        SBTTL("Release Fast Mutex")
//++
//
// VOID
// ExReleaseFastMutex (
//    IN PFAST_MUTEX FastMutex
//    )
//
// Routine Description:
//
//    This function releases ownership to a fast mutex and lowers IRQL to
//    its previous level.
//
// Arguments:
//
//    FastMutex (a0) - Supplies a pointer to a fast mutex.
//
// Return Value:
//
//    None.
//
//--

        NESTED_ENTRY(ExReleaseFastMutex, FastMutexFrameLength, zero)

        lda     sp, -FastMutexFrameLength(sp) // allocate stack frame
        stq     ra, FmRa(sp)            // save return address

        PROLOGUE_END

        ldl     a1, FmOldIrql(a0)      // get old IRQL value
        STP     zero, FmOwner(a0)      // clear owner thread address
//
// Synchronize all previous writes before the mutex is released.
//

#if !defined(NT_UP)

        mb                              // synchronize memory access

#endif

//
// Increment ownership count and release waiter if contention.
//

10:     ldl_l   t0, FmCount(a0)        // get ownership count
        addl    t0, 1, t1              // increment ownership count
        stl_c   t1, FmCount(a0)        // conditionally store ownership count
        beq     t1, 15f                // if eq, store conditional failed
        bne     t0, 30f                // if ne, a waiter is present

//
// Lower IRQL to its previous value.
//

        bis     a1, zero, a0            // set IRQL level

20:     SWAP_IRQL                       // lower IRQL

        lda     sp, FastMutexFrameLength(sp) // deallocate stack frame
        ret     zero, (ra)              // return

//
// There is contention for the fast mutex. Wake up a waiting thread and
// boost its priority to the priority of the current thread.
//

30:     stl     a1, FmIrql(sp)          // save old IRQL value
        ADDP    a0, FmEvent, a0         // compute address of event
        bis     zero, zero, a1          // set optional parameter
        bsr     ra, KeSetEventBoostPriority // set event and boost priority
        ldl     a0, FmIrql(sp)          // restore old IRQL value
        ldq     ra, FmRa(sp)            // restore return address
        br      zero, 20b               // lower IRQL and return

//
// Conditional store attempt failed.
//

15:     br      zero, 10b               // retry

        .end    ExReleaseFastMutex

        SBTTL("Try To Acquire Fast Mutex")
//++
//
// BOOLEAN
// ExTryToAcquireFastMutex (
//    IN PFAST_MUTEX FastMutex
//    )
//
// Routine Description:
//
//    This function attempts to acquire ownership of a fast mutex, and if
//    successful, raises IRQL to APC level.
//
// Arguments:
//
//    FastMutex (a0) - Supplies a pointer to a fast mutex.
//
// Return Value:
//
//    If the fast mutex was successfully acquired, then a value of TRUE
//    is returned as the function value. Otherwise, a valye of FALSE is
//    returned.
//
//--

        LEAF_ENTRY(ExTryToAcquireFastMutex)

//
// Raise IRQL to APC_LEVEL.
//

        bis     a0, zero, t0            // save fast mutex address
        bis     zero, APC_LEVEL, a0     // set new IRQL level

        SWAP_IRQL                       // raise IRQL

        bis     v0, zero, a0            // save previous IRQL

//
// Decrement ownership count if and only if fast mutex is not currently
// owned.
//

10:     ldl_l   t4, FmCount(t0)         // get ownership count
        subl    t4, 1, v0               // decrement ownership count
        ble     t4, 20f                 // if le, mutex is already owned
        stl_c   v0, FmCount(t0)         // conditionally store ownership count
        beq     v0, 15f                 // if ne, conditional store failed

#if !defined(NT_UP)

        mb                              // synchronize memory access

#endif

        stl     a0, FmOldIrql(t0)       // set previous IRQL

        GET_CURRENT_THREAD              // get current thread address

        STP     v0, FmOwner(t0)         // set owner thread address
        bis     zero, TRUE, v0          // set return value
        ret     zero, (ra)              // return

//
// Conditional store attempt failed.
//

15:     br      zero, 10b               // retry

//
// Fast mutex is currently owned by another thread. Restore IRQL to its
// previous valye and return false.
//

20:     SWAP_IRQL                      // lower IRQL

        bis     zero, zero, v0         // set return value
        ret     zero, (ra)             // return

        .end    ExTrytoAcquireFastMutex

        SBTTL("Acquire Fast Mutex Unsafe")
//++
//
// VOID
// ExAcquireFastMutexUnsafe (
//    IN PFAST_MUTEX FastMutex
//    )
//
// Routine Description:
//
//    This function acquires ownership of a fast mutex, but does not raise
//    IRQL to APC Level.
//
// Arguments:
//
//    FastMutex (a0) - Supplies a pointer to a fast mutex.
//
// Return Value:
//
//    None.
//
//--

        NESTED_ENTRY(ExAcquireFastMutexUnsafe, FastMutexFrameLength, zero)

        lda     sp, -FastMutexFrameLength(sp) // allocate stack frame
        stq     ra, FmRa(sp)            // save return address

        PROLOGUE_END

//
// Decrement ownership count.
//

        bis     a0, zero, t0            // save fast mutex address
10:     ldl_l   t4, FmCount(t0)         // get ownership count
        subl    t4, 1, t5               // decrement ownership count
        stl_c   t5, FmCount(t0)         // conditionally store ownership count
        beq     t5, 15f                 // if eq, conditional store failed
        ble     t4, 20f                 // if le zero, mutex is already owned

#if !defined(NT_UP)

        mb                              // synchronize memory access

#endif

        GET_CURRENT_THREAD              // get current thread address

        STP     v0, FmOwner(t0)         // store owning thread
        lda     sp, FastMutexFrameLength(sp) // deallocate stack frame
        ret     zero, (ra)              // return

//
// Conditional store attempt failed.
//

15:     br      zero, 10b                           // retry

//
// Fast mutex is currently owned by another thread. Increment the contention
// count and wait for ownership.
//

20:     STP     t0, FmA0(sp)            // save address of fast mutex
        ldl     t1, FmContention(t0)    // increment contention count
        addl    t1, 1, t2               //
        stl     t2, FmContention(t0)    //
        bis     zero, zero, a4          // set NULL timeout pointer
        bis     zero, FALSE, a3         // set nonalertable wait
        bis     zero, KernelMode, a2    // set mode of wait
        bis     zero, Executive, a1     // set reason for wait
        ADDP    t0, FmEvent, a0         // compute address of event
        bsr     ra, KeWaitForSingleObject // wait for ownership
        LDP     t0, FmA0(sp)            // get address of fast mutex

        GET_CURRENT_THREAD              // get current thread address

        STP     v0, FmOwner(t0)         // set owner  thread address
        ldq     ra, FmRa(sp)            // restore return address
        lda     sp, FastMutexFrameLength(sp) // deallocate stack frame
        ret     zero, (ra)              //

        .end    ExAcquireFastMutexUnsafe

        SBTTL("Release Fast Mutex Unsafe")
//++
//
// VOID
// ExReleaseFastMutexUnsafe (
//    IN PFAST_MUTEX FastMutex
//    )
//
// Routine Description:
//
//    This function releases ownership to a fast mutex, and does not
//    restore IRQL to its previous level.
//
// Arguments:
//
//    FastMutex (a0) - Supplies a pointer to a fast mutex.
//
// Return Value:
//
//    None.
//
//--

        NESTED_ENTRY(ExReleaseFastMutexUnsafe, FastMutexFrameLength, zero)

        lda     sp, -FastMutexFrameLength(sp) // allocate stack frame
        stq     ra, FmRa(sp)            // save return address

        PROLOGUE_END


//
// Synchronize all previous writes before the mutex is released.
//

#if !defined(NT_UP)

        mb                              // synchronize memory access

#endif

//
// Increment ownership count and release waiter if contention.
//

        STP     zero, FmOwner(a0)      // clear owner thread address
10:     ldl_l   t0, FmCount(a0)        // get ownership count
        addl    t0, 1, t1              // increment ownership count
        stl_c   t1, FmCount(a0)        // conditionally store ownership count
        beq     t1, 15f                // if eq, store conditional failed
        beq     t0, 20f                // if ne, a waiter is present

//
// There is contention for the fast mutex. Wake up a waiting thread and
// boost its priority to the priority of the current thread.
//

        ADDP    a0, FmEvent, a0         // compute address of event
        bis     zero, zero, a1          // set optional parameter
        bsr     ra, KeSetEventBoostPriority // set event and boost priority
        ldq     ra, FmRa(sp)            // restore return address
20:     lda     sp, FastMutexFrameLength(sp) // deallocate stack frame
        ret     zero, (ra)              // return

//
// Conditional store attempt failed.

15:     br      zero, 10b               // retry

        .end    ExReleaseFastMutexUnsafe

        SBTTL("Try To Acquire Fast Mutex Unsafe")
//++
//
// BOOLEAN
// ExTryToAcquireFastMutexUnsafe (
//    IN PFAST_MUTEX FastMutex
//    )
//
// Routine Description:
//
//    This function attempts to acquire ownership of a fast mutex, and if
//    successful, does not raise IRQL to APC level.
//
// Arguments:
//
//    FastMutex (a0) - Supplies a pointer to a fast mutex.
//
// Return Value:
//
//    If the fast mutex was successfully acquired, then a value of TRUE
//    is returned as the function value. Otherwise, a valye of FALSE is
//    returned.
//
//--

#if 0

        LEAF_ENTRY(ExTryToAcquireFastMutexUnsafe)

//
// Decrement ownership count if and only if fast mutex is not currently
// owned.
//

        bis     a0, zero, t0            // save fast mutex address
10:     ldl_l   t4, FmCount(t0)         // get ownership count
        subl    t4, 1, v0               // decrement ownership count
        ble     t4, 20f                 // if le zero, mutex is already owned
        stl_c   v0, FmCount(t0)         // conditionally store ownership count
        beq     v0, 15f                 // if eq, conditional store failed

#if !defined(NT_UP)

        mb                              // synchronize memory access

#endif

        GET_CURRENT_THREAD              // get current thread address

        STP     v0, FmOwner(t0)         // set owner thread address
        ret     zero, (ra)              // return

//
// Conditional store attempt failed.

15:     br      zero, 10b                           // retry

//
// Fast mutex is currently owned by another thread. Restore IRQL to its
// previous value and return false.
//

20:     bis     zero, zero, v0         // set return value
        ret     zero, (ra)             // return

        .end    ExTrytoAcquireFastMutexUnsafe

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\alpha\evpair.s ===
//       TITLE("Fast Event Pair Support")
//++
//
// Copyright (c) 1992  Microsoft Corporation
// Copyright (c) 1992  Digital Equipment Corporation
//
// Module Name:
//
//    evpair.s
//
// Abstract:
//
//    This module contains the implementation for the fast event pair
//    system services that are used for client/server synchronization.
//
// Author:
//
//    David N. Cutler (davec) 1-Feb-1992
//
// Environment:
//
//    Kernel mode.
//
// Revision History:
//
//    Thomas Van Baak (tvb) 20-May-1992
//
//        Adapted for Alpha AXP.
//
//--

#include "ksalpha.h"

        SBTTL("Set Low Wait High Thread")
//++
//
// NTSTATUS
// NtSetLowWaitHighThread (
//    )
//
// Routine Description:
//
//    This function uses the prereferenced client/server event pair pointer
//    and sets the low event of the event pair and waits on the high event
//    of the event pair object.
//
//    N.B. This is a very heavily used service.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    STATUS_NO_EVENT_PAIR is returned if no event pair is associated with
//    the current thread. Otherwise, the status of the wait operation is
//    returned as the function value.
//
//
//--

        LEAF_ENTRY(NtSetLowWaitHighThread)

        GET_CURRENT_THREAD              // v0 = current thread

        ldl     a0, EtEventPair(v0)     // get address of event pair object
        beq     a0, 10f                 // if eq, no event pair associated
        addl    a0, EpEventHigh, a1     // compute client event address
        addl    a0, EpEventLow, a0      // comput server event address
        ldil    a2, 1                   // set user mode value
        br      zero, KiSetServerWaitClientEvent // finish in wait code

10:     ldil    v0, STATUS_NO_EVENT_PAIR        // set error status return value
        ret     zero, (ra)              // return

        .end    NtSetLowWaitHighThread

        SBTTL("Set High Wait Low Thread")
//++
//
// NTSTATUS
// NtSetHighWaitLowThread (
//    )
//
// Routine Description:
//
//    This function uses the prereferenced client/server event pair pointer
//    and sets the High event of the event pair and waits on the low event
//    of the event pair object.
//
//    N.B. This is a very heavily used service.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    STATUS_NO_EVENT_PAIR is returned if no event pair is associated with
//    the current thread. Otherwise, the status of the wait operation is
//    returned as the function value.
//
//
//--

        LEAF_ENTRY(NtSetHighWaitLowThread)

        GET_CURRENT_THREAD              // v0 = current thread

        ldl     a0, EtEventPair(v0)     // get address of event pair object
        beq     a0, 10f                 // if eq, no event pair associated
        addl    a0, EpEventLow, a1      // compute client event address
        addl    a0, EpEventHigh, a0     // compute server event address
        ldil    a2, 1                   // set user mode value
        br      zero, KiSetServerWaitClientEvent // finish in wait code

10:     ldil    v0, STATUS_NO_EVENT_PAIR        // set error status return value
        ret     zero, (ra)              // return

        .end    NtSetHighWaitLowThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\alpha\intrlock.s ===
//       TITLE("Interlocked Support")
//++
//
// Copyright (c) 1990  Microsoft Corporation
// Copyright (c) 1992  Digital Equipment Corporation
//
// Module Name:
//
//    intrlock.s
//
// Abstract:
//
//    This module implements functions to support interlocked operations.
//    Interlocked operations can only operate on nonpaged data and the
//    specified spinlock cannot be used for any other purpose.
//
// Author:
//
//    David N. Cutler (davec) 26-Mar-1990
//
// Environment:
//
//    Kernel mode.
//
// Revision History:
//
//    Thomas Van Baak (tvb) 18-May-1992
//
//        Adapted for Alpha AXP.
//
//--

#include "ksalpha.h"

        SBTTL("Interlocked Add Large Integer")
//++
//
// LARGE_INTEGER
// ExInterlockedAddLargeInteger (
//    IN PLARGE_INTEGER Addend,
//    IN LARGE_INTEGER Increment,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function performs an interlocked add of an increment value to an
//    addend variable of type large integer. The initial value of the addend
//    variable is returned as the function value.
//
// Arguments:
//
//    Addend (a0) - Supplies a pointer to a variable whose value is to be
//       adjusted by the increment value.
//
//    Increment (a1) - Supplies the increment value to be added to the
//       addend variable.
//
//    Lock (a2) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the addend variable.
//
// Return Value:
//
//    The result of the interlocked large integer add.
//
// Implementation Note:
//
//    The specification of this function requires that the given lock must be
//    used to synchronize the update even though on Alpha the operation can
//    actually done atomically without using the specified lock.
//
//--

        LEAF_ENTRY(ExInterlockedAddLargeInteger)

10:     DISABLE_INTERRUPTS              // disable interrupts

#if !defined(NT_UP)

        LDP_L   t0, 0(a2)               // get current lock value - locked
        bne     t0, 20f                 // if ne, spin lock owned
        mov     a2, t0                  // set ownership value (lock address)
        STP_C   t0, 0(a2)               // set spin lock owned - conditionally
        beq     t0, 20f                 // if eq, conditional store failed
        mb                              // synchronize memory access


#endif

        ldq     t0, 0(a0)               // get addend
        addq    t0, a1, v0              // do the add
        stq     v0, 0(a0)               // store result

#if !defined(NT_UP)

        mb                              // synchronize memory access
        STP     zero, 0(a2)             // set spin lock not owned

#endif

        ENABLE_INTERRUPTS               // enable interrupts

        ret     zero, (ra)              // return


//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

#if !defined(NT_UP)

20:     ENABLE_INTERRUPTS               // enable interrupts

22:     LDP     t0, 0(a2)               // read current lock value
        beq     t0, 10b                 // if eq, lock not owned
        br      zero, 22b               // spin in cache until available

#endif

        .end    ExInterlockedAddLargeInteger

        SBTTL("Interlocked Add Large Statistic")
//++
//
// VOID
// ExInterlockedAddLargeStatistic (
//    IN PLARGE_INTEGER Addend,
//    IN ULONG Increment
//    )
//
// Routine Description:
//
//    This function performs an interlocked add of an increment value to an
//    addend variable of type large integer.
//
// Arguments:
//
//    Addend (a0) - Supplies a pointer to a variable whose value is to be
//       adjusted by the increment value.
//
//    Increment (a1) - Supplies the increment value to be added to the
//       addend variable.
//
// Return Value:
//
//    None.
//
// Implementation Note:
//
//    The specification of this function requires that the given lock must be
//    used to synchronize the update even though on Alpha the operation can
//    actually done atomically without using the specified lock.
//
//--

        LEAF_ENTRY(ExInterlockedAddLargeStatistic)

        zap     a1, 0xf0, a1            // zero extend increment value
10:     ldq_l   t0, 0(a0)               // get addend
        addq    t0, a1, t0              // do the add
        stq_c   t0, 0(a0)               // store result
        beq     t0, 20f                 // if eq, store conditional failed
        ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

20:     br      zero, 10b               // try again

        .end    ExInterlockedAddLargeStatistic

        SBTTL("Interlocked Add Unsigned Long")
//++
//
// ULONG
// ExInterlockedAddUlong (
//    IN PULONG Addend,
//    IN ULONG Increment,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function performs an interlocked add of an increment value to an
//    addend variable of type unsigned long. The initial value of the addend
//    variable is returned as the function value.
//
// Arguments:
//
//    Addend (a0) - Supplies a pointer to a variable whose value is to be
//       adjusted by the increment value.
//
//    Increment (a1) - Supplies the increment value to be added to the
//       addend variable.
//
//    Lock (a2) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the addend variable.
//
// Return Value:
//
//    The initial value of the addend variable.
//
// Implementation Note:
//
//    The specification of this function requires that the given lock must be
//    used to synchronize the update even though on Alpha the operation can
//    actually done atomically without using the specified lock.
//
//--

        LEAF_ENTRY(ExInterlockedAddUlong)

10:     DISABLE_INTERRUPTS              // (PALcode) v0 is clobbered

#if !defined(NT_UP)

        LDP_L   t0, 0(a2)               // get current lock value - locked
        bne     t0, 20f                 // if ne, spin lock still owned
        mov     a2, t0                  // set ownership value (lock address)
        STP_C   t0, 0(a2)               // set spin lock owned - conditionally
        beq     t0, 20f                 // if eq, conditional store failed
        mb                              // synchronize memory access

#endif

//
// Set the return value in t0 for now since PALcode may use v0.
//

        ldl     t0, 0(a0)               // get addend value (return value also)
        addl    t0, a1, t1              // compute adjusted value
        stl     t1, 0(a0)               // store updated value

#if !defined(NT_UP)

        mb                              // synchronize memory access
        STP     zero, 0(a2)             // set spin lock not owned

#endif

        ENABLE_INTERRUPTS               // (PALcode) v0 is clobbered

        mov     t0, v0                  // set return value
        ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

#if !defined(NT_UP)

20:     ENABLE_INTERRUPTS               // (PALcode) v0 is clobbered

22:     LDP     t0, 0(a2)               // read current lock value
        beq     t0, 10b                 // try spinlock again if available
        br      zero, 22b               // spin in cache until available

#endif

        .end    ExInterlockedAddUlong

        SBTTL("Interlocked Exchange Unsigned Long")
//++
//
// ULONG
// ExInterlockedExchangeUlong (
//    IN PULONG Source,
//    IN ULONG Value,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function performs an interlocked exchange of a longword value with
//    a longword in memory and returns the memory value.
//
//    N.B. There is an alternate entry point provided for this routine which
//         is ALPHA target specific and whose prototype does not include the
//         spinlock parameter. Since the routine never refers to the spinlock
//         parameter, no additional code is required.
//
// Arguments:
//
//    Source (a0) - Supplies a pointer to a variable whose value is to be
//       exchanged.
//
//    Value (a1) - Supplies the value to exchange with the source value.
//
//    Lock (a2) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the source variable.
//
// Return Value:
//
//    The source value is returned as the function value.
//
//--

        LEAF_ENTRY(ExInterlockedExchangeUlong)

        ALTERNATE_ENTRY(ExAlphaInterlockedExchangeUlong)

10:     ldl_l   v0, 0(a0)               // get current source value
        bis     a1, zero, t0            // set exchange value
        stl_c   t0, 0(a0)               // replace source value
        beq     t0, 20f                 // if eq, conditional store failed
        ret     zero, (ra)              // return old value to caller

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

20:     br      zero,10b                // go try spin lock again

        .end    ExInterlockedExchangeUlong

        SBTTL("Interlocked Decrement Long")
//++
//
// INTERLOCKED_RESULT
// ExInterlockedDecrementLong (
//    IN PLONG Addend,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function performs an interlocked decrement on an addend variable
//    of type signed long. The sign and whether the result is zero is returned
//    as the function value.
//
//    N.B. There is an alternate entry point provided for this routine which
//         is ALPHA target specific and whose prototype does not include the
//         spinlock parameter. Since the routine never refers to the spinlock
//         parameter, no additional code is required.
//
// Arguments:
//
//    Addend (a0) - Supplies a pointer to a variable whose value is to be
//       decremented.
//
//    Lock (a1) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the addend variable.
//
// Return Value:
//
//    RESULT_NEGATIVE is returned if the resultant addend value is negative.
//    RESULT_ZERO is returned if the resultant addend value is zero.
//    RESULT_POSITIVE is returned if the resultant addend value is positive.
//
// Implementation Note:
//
//    The specification of this function does not require that the given lock
//    be used to synchronize the update as long as the update is synchronized
//    somehow. On Alpha a single load locked-store conditional does the job.
//
//--

        LEAF_ENTRY(ExInterlockedDecrementLong)

        ALTERNATE_ENTRY(ExAlphaInterlockedDecrementLong)

10:     ldl_l   v0, 0(a0)               // get current addend value - locked
        subl    v0, 1, v0               // decrement addend value
        mov     v0, t0                  // copy updated value to t0 for store
        stl_c   t0, 0(a0)               // store updated value - conditionally
        beq     t0, 20f                 // if eq, conditional store failed

//
// Determine the INTERLOCKED_RESULT value based on the updated addend value.
// N.B. RESULT_ZERO = 0, RESULT_NEGATIVE = 1, RESULT_POSITIVE = 2.
//

        sra     v0, 63, t0              // replicate the sign bit to every bit
        addl    t0, 2, t0               // if t0 = 0 return 2, if -1 return 1
        cmovne  v0, t0, v0              // if v0 = 0 return 0
        ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

20:     br      zero, 10b               // go try spin lock again

        .end    ExInterlockedDecrementLong

        SBTTL("Interlocked Increment Long")
//++
//
// INTERLOCKED_RESULT
// ExInterlockedIncrementLong (
//    IN PLONG Addend,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function performs an interlocked increment on an addend variable
//    of type signed long. The sign and whether the result is zero is returned
//    as the function value.
//
//    N.B. There is an alternate entry point provided for this routine which
//         is ALPHA target specific and whose prototype does not include the
//         spinlock parameter. Since the routine never refers to the spinlock
//         parameter, no additional code is required.
//
// Arguments:
//
//    Addend (a0) - Supplies a pointer to a variable whose value is to be
//       incremented.
//
//    Lock (a1) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the addend variable.
//
// Return Value:
//
//    RESULT_NEGATIVE is returned if the resultant addend value is negative.
//    RESULT_ZERO is returned if the resultant addend value is zero.
//    RESULT_POSITIVE is returned if the resultant addend value is positive.
//
// Implementation Note:
//
//    The specification of this function does not require that the given lock
//    be used to synchronize the update as long as the update is synchronized
//    somehow. On Alpha a single load locked-store conditional does the job.
//
//--

        LEAF_ENTRY(ExInterlockedIncrementLong)

        ALTERNATE_ENTRY(ExAlphaInterlockedIncrementLong)

10:     ldl_l   v0, 0(a0)               // get current addend value - locked
        addl    v0, 1, v0               // increment addend value
        mov     v0, t0                  // copy updated value to t0 for store
        stl_c   t0, 0(a0)               // store updated value - conditionally
        beq     t0, 20f                 // if eq, conditional store failed

//
// Determine the INTERLOCKED_RESULT value based on the updated addend value.
// N.B. RESULT_ZERO = 0, RESULT_NEGATIVE = 1, RESULT_POSITIVE = 2.
//

        sra     v0, 63, t0              // replicate the sign bit to every bit
        addl    t0, 2, t0               // if t0 = 0 return 2, if -1 return 1
        cmovne  v0, t0, v0              // if v0 = 0 return 0
        ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

20:     br      zero, 10b               // go try spin lock again

        .end    ExInterlockedIncrementLong

        SBTTL("Interlocked Insert Head List")
//++
//
// PLIST_ENTRY
// ExInterlockedInsertHeadList (
//    IN PLIST_ENTRY ListHead,
//    IN PLIST_ENTRY ListEntry,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function inserts an entry at the head of a doubly linked list
//    so that access to the list is synchronized in a multiprocessor system.
//
// Arguments:
//
//    ListHead (a0) - Supplies a pointer to the head of the doubly linked
//       list into which an entry is to be inserted.
//
//    ListEntry (a1) - Supplies a pointer to the entry to be inserted at the
//       head of the list.
//
//    Lock (a2) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the list.
//
// Return Value:
//
//    Pointer to entry that was at the head of the list or NULL if the list
//    was empty.
//
//--

        LEAF_ENTRY(ExInterlockedInsertHeadList)

10:     DISABLE_INTERRUPTS              // (PALcode) v0 is clobbered

#if !defined(NT_UP)

        LDP_L   t0, 0(a2)               // get current lock value - locked
        bne     t0, 20f                 // if ne, spin lock still owned
        mov     a2, t0                  // set ownership value (lock address)
        STP_C   t0, 0(a2)               // set spin lock owned - conditionally
        beq     t0, 20f                 // if eq, conditional store failed
        mb                              // synchronize memory access

#endif

//
// Set the return value in t0 for now since PALcode may use v0.
//

        LDP     t0, LsFlink(a0)         // get address of next entry (return value also)
        STP     t0, LsFlink(a1)         // store next link in entry
        STP     a0, LsBlink(a1)         // store previous link in entry
        STP     a1, LsBlink(t0)         // store previous link in next
        STP     a1, LsFlink(a0)         // store next link in head

#if !defined(NT_UP)

        mb                              // sychronize memory access
        STP     zero, 0(a2)             // set spin lock not owned

#endif

        ENABLE_INTERRUPTS               // (PALcode) v0 is clobbered

        xor     t0, a0, v0              // if t0=a0, list empty, set v0 to NULL
        cmovne  v0, t0, v0              // else return previous entry at head
        ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

#if !defined(NT_UP)

20:     ENABLE_INTERRUPTS               // (PALcode) v0 is clobbered

22:     LDP     t0, 0(a2)               // read current lock value
        beq     t0, 10b                 // try spinlock again if available
        br      zero, 22b               // spin in cache until available

#endif

        .end    ExInterlockedInsertHeadList

        SBTTL("Interlocked Insert Tail List")
//++
//
// PLIST_ENTRY
// ExInterlockedInsertTailList (
//    IN PLIST_ENTRY ListHead,
//    IN PLIST_ENTRY ListEntry,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function inserts an entry at the tail of a doubly linked list
//    so that access to the list is synchronized in a multiprocessor system.
//
// Arguments:
//
//    ListHead (a0) - Supplies a pointer to the head of the doubly linked
//       list into which an entry is to be inserted.
//
//    ListEntry (a1) - Supplies a pointer to the entry to be inserted at the
//       tail of the list.
//
//    Lock (a2) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the list.
//
// Return Value:
//
//    Pointer to entry that was at the tail of the list or NULL if the list
//    was empty.
//
//--

        LEAF_ENTRY(ExInterlockedInsertTailList)

10:     DISABLE_INTERRUPTS              // (PALcode) v0 is clobbered

#if !defined(NT_UP)

        LDP_L   t0, 0(a2)               // get current lock value - locked
        bne     t0, 20f                 // if ne, spin lock still owned
        mov     a2, t0                  // set ownership value (lock address)
        STP_C   t0, 0(a2)               // set spin lock owned - conditionally
        beq     t0, 20f                 // if eq, conditional store failed
        mb                              // sychronize memory access

#endif

//
// Set the return value in t0 for now since PALcode may use v0.
//

        LDP     t0, LsBlink(a0)         // get address of previous entry (return value also)
        STP     a0, LsFlink(a1)         // store next link in entry
        STP     t0, LsBlink(a1)         // store previous link in entry
        STP     a1, LsBlink(a0)         // store previous link in next
        STP     a1, LsFlink(t0)         // store next link in head

#if !defined(NT_UP)

        mb                              // sychronize memory access
        STP     zero, 0(a2)             // set spin lock not owned

#endif

        ENABLE_INTERRUPTS               // (PALcode) v0 is clobbered

        xor     t0, a0, v0              // if t0=a0, list empty, set v0 to NULL
        cmovne  v0, t0, v0              // else return previous entry at tail
        ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

#if !defined(NT_UP)

20:     ENABLE_INTERRUPTS               // (PALcode) v0 is clobbered

22:     LDP     t0, 0(a2)               // read current lock value
        beq     t0, 10b                 // try spinlock again if available
        br      zero, 22b               // spin in cache until available

#endif

        .end    ExInterlockedInsertTailList

        SBTTL("Interlocked Remove Head List")
//++
//
// PLIST_ENTRY
// ExInterlockedRemoveHeadList (
//    IN PLIST_ENTRY ListHead,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function removes an entry from the head of a doubly linked list
//    so that access to the list is synchronized in a multiprocessor system.
//    If there are no entries in the list, then a value of NULL is returned.
//    Otherwise, the address of the entry that is removed is returned as the
//    function value.
//
// Arguments:
//
//    ListHead (a0) - Supplies a pointer to the head of the doubly linked
//       list from which an entry is to be removed.
//
//    Lock (a1) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the list.
//
// Return Value:
//
//    The address of the entry removed from the list, or NULL if the list is
//    empty.
//
//--

        LEAF_ENTRY(ExInterlockedRemoveHeadList)

10:     DISABLE_INTERRUPTS              // (PALcode) v0 is clobbered

#if !defined(NT_UP)

        LDP_L   t0, 0(a1)               // get current lock value - locked
        bne     t0, 30f                 // if ne, spin lock still owned
        mov     a1, t0                  // set ownership value (lock address)
        STP_C   t0, 0(a1)               // set spin lock owned - conditionally
        beq     t0, 30f                 // if eq, conditional store failed
        mb                              // synchronize memory access

#endif

//
// Set the return value in t0 for now since PALcode may use v0.
//

        LDP     t2, LsFlink(a0)         // get address of next entry
        xor     t2, a0, t0              // if t2=a0, list empty, set t0 to NULL
        beq     t0, 20f                 // if eq, list is empty
        LDP     t1, LsFlink(t2)         // get address of next entry
        STP     t1, LsFlink(a0)         // store address of next in head
        STP     a0, LsBlink(t1)         // store address of previous in next
        mov     t2, t0                  // return the address of entry removed
20:                                     //

#if !defined(NT_UP)

        mb                              // synchronize memory access
        STP     zero, 0(a1)             // set spin lock not owned

#endif

        ENABLE_INTERRUPTS               // (PALcode) v0 is clobbered

        mov     t0, v0                  // set return value
        ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

#if !defined(NT_UP)

30:     ENABLE_INTERRUPTS               // (PALcode) v0 is clobbered

32:     LDP     t0, 0(a1)               // read current lock value
        beq     t0, 10b                 // try spinlock again if available
        br      zero, 32b               // spin in cache until available

#endif

        .end    ExInterlockedRemoveHeadList

        SBTTL("Interlocked Pop Entry List")
//++
//
// PSINGLE_LIST_ENTRY
// ExInterlockedPopEntryList (
//    IN PSINGLE_LIST_ENTRY ListHead,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function removes an entry from the head of a singly linked list
//    so that access to the list is synchronized in a multiprocessor system.
//    If there are no entries in the list, then a value of NULL is returned.
//    Otherwise, the address of the entry that is removed is returned as the
//    function value.
//
// Arguments:
//
//    ListHead (a0) - Supplies a pointer to the head of the singly linked
//       list from which an entry is to be removed.
//
//    Lock (a1) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the list.
//
// Return Value:
//
//    The address of the entry removed from the list, or NULL if the list is
//    empty.
//
//--

        LEAF_ENTRY(ExInterlockedPopEntryList)

10:     DISABLE_INTERRUPTS              // (PALcode) v0 is clobbered

#if !defined(NT_UP)

        LDP_L   t0, 0(a1)               // get current lock value - locked
        bne     t0, 30f                 // if ne, spin lock still owned
        mov     a1, t0                  // set ownership value (lock address)
        STP_C   t0, 0(a1)               // set spin lock owned - conditionally
        beq     t0, 30f                 // if eq, conditional store failed
        mb                              // synchronize memory access

#endif

//
// Set the return value in t0 for now since PALcode may use v0.
//

        LDP     t0, 0(a0)               // get address of next entry (return value also)
        beq     t0, 20f                 // if eq [NULL], list is empty
        LDP     t1, 0(t0)               // get address of next entry
        STP     t1, 0(a0)               // store address of next in head
20:                                     //

#if !defined(NT_UP)

        mb                              // synchronize memory access
        STP     zero, 0(a1)             // set spin lock not owned

#endif

        ENABLE_INTERRUPTS               // (PALcode) v0 is clobbered

        mov     t0, v0                  // set return value
        ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

#if !defined(NT_UP)

30:     ENABLE_INTERRUPTS               // (PALcode) v0 is clobbered

32:     LDP     t0, 0(a1)               // read current lock value
        beq     t0, 10b                 // try spinlock again if available
        br      zero, 32b               // spin in cache until available

#endif

        .end    ExInterlockedPopEntryList

        SBTTL("Interlocked Push Entry List")
//++
//
// PSINGLE_LIST_ENTRY
// ExInterlockedPushEntryList (
//    IN PSINGLE_LIST_ENTRY ListHead,
//    IN PSINGLE_LIST_ENTRY ListEntry,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function inserts an entry at the head of a singly linked list
//    so that access to the list is synchronized in a multiprocessor system.
//
// Arguments:
//
//    ListHead (a0) - Supplies a pointer to the head of the singly linked
//       list into which an entry is to be inserted.
//
//    ListEntry (a1) - Supplies a pointer to the entry to be inserted at the
//       head of the list.
//
//    Lock (a2) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the list.
//
// Return Value:
//
//    Previous contents of ListHead.  NULL implies list went from empty
//       to not empty.
//
//--

        LEAF_ENTRY(ExInterlockedPushEntryList)

10:     DISABLE_INTERRUPTS              // (PALcode) v0 is clobbered

#if !defined(NT_UP)

        LDP_L   t0, 0(a2)               // get current lock value - locked
        bne     t0, 20f                 // if ne, spin lock still owned
        mov     a2, t0                  // set ownership value (lock address)
        STP_C   t0, 0(a2)               // set spin lock owned - conditionally
        beq     t0, 20f                 // if eq, conditional store failed
        mb                              // synchronize memory access

#endif

//
// Set the return value in t0 for now since PALcode may use v0.
//

        LDP     t0, 0(a0)               // get address of first entry (return value also)
        STP     t0, 0(a1)               // set address of next in new entry
        STP     a1, 0(a0)               // set address of first entry

#if !defined(NT_UP)

        mb                              // synchronize memory access
        STP     zero, 0(a2)             // set spin lock not owned

#endif

        ENABLE_INTERRUPTS               // (PALcode) v0 is clobbered

        mov     t0, v0                  // set return value
        ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

#if !defined(NT_UP)

20:     ENABLE_INTERRUPTS               // (PALcode) v0 is clobbered

22:     LDP     t0, 0(a2)               // read current lock value
        beq     t0, 10b                 // try spinlock again if available
        br      zero, 22b               // spin in cache until available

#endif
        .end    ExInterlockedPushEntryList

        SBTTL("Interlocked Compare Exchange")
//++
//
// PVOID
// InterlockedCompareExchange (
//    IN OUT PVOID *Destination,
//    IN PVOID Exchange,
//    IN PVOID Comperand
//    )
//
// Routine Description:
//
//    This function performs an interlocked compare of the destination
//    value with the comperand value. If the destination value is equal
//    to the comperand value, then the exchange value is stored in the
//    destination. Otherwise, no opeation is performed.
//
// Arguments:
//
//    Destination (a0) - Supplies a pointer to the destination value.
//
//    Exchange (a1) - Supplies the exchange.
//
//    Comperand (a2) - Supplies the comperand value.
//
// Return Value:
//
//    The initial destination value is returned as the function value.
//
//--

        LEAF_ENTRY(InterlockedCompareExchange)

10:                                     //

#if !defined(NT_UP)

        mb                              // synchronize memory access

#endif

        ldl_l   v0, 0(a0)               // get current value
        bis     a1, zero, t0            // copy exchange value for store
        cmpeq   v0, a2, t1              // check if operands match
        beq     t1, 20f                 // if eq, operands mismatch
        stl_c   t0, 0(a0)               // store updated addend value
        beq     t0,25f                  // if eq, store conditional failed

#if !defined(NT_UP)

        mb                              // synchronize memory access

#endif

20:     ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

25:     br      zero, 10b               // go try spin lock again

        .end    InterlockedCompareExchange

        SBTTL("Interlocked Exchange Add")
//++
//
// LONG
// ExInterlockedAdd (
//    IN PLONG Addend,
//    IN ULONG Increment
//    )
//
// Routine Description:
//
//    This function performs an interlocked add of an increment value to an
//    addend variable of type unsigned long. The initial value of the addend
//    variable is returned as the function value.
//
// Arguments:
//
//    Addend (a0) - Supplies a pointer to a variable whose value is to be
//       adjusted by the increment value.
//
//    Increment (a1) - Supplies the increment value to be added to the
//       addend variable.
//
// Return Value:
//
//    The initial value of the addend variable.
//
//--

        LEAF_ENTRY(InterlockedExchangeAdd)

10:                                     //

#if !defined(NT_UP)

        mb                              // synchronize memory access

#endif

        ldl_l   v0, 0(a0)               // get current addend value - locked
        addl    v0, a1, t0              // increment addend value
        stl_c   t0, 0(a0)               // store updated value - conditionally
        beq     t0, 20f                 // if eq, conditonal store failed

#if !defined(NT_UP)

        mb                              // synchronize memory access

#endif

        ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

20:     br      zero, 10b               // go try spin lock again

        .end    InterlockedExchangeAdd

        SBTTL("Interlocked Pop Entry Sequenced List")
//++
//
// PSINGLE_LIST_ENTRY
// ExpInterlockedPopEntrySList (
//    IN PSLIST_HEADER ListHead
//    )
//
// Routine Description:
//
//    This function removes an entry from the front of a sequenced singly
//    linked list so that access to the list is synchronized in a MP system.
//    If there are no entries in the list, then a value of NULL is returned.
//    Otherwise, the address of the entry that is removed is returned as the
//    function value.
//
// Arguments:
//
//    ListHead (a0) - Supplies a pointer to the sequenced listhead from which
//       an entry is to be removed.
//
// Return Value:
//
//    The address of the entry removed from the list, or NULL if the list is
//    empty.
//
//--

        LEAF_ENTRY(ExpInterlockedPopEntrySList)

//
// N.B. The following code is the continuation address should a fault
//      occur in the rare case described below.
//

        ALTERNATE_ENTRY(ExpInterlockedPopEntrySListResume)

10:     ldq     t0, 0(a0)               // get next entry address and sequence

#if defined(_AXP64_)

        sra     t0, 63 - 42, v0         // extract next entry address
        bic     v0, 7, v0               //
        beq     v0, 30f                 // if eq, list is empty
        bis     t0, zero, t1            // copy depth and sequence

#else

        addl    t0, zero, v0            // sign extend next entry address
        beq     v0, 30f                 // if eq, list is empty
        srl     t0, 32, t1              // shift sequence to low 32-bits

#endif

#if !defined(NT_UP)

        mb                              // synchronize memory access

#endif

//
// N.B. It is possible for the following instruction to fault in the rare
//      case where the first entry in the list is allocated on another
//      processor and freed between the time the free pointer is read above
//      and the following instruction. When this happens, the access fault
//      code continues execution above at the resumption address and the
//      entire operation is retried.
//

        ALTERNATE_ENTRY(ExpInterlockedPopEntrySListFault)

        LDP     t5, 0(v0)               // get address of successor entry

#if defined(_AXP64_)

        sll     t5, 63 - 42, t2         // shift address into position

#else

        zapnot  t5, 0xf ,t2             // clear high 32-bits for merge

#endif

        ldq_l   t3, 0(a0)               // reload next entry address and sequence
        ldil    t5, 0xffff              // decrement list depth and
        addl    t1, t5, t1              // increment sequence number

#if defined(_AXP64_)

        zapnot  t1, 0x7, t1             // clear upper five bytes

#else

        sll     t1, 32, t1              // shift depth and sequence into position

#endif

        cmpeq   t0, t3, t4              // check if listhead has changed
        beq     t4, 15f                 // if eq, listhead changed
        bis     t1, t2, t1              // merge address, depth, and sequence
        stq_c   t1, 0(a0)               // store next entry address and sequence
        beq     t1, 15f                 // if eq, store conditional failed

#if !defined(NT_UP)

        mb                              // synchronize memory access

#endif

30:     ret     zero, (ra)              //

//
// Conditional store attempt failed or listhead changed.
//

15:     br      zero, 10b               // retry

        .end    ExpInterlockedPopEntrySList

        SBTTL("Interlocked Push Entry Sequenced List")
//++
//
// PSINGLE_LIST_ENTRY
// ExpInterlockedPushEntrySList (
//    IN PSLIST_HEADER ListHead,
//    IN PSINGLE_LIST_ENTRY ListEntry
//    )
//
// Routine Description:
//
//    This function inserts an entry at the head of a sequenced singly linked
//    list so that access to the list is synchronized in an MP system.
//
// Arguments:
//
//    ListHead (a0) - Supplies a pointer to the sequenced listhead into which
//       an entry is to be inserted.
//
//    ListEntry (a1) - Supplies a pointer to the entry to be inserted at the
//       head of the list.
//
// Return Value:
//
//    Previous contents of ListHead.  NULL implies list went from empty
//       to not empty.
//
//--

        LEAF_ENTRY(ExpInterlockedPushEntrySList)

10:     ldq     t0, 0(a0)               // get next entry address and sequence

#if defined(_AXP64_)

        sra     t0, 63 - 42, v0         // extract next entry address
        bic     v0, 7, v0               //
        bis     t0, zero, t1            // copy depth and sequence number

#else

        addl    t0, zero, v0            // sign extend next entry address
        srl     t0, 32, t1              // shift sequence to low 32-bits

#endif

        STP     v0, 0(a1)               // set next link in new first entry

#if !defined(NT_UP)

        mb                              // synchronize memory access

#endif

#if defined(_AXP64_)

        sll     a1, 63 - 42, t2         // shift address into position

#else

        zapnot  a1, 0xf, t2             // zero extend new first entry

#endif

        ldq_l   t3, 0(a0)               // reload next entry address and sequence
        ldah    t5, 1(zero)             // get sequence adjustment value
        addl    t1, 1, t1               // increment list depth
        addl    t1, t5, t1              // increment sequence number

#if defined(_AXP64_)

        zapnot  t1, 0x7, t1             // clear upper five bytes

#else

        sll     t1, 32, t1              // merge new first entry address and sequence

#endif

        cmpeq   t0, t3, t4              // check if listhead changed
        beq     t4, 15f                 // if eq, listhead changed
        bis     t1, t2, t2              // merge address, depth, and sequence
        stq_c   t2, 0(a0)               // store next entry address and sequence
        beq     t2, 15f                 // if eq, store conditional failed
        ret     zero, (ra)              // return

//
// Conditional store attempt failed or listhead changed.
//

15:     br      zero, 10b               // retry

        .end    ExpInterlockedPushEntrySList

        SBTTL("Interlocked Flush Sequenced List")
//++
//
// PSINGLE_LIST_ENTRY
// ExpInterlockedFlushSList (
//    IN PSLIST_HEADER ListHead
//    )
//
// Routine Description:
//
//    This function flushes the entire list of entries on a sequenced singly
//    linked list so that access to the list is synchronized in a MP system.
//    If there are no entries in the list, then a value of NULL is returned.
//    Otherwise, the address of the 1st entry on the list is returned as the
//    function value.
//
// Arguments:
//
//    ListHead (a0) - Supplies a pointer to the sequenced listhead from which
//       an entry is to be removed.
//
// Return Value:
//
//    The address of the entry removed from the list, or NULL if the list is
//    empty.
//
//--

        LEAF_ENTRY(ExpInterlockedFlushSList)

        and     t1, zero, t1            // set new listhead value
10:     ldq_l   t0, 0(a0)               // get next entry address and sequence
        stq_c	t1, 0(a0)               // store new listhead value
        beq     t1, 15f                 // if eq, store conditional failed

#if defined(_AXP64_)

        sra     t0, 63 - 42, v0         // extract next entry address
        bic     v0, 7, v0               //

#else

        addl    t0, zero, v0            // sign extend next entry address

#endif

        ret     zero, (ra)              // return

//
// Conditional store attempt failed or listhead changed.
//

15:     br      zero, 10b               // retry, store conditional failed

        .end    ExpInterlockedFlushSList

        SBTTL("Interlocked Compare Exchange 64-bits")
//++
//
// LONGLONG
// ExpInterlockedCompareExchange64 (
//    IN PLONGLONG Destination,
//    IN PLONGLONG Exchange,
//    IN PLONGLONG Comperand
//    )
//
// Routine Description:
//
//    This function performs an interlocked compare and exchange of 64-bits.
//
// Arguments:
//
//    Destination (a0) - Supplies a pointer to the destination variable.
//
//    Exchange (a1) - Supplies a pointer to the exchange value.
//
//    Comperand (a2) - Supplies a pointer to the comperand value.
//
// Return Value:
//
//    The current destination value are returned as the function value.
//
//--

        LEAF_ENTRY(ExpInterlockedCompareExchange64)

        ldq     t0, 0(a1)               // get exchange value
        ldq     t1, 0(a2)               // get comperand value
10:     ldq_l   v0, 0(a0)               // get current destination value
        bis     t0, zero, t2            // set exchange value
        cmpeq   v0, t1, t3              // check if current and comperand match
        beq     t3, 20f                 // if eq, current and comperand mismatch
        stq_c   t2, 0(a0)               // store exchange value
        beq     t2, 30f                 // if eq, store conditional failed
20:     ret     zero, (ra)

//
// Conditional store attempt failed.
//

30:     br      zero, 10b               // retry

        .end    ExpInterlockedCompareExchange64

        SBTTL("Interlocked Compare Exchange 64-bits")
//++
//
// LONGLONG
// InterlockedCompareExchange64 (
//    IN PLONGLONG Destination,
//    IN LONGLONG Exchange,
//    IN LONGLONG Comperand
//    )
//
// Routine Description:
//
//    This function performs an interlocked compare and exchange of 64-bits.
//
// Arguments:
//
//    Destination (a0) - Supplies a pointer to the destination variable.
//
//    Exchange (a1) - Supplies the exchange value.
//
//    Comperand (a2) - Supplies the comperand value.
//
// Return Value:
//
//    The current destination value are returned as the function value.
//
//--

#if !defined(_AXP64_)

        LEAF_ENTRY(InterlockedCompareExchange64)

10:     ldq_l   v0, 0(a0)               // get current destination value
        bis     a1, zero, t2            // set exchange value
        cmpeq   v0, a2, t3              // check if current and comperand match
        beq     t3, 20f                 // if eq, current and comperand mismatch
        stq_c   t2, 0(a0)               // store exchange value
        beq     t2, 10b                 // if eq, store conditional failed
20:     ret     zero, (ra)

        .end    InterlockedCompareExchange64

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\alpha\splocks.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

   splocks.c

Abstract:

   All global spinlocks in the kernel image are declared in this
   module.  This is done so that each spinlock can be spaced out
   sufficiently to guaarantee that the L2 cache does not thrash
   by having a spinlock and another high use varible in the same
   cache line.


Author:

    Ken Reneris (kenr) 13-Jan-1992

Revision History:

--*/

#include "exp.h"

//
// Static SpinLocks from ntos\cc\cachedat.c
//

KSPIN_LOCK  CcDeferredWriteSpinLock = 0;
KSPIN_LOCK  CcDebugTraceLock = 0;

//
// Static SpinLocks from ntos\ex
//

KSPIN_LOCK  PoolTraceLock = 0;                  // pool.c

//
// Static SpinLocks from ntos\io\iodata.c
//

KSPIN_LOCK  IopErrorLogLock = 0;
KSPIN_LOCK  IopTimerLock = 0;

//
// Static SpinLocks from ntos\kd\kdlock.c
//

KSPIN_LOCK  KdpDebuggerLock = 0;

//
// Static SpinLocks from ntos\ke\kernldat.c
//

KSPIN_LOCK  KiFreezeExecutionLock = 0;
KSPIN_LOCK  KiFreezeLockBackup = 0;
ULONG_PTR    KiHardwareTrigger = 0;
KSPIN_LOCK  KiPowerNotifyLock = 0;
KSPIN_LOCK  KiProfileLock = 0;

//
// Static SpinLocks from ntos\mm\miglobal.c
//

KSPIN_LOCK  MmSystemSpaceLock = 0;
KSPIN_LOCK  MmAllowWSExpansionLock = 0;

//
// Static SpinLocks from ntos\ps\psinit.c
//

KSPIN_LOCK  PspEventPairLock = 0;
KSPIN_LOCK  PsLoadedModuleSpinLock = 0;

//
// Static SpinLocks from ntos\fsrtl\fsrtlp.c
//

KSPIN_LOCK  FsRtlStrucSupSpinLock = 0;          // fsrtlp.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\alpha\raisests.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    raisests.c

Abstract:

    This module implements routines to raise a general exception from kernel
    mode or a noncontinuable exception from kernel mode.

Author:

    David N. Cutler (davec) 18-Oct-1990

Environment:

    Any mode.

Revision History:

    Thomas Van Baak (tvb) 5-May-1992

        Adapted for Alpha AXP.

--*/

#include "exp.h"

//
// Define private function prototypes.
//

VOID
ExpRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord
    );

VOID
ExpRaiseStatus (
    IN NTSTATUS ExceptionCode
    );

VOID
ExRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord
    )

/*++

Routine Description:

    This function raises a software exception by building a context record
    and calling the exception dispatcher directly.

    N.B. This routine is a shell routine that simply calls another routine
         to do the real work. The reason this is done is to avoid a problem
         in try/finally scopes where the last statement in the scope is a
         call to raise an exception.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

Return Value:

    None.

--*/

{

#ifdef DBGtvb
    DbgPrint("ExRaiseException(ExceptionRecord = %lx) Status = %lx\n",
             ExceptionRecord, ExceptionRecord->ExceptionCode);
);
#endif
    ExpRaiseException(ExceptionRecord);
    return;
}

VOID
ExpRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord
    )

/*++

Routine Description:

    This function raises a software exception by building a context record
    and calling the exception dispatcher directly.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

Return Value:

    None.

--*/

{

    ULONG_PTR ControlPc;
    CONTEXT ContextRecord;
    FRAME_POINTERS EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    BOOLEAN InFunction;
    ULONG_PTR NextPc;
    NTSTATUS Status;

    //
    // Capture the current context, virtually unwind to the caller of this
    // routine, set the fault instruction address to that of the caller, and
    // call the exception dispatcher.
    //

    RtlCaptureContext(&ContextRecord);
    ControlPc = (ULONG_PTR)ContextRecord.IntRa - 4;
    FunctionEntry = RtlLookupFunctionEntry(ControlPc);
    NextPc = RtlVirtualUnwind(ControlPc,
                              FunctionEntry,
                              &ContextRecord,
                              &InFunction,
                              &EstablisherFrame,
                              NULL);

    ContextRecord.Fir = (ULONGLONG)(LONG_PTR)NextPc + 4;
    ExceptionRecord->ExceptionAddress = (PVOID)ContextRecord.Fir;

    //
    // If the exception is successfully dispatched, then continue execution.
    // Otherwise, give the kernel debugger a chance to handle the exception.
    //

    if (RtlDispatchException(ExceptionRecord, &ContextRecord)) {
        Status = ZwContinue(&ContextRecord, FALSE);

    } else {
        Status = ZwRaiseException(ExceptionRecord, &ContextRecord, FALSE);
    }

    //
    // Either the attempt to continue execution or the attempt to give
    // the kernel debugger a chance to handle the exception failed. Raise
    // a noncontinuable exception.
    //

    ExRaiseStatus(Status);
}

VOID
ExRaiseStatus (
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This function raises an exception with the specified status value by
    building an exception record, building a context record, and calling the
    exception dispatcher directly. The exception is marked as noncontinuable
    with no parameters. There is no return from this function.

    N.B. This routine is a shell routine that simply calls another routine
         to do the real work. The reason this is done is to avoid a problem
         in try/finally scopes where the last statement in the scope is a
         call to raise an exception.

Arguments:

    ExceptionCode - Supplies the status value to be used as the exception
        code for the exception that is to be raised.

Return Value:

    None.

--*/

{

#ifdef DBGxx
    DbgPrint("ExRaiseStatus(ExceptionCode = %lx)\n", ExceptionCode);
#endif
    ExpRaiseStatus(ExceptionCode);
    return;
}

VOID
ExpRaiseStatus (
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This function raises an exception with the specified status value by
    building an exception record, building a context record, and calling the
    exception dispatcher directly. The exception is marked as noncontinuable
    with no parameters. There is no return from this function.

Arguments:

    ExceptionCode - Supplies the status value to be used as the exception
        code for the exception that is to be raised.

Return Value:

    None.

--*/

{

    ULONG_PTR ControlPc;
    CONTEXT ContextRecord;
    FRAME_POINTERS EstablisherFrame;
    EXCEPTION_RECORD ExceptionRecord;
    PRUNTIME_FUNCTION FunctionEntry;
    BOOLEAN InFunction;
    ULONG_PTR NextPc;
    NTSTATUS Status;

    //
    // Construct an exception record.
    //

    ExceptionRecord.ExceptionCode = ExceptionCode;
    ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
    ExceptionRecord.NumberParameters = 0;
    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;

    //
    // Capture the current context, virtually unwind to the caller of this
    // routine, set the fault instruction address to that of the caller, and
    // call the exception dispatcher.
    //

    RtlCaptureContext(&ContextRecord);
    ControlPc = (ULONG_PTR)ContextRecord.IntRa - 4;
    FunctionEntry = RtlLookupFunctionEntry(ControlPc);
    NextPc = RtlVirtualUnwind(ControlPc,
                              FunctionEntry,
                              &ContextRecord,
                              &InFunction,
                              &EstablisherFrame,
                              NULL);

    ContextRecord.Fir = (ULONGLONG)(LONG_PTR)NextPc + 4;
    ExceptionRecord.ExceptionAddress = (PVOID)ContextRecord.Fir;
    RtlDispatchException(&ExceptionRecord, &ContextRecord);

    //
    // An unwind was not initiated during the dispatching of a noncontinuable
    // exception. Give the kernel debugger a chance to handle the exception.
    //

    Status = ZwRaiseException(&ExceptionRecord, &ContextRecord, FALSE);

    //
    // The attempt to give the kernel debugger a chance to handle the exception
    // failed. Raise another noncontinuable exception.
    //

    ExRaiseStatus(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\amd64\fmutex.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fmutex.c

Abstract:

    This module implements the code necessary to acquire and release fast
    mutexes.

Author:

    David N. Cutler (davec) 23-Jun-2000

Environment:

    Any mode.

Revision History:

--*/

#include "exp.h"

VOID
ExAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function acquires ownership of a fast mutex and raises IRQL to
    APC Level.

Arguments:

    FastMutex  - Supplies a pointer to a fast mutex.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;

    //
    // Raise IRQL to APC_LEVEL and decrement the ownership count to determine
    // if the fast mutex is owned.
    //

    OldIrql = KfRaiseIrql(APC_LEVEL);
    if (InterlockedDecrement(&FastMutex->Count) != 0) {

        //
        // The fast mutex is owned - wait for ownership to be granted.
        //

        FastMutex->Contention += 1;
        KeWaitForSingleObject(&FastMutex->Event,
                              WrExecutive,
                              KernelMode,
                              FALSE,
                              NULL);

    }

    //
    // Grant ownership of the fast mutext to the current thread.
    //

    FastMutex->Owner = KeGetCurrentThread();
    FastMutex->OldIrql = OldIrql;
    return;
}

VOID
ExReleaseFastMutex (
    IN PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function releases ownership to a fast mutex and lowers IRQL to
    its previous level.

Arguments:

    FastMutex - Supplies a pointer to a fast mutex.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;

    //
    // Save the old IRQL, clear the owner thread, and increment the fast mutex
    // count to detemine is there are any threads waiting for ownership to be
    // granted.
    //

    OldIrql = (KIRQL)FastMutex->OldIrql;

    ASSERT(FastMutex->Owner == KeGetCurrentThread());

    ASSERT(KeGetCurrentIrql() == APC_LEVEL);

    FastMutex->Owner = NULL;
    if (InterlockedIncrement(&FastMutex->Count) <= 0) {

        //
        // There are one or more threads waiting for ownership of the fast
        // mutex.
        //

        KeSetEventBoostPriority(&FastMutex->Event, NULL);
    }

    //
    // Lower IRQL to its previous value.
    //

    KeLowerIrql(OldIrql);
    return;
}

BOOLEAN
ExTryToAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function attempts to acquire ownership of a fast mutex, and if
    successful, raises IRQL to APC level.

Arguments:

    FastMutex  - Supplies a pointer to a fast mutex.

Return Value:

    If the fast mutex was successfully acquired, then a value of TRUE
    is returned as the function value. Otherwise, a value of FALSE is
    returned.

--*/

{

    KIRQL OldIrql;

    //
    // Raise IRQL to APC_LEVEL and attempt to acquire ownership of the fast
    // mutex.
    //

    OldIrql = KfRaiseIrql(APC_LEVEL);
    if (InterlockedCompareExchange(&FastMutex->Count, 0, 1) != 1) {

        //
        // The fast mutex is owned - lower IRQL to its previous value
        // and return FALSE.
        //

        KeLowerIrql(OldIrql);
        return FALSE;

    } else {

        //
        // Grant ownership of the fast mutext to the current thread and
        // return TRUE.
        //

        FastMutex->Owner = KeGetCurrentThread();
        FastMutex->OldIrql = OldIrql;
        return TRUE;
    }
}

VOID
ExAcquireFastMutexUnsafe (
    IN PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function acquires ownership of a fast mutex, but does not raise
    IRQL to APC Level.

Arguments:

    FastMutex - Supplies a pointer to a fast mutex.

Return Value:

    None.

--*/

{

    //
    // Decrement the ownership count to determine if the fast mutex is owned.
    //

    if (InterlockedDecrement(&FastMutex->Count) != 0) {

        //
        // The fast mutex is owned - wait for ownership to be granted.
        //

        FastMutex->Contention += 1;
        KeWaitForSingleObject(&FastMutex->Event,
                              WrExecutive,
                              KernelMode,
                              FALSE,
                              NULL);

    }

    //
    // Grant ownership of the fast mutext to the current thread.
    //

    FastMutex->Owner = KeGetCurrentThread();
    return;
}

VOID
ExReleaseFastMutexUnsafe (
    IN PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function releases ownership to a fast mutex, and does not
    restore IRQL to its previous level.

Arguments:

    FastMutex - Supplies a pointer to a fast mutex.

Return Value:

    None.

--*/

{

    //
    // Clear the owner thread and increment the fast mutex count to detemine
    // is there are any threads waiting for ownership to be granted.
    //

    ASSERT(FastMutex->Owner == KeGetCurrentThread());

    FastMutex->Owner = NULL;
    if (InterlockedIncrement(&FastMutex->Count) <= 0) {

        //
        // There are one or more threads waiting for ownership of the fast
        // mutex.
        //

        KeSetEventBoostPriority(&FastMutex->Event, NULL);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\amd64\hifreqlk.asm ===
title "Global SpinLock declerations"
;++
;
;Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   hifreqlk.asm
;
; Abstract:
;
;   High frequency system spin locks are declared in this module. Each spin
;   lock is placed in its own cache line on MP systems.
;
; Author:
;
;   David N. Cutler (davec) 22-Jun-2000
;
;Revision History:
;
;--

include ksamd64.inc

ifdef NT_UP

ALIGN_VALUE equ 16

else

ALIGN_VALUE equ 128


endif

;
; Define spin lock generation macro.
;

SPINLOCK macro SpinLockName

        align   ALIGN_VALUE

        public  SpinLockName
SpinLockName:
        dq      0

        endm

;
; Define variable generation macro.
;

ULONG64 macro VariableName

        align   ALIGN_VALUE

        public  VariableName
VariableName:
        dq      0

        endm

_DATA$00 SEGMENT PAGE PUBLIC 'DATA'

;
; The Initial PCR must be the first allocation in the section so it will be
; page aligned.
;

        public  KiInitialPCR
KiInitialPCR:
        db      ProcessorControlRegisterLength dup (0) ;

;
; Static SpinLocks from ntos\cc
;

SPINLOCK CcMasterSpinLock
SPINLOCK CcWorkQueueSpinLock
SPINLOCK CcVacbSpinLock
SPINLOCK CcDeferredWriteSpinLock
SPINLOCK CcDebugTraceLock
SPINLOCK CcBcbSpinLock

;
; Static SpinLocks from ntos\ex
;

SPINLOCK NonPagedPoolLock
SPINLOCK ExpResourceSpinLock

;
; Static SpinLocks from ntos\io
;

SPINLOCK IopCompletionLock
SPINLOCK IopCancelSpinLock
SPINLOCK IopVpbSpinLock
SPINLOCK IopDatabaseLock
SPINLOCK IopErrorLogLock
SPINLOCK IopTimerLock
SPINLOCK IoStatisticsLock

;
; Static SpinLocks from ntos\kd
;

SPINLOCK KdpDebuggerLock

;
; Static SpinLocks from ntos\ke
;

SPINLOCK KiContextSwapLock
SPINLOCK KiDispatcherLock
SPINLOCK KiFreezeExecutionLock
SPINLOCK KiFreezeLockBackup
SPINLOCK KiProfileLock
ULONG64 KiHardwareTrigger

;
; Static SpinLocks from ntos\mm
;

SPINLOCK MmPfnLock
SPINLOCK MmSystemSpaceLock
SPINLOCK MmChargeCommitmentLock

;
; Static SpinLocks from ntos\ps
;

SPINLOCK PspEventPairLock
SPINLOCK PsLoadedModuleSpinLock

;
; Static SpinLocks from ntos\fsrtl
;

SPINLOCK FsRtlStrucSupSpinLock

;
; Static SpinLocks from base\fs\ntfs
;

SPINLOCK NtfsStructLock

;
; Static SpinLocks from net\sockets\winsock2\wsp
;

SPINLOCK AfdWorkQueueSpinLock

;
; These variables are referenced together and are defined in a single cache
; line to reduce sharing on MP systems.
;
; KiIdleSummary - This is the set of processors which are idle.  It is
;      used by the ready thread code to speed up the search for a thread
;      to preempt when a thread becomes runnable.
;

        align   ALIGN_VALUE

        public  KiIdleSummary
KiIdleSummary:
        dq      0

;
; KiReadySummary - This is the set of dispatcher ready queues that are not
;      empty.  A member is set in this set for each priority that has one or
;      more entries in its respective dispatcher ready queues.
;

        public  KiReadySummary
KiReadySummary:
        dq      0

;
; PoSleepingSummary - Set of processors which currently sleep (ie stop)
;      when idle.
;

        public  PoSleepingSummary
PoSleepingSummary:
        dq      0

;
; KiTbFlushTimeStamp - This is the TB flush entire time stamp counter.
;
; This variable is in it own cache line to reduce false sharing on MP systems.
;

        align   ALIGN_VALUE

        public  KiTbFlushTimeStamp
KiTbFlushTimeStamp:
        dd      0

;
; These variables are referenced together and are defined in a single cache
; line to reduce sharing on MP systems.
;
; IopLookasideIrpFloat - This is the number of IRPs that are currently
;      in progress that were allocated from a lookaside list.
;

        align   ALIGN_VALUE

        public  IopLookasideIrpFloat
IopLookasideIrpFloat:
        dd      0

;
; IopLookasideIrpLimit - This is the maximum number of IRPs that can be
;      in progress that were allocated from a lookaside list.
;

        public  IopLookasideIrpLimit
IopLookasideIrpLimit:
        dd      0

;
; These variables are referenced together and are defined in a single cache
; line to reduce sharing on MP systems.
;
; KeTickCount - This is the number of clock ticks that have occurred since
;      the system was booted. This count is used to compute a millisecond
;      tick counter.
;

        align   ALIGN_VALUE

        public  KeTickCount
KeTickCount:
        dq      0

;
; KeMaximumIncrement - This is the maximum time between clock interrupts
;      in 100ns units that is supported by the host HAL.
;

        public  KeMaximumIncrement
KeMaximumIncrement:
        dd      0

;
; KeTimeAdjustment - This is the actual number of 100ns units that are to
;      be added to the system time at each interval timer interupt. This
;      value is copied from KeTimeIncrement at system start up and can be
;      later modified via the set system information service.
;      timer table entries.
;

        public  KeTimeAdjustment
KeTimeAdjustment:
        dd      0

;
; KiTickOffset - This is the number of 100ns units remaining before a tick
;      is added to the tick count and the system time is updated.
;

        public  KiTickOffset
KiTickOffset:
        dd      0

;
; These variables are referenced together and are defined in a single cache
; line to reduce sharing on MP systems.
;
; KiMaximumDpcQueueDepth - This is used to control how many DPCs can be
;      queued before a DPC of medium importance will trigger a dispatch
;      interrupt.
;

        align   ALIGN_VALUE

        public  KiMaximumDpcQueueDepth
KiMaximumDpcQueueDepth:
        dd      4

;
; KiMinimumDpcRate - This is the rate of DPC requests per clock tick that
;      must be exceeded before DPC batching of medium importance DPCs
;      will occur.
;

        public  KiMinimumDpcRate
KiMinimumDpcRate:
        dd      3

;
; KiAdjustDpcThreshold - This is the threshold used by the clock interrupt
;      routine to control the rate at which the processor's DPC queue depth
;      is dynamically adjusted.
;

        public  KiAdjustDpcThreshold
KiAdjustDpcThreshold:
        dd      20

;
; KiIdealDpcRate - This is used to control the aggressiveness of the DPC
;      rate adjusting algorithm when decrementing the queue depth. As long
;      as the DPC rate for the last tick is greater than this rate, the
;      DPC queue depth will not be decremented.
;

        public  KiIdealDpcRate
KiIdealDpcRate:
        dd      20

;
; MmPaeMask - This is the value used to mask upper bits of a PAE PTE.
;
; This variable is in it own cache line to reduce false sharing on MP systems.
;

        align   ALIGN_VALUE

         public  MmPaeMask
MmPaeMask:
        dq      0

;
; MmPfnDereferenceSListHead - This is used to store free blocks used for
;      deferred PFN reference count releasing.
;
; This variable is in it own cache line to reduce false sharing on MP systems.
;

        align   ALIGN_VALUE

        public  MmPfnDereferenceSListHead
MmPfnDereferenceSListHead:
        dq      0
        dq      0

;
; MmPfnDeferredList - This is used to queue items that need reference count
;      decrement processing.
;
; This variable is in it own cache line to reduce false sharing on MP systems.
;

        align   ALIGN_VALUE

        public  MmPfnDeferredList
MmPfnDeferredList:
        dq      0

;
; MmSystemLockPagesCount - This is the count of the number of locked pages
;       in the system.
;

        align   ALIGN_VALUE

        public  MmSystemLockPagesCount
MmSystemLockPagesCount:
        dq      0

        align   ALIGN_VALUE

_DATA$00 ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\amd64\intrlock.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   intrlock.asm
;
; Abstract:
;
;   This module implements functions to support interlocked operations.
;
; Author:
;
;   David N. Cutler (davec) 23-Jun-2000
;
; Environment:
;
;    Any mode.
;
;--

include ksamd64.inc

        subttl  "ExInterlockedAddLargeInteger"
;++
;
; LARGE_INTEGER
; ExInterlockedAddLargeInteger (
;     IN PLARGE_INTEGER Addend,
;     IN LARGE_INTEGER Increment,
;     IN PKSPIN_LOCK Lock
;     )
;
; Routine Description:
;
;   This function performs an interlocked add of an increment value to an
;   addend variable of type unsigned large integer. The initial value of
;   the addend variable is returned as the function value.
;
;   N.B. The specification of this function requires that the given lock
;        must be used to synchronize the update even though on AMD64 the
;        operation can actually be done atomically without using the lock.
;
; Arguments:
;
;   Addend (rcx) - Supplies a pointer to a variable whose value is to be
;       adjusted by the increment value.
;
;   Increment (rdx) - Supplies the increment value to be added to the
;       addend variable.
;
;   Lock (r8) - Supplies a pointer to a spin lock to be used to synchronize
;       access to the addend variable.
;
; Return Value:
;
;   The initial value of the addend variable is returned.
;
;--

        LEAF_ENTRY ExInterlockedAddLargeInteger, _TEXT$00

        cli                             ; disable interrupts
        AcquireSpinLock r8              ; acquire spin lock
        mov     rax, [rcx]              ; get initial addend value
        add     [rcx], rdx              ; compute sum of addend and increment
        ReleaseSpinLock r8              ; release spin lock
        sti                             ; enable interrupts
        ret                             ; return

        LEAF_END ExInterlockedAddLargeInteger, _TEXT$00

        subttl  "Interlocked Add Unsigned Long"
;++
;
; ULONG
; ExInterlockedAddUlong (
;     IN PULONG Addend,
;     IN ULONG Increment,
;     IN PKSPIN_LOCK Lock
;     )
;
; Routine Description:
;
;   This function performs an interlocked add of an increment value to an
;   addend variable of type unsinged long. The initial value of the addend
;   variable is returned as the function value.
;
;   N.B. The specification of this function requires that the given lock
;        must be used to synchronize the update even though on AMD64 the
;        opearion can actually be done atomically without using the lock.
;
; Arguments:
;
;   Addend (rcx) - Supplies a pointer to a variable whose value is to be
;       adjusted by the increment value.
;
;   Increment (edx) - Supplies the increment value to be added to the
;       addend variable.
;
;   Lock (r8) - Supplies a pointer to a spin lock to be used to synchronize
;       access to the addend variable.
;
; Return Value:
;
;   The initial value of the addend variable.
;
;--

        LEAF_ENTRY ExInterlockedAddUlong, _TEXT$00

        cli                             ; disable interrupts
        AcquireSpinLock r8              ; acquire spin lock
        mov     eax, [rcx]              ; get initial addend value
        add     [rcx], edx              ; compute sum of addend and increment
        ReleaseSpinLock r8              ; release spin lock
        sti                             ; enable interrupts
        ret                             ; return

        LEAF_END ExInterlockedAddUlong, _TEXT$00

        subttl  "Interlocked Insert Head List"
;++
;
; PLIST_ENTRY
; ExInterlockedInsertHeadList (
;     IN PLIST_ENTRY ListHead,
;     IN PLIST_ENTRY ListEntry,
;     IN PKSPIN_LOCK Lock
;     )
;
; Routine Description:
;
;   This function inserts an entry at the head of a doubly linked list
;   so that access to the list is synchronized in a multiprocessor system.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the head of the doubly linked
;       list into which an entry is to be inserted.
;
;   ListEntry (rdx) - Supplies a pointer to the entry to be inserted at the
;       head of the list.
;
;   Lock (r8) - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;   Pointer to entry that was at the head of the list or NULL if the list
;   was empty.
;
;--

        LEAF_ENTRY ExInterlockedInsertHeadList, _TEXT$00

        cli                             ; disable interrupts
        AcquireSpinLock r8              ; acquire spin lock
        mov     rax, LsFlink[rcx]       ; get address of first entry
        mov     LsFlink[rdx], rax       ; set next link in entry
        mov     LsBlink[rdx], rcx       ; set back link in entry
        mov     LsFlink[rcx], rdx       ; set next link in head
        mov     LsBlink[rax], rdx       ; set back link in next
        ReleaseSpinLock r8              ; release spin lock
        sti                             ; enable interrupts
        xor     rcx, rax                ; check if list was empty
        jnz     short Ih10              ; if nz, list not empty
        xor     eax, eax                ; list was empty
Ih10:   ret                             ; return

        LEAF_END ExInterlockedInsertHeadList, _TEXT$00

        subttl  "Interlocked Insert Tail List"
;++
;
; PLIST_ENTRY
; ExInterlockedInsertTailList (
;     IN PLIST_ENTRY ListHead,
;     IN PLIST_ENTRY ListEntry,
;     IN PKSPIN_LOCK Lock
;     )
;
; Routine Description:
;
;   This function inserts an entry at the tail of a doubly linked list
;   so that access to the list is synchronized in a multiprocessor system.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the head of the doubly linked
;       list into which an entry is to be inserted.
;
;   ListEntry (rdx) - Supplies a pointer to the entry to be inserted at the
;       tail of the list.
;
;   Lock (r8) - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;   Pointer to entry that was at the tail of the list or NULL if the list
;   was empty.
;
;--

        LEAF_ENTRY ExInterlockedInsertTailList, _TEXT$00

        cli                             ; disable interrupts
        AcquireSpinLock r8              ; acquire spin lock
        mov     rax, LsBlink[rcx]       ; get address of last entry
        mov     LsFlink[rdx], rcx       ; set next link in entry
        mov     LsBlink[rdx], rax       ; set back link in entry
        mov     LsBlink[rcx], rdx       ; set back link in head
        mov     LsFlink[rax], rdx       ; set next link in last
        ReleaseSpinLock r8              ; release spin lock
        sti                             ; enable interrupts
        xor     rcx, rax                ; check if list was empty
        jnz     short It10              ; if nz, list not empty
        xor     eax, eax                ; list was empty
It10:   ret                             ; return

        LEAF_END ExInterlockedInsertTailList, _TEXT$00

        subttl  "Interlocked Remove Head List"
;++
;
; PLIST_ENTRY
; ExInterlockedRemoveHeadList (
;     IN PLIST_ENTRY ListHead,
;     IN PKSPIN_LOCK Lock
;     )
;
; Routine Description:
;
;   This function removes an entry from the head of a doubly linked list
;   so that access to the list is synchronized in a multiprocessor system.
;   If there are no entries in the list, then a value of NULL is returned.
;   Otherwise, the address of the entry that is removed is returned as the
;   function value.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the head of the doubly linked
;       list from which an entry is to be removed.
;
;   Lock (rdx) - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;   The address of the entry removed from the list, or NULL if the list is
;   empty.
;
;--

        LEAF_ENTRY ExInterlockedRemoveHeadList, _TEXT$00

        cli                             ; disable interrupt
        AcquireSpinLock rdx             ; acquire spin lock
        mov     rax, LsFlink[rcx]       ; get address of first entry
        cmp     rax, rcx                ; check if list is empty
        je      short Rh10              ; if e, list is empty
        mov     r8, LsFlink[rax]        ; get address of next entry
        mov     LsFlink[rcx], r8        ; set address of first entry
        mov     LsBlink[r8], rcx        ; set back in next entry
Rh10:   ReleaseSpinLock rdx             ; release spin lock
        sti                             ; enable interrupts
        xor     rcx, rax                ; check if list was empty
        jnz     short Rh20              ; if nz, list not empty
        xor     eax, eax                ; list was empty
Rh20:   ret                             ; return

        LEAF_END ExInterlockedRemoveHeadList, _TEXT$00

        subttl  "Interlocked Pop Entry List"
;++
;
; PSINGLE_LIST_ENTRY
; ExInterlockedPopEntryList (
;     IN PSINGLE_LIST_ENTRY ListHead,
;     IN PKSPIN_LOCK Lock
;     )
;
; Routine Description:
;
;   This function removes an entry from the front of a singly linked list
;   so that access to the list is synchronized in a multiprocessor system.
;   If there are no entries in the list, then a value of NULL is returned.
;   Otherwise, the address of the entry that is removed is returned as the
;   function value.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the head of the singly linked
;       list from which an entry is to be removed.
;
;   Lock (rdx) - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;   The address of the entry removed from the list, or NULL if the list is
;   empty.
;
;--

        LEAF_ENTRY ExInterlockedPopEntryList, _TEXT$00

        cli                             ; disable interrupts
        AcquireSpinLock rdx             ; acquire spin lock
        mov     rax, [rcx]              ; get address of first entry
        test    rax, rax                ; check if list is empty
        jz      short Pe10              ; if z, list is empty
        mov     r8, [rax]               ; get address of next entry
        mov     [rcx], r8               ; set address of first entry
Pe10:   ReleaseSpinLock rdx             ; release spin lock
        sti                             ; enable interrupts
        ret                             ; return

        LEAF_END ExInterlockedPopEntryList, _TEXT$00

        subttl  "Interlocked Push Entry List"
;++
;
; PSINGLE_LIST_ENTRY
; ExInterlockedPushEntryList (
;     IN PSINGLE_LIST_ENTRY ListHead,
;     IN PSINGLE_LIST_ENTRY ListEntry,
;     IN PKSPIN_LOCK Lock
;     )
;
; Routine Description:
;
;   This function inserts an entry at the head of a singly linked list
;   so that access to the list is synchronized in a multiprocessor system.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the head of the singly linked
;       list into which an entry is to be inserted.
;
;   ListEntry (rdx) - Supplies a pointer to the entry to be inserted at the
;       head of the list.
;
;   Lock (r8) - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;   Previous contents of ListHead. NULL implies list went from empty to not
;   empty.
;
;--

        LEAF_ENTRY ExInterlockedPushEntryList, _TEXT$00

        cli                             ; disable interrupts
        AcquireSpinLock r8              ; acquire spin lock
        mov     rax, [rcx]              ; get address of first entry
        mov     [rdx], rax              ; set address of next entry
        mov     [rcx], rdx              ; set address of first entry
        ReleaseSpinLock r8              ; release spin lock
        sti                             ; enable interrupts
        ret                             ;

        LEAF_END ExInterlockedPushEntryList, _TEXT$00

        subttl  "ExInterlockedAddLargeStatistic"
;++
;
; VOID
; ExInterlockedAddLargeStatistic (
;     IN PLARGE_INTEGER Addend,
;     IN ULONG Increment
;     )
;
; Routine Description:
;
;   This function performs an interlocked add of an increment value to an
;   addend variable of type unsigned large integer.
;
; Arguments:
;
;   Addend (rcx) - Supplies a pointer to the variable whose value is to be
;       adjusted by the increment value.
;
;   Increment (rdx) - Supplies the increment value that is added to the
;       addend variable.
;
; Return Value:
;
;    None.
;
;--

        LEAF_ENTRY ExInterlockedAddLargeStatistic, _TEXT$00

        or      edx, edx                ; zero upper bits

ifndef NT_UP

   lock add     [rcx], rdx              ; add increment

else

        add     [rcx], rdx              ; add increment

endif

        ret                             ; return

        LEAF_END ExInterlockedAddLargeStatistic, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\i386\intrlock.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    intrlock.asm
;
; Abstract:
;
;    This module implements functions to support interlocked operations.
;    Interlocked operations can only operate on nonpaged data.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Feb-1990
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;   bryanwi 1-aug-90    Clean up and fix stuff.
;   bryanwi 3-aug-90    Add ExInterlockedIncrementLlong,...
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
        .list


_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;   General Notes on Interlocked Procedures:
;
;       These procedures assume that neither their code, nor any of
;       the data they touch, will cause a page fault.
;
;       They use spinlocks to achieve MP atomicity, iff it's an MP machine.
;       (The spinlock macros generate zilch if NT_UP = 1, and
;        we if out some aux code here as well.)
;
;       They turn off interrupts so that they can be used for synchronization
;       between ISRs and driver code.  Flags are preserved so they can
;       be called in special code (Like IPC interrupt handlers) that
;       may have interrupts off.
;
;--


;;      align  512

        page ,132
        subttl  "ExInterlockedAddLargeInteger"
;++
;
; LARGE_INTEGER
; ExInterlockedAddLargeInteger (
;    IN PLARGE_INTEGER Addend,
;    IN LARGE_INTEGER Increment,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsigned large integer. The initial value of
;    the addend variable is returned as the function value.
;
; Arguments:
;
;    (TOS+4) = Addend - a pointer to the addend value
;    (TOS+8) = Increment - the increment value
;    (TOS+16) = Lock - a pointer to a pointer to a spin lock
;
; Return Value:
;
;    The initial value of the addend variable is stored in eax:edx
;
;--

EiulAddend      equ     [ebp + 8]
EiulIncrement   equ     [ebp + 12]
EiulLock        equ     [ebp + 20]
EiulRetval      equ     [ebp - 8]

cPublicProc _ExInterlockedAddLargeInteger, 4

        push    ebp
        mov     ebp,esp
        sub     esp, 8

ifndef NT_UP
        mov     eax,EiulLock            ; (eax) -> KSPIN_LOCK
endif

eiul10: pushfd
        cli                             ; disable interrupts
        ACQUIRE_SPINLOCK eax,<short eiul20>

        mov     eax,EiulAddend          ; (eax)-> addend variable
        mov     ecx,[eax]               ; (ecx)= low part of addend value
        mov     edx,[eax]+4             ; (edx)= high part of addend value
        mov     EiulRetVal,ecx               ; set low part of return value
        mov     EiulRetVal+4,edx             ; set high part of return value
        add     ecx,EiulIncrement       ; add low parts of large integer
        adc     edx,EiulIncrement+4     ; add high parts of large integer and carry
        mov     eax,EiulAddend          ; RELOAD (eax)-> addend variable
        mov     [eax],ecx               ; store low part of result
        mov     [eax]+4,edx             ; store high part of result

ifndef NT_UP
        mov     eax,EiulLock
        RELEASE_SPINLOCK   eax          ; NOTHING if NT_UP = 1
endif
        popfd                           ; restore flags including interrupts
        mov     eax, EiulRetval         ; calling convention
        mov     edx, EiulRetval+4       ; calling convention
        mov     esp, ebp
        pop     ebp
        stdRET    _ExInterlockedAddLargeInteger

ifndef NT_UP
eiul20: popfd
        SPIN_ON_SPINLOCK   eax, eiul10
endif

stdENDP _ExInterlockedAddLargeInteger

        page , 132
        subttl  "Interlocked Add Unsigned Long"
;++
;
; ULONG
; ExInterlockedAddUlong (
;    IN PULONG Addend,
;    IN ULONG Increment,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsinged long. The initial value of the addend
;    variable is returned as the function value.
;
;       It is NOT possible to mix ExInterlockedDecrementLong and
;       ExInterlockedIncrementong with ExInterlockedAddUlong.
;
;
; Arguments:
;
;    Addend - Supplies a pointer to a variable whose value is to be
;       adjusted by the increment value.
;
;    Increment - Supplies the increment value to be added to the
;       addend variable.
;
;    Lock - Supplies a pointer to a spin lock to be used to synchronize
;       access to the addend variable.
;
; Return Value:
;
;    The initial value of the addend variable.
;
;--

EialAddend      equ     [esp + 8]
EialIncrement   equ     [esp + 12]
EialLock        equ     [esp + 16]

; end of arguments

cPublicProc _ExInterlockedAddUlong  , 3
cPublicFpo 3, 1

ifdef NT_UP
;
; UP version of ExInterlockedAddUlong
;

        pushfd
        cli                             ; disable interrupts

        mov     ecx, EialAddend         ; (ecx)->initial addend value
        mov     edx, [ecx]              ; (edx)= initial addend value
        mov     eax, edx                ; (eax)= initial addend value
        add     edx, EialIncrement      ; (edx)=adjusted value
        mov     [ecx], edx              ; [ecx]=adjusted value

        popfd                           ; restore flags including ints
        stdRET    _ExInterlockedAddUlong                             ; cRetURN

else

;
; MP version of ExInterlockedAddUlong
;
        pushfd
        mov     edx,EialLock            ; (edx)-> KSPIN_LOCK
Eial10: cli                             ; disable interrupts
        ACQUIRE_SPINLOCK edx, <short Eial20>

        mov     ecx, EialAddend         ; (ecx)->initial addend value
        mov     eax, [ecx]              ; (eax)=initial addend value
        add     eax, EialIncrement      ; (eax)=adjusted value
        mov     [ecx], eax              ; [ecx]=adjusted value
        sub     eax, EialIncrement      ; (eax)=initial addend value

        RELEASE_SPINLOCK edx
        popfd
        stdRET    _ExInterlockedAddUlong                             ; cRetURN

Eial20: popfd
        pushfd
        SPIN_ON_SPINLOCK edx, <short Eial10>
endif

stdENDP _ExInterlockedAddUlong


        page , 132
        subttl  "Interlocked Insert Head List"
;++
;
; PLIST_ENTRY
; ExInterlockedInsertHeadList (
;    IN PLIST_ENTRY ListHead,
;    IN PLIST_ENTRY ListEntry,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function inserts an entry at the head of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;    ListHead - Supplies a pointer to the head of the doubly linked
;       list into which an entry is to be inserted.
;
;    ListEntry - Supplies a pointer to the entry to be inserted at the
;       head of the list.
;
;    Lock - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;    Pointer to entry that was at the head of the list or NULL if the list
;    was empty.
;
;--

EiihListHead    equ     [esp + 8]
EiihListEntry   equ     [esp + 12]
EiihLock        equ     [esp + 16]

; end arguments

cPublicProc _ExInterlockedInsertHeadList    , 3
cPublicFpo 3, 1

ifndef NT_UP
        mov     edx, EiihLock - 4       ; (edx)->KSPIN_LOCK
endif
Eiih10: pushfd
        cli
        ACQUIRE_SPINLOCK    edx,<short Eiih20>

        mov     eax, EiihListHead       ; (eax)->head of linked list
        mov     ecx, EiihListEntry      ; (ecx)->entry to be inserted
        mov     edx, LsFlink[eax]       ; (edx)->next entry in the list
        mov     [ecx]+LsFlink, edx      ; store next link in entry
        mov     [ecx]+LsBlink, eax      ; store previous link in entry
        mov     [eax]+LsFlink, ecx      ; store next link in head
        mov     [edx]+LsBlink, ecx      ; store previous link in next

ifndef NT_UP
        mov     ecx, EiihLock           ; (ecx)->KSPIN_LOCK
        RELEASE_SPINLOCK ecx
endif
cPublicFpo 3, 0
        popfd                           ; restore flags including interrupts

        xor     eax,edx                 ; return null if list was empty
        jz      short Eiih15
        mov     eax,edx                 ; otherwise return prev. entry at head
Eiih15:
        stdRET    _ExInterlockedInsertHeadList

ifndef NT_UP
align 4
Eiih20: popfd
        SPIN_ON_SPINLOCK edx, <short Eiih10>
endif

stdENDP _ExInterlockedInsertHeadList


        page , 132
        subttl  "Interlocked Insert Tail List"
;++
;
; PLIST_ENTRY
; ExInterlockedInsertTailList (
;    IN PLIST_ENTRY ListHead,
;    IN PLIST_ENTRY ListEntry,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function inserts an entry at the tail of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;    ListHead - Supplies a pointer to the head of the doubly linked
;       list into which an entry is to be inserted.
;
;    ListEntry - Supplies a pointer to the entry to be inserted at the
;       tail of the list.
;
;    Lock - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;    Pointer to entry that was at the tail of the list or NULL if the list
;    was empty.
;
;--

EiitListHead    equ     [esp + 8]
EiitListEntry   equ     [esp + 12]
EiitLock        equ     [esp + 16]

; end arguments

cPublicProc _ExInterlockedInsertTailList    , 3
cPublicFpo 3, 1


ifndef NT_UP
        mov     edx,EiitLock - 4        ; (edx)->KSPIN_LOCK
endif

Eiit10: pushfd
        cli                             ; disable interrupts
        ACQUIRE_SPINLOCK edx, <short Eiit20>

        mov     eax, EiihListHead       ; (eax)->head of linked list
        mov     ecx, EiihListEntry      ; (ecx)->entry to be inserted
        mov     edx, LsBlink[eax]       ; (edx)->previous entry in the list
        mov     [ecx]+LsFlink, eax      ; store next link in entry
        mov     [ecx]+LsBlink, edx      ; store previous link in entry
        mov     [eax]+LsBlink, ecx      ; store previous link in head
        mov     [edx]+LsFlink, ecx      ; store next link in next

ifndef NT_UP
        mov     ecx,EiitLock            ; (ecx)->KSPIN_LOCK
        RELEASE_SPINLOCK ecx
endif
cPublicFpo 3,0
        popfd                           ; restore flags including interrupts

        xor     eax,edx                 ; return null if list was empty
        jz      short Eiit15
        mov     eax,edx                 ; otherwise return prev. entry at tail
Eiit15:
        stdRET    _ExInterlockedInsertTailList

ifndef NT_UP
align 4
Eiit20: popfd
        SPIN_ON_SPINLOCK edx, <short Eiit10>
endif

stdENDP _ExInterlockedInsertTailList

        page , 132
        subttl  "Interlocked Remove Head List"
;++
;
; PLIST_ENTRY
; ExInterlockedRemoveHeadList (
;    IN PLIST_ENTRY ListHead,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function removes an entry from the head of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry that is removed is returned as the
;    function value.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;    ListHead - Supplies a pointer to the head of the doubly linked
;       list from which an entry is to be removed.
;
;    Lock - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;    The address of the entry removed from the list, or NULL if the list is
;    empty.
;
;--

EirhListHead    equ     [esp + 8]
EirhLock        equ     [esp + 12]

; end of arguments

cPublicProc _ExInterlockedRemoveHeadList    , 2
cPublicFpo 2, 1

ifndef NT_UP
        mov     edx, EirhLock - 4       ; (edx)-> KSPIN_LOCK
endif

Eirh10: pushfd
        cli

        ACQUIRE_SPINLOCK edx, <Eirh30>

        mov     edx, EirhListHead       ; (edx)-> head of list
        mov     eax, [edx]+LsFlink      ; (eax)-> next entry
        cmp     eax, edx                ; Is list empty?
        je      short Eirh20            ; if e, list is empty, go Eirh20
        mov     ecx, [eax]+LsFlink      ; (ecx)-> next entry(after deletion)
        mov     [edx]+LsFlink, ecx      ; store address of next in head
        mov     [ecx]+LsBlink, edx      ; store address of previous in next
if DBG
        mov     [eax]+LsFlink, 0baddd0ffh
        mov     [eax]+LsBlink, 0baddd0ffh
endif
ifndef NT_UP
        mov     edx, EirhLock           ; (edx)-> KSPIN_LOCK
        RELEASE_SPINLOCK  edx
endif
cPublicFpo 2, 0
        popfd                           ; restore flags including interrupts
        stdRET    _ExInterlockedRemoveHeadList                             ; cReturn entry

align 4
Eirh20:
ifndef NT_UP
        mov     edx, EirhLock           ; (edx)-> KSPIN_LOCK
        RELEASE_SPINLOCK edx
endif
        popfd
        xor     eax,eax                 ; (eax) = null for empty list
        stdRET    _ExInterlockedRemoveHeadList                             ; cReturn NULL

ifndef NT_UP
align 4
Eirh30: popfd
        SPIN_ON_SPINLOCK edx, Eirh10
endif

stdENDP _ExInterlockedRemoveHeadList

        page , 132
        subttl  "Interlocked Pop Entry List"
;++
;
; PSINGLE_LIST_ENTRY
; ExInterlockedPopEntryList (
;    IN PSINGLE_LIST_ENTRY ListHead,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function removes an entry from the front of a singly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry that is removed is returned as the
;    function value.
;
; Arguments:
;
;    ListHead - Supplies a pointer to the head of the singly linked
;       list from which an entry is to be removed.
;
;    Lock - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;    The address of the entry removed from the list, or NULL if the list is
;    empty.
;
;--

; end of arguments

cPublicProc _ExInterlockedPopEntryList      , 2
cPublicFpo 2,1

ifndef NT_UP
        mov     edx, [esp+8]            ; (edx)-> KSPIN_LOCK
endif

Eipe10: pushfd
        cli                             ; disable interrupts

        ACQUIRE_SPINLOCK edx, <short Eipe30>

        mov     ecx, [esp+8]            ; (ecx)-> head of list
        mov     eax, [ecx]              ; (eax)-> next entry
        or      eax, eax                ; Is it empty?
        je      short Eipe20            ; if e, empty list, go Eipe20
        mov     edx, [eax]              ; (edx)->next entry (after deletion)
        mov     [ecx], edx              ; store address of next in head
if DBG
        mov     [eax], 0baddd0ffh
endif

ifndef NT_UP
        mov     edx, [esp+12]           ; (edx)-> KSPIN_LOCK
endif

Eipe15: RELEASE_SPINLOCK edx

cPublicFpo 2,0
        popfd                           ; restore flags including interrupts
        stdRET    _ExInterlockedPopEntryList    ; cReturn (eax)->removed entry

Eipe20: xor     eax, eax                ; return NULL for empty list
        jmp     short Eipe15            ; continue in common exit

ifndef NT_UP
Eipe30: popfd
        SPIN_ON_SPINLOCK edx, Eipe10
endif

stdENDP _ExInterlockedPopEntryList

        page , 132
        subttl  "Interlocked Push Entry List"
;++
;
; PSINGLE_LIST_ENTRY
; ExInterlockedPushEntryList (
;    IN PSINGLE_LIST_ENTRY ListHead,
;    IN PSINGLE_LIST_ENTRY ListEntry,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function inserts an entry at the head of a singly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;
; Arguments:
;
;    ListHead - Supplies a pointer to the head of the singly linked
;       list into which an entry is to be inserted.
;
;    ListEntry - Supplies a pointer to the entry to be inserted at the
;       head of the list.
;
;    Lock - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;    Previous contents of ListHead.  NULL implies list went from empty
;       to not empty.
;
;--

; end of arguments

cPublicProc _ExInterlockedPushEntryList     , 3
cPublicFpo 3,1

ifndef NT_UP
        mov     edx, [esp+12]           ; (edx)->KSPIN_LOCK
endif

Eipl10: pushfd
        cli

        ACQUIRE_SPINLOCK edx, <short Eipl20>

        mov     edx, [esp+8]            ; (edx)-> Head of list
        mov     eax, [edx]              ; (eax)-> next entry (return value also)
        mov     ecx, [esp+12]           ; (ecx)-> Entry to be pushed
        mov     [ecx], eax              ; store address of next in new entry
        mov     [edx], ecx              ; set address of next in head

ifndef NT_UP
        mov     edx, [esp+16]           ; (edx)->KSPIN_LOCK
        RELEASE_SPINLOCK edx
endif
cPublicFpo 3,0
        popfd                           ; restore flags including interrupts
        stdRET    _ExInterlockedPushEntryList

ifndef NT_UP
align 4
Eipl20: popfd
        SPIN_ON_SPINLOCK edx, <short Eipl10>
endif

stdENDP _ExInterlockedPushEntryList

        page , 132
        subttl  "Interlocked Increment Long"
;++
;
;   INTERLOCKED_RESULT
;   ExInterlockedIncrementLong (
;       IN PLONG Addend,
;       IN PKSPIN_LOCK Lock
;       )
;
;   Routine Description:
;
;       This function atomically increments Addend, returning an ennumerated
;       type which indicates what interesting transitions in the value of
;       Addend occurred due the operation.
;
;       It is NOT possible to mix ExInterlockedDecrementLong and
;       ExInterlockedIncrementong with ExInterlockedAddUlong.
;
;
;   Arguments:
;
;       Addend (esp+4) - Pointer to variable to increment.
;
;       Lock (esp+8) - Spinlock used to implement atomicity.
;                      (not actually used on x86)
;
;   Return Value:
;
;       An ennumerated type:
;
;       ResultNegative if Addend is < 0 after increment.
;       ResultZero     if Addend is = 0 after increment.
;       ResultPositive if Addend is > 0 after increment.
;
;--

cPublicProc _ExInterlockedIncrementLong , 2
cPublicFpo 2, 0

        mov     eax, [esp+4]            ; (eax) -> addend
ifdef NT_UP
        add dword ptr [eax],1
else
        lock add dword ptr [eax],1
endif
        lahf                            ; (ah) = flags
        and     eax,EFLAG_SELECT        ; clear all but sign and zero flags
        stdRET    _ExInterlockedIncrementLong

stdENDP _ExInterlockedIncrementLong


        page , 132
        subttl  "Interlocked Decrement Long"
;++
;
;   INTERLOCKED_RESULT
;   ExInterlockedDecrementLong (
;       IN PLONG Addend,
;       IN PKSPIN_LOCK Lock
;       )
;
;   Routine Description:
;
;       This function atomically decrements Addend, returning an ennumerated
;       type which indicates what interesting transitions in the value of
;       Addend occurred due the operation.
;
;       It is NOT possible to mix ExInterlockedDecrementLong and
;       ExInterlockedIncrementong with ExInterlockedAddUlong.
;
;   Arguments:
;
;       Addend (esp+4) - Pointer to variable to decrement.
;
;       Lock (esp+8) - Spinlock used to implement atomicity.
;                      (not actually used on x86)
;
;   Return Value:
;
;       An ennumerated type:
;
;       ResultNegative if Addend is < 0 after decrement.
;       ResultZero     if Addend is = 0 after decrement.
;       ResultPositive if Addend is > 0 after decrement.
;
;--

cPublicProc _ExInterlockedDecrementLong , 2
cPublicFpo 2, 0

        mov     eax, [esp+4]            ; (eax) -> addend
ifdef NT_UP
        sub dword ptr [eax], 1
else
        lock sub dword ptr [eax], 1
endif
        lahf                            ; (ah) = flags
        and     eax, EFLAG_SELECT       ; clear all but sign and zero flags
        stdRET    _ExInterlockedDecrementLong

stdENDP _ExInterlockedDecrementLong

        page , 132
        subttl  "Interlocked Exchange Ulong"
;++
;
;   ULONG
;   ExInterlockedExchangeUlong (
;       IN PULONG Target,
;       IN ULONG Value,
;       IN PKSPIN_LOCK Lock
;       )
;
;   Routine Description:
;
;       This function atomically exchanges the Target and Value, returning
;       the prior contents of Target
;
;       This function does not necessarily synchronize with the Lock.
;
;   Arguments:
;
;       Target - Address of ULONG to exchange
;       Value  - New value of ULONG
;       Lock   - SpinLock used to implement atomicity.
;
;   Return Value:
;
;       The prior value of Source
;--

cPublicProc _ExInterlockedExchangeUlong, 3
cPublicFpo 3,0

ifndef NT_UP
        mov     edx, [esp+4]                ; (edx) = Target
        mov     eax, [esp+8]                ; (eax) = Value

        xchg    [edx], eax                  ; make the exchange
else
        mov     edx, [esp+4]                ; (edx) = Target
        mov     ecx, [esp+8]                ; (eax) = Value

        pushfd
        cli
        mov     eax, [edx]                  ; get current value
        mov     [edx], ecx                  ; store new value
        popfd
endif

        stdRET  _ExInterlockedExchangeUlong

stdENDP _ExInterlockedExchangeUlong

        page , 132
        subttl  "Interlocked i386 Increment Long"
;++
;
;   INTERLOCKED_RESULT
;   Exi386InterlockedIncrementLong (
;       IN PLONG Addend
;       )
;
;   Routine Description:
;
;       This function atomically increments Addend, returning an ennumerated
;       type which indicates what interesting transitions in the value of
;       Addend occurred due the operation.
;
;       See ExInterlockedIncrementLong.  This function is the i386
;       architectural specific version of ExInterlockedIncrementLong.
;       No source directly calls this function, instead
;       ExInterlockedIncrementLong is called and when built on x86 these
;       calls are macroed to the i386 optimized version.
;
;   Arguments:
;
;       Addend (esp+4) - Pointer to variable to increment.
;
;       Lock (esp+8) - Spinlock used to implement atomicity.
;                      (not actually used on x86)
;
;   Return Value:
;
;       An ennumerated type:
;
;       ResultNegative if Addend is < 0 after increment.
;       ResultZero     if Addend is = 0 after increment.
;       ResultPositive if Addend is > 0 after increment.
;
;--

cPublicProc _Exi386InterlockedIncrementLong , 1
cPublicFpo 1, 0

        mov     eax, [esp+4]            ; (eax) -> addend
ifdef NT_UP
        add dword ptr [eax],1
else
        lock add dword ptr [eax],1
endif
        lahf                            ; (ah) = flags
        and     eax,EFLAG_SELECT        ; clear all but sign and zero flags
        stdRET    _Exi386InterlockedIncrementLong

stdENDP _Exi386InterlockedIncrementLong


        page , 132
        subttl  "Interlocked i386 Decrement Long"
;++
;
;   INTERLOCKED_RESULT
;   ExInterlockedDecrementLong (
;       IN PLONG Addend,
;       IN PKSPIN_LOCK Lock
;       )
;
;   Routine Description:
;
;       This function atomically decrements Addend, returning an ennumerated
;       type which indicates what interesting transitions in the value of
;       Addend occurred due the operation.
;
;       See Exi386InterlockedDecrementLong.  This function is the i386
;       architectural specific version of ExInterlockedDecrementLong.
;       No source directly calls this function, instead
;       ExInterlockedDecrementLong is called and when built on x86 these
;       calls are macroed to the i386 optimized version.
;
;   Arguments:
;
;       Addend (esp+4) - Pointer to variable to decrement.
;
;       Lock (esp+8) - Spinlock used to implement atomicity.
;                      (not actually used on x86)
;
;   Return Value:
;
;       An ennumerated type:
;
;       ResultNegative if Addend is < 0 after decrement.
;       ResultZero     if Addend is = 0 after decrement.
;       ResultPositive if Addend is > 0 after decrement.
;
;--

cPublicProc _Exi386InterlockedDecrementLong , 1
cPublicFpo 1, 0

        mov     eax, [esp+4]            ; (eax) -> addend
ifdef NT_UP
        sub dword ptr [eax], 1
else
        lock sub dword ptr [eax], 1
endif
        lahf                            ; (ah) = flags
        and     eax, EFLAG_SELECT       ; clear all but sign and zero flags
        stdRET    _Exi386InterlockedDecrementLong

stdENDP _Exi386InterlockedDecrementLong

        page , 132
        subttl  "Interlocked i386 Exchange Ulong"

;++
;
;   ULONG
;   Exi386InterlockedExchangeUlong (
;       IN PULONG Target,
;       IN ULONG Value,
;       IN PKSPIN_LOCK Lock
;       )
;
;   Routine Description:
;
;       This function atomically exchanges the Target and Value, returning
;       the prior contents of Target
;
;       See Exi386InterlockedExchangeUlong.  This function is the i386
;       architectural specific version of ExInterlockedDecrementLong.
;       No source directly calls this function, instead
;       ExInterlockedDecrementLong is called and when built on x86 these
;       calls are macroed to the i386 optimized version.
;
;   Arguments:
;
;       Source - Address of ULONG to exchange
;       Value  - New value of ULONG
;       Lock   - SpinLock used to implement atomicity.
;
;   Return Value:
;
;       The prior value of Source
;--

cPublicProc _Exi386InterlockedExchangeUlong, 2
cPublicFpo 2,0

ifndef NT_UP
        mov     edx, [esp+4]                ; (edx) = Target
        mov     eax, [esp+8]                ; (eax) = Value

        xchg    [edx], eax                  ; make the exchange
else
        mov     edx, [esp+4]                ; (edx) = Target
        mov     ecx, [esp+8]                ; (eax) = Value

        pushfd
        cli
        mov     eax, [edx]                  ; get current value
        mov     [edx], ecx                  ; store new value
        popfd
endif

        stdRET  _Exi386InterlockedExchangeUlong

stdENDP _Exi386InterlockedExchangeUlong

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\i386\splocks.asm ===
title "Global SpinLock declerations"
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;   splocks.asm
;
;Abstract:
;
;   All global spinlocks in the kernel image are declared in this
;   module.  This is done so that each spinlock can be spaced out
;   sufficiently to guaarantee that the L2 cache does not thrash
;   by having a spinlock and another high use variable in the same
;   cache line.
;
;Author:
;
;    Ken Reneris (kenr) 13-Jan-1992
;
;Revision History:
;
;--

.386p
        .xlist

ifdef NT_UP

PADLOCKS equ    4

_DATA   SEGMENT PARA PUBLIC 'DATA'

else

PADLOCKS equ    128

_DATA   SEGMENT PAGE PUBLIC 'DATA'

endif

SPINLOCK macro  SpinLockName

        align   PADLOCKS

        public  SpinLockName
SpinLockName    dd      0

        endm

ULONG   macro   VariableName

        align   PADLOCKS

        public  VariableName
VariableName    dd      0

        endm

;
; Static SpinLocks from ntos\cc\cachedat.c
;

SPINLOCK    _CcMasterSpinLock
SPINLOCK    _CcWorkQueueSpinLock
SPINLOCK    _CcVacbSpinLock
SPINLOCK    _CcDeferredWriteSpinLock
SPINLOCK    _CcDebugTraceLock
SPINLOCK    _CcBcbSpinLock

;
; Static SpinLocks from ntos\ex
;

SPINLOCK    _NonPagedPoolLock           ; pool.c
SPINLOCK    _ExpResourceSpinLock        ; resource.c

;
; Static SpinLocks from ntos\io\iodata.c
;

SPINLOCK    _IopCompletionLock
SPINLOCK    _IopCancelSpinLock
SPINLOCK    _IopVpbSpinLock
SPINLOCK    _IopDatabaseLock
SPINLOCK    _IopErrorLogLock
SPINLOCK    _IopTimerLock
SPINLOCK    _IoStatisticsLock

;
; Static SpinLocks from ntos\kd\kdlock.c
;

SPINLOCK    _KdpDebuggerLock

;
; Static SpinLocks from ntos\ke\kernldat.c
;

SPINLOCK    _KiContextSwapLock
SPINLOCK    _KiDispatcherLock
SPINLOCK    _KiFreezeExecutionLock
SPINLOCK    _KiFreezeLockBackup
ULONG       _KiHardwareTrigger
SPINLOCK    _KiProfileLock

;
; Static SpinLocks from ntos\mm\miglobal.c
;

SPINLOCK    _MmPfnLock
SPINLOCK    _MmSystemSpaceLock

;
; Static SpinLocks from ntos\ps\psinit.c
;

SPINLOCK    _PspEventPairLock
SPINLOCK    _PsLoadedModuleSpinLock

;
; Static SpinLocks from ntos\fsrtl\fsrtlp.c
;

SPINLOCK    _FsRtlStrucSupSpinLock          ; fsrtlp.c

;
; Static SpinLocks from base\fs\ntfs
;

SPINLOCK    _NtfsStructLock

;
; Static SpinLocks from net\sockets\winsock2\wsp\afdsys
;

SPINLOCK    _AfdWorkQueueSpinLock

;
; These variables are updated frequently and under control of the dispatcher
; database lock. They are defined in a single cache line to reduce false
; sharing in MP systems.
;
; KiIdleSummary - This is the set of processors which are idle.  It is
;      used by the ready thread code to speed up the search for a thread
;      to preempt when a thread becomes runnable.
;

        align   PADLOCKS

        public  _KiIdleSummary
_KiIdleSummary  dd      0

;
; KiIdleSMTSummary - In multi threaded processors, this is the set of
;      idle processors in which all the logical processors that make up a
;      physical processor are idle.   That is, this is the set of logical
;      processors in completely idle physical processors.
;

        public  _KiIdleSMTSummary
_KiIdleSMTSummary dd      0

;
; KiReadySummary - This is the set of dispatcher ready queues that are not
;      empty.  A member is set in this set for each priority that has one or
;      more entries in its respective dispatcher ready queues.
;

        public  _KiReadySummary
_KiReadySummary dd      0

;
; PoSleepingSummary - Set of processors which currently sleep (ie stop)
;      when idle.
;

        public  _PoSleepingSummary
_PoSleepingSummary dd      0

;
; KiTbFlushTimeStamp - This is the TB flush entire time stamp counter.
;
; This variable is in it own cache line to reduce false sharing on MP systems.
;

        align   PADLOCKS

        public  _KiTbFlushTimeStamp
_KiTbFlushTimeStamp dd      0

;
; These variables are referenced together and are defined in a single cache
; line to reduce sharing on MP systems.
;
; IopLookasideIrpFloat - This is the number of IRPs that are currently
;      in progress that were allocated from a lookaside list.
;

        align   PADLOCKS

        public  _IopLookasideIrpFloat
_IopLookasideIrpFloat dd      0

;
; IopLookasideIrpLimit - This is the maximum number of IRPs that can be
;      in progress that were allocated from a lookaside list.
;

        public  _IopLookasideIrpLimit
_IopLookasideIrpLimit dd      0

;
; These variables are referenced together and are defined in a single cache
; line to reduce sharing on MP systems.
;
; KeTickCount - This is the number of clock ticks that have occurred since
;      the system was booted. This count is used to compute a millisecond
;      tick counter.
;

        align   PADLOCKS

        public  _KeTickCount
_KeTickCount    dd      0, 0, 0

;
; KeMaximumIncrement - This is the maximum time between clock interrupts
;      in 100ns units that is supported by the host HAL.
;

        public  _KeMaximumIncrement
_KeMaximumIncrement dd      0

;
; KeTimeAdjustment - This is the actual number of 100ns units that are to
;      be added to the system time at each interval timer interupt. This
;      value is copied from KeTimeIncrement at system start up and can be
;      later modified via the set system information service.
;      timer table entries.
;

        public  _KeTimeAdjustment
_KeTimeAdjustment dd      0

;
; KiTickOffset - This is the number of 100ns units remaining before a tick
;      is added to the tick count and the system time is updated.
;

        public  _KiTickOffset
_KiTickOffset   dd      0

;
; These variables are referenced together and are defined in a single cache
; line to reduce sharing on MP systems.
;
; KiMaximumDpcQueueDepth - This is used to control how many DPCs can be
;      queued before a DPC of medium importance will trigger a dispatch
;      interrupt.
;

        align   PADLOCKS

        public  _KiMaximumDpcQueueDepth
_KiMaximumDpcQueueDepth dd      4

;
; KiMinimumDpcRate - This is the rate of DPC requests per clock tick that
;      must be exceeded before DPC batching of medium importance DPCs
;      will occur.
;

        public  _KiMinimumDpcRate
_KiMinimumDpcRate dd      3

;
; KiAdjustDpcThreshold - This is the threshold used by the clock interrupt
;      routine to control the rate at which the processor's DPC queue depth
;      is dynamically adjusted.
;

        public  _KiAdjustDpcThreshold
_KiAdjustDpcThreshold dd      20

;
; KiIdealDpcRate - This is used to control the aggressiveness of the DPC
;      rate adjusting algorithm when decrementing the queue depth. As long
;      as the DPC rate for the last tick is greater than this rate, the
;      DPC queue depth will not be decremented.
;

        public  _KiIdealDpcRate
_KiIdealDpcRate dd      20

;
; These variables are referenced together and are defined in a single cache
; line to reduce sharing on MP systems.
;
; KeErrorMask - This is the value used to mask the error code passed to
;      memory management on page faults.
;

        align   PADLOCKS

        public  _KeErrorMask
_KeErrorMask    dd      1

;
; MmPaeErrMask - This is the value used to mask upper bits of a PAE error.
;

        public  _MmPaeErrMask
_MmPaeErrMask   dd      0

;
; MmPaeMask - This is the value used to mask upper bits of a PAE PTE.
;

        public  _MmPaeMask
_MmPaeMask      dq      0

;
; MmPfnDereferenceSListHead - This is used to store free blocks used for
;      deferred PFN reference count releasing.
;

        align   PADLOCKS

        public  _MmPfnDereferenceSListHead
_MmPfnDereferenceSListHead  dq      0

;
; MmPfnDeferredList - This is used to queue items that need reference count
;      decrement processing.
;

        align   PADLOCKS

        public  _MmPfnDeferredList
_MmPfnDeferredList          dd      0

;
; MmSystemLockPagesCount - This is the count of the number of locked pages
;       in the system.
;

        align   PADLOCKS

        public  _MmSystemLockPagesCount
_MmSystemLockPagesCount     dd      0

        align   PADLOCKS

_DATA   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\amd64\wowinfo.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    wowinfo.c

Abstract:

    This module implements the routines to returns processor-specific information
    about the x86 emulation capability.

Author:

    Samer Arafeh (samera) 14-Nov-2000

Environment:

    Kernel Mode.

Revision History:

--*/

#include "exp.h"

NTSTATUS
ExpGetSystemEmulationProcessorInformation (
    OUT PSYSTEM_PROCESSOR_INFORMATION ProcessorInformation
    )

/*++

Routine Description:

    Retreives the processor information of the emulation hardware.

Arguments:

    ProcessorInformation - Pointer to receive the processor's emulation information.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    //  Intel Pentium Family 6, Model 2, Stepping 12
    //

    try {

        ProcessorInformation->ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
        ProcessorInformation->ProcessorLevel = 5;
        ProcessorInformation->ProcessorRevision = 0x020c;
        ProcessorInformation->Reserved = 0;
        ProcessorInformation->ProcessorFeatureBits = KeFeatureBits;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        
        NtStatus = GetExceptionCode ();
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\i386\fmutex.asm ===
TITLE   "Fast Mutex Support"
;++
;
;  Copyright (c) 1994  Microsoft Corporation
;
;  Module Name:
;
;     fmutex.asm
;
;  Abstract:
;
;     This module implements teh code necessary to acquire and release fast
;     mutexes without raising or lowering IRQL.
;
;  Author:
;
;     David N. Cutler (davec) 26-May-1994
;
;  Environment:
;
;     Kernel mode only.
;
;  Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
        .list

        EXTRNP _KeSetEventBoostPriority, 2
        EXTRNP _KeWaitForSingleObject, 5
if DBG
        EXTRNP  _KeGetCurrentIrql,0,IMPORT
        EXTRNP  ___KeGetCurrentThread,0
        EXTRNP  _KeBugCheckEx,5
endif

ifdef NT_UP
    LOCK_ADD  equ   add
    LOCK_DEC  equ   dec
else
    LOCK_ADD  equ   lock add
    LOCK_DEC  equ   lock dec
endif

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;  VOID
;  FASTCALL
;  ExAcquireFastMutexUnsafe (
;     IN PFAST_MUTEX FastMutex
;     )
;
;  Routine description:
;
;   This function acquires ownership of a fast mutex, but does not raise
;   IRQL to APC level.
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to a fast mutex.
;
;  Return Value:
;
;     None.
;
;--

cPublicFastCall ExAcquireFastMutexUnsafe,1
cPublicFpo 0,0

if DBG
        push    ecx
        stdCall _KeGetCurrentIrql
        pop     ecx
        
        ;
        ; Caller must already be at APC_LEVEL or have APCs blocked.
        ;

        cmp     al, APC_LEVEL
        
        mov     eax,PCR[PcPrcbData+PbCurrentThread]  ; grab the current thread 1st
        je      short afm09             ; APCs disabled, this is ok

        cmp     dword ptr [eax]+ThKernelApcDisable, 0
        jne     short afm09             ; APCs disabled, this is ok

        cmp     dword ptr [eax]+ThTeb, 0
        je      short afm09             ; No TEB ==> system thread, this is ok

        test    dword ptr [eax]+ThTeb, 080000000h
        jnz     short afm09             ; TEB in system space, this is ok

        jmp     short afm20             ; APCs not disabled --> fatal

afm09:  cmp     [ecx].FmOwner, eax          ; Already owned by this thread?
        je      short afm21                 ; Yes, error

endif

   LOCK_DEC     dword ptr [ecx].FmCount ; decrement lock count
        jz      short afm_ret           ; The owner? Yes, Done

        inc     dword ptr [ecx].FmContention ; increment contention count

if DBG
        push    eax
endif        
        
        push    ecx                                                                        
        add     ecx, FmEvent            ; wait for ownership event
        
        stdCall _KeWaitForSingleObject,<ecx,WrExecutive,0,0,0> ;
        
        pop ecx

if DBG
        pop eax
endif

afm_ret:

        ;
        ; Leave a notion of owner behind.
        ;
        ; Note: if you change this, change ExAcquireFastMutex.
        ;
        
if DBG  
        mov     [ecx].FmOwner, eax          ; Save in Fast Mutex
else
        ;
        ; Use esp to track the owning thread for debugging purposes.
        ; !thread from kd will find the owning thread.  Note that the
        ; owner isn't cleared on release, check if the mutex is owned
        ; first.
        ;

        mov     [ecx].FmOwner, esp
endif

        fstRet  ExAcquireFastMutexUnsafe ; return

if DBG
afm20:  stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,ecx,eax,039h,0>
afm21:  stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,ecx,eax,040h,0>
endif

int 3

fstENDP ExAcquireFastMutexUnsafe

;++
;
;  VOID
;  FASTCALL
;  ExReleaseFastMutexUnsafe (
;     IN PFAST_MUTEX FastMutex
;     )
;
;  Routine description:
;
;   This function releases ownership of a fast mutex, and does not
;   restore IRQL to its previous value.
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to a fast mutex.
;
;  Return Value:
;
;     None.
;
;--

cPublicFastCall ExReleaseFastMutexUnsafe,1
cPublicFpo 0,0

if DBG
        push    ecx
        stdCall _KeGetCurrentIrql
        pop     ecx

        ;
        ; Caller must already be at APC_LEVEL or have APCs blocked.
        ;

        cmp     al, APC_LEVEL
        mov     eax,PCR[PcPrcbData+PbCurrentThread]  ; grab the current thread 1st
        je      short rfm09             ; APCs disabled, this is ok

        cmp     dword ptr [eax]+ThKernelApcDisable, 0
        jne     short rfm09             ; APCs disabled, this is ok

        cmp     dword ptr [eax]+ThTeb, 0
        je      short rfm09             ; No TEB ==> system thread, this is ok

        test    dword ptr [eax]+ThTeb, 080000000h
        jnz     short rfm09             ; TEB in system space, this is ok

        jmp     short rfm20             ; APCs not disabled --> fatal

rfm09:  cmp     [ecx].FmOwner, eax              ; Owner == CurrentThread?
        jne     short rfm_threaderror           ; No, bugcheck

        or      byte ptr [ecx].FmOwner, 1       ; not the owner anymore
endif

   LOCK_ADD     dword ptr [ecx].FmCount, 1 ; increment ownership count
        jng     short rfm10             ; if ng, waiter present

        fstRet  ExReleaseFastMutexUnsafe ; return

rfm10:  add     ecx, FmEvent            ; compute event address
        stdCall _KeSetEventBoostPriority,<ecx, 0> ; set ownerhsip event
        fstRet  ExReleaseFastMutexUnsafe ; return

if DBG
rfm20:  stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,ecx,eax,03ah,0>
rfm_threaderror:  stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,ecx,eax,03bh,0>
endif

int 3

fstENDP ExReleaseFastMutexUnsafe

_TEXT$00   ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\i386\intrlfst.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    intrlfst.asm
;
; Abstract:
;
;    This module implements functions to support interlocked operations.
;    Interlocked operations can only operate on nonpaged data.
;
;    This module implements the fast call version of the interlocked
;    fuctions.
;
; Author:
;
;    Ken Reneris (kenr) 5-May-1994
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
        .list

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;   General Notes on Interlocked Procedures:
;
;       These procedures assume that neither their code, nor any of
;       the data they touch, will cause a page fault.
;
;       They use spinlocks to achieve MP atomicity, iff it's an MP machine.
;       (The spinlock macros generate zilch if NT_UP = 1, and
;        we if out some aux code here as well.)
;
;       They turn off interrupts so that they can be used for synchronization
;       between ISRs and driver code.  Flags are preserved so they can
;       be called in special code (Like IPC interrupt handlers) that
;       may have interrupts off.
;
;--


;;      align  512

        page ,132
        subttl  "ExInterlockedAddLargeStatistic"
;++
;
; VOID
; FASTCALL
; ExInterlockedAddLargeStatistic (
;    IN PLARGE_INTEGER Addend,
;    IN ULONG Increment
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsigned large integer.
;
; Arguments:
;
;    (ecx) Addend - Supplies a pointer to the variable whose value is
;                     adjusted by the increment value.
;
;    (edx) Increment - Supplies the increment value that is added to the
;                      addend variable.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall ExInterlockedAddLargeStatistic, 2
cPublicFpo 0,0

ifdef NT_UP

        add dword ptr [ecx], edx        ; add low part of large statistic
        adc dword ptr [ecx+4], 0        ; add carry to high part

else

        lock add dword ptr [ecx], edx   ; add low part of large statistic
        jc      short Eils10            ; if c, add generated a carry
        fstRET  ExInterlockedAddLargeStatistic ; return

Eils10: lock adc dword ptr [ecx+4], 0   ; add carry to high part

endif

        fstRET  ExInterlockedAddLargeStatistic ; return

fstENDP ExInterlockedAddLargeStatistic

        page , 132
        subttl  "Interlocked Add Unsigned Long"
;++
;
; ULONG
; FASTCALL
; ExfInterlockedAddUlong (
;    IN PULONG Addend,
;    IN ULONG Increment,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsinged long. The initial value of the addend
;    variable is returned as the function value.
;
;       It is NOT possible to mix ExInterlockedDecrementLong and
;       ExInterlockedIncrementong with ExInterlockedAddUlong.
;
;
; Arguments:
;
;    (ecx)  Addend - Supplies a pointer to a variable whose value is to be
;                    adjusted by the increment value.
;
;    (edx) Increment - Supplies the increment value to be added to the
;                      addend variable.
;
;    (esp+4) Lock - Supplies a pointer to a spin lock to be used to synchronize
;                   access to the addend variable.
;
; Return Value:
;
;    The initial value of the addend variable.
;
;--

cPublicFastCall ExfInterlockedAddUlong, 3
cPublicFpo 1, 1

ifdef NT_UP
;
; UP version of ExInterlockedAddUlong
;

        pushfd
        cli                             ; disable interrupts

        mov     eax, [ecx]              ; (eax)= initial addend value
        add     [ecx], edx              ; [ecx]=adjusted value

        popfd                           ; restore flags including ints
        fstRET  ExfInterlockedAddUlong

else

;
; MP version of ExInterlockedAddUlong
;
        pushfd
        mov     eax, [esp+8]            ; (eax) = SpinLock
Eial10: cli                             ; disable interrupts
        ACQUIRE_SPINLOCK eax, <short Eial20>

        mov     eax, [ecx]              ; (eax)=initial addend value
        add     [ecx], edx              ; [ecx]=adjusted value

        mov     edx, [esp+8]            ; (edx) = SpinLock
        RELEASE_SPINLOCK edx
        popfd
        fstRET    ExfInterlockedAddUlong

Eial20: popfd
        pushfd
        SPIN_ON_SPINLOCK eax, <short Eial10>
endif

fstENDP ExfInterlockedAddUlong

        page , 132
        subttl  "Interlocked Insert Head List"
;++
;
; PLIST_ENTRY
; ExfInterlockedInsertHeadList (
;    IN PLIST_ENTRY ListHead,
;    IN PLIST_ENTRY ListEntry,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function inserts an entry at the head of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;   (ecx) = ListHead - Supplies a pointer to the head of the doubly linked
;                       list into which an entry is to be inserted.
;
;   (edx) = ListEntry - Supplies a pointer to the entry to be inserted at the
;                       head of the list.
;
;   (esp+4)  Lock - Supplies a pointer to a spin lock to be used to synchronize
;                   access to the list.
;
; Return Value:
;
;    Pointer to entry that was at the head of the list or NULL if the list
;    was empty.
;
;--

cPublicFastCall ExfInterlockedInsertHeadList    , 3
cPublicFpo 1, 1

ifndef NT_UP
cPublicFpo 1, 2
        push    esi
        mov     esi, [esp+8]            ; Address of spinlock
endif
        pushfd

Eiih10: cli
        ACQUIRE_SPINLOCK    esi,<short Eiih20>

        mov     eax, LsFlink[ecx]       ; (eax)->next entry in the list
        mov     [edx]+LsFlink, eax      ; store next link in entry
        mov     [edx]+LsBlink, ecx      ; store previous link in entry
        mov     [ecx]+LsFlink, edx      ; store next link in head
        mov     [eax]+LsBlink, edx      ; store previous link in next

        RELEASE_SPINLOCK esi
        popfd
ifndef NT_UP
        pop     esi
endif
        xor     eax, ecx                ; return null if list was empty
        jz      short Eiih15
        xor     eax, ecx
Eiih15: fstRET  ExfInterlockedInsertHeadList

ifndef NT_UP
Eiih20: popfd
        pushfd
        SPIN_ON_SPINLOCK esi, <short Eiih10>
endif

fstENDP ExfInterlockedInsertHeadList

        page , 132
        subttl  "Interlocked Insert Tail List"
;++
;
; PLIST_ENTRY
; FASTCALL
; ExfInterlockedInsertTailList (
;    IN PLIST_ENTRY ListHead,
;    IN PLIST_ENTRY ListEntry,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function inserts an entry at the tail of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;   (ecx) =  ListHead - Supplies a pointer to the head of the doubly linked
;            list into which an entry is to be inserted.
;
;   (edx) =  ListEntry - Supplies a pointer to the entry to be inserted at the
;            tail of the list.
;
;   (esp+4)  Lock - Supplies a pointer to a spin lock to be used to synchronize
;            access to the list.
;
; Return Value:
;
;    Pointer to entry that was at the tail of the list or NULL if the list
;    was empty.
;
;--

cPublicFastCall ExfInterlockedInsertTailList, 3
cPublicFpo 1, 1

ifndef NT_UP
cPublicFpo 1, 2
        push    esi
        mov     esi, [esp+8]            ; Address of spinlock
endif
        pushfd

Eiit10: cli
        ACQUIRE_SPINLOCK    esi,<short Eiit20>

        mov     eax, LsBlink[ecx]       ; (eax)->prev entry in the list
        mov     [edx]+LsFlink, ecx      ; store next link in entry
        mov     [edx]+LsBlink, eax      ; store previous link in entry
        mov     [ecx]+LsBlink, edx      ; store next link in head
        mov     [eax]+LsFlink, edx      ; store previous link in next

        RELEASE_SPINLOCK esi
        popfd

ifndef NT_UP
        pop     esi
endif
        xor     eax, ecx                ; return null if list was empty
        jz      short Eiit15
        xor     eax, ecx
Eiit15: fstRET  ExfInterlockedInsertTailList

ifndef NT_UP
Eiit20: popfd
        pushfd
        SPIN_ON_SPINLOCK esi, <short Eiit10>
endif

fstENDP ExfInterlockedInsertTailList


        page , 132
        subttl  "Interlocked Remove Head List"
;++
;
; PLIST_ENTRY
; FASTCALL
; ExfInterlockedRemoveHeadList (
;    IN PLIST_ENTRY ListHead,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function removes an entry from the head of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry that is removed is returned as the
;    function value.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;    (ecx) ListHead - Supplies a pointer to the head of the doubly linked
;          list from which an entry is to be removed.
;
;    (edx) Lock - Supplies a pointer to a spin lock to be used to synchronize
;          access to the list.
;
; Return Value:
;
;    The address of the entry removed from the list, or NULL if the list is
;    empty.
;
;--

cPublicFastCall ExfInterlockedRemoveHeadList    , 2
cPublicFpo 0, 1
ifdef NT_UP
;
; UP version
;
        pushfd
        cli

        mov     eax, [ecx]+LsFlink      ; (eax)-> next entry
        cmp     eax, ecx                ; Is list empty?
        je      short Eirh20            ; if e, list is empty, go Eirh20

        mov     edx, [eax]+LsFlink      ; (ecx)-> next entry(after deletion)
        mov     [ecx]+LsFlink, edx      ; store address of next in head
        mov     [edx]+LsBlink, ecx      ; store address of previous in next
if DBG
        mov     [eax]+LsFlink, 0baddd0ffh
        mov     [eax]+LsBlink, 0baddd0ffh
endif
        popfd                           ; restore flags including interrupts
        fstRET    ExfInterlockedRemoveHeadList

Eirh20: popfd
        xor     eax,eax                 ; (eax) = null for empty list
        fstRET  ExfInterlockedRemoveHeadList

else
;
; MP version
;

Eirh40: pushfd
        cli
        ACQUIRE_SPINLOCK edx, <short Eirh60>

        mov     eax, [ecx]+LsFlink      ; (eax)-> next entry
        cmp     eax, ecx                ; Is list empty?
        je      short Eirh50            ; if e, list is empty, go Eirh50

cPublicFpo 0,2
        push    ebx

        mov     ebx, [eax]+LsFlink      ; (ecx)-> next entry(after deletion)
        mov     [ecx]+LsFlink, ebx      ; store address of next in head
        mov     [ebx]+LsBlink, ecx      ; store address of previous in next
if DBG
        mov     ebx, 0badd0ffh
        mov     [eax]+LsFlink, ebx
        mov     [eax]+LsBlink, ebx
endif
        RELEASE_SPINLOCK  edx

cPublicFpo 0, 0
        pop     ebx
        popfd                           ; restore flags including interrupts
        fstRET  ExfInterlockedRemoveHeadList

Eirh50: RELEASE_SPINLOCK  edx
        popfd
        xor     eax,eax                 ; (eax) = null for empty list
        fstRET  ExfInterlockedRemoveHeadList

cPublicFpo 0, 0
Eirh60: popfd
        SPIN_ON_SPINLOCK edx, <Eirh40>
        fstRET  ExfInterlockedRemoveHeadList

endif   ; nt_up

fstENDP ExfInterlockedRemoveHeadList

        page , 132
        subttl  "Interlocked Pop Entry List"
;++
;
; PSINGLE_LIST_ENTRY
; FASTCALL
; ExfInterlockedPopEntryList (
;    IN PSINGLE_LIST_ENTRY ListHead,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function removes an entry from the front of a singly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry that is removed is returned as the
;    function value.
;
; Arguments:
;
;    (ecx) = ListHead - Supplies a pointer to the head of the singly linked
;            list from which an entry is to be removed.
;
;    (edx) = Lock - Supplies a pointer to a spin lock to be used to synchronize
;            access to the list.
;
; Return Value:
;
;    The address of the entry removed from the list, or NULL if the list is
;    empty.
;
;--

cPublicFastCall ExfInterlockedPopEntryList      , 2

ifdef NT_UP
;
; UP version
;
cPublicFpo 0,1
        pushfd
        cli                             ; disable interrupts

        mov     eax, [ecx]              ; (eax)-> next entry
        or      eax, eax                ; Is it empty?
        je      short Eipe05            ; if e, empty list, go Eipe05
        mov     edx, [eax]              ; (edx)->next entry (after deletion)
        mov     [ecx], edx              ; store address of next in head
if DBG
        mov     [eax], 0baddd0ffh
endif
cPublicFpo 0,0
        popfd                           ; restore flags including interrupts
        fstRET    ExfInterlockedPopEntryList    ; cReturn (eax)->removed entry

Eipe05: popfd
        xor     eax,eax
        fstRET  ExfInterlockedPopEntryList    ; cReturn (eax)=NULL

else    ; nt_up

;
; MP Version
;

cPublicFpo 0,1

Eipe10: pushfd
        cli                             ; disable interrupts

        ACQUIRE_SPINLOCK edx, <short Eipe30>

        mov     eax, [ecx]              ; (eax)-> next entry
        or      eax, eax                ; Is it empty?
        je      short Eipe20            ; if e, empty list, go Eipe20
cPublicFpo 0,2
        push    edx                     ; Save SpinLock address
        mov     edx, [eax]              ; (edx)->next entry (after deletion)
        mov     [ecx], edx              ; store address of next in head
        pop     edx                     ; Restore SpinLock address
if DBG
        mov     [eax], 0baddd0ffh
endif
        RELEASE_SPINLOCK edx

cPublicFpo 0,0
        popfd                           ; restore flags including interrupts
        fstRET    ExfInterlockedPopEntryList

Eipe20: RELEASE_SPINLOCK edx
        popfd
        xor     eax,eax
        fstRET    ExfInterlockedPopEntryList

Eipe30: popfd
        SPIN_ON_SPINLOCK edx, Eipe10

endif   ; nt_up

fstENDP ExfInterlockedPopEntryList

        page , 132
        subttl  "Interlocked Push Entry List"
;++
;
; PSINGLE_LIST_ENTRY
; FASTCALL
; ExInterlockedPushEntryList (
;    IN PSINGLE_LIST_ENTRY ListHead,
;    IN PSINGLE_LIST_ENTRY ListEntry,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function inserts an entry at the head of a singly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;
; Arguments:
;
;    (ecx) ListHead - Supplies a pointer to the head of the singly linked
;          list into which an entry is to be inserted.
;
;    (edx) ListEntry - Supplies a pointer to the entry to be inserted at the
;          head of the list.
;
;    (esp+4) Lock - Supplies a pointer to a spin lock to be used to synchronize
;            access to the list.
;
; Return Value:
;
;    Previous contents of ListHead.  NULL implies list went from empty
;       to not empty.
;
;--

cPublicFastCall ExfInterlockedPushEntryList     , 3
ifdef NT_UP
;
; UP Version
;
cPublicFpo 0,1
        pushfd
        cli

        mov     eax, [ecx]              ; (eax)-> next entry (return value also)
        mov     [edx], eax              ; store address of next in new entry
        mov     [ecx], edx              ; set address of next in head

cPublicFpo 0,0
        popfd                           ; restore flags including interrupts
        fstRET    ExfInterlockedPushEntryList

else
;
; MP Version
;

cPublicFpo 1,1
        pushfd
        push    edx
        mov     edx, [esp+12]           ; (edx) = SpinLock

Eipl10: cli
        ACQUIRE_SPINLOCK edx, <short Eipl20>

        pop     edx                     ; (edx)-> Entry to be pushed
        mov     eax, [ecx]              ; (eax)-> next entry (return value also)
        mov     [edx], eax              ; store address of next in new entry
        mov     [ecx], edx              ; set address of next in head

        mov     edx, [esp+8]            ; (edx) = SpinLock
        RELEASE_SPINLOCK edx

cPublicFpo 0,0
        popfd                           ; restore flags including interrupts
        fstRET    ExfInterlockedPushEntryList

cPublicFpo 1,2
Eipl20: pop     edx
        popfd                           ; Restore interrupt state

        pushfd
        push    edx
        mov     edx, [esp+12]
        SPIN_ON_SPINLOCK edx, <short Eipl10>
endif

fstENDP ExfInterlockedPushEntryList

        page , 132

        subttl  "Interlocked i386 Increment Long"
;++
;
;   INTERLOCKED_RESULT
;   FASTCALL
;   Exfi386InterlockedIncrementLong (
;       IN PLONG Addend
;       )
;
;   Routine Description:
;
;       This function atomically increments Addend, returning an ennumerated
;       type which indicates what interesting transitions in the value of
;       Addend occurred due the operation.
;
;       See ExInterlockedIncrementLong.  This function is the i386
;       architectural specific version of ExInterlockedIncrementLong.
;       No source directly calls this function, instead
;       ExInterlockedIncrementLong is called and when built on x86 these
;       calls are macroed to the i386 optimized version.
;
;   Arguments:
;
;       (ecx) Addend - Pointer to variable to increment.
;
;   Return Value:
;
;       An ennumerated type:
;
;       ResultNegative if Addend is < 0 after increment.
;       ResultZero     if Addend is = 0 after increment.
;       ResultPositive if Addend is > 0 after increment.
;
;--

cPublicFastCall Exfi386InterlockedIncrementLong, 1
cPublicFpo 0, 0

ifdef NT_UP
        add dword ptr [ecx],1
else
        lock add dword ptr [ecx],1
endif
        lahf                            ; (ah) = flags
        and     eax,EFLAG_SELECT        ; clear all but sign and zero flags
        fstRET  Exfi386InterlockedIncrementLong

fstENDP Exfi386InterlockedIncrementLong


        page , 132
        subttl  "Interlocked i386 Decrement Long"
;++
;
;   INTERLOCKED_RESULT
;   FASTCALL
;   Exfi386InterlockedDecrementLong (
;       IN PLONG Addend,
;       IN PKSPIN_LOCK Lock
;       )
;
;   Routine Description:
;
;       This function atomically decrements Addend, returning an ennumerated
;       type which indicates what interesting transitions in the value of
;       Addend occurred due the operation.
;
;       See Exi386InterlockedDecrementLong.  This function is the i386
;       architectural specific version of ExInterlockedDecrementLong.
;       No source directly calls this function, instead
;       ExInterlockedDecrementLong is called and when built on x86 these
;       calls are macroed to the i386 optimized version.
;
;   Arguments:
;
;       Addend (esp+4) - Pointer to variable to decrement.
;
;       Lock (esp+8) - Spinlock used to implement atomicity.
;                      (not actually used on x86)
;
;   Return Value:
;
;       An ennumerated type:
;
;       ResultNegative if Addend is < 0 after decrement.
;       ResultZero     if Addend is = 0 after decrement.
;       ResultPositive if Addend is > 0 after decrement.
;
;--

cPublicFastCall Exfi386InterlockedDecrementLong , 1
cPublicFpo 0, 0

ifdef NT_UP
        sub dword ptr [ecx], 1
else
        lock sub dword ptr [ecx], 1
endif
        lahf                            ; (ah) = flags
        and     eax, EFLAG_SELECT       ; clear all but sign and zero flags
        fstRET  Exfi386InterlockedDecrementLong

fstENDP Exfi386InterlockedDecrementLong

        page , 132
        subttl  "Interlocked i386 Exchange Ulong"
;++
;
;   ULONG
;   FASTCALL
;   Exfi386InterlockedExchangeUlong (
;       IN PULONG Target,
;       IN ULONG Value
;       )
;
;   Routine Description:
;
;       This function atomically exchanges the Target and Value, returning
;       the prior contents of Target
;
;       See Exi386InterlockedExchangeUlong.  This function is the i386
;       architectural specific version of ExInterlockedDecrementLong.
;       No source directly calls this function, instead
;       ExInterlockedDecrementLong is called and when built on x86 these
;       calls are macroed to the i386 optimized version.
;
;   Arguments:
;
;       (ecx) = Source - Address of ULONG to exchange
;       (edx) = Value  - New value of ULONG
;
;   Return Value:
;
;       The prior value of Source
;--

cPublicFastCall Exfi386InterlockedExchangeUlong, 2
cPublicFpo 0,0

.486
ifndef NT_UP
        xchg    [ecx], edx                  ; make the exchange
        mov     eax, edx
else
        mov     eax, [ecx]                  ; get comperand value
Ixchg:  cmpxchg [ecx], edx                  ; compare and swap
        jnz     Ixchg                       ; if nz, exchange failed
endif
.386

        fstRET  Exfi386InterlockedExchangeUlong
fstENDP Exfi386InterlockedExchangeUlong

;++
;
; LONG
; InterlockedIncrement(
;    IN PLONG Addend
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of one to the addend variable.
;
;    No checking is done for overflow.
;
; Arguments:
;
;    Addend (ecx) - Supplies a pointer to a variable whose value is to be
;       incremented by one.
;
; Return Value:
;
;   (eax) - The incremented value.
;
;--

cPublicFastCall __InterlockedIncrement,1
cPublicFpo 0,0

        mov     eax, 1                  ; set increment value

.486
ifndef NT_UP
   lock xadd    [ecx], eax              ; interlocked increment
else
        xadd    [ecx], eax              ; interlocked increment
endif
.386p
        inc     eax                     ; adjust return value

        fstRET __InterlockedIncrement

fstENDP __InterlockedIncrement

        page , 132
        subttl  "InterlockedDecrment"
;++
;
; LONG
; InterlockedDecrement(
;    IN PLONG Addend
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of -1 to the addend variable.
;
;    No checking is done for overflow
;
; Arguments:
;
;    Addend (ecx) - Supplies a pointer to a variable whose value is to be
;       decremented by one.
;
; Return Value:
;
;   (eax) - The decremented value.
;
;--

cPublicFastCall __InterlockedDecrement,1
cPublicFpo 0,0

        mov     eax, -1                 ; set decrment value

.486
ifndef NT_UP
   lock xadd    [ecx], eax              ; interlocked decrement
else
        xadd    [ecx], eax              ; interlocked decrement
endif
.386

        dec     eax                     ; adjust return value

        fstRET __InterlockedDecrement

fstENDP __InterlockedDecrement

        page , 132
        subttl  "Interlocked Compare Exchange"
;++
;
;   PVOID
;   FASTCALL
;   InterlockedCompareExchange (
;       IN OUT PVOID *Destination,
;       IN PVOID Exchange,
;       IN PVOID Comperand
;       )
;
;   Routine Description:
;
;    This function performs an interlocked compare of the destination
;    value with the comperand value. If the destination value is equal
;    to the comperand value, then the exchange value is stored in the
;    destination. Otherwise, no operation is performed.
;
; Arguments:
;
;    (ecx)  Destination - Supplies a pointer to destination value.
;
;    (edx) Exchange - Supplies the exchange value.
;
;    [esp + 4] Comperand - Supplies the comperand value.
;
; Return Value:
;
;    The initial destination value is returned as the function value.
;
;--

cPublicFastCall __InterlockedCompareExchange, 3
cPublicFpo 0,0

        mov     eax, [esp + 4]          ; set comperand value
.486
ifndef NT_UP
   lock cmpxchg [ecx], edx              ; compare and exchange
else
        cmpxchg [ecx], edx              ; compare and exchange
endif
.386

        fstRET  __InterlockedCompareExchange

fstENDP __InterlockedCompareExchange

        subttl  "Interlocked Compare Exchange 64-bit - without lock"
;++
;
; LONGLONG
; FASTCALL
; ExfInterlockedCompareExchange64 (
;    IN OUT PLONGLONG Destination,
;    IN PLONGLONG Exchange,
;    IN PLONGLONG Comperand
;    )
;
; Routine Description:
;
;    This function performs a compare and exchange of 64-bits.
;
; Arguments:
;
;    (ecx) Destination - Supplies a pointer to the destination variable.
;
;    (edx) Exchange - Supplies a pointer to the exchange value.
;
;    (esp+4) Comperand - Supplies a pointer to the comperand value.
;
; Return Value:
;
;    The current destination value is returned as the function value.
;
;--

cPublicFastCall ExfInterlockedCompareExchange64, 3

cPublicFpo 0,2

;
; Save nonvolatile registers and read the exchange and comperand values.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; set destination address
        mov     ebx, [edx]              ; get exchange value
        mov     ecx, [edx] + 4          ;
        mov     edx, [esp] + 12         ; get comperand address
        mov     eax, [edx]              ; get comperand value
        mov     edx, [edx] + 4          ;

.586
ifndef NT_UP

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

else

        cmpxchg8b qword ptr[ebp]        ; compare and exchange

endif
.386

;
; Restore nonvolatile registers and return result in edx:eax.
;

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET  ExfInterlockedCompareExchange64

fstENDP ExfInterlockedCompareExchange64

        page , 132
        subttl  "Interlocked Compare Exchange 64-bits - with lock"
;++
;
; LONGLONG
; FASTCALL
; ExInterlockedCompareExchange64 (
;    IN PLONGLONG Destination,
;    IN PLONGLONG Exchange,
;    IN PLONGLONG Comperand,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function performs a compare and exchange of 64-bits.
;
;    N.B. This routine is provided for backward compatibility only. The
;         lock address is not used.
;
; Arguments:
;
;    (ecx) Destination - Supplies a pointer to the destination variable.
;
;    (edx) Exchange - Supplies a pointer to the exchange value.
;
;    (esp+4) Comperand - Supplies a pointer to the comperand value.
;
;    (esp+4) Lock - Supplies a pointer to a spin lock to use if the cmpxchg8b
;        instruction is not available on the host system.
;
; Return Value:
;
;    The current destination value is returned as the function value.
;
;--

cPublicFastCall ExInterlockedCompareExchange64, 4

cPublicFpo 0,2

;
; Save nonvolatile registers and read the exchange and comperand values.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; set destination address
        mov     ebx, [edx]              ; get exchange value
        mov     ecx, [edx] + 4          ;
        mov     edx, [esp] + 12         ; get comperand address
        mov     eax, [edx]              ; get comperand value
        mov     edx, [edx] + 4          ;

.586
ifndef NT_UP

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

else

        cmpxchg8b qword ptr[ebp]        ; compare and exchange

endif
.386

;
; Restore nonvolatile registers and return result in edx:eax.
;

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET    ExInterlockedCompareExchange64

fstENDP ExInterlockedCompareExchange64

        subttl  "Interlocked Exchange Add"
;++
;
;   LONG
;   FASTCALL
;   InterlockedExchangeAdd (
;       IN OUT PLONG Addend,
;       IN LONG Increment
;       )
;
;   Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsinged long. The initial value of the addend
;    variable is returned as the function value.
;
;       It is NOT possible to mix ExInterlockedDecrementLong and
;       ExInterlockedIncrementong with ExInterlockedAddUlong.
;
;
; Arguments:
;
;    (ecx)  Addend - Supplies a pointer to a variable whose value is to be
;                    adjusted by the increment value.
;
;    (edx) Increment - Supplies the increment value to be added to the
;                      addend variable.
;
; Return Value:
;
;    The initial value of the addend variable.
;
;--

cPublicFastCall __InterlockedExchangeAdd, 2
cPublicFpo 0,0

.486
ifndef NT_UP
   lock xadd    [ecx], edx              ; exchange add
else
        xadd    [ecx], edx              ; exchange add
endif
.386

        mov     eax, edx                ; set initial value

        fstRET  __InterlockedExchangeAdd

fstENDP __InterlockedExchangeAdd

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\i386\raisests.asm ===
title  "Raise Exception"
;++
;
; Copyright (c) 1990  Microsoft Corporation
;
; Module Name:
;
;    raisests.asm
;
; Abstract:
;
;    This module implements the function to raise a software exception.
;
; Author:
;
;    Bryan Willman  11 Nov 90
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list

        EXTRNP  _RtlDispatchException,2
        EXTRNP  _ZwContinue,2
        EXTRNP  _ZwRaiseException,3

_TEXT$01   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;
; Context flags definition.
;

CONTEXT_SETTING EQU CONTEXT_INTEGER OR CONTEXT_CONTROL OR CONTEXT_SEGMENTS

;
; Exception record length definition.
;

EXCEPTION_RECORD_LENGTH EQU (ErExceptionInformation + 16) AND 0fffffff0H

        page
        subttl  "Raise Software Exception"
;++
;
; VOID
; ExRaiseException (
;    IN PEXCEPTION_RECORD ExceptionRecord
;    )
;
; Routine Description:
;
;    This function raises a software exception by building a context record,
;    establishing the stack limits of the current processor mode, and calling
;    the exception dispatcher. If the exception dispatcher finds a handler
;    to process the exception, then control is returned to the caller using
;    the NtContinue system service. Otherwise the NtLastChance system service
;    is called to provide default handing.
;
;   N.B.    On the 386, floating point state is not defined for non-fp
;           exceptions.  Therefore, this routine does not attempt to
;           capture it.
;
;           This means this routine cannot be used to report fp exceptions.
;
; Arguments:
;
;    ExceptionRecord (ebp+8) - Supplies a pointer to an exception record.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _ExRaiseException  , 1

        push    ebp
        mov     ebp,esp
        pushfd                          ; save flags before sub
        sub     esp,ContextFrameLength  ; Allocate a context record

;
; Save regs we use in context record
;

        mov     [(ebp-ContextFrameLength-4)+CsEax],eax
        mov     [(ebp-ContextFrameLength-4)+CsEcx],ecx

;
; Get pointer to exception report record, and set the exceptionaddress
; field to be our return address
;

        mov     eax,[ebp+8]             ; (eax) -> ExceptionReportRecord

        mov     ecx,[ebp+4]
        mov     [eax.ErExceptionAddress],ecx

;
; Copy machine context into the context record
;

        lea     eax,[ebp-ContextFrameLength-4]  ; (eax) -> Context record

        mov     [eax.CsEip],ecx

        mov     [eax.CsEbx],ebx
        mov     [eax.CsEdx],edx

        mov     [eax.CsEsi],esi
        mov     [eax.CsEdi],edi

        lea     ecx,[ebp+8]
        mov     [eax.CsEsp],ecx

        mov     ecx,[ebp]
        mov     [eax.CsEbp],ecx

        mov     ecx,[ebp-4]
        mov     [eax.CsEflags],ecx

        mov     dword ptr [eax.CsSegCs],cs
        mov     dword ptr [eax.CsSegDs],ds
        mov     dword ptr [eax.CsSegEs],es
        mov     dword ptr [eax.CsSegFs],fs
        mov     dword ptr [eax.CsSegGs],gs
        mov     dword ptr [eax.CsSegSs],ss

;
; Set Context flags, note that FLOATING_POINT is NOT set.
;

        mov     dword ptr [eax.CsContextFlags],CONTEXT_SETTING

;
; _RtlDispatchException(ExceptionRecord, ContextRecord)
;
        stdCall    _RtlDispatchException, <[ebp+8],eax>
;
; If the exception is successfully dispatched, then continue execution.
; Otherwise, give the kernel debugger a chance to handle the exception.
;
        lea     ecx,[ebp-ContextFrameLength-4]  ; (eax) -> Context record

        or      eax, eax
        jz      short ere10

        stdCall    _ZwContinue, <ecx,0>
        jmp     short ere20

ere10:
        stdCall    _ZwRaiseException, <[ebp+8],ecx,0>

ere20:
;
; Either the attempt to continue execution or the attempt to give
; the kernel debugger a chance to handle the exception failed. Raise
; a noncontinuable exception.
;
        stdCall    _ExRaiseStatus, <eax>


stdENDP _ExRaiseException

        page
        subttl  "Raise Software Exception"
;++
;
; VOID
; ExRaiseStatus (
;     IN NTSTATUS Status
;     )
;
; Routine Description:
;
;    This function raises a software exception with the specified status value
;    by building a context record, establishing the stack limits of the current
;    processor mode, and calling the exception dispatcher. If the exception
;    dispatcher finds a handler to process the exception, then control is
;    returned to the caller using the NtContinue system service. Otherwise
;    the NtLastChance system service is called to provide default handing.
;
;   N.B.    On the 386, floating point state is not defined for non-fp
;           exceptions.  Therefore, this routine does not attempt to
;           capture it.
;
;           This means this routine cannot be used to report fp exceptions.
;
; Arguments:
;
;     Status - Supplies the status value to be used as the exception code
;         for the exception that is to be raised.
;
; Return Value:
;
;     None.

; Arguments:
;
;--

cPublicProc     _ExRaiseStatus,1

        push    ebp
        mov     ebp,esp
        pushfd                          ; save flags before sub
        sub     esp,ContextFrameLength+ExceptionRecordLength

;
; Save regs we use in context record
;

        mov     [(ebp-ContextFrameLength-4)+CsEax],eax
        mov     [(ebp-ContextFrameLength-4)+CsEcx],ecx

;
; Copy machine context into the context record
;


        lea     eax,[ebp-ContextFrameLength-4]  ; (eax) -> Context record

        mov     ecx,[ebp+4]                     ; [ecx] = returned address
        mov     [eax.CsEip],ecx

        mov     [eax.CsEbx],ebx
        mov     [eax.CsEdx],edx

        mov     [eax.CsEsi],esi
        mov     [eax.CsEdi],edi

        lea     ecx,[ebp+8]
        mov     [eax.CsEsp],ecx

        mov     ecx,[ebp]
        mov     [eax.CsEbp],ecx

        mov     ecx,[ebp-4]
        mov     [eax.CsEflags],ecx

        mov     dword ptr [eax.CsSegCs],cs
        mov     dword ptr [eax.CsSegDs],ds
        mov     dword ptr [eax.CsSegEs],es
        mov     dword ptr [eax.CsSegFs],fs
        mov     dword ptr [eax.CsSegGs],gs
        mov     dword ptr [eax.CsSegSs],ss

;
; Set Context flags, note that FLOATING_POINT is NOT set.
;

        mov     dword ptr [eax.CsContextFlags],CONTEXT_SETTING

;
; Get pointer to exception report record, and set the exceptionaddress
; field to be our return address
;

        lea     eax,[ebp-ContextFrameLength-ExceptionRecordLength-4]
                                        ; (eax) -> ExceptionRecord
        mov     ecx,[ebp+4]
        mov     dword ptr [eax.ErExceptionAddress],ecx
        mov     ecx,[ebp+8]
        mov     dword ptr [eax.ErExceptionCode],ecx
        mov     dword ptr [eax.ErNumberParameters], 0
        mov     dword ptr [eax.ErExceptionRecord], 0
        mov     dword ptr [eax.ErExceptionFlags], EXCEPTION_NONCONTINUABLE

;
; _RtlDispatchException(ExceptionRecord, ContextRecord)
;

        lea     ecx,[ebp-ContextFrameLength-4]  ; (eax) -> Context record

; ecx - Context record
; eax - Exception record
        stdCall _RtlDispatchException, <eax, ecx>

;
; An unwind was not initiated during the dispatching of a noncontinuable
; exception. Give the kernel debugger a chance to handle the exception.
;

;
; _ZwRaiseException(ExceptionRecord, ContextRecord, FirstChance=TRUE)
;

        lea     ecx,[ebp-ContextFrameLength-4]  ; (eax) -> Context record
        lea     eax,[ebp-ContextFrameLength-ExceptionRecordLength-4]
; 1 - TRUE
; ecx - Context Record
; eax - Exception Report Record
        stdCall   _ZwRaiseException, <eax, ecx, 1>

;
; We came back, suggesting some sort of error in the call.  Raise
; a status exception to report this, return from ZwRaiseException is type.
;

        stdCall    _ExRaiseStatus, <eax>


stdENDP _ExRaiseStatus

_TEXT$01   ends
        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\ia64\wowinfo.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    wowinfo.c

Abstract:

    This module implements the routines to returns processor-specific information
    about the x86 emulation capability.

Author:

    Samer Arafeh (samera) 14-Nov-2000

Environment:

    Kernel Mode.

Revision History:

--*/

#include "exp.h"

NTSTATUS
ExpGetSystemEmulationProcessorInformation (
    OUT PSYSTEM_PROCESSOR_INFORMATION ProcessorInformation
    )

/*++

Routine Description:

    Retreives the processor information of the emulation hardware.

Arguments:

    ProcessorInformation - Pointer to receive the processor's emulation information.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    //  Intel Pentium Family 6, Model 2, Stepping 12
    //

    try {

        ProcessorInformation->ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
        ProcessorInformation->ProcessorLevel = 5;
        ProcessorInformation->ProcessorRevision = 0x020c;
        ProcessorInformation->Reserved = 0;
        ProcessorInformation->ProcessorFeatureBits = KeFeatureBits;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        
        NtStatus = GetExceptionCode ();
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\ia64\hifreqlk.s ===
//       TITLE("High Frequency Spin Locks")
//++
//
// Module Name:
//
//    hifreqlk.s
//
// Abstract:
//
//    This module contains storage for high frequency spin locks. Each
//    is allocated to a separate cache line.
//
// Author:
//
//    William K. Cheung (wcheung) 29-Sep-1995
//
//    based on David N. Cutler (davec) 25-Jun-1993
//
// Environment:
//
//    Kernel mode.
//
// Revision History:
//
//--

#include "ksia64.h"

#if defined(NT_UP)

#define ALIGN .##align 8
#define ALIGN_SLIST .##align 16

#else

#define ALIGN .##align 128
#define ALIGN_SLIST ALIGN

#endif

#define SPIN_LOCK data8  0

        .sdata
        ALIGN
        SPIN_LOCK

        .global    AfdWorkQueueSpinLock
        ALIGN
AfdWorkQueueSpinLock:                          // AFD work queue lock
        SPIN_LOCK

        .global    CcBcbSpinLock
        ALIGN
CcBcbSpinLock:                                 // cache manager BCB lock
        SPIN_LOCK

        .global    CcMasterSpinLock
        ALIGN
CcMasterSpinLock:                              // cache manager master lock
        SPIN_LOCK

        .global    CcVacbSpinLock
        ALIGN
CcVacbSpinLock:                                // cache manager VACB lock
        SPIN_LOCK

        .global    ExpResourceSpinLock
        ALIGN
ExpResourceSpinLock:                           // resource package lock
        SPIN_LOCK

        .global    IopCancelSpinLock
        ALIGN
IopCancelSpinLock:                             // I/O cancel lock
        SPIN_LOCK

        .global    IopCompletionLock
        ALIGN
IopCompletionLock:                             // I/O completion lock
        SPIN_LOCK

        .global    IopDatabaseLock
        ALIGN
IopDatabaseLock:                               // I/O database lock
        SPIN_LOCK

        .global    IopVpbSpinLock
        ALIGN
IopVpbSpinLock:                                // I/O VPB lock
        SPIN_LOCK

        .global    IoStatisticsLock
        ALIGN
IoStatisticsLock:                              // I/O statistics lock
        SPIN_LOCK

        .global    KiContextSwapLock
        ALIGN
KiContextSwapLock:                             // context swap lock
        SPIN_LOCK

        .global    KiDispatcherLock
        ALIGN
KiDispatcherLock:                              // dispatcher database lock
        SPIN_LOCK

        .global    MmPfnLock
        ALIGN
MmPfnLock:                                     // page frame database lock
        SPIN_LOCK

        .global    NonPagedPoolLock
        ALIGN
NonPagedPoolLock:                              // nonpage pool allocation lock
        SPIN_LOCK

        .global    NtfsStructLock
        ALIGN
NtfsStructLock:                               // NTFS structure lock
        SPIN_LOCK

//
// IopLookasideIrpFloat - This is the number of IRPs that are currently
//      in progress that were allocated from a lookaside list.
//

        .global    IopLookasideIrpFloat;
        ALIGN
IopLookasideIrpFloat:
        data4      0

//
// IopLookasideIrpLimit - This is the maximum number of IRPs that can be
//      in progress that were allocated from a lookaside list.
//

        .global    IopLookasideIrpLimit;
IopLookasideIrpLimit:
        data4      0


//
// The following fields are updated rarely.
//

        ALIGN
        .global    KiMasterSequence            // master sequence number
KiMasterSequence:
        data8      START_SEQUENCE

        .global    KiMasterRid                 // master region ID
KiMasterRid:
        data4      START_PROCESS_RID

//
// KeTickCount - This is the number of clock ticks that have occurred since
//      the system was booted. This count is used to compute a millisecond
//      tick counter.
//

        ALIGN
        .global    KeTickCount
KeTickCount:                                   //
        data8      0

//
// KiTickOffset - This is the number of 100ns units remaining before a tick
//      is added to the tick count and the system time is updated.
//

        .global    KiTickOffset
KiTickOffset:                                  //
        data4     0

//
// The following fields are static for the life of the system.
//

        .global    KiSynchIrql
KiSynchIrql:                                   // synchronization IRQL
        data4      SYNCH_LEVEL                 //

//
// KeMaximumIncrement - This is the maximum time between clock interrupts
//      in 100ns units that is supported by the host HAL.
//

        .global    KeMaximumIncrement
KeMaximumIncrement:                            //
        data4     0

//
// KeTimeAdjustment - This is the actual number of 100ns units that are to
//      be added to the system time at each interval timer interupt. This
//      value is copied from KeTimeIncrement at system start up and can be
//      later modified via the set system information service.
//      timer table entries.
//

        .global    KeTimeAdjustment
KeTimeAdjustment:                              //
        data4     0

//
// KiMaximumDpcQueueDepth - This is used to control how many DPCs can be
//      queued before a DPC of medium importance will trigger a dispatch
//      interrupt.
//

         ALIGN
        .global    KiMaximumDpcQueueDepth
KiMaximumDpcQueueDepth:                        //
        data4     4

//
// KiMinimumDpcRate - This is the rate of DPC requests per clock tick that
//      must be exceeded before DPC batching of medium importance DPCs
//      will occur.
//

        .global    KiMinimumDpcRate
KiMinimumDpcRate:                              //
        data4     3

//
// KiAdjustDpcThreshold - This is the threshold used by the clock interrupt
//      routine to control the rate at which the processor's DPC queue depth
//      is dynamically adjusted.
//

        .global    KiAdjustDpcThreshold
KiAdjustDpcThreshold:                          //
        data4     20

//
// KiIdealDpcRate - This is used to control the aggressiveness of the DPC
//      rate adjusting algorithm when decrementing the queue depth. As long
//      as the DPC rate for the last tick is greater than this rate, the
//      DPC queue depth will not be decremented.
//

        .global    KiIdealDpcRate
KiIdealDpcRate:                                //
        data4     20

//
// KiTbFlushTimeStamp - This is the TB flush entire time stamp counter.
//

        ALIGN
        .global    KiTbFlushTimeStamp
KiTbFlushTimeStamp:                           //
        data4     0

//
// The following data is frequently updated together and always
// under the ownership of the dispatcher database lock.
//

        ALIGN
        .global    KiIdleSummary
KiIdleSummary:
        data8      0

        .global    KiReadySummary
KiReadySummary:
        data8      0

        .global    PoSleepingSummary
PoSleepingSummary:
        data8      0

//
// MmPfnDereferenceSListHead - This is used to store free blocks used for
//      deferred PFN reference count releasing.
//

        ALIGN_SLIST
        .global    MmPfnDereferenceSListHead
MmPfnDereferenceSListHead:
        data8      0
        data8      0

//
// MmPfnDeferredList - This is used to queue items that need reference count
//      decrement processing.
//

         ALIGN
        .global    MmPfnDeferredList
MmPfnDeferredList:
        data8      0

//
// MmSystemLockPagesCount - This is the count of the number of locked pages
//      in the system. 
//

        ALIGN
        .global    MmSystemLockPagesCount
MmSystemLockPagesCount:
        data8      0

        ALIGN
        data8      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\ia64\gettick.s ===
//++
//
// Module Name:
//
//     gettick.s
//
// Abstract:
//
//    This module implements the system service that returns the number
//    of milliseconds since the system was booted.
//
// Author:
//
//    William K. Cheung (wcheung) 25-Sep-95
//
// Revision History:
//
//    02-Feb-96    Updated to EAS2.1
//
//--

#include "ksia64.h"

        .file       "gettick.s"

        .global    KeTickCount
        .global    ExpTickCountMultiplier

//++
//
// ULONG
// NtGetTickCount (
//    VOID
//    )
//
// Routine Description:
//
//    This function computes the number of milliseconds since the system
//    was booted. The computation is performed by multiplying the clock
//    interrupt count by a scaled fixed binary multiplier and then right
//    shifting the 64-bit result to extract the 32-bit millisecond count.
//
//    The multiplier fraction is scaled by 24 bits. Thus for a 100 Hz clock
//    rate, there are 10 ticks per millisecond, and the multiplier is
//    0x0a000000 (10 << 24). For a 128 Hz clock rate, there are 7.8125, or
//    7 13/16 ticks per millisecond, and so the multiplier is 0x07d00000.
//
//    This effectively replaces a (slow) divide instruction with a (fast)
//    multiply instruction. The multiplier value is only calculated once
//    based on the TimeIncrement value (clock tick interval in 100ns units).
//
//    N.B. The tick count value wraps every 2^32 milliseconds (49.71 days).
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    The number of milliseconds since the system was booted is returned
//    as the function value.
//
//--

        LEAF_ENTRY(NtGetTickCount)

//
// load zero-extended operands
//

        add         t0 = @gprel(KeTickCount), gp
        add         t1 = @gprel(ExpTickCountMultiplier), gp
        ;;

        ld4         t2 = [t0]
        ld4         t3 = [t1]
        ;;

//
// compute 64-bit product
//

        setf.sig    fs2 = t2
        setf.sig    fs3 = t3
        ;;
        xmpy.lu     fs1 = fs2, fs3
        ;;

//
// shift off 24-bit fraction part and 
// the 32-bit canonical ULONG integer part.
//

        getf.sig    v0 = fs1
        ;;
        extr.u      v0 = v0, 24, 32

        br.ret.sptk.clr brp                    // return

        LEAF_EXIT(NtGetTickCount)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\i386\tickcnt.asm ===
title  "NtGetTickCount"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    tickcnt.asm
;
; Abstract:
;
;
;    This module contains the implementation for the fast NtGetTickCount service
;
;
; Author:
;
;    Mark Lucovsky (markl) 19-Oct-1996
;
; Environment:
;
;    Kernel mode.
;
; Revision History:
;
;
;--
.386p
;        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
;        .list

extrn   _KeTickCount:DWORD
extrn   _ExpTickCountMultiplier:DWORD

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132

;++
;
; Routine Description:
;
;     This function returns number of milliseconds since the system
;     booted.  This function is designed to support the Win32 GetTicKCount
;     API.
;
; Arguments:
;
;     NONE
;
; Return Value:
;
;     Returns the number of milliseconds that have transpired since boot
;
;--

cPublicProc _NtGetTickCount, 0
cPublicFpo 0, 0

        mov     eax,dword ptr [_KeTickCount]
        mul     dword ptr [_ExpTickCountMultiplier]
        shrd    eax,edx,24                  ; compute resultant tick count

        stdRET  _NtGetTickCount
stdENDP _NtGetTickCount

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\ia64\gettickc.c ===
//++
//
// Module Name:
//
//     gettickc.c
//
// Abstract:
//
//    This module implements the system service that returns the number
//    of milliseconds since the system was booted.
//
// Author:
//
//    Bernard Lint
//
// Revision History:
//
//    Based on gettick.s (wcheung)
//
//--

#include "exp.h"
#undef NtGetTickCount

ULONG
NtGetTickCount (
   VOID
   )

/*++

Routine Description:

    This function computes the number of milliseconds since the system
    was booted. The computation is performed by multiplying the clock
    interrupt count by a scaled fixed binary multiplier and then right
    shifting the 64-bit result to extract the 32-bit millisecond count.

    The multiplier fraction is scaled by 24 bits. Thus for a 100 Hz clock
    rate, there are 10 ticks per millisecond, and the multiplier is
    0x0a000000 (10 << 24). For a 128 Hz clock rate, there are 7.8125, or
    7 13/16 ticks per millisecond, and so the multiplier is 0x07d00000.

    This effectively replaces a (slow) divide instruction with a (fast)
    multiply instruction. The multiplier value is only calculated once
    based on the TimeIncrement value (clock tick interval in 100ns units).

    N.B. The tick count value wraps every 2^32 milliseconds (49.71 days).

Arguments:

    None.

Return Value:

    The number of milliseconds since the system was booted is returned
    as the function value.

--*/

{
    ULONGLONG Product;

    //
    // compute unsigned 64-bit product
    //

    Product = KeTickCount.QuadPart * ExpTickCountMultiplier;

    //
    // shift off 24-bit fraction part and
    // return the 32-bit canonical ULONG integer part.
    //

    return ((ULONG)(Product >> 24));
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\ia64\fmutex.s ===
//      TITLE("Fast Mutex Support")
//++
//
// Module Name:
//
//    fmutex.s
//
// Abstract:
//
//    This module implements the code necessary to acquire and release fast
//    mutxes.
//
//
// Author:
//
//    William K. Cheung (wcheung) 02-Oct-1995
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//    08-Feb-96    Updated to EAS2.1
//
//--

#include "ksia64.h"

        .file "fmutex.s"

        PublicFunction(KeWaitForSingleObject)
        PublicFunction(KeSetEventBoostPriority)
        PublicFunction(KiCheckForSoftwareInterrupt)

//++
//
// VOID
// ExAcquireFastMutex (
//    IN PFAST_MUTEX FastMutex
//    )
//
// Routine Description:
//
//    This function acquires ownership of a fast mutex and raises IRQL to
//    APC Level. Must be called at IRQL < DISPATCH_LEVEL.
//
// Arguments:
//
//    FastMutex (a0) - Supplies a pointer to a fast mutex.
//
// Return Value:
//
//    None.
//
//--

//
// t0  -- Original value of Fmutex.FmCount
// t1  -- Address of Fmutex.FmCount
// t2  -- Address of Fmutex.FmOldIrql
// t3  -- Address of KiPcr
// t4  -- Address of Fmutex.FmContention
// t8  -- Address of KiPcr.PcCurrentThread
// r35 -- old IRQL
//
// t5  -- temp
//

        NESTED_ENTRY(ExAcquireFastMutex)

        .regstk     1, 4, 5, 0
        .prologue   0xC, savedpfs

        alloc       savedpfs = ar.pfs, 1, 4, 5, 0
        add         loc3 = FmOwner, a0
        mov         savedbrp = brp
        GET_IRQL    (loc2)                      // Get old IRQL

        PROLOGUE_END

        mov         t4 = APC_LEVEL
        add         t1 = FmCount, a0
        add         t2 = FmOldIrql, a0
        ;;
        SET_IRQL    (t4)                 // change IRQL to APC_LEVEL
        ;;

        //
        // synchronize subsequent reads
        //

        fetchadd4.acq t0 = [t1], -1             // decrement mutex count
        add         t4 = FmContention, a0
        add         out0 = FmEvent, a0

        mov         out1 = Executive            // set reason for wait
        mov         out2 = KernelMode           // set mode of wait
        ;;

        cmp4.le     pt7, pt8 = t0, zero         // if le, mutex acq failed
        mov         out3 = FALSE                // set nonalertable wait
        mov         out4 = zero                 // set NULL timeout pointer
        ;;

  (pt7) ld4         t5 = [t4]                   // load contention count
  (pt8) st8         [loc3] = sp                 // Save the SP so we can identify the owner.
  (pt8) st4         [t2] = loc2                 // save old IRQL
  (pt8) br.ret.sptk.clr brp                     // return
        ;;

Eafm10:

  (pt7) add         t5 = 1, t5                  // inc contention count
        ;;
        st4         [t4] = t5                   // save contention count
        br.call.sptk.many brp = KeWaitForSingleObject

        add         t2 = FmOldIrql, a0
        mov         ar.pfs = savedpfs           // restore pfs
        mov         brp = savedbrp              // restore brp
        ;;

        st4         [t2] = loc2                 // save old IRQL
        st8         [loc3] = sp                 // Save the SP so we can identify the owner.
        br.ret.sptk.clr brp                     // return

        NESTED_EXIT(ExAcquireFastMutex)

//++
//
// VOID
// ExReleaseFastMutex (
//    IN PFAST_MUTEX FastMutex
//    )
//
// Routine Description:
//
//    This function releases ownership to a fast mutex and lowers IRQL to
//    its previous level.
//
// Arguments:
//
//    FastMutex (a0) - Supplies a pointer to a fast mutex.
//
// Return Value:
//
//    None.
//
//--

        NESTED_ENTRY(ExReleaseFastMutex)
  
        NESTED_SETUP(1, 3, 2, 0)
        add         t1 = FmCount, a0

        PROLOGUE_END

//
// Increment mutex count and release waiter if contention.
//

        //
        // use release semantics to synchronize all previous writes
        //
        add         t2 = FmOldIrql, a0
        ;;

        ld4         loc2 = [t2]                 // get old IRQL before releasing lock
        fetchadd4.rel t9 = [t1], 1              // increment mutex count
        add         out0 = FmEvent, a0
        ;;

        cmp4.eq     pt1, pt0 = zero, t9         // if eq, no waiter
        mov         out1 = zero
 (pt0)  br.call.spnt.many brp = KeSetEventBoostPriority
        ;;
        
        LOWER_IRQL  (loc2)
        NESTED_RETURN

        NESTED_EXIT(ExReleaseFastMutex)

//++
//
// BOOLEAN
// ExTryToAcquireFastMutex (
//    IN PFAST_MUTEX FastMutex
//    )
//
// Routine Description:
//
//    This function attempts to acquire ownership of a fast mutex, and if
//    successful, raises IRQL to APC level.
//
// Arguments:
//
//    FastMutex (a0) - Supplies a pointer to a fast mutex.
//
// Return Value:
//
//    If the fast mutex was successfully acquired, then a value of TRUE
//    is returned as the function value. Otherwise, a valye of FALSE is
//    returned.
//
//--

        LEAF_ENTRY(ExTryToAcquireFastMutex)

        mov         t4 = APC_LEVEL
        add         t1 = FmCount, a0
        add         t2 = FmOldIrql, a0
        add         t6 = FmOwner, a0   
        GET_IRQL    (t0)                       // get old IRQL
        SET_IRQL    (t4)                       // change IRQL to APC_LEVEL
        ;;

        ld4         t4 = [t1]
        ;;
        mov         ar.ccv = t4
        cmp4.le     pt8, pt7 = t4, zero        // if le, mutex acq failed

        add         t5 = -1, t4
        mov         v0 = TRUE                  // return TRUE by default
  (pt8) br.spnt.few Ettafm10
        ;;

        //
        // use acquire semantics to sychronize subsequent reads
        //

        cmpxchg4.acq t4 = [t1], t5, ar.ccv
        ;;
        cmp4.le     pt8, pt7 = t4, zero        // if le, mutex acq failed
        ;;
        
Ettafm10:

        PSET_IRQL   (pt8, t0)                  // restore IRQL        
  (pt7) st4         [t2] = t0                  // save old IRQL
  (pt8) mov         v0 = FALSE                 // return FALSE
  (pt7) st8         [t6] = sp                  // Save the SP so we can identify the owner.                               
        br.ret.sptk.clr brp                    // return

        LEAF_EXIT(ExTryToAcquireFastMutex)

//++
//
// VOID
// ExAcquireFastMutexUnsafe (
//    IN PFAST_MUTEX FastMutex
//    )
//
// Routine Description:
//
//    This function acquires ownership of a fast mutex, but does not raise
//    IRQL to APC Level.
//
// Arguments:
//
//    FastMutex (a0) - Supplies a pointer to a fast mutex.
//
// Return Value:
//
//    None.
//
//--

        NESTED_ENTRY(ExAcquireFastMutexUnsafe)

        NESTED_SETUP(1, 3, 5, 0)
        add         t1 = FmCount, a0
        ;;

        PROLOGUE_END

        //
        // Use acquire semantics to synchronize subsequent reads
        //

        fetchadd4.acq t0 = [t1], -1             // decrement mutex count
        add         out0 = FmEvent, a0

        add         t3 = FmContention, a0
        add         loc2 = FmOwner, a0
        mov         out1 = Executive            // set reason for wait
        mov         out2 = KernelMode           // set mode of wait
        ;;

        cmp4.le     p0, pt8 = t0, zero          // if le, contention
        mov         out3 = FALSE                // set nonalertable wait
        ;;
  (pt8) st8         [loc2] = sp                 // Save the SP so we can identify the owner.
  (pt8) br.ret.sptk.clr brp                     // return

//
// Increment the contention count and then call KeWaitForSingleObject().
// The outgoing arguments have been set up ahead of time.
//

        ld4         t4 = [t3]                   // get contention count
        ;;
        add         t4 = 1, t4                  // increment contention count
        mov         out4 = 0                    // set NULL timeout pointer
        ;;

        st4         [t3] = t4                   // save contention count
        br.call.sptk.many brp = KeWaitForSingleObject
  
        mov         ar.pfs = savedpfs           // restore pfs
        mov         brp = savedbrp              // restore return link
        st8         [loc2] = sp                 // Save the sp of the owner      
        br.ret.sptk.clr brp                     // return

        NESTED_EXIT(ExAcquireFastMutexUnsafe)

//++
//
// VOID
// ExReleaseFastMutexUnsafe (
//    IN PFAST_MUTEX FastMutex
//    )
//
// Routine Description:
//
//    This function releases ownership to a fast mutex, and does not
//    restore IRQL to its previous level.
//
// Arguments:
//
//    FastMutex (a0) - Supplies a pointer to a fast mutex.
//
// Return Value:
//
//    None.
//
//--

        NESTED_ENTRY(ExReleaseFastMutexUnsafe)
  
        NESTED_SETUP(1, 2, 2, 0)
        add         t1 = FmCount, a0
        ;;

        PROLOGUE_END

//
// Increment mutex count and release waiter if contention.
//

        //
        // Use release semantics to syncrhonize all previous writes
        // before the mutext is released.
        //

        fetchadd4.rel t9 = [t1], 1              // increment mutex count
        ;;
        add         out0 = FmEvent, a0
        cmp4.eq     pt7, pt8 = zero, t9         // if eq, no waiter

        add         out1 = zero, zero
  (pt7) br.ret.sptk.clr brp                     // return
  (pt8) br.call.spnt.many brp = KeSetEventBoostPriority

        mov         ar.pfs = savedpfs
        mov         brp = savedbrp
        br.ret.sptk.clr brp                     // return

        NESTED_EXIT(ExReleaseFastMutexUnsafe)


//++
//
// BOOLEAN
// ExTryToAcquireFastMutexUnsafe (
//    IN PFAST_MUTEX FastMutex
//    )
//
// Routine Description:
//
//    This function attempts to acquire ownership of a fast mutex, and if
//    successful, does not raise IRQL to APC level.
//
// Arguments:
//
//    FastMutex (a0) - Supplies a pointer to a fast mutex.
//
// Return Value:
//
//    If the fast mutex was successfully acquired, then a value of TRUE
//    is returned as the function value. Otherwise, a valye of FALSE is
//    returned.
//
//--

#if 0
         LEAF_ENTRY(ExTryToAcquireFastMutexUnsafe)


         LEAF_EXIT(ExTryToAcquireFastMutexUnsafe)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\ia64\intrlock.s ===
//++
//
// Module Name:
//
//     intrlock.s
//
// Abstract:
//
//    This module implements the functions to support interlocked
//    operations.  Interlocked operations can only operate on
//    nonpaged data and the specified spinlock cannot be used for
//    any other purpose.
//
// Author:
//
//    William K. Cheung (wcheung) 27-Sep-95
//
// Revision History:
//
//    07-Jul-97  bl    Updated to EAS2.3
//
//    02-Feb-96        Updated to EAS2.1
//
//--

#include "ksia64.h"

         .file    "intrlock.s"


//++
//
// LARGE_INTEGER
// ExInterlockedAddLargeInteger (
//    IN PLARGE_INTEGER Addend,
//    IN LARGE_INTEGER Increment,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function performs an interlocked add of an increment value to an
//    addend variable of type large integer. The initial value of the addend
//    variable is returned as the function value.
//
// Arguments:
//
//    Addend (a0) - Supplies a pointer to a variable whose value is to be
//       adjusted by the increment value.
//
//    Increment (a1) - Supplies the increment value to be added to the
//       addend variable.
//
//    Lock (a2) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the addend variable.
//
// Return Value:
//
//    The initial value of the addend variable is stored at the address
//    supplied by v0.
//
//--


#if !defined(NT_UP)

        LEAF_ENTRY(ExInterlockedAddLargeInteger)

//
// disable interrupt and then acquire the spinlock
//

        rsm         1 << PSR_I                  // disable interrupt
        cmp.eq      pt0, pt1 = zero, zero
        cmp.eq      pt2 = zero, zero
        ;;

Eiali10:
.pred.rel "mutex",pt0,pt1
(pt0)   xchg8       t0 = [a2], a2
(pt1)   ld8.nt1     t0 = [a2]
        ;;
(pt0)   cmp.ne      pt2 = zero, t0
        cmp.eq      pt0, pt1 = zero, t0
        ;;
(pt1)   ssm         1 << PSR_I                  // enable interrupt
(pt0)   rsm         1 << PSR_I                  // disable interrupt
(pt2)   br.dpnt     Eiali10
        ;;

        ld8         v0 = [a0]
        ;;
        add         t1 = a1, v0                 // do the add
        ;;

        st8         [a0] = t1                   // save result
        st8.rel.nta [a2] = zero                 // release spinlock

        ssm         1 << PSR_I                  // enable interrupt
        br.ret.sptk.clr brp                     // return
        ;;

        LEAF_EXIT(ExInterlockedAddLargeInteger)

#else

        LEAF_ENTRY(ExInterlockedAddLargeInteger)

        rsm         1 << PSR_I                  // disable interrupt
        ;;
        ld8.acq     v0 = [a0]
        ;;

        add         t0 = a1, v0
        ;;
        st8.rel     [a0] = t0
        ssm         1 << PSR_I                  // enable interrupt
        br.ret.sptk brp
        ;;

        LEAF_EXIT(ExInterlockedAddLargeInteger)

#endif // !defined(NT_UP)


//++
//
// VOID
// ExInterlockedAddLargeStatistic (
//    IN PLARGE_INTEGER Addend,
//    IN ULONG Increment
//    )
//
// Routine Description:
//
//    This function performs an interlocked add of an increment value to an
//    addend variable of type large integer.
//
// Arguments:
//
//    Addend (a0) - Supplies a pointer to a variable whose value is to be
//       adjusted by the increment value.
//
//    Increment (a1) - Supplies the increment value to be added to the
//       addend variable.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(ExInterlockedAddLargeStatistic)

        ld8.nt1     v0 = [a0]
        extr.u      a1 = a1, 0, 32              // sanitize the top 32 bits
        ;;

Eials10:
        nop.m       0
        mov         ar.ccv = v0
        add         t0 = a1, v0
        ;;

//
// If the addend has been modified since the last load, pt8 will be set
// to TRUE and need to branch back to Eiali10 to retry the operation again.
//

        cmpxchg8.rel t1 = [a0], t0, ar.ccv
        ;;
        cmp.ne      pt8, pt7 = v0, t1
        mov         v0 = t1
        ;;

        nop.m       0
 (pt8)  br.cond.spnt Eials10                    // if failed, then try again
 (pt7)  br.ret.sptk.clr brp                     // otherwise, return
        ;;

        LEAF_EXIT(ExInterlockedAddLargeStatistic)


//++
//
// ULONG
// ExInterlockedAddUlong (
//    IN PULONG Addend,
//    IN ULONG Increment,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function performs an interlocked add of an increment value to an
//    addend variable of type unsigned long. The initial value of the addend
//    variable is returned as the function value.
//
// Arguments:
//
//    Addend (a0) - Supplies a pointer to a variable whose value is to be
//       adjusted by the increment value.
//
//    Increment (a1) - Supplies the increment value to be added to the
//       addend variable.
//
//    Lock (a2) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the addend variable.
//
// Return Value:
//
//    The initial value of the addend variable.
//
//--


#if !defined(NT_UP)

        LEAF_ENTRY(ExInterlockedAddUlong)

//
// disable interrupt and then acquire the spinlock
//

        rsm         1 << PSR_I                  // disable interrupt
        zxt4        a1 = a1                     // sanitize the top 32 bits

        cmp.eq      pt0, pt1 = zero, zero
        cmp.eq      pt2 = zero, zero
        ;;

Eiau10:
.pred.rel "mutex",pt0,pt1
(pt0)   xchg8       t0 = [a2], a2
(pt1)   ld8.nt1     t0 = [a2]
        ;;
(pt0)   cmp.ne      pt2 = zero, t0
        cmp.eq      pt0, pt1 = zero, t0
        ;;
(pt1)   ssm         1 << PSR_I                  // enable interrupt
(pt0)   rsm         1 << PSR_I                  // disable interrupt
(pt2)   br.dpnt     Eiau10
        ;;

//
// lock acquired; load the addend, perform the addition and write it back.
// then release the lock and enable interrupts.
//

        ld4         v0 = [a0]
        ;;
        add         t0 = a1, v0                 // do the add
        ;;

        st4         [a0] = t0                   // save result
        st8.rel.nta [a2] = zero                 // release spinlock

        ssm         1 << PSR_I                  // enable interrupt
        br.ret.sptk.clr brp                     // return

        LEAF_EXIT(ExInterlockedAddUlong)

#else

        LEAF_ENTRY(ExInterlockedAddUlong)

        rsm         1 << PSR_I                  // disable interrupt
        ;;
        ld4.acq     v0 = [a0]
        zxt4        a1 = a1                     // sanitize the top 32 bits
        ;;
        add         t0 = a1, v0
        ;;
        st4.rel     [a0] = t0
        ssm         1 << PSR_I                  // enable interrupt
        br.ret.sptk brp
        ;;

        LEAF_EXIT(ExInterlockedAddUlong)

#endif // !defined(NT_UP)


//++
//
// ULONG
// ExInterlockedExchangeUlong (
//    IN PULONG Source,
//    IN ULONG Value,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function performs an interlocked exchange of a longword value with
//    a longword in memory and returns the memory value.
//
//    N.B. There is an alternate entry point provided for this routine which
//         is IA64 target specific and whose prototype does not include the
//         spinlock parameter. Since the routine never refers to the spinlock
//         parameter, no additional code is required.
//
// Arguments:
//
//    Source (a0) - Supplies a pointer to a variable whose value is to be
//       exchanged.
//
//    Value (a1) - Supplies the value to exchange with the source value.
//
//    Lock (a2) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the source variable.
//
// Return Value:
//
//    The source value is returned as the function value.
//
// Implementation Note:
//
//    The specification of this function does not require that the given lock
//    be used to synchronize the update as long as the update is synchronized
//    somehow. On Alpha a single load locked-store conditional does the job.
//
//--

        LEAF_ENTRY(ExInterlockedExchangeUlong)
        ALTERNATE_ENTRY(ExIa64InterlockedExchangeUlong)

        mf
        zxt4        a1 = a1          // sanitize the upper 32 bits
        ;;

        xchg4       v0 = [a0], a1
        br.ret.sptk.clr brp

        LEAF_EXIT(ExInterlockedExchangeUlong)

//++
//
// LONG
// InterlockedExchangeAdd (
//     IN OUT PLONG Addend,
//     IN LONG Increment
//     )
//
// Routine Description:
//
//     This function performs an interlocked add of an increment value to an
//     addend variable of type unsinged long. The initial value of the addend
//     variable is returned as the function value.
//
//         It is NOT possible to mix ExInterlockedDecrementLong and
//         ExInterlockedIncrementong with ExInterlockedAddUlong.
//
//
// Arguments:
//
//     Addend - Supplies a pointer to a variable whose value is to be
//         adjusted by the increment value.
//
//     Increment - Supplies the increment value to be added to the
//         addend variable.
//
// Return Value:
//
//     (r8) - The initial value of the addend.
//
//--

        LEAF_ENTRY(InterlockedExchangeAdd)

        ld4.nt1     v0 = [a0]
        ;;

Iea10:
        mov         ar.ccv = v0
        add         t1 = a1, v0
        mov         t0 = v0
        ;;

        cmpxchg4.acq v0 = [a0], t1, ar.ccv
        nop.m       0
        nop.i       0
        ;;

        cmp.ne      pt7, pt8 = v0, t0
(pt7)   br.cond.spnt Iea10
(pt8)   br.ret.sptk.clr brp
        ;;

        LEAF_EXIT(InterlockedExchangeAdd)


//++
//
// PVOID
// InterlockedCompareExchange (
//     IN OUT PVOID *Destination,
//     IN PVOID Exchange,
//     IN PVOID Comperand
//     )
//
// Routine Description:
//
//     This function performs an interlocked compare of the destination
//     value with the comperand value. If the destination value is equal
//     to the comperand value, then the exchange value is stored in the
//     destination. Otherwise, no operation is performed.
//
// Arguments:
//
//     Destination - Supplies a pointer to destination value.
//
//     Exchange - Supplies the exchange value.
//
//     Comperand - Supplies the comperand value.
//
// Return Value:
//
//     (r8) - The initial destination value.
//
//--

        LEAF_ENTRY(InterlockedCompareExchange)

        mf
        mov         ar.ccv = a2
        ;;

        cmpxchg4.acq v0 = [a0], a1, ar.ccv
        br.ret.sptk.clr brp
        ;;

        LEAF_EXIT(InterlockedCompareExchange)


//++
//
// INTERLOCKED_RESULT
// ExInterlockedDecrementLong (
//    IN PLONG Addend,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function performs an interlocked decrement on an addend variable
//    of type signed long. The sign and whether the result is zero is returned
//    as the function value.
//
//    N.B. There is an alternate entry point provided for this routine which
//         is IA64 target specific and whose prototype does not include the
//         spinlock parameter. Since the routine never refers to the spinlock
//         parameter, no additional code is required.
//
// Arguments:
//
//    Addend (a0) - Supplies a pointer to a variable whose value is to be
//       decremented.
//
//    Lock (a1) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the addend variable.
//
// Return Value:
//
//    RESULT_NEGATIVE is returned if the resultant addend value is negative.
//    RESULT_ZERO is returned if the resultant addend value is zero.
//    RESULT_POSITIVE is returned if the resultant addend value is positive.
//
//        RESULT_ZERO = 0
//        RESULT_NEGATIVE = 1
//        RESULT_POSITIVE = 2
//
// Implementation Notes:
//
//    The specification of this function does not require that the given lock
//    be used to synchronize the update as long as the update is synchronized
//    somehow. On Alpha a single load locked-store conditional does the job.
//
//--

        LEAF_ENTRY(ExInterlockedDecrementLong)
        ALTERNATE_ENTRY(ExIa64InterlockedDecrementLong)

        fetchadd4.acq t1 = [a0], -1
        mov         v0 = 0                      // assume result is zero
        ;;

        cmp4.le     pt7, p0 = 2, t1
        cmp4.ge     pt8, p0 = 0, t1
        ;;
.pred.rel "mutex",pt7,pt8
  (pt8) mov         v0 = 1                      // negative result
  (pt7) mov         v0 = 2                      // positive result
        br.ret.sptk.clr brp                     // return
        ;;

        LEAF_EXIT(ExInterlockedDecrementLong)


//++
//
// INTERLOCKED_RESULT
// ExInterlockedIncrementLong (
//    IN PLONG Addend,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function performs an interlocked increment on an addend variable
//    of type signed long. The sign and whether the result is zero is returned
//    as the function value.
//
//    N.B. There is an alternate entry point provided for this routine which
//         is IA64 target specific and whose prototype does not include the
//         spinlock parameter. Since the routine never refers to the spinlock
//         parameter, no additional code is required.
//
// Arguments:
//
//    Addend (a0) - Supplies a pointer to a variable whose value is to be
//       incremented.
//
//    Lock (a1) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the addend variable.
//
// Return Value:
//
//    RESULT_NEGATIVE is returned if the resultant addend value is negative.
//    RESULT_ZERO is returned if the resultant addend value is zero.
//    RESULT_POSITIVE is returned if the resultant addend value is positive.
//
// Implementation Notes:
//
//    The specification of this function does not require that the given lock
//    be used to synchronize the update as long as the update is synchronized
//    somehow. On Alpha a single load locked-store conditional does the job.
//
//--

        LEAF_ENTRY(ExInterlockedIncrementLong)
        ALTERNATE_ENTRY(ExIa64InterlockedIncrementLong)

        fetchadd4.acq t1 = [a0], 1
        mov         v0 = 0                      // assume result is zero
        ;;

        cmp4.le     pt7, p0 = 0, t1
        cmp4.ge     pt8, p0 = -2, t1
        ;;
.pred.rel "mutex",pt7,pt8
  (pt8) mov         v0 = 1                      // negative result
  (pt7) mov         v0 = 2                      // positive result
        br.ret.sptk.clr brp                     // return
        ;;

        LEAF_EXIT(ExInterlockedIncrementLong)


//++
//
// PLIST_ENTRY
// ExInterlockedInsertHeadList (
//    IN PLIST_ENTRY ListHead,
//    IN PLIST_ENTRY ListEntry,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function inserts an entry at the head of a doubly linked list
//    so that access to the list is synchronized in a multiprocessor system.
//
// Arguments:
//
//    ListHead (a0) - Supplies a pointer to the head of the doubly linked
//       list into which an entry is to be inserted.
//
//    ListEntry (a1) - Supplies a pointer to the entry to be inserted at the
//       head of the list.
//
//    Lock (a2) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the list.
//
// Return Value:
//
//    Pointer to entry that was at the head of the list or NULL if the list
//    was empty.
//
//--

        LEAF_ENTRY(ExInterlockedInsertHeadList)

//
// disable interrupt and then try to acquire the spinlock
//

        add         t3 = LsFlink, a0
        add         t5 = LsBlink, a1
        add         t4 = LsFlink, a1

        rsm         1 << PSR_I                  // disable interrupt
#if !defined(NT_UP)

        cmp.eq      pt0, pt1 = zero, zero
        cmp.eq      pt2 = zero, zero
        ;;

Eiihl10:
.pred.rel "mutex",pt0,pt1
(pt0)   xchg8       t0 = [a2], a2
(pt1)   ld8.nt1     t0 = [a2]
        ;;
(pt0)   cmp.ne      pt2 = zero, t0
        cmp.eq      pt0, pt1 = zero, t0
        ;;
(pt1)   ssm         1 << PSR_I                  // enable interrupt
(pt0)   rsm         1 << PSR_I                  // disable interrupt
(pt2)   br.dpnt     Eiihl10

#endif // !defined(NT_UP)
        ;;

        LDPTR(v0, t3)                           // get address of next entry
        STPTR(t5, a0)                           // store previous link in next

        STPTR(t3, a1)                           // store next link in head
        ;;
        STPTR(t4, v0)                           // store next link in entry
        add         t6 = LsBlink, v0
        ;;

        STPTR(t6, a1)                           // store previous link in next
#if !defined(NT_UP)
        st8.rel.nta [a2] = zero                 // release the spinlock
#endif // !defined(NT_UP)
        cmp.eq      pt4, p0 = v0, a0            // if v0 == a0, list empty
        ;;

        ssm         1 << PSR_I                  // enable interrupt
  (pt4) mov         v0 = zero
        br.ret.sptk.clr brp                     // return
        ;;

        LEAF_EXIT(ExInterlockedInsertHeadList)

//++
//
// PLIST_ENTRY
// ExInterlockedInsertTailList (
//    IN PLIST_ENTRY ListHead,
//    IN PLIST_ENTRY ListEntry,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function inserts an entry at the tail of a doubly linked list
//    so that access to the list is synchronized in a multiprocessor system.
//
// Arguments:
//
//    ListHead (a0) - Supplies a pointer to the head of the doubly linked
//       list into which an entry is to be inserted.
//
//    ListEntry (a1) - Supplies a pointer to the entry to be inserted at the
//       tail of the list.
//
//    Lock (a2) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the list.
//
// Return Value:
//
//    Pointer to entry that was at the tail of the list or NULL if the list
//    was empty.
//
//--

        LEAF_ENTRY(ExInterlockedInsertTailList)

//
// disable interrupt and then try to acquire the spinlock
//

        add         t3 = LsBlink, a0
        add         t4 = LsFlink, a1
        add         t5 = LsBlink, a1

        rsm         1 << PSR_I                  // disable interrupt
#if !defined(NT_UP)

        cmp.eq      pt0, pt1 = zero, zero
        cmp.eq      pt2 = zero, zero
        ;;

Eiitl10:
.pred.rel "mutex",pt0,pt1
(pt0)   xchg8       t0 = [a2], a2
(pt1)   ld8.nt1     t0 = [a2]
        ;;
(pt0)   cmp.ne      pt2 = zero, t0
        cmp.eq      pt0, pt1 = zero, t0
        ;;
(pt1)   ssm         1 << PSR_I                  // enable interrupt
(pt0)   rsm         1 << PSR_I                  // disable interrupt
(pt2)   br.dpnt     Eiitl10

#endif // !defined(NT_UP)
        ;;

        LDPTR(v0, t3)                           // get address of previous entry
        STPTR(t4, a0)                           // store next link in entry

        STPTR(t3, a1)                           // store previous link in head
        ;;
        STPTR(t5, v0)                           // store previous link in entry
        add         t6 = LsFlink, v0
        ;;

        STPTR(t6, a1)                           // store next in previous entry
#if !defined(NT_UP)
        st8.rel.nta [a2] = zero                 // release the spinlock
#endif // !defined(NT_UP)
        cmp.eq      pt4, p0 = v0, a0            // if v0 == a0, list empty
        ;;

        ssm         1 << PSR_I                  // enable interrupt
  (pt4) mov         v0 = zero
        br.ret.sptk.clr brp                     // return
        ;;

        LEAF_EXIT(ExInterlockedInsertTailList)


//++
//
// PLIST_ENTRY
// ExInterlockedRemoveHeadList (
//    IN PLIST_ENTRY ListHead,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function removes an entry from the head of a doubly linked list
//    so that access to the list is synchronized in a multiprocessor system.
//    If there are no entries in the list, then a value of NULL is returned.
//    Otherwise, the address of the entry that is removed is returned as the
//    function value.
//
// Arguments:
//
//    ListHead (a0) - Supplies a pointer to the head of the doubly linked
//       list from which an entry is to be removed.
//
//    Lock (a1) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the list.
//
// Return Value:
//
//    The address of the entry removed from the list, or NULL if the list is
//    empty.
//
//--

        LEAF_ENTRY(ExInterlockedRemoveHeadList)

//
// disable interrupt and then acquire the spinlock
//

        rsm         1 << PSR_I                  // disable interrupt
        add         t3 = LsFlink, a0
#if !defined(NT_UP)

        cmp.eq      pt0, pt1 = zero, zero
        cmp.eq      pt2 = zero, zero
        ;;

Eirhl10:
.pred.rel "mutex",pt0,pt1
(pt0)   xchg8       t0 = [a1], a1
(pt1)   ld8.nt1     t0 = [a1]
        ;;
(pt0)   cmp.ne      pt2 = zero, t0
        cmp.eq      pt0, pt1 = zero, t0
        ;;
(pt1)   ssm         1 << PSR_I                  // enable interrupt
(pt0)   rsm         1 << PSR_I                  // disable interrupt
(pt2)   br.dpnt     Eirhl10

#endif // !defined(NT_UP)
        ;;

        LDPTR(v0, t3)                           // get address of next entry
        ;;
        cmp.eq      pt4, pt3 = v0, a0           // if v0 == a0, list is empty
        add         t5 = LsFlink, v0
        ;;

        PLDPTR(pt3, t6, t5)                     // get address of next in next
        ;;
        PSTPTR(pt3, t3, t6)                     // store address of next in head
(pt3)   add         t7 = LsBlink, t6
        ;;

        PSTPTR(pt3, t7, a0)                     // store addr of prev in next
#if !defined(NT_UP)
        st8.rel.nta [a1] = zero                 // release the spinlock
#endif // !defined(NT_UP)

        ssm         1 << PSR_I                  // enable interrupt
(pt4)   mov         v0 = zero
        br.ret.sptk.clr brp                     // return
        ;;

        LEAF_EXIT(ExInterlockedRemoveHeadList)


//++
//
// PSINGLE_LIST_ENTRY
// ExInterlockedPopEntryList (
//    IN PSINGLE_LIST_ENTRY ListHead,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function removes an entry from the head of a singly linked list
//    so that access to the list is synchronized in a multiprocessor system.
//    If there are no entries in the list, then a value of NULL is returned.
//    Otherwise, the address of the entry that is removed is returned as the
//    function value.
//
// Arguments:
//
//    ListHead (a0) - Supplies a pointer to the head of the singly linked
//       list from which an entry is to be removed.
//
//    Lock (a1) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the list.
//
// Return Value:
//
//    The address of the entry removed from the list, or NULL if the list is
//    empty.
//
//--

        LEAF_ENTRY(ExInterlockedPopEntryList)

//
// disable interrupt and then acquire the spinlock
//

        rsm         1 << PSR_I                  // disable interrupt
#if !defined(NT_UP)

        cmp.eq      pt0, pt1 = zero, zero
        cmp.eq      pt2 = zero, zero
        ;;

Eipopel10:
.pred.rel "mutex",pt0,pt1
(pt0)   xchg8       t0 = [a1], a1
(pt1)   ld8.nt1     t0 = [a1]
        ;;
(pt0)   cmp.ne      pt2 = zero, t0
        cmp.eq      pt0, pt1 = zero, t0
        ;;
(pt1)   ssm         1 << PSR_I                  // enable interrupt
(pt0)   rsm         1 << PSR_I                  // disable interrupt
(pt2)   br.dpnt     Eipopel10

#endif // !defined(NT_UP)
        ;;

        LDPTR(v0, a0)                           // get address of next entry
        ;;
        cmp.ne      pt4, p0 = zero, v0          // if v0 == NULL, list is empty
        ;;

        PLDPTR(pt4, t6, v0)                     // get address of next entry
        ;;
        PSTPTR(pt4, a0, t6)                     // store address of next in head

#if !defined(NT_UP)
        st8.rel.nta [a1] = zero                 // release the spinlock
#endif // !defined(NT_UP)
        ssm         1 << PSR_I                  // enable interrupt
        br.ret.sptk.clr brp                     // return
        ;;

        LEAF_EXIT(ExInterlockedPopEntryList)


//++
//
// PSINGLE_LIST_ENTRY
// ExInterlockedPushEntryList (
//    IN PSINGLE_LIST_ENTRY ListHead,
//    IN PSINGLE_LIST_ENTRY ListEntry,
//    IN PKSPIN_LOCK Lock
//    )
//
// Routine Description:
//
//    This function inserts an entry at the head of a singly linked list
//    so that access to the list is synchronized in a multiprocessor system.
//
// Arguments:
//
//    ListHead (a0) - Supplies a pointer to the head of the singly linked
//       list into which an entry is to be inserted.
//
//    ListEntry (a1) - Supplies a pointer to the entry to be inserted at the
//       head of the list.
//
//    Lock (a2) - Supplies a pointer to a spin lock to be used to synchronize
//       access to the list.
//
// Return Value:
//
//    Previous contents of ListHead.  NULL implies list went from empty
//       to not empty.
//
//--

        LEAF_ENTRY(ExInterlockedPushEntryList)

//
// disable interrupt and then acquire the spinlock
//

        rsm         1 << PSR_I                  // disable interrupt
#if !defined(NT_UP)

        cmp.eq      pt0, pt1 = zero, zero
        cmp.eq      pt2 = zero, zero
        ;;

Eipushel10:
.pred.rel "mutex",pt0,pt1
(pt0)   xchg8       t0 = [a2], a2
(pt1)   ld8.nt1     t0 = [a2]
        ;;
(pt0)   cmp.ne      pt2 = zero, t0
        cmp.eq      pt0, pt1 = zero, t0
        ;;
(pt1)   ssm         1 << PSR_I                  // enable interrupt
(pt0)   rsm         1 << PSR_I                  // disable interrupt
(pt2)   br.dpnt     Eipushel10

#endif // !defined(NT_UP)
        ;;

        LDPTR(v0, a0)                           // get address of next entry
        STPTR(a0, a1)                           // set address of first entry
        ;;

        STPTR(a1, v0)                           // set addr of next in new entry
#if !defined(NT_UP)
        st8.rel.nta [a2] = zero                 // release the spinlock
#endif // !defined(NT_UP)

        ssm         1 << PSR_I                  // enable interrupt
        br.ret.sptk brp                         // return
        ;;

        LEAF_EXIT(ExInterlockedPushEntryList)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ex\ia64\splocks.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

   splocks.c

Abstract:

   All global spinlocks in the kernel image are declared in this
   module.  This is done so that each spinlock can be spaced out
   sufficiently to guaarantee that the L2 cache does not thrash
   by having a spinlock and another high use varible in the same
   cache line.


Author:

    Ken Reneris (kenr) 13-Jan-1992

Revision History:

--*/

#include "exp.h"

//
// Static SpinLocks from ntos\cc\cachedat.c
//

KSPIN_LOCK  CcWorkQueueSpinLock = 0;
KSPIN_LOCK  CcDeferredWriteSpinLock = 0;
KSPIN_LOCK  CcDebugTraceLock = 0;

//
// Static SpinLocks from ntos\ex
//

KSPIN_LOCK  PoolTraceLock = 0;

//
// Static SpinLocks from ntos\io\iodata.c
//

KSPIN_LOCK  IopErrorLogLock = 0;
KSPIN_LOCK  IopErrorLogAllocationLock = 0;
KSPIN_LOCK  IopTimerLock = 0;

//
// Static SpinLocks from ntos\kd\kdlock.c
//

KSPIN_LOCK  KdpDebuggerLock = 0;

//
// Static SpinLocks from ntos\ke\kernldat.c
//

KSPIN_LOCK  KiFreezeExecutionLock = 0;
KSPIN_LOCK  KiFreezeLockBackup = 0;
ULONG_PTR    KiHardwareTrigger = 0;
KSPIN_LOCK  KiPowerNotifyLock = 0;
KSPIN_LOCK  KiProfileLock = 0;

//
// Static SpinLocks from ntos\mm\miglobal.c
//

KSPIN_LOCK  MmSystemSpaceLock = 0;
KSPIN_LOCK  MmAllowWSExpansionLock = 0;

//
// Static SpinLocks from ntos\ps\psinit.c
//

KSPIN_LOCK  PspEventPairLock = 0;
KSPIN_LOCK  PsLoadedModuleSpinLock = 0;

//
// Static SpinLocks from ntos\fsrtl\fsrtlp.c
//

KSPIN_LOCK  FsRtlStrucSupSpinLock = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\dbcsname.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DbcsName.c

Abstract:

    The name support package is for manipulating DBCS strings.  The routines
    allow the caller to dissect and compare strings.

    The following routines are provided by this package:

      o  FsRtlIsFatDbcsLegal - This routine takes an input dbcs
         string and determines if it describes a legal name or path.

      o  FsRtlIsHpfsDbcsLegal - This routine takes an input dbcs
         string and determines if it describes a legal name or path.

      o  FsRtlDissectDbcs - This routine takes a path name string and
         breaks into two parts.  The first name in the string and the
         remainder.

      o  FsRtlDoesDbcsContainWildCards - This routines tells the caller if
         a string contains any wildcard characters.

      o  FsRtlIsDbcsInExpression - This routine is used to compare a string
         against a template (possibly containing wildcards) to sees if the
         string is in the language denoted by the template.

Author:

    Gary Kimura     [GaryKi]    5-Feb-1990

Revision History:

--*/

#include "FsRtlP.h"

//
//  Trace level for the module
//

#define Dbg                              (0x10000000)

//
//  Some special debugging code
//

#if DBG

ULONG DaveDebug = 0;
#define DavePrint if (DaveDebug) DbgPrint

#else

#define DavePrint NOTHING

#endif

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('drSF')

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlDissectDbcs)
#pragma alloc_text(PAGE, FsRtlDoesDbcsContainWildCards)
#pragma alloc_text(PAGE, FsRtlIsDbcsInExpression)
#pragma alloc_text(PAGE, FsRtlIsFatDbcsLegal)
#pragma alloc_text(PAGE, FsRtlIsHpfsDbcsLegal)
#endif


BOOLEAN
FsRtlIsFatDbcsLegal (
    IN ANSI_STRING DbcsName,
    IN BOOLEAN WildCardsPermissible,
    IN BOOLEAN PathNamePermissible,
    IN BOOLEAN LeadingBackslashPermissible
    )

/*++

Routine Description:

    This routine simple returns whether the specified file names conforms
    to the file system specific rules for legal file names.  This routine
    will check the single name, or if PathNamePermissible is specified as
    TRUE, whether the whole path is a legal name.

    For FAT, the following rules apply:

    A. A Fat file name may not contain any of the following characters:

       0x00-0x1F " / : | + , ; = [ ]

    B. A Fat file name is either of the form N.E or just N, where N is a
       string of 1-8 bytes and E is a string of 1-3 bytes conformant to
       rule A above. In addition, neither N nor E may contain a period
       character or end with a space character.

       Incidently, N corresponds to name and E to extension.

    Case: Lower case characters are taken as valid, but are up-shifted upon
          receipt, ie. Fat only deals with upper case file names.

    For example, the files ".foo", "foo.", and "foo .b" are illegal, while
    "foo. b" and " bar" are legal.

Arguments:

    DbcsName - Supllies the name/path to check.

    WildCardsPermissible - Specifies if Nt wild card characters are to be
        considered considered legal.

    PathNamePermissible - Spcifes if Name may be a path name separated by
        backslash characters, or just a simple file name.

    LeadingBackSlashPermissible - Specifies if a single leading backslash
        is permissible in the file/path name.

Return Value:

    BOOLEAN - TRUE if the name is legal, FALSE otherwise.

--*/
{
    BOOLEAN ExtensionPresent = FALSE;

    ULONG Index;

    UCHAR Char;

    PAGED_CODE();

    //
    //  Empty names are not valid.
    //

    if ( DbcsName.Length == 0 ) { return FALSE; }

    //
    //  If Wild Cards are OK, then for directory enumeration to work
    //  correctly we have to accept . and ..
    //

    if ( WildCardsPermissible &&
         ( ( (DbcsName.Length == 1) &&
             ((DbcsName.Buffer[0] == '.') ||
              (DbcsName.Buffer[0] == ANSI_DOS_DOT)) )
           ||
           ( (DbcsName.Length == 2) &&
             ( ((DbcsName.Buffer[0] == '.') &&
                (DbcsName.Buffer[1] == '.')) ||
               ((DbcsName.Buffer[0] == ANSI_DOS_DOT) &&
                (DbcsName.Buffer[1] == ANSI_DOS_DOT)) ) ) ) ) {

        return TRUE;
    }

    //
    //  If a leading \ is OK, skip over it (if there's more)
    //

    if ( DbcsName.Buffer[0] == '\\' ) {

        if ( LeadingBackslashPermissible ) {

            if ( (DbcsName.Length > 1) ) {

                DbcsName.Buffer += 1;
                DbcsName.Length -= 1;

            } else { return TRUE; }

        } else { return FALSE; }
    }

    //
    //  If we got a path name, check each componant.
    //

    if ( PathNamePermissible ) {

        ANSI_STRING FirstName;
        ANSI_STRING RemainingName;

        RemainingName = DbcsName;

        while ( RemainingName.Length != 0 ) {

            //
            //  This will catch the case of an illegal double backslash.
            //

            if ( RemainingName.Buffer[0] == '\\' ) { return FALSE; }

            FsRtlDissectDbcs(RemainingName, &FirstName, &RemainingName);

            if ( !FsRtlIsFatDbcsLegal( FirstName,
                                       WildCardsPermissible,
                                       FALSE,
                                       FALSE) ) {

                return FALSE;
            }
        }

        //
        //  All the componants were OK, so the path is OK.
        //

        return TRUE;
    }

    //
    //  If this name contains wild cards, just check for invalid characters.
    //

    if ( WildCardsPermissible && FsRtlDoesDbcsContainWildCards(&DbcsName) ) {

        for ( Index = 0; Index < DbcsName.Length; Index += 1 ) {

            Char = DbcsName.Buffer[ Index ];

            //
            //  Skip over any Dbcs chacters
            //

            if ( FsRtlIsLeadDbcsCharacter( Char ) ) {

                ASSERT( Index != (ULONG)(DbcsName.Length - 1) );
                Index += 1;
                continue;
            }

            //
            //  Make sure this character is legal, and if a wild card, that
            //  wild cards are permissible.
            //

            if ( !FsRtlIsAnsiCharacterLegalFat(Char, WildCardsPermissible) ) {
                return FALSE;
            }
        }

        return TRUE;
    }


    //
    //  At this point we should only have a single name, which can't have
    //  more than 12 characters (including a single period)
    //

    if ( DbcsName.Length > 12 ) { return FALSE; }

    for ( Index = 0; Index < DbcsName.Length; Index += 1 ) {

        Char = DbcsName.Buffer[ Index ];

        //
        //  Skip over and Dbcs chacters
        //

        if ( FsRtlIsLeadDbcsCharacter( Char ) ) {

            //
            //  FsRtlIsFatDbcsLegal(): fat name part and extension part dbcs check
            //
            //  1) if we're looking at base part ( !ExtensionPresent ) and the 8th byte
            //     is in the dbcs leading byte range, it's error ( Index == 7 ). If the
            //     length of base part is more than 8 ( Index > 7 ), it's definitely error.
            //
            //  2) if the last byte ( Index == DbcsName.Length - 1 ) is in the dbcs leading
            //     byte range, it's error
            //

            if ( (!ExtensionPresent && (Index >= 7)) ||
                 ( Index == (ULONG)(DbcsName.Length - 1) ) ) {
                return FALSE;
            }

            Index += 1;

            continue;
        }

        //
        //  Make sure this character is legal, and if a wild card, that
        //  wild cards are permissible.
        //

        if ( !FsRtlIsAnsiCharacterLegalFat(Char, WildCardsPermissible) ) {

            return FALSE;
        }

        if ( (Char == '.') || (Char == ANSI_DOS_DOT) ) {

            //
            //  We stepped onto a period.  We require the following things:
            //
            //      - It can't be the first character
            //      - There can only be one
            //      - There can't be more than three characters following
            //      - The previous character can't be a space.
            //

            if ( (Index == 0) ||
                 ExtensionPresent ||
                 (DbcsName.Length - (Index + 1) > 3) ||
                 (DbcsName.Buffer[Index - 1] == ' ') ) {

                return FALSE;
            }

            ExtensionPresent = TRUE;
        }

        //
        //  The base part of the name can't be more than 8 characters long.
        //

        if ( (Index >= 8) && !ExtensionPresent ) { return FALSE; }
    }

    //
    //  The name cannot end in a space or a period.
    //

    if ( (Char == ' ') || (Char == '.') || (Char == ANSI_DOS_DOT)) { return FALSE; }

    return TRUE;
}

BOOLEAN
FsRtlIsHpfsDbcsLegal (
    IN ANSI_STRING DbcsName,
    IN BOOLEAN WildCardsPermissible,
    IN BOOLEAN PathNamePermissible,
    IN BOOLEAN LeadingBackslashPermissible
    )

/*++

Routine Description:

    This routine simple returns whether the specified file names conforms
    to the file system specific rules for legal file names.  This routine
    will check the single name, or if PathNamePermissible is specified as
    TRUE, whether the whole path is a legal name.

    For HPFS, the following rules apply:

    A. An HPFS file name may not contain any of the following characters:

       0x0000 - 0x001F  " / : < > ? | *

    B. An HPFS file name may not end in a period or a space.

    C. An HPFS file name must contain no more than 255 bytes.

    Case: HPFS is case preserving, but not case sensitive.  Case is
          preserved on creates, but not checked for on file name compares.

    For example, the files "foo " and "foo." are illegal, while ".foo",
    " foo" and "foo.bar.foo" are legal.

Arguments:

    DbcsName - Supllies the name/path to check.

    WildCardsPermissible - Specifies if Nt wild card characters are to be
        considered considered legal.

    PathNamePermissible - Spcifes if Name may be a path name separated by
        backslash characters, or just a simple file name.

    LeadingBackSlashPermissible - Specifies if a single leading backslash
        is permissible in the file/path name.

Return Value:

    BOOLEAN - TRUE if the name is legal, FALSE otherwise.

--*/
{
    BOOLEAN ExtensionPresent = FALSE;

    ULONG Index;

    UCHAR Char;

    PAGED_CODE();

    //
    //  Empty names are not valid.
    //

    if ( DbcsName.Length == 0 ) { return FALSE; }

    //
    //  If Wild Cards are OK, then for directory enumeration to work
    //  correctly we have to accept . and ..
    //

    if ( WildCardsPermissible &&
         ( ( (DbcsName.Length == 1) &&
             ((DbcsName.Buffer[0] == '.') ||
              (DbcsName.Buffer[0] == ANSI_DOS_DOT)) )
           ||
           ( (DbcsName.Length == 2) &&
             ( ((DbcsName.Buffer[0] == '.') &&
                (DbcsName.Buffer[1] == '.')) ||
               ((DbcsName.Buffer[0] == ANSI_DOS_DOT) &&
                (DbcsName.Buffer[1] == ANSI_DOS_DOT)) ) ) ) ) {

        return TRUE;
    }

    //
    //  If a leading \ is OK, skip over it (if there's more)
    //

    if ( DbcsName.Buffer[0] == '\\' ) {

        if ( LeadingBackslashPermissible ) {

            if ( (DbcsName.Length > 1) ) {

                DbcsName.Buffer += 1;
                DbcsName.Length -= 1;

            } else { return TRUE; }

        } else { return FALSE; }
    }

    //
    //  If we got a path name, check each componant.
    //

    if ( PathNamePermissible ) {

        ANSI_STRING FirstName;
        ANSI_STRING RemainingName;

        RemainingName = DbcsName;

        while ( RemainingName.Length != 0 ) {

            //
            //  This will catch the case of an illegal double backslash.
            //

            if ( RemainingName.Buffer[0] == '\\' ) { return FALSE; }

            FsRtlDissectDbcs(RemainingName, &FirstName, &RemainingName);

            if ( !FsRtlIsHpfsDbcsLegal( FirstName,
                                       WildCardsPermissible,
                                       FALSE,
                                       FALSE) ) {

                return FALSE;
            }
        }

        //
        //  All the componants were OK, so the path is OK.
        //

        return TRUE;
    }

    //
    //  At this point we should only have a single name, which can't have
    //  more than 255 characters
    //

    if ( DbcsName.Length > 255 ) { return FALSE; }

    for ( Index = 0; Index < DbcsName.Length; Index += 1 ) {

        Char = DbcsName.Buffer[ Index ];

        //
        //  Skip over and Dbcs chacters
        //

        if ( FsRtlIsLeadDbcsCharacter( Char ) ) {

            //
            //  FsRtlIsHpfsDbcsLegal () hpfs dbcs check
            //
            //  If the last byte ( Index == DbcsName.Length - 1 ) is in the
            //  dbcs leading byte range, it's error.
            //

            if ( Index == (ULONG)(DbcsName.Length - 1) ) {

                return FALSE;
            }

            Index += 1;
            continue;
        }

        //
        //  Make sure this character is legal, and if a wild card, that
        //  wild cards are permissible.
        //

        if ( !FsRtlIsAnsiCharacterLegalHpfs(Char, WildCardsPermissible) ) {

            return FALSE;
        }
    }

    //
    //  The name cannot end in a space or a period.
    //

    if ( (Char == ' ') || (Char == '.') || (Char == ANSI_DOS_DOT) ) {

        return FALSE;
    }

    return TRUE;
}


VOID
FsRtlDissectDbcs (
    IN ANSI_STRING Path,
    OUT PANSI_STRING FirstName,
    OUT PANSI_STRING RemainingName
    )

/*++

Routine Description:

    This routine takes an input Dbcs string and dissects it into two
    substrings.  The first output string contains the name that appears at
    the beginning of the input string, the second output string contains the
    remainder of the input string.

    In the input string backslashes are used to separate names.  The input
    string must not start with a backslash.  Both output strings will not
    begin with a backslash.

    If the input string does not contain any names then both output strings
    are empty.  If the input string contains only one name then the first
    output string contains the name and the second string is empty.

    Note that both output strings use the same string buffer memory of the
    input string.

    Example of its results are:

//. .     InputString    FirstPart    RemainingPart
//
//. .     empty          empty        empty
//
//. .     A              A            empty
//
//. .     A\B\C\D\E      A            B\C\D\E
//
//. .     *A?            *A?          empty
//
//. .     \A             A            empty
//
//. .     A[,]           A[,]         empty
//
//. .     A\\B+;\C       A            \B+;\C

Arguments:

    InputName - Supplies the input string being dissected

    Is8dot3 - Indicates if the first part of the input name must be 8.3
        or can be long file name.

    FirstPart - Receives the first name in the input string

    RemainingPart - Receives the remaining part of the input string

Return Value:

    NONE

--*/

{
    ULONG i = 0;
    ULONG PathLength;
    ULONG FirstNameStart;

    PAGED_CODE();

    //
    //  Make both output strings empty for now
    //

    FirstName->Length = 0;
    FirstName->MaximumLength = 0;
    FirstName->Buffer = NULL;

    RemainingName->Length = 0;
    RemainingName->MaximumLength = 0;
    RemainingName->Buffer = NULL;

    PathLength = Path.Length;

    //
    //  Check for an empty input string
    //

    if (PathLength == 0) {

        return;
    }

    //
    //  Skip over a starting backslash, and make sure there is more.
    //

    if ( Path.Buffer[0] == '\\' ) {

        i = 1;
    }

    //
    //  Now run down the input string until we hit a backslash or the end
    //  of the string, remembering where we started;
    //

    for ( FirstNameStart = i;
          (i < PathLength) && (Path.Buffer[i] != '\\');
          i += 1 ) {

        //
        //  If this is the first byte of a Dbcs character, skip over the
        //  next byte as well.
        //

        if ( FsRtlIsLeadDbcsCharacter( Path.Buffer[i] ) ) {

            i += 1;
        }
    }

    //
    //  At this point all characters up to (but not including) i are
    //  in the first part.   So setup the first name
    //

    FirstName->Length = (USHORT)(i - FirstNameStart);
    FirstName->MaximumLength = FirstName->Length;
    FirstName->Buffer = &Path.Buffer[FirstNameStart];

    //
    //  Now the remaining part needs a string only if the first part didn't
    //  exhaust the entire input string.  We know that if anything is left
    //  that is must start with a backslash.  Note that if there is only
    //  a trailing backslash, the length will get correctly set to zero.
    //

    if (i < PathLength) {

        RemainingName->Length = (USHORT)(PathLength - (i + 1));
        RemainingName->MaximumLength = RemainingName->Length;
        RemainingName->Buffer = &Path.Buffer[i + 1];
    }

    //
    //  And return to our caller
    //

    return;
}


BOOLEAN
FsRtlDoesDbcsContainWildCards (
    IN PANSI_STRING Name
    )

/*++

Routine Description:

    This routine checks if the input Dbcs name contains any wild card
    characters (i.e., *, ?, ANSI_DOS_STAR, or ANSI_DOS_QM).

Arguments:

    Name - Supplies the name to examine

Return Value:

    BOOLEAN - TRUE if the input name contains any wildcard characters and
        FALSE otherwise.

--*/

{
    CLONG i;

    PAGED_CODE();

    //
    //  Check each character in the name to see if it's a wildcard
    //  character
    //

    for (i = 0; i < Name->Length; i += 1) {

        //
        //  check for dbcs character because we'll just skip over those
        //

        if (FsRtlIsLeadDbcsCharacter( Name->Buffer[i] )) {

            i += 1;

        //
        //  else check for a wild card character
        //

        } else if (FsRtlIsAnsiCharacterWild( Name->Buffer[i] )) {

            //
            //  Tell caller that this name contains wild cards
            //

            return TRUE;
        }
    }

    //
    //  No wildcard characters were found, so return to our caller
    //

    return FALSE;
}

#define GetDbcs(BUF,OFFSET,DBCS_CHAR,LENGTH) {               \
    if (FsRtlIsLeadDbcsCharacter( (BUF)[(OFFSET)] )) {       \
        *(DBCS_CHAR) = (WCHAR)((BUF)[(OFFSET)] +             \
                               0x100 * (BUF)[(OFFSET) + 1]); \
        *(LENGTH) = 2;                                       \
    } else {                                                 \
        *(DBCS_CHAR) = (WCHAR)(BUF)[(OFFSET)];               \
        *(LENGTH) = 1;                                       \
    }                                                        \
}

#define MATCHES_ARRAY_SIZE 16

BOOLEAN
FsRtlIsDbcsInExpression (
    IN PANSI_STRING Expression,
    IN PANSI_STRING Name
    )

/*++

Routine Description:

    This routine compares a Dbcs name and an expression and tells the caller
    if the name is in the language defined by the expression.  The input name
    cannot contain wildcards, while the expression may contain wildcards.

    Expression wild cards are evaluated as shown in the nondeterministic
    finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except the final .

               e is a null character transition

               EOF is the end of the name string

    In words:

        * matches 0 or more characters.

        ? matches exactly 1 character.

        DOS_STAR matches 0 or more characters until encountering and matching
            the final . in the name.

        DOS_QM matches any single character, or upon encountering a period or
            end of name string, advances the expression to the end of the
            set of contiguous DOS_QMs.

        DOS_DOT matches either a . or zero characters beyond name string.

Arguments:

    Expression - Supplies the input expression to check against

    Name - Supplies the input name to check for.

Return Value:

    BOOLEAN - TRUE if Name is an element in the set of strings denoted
        by the input Expression and FALSE otherwise.

--*/

{
    USHORT NameOffset;
    USHORT ExprOffset;
    USHORT Length;

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;

    WCHAR NameChar, ExprChar;

    USHORT LocalBuffer[MATCHES_ARRAY_SIZE * 2];

    USHORT *AuxBuffer = NULL;
    USHORT *PreviousMatches;
    USHORT *CurrentMatches;

    USHORT MaxState;
    USHORT CurrentState;

    BOOLEAN NameFinished = FALSE;

    //
    //  The idea behind the algorithm is pretty simple.  We keep track of
    //  all possible locations in the regular expression that are matching
    //  the name.  If when the name has been exhausted one of the locations
    //  in the expression is also just exhausted, the name is in the language
    //  defined by the regular expression.
    //

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlIsDbcsInExpression\n", 0);
    DebugTrace( 0, Dbg, " Expression      = %Z\n", Expression );
    DebugTrace( 0, Dbg, " Name            = %Z\n", Name );

    ASSERT( Name->Length != 0 );
    ASSERT( Expression->Length != 0 );

    //
    //  If one string is empty return FALSE.  If both are empty return TRUE.
    //

    if ( (Name->Length == 0) || (Expression->Length == 0) ) {

        return (BOOLEAN)(!(Name->Length + Expression->Length));
    }

    //
    //  Special case by far the most common wild card search of *
    //

    if ((Expression->Length == 1) && (Expression->Buffer[0] == '*')) {

        return TRUE;
    }

    ASSERT( FsRtlDoesDbcsContainWildCards( Expression ) );

    //
    //  Also special case expressions of the form *X.  With this and the prior
    //  case we have covered virtually all normal queries.
    //

    if (Expression->Buffer[0] == '*') {

        ANSI_STRING LocalExpression;

        LocalExpression = *Expression;

        LocalExpression.Buffer += 1;
        LocalExpression.Length -= 1;

        //
        //  Only special case an expression with a single *
        //

        if ( !FsRtlDoesDbcsContainWildCards( &LocalExpression ) ) {

            ULONG StartingNameOffset;

            if (Name->Length < (USHORT)(Expression->Length - 1)) {

                return FALSE;
            }

            StartingNameOffset = Name->Length - LocalExpression.Length;

            //
            //  FsRtlIsDbcsInExpression(): bug fix "expression[0] == *" case
            //
            //  StatingNameOffset must not bisect DBCS characters.
            //

            if (NlsMbOemCodePageTag) {

                ULONG i = 0;

                while ( i < StartingNameOffset ) {

                    i += FsRtlIsLeadDbcsCharacter( Name->Buffer[i] ) ? 2 : 1;
                }

                if ( i > StartingNameOffset ) {

                    return FALSE;
                }
            }

            //
            //  Do a simple memory compare if case sensitive, otherwise
            //  we have got to check this one character at a time.
            //

            return (BOOLEAN) RtlEqualMemory( LocalExpression.Buffer,
                                             Name->Buffer + StartingNameOffset,
                                             LocalExpression.Length );
        }
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the expression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the expression can represent one or two
    //  states.  * and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expreesion characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  - The offset of the current name char being processed.
    //
    //  ExprOffset  - The offset of the current expression char being processed.
    //
    //  SrcCount    - Prior match being investigated with current name char
    //
    //  DestCount   - Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more itteration through the Matches array
    //                 after the name is exhusted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication, see coment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    //
    //  Set up the initial variables
    //

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches = &LocalBuffer[MATCHES_ARRAY_SIZE];

    PreviousMatches[0] = 0;
    MatchesCount = 1;

    NameOffset = 0;

    MaxState = (USHORT)(Expression->Length * 2);

    while ( !NameFinished ) {

        if ( NameOffset < Name->Length ) {

            GetDbcs( Name->Buffer, NameOffset, &NameChar, &Length );
            NameOffset += Length;

        } else {

            NameFinished = TRUE;

            //
            //  if we have already exhasted the expression, cool.  Don't
            //  continue.
            //

            if ( PreviousMatches[MatchesCount-1] == MaxState ) {

                break;
            }
        }


        //
        //  Now, for each of the previous stored expression matches, see what
        //  we can do with this name character.
        //

        SrcCount = 0;
        DestCount = 0;
        PreviousDestCount = 0;

        while ( SrcCount < MatchesCount ) {

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (USHORT)((PreviousMatches[SrcCount++] + 1) / 2);

            Length = 0;


            while ( TRUE ) {

                if ( ExprOffset == Expression->Length ) {

                    break;
                }

                //
                //  The first time through the loop we don't want
                //  to increment ExprOffset.
                //

                ExprOffset += Length;

                CurrentState = (USHORT)(ExprOffset * 2);

                if ( ExprOffset == Expression->Length ) {

                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }

                GetDbcs(Expression->Buffer, ExprOffset, &ExprChar, &Length);

                ASSERT( !((ExprChar >= 'a') && (ExprChar <= 'z')) );

                //
                //  Before we get started, we have to check for something
                //  really gross.  We may be about to exhaust the local
                //  space for ExpressionMatches[][], so we have to allocate
                //  some pool if this is the case.  Yuk!
                //

                if ( (DestCount >= MATCHES_ARRAY_SIZE - 2) &&
                     (AuxBuffer == NULL) ) {

                    AuxBuffer = FsRtlpAllocatePool( PagedPool,
                                                    (Expression->Length+1) *
                                                    sizeof(USHORT)*2*2 );

                    RtlCopyMemory( AuxBuffer,
                                   CurrentMatches,
                                   MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    CurrentMatches = AuxBuffer;

                    RtlCopyMemory( AuxBuffer + (Expression->Length+1)*2,
                                   PreviousMatches,
                                   MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    PreviousMatches = AuxBuffer + (Expression->Length+1)*2;

                }

                //
                //  * matches any character zero or more times.
                //

                if (ExprChar == '*') {

                    CurrentMatches[DestCount++] = CurrentState;
                    CurrentMatches[DestCount++] = CurrentState + 1;
                    continue;
                }

                //
                //  DOS_STAR matches any character except . zero or more times.
                //

                if (ExprChar == ANSI_DOS_STAR) {

                    BOOLEAN ICanEatADot = FALSE;

                    //
                    //  If we are at a period, determine if we are allowed to
                    //  consume it, ie. make sure it is not the last one.
                    //

                    if ( !NameFinished && (NameChar == '.') ) {

                        WCHAR NameChar;
                        USHORT Offset;
                        USHORT Length;

                        for ( Offset = NameOffset;
                              Offset < Name->Length;
                              Offset += Length ) {

                            GetDbcs( Name->Buffer, Offset, &NameChar, &Length );

                            if (NameChar == '.') {

                                ICanEatADot = TRUE;
                                break;
                            }
                        }
                    }

                    if (NameFinished || (NameChar != '.') || ICanEatADot) {

                        CurrentMatches[DestCount++] = CurrentState;
                        CurrentMatches[DestCount++] = CurrentState + 1;
                        continue;

                    } else {

                        //
                        //  We are at a period.  We can only match zero
                        //  characters (ie. the epsilon transition).
                        //

                        CurrentMatches[DestCount++] = CurrentState + 1;
                        continue;
                    }
                }

                //
                //  The following expreesion characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  forward.
                //

                CurrentState += (USHORT)(Length * 2);

                //
                //  DOS_QM is the most complicated.  If the name is finished,
                //  we can match zero characters.  If this name is a '.', we
                //  don't match, but look at the next expression.  Otherwise
                //  we match a single character.
                //

                if ( ExprChar == ANSI_DOS_QM ) {

                    if ( NameFinished || (NameChar == '.') ) {

                        continue;
                    }

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  A DOS_DOT can match either a period, or zero characters
                //  beyond the end of name.
                //

                if (ExprChar == DOS_DOT) {

                    if ( NameFinished ) {

                        continue;
                    }

                    if (NameChar == '.') {

                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }

                //
                //  From this point on a name character is required to even
                //  continue, let alone make a match.
                //

                if ( NameFinished ) {

                    break;
                }

                //
                //  If this expression was a '?' we can match it once.
                //

                if (ExprChar == '?') {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  Finally, check if the expression char matches the name char
                //

                if (ExprChar == NameChar) {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  The expression didn't match so go look at the next
                //  previous match.
                //

                break;
            }


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is montonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarentees non-duplication in the dest. array.
            //

            while ((SrcCount < MatchesCount) &&
                   (PreviousDestCount < DestCount)) {

                while ((SrcCount < MatchesCount) &&
                       (PreviousMatches[SrcCount] <
                        CurrentMatches[PreviousDestCount])) {

                    SrcCount += 1;
                }

                PreviousDestCount += 1;
            }
        }

        //
        //  If we found no matches in the just finished itteration, it's time
        //  to bail.
        //

        if ( DestCount == 0 ) {


            if (AuxBuffer != NULL) { ExFreePool( AuxBuffer ); }

            return FALSE;
        }

        //
        //  Swap the meaning the two arrays
        //

        {
            USHORT *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;
    }


    CurrentState = PreviousMatches[MatchesCount-1];

    if (AuxBuffer != NULL) { ExFreePool( AuxBuffer ); }


    return (BOOLEAN)(CurrentState == MaxState);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\fastio.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FastIo.c

Abstract:

    The Fast I/O path is used to avoid calling the file systems directly to
    do a cached read.  This module is only used if the file object indicates
    that caching is enabled (i.e., the private cache map is not null).

Author:

    Gary Kimura     [GaryKi]    25-Feb-1991

Revision History:

    Tom Miller      [TomM]      14-Apr-1991 Added Fast Write routines

--*/

#include "FsRtlP.h"

#if DBG

typedef struct _FS_RTL_DEBUG_COUNTERS {

    ULONG AcquireFileExclusiveEx_Succeed;
    ULONG AcquireFileExclusiveEx_Fail;
    ULONG ReleaseFile;

    ULONG AcquireFileForModWriteEx_Succeed;
    ULONG AcquireFileForModWriteEx_Fail;
    ULONG ReleaseFileForModWrite;

    ULONG AcquireFileForCcFlushEx_Succeed;
    ULONG AcquireFileForCcFlushEx_Fail;
    ULONG ReleaseFileForCcFlush;
    
} FS_RTL_DEBUG_COUNTERS, *PFS_RTL_DEBUG_COUNTERS;

FS_RTL_DEBUG_COUNTERS gCounter = { 0, 0, 0,
                                   0, 0, 0,
                                   0, 0, 0 };

#endif

//
//  Trace level for the module
//

#define Dbg                              (0x04000000)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlCopyRead)
#pragma alloc_text(PAGE, FsRtlCopyWrite)
#pragma alloc_text(PAGE, FsRtlMdlRead)
#pragma alloc_text(PAGE, FsRtlMdlReadDev)
#pragma alloc_text(PAGE, FsRtlPrepareMdlWrite)
#pragma alloc_text(PAGE, FsRtlPrepareMdlWriteDev)
#pragma alloc_text(PAGE, FsRtlMdlWriteComplete)
#pragma alloc_text(PAGE, FsRtlMdlWriteCompleteDev)
#pragma alloc_text(PAGE, FsRtlAcquireFileForCcFlush)
#pragma alloc_text(PAGE, FsRtlAcquireFileForCcFlushEx)
#pragma alloc_text(PAGE, FsRtlReleaseFileForCcFlush)
#pragma alloc_text(PAGE, FsRtlAcquireFileExclusive)
#pragma alloc_text(PAGE, FsRtlAcquireToCreateMappedSection)
#pragma alloc_text(PAGE, FsRtlAcquireFileExclusiveCommon)
#pragma alloc_text(PAGE, FsRtlReleaseFile)
#pragma alloc_text(PAGE, FsRtlGetFileSize)
#pragma alloc_text(PAGE, FsRtlSetFileSize)
#pragma alloc_text(PAGE, FsRtlIncrementCcFastReadNotPossible )
#pragma alloc_text(PAGE, FsRtlIncrementCcFastReadWait )

#endif


BOOLEAN
FsRtlCopyRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcCopyRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered, or
        if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PFSRTL_COMMON_FCB_HEADER Header;
    BOOLEAN Status = TRUE;
    ULONG PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES( FileOffset->QuadPart, Length );
    LARGE_INTEGER BeyondLastByte;
    PDEVICE_OBJECT targetVdo;

    PAGED_CODE();

    //
    //  Special case a read of zero length
    //

    if (Length != 0) {

        //
        //  Check for overflow. Returning false here will re-route this request through the
        //  IRP based path, but this isn't performance critical.
        //

        if (MAXLONGLONG - FileOffset->QuadPart < (LONGLONG)Length) {

            IoStatus->Status = STATUS_INVALID_PARAMETER;
            IoStatus->Information = 0;
            
            return FALSE;
        }
        
        BeyondLastByte.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
        Header = (PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext;

        //
        //  Enter the file system
        //

        FsRtlEnterFileSystem();

        //
        //  Increment performance counters and get the resource
        //

        if (Wait) {

            HOT_STATISTIC(CcFastReadWait) += 1;

            //
            //  Acquired shared on the common fcb header
            //

            (VOID)ExAcquireResourceSharedLite( Header->Resource, TRUE );

        } else {

            HOT_STATISTIC(CcFastReadNoWait) += 1;

            //
            //  Acquired shared on the common fcb header, and return if we
            //  don't get it
            //

            if (!ExAcquireResourceSharedLite( Header->Resource, FALSE )) {

                FsRtlExitFileSystem();

                CcFastReadResourceMiss += 1;

                return FALSE;
            }
        }

        //
        //  Now that the File is acquired shared, we can safely test if it
        //  is really cached and if we can do fast i/o and if not, then
        //  release the fcb and return.
        //

        if ((FileObject->PrivateCacheMap == NULL) ||
            (Header->IsFastIoPossible == FastIoIsNotPossible)) {

            ExReleaseResourceLite( Header->Resource );
            FsRtlExitFileSystem();

            HOT_STATISTIC(CcFastReadNotPossible) += 1;

            return FALSE;
        }

        //
        //  Check if fast I/O is questionable and if so then go ask the
        //  file system the answer
        //

        if (Header->IsFastIoPossible == FastIoIsQuestionable) {

            PFAST_IO_DISPATCH FastIoDispatch;

            ASSERT(!KeIsExecutingDpc());

            targetVdo = IoGetRelatedDeviceObject( FileObject );
            FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;


            //
            //  All file systems that set "Is Questionable" had better support
            // fast I/O
            //

            ASSERT(FastIoDispatch != NULL);
            ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

            //
            //  Call the file system to check for fast I/O.  If the answer is
            //  anything other than GoForIt then we cannot take the fast I/O
            //  path.
            //

            if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        Wait,
                                                        LockKey,
                                                        TRUE, // read operation
                                                        IoStatus,
                                                        targetVdo )) {

                //
                //  Fast I/O is not possible so release the Fcb and return.
                //

                ExReleaseResourceLite( Header->Resource );
                FsRtlExitFileSystem();

                HOT_STATISTIC(CcFastReadNotPossible) += 1;

                return FALSE;
            }
        }

        //
        //  Check for read past file size.
        //

        if ( BeyondLastByte.QuadPart > Header->FileSize.QuadPart ) {

            if ( FileOffset->QuadPart >= Header->FileSize.QuadPart ) {
                IoStatus->Status = STATUS_END_OF_FILE;
                IoStatus->Information = 0;

                ExReleaseResourceLite( Header->Resource );
                FsRtlExitFileSystem();

                return TRUE;
            }

            Length = (ULONG)( Header->FileSize.QuadPart - FileOffset->QuadPart );
        }

        //
        //  We can do fast i/o so call the cc routine to do the work and then
        //  release the fcb when we've done.  If for whatever reason the
        //  copy read fails, then return FALSE to our caller.
        //
        //  Also mark this as the top level "Irp" so that lower file system
        //  levels will not attempt a pop-up
        //

        PsGetCurrentThread()->TopLevelIrp = FSRTL_FAST_IO_TOP_LEVEL_IRP;

        try {

            if (Wait && ((BeyondLastByte.HighPart | Header->FileSize.HighPart) == 0)) {

                CcFastCopyRead( FileObject,
                                FileOffset->LowPart,
                                Length,
                                PageCount,
                                Buffer,
                                IoStatus );

                FileObject->Flags |= FO_FILE_FAST_IO_READ;

                ASSERT( (IoStatus->Status == STATUS_END_OF_FILE) ||
                        ((FileOffset->LowPart + IoStatus->Information) <= Header->FileSize.LowPart));

            } else {

                Status = CcCopyRead( FileObject,
                                     FileOffset,
                                     Length,
                                     Wait,
                                     Buffer,
                                     IoStatus );

                FileObject->Flags |= FO_FILE_FAST_IO_READ;

                ASSERT( !Status || (IoStatus->Status == STATUS_END_OF_FILE) ||
                        ((LONGLONG)(FileOffset->QuadPart + IoStatus->Information) <= Header->FileSize.QuadPart));
            }

            if (Status) {

                FileObject->CurrentByteOffset.QuadPart = FileOffset->QuadPart + IoStatus->Information;
            }

        } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                        ? EXCEPTION_EXECUTE_HANDLER
                                        : EXCEPTION_CONTINUE_SEARCH ) {

            Status = FALSE;
        }

        PsGetCurrentThread()->TopLevelIrp = 0;

        ExReleaseResourceLite( Header->Resource );
        FsRtlExitFileSystem();
        return Status;

    } else {

        //
        //  A zero length transfer was requested.
        //

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = 0;

        return TRUE;
    }
}


BOOLEAN
FsRtlCopyWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached write bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy write
    of a cached file object.  For a complete description of the arguments
    see CcCopyWrite.

Arguments:

    FileObject - Pointer to the file object being write.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered, or
        if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PFSRTL_COMMON_FCB_HEADER Header;
    BOOLEAN AcquiredShared = FALSE;
    BOOLEAN Status = TRUE;
    BOOLEAN FileSizeChanged = FALSE;
    BOOLEAN WriteToEndOfFile = (BOOLEAN)((FileOffset->LowPart == FILE_WRITE_TO_END_OF_FILE) &&
                                         (FileOffset->HighPart == -1));

    PAGED_CODE();

    //
    //  Get a real pointer to the common fcb header
    //

    Header = (PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext;

    //
    //  Do we need to verify the volume?  If so, we must go to the file
    //  system.  Also return FALSE if FileObject is write through, the
    //  File System must do that.
    //

    if (CcCanIWrite( FileObject, Length, Wait, FALSE ) &&
        !FlagOn(FileObject->Flags, FO_WRITE_THROUGH) &&
        CcCopyWriteWontFlush(FileObject, FileOffset, Length)) {

        //
        //  Assume our transfer will work
        //

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = Length;

        //
        //  Special case the zero byte length
        //

        if (Length != 0) {

            //
            //  Enter the file system
            //

            FsRtlEnterFileSystem();

            //
            //  Split into separate paths for increased performance.  First
            //  we have the faster path which only supports Wait == TRUE and
            //  32 bits.  We will make an unsafe test on whether the fast path
            //  is ok, then just return FALSE later if we were wrong.  This
            //  should virtually never happen.
            //
            //  IMPORTANT NOTE: It is very important that any changes made to
            //                  this path also be applied to the 64-bit path
            //                  which is the else of this test!
            //

            if (Wait && (Header->AllocationSize.HighPart == 0)) {

                ULONG Offset, NewFileSize;
                ULONG OldFileSize;
                ULONG OldValidDataLength;
                BOOLEAN Wrapped;

                //
                //  Make our best guess on whether we need the file exclusive
                //  or shared.  Note that we do not check FileOffset->HighPart
                //  until below.
                //

                NewFileSize = FileOffset->LowPart + Length;

                if (WriteToEndOfFile || (NewFileSize > Header->ValidDataLength.LowPart)) {

                    //
                    //  Acquired shared on the common fcb header
                    //

                    ExAcquireResourceExclusiveLite( Header->Resource, TRUE );

                } else {

                    //
                    //  Acquired shared on the common fcb header
                    //

                    ExAcquireResourceSharedLite( Header->Resource, TRUE );

                    AcquiredShared = TRUE;
                }

                //
                //  We have the fcb shared now check if we can do fast i/o
                //  and if the file space is allocated, and if not then
                //  release the fcb and return.
                //

                if (WriteToEndOfFile) {

                    Offset = Header->FileSize.LowPart;
                    NewFileSize = Header->FileSize.LowPart + Length;
                    Wrapped = NewFileSize < Header->FileSize.LowPart;

                } else {

                    Offset = FileOffset->LowPart;
                    NewFileSize = FileOffset->LowPart + Length;
                    Wrapped = (NewFileSize < FileOffset->LowPart) || (FileOffset->HighPart != 0);
                }

                //
                //  Now that the File is acquired shared, we can safely test
                //  if it is really cached and if we can do fast i/o and we
                //  do not have to extend. If not then release the fcb and
                //  return.
                //
                //  Get out if we have too much to zero.  This case is not important
                //  for performance, and a file system supporting sparseness may have
                //  a way to do this more efficiently.
                //

                if ((FileObject->PrivateCacheMap == NULL) ||
                    (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                    (NewFileSize > Header->AllocationSize.LowPart) ||
                    (Offset >= (Header->ValidDataLength.LowPart + 0x2000)) ||
                    (Header->AllocationSize.HighPart != 0) || Wrapped) {

                    ExReleaseResourceLite( Header->Resource );
                    FsRtlExitFileSystem();

                    return FALSE;
                }

                //
                //  If we will be extending ValidDataLength, we will have to
                //  get the Fcb exclusive, and make sure that FastIo is still
                //  possible.  We should only execute this block of code very
                //  rarely, when the unsafe test for ValidDataLength failed
                //  above.
                //

                if (AcquiredShared && (NewFileSize > Header->ValidDataLength.LowPart)) {

                    ExReleaseResourceLite( Header->Resource );

                    ExAcquireResourceExclusiveLite( Header->Resource, TRUE );

                    //
                    // If writing to end of file, we must recalculate new size.
                    //

                    if (WriteToEndOfFile) {

                        Offset = Header->FileSize.LowPart;
                        NewFileSize = Header->FileSize.LowPart + Length;
                        Wrapped = NewFileSize < Header->FileSize.LowPart;
                    }

                    if ((FileObject->PrivateCacheMap == NULL) ||
                        (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                        (NewFileSize > Header->AllocationSize.LowPart) ||
                        (Header->AllocationSize.HighPart != 0) || Wrapped) {

                        ExReleaseResourceLite( Header->Resource );
                        FsRtlExitFileSystem();

                        return FALSE;
                    }
                }

                //
                //  Check if fast I/O is questionable and if so then go ask
                //  the file system the answer
                //

                if (Header->IsFastIoPossible == FastIoIsQuestionable) {

                    PDEVICE_OBJECT targetVdo = IoGetRelatedDeviceObject( FileObject );
                    PFAST_IO_DISPATCH FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;
                    IO_STATUS_BLOCK IoStatus;

                    //
                    //  All file system then set "Is Questionable" had better
                    //  support fast I/O
                    //

                    ASSERT(FastIoDispatch != NULL);
                    ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

                    //
                    //  Call the file system to check for fast I/O.  If the
                    //  answer is anything other than GoForIt then we cannot
                    //  take the fast I/O path.
                    //

                    ASSERT(FILE_WRITE_TO_END_OF_FILE == 0xffffffff);

                    if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                                FileOffset->QuadPart != (LONGLONG)-1 ?
                                                                  FileOffset : &Header->FileSize,
                                                                Length,
                                                                TRUE,
                                                                LockKey,
                                                                FALSE, // write operation
                                                                &IoStatus,
                                                                targetVdo )) {

                        //
                        //  Fast I/O is not possible so release the Fcb and
                        //  return.
                        //

                        ExReleaseResourceLite( Header->Resource );
                        FsRtlExitFileSystem();

                        return FALSE;
                    }
                }

                //
                //  Now see if we will change FileSize.  We have to do it now
                //  so that our reads are not nooped.
                //

                if (NewFileSize > Header->FileSize.LowPart) {

                    FileSizeChanged = TRUE;
                    OldFileSize = Header->FileSize.LowPart;
                    OldValidDataLength = Header->ValidDataLength.LowPart;
                    Header->FileSize.LowPart = NewFileSize;
                }

                //
                //  We can do fast i/o so call the cc routine to do the work
                //  and then release the fcb when we've done.  If for whatever
                //  reason the copy write fails, then return FALSE to our
                //  caller.
                //
                //  Also mark this as the top level "Irp" so that lower file
                //  system levels will not attempt a pop-up
                //

                PsGetCurrentThread()->TopLevelIrp = FSRTL_FAST_IO_TOP_LEVEL_IRP;

                try {

                    //
                    //  See if we have to do some zeroing
                    //

                    if (Offset > Header->ValidDataLength.LowPart) {

                        LARGE_INTEGER ZeroEnd;

                        ZeroEnd.LowPart = Offset;
                        ZeroEnd.HighPart = 0;

                        CcZeroData( FileObject,
                                    &Header->ValidDataLength,
                                    &ZeroEnd,
                                    TRUE );
                    }

                    CcFastCopyWrite( FileObject,
                                     Offset,
                                     Length,
                                     Buffer );

                } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                                ? EXCEPTION_EXECUTE_HANDLER
                                                : EXCEPTION_CONTINUE_SEARCH ) {

                    Status = FALSE;
                }

                PsGetCurrentThread()->TopLevelIrp = 0;

                //
                //  If we succeeded, see if we have to update FileSize or
                //  ValidDataLength.
                //

                if (Status) {

                    //
                    //  In the case of ValidDataLength, we really have to
                    //  check again since we did not do this when we acquired
                    //  the resource exclusive.
                    //

                    if (NewFileSize > Header->ValidDataLength.LowPart) {

                        Header->ValidDataLength.LowPart = NewFileSize;
                    }

                    //
                    //  Set this handle as having modified the file
                    //

                    FileObject->Flags |= FO_FILE_MODIFIED;

                    if (FileSizeChanged) {

                        CcGetFileSizePointer(FileObject)->LowPart = NewFileSize;

                        FileObject->Flags |= FO_FILE_SIZE_CHANGED;
                    }

                    //
                    //  Also update the file position pointer
                    //

                    FileObject->CurrentByteOffset.LowPart = Offset + Length;
                    FileObject->CurrentByteOffset.HighPart = 0;

                //
                //  If we did not succeed, then we must restore the original
                //  FileSize while holding the PagingIoResource exclusive if
                //  it exists.
                //

                } else if (FileSizeChanged) {

                    if ( Header->PagingIoResource != NULL ) {

                        (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                        Header->FileSize.LowPart = OldFileSize;
                        Header->ValidDataLength.LowPart = OldValidDataLength;
                        ExReleaseResourceLite( Header->PagingIoResource );

                    } else {

                        Header->FileSize.LowPart = OldFileSize;
                        Header->ValidDataLength.LowPart = OldValidDataLength;
                    }
                }

            //
            //  Here is the 64-bit or no-wait path.
            //

            } else {

                LARGE_INTEGER Offset, NewFileSize;
                LARGE_INTEGER OldFileSize;
                LARGE_INTEGER OldValidDataLength;

                ASSERT(!KeIsExecutingDpc());

                //
                //  Make our best guess on whether we need the file exclusive
                //  or shared.
                //

                NewFileSize.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;

                if (WriteToEndOfFile || (NewFileSize.QuadPart > Header->ValidDataLength.QuadPart)) {

                    //
                    //  Acquired shared on the common fcb header, and return
                    //  if we don't get it.
                    //

                    if (!ExAcquireResourceExclusiveLite( Header->Resource, Wait )) {

                        FsRtlExitFileSystem();

                        return FALSE;
                    }

                } else {

                    //
                    //  Acquired shared on the common fcb header, and return
                    //  if we don't get it.
                    //

                    if (!ExAcquireResourceSharedLite( Header->Resource, Wait )) {

                        FsRtlExitFileSystem();

                        return FALSE;
                    }

                    AcquiredShared = TRUE;
                }


                //
                //  We have the fcb shared now check if we can do fast i/o
                //  and if the file space is allocated, and if not then
                //  release the fcb and return.
                //

                if (WriteToEndOfFile) {

                    Offset = Header->FileSize;
                    NewFileSize.QuadPart = Header->FileSize.QuadPart + (LONGLONG)Length;

                } else {

                    Offset = *FileOffset;
                    NewFileSize.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
                }

                //
                //  Now that the File is acquired shared, we can safely test
                //  if it is really cached and if we can do fast i/o and we
                //  do not have to extend. If not then release the fcb and
                //  return.
                //
                //  Get out if we are about to zero too much as well, as commented above.
                //  Likewise, for NewFileSizes that exceed MAXLONGLONG.
                //

                if ((FileObject->PrivateCacheMap == NULL) ||
                    (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                      (Offset.QuadPart >= (Header->ValidDataLength.QuadPart + 0x2000)) ||
                      (MAXLONGLONG - Offset.QuadPart < (LONGLONG)Length) ||
                      (NewFileSize.QuadPart > Header->AllocationSize.QuadPart) ) {

                    ExReleaseResourceLite( Header->Resource );
                    FsRtlExitFileSystem();

                    return FALSE;
                }

                //
                //  If we will be extending ValidDataLength, we will have to
                //  get the Fcb exclusive, and make sure that FastIo is still
                //  possible.  We should only execute this block of code very
                //  rarely, when the unsafe test for ValidDataLength failed
                //  above.
                //

                if (AcquiredShared && ( NewFileSize.QuadPart > Header->ValidDataLength.QuadPart )) {

                    ExReleaseResourceLite( Header->Resource );

                    if (!ExAcquireResourceExclusiveLite( Header->Resource, Wait )) {

                        FsRtlExitFileSystem();

                        return FALSE;
                    }

                    //
                    // If writing to end of file, we must recalculate new size.
                    //

                    if (WriteToEndOfFile) {

                        Offset = Header->FileSize;
                        NewFileSize.QuadPart = Header->FileSize.QuadPart + (LONGLONG)Length;
                    }

                    if ((FileObject->PrivateCacheMap == NULL) ||
                        (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                        ( NewFileSize.QuadPart > Header->AllocationSize.QuadPart ) ) {

                        ExReleaseResourceLite( Header->Resource );
                        FsRtlExitFileSystem();

                        return FALSE;
                    }
                }

                //
                //  Check if fast I/O is questionable and if so then go ask
                //  the file system the answer
                //

                if (Header->IsFastIoPossible == FastIoIsQuestionable) {

                    PFAST_IO_DISPATCH FastIoDispatch = IoGetRelatedDeviceObject( FileObject )->DriverObject->FastIoDispatch;
                    IO_STATUS_BLOCK IoStatus;

                    //
                    //  All file system then set "Is Questionable" had better
                    //  support fast I/O
                    //

                    ASSERT(FastIoDispatch != NULL);
                    ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

                    //
                    //  Call the file system to check for fast I/O.  If the
                    //  answer is anything other than GoForIt then we cannot
                    //  take the fast I/O path.
                    //

                    ASSERT(FILE_WRITE_TO_END_OF_FILE == 0xffffffff);

                    if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                                FileOffset->QuadPart != (LONGLONG)-1 ?
                                                                  FileOffset : &Header->FileSize,
                                                                Length,
                                                                Wait,
                                                                LockKey,
                                                                FALSE, // write operation
                                                                &IoStatus,
                                                                DeviceObject )) {

                        //
                        //  Fast I/O is not possible so release the Fcb and
                        //  return.
                        //

                        ExReleaseResourceLite( Header->Resource );
                        FsRtlExitFileSystem();

                        return FALSE;
                    }
                }

                //
                //  Now see if we will change FileSize.  We have to do it now
                //  so that our reads are not nooped.
                //

                if ( NewFileSize.QuadPart > Header->FileSize.QuadPart ) {

                    FileSizeChanged = TRUE;
                    OldFileSize = Header->FileSize;
                    OldValidDataLength = Header->ValidDataLength;

                    //
                    //  Deal with an extremely rare pathalogical case here the
                    //  file size wraps.
                    //

                    if ( (Header->FileSize.HighPart != NewFileSize.HighPart) &&
                         (Header->PagingIoResource != NULL) ) {

                        (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                        Header->FileSize = NewFileSize;
                        ExReleaseResourceLite( Header->PagingIoResource );

                    } else {

                        Header->FileSize = NewFileSize;
                    }
                }

                //
                //  We can do fast i/o so call the cc routine to do the work
                //  and then release the fcb when we've done.  If for whatever
                //  reason the copy write fails, then return FALSE to our
                //  caller.
                //
                //  Also mark this as the top level "Irp" so that lower file
                //  system levels will not attempt a pop-up
                //

                PsGetCurrentThread()->TopLevelIrp = FSRTL_FAST_IO_TOP_LEVEL_IRP;

                try {

                    //
                    //  See if we have to do some zeroing
                    //

                    if ( Offset.QuadPart > Header->ValidDataLength.QuadPart ) {

                        Status = CcZeroData( FileObject,
                                             &Header->ValidDataLength,
                                             &Offset,
                                             Wait );
                    }

                    if (Status) {

                        Status = CcCopyWrite( FileObject,
                                              &Offset,
                                              Length,
                                              Wait,
                                              Buffer );
                    }

                } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                                ? EXCEPTION_EXECUTE_HANDLER
                                                : EXCEPTION_CONTINUE_SEARCH ) {

                    Status = FALSE;
                }

                PsGetCurrentThread()->TopLevelIrp = 0;

                //
                //  If we succeeded, see if we have to update FileSize or
                //  ValidDataLength.
                //

                if (Status) {

                    //
                    //  In the case of ValidDataLength, we really have to
                    //  check again since we did not do this when we acquired
                    //  the resource exclusive.
                    //

                    if ( NewFileSize.QuadPart > Header->ValidDataLength.QuadPart ) {

                        //
                        //  Deal with an extremely rare pathalogical case here
                        //  the ValidDataLength wraps.
                        //

                        if ( (Header->ValidDataLength.HighPart != NewFileSize.HighPart) &&
                             (Header->PagingIoResource != NULL) ) {

                            (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                            Header->ValidDataLength = NewFileSize;
                            ExReleaseResourceLite( Header->PagingIoResource );

                        } else {

                            Header->ValidDataLength = NewFileSize;
                        }
                    }

                    //
                    //  Set this handle as having modified the file
                    //

                    FileObject->Flags |= FO_FILE_MODIFIED;

                    if (FileSizeChanged) {

                        *CcGetFileSizePointer(FileObject) = NewFileSize;

                        FileObject->Flags |= FO_FILE_SIZE_CHANGED;
                    }

                    //
                    //  Also update the current file position pointer
                    //

                    FileObject->CurrentByteOffset.QuadPart = Offset.QuadPart + Length;

                //
                // If we did not succeed, then we must restore the original
                // FileSize while holding the PagingIoResource exclusive if
                // it exists.
                //

                } else if (FileSizeChanged) {

                    if ( Header->PagingIoResource != NULL ) {

                        (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                        Header->FileSize = OldFileSize;
                        Header->ValidDataLength = OldValidDataLength;
                        ExReleaseResourceLite( Header->PagingIoResource );

                    } else {

                        Header->FileSize = OldFileSize;
                        Header->ValidDataLength = OldValidDataLength;
                    }
                }

            }

            ExReleaseResourceLite( Header->Resource );
            FsRtlExitFileSystem();

            return Status;

        } else {

            //
            //  A zero length transfer was requested.
            //

            return TRUE;
        }

    } else {

        //
        // The volume must be verified or the file is write through.
        //

        return FALSE;
    }
}


BOOLEAN
FsRtlMdlReadDev (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached mdl read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcMdlRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    MdlChain - On output it returns a pointer to an MDL chain describing
        the desired data.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

    DeviceObject - Supplies DeviceObject for callee.

Return Value:

    FALSE - if the data was not delivered, or if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PFSRTL_COMMON_FCB_HEADER Header;
    BOOLEAN Status = TRUE;
    LARGE_INTEGER BeyondLastByte;

    PAGED_CODE();

    //
    //  Special case a read of zero length
    //

    if (Length == 0) {

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = 0;

        return TRUE;
    }

    //
    //  Overflows should've been handled by caller.
    //

    ASSERT(MAXLONGLONG - FileOffset->QuadPart >= (LONGLONG)Length);

       
    //
    //  Get a real pointer to the common fcb header
    //

    BeyondLastByte.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
    Header = (PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext;

    //
    //  Enter the file system
    //

    FsRtlEnterFileSystem();

    CcFastMdlReadWait += 1;

    //
    //  Acquired shared on the common fcb header
    //

    (VOID)ExAcquireResourceSharedLite( Header->Resource, TRUE );

    //
    //  Now that the File is acquired shared, we can safely test if it is
    //  really cached and if we can do fast i/o and if not
    //  then release the fcb and return.
    //

    if ((FileObject->PrivateCacheMap == NULL) ||
        (Header->IsFastIoPossible == FastIoIsNotPossible)) {

        ExReleaseResourceLite( Header->Resource );
        FsRtlExitFileSystem();

        CcFastMdlReadNotPossible += 1;

        return FALSE;
    }

    //
    //  Check if fast I/O is questionable and if so then go ask the file system
    //  the answer
    //

    if (Header->IsFastIoPossible == FastIoIsQuestionable) {

        PFAST_IO_DISPATCH FastIoDispatch;

        ASSERT(!KeIsExecutingDpc());

        FastIoDispatch = IoGetRelatedDeviceObject( FileObject )->DriverObject->FastIoDispatch;


        //
        //  All file system then set "Is Questionable" had better support fast I/O
        //

        ASSERT(FastIoDispatch != NULL);
        ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

        //
        //  Call the file system to check for fast I/O.  If the answer is anything
        //  other than GoForIt then we cannot take the fast I/O path.
        //

        if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                    FileOffset,
                                                    Length,
                                                    TRUE,
                                                    LockKey,
                                                    TRUE, // read operation
                                                    IoStatus,
                                                    IoGetRelatedDeviceObject( FileObject ) )) {

            //
            //  Fast I/O is not possible so release the Fcb and return.
            //

            ExReleaseResourceLite( Header->Resource );
            FsRtlExitFileSystem();

            CcFastMdlReadNotPossible += 1;

            return FALSE;
        }
    }

    //
    //  Check for read past file size.
    //

    if ( BeyondLastByte.QuadPart > Header->FileSize.QuadPart ) {

        if ( FileOffset->QuadPart >= Header->FileSize.QuadPart ) {
            IoStatus->Status = STATUS_END_OF_FILE;
            IoStatus->Information = 0;

            ExReleaseResourceLite( Header->Resource );
            FsRtlExitFileSystem();

            return TRUE;
        }

        Length = (ULONG)( Header->FileSize.QuadPart - FileOffset->QuadPart );
    }

    //
    //  We can do fast i/o so call the cc routine to do the work and then
    //  release the fcb when we've done.  If for whatever reason the
    //  mdl read fails, then return FALSE to our caller.
    //
    //
    //  Also mark this as the top level "Irp" so that lower file system levels
    //  will not attempt a pop-up
    //

    PsGetCurrentThread()->TopLevelIrp = FSRTL_FAST_IO_TOP_LEVEL_IRP;

    try {

        CcMdlRead( FileObject, FileOffset, Length, MdlChain, IoStatus );

        FileObject->Flags |= FO_FILE_FAST_IO_READ;

    } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                   ? EXCEPTION_EXECUTE_HANDLER
                                   : EXCEPTION_CONTINUE_SEARCH ) {

        Status = FALSE;
    }

    PsGetCurrentThread()->TopLevelIrp = 0;

    ExReleaseResourceLite( Header->Resource );
    FsRtlExitFileSystem();

    return Status;
}


//
//  The old routine will either dispatch or call FsRtlMdlReadDev
//

BOOLEAN
FsRtlMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This routine does a fast cached mdl read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcMdlRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    MdlChain - On output it returns a pointer to an MDL chain describing
        the desired data.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if the data was not delivered, or if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PDEVICE_OBJECT DeviceObject, VolumeDeviceObject;
    PFAST_IO_DISPATCH FastIoDispatch;

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;

    //
    //  See if the (top-level) FileSystem has a FastIo routine, and if so, call it.
    //

    if ((FastIoDispatch != NULL) &&
        (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlRead)) &&
        (FastIoDispatch->MdlRead != NULL)) {

        return FastIoDispatch->MdlRead( FileObject, FileOffset, Length, LockKey, MdlChain, IoStatus, DeviceObject );

    } else {

        //
        //  Get the DeviceObject for the volume.  If that DeviceObject is different, and
        //  it specifies the FastIo routine, then we have to return FALSE here and cause
        //  an Irp to get generated.
        //

        VolumeDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );
        if ((VolumeDeviceObject != DeviceObject) &&
            (FastIoDispatch = VolumeDeviceObject->DriverObject->FastIoDispatch) &&
            (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlRead)) &&
            (FastIoDispatch->MdlRead != NULL)) {

            return FALSE;

        //
        //  Otherwise, call the default routine.
        //

        } else {

            return FsRtlMdlReadDev( FileObject, FileOffset, Length, LockKey, MdlChain, IoStatus, DeviceObject );
        }
    }
}


//
//  The old routine will either dispatch or call FsRtlMdlReadCompleteDev
//

BOOLEAN
FsRtlMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain
    )

/*++

Routine Description:

    This routine does a fast cached mdl read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.

Arguments:

    FileObject - Pointer to the file object being read.

    MdlChain - Supplies a pointer to an MDL chain returned from CcMdlRead.

Return Value:

    None

--*/

{
    PDEVICE_OBJECT DeviceObject, VolumeDeviceObject;
    PFAST_IO_DISPATCH FastIoDispatch;

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;

    //
    //  See if the (top-level) FileSystem has a FastIo routine, and if so, call it.
    //

    if ((FastIoDispatch != NULL) &&
        (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlReadComplete)) &&
        (FastIoDispatch->MdlReadComplete != NULL)) {

        return FastIoDispatch->MdlReadComplete( FileObject, MdlChain, DeviceObject );

    } else {

        //
        //  Get the DeviceObject for the volume.  If that DeviceObject is different, and
        //  it specifies the FastIo routine, then we have to return FALSE here and cause
        //  an Irp to get generated.
        //

        VolumeDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );
        if ((VolumeDeviceObject != DeviceObject) &&
            (FastIoDispatch = VolumeDeviceObject->DriverObject->FastIoDispatch) &&
            (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlReadComplete)) &&
            (FastIoDispatch->MdlReadComplete != NULL)) {

            return FALSE;

        //
        //  Otherwise, call the default routine.
        //

        } else {

            return FsRtlMdlReadCompleteDev( FileObject, MdlChain, DeviceObject );
        }
    }
}


BOOLEAN
FsRtlMdlReadCompleteDev (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached mdl read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.

Arguments:

    FileObject - Pointer to the file object being read.

    MdlChain - Supplies a pointer to an MDL chain returned from CcMdlRead.

    DeviceObject - Supplies the DeviceObject for the callee.

Return Value:

    None

--*/


{
    CcMdlReadComplete2( FileObject, MdlChain );
    return TRUE;
}


BOOLEAN
FsRtlPrepareMdlWriteDev (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached mdl read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcMdlRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    MdlChain - On output it returns a pointer to an MDL chain describing
        the desired data.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

    DeviceObject - Supplies the DeviceObject for the callee.

Return Value:

    FALSE - if the data was not written, or if there is an I/O error.

    TRUE - if the data is being written

--*/

{
    PFSRTL_COMMON_FCB_HEADER Header;
    LARGE_INTEGER Offset, NewFileSize;
    LARGE_INTEGER OldFileSize;
    LARGE_INTEGER OldValidDataLength;
    BOOLEAN Status = TRUE;
    BOOLEAN AcquiredShared = FALSE;
    BOOLEAN FileSizeChanged = FALSE;
    BOOLEAN WriteToEndOfFile = (BOOLEAN)((FileOffset->LowPart == FILE_WRITE_TO_END_OF_FILE) &&
                                         (FileOffset->HighPart == -1));

    PAGED_CODE();

    //
    //  Call CcCanIWrite.  Also return FALSE if FileObject is write through,
    //  the File System must do that.
    //

    if ( !CcCanIWrite( FileObject, Length, TRUE, FALSE ) ||
         FlagOn( FileObject->Flags, FO_WRITE_THROUGH )) {

        return FALSE;
    }

    //
    //  Assume our transfer will work
    //

    IoStatus->Status = STATUS_SUCCESS;

    //
    //  Special case the zero byte length
    //

    if (Length == 0) {

        return TRUE;
    }

    //
    //  Get a real pointer to the common fcb header
    //

    Header = (PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext;

    //
    //  Enter the file system
    //

    FsRtlEnterFileSystem();

    //
    //  Make our best guess on whether we need the file exclusive or
    //  shared.
    //

    NewFileSize.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;

    if (WriteToEndOfFile || (NewFileSize.QuadPart > Header->ValidDataLength.QuadPart)) {

        //
        //  Acquired exclusive on the common fcb header, and return if we don't
        //  get it.
        //

        ExAcquireResourceExclusiveLite( Header->Resource, TRUE );

    } else {

        //
        //  Acquired shared on the common fcb header, and return if we don't
        //  get it.
        //

        ExAcquireResourceSharedLite( Header->Resource, TRUE );

        AcquiredShared = TRUE;
    }


    //
    //  We have the fcb shared now check if we can do fast i/o  and if the file
    //  space is allocated, and if not then release the fcb and return.
    //

    if (WriteToEndOfFile) {

        Offset = Header->FileSize;
        NewFileSize.QuadPart = Header->FileSize.QuadPart + (LONGLONG)Length;

    } else {

        Offset = *FileOffset;
        NewFileSize.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
    }

    //
    //  Now that the File is acquired shared, we can safely test if it is
    //  really cached and if we can do fast i/o and we do not have to extend.
    //  If not then release the fcb and return.
    //

    if ((FileObject->PrivateCacheMap == NULL) ||
        (Header->IsFastIoPossible == FastIoIsNotPossible) ||
        (MAXLONGLONG - Offset.QuadPart < (LONGLONG)Length) ||
        ( NewFileSize.QuadPart > Header->AllocationSize.QuadPart ) ) {

        ExReleaseResourceLite( Header->Resource );
        FsRtlExitFileSystem();

        return FALSE;
    }

    //
    //  If we will be extending ValidDataLength, we will have to get the
    //  Fcb exclusive, and make sure that FastIo is still possible.
    //

    if (AcquiredShared && ( NewFileSize.QuadPart > Header->ValidDataLength.QuadPart )) {

        ExReleaseResourceLite( Header->Resource );

        ExAcquireResourceExclusiveLite( Header->Resource, TRUE );

        AcquiredShared = FALSE;

        //
        //  If writing to end of file, we must recalculate new size.
        //

        if (WriteToEndOfFile) {

            Offset = Header->FileSize;
            NewFileSize.QuadPart = Header->FileSize.QuadPart + (LONGLONG)Length;
        }

        if ((FileObject->PrivateCacheMap == NULL) ||
            (Header->IsFastIoPossible == FastIoIsNotPossible) ||
            ( NewFileSize.QuadPart > Header->AllocationSize.QuadPart )) {

            ExReleaseResourceLite( Header->Resource );
            FsRtlExitFileSystem();

            return FALSE;
        }
    }

    //
    //  Check if fast I/O is questionable and if so then go ask the file system
    //  the answer
    //

    if (Header->IsFastIoPossible == FastIoIsQuestionable) {

        PFAST_IO_DISPATCH FastIoDispatch = IoGetRelatedDeviceObject( FileObject )->DriverObject->FastIoDispatch;

        //
        //  All file system then set "Is Questionable" had better support fast I/O
        //

        ASSERT(FastIoDispatch != NULL);
        ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

        //
        //  Call the file system to check for fast I/O.  If the answer is anything
        //  other than GoForIt then we cannot take the fast I/O path.
        //

        if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                    FileOffset,
                                                    Length,
                                                    TRUE,
                                                    LockKey,
                                                    FALSE, // write operation
                                                    IoStatus,
                                                    IoGetRelatedDeviceObject( FileObject ) )) {

            //
            //  Fast I/O is not possible so release the Fcb and return.
            //

            ExReleaseResourceLite( Header->Resource );
            FsRtlExitFileSystem();

            return FALSE;
        }
    }

    //
    // Now see if we will change FileSize.  We have to do it now so that our
    // reads are not nooped.
    //

    if ( NewFileSize.QuadPart > Header->FileSize.QuadPart ) {

        FileSizeChanged = TRUE;
        OldFileSize = Header->FileSize;
        OldValidDataLength = Header->ValidDataLength;

        //
        //  Deal with an extremely rare pathalogical case here the file
        //  size wraps.
        //

        if ( (Header->FileSize.HighPart != NewFileSize.HighPart) &&
             (Header->PagingIoResource != NULL) ) {

            (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
            Header->FileSize = NewFileSize;
            ExReleaseResourceLite( Header->PagingIoResource );

        } else {

            Header->FileSize = NewFileSize;
        }
    }

    //
    //  We can do fast i/o so call the cc routine to do the work and then
    //  release the fcb when we've done.  If for whatever reason the
    //  copy write fails, then return FALSE to our caller.
    //
    //
    //  Also mark this as the top level "Irp" so that lower file system levels
    //  will not attempt a pop-up
    //

    PsGetCurrentThread()->TopLevelIrp = FSRTL_FAST_IO_TOP_LEVEL_IRP;

    try {

        //
        //  See if we have to do some zeroing
        //

        if ( Offset.QuadPart > Header->ValidDataLength.QuadPart ) {

            Status = CcZeroData( FileObject,
                                 &Header->ValidDataLength,
                                 &Offset,
                                 TRUE );
        }

        if (Status) {

            CcPrepareMdlWrite( Fi