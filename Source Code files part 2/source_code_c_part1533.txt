ostedObject* pStartObj = NULL, bool fForward = true);
};

#endif //__MFBAR_H_
/*************************************************************************/
/* End of file: MFBar.h                                                  */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\mfbar.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MFBar.cpp                                                       */
/* Description: Control that is scriptable and contains other controls.  */
/* Designed specifically for DVD/TV control plates.                      */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "MFBar.h"
#include "ccobj.h"
#include "eobj.h"
#include "CBitmap.h"

/*************************************************************************/
/* Local defines                                                         */
/* Could not find these under windows headers, so if there is a conflict */
/* it is good idea to ifdef these out.                                   */
/*************************************************************************/
#define GET_X_LPARAM(lp)   ((int)(short)LOWORD(lp))
#define GET_Y_LPARAM(lp)   ((int)(short)HIWORD(lp))
#define RECTWIDTH(lpRect)     ((lpRect)->right - (lpRect)->left)
#define RECTHEIGHT(lpRect)    ((lpRect)->bottom - (lpRect)->top)
#define NOHIT               1
#define LEFT                2
#define TOP                 4
#define RIGHT               8
#define BOTTOM              16
#define ID_EV_TIMER         0xff

/*************************************************************************/
/* Windows defines not present, remove when doing the real BUILD.        */
/*************************************************************************/
typedef WINUSERAPI BOOL ( WINAPI * SETLAYEREDWINDATR)(
    HWND hwnd,
    COLORREF crKey,
    BYTE bAlpha,
    DWORD dwFlags);
#if 0
#define LWA_COLORKEY            0x00000001
#endif
/*************************************************************************/
/* Local functions                                                       */
/*************************************************************************/
inline long MAX(long l1, long l2){return(l1 > l2 ? l1 : l2);}
inline long MIN(long l1, long l2){return(l1 < l2 ? l1 : l2);}

/*************************************************************************/
/* Statics for window class info                                         */
/*************************************************************************/
HICON CMFBar::m_hIcon = NULL;

/*****************************************************************/
/* change this depending if the file was saved as Unicode or not */
/*****************************************************************/
//#define _UNICODE_SCRIPT_FILE 

/*************************************************************************/
/* CMFBar Implementation                                                 */
/*************************************************************************/

/*************************************************************************/
/* Function:  Init                                                       */
/* Description: Initializes memeber variables.                           */
/*************************************************************************/
HRESULT CMFBar::Init(){

    HRESULT hr = S_OK;

// ####  BEGIN CONTAINER SUPPORT ####
    m_bCanWindowlessActivate = true;
// ####  END CONTAINER SUPPORT ####
    
#if 1 // used for getting the windowed case working DJ
    m_bWindowOnly = TRUE;
#endif
    m_fSelfHosted = false;

    // TODO: Investigate if it works in pallete mode
    m_clrBackColor = ::GetSysColor(COLOR_BTNFACE);
    m_lMinWidth = -1;  // disable it 
    m_lMinHeight = -1;  // disable it by default
    m_fHandleHelp = false;
    m_blitType = DISABLE;
    m_bMouseDown = false;
    m_ptMouse.x = 0;
    m_ptMouse.y = 0;
    m_nReadyState = READYSTATE_LOADING;        
    m_fAutoLoad = VARIANT_TRUE;
    m_pBackBitmap = NULL;
    m_fForceKey = false;
    m_lTimeout = 0;
    m_fUserActivity = false;
    m_fWaitingForActivity = false;

    // setup the default resource DLL to be this binary
    m_hRes = _Module.m_hInstResource; // set the resource DLL Name
    TCHAR szModule[_MAX_PATH+10];
    ::GetModuleFileName(m_hRes, szModule, _MAX_PATH);

    USES_CONVERSION;
    m_strResDLL = T2OLE(szModule);

    if(NULL == m_hIcon){

         m_hIcon = ::LoadIcon(m_hRes, MAKEINTRESOURCE(IDI_ICON1));
         //m_hIcon = (HICON)::LoadImage(_Module.m_hInstResource, MAKEINTRESOURCE(IDI_ICON1),
         //   IMAGE_ICON, ::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR);
    }/* end of if statement */
    
    
   return(hr);
}/* end of function Init */

/*************************************************************************/
/* Function: Cleanup                                                     */
/* Description: Makes sure the script engine is released. Also cleans    */
/* up the contained objects in the containers.                           */
/*************************************************************************/
HRESULT CMFBar::Cleanup(){
// ##### BEGIN ACTIVEX SCRIPTING SUPPORT #####
  // Release the language engine, since it may hold on to us
    if (m_psp){

        m_psp.Release();
    }/* end of if statement */

    if (m_ps){

        m_ps->Close();
        m_ps.Release();
    }/* end of if statement */

    // cleanup the event list    
    for(CNTEVNT::iterator i = m_cntEvnt.begin(); false == m_cntEvnt.empty(); ){        

        CEventObject* pObj = (*i);
        delete pObj;
        i = m_cntEvnt.erase(i);
    }/* end of if statement */
    
    CContainerObject* pSelfContainerObj = NULL;
    // cleanup the object list    
    for(CNTOBJ::iterator j = m_cntObj.begin(); false == m_cntObj.empty(); ){        

        CHostedObject* pObj = (*j);

        // delete the container object as well
        CContainerObject* pContainerObj;
        HRESULT hrCont = pObj->GetContainerObject(&pContainerObj);
        
        IUnknown* pUnk = pObj->GetUnknown();
#if _DEBUG

        BSTR strOBJID = ::SysAllocString(pObj->GetID());
#endif
        try {

            delete pObj;
        }
        catch(...){
#if _DEBUG
            USES_CONVERSION;
            ATLTRACE(TEXT(" Failed to destroy %s "), OLE2T(strOBJID));
            ::SysFreeString(strOBJID);
#endif
        }/* end of catch statement */

        if(SUCCEEDED(hrCont)){

#if 1
            if(GetUnknown() != pUnk){

                delete pContainerObj; // do not delete our self
            }
            else {

                pSelfContainerObj = pContainerObj;
            }/* end of if statement */
#endif
        }/* end of if statement */

        j = m_cntObj.erase(j);
    }/* end of if statement */

    ResetFocusArray();
    
    delete pSelfContainerObj;

    if(m_pBackBitmap){

        delete m_pBackBitmap;
        m_pBackBitmap = NULL;
    }/* end of if statement */

    HRESULT hr = Init();
// #####  END  ACTIVEX SCRIPTING SUPPORT #####

    return (hr);
}/* end of function Cleanup */

/*************************************************************************/
/* Function:  ~CMFBar                                                    */
/*************************************************************************/
CMFBar::~CMFBar(){

    Cleanup();
    ATLTRACE(TEXT("Exiting CMFBar destructor! \n"));
}/* end of function  ~CMFBar */

/*************************************************************************/
/* Message handling.                                                     */
/*************************************************************************/

/*************************************************************************/
/* Function: OnPaint                                                     */
/* Description: Had to overwrite the the deafult OnPaint so I could      */
/* somehow get the real update rects.                                    */
/*************************************************************************/
LRESULT CMFBar::OnPaint(UINT /* uMsg */, WPARAM wParam,
	LPARAM /* lParam */, BOOL& /* lResult */){

	RECT rc;
	PAINTSTRUCT ps;

	HDC hdc = (wParam != NULL) ? (HDC)wParam : ::BeginPaint(m_hWndCD, &ps);
	if (hdc == NULL)
		return 0;
	::GetClientRect(m_hWndCD, &rc);

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = DVASPECT_CONTENT;
	di.lindex = -1;
	di.hdcDraw = hdc;
    // DJ change here, keep the real update rect from the PAINTSTRUCT
    // Set the window size to the size of the window
    di.prcWBounds = (LPCRECTL)&rc; 
    di.prcBounds = (LPCRECTL)&ps.rcPaint; 

	OnDrawAdvanced(di); // Eventually propagates to OnDraw
	if (wParam == NULL)
		::EndPaint(m_hWndCD, &ps);
	return 0; 
}/* end of function OnPaint */

/*************************************************************************/
/* Function: OnDraw                                                      */
/* Description: Just Draws the rectangular background and contained      */
/* windowless controls.                                                  */
/*************************************************************************/
HRESULT CMFBar::OnDraw(ATL_DRAWINFO& di){

    try {
        HDC hdc = di.hdcDraw;

        RECT rcClient = *(RECT*)di.prcBounds;        
        RECT rcWClient = *(RECT*)di.prcWBounds;           

        // this might not work if you overlapp the controls
        // controls like to be painted as a whole so if
        // we need to update the are that contains the control
        // we need to find all the controls that intersect it, combine the
        // rectangle and then repaint the whole region
        if(::IsWindow(m_hWnd)){

            if(!::EqualRect(&rcClient, &rcWClient)){

                RECT rcNewClient = rcClient; // the original update are which we are enlarging
                for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
                    // iterate through all the contained objects and draw them
                    CHostedObject* pObj = (*i);
                       
                    if((NULL != pObj) && (pObj->IsActive())){

                        if(pObj->IsWindowless()){
                        
                            RECT rcCntrl;
                            pObj->GetPos(&rcCntrl); // get the position of the object

                            RECT rcInt;
                            if(!::IntersectRect(&rcInt, &rcCntrl, &rcClient)){

                                continue;
                            }
                            else {
                                // OK we need to add this control rect to our rect union
                                ::UnionRect(&rcNewClient, &rcClient, &rcCntrl);
                            }/* end of if statement */                                                  
		                }/* end of if statement */
                    }/* end of if statement */
                }/* end of for loop */

                rcClient = rcNewClient; // update our are with enlarged client
            }/* end of if statement */
            // else if the rects are the same we are updating the whole
            // window so there is no point to do the calculations
        }/* end of if statement */

        COLORREF clr;
        HPALETTE hPal = NULL;
        
        if(m_pBackBitmap){
                        
            hPal = m_pBackBitmap->GetPal();

            if(NULL != hPal){

                ::SelectPalette(hdc, hPal, FALSE);
                ::RealizePalette(hdc);
            }/* end of if statement */
        }/* end of if statement */
        
        ::OleTranslateColor (m_clrBackColor, hPal, &clr);        
     
        // fill in the background and get ready to fill in the objects
        LONG lBmpWidth = RECTWIDTH(&rcWClient);
        LONG lBmpHeight = RECTHEIGHT(&rcWClient);

        HBITMAP hBitmap = ::CreateCompatibleBitmap(hdc, lBmpWidth, lBmpHeight);

        if(NULL == hBitmap){

            ATLASSERT(FALSE);
            return(0);
        }/* end of if statement */

	    HDC hdcCompatible = ::CreateCompatibleDC(hdc);

        if(NULL == hBitmap){

            ATLASSERT(FALSE);
            ::DeleteObject(hBitmap);
            return(0);
        }/* end of if statement */

        // Draw background on the faceplate bitmap
        ::SelectObject(hdcCompatible, hBitmap); 
        
        if (!m_pBackBitmap){
            // fill background of specific color
            HBRUSH hbrBack = ::CreateSolidBrush(clr);            
            //::FillRect(hdc, &rcClient, hbrBack);
            ::FillRect(hdcCompatible, &rcClient, hbrBack);
            ::DeleteObject(hbrBack);
        }
        else {
            
            //BOOL bRet = m_pBackBitmap->PaintTransparentDIB(hdc, &rcWClient, &rcClient, m_blitType, true);
            BOOL bRet = m_pBackBitmap->PaintTransparentDIB(hdcCompatible, &rcWClient, &rcClient, m_blitType, true);
            
            if(!bRet){
                
                ATLTRACE(TEXT(" The transparent Blit did not work!"));
            }/* end of if statement */
        }/* end of if statement */
        
        for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
        // iterate through all the contained objects and draw them
            CHostedObject* pObj = (*i);

            CComPtr<IViewObjectEx> pViewObject = NULL;
        
            if((NULL != pObj) && (pObj->IsActive()) && (SUCCEEDED(pObj->GetViewObject(&pViewObject)))){

                if(pObj->IsWindowless()){

                    if(pViewObject){

                        if(GetUnknown() == pObj->GetUnknown()){
                            // in case we are windowless and we are trying to draw our self again
                            continue;
                        }/* end of if statement */                    
                        
                        RECT rcCntrl;
                        pObj->GetPos(&rcCntrl);

                        RECT rcInt;
                        if(!::IntersectRect(&rcInt, &rcCntrl, &rcClient)){

                            continue;
                        }/* end of if statement */
                        
                        LONG lBmpWidth = RECTWIDTH(&rcCntrl);
                        LONG lBmpHeight = RECTHEIGHT(&rcCntrl);
                        RECT rcCntrlBitmap = {0, 0, lBmpWidth, lBmpHeight};

                        POINT ptNewOffset = {rcCntrl.left, rcCntrl.top};
                        
                        POINT ptOldOffset;

                        ::GetViewportOrgEx(hdcCompatible, &ptOldOffset);
                        LPtoDP(hdcCompatible, &ptNewOffset, 1);
                        // offset the rect we are catually going to draw
                        //::OffsetRect(&rcInt, -ptNewOffset.x, -ptNewOffset.y);
                        // offset the DC
                        ::OffsetViewportOrgEx(hdcCompatible, ptNewOffset.x, ptNewOffset.y, &ptOldOffset);
                        
                       // draw
                        ATLTRACE2(atlTraceWindowing, 31, TEXT("Drawing CONTROL into rcClient.left = %d, rcClient.right = %d, rcClient.bottom =%d, rcClient.top = %d\n"),rcCntrl.left, rcCntrl.right, rcCntrl.bottom, rcCntrl.top); 
#if 1    // used to redraw the whole control, now we are just doinf part of it
                        //HRGN hrgnOld = NULL;
                        //HRGN hrgnNew = NULL;
                        //if(::IsWindow(m_hWnd)){
                        //
                        //    hrgnNew = ::CreateRectRgnIndirect(&rcInt);
                        //    hrgnOld = (HRGN)::SelectObject(hdc, hrgnNew);                            
                        //}/* end of if statement */

			            pViewObject->Draw(DVASPECT_CONTENT, -1, NULL, NULL, NULL, hdcCompatible, (RECTL*)&rcCntrlBitmap, (RECTL*)&rcCntrlBitmap, NULL, NULL); 
#else
                        pViewObject->Draw(DVASPECT_CONTENT, -1, NULL, NULL, NULL, hdcCompatible, (RECTL*)&rcInt, (RECTL*)&rcCntrlBitmap, NULL, NULL); 
#endif                       
                        ::SetViewportOrgEx(hdcCompatible, ptOldOffset.x, ptOldOffset.y, NULL);
                    }
    #ifdef _DEBUG
                    else {

                        ATLTRACE2(atlTraceWindowing, 30,TEXT("FAILED Drawing the object since pView is NULL\n"));              
                    }/* end of if statement */
    #endif                                    
		        }/* end of if statement */
            }/* end of if statement */
        }/* end of for loop */

        ::BitBlt(hdc, rcClient.left, rcClient.top, lBmpWidth, lBmpHeight,  hdcCompatible, rcClient.left, rcClient.top, SRCCOPY);             
        // cleanup
        ::DeleteDC(hdcCompatible);        
        ::DeleteObject(hBitmap);        
                
        return(1);       
    }/* end of try statement */
    catch(...){
        return(0);
    }/* end of catch statement */
}/* end of function OnDraw */

/*************************************************************************/
/* Function: OnErase                                                     */
/* Description: Skip the erasing to avoid flickers.                      */
/*************************************************************************/
LRESULT CMFBar::OnErase(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    ATLTRACE2(atlTraceWindowing, 32, TEXT("Received WM_ERASE MESSAGE \n")); 

#if 0
    POINT pt; pt.x =0; pt.y = 0;
    ::MapWindowPoints(m_hWnd, hWndPar, &pt, 1);
    ::OffsetWindowOrgEx(hdc, pt.x, pt.y, &pt);        
    ::SendMessage(hWndPar, WM_ERASEBKGND, (WPARAM) hdc, 0);
    ::SetWindowOrgEx(hdc, pt.x, pt.y, NULL);
    
#endif

    //InvalidateRect(&m_rcPos, FALSE);

    bHandled = TRUE;
	return 1;
}/* end of function OnErase */

/*************************************************************************/
/* Function: OnQueryNewPalette                                           */
/* Description: Called when we are about to be instantiated.             */
/*************************************************************************/
LRESULT CMFBar::OnQueryNewPalette(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if(NULL == ::IsWindow(m_hWnd)){

        bHandled = FALSE;
        return FALSE;
    }/* end of if statement */

    HPALETTE hPal = NULL;

    if(NULL == m_pBackBitmap){
            
        hPal = m_pBackBitmap->GetPal();
    }/* end of if statement */

    if(NULL == hPal){

        //bHandled = FALSE;
        return FALSE;
    }/* end of if statement */

    HDC hdc = ::GetDC(m_hWnd);
    ::SelectPalette(hdc, hPal, FALSE);
    ::RealizePalette(hdc);
    ::InvalidateRect(m_hWnd, NULL, FALSE);

    ::ReleaseDC(m_hWnd, hdc);
    
	return TRUE;
}/* end of function OnQueryNewPalette */

/*************************************************************************/
/* Function: OnPaletteChanged                                            */
/* Description: Called when palette is chaning.                          */
/*************************************************************************/
LRESULT CMFBar::OnPaletteChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if(NULL == ::IsWindow(m_hWnd)){

        bHandled = FALSE;
        return FALSE;
    }/* end of if statement */

    if((HWND) wParam == m_hWnd){

        bHandled = FALSE;
        return FALSE;
    }/* end of if statement */

    HPALETTE hPal = NULL;

    if(NULL == m_pBackBitmap){
            
        hPal = m_pBackBitmap->GetPal();        
    }/* end of if statement */    

    if(NULL == hPal){

        bHandled = FALSE;
        return FALSE;
    }/* end of if statement */

    HDC hdc = ::GetDC(m_hWnd);
    ::SelectPalette(hdc, hPal, FALSE);
    ::RealizePalette(hdc);
    ::UpdateColors(hdc);
    
    ::ReleaseDC(m_hWnd, hdc);

    bHandled = FALSE;
    
	return TRUE;
}/* end of function OnPaletteChanged */

/*************************************************************************/
/* Function: OnClose                                                     */
/* Description: Skip the erasing to avoid flickers.                      */
/*************************************************************************/
LRESULT CMFBar::OnClose(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if(::IsWindow(m_hWnd)){

        ::DestroyWindow(m_hWnd);
    }/* end of if statement */

    HRESULT hr = Close(OLECLOSE_SAVEIFDIRTY);
    ATLTRACE(TEXT("Closing \n"));

    if(SUCCEEDED(hr)){

        bHandled = TRUE;
    }/* end of if statement */
    
    return 0;
}/* end of function OnClose */

/*************************************************************************/
/* Function: OnSysCommand                                                */
/* Description: Handles the on syscommand.                               */
/*************************************************************************/
LRESULT CMFBar::OnSysCommand(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    ATLTRACE2(atlTraceWindowing, 20, TEXT("Received WM_SYSCOMMAND MESSAGE \n")); 

    if(wParam == SC_CONTEXTHELP){

        m_fHandleHelp = true;
    }/* end of if statement */
    
    bHandled = FALSE;
    return(1);    
}/* end of function OnSysCommand */

/*************************************************************************/
/* Function: OnTimer                                                     */
/* Description: Handles the timer message.                               */
/*************************************************************************/
LRESULT CMFBar::OnTimer(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    WPARAM wTimerID = wParam;

    if(ID_EV_TIMER == wTimerID){

        if(false == m_fUserActivity && false == m_fWaitingForActivity){

            // fire message that there is no activity going on 
            m_fWaitingForActivity = true;
            Fire_ActivityDeclined();        
        }/* end of if statement */

        m_fUserActivity = false; // reset the flag
    } 
    else {

        if(::IsWindow(m_hWnd)){

            ::KillTimer(m_hWnd, wTimerID);
        }/* end of if statement */

        Fire_Timeout(wTimerID);        
    }/* end of if statement */
    
    bHandled = TRUE;
    return(1);    
}/* end of function OnTimer */

/*************************************************************************/
/* Function: OnCaptureChanged                                            */
/* Description: Handles the on syscommand.                               */
/*************************************************************************/
LRESULT CMFBar::OnCaptureChanged(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    ATLTRACE2(atlTraceWindowing, 20, TEXT("Received WM_CAPTURECHANGED MESSAGE \n")); 
   
    if(m_fHandleHelp){

        HWND h;
        if(SUCCEEDED(GetWindow(&h))){

            POINT pt;
            ::GetCursorPos(&pt);
            RECT rc;
            ::GetWindowRect(h, &rc);

            if(!::PtInRect(&rc, pt)){
                // we clicked somewhere outiside in our help mode
                m_fHandleHelp = false; // otherwise we are going to get lbutton up and we will
                                       // turn it off then
            }/* end of if statement */
        }
        else {

            m_fHandleHelp = false; // could not get the window, but better trun off
                                   // the help mode
        }/* end of if statement */
    }/* end of if statement */

    bHandled = TRUE;
    return(0);    
}/* end of function OnCaptureChanged */

/*************************************************************************/
/* Function: OnSetIcon                                                   */
/* Description: Fires the help event.                                    */
/*************************************************************************/
LRESULT CMFBar::OnSetIcon(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    LRESULT lr = ::DefWindowProc(m_hWnd, uMsg, wParam, lParam);

    return(lr);
}/* end of function OnSetIcon */

/*************************************************************************/
/* Function: OnInitDialog                                                */
/* Description: Fires the help event.                                    */
/*************************************************************************/
LRESULT CMFBar::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    ATLASSERT(FALSE);
    LRESULT lr = ::DefWindowProc(m_hWnd, uMsg, wParam, lParam);

    return(lr);
}/* end of function OnInitDialog */

/*************************************************************************/
/* Function: OnHelp                                                      */
/* Description: Fires the help event.                                    */
/*************************************************************************/
LRESULT CMFBar::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    HELPINFO* pHpi = (LPHELPINFO) lParam;
    bHandled = TRUE;

    if(NULL == pHpi){

        return 0;
    }/* end of if statement */

    // first check if we have fired help on message box
    HWND hCntrlWnd = (HWND)pHpi->hItemHandle;

    if(::GetWindowLong(hCntrlWnd, GWL_STYLE) & WS_DLGFRAME == WS_DLGFRAME){
        // we have a message box up

        HWND hwndText;

        hwndText = ::FindWindowEx(hCntrlWnd, NULL, TEXT("Static"), NULL);

        if(hwndText){

            TCHAR strWindowText[MAX_PATH];
            ::GetWindowText(hwndText, strWindowText, MAX_PATH);

            ::DestroyWindow(hCntrlWnd);

            BSTR strToolbarName;

            if(SUCCEEDED(GetToolbarName(&strToolbarName))){

                USES_CONVERSION;            
                Fire_OnHelp(strToolbarName, ::SysAllocString(T2OLE(strWindowText)));
            }/* end of if statement */
        }
        else {

            ::DestroyWindow(hCntrlWnd);
        }/* end of if statement */

        return(TRUE);
    }/* end of if statement */

    // then check if a windowed control has fired help
    for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
    // iterate through all the contained controls
        
        CHostedObject* pObj = (*i);
        
        if(NULL == pObj){

            ATLASSERT(FALSE); // should not be null
            continue;
        }/* end of if statement */

        if(pObj->IsActive() && !pObj->IsWindowless()){
            
            HWND hwnd = NULL;

            HRESULT hr = pObj->GetWindow(&hwnd);

            if(FAILED(hr)){

                continue;
            }/* end of if statement */

            if(hwnd == hCntrlWnd){

                Fire_OnHelp(::SysAllocString(pObj->GetID()));                                
                return(TRUE);
            }/* end of if statement */        
        }/* end of if statement */
    }/* end of for loop */

    // now look into windowless control
    POINT ptMouse = pHpi->MousePos;

    m_fHandleHelp = false; // get our self out of the help mode in case we clicked
    // on windowed control and we did not get notified about this 

    // convert the point to client coordinates
    HWND h = NULL;
    HRESULT hr = GetWindow(&h);

    if(FAILED(hr)){

        ATLASSERT(FALSE);    
        return(0);
    }/* end of if statement */

    if(!::ScreenToClient(h, &ptMouse)){

        ATLASSERT(FALSE);    
        return(0);
    }/* end of if statement */
        
    for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
    // iterate through all the contained controls
        
        CHostedObject* pObj = (*i);
        
        if(NULL == pObj){

            ATLASSERT(FALSE); // should not be null
            continue;
        }/* end of if statement */


        // send the message to the control over which we are howering or on which we
        // have clicked, check if we already are ready to send the message
        // in that case do not bother with the rect interstec bussines
        if(pObj->IsActive()){
            
            CComPtr<IViewObjectEx> pViewObject;
            HRESULT hr = pObj->GetViewObject(&pViewObject);

            if(FAILED(hr)){

                ATLASSERT(FALSE); // should have a view
                continue;
            }/* end of if statement */

            DWORD dwHitResult = HITRESULT_OUTSIDE;
            
            RECT rcCntrl;
            pObj->GetPos(&rcCntrl);

			pViewObject->QueryHitPoint(DVASPECT_CONTENT, &rcCntrl, ptMouse, 0, &dwHitResult);
			
            if(HITRESULT_HIT == dwHitResult){
                Fire_OnHelp(::SysAllocString(pObj->GetID()));                                
                return(TRUE);
            }/* end of if statement */        
            
        }/* end of if statement */
    }/* end of for loop */

    // Get toolbar name
    BSTR strToolbarName;

    if(SUCCEEDED(GetToolbarName(&strToolbarName))){

        Fire_OnHelp(strToolbarName);
    }/* end of if statement */

    return(TRUE);
}/* end of function OnHelp */

/*************************************************************************/
/* Function: OnSize                                                      */
/* Description: Handles the onsize message if we are self contained.     */
/*************************************************************************/
LRESULT CMFBar::OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if(false == m_fSelfHosted){

        bHandled = FALSE;
        return 0;
    }/* end of if statement */

    LONG lWidth = LOWORD(lParam);
    LONG lHeight = HIWORD(lParam);

    Fire_OnResize(lWidth, lHeight, wParam);

    if (m_pBackBitmap) {
        InvalidateRgn();
        if (::IsWindow(m_hWnd))
            ::UpdateWindow(m_hWnd);
    }

    bHandled = true;

    return 0;
}/* end of function OnSize */

/*************************************************************************/
/* Function: OnSizing                                                    */
/* Description: Does not let us scale beyond the minimum size. If it     */
/* tries to we fix up the rect on it.                                    */
/*************************************************************************/
LRESULT CMFBar::OnSizing(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if(false == m_fSelfHosted){

        bHandled = FALSE;
        return 0;
    }/* end of if statement */

    RECT* lpRect = (LPRECT)lParam;
    
    LONG lWidth = RECTWIDTH(lpRect);
    LONG lHeight = RECTHEIGHT(lpRect);

    // if we are going to be to small fix the rect
    if(lWidth < m_lMinWidth){

        lpRect->right = lpRect->left + m_lMinWidth;
    }/* end of if statement */

    if(lHeight < m_lMinHeight){

        lpRect->bottom = lpRect->top + m_lMinHeight;
    }/* end of if statement */
   
    bHandled = true;

    return 0;
}/* end of function OnSizing */

/*************************************************************************/
/* Function: Close                                                       */
/* Description: Just exposes the underlaying Close functionality to our  */
/* custom interface.                                                     */
/*************************************************************************/
STDMETHODIMP CMFBar::Close(){


    if(::IsWindow(m_hWnd)){

        ::PostMessage(m_hWnd, WM_CLOSE, NULL, NULL);

        return(S_OK);
        //::DestroyWindow(m_hWnd);
    }/* end of if statement */

	return(Close(OLECLOSE_SAVEIFDIRTY));
}/* end of function Close */

/*************************************************************************/
/* Function: Close                                                       */
/* Description: Calls OLECLOSE the contained objects, then itself.       */
/* The cleans up the containers and send WM_QUIT if we are self hosting. */
/*************************************************************************/
STDMETHODIMP CMFBar::Close(DWORD dwSaveOption){
       
    HRESULT hr = DestroyScriptEngine();

    ATLASSERT(SUCCEEDED(hr));

    for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        // iterate through all the contained objects and call on the Close
        CHostedObject* pObj = (*i);

        CComPtr<IOleObject> pIOleObject;
        HRESULT hrIOleObj = pObj->GetOleObject(&pIOleObject);

        if(FAILED(hr)){

            continue;
        }/* end of if statement */

        if(GetUnknown() == pObj->GetUnknown()){

            continue; // that is us we close our self later after the contained objects
        }/* end of if statement */

        pIOleObject->Close(dwSaveOption);               

        //pIOleObject->Release(); // we added a reference, we better clean it up now
    }/* end of for loop */    

    hr = IOleObjectImpl<CMFBar>::Close(dwSaveOption);
    
    bool fSelfHosted = m_fSelfHosted; // cache up the variable, since we are going to
                                      // wipe it out

    Cleanup(); // delete all the objects

    if(fSelfHosted){

        ::PostMessage(NULL, WM_QUIT, NULL, NULL); // tell our container to give up
    }/* end of if statement */

    return(hr);
}/* end of function Close */

/*************************************************************************/
/* Function: AddFocusObject                                              */
/* Description: Adds an object to the end of the focus array.            */
/*************************************************************************/
STDMETHODIMP CMFBar::AddFocusObject(BSTR strObjectID){

	HRESULT hr = S_OK;

    try {

        CHostedObject* pObj;

        hr = FindObject(strObjectID, &pObj);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        m_cntFocus.insert(m_cntFocus.end(), pObj);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of try statement */

	return (hr);
}/* end of function AddFocusObject */

/*************************************************************************/
/* Function: ResetFocusArray                                             */
/* Description: Resets the focus array.                                  */
/*************************************************************************/
STDMETHODIMP CMFBar::ResetFocusArray(){

	HRESULT hr = S_OK;

    try {
        ResetFocusFlags();

        // cleanup the focus array    
        for(CNTOBJ::iterator k = m_cntFocus.begin(); false == m_cntFocus.empty(); ){        

            k = m_cntFocus.erase(k);
        }/* end of for loop */
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of try statement */

	return (hr);
}/* end of function ResetFocusArray */

/*************************************************************************/
/* Function: OnSetFocus                                                  */
/* Description: Iterates through the container and sends the focus       */
/* message to the control that thinks it has the focus.                  */
/*************************************************************************/
LRESULT CMFBar::OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    bHandled = TRUE;
    LONG lRes = 0;

    if(m_cntObj.empty() == true){

    	return 0;
    }/* end of if statement */

    MoveFocus(TRUE, lRes);

	return lRes;
}/* end of function OnSetFocus */

/*************************************************************************/
/* Function: OnUserFocus                                                 */
/* Description: Iterates through the container and sends the focus       */
/* message to the control that thinks it has the focus. In this case     */
/* the control is specified by hwnd and that it is a windowed control.   */
/*************************************************************************/
LRESULT CMFBar::OnUserFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    bHandled = TRUE;
    LONG lRes = 0;

    HRESULT hr = E_FAIL; // did not find the object

    for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        CHostedObject* pObj = (*i);
        
        if(NULL == pObj){

            continue;
        }/* end of if statement */

        HWND hwndCtrl = NULL;
        hr = pObj->GetWindow(&hwndCtrl);

        if(FAILED(hr)){

            continue;
        }/* end of if statement */

        if(hwndCtrl == (HWND) wParam){

            SetClosestFocus(lRes, pObj);

            //SetObjectFocus(pObj, TRUE, lRes);            
            return(lRes);
        }/* end of if statement */
    }/* end of for loop */

	return lRes;
}/* end of function OnUserFocus */

/*************************************************************************/
/* Function: OnKillFocus                                                 */
/* Description: Sends the kill focus message to the control that has     */
/* Itterates through the container and removes the focus                 */
/* from the contained objects.                                           */
/*************************************************************************/
LRESULT CMFBar::OnKillFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    bHandled = TRUE;
    LONG lRes = 0;

    if(m_cntObj.empty() == true){

    	return 0;
    }/* end of if statement */

    bool bFirstElement = true;
	CNTOBJ::iterator i;
    for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
        
        CHostedObject* pObj = (*i);
        if(pObj->HasFocus()){

            HRESULT hr = SetObjectFocus(pObj, FALSE, lRes);
                          
            if(SUCCEEDED(hr)){
            
                return lRes;    
            }/* end of if statement */
        }/* end of if statement */
    }/* end of for loop */        
	
    //ResetFocusFlags(); // cleanup the focus flags
    
	return lRes;
}/* end of function OnKillFocus */ 

/*************************************************************************/
/* Function: OnMouseMessage                                              */
/* Description: Handles the mouse messages, distrubutes to proper        */
/* controls if needed.                                                   */
/*************************************************************************/
LRESULT CMFBar::OnMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                               BOOL& bHandled){

    LONG lRes = 0;
    bHandled = FALSE; // indicated if we dispatched the message

    if(m_lTimeout > 0){

        //WM_MOUSEMOVE messages keep comming over even if we really do not move the mouse

        bool bResetActivity = false;
        if(WM_MOUSEMOVE == uMsg){

            static WPARAM wParTmp = 0;
            static LPARAM lParTmp = 0;

            if(wParam != wParTmp || lParam != lParTmp){

                 bResetActivity = true;
            }/* end of if statement */

            if(wParam & MK_CONTROL ||
               wParam & MK_CONTROL ||
               wParam & MK_LBUTTON ||
               wParam & MK_MBUTTON ||
               wParam & MK_RBUTTON ||
               wParam & MK_SHIFT   ){

                 bResetActivity = true;
            }/* end of if statement */

            lParTmp = lParam;
            wParTmp = wParam;
        }
        else {

            bResetActivity = true;
        }/* end of if statement */
        
        if(bResetActivity){

            m_fUserActivity = true;

            if(m_fWaitingForActivity){

                Fire_ActivityStarted();        
                m_fWaitingForActivity = false;
            }/* end of if statement */
        }/* end of if statement */
    }/* end of if statement */

    ATLTRACE2(atlTraceWindowing, 32, TEXT("R WM_ button message : "));

    if(!m_bMouseDown){
        
        CHostedObject* pMouseCaptureObj = NULL;

        // send the message to the control(s) that have the capture    
        if(false == m_fHandleHelp && GetCapture() == S_OK){

            for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
            // iterate through all the contained controls
          

                CHostedObject* pObj = (*i);
        
                if(NULL == pObj){

                    ATLASSERT(FALSE); // should not be null
                    continue;
                }/* end of if statement */

                // need to be able send message to the button with the capture                
                if(pObj->HasCapture()){

                    ATLTRACE2(atlTraceUser, 31, TEXT("Sending WM_ buttons message to button %ls \n"), pObj->GetID());
                    HRESULT hr = SendMessageToCtl(pObj, uMsg, wParam, lParam, bHandled, lRes);

                    if(SUCCEEDED(hr)){

                        
                       if (WM_LBUTTONDOWN == uMsg) {

                           CComPtr<IViewObjectEx> pViewObject;
                            HRESULT hr = pObj->GetViewObject(&pViewObject);

                            if(FAILED(hr)){

                                ATLASSERT(FALSE); // should have a view
                                continue;
                            }/* end of if statement */

                            DWORD dwHitResult = HITRESULT_OUTSIDE;

                            POINT ptMouse = { LOWORD(lParam), HIWORD(lParam) };
                            RECT rcCntrl;
                            pObj->GetPos(&rcCntrl);

			                pViewObject->QueryHitPoint(DVASPECT_CONTENT, &rcCntrl, ptMouse, 0, &dwHitResult);
			                
                            if(HITRESULT_HIT == dwHitResult){

                                if (WM_LBUTTONDOWN == uMsg) {

                                    LONG lRes;
                                    //SetObjectFocus(pObj, TRUE, lRes);
                                    SetClosestFocus(lRes, pObj);
                                }/* end of if statement */
                            }/* end of if statement */
                        }/* end of if statement */

                        pMouseCaptureObj = pObj;
                        break; // send mouse message to only the one control that has capture
                        // then to the ones we hower over
                    }/* end of if statement */                    
                }/* end of if statement */
            }/* end of for loop */
        }/* end of if statement */    
    
        // send the message to the control(s) that we are over, but not to the one
        // that which had focus and we already send one
        for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
        // iterate through all the contained controls

            CHostedObject* pObj = (*i);
        
            if(NULL == pObj){

                ATLASSERT(FALSE); // should not be null
                continue;
            }/* end of if statement */

            // need to be able send message to the button with the capture
            
            // send the message to the control over which we are howering or on which we
            // have clicked, check if we already are ready to send the message
            // in that case do not bother with the rect interstec bussines
            if(!bHandled && pObj->IsWindowless() && pObj->IsActive()){
            
                CComPtr<IViewObjectEx> pViewObject;
                HRESULT hr = pObj->GetViewObject(&pViewObject);

                if(FAILED(hr)){

                    ATLASSERT(FALSE); // should have a view
                    continue;
                }/* end of if statement */

                DWORD dwHitResult = HITRESULT_OUTSIDE;

                POINT ptMouse = { LOWORD(lParam), HIWORD(lParam) };
                RECT rcCntrl;
                pObj->GetPos(&rcCntrl);

			    pViewObject->QueryHitPoint(DVASPECT_CONTENT, &rcCntrl, ptMouse, 0, &dwHitResult);

                if(HITRESULT_HIT == dwHitResult){

                    // see if we are handling help, if so do not do anything else, but
                    // fire help with the control ID we are howering over
                    if(m_fHandleHelp){

                        if (WM_LBUTTONUP == uMsg) {
                            Fire_OnHelp(::SysAllocString(pObj->GetID()));
                            m_fHandleHelp = false;
                        }/* end of if statement */
    
                        bHandled = TRUE;
                        return(lRes);
                    }
                    else {
                        
                        if(pMouseCaptureObj == pObj){

                            continue; // we already have send message to this control
                            // do not do it again
                        }/* end of if statememt */

                        ATLTRACE2(atlTraceUser, 31, TEXT("Sending WM_ buttons message to button %ls \n"), pObj->GetID());
                        SendMessageToCtl(pObj, uMsg, wParam, lParam, bHandled, lRes);    

                        if (WM_LBUTTONDOWN == uMsg) {
                            
                               LONG lRes;
                               //SetObjectFocus(pObj, TRUE, lRes);                            
                               SetClosestFocus(lRes, pObj);
                        }/* end of if statement */

                    }/* end of if statement */                    
                }/* end of if statement */        
            }/* end of if statement */            
        }/* end of for loop */    
    }/* end of if statement */

    
    if(TRUE == bHandled){
        // we send some messages to a control, so there is no need to handle container now
        
        return(lRes);
    }/* end of if statement */

    // we are not over any control so we might be over container itself, so handle
    // the mouse message appropriately

    ATLTRACE2(atlTraceWindowing, 32, TEXT("Not forwarding the message to the controls\n"));
    if(WM_LBUTTONUP == uMsg || WM_LBUTTONDBLCLK == uMsg){

        // TODO: Fire the click only if we are on our window or bitmap
        if(m_fHandleHelp){
            BSTR strToolbarName;

            if(SUCCEEDED(GetToolbarName(&strToolbarName))){
                Fire_OnHelp(strToolbarName);
            }/* end of if statement */
            m_fHandleHelp = false;
        }
        else {

            if(WM_LBUTTONUP == uMsg){

                Fire_OnClick();
            }
            else {
                
                Fire_OnDblClick();
            }/* end of if statement */
        }/* end of if statement */
    }/* end of if statement */

    // handle the moving of the container window
    if(m_fSelfHosted && !m_fHandleHelp){

            if(WM_LBUTTONDOWN == uMsg){
                OnButtonDown(uMsg, wParam, lParam, bHandled);
            }/* end of if statement */

            if(WM_MOUSEMOVE == uMsg){
                OnMouseMove(uMsg, wParam, lParam, bHandled);
            }/* end of if statement */

            if(WM_LBUTTONUP == uMsg){
                OnButtonUp(uMsg, wParam, lParam, bHandled);
            }/* end of if statement */
    }/* end of if statement */

    return(lRes);
}/* end of function OnMouseMessage */

/*************************************************************************/
/* Function: OnKeyMessage                                                */
/* Description: Distrubutes the keyboard messages properly.              */
/*************************************************************************/
LRESULT CMFBar::OnKeyMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                             BOOL& bHandled){

    m_fUserActivity = true;

    if(m_fWaitingForActivity){

        Fire_ActivityStarted();        
        m_fWaitingForActivity = false;
    }/* end of if statement */

    bHandled = FALSE;
    LONG lRes = 0;    
    VARIANT_BOOL fEat = VARIANT_FALSE;

    LONG lEnable = 1; // using long since the framework will not handle short

    LONG lVirtKey = (LONG)wParam;
    LONG lKeyData = (LONG) lParam;

    m_fForceKey = false; // reset the flag, the change in the value would indicate
                         // that we have received call to force key during the event
                         // processing

    if(WM_KEYDOWN == uMsg){

        Fire_OnKeyUp(lVirtKey, lKeyData);
    }/* end of if statement */

    if(WM_KEYUP == uMsg){

        Fire_OnKeyDown(lVirtKey, lKeyData);
    }/* end of if statement */

    if(WM_SYSKEYDOWN == uMsg){

        Fire_OnSysKeyUp(lVirtKey, lKeyData);
    }/* end of if statement */

    if(WM_SYSKEYUP == uMsg){

        Fire_OnSysKeyDown(lVirtKey, lKeyData);
    }/* end of if statement */

    if(m_fForceKey){

        fEat = m_fEat;
        lVirtKey = m_lVirtKey;
        lKeyData = m_lKeyData;
    }/* end of if statement */

    if(VARIANT_FALSE == fEat){

        if(WM_KEYUP == uMsg ){
            switch(lVirtKey){

            case VK_TAB:
                bool fForward = true;

                if(::GetKeyState(VK_SHIFT) < 0){

                    fForward = false;
                }/* end of if statement */

                MoveFocus(fForward, lRes);
                return(lRes);        
             }/* end of switch statement */
        }/* end of if statement */

        // iterates through the controls and send these key messages to the one
        // with focus
        CNTOBJ::iterator i;     
        for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
        // iterate through all the contained controls

            CHostedObject* pObj = (*i);
        
            if(NULL == pObj){

                ATLASSERT(FALSE);
                continue;
            }/* end of if statement */

            if(pObj->HasFocus()){

                HRESULT hr = SendMessageToCtl(pObj, uMsg, lVirtKey, lKeyData, bHandled, lRes, false);

                if(SUCCEEDED(hr)){

                    return(lRes);
                }/* end of if statement */                        
            }/* end of if statement */
        }/* end of for loop */
    }/* end of if statement */

    return(lRes);
}/* end of function OnKeyMessage */

/*************************************************************************/
/* Function: AdvanceIterator                                             */
/* Description: Helper inline function that helps to keep track which    */
/* direction we are advancing.                                           */
/*************************************************************************/
void AdvanceIterator(CNTOBJ::iterator& i, bool fForward){

    if(fForward){

        i++;
    }
    else {

        i--;
    }/* end of if statement */
}/* end of function AdvanceIterator */

/*************************************************************************/
/* Function: MoveFocus                                                   */
/* Descrition: Moves focus through the objects in forward or reverse     */
/* direction.                                                            */
/*************************************************************************/
HRESULT CMFBar::MoveFocus(bool fForward, LONG& lRes){

    
    HRESULT hr = S_OK;

    // first remove the focus and remeber the object
    CHostedObject* pLastFocusObject = NULL;            

    CNTOBJ::iterator i, iEnd;

    if(fForward){

        i = m_cntFocus.begin();
        iEnd = m_cntFocus.end();
    }
    else {
        i = m_cntFocus.end();
        i--;
        iEnd = m_cntFocus.begin();
    }/* end of if statement */

    for( ;i!= iEnd; AdvanceIterator(i, fForward)){
        
    // iterate through all the contained controls

        CHostedObject* pObj = (*i);

        if(NULL == pObj){

            ATLASSERT(FALSE);
            continue;
        }/* end of if statement */

        if(pObj->HasFocus()){

           LONG lRes;
           SetObjectFocus(pObj, FALSE, lRes);                       
           pLastFocusObject = pObj;
           continue; // get to the next object
        }/* end of if statement */

        // try to set the focus to the next object
        if(NULL != pLastFocusObject){

            if(pObj->IsActive()){
           
               LONG lRes = 0;
               HRESULT hr = SetObjectFocus(pObj, TRUE, lRes);                       

                if(FAILED(hr)){
            
                    continue; // this is the container so skip it
                }/* end of if statement */

                if(-1 == lRes){
                    // did not want to handle focus, since the button is disabled
                    SetObjectFocus(pObj, FALSE, lRes); 
                    continue;
                }/* end of if statement */

                return(hr);
            }/* end of if statement */
        }/* end of if statement */
    }/* end of for loop */

    // OK lets try to set focus to somebody before
    //CNTOBJ::iterator i;
    if(fForward){

        i = m_cntFocus.begin();
        iEnd = m_cntFocus.end();
    }
    else {
        i = m_cntFocus.end();
        i--;
        iEnd = m_cntFocus.begin();
    }/* end of if statement */

    for( ;i!= iEnd; AdvanceIterator(i, fForward)){

        // iterate through all the contained controls

        CHostedObject* pObj = (*i);

        if(NULL == pObj){

            ATLASSERT(FALSE);
            continue;
        }/* end of if statement */

        if(pObj->IsActive()){

            LONG lRes = 0;
            HRESULT hr = SetObjectFocus(pObj, TRUE, lRes);                       

            if(FAILED(hr)){

                continue; // this is the container so skip it
            }/* end of if statement */

            if(-1 == lRes){
                // did not want to handle focus, since the button is disabled
                SetObjectFocus(pObj, FALSE, lRes); 
                continue;
            }/* end of if statement */

            return(hr);
        }/* end of if statement */
    }/* end of for loop */

    //ATLASSERT(FALSE); // should not really hapen, to have all the objects disabled
    return(hr);    
}/* end of function MoveFocus */

/*************************************************************************/
/* Function: SetClosestFocus                                             */
/* Descrition: Sets the focus to the closes object to pObj if specified. */
/*************************************************************************/
HRESULT CMFBar::SetClosestFocus(LONG& lRes, CHostedObject* pStartObj, bool fForward){
    
    HRESULT hr = S_OK;

    if(m_cntFocus.empty()){

        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    ResetFocusFlags();
    
    // first remove the focus and remeber the object
    bool fStartSettingFocus = false;            

    CNTOBJ::iterator i, iEnd;

    if(fForward){

        i = m_cntFocus.begin();
        iEnd = m_cntFocus.end();
    }
    else {
        i = m_cntFocus.end();
        i--;
        iEnd = m_cntFocus.begin();
    }/* end of if statement */

    if(NULL == pStartObj){
        
        pStartObj = (*i); // initialize our start object
    }/* end of if statement */

    for( ;i!= iEnd; AdvanceIterator(i, fForward)){
        
    // iterate through all the contained controls

        CHostedObject* pObj = (*i);

        if(NULL == pObj){

            ATLASSERT(FALSE);
            continue;
        }/* end of if statement */

        if(pObj == pStartObj){

           fStartSettingFocus = true;           
        }/* end of if statement */

        // try to set the focus to the next object
        if(fStartSettingFocus ){

            if(pObj->IsActive()){
           
               LONG lRes = 0;
               HRESULT hr = SetObjectFocus(pObj, TRUE, lRes);                       

                if(FAILED(hr)){
            
                    continue; // this is the container so skip it
                }/* end of if statement */

                if(-1 == lRes){
                    // did not want to handle focus, since the button is disabled
                    SetObjectFocus(pObj, FALSE, lRes); 
                    continue;
                }/* end of if statement */

                return(hr);
            }/* end of if statement */
        }/* end of if statement */
    }/* end of for loop */

    if(!fStartSettingFocus){

        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    // OK lets try to set focus to somebody before
    //CNTOBJ::iterator i;
    if(fForward){

        i = m_cntFocus.begin();
        iEnd = m_cntFocus.end();
    }
    else {
        i = m_cntFocus.end();
        i--;
        iEnd = m_cntFocus.begin();
    }/* end of if statement */

    for( ;i!= iEnd; AdvanceIterator(i, fForward)){

        // iterate through all the contained controls

        CHostedObject* pObj = (*i);

        if(NULL == pObj){

            ATLASSERT(FALSE);
            continue;
        }/* end of if statement */

        if(pObj->IsActive()){

            LONG lRes = 0;
            HRESULT hr = SetObjectFocus(pObj, TRUE, lRes);                       

            if(FAILED(hr)){

                continue; // this is the container so skip it
            }/* end of if statement */

            if(-1 == lRes){
                // did not want to handle focus, since the button is disabled
                SetObjectFocus(pObj, FALSE, lRes); 
                continue;
            }/* end of if statement */

            return(hr);
        }/* end of if statement */
    }/* end of for loop */

    ATLASSERT(FALSE); // should not really hapen, to have all the objects disabled
    return(hr);
    
}/* end of function SetClosestFocus */


/*************************************************************************/
/* Function: OnForwardMsg                                                */
/* Description: Forwards the message to the active object.               */
/*************************************************************************/
LRESULT CMFBar::OnForwardMsg(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/){

    ATLTRACE2(atlTraceHosting, 2, TEXT("CMFBar::OnForwardMsg\n"));

	ATLASSERT(lParam != 0);
	LPMSG lpMsg = (LPMSG)lParam;
	
	if(m_spActiveObject){

		if(m_spActiveObject->TranslateAccelerator(lpMsg) == S_OK)
			return 1;
	}/* end of function OnForwardMessage */
	return 0;
}/* end of function OnForwardMessage */

/*************************************************************************/
/* Function: ReflectNotifications                                        */
/* Description: Reflects the messages to the child windows               */
/*************************************************************************/
LRESULT CMFBar::ReflectNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                                     BOOL& bHandled){
	HWND hWndChild = NULL;

	switch(uMsg){

	    case WM_COMMAND:
		    if(lParam != NULL)	// not from a menu
			    hWndChild = (HWND)lParam;
		    break;
	    case WM_NOTIFY:
		    hWndChild = ((LPNMHDR)lParam)->hwndFrom;
		    break;
	    case WM_PARENTNOTIFY:
		    switch(LOWORD(wParam))
		    {
		    case WM_CREATE:
		    case WM_DESTROY:
			    hWndChild = (HWND)lParam;
			    break;
		    default:
			    hWndChild = GetDlgItem(HIWORD(wParam));
			    break;
		    }
		    break;
	    case WM_DRAWITEM:
		    if(wParam)	// not from a menu
			    hWndChild = ((LPDRAWITEMSTRUCT)lParam)->hwndItem;
		    break;
	    case WM_MEASUREITEM:
		    if(wParam)	// not from a menu
			    hWndChild = GetDlgItem(((LPMEASUREITEMSTRUCT)lParam)->CtlID);
		    break;
	    case WM_COMPAREITEM:
		    if(wParam)	// not from a menu
			    hWndChild = GetDlgItem(((LPCOMPAREITEMSTRUCT)lParam)->CtlID);
		    break;
	    case WM_DELETEITEM:
		    if(wParam)	// not from a menu
			    hWndChild = GetDlgItem(((LPDELETEITEMSTRUCT)lParam)->CtlID);
		    break;
	    case WM_VKEYTOITEM:
	    case WM_CHARTOITEM:
	    case WM_HSCROLL:
	    case WM_VSCROLL:
		    hWndChild = (HWND)lParam;
		    break;
	    case WM_CTLCOLORBTN:
	    case WM_CTLCOLORDLG:
	    case WM_CTLCOLOREDIT:
	    case WM_CTLCOLORLISTBOX:
	    case WM_CTLCOLORMSGBOX:
	    case WM_CTLCOLORSCROLLBAR:
	    case WM_CTLCOLORSTATIC:
		    hWndChild = (HWND)lParam;
		    break;
	    default:
		    break;
	}/* end of switch statement */

	if(hWndChild == NULL){

		bHandled = FALSE;
		return 1;
	}/* end of if statememnt */

	ATLASSERT(::IsWindow(hWndChild));
	return ::SendMessage(hWndChild, OCM__BASE + uMsg, wParam, lParam);
}/* end of function ReflectNotifications */

/*************************************************************************/
/* Function: put_Caption                                                 */
/* Description: Sets the caption to the window if present and handles    */
/* the ambient property implementation.                                  */
/*************************************************************************/
STDMETHODIMP CMFBar::put_Caption(BSTR bstrCaption){ 

	ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_Caption\n")); 
	
    if (FireOnRequestEdit(DISPID_CAPTION) == S_FALSE){

		return S_FALSE; 
    }/* end of if statement */

    m_bstrCaption.Empty();    
    m_bstrCaption.Attach(::SysAllocString(bstrCaption)); 
	m_bRequiresSave = TRUE; 
	FireOnChanged(DISPID_CAPTION);
	FireViewChange(); 
	SendOnDataChange(NULL); 

    if(::IsWindow(m_hWnd)){

#ifdef _UNICODE
        ::SetWindowText(m_hWnd, bstrCaption);
#else
        USES_CONVERSION;
        ::SetWindowText(m_hWnd, OLE2T(bstrCaption));
#endif
    }/* end of if statement */

	return S_OK; 
}/* end of function put_Caption */

	
// ##### BEGIN ACTIVEX SCRIPTING SUPPORT #####
/*************************************************************************/
/* IActiveScriptSite Interface Implementation                            */
/*************************************************************************/

/*************************************************************************/
/* Function: get_CmdLine                                                 */
/*************************************************************************/
STDMETHODIMP CMFBar::get_CmdLine(BSTR *pVal){

    if(NULL == pVal){

        return(E_POINTER);
    }/* end of if statement */

    *pVal = m_strCmdLine.Copy();
	return S_OK;
}/* end of function get_CmdLine */

/*************************************************************************/
/* Function: put_CmdLine                                                 */
/*************************************************************************/
STDMETHODIMP CMFBar::put_CmdLine(BSTR newVal){

    m_strCmdLine = newVal;
	return S_OK;
}/* end of function put_CmdLine */

/*************************************************************************/
/* Function: GetUserLCID                                                 */
/* Description: Gets the user default LCID                               */
/*************************************************************************/
STDMETHODIMP CMFBar::GetUserLCID(long *plcid){

    *plcid = ::GetUserDefaultLCID();
  return (S_OK);
}/* end of function GetUserLCID */

/*************************************************************************/
/* Function: GetLCID                                                     */
/* Description: Gets the user default LCID                               */
/*************************************************************************/
STDMETHODIMP CMFBar::GetLCID(LCID *plcid){

    *plcid = ::GetUserDefaultLCID();
  return (S_OK);
}/* end of function GetLCID */

/*************************************************************************/
/* Function: GetItemInfo                                                 */
/* Description: Returns IUnknown or TypeInfo of the contained (embedded) */
/* objects in the active script, in this case we return also a container,*/
/* since we can script it as well (but the script container is inserted  */
/* in the list as well, so no special case for it.                       */
/* TODO: Might want to optimize and use hash table for faster compares.  */
/* on the other hand it seems like a script engine calls this just once  */
/* for an object an then reuses its internal reference.                  */
/*************************************************************************/
STDMETHODIMP CMFBar::GetItemInfo(LPCOLESTR strObjectID, DWORD dwReturnMask, 
                                 IUnknown**  ppunkItemOut, ITypeInfo** pptinfoOut){

    HRESULT hr = S_OK;

    if (dwReturnMask & SCRIPTINFO_ITYPEINFO){

      if (!pptinfoOut){

        return E_INVALIDARG;
      }/* end of if statement */

    *pptinfoOut = NULL;
    }/* end of if statement */

    if (dwReturnMask & SCRIPTINFO_IUNKNOWN){

      if (!ppunkItemOut){
        return E_INVALIDARG;
      }/* end of if statement */

    *ppunkItemOut = NULL;
    }/* end of if statement */

    CHostedObject* pObj;

    if(SUCCEEDED(FindObject(const_cast<BSTR>(strObjectID), &pObj))){
    
        if (dwReturnMask & SCRIPTINFO_ITYPEINFO){

            hr = pObj->GetTypeInfo(0, ::GetUserDefaultLCID(), pptinfoOut);

            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */
        }/* end of if statement */

        if (dwReturnMask & SCRIPTINFO_IUNKNOWN){

            *ppunkItemOut = pObj->GetUnknown(); // does AddRef under the hood
        }/* end of if statement */

        return(hr); // found out item no need to dig around longer      
    }/* end of for loop */
    
    return TYPE_E_ELEMENTNOTFOUND;
}/* end of function GetItemInfo */

/*************************************************************************/
/* Function: GetDocVersionString                                         */
/*************************************************************************/
STDMETHODIMP CMFBar::GetDocVersionString(BSTR *pbstrVersion ){

  return (E_NOTIMPL);  
}/* end of function GetDocVersionString */

/*************************************************************************/
/* Function: OnScriptTerminate                                           */  
/*************************************************************************/
STDMETHODIMP CMFBar::OnScriptTerminate(const VARIANT   *pvarResult,
                                       const EXCEPINFO *pexcepinfo){

  return (E_NOTIMPL);  
}/* end of function OnScriptTerminate */

/*************************************************************************/
/* Function: OnStateChange                                               */
/*************************************************************************/
STDMETHODIMP CMFBar::OnStateChange(SCRIPTSTATE ssScriptState){

    return (E_NOTIMPL);  
}/* end of function OnStateChange */

/*************************************************************************/
/* Function: OnScriptError                                               */
/* Description: Display the script error in debug mode, skip it in       */
/* release mode for now.                                                 */
/*************************************************************************/
STDMETHODIMP CMFBar::OnScriptError(IActiveScriptError *pse){

  HRESULT   hr = S_OK;

#ifdef _DEBUG
  WCHAR      szError[1024]; 
  EXCEPINFO ei;
  DWORD     dwSrcContext;
  ULONG     ulLine;
  LONG      ichError;
  BSTR      bstrLine = NULL;


  hr = pse->GetExceptionInfo(&ei);

  if(FAILED(hr)){

      return(hr);
  }/* end of if statement */

  hr = pse->GetSourcePosition(&dwSrcContext, &ulLine, &ichError);

  if(FAILED(hr)){

      return(hr);
  }/* end of if statement */

  hr = pse->GetSourceLineText(&bstrLine);

  if (hr){

    hr = S_OK;  // Ignore this error, there may not be source available
  }/* end of if statement */
  
  if (!hr){
 
     wsprintfW(szError, L"Source:'%s'\n Line:%d  Description:%s\n",
                      ei.bstrSource, ulLine, ei.bstrDescription);
#ifdef _DEBUG
     USES_CONVERSION;
     ATLTRACE(W2T(szError));
     ::MessageBeep((UINT)-1);
     ::MessageBoxW(::GetFocus(), szError, L"Error", MB_OK);    
#endif
    // TODO: Add real error handling for released version
 }/* end of if statment */

  if (bstrLine){

      ::SysFreeString(bstrLine);
  }/* end of if statement */

#endif
  return hr;
}/* end of function OnScriptError */

//---------------------------------------------------------------------------
// 
//---------------------------------------------------------------------------
STDMETHODIMP CMFBar::OnEnterScript
(
  void 
)
{
  // No need to do anything
  return S_OK;
}


//---------------------------------------------------------------------------
// 
//---------------------------------------------------------------------------
STDMETHODIMP CMFBar::OnLeaveScript
(
  void 
)
{
  // No need to do anything
  return S_OK;
}

// #####  END  ACTIVEX SCRIPTING SUPPORT #####

/*************************************************************************/
/* Function: About                                                       */
/* Description: Displayes about box.                                     */
/*************************************************************************/
STDMETHODIMP CMFBar::About(){

     HRESULT hr = S_OK;

     const INT ciMaxBuffSize = MAX_PATH; // enough for the text
     TCHAR strBuffer[ciMaxBuffSize];
     TCHAR strBufferAbout[ciMaxBuffSize];

     if(!::LoadString(m_hRes, IDS_BAR_ABOUT, strBuffer, ciMaxBuffSize)){

         hr = E_UNEXPECTED;
         return(hr);
     }/* end of if statement */

     if(!::LoadString(m_hRes, IDS_ABOUT, strBufferAbout, ciMaxBuffSize)){

         hr = E_UNEXPECTED;
         return(hr);
     }/* end of if statement */

    ::MessageBox(::GetFocus(), strBuffer, strBufferAbout, MB_OK);

	return (hr);
}/* end of function About */

/*************************************************************************/
/* Function: GetObjectUnknown                                            */
/* Description: Iterates throught the object collection, finds the       */
/* object that has the specific ID then returns it IUnknown.             */
/*************************************************************************/
STDMETHODIMP CMFBar::GetObjectUnknown(BSTR strObjectID, IUnknown **ppUnk){

    HRESULT hr = E_FAIL;

    if(NULL == strObjectID){

        return E_POINTER;
    }/* end of if statement */

    if(NULL == ppUnk){

        return E_POINTER;
    }/* end of if statement */

    *ppUnk = NULL;

    CHostedObject* pObj;

    hr = FindObject(strObjectID, &pObj);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    *ppUnk = pObj->GetUnknown();        
    hr = S_OK;

    if(*ppUnk == NULL){
    
        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    (*ppUnk)->AddRef(); // adds the reference, since we are giving  out
    
	return (hr);
}/* end of function GetObjectUnknown */

/*************************************************************************/
/* Function: EnableObject                                                */
/* Description: Goes trough the objects and enables or disables it       */
/* depending on the flag. Invalidates the objects rect as well.          */
/*************************************************************************/
STDMETHODIMP CMFBar::EnableObject(BSTR strObjectID, VARIANT_BOOL fEnable){

    HRESULT hr = E_FAIL;

    if(NULL == strObjectID){

        return E_POINTER;
    }/* end of if sattement */

    CHostedObject* pObj;
    hr = FindObject(strObjectID, &pObj);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */
           
    bool fTmpEnable = VARIANT_FALSE == fEnable ? false: true;

    CContainerObject* pCnt;
    hr = pObj->GetContainerObject(&pCnt);

    if(FAILED(hr)){

        if(pObj->GetUnknown() == GetUnknown()){
            // special case when we are invalidating our self/ the self hosted container
            if(fTmpEnable){

                InvalidateRect(NULL, false);
            }/* end of if statement */
            pObj->SetActive(fTmpEnable);
            hr = S_OK;
            return(hr);
        }/* end of if statement */        
    }/* end of if statemenet */

    if (pObj->IsActive() == fTmpEnable)
        return S_OK;

    pObj->SetActive(fTmpEnable);        

    if(false == fTmpEnable){

        LONG lRes = 0;
        SetClosestFocus(lRes);
        //MoveFocus(true, lRes);
        //SetObjectFocus(pObj, FALSE, lRes);

        if(pObj->HasCapture()){

            pCnt->SetCapture(FALSE);
        }/* end of if statement */
    }/* end of if statement */
    
    // invalidate area where the object lives
    if(pObj->IsWindowless()){

        // invalidate the rect only if we are windowless control
        // the windowed control shopuld be able
        // to update itself depending on the SW_SHOW, HIDE messagess
        hr = pCnt->InvalidateObjectRect();
    }/* end of if statement */

	return (hr);
}/* end of function EnableObject */

/*************************************************************************/
/* Function: ObjectEnabled                                               */
/* Description: Goes trough the objects and checks if the particular     */
/* object is enabled or disabled.                                        */
/*************************************************************************/
STDMETHODIMP CMFBar::ObjectEnabled(BSTR strObjectID, VARIANT_BOOL *pfEnabled){

    HRESULT hr = E_FAIL;

    if(NULL == pfEnabled){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    if(NULL == strObjectID){

        hr = E_POINTER;
        return(hr);
    }/* end of if sattement */

    bool bFirstElement = true;
	CNTOBJ::iterator i;
    for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
        
        if(!_wcsicmp((*i)->GetID(), strObjectID)){

            CHostedObject* pObj = (*i);        
            *pfEnabled = pObj->IsActive()? VARIANT_TRUE : VARIANT_FALSE;        
            hr = S_OK;                                             // might have to turn it on            
            return(hr); // already have set the state and invalidated and bail out
        }/* end of if statement */
    }/* end of for loop */

	return (hr);
}/* end of function ObjectEnabled */

/*************************************************************************/
/* Function: ForceKey                                                    */
/* Description: Forces the in the eventa handling code.                  */
/* The fEat disables or enables default key handler.                     */
/*************************************************************************/
STDMETHODIMP CMFBar::ForceKey(LONG lVirtKey, LONG lKeyData, VARIANT_BOOL fEat){

    m_fForceKey = true; // set the flag for key handler routine

    m_fEat = (fEat == VARIANT_FALSE ? VARIANT_FALSE : VARIANT_TRUE); // disable or enable this call
    m_lVirtKey = lVirtKey; // put in data
    m_lKeyData = lKeyData; // put in data

    return S_OK;
}/* end of function ForceKey */

/*************************************************************************/
/* Function: get_ScriptLanguage                                          */
/* Description: Gets current script language such as JScript, VBScript   */
/*************************************************************************/
STDMETHODIMP CMFBar::get_ScriptLanguage(BSTR *pstrScriptLanguage){

    if(NULL == pstrScriptLanguage){

        return(E_POINTER);
    }/* end of if statement */

    *pstrScriptLanguage = m_strScriptLanguage.Copy();
	return S_OK;
}/* end of function get_ScriptLanguage */

/*************************************************************************/
/* Function: put_ScriptLanguage                                          */
/* Description: Gets current script language such as JScript, VBScript   */
/*************************************************************************/
STDMETHODIMP CMFBar::put_ScriptLanguage(BSTR strScriptLanguage){

    HRESULT hr = S_OK;

    if (m_ps){

        hr = E_FAIL;  // Already created the script engine, so it 
                      // will not take an effect untill we unload it
        return(hr);
    }/* end of if statement */
    
    m_strScriptLanguage = strScriptLanguage;
	
	return (hr);
}/* end of function put_ScriptLanguage */

/*************************************************************************/
/* Function: get_ScriptFile                                              */
/* Description: Gets the current script file.                            */
/* By default we have empty string which means loading from Windows      */
/* resources, which is not really a file.                                */
/*************************************************************************/
STDMETHODIMP CMFBar::get_ScriptFile(BSTR *pstrScriptFile){

    if(NULL == pstrScriptFile){

        return(E_POINTER);
    }/* end of if statement */

    *pstrScriptFile = m_strScriptFile.Copy();	
	return S_OK;
}/* end of function get_ScriptFile */

/*************************************************************************/
/* Function: put_ScriptFile                                              */
/* Description: Sets the script file. Only valid before the load and     */
/* unload.                                                               */
/*************************************************************************/
STDMETHODIMP CMFBar::put_ScriptFile(BSTR strScriptFile){
	
	HRESULT hr = S_OK;

    try {

        if(VARIANT_TRUE == m_fAutoLoad){

            hr = DestroyScriptEngine();

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            m_strScriptFile = strScriptFile;

            hr = Load();

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

             const INT ciMaxBuffSize = MAX_PATH; // enough for the text
             TCHAR strBuffer[ciMaxBuffSize];
     
             if(!::LoadString(m_hRes, IDS_MAIN_ENTRY, strBuffer, ciMaxBuffSize)){

                 hr = E_UNEXPECTED;
                 return(hr);
             }/* end of if statement */

             USES_CONVERSION;
             hr = Run(T2OLE(strBuffer));

        } 
        else {

            // case when we are loading manually        


            if (m_ps){

                hr = E_FAIL;  // Already created the script engine, so it 
                              // will not take an effect untill we unload it
                throw(hr);
            }/* end of if statement */  

            m_strScriptFile = strScriptFile;        
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;      
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function put_ScriptFile */

/*************************************************************************/
/* IActiveScriptSiteWindow Interface Implementation                      */
/*************************************************************************/

/*************************************************************************/
/* Function: GetWindow                                                   */
/* Description:  Gets the window. If we are windowless we do not pass    */
/* down the parent window, since that seems to confuse the control       */
/*************************************************************************/
STDMETHODIMP CMFBar::GetWindow(HWND *phwndOut){

  HRESULT hr = S_OK;

  if (!phwndOut){

    hr = E_INVALIDARG;
    return (hr);
  }/* end of if statement */


  if(m_bWndLess){
      if(!::IsWindow(m_hWnd)){

          return(GetParentHWND(phwndOut));
      }/* end of if statement */
  }
  else {
      if(!::IsWindow(m_hWnd)){
          
          *phwndOut = NULL;
          hr = E_FAIL;
          return(hr);
      }/* end of if statement */
  }/* end of if statement */

  *phwndOut = m_hWnd;    
  
  return(hr);
}/* end of function GetWindow */

/*************************************************************************/
/* Function: EnableModeless                                              */
/* Description: Sets the window from which the UI elemnt can come out    */
/*************************************************************************/
STDMETHODIMP CMFBar::EnableModeless(BOOL fModeless){

    HRESULT hr = S_OK;

    if(m_hWnd == NULL){

        hr = E_NOTIMPL;
        return (hr);
    }/* end of if statement */

    ::EnableWindow(m_hWnd, fModeless);
    return(hr);
}/* end of function EnableModeless */

/*************************************************************************/
/* Function: get_MinWidth                                                */
/* Description: Gets the minimum width beyond which we do not resize.    */
/*************************************************************************/
STDMETHODIMP CMFBar::get_MinWidth(long *pVal){
	
	if(NULL == pVal){
        
        return(E_POINTER);
    }/* end of if statement */

    *pVal = m_lMinWidth;
	return S_OK;
}/* end of function get_MinWidth */

/*************************************************************************/
/* Function: put_MinWidth                                                */
/* Description: Puts the minimum width beyond which we do not resize.    */
/*************************************************************************/
STDMETHODIMP CMFBar::put_MinWidth(long newVal){

	m_lMinWidth = newVal;
	return S_OK;
}/* end of function put_MinWidth */

/*************************************************************************/
/* Function: get_MinWidth                                                */
/* Description: Gets the minimum height beyond which we do not resize.   */
/*************************************************************************/
STDMETHODIMP CMFBar::get_MinHeight(long *pVal){

    if(NULL == pVal){
        
        return(E_POINTER);
    }/* end of if statement */

    *pVal = m_lMinHeight;
	return S_OK;
}/* end of function get_MinHeight */

/*************************************************************************/
/* Function: put_MinHeight                                               */
/* Description: Sets the minimum height beyond which we do not resize.   */
/*************************************************************************/
STDMETHODIMP CMFBar::put_MinHeight(long newVal){
	
    m_lMinHeight = newVal;
	return S_OK;
}/* end of function put_MinHeight */

// ##### BEGIN ACTIVEX SCRIPTING SUPPORT #####

/*************************************************************************/
/* Function: CreateScriptEngine                                          */
/* Description: Initializes the script engine.                           */
/*************************************************************************/
HRESULT CMFBar::CreateScriptEngine(){
  
    HRESULT hr = S_OK;

#ifndef _UNICODE  
    USES_CONVERSION;
#endif

    if (m_ps){

        hr = S_FALSE;  // Already created the script engine
        return(hr);    // so get out
    }/* end of if statement */  

    /*************************************************************************/
    /* add (this) the container as a scriptable object as well               */
    /* this is special case so we can call script on our self as well        */
    /*************************************************************************/
    const INT ciMaxBuffSize = MAX_PATH; // should be enough for tlbr ID, keep ID small if can
    TCHAR strBuffer[ciMaxBuffSize];
    
    if(!::LoadString(m_hRes, IDS_ROOT_OBJECT, strBuffer, ciMaxBuffSize)){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

    CComPtr<IUnknown> pUnk = GetUnknown();
    CComQIPtr<IDispatch> pDisp (pUnk);    
    
    if(!pDisp){
        
        return(hr);
    }/* end of if statement */

#ifdef _UNICODE  
    BSTR strObjectID = ::SysAllocString(strBuffer); // gets freed in the destructor of the holding object    
#else
    BSTR strObjectID = ::SysAllocString(T2OLE(strBuffer));
#endif

    hr = AddObject(strObjectID, pDisp); // this one adds the object to the list as well

    ::SysFreeString(strObjectID); // free up the sys string, since we allocate it in the contructor for the object

    if(FAILED(hr)){
                
        return(hr);
    }/* end of if statement */
    
    if(!m_strScriptLanguage){
         // load what script language we decided to support if not set explicitly by user
        if(!::LoadString(m_hRes, IDS_SCRIPT_LANGUAGE, strBuffer, ciMaxBuffSize)){

            hr = E_UNEXPECTED;
            return(hr);
        }/* end of if statement */

        m_strScriptLanguage = strBuffer;
    }/* end of if statement */

    CLSID clsid;

    hr = ::CLSIDFromProgID(m_strScriptLanguage, &clsid); // get the language

    if(FAILED(hr)){

	    return hr;
    }/* end of if statement */

    hr = m_ps.CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER);
    // Create the ActiveX Scripting Engine
    //hr = ::CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void **)&m_ps);
    if (FAILED(hr)){

        //s_pszError = "Creating the ActiveX Scripting engine failed.  Scripting engine is probably not correctly registered or CLSID incorrect.";
        return (hr);
    }/* end of if statement */

    // Script Engine must support IActiveScriptParse for us to use it
    hr = m_ps->QueryInterface(IID_IActiveScriptParse, (void**) &m_psp);

    if (FAILED(hr)){

        //s_pszError = "ActiveX Scripting engine does not support IActiveScriptParse";
        return (hr);
    }/* end of if statement */

    hr = m_ps->SetScriptSite(this);

    if(FAILED(hr)){

        return hr;
    }/* end of if statement */

    // InitNew the object:
    hr = m_psp->InitNew();

    if(FAILED(hr)){

        return hr;
    }/* end of if statement */

    // Adding dynamically added items so they can be recognized by name
    // and scripted via script language such as VBScript or JScript
    for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        // iterate throw the array and see if we find matching ID
        CHostedObject* pObj = (*i);

        hr = m_ps->AddNamedItem((pObj)->GetID(), SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);

        if(FAILED(hr)){

            return(hr); // might want to modify this later to not exit if we get one bad object
        }/* end of if statement */    
    }/* end of for loop */
   
    // Special case adding the root object
    if(!::LoadString(m_hRes, IDS_ROOT_OBJECT, strBuffer, ciMaxBuffSize)){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */

#ifdef _UNICODE
    hr = m_ps->AddNamedItem(strBuffer, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);
#else
    hr = m_ps->AddNamedItem(A2W(strBuffer), SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);
#endif

    // Add up the events that we have saved in the event array
    for(CNTEVNT::iterator j = m_cntEvnt.begin(); j!= m_cntEvnt.end(); j++){

        EXCEPINFO ei;
        ::ZeroMemory(&ei, sizeof(EXCEPINFO));

        BSTR strName;
        CEventObject* pObj = (*j);

        hr = m_psp->AddScriptlet(NULL, pObj->m_strEventCode, pObj->m_strObjectID, NULL, pObj->m_strEvent, NULL, 0, 0,  0, &strName, &ei);

        if(FAILED(hr)){

            ATLTRACE(TEXT("Failed to add an event, might be using a different language or the object does not exists. \n"));
            ATLASSERT(FALSE);
            return(hr);
        }/* end of if statement */  
    }/* end of for loop */

    return (hr);
}/* end of function CreateScriptEngine */

/*************************************************************************/
/* Function: DestroyScriptEngine                                         */
/* Description: Destroys the engine. Might be usefull when using one     */
/* script to initialize the objects and the other script to run the      */
/* objects.                                                              */
/*************************************************************************/
STDMETHODIMP CMFBar::DestroyScriptEngine(){

    HRESULT hr = S_OK;

    // Release the language engine, since it may hold on to us
    if (m_psp){
        
        m_psp.Release();        
    }/* end of if statement */

    if (m_ps){

        //HRESULT hrTmp = m_ps->InterruptScriptThread(SCRIPTTHREADID_CURRENT, NULL, SCRIPTINTERRUPT_DEBUG);
        //ATLASSERT(SUCCEEDED(hrTmp));
        
        hr = m_ps->Close();

        if(FAILED(hr)){

            return(hr);
        }/* end of if statement */
                
        m_ps.Release();
    }/* end of if statement */

	return (hr);
}/* end of function DestroyScriptEngine */

/*************************************************************************/
/* Function: Load                                                        */
/* Description: Loads the script.                                        */
/*************************************************************************/
STDMETHODIMP CMFBar::Load(){

#ifndef _UNICODE_SCRIPT_FILE 
    USES_CONVERSION;
#endif

    HRESULT hr = CreateScriptEngine();

    if(FAILED(hr)){

        ATLTRACE(TEXT("Failed to create a script engine.\n")); 
        ATLASSERT(FALSE);
        return(hr);
    }/* end of if statement */

    // see if we can find this resource DLL in the script
//    TCHAR* strType = TEXT("SCRIPT");
    HRSRC hrscScript = ::FindResource(m_hRes, OLE2T(m_strScriptFile), MAKEINTRESOURCE(23));
    
    if(NULL != hrscScript){
        
        /**********************************************************************/
        /* load up the script from a resource                                 */
        /**********************************************************************/

        if(NULL == hrscScript){

            hr = HRESULT_FROM_WIN32(::GetLastError());
            return(hr);
        }/* end of if statement */

        HGLOBAL hScript = ::LoadResource(m_hRes, hrscScript); 

        if(NULL == hScript){

            hr = HRESULT_FROM_WIN32(::GetLastError());
            return(hr);
        }/* end of if statement */
    
        DWORD dwSize = SizeofResource((HMODULE)m_hRes, hrscScript);

        if(dwSize == 0){
        
            hr = E_UNEXPECTED;
            return(hr);
        }/* end of if statement */

        /*****************************************************************/
        /* change this depending if the file was saved as Unicode or not */
        /*****************************************************************/
    #ifndef _UNICODE_SCRIPT_FILE 
        WCHAR* strCode = A2W((CHAR*)hScript);
    #else        
        WCHAR* strCode = (WCHAR*)hScript;    
    #endif

        const INT ciMaxBuffSize = MAX_PATH;
        TCHAR strEOFMarker[ciMaxBuffSize]; // the end of file marker        

        // Load up the end of file delimiter
        if(!::LoadString(m_hRes, IDS_END_FILE, strEOFMarker, ciMaxBuffSize)){

             hr = E_UNEXPECTED;
             return(hr);
        }/* end of if statement */

        EXCEPINFO ei;
        ::ZeroMemory(&ei, sizeof(EXCEPINFO));

        #ifdef _UNICODE
            hr = m_psp->ParseScriptText(strCode, NULL, NULL, strEOFMarker, 0, 0, SCRIPTTEXT_ISEXPRESSION|SCRIPTTEXT_ISVISIBLE, NULL, &ei);
        #else
            hr = m_psp->ParseScriptText(strCode, NULL, NULL, A2W(strEOFMarker), 0, 0, SCRIPTTEXT_ISEXPRESSION|SCRIPTTEXT_ISVISIBLE, NULL, &ei);
        #endif       
    }
    else {
        /**********************************************************************/
        /* load up the script from a file                                     */
        /**********************************************************************/
        // Create File m_strScriptFile
        HANDLE hFile = ::CreateFile(
	                        OLE2T(m_strScriptFile),    // pointer to name of the file
	                        GENERIC_READ,   // access (read-write) mode
	                        FILE_SHARE_READ,    // share mode
	                        NULL,   // pointer to security descriptor
	                        OPEN_EXISTING,  // how to create
	                        FILE_ATTRIBUTE_NORMAL,  // file attributes
	                        NULL    // handle to file with attributes to copy
                           );

        if(hFile == INVALID_HANDLE_VALUE){

            hr = HRESULT_FROM_WIN32(::GetLastError());

            #if _DEBUG
    
                TCHAR strBuffer[MAX_PATH + 25];
                wsprintf(strBuffer, TEXT("Failed to open script file %s"), OLE2T(m_strScriptFile));
                ::MessageBox(::GetFocus(), strBuffer, TEXT("Error"), MB_OK);
            #endif            
            return(hr);
        }/* end of if statement */

        DWORD dwBitsSize = GetFileSize(hFile,NULL);

        if(0 == dwBitsSize){

            hr = E_UNEXPECTED;
            return(hr); // the file size should be definetly more then 0
        }/* end of if statement */

        BYTE* pbBuffer = new BYTE[dwBitsSize + sizeof(WCHAR)];
        ::ZeroMemory(pbBuffer, dwBitsSize + sizeof(WCHAR));

        // load it up convert the text to UNICODE
        DWORD dwBytesRead = 0;

        if(!ReadFile(hFile, pbBuffer, dwBitsSize, &dwBytesRead, NULL)){

            hr = HRESULT_FROM_WIN32(::GetLastError());
	        delete[] pbBuffer;            
            ::CloseHandle(hFile); // close the file
		    return (hr);
    	}/* end of function ReadFile */

        if(dwBitsSize != dwBytesRead){

           ATLTRACE(TEXT("Implement reading loop"));
           delete[] pbBuffer; // free up the temp buffer
           ::CloseHandle(hFile); // close the file
           hr = E_UNEXPECTED;
           return(hr);
        }/* end of if statement */

        /*****************************************************************/
        /* change this depending if the file was saved as Unicode or not */
        /*****************************************************************/
    #ifndef _UNICODE_SCRIPT_FILE 
        WCHAR* strCode = A2W((CHAR*)pbBuffer);
    #else        
        WCHAR* strCode = (WCHAR*)pbBuffer;
    #endif
        delete[] pbBuffer; // free up the temp buffer
        ::CloseHandle(hFile); // close the file

        EXCEPINFO ei;
        ::ZeroMemory(&ei, sizeof(EXCEPINFO));

        #ifdef _UNICODE
            hr = m_psp->ParseScriptText(strCode, NULL, NULL, NULL, 0, 0, SCRIPTTEXT_ISEXPRESSION|SCRIPTTEXT_ISVISIBLE, NULL, &ei);
        #else
            hr = m_psp->ParseScriptText(strCode, NULL, NULL, NULL, 0, 0, SCRIPTTEXT_ISEXPRESSION|SCRIPTTEXT_ISVISIBLE, NULL, &ei);
        #endif
    }/* end of if statement */

    // take out the extra character at the begining of the unicode file just in case it is garbled by editor
    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

	hr = m_ps->SetScriptState(/* SCRIPTSTATE_STARTED */ SCRIPTSTATE_CONNECTED);

	return hr;
}/* end of function Load */

/*************************************************************************/
/* Function: AddScriptlet                                                */
/* Description: Using this method you can add events for JScript and     */
/* other languages that do not support event handlers internally. This   */
/* method just add these to the array which does get initializied on load*/
/*************************************************************************/
STDMETHODIMP CMFBar::AddScriptlet(BSTR strObjectID, BSTR strEvent, BSTR strEventCode){

    HRESULT hr = S_OK;

    CEventObject* pObj = new CEventObject(strObjectID, strEvent, strEventCode);
    
    if(NULL == pObj){

        hr = E_OUTOFMEMORY;
        return(hr);
    }/* end of if statement */

    m_cntEvnt.insert(m_cntEvnt.end(), pObj);

	return(hr);
}/* end of function AddScriptlet */

/*************************************************************************/
/* Function: HookScriptlet                                               */
/* Description: Hooks the scrtiptlet for immidiate use, unlike the       */
/* Add scriptlet which adds it, so it takes effect in the next Load.     */
/* However, it also adds the callback to the array, so if needs to be    */
/* loaded on the next load.                                              */
/*************************************************************************/
STDMETHODIMP CMFBar::HookScriptlet(BSTR strObjectID, BSTR strEvent, BSTR strEventCode){

    HRESULT hr = S_OK;

    try {

        hr = AddScriptlet(strObjectID, strEvent, strEventCode);

        if(!m_ps){
        
            ATLTRACE(TEXT("No Script Engine!! No Run!!\n")); 
            ATLASSERT(FALSE);
            throw(S_FALSE);
        }/* end of if statement */

        EXCEPINFO ei;
        ::ZeroMemory(&ei, sizeof(EXCEPINFO));

        BSTR strName;

        hr = m_ps->SetScriptState(SCRIPTSTATE_STARTED);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = m_psp->AddScriptlet(NULL, strEventCode, strObjectID, NULL, strEvent, NULL, 0, 0,  0, &strName, &ei);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = m_ps->SetScriptState(SCRIPTSTATE_CONNECTED);
              
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function HookScriptlet */

/*************************************************************************/
/* Function: Run                                                         */
/* Description: Runs the Script function. Right now I do not support     */
/* TODO: parameters, but they can be added, by handling VARIANT.         */
/*************************************************************************/
STDMETHODIMP CMFBar::Run(BSTR strStatement){

    HRESULT hr = E_FAIL;

    if(!m_ps){
        
        ATLTRACE(TEXT("No Script Engine!! No Run!!\n")); 
        ATLASSERT(FALSE);
        return(hr);
    }/* end of if statement */

    CComPtr<IDispatch> pDispatch;

    hr = m_ps->GetScriptDispatch(NULL, &pDispatch);

    if (FAILED(hr)){

        return(hr);
    }/* end of if statement */
	    
    DISPID dispidMain;

    LCID lcid = ::GetUserDefaultLCID();
    hr = pDispatch->GetIDsOfNames(IID_NULL, &strStatement, 1, lcid, &dispidMain);
    
    if (hr == ResultFromScode(DISP_E_UNKNOWNNAME))
	    hr = NOERROR;
    else if (FAILED(hr))
	    hr = E_UNEXPECTED;
    else{

	    UINT uArgErr;
	    DISPPARAMS params;
	    EXCEPINFO ei;

	    params.cArgs = 0;
	    params.cNamedArgs = 0;
	    params.rgvarg = NULL;
	    params.rgdispidNamedArgs = NULL;

	    hr = pDispatch->Invoke(dispidMain, IID_NULL, lcid, DISPATCH_METHOD,
						       &params,NULL, &ei, &uArgErr);
        if (FAILED(hr)){
            
		    return(hr);
	    }/* end of if statement */
        
    }/* end of if statement */

#ifdef _DEBUG    
    ULONG ulcstmt;

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    CComQIPtr<IActiveScriptStats> pstat(m_ps);
   
    if (pstat){
        ULONG luT;
        if (FAILED(pstat->GetStat(SCRIPTSTAT_STATEMENT_COUNT, &luT, &ulcstmt)))
	        ulcstmt = 0;            
    }/* end of if statement */

    ATLTRACE("Statments executed %d\n", ulcstmt);
#endif

    return(hr);
}/* end of function Run */

/*************************************************************************/
/* Function: CreateObject                                                */
/* Description: Creates a new ActiveX object that can be scripted.       */
/* Puts the newly created object into container and activates it.        */
/*************************************************************************/
STDMETHODIMP CMFBar::CreateObject(BSTR strID, BSTR strProgID, 
                                  long lx, long ly, long lWidth, long lHeight,
                                  BSTR strPropBag, VARIANT_BOOL fDisabled,
                                  BSTR strScriptHook){

    HRESULT hr;
	CHostedObject *pObj = NULL; // an ActiveX object

    try {

        hr = FindObject(strID, &pObj);
        
        if(SUCCEEDED(hr)){

            ATLTRACE(TEXT("Duplicate Object \n!"));
            throw(E_FAIL);
        }/* end of if statement */

        // create the object
        hr = CHostedObject::CreateObject(strID, strProgID, strPropBag, &pObj);
       
        if(FAILED(hr)){

            ATLTRACE2(atlTraceHosting, 2, TEXT("Failed to Create Object %ls \n"), strID);
            throw(hr);
        }/* end of if statement */

        // initialize inPlaceObject
        CComPtr<IUnknown> pObjectUnknown;
        pObjectUnknown = pObj->GetUnknown();
        
        // Get this container unknown
        CComPtr<IUnknown> pContainerUnknown;
        pContainerUnknown = GetUnknown();

        if(!pContainerUnknown){

            throw(hr);
        }/* end of if statement */
        
        // this is just a container that delegates pretty
        // much all the methods to this container
        // only purpose for its being is that we need to connection
        // between the container and a specific object
        // for SetCapture and SetFocus calls

        CContainerObject* pContainerObj = new CContainerObject(pContainerUnknown, pObj);
        pContainerUnknown.Release();

        if(NULL == pContainerObj){

            throw(E_OUTOFMEMORY);
        }/* end of if statement */

        pObj->SetContainerObject(pContainerObj);

        CComPtr<IUnknown> pUnkContainerObj;
        
        hr = pContainerObj->QueryInterface(IID_IUnknown, (void**)&pUnkContainerObj);
                
        if(FAILED(hr)){

            hr = E_FAIL;
            throw(hr);
        }/* end of if statement */

        // insert it at the end of the list
        // TODO: eventually check for duplicate IDs
        m_cntObj.insert(m_cntObj.end(), pObj);
        // add our self to the script engine, so we can hook up the events
        HRESULT hrTmp = m_ps->AddNamedItem((pObj)->GetID(), SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);

        if(FAILED(hrTmp)){

            ATLTRACE(TEXT("Engine is not initilized yet, but that is what I guess we intended\n"));
            ATLASSERT(FALSE);
        }/* end of if statement */
        
        CComPtr<IOleObject> pOleObject;
        HRESULT hrOle = pObj->GetOleObject(&pOleObject);

        if(SUCCEEDED(hrOle)){

            DWORD dwMiscStatus;
            pOleObject->GetMiscStatus(DVASPECT_CONTENT, &dwMiscStatus);

             // set the OLE site
            CComPtr<IOleClientSite> spClientSite;
        
            hr = pUnkContainerObj->QueryInterface(&spClientSite);

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

			if(dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST){

				pOleObject->SetClientSite(spClientSite); // set the client site
			}/* end of if statement */

            // no property bag so try to initialze from stream
            CComQIPtr<IPersistStreamInit, &IID_IPersistStreamInit> spPSI(pOleObject);
            
            // TODO: Eventaully load up stream via CreateStreamOnHGlobal
            
            if (spPSI)
                spPSI->InitNew(); // create new stream
            

            // see if want to use the IPropertyBag to initialize our properties
            CComQIPtr<IPersistPropertyBag, &IID_IPersistPropertyBag> pBag(pObjectUnknown);

            if (pBag) {
                CComQIPtr<IPropertyBag, &IID_IPropertyBag> pSBag(pUnkContainerObj);
                
                if(!pSBag){
                    
                    ATLTRACE2(atlTraceHosting, 0, _T("Could not get IPropertyBag.\r\n"));
                    ATLASSERT(FALSE);
                    throw(E_UNEXPECTED);
                }/* end of if statement */
                
                HRESULT hrTmp = pBag->Load(pSBag, NULL);
                
                if(SUCCEEDED(hrTmp)){
                    
                    pBag->Save(pSBag, FALSE, TRUE);
                }/* end of if statement */
            }/* end of if statement */
            
            if(0 == (dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)){

				pOleObject->SetClientSite(spClientSite); // set the client site
			}/* end of if statement */

            pObj->InitViewObject(); // cache view object

            // hook up sink/notify for events
            // via this call in which we have chance to hook them up
            if(NULL != *strScriptHook){
                          
                HRESULT hrTmp = Run(strScriptHook);

                if(FAILED(hrTmp)){

                    ATLTRACE(TEXT("Engine is not initilized yet, but that is what I guess we intended\n"));
                    ATLASSERT(FALSE);
                }/* end of if statement */
            }/* end of if statement */
        
            // Get the extents adjust them etc...
            // TODO enhance this to handle generic size
            RECT rcPos;

            SIZEL sSize, shmSize;            
			sSize.cx = lWidth;
			sSize.cy = lHeight;
			AtlPixelToHiMetric(&sSize, &shmSize);

			pOleObject->SetExtent(DVASPECT_CONTENT, &shmSize);
			pOleObject->GetExtent(DVASPECT_CONTENT, &shmSize);
			AtlHiMetricToPixel(&shmSize, &sSize);

            // TODO: handle the moves on SetObjectRects
            // right now we set offset once but this needs to be eventaully done

            rcPos.left   = lx; // use m_rcPos for the offsets these any time we get SetObjectRects call
            rcPos.top    = ly;
			rcPos.right  = rcPos.left + sSize.cx;
			rcPos.bottom = rcPos.top + sSize.cy;
            
            // TODO: we might want to wait till our rect is set 
            // and then let the script to go at it, that way we reduce the moves
            // and possible flashes
            pObj->SetRawPos(&rcPos); // remember our new position raw position

            //pObj->SetOffset(&m_rcPos.left, &m_rcPos.top); // sets the pointers to the offset

            //pObj->GetPos(&rcPos); // get the position back with adjusted rect
            
            

            if(VARIANT_FALSE != fDisabled){	        

              pObj->SetActive(false);
            }/* end of if statement */

            // IN_PLACE ACTIVATE
			hrOle = pOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, spClientSite, 0, m_hWnd, &rcPos);			                                  
        }
        else {
            // use the liter interface when IOleObject is not available            
            CComQIPtr<IObjectWithSite> spSite(pObjectUnknown);
		    
            if(spSite){

			    spSite->SetSite(pUnkContainerObj);
            }/* end of if statement */
        }/* end of if statement */
        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
        // cleanup our variables just in case
        if(NULL != pObj){

            delete pObj;
        }/* end of if statement */
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function CreateObject */

/*************************************************************************/
/* Function: ShowSelfSite                                                */
/* Description: Show itself as an site for itself.                       */
/*************************************************************************/
STDMETHODIMP CMFBar::ShowSelfSite(long nCmd)
{
    if (::IsWindow(m_hWnd)) {
        m_pBackBitmap->DeleteMemDC();
        ::ShowWindow(m_hWnd, nCmd);
        InvalidateRgn();
    }
    return S_OK;
}

/*************************************************************************/
/* Function: SetupSelfSite                                               */
/* Description: Sets itself as an site for itself.                       */
/*************************************************************************/
STDMETHODIMP CMFBar::SetupSelfSite(long lx, long ly, long lWidth, 
                                   long lHeight, BSTR strPropBag,
                                   VARIANT_BOOL fDisabled,
                                   VARIANT_BOOL fHelpDisabled,
                                   VARIANT_BOOL fWindowDisabled){
	
    HRESULT hr;
	CHostedObject *pObj = NULL; // an ActiveX object

    try {
        if(true == m_fSelfHosted){
            // we are already hosting our self so do not try to do so again
            throw(S_FALSE);
        }/* end of if statement */

        if(m_nReadyState == READYSTATE_COMPLETE){

            throw(S_FALSE); //we are already hosted (most likely IE)
        }/* end of if statement */

        m_bWindowOnly = TRUE; // create self as a window
        m_fSelfHosted = true; // we are trying to self host so send a QUIT message
        
        CComPtr<IDispatch> pDisp;
        hr = GetUnknown()->QueryInterface(&pDisp);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        const INT ciMaxBuffSize = MAX_PATH; // should be enough for tlbr ID, keep ID small if can
        TCHAR strBuffer[ciMaxBuffSize];
    
        if(!::LoadString(m_hRes, IDS_ROOT_OBJECT, strBuffer, ciMaxBuffSize)){

            hr = E_UNEXPECTED;
            return(hr);
        }/* end of if statement */

#ifndef _UNICODE
        USES_CONVERSION;        
        BSTR strObjectID = ::SysAllocString(T2W(strBuffer));

#else
        BSTR strObjectID = ::SysAllocString(strBuffer);
#endif

        hr = CHostedObject::AddObject(strObjectID, strPropBag, pDisp, &pObj);
        // strPropBag gets allocated as well
        ::SysFreeString(strObjectID);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        // initialize inPlaceObject
        CComPtr<IUnknown> pObjectUnknown;
        pObjectUnknown = pObj->GetUnknown();

        // Get this container unknown
        CComPtr<IUnknown> pContainerUnknown;
        pContainerUnknown = GetUnknown();

        if(!pContainerUnknown){

            throw(hr);
        }/* end of if statement */
        
        // this is just a container that delegates pretty
        // much all the methods to this container
        // only purpose for its being is that we need to connection
        // between the container and a specific object
        // for SetCapture and SetFocus calls

        CContainerObject* pContainerObj = new CContainerObject(pContainerUnknown, pObj);
        pContainerUnknown.Release();

        if(NULL == pContainerObj){

            throw(E_OUTOFMEMORY);
        }/* end of if statement */

        pObj->SetContainerObject(pContainerObj);

        CComPtr<IUnknown> pUnkContainerObj;
        
        hr = pContainerObj->QueryInterface(IID_IUnknown, (void**)&pUnkContainerObj);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        // DO NOT INSERT THIS OBJECT, SINCE IT IS OUR CONTAINER
        // m_cntObj.insert(m_cntObj.end(), pObj);
        
        CComPtr<IOleObject> pOleObject;
        HRESULT hrOle = pObj->GetOleObject(&pOleObject);

        if(FAILED(hrOle)){

            throw(hrOle);
        }/* end of if statement */
        
        DWORD dwMiscStatus;
        pOleObject->GetMiscStatus(DVASPECT_CONTENT, &dwMiscStatus);

         // set the OLE site
        CComPtr<IOleClientSite> spClientSite;
    
        hr = pUnkContainerObj->QueryInterface(&spClientSite);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

		if(dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST){

			pOleObject->SetClientSite(spClientSite); // set the client site
		}/* end of if statement */

        // no property bag so try to initialze from stream
        CComQIPtr<IPersistStreamInit, &IID_IPersistStreamInit> spPSI(pOleObject);
        
        // TODO: Eventaully load up stream via CreateStreamOnHGlobal
        
        if (spPSI)
            spPSI->InitNew(); // create new stream
        
        // see if want to use the IPropertyBag to initialize our properties
        CComQIPtr<IPersistPropertyBag, &IID_IPersistPropertyBag> pBag(pObjectUnknown);

        if (pBag) {
            CComQIPtr<IPropertyBag, &IID_IPropertyBag> pSBag(pUnkContainerObj);
            
            if(!pSBag){
                
                ATLTRACE2(atlTraceHosting, 0, _T("Could not get IPropertyBag.\r\n"));
                ATLASSERT(FALSE);
                throw(E_UNEXPECTED);
            }/* end of if statement */
            
            HRESULT hrTmp = pBag->Load(pSBag, NULL);
            
            if(SUCCEEDED(hrTmp)){
                
                pBag->Save(pSBag, FALSE, TRUE);
            }/* end of if statement */
        }/* end of if statement */
        
        if(0 == (dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)){

			pOleObject->SetClientSite(spClientSite); // set the client site
		}/* end of if statement */

        pObj->InitViewObject(); // cache view object

        // TODO: hook up sink/notify for events

        // Get the extents adjust them etc...
        // TODO enhance this to handle generic size
        RECT rcPos;

        SIZEL sSize, shmSize;            
		sSize.cx = lWidth;
		sSize.cy = lHeight;
		AtlPixelToHiMetric(&sSize, &shmSize);

		pOleObject->SetExtent(DVASPECT_CONTENT, &shmSize);
		pOleObject->GetExtent(DVASPECT_CONTENT, &shmSize);
		AtlHiMetricToPixel(&shmSize, &sSize);

        // TODO: handle the moves on SetObjectRects
        // right now we set offset once but this needs to be eventaully done        

        rcPos.left   = lx; // use m_rcPos for the offsets these any time we get SetObjectRects call
        rcPos.top    = ly;
		rcPos.right  = rcPos.left + sSize.cx;
		rcPos.bottom = rcPos.top + sSize.cy;
        
        RECT rcClientRect;

        rcClientRect.left   = 0; // use m_rcPos for the offsets these any time we get SetObjectRects call
        rcClientRect.top    = 0;
		rcClientRect.right  = sSize.cx;
		rcClientRect.bottom = sSize.cy;
        
        // TODO: we might want to wait till our rect is set 
        // and then let the script to go at it, that way we reduce the moves
        // and possible flashes

        pObj->SetRawPos(&rcPos); // remember our new position raw position

        // adjust rects
        // IN_PLACE ACTIVATE OUR SELF ACTIVATION VERSION

        if (m_spClientSite == NULL)
		    return S_OK;

	    CComPtr<IOleInPlaceObject> pIPO;
	    ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
	    ATLASSERT(pIPO != NULL);

        m_spClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void**)&m_spInPlaceSite);
		if (m_spInPlaceSite)
			m_bInPlaceSiteEx = TRUE;
		else
			hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSite, (void**) &m_spInPlaceSite);

	    ATLASSERT(m_spInPlaceSite);
	    if (!m_spInPlaceSite)
		    throw(E_FAIL);

	    m_bNegotiatedWnd = TRUE;

	    if (!m_bInPlaceActive){

		    BOOL bNoRedraw = FALSE;
		    if (m_bInPlaceSiteEx)
				m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, 0);
			else
			{
				hr = m_spInPlaceSite->CanInPlaceActivate();
				// CanInPlaceActivate returns S_FALSE or S_OK
				if (FAILED(hr))
					throw(hr);
				if ( hr != S_OK )
				{
				   // CanInPlaceActivate returned S_FALSE.
				   throw( E_FAIL );
				}
				m_spInPlaceSite->OnInPlaceActivate();
			}		        
	    }/* end of if statement */

	    m_bInPlaceActive = TRUE;

	    // get location in the parent window,
	    // as well as some information about the parent
	    //
	    OLEINPLACEFRAMEINFO frameInfo;
	    
	    CComPtr<IOleInPlaceFrame> spInPlaceFrame;
	    CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
	    frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);

	    if (!m_bWndLess){

            DWORD dwStyle;
            DWORD dwExStyle;
            HWND hwndPar = NULL;

            
            if(VARIANT_FALSE == fWindowDisabled){
                // one with the frame
                 dwStyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
                 dwExStyle = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;
            }
            else {
                // one without the frame
                dwStyle =  WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
                //dwExStyle = WS_EX_TRANSPARENT; //| WS_EX_LTRREADING| WS_EX_WINDOWEDGE;
                //dwExStyle = 0x00080000; //WS_EX_LAYERED = 0x00080000;
                dwExStyle = WS_EX_APPWINDOW;
                //hwndPar = ::GetDesktopWindow();
            }/* end of if statement */

            if(VARIANT_FALSE == fDisabled){

                dwStyle |= WS_VISIBLE;                
            }/* end of if statement */            

            if(VARIANT_FALSE == fHelpDisabled){

                dwStyle &= ~(WS_MINIMIZEBOX | WS_MAXIMIZEBOX); // take out the min max style
                            // help does not work with it
                dwExStyle |=  WS_EX_CONTEXTHELP;
            }/* end of if statement */

#ifdef _UNICODE
            HWND h = Create(hwndPar, rcPos, m_bstrCaption /* window name */, dwStyle, dwExStyle);
#else
            USES_CONVERSION;
            HWND h = Create(hwndPar, rcPos, OLE2T(m_bstrCaption) /* window name */, dwStyle, dwExStyle);
#endif
            
            //  used instead of 
			//  HWND h = CreateControlWindow(hwndParent, rcPos);
			ATLASSERT(h != NULL);	// will assert if creation failed
			ATLASSERT(h == m_hWndCD);
			if(NULL == h){

                throw(E_FAIL);
            }/* end of if statement */

            if(VARIANT_TRUE == fWindowDisabled){

                ::SendMessage(h, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM) m_hIcon);
                ::SendMessage(h, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM) m_hIcon);
            }/* end of if statement */

	    }/* end of if statement */

        if(VARIANT_FALSE != fDisabled){	        

          pObj->SetActive(false);
        }/* end of if statement */


    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
        m_fSelfHosted = false;
        // cleanup our variables just in case
        if(NULL != pObj){

            delete pObj;
        }/* end of if statement */
    }
    catch(...){        
        m_fSelfHosted = false;
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function SetupSelfSite */

/*************************************************************************/
/* Function: AddObject                                                   */
/* Description: Adds a scriptable only object that was created somewhere */
/* else into our object container.                                       */
/*************************************************************************/
STDMETHODIMP CMFBar::AddObject(BSTR strObjectID, LPDISPATCH pDisp){

    HRESULT hr;
	CHostedObject *pObj = NULL; // an ActiveX object

    try {
        // add an object that was already created
        // this object does not get the Active flag set which
        // means we will not try to draw it and do other
        // activities on it, such as we would do on the objects
        // that are contained and have a site
        hr = CHostedObject::AddObject(strObjectID, NULL, pDisp, &pObj);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        // now add the object to the container
        // insert it at the end of the list
        // TODO: eventually check for duplicate IDs
        m_cntObj.insert(m_cntObj.end(), pObj);

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
        // cleanup our variables just in case
        if(NULL != pObj){

            delete pObj;
        }/* end of if statement */
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function AddObject */

// #####  END  ACTIVEX SCRIPTING SUPPORT #####

/*************************************************************************/
/* Function: GetParentHWND                                               */
/* Description: Gets the parent window HWND where we are operating.      */
/*************************************************************************/
HRESULT CMFBar::GetParentHWND(HWND* pWnd){

    HRESULT hr = E_FAIL;
    *pWnd = NULL;

    if(m_bWndLess){

        CComPtr<IOleClientSite> pClientSite;

        hr = GetClientSite(&pClientSite);

        if(FAILED(hr)){

		    return(hr);	
        }/* end of if statement */

        CComQIPtr<IOleWindow> pOleWindow(pClientSite);
    
        if(!pOleWindow){

            hr = E_FAIL;
		    return(hr);	
        }/* end of if statement */

        hr = pOleWindow->GetWindow(pWnd);        
    }
    else {

        if(::IsWindow(m_hWnd)){

            *pWnd = ::GetParent(m_hWnd);
            if(::IsWindow(*pWnd)){

                hr = S_OK;
            }/* end of if statement */
        }/* end of if statement */
    }/* end of if statement */

    return(hr);
}/* end of function GetParentHWND */

/*************************************************************************/
/* Function: GetClientRect                                               */
/* Description:  Gets the client rect. If we are windowless we pass down */
/* the m_rcPos.                                                          */
/*************************************************************************/
BOOL CMFBar::GetClientRect(LPRECT lpRect) const{

  BOOL bRet = TRUE;

  if (!lpRect){

    bRet = FALSE;
    return (bRet);
  }/* end of if statement */

  if(m_bWndLess){
      
      *lpRect = m_rcPos;
      return(bRet);
  }/* end of if statement */

  ATLASSERT(::IsWindow(m_hWnd));
  bRet = ::GetClientRect(m_hWnd, lpRect);
      
  return(bRet);
}/* end of function GetClientRect */

/*************************************************************************/
/* Function: GetParent                                                   */
/* Description:  Gets the parent window. If we are windowless we pass    */
/* down the parent container window, which is really in a sense parent.  */
/*************************************************************************/
HWND CMFBar::GetParent(){

  HWND hwnd = NULL;

  if(m_bWndLess){

      GetParentHWND(&hwnd);
      return(hwnd);
  }/* end of if statement */

  ATLASSERT(::IsWindow(m_hWnd));
  return ::GetParent(m_hWnd);
}/* end of function GetParent */

/*************************************************************************/
/* Function: AdjustRects                                                 */
/* Description: calls all our contained objects and the adjusts their    */
/* rects in the case we have moved, if we do not have any that is OK,    */
/* since the offset is kept in m_rcPos and set whenever the objects      */
/* get created.                                                          */
/*************************************************************************/
HRESULT CMFBar::AdjustRects(const LPCRECT prcPos){

    HRESULT hr = S_OK;

    //TODO: handle resizing
    ATLTRACE2(atlTraceHosting, 2, TEXT("Resizing control prcPos->left = %d, prcPos.right = %d, prcPos.bottom =%d, prcPos.top = %d\n"),
        prcPos->left, prcPos->right, prcPos->bottom, prcPos->top); 

    if(false == m_fSelfHosted){

        Fire_OnResize(RECTWIDTH(prcPos), RECTHEIGHT(prcPos), SIZE_RESTORED);        
    }/* end of if statement */

#if 0    
    if(!m_bWndLess){

        return(hr);
    }/* end of if statement */

    if(m_cntObj.empty() == true){

    	hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    CNTOBJ::iterator i;
    for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        CHostedObject* pObj = (*i);
        ATLASSERT(pObj);

        if(m_fSelfHosted && (GetUnknown() == pObj->GetUnknown())){

            continue; // that is us we close our self later after the contained objects
        }/* end of if statement */

        pObj->SetObjectRects(); // adjust the current offset if it needs to be so       
    }/* end of for loop */    
#endif
    return(hr);
}/* end of function AdjustRects */
                               
/*************************************************************************/
/* IOleInPlaceSiteEx Implementation                                      */
/*************************************************************************/

/*************************************************************************/
/* Function: CanWindowlessActivate                                       */
/* Description: Return if we can windowless activate or not.             */
/*************************************************************************/
STDMETHODIMP CMFBar::CanWindowlessActivate(){

	return m_bCanWindowlessActivate ? S_OK : S_FALSE;
}/* end of function CanWindowlessActivate */

/*************************************************************************/
/* Function: GetDC                                                       */
/* Description: Gets a DC to draw with.                                  */
/*************************************************************************/
STDMETHODIMP CMFBar::GetDC(LPCRECT pRect, DWORD grfFlags, HDC* phDC){
    
	HRESULT hr = S_OK;

    if(m_bWndLess){

        hr = m_spInPlaceSite->GetDC(pRect, grfFlags, phDC);
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

		    *phDC  = ::GetDC(m_hWnd);
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */
    }/* end of if statement */

    return(hr);
}/* end of function GetDC */

/*************************************************************************/
/* Function: ReleaseDC                                                   */
/* Description: Releases the DC                                          */
/*************************************************************************/
STDMETHODIMP CMFBar::ReleaseDC(HDC hDC){

    HRESULT hr = S_OK;

    if(m_bWndLess){

        hr = m_spInPlaceSite->ReleaseDC(hDC);
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

		    ::ReleaseDC(m_hWnd, hDC);
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function ReleaseDC */

/*************************************************************************/
/* Function: OnDefWindowMessage                                          */
/* Description: Sends on messages to the default window procedure.       */
/*************************************************************************/
STDMETHODIMP CMFBar::OnDefWindowMessage(UINT msg, WPARAM wParam, 
                                        LPARAM lParam, LRESULT* plResult){

		*plResult = DefWindowProc(msg, wParam, lParam);
		return S_OK;
}/* end of function OnDefWindowMessage */

/*************************************************************************/
/* Function: InvalidateRgn                                               */
/* Description: Invalidates the whole rect in case we need to repaint it.*/
/*************************************************************************/
STDMETHODIMP CMFBar::InvalidateRgn(HRGN hRGN, BOOL fErase){

    HRESULT hr = S_OK;
#if 0
    if (!hRGN) {
        RECT rc;
        GetClientRect(&rc);
        hRGN = ::CreateRectRgn( rc.left, rc.top, rc.right, rc.bottom);
    }

    HRGN newRgn = ::CreateRectRgn(0, 0, 10, 10);
    ::CombineRgn(newRgn, hRGN, NULL, RGN_COPY) ;

    CNTOBJ::iterator i;
    for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        CHostedObject* pObj = (*i);
        ATLASSERT(pObj);

        if(m_fSelfHosted && (GetUnknown() == pObj->GetUnknown())){

            continue; // that is us we close our self later after the contained objects
        }/* end of if statement */

        if (!pObj->IsWindowless() &&  pObj->IsActive()) {
            LONG x1, y1, w, h;
            GetObjectPosition(pObj->GetID(), &x1, &y1, &w, &h);
            HRGN objRgn = ::CreateRectRgn( x1, y1, x1+w, y1+h );
            ::CombineRgn(newRgn, newRgn, objRgn, RGN_DIFF);
            //ATLTRACE(TEXT("Excluding Rgn %d %d %d %d\n"), x1, y1, x1+w, y1+h);
        }
    }/* end of for loop */    

    hRGN = newRgn;
#endif

    if(m_bWndLess){

        hr = m_spInPlaceSite->InvalidateRgn(hRGN ,fErase);
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

		    ::InvalidateRgn(m_hWnd, hRGN, fErase); // see if we can get by by not erasing..
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function InvalidateRgn */

/*************************************************************************/
/* Function: InvalidateRect                                              */
/* Description: Invalidates the rect, handles if we are windowless       */
/*************************************************************************/
STDMETHODIMP CMFBar::InvalidateRect(LPCRECT pRect, BOOL fErase){

    HRESULT hr = S_OK;

    if(m_bWndLess){

        hr = m_spInPlaceSite->InvalidateRect(pRect, fErase);
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

		    ::InvalidateRect(m_hWnd, pRect, fErase);
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function InvalidateRect */

/*************************************************************************/
/* Function: GetCapture                                                  */
/* Description: Used to determine if we have a cupature or not           */
/*************************************************************************/
STDMETHODIMP CMFBar::GetCapture(){

    HRESULT hr = S_OK;

    if(m_bWndLess){
       
        hr = m_spInPlaceSite->GetCapture();                    
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

            hr = ::GetCapture() == m_hWnd ? S_OK : S_FALSE;
        }/* end of if statement */
    }/* end of if statement */
            
    return(hr);    
}/* end of function GetCapture */
	
/*************************************************************************/
/* Function: SetCapture                                                  */
/* Description: Used to set the capture for mouse events                 */
/* Only one container at the time can have a capture.                    */
/*************************************************************************/
STDMETHODIMP CMFBar::SetCapture(BOOL fCapture){

    HRESULT hr = S_OK;

    // whatever we we are doing we need to reset the capture flags on all the object
    // after this call is finished the specific site will set appropriate flag
    ResetCaptureFlags();

    if(fCapture){

        ATLTRACE2(atlTraceUser, 31, TEXT("Setting Mouse Capture in the container \n")); 
    }
    else {

        ATLTRACE2(atlTraceUser, 31, TEXT("Resetting Mouse Capture in the container\n")); 
    }/* end of if statement */
    
    if(m_bWndLess){

        if (fCapture){

            hr = m_spInPlaceSite->SetCapture(TRUE);            
        }
        else {

            hr = m_spInPlaceSite->SetCapture(FALSE);            
        }/* end of if statement */
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

	        if (fCapture){
                // do not have a capture, so set it
                ::SetCapture(m_hWnd);                
            }
            else{
                // nobody more has a capture, so let it go
                ::ReleaseCapture();                
            }/* end of if statement */
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);    
}/* end of function SetCapture */

/*************************************************************************/
/* Function: ResetCaptureFlags                                           */
/* Description: Resets the capture on contained objects.                 */
/*************************************************************************/
HRESULT  CMFBar::ResetCaptureFlags(){

    for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
        // iterate through all the contained objects and draw them
        CHostedObject* pObj = (*i);
   
        pObj->SetCapture(false);
    }/* end of for function */

    return(S_OK);
}/* end of function ResetCaptureFlags */

/*************************************************************************/
/* Function: ResetFocusFlags                                             */
/* Description: Resets the capture on contained objects.                 */
/*************************************************************************/
HRESULT  CMFBar::ResetFocusFlags(){

    for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
        // iterate through all the contained objects and draw them
        CHostedObject* pObj = (*i);
        if(pObj->HasFocus()){

            LONG lRes;
            SetObjectFocus(pObj, FALSE, lRes);          
        }/* end of if statement */
    }/* end of for function */

    return(S_OK);
}/* end of function ResetFocusFlags */

/*************************************************************************/
/* Function: EnumObjects                                                 */
/* Description: Returns IEnumUnknown                                     */
/*************************************************************************/
STDMETHODIMP CMFBar::EnumObjects(DWORD /*grfFlags*/, IEnumUnknown** ppenum){

    if (ppenum == NULL)
	    return E_POINTER;

    *ppenum = NULL;

    // TODO: handle flags

    if(m_cntObj.empty() == true){

    	return E_FAIL;
    }/* end of if statement */

    typedef CComObject<CComEnum<IEnumUnknown, &IID_IEnumUnknown, IUnknown*, _CopyInterface<IUnknown> > > enumunk;
    enumunk* p = NULL;
    ATLTRY(p = new enumunk);
    if(p == NULL)
	    return E_OUTOFMEMORY;

    // create an array to which we put our *IUnknowns   
    INT iSize = m_cntObj.size();
    IUnknown** pArray = new IUnknown* [iSize];

    if(pArray == NULL)
	    return E_OUTOFMEMORY;
    
    bool bFirstElement = true;
	CNTOBJ::iterator i;
    INT iCount = 0;

    for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
    // move the interfaces to the array        
        CHostedObject* pObj = (*i);        
        pArray[iCount] = pObj->GetUnknown();
        iCount++;
    }/* end of for loop */

    HRESULT hRes = p->Init(pArray, pArray + iSize, GetUnknown(), AtlFlagCopy);
    if (SUCCEEDED(hRes))
	    hRes = p->QueryInterface(IID_IEnumUnknown, (void**)ppenum);
    if (FAILED(hRes))
	    delete p;

    delete[] pArray;

    return hRes;
}/* end of function EnumObjects */

/*************************************************************************/
/* Function: SendMessageToCtl                                            */
/* Description: Forwards message to a control                            */
/*************************************************************************/
HRESULT CMFBar::SendMessageToCtl(CHostedObject* pObj, 
                                      UINT uMsg, WPARAM wParam, LPARAM lParam,
                                      BOOL& bHandled, LONG& lRes, bool fWndwlsOnly){

    HRESULT hr = S_OK;
   
    if(NULL == pObj){

      hr = E_UNEXPECTED;
      return(hr);
    }/* end of if statement */

    if(fWndwlsOnly && (!pObj->IsWindowless())){

        ATLTRACE2(atlTraceUser, 31, TEXT("NOT SENDING message to control %ls !!!\n"), pObj->GetID());
        hr = E_FAIL;
        return(hr);
    }/* end of if statement */

    if(!pObj->IsActive()){

        ATLTRACE2(atlTraceUser, 31, TEXT("NOT SENDING message to control %ls !!!\n"), pObj->GetID());
        hr = E_FAIL;
        return(hr);
    }/* end of if statement */
   
    CComPtr<IUnknown> pUnk = pObj->GetUnknown();

    if(!pUnk){

        ATLASSERT(FALSE); // should not be null
        return(E_FAIL);
    }/* end of if statement */

    CComQIPtr<IOleInPlaceObjectWindowless> spInPlaceObjectWindowless(pUnk);
    
    if(spInPlaceObjectWindowless){

        // more then one control can have have a capture			    

        LRESULT lRes64;
        spInPlaceObjectWindowless->OnWindowMessage(uMsg, wParam, lParam, &lRes64);

         //BUGBUG: Just to get this compiling for now. Will overhaul all
         //datatypes later for 64-bit compatibility

        lRes = (LONG)lRes64;

         bHandled = TRUE;                                        
    }/* end of if statement */

    return(hr);
}/* end of function SendMessageToCtl */
  
/*************************************************************************/
/* Function: GetFocus                                                    */
/* Description: Determine if we have a focus or not.                     */
/*************************************************************************/
STDMETHODIMP CMFBar::GetFocus(){

    HRESULT hr = S_OK;

    if(m_bWndLess){
       
        hr = m_spInPlaceSite->GetFocus();                    
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

            hr = ::GetFocus() == m_hWnd ? S_OK : S_FALSE;
        }/* end of if statement */
    }/* end of if statement */
            
    return(hr);    
}/* end of function GetFocus */

/*************************************************************************/
/* Function: SetFocus                                                    */
/* Description: Sets focus to the control                                */
/*************************************************************************/
STDMETHODIMP CMFBar::SetFocus(BOOL fFocus){
    
    HRESULT hr = S_OK;

    // we reset the flags depending on WM_SET and WM_KILL focus messages
    if(fFocus){

        ATLTRACE2(atlTraceUser, 31, TEXT("Setting Mouse Focus in the container \n")); 
    }
    else {

        ATLTRACE2(atlTraceUser, 31, TEXT("Resetting Mouse Focus in the container\n")); 
    }/* end of if statement */
    
    if(m_bWndLess){

        if (fFocus){

            hr = m_spInPlaceSite->SetFocus(TRUE);            
        }
        else {

            hr = m_spInPlaceSite->SetFocus(FALSE);            
        }/* end of if statement */
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

	        if (fFocus){
                
                ::SetFocus(m_hWnd);                
            }
            else {

                // else could call ::SetFocus(NULL), but that does not seem like a good solution
                // so instead reset the focus on contained conrols 
                // which is risky too, since some control could try to call SetFocus(false)
                // when it does not have the focus, but that is handled in the caller
                //ResetFocusFlags();
            }/* end of if statement */                        
        }/* end of if statement */
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);    
}/* end of function SetFocus */

/*************************************************************************/
/* Function: get_ActivityTimeOut                                         */
/* Description: Gets the currrent timout value.                          */
/*************************************************************************/
STDMETHODIMP CMFBar::get_ActivityTimeout(long *plTimeout){

    *plTimeout = m_lTimeout;
    return(S_OK);
}/* end of function get_ActivityTimeOut */

/*************************************************************************/
/* Function: put_ActivityTimeOut                                         */
/* Description: Creates a new timer if needed.                           */
/*************************************************************************/
STDMETHODIMP CMFBar::put_ActivityTimeout(long lTimeout){

    if(lTimeout < 0){

        return(E_INVALIDARG);
    }/* end of if statement */

    if(!::IsWindow(m_hWnd)){

        return(E_FAIL);
    }/* end of if statement */

    if(m_lTimeout != 0 || 0 == lTimeout ){

        // kill it each time we set a new timer
        ::KillTimer(m_hWnd, ID_EV_TIMER);
    }
    else {

        if(0 == ::SetTimer(m_hWnd, ID_EV_TIMER, lTimeout, NULL)){

            return(E_FAIL);
        }/* end of if statement */
    }/* end of if statement */

    m_lTimeout = lTimeout;
    m_fUserActivity = false;    
    m_fWaitingForActivity = false;

    return(S_OK);
}/* end of function put_ActivityTimeOut */

/*************************************************************************/
/* Function: SetObjectExtent                                             */
/* Description: Sets specific object witdth and height.                  */
/*************************************************************************/
STDMETHODIMP CMFBar::SetObjectExtent(BSTR strObjectID, long lWidth, long lHeight){

    HRESULT hr = E_FAIL;

    if(NULL == strObjectID){

        hr = E_POINTER;
        return(hr);
    }/* end of if sattement */
    
    bool bFirstElement = true;
	CNTOBJ::iterator i;
    for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        CHostedObject* pObj = (*i);

        if(!_wcsicmp(pObj->GetID(), strObjectID)){
            RECT rcOld;
            hr = pObj->GetPos(&rcOld);
            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */

            RECT rcNew; 
            rcNew.left = rcOld.left; rcNew.top = rcOld.top; 
            rcNew.right = rcNew.left + lWidth; rcNew.bottom = rcNew.top + lHeight;

            if(::EqualRect(&rcOld, &rcNew)){

                hr = S_FALSE; // no point to monkey around if the rects are the same
                return(hr);
            }/* end of if statement */

            // Set the objects new position            
            hr = pObj->SetRawPos(&rcNew); 
            
            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */

            // Set the objects new position            
            hr = pObj->SetRawPos(&rcNew); 
            
            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */

            if(pObj->IsWindowless()){

                hr = pObj->SetObjectRects();            
            }
            else {
                
                hr = pObj->SetObjectRects(&rcNew);            
            }/* end of if statement */

            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */
            
            RECT rcUnion;

            ::UnionRect(&rcUnion, &rcOld, &rcNew);

            if (pObj->IsWindowless())
                hr = InvalidateRect(&rcUnion, FALSE);

            break; // already have set the state and invalidated and bail out
        }/* end of if statement */
    }/* end of for loop */

	return (hr);
}/* end of function SetObjectExtent */

/*************************************************************************/
/* Function: SetObjectPosition                                           */
/* Description: Sets specific object position. Looks up object by object */
/* ID.  Sets also extents.                                               */
/*************************************************************************/
STDMETHODIMP CMFBar::SetObjectPosition(BSTR strObjectID, long xPos, 
                                       long yPos, long lWidth, long lHeight){

    HRESULT hr = E_FAIL;

    if(NULL == strObjectID){

        hr = E_POINTER;
        return(hr);
    }/* end of if sattement */

    RECT rcNew; 
    rcNew.left = xPos; rcNew.top = yPos; 
    rcNew.right = rcNew.left + lWidth; rcNew.bottom = rcNew.top + lHeight;

    bool bFirstElement = true;
	CNTOBJ::iterator i;
    for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        CHostedObject* pObj = (*i);

        if(!_wcsicmp(pObj->GetID(), strObjectID)){
            RECT rcOld;
            hr = pObj->GetPos(&rcOld);
            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */

            if(::EqualRect(&rcOld, &rcNew)){

                hr = S_FALSE; // no point to monkey around if the rects are the same
                return(hr);
            }/* end of if statement */

            // Set the objects new position            
            hr = pObj->SetRawPos(&rcNew); 
            
            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */

            if(pObj->IsWindowless()){

                hr = pObj->SetObjectRects();            
            }
            else {
                
                hr = pObj->SetObjectRects(&rcNew);            
            }/* end of if statement */

            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */
            
            RECT rcUnion;

            ::UnionRect(&rcUnion, &rcOld, &rcNew);

            if (pObj->IsWindowless())
                hr = InvalidateRect(&rcUnion, FALSE);

            break; // already have set the state and invalidated and bail out
        }/* end of if statement */
    }/* end of for loop */

	return (hr);
}/* end of function SetObjectPosition */

/*************************************************************************/
/* Function: GetObjectPosition                                           */
/* Description: SetObjectPosition                                        */
/*************************************************************************/
STDMETHODIMP CMFBar::GetObjectPosition(BSTR strObjectID, long* pxPos, long* pyPos, long* plWidth, long* plHeight){

    HRESULT hr = E_FAIL;

    if(NULL == strObjectID){

        hr = E_POINTER;
        return(hr);
    }/* end of if sattement */

    if(NULL == pxPos || NULL == pyPos || NULL == plWidth || NULL == plHeight){

        return(E_POINTER);
    }/* end of if statement */

    *pxPos = *pyPos = *plWidth = *plHeight = 0;

    bool bFirstElement = true;
	CNTOBJ::iterator i;
    for(i = m_cntObj.begin(); i!= m_cntObj.end(); i++){
        
        if(!_wcsicmp((*i)->GetID(), strObjectID)){

            CHostedObject* pObj = (*i);        
             
            // Set the objects new position
            RECT rc;             
            hr = pObj->GetPos(&rc);

            if(SUCCEEDED(hr)){
                
                *pxPos = rc.left; *pyPos = rc.top; *plWidth = RECTWIDTH(&rc); *plHeight = RECTHEIGHT(&rc);
            }/* end of if statement */

            break; // already have set the state and invalidated and bail out
        }/* end of if statement */
    }/* end of for loop */

	return (hr);
}/* end function GetObjectPosition */

/*************************************************************************/
/* Function: WinHelp                                                     */
/* Description: Called by the script to execute specific help topic.     */
/*************************************************************************/
STDMETHODIMP CMFBar::WinHelp(long lCommand, long dwData, BSTR strHelpFile){

    HRESULT hr = S_OK;

    try {
        HWND h = NULL;

        hr = GetWindow(&h);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        USES_CONVERSION;
        BOOL bResult = ::WinHelp(h, OLE2T(strHelpFile), lCommand, dwData);

        if(!bResult){

            // failed so lets try to get some more meaningful result
            hr = HRESULT_FROM_WIN32(::GetLastError());            
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function WinHelp */

/*************************************************************************/
/* Function: MessageBox                                                  */
/* Description: Displays the message box using specified parameters.     */
/*************************************************************************/
STDMETHODIMP CMFBar::MessageBox(BSTR strText, BSTR strCaption, long lType){

    HRESULT hr = S_OK;

    try {
        USES_CONVERSION;

        HWND hWnd = NULL;
        HRESULT hr = GetWindow(&hWnd);

        if(FAILED(hr)){

            ATLASSERT(FALSE);    
            throw(hr);
        }/* end of if statement */

        ::MessageBox(hWnd, OLE2T(strText), OLE2T(strCaption), lType);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }
	return S_OK;
}/* end of function MessageBox */

/*************************************************************************/
/* Function: GetToolbarName                                              */
/* Description: Gets and allocates the toolbar name.                     */
/*************************************************************************/
HRESULT CMFBar::GetToolbarName(BSTR* strToolbarName){

    HRESULT hr = S_OK;

    if(NULL == strToolbarName){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    const INT ciMaxBuffSize = MAX_PATH; // should be enough for tlbr ID, keep ID small if can
    TCHAR strBuffer[ciMaxBuffSize];
    
    if(!::LoadString(m_hRes, IDS_ROOT_OBJECT, strBuffer, ciMaxBuffSize)){

        hr = E_FAIL;
        return(E_FAIL);
    }/* end of if statement */   

#ifdef _UNICODE  
    *strToolbarName = ::SysAllocString(strBuffer); 
#else
   USES_CONVERSION;
   *strToolbarName = ::SysAllocString(T2OLE(strBuffer));
#endif

   return(hr);
}/* end of function GetToolbarName */

/*************************************************************************/
/* Function: SetPriority                                                 */
/* Description: Sets the thread priority.                                */
/*************************************************************************/
STDMETHODIMP CMFBar::SetPriority(long lPriority){

    HRESULT hr = S_OK;

    try {

        HANDLE hThread = ::GetCurrentThread();

        if(!::SetThreadPriority(hThread, lPriority)){

            hr = HRESULT_FROM_WIN32(::GetLastError());
            throw (hr);
        }/* end of if statement */
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function SetPriority */

/*************************************************************************/
/* Function: SetPriorityClass                                            */
/* Description: Sets the thread priority.                                */
/*************************************************************************/
STDMETHODIMP CMFBar::SetPriorityClass(long lPriority){

    HRESULT hr = S_OK;

    try {

        HANDLE hThread = ::GetCurrentThread();

        if(!::SetPriorityClass(hThread, lPriority)){

            hr = HRESULT_FROM_WIN32(::GetLastError());
            throw (hr);
        }/* end of if statement */
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function SetPriorityClass */

/*************************************************************************/
/* Function: get_BackgroundImage                                         */
/* Description: Gets the backround image.                                */
/*************************************************************************/
STDMETHODIMP CMFBar::get_BackgroundImage(BSTR *pstrFilename){

	*pstrFilename = m_bstrBackImageFilename.Copy();
	return S_OK;
}/* end of function get_BackgroundImage */

/*************************************************************************/
/* Function: put_BackgroundImage                                         */
/* Description: Attempts to load the background image.                   */
/*************************************************************************/
STDMETHODIMP CMFBar::put_BackgroundImage(BSTR strFilename){

    USES_CONVERSION;
    HRESULT hr = S_OK;

    if(NULL != m_pBackBitmap){

        delete m_pBackBitmap;
    }/* end of if statement */

    m_pBackBitmap = new CBitmap;

    m_pBackBitmap->LoadPalette(true); // load the palette if available, since this
                                 // is the palette we use for the rest
                                 // of the contained objects

	m_bstrBackImageFilename = strFilename;

    TCHAR strBuffer[MAX_PATH] = TEXT("\0");

    bool fGrayOut = false;

    hr = m_pBackBitmap->PutImage(strFilename, m_hRes, GetUnknown(),fGrayOut ,m_blitType);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    // we are updating image that is being used, refresh it
    ATLTRACE2(atlTraceWindowing, 20, TEXT("Redrawing the image\n"));
    InvalidateRgn(); // our helper function            

    return(hr);
}/* end of function put_BackgroundImage */

/*************************************************************************/
/* Function: SetReadyState                                               */
/* Description: Sets ready state and fires event if it needs to be fired */
/*************************************************************************/
HRESULT CMFBar::SetReadyState(LONG lReadyState){

    HRESULT hr = S_OK;
    
    bool bFireEvent = (lReadyState != m_nReadyState);

    
#ifdef _DEBUG    
    if(m_nFreezeEvents > 0){

        ::Sleep(10);
        ATLTRACE("Container not expecting events at the moment");
    }/* end of is statement */

#endif

    if(bFireEvent){

        put_ReadyState(lReadyState);
        Fire_ReadyStateChange(lReadyState);
    }
    else {
        // set the variable
        m_nReadyState = lReadyState;
    }/* end of if statement */

    return(hr);
}/* end of function SetReadyState */

/*************************************************************************/
/* Function: OnPostVerbInPlaceActivate                                   */
/* Description: Creates the in place active object.                      */
/*************************************************************************/
HRESULT CMFBar::OnPostVerbInPlaceActivate(){

    SetReadyState(READYSTATE_COMPLETE);

    return(S_OK);
}/* end of function OnPostVerbInPlaceActivate */

/*************************************************************************/
/* Function: get_AutoLoad                                                */
/*************************************************************************/
STDMETHODIMP CMFBar::get_AutoLoad(VARIANT_BOOL *pVal){

    *pVal = m_fAutoLoad;

	return S_OK;
}/* end of function get_AutoLoad */

/*************************************************************************/
/* Function: put_AutoLoad                                                */
/* Description: Sets the flag to autolaod the engine after we set a      */
/* script file or not.                                                   */
/*************************************************************************/
STDMETHODIMP CMFBar::put_AutoLoad(VARIANT_BOOL newVal){

    m_fAutoLoad = (VARIANT_FALSE == newVal ? VARIANT_FALSE : VARIANT_TRUE);

	return S_OK;
}/* end of function put_AutoLoad */

/*************************************************************/
/* Name: SetRectRgn
/* Description: Set up a rectangular window update region
/*************************************************************/
STDMETHODIMP CMFBar::SetRectRgn(long x1, long y1, long x2, long y2)
{
    HRGN hRgn = ::CreateRectRgn( x1, y1, x2, y2 );
    ::SetWindowRgn(m_hWnd, hRgn, TRUE);
	return S_OK;
}

/*************************************************************/
/* Name: SetRoundRectRgn
/* Description: Set up a round corner window update region
/*************************************************************/
STDMETHODIMP CMFBar::SetRoundRectRgn(long x1, long y1, long x2, long y2, long width, long height){

    HRGN hRgn = ::CreateRoundRectRgn(x1, y1, x2, y2, width, height);
    ::SetWindowRgn(m_hWnd, hRgn, TRUE);
	return S_OK;
}/* end of function SetRoundRectRgn */

/*************************************************************/
/* Function: SetTimeout                                      */
/* Description: Creates a timer and then calls events when   */
/* timer proc gets called.                                   */
/*************************************************************/
STDMETHODIMP CMFBar::SetTimeout(long lTimeout, long lId){

    if(lTimeout < 0){

        return(E_INVALIDARG);
    }/* end of if statement */

    if(!::IsWindow(m_hWnd)){

        return(E_FAIL);
    }/* end of if statement */

    if(ID_EV_TIMER == lId){

        return(E_INVALIDARG);
    }/* end of if statement */

    if(lTimeout == 0){

        ::KillTimer(m_hWnd, lId);
    }
    else{

        if(0 != lTimeout){

            if(0 == ::SetTimer(m_hWnd, lId, lTimeout, NULL)){

                return(E_FAIL);
            }/* end of if statement */
        }/* end of if statement */	
    }/* end of if statement */

	return S_OK;
}/* end of function SetTimeout */

/*************************************************************/
/* Function: Sleep                                           */
/*************************************************************/
STDMETHODIMP CMFBar::Sleep(long lMiliseconds){

    ::Sleep(lMiliseconds);

	return S_OK;
}/* end of function Sleep */

/*************************************************************/
/* Name: OnButtonDown
/* Description: Handles WM_MOUSEDOWN
/*************************************************************/
LRESULT CMFBar::OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(::IsWindow(m_hWnd)){    
        
        m_ptMouse.x = GET_X_LPARAM(lParam);
        m_ptMouse.y = GET_Y_LPARAM(lParam);
        ::ClientToScreen(m_hWnd, &m_ptMouse);
        ::SetCapture(m_hWnd);
        SetFocus(TRUE);
        ATLTRACE(TEXT("Button down, starting to track\n"));

        m_bMouseDown = TRUE;
        
        // Test for resize hit region
        ::GetWindowRect(m_hWnd, &m_rcWnd);
        m_HitRegion = ResizeHitRegion(m_ptMouse);
        UpdateCursor(m_HitRegion);
    }/* end of if statement */
    
    return 0;
}

/*************************************************************/
/* Name: OnButtonUp
/* Description: Handles WM_MOUSEUP
/*************************************************************/
LRESULT CMFBar::OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(::IsWindow(m_hWnd)){

        ::ReleaseCapture();
        ATLTRACE(TEXT("Done tracking the window\n"));
        m_bMouseDown = false;
        m_HitRegion = ResizeHitRegion(m_ptMouse);
        UpdateCursor(m_HitRegion);

    }/* end of if statement */
    
    return 0;
}

/*************************************************************/
/* Name: OnMouseMove
/* Description: Handles WM_MOUSEMOVE
/*************************************************************/
LRESULT CMFBar::OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
        
    if(::IsWindow(m_hWnd)){
        ::GetWindowRect(m_hWnd, &m_rcWnd);
        
        POINT ptMouse;
        ptMouse.x = GET_X_LPARAM(lParam);
        ptMouse.y = GET_Y_LPARAM(lParam);
        ::ClientToScreen(m_hWnd, &ptMouse);
        
        // Test for resize hit region
        int hitRegion = ResizeHitRegion(ptMouse);
        if (!m_bMouseDown)
            UpdateCursor(hitRegion);
        
        // No mouse movement, return
        long xAdjustment = m_ptMouse.x - ptMouse.x;
        long yAdjustment = m_ptMouse.y - ptMouse.y;
        if (xAdjustment == 0 &&  yAdjustment == 0)
            return 0;

        m_ptMouse = ptMouse;
//        ATLTRACE(TEXT("Mouse pos: %d %d\n"), m_ptMouse.x, m_ptMouse.y);

        if (m_HitRegion!=NOHIT && m_bMouseDown) {
            long resizeX = m_rcWnd.left;
            long resizeY = m_rcWnd.top;
            long resizeW = RECTWIDTH(&m_rcWnd);
            long resizeH = RECTHEIGHT(&m_rcWnd);
            if (m_HitRegion & LEFT) {
                if (m_rcWnd.right-ptMouse.x >= m_lMinWidth) {
                    resizeW = m_rcWnd.right-ptMouse.x;
                    resizeX = ptMouse.x;
                }
                else {
                    resizeW = m_lMinWidth;
                    resizeX = m_rcWnd.right-m_lMinWidth;
                }
                ATLTRACE(TEXT("m_rcWnd right %d\n"), m_rcWnd.right);
            }
            if (m_HitRegion & RIGHT) {
                if (ptMouse.x-m_rcWnd.left >= m_lMinWidth) {
                    resizeW = ptMouse.x-m_rcWnd.left;
                }
                else {
                    resizeW = m_lMinWidth;
                }

            }
            if (m_HitRegion & TOP) {
                if (m_rcWnd.bottom-ptMouse.y >= m_lMinHeight) {
                    resizeH = m_rcWnd.bottom-ptMouse.y;
                    resizeY = ptMouse.y;
                }
                else {
                    resizeH = m_lMinHeight;
                    resizeY = m_rcWnd.bottom - m_lMinHeight;
                }
            }
            if (m_HitRegion & BOTTOM) {
                if (ptMouse.y-m_rcWnd.top >= m_lMinHeight) {
                    resizeH = ptMouse.y-m_rcWnd.top;
                }
                else {
                    resizeH = m_lMinHeight;
                }
            }

            if (resizeW >= m_lMinWidth || resizeH >= m_lMinHeight) {

                if(NULL != m_pBackBitmap){

                    m_pBackBitmap->DeleteMemDC();
                }/* end of if statement */
                ::MoveWindow(m_hWnd, resizeX, resizeY, resizeW, resizeH, TRUE);
                ATLTRACE(TEXT("Resize window to: %d %d %d %d\n"), resizeX, resizeY, resizeX+resizeW, resizeY+resizeH);
            }

        }/* end of if statement */
    
            
        else if(m_bMouseDown){
            long x = m_rcWnd.left;
            long y = m_rcWnd.top;
            long width = RECTWIDTH(&m_rcWnd);
            long height = RECTHEIGHT(&m_rcWnd);
            ::MoveWindow(m_hWnd, x - xAdjustment, y - yAdjustment, width, height, TRUE);
            ATLTRACE2(atlTraceWindowing, 32, TEXT("Moving the window\n"));
            m_ptMouse = ptMouse;
        }/* end of if statement */
    }/* end of if statement */
    
    return 0;
}

/*************************************************************/
/* Name: ResizeHitRegion                                     */
/* Description: Test if mouse is in resize hit region        */
/*************************************************************/
int CMFBar::ResizeHitRegion(POINT p){

    // TODO: DO NOT HARDCODE THE REGION SIZES
    int hitRegion = NOHIT;
    if (abs(p.x-m_rcWnd.left)<=10) {
        hitRegion |= LEFT;
    }
    else if (abs(p.x-m_rcWnd.right)<=10) {
        hitRegion |= RIGHT;
    }/* end of if statement */

    if (abs(p.y-m_rcWnd.top)<=10) {
        hitRegion |= TOP;
    }
    else if (abs(p.y-m_rcWnd.bottom)<=10) {
        hitRegion |= BOTTOM;
    }/* end of if statement */

    return hitRegion;
}/* end of function ResizeHitRegion */

/*************************************************************/
/* Name: UpdateCursor                                        */
/* Description: Change cursor shape to move arrows           */
/*************************************************************/
HRESULT CMFBar::UpdateCursor(int hitRegion){

    HCURSOR hCursor;
    switch (hitRegion) {
    case LEFT|NOHIT:
    case RIGHT|NOHIT:
        hCursor = ::LoadCursor(0, IDC_SIZEWE);
        break;
    case TOP|NOHIT:
    case BOTTOM|NOHIT:
        hCursor = ::LoadCursor(0, IDC_SIZENS);
        break;
    case LEFT|TOP|NOHIT:
    case RIGHT|BOTTOM|NOHIT:
        hCursor = ::LoadCursor(0, IDC_SIZENWSE);
        break;
    case RIGHT|TOP|NOHIT:
    case LEFT|BOTTOM|NOHIT:
        hCursor = ::LoadCursor(0, IDC_SIZENESW);
        break;
    default:
        hCursor = ::LoadCursor(0, IDC_ARROW);
        break;

    }/* end of switch statement */

    ::SetCursor(hCursor);

    return S_OK;
}/* end of function UpdateCursor */

/*************************************************************************/
/* Function: SetObjectFocus                                              */
/* Description: Sets or resets focus to specific object.                 */
/*************************************************************************/
STDMETHODIMP CMFBar::SetObjectFocus(BSTR strObjectID, VARIANT_BOOL fEnable){

    HRESULT hr = S_OK;

    try {

        CHostedObject* pObj;

        hr = FindObject(strObjectID, &pObj);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statetement */

        LONG lRes = 0;

        hr = SetObjectFocus(pObj, VARIANT_FALSE == fEnable ? FALSE : TRUE, lRes);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(-1 == lRes){

            throw(E_FAIL); // the control did not take the focus since it is disabled
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;      
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */    

    return(hr);
}/* end of function SetObjectFocus */

/*************************************************************************/
/* Function: HasObjectFocus                                              */
/*************************************************************************/
STDMETHODIMP CMFBar::HasObjectFocus(BSTR strObjectID, VARIANT_BOOL* pfEnable){

    HRESULT hr = S_OK;

    try {

        CHostedObject* pObj;

        hr = FindObject(strObjectID, &pObj);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statetement */
        
        *pfEnable = pObj->HasFocus() ? VARIANT_TRUE : VARIANT_FALSE;
       
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;      
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */    

    return(hr);
}/* end of function HasObjectFocus */

/*************************************************************************/
/* Function: SetObjectFocus                                              */
/* Description: Sets or resets focus to specific object.                 */
/*************************************************************************/
HRESULT CMFBar::SetObjectFocus(CHostedObject* pObj, BOOL fSet, LONG& lRes){

    HRESULT hr = S_OK;

    CContainerObject* pCnt;
    hr = pObj->GetContainerObject(&pCnt);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    LONG lParam = 0;
    BOOL bHandled = FALSE;

    if(fSet){

        ResetFocusFlags(); // reset old focus on other control
        pCnt->SetFocus(TRUE);                                                                      
        SendMessageToCtl(pObj, WM_SETFOCUS, (WPARAM) m_hWnd, lParam, bHandled, lRes, false);

        ATLTRACE2(atlTraceUser, 31, TEXT("Sending WM_SETFOCUS to %ls \n"), pObj->GetID());
    }
    else {

        pCnt->SetFocus(FALSE);  // disable focus and caputure if we are disabeling the object                                        
        SendMessageToCtl(pObj, WM_KILLFOCUS, (WPARAM) m_hWnd, lParam, bHandled, lRes, false);

        ATLTRACE2(atlTraceUser, 31, TEXT("Sending WM_KILLFOCUS to %ls \n"), pObj->GetID());
    }/* end of if statement */

    return(hr);
}/* end of function SetObjectFocus */

/*************************************************************************/
/* Function: FindObject                                                  */
/* Description: Itterates the objects till it finds the one with matching*/
/* ID.                                                                   */
/*************************************************************************/
HRESULT CMFBar::FindObject(BSTR strObjectID, CHostedObject** ppObj){

    HRESULT hr = E_FAIL; // did not find the object
    *ppObj = NULL;

    for(CNTOBJ::iterator i = m_cntObj.begin(); i!= m_cntObj.end(); i++){

        CHostedObject* pObj = (*i);
        
        if(NULL == pObj){

            continue;
        }/* end of if statement */
        
        if(!_wcsicmp(pObj->GetID(), strObjectID)){

            *ppObj = pObj; // set the pointer and bail out            
            hr = S_OK;
            break; // got the unknown get out
        }/* end of if statement */
    }/* end of for loop */

    return(hr);
}/* end of function FindObject */

/*************************************************************************/
/* End of file: MFBar.cpp                                                */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\msmfimg.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFImg.h                                                       */
/* Description: Declaration of CMSMFImg                                  */
/* Author: David Janecek                                                 */
/*************************************************************************/
#ifndef __MSMFIMG_H_
#define __MSMFIMG_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include "CstUtils.h"
#include "CBitmap.h"


/////////////////////////////////////////////////////////////////////////////
// CMSMFImg
class ATL_NO_VTABLE CMSMFImg : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CStockPropImpl<CMSMFImg, IMSMFImg, &IID_IMSMFImg, &LIBID_MSMFCNTLib>,
	public CComControl<CMSMFImg>,
	public IPersistStreamInitImpl<CMSMFImg>,
	public IOleControlImpl<CMSMFImg>,
	public IOleObjectImpl<CMSMFImg>,
	public IOleInPlaceActiveObjectImpl<CMSMFImg>,
	public IViewObjectExImpl<CMSMFImg>,
	public IOleInPlaceObjectWindowlessImpl<CMSMFImg>,
	public IPersistStorageImpl<CMSMFImg>,
	public ISpecifyPropertyPagesImpl<CMSMFImg>,
	public IQuickActivateImpl<CMSMFImg>,
	public IDataObjectImpl<CMSMFImg>,
    public IPersistPropertyBagImpl<CMSMFImg>,
	public IProvideClassInfo2Impl<&CLSID_MSMFImg, NULL, &LIBID_MSMFCNTLib>,
	public CComCoClass<CMSMFImg, &CLSID_MSMFImg>,
    public CMSMFCntrlUtils<CMSMFImg> // custom utilities we share across controls

{
public:
	CMSMFImg();
	~CMSMFImg();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMFIMG)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSMFImg)
	COM_INTERFACE_ENTRY(IMSMFImg)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IPersist, IPersistPropertyBag)
	COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_PROP_MAP(CMSMFImg)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
    PROP_ENTRY("Windowless", 3, CLSID_NULL)
    PROP_ENTRY("TransparentBlitType", 4, CLSID_NULL)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CMSMFImg)
    CHAIN_MSG_MAP(CMSMFCntrlUtils<CMSMFImg>)
	CHAIN_MSG_MAP(CComControl<CMSMFImg>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    HRESULT OnDraw(ATL_DRAWINFO& di);
    USE_MF_OVERWRITES
    USE_MF_CLASSSTYLE  // used to overwrite default class, so we avoid flickers

    

// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IMSMFImg
public:
    USE_MF_RESOURCEDLL
    USE_MF_TRANSPARENT_FLAG
	STDMETHOD(get_Image)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Image)(/*[in]*/ BSTR newVal);
    USE_MF_WINDOWLESS_ACTIVATION	
    OLE_COLOR m_clrBackColor;

protected: // member variables
    CBitmap* m_pBackBitmap;
    CComBSTR m_bstrBackFilename;

protected: 
    void Init();
    HRESULT PutImage(BSTR strFilename);
};

#endif //__MSMFIMG_H_
/*************************************************************************/
/* End of file: MSMFImg.h                                                */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\msmfsldr.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFSldr.cpp                                                    */
/* Description: Implementation of CMSMFSldr                              */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "MSMFCnt.h"
#include "MSMFSldr.h"

#define RECTWIDTH(lpRect)     ((lpRect)->right - (lpRect)->left)
#define RECTHEIGHT(lpRect)    ((lpRect)->bottom - (lpRect)->top)

/////////////////////////////////////////////////////////////////////////////
// CMSMFSldr

/*************************************************************************/
/* Function:  CMSMFSldr                                                  */
/*************************************************************************/
CMSMFSldr::CMSMFSldr(){

    Init();    
    for(INT i = 0; i < cgMaxSldrStates; i++){        

	    m_pThumbBitmap[i] = new CBitmap;
        m_pBackBitmap[i] = new CBitmap;
    }/* end of for loop */

}/* end of function CMSMFSldr */

/*************************************************************************/
/* Function: Init                                                        */
/* Description: Initializes variable states.                             */
/*************************************************************************/
void CMSMFSldr::Init(){

    m_nEntry = SldrState::Static;
    m_fValue =0.2f;
    m_fMin =0;
    m_fMax = 100;
    m_lXOffset = 5; 
    m_lYOffset = 2;
    m_fKeyIncrement = 4.0f;
    m_fKeyDecrement = 2.0f;
    m_lThumbWidth = 8;
    m_clrBackColor = ::GetSysColor(COLOR_BTNFACE);
    
    ::ZeroMemory(&m_rcThumb, sizeof(RECT));
}/* end of function Init */

/*************************************************************************/
/* Function:  ~CMSMFSldr                                                 */
/* Description: Cleanup the stuff we allocated here rest will be done    */
/* in the button destructor.                                             */
/*************************************************************************/
CMSMFSldr::~CMSMFSldr(){

    for(INT i = 0; i < cgMaxSldrStates; i++){        

	    delete m_pThumbBitmap[i];
        delete m_pBackBitmap[i];
        m_pBackBitmap[i] = NULL;
        m_pThumbBitmap[i] = NULL;
    }/* end of for loop */

    Init();    
}/* end of function CMSMFSldr */

/*************************************************************************/
/* Function: OnDraw                                                      */
/* Description: Does the basic drawing                                   */
/* First draws the background the the thumb at the specific position.    */
/*************************************************************************/
HRESULT CMSMFSldr::OnDraw(ATL_DRAWINFO& di){

    HRESULT hr = S_OK;

    BOOL bRet = TRUE;
    HDC hdc = di.hdcDraw;
    RECT rcClient = *(RECT*)di.prcBounds;

    // DRAW THE BACKGROUND
    if (::IsWindow(m_hWnd) && m_blitType != DISABLE) {

            
            // TODO: Optimaze palette handling
#if 0
            HPALETTE hNewPal = m_pBitmap[m_nEntry]->GetPal();

            if(hNewPal){

                HPALETTE hPal = ::SelectPalette(di.hdcDraw, hNewPal, TRUE);
                ::RealizePalette(di.hdcDraw);
            }/* end of if statement */
#endif
            
            COLORREF clr;
            HPALETTE hNewPal = m_pBackBitmap[m_nEntry]->GetPal();
            ::OleTranslateColor (m_clrBackColor, hNewPal, &clr);        
            
            // fill background of specific color
            HBRUSH hbrBack = ::CreateSolidBrush(clr);            
            //::FillRect(hdc, &rcClient, hbrBack);
            ::FillRect(di.hdcDraw, (LPRECT)di.prcBounds, hbrBack);
            ::DeleteObject(hbrBack);
    }/* end of if statement */

    if (m_pBackBitmap[m_nEntry]){

        bRet = m_pBackBitmap[m_nEntry]->PaintTransparentDIB(hdc, NULL, 
            &rcClient, m_blitType);
    } 
    else {

        COLORREF clr;
        ::OleTranslateColor (m_clrBackColor, m_pBackBitmap[m_nEntry]->GetPal(), &clr); 

        HBRUSH hbrBack = ::CreateSolidBrush(clr);                        
        ::FillRect(hdc, &rcClient, hbrBack);
        ::DeleteObject(hbrBack);
    }/* end of if statement */

    // DRAW THE THUMB
#if 0 // just for debugging purposes
    COLORREF clr = RGB(0xff, 0, 0);
    
    HBRUSH hbrBack = ::CreateSolidBrush(clr);                        
    ::FillRect(hdc, &m_rcThumb, hbrBack);
    ::DeleteObject(hbrBack);
#endif

    if (m_pBackBitmap[m_nEntry]){

            RECT rcThumb = m_rcThumb;

            if(!m_bWndLess){

                 ATLASSERT(::IsWindow(m_hWnd));

                 ::OffsetRect(&rcThumb, -m_rcPos.left, -m_rcPos.top);        
            }/* end of if statement */            

        bRet = m_pThumbBitmap[m_nEntry]->PaintTransparentDIB(hdc, NULL, 
            &rcThumb, m_blitType);
    } /* end of if statement */
        
    hr = GetFocus();

    // THIS ASSUMES WE ARE REPAINTING THE WHOLE CONTROL
    // WHICH IS WHAT ATL AT THIS INCARNATION DOES
    if(S_OK == hr){

        ::DrawFocusRect(hdc, &rcClient);
    }/* end of if statement */

    if(!bRet){

        hr = E_UNEXPECTED;
    }/* end of if statement */
    	
	return (hr);
}/* end of function OnDraw */

/*************************************************************************/
/* Function: OnSize                                                      */
/* Description: Handles the onsize message if we are self contained.     */
/*************************************************************************/
LRESULT CMSMFSldr::OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){
    
    bHandled = true;

    RecalculateTumbPos();

    //ATLASSERT(FALSE); // move the code from SetObjectRects in here  

    return 0;
}/* end of function OnSize */

/*************************************************************************/
/* Function: OnSetFocus                                                  */
/* Description: If we are in disabled state SetFocus(false)              */
/*************************************************************************/
LRESULT CMSMFSldr::OnSetFocus(UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_nEntry == SldrState::Disabled){

        if(GetFocus() == S_OK){

            SetFocus(false);
        }/* end of if statement */

         FireViewChange();
        return(-1);
    }/* end of if statement */

    FireViewChange();
    return 0;
}/* end of function OnSetFocus */

/*************************************************************************/
/* Function: OnKillFocus                                                 */
/* Description: If we are in disabled state SetFocus(false)              */
/*************************************************************************/
LRESULT CMSMFSldr::OnKillFocus(UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    FireViewChange();
    return 0;
}/* end of function OnKillFocus */

/*************************************************************************/
/* Function: OnButtonDown                                                */
/* Description: Handles when buttons is selected. Captures the mouse     */
/* movents (supported for windowless, via interfaces).                   */
/*************************************************************************/
LRESULT CMSMFSldr::OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_nEntry == SldrState::Disabled){
        
        return 0;
    }/* end of if statement */

    LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    if(PtOnSlider(xPos, yPos)){        

        if(SldrState::Hover !=  m_nEntry){
            // in hover case we already have captured the mouse, so do not do
            // that again
            SetCapture(true); // capture the mouse messages
        }/* end of if statement */

        OffsetX(xPos);	    
        SetThumbPos(xPos);
        SetSliderState(SldrState::Push);
    }/* end of if statement */

    Fire_OnMouseDown();

	return 0;
}/* end of function OnButtonDown */

/*************************************************************************/
/* Function: OnButtonUp                                                  */
/* Description: Releases the capture, updates the button visual state,   */
/* and if release on the buttons image fire the event.                   */
/*************************************************************************/
LRESULT CMSMFSldr::OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    LONG lRes = 0;

    if (m_nEntry == SldrState::Disabled){

        ForwardWindowMessage(WM_USER_FOCUS, (WPARAM) m_hWnd, 0, lRes);
        
        return lRes;
    }/* end of if statement */


    LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    bool bOnButtonImage = PtOnSlider(xPos, yPos);
    bool bFire = (m_nEntry == SldrState::Push);
	
    if(bOnButtonImage){

        SetSliderState(SldrState::Static); //change to static even 
        SetCapture(false); // release the capture of the mouse messages
    }
    else {

        SetSliderState(SldrState::Static);
        // do it only when we do not hower, if we hower, then keep the capture
        SetCapture(false); // release the capture of the mouse messages
    }/* end of if statement */

    if (bFire){

        if(bOnButtonImage){

            OffsetX(xPos);
            SetThumbPos(xPos);
            Fire_OnClick();            
        }/* end of if statement */
    }/* end of if statement */

    Fire_OnMouseUp();

	 ForwardWindowMessage(WM_USER_FOCUS, (WPARAM) m_hWnd, 0, lRes);

	return lRes;
}/* end of function OnButtonUp */

/*************************************************************************/
/* Function: OnMouseMove                                                 */
/* Description: Check if we were captured/pushed the do not do much,     */
/* otherwise do the hit detection and see if we are in static or hower   */
/* state.                                                                */
/*************************************************************************/
LRESULT CMSMFSldr::OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_nEntry == SldrState::Disabled)
        return 0;

	LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    bool fPointOnSlider = PtOnSlider(xPos, yPos);

    if (m_nEntry != SldrState::Push){    
    
        if(fPointOnSlider){
            if(SldrState::Hover != m_nEntry || S_OK != GetCapture()){

                SetCapture(true); // capture the mouse messages
		        SetSliderState(SldrState::Hover);
            }/* end of if statement */
        }
        else {

            if(SldrState::Static != m_nEntry){

                SetCapture(false); // release the capture of the mouse messages
		        SetSliderState(SldrState::Static);
            }/* end of if statement */
        }/* end of if statement */
    }
    else {
        if(fPointOnSlider){

            OffsetX(xPos);
            SetThumbPos(xPos);
            FireViewChange();
        }/* end of if statement */
	}/* end of if statement */

	return 0;
}/* end of function OnMouseMove */

/*************************************************************************/
/* Function: OnKeyDown                                                   */
/* Description: Depresses the button.                                    */
/*************************************************************************/
LRESULT CMSMFSldr::OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                             BOOL& bHandled){

    bHandled = FALSE;
    LONG lRes = 0;

    switch(wParam){

        case VK_RETURN:
        case VK_SPACE: 
        case VK_LEFT:
        case VK_RIGHT:

            SetSliderState(SldrState::Push);

            break;
    }/* end of if statement */    
    return(lRes);
}/* end of function OnKeyDown */

/*************************************************************************/
/* Function: OnKeyUp                                                     */
/* Description: Distrubutes the keyboard messages properly.              */
/*************************************************************************/
LRESULT CMSMFSldr::OnKeyUp(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                             BOOL& bHandled){

    bHandled = FALSE;
    LONG lRes = 0;

    LONG xPos = m_rcThumb.left + m_lThumbWidth /2;

    switch(wParam){

        case VK_RETURN:
        case VK_SPACE: 
            break;

        case VK_LEFT: m_fValue -= m_fKeyDecrement; FitValue();
             break;

        case VK_RIGHT: m_fValue += m_fKeyIncrement; FitValue();
            break;
    }/* end of switch statement */

    RecalculateTumbPos();

    Fire_OnClick(); // we clicked on it, it does not meen
    // we did change the value of it

    SetSliderState(SldrState::Static);

    return(lRes);
}/* end of function OnKeyUp */

/*************************************************************/
/* Function: FitValue                                        */
/* Description: Fits the xVal inside the params.             */
/*************************************************************/
HRESULT CMSMFSldr::FitValue(){

    if(m_fValue < m_fMin){

        m_fValue = m_fMin;    
    }/* end of if statement */

    if(m_fValue > m_fMax){

        m_fValue = m_fMax;            
    }/* end of if statement */

    return(S_OK);
}/* end of function FitValue */

/*************************************************************/
/* Name: SetObjectRects                                      */
/* Description: Update thumbnail rect object is being moved  */
/*************************************************************/
STDMETHODIMP CMSMFSldr::SetObjectRects(LPCRECT prcPos,LPCRECT prcClip){
    // Call the default method first
    IOleInPlaceObjectWindowlessImpl<CMSMFSldr>::SetObjectRects(prcPos, prcClip);
  
    RecalculateTumbPos();
    
    return S_OK;
}/* end of function SetObjectRects */

/*************************************************************************/
/* Function: PutThumbImage                                               */
/* Description: Sets the image to thumb.                                 */
/*************************************************************************/
HRESULT CMSMFSldr::PutThumbImage(BSTR strFilename, int nEntry){

    HRESULT hr = S_OK;

    m_bstrThumbFilename[nEntry] = strFilename;

    // figure out if we need to gray out the image

    bool fGrayOut = false;

    if(SldrState::Disabled == nEntry){

        fGrayOut = gcfGrayOut; 
    }/* end of if statement */

    hr = m_pThumbBitmap[nEntry]->PutImage(strFilename, m_hRes, GetUnknown(),fGrayOut ,m_blitType);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    if(nEntry == m_nEntry ){
        // we are updating image that is being used, refresh it
        ATLTRACE2(atlTraceWindowing, 20, TEXT("Redrawing the image\n"));
        InvalidateRgn(); // our helper function            
    }/* end of if statement */

    return(hr);
}/* end of function PutThumbImage */

/*************************************************************************/
/* Function: PutBackImage                                               */
/* Description: Sets the image to Back.                                 */
/*************************************************************************/
HRESULT CMSMFSldr::PutBackImage(BSTR strFilename, int nEntry){

    HRESULT hr = S_OK;

    m_bstrBackFilename[nEntry] = strFilename;

    bool fGrayOut = false;

    if(SldrState::Disabled == nEntry){

        fGrayOut = gcfGrayOut; // TODO some more complex stuff if we get custom disable
                          // images                            
    }/* end of if statement */

    hr = m_pBackBitmap[nEntry]->PutImage(strFilename, m_hRes, GetUnknown(),fGrayOut ,m_blitType);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    if(nEntry == m_nEntry ){
        // we are updating image that is being used, refresh it
        ATLTRACE2(atlTraceWindowing, 20, TEXT("Redrawing the image\n"));
        InvalidateRgn(); // our helper function            
    }/* end of if statement */

    return(hr);
}/* end of function PutBackImage */

/*************************************************************************/
/* Function: get_Value                                                   */
/* Description: Get the current value.                                   */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_Value(float *pVal){

	*pVal = m_fValue;

	return S_OK;
}/* end of function get_Value */

/*************************************************************************/
/* Function: put_Value                                                   */
/* Description: Sets the current value                                   */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_Value(float newVal){

	HRESULT hr = S_OK;

    if(newVal < m_fMin || newVal > m_fMax){

        hr = E_INVALIDARG;
        return (hr);
    }/* end of if statement */

    if(newVal == m_fValue){

        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    m_fValue = newVal;

    RecalculateTumbPos(); // apply the new position to the tumb rect and invalidate

	return (hr);
}/* end of function put_Value */

/*************************************************************************/
/* Function: get_Min                                                     */
/* Description: Gets the minimum value on which the rect should expand   */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_Min(float *pVal){

	*pVal = m_fMin;
	return S_OK;
}/* end of function get_Min */

/*************************************************************************/
/* Function: put_Max                                                     */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_Min(float newVal){

	HRESULT hr = S_OK;

	m_fMin = newVal;    
    hr = RecalculateTumbPos(); // apply the new position to the tumb rect and invalidate

    //ATLASSERT(SUCCEEDED(hr));

	return (S_OK);
}/* end of function put_Min */

/*************************************************************************/
/* Function: get_Max                                                     */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_Max(float *pVal){

	*pVal = m_fMax;
	return S_OK;
}/* end of function get_Max */

/*************************************************************************/
/* Function: put_Max                                                     */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_Max(float newVal){

    HRESULT hr = S_OK;

	m_fMax = newVal;    
    hr = RecalculateTumbPos(); // apply the new position to the tumb rect and invalidate

    //ATLASSERT(SUCCEEDED(hr));

	return (S_OK);
}/* end of function put_Max */

/*************************************************************************/
/* Function: get_XOffset                                                 */
/* Descriptoin: The part we do not draw on, end of the rail..            */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_XOffset(LONG *pVal){

	*pVal = m_lXOffset;
	return S_OK;
}/* end of function get_XOffset */

/*************************************************************************/
/* Function: put_XOffset                                                 */
/* Description: Adjust it, cache our new FLOAT offset and recalculate    */
/* the position.                                                         */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_XOffset(LONG newVal){

    HRESULT hr = S_OK;

	m_lXOffset = newVal;    

    hr = RecalculateTumbPos(); // apply the new position to the tumb rect and invalidate

    //ATLASSERT(SUCCEEDED(hr));

	return (S_OK);
}/* end of function put_XOffset */

/*************************************************************************/
/* Function: get_Offset                                                  */
/* Descriptoin: The part we do not draw on, end of the rail..            */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_YOffset(LONG *pVal){

	*pVal = m_lYOffset;
	return S_OK;
}/* end of function get_YOffset */

/*************************************************************************/
/* Function: put_YOffset                                                 */
/* Description: Adjust it, cache our new FLOAT offset and recalculate    */
/* the position.                                                         */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_YOffset(LONG newVal){

    HRESULT hr = S_OK;

	m_lYOffset = newVal;    

    m_rcThumb.top = m_rcPos.top - m_lYOffset;
    m_rcThumb.bottom = m_rcPos.bottom - m_lYOffset;

    FireViewChange();

	return (hr);
}/* end of function put_YOffset */

/*************************************************************************/
/* Function: get_ThumbWidth                                              */
/* Descriptoin: Width of the thumb.                                      */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_ThumbWidth(LONG *pVal){

	*pVal = m_lThumbWidth;
	return S_OK;
}/* end of function get_YOffset */

/*************************************************************************/
/* Function: put_ThumbWidth                                              */
/* Description: Sets the thumb width.                                    */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_ThumbWidth(LONG newVal){

    HRESULT hr = S_OK;

	m_lThumbWidth = newVal;    

    RecalculateTumbPos();

	return (S_OK);
}/* end of function put_YOffset */

/*************************************************************************/
/* Function: get_ThumbStatic                                             */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_ThumbStatic(BSTR *pstrFilename){

	*pstrFilename = m_bstrThumbFilename[SldrState::Static].Copy();
	return S_OK;
}/* end of function get_ThumbStatic */

/*************************************************************************/
/* Function: put_ThumbStatic                                             */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_ThumbStatic(BSTR strFilename){

    if (!m_bstrThumbFilename[SldrState::Disabled]){

        PutThumbImage(strFilename, SldrState::Disabled);
    }/* end of if statement */

	return (PutThumbImage(strFilename, SldrState::Static));
}/* end of function put_ThumbStatic */

/*************************************************************************/
/* Function: get_ThumbHover                                              */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_ThumbHover(BSTR *pstrFilename){

	*pstrFilename = m_bstrThumbFilename[SldrState::Hover].Copy(); 

	return S_OK;
}/* end of function get_ThumbHover */

/*************************************************************************/
/* Function: put_ThumbHover                                              */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_ThumbHover(BSTR strFilename){

	return (PutThumbImage(strFilename, SldrState::Hover));
}/* end of function put_ThumbHover */

/*************************************************************************/
/* Function: get_ThumbPush                                               */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_ThumbPush(BSTR *pstrFilename){

	*pstrFilename = m_bstrThumbFilename[SldrState::Push].Copy();    
    return S_OK;
}/* end of function get_ThumbPush */

/*************************************************************************/
/* Function: put_ThumbPush                                               */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_ThumbPush(BSTR strFilename){

    return (PutThumbImage(strFilename, SldrState::Push));
}/* end of function put_ThumbPush */

/*************************************************************************/
/* Function: get_ThumbDisabled                                           */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_ThumbDisabled(BSTR *pstrFilename){

	*pstrFilename = m_bstrThumbFilename[SldrState::Disabled].Copy();    
    return S_OK;
}/* end of function get_ThumbDisabled */

/*************************************************************************/
/* Function: put_ThumbDisabled                                           */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_ThumbDisabled(BSTR strFilename){

    return (PutThumbImage(strFilename, SldrState::Disabled));
}/* end of function put_ThumbDisabled */

/*************************************************************************/
/* Function: get_ThumbActive                                             */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_ThumbActive(BSTR *pstrFilename){

    *pstrFilename = m_bstrThumbFilename[SldrState::Active].Copy();    
    return S_OK;
}/* end of function get_ThumbActive */

/*************************************************************************/
/* Function: put_ThumbActive                                             */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_ThumbActive(BSTR strFilename){

    return (PutThumbImage(strFilename, SldrState::Active));
}/* end of function put_ThumbActive */


/*************************************************************************/
/* Function: get_BackStatic                                              */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_BackStatic(BSTR *pstrFilename){

	*pstrFilename = m_bstrBackFilename[SldrState::Static].Copy();
	return S_OK;
}/* end of function get_BackStatic */

/*************************************************************************/
/* Function: put_BackStatic                                              */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_BackStatic(BSTR strFilename){

    if (!m_bstrBackFilename[SldrState::Disabled]){

        PutBackImage(strFilename, SldrState::Disabled);
    }/* end of if statement */

	return (PutBackImage(strFilename, SldrState::Static));
}/* end of function put_BackStatic */

/*************************************************************************/
/* Function: get_BackHover                                              */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_BackHover(BSTR *pstrFilename){

	*pstrFilename = m_bstrBackFilename[SldrState::Hover].Copy(); 

	return S_OK;
}/* end of function get_BackHover */

/*************************************************************************/
/* Function: put_BackHover                                               */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_BackHover(BSTR strFilename){

	return (PutBackImage(strFilename, SldrState::Hover));
}/* end of function put_BackHover */

/*************************************************************************/
/* Function: get_BackPush                                                */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_BackPush(BSTR *pstrFilename){

	*pstrFilename = m_bstrBackFilename[SldrState::Push].Copy();    
    return S_OK;
}/* end of function get_BackPush */

/*************************************************************************/
/* Function: put_BackPush                                                */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_BackPush(BSTR strFilename){

    return (PutBackImage(strFilename, SldrState::Push));
}/* end of function put_BackPush */

/*************************************************************************/
/* Function: get_BackDisabled                                            */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_BackDisabled(BSTR *pstrFilename){

	*pstrFilename = m_bstrBackFilename[SldrState::Disabled].Copy();    
    return S_OK;
}/* end of function get_BackDisabled */

/*************************************************************************/
/* Function: put_BackDisabled                                            */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_BackDisabled(BSTR strFilename){

    return (PutBackImage(strFilename, SldrState::Disabled));
}/* end of function put_BackDisabled */

/*************************************************************************/
/* Function: get_BackActive                                              */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_BackActive(BSTR *pstrFilename){

    *pstrFilename = m_bstrBackFilename[SldrState::Active].Copy();    
    return S_OK;
}/* end of function get_BackActive */

/*************************************************************************/
/* Function: put_BackActive                                              */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_BackActive(BSTR strFilename){

    return (PutBackImage(strFilename, SldrState::Active));
}/* end of function put_BackActive */

/*************************************************************/
/* Function: get_SldrState                                   */
/* Description: Gets current slider state.                   */
/*************************************************************/
STDMETHODIMP CMSMFSldr::get_SldrState(long *pVal){

	*pVal =  (long) m_nEntry;
	return S_OK;
}/* end of function get_SldrState */

/*************************************************************************/
/* Function: put_SldrState                                               */
/* Description: Sets slider state.                                       */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_SldrState(long newVal){

	HRESULT hr = SetSliderState((SldrState)newVal);
	return (hr);
}/* end of function put_SldrState */

/*************************************************************/
/* Function: get_Disable                                     */
/* Description: Returns OLE-BOOL if disabled or enabled.     */
/*************************************************************/
STDMETHODIMP CMSMFSldr::get_Disable(VARIANT_BOOL *pVal){

    *pVal =  SldrState::Disabled == m_nEntry ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}/* end of function get_Disable */

/*************************************************************/
/* Function: put_Disable                                     */
/* Description: Disable or enable the buttons (disabled      */
/* are greyed out and do not except mouse clicks).           */
/*************************************************************/
STDMETHODIMP CMSMFSldr::put_Disable(VARIANT_BOOL newVal){

    SldrState  sldrSt =  VARIANT_FALSE == newVal ? SldrState::Static : SldrState::Disabled;	
    HRESULT hr = SetSliderState(sldrSt);

	return (hr);
}/* end of function put_Disable */

/*************************************************************************/
/* HELPER Functions                                                      */
/*************************************************************************/

/*************************************************************************/
/* Function: RecalculateTumbPos                                          */
/* Description: Centers the rect around x value.                         */
/* This one calculate the thumb rectangle x position.                    */
/*************************************************************************/
HRESULT CMSMFSldr::RecalculateTumbPos(){

    HRESULT hr = S_OK;

    // offset the rect depending on the y value
    m_rcThumb.top = m_rcPos.top + m_lYOffset;
    m_rcThumb.bottom = m_rcPos.bottom - m_lYOffset;

    // just offset x coordibate of the thumb the rect depening on the new xValue
    // calculate the length
    FLOAT flLengthU = m_fMax - m_fMin; // length in units
    FLOAT flLengthR = (FLOAT)RECTWIDTH(&m_rcPos) - 2* m_lXOffset;

    // calcalate the center of the thumb in RECT coordinates
    FLOAT fPos = (m_fValue - m_fMin) * flLengthR /  flLengthU;
    // fPos is at the center of the thumb
    
    LONG lThumbWidthHalf =  m_lThumbWidth/2;

    LONG lPos = (INT)fPos + m_lXOffset + m_rcPos.left;

    if(lPos < (m_rcPos.left + lThumbWidthHalf) || lPos > (m_rcPos.right - lThumbWidthHalf)){

        // we are of the rectangle
        hr = E_FAIL;
        return(hr);
    }/* end of if statement */

    LONG lOldPos = m_rcThumb.left + lThumbWidthHalf;

    if(lOldPos == lPos){

        // thumb is in the same position as before so lets not bother with it
        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    m_rcThumb.left = lPos - lThumbWidthHalf;
    m_rcThumb.right = lPos + lThumbWidthHalf;    

    FireViewChange();

    return(hr);
}/* end of function RecalculateTumbPos */

/*************************************************************************/
/* Function: RecalculateValue                                            */
/* Description: Recalculates the slider value, since the thumb rect has  */
/* changed.                                                              */
/*************************************************************************/
HRESULT CMSMFSldr::RecalculateValue(){

    HRESULT hr = S_OK;

    // calculate the length
    FLOAT flLengthU = m_fMax - m_fMin; // length in units
    FLOAT flLengthR = (FLOAT)RECTWIDTH(&m_rcPos) - 2* m_lXOffset;

    LONG lThumbXPos = m_rcThumb.left + m_lThumbWidth/2;    
    lThumbXPos -= m_rcPos.left + m_lXOffset; // shift it over to 0 origin at left offset

    // calcalate the center of the thumb in VALUE coordinates
    FLOAT fPos = m_fMin + (lThumbXPos) * flLengthU / flLengthR;
    // fPos is at the center of the thumb
        
    if(fPos < (m_fMin) || fPos > (m_fMax)){

        // we are of the rectangle
        hr = E_FAIL;
        return(hr);
    }/* end of if statement */

    m_fValue = fPos;

    // Fire Event that we have changed our value

    return(hr);
}/* end of function RecalculateValue */

/*************************************************************************/
/* Function: SetSliderState                                              */
/* Description: Sets the button states forces redraw.                    */
/*************************************************************************/
HRESULT CMSMFSldr::SetSliderState(SldrState sldrState){

    HRESULT hr = S_OK;

    bool fRedraw = false;
    
    if(sldrState != m_nEntry ){

        fRedraw = true;
    }/* end of if statement */

    m_nEntry = sldrState;    
    
    if(fRedraw){

        if (m_nEntry == SldrState::Disabled){
            
            SetFocus(false); // disable the focus
            SetCapture(false);
        }/* end of if statement */

        // we are updating image that is being used, refresh it
        ATLTRACE2(atlTraceWindowing, 20, TEXT("Redrawing the image\n"));
	    FireViewChange(); // update the display
        //InvalidateRgn(); // our helper function            
    }/* end of if statement */

    return(hr);
}/* end of function SetSliderState */

/*************************************************************************/
/* Function: PtOnSlider                                                  */
/* Description: Uses helper to do the same.                              */
/*************************************************************************/
bool CMSMFSldr::PtOnSlider(LONG x, LONG y){

    POINT pos = {x, y};
    return(PtOnSlider(pos));
}/* end of function PtOnSlider */

/*************************************************************************/
/* Function: PtOnSlider                                                  */
/* Description: Determines if the point is located on the slider.        */
/* TODO: Needs to be modified when we will handle transparent color.     */
/*************************************************************************/
bool CMSMFSldr::PtOnSlider(POINT pos){

    RECT rc;
    bool bRet = false;

    if(m_bWndLess){

        rc = m_rcPos;
    } 
    else {

        if(!::IsWindow(m_hWnd)){

            return(bRet);
        }/* end of if statement */

        ::GetClientRect(m_hWnd, &rc);
    }/* end of if statement */

    bRet = PtInRect(&rc, pos) ? true : false;    

    //TODO: Add also if we are on bitmap itsels possibly

#ifdef _DEBUG
if(bRet)
    ATLTRACE2(atlTraceWindowing, 20, TEXT("Point x = %d y = %d in Rect left = %d top %d right %d bottom %d\n"), 
        pos.x, pos.y, m_rcPos.left, m_rcPos.top, m_rcPos.right, m_rcPos.bottom);
else
    ATLTRACE2(atlTraceWindowing, 20, TEXT("Point x = %d y = %d NOT ON RECT Rect left = %d top %d right %d bottom %d\n"), 
        pos.x, pos.y, m_rcPos.left, m_rcPos.top, m_rcPos.right, m_rcPos.bottom);
#endif

    return(bRet);
}/* end of function PtOnSlider */

/*************************************************************************/
/* Function: PtOnThumb                                                   */
/* Description: Uses helper to do the same.                              */
/*************************************************************************/
bool CMSMFSldr::PtOnThumb(LONG x, LONG y){

    POINT pos = {x, y};
    return(PtOnThumb(pos));
}/* end of function PtOnThumb */

/*************************************************************************/
/* Function: PtOnThumb                                                  */
/* Description: Determines if the point is located on the slider.        */
/* TODO: Needs to be modified when we will handle transparent color.     */
/*************************************************************************/
bool CMSMFSldr::PtOnThumb(POINT pos){

    RECT rc;
    bool bRet = false;

    if(m_bWndLess){

        rc = m_rcPos;
    } 
    else {

        if(!::IsWindow(m_hWnd)){

            return(bRet);
        }/* end of if statement */

        ::GetClientRect(m_hWnd, &rc);
    }/* end of if statement */

    bRet = PtInRect(&rc, pos) ? true : false;    

    return(bRet);
}/* end of function PtOnThumb */

/*************************************************************************/
/* Function: OffsetX                                                     */
/* Description: Adjusts the x position for windows case when we are 0,0  */
/* based.                                                                */
/*************************************************************************/
HRESULT CMSMFSldr::OffsetX(LONG& xPos){

    HRESULT hr = S_OK;

    if(m_bWndLess){

        return(hr);
    }/* end of if statement */

    ATLASSERT(::IsWindow(m_hWnd));

    xPos = m_rcPos.left + xPos;
    
    return(hr);
}/* end of function OffsetX */

/*************************************************************************/
/* Function: SetThumbPos                                                 */
/* Description: Sets the thumb position.                                 */
/*************************************************************************/
HRESULT CMSMFSldr::SetThumbPos(LONG xPos){

    HRESULT hr = S_FALSE;

    //MOVE THE THUMB TO THIS X POSITION        
    long ThumbWidthHalf = m_lThumbWidth /2;

    // see if the positions are the same
    if(m_rcThumb.left + ThumbWidthHalf != xPos){

        // see if we are with offset regions
        if((xPos > (m_rcPos.left  + m_lXOffset)) && 
           (xPos < (m_rcPos.right - m_lXOffset))){

            m_rcThumb.left = xPos - ThumbWidthHalf;
            m_rcThumb.right = xPos + ThumbWidthHalf;
            hr = RecalculateValue();

            if(SUCCEEDED(hr)){

                Fire_OnValueChange(m_fValue); // fire to the container that we are chaning the value
            }/* end of if statement */            
        }
        else {

            hr = E_FAIL; // not in the offset any more
        }/* end of if statement*/
    }/* end of if statement */

    return(hr);
}/* end of function SetThumbPos */

/*************************************************************************/
/* Function: get_ArrowKeyIncrement                                       */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_ArrowKeyIncrement(FLOAT *pVal){

    *pVal = m_fKeyIncrement;
	return S_OK;
}/* end of function get_ArrowKeyIncrement */

/*************************************************************************/
/* Function: put_ArrowKeyIncrement                                       */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_ArrowKeyIncrement(FLOAT newVal){

	m_fKeyIncrement = newVal;
	return S_OK;
}/* end of function put_ArrowKeyIncrement */

/*************************************************************************/
/* Function: get_ArrowKeyDecrement                                       */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::get_ArrowKeyDecrement(float *pVal){

	*pVal = m_fKeyDecrement;
	return S_OK;
}/* end of function get_ArrowKeyDecrement */

/*************************************************************************/
/* Function: put_ArrowKeyDecrement                                       */
/*************************************************************************/
STDMETHODIMP CMSMFSldr::put_ArrowKeyDecrement(float newVal){
	
    m_fKeyDecrement = newVal;
	return S_OK;
}/* end of function put_ArrowKeyDecrement */

/*************************************************************************/
/* End of file: MSMFSldr.cpp                                             */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\msmfsldr.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFSldr.h                                                      */
/* Description: Declaration of MSMFSldr                                  */
/* Author: David Janecek                                                 */
/*************************************************************************/
#ifndef __MSMFSLDR_H_
#define __MSMFSLDR_H_

#include "resource.h"       // main symbols
#include "CBitmap.h"
#include <atlctl.h>
#include "CstUtils.h"
#include "MSMFCntCP.h"

/*************************************************************************/
/* Consts                                                                */
/*************************************************************************/
const int cgMaxSldrStates = 5; // the number of button states

/////////////////////////////////////////////////////////////////////////////
// CMSMFSldr
class ATL_NO_VTABLE CMSMFSldr : 
	public CComObjectRootEx<CComSingleThreadModel>,	
    public CStockPropImpl<CMSMFSldr, IMSMFSldr, &IID_IMSMFSldr, &LIBID_MSMFCNTLib>,
	public CComControl<CMSMFSldr>,
	public IPersistStreamInitImpl<CMSMFSldr>,
	public IOleControlImpl<CMSMFSldr>,
	public IOleObjectImpl<CMSMFSldr>,
	public IOleInPlaceActiveObjectImpl<CMSMFSldr>,
	public IViewObjectExImpl<CMSMFSldr>,
	public IOleInPlaceObjectWindowlessImpl<CMSMFSldr>,
	public IPersistStorageImpl<CMSMFSldr>,
	public ISpecifyPropertyPagesImpl<CMSMFSldr>,
	public IQuickActivateImpl<CMSMFSldr>,
	public IDataObjectImpl<CMSMFSldr>,	
	public CComCoClass<CMSMFSldr, &CLSID_MSMFSldr>,
    public IProvideClassInfo2Impl<&CLSID_MSMFSldr, &DIID__IMSMFSldr, &LIBID_MSMFCNTLib>,
    public IPersistPropertyBagImpl<CMSMFSldr>,
    public IConnectionPointContainerImpl<CMSMFSldr>,
    public CProxy_IMSMFSldr< CMSMFSldr>,
    public CMSMFCntrlUtils<CMSMFSldr> // custom utilities we share across controls
{
public:
    CMSMFSldr();
    virtual ~CMSMFSldr();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMFSLDR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSMFSldr)
	COM_INTERFACE_ENTRY(IMSMFSldr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IPersist, IPersistPropertyBag)
	COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSMFSldr)    
	CONNECTION_POINT_ENTRY(DIID__IMSMFSldr)	
END_CONNECTION_POINT_MAP()


BEGIN_PROP_MAP(CMSMFSldr)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
    PROP_ENTRY("ResourceDLL", 19, CLSID_NULL)
    PROP_ENTRY("Windowless", 20, CLSID_NULL)
    //PROP_ENTRY("TransparentBlitType", 4, CLSID_NULL)
	PROP_ENTRY("ThumbStatic",5, CLSID_NULL)
	PROP_ENTRY("ThumbHover", 6, CLSID_NULL)
	PROP_ENTRY("ThumbPush",  7, CLSID_NULL)
    PROP_ENTRY("ThumbDisabled",  8, CLSID_NULL)
    PROP_ENTRY("ThumbActive",  9, CLSID_NULL)
    PROP_ENTRY("BackStatic",10, CLSID_NULL)
	PROP_ENTRY("BackHover", 11, CLSID_NULL)
	PROP_ENTRY("BackPush",  12, CLSID_NULL)
    PROP_ENTRY("BackDisabled",  13, CLSID_NULL)
    PROP_ENTRY("BackActive",  14, CLSID_NULL)
    PROP_ENTRY("ThumbWidth",  4, CLSID_NULL)
    PROP_ENTRY("Min",  2, CLSID_NULL)
    PROP_ENTRY("Max",  3, CLSID_NULL)
    PROP_ENTRY("Value",  1, CLSID_NULL)
    PROP_ENTRY("XOffset",  17, CLSID_NULL)
    PROP_ENTRY("YOffset",  18, CLSID_NULL)
    
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CMSMFSldr)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_MOUSEMOVE,   OnMouseMove)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnButtonDown)
	MESSAGE_HANDLER(WM_LBUTTONUP,   OnButtonUp)
    MESSAGE_HANDLER(WM_KEYUP,  OnKeyUp)
    MESSAGE_HANDLER(WM_KEYDOWN,  OnKeyDown)
    MESSAGE_HANDLER(WM_SETFOCUS,    OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS,    OnKillFocus)    
    CHAIN_MSG_MAP(CMSMFCntrlUtils<CMSMFSldr>)
	CHAIN_MSG_MAP(CComControl<CMSMFSldr>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()

    LRESULT OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnSetFocus(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnKillFocus(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnKeyUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
    LRESULT OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);   
    
// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IMSMFSldr
// IMSMFSldr
public:
	STDMETHOD(get_Disable)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Disable)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_SldrState)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_SldrState)(/*[in]*/ long newVal);
	STDMETHOD(get_ThumbActive)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ThumbActive)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ThumbDisabled)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ThumbDisabled)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ThumbPush)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ThumbPush)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ThumbHover)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ThumbHover)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ThumbStatic)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ThumbStatic)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_BackActive)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_BackActive)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_BackDisabled)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_BackDisabled)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_BackPush)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_BackPush)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_BackHover)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_BackHover)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_BackStatic)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_BackStatic)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_XOffset)(/*[out, retval]*/ LONG *pVal);
	STDMETHOD(put_XOffset)(/*[in]*/ LONG newVal);
    STDMETHOD(get_YOffset)(/*[out, retval]*/ LONG *pVal);
	STDMETHOD(put_YOffset)(/*[in]*/ LONG newVal);	
    STDMETHOD(get_ThumbWidth)(/*[out, retval]*/ LONG *pVal);
	STDMETHOD(put_ThumbWidth)(/*[in]*/ LONG newVal);	
	STDMETHOD(get_Max)(/*[out, retval]*/ float *pVal);
	STDMETHOD(put_Max)(/*[in]*/ float newVal);
	STDMETHOD(get_Min)(/*[out, retval]*/ float *pVal);
	STDMETHOD(put_Min)(/*[in]*/ float newVal);
	STDMETHOD(get_Value)(/*[out, retval]*/ float *pVal);
	STDMETHOD(put_Value)(/*[in]*/ float newVal);
    USE_MF_RESOURCEDLL  // replaces the two lines below
    //STDMETHOD(get_ResourceDLL)(/*[out, retval]*/ BSTR *pVal);
	//STDMETHOD(put_ResourceDLL)(/*[in]*/ BSTR newVal);
    USE_MF_WINDOWLESS_ACTIVATION
    USE_MF_TRANSPARENT_FLAG

    HRESULT OnDraw(ATL_DRAWINFO& di);

    // IOleInPlaceObjectWindowlessImpl
	STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip);

    enum SldrState {Static = 0, Hover = 1, Push = 2, Disabled = 3, Active = 4};

    USE_MF_OVERWRITES
    USE_MF_CLASSSTYLE  // used to overwrite default class, so we avoid flickers


public: // member variable that have to be public due to ATL
	STDMETHOD(get_ArrowKeyDecrement)(/*[out, retval]*/ float *pVal);
	STDMETHOD(put_ArrowKeyDecrement)(/*[in]*/ float newVal);
	STDMETHOD(get_ArrowKeyIncrement)(/*[out, retval]*/ FLOAT *pVal);
	STDMETHOD(put_ArrowKeyIncrement)(/*[in]*/ FLOAT newVal);
    OLE_COLOR m_clrBackColor;   // stock property implemeted in the CStockPropImpl

private:
    FLOAT m_fValue;
    FLOAT m_fMin;
    FLOAT m_fMax;    
    LONG  m_lXOffset; 
    LONG  m_lYOffset; 
    LONG  m_lThumbWidth; 
    FLOAT m_fKeyIncrement;
    FLOAT m_fKeyDecrement;
    CBitmap* m_pThumbBitmap[cgMaxSldrStates];
    CComBSTR m_bstrThumbFilename[cgMaxSldrStates]; // filenames containing the thumb images
    CBitmap* m_pBackBitmap[cgMaxSldrStates];
    CComBSTR m_bstrBackFilename[cgMaxSldrStates]; // filenames containing the background images
    SldrState m_nEntry;
    RECT m_rcThumb; // position for the thumb

protected:
    void Init();
    HRESULT RecalculateValue();
    HRESULT RecalculateTumbPos(); // Centers the thumb rect around the m_fValue
    HRESULT PutThumbImage(BSTR strFilename, int nEntry);
    HRESULT PutBackImage(BSTR strFilename, int nEntry);
    HRESULT SetSliderState(SldrState sldrState);    
    HRESULT SetThumbPos(LONG xPos);
    HRESULT OffsetX(LONG& xPos);
    HRESULT FitValue();
    bool PtOnSlider(LONG x, LONG y);
    bool PtOnSlider(POINT pos);
    bool PtOnThumb(LONG x, LONG y);
    bool PtOnThumb(POINT pos);
};

#endif //__MSMFSLDR_H_
/*************************************************************************/
/* End of file: MSMFSldr.h                                               */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\msmfimg.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFImg.cpp                                                     */
/* Description: Implementation of CMSMFImg Static Image class            */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "MSMFCnt.h"
#include "MSMFImg.h"

/////////////////////////////////////////////////////////////////////////////
// CMSMFImg

/*************************************************************************/
/* Function:  CMSMFImg                                                   */
/*************************************************************************/
CMSMFImg::CMSMFImg(){

    m_pBackBitmap = new CBitmap;
    Init();    
}/* end of function CMSMFSldr */

/*************************************************************************/
/* Function: Init                                                        */
/* Description: Initializes variable states.                             */
/*************************************************************************/
void CMSMFImg::Init(){

    m_blitType = DISABLE;
    m_clrBackColor = ::GetSysColor(COLOR_BTNFACE);
        
#if 0 // used for getting the windowed case working DJ
    m_bWindowOnly = TRUE;
#endif    
}/* end of function Init */

/*************************************************************************/
/* Function:  ~CMSMFImg                                                 */
/* Description: Cleanup the stuff we allocated here rest will be done    */
/* in the button destructor.                                             */
/*************************************************************************/
CMSMFImg::~CMSMFImg(){

    delete m_pBackBitmap;
    
    Init();    
}/* end of function CMSMFSldr */

/*************************************************************************/
/* Function: OnDraw                                                      */
/* Description: Does the basic drawing                                   */
/* First draws the background the the thumb at the specific position.    */
/*************************************************************************/
HRESULT CMSMFImg::OnDraw(ATL_DRAWINFO& di){

    HRESULT hr = S_OK;

    BOOL bRet = TRUE;
    HDC hdc = di.hdcDraw;
    RECT rcClient = *(RECT*)di.prcBounds;

    // DRAW THE BACKGROUND
    if (!m_pBackBitmap->IsEmpty()){

        bRet = m_pBackBitmap->PaintTransparentDIB(hdc, NULL, 
            &rcClient, m_blitType);
    } 
    else {

        COLORREF clr;
        ::OleTranslateColor (m_clrBackColor, m_pBackBitmap->GetPal(), &clr); 

        HBRUSH hbrBack = ::CreateSolidBrush(clr);                        
        ::FillRect(hdc, &rcClient, hbrBack);
        ::DeleteObject(hbrBack);
    }/* end of if statement */
    	
	return (hr);
}/* end of function OnDraw */

/*************************************************************************/
/* Function: PutImage                                                    */
/* Description: Sets the image of the background.                        */
/*************************************************************************/
HRESULT CMSMFImg::PutImage(BSTR strFilename){

    HRESULT hr = S_OK;

    m_bstrBackFilename = strFilename;

    bool fGrayOut = false;
    
    hr = m_pBackBitmap->PutImage(strFilename, m_hRes, GetUnknown(),fGrayOut ,m_blitType);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    InvalidateRgn(); // our helper function            
   
    return(hr);
}/* end of function PutImage */


/*************************************************************************/
/* Function: get_Image                                                   */
/*************************************************************************/
STDMETHODIMP CMSMFImg::get_Image(BSTR *pstrFilename){

    *pstrFilename = m_bstrBackFilename.Copy();
	return S_OK;
}/* end of function get_Image */

/*************************************************************************/
/* Function: put_Image                                                   */
/*************************************************************************/
STDMETHODIMP CMSMFImg::put_Image(BSTR strFilename){
	
	return (PutImage(strFilename));
}/* end of function put_BackStatic */

/*************************************************************************/
/* End of file: MSMFImg.cpp                                              */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSMFCnt.rc
//
#define IDS_PROJNAME                    100
#define IDB_MSMFBAR                     101
#define IDR_MSMFBAR                     102
#define IDB_MSMFBBTN                    103
#define IDR_MSMFBBTN                    104
#define IDB_MSMFIMG                     105
#define IDR_MSMFIMG                     106
#define IDB_MSMFSLDR                    107
#define IDR_MSMFSLDR                    108
#define IDB_MSMFTEXT                    109
#define IDR_MSMFTEXT                    110
#define IDS_BAR_ABOUT                   111
#define IDS_ABOUT                       112
#define IDS_SCRIPT_LANGUAGE             113
#define IDS_END_FILE                    114
#define IDS_ROOT_OBJECT                 115
#define IDS_BTN_ABOUT                   116
#define IDS_MAIN_ENTRY                  117
#define IDR_SCRIPT                      118
#define IDI_ICON1                       201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        205
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           111
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\msmftext.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFText.h                                                      */
/* Description: Header file for CMSMFText control object                 */
/* Author: phillu                                                        */
/* Date: 10/06/99                                                        */
/*************************************************************************/

#ifndef __MSMFTEXT_H_
#define __MSMFTEXT_H_

#include "MSMFCntCP.h"
#include "resource.h"       // main symbols
#include "ctext.h"
#include <atlctl.h>
#include "CstUtils.h"


/////////////////////////////////////////////////////////////////////////////
// CMSMFText
class ATL_NO_VTABLE CMSMFText : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CStockPropImpl<CMSMFText, IMSMFText, &IID_IMSMFText, &LIBID_MSMFCNTLib>,
	public CComControl<CMSMFText>,
	public IPersistStreamInitImpl<CMSMFText>,
	public IOleControlImpl<CMSMFText>,
	public IOleObjectImpl<CMSMFText>,
	public IOleInPlaceActiveObjectImpl<CMSMFText>,
	public IViewObjectExImpl<CMSMFText>,
	public IOleInPlaceObjectWindowlessImpl<CMSMFText>,
	public IConnectionPointContainerImpl<CMSMFText>,
	public IPersistStorageImpl<CMSMFText>,
	public ISpecifyPropertyPagesImpl<CMSMFText>,
	public IQuickActivateImpl<CMSMFText>,
	public IDataObjectImpl<CMSMFText>,
	public IProvideClassInfo2Impl<&CLSID_MSMFText, &DIID__IMSMFText, &LIBID_MSMFCNTLib>,	
	public CComCoClass<CMSMFText, &CLSID_MSMFText>,
    public IPersistPropertyBagImpl<CMSMFText>,
    public CProxy_IMSMFText<CMSMFText>,
    public CMSMFCntrlUtils<CMSMFText> // custom utilities we share across controls
{
public:
    CMSMFText();

DECLARE_REGISTRY_RESOURCEID(IDR_MSMFTEXT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSMFText)
	COM_INTERFACE_ENTRY(IMSMFText)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IPersist, IPersistPropertyBag)
	COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_PROP_MAP(CMSMFText)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
    PROP_ENTRY("TransparentText", 17, CLSID_NULL)
    PROP_ENTRY("Windowless", 18, CLSID_NULL)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSMFText)	
    CONNECTION_POINT_ENTRY(DIID__IMSMFText)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CMSMFText)
	MESSAGE_HANDLER(WM_MOUSEMOVE,   OnMouseMove)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnButtonDown)
	MESSAGE_HANDLER(WM_LBUTTONUP,   OnButtonUp)
    MESSAGE_HANDLER(WM_SETFOCUS,    OnSetFocus)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    CHAIN_MSG_MAP(CMSMFCntrlUtils<CMSMFText>)
	CHAIN_MSG_MAP(CComControl<CMSMFText>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);


// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

    USE_MF_OVERWRITES
    USE_MF_CLASSSTYLE  // used to overwrite default class, so we avoid flickers

// IMSMFText
public:
	STDMETHOD(get_TransparentText)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_TransparentText)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_TextHeight)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_TextWidth)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_EdgeStyle)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_EdgeStyle)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_TextAlignment)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_TextAlignment)(/*[in]*/ BSTR newVal);
    USE_MF_RESOURCEDLL  // replaces the two lines below
	STDMETHOD(get_Disable)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Disable)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_TextState)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_TextState)(/*[in]*/ long newVal);
	STDMETHOD(get_ColorActive)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorActive)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ColorDisable)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorDisable)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ColorStatic)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorStatic)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ColorHover)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorHover)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_ColorPush)(/*[out, retval]*/ OLE_COLOR *pVal);
	STDMETHOD(put_ColorPush)(/*[in]*/ OLE_COLOR newVal);
	STDMETHOD(get_FontStyle)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FontStyle)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FontFace)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FontFace)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Text)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Text)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FontSize)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_FontSize)(/*[in]*/ long newVal);
    USE_MF_WINDOWLESS_ACTIVATION //Replaces the two lines below
    //STDMETHOD(get_Windowless)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	//STDMETHOD(put_Windowless)(/*[in]*/ VARIANT_BOOL newVal);
	HRESULT OnDraw(ATL_DRAWINFO& di);
    STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip);
	OLE_COLOR m_clrBackColor;   // stock property implemeted in the CStockPropImpl

	enum TextState {Static = 0, Hover = 1, Push = 2, Disabled = 3, Active = 4};

private:    

    CText       m_cText;
    bool        m_fDirty; // if any attribute for the text drawing object changes

    //properties
    UINT        m_uiState;
    CComBSTR    m_bstrTextValue;
    CComBSTR    m_bstrFontFace;
    CComBSTR    m_bstrFontStyle;
    CComBSTR    m_bstrAlignment;
    UINT        m_uiFontSize;
    bool        m_fDisabled;
    OLE_COLOR   m_clrColorActive;
    OLE_COLOR   m_clrColorStatic;
    OLE_COLOR   m_clrColorHover;
    OLE_COLOR   m_clrColorPush;
    OLE_COLOR   m_clrColorDisable;
    UINT        m_uiEdgeStyle;
    bool        m_fTransparent;

    HRESULT SetTextProperties();
    bool PtOnButton(LONG x, LONG y);
    bool PtOnButton(POINT pos);
    HRESULT SetButtonState(TextState txtState);        
};

#endif //__MSMFTEXT_H_

/*************************************************************************/
/* End of file: MSMFText.cpp                                             */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\msmftext.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSMFText.cpp                                                    */
/* Description: Implementation of CMSMFText control object               */
/* Author: phillu                                                        */
/* Date: 10/06/99                                                        */
/*************************************************************************/
#include "stdafx.h"
#include "MSMFCnt.h"
#include "MSMFText.h"

/////////////////////////////////////////////////////////////////////////////
// CMSMFText

/*************************************************************************/
/* Function: CMSMFText::CMSMFText()                                      */
/* Description: Initialize the properties and states.                    */
/*************************************************************************/
CMSMFText::CMSMFText()
{
    m_fDirty = true;

    //properties
    m_clrBackColor = ::GetSysColor(COLOR_BTNFACE);
    m_uiState = TextState::Static;
    m_uiFontSize = 10;
    m_fDisabled = false;
    m_clrColorActive = 0x00ff0000; // blue
    m_clrColorStatic = 0x00000000; // black
    m_clrColorHover = 0x00ff0000;  // blue
    m_clrColorPush = 0x00ffffff;   // white
    m_clrColorDisable = 0x00808080; // grey
    m_bstrTextValue = L"";
    m_bstrFontFace = L"Arial";
    m_bstrAlignment = L"Center";
    m_bstrFontStyle = L"Normal";
    m_uiEdgeStyle = 0; // no edge
    #if 0 // used for getting the windowed case working DJ
    m_bWindowOnly = TRUE;
    #endif
    m_fTransparent = false;
}


/*************************************************************************/
/* Function: CMSMFText::SetTextProperties                                */
/* Description: Set the properties for the CText object.                 */
/*************************************************************************/
HRESULT CMSMFText::SetTextProperties()
{
    HRESULT hr = S_OK;

    m_cText.SetFontFace(m_bstrFontFace);
    m_cText.SetFontSize(m_uiFontSize);
    m_cText.SetFontStyle(m_bstrFontStyle);
    m_cText.SetTextAlignment(m_bstrAlignment);
    m_cText.SetFixedSizeFont(true);

    // set the font color based on the current state

    OLE_COLOR clrColorCurrent = m_clrColorStatic;
    switch(m_uiState)
    {
        case(TextState::Static):
            clrColorCurrent = m_clrColorStatic;
            break;
        case(TextState::Hover):
            clrColorCurrent = m_clrColorHover;
            break;
        case(TextState::Active):
            clrColorCurrent = m_clrColorActive;
            break;
        case(TextState::Push):
            clrColorCurrent = m_clrColorPush;
            break;
        case(TextState::Disabled):
            clrColorCurrent = m_clrColorDisable;
            break;
    }

    // translate OLE_COLOR to COLORREF
    COLORREF crCurrentState;

    hr = OleTranslateColor(clrColorCurrent, NULL, &crCurrentState);

    if (FAILED(hr))
    {
        crCurrentState = GetSysColor(COLOR_WINDOWTEXT);
    }
    
    m_cText.SetTextColor(crCurrentState);

    m_fDirty = false;

    return hr;
}

/*************************************************************************/
/* Function: OnDraw                                                      */
/* Description: Draw text in the specified rectangle.                    */
/*************************************************************************/
HRESULT CMSMFText::OnDraw(ATL_DRAWINFO& di)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
	RECT& rc = *(RECT*)di.prcBounds;

    // draw background
    if (!m_fTransparent)
    {
        COLORREF clr;
        ::OleTranslateColor (m_clrBackColor, NULL, &clr);        
 
        HBRUSH hbrBack = ::CreateSolidBrush(clr);            
        ::FillRect(di.hdcDraw, &rc, hbrBack);
        ::DeleteObject(hbrBack);
    }

    if (m_fDirty)
    {
        SetTextProperties();
    }

    hr = m_cText.Write(di.hdcDraw, rc, m_bstrTextValue);

    // draw edge

    if (m_uiEdgeStyle != 0)
    {
        ::DrawEdge(di.hdcDraw, &rc, m_uiEdgeStyle, BF_RECT);
    }

    // draw focus rectagle

    hr = GetFocus();

    if(S_OK == hr)
    {
        ::DrawFocusRect(di.hdcDraw, (LPRECT)di.prcBounds);
    }

	return hr;
}/* end of function OnDraw */


/*************************************************************************/
/* Function: get_FontSize                                                */
/* Description: return the FontSize property.                            */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_FontSize(long *pVal)
{
    if (!pVal)
    {
        return E_POINTER;
    }

    *pVal = m_uiFontSize;

	return S_OK;
}


/*************************************************************************/
/* Function: put_FontSize                                                */
/* Description: set the FontSize property, in pt.                        */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_FontSize(long lSize)
{
    if ((UINT)lSize != m_uiFontSize)
    {
        m_uiFontSize = (UINT)lSize;
        m_fDirty = true;
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_Text                                                    */
/* Description: return the Text that is displayed in the control.        */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_Text(BSTR *pText)
{
    if (!pText)
    {
        return E_POINTER;
    }

    *pText = m_bstrTextValue.Copy();

    return S_OK;
}


/*************************************************************************/
/* Function: put_Text                                                    */
/* Description: set the text to be displayed in the control.             */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_Text(BSTR wsText)
{
    if (_wcsicmp(m_bstrTextValue, wsText) != 0)
    {
        m_bstrTextValue = wsText;
        FireViewChange();
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_FontFace                                                */
/* Description: return the FontFace property.                            */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_FontFace(BSTR *pFontFace)
{
    if (!pFontFace)
    {
        return E_POINTER;
    }

    *pFontFace = m_bstrFontFace.Copy();
    
	return S_OK;
}


/*************************************************************************/
/* Function: put_FontFace                                                */
/* Description: set the FontFace property.                               */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_FontFace(BSTR wsFontFace)
{
    if (_wcsicmp(m_bstrFontFace, wsFontFace) != 0)
    {
        m_bstrFontFace = wsFontFace;
        m_fDirty = true;
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_FontStyle                                               */
/* Description: return the FontSize property.                            */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_FontStyle(BSTR *pFontStyle)
{
    if (!pFontStyle)
    {
        return E_POINTER;
    }

    *pFontStyle = m_bstrFontStyle.Copy();
    
    return S_OK;
}


/*************************************************************************/
/* Function: put_FontStyle                                               */
/* Description: set the FontStyle property. The style string should      */
/* contain either "Normal", or concatenation of one or more strings of:  */
/* "Bold", "Italic", "Underline", "Strikeout". Default is "Normal".      */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_FontStyle(BSTR wsFontStyle)
{
    if (_wcsicmp(m_bstrFontStyle, wsFontStyle) != 0)
    {
        m_bstrFontStyle = wsFontStyle;
        m_fDirty = true;
    }

    return S_OK;
}


/*************************************************************************/
/* Function: get_TextAlignment                                           */
/* Description: return the TextAlignment (horizontal) property.          */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_TextAlignment(BSTR *pAlignment)
{
    if (!pAlignment)
    {
        return E_POINTER;
    }

    *pAlignment = m_bstrAlignment.Copy();

    return S_OK;
}


/*************************************************************************/
/* Function: put_TextAlignment                                           */
/* Description: set the TextAlignment property. It controls the          */
/* horizontal text alignment. Must be one of "Left", "Center", or        */
/* "Right". Default is "Center".                                         */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_TextAlignment(BSTR wsAlignment)
{
    if (_wcsicmp(m_bstrAlignment, wsAlignment) != 0)
    {
        m_bstrAlignment = wsAlignment;
        m_fDirty = true;
    }

    return S_OK;
}


/*************************************************************************/
/* Function: get_ColorPush                                               */
/* Description: return the ColorPush property.                           */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_ColorPush(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorPush;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorPush                                               */
/* Description: set the ColorPush property. This is the color of text    */
/* in the Push state.                                                    */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_ColorPush(OLE_COLOR clrColor)
{
    m_clrColorPush = clrColor;

    if (m_uiState == TextState::Push)
    {
        m_fDirty = true;
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_ColorHover                                              */
/* Description: return the ColorHover property.                          */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_ColorHover(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorHover;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorHover                                              */
/* Description: set the ColorHover property. This is the color of text   */
/* in the Hover state.                                                   */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_ColorHover(OLE_COLOR clrColor)
{
    m_clrColorHover = clrColor;

    if (m_uiState == TextState::Hover)
    {
        m_fDirty = true;
    }

    return S_OK;
}


/*************************************************************************/
/* Function: get_ColorStatic                                             */
/* Description: return the ColorStatic property.                         */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_ColorStatic(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorStatic;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorPush                                               */
/* Description: set the ColorPush property. This is the color of text    */
/* in the Static (normal) state.                                         */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_ColorStatic(OLE_COLOR clrColor)
{
    m_clrColorStatic = clrColor;

    if (m_uiState == TextState::Static)
    {
        m_fDirty = true;
    }
	
    return S_OK;
}


/*************************************************************************/
/* Function: get_ColorDisable                                            */
/* Description: return the ColorDisable property.                        */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_ColorDisable(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorDisable;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorDisable                                            */
/* Description: set the ColorDisable property. This is the color of text */
/* in the Disabled state.                                                */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_ColorDisable(OLE_COLOR clrColor)
{
    m_clrColorDisable = clrColor;

    if (m_uiState == TextState::Disabled)
    {
        m_fDirty = true;
    }

    return S_OK;
}


/*************************************************************************/
/* Function: get_ColorActive                                             */
/* Description: return the ColorActive property.                         */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_ColorActive(OLE_COLOR *pColor)
{
    if (!pColor)
    {
        return E_POINTER;
    }

    *pColor = m_clrColorActive;

	return S_OK;
}


/*************************************************************************/
/* Function: put_ColorActive                                             */
/* Description: set the ColorActive property. This is the color of text  */
/* in the Active state.                                                  */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_ColorActive(OLE_COLOR clrColor)
{
    m_clrColorActive = clrColor;

    if (m_uiState == TextState::Active)
    {
        m_fDirty = true;
    }

    return S_OK;
}


/*************************************************************************/
/* Function: get_TextState                                               */
/* Description: return the TextState property.                           */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_TextState(long *pState)
{
    if (!pState)
    {
        return E_POINTER;
    }

    *pState = m_uiState;
	return S_OK;
}


/*************************************************************************/
/* Function: put_TextState                                               */
/* Description: set the TextState property. It should be one of:         */
/* Static = 0, Hover = 1, Push = 2, Disabled = 3, Active = 4.            */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_TextState(long lState)
{
    if (lState < 0 || lState > 4)
    {
        return E_INVALIDARG;
    }

    if ((UINT)lState != m_uiState)
    {
        m_uiState = (UINT)lState;
        m_fDirty = true;
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_Disable                                                 */
/* Description: return the Disable property.                             */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_Disable(VARIANT_BOOL *pVal)
{
    if (!pVal)
    {
        return E_POINTER;
    }

    *pVal = m_fDisabled?VARIANT_TRUE:VARIANT_FALSE;

	return S_OK;
}


/*************************************************************************/
/* Function: put_Disable                                                 */
/* Description: set the Disable property.                                */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_Disable(VARIANT_BOOL newVal)
{
    bool fDisabled;

    if (newVal == VARIANT_TRUE)
    {
        fDisabled = true;
        m_uiState = TextState::Disabled;
    }
    else
    {
        fDisabled = false;
        m_uiState = TextState::Static;
    }

    if (fDisabled != m_fDisabled)
    {
        m_fDisabled = fDisabled;
        m_fDirty = true;
    }

	return S_OK;
}


/*************************************************************************/
/* Function: get_EdgeStyle                                               */
/* Description: return the EdgeStyle.                                    */
/*************************************************************************/
STDMETHODIMP CMSMFText::get_EdgeStyle(BSTR *pStyle)
{
    if (!pStyle)
    {
        return E_POINTER;
    }

    switch (m_uiEdgeStyle)
    {
    case 0: // no edge
        *pStyle = SysAllocString(L"None");
        break;
    case EDGE_SUNKEN:
        *pStyle = SysAllocString(L"Sunken");
        break;
    case EDGE_RAISED:
        *pStyle = SysAllocString(L"Raised");
        break;
    default:
        // we should not reach here
        *pStyle = NULL;
        DebugBreak();
    }

	return S_OK;
}


/*************************************************************************/
/* Function: put_EdgeStyle                                               */
/* Description: set the EdgeStyle property. Must be one of "None",       */
/* "Raised", or "Sunken". Default is "None".                             */
/*************************************************************************/
STDMETHODIMP CMSMFText::put_EdgeStyle(BSTR wsStyle)
{
    UINT uiStyle = 0;

    //set the text alignment
    if (!_wcsicmp(wsStyle, L"None"))
    {
        uiStyle = 0;
    }
    else if (!_wcsicmp(wsStyle, L"Sunken"))
    {
        uiStyle = EDGE_SUNKEN;
    }
    else if (!_wcsicmp(wsStyle, L"Raised"))
    {
        uiStyle = EDGE_RAISED;
    }

    if (m_uiEdgeStyle != uiStyle)
    {
        m_uiEdgeStyle = uiStyle;
        FireViewChange();
    }

    return S_OK;
}


/*************************************************************************/
/* Function: OnButtonDown                                                */
/* Description: Handles when buttons is selected. Captures the mouse     */
/* movents (supported for windowless, via interfaces).                   */
/*************************************************************************/
LRESULT CMSMFText::OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_uiState == TextState::Disabled){
        
        return 0;
    }/* end of if statement */

    LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    if(PtOnButton(xPos, yPos)){

        // we are really on the buttons bitmap and we pushed it

        if(TextState::Hover !=  m_uiState){
            // in hover case we already have captured the mouse, so do not do
            // that again
            SetCapture(true); // capture the mouse messages
        }/* end of if statement */

	    SetButtonState(TextState::Push);
    }/* end of if statement */

	return 0;
}/* end of function OnButtonDown */

/*************************************************************************/
/* Function: OnButtonUp                                                  */
/* Description: Releases the capture, updates the button visual state,   */
/* and if release on the buttons image fire the event.                   */
/*************************************************************************/
LRESULT CMSMFText::OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_uiState == TextState::Disabled)
        return 0;

    LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    bool bOnButtonImage = PtOnButton(xPos, yPos);
    bool bFire = (m_uiState == TextState::Push);
	
    if(bOnButtonImage){

        SetButtonState(TextState::Static); //change to static even 
        SetCapture(false); // release the capture of the mouse messages
    }
    else {

        SetButtonState(TextState::Static);
        // do it only when we do not hower, if we hower, then keep the capture
        SetCapture(false); // release the capture of the mouse messages
    }/* end of if statement */

    if (bFire){

        if(bOnButtonImage){

            Fire_OnClick();
        }/* end of if statement */
    }/* end of if statement */

	return 0;
}/* end of function OnButtonUp */

/*************************************************************************/
/* Function: OnMouseMove                                                 */
/* Description: Check if we were captured/pushed the do not do much,     */
/* otherwise do the hit detection and see if we are in static or hower   */
/* state.                                                                */
/*************************************************************************/
LRESULT CMSMFText::OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_uiState == TextState::Disabled)
        return 0;

	LONG xPos = GET_X_LPARAM(lParam);
    LONG yPos = GET_Y_LPARAM(lParam);

    if (m_uiState != TextState::Push){    
    
        if(PtOnButton(xPos, yPos)){
            if(TextState::Hover != m_uiState || S_OK != GetCapture()){

                SetCapture(true); // capture the mouse messages
		        SetButtonState(TextState::Hover);
            }/* end of if statement */
        }
        else {

            if(TextState::Static != m_uiState){

                SetCapture(false); // release the capture of the mouse messages
		        SetButtonState(TextState::Static);
            }/* end of if statement */
        }/* end of if statement */
	}/* end of if statement */

	return 0;
}/* end of function OnMouseMove */


/*************************************************************************/
/* Function: OnSetFocus                                                  */
/* Description: If we are in disabled state SetFocus(false)              */
/*************************************************************************/
LRESULT CMSMFText::OnSetFocus(UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_uiState == TextState::Disabled){

        if(GetFocus() == S_OK){

            SetFocus(false);
        }/* end of if statement */

        return(-1);
    }/* end of if statement */

    return 0;
}/* end of function OnSetFocus */

/*************************************************************************/
/* Function: PtOnButton                                                  */
/* Description: Uses helper to do the same.                              */
/*************************************************************************/
bool CMSMFText::PtOnButton(LONG x, LONG y){

    POINT pos = {x, y};
    return(PtOnButton(pos));
}/* end of function PtOnButton */

/*************************************************************************/
/* Function: PtOnButton                                                  */
/* Description: Determines if the point is located on the button.        */
/* TODO: Needs to be modified when we will handle transparent color.     */
/*************************************************************************/
bool CMSMFText::PtOnButton(POINT pos){

    RECT rc;
    bool bRet = false;

    if(m_bWndLess){

        rc = m_rcPos;
    } 
    else {

        if(!::IsWindow(m_hWnd)){

            return(bRet);
        }/* end of if statement */

        ::GetClientRect(m_hWnd, &rc);
    }/* end of if statement */

    bRet = PtInRect(&rc, pos) ? true : false;    

    //TODO: Add also if we are on bitmap itsels possibly

#ifdef _DEBUG
if(bRet)
    ATLTRACE2(atlTraceWindowing, 20, TEXT("Point x = %d y = %d in Rect left = %d top %d right %d bottom %d\n"), 
        pos.x, pos.y, m_rcPos.left, m_rcPos.top, m_rcPos.right, m_rcPos.bottom);
else
    ATLTRACE2(atlTraceWindowing, 20, TEXT("Point x = %d y = %d NOT ON RECT Rect left = %d top %d right %d bottom %d\n"), 
        pos.x, pos.y, m_rcPos.left, m_rcPos.top, m_rcPos.right, m_rcPos.bottom);
#endif

    return(bRet);
}/* end of function PtOnButton */


/*************************************************************************/
/* Function: SetButtonState                                              */
/* Description: Sets the button states forces redraw.                    */
/*************************************************************************/
HRESULT CMSMFText::SetButtonState(TextState txtState){

    HRESULT hr = S_OK;

    bool fRedraw = false;
    
    if((UINT)txtState != m_uiState ){

        fRedraw = true;
    }/* end of if statement */

    m_uiState = txtState;    
    
    if(fRedraw){

        if (m_uiState == TextState::Disabled){
            
            SetFocus(false); // disable the focus
            SetCapture(false);
        }/* end of if statement */

        m_fDirty = true;
	    FireViewChange(); // update the display
    }/* end of if statement */

    return(hr);
}/* end of function SetButtonState */


STDMETHODIMP CMSMFText::get_TextWidth(long *pVal)
{
    // special case early return
    if (m_bstrTextValue.Length() == 0)
    {
        *pVal = 0;
        return S_OK;
    }

    // get the current window or the window of its parent
    HWND hwnd = GetWindow();
    HDC hdc = ::GetWindowDC(hwnd);

    // normalize to pixel coord as required by the container
    SetMapMode(hdc, MM_TEXT); 

    if (m_fDirty)
    {
        SetTextProperties();
    }

    SIZE size;
    m_cText.GetTextWidth(hdc, m_bstrTextValue, &size);
    *pVal = size.cx;

    ::ReleaseDC(hwnd, hdc);

	return S_OK;
}

STDMETHODIMP CMSMFText::get_TextHeight(long *pVal)
{
    // get the current window or the window of its parent
    HWND hwnd = GetWindow();
    HDC hdc = ::GetWindowDC(hwnd);

    // normalize to pixel coord as required by the container
    SetMapMode(hdc, MM_TEXT); 

    if (m_fDirty)
    {
        SetTextProperties();
    }

    SIZE size;
    m_cText.GetTextWidth(hdc, m_bstrTextValue, &size);
    *pVal = size.cy;

    ::ReleaseDC(hwnd, hdc); // do not forget to free DC

	return S_OK;
}

STDMETHODIMP CMSMFText::get_TransparentText(VARIANT_BOOL *pVal)
{
    if (!pVal)
    {
        return E_POINTER;
    }

    *pVal = m_fTransparent?VARIANT_TRUE:VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CMSMFText::put_TransparentText(VARIANT_BOOL newVal)
{
    bool fTransparent;

    if (newVal == VARIANT_FALSE)
    {
        fTransparent = false;
    }
    else
    {
        fTransparent = true;
    }

    if (fTransparent != m_fTransparent)
    {
        m_fTransparent = fTransparent;
        FireViewChange();
    }

	return S_OK;
}

/*************************************************************/
/* Name: SetObjectRects                                      */
/*************************************************************/
STDMETHODIMP CMSMFText::SetObjectRects(LPCRECT prcPos,LPCRECT prcClip){
    // Call the default method first
    IOleInPlaceObjectWindowlessImpl<CMSMFText>::SetObjectRects(prcPos, prcClip);
  
    FireViewChange();

    
    return S_OK;
}/* end of function SetObjectRects */

/*************************************************************************/
/* Function: OnSize                                                      */
/*************************************************************************/
LRESULT CMSMFText::OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){
    
    bHandled = true;

    FireViewChange();

    return 0;
}/* end of function OnSize */


/*************************************************************************/
/* End of file: MSMFText.cpp                                             */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\sndctl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\tvprof\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\sndctl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sndctl.rc
//
#define IDS_PROJNAME                    100
#define IDR_SOUNDCTL                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\msmfcnt\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__801B2C9D_82CA_459C_8670_6F6293B6985E__INCLUDED_)
#define AFX_STDAFX_H__801B2C9D_82CA_459C_8670_6F6293B6985E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#pragma warning( disable: 4100 )  /*unreferenced formal parameter*/

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__801B2C9D_82CA_459C_8670_6F6293B6985E__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\sndctl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__643D1669_DF5C_4289_BBBF_56329E8D44AE__INCLUDED_)
#define AFX_STDAFX_H__643D1669_DF5C_4289_BBBF_56329E8D44AE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__643D1669_DF5C_4289_BBBF_56329E8D44AE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\tvprof\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tvprof.rc
//
#define IDS_PROJNAME                    100
#define IDR_TVPROFILE                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\sndctl\soundctl.h ===
// SoundCtl.h : Declaration of the CSoundCtl

#ifndef __SOUNDCTL_H_
#define __SOUNDCTL_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include <mmsystem.h>

/////////////////////////////////////////////////////////////////////////////
// CSoundCtl
class ATL_NO_VTABLE CSoundCtl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSoundCtl, &CLSID_SoundCtl>,
	public IDispatchImpl<ISoundCtl, &IID_ISoundCtl, &LIBID_SNDCTLLib>,
    public IObjectSafetyImpl<CSoundCtl, (INTERFACESAFE_FOR_UNTRUSTED_CALLER|INTERFACESAFE_FOR_UNTRUSTED_DATA)>
{
public:
    CSoundCtl();

DECLARE_REGISTRY_RESOURCEID(IDR_SOUNDCTL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSoundCtl)
	COM_INTERFACE_ENTRY(ISoundCtl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

// ISoundCtl
public:
	STDMETHOD(get_ComponentType)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_ComponentType)(/*[in]*/ long newVal);
	STDMETHOD(get_Mute)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Mute)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_Volume)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_Volume)(/*[in]*/ DWORD newVal);

private:
    MMRESULT AdjustLineVolume(HMIXEROBJ hmx, MIXERCONTROL *pmxctrl, DWORD cChannels, DWORD dwValue);
    MMRESULT AdjustLineMute(HMIXEROBJ hmx, MIXERCONTROL *pmxctrl, DWORD cChannels, DWORD dwValue);
    MMRESULT AdjustLine(HMIXEROBJ hmx, MIXERLINE *pmxl, DWORD dwControlType, DWORD dwValue);
    MMRESULT AdjustSound(DWORD dwComponentType, DWORD dwControlType, DWORD dwValue);

private:
    DWORD   m_dwComponentType;
};

#endif //__SOUNDCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\sndctl\sndctl.cpp ===
// sndctl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f sndctlps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "sndctl.h"

#include "sndctl_i.c"
#include "SoundCtl.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SoundCtl, CSoundCtl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SNDCTLLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\tvprof\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__0EDC19FC_7732_4688_A08A_A581BADF1ED9__INCLUDED_)
#define AFX_STDAFX_H__0EDC19FC_7732_4688_A08A_A581BADF1ED9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0EDC19FC_7732_4688_A08A_A581BADF1ED9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\sndctl\soundctl.cpp ===
// SoundCtl.cpp : Implementation of CSoundCtl
#include "stdafx.h"
#include "Sndctl.h"
#include "SoundCtl.h"

#define SND_VALUE_MAX   0xffff

//const DWORD gc_dwSoundTarget = MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;


//***************************************************************************************
MMRESULT
CSoundCtl::AdjustLineVolume(HMIXEROBJ hmx, MIXERCONTROL *pmxctrl, DWORD cChannels, DWORD dwValue)
{
    if (dwValue > SND_VALUE_MAX)
        return MIXERR_INVALVALUE;

    MIXERCONTROLDETAILS           mxcd;
	BYTE                          data[64];
	MIXERCONTROLDETAILS_UNSIGNED *pVolumeLeft, *pVolumeRight;
    MMRESULT                      mmResult;

    mxcd.cbStruct       = sizeof(MIXERCONTROLDETAILS);
    mxcd.cChannels      = cChannels;
    mxcd.dwControlID    = pmxctrl->dwControlID;
    mxcd.cMultipleItems = pmxctrl->cMultipleItems;	// should be 0!
    mxcd.cbDetails      = sizeof(MIXERCONTROLDETAILS_UNSIGNED);
    mxcd.paDetails      = (LPVOID)data; // 1st long=left channel, 2nd long=right channel

    mmResult = mixerGetControlDetails(hmx, &mxcd, MIXER_GETCONTROLDETAILSF_VALUE);
    if (mmResult != MMSYSERR_NOERROR)
        return mmResult;

    pVolumeLeft  = (MIXERCONTROLDETAILS_UNSIGNED *)data;
    pVolumeRight = pVolumeLeft + 1;

    DWORD dwMin = pmxctrl->Bounds.dwMinimum;
    DWORD dwMax = pmxctrl->Bounds.dwMaximum;
    
    // dwValue is a volume expressed on the scale 0..SND_VALUE_MAX. Map this linearly
    // to the scale dwMin..dwMax

    DWORD dwDesiredVolume = dwMin + ((dwMax-dwMin)*dwValue)/SND_VALUE_MAX;
    
    pVolumeLeft->dwValue  = dwDesiredVolume;
    pVolumeRight->dwValue = dwDesiredVolume;
    
    return mixerSetControlDetails(hmx, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE);
}

//***************************************************************************************
MMRESULT
CSoundCtl::AdjustLineMute(HMIXEROBJ hmx, MIXERCONTROL *pmxctrl, DWORD cChannels, DWORD dwValue)
{
    MIXERCONTROLDETAILS           mxcd;
	BYTE                          data[64];
	MIXERCONTROLDETAILS_BOOLEAN  *pMute;
    MMRESULT                      mmResult;

    mxcd.cbStruct       = sizeof(MIXERCONTROLDETAILS); 
    mxcd.cChannels      = 1; // mixerGetControlDetails fails if this is cChannels
    mxcd.dwControlID    = pmxctrl->dwControlID;
    mxcd.cMultipleItems = pmxctrl->cMultipleItems;	// should be 0!
    mxcd.cbDetails      = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mxcd.paDetails      = (LPVOID)data;	// 1st bool=mute left, 2nd bool=mute right

    mmResult = mixerGetControlDetails(hmx, &mxcd, MIXER_GETCONTROLDETAILSF_VALUE);
    if (mmResult != MMSYSERR_NOERROR)
        return mmResult;

    pMute = (MIXERCONTROLDETAILS_BOOLEAN *)data;
    
    pMute->fValue = dwValue;
    
    return mixerSetControlDetails(hmx, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE);
}


//***************************************************************************************
MMRESULT
CSoundCtl::AdjustLine(HMIXEROBJ hmx, MIXERLINE *pmxl, DWORD dwControlType, DWORD dwValue)
{
    MMRESULT mmResult = MMSYSERR_NOERROR;

	switch (pmxl->dwComponentType)
	{
	// TBD: Only handling volume level output for these destinations from mixer!
	// Currently hardcoded.
	case MIXERLINE_COMPONENTTYPE_DST_SPEAKERS:
	case MIXERLINE_COMPONENTTYPE_DST_MONITOR:
	case MIXERLINE_COMPONENTTYPE_DST_HEADPHONES:
	case MIXERLINE_COMPONENTTYPE_DST_DIGITAL:
	case MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT:
	case MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC:
	case MIXERLINE_COMPONENTTYPE_SRC_ANALOG:
	case MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY:
	case MIXERLINE_COMPONENTTYPE_SRC_LINE:
	case MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED: 
	case MIXERLINE_COMPONENTTYPE_SRC_DIGITAL:
	case MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE:
	case MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER:
	case MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE:
	case MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER:

    	MIXERLINECONTROLS   mxlc;
	    MIXERCONTROL        amxctrl[10];

		mxlc.cbStruct  = sizeof(MIXERLINECONTROLS);
		mxlc.dwLineID  = pmxl->dwLineID;
		mxlc.cControls = pmxl->cControls;
		mxlc.cbmxctrl  = sizeof(MIXERCONTROL);
		mxlc.pamxctrl  = amxctrl;
		MMRESULT mmResult;
         
		mmResult = mixerGetLineControls((hmx),(LPMIXERLINECONTROLS)&mxlc,
							             MIXER_GETLINECONTROLSF_ALL);

		if ( mmResult != MMSYSERR_NOERROR )
            return mmResult;

        DWORD iCtrl;
        for (iCtrl=0; iCtrl< pmxl->cControls; iCtrl++ )
        {
            if (amxctrl[iCtrl].dwControlType == dwControlType)
            {
                switch (dwControlType) 
                {
                case MIXERCONTROL_CONTROLTYPE_VOLUME:
                    return AdjustLineVolume(hmx, &amxctrl[iCtrl], pmxl->cChannels, dwValue);

                case MIXERCONTROL_CONTROLTYPE_MUTE:
                    return AdjustLineMute(hmx, &amxctrl[iCtrl], pmxl->cChannels, dwValue);

                default:
                    return MIXERR_INVALCONTROL;
                }
            }
        }

        // Couldn't find a control of the desired type in this line
        return MIXERR_INVALCONTROL;

    default:
        // We don't yet support changing volume on this type of line
        return MIXERR_INVALLINE;
	}

    // This statement is unreachable
	return MIXERR_INVALLINE;
}


//****************************************************************************************
MMRESULT
CSoundCtl::AdjustSound(DWORD dwComponentType, DWORD dwControlType, DWORD dwValue)
{
	UINT nMixers = mixerGetNumDevs();
	if ( nMixers == 0 )
	{
		return MMSYSERR_NOERROR;
	}

    // Is the component we are changing parameters for one of the destinations of the
    // mixer?

    bool bComponentIsDestType = false;
    if (dwComponentType >  MIXERLINE_COMPONENTTYPE_DST_FIRST &&
        dwComponentType <= MIXERLINE_COMPONENTTYPE_DST_LAST)
    {
            bComponentIsDestType = true;
    }


    for ( UINT iMixer=0; iMixer<nMixers; iMixer++ )
	{
		MIXERCAPS mxcaps;
        MMRESULT  mmResult;

		mmResult = mixerGetDevCaps( iMixer, (LPMIXERCAPS)&mxcaps, sizeof(MIXERCAPS) );
		if ( mmResult != MMSYSERR_NOERROR )
		{
            return mmResult;
        }

        HMIXEROBJ    hmx;

        // Idiosyncracy in the mixer API. mixerOpen returns HMIXER but other functions
        // take HMIXEROBJ. Both are handles.
        mmResult = mixerOpen((LPHMIXER)&hmx, iMixer, 0, 0, MIXER_OBJECTF_MIXER );
        if (mmResult != MMSYSERR_NOERROR)
        {
            mixerClose((HMIXER)hmx);
            return mmResult;
        }
        

        // To get the sources, one must enumerate the destinations first and then
        // enumerate the sources for each dest.

        for (DWORD iDest=0; iDest < mxcaps.cDestinations; iDest++)
        {
            MIXERLINE mxl;        
            mxl.cbStruct      = sizeof(MIXERLINE);
            mxl.dwDestination = iDest;
            mxl.dwSource      = 0;
            
            mmResult = mixerGetLineInfo(hmx, &mxl, MIXER_GETLINEINFOF_DESTINATION);
            if ( mmResult != MMSYSERR_NOERROR )
            {
                mixerClose((HMIXER)hmx);
                return mmResult;
            }
    
            if (bComponentIsDestType)
            {
                // Adjust destination
                if (mxl.dwComponentType == dwComponentType)
                {
                    mmResult = AdjustLine(hmx, &mxl, dwControlType, dwValue);
                }
            }
            else
            {
                // For each source connected to this destination that is of 
                // the desired component type, adjust it.
                
                DWORD cConnections = mxl.cConnections;
                
                for (DWORD iSource=0; iSource < cConnections; iSource++)
                {
                    mxl.dwDestination = iDest;
                    mxl.dwSource      = iSource;
                    
                    mmResult = mixerGetLineInfo(hmx, &mxl, MIXER_GETLINEINFOF_SOURCE);
                    if ( mmResult != MMSYSERR_NOERROR )
                    {
                        mixerClose((HMIXER)hmx);
                        return mmResult;
                    }
                    
                    if (mxl.dwComponentType == dwComponentType)
                    {
                        mmResult = AdjustLine(hmx, &mxl, dwControlType, dwValue);
                    }
                } // for over sources
            } // if bComponentIsDestType
        } // for over destinations

        mixerClose((HMIXER)hmx);
    } // for over mixers

	return MMSYSERR_NOERROR;
}


//****************************************************************************************
CSoundCtl::CSoundCtl() :
    m_dwComponentType(MIXERLINE_COMPONENTTYPE_DST_SPEAKERS)
{
}


/////////////////////////////////////////////////////////////////////////////
// CSoundCtl


STDMETHODIMP CSoundCtl::get_Volume(DWORD *pVal)
{
	return S_OK;
}

STDMETHODIMP CSoundCtl::put_Volume(DWORD newVal)
{
    MMRESULT mmResult;
    
    mmResult = AdjustSound(m_dwComponentType, MIXERCONTROL_CONTROLTYPE_VOLUME, newVal);
    if (mmResult == MMSYSERR_NOERROR)
	    return S_OK;

    return E_FAIL;
}

STDMETHODIMP CSoundCtl::get_Mute(VARIANT_BOOL *pVal)
{
	return S_OK;
}

STDMETHODIMP CSoundCtl::put_Mute(VARIANT_BOOL newVal)
{
    MMRESULT mmResult;
    
    DWORD dwNewVal = (newVal == VARIANT_TRUE ? 1 : 0);

    mmResult = AdjustSound(m_dwComponentType, MIXERCONTROL_CONTROLTYPE_MUTE, dwNewVal);
    if (mmResult == MMSYSERR_NOERROR)
	    return S_OK;

    return E_FAIL;
}

STDMETHODIMP CSoundCtl::get_ComponentType(long *pVal)
{
    *pVal = m_dwComponentType;
	return S_OK;
}

STDMETHODIMP CSoundCtl::put_ComponentType(long newVal)
{
    m_dwComponentType = newVal;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\tvprof\tvprof.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Dec 29 17:37:20 1999
 */
/* Compiler settings for C:\tmp\tvprof\tvprof.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tvprof_h__
#define __tvprof_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITVProfile_FWD_DEFINED__
#define __ITVProfile_FWD_DEFINED__
typedef interface ITVProfile ITVProfile;
#endif 	/* __ITVProfile_FWD_DEFINED__ */


#ifndef __TVProfile_FWD_DEFINED__
#define __TVProfile_FWD_DEFINED__

#ifdef __cplusplus
typedef class TVProfile TVProfile;
#else
typedef struct TVProfile TVProfile;
#endif /* __cplusplus */

#endif 	/* __TVProfile_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ITVProfile_INTERFACE_DEFINED__
#define __ITVProfile_INTERFACE_DEFINED__

/* interface ITVProfile */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITVProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("28B576D7-E966-4393-AAF2-F139B096DD4C")
    ITVProfile : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IPSinkAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AudioDestination( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITVProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITVProfile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITVProfile __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITVProfile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITVProfile __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITVProfile __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITVProfile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITVProfile __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IPSinkAddress )( 
            ITVProfile __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AudioDestination )( 
            ITVProfile __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        END_INTERFACE
    } ITVProfileVtbl;

    interface ITVProfile
    {
        CONST_VTBL struct ITVProfileVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITVProfile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITVProfile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITVProfile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITVProfile_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITVProfile_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITVProfile_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITVProfile_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITVProfile_get_IPSinkAddress(This,pVal)	\
    (This)->lpVtbl -> get_IPSinkAddress(This,pVal)

#define ITVProfile_get_AudioDestination(This,pVal)	\
    (This)->lpVtbl -> get_AudioDestination(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITVProfile_get_IPSinkAddress_Proxy( 
    ITVProfile __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ITVProfile_get_IPSinkAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITVProfile_get_AudioDestination_Proxy( 
    ITVProfile __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB ITVProfile_get_AudioDestination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITVProfile_INTERFACE_DEFINED__ */



#ifndef __TVPROFLib_LIBRARY_DEFINED__
#define __TVPROFLib_LIBRARY_DEFINED__

/* library TVPROFLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_TVPROFLib;

EXTERN_C const CLSID CLSID_TVProfile;

#ifdef __cplusplus

class DECLSPEC_UUID("EB24C040-9E6B-4469-A425-87DCCFFE4395")
TVProfile;
#endif
#endif /* __TVPROFLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\tvprof\tvprof.cpp ===
// tvprof.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f tvprofps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "tvprof.h"

#include "tvprof_i.c"
#include "TVProfile.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TVProfile, CTVProfile)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TVPROFLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\setup\src\setup20\runtime\actmovie\actmovie.cpp ===
// ---------------------------------------------------------------------------------------------
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR
// FITNESS FOR A PARTICULAR PURPOSE.
// Copyright (C) 1997  Microsoft Corporation.  All Rights Reserved.
// ---------------------------------------------------------------------------------------------

#include <windows.h>
//////////////////////////////////////////////////////////////////
WINAPI WinMain (HINSTANCE hInstance, HINSTANCE b, LPSTR c, int d)
//////////////////////////////////////////////////////////////////
{ // WinMain //

    // dummy executable to keep ActiveMovie 1.0 actmovie.exe from
    // being installed and popping up the "file associations wrong"
    // dialog every time a user logs in
    
    return 0;
} // WinMain //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\tvprof\tvprofile.cpp ===
// TVProfile.cpp : Implementation of CTVProfile
#include "stdafx.h"
#include "Tvprof.h"
#include "TVProfile.h"

typedef TCHAR IPADDR_TSTR[4*4];
TCHAR gc_tszPathTVProfile[] = _TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\TVPlayer");
TCHAR gc_tszIPSinkAddress[] = _TEXT("IPSinkAddress");
TCHAR gc_tszAudioDestination[] = _TEXT("AudioDestination");



/////////////////////////////////////////////////////////////////////////////
// CTVProfile


STDMETHODIMP CTVProfile::get_IPSinkAddress(BSTR *pVal)
{
    if (NULL == pVal)
        return E_POINTER;

    HRESULT hr = S_OK;
    HKEY    hKey = NULL;
    LONG    lRes;

    // TODO: Once we expand the list of environment variables, write a function
    // ReadMachineProfile that reads and caches all HKLM variables at once, and
    // call it from here if not already called.

    // Open key
    lRes = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          gc_tszPathTVProfile,
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_QUERY_VALUE,
                          NULL,
                          &hKey,
                          NULL );
    if ((lRes != ERROR_SUCCESS) || (hKey == NULL))
        return E_FAIL;


    IPADDR_TSTR tszData;
    DWORD       cbData;
    DWORD       dwType;

    cbData = sizeof(IPADDR_TSTR);
    lRes = RegQueryValueExA(hKey,
                            gc_tszIPSinkAddress,
                            NULL,
                            &dwType,
                            (LPBYTE)tszData,
                            &cbData);
    RegCloseKey(hKey);

    if (lRes != ERROR_SUCCESS)
    {
        return E_FAIL;
    }
    
    if (dwType != REG_SZ)
    {
        // Registry is messed up. Value of IPStringAddress is not a string.
        return E_FAIL;
    }


#ifdef UNICODE
    *pVal = SysAllocString(tszData);
    if (NULL == *pVal)
    {
        return E_OUTOFMEMORY;
    }

#else
    *pVal = SysAllocStringLen(NULL, cbData); // length of string == cbData
    if (NULL == *pVal)
    {
        return E_OUTOFMEMORY;
    }

    int cConverted = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, tszData, cbData, *pVal, cbData);
    if (0 == cConverted)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
#endif

    return S_OK;
}


//******************************************************************************************
STDMETHODIMP CTVProfile::get_AudioDestination(long *pVal)
{
    if (NULL == pVal)
        return E_POINTER;

    HRESULT hr = S_OK;
    HKEY    hKey = NULL;
    LONG    lRes;

    // Open key
    lRes = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          gc_tszPathTVProfile,
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_QUERY_VALUE,
                          NULL,
                          &hKey,
                          NULL );
    if ((lRes != ERROR_SUCCESS) || (hKey == NULL))
        return E_FAIL;


    DWORD       dwAudioDestination;
    DWORD       cbData;
    DWORD       dwType;

    cbData = sizeof(DWORD);
    lRes = RegQueryValueEx(hKey,
                           gc_tszAudioDestination,
                           NULL,
                           &dwType,
                           (LPBYTE)&dwAudioDestination,
                           &cbData);
    RegCloseKey(hKey);

    if (lRes != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    if (dwType != REG_DWORD)
    {
        // Registry is messed up. Value of AudioDestination is not a dword
        return E_FAIL;
    }

    *pVal  = (long)dwAudioDestination;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\setup\src\setup20\runtime\actmovie\resource.h ===
#define IDS_OCXDESCRIPTION              1
#define IDS_FTAPPLET                    2
#define IDS_ACCESSORIES                 3
#define IDS_MULTIMEDIA                  4
#define IDS_EXTINFO                     6
#define IDS_PROGRAM                     7
#define IDS_CLSID                       8
#define IDS_CONTENTTYPE                 9
#define IDS_DEFAULTICON                 10
#define IDS_EXTENSION_MTYPE_BAK         11
#define IDS_EXTENSION_MIME              12
#define IDS_EXTENSION_MIME_BAK          13
#define IDS_MEDIATYPE_DESC              14
#define IDS_MEDIATYPE_DESC_BAK          15
#define IDS_MEDIATYPE_ICON              16
#define IDS_MEDIATYPE_ICON_BAK          17
#define IDS_MEDIATYPE_MTYPE             18
#define IDS_MEDIATYPE_MTYPE_BAK         19
#define IDS_MEDIATYPE_OPEN_BAK          20
#define IDS_MEDIATYPE_PLAY_BAK          21
#define IDS_MEDIATYPE_VERB_BAK          22
#define IDS_MIMECLSID_BAK               23
#define IDS_MIME_CONTENTLIST            24
#define IDS_SETUP_CLSID                 25
#define IDS_SETUP_OCX                   26
#define IDS_SHELL_OPENCMD               27
#define IDS_SHELL_PLAYCMD               28
#define IDS_SETUP_RUNDLLNT              29
#define IDS_SETUP_RUNDLL95              30
#define IDS_SHELL                       31
#define IDS_SHELL_OPEN                  32
#define IDS_SHELL_PLAY                  33
#define IDS_SENSE_AM10                  34
#define IDS_OSR2PARTIAL                 35
#define IDS_OCXPARAMETERS               37
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\mfvideo\tvplayer\tvprof\tvprofile.h ===
// TVProfile.h : Declaration of the CTVProfile

#ifndef __TVPROFILE_H_
#define __TVPROFILE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CTVProfile
class ATL_NO_VTABLE CTVProfile : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTVProfile, &CLSID_TVProfile>,
	public IDispatchImpl<ITVProfile, &IID_ITVProfile, &LIBID_TVPROFLib>
{
public:
	CTVProfile()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVPROFILE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVProfile)
	COM_INTERFACE_ENTRY(ITVProfile)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ITVProfile
public:
	STDMETHOD(get_AudioDestination)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_IPSinkAddress)(/*[out, retval]*/ BSTR *pVal);
};

#endif //__TVPROFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\audtest\audio.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include <windows.h>
#include <mmsystem.h>
#include <amstream.h>
#include <stdio.h>
#include <initguid.h>
#include <atlbase.h>
#include <atlimpl.cpp>

#define CHECK_ERROR(x)     \
   if (FAILED(hr = (x))) { \
       printf(#x "  failed with HRESULT(0x%8.8X)\n", hr); \
       goto Exit;          \
   }

HRESULT GetAudioFormat(IMultiMediaStream *pMMStream, WAVEFORMATEX *pwfx)
{
    CComPtr<IMediaStream>      pStream;
    CComPtr<IAudioMediaStream> pAudioStream;
    HRESULT hr = pMMStream->GetMediaStream(MSPID_PrimaryAudio, &pStream);
    if (FAILED(hr)) {
        return hr;
    }
    hr =  pStream->QueryInterface(IID_IAudioMediaStream, (void **)&pAudioStream);
    if (FAILED(hr)) {
        return hr;
    }
    return pAudioStream->GetFormat(pwfx);
}

/*  Read a section from an MMStream into a buffer */
HRESULT ReadSection(
    IMultiMediaStream *pMMStream,
    DWORD          dwBufferIncrement,
    REFERENCE_TIME rtStart,
    REFERENCE_TIME rtStop,
    REFERENCE_TIME *prtStart,
    REFERENCE_TIME *prtStop,
    HLOCAL         *phData,
    DWORD          *dwLength
)
{
    HRESULT hr = S_OK;
    *phData = NULL;
    CComPtr<IMediaStream>      pStream;
    CComPtr<IAudioMediaStream> pAudioStream;
    CComPtr<IAudioData>        pAudioData;
    CComPtr<IAudioStreamSample> pSample;
    WAVEFORMATEX               wfx;
    _ASSERTE(rtStart <= rtStop);
    DWORD                      dwSize = 0;
    HLOCAL                     hData = LocalAlloc(LMEM_MOVEABLE, dwBufferIncrement);
    bool bFirst = true;

    #define SEEKDELTA 1000000
    CHECK_ERROR(pMMStream->Seek(rtStart < SEEKDELTA ? 0 : rtStart - SEEKDELTA));
    CHECK_ERROR(pMMStream->GetMediaStream(MSPID_PrimaryAudio, &pStream));
    CHECK_ERROR(pStream->QueryInterface(IID_IAudioMediaStream, (void **)&pAudioStream));
    CHECK_ERROR(pAudioStream->GetFormat(&wfx));
    CHECK_ERROR(CoCreateInstance(CLSID_AMAudioData, NULL, CLSCTX_INPROC_SERVER,
                     IID_IAudioData, (void **)&pAudioData));
    CHECK_ERROR(pAudioData->SetFormat(&wfx));
    CHECK_ERROR(pAudioStream->CreateSample(pAudioData, 0, &pSample));

    for (; ; ) {
        _ASSERTE(hData != NULL);
        PBYTE pbData = (PBYTE)LocalLock(hData);
        pAudioData->SetBuffer(dwBufferIncrement, pbData + dwSize, 0);
        HRESULT hr = pSample->Update(0, NULL, NULL, 0);
        LocalUnlock(hData);
        if (S_OK != hr) {
            printf("Update returned 0x%8.8x\n", hr);
            break;
        }
        CHECK_ERROR(pSample->GetSampleTimes(bFirst ? prtStart : NULL, prtStop, NULL));
        DWORD dwLength;
        pAudioData->GetInfo(NULL, NULL, &dwLength);
        dwSize += dwLength;
        hData = LocalReAlloc(hData,
                             LocalSize(hData) + dwBufferIncrement,
                             LMEM_MOVEABLE);
        bFirst = false;
        if (*prtStop >= rtStop) {
            break;
        }
    }
    *dwLength = dwSize;
    *phData = hData;
Exit:
    if (FAILED(hr)) {
        LocalFree(hData);
    }
    return hr;
}



HRESULT RenderFileToMMStream(WCHAR * pszFileName, IMultiMediaStream **ppMMStream)
{
    IAMMultiMediaStream *pAMStream;
    CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER,
                     IID_IAMMultiMediaStream, (void **)&pAMStream);
    pAMStream->Initialize(STREAMTYPE_READ, 0, NULL);
    pAMStream->AddMediaStream(NULL, &MSPID_PrimaryAudio, 0, NULL);
    pAMStream->OpenFile(pszFileName, AMMSF_RUN | AMMSF_NOCLOCK);
    *ppMMStream = pAMStream;
    return S_OK;
}

typedef struct {
    REFERENCE_TIME rtStartIntended;
    REFERENCE_TIME rtEndIntended;
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtEnd;
    DWORD          dwByteStart;
    DWORD          dwByteEnd;
    DWORD          dwLength;
    HGLOBAL        hData;
} AUDIO_SECTION;

int _CRTAPI1 main(int argc, char *argv[])
{
    if (argc < 4) {
        printf("Usage : audtest foo.bar n foo.out\n"
               "  splits up foo.bar into n sections and writes\n"
               "  it out in PCM format to foo.out\n");
        exit(0);
    }
    IMultiMediaStream *pMMStream;
    CoInitialize(NULL);
    WCHAR wszName[1000];
    MultiByteToWideChar(CP_ACP, 0, argv[1], -1, wszName,
                        sizeof(wszName) / sizeof(wszName[0]));
    RenderFileToMMStream(wszName, &pMMStream);
    int NumSections = atoi(argv[2]);

    STREAM_TIME Duration;
    pMMStream->GetDuration(&Duration);

    WAVEFORMATEX wfx;
    GetAudioFormat(pMMStream, &wfx);

    DWORD dwDataSize = 0;

    /*  Read 2 sections */
    AUDIO_SECTION *Sections = new AUDIO_SECTION[NumSections];
    for (int i = 0; i < NumSections; i++) {
        Sections[i].rtStartIntended = Duration * i / NumSections;
        Sections[i].rtEndIntended = Duration * (i + 1) / NumSections;
        ReadSection(pMMStream,
                    5000,
                    Sections[i].rtStartIntended,
                    Sections[i].rtEndIntended,
                    &Sections[i].rtStart,
                    &Sections[i].rtEnd,
                    &Sections[i].hData,
                    &Sections[i].dwLength);
        Sections[i].dwByteStart = 0;
        Sections[i].dwByteEnd = Sections[i].dwLength;
        if (Sections[i].rtStart < Sections[i].rtStartIntended) {
            DWORD dwOffset = (DWORD)(
                             (Sections[i].rtStartIntended -
                              Sections[i].rtStart) * wfx.nSamplesPerSec /
                              10000000);
            dwOffset *= wfx.nBlockAlign;
            if (dwOffset > Sections[i].dwLength) {
                dwOffset = Sections[i].dwLength;
            }
            Sections[i].dwByteStart = dwOffset;
        }
        if (Sections[i].rtEnd > Sections[i].rtEndIntended) {
            DWORD dwOffset = (DWORD)(
                             (Sections[i].rtEnd -
                              Sections[i].rtEndIntended) * wfx.nSamplesPerSec /
                              10000000);
            dwOffset *= wfx.nBlockAlign;
            if (dwOffset > Sections[i].dwLength) {
                dwOffset = Sections[i].dwLength;
            }
            Sections[i].dwByteEnd -= dwOffset;
            if (Sections[i].dwByteEnd < Sections[i].dwByteStart) {
                Sections[i].dwByteEnd = Sections[i].dwByteStart;
            }
        }
        dwDataSize += Sections[i].dwByteEnd - Sections[i].dwByteStart;
    }
//#define DUMP_SECTIONS
#ifdef DUMP_SECTIONS
    printf("File is %d milliseconds long\n", (int)(Duration / 10000));
    for (i = 0; i < NumSections; i++) {
        printf("Section %d Bytes %d Bytes time %d\n\n"
               "           Start %d        Stop        %d\n"
               "           Start Actual %d Stop Actual %d\n\n",
               i, Sections[i].dwByteEnd - Sections[i].dwByteStart,
               MulDiv(Sections[i].dwByteEnd - Sections[i].dwByteStart,
                      1000,
                      wfx.nAvgBytesPerSec),
               (int)(Sections[i].rtStartIntended / 10000),
               (int)(Sections[i].rtEndIntended / 10000),
               (int)(Sections[i].rtStart / 10000),
               (int)(Sections[i].rtEnd / 10000));
    }
#endif

    /*  Now output a wave file */
    HANDLE hFileWrite = CreateFile(argv[3],
                                   GENERIC_WRITE,
                                   0,
                                   NULL,
                                   CREATE_ALWAYS,
                                   0,
                                   NULL);

    if (INVALID_HANDLE_VALUE == hFileWrite) {
        printf("Could not open output file %s\n", argv[3]);
        exit(0);
    }

    DWORD dwBytesWritten;
#pragma pack(1)
    typedef struct tagMyHeader {
        DWORD dwRIFF;
        DWORD cbSize;
        DWORD dwWAVE;
        DWORD dwfmt;
        DWORD cbSizeFormat;
        WAVEFORMATEX Format;
        DWORD dwDATA;
        DWORD cbData;
    } MyHeader;
    MyHeader Header;
#pragma pack()
    Header.dwRIFF = MAKEFOURCC('R','I','F','F');
    Header.cbSize = dwDataSize +
                    (sizeof(Header) - FIELD_OFFSET(MyHeader, dwWAVE));
    Header.dwWAVE = MAKEFOURCC('W','A','V','E');
    Header.dwfmt = MAKEFOURCC('f','m','t',' ');
    Header.cbSizeFormat = sizeof(Header.Format);
    Header.Format = wfx;
    Header.dwDATA = MAKEFOURCC('d','a','t','a');
    Header.cbData = dwDataSize;
    WriteFile(hFileWrite,  &Header, sizeof(Header),&dwBytesWritten,
              NULL);
    if (dwBytesWritten != sizeof(Header)) {
        printf("couldn't write output file %s\n", argv[3]);
        exit(0);
    }

    for (i = 0; i < NumSections; i++) {
        PBYTE pbData = (PBYTE)LocalLock(Sections[i].hData);
        WriteFile(hFileWrite,
                  pbData + Sections[i].dwByteStart,
                  Sections[i].dwByteEnd - Sections[i].dwByteStart,
                  &dwBytesWritten,
                  NULL);
    }

    CloseHandle(hFileWrite);

    pMMStream->Release();
    for (i = 0; i < NumSections; i++) {
        LocalFree(Sections[i].hData);
    }
    delete [] Sections;
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\audio\audio.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include <windows.h>
#include <mmsystem.h>
#include <amstream.h>
#include <stdio.h>

/********************************************************************

   Trivial wave player stuff

 ********************************************************************/

class CWaveBuffer;

class CWaveBuffer {
    public:
        CWaveBuffer();
        ~CWaveBuffer();
        BOOL Init(HWAVEOUT hWave, int Size);
        void Done();
        BOOL Write(PBYTE pData, int nBytes, int& BytesWritten);
        void Flush();

    private:
        WAVEHDR      m_Hdr;
        HWAVEOUT     m_hWave;
        int          m_nBytes;
};

class CWaveOut {
    public:
        CWaveOut(LPCWAVEFORMATEX Format, int nBuffers, int BufferSize);
        ~CWaveOut();
        void Write(PBYTE Data, int nBytes);
        void Flush();
        void Wait();
        void Reset();
    private:
        const HANDLE       m_hSem;
        const int          m_nBuffers;
              int          m_CurrentBuffer;
              BOOL         m_NoBuffer;
              CWaveBuffer *m_Hdrs;
              HWAVEOUT     m_hWave;
};

/*
    CWaveBuffer
*/

CWaveBuffer::CWaveBuffer()
{
}

BOOL CWaveBuffer::Init(HWAVEOUT hWave, int Size)
{
    m_hWave  = hWave;
    m_nBytes = 0;

    /*  Allocate a buffer and initialize the header */
    m_Hdr.lpData = (LPSTR)LocalAlloc(LMEM_FIXED, Size);
    if (m_Hdr.lpData == NULL) {
        return FALSE;
    }
    m_Hdr.dwBufferLength  = Size;
    m_Hdr.dwBytesRecorded = 0;
    m_Hdr.dwUser = 0;
    m_Hdr.dwFlags = 0;
    m_Hdr.dwLoops = 0;
    m_Hdr.lpNext = 0;
    m_Hdr.reserved = 0;

    /*  Prepare it */
    waveOutPrepareHeader(hWave, &m_Hdr, sizeof(WAVEHDR));

    return TRUE;
}

CWaveBuffer::~CWaveBuffer() {
    if (m_Hdr.lpData) {
        waveOutUnprepareHeader(m_hWave, &m_Hdr, sizeof(WAVEHDR));
        LocalFree(m_Hdr.lpData);
    }
}

void CWaveBuffer::Flush()
{
    //ASSERT(m_nBytes != 0);
    m_nBytes = 0;
    waveOutWrite(m_hWave, &m_Hdr, sizeof(WAVEHDR));
}

BOOL CWaveBuffer::Write(PBYTE pData, int nBytes, int& BytesWritten)
{
    //ASSERT((DWORD)m_nBytes != m_Hdr.dwBufferLength);
    BytesWritten = min((int)m_Hdr.dwBufferLength - m_nBytes, nBytes);
    CopyMemory((PVOID)(m_Hdr.lpData + m_nBytes), (PVOID)pData, BytesWritten);
    m_nBytes += BytesWritten;
    if (m_nBytes == (int)m_Hdr.dwBufferLength) {
        /*  Write it! */
        m_nBytes = 0;
        waveOutWrite(m_hWave, &m_Hdr, sizeof(WAVEHDR));
        return TRUE;
    }
    return FALSE;
}

void CALLBACK WaveCallback(HWAVEOUT hWave, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2)
{
    if (uMsg == WOM_DONE) {
        ReleaseSemaphore((HANDLE)dwUser, 1, NULL);
    }
}

/*
    CWaveOut
*/

CWaveOut::CWaveOut(LPCWAVEFORMATEX Format, int nBuffers, int BufferSize) :
    m_nBuffers(nBuffers),
    m_CurrentBuffer(0),
    m_NoBuffer(TRUE),
    m_hSem(CreateSemaphore(NULL, nBuffers, nBuffers, NULL)),
    m_Hdrs(new CWaveBuffer[nBuffers]),
    m_hWave(NULL)
{
    /*  Create wave device */
    waveOutOpen(&m_hWave,
                WAVE_MAPPER,
                Format,
                (DWORD)WaveCallback,
                (DWORD)m_hSem,
                CALLBACK_FUNCTION);

    /*  Initialize the wave buffers */
    for (int i = 0; i < nBuffers; i++) {
        m_Hdrs[i].Init(m_hWave, BufferSize);
    }
}

CWaveOut::~CWaveOut()
{
    /*  First get our buffers back */
    waveOutReset(m_hWave);

    /*  Free the buffers */
    delete [] m_Hdrs;

    /*  Close the wave device */
    waveOutClose(m_hWave);

    /*  Free our semaphore */
    CloseHandle(m_hSem);
}

void CWaveOut::Flush()
{
    if (!m_NoBuffer) {
        m_Hdrs[m_CurrentBuffer].Flush();
        m_NoBuffer = TRUE;
        m_CurrentBuffer = (m_CurrentBuffer + 1) % m_nBuffers;
    }
}

void CWaveOut::Reset()
{
    waveOutReset(m_hWave);
}


void CWaveOut::Write(PBYTE pData, int nBytes)
{
    while (nBytes != 0) {
        /*  Get a buffer if necessary */
        if (m_NoBuffer) {
            WaitForSingleObject(m_hSem, INFINITE);
            m_NoBuffer = FALSE;
        }

        /*  Write into a buffer */
        int nWritten;
        if (m_Hdrs[m_CurrentBuffer].Write(pData, nBytes, nWritten)) {
            m_NoBuffer = TRUE;
            m_CurrentBuffer = (m_CurrentBuffer + 1) % m_nBuffers;
            nBytes -= nWritten;
            pData += nWritten;
        } else {
            //ASSERT(nWritten == nBytes);
            break;
        }
    }
}

void CWaveOut::Wait()
{
    /*  Send any remaining buffers */
    Flush();

    /*  Wait for our buffers back */
    for (int i = 0; i < m_nBuffers; i++) {
        WaitForSingleObject(m_hSem, INFINITE);
    }
    LONG lPrevCount;
    ReleaseSemaphore(m_hSem, m_nBuffers, &lPrevCount);
}

/**************************************************************************

  End of wave player stuff

 **************************************************************************/


HRESULT RenderStreamToDevice(IMultiMediaStream *pMMStream)
{
    WAVEFORMATEX wfx;
    #define DATA_SIZE 5000
    PBYTE pBuffer = (PBYTE)LocalAlloc(LMEM_FIXED, DATA_SIZE);

    IMediaStream *pStream;
    IAudioStreamSample *pSample;
    IAudioMediaStream *pAudioStream;
    IAudioData *pAudioData;

    pMMStream->GetMediaStream(MSPID_PrimaryAudio, &pStream);
    pStream->QueryInterface(IID_IAudioMediaStream, (void **)&pAudioStream);
    pAudioStream->GetFormat(&wfx);
    CoCreateInstance(CLSID_AMAudioData, NULL, CLSCTX_INPROC_SERVER,
                     IID_IAudioData, (void **)&pAudioData);
    pAudioData->SetBuffer(DATA_SIZE, pBuffer, 0);
    pAudioData->SetFormat(&wfx);
    pAudioStream->CreateSample(pAudioData, 0, &pSample);
    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    CWaveOut WaveOut(&wfx, 4, 2048);
    int iTimes;
    DWORD dwLength = 0;
    for (iTimes = 0; iTimes < 3; iTimes++) {
        for (; ; ) {
            HRESULT hr = pSample->Update(0, hEvent, NULL, 0);
            WaitForSingleObject(hEvent, INFINITE);
            pAudioData->GetInfo(NULL, NULL, &dwLength);
            printf("%d bytes in buffer\n", dwLength);
            WaveOut.Write(pBuffer, dwLength);
            hr = pSample->CompletionStatus(0, 0);
            if (hr != S_OK) {
                printf("Completion status %8.8x\n", hr);
                break;
            }
        }
        HANDLE hComplete;
        pMMStream->GetEndOfStreamEventHandle(&hComplete);
        WaitForSingleObject(hComplete, INFINITE);
        pMMStream->Seek(0);
    }

    pAudioData->Release();
    pSample->Release();
    pStream->Release();
    pAudioStream->Release();
    LocalFree((HLOCAL)pBuffer);

    return S_OK;
}

HRESULT RenderFileToMMStream(WCHAR * pszFileName, IMultiMediaStream **ppMMStream)
{
    IAMMultiMediaStream *pAMStream;
    CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER,
                     IID_IAMMultiMediaStream, (void **)&pAMStream);
    pAMStream->Initialize(STREAMTYPE_READ, AMMSF_NOGRAPHTHREAD, NULL);
    pAMStream->AddMediaStream(NULL, &MSPID_PrimaryAudio, 0, NULL);
    pAMStream->OpenFile(pszFileName, AMMSF_RUN);
    *ppMMStream = pAMStream;
    return S_OK;
}

int _CRTAPI1 main(int argc, char *argv[])
{
    IMultiMediaStream *pMMStream;
    CoInitialize(NULL);
    WCHAR wszName[1000];
    MultiByteToWideChar(CP_ACP, 0, argv[1], -1, wszName,
                        sizeof(wszName) / sizeof(wszName[0]));
    RenderFileToMMStream(wszName, &pMMStream);
    RenderStreamToDevice(pMMStream);
    pMMStream->Release();
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\cutlist\main.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#define INITGUID
#include <windows.h>
#include <stdio.h>
#include "ddraw.h"
#include "mmstream.h"
#include "amstream.h"
#include "ddstream.h"


#define RELEASE(x) if (x) (x)->Release();
#define CHECK_ERROR(x) if (FAILED(hr = (x))) goto Exit;


HRESULT OpenMMStream(const char * pszFileName, IDirectDraw *pDD, IMultiMediaStream **ppMMStream)
{
    *ppMMStream = NULL;
    IAMMultiMediaStream *pAMStream;
    HRESULT hr;

    CHECK_ERROR(CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER,
                                 IID_IAMMultiMediaStream, (void **)&pAMStream));
    CHECK_ERROR(pAMStream->Initialize(STREAMTYPE_READ, NULL));
    CHECK_ERROR(pAMStream->AddMediaStream(pDD, MSPID_PrimaryVideo, 0, NULL));
    ///CHECK_ERROR(pAMStream->AddMediaStream(NULL, MSPID_PrimaryAudio, AMMSF_ADDDEFAULTRENDERER, NULL));

    WCHAR	wPath[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, pszFileName, -1, wPath, sizeof(wPath)/sizeof(wPath[0]));

    CHECK_ERROR(pAMStream->OpenFile(wPath, AMMSF_NOCLOCK));

    *ppMMStream = pAMStream;
    pAMStream->AddRef();

Exit:
    RELEASE(pAMStream);
    return hr;
}




HRESULT RenderStreamToSurface(IDirectDraw *pDD, IDirectDrawSurface *pSurface, IMultiMediaStream *pMMStream,
                              STREAM_TIME TimeEnd)
{

    HRESULT hr;
    IMediaStream *pPrimaryVidStream = NULL;
    IDirectDrawMediaStream *pDDStream = NULL;
    IDirectDrawStreamSample *pSample = NULL;
    
    CHECK_ERROR(pMMStream->GetMediaStream(MSPID_PrimaryVideo, &pPrimaryVidStream));
    CHECK_ERROR(pPrimaryVidStream->QueryInterface(IID_IDirectDrawMediaStream, (void **)&pDDStream));
    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);

    CHECK_ERROR(pDDStream->GetFormat(&ddsd, NULL, NULL));
    RECT rect;
    rect.top = rect.left = 0;
    rect.bottom = ddsd.dwHeight;
    rect.right = ddsd.dwWidth;

    CHECK_ERROR(pDDStream->CreateSample(pSurface, &rect, 0, &pSample));
    
    STREAM_TIME SampleEnd;
    do {
        if (pSample->Update(0, NULL, NULL, 0) != S_OK) {
            break;
        }
        pSample->GetSampleTimes(NULL, &SampleEnd, NULL);
    } while (SampleEnd < TimeEnd);

Exit:
    RELEASE(pPrimaryVidStream);
    RELEASE(pDDStream);
    RELEASE(pSample);

    return hr;
}


typedef struct {
    char szName[MAX_PATH];
    STREAM_TIME TimeStart;
    STREAM_TIME TimeEnd;
} CUTLIST_ENTRY;

#define SECOND(x) (x * 1000 * 10000)

#define ARRAYSIZE(x) (sizeof(x) / sizeof((x)[0]))

CUTLIST_ENTRY g_CutList[] = {
    { "C:\\MOVIES\\BELUSHI1.MPG", SECOND(0), SECOND(5) },
    { "C:\\MOVIES\\ZIMA.MPG", SECOND(20), SECOND(30) },
    { "C:\\MOVIES\\BELUSHI3.MPG", SECOND(5), SECOND(10) }
};


int _CRTAPI1
main(
    int argc,
    char *argv[]
    )
{
    CoInitialize(NULL);
    IDirectDraw *pDD;

    HRESULT hr = DirectDrawCreate(NULL, &pDD, NULL);
    if (SUCCEEDED(hr)) {
    	DDSURFACEDESC ddsd;
    	IDirectDrawSurface *pPrimarySurface;

    	pDD->SetCooperativeLevel(GetDesktopWindow(), DDSCL_NORMAL);

    	ddsd.dwSize = sizeof(ddsd);
    	ddsd.dwFlags = DDSD_CAPS;
    	ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
    	hr = pDD->CreateSurface(&ddsd, &pPrimarySurface, NULL);
    	if (SUCCEEDED(hr)) {
            int i;
            IMultiMediaStream *apCut[ARRAYSIZE(g_CutList)] = {0};
            for (i = 0; i < ARRAYSIZE(g_CutList); i++) {
                if (FAILED(OpenMMStream(g_CutList[i].szName, pDD, &apCut[i]))) {
                    break;
                }
                apCut[i]->Seek(g_CutList[i].TimeStart);
                Sleep(500);
            }
            for (i = 0; i < ARRAYSIZE(apCut); i++) {
                if (apCut[i]) {
                    RenderStreamToSurface(pDD, pPrimarySurface, apCut[i], g_CutList[i].TimeEnd);
                    apCut[i]->Release();
                } else {
                    break;
                }
            }
    	    pPrimarySurface->Release();
    	}
    	pDD->Release();
    }
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\austrm.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// austrm.cpp : Implementation of CAudioStream
#include "stdafx.h"
#include "project.h"
#include "austrm.h"

//  Helper
void SetWaveFormatEx(
    LPWAVEFORMATEX pFormat,
    int nChannels,
    int nBitsPerSample,
    int nSamplesPerSecond
)
{
    pFormat->wFormatTag = WAVE_FORMAT_PCM;
    pFormat->nChannels  = (WORD)nChannels;
    pFormat->nSamplesPerSec = (DWORD)nSamplesPerSecond;
    pFormat->nBlockAlign = (WORD)((nBitsPerSample * nChannels) / 8);
    pFormat->nAvgBytesPerSec = (DWORD)(nSamplesPerSecond * pFormat->nBlockAlign);
    pFormat->wBitsPerSample = (WORD)nBitsPerSample;
    pFormat->cbSize = 0;
}

HRESULT ConvertWAVEFORMATEXToMediaType(
    const WAVEFORMATEX *pFormat,
    AM_MEDIA_TYPE **ppmt
)
{
    AM_MEDIA_TYPE *pmt;
    pmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(*pmt));
    if (pmt == NULL) {
        return E_OUTOFMEMORY;
    }
    _ASSERTE(pFormat->wFormatTag == WAVE_FORMAT_PCM);
    ZeroMemory(pmt, sizeof(*pmt));
    pmt->majortype = MEDIATYPE_Audio;
    pmt->formattype = FORMAT_WaveFormatEx;
    pmt->bFixedSizeSamples = TRUE;
    pmt->lSampleSize = pFormat->nBlockAlign;
    pmt->cbFormat = sizeof(*pFormat);
    pmt->pbFormat = (PBYTE)CoTaskMemAlloc(sizeof(*pFormat));
    if (pmt->pbFormat == NULL) {
        CoTaskMemFree(pmt);
        return E_OUTOFMEMORY;
    }
    CopyMemory(pmt->pbFormat, pFormat, sizeof(*pFormat));
    *ppmt = pmt;
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioStream

CAudioStream::CAudioStream() :
        m_fForceFormat(false)
{
    //  Set to mono 16bit PCM 11025Hz
    SetWaveFormatEx(&m_Format, 1, 16, 11025);
}

STDMETHODIMP
CAudioStream::ReceiveConnection(
    IPin * pConnector,
    const AM_MEDIA_TYPE *pmt
)
{
    AUTO_CRIT_LOCK;
    //
    //  This helper function in CStream checks basic parameters for the Pin such as
    //  the connecting pin's direction (we need to check this -- Sometimes the filter
    //  graph will try to connect us to ourselves!) and other errors like already being
    //  connected, etc.
    //
    HRESULT hr = CheckReceiveConnectionPin(pConnector);
    if (hr == NOERROR) {
        /*  Accept only the format we've been given.  If we
            haven't been given a format accept PCM only
        */
        if (pmt->majortype != MEDIATYPE_Audio ||
            pmt->formattype != FORMAT_WaveFormatEx ||
            pmt->cbFormat < sizeof(WAVEFORMATEX)) {
            hr = VFW_E_TYPE_NOT_ACCEPTED;
        } else {
            hr = InternalSetFormat((LPWAVEFORMATEX)pmt->pbFormat, true);
            if (SUCCEEDED(hr)) {
                CopyMediaType(&m_ConnectedMediaType, pmt);
                m_pConnectedPin = pConnector;
            }
        }
    }
    return hr;
}

STDMETHODIMP CAudioStream::SetSameFormat(IMediaStream *pStream, DWORD dwFlags)
{
    CComQIPtr<IAudioMediaStream, &IID_IAudioMediaStream> pSource(pStream);
    if (!pSource) {
        return MS_E_INCOMPATIBLE;
    }
    WAVEFORMATEX wfx;
    HRESULT hr = pSource->GetFormat(&wfx);
    if (SUCCEEDED(hr)) {
        hr = SetFormat(&wfx);
    }
    return hr;
}

STDMETHODIMP CAudioStream::AllocateSample(DWORD dwFlags, IStreamSample **ppNewSample)
{
    IAudioStreamSample *pSample = NULL;
    IAudioData *pAudioData;
    HRESULT hr = CoCreateInstance(CLSID_AMAudioData, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IAudioData, (void **)&pAudioData);
    if (SUCCEEDED(hr)) {
        //  Pick a sensible buffer size - 1/10 second
        DWORD dwBufferSize = m_Format.nAvgBytesPerSec / 10 +
                             m_Format.nBlockAlign - 1;
        dwBufferSize -= dwBufferSize % m_Format.nBlockAlign;
        pAudioData->SetBuffer(dwBufferSize, NULL, 0);
        pAudioData->SetFormat(&m_Format);
        hr = CreateSample(pAudioData, 0, &pSample);
    }
    *ppNewSample = pSample;
    return hr;
}

STDMETHODIMP CAudioStream::CreateSharedSample(
    /* [in] */ IStreamSample *pExistingSample,
                DWORD dwFlags,
    /* [out] */ IStreamSample **ppNewSample
)
{
    AUTO_CRIT_LOCK;
    //  See if we can get the information we need from the existing
    //  sample
    IAudioStreamSample *pAudioSample;
    HRESULT hr = pExistingSample->QueryInterface(
                     IID_IAudioStreamSample,
                     (void **)&pAudioSample);
    if (FAILED(hr)) {
        return hr;
    }
    IAudioData *pAudioData;
    hr = pAudioSample->GetAudioData(&pAudioData);
    pAudioSample->Release();
    if (FAILED(hr)) {
        return hr;
    }
    IAudioStreamSample *pNewSample;
    hr = CreateSample(pAudioData, 0, &pNewSample);
    pAudioData->Release();
    if (FAILED(hr)) {
        return hr;
    }
    hr = pNewSample->QueryInterface(IID_IStreamSample, (void**)ppNewSample);
    pNewSample->Release();
    return hr;
}

STDMETHODIMP CAudioStream::SetFormat(const WAVEFORMATEX *pFormat)
{
    if (pFormat == NULL) {
        return E_POINTER;
    }
    AUTO_CRIT_LOCK;
    return InternalSetFormat(pFormat, false);
}
STDMETHODIMP CAudioStream::GetFormat(LPWAVEFORMATEX pFormat)
{
    if (pFormat == NULL) {
        return E_POINTER;
    }
    if (!m_pConnectedPin) {
        return MS_E_NOSTREAM;
    }

    *pFormat = m_Format;
    return S_OK;
}

STDMETHODIMP CAudioStream::CreateSample(
        /* [in] */ IAudioData *pAudioData,
        /* [in] */ DWORD dwFlags,
        /* [out] */ IAudioStreamSample **ppSample
)
{
    if (dwFlags != 0) {
        return E_INVALIDARG;
    }
    if (pAudioData == NULL || ppSample == NULL) {
        return E_POINTER;
    }
    AUTO_CRIT_LOCK;
    //  Check the format
    WAVEFORMATEX wfx;
    HRESULT hr = pAudioData->GetFormat(&wfx);
    if (FAILED(hr)) {
        return hr;
    }
    hr = CheckFormat(&wfx);
    if (FAILED(hr)) {
        return hr;
    }
    typedef CComObject<CAudioStreamSample> _AudioSample;
    _AudioSample *pSample = new _AudioSample;
    if (pSample == NULL) {
        return E_OUTOFMEMORY;
    }
    hr = pSample->Init(pAudioData);
    if (FAILED(hr)) {
        return hr;
    }
    pSample->InitSample(this, false);
    return pSample->GetControllingUnknown()->QueryInterface(
        IID_IAudioStreamSample, (void **)ppSample
    );
}

HRESULT CAudioStream::CheckFormat(const WAVEFORMATEX *lpFormat, bool bForceFormat)
{
    if (lpFormat->wFormatTag != WAVE_FORMAT_PCM ||
        lpFormat->nBlockAlign == 0) {
        return E_INVALIDARG;
    }
    if ((m_pConnectedPin || bForceFormat) &&
        0 != memcmp(lpFormat, &m_Format, sizeof(m_Format)))
    {
        //  Try reconnection!
        return E_INVALIDARG;
    }
    return S_OK;
}
HRESULT CAudioStream::InternalSetFormat(const WAVEFORMATEX *lpFormat, bool bFromPin)
{
    HRESULT hr = CheckFormat(lpFormat, m_fForceFormat);
    if (FAILED(hr)) {
        return hr;
    }
    m_Format = *lpFormat;
    m_lBytesPerSecond = m_Format.nAvgBytesPerSec;
    if(!bFromPin) {
        m_fForceFormat = true;
    }
    return S_OK;
}


//
// Special CStream methods
//
HRESULT CAudioStream::GetMediaType(ULONG Index, AM_MEDIA_TYPE **ppMediaType)
{
    if (Index != 0) {
        return S_FALSE;
    }
    return ConvertWAVEFORMATEXToMediaType(&m_Format, ppMediaType);
}

//////////////////////////////////////////////////////////////////////
//  CAudioData
CAudioData::CAudioData() :
    m_cbSize(0),
    m_pbData(0),
    m_cbData(0),
    m_bWeAllocatedData(false)
{
    //  Set to mono 16bit PCM 11025Hz
    SetWaveFormatEx(&m_Format, 1, 16, 11025);
}

CAudioData::~CAudioData()
{
    if (m_bWeAllocatedData) {
        CoTaskMemFree(m_pbData);
    }
}


STDMETHODIMP CAudioStream::GetProperties(ALLOCATOR_PROPERTIES* pProps)
{
    AUTO_CRIT_LOCK;

    //  NB TAPI relies on this number as a max for now when
    //  we're connected to the AVI Mux which uses this size to
    //  create its own samples
    pProps->cbBuffer = CAudioStream::GetChopSize();

    //  Default to 5 buffers (half a second at our default buffer size)
    pProps->cBuffers = m_lRequestedBufferCount ? m_lRequestedBufferCount : 5;
    pProps->cbAlign = 1;
    pProps->cbPrefix = 0;
    return NOERROR;
}

STDMETHODIMP CAudioStream::SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual)
{
    HRESULT hr;

    AUTO_CRIT_LOCK;
    ZeroMemory(pActual, sizeof(*pActual));
    if (pRequest->cbAlign == 0) {
    	hr = VFW_E_BADALIGN;
    } else {
        if (m_bCommitted == TRUE) {
    	    hr = VFW_E_ALREADY_COMMITTED;
    	} else {
            m_lRequestedBufferCount = pRequest->cBuffers;
            hr = GetProperties(pActual);
    	}
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\crtfree.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//
// Code to help free modules from the bondage and tyranny of CRT libraries
//
// Include this header in a single component and #define CPP_FUNCTIONS
//


#if defined(__cplusplus) && defined(CPP_FUNCTIONS)

void *  __cdecl operator new(unsigned int nSize)
    {
    // Zero init just to save some headaches
    return((LPVOID)LocalAlloc(LPTR, nSize));
    }


void  __cdecl operator delete(void *pv)
    {
    LocalFree((HLOCAL)pv);
    }

extern "C" int __cdecl _purecall(void) {return 0;}

#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(DEFINE_FLOAT_STUFF)
// If you aren't using any floating-point CRT functions and you know
// you aren't performing any float conversions or arithmetic, yet the
// linker wants these symbols declared, then define DEFINE_FLOAT_STUFF.
//
// Warning: declaring these symbols in a component that needs floating
// point support from the CRT will produce undefined results.  (You will
// need fp support from the CRT if you simply perform fp arithmetic.)

int _fltused = 0;
void __cdecl _fpmath(void) { }
#endif

#ifdef __cplusplus
};
#endif

//
// This file should be included in a global component header
// to use the following
//

#ifndef __CRTFREE_H_
#define __CRTFREE_H_

#ifdef __cplusplus

#ifndef _M_PPC
#pragma intrinsic(memcpy)
#pragma intrinsic(memcmp)
#pragma intrinsic(memset)
#endif

#endif

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\ddsample.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// Sample.cpp: implementation of the DirectDraw Sample class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "project.h"

#define m_pDDStream ((CDDStream *)m_pStream)

CDDSample::CDDSample() :
    m_pSurface(NULL),
    m_lLastSurfacePitch(0),
    m_bFormatChanged(false),
    m_lImageSize(0),
    m_pvLockedSurfacePtr(0)
{
}

HRESULT CDDSample::InitSample(CStream *pStream, IDirectDrawSurface *pSurface, const RECT *pRect, bool bIsProgressiveRender, bool bIsInternal,
                              bool bTemp)
{
    m_pMediaSample = new CDDMediaSample(this);
    if (!m_pMediaSample) {
        return E_OUTOFMEMORY;
    }
    HRESULT hr = CSample::InitSample(pStream, bIsInternal);
    if (FAILED(hr)) {
        return hr;
    }
    m_pSurface = pSurface;  // Auto addref since CComPtr
    m_Rect = *pRect;
    m_bProgressiveRender = bIsProgressiveRender;
    m_bTemp = bTemp;
    return S_OK;
}

//
// IDirectDrawStreamSample
//
STDMETHODIMP CDDSample::GetSurface(IDirectDrawSurface **ppDirectDrawSurface, RECT * pRect)
{
    TRACEINTERFACE(_T("IDirectDrawStreamSample::GetSurface(0x%8.8X, 0x%8.8X)\n"),
                   ppDirectDrawSurface, pRect);
    AUTO_SAMPLE_LOCK;
    if (ppDirectDrawSurface) {
        *ppDirectDrawSurface = m_pSurface;
        (*ppDirectDrawSurface)->AddRef();
    }
    if (pRect) {
        *pRect = m_Rect;
    }
    return S_OK;
}


STDMETHODIMP CDDSample::SetRect(const RECT * pRect)
{
    TRACEINTERFACE(_T("IDirectDrawStreamSample::SetRect(0x%8.8X)\n"),
                   pRect);
    HRESULT hr;
    if (!pRect) {
        hr = E_POINTER;
    } else {
        DDSURFACEDESC ddsd;
        ddsd.dwSize = sizeof(ddsd);
        hr = m_pSurface->GetSurfaceDesc(&ddsd);
        if (SUCCEEDED(hr)) {
            if (pRect->right > (LONG)ddsd.dwWidth ||
                pRect->bottom > (LONG)ddsd.dwHeight ||
                pRect->right - pRect->left != m_pDDStream->m_Width ||
                pRect->bottom - pRect->top != m_pDDStream->m_Height) {
                hr = DDERR_INVALIDRECT;
            } else {
                AUTO_SAMPLE_LOCK;
                m_Rect = *pRect;
                m_bFormatChanged = true;
                hr = S_OK;
            }
        }
    }
    return hr;
}


void CDDSample::ReleaseMediaSampleLock()
{
    AUTO_SAMPLE_LOCK;
    if (m_pvLockedSurfacePtr != NULL) {
        m_pSurface->Unlock(m_pvLockedSurfacePtr);
        m_pvLockedSurfacePtr = NULL;
    }
}

HRESULT CDDSample::LockMediaSamplePointer()
{
    HRESULT hr = S_OK;
    AUTO_SAMPLE_LOCK;
    if (m_pvLockedSurfacePtr == NULL) {
        DDSURFACEDESC ddsd;
        ddsd.dwSize = sizeof(ddsd);
        hr = m_pSurface->Lock(NULL, &ddsd, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, NULL);
        if (SUCCEEDED(hr)) {
            m_pvLockedSurfacePtr = ddsd.lpSurface;
        }
    }
    return hr;
}

long CDDSample::LockAndPrepareMediaSample(long lLastPinPitch)
{
    AUTO_SAMPLE_LOCK;
    if (m_pvLockedSurfacePtr == NULL) {
        DDSURFACEDESC ddsd;
        ddsd.dwSize = sizeof(ddsd);
        if (m_pMediaSample->m_pMediaType) {
            DeleteMediaType(m_pMediaSample->m_pMediaType);	
            m_pMediaSample->m_pMediaType = NULL;
        }
        if (FAILED(m_pSurface->Lock(NULL, &ddsd, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, NULL))) {
            return 0;
        }
        m_pvLockedSurfacePtr = ddsd.lpSurface;
        if (lLastPinPitch != ddsd.lPitch ||
    	    m_lLastSurfacePitch != ddsd.lPitch ||
            m_bFormatChanged) {
            ConvertSurfaceDescToMediaType(&ddsd, m_pDDStream->m_pDirectDrawPalette,
                                          &m_Rect, TRUE, &m_pMediaSample->m_pMediaType,
                                          &m_pStream->m_ConnectedMediaType);
    	    if (m_pMediaSample->m_pMediaType) {
                VIDEOINFO *pvi = (VIDEOINFO *)m_pMediaSample->m_pMediaType->pbFormat;
                m_lImageSize = pvi->bmiHeader.biSizeImage;
    	        m_lLastSurfacePitch = ddsd.lPitch;
                m_bFormatChanged = false;
    	    } else {
    	        ReleaseMediaSampleLock();
    	        return 0;
            }
    	}
        return ddsd.lPitch;
    } else {
        return lLastPinPitch;
    }
}



void CDDSample::FinalMediaSampleRelease()
{
    ReleaseMediaSampleLock();
    CSample::FinalMediaSampleRelease();
}


HRESULT CDDSample::CopyFrom(CDDSample *pSrcSample)
{
    AUTO_SAMPLE_LOCK;
    CSample::CopyFrom(pSrcSample);
    return m_pSurface->BltFast(m_Rect.left, m_Rect.top,
                               pSrcSample->m_pSurface, &pSrcSample->m_Rect,
                               DDBLTFAST_NOCOLORKEY | DDBLTFAST_WAIT);
}



//
//  Helper
//
//  ASSUMES pClip clipped to surfae
//
void CopySampleToSurface(
    IMediaSample *pSample,
    VIDEOINFO *pInfo,
    DDSURFACEDESC& ddsd,
    const RECT *pClip
)
{

    DWORD dwBytesPerPixel = pInfo->bmiHeader.biBitCount / 8;

    //  Need src pointer and stride for source and dest and
    //  number of lines

    //
    //  The source of the target is the top left-hand corner of pClip
    //  within the surface
    //

    PBYTE pbSource;
    PBYTE pbTarget;
    LONG lSourceStride;
    LONG lTargetStride;
    DWORD dwWidth;
    DWORD dwLines;


    //
    //  Target first
    //
    pbTarget = (LPBYTE)ddsd.lpSurface;
    lTargetStride = ddsd.lPitch;
    dwLines = ddsd.dwHeight;
    dwWidth = ddsd.dwWidth;
    if (pClip) {
        pbTarget += (pClip->left + pClip->top * ddsd.lPitch) * dwBytesPerPixel;
        lTargetStride -= (ddsd.dwWidth - (pClip->right - pClip->left)) *
                         dwBytesPerPixel;
        dwLines = pClip->bottom - pClip->top;
        dwWidth = pClip->right - pClip->left;
    }

    //  Now do the source
    HRESULT hr = pSample->GetPointer(&pbSource);
    _ASSERTE(SUCCEEDED(hr));

    //  Adjust to the source rect - if the height is negative
    //  it means we have a ddraw surface already, otherwise
    //  we must invert everything
    LONG lSourceHeight = (LONG)pInfo->bmiHeader.biHeight;
    lSourceStride = pInfo->bmiHeader.biWidth * dwBytesPerPixel;
    if (lSourceHeight > 0) {
        pbSource += (lSourceStride * (lSourceHeight - 1));
        lSourceStride = -lSourceStride;
    } else {
        lSourceHeight = -lSourceHeight;
    }
    if (!IsRectEmpty(&pInfo->rcSource)) {
        pbSource += (pInfo->rcSource.left +
                     pInfo->rcSource.top * lSourceStride) * dwBytesPerPixel;
        //  Now check on the width etc
        dwWidth = min(dwWidth, (DWORD)(pInfo->rcSource.right - pInfo->rcSource.left));
        dwLines = min(dwLines, (DWORD)(pInfo->rcSource.bottom - pInfo->rcSource.top));
    } else {
        dwWidth = min(dwWidth, (DWORD)pInfo->bmiHeader.biWidth);
        dwLines = min(dwLines, (DWORD)lSourceHeight);
    }

    //
    //  Now do the copy
    //

    DWORD dwWidthInBytes = dwWidth * dwBytesPerPixel;

    while (dwLines-- > 0) {
        CopyMemory(pbTarget, pbSource, dwWidthInBytes);
        pbSource += lSourceStride;
        pbTarget += lTargetStride;
    }
}



HRESULT CDDSample::CopyFrom(IMediaSample *pSrcMediaSample, const AM_MEDIA_TYPE *pmt)
{
    AUTO_SAMPLE_LOCK;
    CSample::CopyFrom(pSrcMediaSample);
    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    HRESULT hr = m_pSurface->Lock(NULL, &ddsd, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, NULL);
    if (SUCCEEDED(hr)) {
        CopySampleToSurface(pSrcMediaSample, (VIDEOINFO *)pmt->pbFormat, ddsd, &m_Rect);
        m_pSurface->Unlock(ddsd.lpSurface);
    }
    return hr;
}


CDDInternalSample::CDDInternalSample() :
    m_pBuddySample(NULL),
    m_lWaiting(0),
    m_hWaitFreeSem(NULL),
    m_bDead(false)
{
};


CDDInternalSample::~CDDInternalSample()
{
    // ATLTRACE("CDDInternalSample::~CDDInternalSample\n");
    if (m_hWaitFreeSem) {
        CloseHandle(m_hWaitFreeSem);
    }
}


HRESULT CDDInternalSample::InternalInit(void)
{
    m_hWaitFreeSem = CreateSemaphore(NULL, 0, 0x7FFFFFF, NULL);
    return m_hWaitFreeSem ? S_OK : E_OUTOFMEMORY;
}


HRESULT CDDInternalSample::JoinToBuddy(CDDSample *pBuddy)
{
    LOCK_SAMPLE;
    while (!m_bDead && m_pBuddySample) {
        m_lWaiting++;
        UNLOCK_SAMPLE;
        WaitForSingleObject(m_hWaitFreeSem, INFINITE);
        LOCK_SAMPLE;
    }
    HRESULT hr;
    if (m_bDead) {
        hr = VFW_E_NOT_COMMITTED;
    } else {
        hr = S_OK;
        m_pBuddySample = pBuddy;
        ResetEvent(m_hCompletionEvent);
        m_Status = MS_S_PENDING;
        m_bWantAbort = false;
        m_bModified = false;
        m_bContinuous = false;
        m_UserAPC = 0;
        m_hUserHandle = NULL;
    }
    UNLOCK_SAMPLE;
    return hr;
}


HRESULT CDDInternalSample::Die(void)
{
    AUTO_SAMPLE_LOCK;
    m_bDead = true;
    if (m_lWaiting) {
        ReleaseSemaphore(m_hWaitFreeSem, m_lWaiting, 0);
        m_lWaiting = 0;
    }
    return S_OK;
}

HRESULT CDDInternalSample::SetCompletionStatus(HRESULT hrStatus)
{
    if (m_pBuddySample != NULL) {
        if (hrStatus == S_OK) {
            m_pBuddySample->CopyFrom(this);
        }
        //
        //  If we're just being recycled, but our buddy wants to abort, then abort him.
        //
        m_pBuddySample->SetCompletionStatus((hrStatus == MS_S_PENDING && m_pBuddySample->m_bWantAbort) ? E_ABORT : hrStatus);
    }

    LOCK_SAMPLE;
    m_Status = S_OK;
    m_pBuddySample = NULL;
    if (m_lWaiting) {
        m_lWaiting--;
        ReleaseSemaphore(m_hWaitFreeSem, 1, 0);
    }
    UNLOCK_SAMPLE;
    GetControllingUnknown()->Release(); // May die right here
    return hrStatus;
}



//
//  Forwarded IMediaSample methods.
//
HRESULT CDDSample::MSCallback_GetPointer(BYTE ** ppBuffer)
{
    *ppBuffer = (BYTE *)m_pvLockedSurfacePtr;
    return NOERROR;
}

LONG CDDSample::MSCallback_GetSize(void)
{
    return m_lImageSize;
}

LONG CDDSample::MSCallback_GetActualDataLength(void)
{
    return m_lImageSize;
}

HRESULT CDDSample::MSCallback_SetActualDataLength(LONG lActual)
{
    if (lActual == m_lImageSize) {
	return S_OK;
    } else {
	return E_FAIL;
    }
}


STDMETHODIMP CDDMediaSample::QueryInterface(REFIID riid, void ** ppv)
{
    if (riid==IID_IDirectDrawMediaSample) {
	*ppv = (IDirectDrawMediaSample *)this;
	((LPUNKNOWN)(*ppv))->AddRef();
	return S_OK;
    }
    return CMediaSample::QueryInterface(riid, ppv);
}


#define m_pDDSample ((CDDSample *)m_pSample)

STDMETHODIMP CDDMediaSample::GetSurfaceAndReleaseLock(IDirectDrawSurface **ppDirectDrawSurface, RECT * pRect)
{
    m_pDDSample->ReleaseMediaSampleLock();
    return m_pDDSample->GetSurface(ppDirectDrawSurface, pRect);
}


STDMETHODIMP CDDMediaSample::LockMediaSamplePointer()
{
    return m_pDDSample->LockMediaSamplePointer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\austrm.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// austrm.h : Declaration of the CAudioStream

/*
    Basic design
    ------------

    For simplification purposes we will always provide our own
    allocator buffer and copy into the application's buffer.  This
    will fix 2 problems:

    1.  Confusion caused by the filter no filling the allocator's
        buffers.

    2.  Problems when the application doesn't supply a big enough buffer.

    NOTES
    -----

    Continuous update might be a bit dumb to use for audio
*/

#ifndef __AUSTREAM_H_
#define __AUSTREAM_H_


/////////////////////////////////////////////////////////////////////////////
// CAudioStream
class ATL_NO_VTABLE CAudioStream :
	public CComCoClass<CAudioStream, &CLSID_AMAudioStream>,
        public CByteStream,
	public IAudioMediaStream
{
public:

        //
        // METHODS
        //
	CAudioStream();

        //
        //  IMediaStream
        //
        //
        // IMediaStream
        //
        // HACK HACK - the first 2 are duplicates but it won't link
        // without
        STDMETHODIMP GetMultiMediaStream(
            /* [out] */ IMultiMediaStream **ppMultiMediaStream)
        {
            return CStream::GetMultiMediaStream(ppMultiMediaStream);
        }

        STDMETHODIMP GetInformation(
            /* [optional][out] */ MSPID *pPurposeId,
            /* [optional][out] */ STREAM_TYPE *pType)
        {
            return CStream::GetInformation(pPurposeId, pType);
        }

        STDMETHODIMP SetState(
            /* [in] */ FILTER_STATE State
        )
        {
            return CByteStream::SetState(State);
        }

        STDMETHODIMP SetSameFormat(IMediaStream *pStream, DWORD dwFlags);

        STDMETHODIMP AllocateSample(
            /* [in]  */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppSample
        );

        STDMETHODIMP CreateSharedSample(
            /* [in] */ IStreamSample *pExistingSample,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppNewSample
        );

        STDMETHODIMP SendEndOfStream(DWORD dwFlags)
        {
            return CStream::SendEndOfStream(dwFlags);
        }
        //
        // IPin
        //
        STDMETHODIMP ReceiveConnection(IPin * pConnector, const AM_MEDIA_TYPE *pmt);

        //
        // IMemAllocator
        //
        STDMETHODIMP SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual);
        STDMETHODIMP GetProperties(ALLOCATOR_PROPERTIES* pProps);

        //
        // IAudioMediaStream
        //
        STDMETHODIMP GetFormat(
            /* [optional][out] */ LPWAVEFORMATEX lpWaveFormatCurrent
        );

        STDMETHODIMP SetFormat(
            /* [in] */ const WAVEFORMATEX *lpWaveFormat
        );

        STDMETHODIMP CreateSample(
                /* [in] */ IAudioData *pAudioData,
                /* [in] */ DWORD dwFlags,
                /* [out] */ IAudioStreamSample **ppSample
        );



        //
        // Special CStream methods
        //
        HRESULT GetMediaType(ULONG Index, AM_MEDIA_TYPE **ppMediaType);

        LONG GetChopSize()
        {
#ifdef MY_CHOP_SIZE
            if (m_Direction == PINDIR_OUTPUT) {
                return MY_CHOP_SIZE;
            }
#endif
            return 65536;
        }

DECLARE_REGISTRY_RESOURCEID(IDR_AUDIOSTREAM)

protected:
        HRESULT InternalSetFormat(const WAVEFORMATEX *pFormat, bool bFromPin);
        HRESULT CheckFormat(const WAVEFORMATEX *pFormat, bool bForce=false);

BEGIN_COM_MAP(CAudioStream)
	COM_INTERFACE_ENTRY(IAudioMediaStream)
        COM_INTERFACE_ENTRY_CHAIN(CStream)
END_COM_MAP()

protected:
        /*  Format */
        WAVEFORMATEX    m_Format;
        bool            m_fForceFormat;
};


/////////////////////////////////////////////////////////////////////////////
// CAudioStreamSample
class ATL_NO_VTABLE CAudioStreamSample :
    public CByteStreamSample,
    public IAudioStreamSample
{
public:
        CAudioStreamSample() {}

//  DELEGATE TO BASE CLASS
        //
        //  IStreamSample
        //
        STDMETHODIMP GetMediaStream(
            /* [in] */ IMediaStream **ppMediaStream)
        {
            return CSample::GetMediaStream(ppMediaStream);
        }

        STDMETHODIMP GetSampleTimes(
            /* [optional][out] */ STREAM_TIME *pStartTime,
            /* [optional][out] */ STREAM_TIME *pEndTime,
            /* [optional][out] */ STREAM_TIME *pCurrentTime)
        {
            return CSample::GetSampleTimes(
                pStartTime,
                pEndTime,
                pCurrentTime
            );
        }

        STDMETHODIMP SetSampleTimes(
            /* [optional][in] */ const STREAM_TIME *pStartTime,
            /* [optional][in] */ const STREAM_TIME *pEndTime)
        {
            return CSample::SetSampleTimes(pStartTime, pEndTime);
        }

        STDMETHODIMP Update(
            /* [in] */           DWORD dwFlags,
            /* [optional][in] */ HANDLE hEvent,
            /* [optional][in] */ PAPCFUNC pfnAPC,
            /* [optional][in] */ DWORD_PTR dwAPCData)
        {
            return CByteStreamSample::Update(dwFlags, hEvent, pfnAPC, dwAPCData);
        }

        STDMETHODIMP CompletionStatus(
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ DWORD dwMilliseconds)
        {
            return CSample::CompletionStatus(dwFlags, dwMilliseconds);
        }

BEGIN_COM_MAP(CAudioStreamSample)
        COM_INTERFACE_ENTRY(IAudioStreamSample)
        COM_INTERFACE_ENTRY_CHAIN(CSample)
END_COM_MAP()

        //  IAudioStreamSample
        STDMETHODIMP GetAudioData(IAudioData **ppAudioData)
        {
            return m_pMemData->QueryInterface(IID_IAudioData, (void **)ppAudioData);
        }

        //  Set the pointer
        HRESULT SetSizeAndPointer(BYTE *pbData, LONG lActual, LONG lSize)
        {
            m_pbData = pbData;
            m_cbSize = (DWORD)lSize;
            m_cbData = (DWORD)lActual;
            return S_OK;
        }
};

//  Audio data object
class ATL_NO_VTABLE CAudioData :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IAudioData,
    public CComCoClass<CAudioData, &CLSID_AMAudioData>
{
public:
    CAudioData();
    ~CAudioData();

DECLARE_REGISTRY_RESOURCEID(IDR_AUDIODATA)

BEGIN_COM_MAP(CAudioData)
    COM_INTERFACE_ENTRY(IAudioData)
END_COM_MAP()

    //
    //  IMemoryData
    //

    STDMETHODIMP SetBuffer(
        /* [in] */ DWORD cbSize,
        /* [in] */ BYTE * pbData,
        /* [in] */ DWORD dwFlags
    )
    {
        if (dwFlags != 0 || cbSize == 0) {
            return E_INVALIDARG;
        }
        //
        //  Free anything we allocated ourselves -- We allow multiple calls to this method
        //
        if (m_bWeAllocatedData) {
            CoTaskMemFree(m_pbData);
            m_bWeAllocatedData = false;
        }
        m_cbSize = cbSize;
        if (pbData) {
            m_pbData = pbData;
            return S_OK;
        } else {
            m_pbData = (BYTE *)CoTaskMemAlloc(cbSize);
            if (m_pbData) {
                m_bWeAllocatedData = true;
                return S_OK;
            }
            return E_OUTOFMEMORY;
        }
    }

    STDMETHODIMP GetInfo(
        /* [out] */ DWORD *pdwLength,
        /* [out] */ BYTE **ppbData,
        /* [out] */ DWORD *pcbActualData
    )
    {
        if (m_cbSize == 0) {
            return MS_E_NOTINIT;
        }
        if (pdwLength) {
            *pdwLength = m_cbSize;
        }
        if (ppbData) {
            *ppbData = m_pbData;
        }
        if (pcbActualData) {
            *pcbActualData = m_cbData;
        }
        return S_OK;
    }
    STDMETHODIMP SetActual(
        /* [in] */ DWORD cbDataValid
    )
    {
        if (cbDataValid > m_cbSize) {
            return E_INVALIDARG;
        }
        m_cbData = cbDataValid;
        return S_OK;
    }

    //
    // IAudioData
    //

    STDMETHODIMP GetFormat(
    	/* [out] [optional] */ WAVEFORMATEX *pWaveFormatCurrent
    )
    {
        if (pWaveFormatCurrent == NULL) {
            return E_POINTER;
        }
        *pWaveFormatCurrent = m_Format;
        return S_OK;
    }

    STDMETHODIMP SetFormat(
    	/* [in] */ const WAVEFORMATEX *lpWaveFormat
    )
    {
        if (lpWaveFormat == NULL) {
            return E_POINTER;
        }
        if (lpWaveFormat->wFormatTag != WAVE_FORMAT_PCM) {
            return E_INVALIDARG;
        }
        m_Format = *lpWaveFormat;
        return S_OK;
    }


protected:
    PBYTE        m_pbData;
    DWORD        m_cbSize;
    DWORD        m_cbData;
    WAVEFORMATEX m_Format;
    bool         m_bWeAllocatedData;
};

#endif // __AUSTREAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\bytestrm.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
// bytestrm.h : Declaration of the CByteStream

#ifndef __BYTESTRM_H_
#define __BYTESTRM_H_

class CByteSample;

/////////////////////////////////////////////////////////////////////////////
// CByteStream
class ATL_NO_VTABLE CByteStream :
        public CStream
{
public:

        //
        // METHODS
        //
	CByteStream();

        STDMETHODIMP SetState(
            /* [in] */ FILTER_STATE State
        );

        //
        // IPin
        //
        STDMETHODIMP BeginFlush();
        STDMETHODIMP EndOfStream(void);

        //
        // IMemInputPin
        //
        STDMETHODIMP Receive(IMediaSample *pSample);
        STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);

        //
        // IMemAllocator
        //
        STDMETHODIMP GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME * pStartTime,
                               REFERENCE_TIME * pEndTime, DWORD dwFlags);

        //  Fill any samples waiting to be filled
        void FillSamples();

        //  Check if it's time to do the real EndOfStream
        void CheckEndOfStream();

protected:
        /*  Queue of samples */
        CDynamicArray<IMediaSample *, CComPtr<IMediaSample> >
                        m_arSamples;

        /*  Current sample/buffer */
        PBYTE           m_pbData;
        DWORD           m_cbData;
        DWORD           m_dwPosition;

        /*  Track time stamps */
        CTimeStamp      m_TimeStamp;

        /*  Byte rate for time stamp computation */
        LONG  m_lBytesPerSecond;

        /*  End Of Stream pending - it will be delivered when we've
            emptied the last sample off our list
        */
        bool            m_bEOSPending;
};

/////////////////////////////////////////////////////////////////////////////
// CByteStreamSample
class ATL_NO_VTABLE CByteStreamSample :
        public CSample
{
friend class CByteStream;
public:
        CByteStreamSample();

        //
        //  IStreamSample
        //
        STDMETHODIMP GetMediaStream(
            /* [in] */ IMediaStream **ppMediaStream)
        {
            return CSample::GetMediaStream(ppMediaStream);
        }

        STDMETHODIMP GetSampleTimes(
            /* [optional][out] */ STREAM_TIME *pStartTime,
            /* [optional][out] */ STREAM_TIME *pEndTime,
            /* [optional][out] */ STREAM_TIME *pCurrentTime)
        {
            return CSample::GetSampleTimes(
                pStartTime,
                pEndTime,
                pCurrentTime
            );
        }

        STDMETHODIMP SetSampleTimes(
            /* [optional][in] */ const STREAM_TIME *pStartTime,
            /* [optional][in] */ const STREAM_TIME *pEndTime)
        {
            return CSample::SetSampleTimes(pStartTime, pEndTime);
        }

        STDMETHODIMP CompletionStatus(
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ DWORD dwMilliseconds)
        {
            return CSample::CompletionStatus(dwFlags, dwMilliseconds);
        }

        HRESULT Init(
            IMemoryData *pMemData
        );

        STDMETHODIMP GetInformation(
            /* [out] */ DWORD *pdwLength,
            /* [out] */ BYTE **ppbData,
            /* [out] */ DWORD *pcbActualData
        );

        //  Override to make sure samples get updated
        HRESULT InternalUpdate(
            DWORD dwFlags,
            HANDLE hEvent,
            PAPCFUNC pfnAPC,
            DWORD_PTR dwAPCData
        );


        //
        //  Methods forwarded from MediaSample object.
        //
        HRESULT MSCallback_GetPointer(BYTE ** ppBuffer) { *ppBuffer = m_pbData; return NOERROR; };
        LONG MSCallback_GetSize(void) { return m_cbSize; };
        LONG MSCallback_GetActualDataLength(void) { return m_cbData; };
        HRESULT MSCallback_SetActualDataLength(LONG lActual)
        {
            if ((DWORD)lActual <= m_cbSize) {
                m_cbData = lActual;
                return NOERROR;
            }
            return E_INVALIDARG;
        };

protected:
        PBYTE m_pbData;
        DWORD m_cbSize;
        DWORD m_cbData;
        CComPtr<IMemoryData> m_pMemData;
};

#endif // __BYTESTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\bytestrm.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
// bytestrm.cpp : Implementation of CByteStream
#include "stdafx.h"
#include "project.h"

/////////////////////////////////////////////////////////////////////////////
// CByteStream

CByteStream::CByteStream() :
    m_cbData(0),
    m_lBytesPerSecond(0),
    m_bEOSPending(false)
{
}

STDMETHODIMP CByteStream::GetBuffer(
    IMediaSample **ppBuffer,
    REFERENCE_TIME * pStartTime,
    REFERENCE_TIME * pEndTime,
    DWORD dwFlags
)
{
    HRESULT hr;
    *ppBuffer = NULL;
    if (m_bStopIfNoSamples && m_cAllocated == 0) {
        return E_FAIL;
    }
    if (m_Direction == PINDIR_INPUT) {
        AtlTrace(_T("Should never get here!\n"));
        _ASSERTE(FALSE);
        hr = E_UNEXPECTED;
    } else {
        CSample *pSample;
        hr = AllocSampleFromPool(pStartTime, &pSample);
        if (hr == NOERROR) {
            pSample->m_pMediaSample->m_dwFlags = dwFlags;
            pSample->m_bReceived = false;
            pSample->m_bModified = true;
            *ppBuffer = (IMediaSample *)(pSample->m_pMediaSample);
            (*ppBuffer)->AddRef();
        }
    }
    return hr;
}

STDMETHODIMP CByteStream::BeginFlush()
{
    AUTO_CRIT_LOCK;
    m_bEOSPending = false;
    m_arSamples.RemoveAll();
    m_cbData = 0;
    m_TimeStamp.Reset();
    return CStream::BeginFlush();
}

STDMETHODIMP CByteStream::EndOfStream()
{
    HRESULT hr = S_OK;
    Lock();
    if (m_bFlushing || m_bEndOfStream || m_bEOSPending) {
        hr = E_FAIL;
    } else {
        m_bEOSPending = TRUE;
        CheckEndOfStream();
    }
    Unlock();
    return hr;
}

STDMETHODIMP CByteStream::GetAllocator(IMemAllocator ** ppAllocator)
{
    HRESULT hr;
    AUTO_CRIT_LOCK;
    if (m_Direction == PINDIR_OUTPUT) {
        hr = CStream::GetAllocator(ppAllocator);
    } else {
        if (m_pAllocator == NULL) {
            hr = CoCreateInstance(CLSID_MemoryAllocator,
                                          0,
                                          CLSCTX_INPROC_SERVER,
                                          IID_IMemAllocator,
                                          (void **)&m_pAllocator);
            if (FAILED(hr)) {
                goto Exit;
            }
        }
        m_pAllocator->AddRef();
        *ppAllocator = m_pAllocator;
        hr = NOERROR;
    }
Exit:
    return hr;
}

STDMETHODIMP CByteStream::Receive(IMediaSample *pSample)
{
    AUTO_CRIT_LOCK;

    if (m_bFlushing || m_bStopIfNoSamples && m_cAllocated == 0) {
        EndOfStream();
        return S_FALSE;
    }

    if(m_FilterState == State_Stopped) {
        return VFW_E_WRONG_STATE;
    }

    /*  Put it on the queue */
    if (!m_arSamples.Add(pSample)) {
        EndOfStream();
        return E_OUTOFMEMORY;
    }

    /*  Eat as much as we can, then return */
    FillSamples();
    return S_OK;
}

STDMETHODIMP CByteStream::SetState(
    /* [in] */ FILTER_STATE State
)
{
    HRESULT hr =  CStream::SetState(State);    // Must be called with the critical seciton unowned!

    Lock();
    if (State == State_Stopped) {
        m_bEOSPending = false;
        m_arSamples.RemoveAll();

        m_cbData = 0;
        m_TimeStamp.Reset();
    }
    Unlock();

    if (State == State_Stopped) {
        _ASSERTE(m_arSamples.Size() == 0);
    }

    return hr;
}


//  Fill any samples lying around
void CByteStream::FillSamples()
{
    while (m_arSamples.Size() != 0 && m_pFirstFree != NULL) {
        if (m_cbData == 0) {
            IMediaSample * const pSample = m_arSamples.Element(0);

            /*  At the start so initialize some stuff */
            pSample->GetPointer(&m_pbData);
            m_cbData = m_arSamples.Element(0)->GetActualDataLength();

            /*  See if there are any time stamps */
            REFERENCE_TIME rtStart, rtStop;
            if (SUCCEEDED(pSample->GetTime(&rtStart, &rtStop))) {
#if 0
                AtlTrace("TimeStamp current %d, new %d, length %d length(ms) %d, bytelen %d\n",
                         (long)(m_TimeStamp.TimeStamp(0, m_lBytesPerSecond) / 10000),
                         (long)(rtStart / 10000),
                         (long)((rtStop - rtStart) / 10000),
                         MulDiv(m_cbData, 1000, m_lBytesPerSecond),
                         m_cbData);
#endif
                m_TimeStamp.SetTime(rtStart);
            }
        }
        /*  Copy some data across */
        CByteStreamSample* const pStreamSample = (CByteStreamSample *)m_pFirstFree;

        /*  Do timestamps */
        if (pStreamSample->m_cbData == 0) {
            pStreamSample->m_pMediaSample->m_rtEndTime =
            pStreamSample->m_pMediaSample->m_rtStartTime =
                m_TimeStamp.TimeStamp(0, m_lBytesPerSecond);
        }
        /*  See how much we can copy */
        _ASSERTE(pStreamSample->m_cbData <= pStreamSample->m_cbSize);

        DWORD cbBytesToCopy = min(m_cbData,
                                  pStreamSample->m_cbSize -
                                  pStreamSample->m_cbData);
        CopyMemory(pStreamSample->m_pbData + pStreamSample->m_cbData,
                   m_pbData,
                   cbBytesToCopy);
        m_cbData -= cbBytesToCopy;
        m_TimeStamp.AccumulateBytes(cbBytesToCopy);

        /*  Is this  a bit expensive?  - who cares about the stop time */
        pStreamSample->m_pMediaSample->m_rtEndTime =
            m_TimeStamp.TimeStamp(0, m_lBytesPerSecond);
        if (m_cbData == 0) {
            //  This performs the Release()
            m_arSamples.Remove(0);
        }
        m_pbData += cbBytesToCopy;
        pStreamSample->m_cbData += cbBytesToCopy;

        //  Update the actual data object
        pStreamSample->m_pMemData->SetActual(pStreamSample->m_cbData);
        if (pStreamSample->m_cbData == pStreamSample->m_cbSize) {
            // this is a lot of overhead since we know
            // it's free but it's not a bug
#if 0
            AtlTrace("Sample start %dms, length %dms bytelen %dms\n",
                     (long)(pStreamSample->m_pMediaSample->m_rtEndTime / 10000),
                     (long)((pStreamSample->m_pMediaSample->m_rtEndTime -
                             pStreamSample->m_pMediaSample->m_rtStartTime) / 10000),
                     MulDiv(pStreamSample->m_cbData, 1000, m_lBytesPerSecond));
#endif
            StealSampleFromFreePool(m_pFirstFree, true);
            pStreamSample->SetCompletionStatus(S_OK);
        }
    }
    CheckEndOfStream();
}

void CByteStream::CheckEndOfStream()
{
    AUTO_CRIT_LOCK;
    if (m_bEOSPending && m_arSamples.Size() == 0) {
        m_bEOSPending = false;

        //  If the first sample contains data set the status on the
        //  next one
        if (m_pFirstFree != NULL) {
            CByteStreamSample* const pStreamSample =
            (CByteStreamSample *)m_pFirstFree;
            if (pStreamSample->m_cbData != 0) {
                StealSampleFromFreePool(m_pFirstFree, true);
                pStreamSample->SetCompletionStatus(S_OK);
            }
        }

        CStream::EndOfStream();
    }
}

#if 0
HRESULT CByteStream::InternalAllocateSample(
    IByteStreamSample **ppBSSample
)
{
    CByteStreamSample *pBSSample = new CComObject<CByteStreamSample>;
    if (pBSSample == NULL) {
        *ppBSSample = NULL;
        return E_OUTOFMEMORY;
    } else {
        return pBSSample->GetControllingUnknown()->QueryInterface(
            IID_IByteStreamSample, (void **)ppBSSample
        );
    }
}
#endif

//
//   CByteStreamSample
//

CByteStreamSample::CByteStreamSample() :
    m_pbData(NULL),
    m_cbSize(0),
    m_cbData(0)
{
}

HRESULT CByteStreamSample::InternalUpdate(
    DWORD dwFlags,
    HANDLE hEvent,
    PAPCFUNC pfnAPC,
    DWORD_PTR dwAPCData
)
{
    if (m_pMemData == NULL) {
        return MS_E_NOTINIT;
    }
    HRESULT hr =  m_pMemData->GetInfo(
                      &m_cbSize,
                      &m_pbData,
                      &m_cbData
                  );
    if (FAILED(hr)) {
        return hr;
    }

    //  InternalUpdate will check everything and add us to queues etc
    hr =  CSample::InternalUpdate(dwFlags, hEvent, pfnAPC, dwAPCData);
    if (SUCCEEDED(hr) && m_pStream->m_Direction == PINDIR_INPUT) {
        m_cbData = 0;
        m_pMemData->SetActual(0);
        CByteStream *pStream = (CByteStream *)m_pStream;
        pStream->FillSamples();
    }
    return hr;
}

STDMETHODIMP::CByteStreamSample::GetInformation(
    /* [out] */ DWORD *pdwLength,
    /* [out] */ PBYTE *ppbData,
    /* [out] */ DWORD *pcbActualData
)
{
    if (m_pbData == NULL) {
        return MS_E_NOTINIT;
    }
    if (pdwLength) {
        *pdwLength = m_cbSize;
    }
    if (ppbData) {
        *ppbData = m_pbData;
    }
    if (pcbActualData) {
        *pcbActualData = m_cbData;
    }
    return S_OK;
}


HRESULT CByteStreamSample::Init(
    IMemoryData *pMemData
)
{
    if (m_pMemData) {
        _ASSERTE(_T("Initialization called twice!"));
        return E_UNEXPECTED;
    }
    m_pMemData = pMemData;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\ddsample.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.

/////////////////////////////////////////////////////////////////////////////
// CDDSample
class ATL_NO_VTABLE CDDSample :
        public CSample,
	public IDirectDrawStreamSample
{
public:
        CDDSample();

        HRESULT InitSample(CStream *pStream, IDirectDrawSurface *pSurface, const RECT *pRect, bool bIsProgressiveRender, bool bIsInternalSample,
                           bool bTemp);

        //
        //  IStreamSample
        //
        STDMETHODIMP GetMediaStream(
            /* [in] */ IMediaStream **ppMediaStream)
        {
            return CSample::GetMediaStream(ppMediaStream);
        }

        STDMETHODIMP GetSampleTimes(
            /* [optional][out] */ STREAM_TIME *pStartTime,
            /* [optional][out] */ STREAM_TIME *pEndTime,
            /* [optional][out] */ STREAM_TIME *pCurrentTime)
        {
            return CSample::GetSampleTimes(
                pStartTime,
                pEndTime,
                pCurrentTime
            );
        }

        STDMETHODIMP SetSampleTimes(
            /* [optional][in] */ const STREAM_TIME *pStartTime,
            /* [optional][in] */ const STREAM_TIME *pEndTime)
        {
            return CSample::SetSampleTimes(pStartTime, pEndTime);
        }

        STDMETHODIMP Update(
            /* [in] */           DWORD dwFlags,
            /* [optional][in] */ HANDLE hEvent,
            /* [optional][in] */ PAPCFUNC pfnAPC,
            /* [optional][in] */ DWORD_PTR dwAPCData)
        {
            return CSample::Update(dwFlags, hEvent, pfnAPC, dwAPCData);
        }

        STDMETHODIMP CompletionStatus(
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ DWORD dwMilliseconds)
        {
            return CSample::CompletionStatus(dwFlags, dwMilliseconds);
        }
        //
        // IDirectDrawStreamSample
        //
        STDMETHODIMP GetSurface(IDirectDrawSurface **ppDirectDrawSurface, RECT * pRect);
        STDMETHODIMP SetRect(const RECT * pRect);

        //
        //  Overridden virtual function for CSample
        //
        void FinalMediaSampleRelease(void);


        //
        //  Methods forwarded from MediaSample object.
        //
        HRESULT MSCallback_GetPointer(BYTE ** ppBuffer);
        LONG MSCallback_GetSize(void);
        LONG MSCallback_GetActualDataLength(void);
        HRESULT MSCallback_SetActualDataLength(LONG lActual);

        //
        // Internal methods
        //
        long LockAndPrepareMediaSample(long lLastPinPitch);
        void ReleaseMediaSampleLock(void);
        HRESULT CopyFrom(CDDSample *pSrcSample);
        HRESULT CopyFrom(IMediaSample *pSrcMediaSample, const AM_MEDIA_TYPE *pmt);
        HRESULT LockMediaSamplePointer();

BEGIN_COM_MAP(CDDSample)
	COM_INTERFACE_ENTRY(IDirectDrawStreamSample)
        COM_INTERFACE_ENTRY_CHAIN(CSample)
END_COM_MAP()

public:
        CComPtr<IDirectDrawSurface>     m_pSurface;
        RECT                            m_Rect;

        long                            m_lLastSurfacePitch;
        bool                            m_bProgressiveRender;
        bool                            m_bFormatChanged;

        LONG                            m_lImageSize;
        void *                          m_pvLockedSurfacePtr;
};



class CDDInternalSample : public CDDSample
{
public:
    CDDInternalSample();
    ~CDDInternalSample();
    HRESULT InternalInit(void);
    HRESULT SetCompletionStatus(HRESULT hrStatus);
    HRESULT Die(void);
    HRESULT JoinToBuddy(CDDSample *pBuddy);

    BOOL HasBuddy() const
    {
        return m_pBuddySample != NULL;
    }
    
private:
    CDDSample       *m_pBuddySample;    
    long            m_lWaiting;
    HANDLE          m_hWaitFreeSem;
    bool            m_bDead;
};


class CDDMediaSample : public CMediaSample, public IDirectDrawMediaSample
{
public:
    CDDMediaSample(CSample *pSample) :
      CMediaSample(pSample) {};
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) AddRef() {return CMediaSample::AddRef();}
    STDMETHODIMP_(ULONG) Release() {return CMediaSample::Release();}

    STDMETHODIMP GetSurfaceAndReleaseLock(IDirectDrawSurface **ppDirectDrawSurface, RECT * pRect);
    STDMETHODIMP LockMediaSamplePointer();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\ddstream.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// ddstream.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL,
//		run nmake -f ddstreamps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "ddstream.h"
#include "Stream.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_AMDirectDrawStream, CStream)
        OBJECT_ENTRY(CLSID_AMMediaTypeStream, CAMMediaTypeStream)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\ddstrm.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// DDStrm.cpp : Implementation of CDDStream
#include "stdafx.h"
#include "project.h"

//#define SHOWSURFACES

#ifdef SHOWSURFACES
//  See if we can blt this to the screen
void ShowSurface(IDirectDrawSurface *pSurface)
{
    CComPtr<IDirectDraw> pDDraw;
    CComPtr<IDirectDrawSurface2> pSurface2;
    DDSURFACEDESC ddsdSurf;
    ddsdSurf.dwSize = sizeof(ddsdSurf);
    HRESULT hr = pSurface->QueryInterface(IID_IDirectDrawSurface2, (void **)&pSurface2);
    if (SUCCEEDED(hr)) {
        hr = pSurface2->GetDDInterface((void **)&pDDraw);
    }
    if (SUCCEEDED(hr)) {
        hr = pSurface->GetSurfaceDesc(&ddsdSurf);
    }
    if (SUCCEEDED(hr)) {
        CComPtr<IDirectDrawSurface> pPrimary;
        DDSURFACEDESC ddsd;
        ddsd.dwSize = sizeof(ddsd);
        ddsd.dwFlags = DDSD_CAPS;
        ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
        HRESULT hr = pDDraw->CreateSurface(&ddsd, &pPrimary, NULL);
        RECT rc;
        rc.left = 0;
        rc.top = 0;
        rc.right = ddsdSurf.dwWidth;
        rc.bottom = ddsdSurf.dwHeight;
        if (SUCCEEDED(hr)) {
    	    pPrimary->Blt(&rc, pSurface, &rc, DDBLT_WAIT, NULL);
        } else {
        }
    }
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CDDStream

CDDStream::CDDStream() :
    m_dwForcedFormatFlags(0),
    m_Height(0),
    m_Width(0),
    m_lLastPitch(0),
    m_pMyReadOnlySample(NULL),
    m_pDefPixelFormat(GetDefaultPixelFormatPtr(NULL))
{
}

HRESULT CDDStream::InitDirectDraw()
{
    HRESULT hr = NOERROR;
    if (!m_pDirectDraw) {
        CComPtr<IDirectDraw> pDDraw;
        hr = DirectDrawCreate(NULL, &pDDraw, NULL);
        if (SUCCEEDED(hr)) {
            hr = pDDraw->SetCooperativeLevel(NULL, DDSCL_NORMAL);
        }
        if (SUCCEEDED(hr)) {
            m_pDirectDraw = pDDraw;
        }
    }
    return hr;
}

HRESULT CDDStream::InternalAllocateSample(
    DWORD dwFlags,
    bool bIsInternalSample,
    IDirectDrawStreamSample **ppDDSample,
    bool bTemp
)
{
    AUTO_CRIT_LOCK;
    HRESULT hr = S_OK;
    CComPtr <IDirectDrawSurface> pSurface;
    CComPtr<IDirectDrawPalette> pPalette;

    //
    //  Create the direct draw object here if necessary.  It is important to call the
    //  SetDirectDraw method so it can set other member variables appropriately
    //
    if (!m_pDirectDraw) {
        hr = InitDirectDraw();
        if (FAILED(hr)) {
            goto Exit;
        }
    }

    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    GetFormatInternal(&ddsd, &pPalette, NULL, NULL);

    hr = m_pDirectDraw->CreateSurface(&ddsd, &pSurface, NULL);
    if (SUCCEEDED(hr)) {
        if (pPalette) {
            pSurface->SetPalette(pPalette);
        }
        RECT rect = {0, 0, ddsd.dwWidth, ddsd.dwHeight};
        hr = InternalCreateSample(pSurface,
                                  &rect,
                                  dwFlags,
                                  bIsInternalSample,
                                  ppDDSample,
                                  bTemp);
        // No need to release surface if create fails since pSurface is a CComPtr

        if (SUCCEEDED(hr) && !bIsInternalSample) {
            //  Make sure the surface has a palette if the stream has one
            if (pPalette == NULL && m_pDirectDrawPalette) {
                pSurface->SetPalette(m_pDirectDrawPalette);
            }
        }
    }
Exit:
    return hr;
}


STDMETHODIMP CDDStream::SetSameFormat(IMediaStream *pStream, DWORD dwFlags)
{
    TRACEINTERFACE(_T("IDirectDrawStream::SetSameFormat(0x%8.8X, 0x%8.8X)\n"),
                   pStream, dwFlags);
    CComQIPtr<IDirectDrawMediaStream, &IID_IDirectDrawMediaStream> pSource(pStream);
    if (!pSource) {
        return MS_E_INCOMPATIBLE;
    }
    DDSURFACEDESC ddsdCurrent;
    CComPtr <IDirectDrawPalette> pPalette;
    ddsdCurrent.dwSize = sizeof(ddsdCurrent);
    HRESULT hr = pSource->GetFormat(&ddsdCurrent, &pPalette, NULL, 0);

    /*  Lock the source format */
    ddsdCurrent.dwFlags |= DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT;
    if (SUCCEEDED(hr)) {
        hr = pSource->SetFormat(&ddsdCurrent, pPalette);
    }
    if (SUCCEEDED(hr)) {
        hr = SetFormat(&ddsdCurrent, pPalette);
        if (SUCCEEDED(hr)) {
            CComPtr<IDirectDraw> pDD;
            hr = pSource->GetDirectDraw(&pDD);
            if (SUCCEEDED(hr)) {
                hr = SetDirectDraw(pDD);
            }
        }
    }
    return hr;
}

STDMETHODIMP CDDStream::AllocateSample(DWORD dwFlags, IStreamSample **ppSample)
{
    TRACEINTERFACE(_T("IDirectDrawStream::AllocateSample(0x%8.8X, 0x%8.8X)\n"),
                   dwFlags, ppSample);
    HRESULT hr;
    if (ppSample) {
        *ppSample = NULL;
    }
    if (!ppSample || dwFlags) {
        hr = E_INVALIDARG;
    } else {
        IDirectDrawStreamSample *pDDSample = NULL;
        hr = InternalAllocateSample(0, false, &pDDSample);
        *ppSample = pDDSample;
    }
    return hr;
}


STDMETHODIMP CDDStream::CreateSharedSample(IStreamSample *pExistingSample,
                                           DWORD dwFlags,
                                           IStreamSample **ppNewSample)
{
    TRACEINTERFACE(_T("IDirectDrawStream::CreateSharedSample(0x%8.8X, 0x%8.8X, 0x%8.8X)\n"),
                   pExistingSample, dwFlags, ppNewSample);
    *ppNewSample = NULL;
    CComQIPtr<IDirectDrawStreamSample, &IID_IDirectDrawStreamSample> pSource(pExistingSample);
    if (!pSource) {
        return MS_E_INCOMPATIBLE;
    }
    CComPtr<IDirectDrawSurface> pSurface;
    RECT rect;
    pSource->GetSurface(&pSurface, &rect);

    IDirectDrawStreamSample * pDDSample;
    HRESULT hr = CreateSample(pSurface, &rect, 0, &pDDSample);
    if (SUCCEEDED(hr)) {
        *ppNewSample = pDDSample;
    }
    return hr;
}


//
// IDirectDrawMediaStream
//

void CDDStream::InitSurfaceDesc(LPDDSURFACEDESC lpddsd)
{
    lpddsd->dwFlags = 0;
    if (m_Height) {
        lpddsd->dwHeight = m_Height;
        lpddsd->dwWidth  = m_Width;
    } else {
        lpddsd->dwHeight = lpddsd->dwWidth = 100;
    }
    if ((m_dwForcedFormatFlags & DDSD_PIXELFORMAT) || m_pConnectedPin) {
        memcpy(&lpddsd->ddpfPixelFormat, &m_PixelFormat, sizeof(m_PixelFormat));
    } else {
        memcpy(&lpddsd->ddpfPixelFormat, m_pDefPixelFormat, sizeof(m_PixelFormat));
    }
    lpddsd->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
}


STDMETHODIMP CDDStream::GetFormat(DDSURFACEDESC *pDDSDCurrent,
                                  IDirectDrawPalette **ppDirectDrawPalette,
                                  DDSURFACEDESC *pDDSDDesired,
                                  DWORD *pdwFlags)
{
    if(!m_pConnectedPin) {
        return MS_E_NOSTREAM;
    }

    return GetFormatInternal(pDDSDCurrent, ppDirectDrawPalette, pDDSDDesired, pdwFlags);
}

STDMETHODIMP CDDStream::GetFormatInternal(DDSURFACEDESC *pDDSDCurrent,
                                  IDirectDrawPalette **ppDirectDrawPalette,
                                  DDSURFACEDESC *pDDSDDesired,
                                  DWORD *pdwFlags)
{
    TRACEINTERFACE(_T("IDirectDrawStream::GetFormat(0x%8.8X, 0x%8.8X, 0x%8.8X, 0x%8.8X)\n"),
                   pDDSDCurrent, ppDirectDrawPalette, pDDSDDesired, pdwFlags);
    //
    // If we have never connected, and the format is not set, then default
    // to returning a height and width (100 x 100) and a caps of
    // data interchange type,
    //
    // If we are connected but haven't allocated a sureface, simply return the
    // correct height and width, and a caps of data interchange type.
    //
    // If we have a set format, then return the height, width, pixel format,
    // and caps of the current surfacedesc we have.
    //
    if (pDDSDCurrent) {
        InitSurfaceDesc(pDDSDCurrent);
        pDDSDCurrent->dwFlags = DDSD_HEIGHT | DDSD_WIDTH | DDSD_CAPS | m_dwForcedFormatFlags;
        if (m_cAllocated) {
            pDDSDCurrent->dwFlags |= DDSD_PIXELFORMAT;
        }
    }
    if (pDDSDDesired) {
        InitSurfaceDesc(pDDSDDesired);
        if (m_pConnectedPin) {
            pDDSDDesired->dwFlags |= DDSD_HEIGHT | DDSD_WIDTH;
        }
    }
    if (ppDirectDrawPalette) {
        *ppDirectDrawPalette = m_pDirectDrawPalette;
        if (*ppDirectDrawPalette) {
            (*ppDirectDrawPalette)->AddRef();
        }
    }
    if (pdwFlags) {
        *pdwFlags = m_bSamplesAreReadOnly ? DDSFF_PROGRESSIVERENDER : 0;
    }
    return S_OK;
}

STDMETHODIMP CDDStream::SetFormat(const DDSURFACEDESC *lpDDSurfaceDesc,
                                  IDirectDrawPalette *pDirectDrawPalette)
{
    TRACEINTERFACE(_T("IDirectDrawStream::SetFormat(0x%8.8X, 0x%8.8X)\n"),
                   lpDDSurfaceDesc, pDirectDrawPalette);
    HRESULT hr = InternalSetFormat(lpDDSurfaceDesc, pDirectDrawPalette, false);
    if (hr == VFW_E_TYPE_NOT_ACCEPTED) {
        hr = DDERR_INVALIDSURFACETYPE;
    }
    return hr;
}


HRESULT CDDStream::RenegotiateMediaType(const DDSURFACEDESC *lpDDSurfaceDesc,
                                        IDirectDrawPalette *pPalette,
                                        const AM_MEDIA_TYPE *pmt)
{
    HRESULT hr = VFW_E_TYPE_NOT_ACCEPTED;
    //  If the type is acceptable and we're using
    //  our own allocator then QueryAccept is OK - we can
    //  just return the new type from GetBuffer
    if (m_bUsingMyAllocator) {
        if (S_OK == m_pConnectedPin->QueryAccept(pmt)) {
            hr = S_OK;
        }
    }

    //  Check if we'll be able to make a read-only sample
    if (m_bSamplesAreReadOnly) {
        //  If the pixel format is not OK
        if (!IsSupportedType(&lpDDSurfaceDesc->ddpfPixelFormat)) {
            hr = VFW_E_TYPE_NOT_ACCEPTED;
        }
    }

    //
    //  If we're stopped then we can attempt to reconnect
    //
    if (S_OK !=  hr && m_FilterState == State_Stopped) {
        AM_MEDIA_TYPE SavedType;
        DDSURFACEDESC ddsdSaved;
        CComPtr<IDirectDrawPalette> pPaletteSaved;
        ddsdSaved.dwSize = sizeof(ddsdSaved);
        ConnectionMediaType(&SavedType);
        GetFormatInternal(&ddsdSaved, &pPaletteSaved, NULL, NULL);
        CComPtr<IPin> pConnected = m_pConnectedPin;
        Disconnect();
        pConnected->Disconnect();
        IPin *ppinIn;
        IPin *ppinOut;
        if (m_Direction == PINDIR_INPUT) {
            ppinIn = this;
            ppinOut = pConnected;
        } else {
            ppinOut = this;
            ppinIn = pConnected;
        }
        HRESULT hrTmp = InternalSetFormat(lpDDSurfaceDesc, pPalette, false);   // Recurse!
        if (SUCCEEDED(hrTmp)) {
            CComQIPtr<IGraphBuilder, &IID_IGraphBuilder>
                pBuilder(m_pFilterGraph);
            hrTmp = pBuilder->Connect(ppinOut, ppinIn);
        }
        if (FAILED(hrTmp)) {
            SetFormat(&ddsdSaved, pPaletteSaved);
            m_pFilterGraph->ConnectDirect(ppinOut, ppinIn, &SavedType);
        } else {
            hr = S_OK;
        }
        CoTaskMemFree(SavedType.pbFormat);
    }
    return hr;
}


HRESULT CDDStream::InternalSetFormat(const DDSURFACEDESC *lpDDSurfaceDesc,
                                     IDirectDrawPalette *pPalette,
                                     bool bFromPin,
                                     bool bQuery)
{
    if (!lpDDSurfaceDesc) {
        return E_POINTER;
    }
    if (lpDDSurfaceDesc->dwSize != sizeof(*lpDDSurfaceDesc)) {
        return DDERR_INVALIDPARAMS;
    }

    DDSURFACEDESC ddsd;
    bool bPaletteAllocated = false;

    Lock();
    DDSURFACEDESC ddsdCopy;
    if (m_pConnectedPin && !bQuery &&
        (bFromPin && !(m_dwForcedFormatFlags & (DDSD_WIDTH | DDSD_HEIGHT)) ||
         !bFromPin && pPalette == NULL &&
             lpDDSurfaceDesc->ddpfPixelFormat.dwRGBBitCount == 8
        )
       ) {

        /*  See what size the connected pin would like :

            -- If the width and height haven't been specified set them
               to the output pin's preferred values
            -- If no palette is specified try to get one from the output
               pin
        */
        AM_MEDIA_TYPE *pmt;
        IEnumMediaTypes *pEnum;
        HRESULT hr = m_pConnectedPin->EnumMediaTypes(&pEnum);
        if (SUCCEEDED(hr)) {
            ULONG ulGot;
            bool bBreak = false;
            while (!bBreak && S_OK == pEnum->Next(1, &pmt, &ulGot)) {
                if (pmt->formattype == FORMAT_VideoInfo) {
                    VIDEOINFO *pvi = (VIDEOINFO *)pmt->pbFormat;
                    if (bFromPin) {
                        ddsdCopy = *lpDDSurfaceDesc;
                        ddsdCopy.dwWidth = pvi->bmiHeader.biWidth;
                        ddsdCopy.dwHeight = pvi->bmiHeader.biHeight < 0 ?
                                               -pvi->bmiHeader.biHeight :
                                               pvi->bmiHeader.biHeight;
                        lpDDSurfaceDesc = &ddsdCopy;
                        bBreak = true;
                    } else {
                        if (pmt->subtype == MEDIASUBTYPE_RGB8) {
                            DDSURFACEDESC ddsd;
                            _ASSERTE(pPalette == NULL);
                            if (SUCCEEDED(ConvertMediaTypeToSurfaceDesc(
                                    pmt,
                                    m_pDirectDraw,
                                    &pPalette,
                                    &ddsd)) &&
                                pPalette != NULL) {
                                bPaletteAllocated = true;
                            }
                            bBreak = true;
                        }
                    }
                }
                DeleteMediaType(pmt);
            }
            pEnum->Release();
        }
    }
    InitSurfaceDesc(&ddsd);
    ddsd.dwFlags = lpDDSurfaceDesc->dwFlags;
    bool bMatches = true;
    bool bPixelFmtMatches = true;
    BOOL bContradictsForced = FALSE;
    if (ddsd.dwFlags & (DDSD_HEIGHT | DDSD_WIDTH)) {
        if (ddsd.dwHeight != lpDDSurfaceDesc->dwHeight ||
            ddsd.dwWidth !=  lpDDSurfaceDesc->dwWidth) {
            bMatches = false;
            ddsd.dwHeight = lpDDSurfaceDesc->dwHeight;
            ddsd.dwWidth = lpDDSurfaceDesc->dwWidth;
            bContradictsForced |= (m_dwForcedFormatFlags & DDSD_HEIGHT);
        }
    }
    if (ddsd.dwFlags & DDSD_PIXELFORMAT) {
        if (!ComparePixelFormats(&ddsd.ddpfPixelFormat,
                                 &lpDDSurfaceDesc->ddpfPixelFormat)) {
            bMatches = false;
            bPixelFmtMatches = false;
            bContradictsForced |= (m_dwForcedFormatFlags & DDSD_PIXELFORMAT);
        }

        //  Always copy because ComparePixelFormats doesn't check all
        //  the bits but we need to save the correct format for making
        //  more surfaces
        memcpy(&ddsd.ddpfPixelFormat, &lpDDSurfaceDesc->ddpfPixelFormat, sizeof(ddsd.ddpfPixelFormat));
    }

    HRESULT hr;
    if (bMatches) {
        hr = S_OK;
    } else {
        if (bContradictsForced && bFromPin) {
            hr = VFW_E_TYPE_NOT_ACCEPTED;
        } else {
            if (m_cAllocated) {
                hr = MS_E_SAMPLEALLOC;
            } else {
                //
                //  If the pin is trying to change its own type via query accept then skip the
                //  renegotiation phase.
                //
                if (bFromPin || bQuery) {
                    // If we're connected then this is from QueryAccept so we'll say OK.  Otherwise, only
                    // accept a ReceiveConnection if the pixel format matches the display pixel format.
                    //
                    // NOTE - aren't we going to return S_OK always here?
                    // During connection m_pConnectedPin is not set anyway
                    // and bQuery already checks for QueryAccept (Robin)
                    hr = (m_pConnectedPin || bPixelFmtMatches) ? S_OK : VFW_E_TYPE_NOT_ACCEPTED;
                } else {
                    _ASSERTE(!bQuery);
                    // Note:  The below call to ConvertSurfaceDescToMediaType should always be done to make
                    // sure that the surface descriptor is valid, EVEN IF WE'RE NOT CONNECTED TO A PIN!
                    AM_MEDIA_TYPE *pmt;
                    hr = ConvertSurfaceDescToMediaType(lpDDSurfaceDesc, pPalette,
                                                       NULL, true, &pmt);
                    if (SUCCEEDED(hr)) {
                        hr = m_pConnectedPin ? RenegotiateMediaType(lpDDSurfaceDesc, pPalette, pmt) : S_OK;
                        DeleteMediaType(pmt);
                    }
                }
            }
        }
    }

    //
    //  Even if we match we may be forcing more format flags and
    //  setting caps flags
    if (S_OK == hr && !bQuery) {

        //  Don't update the pixel format if it was already forced
        if (ddsd.dwFlags & DDSD_PIXELFORMAT) {
            if (!bFromPin || !(m_dwForcedFormatFlags & DDSD_PIXELFORMAT)) {
                memcpy(&m_PixelFormat, &ddsd.ddpfPixelFormat, sizeof(m_PixelFormat));
                m_PixelFormat.dwSize = sizeof(m_PixelFormat);
            }
        }

        if (!bFromPin) {
            m_dwForcedFormatFlags = ddsd.dwFlags &
                (DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT | DDSD_CAPS);
        }
        m_pDirectDrawPalette = pPalette;

        if (ddsd.dwFlags & (DDSD_HEIGHT | DDSD_WIDTH)) {
            m_Height = ddsd.dwHeight;
            m_Width  = ddsd.dwWidth;
        }
    }

    if (bPaletteAllocated) {
        pPalette->Release();
        pPalette = NULL;
    }


    Unlock();
    return hr;
}


STDMETHODIMP CDDStream::GetDirectDraw(IDirectDraw **ppDirectDraw)
{
    TRACEINTERFACE(_T("IDirectDrawStream::GetDirectDraw(0x%8.8X)\n"),
                   ppDirectDraw);
    if (!ppDirectDraw) {
        return E_POINTER;
    }
    Lock();
    *ppDirectDraw = m_pDirectDraw;
    Unlock();
    if (*ppDirectDraw) {
        (*ppDirectDraw)->AddRef();
    }
    return S_OK;
}

STDMETHODIMP CDDStream::SetDirectDraw(IDirectDraw *pDirectDraw)
{
    TRACEINTERFACE(_T("IDirectDrawStream::SetDirectDraw(0x%8.8X)\n"),
                   pDirectDraw);
    HRESULT hr;
    AUTO_CRIT_LOCK;
    if (m_cAllocated) {
        hr = IsSameObject(m_pDirectDraw, pDirectDraw) ? S_OK : MS_E_SAMPLEALLOC;
    } else {
        //
        //  NOTE:  This is important!  We need to release ALL objects that were allocated
        //         by the previous DirectDraw object since they will magically disappear
        //         beneath us.  So far, the only object we hold is the palette so we'll copy
        //         the entries and then create a new object.
        //
        hr = S_OK;
        if (m_pDirectDrawPalette) {
            if (pDirectDraw) {
                PALETTEENTRY aPaletteEntry[256];
                hr = m_pDirectDrawPalette->GetEntries(0, 0, 256, aPaletteEntry);
                if (SUCCEEDED(hr)) {
                    CComPtr <IDirectDrawPalette> pNewPal;
                    hr = pDirectDraw->CreatePalette(DDPCAPS_8BIT | DDPCAPS_ALLOW256, aPaletteEntry, &pNewPal, NULL);
                    if (SUCCEEDED(hr)) {
                        m_pDirectDrawPalette = pNewPal;
                    }
                }
            } else {
                m_pDirectDrawPalette = NULL;    // If no direct draw object then toss the palette.
            }
        }
        if (SUCCEEDED(hr)) {
            m_pDirectDraw = pDirectDraw;
            if (pDirectDraw) {
                m_pDefPixelFormat = GetDefaultPixelFormatPtr(pDirectDraw);
            }
        }
    }
    return hr;
}



//
//  NOTE:  For this function, the caller MUST provide a rect.  The format of the surface
//  and the DirectDraw object are not checked for validity.  They are assumed to be correct.
//
HRESULT CDDStream::InternalCreateSample(IDirectDrawSurface *pSurface, const RECT *pRect,
                                        DWORD dwFlags, bool bIsInternalSample,
                                        IDirectDrawStreamSample **ppSample,
                                        bool bTemp)
{
    HRESULT hr = S_OK;
    *ppSample = NULL;

    AUTO_CRIT_LOCK;
    CDDSample *pSample;

    //  First check the surface format
    {
        DDSURFACEDESC ddsd;

        CComPtr<IDirectDrawPalette> pPalette;
        pSurface->GetPalette(&pPalette);
        ddsd.dwSize = sizeof(ddsd);
        _ASSERTE(pRect != NULL);
        hr = pSurface->GetSurfaceDesc(&ddsd);
        ddsd.dwWidth  = pRect->right - pRect->left;
        ddsd.dwHeight = pRect->bottom - pRect->top;
        if (SUCCEEDED(hr)) {
            hr = SetFormat(&ddsd, pPalette ? pPalette : m_pDirectDrawPalette);
        }
    }

    if (SUCCEEDED(hr)) {
        if (bIsInternalSample) {
            CDDInternalSample *pInternal = new CComObject<CDDInternalSample>;
            if (pInternal != NULL) {
                hr = pInternal->InternalInit();
            }
            pSample = pInternal;
        } else {
            pSample = new CComObject<CDDSample>;
        }
        if (pSample) {
            //
            //  InitSample will increment our m_cAllocated variable if this is not an internal sample....
            //
            if (SUCCEEDED(hr)) {
                hr = pSample->InitSample(this, pSurface, pRect, dwFlags & DDSFF_PROGRESSIVERENDER, bIsInternalSample,
                                         bTemp);
            }
            if (SUCCEEDED(hr)) {
                pSample->GetControllingUnknown()->QueryInterface(IID_IDirectDrawStreamSample, (void **)ppSample);
            } else {
                delete pSample;
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    }

#if 0
    //  Use the real pixel format for subsequent surfaces
    if (SUCCEEDED(hr)) {
        m_PixelFormat.dwFlags = ddsd.ddpfPixelFormat.dwFlags;
    }
#endif

    return hr;
}



STDMETHODIMP CDDStream::CreateSample(IDirectDrawSurface *pSurface, const RECT *pRect, DWORD dwFlags,
                                     IDirectDrawStreamSample **ppSample)
{
    TRACEINTERFACE(_T("IDirectDrawStream::CreateSample(0x%8.8X, 0x%8.8X, 0x%8.8X, 0x%8.8X)\n"),
                   pSurface, pRect, dwFlags, ppSample);
    HRESULT hr;
    *ppSample = NULL;

    if (dwFlags & (~DDSFF_PROGRESSIVERENDER)) {
        return E_INVALIDARG;
    }

    AUTO_CRIT_LOCK;
    if (pSurface == NULL) {
        if (pRect) {
            hr = E_INVALIDARG;
        } else {
            hr = InternalAllocateSample(dwFlags, false, ppSample);
        }
    } else {
        CComQIPtr <IDirectDrawSurface2, &IID_IDirectDrawSurface2> pSurf2(pSurface);

        //  Work around DDrawEx bug
        IUnknown *pUnk;
        hr = pSurf2->GetDDInterface((void **)&pUnk);
        if (SUCCEEDED(hr)) {
            IDirectDraw *pDD;
            hr = pUnk->QueryInterface(IID_IDirectDraw, (void **)&pDD);
            pUnk->Release();
            if (SUCCEEDED(hr)) {
                hr = SetDirectDraw(pDD);
                pDD->Release();
            }
        }

        if (SUCCEEDED(hr)) {
            DDSURFACEDESC ddsd;
            ddsd.dwSize = sizeof(ddsd);
            hr = pSurface->GetSurfaceDesc(&ddsd);

            if (SUCCEEDED(hr)) {
                RECT SubRect;
                if (pRect) {
                    SubRect = *pRect;
                    if (SubRect.left > SubRect.right || SubRect.right > (LONG)ddsd.dwWidth ||
                        SubRect.top > SubRect.bottom || SubRect.bottom > (LONG)ddsd.dwHeight) {
                        hr = DDERR_INVALIDRECT;
                        goto Exit;
                    }
                    ddsd.dwWidth = SubRect.right - SubRect.left;
                    ddsd.dwHeight = SubRect.bottom - SubRect.top;
                } else {
                    SubRect.top = SubRect.left = 0;
                    SubRect.bottom = ddsd.dwHeight;
                    SubRect.right = ddsd.dwWidth;
                }

                //
                //  We don't set the CAPS flag here so we won't force a particular caps
                //  mode.  I'm not sure if this is the right choice, but it seems more
                //  flexible.
                //
                ddsd.dwFlags &= (DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT);
                CComPtr<IDirectDrawPalette> pPalette;
                pSurface->GetPalette(&pPalette);
                hr = SetFormat(&ddsd, pPalette);
                if (SUCCEEDED(hr)) {
                    hr = InternalCreateSample(pSurface, &SubRect, dwFlags, false, ppSample);
                }
            }
        }
    }
Exit:
    return hr;
}

//  Get the time per frame
//  If we're connected this comes out of the media type, otherwise we
//  don't know
STDMETHODIMP CDDStream::GetTimePerFrame(
        /* [out] */ STREAM_TIME *pFrameTime
)
{
    if (pFrameTime == NULL) {
        return E_POINTER;
    }
    AUTO_CRIT_LOCK;
    if (m_pConnectedPin) {
        *pFrameTime = ((VIDEOINFO *)m_ConnectedMediaType.pbFormat)->AvgTimePerFrame;
    } else {
        return MS_E_NOSTREAM;
    }
    return S_OK;
}

//
//  IPin implementation
//

STDMETHODIMP CDDStream::ReceiveConnection(IPin * pConnector, const AM_MEDIA_TYPE *pmt)
{
    AUTO_CRIT_LOCK;
    //
    //  This helper function in CStream checks basic parameters for the Pin such as
    //  the connecting pin's direction (we need to check this -- Sometimes the filter
    //  graph will try to connect us to ourselves!) and other errors like already being
    //  connected, etc.
    //
    HRESULT hr = CheckReceiveConnectionPin(pConnector);

    if (hr == NOERROR && pmt->formattype == FORMAT_VideoInfo) {
        //
        //  Check the source accepts negative heights
        //
        VIDEOINFO * const pvi = (VIDEOINFO *)pmt->pbFormat;
        if (pvi->bmiHeader.biHeight > 0) {
            VIDEOINFO vi;
            CopyMemory((PVOID)&vi, (PVOID)pmt->pbFormat,
                       min(pmt->cbFormat, sizeof(vi)));
            AM_MEDIA_TYPE mt = *pmt;
            mt.pbFormat = (PBYTE)&vi;
            vi.bmiHeader.biHeight = - vi.bmiHeader.biHeight;
            if (S_OK != pConnector->QueryAccept(&mt)) {
                hr = VFW_E_TYPE_NOT_ACCEPTED;
            }
        }
    }

    if (hr == NOERROR) {
        DDSURFACEDESC SurfaceDesc;
        SurfaceDesc.dwSize = sizeof(DDSURFACEDESC);
        CComPtr <IDirectDrawPalette> pPalette;
        m_pConnectedPin = pConnector;
        if (NOERROR == ConvertMediaTypeToSurfaceDesc(pmt, m_pDirectDraw, &pPalette, &SurfaceDesc) &&
            SUCCEEDED(InternalSetFormat(&SurfaceDesc, pPalette, true))) {
            CopyMediaType(&m_ConnectedMediaType, pmt);
            CopyMediaType(&m_ActualMediaType, pmt);
            hr = NOERROR;
        } else {
            m_pConnectedPin = NULL;
            hr = VFW_E_TYPE_NOT_ACCEPTED;
        }
    }
    if (SUCCEEDED(hr)) {
        pConnector->QueryInterface(IID_IQualityControl, (void **)&m_pQC);
    }

    return hr;
}


STDMETHODIMP CDDStream::QueryAccept(const AM_MEDIA_TYPE *pmt)
{
    AUTO_CRIT_LOCK;

    HRESULT hr = VFW_E_TYPE_NOT_ACCEPTED;
    DDSURFACEDESC SurfaceDesc;
    SurfaceDesc.dwSize = sizeof(DDSURFACEDESC);
    CComPtr <IDirectDrawPalette> pPalette;
    if (S_OK == ConvertMediaTypeToSurfaceDesc(pmt, m_pDirectDraw, &pPalette, &SurfaceDesc) &&
        SUCCEEDED(InternalSetFormat(&SurfaceDesc, pPalette, true, true)) &&
        ((VIDEOINFOHEADER *)pmt->pbFormat)->bmiHeader.biHeight >= 0) {
        hr = S_OK;
    }
    return hr;
}


STDMETHODIMP CDDStream::Receive(IMediaSample *pMediaSample)
{
    bool bDummySample = false;

    if (m_bFlushing || m_bStopIfNoSamples && m_cAllocated == 0) {
        EndOfStream();
        return S_FALSE;
    }
    HRESULT hr = S_OK;
#ifdef DEBUG
    if (bDbgTraceTimes) {
        REFERENCE_TIME rtStart, rtStop;
        if (SUCCEEDED(pMediaSample->GetTime(&rtStart, &rtStop))) {
            ATLTRACE(_T("AMSTREAM.DLL : Video sample received - start %dms, end %dms, duration %dms\n"),
                     (LONG)(rtStart / 10000), (LONG)(rtStop / 10000),
                     (LONG)((rtStop - rtStart) / 10000));
        }
    }
#endif
    if (m_bUsingMyAllocator) {
        CDDSample *pSrcSample = (CDDSample *)((CMediaSample *)pMediaSample)->m_pSample;
        pSrcSample->ReleaseMediaSampleLock();
        pSrcSample->m_bReceived = true;
        if (!pSrcSample->m_bWaited) {
            //  Wait for render time
            REFERENCE_TIME rtStart, rtStop;
            if (SUCCEEDED(pMediaSample->GetTime(&rtStart, &rtStop))) {
                m_pFilter->WaitUntil(rtStart);
            }
        }
        if (pSrcSample->IsTemp()) {
            bDummySample = true;
        } else {
#ifdef SHOWSURFACES
            ShowSurface(pSrcSample->m_pSurface);
#endif
            //  In this case if the read-only sample has no buddy then
            //  it's a temp sample for the nostall stuff
            if (pSrcSample == m_pMyReadOnlySample &&
                !m_pMyReadOnlySample->HasBuddy()) {
                _ASSERTE(m_bNoStall);
                bDummySample = true;
            }
        }
    } else {
        CDDSample *pDestSample;
        REFERENCE_TIME rtStart, rtEnd;
        pMediaSample->GetTime(&rtStart, &rtEnd);
        hr = AllocDDSampleFromPool(&rtStart, &pDestSample);


        if (SUCCEEDED(hr)) {
            _ASSERTE(!pDestSample->IsTemp());
            Lock();
            // This is a media sample coming from a different allocator.
            AM_MEDIA_TYPE *pNewMediaType;
            if (pMediaSample->GetMediaType(&pNewMediaType) == S_OK) {
                FreeMediaType(m_ActualMediaType);
                //  Note just copying has the effect
                //  of transferring pNewMediaType's format block
                //  and pUnk reference count
                //  Also this way we avoid allocation failures
                m_ActualMediaType = *pNewMediaType;
                CoTaskMemFree((PVOID)pNewMediaType);
            }
            if (SUCCEEDED(hr)) {
                hr = pDestSample->CopyFrom(pMediaSample, &m_ActualMediaType);
#ifdef SHOWSURFACES
                ShowSurface(pDestSample->m_pSurface);
#endif
                hr = pDestSample->SetCompletionStatus(hr);
                // Warning!  The SetCompletionStatus may delete pDestSample.  Don't touch it after this point!
            }
            Unlock();
        } else {
            //  Might be timeout which means we become a zombie
            hr = S_OK;
            bDummySample = true;
        }
    }

    //  Send quality message if clocked
    //  NOTE - we must do this AFTER releasing the media sample lock
    //  or we can deadlock on the win16 lock when querying the clock
    //  because dsound can be running on another thread waiting for
    //  the win16 lock but holding its global mutex
    REFERENCE_TIME CurTime;
    if (S_OK == m_pFilter->GetCurrentStreamTime(&CurTime)) {
        REFERENCE_TIME rtStart, rtStop;
        if (m_pQC && SUCCEEDED(pMediaSample->GetTime(&rtStart, &rtStop))) {
            Quality msg;
            msg.Proportion = 1000;
            msg.Type = Famine;
            msg.Late = CurTime - rtStart;
            msg.TimeStamp = rtStart;
            if (bDummySample) {
                //  Tell them they're later than they actually are
                msg.Late += 150 * 10000;
            }

            //  Call Notify on our connected pin
            m_pQC->Notify(m_pBaseFilter, msg);

            //ATLTRACE("Late by %dms\n", (LONG)((CurTime - rtStart) / 10000));
        } else {
            //ATLTRACE("No timestamp\n");
        }
    }

#ifdef DEBUG
    if (bDbgTraceTimes) {
        REFERENCE_TIME CurTime;
        m_pFilter->GetCurrentStreamTime(&CurTime);
        ATLTRACE(_T("AMSTREAM.DLL : Got sample at %dms\n"),
                 (LONG)(CurTime / 10000));
    }
#endif
    return hr;
}


STDMETHODIMP CDDStream::NotifyAllocator(IMemAllocator * pAllocator, BOOL bReadOnly)
{
    if (bReadOnly) {
        //  If the pixel format is not OK
        if (!IsSupportedType(&m_PixelFormat)) {
            return VFW_E_TYPE_NOT_ACCEPTED;
        }
    }
    return CStream::NotifyAllocator(pAllocator, bReadOnly);
}


//
// IMemAllocator implementation
//

//
// IMemAllocator
//
STDMETHODIMP CDDStream::SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual)
{
    HRESULT hr;

    AUTO_CRIT_LOCK;
    ZeroMemory(pActual, sizeof(*pActual));
    if (pRequest->cbAlign == 0) {
    	hr = VFW_E_BADALIGN;
    } else {
        if (m_bCommitted == TRUE) {
    	    hr = VFW_E_ALREADY_COMMITTED;
    	} else {
            m_lRequestedBufferCount = pRequest->cBuffers;
            hr = GetProperties(pActual);
    	}
    }
    return hr;
}


STDMETHODIMP CDDStream::GetProperties(ALLOCATOR_PROPERTIES* pProps)
{
    AUTO_CRIT_LOCK;
    AM_MEDIA_TYPE *pMediaType;
    HRESULT hr = GetMediaType(-1, &pMediaType);
    if (SUCCEEDED(hr)) {
        VIDEOINFO *pVideoInfo = (VIDEOINFO *)pMediaType->pbFormat;
        BITMAPINFOHEADER *pbmiHeader = &pVideoInfo->bmiHeader;
        pProps->cbBuffer = pbmiHeader->biSizeImage;
        pProps->cBuffers = m_lRequestedBufferCount ?
                               m_lRequestedBufferCount : 1;
        pProps->cbAlign = 1;
        pProps->cbPrefix = 0;
        DeleteMediaType(pMediaType);
    }
    return hr;
}


STDMETHODIMP CDDStream::Decommit()
{
    AUTO_CRIT_LOCK;
    if (m_pMyReadOnlySample) {
        m_pMyReadOnlySample->Die();
        m_pMyReadOnlySample->GetControllingUnknown()->Release();
        m_pMyReadOnlySample = NULL;
    }
    return CStream::Decommit();
}

//
//  This method assumes the critical section is *NOT* owned!
//

HRESULT CDDStream::GetMyReadOnlySample(CDDSample *pBuddy, CDDSample **ppSample)
{
    *ppSample = NULL;
    CDDInternalSample *pROSample;
    Lock();
    if (!m_pMyReadOnlySample) {
        IDirectDrawStreamSample *pDDSample;
        HRESULT hr = InternalAllocateSample(DDSFF_PROGRESSIVERENDER, true, &pDDSample);
        if (FAILED(hr)) {
            Unlock();
            return hr;
        }
        m_pMyReadOnlySample = (CDDInternalSample *)pDDSample;
    }
    pROSample = m_pMyReadOnlySample;
    pROSample->GetControllingUnknown()->AddRef();
    Unlock();
    //
    //  Must leave our critical section here!  This is very important since JoinToBuddy can fail.
    //
    HRESULT hr;
    if (pBuddy) {
        hr = pROSample->JoinToBuddy(pBuddy);
    } else {
        hr = S_OK;
    }
    if (hr == S_OK) {
        *ppSample = pROSample;
    } else {
        pROSample->GetControllingUnknown()->Release();
    }
    return hr;
}





STDMETHODIMP CDDStream::GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME * pStartTime,
                                  REFERENCE_TIME * pEndTime, DWORD dwFlags)
{
    *ppBuffer = NULL;
    if (m_bStopIfNoSamples && m_cAllocated == 0) {
        return E_FAIL;
    }
    CDDSample *pSample;
#ifdef DEBUG
    if (bDbgTraceTimes) {
        ATLTRACE(_T("AMSTREAM.DLL : GetBuffer for %dms\n"),
                 pStartTime ? (LONG)(*pStartTime / 10000)  : 0);
    }
#endif
    HRESULT hr = AllocDDSampleFromPool(pStartTime, &pSample);
    if (SUCCEEDED(hr)) {
        if (CreateInternalSample() && !pSample->m_bProgressiveRender) {
            CDDSample *pMyReadOnlySample;
            hr = GetMyReadOnlySample(pSample, &pMyReadOnlySample);
            if (FAILED(hr)) {
                return pSample->SetCompletionStatus(hr);
            }
            pSample = pMyReadOnlySample;
        }
        Lock();
        pSample->m_pMediaSample->m_dwFlags = dwFlags;
        m_lLastPitch = pSample->LockAndPrepareMediaSample(m_lLastPitch);
        if (m_lLastPitch == 0) {
            hr = pSample->SetCompletionStatus(E_UNEXPECTED);    // Really strange to fail this way!
        } else {
            pSample->m_bReceived = false;
            pSample->m_bModified = true;
            *ppBuffer = (IMediaSample *)(pSample->m_pMediaSample);
            (*ppBuffer)->AddRef();
        }
        Unlock();
    }
    return hr;
}


//
// Special CStream methods
//
HRESULT CDDStream::GetMediaType(ULONG Index, AM_MEDIA_TYPE **ppMediaType)
{
    if (Index != 0 && Index != -1) {
        return S_FALSE;
    }

    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    CComPtr<IDirectDrawPalette> pPalette;
    GetFormatInternal(&ddsd, &pPalette, NULL, NULL);
    HRESULT hr = ConvertSurfaceDescToMediaType(&ddsd, pPalette, NULL, TRUE, ppMediaType);

    //  Don't offer a type for input - someone might use it!
    if (SUCCEEDED(hr) && m_Direction == PINDIR_INPUT && Index == 0) {
        //  Something impossible - or at least something we'll reject
        //  but something they won't fall over on
        (*ppMediaType)->formattype = GUID_NULL;
    }

    return hr;
}


//  Create a temporary sample in order to throw away the data
HRESULT CDDStream::CreateTempSample(CSample **ppSample)
{
    if (CreateInternalSample()) {
        CDDSample *pDDSample;
        HRESULT hr = GetMyReadOnlySample(NULL, &pDDSample);
        *ppSample = pDDSample;
        return hr;
    }
    //ATLTRACE("Creating temp sample\n");
    IDirectDrawStreamSample *pSample;
    *ppSample = NULL;

    //  This must be allocated as an internal sample otherwise
    //  we wind up AddRef'ing the filter graph and leaking
    //  everything (because the final release is on a filter
    //  thread and the filter graph hangs waiting for the thread
    //  that is actually doing the final release to go away).
    HRESULT hr = InternalAllocateSample(0, true, &pSample, true);
    if (SUCCEEDED(hr)) {
        *ppSample = static_cast<CDDSample *>(pSample);
    } else {
        //ATLTRACE("Failed to create temp sample\n");
    }
    return hr;
}

STDMETHODIMP CDDStream::Initialize(IUnknown *pSourceObject, DWORD dwFlags, REFMSPID PurposeId, const STREAM_TYPE StreamType)
{
    //
    TRACEINTERFACE(_T("IDirectDrawStream::Initialize(0x%8.8X, 0x%8.8X, %s, %d)\n"),
                   pSourceObject, dwFlags, TextFromPurposeId(PurposeId), StreamType);
    //  It is important to call the base class first since if we are creating a peer
    //  stream then the Initalize call from the base class will end up calling SetSameFormat
    //  which will initialize this stream with the same directdraw object as it's peer.
    //  Otherwise, if the pSourceObject is actually a DirectDraw then we'll use that one.
    //
    HRESULT hr = CStream::Initialize(pSourceObject,
                                     dwFlags & ~AMMSF_NOSTALL,
                                     PurposeId,
                                     StreamType);
    if (SUCCEEDED(hr)) {

        if (dwFlags & AMMSF_NOSTALL) {
            m_bNoStall = true;
        }
        IDirectDraw *pDD;
        if (pSourceObject &&
            pSourceObject->QueryInterface(IID_IDirectDraw, (void **)&pDD) == S_OK) {
            SetDirectDraw(pDD);
            pDD->Release();
        } else {
            hr = InitDirectDraw();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\medsampl.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "project.h"

CAMMediaTypeSample::CAMMediaTypeSample() :
    m_pDataPointer(NULL),
    m_lSize(0),
    m_lActualDataLength(0),
    m_bIAllocatedThisBuffer(false)
{};


HRESULT CAMMediaTypeSample::Initialize(CAMMediaTypeStream *pStream, long lSize, BYTE *pData)
{
    HRESULT hr = CSample::InitSample(pStream, false);
    if (SUCCEEDED(hr)) {
        hr = SetPointer(pData, lSize);
    }
    return hr;
}

CAMMediaTypeSample::~CAMMediaTypeSample()
{
    if (m_bIAllocatedThisBuffer) {
        CoTaskMemFree(m_pDataPointer);
    }
}

HRESULT CAMMediaTypeSample::CopyFrom(IMediaSample *pSrcMediaSample)
{
    AUTO_SAMPLE_LOCK;
    CSample::CopyFrom(pSrcMediaSample);
    BYTE * pBytes;
    HRESULT hr = pSrcMediaSample->GetPointer(&pBytes);
    if (SUCCEEDED(hr)) {
        LONG lCopySize = pSrcMediaSample->GetActualDataLength();
        if (lCopySize > m_lSize) {
            hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
            lCopySize = m_lSize;
        }
        memcpy(m_pDataPointer, pBytes, lCopySize);
    }
    return hr;
}


STDMETHODIMP CAMMediaTypeSample::SetPointer(BYTE * pBuffer, LONG lSize)
{
    AUTO_SAMPLE_LOCK;
    HRESULT hr = S_OK;
    if (m_bIAllocatedThisBuffer) {
        CoTaskMemFree(m_pDataPointer);
        m_bIAllocatedThisBuffer = false;
    }
    m_lSize = lSize;
    if (pBuffer) {
        m_pDataPointer = pBuffer;
    } else {
        m_pDataPointer = (BYTE *)CoTaskMemAlloc(lSize);
        if (!m_pDataPointer) {
            hr = E_OUTOFMEMORY;
        } else {
            m_bIAllocatedThisBuffer = true;
        }
    }
    m_lActualDataLength = 0;
    return hr;
}



#define STDMETHOD_FORWARD0(fctn) STDMETHODIMP CAMMediaTypeSample::fctn(void) { return m_pMediaSample->fctn(); }
#define STDMETHOD_FORWARD1(fctn, t1) STDMETHODIMP CAMMediaTypeSample::fctn(t1 p1) { return m_pMediaSample->fctn(p1); }
#define STDMETHOD_FORWARD2(fctn, t1, t2) STDMETHODIMP CAMMediaTypeSample::fctn(t1 p1, t2 p2) { return m_pMediaSample->fctn(p1, p2); }
#define LONG_RET_VAL_FWD(fctn) STDMETHODIMP_(LONG) CAMMediaTypeSample::fctn(void) { return m_pMediaSample->fctn(); }

STDMETHOD_FORWARD1(GetPointer, BYTE **)
LONG_RET_VAL_FWD  (GetSize)
STDMETHOD_FORWARD2(GetTime, REFERENCE_TIME *, REFERENCE_TIME *)
STDMETHOD_FORWARD2(SetTime, REFERENCE_TIME *, REFERENCE_TIME *)
STDMETHOD_FORWARD0(IsSyncPoint)
STDMETHOD_FORWARD1(SetSyncPoint, BOOL)
STDMETHOD_FORWARD0(IsPreroll)
STDMETHOD_FORWARD1(SetPreroll, BOOL)
LONG_RET_VAL_FWD  (GetActualDataLength)
STDMETHOD_FORWARD1(SetActualDataLength, LONG)
STDMETHOD_FORWARD1(GetMediaType, AM_MEDIA_TYPE **)
STDMETHOD_FORWARD1(SetMediaType, AM_MEDIA_TYPE *)
STDMETHOD_FORWARD0(IsDiscontinuity)
STDMETHOD_FORWARD1(SetDiscontinuity, BOOL)
STDMETHOD_FORWARD2(GetMediaTime, LONGLONG *, LONGLONG *)
STDMETHOD_FORWARD2(SetMediaTime, LONGLONG *, LONGLONG *)

HRESULT CAMMediaTypeSample::MSCallback_GetPointer(BYTE **ppBuffer)
{
    *ppBuffer = m_pDataPointer;
    return S_OK;
}

LONG CAMMediaTypeSample::MSCallback_GetSize(void)
{
    return m_lSize;
}

LONG CAMMediaTypeSample::MSCallback_GetActualDataLength(void) {
    return m_lActualDataLength;
}

HRESULT CAMMediaTypeSample::MSCallback_SetActualDataLength(LONG lActual)
{
    if (lActual >= 0 && lActual <= m_lSize) {
        m_lActualDataLength = lActual;
        return S_OK;
    } else {
        return E_INVALIDARG;
    }
}

bool CAMMediaTypeSample::MSCallback_AllowSetMediaTypeOnMediaSample(void)
{
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\mtenum.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.

#ifndef __MTENUM_H_INC__
#define __MTENUM_H_INC__

class ATL_NO_VTABLE CMediaTypeEnum : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IEnumMediaTypes
{
public:
        // 
        // METHODS
        //
        CMediaTypeEnum();
        ~CMediaTypeEnum();

        DECLARE_GET_CONTROLLING_UNKNOWN()

        void Initialize(CStream *pStream, ULONG cCurPos);

        //
        // IEnumMediaTypes
        //
        STDMETHODIMP Next(ULONG cNumToFetch, AM_MEDIA_TYPE **ppMediaTypes, ULONG *pcFetched);
        STDMETHODIMP Skip(ULONG cSkip);
        STDMETHODIMP Reset();
        STDMETHODIMP Clone(IEnumMediaTypes **ppEnumMediaTypes);

BEGIN_COM_MAP(CMediaTypeEnum)
        COM_INTERFACE_ENTRY(IEnumMediaTypes)
END_COM_MAP()

public:
        ULONG           m_cCurrentPos;
        CStream         *m_pStream;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\mss.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// mss.cpp : Implementation of CAMMediaTypeStream
#include "stdafx.h"
#include "project.h"


/////////////////////////////////////////////////////////////////////////////
// CAMMediaTypeStream

CAMMediaTypeStream::CAMMediaTypeStream()
{
    InitMediaType(&m_MediaType);
    m_AllocatorProperties.cBuffers = 1;
    m_AllocatorProperties.cbBuffer = 0x1000;
    m_AllocatorProperties.cbAlign = 1;

    //  We don't require any prefix.  If there is a prefix we don't
    //  need to add it in GetPointer - it's hidden unless we want to
    //  access it.
    m_AllocatorProperties.cbPrefix = 0;
}



STDMETHODIMP CAMMediaTypeStream::AllocateSample(DWORD dwFlags, IStreamSample **ppSample)
{
    TRACEINTERFACE(_T("IDirectDrawStream::AllocateSample(0x%8.8X, 0x%8.8X)\n"),
                   dwFlags, ppSample);
    HRESULT hr;
    if (!ppSample) {
        hr = E_POINTER;
    } else {
        *ppSample = NULL;
        if (dwFlags) {
            hr = E_INVALIDARG;
        } else {
            hr = CreateSample(m_AllocatorProperties.cbBuffer, NULL, 0, NULL,
                              (IAMMediaTypeSample **)ppSample);
        }
    }
    return hr;
}


STDMETHODIMP CAMMediaTypeStream::CreateSharedSample(IStreamSample *pExistingSample,
                                           DWORD dwFlags,
                                           IStreamSample **ppNewSample)
{
    return E_NOTIMPL;   // There really is no way to share data since the actual
                        // size of the data can not be transfered.
}

STDMETHODIMP CAMMediaTypeStream::SetSameFormat(IMediaStream *pStream, DWORD dwFlags)
{
    TRACEINTERFACE(_T("IAMMediaSampleStream::SetSameFormat(0x%8.8X, 0x%8.8X)\n"),
                   pStream, dwFlags);
    CComQIPtr<IAMMediaTypeStream, &IID_IAMMediaTypeStream> pSource(pStream);
    HRESULT hr;
    if (!pSource) {
        hr = MS_E_INCOMPATIBLE;
    } else {
        AM_MEDIA_TYPE MediaType;
        hr = pSource->GetFormat(&MediaType, 0);
        if (SUCCEEDED(hr)) {
            hr = SetFormat(&MediaType, 0);
            FreeMediaType(MediaType);
        }
    }
    return hr;
}



////////////////////////////////////

STDMETHODIMP CAMMediaTypeStream::GetFormat(AM_MEDIA_TYPE *pMediaType, DWORD dwFlags)
{
    AUTO_CRIT_LOCK;
    HRESULT hr = S_OK;

    if (m_pConnectedPin) {
        CopyMediaType(pMediaType, &m_MediaType);
    } else {
        hr = MS_E_NOSTREAM;
    }

    return hr;
}

STDMETHODIMP CAMMediaTypeStream::SetFormat(AM_MEDIA_TYPE *pMediaType, DWORD dwFlags)
{
    AUTO_CRIT_LOCK;
    HRESULT hr = S_OK;
    if (m_cAllocated) {
        if (!IsEqualMediaType(*pMediaType, m_MediaType)) {
            hr = MS_E_SAMPLEALLOC;
        }
    } else {
        FreeMediaType(m_MediaType);
        CopyMediaType(&m_MediaType, pMediaType);
    }
    return hr;
}

STDMETHODIMP CAMMediaTypeStream::CreateSample(long lSampleSize, BYTE * pbBuffer,
                                              DWORD dwFlags,
                                              IUnknown * pUnkOuter,
                                              IAMMediaTypeSample **ppSample)
{
    AUTO_CRIT_LOCK;
    HRESULT hr;
    if (!ppSample) {
        hr = E_POINTER;
    } else {
        *ppSample = NULL;
        CComPolyObject<CAMMediaTypeSample> * pATLSampleObject = new CComPolyObject<CAMMediaTypeSample>(pUnkOuter);
        if (!pATLSampleObject) {
            hr = E_OUTOFMEMORY;
        } else {
            CAMMediaTypeSample *pNewSample = &pATLSampleObject->m_contained;
            hr = pNewSample->Initialize(this, lSampleSize, pbBuffer);
            if (SUCCEEDED(hr)) {
                pNewSample->GetControllingUnknown()->QueryInterface(IID_IAMMediaTypeSample, (void **)ppSample);
            } else {
                delete pATLSampleObject;
            }
        }
    }
    return hr;
}

STDMETHODIMP CAMMediaTypeStream::GetStreamAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps)
{
    return E_FAIL;
}


STDMETHODIMP CAMMediaTypeStream::SetStreamAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps)
{
    return E_FAIL;
}




//
//  IPin implementation
//

STDMETHODIMP CAMMediaTypeStream::ReceiveConnection(IPin * pConnector, const AM_MEDIA_TYPE *pmt)
{
    // Check the type is accepted and then save the connected pin
    HRESULT hr = QueryAccept(pmt);
    if (FAILED(hr)) {
        return hr;
    }
    AUTO_CRIT_LOCK;
    m_pConnectedPin = pConnector;
    return hr;
}


STDMETHODIMP CAMMediaTypeStream::QueryAccept(const AM_MEDIA_TYPE *pmt)
{
    AUTO_CRIT_LOCK;
    return (IsEqualMediaType(*pmt, m_MediaType) ? S_OK : VFW_E_TYPE_NOT_ACCEPTED);
}


STDMETHODIMP CAMMediaTypeStream::Receive(IMediaSample *pMediaSample)
{
    if (m_bFlushing || m_bStopIfNoSamples && m_cAllocated == 0) {
        EndOfStream();
        return S_FALSE;
    }

    HRESULT hr = S_OK;
    //  Send quality message if clocked
    REFERENCE_TIME CurTime;
    if (S_OK == m_pFilter->GetCurrentStreamTime(&CurTime)) {
        REFERENCE_TIME rtStart, rtStop;
        if (m_pQC && SUCCEEDED(pMediaSample->GetTime(&rtStart, &rtStop))) {
            Quality msg;
            msg.Proportion = 1000;
            msg.Type = Famine;
            msg.Late = CurTime - rtStart;
            msg.TimeStamp = rtStart;

            //  Call Notify on our connected pin
            m_pQC->Notify(m_pBaseFilter, msg);
        }
    }
#ifdef DEBUG
    if (bDbgTraceTimes) {
        REFERENCE_TIME rtStart, rtStop;
        if (SUCCEEDED(pMediaSample->GetTime(&rtStart, &rtStop))) {
            ATLTRACE(_T("AMSTREAM.DLL : Video sample received - start %dms, end %dms\n"),
                     (LONG)(rtStart / 10000), (LONG)(rtStop / 10000));
        }
    }
#endif
    if (m_bUsingMyAllocator) {
        CAMMediaTypeSample *pSrcSample = (CAMMediaTypeSample *)((CMediaSample *)pMediaSample)->m_pSample;
        pSrcSample->m_bReceived = true;
    } else {
        CAMMediaTypeSample *pDestSample;
        REFERENCE_TIME rtStart, rtEnd;
        pMediaSample->GetTime(&rtStart, &rtEnd);
        hr = AllocMTSampleFromPool(&rtStart, &pDestSample);
        Lock();
        // This is a media sample coming from a different allocator.
        // Because QueryAccept only accepts our type the format should
        // be compatible
        if (SUCCEEDED(hr)) {
            hr = pDestSample->SetCompletionStatus(pDestSample->CopyFrom(pMediaSample));
            // Warning!  The SetCompletionStatus may delete pDestSample.  Don't touch it after this point!
        }
        Unlock();
    }

#ifdef DEBUG
    if (bDbgTraceTimes) {
        REFERENCE_TIME CurTime;
        m_pFilter->GetCurrentStreamTime(&CurTime);
        ATLTRACE(_T("AMSTREAM.DLL : Got sample at %dms\n"),
                 (LONG)(CurTime / 10000));
    }
#endif
    return hr;
}



//
// IMemAllocator implementation
//

//
// IMemAllocator
//
STDMETHODIMP CAMMediaTypeStream::SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual)
{
    HRESULT hr;

    AUTO_CRIT_LOCK;
    ZeroMemory(pActual, sizeof(*pActual));
    if (pRequest->cbAlign == 0) {
    	hr = VFW_E_BADALIGN;
    } else {
        if (m_bCommitted == TRUE) {
    	    hr = VFW_E_ALREADY_COMMITTED;
    	} else {

            m_AllocatorProperties = *pRequest;
            hr = GetProperties(pActual);
    	}
    }
    return hr;
}


STDMETHODIMP CAMMediaTypeStream::GetProperties(ALLOCATOR_PROPERTIES* pProps)
{
    AUTO_CRIT_LOCK;
    CopyMemory(pProps, &m_AllocatorProperties, sizeof(*pProps));
    return S_OK;
}





STDMETHODIMP CAMMediaTypeStream::GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME * pStartTime,
                                  REFERENCE_TIME * pEndTime, DWORD dwFlags)
{
    *ppBuffer = NULL;
    CAMMediaTypeSample *pSample;
    if (m_bStopIfNoSamples && m_cAllocated == 0) {
        return E_FAIL;
    }
#ifdef DEBUG
    if (bDbgTraceTimes) {
        ATLTRACE(_T("AMSTREAM.DLL : GetBuffer for %dms\n"),
                 pStartTime ? (LONG)(*pStartTime / 10000)  : 0);
    }
#endif
    HRESULT hr = AllocMTSampleFromPool(pStartTime, &pSample);
    if (SUCCEEDED(hr)) {
        pSample->m_bReceived = false;
        pSample->m_bModified = true;
        *ppBuffer = (IMediaSample *)(pSample->m_pMediaSample);
        (*ppBuffer)->AddRef();
    }
    return hr;
}


//
// Special CStream methods
//
HRESULT CAMMediaTypeStream::GetMediaType(ULONG Index, AM_MEDIA_TYPE **ppMediaType)
{
    if (Index != 0) {
        return S_FALSE;
    }

    *ppMediaType = CreateMediaType(&m_MediaType);
    return (*ppMediaType) ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\mtenum.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "project.h"


CMediaTypeEnum::CMediaTypeEnum() :
    m_cCurrentPos(0),
    m_pStream(NULL)
{
}

void CMediaTypeEnum::Initialize(CStream *pStream, ULONG cCurPos)
{
    m_pStream = pStream;
    m_pStream->GetControllingUnknown()->AddRef();
    m_cCurrentPos = cCurPos;
}

CMediaTypeEnum::~CMediaTypeEnum()
{
    m_pStream->GetControllingUnknown()->Release();
}


STDMETHODIMP CMediaTypeEnum::Next(ULONG cNumToFetch, AM_MEDIA_TYPE **ppMediaTypes, ULONG *pcFetched)
{
    if (pcFetched == NULL) {
        return E_POINTER;
    }
    HRESULT hr = S_OK;
    *pcFetched = 0;
    for (; cNumToFetch > 0; ) {
        if (S_OK == hr) {
            hr = m_pStream->GetMediaType(m_cCurrentPos, ppMediaTypes);
            if (S_OK != hr) {
                *ppMediaTypes = NULL;
            } else {
                m_cCurrentPos++;
                (*pcFetched)++;
            }
        }
        ppMediaTypes++;
        cNumToFetch--;
    }
    return hr;
}


STDMETHODIMP CMediaTypeEnum::Skip(ULONG cSkip)
{
    m_cCurrentPos += cSkip;
    return NOERROR;
}

STDMETHODIMP CMediaTypeEnum::Reset()
{
    m_cCurrentPos = 0;
    return NOERROR;
}

STDMETHODIMP CMediaTypeEnum::Clone(IEnumMediaTypes **ppEnumMediaTypes)
{
    HRESULT hr = S_OK;
    CMediaTypeEnum *pNewEnum = new CComObject<CMediaTypeEnum>; 
    if (pNewEnum == NULL) {
	hr = E_OUTOFMEMORY;
    } else {
        pNewEnum->Initialize(m_pStream, m_cCurrentPos);
    }
    pNewEnum->GetControllingUnknown()->QueryInterface(IID_IEnumMediaTypes, (void **)ppEnumMediaTypes);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\medsampl.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
#ifndef __MEDIA_STREAM_SAMPLE_H_
#define __MEDIA_STREAM_SAMPLE_H_

class ATL_NO_VTABLE CAMMediaTypeSample :
    public CSample,
    public IAMMediaTypeSample
{
public:
    CAMMediaTypeSample();
    virtual ~CAMMediaTypeSample();

    DECLARE_POLY_AGGREGATABLE(CAMMediaTypeSample);

        //
        //  IStreamSample
        //
        STDMETHODIMP GetMediaStream(
            /* [in] */ IMediaStream **ppMediaStream)
        {
            return CSample::GetMediaStream(ppMediaStream);
        }

        STDMETHODIMP GetSampleTimes(
            /* [optional][out] */ STREAM_TIME *pStartTime,
            /* [optional][out] */ STREAM_TIME *pEndTime,
            /* [optional][out] */ STREAM_TIME *pCurrentTime)
        {
            return CSample::GetSampleTimes(
                pStartTime,
                pEndTime,
                pCurrentTime
            );
        }

        STDMETHODIMP SetSampleTimes(
            /* [optional][in] */ const STREAM_TIME *pStartTime,
            /* [optional][in] */ const STREAM_TIME *pEndTime)
        {
            return CSample::SetSampleTimes(pStartTime, pEndTime);
        }

        STDMETHODIMP Update(
            /* [in] */           DWORD dwFlags,
            /* [optional][in] */ HANDLE hEvent,
            /* [optional][in] */ PAPCFUNC pfnAPC,
            /* [optional][in] */ DWORD_PTR dwAPCData)
        {
            return CSample::Update(dwFlags, hEvent, pfnAPC, dwAPCData);
        }

        STDMETHODIMP CompletionStatus(
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ DWORD dwMilliseconds)
        {
            return CSample::CompletionStatus(dwFlags, dwMilliseconds);
        }


    //
    //  Extensions to media sample interface.
    //
    STDMETHODIMP SetPointer(BYTE * pBuffer, LONG lSize);

    //
    //  Basic methods all forwarded to the media sample.
    //
    STDMETHODIMP GetPointer(BYTE ** ppBuffer);
    STDMETHODIMP_(LONG) GetSize(void);
    STDMETHODIMP GetTime(REFERENCE_TIME * pTimeStart, REFERENCE_TIME * pTimeEnd);
    STDMETHODIMP SetTime(REFERENCE_TIME * pTimeStart, REFERENCE_TIME * pTimeEnd);
    STDMETHODIMP IsSyncPoint(void);
    STDMETHODIMP SetSyncPoint(BOOL bIsSyncPoint);
    STDMETHODIMP IsPreroll(void);
    STDMETHODIMP SetPreroll(BOOL bIsPreroll);
    STDMETHODIMP_(LONG) GetActualDataLength(void);
    STDMETHODIMP SetActualDataLength(LONG lActual);
    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE **ppMediaType);
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *pMediaType);
    STDMETHODIMP IsDiscontinuity(void);
    STDMETHODIMP SetDiscontinuity(BOOL bDiscontinuity);
    STDMETHODIMP GetMediaTime(LONGLONG * pTimeStart, LONGLONG * pTimeEnd);
    STDMETHODIMP SetMediaTime(LONGLONG * pTimeStart, LONGLONG * pTimeEnd);

    //
    //  Methods for this stream samples that will be called by CMediaSample.
    //
    HRESULT MSCallback_GetPointer(BYTE ** ppBuffer);
    LONG MSCallback_GetSize(void);
    LONG MSCallback_GetActualDataLength(void);
    HRESULT MSCallback_SetActualDataLength(LONG lActual);
    bool MSCallback_AllowSetMediaTypeOnMediaSample(void);

    //
    //  Internal functions
    //
    HRESULT Initialize(CAMMediaTypeStream *pStream, long lSize, BYTE *pData);
    HRESULT CopyFrom(IMediaSample *pSrcMediaSample);

BEGIN_COM_MAP(CAMMediaTypeSample)
	COM_INTERFACE_ENTRY(IAMMediaTypeSample)
        COM_INTERFACE_ENTRY_CHAIN(CSample)
END_COM_MAP()

public:
    BYTE *          m_pDataPointer;
    LONG            m_lSize;
    LONG            m_lActualDataLength;
    bool            m_bIAllocatedThisBuffer;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\ddstrm.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// ddstrm.h : Declaration of the CDDStream

#ifndef __DDSTRM_H_
#define __DDSTRM_H_

#include "resource.h"       // main symbols

class CDDSample;
class CDDInternalSample;

/////////////////////////////////////////////////////////////////////////////
// CDDStream
class ATL_NO_VTABLE CDDStream :
	public CComCoClass<CDDStream, &CLSID_AMDirectDrawStream>,
        public CStream,
	public IDirectDrawMediaStream,
        public IDirectDrawMediaSampleAllocator  // This interface indicates that our mem
                                                // allocator supports direct draw surfaces
                                                // from the media samples.
{
friend CDDSample;
public:

        //
        // METHODS
        //
	CDDStream();

        //
        // IMediaStream
        //
        // HACK HACK - the first 2 are duplicates but it won't link
        // without
        STDMETHODIMP GetMultiMediaStream(
            /* [out] */ IMultiMediaStream **ppMultiMediaStream)
        {
            return CStream::GetMultiMediaStream(ppMultiMediaStream);
        }

        STDMETHODIMP GetInformation(
            /* [optional][out] */ MSPID *pPurposeId,
            /* [optional][out] */ STREAM_TYPE *pType)
        {
            return CStream::GetInformation(pPurposeId, pType);
        }

        STDMETHODIMP SetSameFormat(IMediaStream *pStream, DWORD dwFlags);

        STDMETHODIMP AllocateSample(
            /* [in] */  DWORD dwFlags,
            /* [out] */ IStreamSample **ppSample);

        STDMETHODIMP CreateSharedSample(
            /* [in] */ IStreamSample *pExistingSample,
            /* [in] */  DWORD dwFlags,
            /* [out] */ IStreamSample **ppNewSample);

        STDMETHODIMP SendEndOfStream(DWORD dwFlags)
        {
            return CStream::SendEndOfStream(dwFlags);
        }

        //
        //  IAMMediaStream
        //
        STDMETHODIMP Initialize(IUnknown *pSourceObject, DWORD dwFlags, REFMSPID PurposeId, const STREAM_TYPE StreamType);

        //
        // IDirectDrawMediaStream
        //
        STDMETHODIMP GetFormat(
            /* [optional][out] */ DDSURFACEDESC *pDDSDCurrent,
            /* [optional][out] */ IDirectDrawPalette **ppDirectDrawPalette,
            /* [optional][out] */ DDSURFACEDESC *pDDSDDesired,
            /* [optional][out] */ DWORD *pdwFlags);

        STDMETHODIMP SetFormat(
            /* [in] */ const DDSURFACEDESC *lpDDSurfaceDesc,
            /* [optional][in] */ IDirectDrawPalette *pDirectDrawPalette);

        STDMETHODIMP GetDirectDraw(                     // NOTE == Function also used by IDirectDrawMediaSampleAllocator
            /* [out] */ IDirectDraw **ppDirectDraw);

        STDMETHODIMP SetDirectDraw(
            /* [in] */ IDirectDraw *pDirectDraw);

        STDMETHODIMP CreateSample(
            /* [in] */ IDirectDrawSurface *pSurface,
            /* [optional][in] */ const RECT *pRect,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDirectDrawStreamSample **ppSample);


        STDMETHODIMP GetTimePerFrame(
                /* [out] */ STREAM_TIME *pFrameTime);

        //
        // IPin
        //
        STDMETHODIMP ReceiveConnection(IPin * pConnector, const AM_MEDIA_TYPE *pmt);
        STDMETHODIMP QueryAccept(const AM_MEDIA_TYPE *pmt);


        //
        // IMemInputPin
        //
        STDMETHODIMP Receive(IMediaSample *pSample);
        STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator, BOOL bReadOnly);
        //
        // IMemAllocator
        //
        STDMETHODIMP SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual);
        STDMETHODIMP GetProperties(ALLOCATOR_PROPERTIES* pProps);
        STDMETHODIMP GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME * pStartTime,
                               REFERENCE_TIME * pEndTime, DWORD dwFlags);
        STDMETHODIMP Decommit();

        //
        // Special CStream methods
        //
        HRESULT GetMediaType(ULONG Index, AM_MEDIA_TYPE **ppMediaType);
        HRESULT CreateTempSample(CSample **ppSample);

protected:
        STDMETHODIMP GetFormatInternal(
            DDSURFACEDESC *pDDSDCurrent,
            IDirectDrawPalette **ppDirectDrawPalette,
            DDSURFACEDESC *pDDSDDesired,
            DWORD *pdwFlags);

        HRESULT InitDirectDraw(void);
        void InitSurfaceDesc(LPDDSURFACEDESC);
        HRESULT InternalSetFormat(const DDSURFACEDESC *lpDDSurfaceDesc, IDirectDrawPalette *pPalette, bool bFromPin, bool bQuery = false);
        HRESULT InternalAllocateSample(DWORD dwFlags,
                                       bool bIsInternalSample,
                                       IDirectDrawStreamSample **ppDDSample,
                                       bool bTemp = false);
        HRESULT InternalCreateSample(IDirectDrawSurface *pSurface, const RECT *pRect,
                                     DWORD dwFlags, bool bIsInternalSample,
                                     IDirectDrawStreamSample **ppSample,
                                     bool bTemp = false);
        HRESULT GetMyReadOnlySample(CDDSample *pBuddy, CDDSample **ppSample);
        HRESULT RenegotiateMediaType(const DDSURFACEDESC *lpDDSurfaceDesc, IDirectDrawPalette *pPalette, const AM_MEDIA_TYPE *pmt);
        HRESULT inline CDDStream::AllocDDSampleFromPool(
            const REFERENCE_TIME *rtStart,
            CDDSample **ppDDSample)
        {
            CSample *pSample;
            HRESULT hr = AllocSampleFromPool(rtStart, &pSample);
            *ppDDSample = (CDDSample *)pSample;
            return hr;
        }

        bool CreateInternalSample() const
        {
            return m_bSamplesAreReadOnly &&
                   m_StreamType==STREAMTYPE_READ;
        }

public:
DECLARE_REGISTRY_RESOURCEID(IDR_STREAM)

BEGIN_COM_MAP(CDDStream)
	COM_INTERFACE_ENTRY(IDirectDrawMediaStream)
	COM_INTERFACE_ENTRY(IDirectDrawMediaSampleAllocator)
        COM_INTERFACE_ENTRY_CHAIN(CStream)
END_COM_MAP()

protected:
        //
        //  Member variables
        //
        CComPtr<IDirectDraw>            m_pDirectDraw;
        CComPtr<IDirectDrawPalette>     m_pDirectDrawPalette;
        DWORD                           m_dwForcedFormatFlags;
        long                            m_Height;
        long                            m_Width;
        DDPIXELFORMAT                   m_PixelFormat;
        const DDPIXELFORMAT             *m_pDefPixelFormat;
        long                            m_lLastPitch;

        CDDInternalSample               *m_pMyReadOnlySample;
};

#endif // __DDSTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\project.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include "strmif.h"
#include "vfwmsgs.h"
#include "Stream.h"
#include "ddstrm.h"
#include "Sample.h"
#include "ddsample.h"
#include "util.h"
#include "mtenum.h"
#include "amvideo.h"
#include "uuids.h"
#include "amutil.h"
#include "ambase.h"
#include "bytestrm.h"
#include "austrm.h"
#include "mss.h"
#include "medsampl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\mss.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// MSS.h : Declaration of the CAMMediaTypeStream

#ifndef __MSS_H_
#define __MSS_H_

#include "resource.h"       // main symbols

class CAMMediaTypeSample;

/////////////////////////////////////////////////////////////////////////////
// CDDStream
class ATL_NO_VTABLE CAMMediaTypeStream :
	public CComCoClass<CAMMediaTypeStream, &CLSID_AMMediaTypeStream>,
        public CStream,
	public IAMMediaTypeStream
{
friend CAMMediaTypeSample;
public:

        //
        // METHODS
        //
	CAMMediaTypeStream();

        //
        // IMediaStream
        //
        // HACK HACK - the first 2 are duplicates but it won't link
        // without
        STDMETHODIMP GetMultiMediaStream(
            /* [out] */ IMultiMediaStream **ppMultiMediaStream)
        {
            return CStream::GetMultiMediaStream(ppMultiMediaStream);
        }

        STDMETHODIMP GetInformation(
            /* [optional][out] */ MSPID *pPurposeId,
            /* [optional][out] */ STREAM_TYPE *pType)
        {
            return CStream::GetInformation(pPurposeId, pType);
        }

        STDMETHODIMP SetSameFormat(IMediaStream *pStream, DWORD dwFlags);

        STDMETHODIMP AllocateSample(
            /* [in] */  DWORD dwFlags,
            /* [out] */ IStreamSample **ppSample);

        STDMETHODIMP CreateSharedSample(
            /* [in] */ IStreamSample *pExistingSample,
            /* [in] */  DWORD dwFlags,
            /* [out] */ IStreamSample **ppNewSample);

        STDMETHODIMP SendEndOfStream(DWORD dwFlags)
        {
            return CStream::SendEndOfStream(dwFlags);
        }

        //
        //  IAMMediaTypeStream
        //
        STDMETHODIMP GetFormat(
            /* [out] */ AM_MEDIA_TYPE __RPC_FAR *pMediaType,
            /* [in] */ DWORD dwFlags);

        STDMETHODIMP SetFormat(
            /* [in] */ AM_MEDIA_TYPE __RPC_FAR *pMediaType,
            /* [in] */ DWORD dwFlags);

        STDMETHODIMP CreateSample(
            /* [in] */ long lSampleSize,
            /* [optional][in] */ BYTE __RPC_FAR *pbBuffer,
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ IUnknown *pUnkOuter,
            /* [out] */ IAMMediaTypeSample __RPC_FAR *__RPC_FAR *ppAMMediaTypeSample);

        STDMETHODIMP GetStreamAllocatorRequirements(
            /* [out] */ ALLOCATOR_PROPERTIES __RPC_FAR *pProps);

        STDMETHODIMP SetStreamAllocatorRequirements(
            /* [in] */ ALLOCATOR_PROPERTIES __RPC_FAR *pProps);


        //
        // IPin
        //
        STDMETHODIMP ReceiveConnection(IPin * pConnector, const AM_MEDIA_TYPE *pmt);
        STDMETHODIMP QueryAccept(const AM_MEDIA_TYPE *pmt);

        //
        // IMemInputPin
        //
        STDMETHODIMP Receive(IMediaSample *pSample);
        //
        // IMemAllocator
        //
        STDMETHODIMP SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual);
        STDMETHODIMP GetProperties(ALLOCATOR_PROPERTIES* pProps);
        STDMETHODIMP GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME * pStartTime,
                               REFERENCE_TIME * pEndTime, DWORD dwFlags);

        //
        // Special CStream methods
        //
        HRESULT GetMediaType(ULONG Index, AM_MEDIA_TYPE **ppMediaType);

protected:
        HRESULT inline AllocMTSampleFromPool(const REFERENCE_TIME *rtStart, CAMMediaTypeSample **ppMTSample)
        {
            CSample *pSample;
            HRESULT hr = AllocSampleFromPool(rtStart, &pSample);
            *ppMTSample = (CAMMediaTypeSample *)pSample;
            return hr;
        }

public:
DECLARE_REGISTRY_RESOURCEID(IDR_MTSTREAM)

BEGIN_COM_MAP(CAMMediaTypeStream)
	COM_INTERFACE_ENTRY(IAMMediaTypeStream)
        COM_INTERFACE_ENTRY_CHAIN(CStream)
END_COM_MAP()

protected:
        AM_MEDIA_TYPE           m_MediaType;
        ALLOCATOR_PROPERTIES    m_AllocatorProperties;
};

#endif // __MSS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\pump.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// Pump.cpp : Implementation of CStream
#include "stdafx.h"
#include "project.h"


DWORD WINAPI WritePumpThreadStart(void *pvPump)
{
    return ((CPump *)pvPump)->PumpMainLoop();
}


CPump::CPump(CStream *pStream) :
    m_pStream(pStream),
    m_hThread(NULL),
    m_hRunEvent(NULL),
    m_bShutDown(false)
    {}


CPump::~CPump()
{
    if (m_hThread) {
        m_CritSec.Lock();
        m_bShutDown = true;
        Run(true);
        m_CritSec.Unlock();
        WaitForSingleObject(m_hThread, INFINITE);
    }
    if (m_hRunEvent) {
        CloseHandle(m_hRunEvent);
    }
}



HRESULT CPump::CreatePump(CStream *pStream, CPump **ppPump)
{
    CPump *pPump = new CPump(pStream);
    if (pPump) {
        pPump->m_hRunEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (pPump->m_hRunEvent) {
            DWORD dwId;
            pPump->m_hThread = CreateThread(NULL, 0, WritePumpThreadStart, (void *)pPump, 0, &dwId);
            if (pPump->m_hThread) {
                *ppPump = pPump;
                return S_OK;
            }
        }
        delete pPump;
    }
    *ppPump = pPump;
    return E_OUTOFMEMORY;
}


void CPump::Run(bool bRunning)
{
    if (bRunning) {
        SetEvent(m_hRunEvent);
    } else {
        ResetEvent(m_hRunEvent);
    }
}

HRESULT CPump::PumpMainLoop()
{
    while (true) {
        WaitForSingleObject(m_hRunEvent, INFINITE);
        m_CritSec.Lock();
        bool bShutDown = m_bShutDown;
        m_CritSec.Unlock();
        if (bShutDown) {
            return 0;
        }
        IMediaSample *pMediaSample;
        HRESULT hr = m_pStream->GetBuffer(&pMediaSample, NULL, NULL, 0);
        if (SUCCEEDED(hr)) {
            LONG lChopSize = m_pStream->GetChopSize();
            HRESULT hrReceived = S_OK;
            if (lChopSize != 0) {
                //  Send data in smaller batches generating
                //  appropriate timestamps
                CMediaSample *pSample = (CMediaSample *)pMediaSample;
                PBYTE pbStart;
                pMediaSample->GetPointer(&pbStart);

                //  Make these const so we don't accidentally
                //  update them
                PBYTE pbCurrent = pbStart;
                const LONG lLength = pSample->GetActualDataLength();
                const LONG lSize = pSample->GetSize();
                const REFERENCE_TIME rtStart = pSample->m_rtStartTime;
                const REFERENCE_TIME rtStop = pSample->m_rtEndTime;
                LONG lLeft = lLength;
                while (lLeft != 0) {
                    LONG lToSend = min(lLeft, lChopSize);
                    pSample->SetActualDataLength(lToSend);
                    pSample->SetSizeAndPointer(pbCurrent, lToSend, lToSend);
                    pSample->m_rtEndTime =
                        pSample->m_rtStartTime +
                        MulDiv((LONG)(rtStop -
                                      pSample->m_rtStartTime),
                               lToSend,
                               lLeft);
                    hrReceived = m_pStream->m_pConnectedMemInputPin->Receive(pMediaSample);
                    if (S_OK != hrReceived) {
                        break;
                    }
                    pbCurrent += lToSend;
                    pSample->m_rtStartTime = pSample->m_rtEndTime;
                    lLeft -= lToSend;
                }

                //  Put everything back
                pSample->m_rtStartTime = rtStart;
                pSample->m_rtEndTime = rtStop;
                pSample->SetSizeAndPointer(pbStart, lLength, lSize);
            } else {
                hrReceived = m_pStream->m_pConnectedMemInputPin->Receive(pMediaSample);
            }
            CSample *pSample = ((CMediaSample *)pMediaSample)->m_pSample;
            pSample->m_bReceived = true;
            if (hrReceived != S_OK) {
                AtlTrace(_T("Receive returned %i.  Aborting I/O operation/n"), hrReceived);
                pSample->m_MediaSampleIoStatus = E_ABORT;
            }
            pMediaSample->Release();
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\sample.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
#ifndef __SAMPLE_H_
#define __SAMPLE_H_

#include "resource.h"       // main symbols
#include "stream.h"


//
//  Samples don't use their own critical sections -- They always take the critical section of their
//  stream.  This avoids all sorts of deadlocks, and reduces the number of locks we take.  These
//  macros are helpers.
//
#define LOCK_SAMPLE m_pStream->Lock();
#define UNLOCK_SAMPLE m_pStream->Unlock();
#define AUTO_SAMPLE_LOCK  CAutoObjectLock lck(m_pStream);


class CSample;

class CMediaSample : public IMediaSample
{
public:
    CMediaSample(CSample *pSample);
    virtual ~CMediaSample();

    //
    //  IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // IMediaSample
    //
    STDMETHODIMP GetPointer(BYTE ** ppBuffer);
    STDMETHODIMP_(LONG) GetSize(void);
    STDMETHODIMP GetTime(REFERENCE_TIME * pTimeStart, REFERENCE_TIME * pTimeEnd);
    STDMETHODIMP SetTime(REFERENCE_TIME * pTimeStart, REFERENCE_TIME * pTimeEnd);
    STDMETHODIMP IsSyncPoint(void);
    STDMETHODIMP SetSyncPoint(BOOL bIsSyncPoint);
    STDMETHODIMP IsPreroll(void);
    STDMETHODIMP SetPreroll(BOOL bIsPreroll);
    STDMETHODIMP_(LONG) GetActualDataLength(void);
    STDMETHODIMP SetActualDataLength(LONG lActual);
    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE **ppMediaType);
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *pMediaType);
    STDMETHODIMP IsDiscontinuity(void);
    STDMETHODIMP SetDiscontinuity(BOOL bDiscontinuity);
    STDMETHODIMP GetMediaTime(LONGLONG * pTimeStart, LONGLONG * pTimeEnd);
    STDMETHODIMP SetMediaTime(LONGLONG * pTimeStart, LONGLONG * pTimeEnd);

    // Set the pointer
    HRESULT SetSizeAndPointer(PBYTE pbData, LONG lActual, LONG lSize);

public:
    CSample        *m_pSample;

    BOOL            m_bIsPreroll;
    DWORD           m_dwFlags;
    long            m_cRef;
    AM_MEDIA_TYPE  *m_pMediaType;

    /// Stream time
    REFERENCE_TIME  m_rtStartTime;
    REFERENCE_TIME  m_rtEndTime;
};





/////////////////////////////////////////////////////////////////////////////
// CSample
class ATL_NO_VTABLE CSample :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IStreamSample
{
public:
        //
        // METHODS
        //
        CSample();
        HRESULT InitSample(CStream *pStream, bool bIsInternalSample);
        virtual ~CSample();

        DECLARE_GET_CONTROLLING_UNKNOWN()

        //
        //  IStreamSample
        //
        STDMETHODIMP GetMediaStream(
            /* [in] */ IMediaStream **ppMediaStream);

        STDMETHODIMP GetSampleTimes(
            /* [optional][out] */ STREAM_TIME *pStartTime,
            /* [optional][out] */ STREAM_TIME *pEndTime,
            /* [optional][out] */ STREAM_TIME *pCurrentTime);

        STDMETHODIMP SetSampleTimes(
            /* [optional][in] */ const STREAM_TIME *pStartTime,
            /* [optional][in] */ const STREAM_TIME *pEndTime);

        STDMETHODIMP Update(
            /* [in] */           DWORD dwFlags,
            /* [optional][in] */ HANDLE hEvent,
            /* [optional][in] */ PAPCFUNC pfnAPC,
            /* [optional][in] */ DWORD_PTR dwAPCData);

        STDMETHODIMP CompletionStatus(
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ DWORD dwMilliseconds);


        //
        //  Forwarding functions for various Media Sample interfaces that can be
        //
        virtual HRESULT MSCallback_GetPointer(BYTE ** ppBuffer) = 0;
        virtual LONG MSCallback_GetSize(void) = 0;
        virtual LONG MSCallback_GetActualDataLength(void) = 0;
        virtual HRESULT MSCallback_SetActualDataLength(LONG lActual) = 0;
        virtual bool MSCallback_AllowSetMediaTypeOnMediaSample(void) {return false;}

        //
        // ATL class methods
        //
        void FinalRelease(void);

        //
        // Internal methods
        //
        virtual void FinalMediaSampleRelease(void);
        virtual HRESULT SetCompletionStatus(HRESULT hrCompletionStatus);
        void CopyFrom(CSample *pSrcSample);
        void CopyFrom(IMediaSample *pSrcMediaSample);
        virtual HRESULT InternalUpdate(
            DWORD dwFlags,
            HANDLE hEvent,
            PAPCFUNC pfnAPC,
            DWORD_PTR dwAPCData);

        //  Temp?
        bool IsTemp() { return m_bTemp; }

        //  Set the pointer?
        virtual HRESULT SetSizeAndPointer(PBYTE pbData, LONG lActual, LONG lSize)
        {
            return E_FAIL;
        }

BEGIN_COM_MAP(CSample)
        COM_INTERFACE_ENTRY(IStreamSample)
END_COM_MAP()

public:
        //
        //  MEMBER VARIABLES
        //
        CMediaSample *                  m_pMediaSample;
        bool                            m_bReceived;
        bool                            m_bWantAbort;
        bool                            m_bContinuous;
        bool                            m_bModified;
        bool                            m_bInternal;
        bool                            m_bTemp;
        bool                            m_bWaited;
        CStream                         *m_pStream;
        CSample                         *m_pNextFree;
        CSample                         *m_pPrevFree;
        HANDLE                          m_hUserHandle;
        PAPCFUNC                        m_UserAPC;
        DWORD_PTR                       m_dwUserAPCData;
        HRESULT                         m_Status;
        HRESULT                         m_MediaSampleIoStatus;
        HANDLE                          m_hCompletionEvent;

};




#endif //__SAMPLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\sample.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// Sample.cpp: implementation of the Sample class.
//
//////////////////////////////////////////////////////////////////////


/*
      Overview of handling of sample states
      -------------------------------------


      A sample can be in one of the following states:

      -- Application - Application owned - not updated
      -- Stream owned (in our queue)
      -- Owned by a filter for update

      The state can only change under the protection of the stream
      critical section.

      Stealing a sample occurs on WaitForCompletion with NOUPDATEOK or
      ABORT specified.

      Also, not that WaitForCompletion turns off continuous updates
      if and of the 3 flags are set.


	  Action

Owner            Update    GetBuffer    Receive      Release     Steal
			   completion                            sample
  ---------------------------------------------------------------------------
  Application    Note 3    Impossible   Impossible   Impossible  Application
  ---------------------------------------------------------------------------
  Stream         Invalid   Filter       Impossible   Impossible  Application
  ---------------------------------------------------------------------------
  Filter         Invalid   Impossible   Note 1       Note 2      Filter
  ---------------------------------------------------------------------------

  Notes:
      1.  New owner is
	      Stream for continuous update
	      Application otherwise

      2.  New owner is
	      Application if at end of stream or abort
	      Stream otherwise

      3.  If at end of stream status is MS_S_ENDOFSTREAM


*/

#include "stdafx.h"
#include "project.h"


CSample::CSample() :
    m_pStream(NULL),
    m_pMediaSample(NULL),
    m_hUserHandle(NULL),
    m_UserAPC(NULL),
    m_Status(S_OK),
    m_MediaSampleIoStatus(S_OK),
    m_pNextFree(NULL),
    m_pPrevFree(NULL),
    m_hCompletionEvent(NULL),
    m_bReceived(false),
    m_bTemp(false),
    m_bWaited(true)
{
}

HRESULT CSample::InitSample(CStream *pStream, bool bIsInternalSample)
{
    if (!m_pMediaSample) {
        m_pMediaSample = new CMediaSample(this);
        if (!m_pMediaSample) {
            return E_OUTOFMEMORY;
        }
    }
    m_pStream = pStream;
    m_bInternal = bIsInternalSample;
    if (!bIsInternalSample) {
	pStream->Lock();
	pStream->m_cAllocated++;
	pStream->Unlock();
	//
	//  Hold a strong reference to the stream and the multi media stream.
	//  The pMMStream can not change once we have incremented m_cAllocted on the stream, so we're sure that this
	//  addref and the final release of the multi-media stream won't change.
	//
	pStream->GetControllingUnknown()->AddRef();
        if (pStream->m_pMMStream) {
            pStream->m_pMMStream->AddRef();
        }
    }

    m_hCompletionEvent = CreateEvent(NULL, FALSE, TRUE, NULL);
    return m_hCompletionEvent ? S_OK : E_OUTOFMEMORY;
}

void CSample::FinalRelease(void)
{
    m_bWaited = true;
    CompletionStatus(COMPSTAT_WAIT | COMPSTAT_ABORT, INFINITE);
}

CSample::~CSample()
{
    CompletionStatus(COMPSTAT_NOUPDATEOK | COMPSTAT_ABORT, 0);
    if (m_hCompletionEvent) {
	CloseHandle(m_hCompletionEvent);
    }
    if (!m_bInternal) {
	m_pStream->Lock();
        IMultiMediaStream *pMMStream = m_pStream->m_pMMStream;
	m_pStream->m_cAllocated--;
	m_pStream->Unlock();    // Unlock it before we release it!
        if (pMMStream) {
            pMMStream->Release();
            if (m_pStream->m_bStopIfNoSamples && m_pStream->m_cAllocated == 0) {
                if (m_pStream->m_pAllocator) {
                    m_pStream->m_pAllocator->Decommit();
                }
            }
        }
	m_pStream->GetControllingUnknown()->Release();
    }
    if (m_pMediaSample) {
        delete m_pMediaSample;
    }
}

//
// IStreamSample
//
STDMETHODIMP CSample::GetMediaStream(IMediaStream **ppMediaStream)
{
    TRACEINTERFACE(_T("IStreamSample::GetMediaStream(0x%8.8X)\n"),
                   ppMediaStream);
    *ppMediaStream = m_pStream;
    (*ppMediaStream)->AddRef();
    return S_OK;
}

STDMETHODIMP CSample::GetSampleTimes(STREAM_TIME *pStartTime, STREAM_TIME *pEndTime,
				     STREAM_TIME *pCurrentTime)
{
    TRACEINTERFACE(_T("IStreamSample::GetSampleTimes(0x%8.8X, 0x%8.8X, 0x%8.8X)\n"),
                   pStartTime, pEndTime, pCurrentTime);
    // Return media times using NewSegment data
    REFERENCE_TIME rtSegmentStart = m_pStream->m_rtSegmentStart;
    m_pMediaSample->GetTime(pStartTime, pEndTime);
    if (pStartTime) {
	*pStartTime += rtSegmentStart;
    }
    if (pEndTime) {
	*pEndTime += rtSegmentStart;
    }

    //  Get current stream time from the filter
    if (pCurrentTime) {
	m_pStream->m_pFilter->GetCurrentStreamTime(pCurrentTime);
    }
    return S_OK;
}

STDMETHODIMP CSample::SetSampleTimes(const STREAM_TIME *pStartTime, const STREAM_TIME *pEndTime)
{
    TRACEINTERFACE(_T("IStreamSample::SetSampleTimes(0x%8.8X, 0x%8.8X)\n"),
                   pStartTime, pEndTime);
    /*  Only settable for writable streams */
    if (m_pStream->m_StreamType != STREAMTYPE_WRITE) {
        return MS_E_INVALIDSTREAMTYPE;
    }
    /*  Since writable streams can't be seeked we don't need to
        compensate here for any seek offsets
    */
    return m_pMediaSample->SetTime((REFERENCE_TIME *)pStartTime, (REFERENCE_TIME *)pEndTime);
}

STDMETHODIMP CSample::Update(DWORD dwFlags, HANDLE hEvent, PAPCFUNC pfnAPC, DWORD_PTR dwAPCData)
{
    TRACEINTERFACE(_T("IStreamSample::Update(0x%8.8X, 0x%8.8X, 0x%8.8X, 0x%8.8X)\n"),
                   dwFlags, hEvent, pfnAPC, dwAPCData);
    LOCK_SAMPLE;
    HRESULT hr = InternalUpdate(dwFlags, hEvent, pfnAPC, dwAPCData);
    UNLOCK_SAMPLE;
    if (S_OK == hr) {
	hr = CompletionStatus(COMPSTAT_WAIT, INFINITE);
    }
    return hr;
}


void CSample::FinalMediaSampleRelease(void)
{
    if (m_bTemp) {
        GetControllingUnknown()->Release();
        return;
    }
    LOCK_SAMPLE;
    HRESULT hrStatus = m_MediaSampleIoStatus;
    if (hrStatus != S_OK) {
	m_MediaSampleIoStatus = S_OK;    // Reset this here so we don't need to reset it every time.
    } else {
	if (!m_bReceived) {
	    if (m_pStream->m_bEndOfStream) {
		hrStatus = MS_S_ENDOFSTREAM;
	    } else {
		if (m_bWantAbort) {
		    m_bWantAbort = false;
		    hrStatus = E_ABORT;
		} else {
		    // Upstream guy just allocated the sample and never used it! -- Keep it pending.
		    hrStatus = MS_S_PENDING;
		}
	    }
	}
    }
    UNLOCK_SAMPLE;
    SetCompletionStatus(hrStatus);
    // DANGER!  Sample may be dead right here
}



//
//  Set the sample's status and signal completion if necessary.
//
//  Note that when the application has been signalled by whatever method
//  the application can immediately turn around on another thread
//  and Release() the sample.  This is most likely when the completion
//  status is set from the quartz thread that's pushing the data.
//
//  Should we actually keep a reference count on the sample ourselves while
//  it's being updated?  Currently we don't.
//
HRESULT CSample::SetCompletionStatus(HRESULT hrStatus)
{
    LOCK_SAMPLE;
    _ASSERTE(m_Status == MS_S_PENDING);
    if (hrStatus == MS_S_PENDING || (hrStatus == S_OK && m_bContinuous)) {
	m_pStream->AddSampleToFreePool(this);
        UNLOCK_SAMPLE;
    } else {
	HANDLE handle = m_hUserHandle;
	PAPCFUNC pfnAPC = m_UserAPC;
	DWORD_PTR dwAPCData = m_dwUserAPCData;
	m_hUserHandle = m_UserAPC = NULL;
	m_dwUserAPCData = 0;
	m_Status = hrStatus;
        HANDLE hCompletionEvent = m_hCompletionEvent;
        UNLOCK_SAMPLE;

        //  DANGER DANGER - sample can go away here
	SetEvent(hCompletionEvent);
	if (pfnAPC) {
	    QueueUserAPC(pfnAPC, handle, dwAPCData);
            BOOL bClose = CloseHandle(handle);
            _ASSERTE(bClose);
	} else {
	    if (handle) {
		SetEvent(handle);
	    }
	}
    }
    return hrStatus;
}


STDMETHODIMP CSample::CompletionStatus(DWORD dwFlags, DWORD dwMilliseconds)
{
    TRACEINTERFACE(_T("IStreamSample::CompletionStatus(0x%8.8X, 0x%8.8X)\n"),
                   dwFlags, dwMilliseconds);
    LOCK_SAMPLE;
    HRESULT hr = m_Status;
    if (hr == MS_S_PENDING) {
	if (dwFlags & (COMPSTAT_NOUPDATEOK | COMPSTAT_ABORT) ||
	    (m_bContinuous && m_bModified && (dwFlags & COMPSTAT_WAIT))) {
	    m_bContinuous = false;
	    if (dwFlags & COMPSTAT_ABORT) {
		m_bWantAbort = true;    // Set this so we won't add it back to the free pool if released
	    }
	    if (m_pStream->StealSampleFromFreePool(this, dwFlags & COMPSTAT_ABORT)) {
		UNLOCK_SAMPLE;
		return SetCompletionStatus(m_bModified ? S_OK : MS_S_NOUPDATE);
	    } // If doesn't work then return MS_S_PENDING unless we're told to wait!
	}
	if (dwFlags & COMPSTAT_WAIT) {
	    m_bContinuous = false;  // Make sure it will complete!
	    UNLOCK_SAMPLE;
	    WaitForSingleObject(m_hCompletionEvent, dwMilliseconds);
	    LOCK_SAMPLE;
	    hr = m_Status;
	}
    }
    UNLOCK_SAMPLE;
    return hr;
}

HRESULT CSample::InternalUpdate(
    DWORD dwFlags,
    HANDLE hEvent,
    PAPCFUNC pfnAPC,
    DWORD_PTR dwAPCData
)
{
    if ((hEvent && pfnAPC) || (dwFlags & (~(SSUPDATE_ASYNC | SSUPDATE_CONTINUOUS)))) {
	return E_INVALIDARG;
    }
    if (m_Status == MS_S_PENDING) {
	return MS_E_BUSY;
    }
    if (NULL != m_pStream->m_pMMStream) {
        STREAM_STATE StreamState;
        m_pStream->m_pMMStream->GetState(&StreamState);
        if (StreamState != STREAMSTATE_RUN) {
    	return MS_E_NOTRUNNING;
        }
    }


    ResetEvent(m_hCompletionEvent);
    m_Status = MS_S_PENDING;
    m_bWantAbort = false;
    m_bModified = false;
    m_bContinuous = (dwFlags & SSUPDATE_CONTINUOUS) != 0;
    m_UserAPC = NULL;
    if (pfnAPC) {
        //
        //  Make a real handle
        //
	if (!DuplicateHandle(GetCurrentProcess(), GetCurrentThread(),
		        GetCurrentProcess(), &m_hUserHandle,
		        0, TRUE, DUPLICATE_SAME_ACCESS))
        {
            DWORD dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }

        m_UserAPC = pfnAPC;
	m_dwUserAPCData = dwAPCData;
    } else {
	m_hUserHandle = hEvent;
	if (hEvent) {
	    ResetEvent(hEvent);
	}
    }

    //
    //  If we're at the end of the stream, wait until this point before punting it
    //  because we need to signal the event or fire the APC.
    //
    if (m_pStream->m_bEndOfStream) {
        //  Because this is called synchronously from Update the
        //  application must have a ref count on the sample until we
        //  return so we don't have to worry about it going away here
        return SetCompletionStatus(MS_S_ENDOFSTREAM);
    }

    SetCompletionStatus(MS_S_PENDING);   // This adds us to the free pool.
    if (hEvent || pfnAPC || (dwFlags & SSUPDATE_ASYNC)) {
	return MS_S_PENDING;
    } else {
	return S_OK;
    }
}

void CSample::CopyFrom(CSample *pSrcSample)
{
    m_bModified = true;
    m_pMediaSample->m_rtStartTime = pSrcSample->m_pMediaSample->m_rtStartTime;
    m_pMediaSample->m_rtEndTime = pSrcSample->m_pMediaSample->m_rtEndTime;
    m_pMediaSample->m_dwFlags = pSrcSample->m_pMediaSample->m_dwFlags;
    m_pMediaSample->m_bIsPreroll = pSrcSample->m_pMediaSample->m_bIsPreroll;
}


void CSample::CopyFrom(IMediaSample *pSrcMediaSample)
{
    m_bModified = true;
    pSrcMediaSample->GetTime(&m_pMediaSample->m_rtStartTime, &m_pMediaSample->m_rtEndTime);
    m_pMediaSample->m_dwFlags = (pSrcMediaSample->IsSyncPoint() == S_OK) ? 0 : AM_GBF_NOTASYNCPOINT;
    m_pMediaSample->m_dwFlags |= (pSrcMediaSample->IsDiscontinuity() == S_OK) ? AM_GBF_PREVFRAMESKIPPED : 0;
    m_pMediaSample->m_bIsPreroll = (pSrcMediaSample->IsPreroll() == S_OK);
}



/////////////////////////////////////////////////////////////////////////////////////////////
//
//  Implementation of IMediaSample
//


CMediaSample::CMediaSample(CSample *pSample) :
    m_pSample(pSample),
    m_cRef(0),
    m_dwFlags(0),
    m_bIsPreroll(FALSE),
    m_pMediaType(NULL),
    m_rtStartTime(0),
    m_rtEndTime(0)
{
}

CMediaSample::~CMediaSample()
{
    if (m_pMediaType) {
        DeleteMediaType(m_pMediaType);
    }
}



STDMETHODIMP CMediaSample::QueryInterface(REFIID riid, void ** ppv)
{
    if (riid==IID_IUnknown || riid==IID_IMediaSample) {
	*ppv = (IMediaSample *)this;
	AddRef();
	return S_OK;
    }
    return E_NOINTERFACE;
}



STDMETHODIMP_(ULONG) CMediaSample::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CMediaSample::Release()
{
    long lRef = InterlockedDecrement(&m_cRef);
    if (lRef == 0) {
	m_pSample->FinalMediaSampleRelease();
    }
    return lRef;
}


STDMETHODIMP CMediaSample::GetPointer(BYTE ** ppBuffer)
{
    return m_pSample->MSCallback_GetPointer(ppBuffer);
}

STDMETHODIMP_(LONG) CMediaSample::GetSize(void)
{
    return m_pSample->MSCallback_GetSize();
}


STDMETHODIMP CMediaSample::GetTime(REFERENCE_TIME * pStartTime, REFERENCE_TIME * pEndTime)
{
    if (pStartTime) {
	*pStartTime = m_rtStartTime;
    }
    if (pEndTime) {
	*pEndTime = m_rtEndTime;
    }
    return S_OK;
}

STDMETHODIMP CMediaSample::SetTime(REFERENCE_TIME * pStartTime, REFERENCE_TIME * pEndTime)
{
    // Set stream time
    if (pStartTime) {
	m_rtStartTime = *pStartTime;
    }
    if (pEndTime) {
	m_rtEndTime = *pEndTime;
    }
    return S_OK;
}


STDMETHODIMP CMediaSample::IsSyncPoint(void)
{
    return ((m_dwFlags & AM_GBF_NOTASYNCPOINT) ? S_FALSE : S_OK);
}

STDMETHODIMP CMediaSample::SetSyncPoint(BOOL bIsSyncPoint)
{
    if (bIsSyncPoint) {
	m_dwFlags &= (~AM_GBF_NOTASYNCPOINT);
    } else {
	m_dwFlags |= AM_GBF_NOTASYNCPOINT;
    }
    return NOERROR;
}


STDMETHODIMP CMediaSample::IsPreroll(void)
{
    return (m_bIsPreroll ? S_OK : S_FALSE);
}

STDMETHODIMP CMediaSample::SetPreroll(BOOL bIsPreroll)
{
    m_bIsPreroll = bIsPreroll;
    return S_OK;
}

STDMETHODIMP_(LONG) CMediaSample::GetActualDataLength(void)
{
    return m_pSample->MSCallback_GetActualDataLength();
}

STDMETHODIMP CMediaSample::SetActualDataLength(LONG lActual)
{
    return m_pSample->MSCallback_SetActualDataLength(lActual);
}


STDMETHODIMP CMediaSample::GetMediaType(AM_MEDIA_TYPE **ppMediaType)
{
    if (m_pMediaType) {
	*ppMediaType = CreateMediaType(m_pMediaType);
        if (*ppMediaType) {
	    return NOERROR;
        } else {
            return E_OUTOFMEMORY;
        }
    } else {
	*ppMediaType = NULL;
	return S_FALSE;
    }
}


STDMETHODIMP CMediaSample::SetMediaType(AM_MEDIA_TYPE *pMediaType)
{
    if ((!m_pMediaType && !pMediaType) ||
        (m_pMediaType && pMediaType && IsEqualMediaType(*m_pMediaType, *pMediaType))) {
        return S_OK;
    }
    if (!m_pSample->MSCallback_AllowSetMediaTypeOnMediaSample()) {
        return VFW_E_TYPE_NOT_ACCEPTED;
    }
    if (m_pMediaType) {
        DeleteMediaType(m_pMediaType);
    }
    m_pMediaType = NULL;
    if (pMediaType) {
        m_pMediaType = CreateMediaType(pMediaType);
        if (!m_pMediaType) {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}


STDMETHODIMP CMediaSample::IsDiscontinuity(void)
{
    return ((m_dwFlags & AM_GBF_PREVFRAMESKIPPED) ? S_OK : S_FALSE);
}

STDMETHODIMP CMediaSample::SetDiscontinuity(BOOL bDiscontinuity)
{
    if (bDiscontinuity) {
	m_dwFlags |= AM_GBF_PREVFRAMESKIPPED;
    } else {
	m_dwFlags &= (~AM_GBF_PREVFRAMESKIPPED);
    }
    return NOERROR;
}

STDMETHODIMP CMediaSample::GetMediaTime(LONGLONG * pTimeStart, LONGLONG * pTimeEnd)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMediaSample::SetMediaTime(LONGLONG * pTimeStart, LONGLONG * pTimeEnd)
{
    return E_NOTIMPL;
}


HRESULT CMediaSample::SetSizeAndPointer(PBYTE pbData, LONG lActual, LONG lSize)
{
    return m_pSample->SetSizeAndPointer(pbData, lActual, lSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\stream.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// Stream.cpp : Implementation of CStream
#include "stdafx.h"
#include "project.h"





/////////////////////////////////////////////////////////////////////////////
// CStream

CStream::CStream() :
    m_bCommitted(false),
    m_lRequestedBufferCount(0),
    m_bFlushing(false),
    m_rtWaiting(0),
    m_lWaiting(0),
    m_hWaitFreeSem(NULL),
    m_pFirstFree(NULL),
    m_pLastFree(NULL),
    m_cAllocated(0),
    m_bEndOfStream(false),
    m_FilterState(State_Stopped),
    m_pFilter(NULL),
    m_pFilterGraph(NULL),
    m_pMMStream(NULL),
    m_pWritePump(NULL),
    m_rtSegmentStart(0),
    m_bNoStall(false),
    m_bStopIfNoSamples(false)
{
    InitMediaType(&m_ConnectedMediaType);
    InitMediaType(&m_ActualMediaType);
    CHECKSAMPLELIST
}

#ifdef DEBUG
bool CStream::CheckSampleList()
{
    if (m_pFirstFree) {
        CSample *pSample = m_pFirstFree;
        if (pSample->m_pPrevFree != NULL) {
            return false;
        }
        while (pSample->m_pNextFree) {
            if (pSample->m_pNextFree->m_pPrevFree != pSample) {
                return false;
            }
            pSample = pSample->m_pNextFree;
        }
        if (pSample != m_pLastFree) {
            return false;
        }
    } else {
        if (m_pLastFree) {
            return false;
        }
    }
    return true;
}
#endif

HRESULT CStream::FinalConstruct(void)
{
    m_hWaitFreeSem = CreateSemaphore(NULL, 0, 0x7FFFFFF, NULL);
    return m_hWaitFreeSem ? S_OK : E_OUTOFMEMORY;
}


CStream::~CStream()
{
    SetState(State_Stopped);        // Make sure we're decommitted and pump is dead
    Disconnect();                   // Free any allocated media types and release held references
    if (m_hWaitFreeSem) {
        CloseHandle(m_hWaitFreeSem);
    }
}

STDMETHODIMP CStream::GetMultiMediaStream(IMultiMediaStream **ppMultiMediaStream)
{
    TRACEINTERFACE(_T("IMediaStream::GetMultiMediaStream(0x%8.8X)\n"),
                   ppMultiMediaStream);
    if (NULL == ppMultiMediaStream) {
	return E_POINTER;
    }

    if (m_pMMStream != NULL) {
    	m_pMMStream->AddRef();
    }

    *ppMultiMediaStream = m_pMMStream;
    return S_OK;
}

STDMETHODIMP CStream::GetInformation(MSPID *pPurposeId, STREAM_TYPE *pType)
{
    TRACEINTERFACE(_T("IMediaStream::GetInformation(0x%8.8X, 0x%8.8X)\n"),
                   pPurposeId, pType);
    if (pPurposeId) {
        *pPurposeId = m_PurposeId;
    }
    if (pType) {
        *pType = m_StreamType;
    }
    return S_OK;
}

STDMETHODIMP CStream::SendEndOfStream(DWORD dwFlags)
{
    TRACEINTERFACE(_T("IMediaStream::SendEndOfStream(0x%8.8X)\n"),
                   dwFlags);
    if (m_StreamType != STREAMTYPE_WRITE) {
        return MS_E_INVALIDSTREAMTYPE;
    }
    if (m_pConnectedPin) {
        return m_pConnectedPin->EndOfStream();
    }
    return S_OK;
}


STDMETHODIMP CStream::Initialize(IUnknown *pSourceObject, DWORD dwFlags,
    REFMSPID PurposeId, const STREAM_TYPE StreamType)
{
    TRACEINTERFACE(_T("IMediaStream::Initalize(0x%8.8X, 0x%8.8X, %s, %d)\n"),
                   pSourceObject, dwFlags, TextFromPurposeId(PurposeId), StreamType);
    HRESULT hr = NOERROR;

    if (dwFlags & ~(AMMSF_CREATEPEER | AMMSF_STOPIFNOSAMPLES)) {
        return E_INVALIDARG;
    }
    m_PurposeId = PurposeId;
    m_StreamType = StreamType;
    m_Direction = (StreamType == STREAMTYPE_WRITE) ? PINDIR_OUTPUT : PINDIR_INPUT;
    if (dwFlags & AMMSF_CREATEPEER) {
        if (!pSourceObject) {
            hr = E_INVALIDARG;
        } else {
            CComQIPtr<IMediaStream, &IID_IMediaStream> pMediaStream(pSourceObject);
            if (!pSourceObject) {
                hr = E_INVALIDARG;
            } else {
                hr = SetSameFormat(pMediaStream, 0);
            }
        }
    }
    m_bStopIfNoSamples = dwFlags & AMMSF_STOPIFNOSAMPLES ? true : false;
    return hr;
}

STDMETHODIMP CStream::SetState(FILTER_STATE State)
{
    TRACEINTERFACE(_T("IMediaStream::SetState(%d)\n"),
                   State);
    Lock();
    if (m_pConnectedPin == NULL) {
        Unlock();
        if (State == STREAMSTATE_RUN) {
            EndOfStream();
        }
    } else {
        _ASSERTE(m_pAllocator != NULL);
        FILTER_STATE prevState = m_FilterState;
        m_FilterState = State;
        if (State == State_Stopped) {
            m_pAllocator->Decommit();
            if (!m_bUsingMyAllocator) {
                Decommit();
            }
            CPump *pPump = m_pWritePump;
            m_pWritePump = NULL;
            Unlock();
            delete pPump;
        }  else {
            m_pAllocator->Commit();
            if (!m_bUsingMyAllocator) {
                Commit();
            }
            if( State_Stopped == prevState )
            {   
                // need this in the case of a seek while stopped, since BeginFlush
                // may not be called to reset this flag         
                m_bEndOfStream = false;
            }                
            Unlock();
        }
    }
    return S_OK;
}

STDMETHODIMP CStream::JoinAMMultiMediaStream(IAMMultiMediaStream *pAMMultiMediaStream)
{
    _ASSERTE(pAMMultiMediaStream == NULL || m_pMMStream == NULL);
    AUTO_CRIT_LOCK;
    HRESULT hr;
    if (m_cAllocated) {
        hr = MS_E_SAMPLEALLOC;
    } else {
        m_pMMStream = pAMMultiMediaStream;
    }
    return S_OK;
}

STDMETHODIMP CStream::JoinFilter(IMediaStreamFilter *pMediaStreamFilter)
{
    _ASSERTE(pMediaStreamFilter == NULL || m_pFilter == NULL);
    m_pFilter = pMediaStreamFilter;
    pMediaStreamFilter->QueryInterface(IID_IBaseFilter, (void **)&m_pBaseFilter);
    m_pBaseFilter->Release();
    return S_OK;
}

STDMETHODIMP CStream::JoinFilterGraph(IFilterGraph *pFilterGraph)
{
    _ASSERTE(pFilterGraph == NULL || m_pFilterGraph == NULL);
    m_pFilterGraph = pFilterGraph;
    return S_OK;
}



//
//  IPin Implementation
//

STDMETHODIMP CStream::Disconnect()
{
    m_pConnectedPin = NULL;
    m_pConnectedMemInputPin.Release();  // Magically sets to NULL here
    m_pQC.Release();
    m_pAllocator = NULL;
    m_lRequestedBufferCount = 0;
    FreeMediaType(m_ConnectedMediaType);
    FreeMediaType(m_ActualMediaType);
    return S_OK;
}

STDMETHODIMP CStream::ConnectedTo(IPin **pPin)
{
    *pPin = m_pConnectedPin;
    if (*pPin) {
        (*pPin)->AddRef();
        return S_OK;
    } else {
        return VFW_E_NOT_CONNECTED;
    }
}

STDMETHODIMP CStream::ConnectionMediaType(AM_MEDIA_TYPE *pmt)
{
    if (m_pConnectedPin) {
        CopyMediaType(pmt, &m_ConnectedMediaType);
        return S_OK;
    } else {
        ZeroMemory(pmt, sizeof(*pmt));
        pmt->lSampleSize = 1;
        pmt->bFixedSizeSamples = TRUE;
        return VFW_E_NOT_CONNECTED;
    }
}



void CStream::GetName(LPWSTR pszBuf)
{
    if (m_PurposeId == GUID_NULL) {
        pszBuf[0] = 0;
    } else {
        pszBuf[0] = (m_Direction == PINDIR_INPUT) ? (WCHAR)'I' : (WCHAR)'O';
        WStringFromGUID(&m_PurposeId, &pszBuf[1]);
    }
}


STDMETHODIMP CStream::QueryPinInfo(PIN_INFO * pInfo)
{
    pInfo->dir = m_Direction;
    GetName(pInfo->achName);
    return m_pFilter->QueryInterface(IID_IBaseFilter, (void **)&pInfo->pFilter);
}

STDMETHODIMP CStream::QueryDirection(PIN_DIRECTION * pPinDir)
{
    *pPinDir = m_Direction;
    return S_OK;
}


STDMETHODIMP CStream::QueryId(LPWSTR * Id)
{
    *Id = (LPWSTR)CoTaskMemAlloc(128 * sizeof(WCHAR));
    if (*Id) {
        GetName(*Id);
        return S_OK;
    } else {
        return E_OUTOFMEMORY;
    }
}


//
//  Derived classes must override this method
//
STDMETHODIMP CStream::QueryAccept(const AM_MEDIA_TYPE *pmt)
{
    return E_NOTIMPL;
};


STDMETHODIMP CStream::QueryInternalConnections(IPin **apPin, ULONG *nPin)
{
    //
    //  Returning E_NOTIMPL tells the filter graph manager that all input pins are connected to
    //  all output pins.
    //
    return E_NOTIMPL;
};


STDMETHODIMP CStream::EndOfStream(void)
{
    HRESULT hr = S_OK;
    Lock();
    if (m_bFlushing || m_bEndOfStream) {
        hr = E_FAIL;
    } else {
        m_bEndOfStream = true;
        CSample *pSample = m_pFirstFree;
        m_pFirstFree = m_pLastFree = NULL;              // Out of paranoia, clear these pointers first
        while (pSample) {
            CSample *pNext = pSample->m_pNextFree;
            pSample->SetCompletionStatus(MS_S_ENDOFSTREAM);  // WARNING!  This sample may go away!!!
            pSample = pNext;
        }
        CHECKSAMPLELIST
    }
    if (S_OK == hr) {
        m_pFilter->EndOfStream();
    }
    Unlock();

    return hr;
}


STDMETHODIMP CStream::BeginFlush(void)
{
    HRESULT hr = S_OK;
    Lock();
    const BOOL bCancelEOS = m_bEndOfStream;
    if (m_bFlushing) {
        hr = S_FALSE;
    } else {
        m_bFlushing = true;
        m_bEndOfStream = false;
        Decommit();     // Force everyone to unblock
    }
    if (S_OK == hr) {
        m_pFilter->Flush(bCancelEOS);
    }
    Unlock();

    return hr;
}

STDMETHODIMP CStream::EndFlush(void)
{
    AUTO_CRIT_LOCK;
    m_bFlushing = false;
    _ASSERTE(!m_bEndOfStream);
    Commit();   // Let getbuffer work again
    return S_OK;
}

STDMETHODIMP CStream::NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate)
{
    Lock();
    m_rtSegmentStart = tStart;
    m_bEndOfStream = false;
    Unlock();
    return S_OK;
}

//
// IMemInputPin
//
STDMETHODIMP CStream::GetAllocator(IMemAllocator ** ppAllocator)
{
    return GetControllingUnknown()->QueryInterface(IID_IMemAllocator, (void **)ppAllocator);
}

STDMETHODIMP CStream::NotifyAllocator(IMemAllocator * pAllocator, BOOL bReadOnly)
{
    m_bUsingMyAllocator = IsSameObject(pAllocator, GetControllingUnknown());
    m_bSamplesAreReadOnly = bReadOnly ? true : false;
    HRESULT hr = S_OK;
    if (!m_bUsingMyAllocator) {
        //  Transfer the properties across
        ALLOCATOR_PROPERTIES Props;
        hr = pAllocator->GetProperties(&Props);
        if (FAILED(hr)) {
            return hr;
        }
        ALLOCATOR_PROPERTIES PropsActual;
        hr = SetProperties(&Props, &PropsActual);
    }
    m_pAllocator = pAllocator;
    return hr;
}


STDMETHODIMP CStream::GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps)
{
    // Return E_NOTIMPL to indicate that we don't have any requirement and will not accept someone
    // elses allocator.
    return E_NOTIMPL;
}


STDMETHODIMP CStream::ReceiveMultiple(IMediaSample **pSamples, long nSamples, long *nSamplesProcessed)
{
    HRESULT hr = S_OK;
    *nSamplesProcessed = 0;
    while (nSamples-- > 0) {
        hr = Receive(pSamples[*nSamplesProcessed]);
        if (hr != S_OK) {
            break;
        }
        (*nSamplesProcessed)++;
    }
    return hr;
}

STDMETHODIMP CStream::ReceiveCanBlock()
{
    return S_OK;    // Pin can block if not using our allocator or using read-only samples
}



//
//  This method assumes the critical section is taken.
//
HRESULT CStream::ConnectThisMediaType(IPin *pReceivePin, const AM_MEDIA_TYPE *pmt)
{
    HRESULT hr = pReceivePin->ReceiveConnection(this, pmt);
    if (SUCCEEDED(hr)) {
        m_pConnectedMemInputPin = pReceivePin;  // Does a magic QI here!
        if (!m_pConnectedMemInputPin) {
            hr = VFW_E_TYPE_NOT_ACCEPTED;
        } else {
            hr = ReceiveConnection(pReceivePin, pmt);
            if (SUCCEEDED(hr)) {
                hr = m_pConnectedMemInputPin->NotifyAllocator(this, TRUE);
            }
            if (SUCCEEDED(hr)) {
                CopyMediaType(&m_ConnectedMediaType, pmt);
            }
            if (SUCCEEDED(hr)) {
                m_pAllocator = this;
                m_bUsingMyAllocator = true;
            } else {
                Disconnect();
            }
        }
    }
    return hr;
}

STDMETHODIMP CStream::Connect(IPin * pReceivePin, const AM_MEDIA_TYPE *pmt)
{
    HRESULT hr;
    AUTO_CRIT_LOCK;

    if (pmt) {
        hr = ConnectThisMediaType(pReceivePin, pmt);
    } else {
        AM_MEDIA_TYPE *pCurMediaType;
        hr = GetMediaType(0, &pCurMediaType);
        if (SUCCEEDED(hr)) {
            hr = ConnectThisMediaType(pReceivePin, pCurMediaType);
            DeleteMediaType(pCurMediaType);
        }
    }
    return hr;
}



STDMETHODIMP CStream::EnumMediaTypes(IEnumMediaTypes **ppEnum)
{
    HRESULT hr = S_OK;
    CMediaTypeEnum *pNewEnum = new CComObject<CMediaTypeEnum>;
    if (pNewEnum == NULL) {
	hr = E_OUTOFMEMORY;
    } else {
        pNewEnum->Initialize(this, 0);
    }
    pNewEnum->GetControllingUnknown()->QueryInterface(IID_IEnumMediaTypes, (void **)ppEnum);
    return hr;
}


STDMETHODIMP CStream::Commit()
{
    AUTO_CRIT_LOCK;
    if (!m_bCommitted) {
        if (m_StreamType == STREAMTYPE_WRITE) {
            if (!m_pWritePump) {
                HRESULT hr = CPump::CreatePump(this, &m_pWritePump);
                if (hr != S_OK) {
                    return hr;
                }
            }
            m_pWritePump->Run(true);
        }
        //
        //  Interesting thing to note here -- Even if we have not been initialized we will still
        //  work correctly on commit.  We will simply set the requested buffer count to 1.
        //
        if (m_lRequestedBufferCount == 0) {
            m_lRequestedBufferCount = 1;
        }
        m_bCommitted = true;
    }
    return S_OK;
}



STDMETHODIMP CStream::Decommit()
{
    HRESULT hr = S_OK;

    AUTO_CRIT_LOCK;
    if (m_bCommitted) {     // If we're already decommitted then just return S_OK.
        m_bCommitted = false;
        if (m_lWaiting > 0) {
            ReleaseSemaphore(m_hWaitFreeSem, m_lWaiting, 0);
            m_lWaiting = 0;
        }
        if (m_pWritePump) {
            m_pWritePump->Run(false);
        }
    }
    return hr;
}


//
//  This method is not supported and never will be!
//
STDMETHODIMP CStream::ReleaseBuffer(IMediaSample *pBuffer)
{
    return E_UNEXPECTED;
};


//
//  The caller holds the reference to the sample after this point.
//
HRESULT CStream::AllocSampleFromPool(
    const REFERENCE_TIME *pStartTime,
    CSample **ppSample
)
{
    CSample *pSample = NULL;
    HRESULT hr = NOERROR;
    bool bWaited = false;
    bool bCreatedTemp = false;

    do {
        LONGLONG llLate = 0;
    	Lock();
        // Check we are committed -- This can happen after we've blocked and then
    	// wake back up due to a decommit.
        if (!m_bCommitted) {
    	    hr = VFW_E_NOT_COMMITTED;
    	    break;
        }
        if (pStartTime) {
            REFERENCE_TIME CurTime;
            if (m_pFilter->GetCurrentStreamTime(&CurTime) == S_OK) {
                llLate = CurTime - *pStartTime;

                /*  Block if more than a millisecond early */
                if (-llLate >= 10000) {
                    m_rtWaiting = *pStartTime;
                    Unlock();
                    m_pFilter->WaitUntil(*pStartTime);
                    Lock();
                    m_rtWaiting = 0;
                    if (!m_bCommitted) {
    	                hr = VFW_E_NOT_COMMITTED;
    	                break;
                    }
                }
            }
        }
        pSample = m_pFirstFree;
        if (bWaited && pSample == NULL) {
            _ASSERTE(m_bNoStall);
            if (!m_bUsingMyAllocator) {
                hr = HRESULT_FROM_WIN32(ERROR_SEM_TIMEOUT);
                break;
            } else {
                //  Try to make one
                CreateTempSample(&pSample);
                if (pSample) {
                    bCreatedTemp = true;
                }
                //  pSample->SetCompletionStatus(MS_S_PENDING);
            }
        }
        if (pSample == NULL) {
            m_lWaiting++;
            Unlock();

            //  Only wait for half a second if non-blocking
            DWORD dwWait = INFINITE;
            if (m_bNoStall) {
                const LONGLONG llLateMs = llLate / 10000;
                const DWORD dwMaxLateMs = 100;
                if (llLateMs > dwMaxLateMs) {
                    dwWait = 0;
                } else {
                    // llLateMs could be negative which means we waited
                    // just above
                    if (llLateMs > 0) {
                        dwWait = dwMaxLateMs - (DWORD)llLateMs;
                    } else {
                        dwWait = dwMaxLateMs;
                    }
                }
            }
            bWaited = WAIT_TIMEOUT == WaitForSingleObject(
                                          m_hWaitFreeSem,
                                          dwWait) ?
                      true : false;
        } else if (!bCreatedTemp) {
            m_pFirstFree = pSample->m_pNextFree;
            if (m_pFirstFree) {
                m_pFirstFree->m_pPrevFree = NULL;
            } else {
                m_pLastFree = NULL;
            }
            pSample->m_pNextFree = NULL;	// Just to be tidy.  We know that m_pPrevFree is null!
            _ASSERTE(pSample->m_Status == MS_S_PENDING);
            CHECKSAMPLELIST
        }
    } while (pSample == NULL);
    Unlock();
    if (pSample) {
        pSample->m_bWaited = pStartTime != 0 ? true : false;
    }
    *ppSample = pSample;
    return hr;
}


void CStream::AddSampleToFreePool(CSample *pSample)
{
    Lock();
    _ASSERTE(pSample->m_pPrevFree == NULL && pSample->m_pNextFree == NULL);
    if (m_pFirstFree) {
        pSample->m_pPrevFree = m_pLastFree;
        m_pLastFree->m_pNextFree = pSample;
    } else {
        pSample->m_pPrevFree = NULL;
        m_pFirstFree = pSample;
    }
    pSample->m_pNextFree = NULL;    // We know that the prev ptr is already null
    m_pLastFree = pSample;
    CHECKSAMPLELIST
    if (m_lWaiting > 0) {
        ReleaseSemaphore(m_hWaitFreeSem, 1, 0);
    	m_lWaiting--;
    }
    Unlock();
}


//
//  The caller holds the reference to the sample after this point!
//
bool CStream::StealSampleFromFreePool(CSample *pSample, BOOL bAbort)
{
    bool bWorked = false;
    Lock();
    if (m_pFirstFree) {
        if (m_pFirstFree == pSample) {
            // We'll only steal the first sample if there's nobody waiting for it right now.
            bool bTakeFirstFree = true;
            if (!bAbort && m_bCommitted) {
                REFERENCE_TIME CurTime;
                if (m_rtWaiting && m_pFilter->GetCurrentStreamTime(&CurTime) == S_OK) {
                    bTakeFirstFree = m_rtWaiting > CurTime;
                }
            }
            if (bTakeFirstFree) {
                m_pFirstFree = pSample->m_pNextFree;
                if (m_pFirstFree) {
                    m_pFirstFree->m_pPrevFree = NULL;
                } else {
                    m_pLastFree = NULL;
                }
                pSample->m_pNextFree = NULL;    // We know the prev ptr is already null!
                _ASSERTE(pSample->m_pPrevFree == NULL);
                bWorked = true;
            }
        } else {
            if (pSample->m_pPrevFree) {
                pSample->m_pPrevFree->m_pNextFree = pSample->m_pNextFree;
                if (pSample->m_pNextFree) {
                    pSample->m_pNextFree->m_pPrevFree = pSample->m_pPrevFree;
                } else {
                    m_pLastFree = pSample->m_pPrevFree;
                }
                pSample->m_pNextFree = pSample->m_pPrevFree = NULL;
                bWorked = true;
            }
        }
        CHECKSAMPLELIST
    }
    Unlock();
    return bWorked;
}


HRESULT CStream::CheckReceiveConnectionPin(IPin * pPin)
{
    HRESULT hr;
    if (!pPin) {
        hr = E_POINTER;
    } else {
        if (m_pConnectedPin != NULL) {
            hr = VFW_E_ALREADY_CONNECTED;
        } else {
            PIN_INFO pinfo;
            hr = pPin->QueryPinInfo(&pinfo);
            if (hr == NOERROR) {
                pinfo.pFilter->Release();
                if (pinfo.dir == m_Direction) {
                    hr = VFW_E_INVALID_DIRECTION;
                }
            }
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\stdafx.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\stream.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// Stream.h : Declaration of the CStream

#ifndef __STREAM_H_
#define __STREAM_H_

class CSample;
class CPump;

/////////////////////////////////////////////////////////////////////////////
// CStream
class ATL_NO_VTABLE CStream :
	public CComObjectRootEx<CComMultiThreadModel>,
        public IPin,
        public IMemInputPin,
        public IAMMediaStream,
        public IMemAllocator
{
friend CPump;

public:
        typedef CComObjectRootEx<CComMultiThreadModel> _BaseClass;
        DECLARE_GET_CONTROLLING_UNKNOWN()
        //
        // METHODS
        //
	CStream();
        virtual ~CStream();

        //
        // IMediaStream
        //

        STDMETHODIMP GetMultiMediaStream(
            /* [out] */ IMultiMediaStream **ppMultiMediaStream);

        STDMETHODIMP GetInformation(
            /* [optional][out] */ MSPID *pPurposeId,
            /* [optional][out] */ STREAM_TYPE *pType);

        STDMETHODIMP SendEndOfStream(DWORD dwFlags);

        //
        // IAMMediaStream
        //
        STDMETHODIMP Initialize(
            IUnknown *pSourceObject,
            DWORD dwFlags,
            /* [in] */ REFMSPID PurposeId,
            /* [in] */ const STREAM_TYPE StreamType);

        STDMETHODIMP SetState(
            /* [in] */ FILTER_STATE State);

        STDMETHODIMP JoinAMMultiMediaStream(
            /* [in] */ IAMMultiMediaStream *pAMMultiMediaStream);

        STDMETHODIMP JoinFilter(
            /* [in] */ IMediaStreamFilter *pMediaStreamFilter);

        STDMETHODIMP JoinFilterGraph(
            /* [in] */ IFilterGraph *pFilterGraph);


        //
        // IPin
        //
        STDMETHODIMP Disconnect();
        STDMETHODIMP ConnectedTo(IPin **pPin);
        STDMETHODIMP ConnectionMediaType(AM_MEDIA_TYPE *pmt);
        STDMETHODIMP QueryPinInfo(PIN_INFO * pInfo);
        STDMETHODIMP QueryDirection(PIN_DIRECTION * pPinDir);
        STDMETHODIMP QueryId(LPWSTR * Id);
        STDMETHODIMP QueryAccept(const AM_MEDIA_TYPE *pmt);
        STDMETHODIMP QueryInternalConnections(IPin* *apPin, ULONG *nPin);
        STDMETHODIMP EndOfStream(void);
        STDMETHODIMP BeginFlush(void);
        STDMETHODIMP EndFlush(void);
        STDMETHODIMP NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate);

        //
        // IMemInputPin
        //
        STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);
        STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator, BOOL bReadOnly);
        STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps);
        STDMETHODIMP ReceiveMultiple(IMediaSample **pSamples, long nSamples, long *nSamplesProcessed);
        STDMETHODIMP ReceiveCanBlock();
        STDMETHODIMP Connect(IPin * pReceivePin, const AM_MEDIA_TYPE *pmt);
        STDMETHODIMP EnumMediaTypes(IEnumMediaTypes **ppEnum);

        //
        // IMemAllocator
        //
        STDMETHODIMP Commit();
        STDMETHODIMP Decommit();
        STDMETHODIMP ReleaseBuffer(IMediaSample *pBuffer);

        // Note that NotifyAllocator calls this so override it
        // if you care.  Audio doesn't care becuase it's not
        // really using this allocator at all.
        STDMETHODIMP SetProperties(
    		ALLOCATOR_PROPERTIES* pRequest,
    		ALLOCATOR_PROPERTIES* pActual)
        {
            return S_OK;
        }
        STDMETHODIMP GetProperties(ALLOCATOR_PROPERTIES* pProps)
        {
            return E_UNEXPECTED;
        }

        //
        // Special CStream methods
        //
        virtual HRESULT GetMediaType(ULONG Index, AM_MEDIA_TYPE **ppMediaType) = 0;

        // Special to make sample to discard stuff into
        virtual HRESULT CreateTempSample(CSample **ppSample)
        {
            return E_FAIL;
        }

        virtual LONG GetChopSize()
        {
            return 0;
        }
public:
        //
        //  Private methods
        //
        void GetName(LPWSTR);
        HRESULT AllocSampleFromPool(const REFERENCE_TIME * pStartTime, CSample **ppSample);
        void AddSampleToFreePool(CSample *pSample);
        bool StealSampleFromFreePool(CSample *pSample, BOOL bAbort);
        HRESULT FinalConstruct(void);
        HRESULT ConnectThisMediaType(IPin *pReceivePin, const AM_MEDIA_TYPE *pmt);
        HRESULT CheckReceiveConnectionPin(IPin * pConnector);
#ifdef DEBUG
        #define CHECKSAMPLELIST _ASSERTE(CheckSampleList());
        bool CheckSampleList();
#else
        #define CHECKSAMPLELIST
#endif

BEGIN_COM_MAP(CStream)
        COM_INTERFACE_ENTRY(IPin)
        COM_INTERFACE_ENTRY(IMemInputPin)
        COM_INTERFACE_ENTRY(IMemAllocator)
        COM_INTERFACE_ENTRY2(IMediaStream, IAMMediaStream)
        COM_INTERFACE_ENTRY(IAMMediaStream)
END_COM_MAP()

        //
        //  MEMBER VARIABLES
        //
public:
        //
        //  These SHOULD NOT BE CCOMPTRS since we hold weak references to both of them
        //  (we never addref them).
        //
        IMediaStreamFilter             *m_pFilter;
        IBaseFilter                    *m_pBaseFilter;
        IFilterGraph                   *m_pFilterGraph;
        IAMMultiMediaStream            *m_pMMStream;

        //  Allocator held during connection
        CComPtr<IMemAllocator>          m_pAllocator;

        //  Writable streams
        CPump                           *m_pWritePump;

        //  Stream configuration
	STREAM_TYPE                     m_StreamType;
        PIN_DIRECTION                   m_Direction;
	MSPID                           m_PurposeId;
        REFERENCE_TIME                  m_rtSegmentStart;

        //  Allocator state information
        bool                            m_bUsingMyAllocator;
        bool                            m_bSamplesAreReadOnly;
        bool                            m_bCommitted;
        long                            m_lRequestedBufferCount;

        //  Sample list and semaphores
        CSample                         *m_pFirstFree;
        CSample                         *m_pLastFree;
        long                            m_cAllocated;
        long                            m_lWaiting;
        HANDLE                          m_hWaitFreeSem;
        REFERENCE_TIME                  m_rtWaiting;

        //  Filter state
        FILTER_STATE                    m_FilterState;

        //  Pin state
        CComPtr<IPin>                   m_pConnectedPin;
        CComPtr<IQualityControl>        m_pQC;
        CComQIPtr<IMemInputPin, &IID_IMemInputPin> m_pConnectedMemInputPin;
        AM_MEDIA_TYPE                   m_ConnectedMediaType;
        AM_MEDIA_TYPE                   m_ActualMediaType;
        bool                            m_bFlushing;
        bool                            m_bEndOfStream;
        bool                            m_bStopIfNoSamples;
        bool                            m_bNoStall;
};


//
//  Pump class used for write streams
//

class CPump
{
public:
    CPump(CStream *pStream);
    ~CPump();

    static HRESULT CreatePump(CStream *pStream, CPump **ppNewPump);
    HRESULT PumpMainLoop(void);
    void Run(bool);


public:
    CStream                 *m_pStream;
    HANDLE                  m_hThread;
    HANDLE                  m_hRunEvent;
    bool                    m_bShutDown;
    CComAutoCriticalSection m_CritSec;
};




#endif //__STREAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\util.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
#ifndef __UTIL_H_INC__
#define __UTIL_H_INC__

bool IsSameObject(IUnknown *pUnk1, IUnknown *pUnk2);

STDAPI_(void) TStringFromGUID(const GUID* pguid, LPTSTR pszBuf);

#ifdef UNICODE
#define WStringFromGUID TStringFromGUID
#else
STDAPI_(void) WStringFromGUID(const GUID* pguid, LPWSTR pszBuf);
#endif

void InitMediaType(AM_MEDIA_TYPE *pmt);
void DeleteMediaType(AM_MEDIA_TYPE *pmt);
bool IsEqualMediaType(AM_MEDIA_TYPE const & mt1, AM_MEDIA_TYPE const & mt2);
void CopyMediaType(AM_MEDIA_TYPE *pmtTarget, const AM_MEDIA_TYPE *pmtSource);
AM_MEDIA_TYPE * CreateMediaType(AM_MEDIA_TYPE *pSrc);
void FreeMediaType(AM_MEDIA_TYPE& mt);


AM_MEDIA_TYPE * WINAPI AllocVideoMediaType(const AM_MEDIA_TYPE * pmtSource);
HRESULT ConvertMediaTypeToSurfaceDesc(const AM_MEDIA_TYPE *pmt,
                                      IDirectDraw *pDD,
                                      IDirectDrawPalette **ppPalette,
                                      LPDDSURFACEDESC pSurfaceDesc);

HRESULT ConvertSurfaceDescToMediaType(
    const DDSURFACEDESC *pSurfaceDesc, IDirectDrawPalette *pPalette, const RECT *pRect,
    BOOL bInvertSize, AM_MEDIA_TYPE **ppMediaType,
    AM_MEDIA_TYPE *pmtTemplate = 0 // preserve any type information
    );

const DDPIXELFORMAT * GetDefaultPixelFormatPtr(IDirectDraw *pDirectDraw);
bool VideoSubtypeFromPixelFormat(const DDPIXELFORMAT *pPixelFormat, GUID *pSubType);
bool IsSupportedType(const DDPIXELFORMAT *pPixelFormat);
bool ComparePixelFormats(const DDPIXELFORMAT *pFormat1,
                         const DDPIXELFORMAT *pFormat2);

/*  Class to track timestamps for fixed bitrate data */
class CTimeStamp
{
public:
    CTimeStamp()
    {
        Reset();
    }

    void Reset()
    {
        m_lBytesSinceTimeStamp = 0;
        m_rt = 0;
    }

    void SetTime(REFERENCE_TIME rt)
    {
        m_rt = rt;
        m_lBytesSinceTimeStamp = 0;
    }

    void AccumulateBytes(LONG lBytes)
    {
        m_lBytesSinceTimeStamp += lBytes;
    }

    REFERENCE_TIME TimeStamp(LONG lOffset, LONG lByteRate) const
    {
        _ASSERTE(lByteRate > 0);

        //  Do the conversion
        return m_rt + MulDiv(m_lBytesSinceTimeStamp + lOffset,
                             10000000L,
                             lByteRate);
    }

private:
    LONG           m_lBytesSinceTimeStamp;
    REFERENCE_TIME m_rt;
};
#endif __UTIL_H_INC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\ddstream\util.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// Util.cpp : Utility functions
//

#include "stdafx.h"
#include "project.h"
#include <fourcc.h>

bool IsSameObject(IUnknown *pUnk1, IUnknown *pUnk2)
{
    if (pUnk1 == pUnk2) {
  	return TRUE;
    }
    //
    // NOTE:  We can't use CComQIPtr here becuase it won't do the QueryInterface!
    //
    IUnknown *pRealUnk1;
    IUnknown *pRealUnk2;
    pUnk1->QueryInterface(IID_IUnknown, (void **)&pRealUnk1);
    pUnk2->QueryInterface(IID_IUnknown, (void **)&pRealUnk2);
    pRealUnk1->Release();
    pRealUnk2->Release();
    return (pRealUnk1 == pRealUnk2);
}


STDAPI_(void) TStringFromGUID(const GUID* pguid, LPTSTR pszBuf)
{
    wsprintf(pszBuf, TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"), pguid->Data1,
            pguid->Data2, pguid->Data3, pguid->Data4[0], pguid->Data4[1], pguid->Data4[2],
            pguid->Data4[3], pguid->Data4[4], pguid->Data4[5], pguid->Data4[6], pguid->Data4[7]);
}

#ifndef UNICODE
STDAPI_(void) WStringFromGUID(const GUID* pguid, LPWSTR pszBuf)
{
    char szAnsi[40];
    TStringFromGUID(pguid, szAnsi);
    MultiByteToWideChar(CP_ACP, 0, szAnsi, -1, pszBuf, sizeof(szAnsi));
}
#endif


//
//  Media Type helpers
//

void InitMediaType(AM_MEDIA_TYPE * pmt)
{
    ZeroMemory(pmt, sizeof(*pmt));
    pmt->lSampleSize = 1;
    pmt->bFixedSizeSamples = TRUE;
}



bool IsEqualMediaType(AM_MEDIA_TYPE const & mt1, AM_MEDIA_TYPE const & mt2)
{
    return ((IsEqualGUID(mt1.majortype,mt2.majortype) == TRUE) &&
        (IsEqualGUID(mt1.subtype,mt2.subtype) == TRUE) &&
        (IsEqualGUID(mt1.formattype,mt2.formattype) == TRUE) &&
        (mt1.cbFormat == mt2.cbFormat) &&
        ( (mt1.cbFormat == 0) ||
        ( memcmp(mt1.pbFormat, mt2.pbFormat, mt1.cbFormat) == 0)));
}


void CopyMediaType(AM_MEDIA_TYPE *pmtTarget, const AM_MEDIA_TYPE *pmtSource)
{
    *pmtTarget = *pmtSource;
    if (pmtSource->cbFormat != 0) {
        _ASSERTE(pmtSource->pbFormat != NULL);
        pmtTarget->pbFormat = (PBYTE)CoTaskMemAlloc(pmtSource->cbFormat);
        if (pmtTarget->pbFormat == NULL) {
            pmtTarget->cbFormat = 0;
        } else {
            CopyMemory((PVOID)pmtTarget->pbFormat, (PVOID)pmtSource->pbFormat,
                       pmtTarget->cbFormat);
        }
    }
    if (pmtTarget->pUnk != NULL) {
        pmtTarget->pUnk->AddRef();
    }
}

AM_MEDIA_TYPE * CreateMediaType(AM_MEDIA_TYPE *pSrc)
{
    AM_MEDIA_TYPE *pMediaType = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));

    if (pMediaType ) {
        if (pSrc) {
            CopyMediaType(pMediaType,pSrc);
        } else {
            InitMediaType(pMediaType);
        }
    }
    return pMediaType;
}


void DeleteMediaType(AM_MEDIA_TYPE *pmt)
{
    if (pmt) {
        FreeMediaType(*pmt);
	CoTaskMemFree((PVOID)pmt);
    }
}


void FreeMediaType(AM_MEDIA_TYPE& mt)
{
    if (mt.cbFormat != 0) {
        CoTaskMemFree((PVOID)mt.pbFormat);

        // Strictly unnecessary but tidier
        mt.cbFormat = 0;
        mt.pbFormat = NULL;
    }
    if (mt.pUnk != NULL) {
        mt.pUnk->Release();
        mt.pUnk = NULL;
    }
}


// this also comes in useful when using the IEnumMediaTypes interface so
// that you can copy a media type, you can do nearly the same by creating
// a CMediaType object but as soon as it goes out of scope the destructor
// will delete the memory it allocated (this takes a copy of the memory)

AM_MEDIA_TYPE * WINAPI AllocVideoMediaType(const AM_MEDIA_TYPE * pmtSource)
{
    AM_MEDIA_TYPE *pMediaType = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (pMediaType) {
	VIDEOINFO *pVideoInfo = (VIDEOINFO *)CoTaskMemAlloc(sizeof(VIDEOINFO));
	if (pVideoInfo) {
	    if (pmtSource) {
		*pMediaType = *pmtSource;
		CopyMemory(pVideoInfo, pmtSource->pbFormat, sizeof(*pVideoInfo));
	    } else {
		ZeroMemory(pMediaType, sizeof(*pMediaType));
		ZeroMemory(pVideoInfo, sizeof(*pVideoInfo));
		pMediaType->majortype = MEDIATYPE_Video;
		pMediaType->cbFormat = sizeof(*pVideoInfo);
                pMediaType->formattype = FORMAT_VideoInfo;
	    }
	    pMediaType->pbFormat = (BYTE *)pVideoInfo;
	} else {
	    CoTaskMemFree((PVOID)pMediaType);
	    pMediaType = NULL;
	}
    }
    return pMediaType;
}


//
//  WARNING:  The order of the entries in these tables is important!  Make sure the
//  pixelformats and mediatypes line up!
//
const GUID * g_aFormats[] =
{
    &MEDIASUBTYPE_RGB8,
    &MEDIASUBTYPE_RGB565,
    &MEDIASUBTYPE_RGB555,
    &MEDIASUBTYPE_RGB24,
    &MEDIASUBTYPE_RGB24,
    &MEDIASUBTYPE_RGB32,
    &MEDIASUBTYPE_RGB32
};

const DDPIXELFORMAT g_aPixelFormats[] =
{
    {sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED8, 0, 8, 0, 0, 0, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 16, 0x0000F800, 0x000007E0, 0x0000001F, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 16, 0x00007C00, 0x000003E0, 0x0000001F, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 24, 0x00FF0000, 0x0000FF00, 0x000000FF, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 24, 0x000000FF, 0x0000FF00, 0x00FF0000, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 32, 0x00FF0000, 0x0000FF00, 0x000000FF, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 32, 0x000000FF, 0x0000FF00, 0x00FF0000, 0}
};



bool VideoSubtypeFromPixelFormat(const DDPIXELFORMAT *pPixelFormat, GUID *pSubType)
{
    for( int i = 0; i < sizeof(g_aPixelFormats)/sizeof(g_aPixelFormats[0]); i++ )
    {
        if (ComparePixelFormats(&g_aPixelFormats[i], pPixelFormat)) {
            *pSubType = *g_aFormats[i];
	    return true;
	}
    }
    //  OK - try just using the fourcc
    if (pPixelFormat->dwFlags & DDPF_FOURCC) {
        *pSubType = FOURCCMap(pPixelFormat->dwFourCC);
        return true;
    }
    return false;
}

bool IsSupportedType(const DDPIXELFORMAT *pPixelFormat)
{
    for( int i = 0; i < sizeof(g_aPixelFormats)/sizeof(g_aPixelFormats[0]); i++ )
    {
        if(ComparePixelFormats(&g_aPixelFormats[i], pPixelFormat)) {
	    return true;
	}
    }
    return false;
}


const DDPIXELFORMAT * GetDefaultPixelFormatPtr(IDirectDraw *pDirectDraw)
{
    if (pDirectDraw) {
        DDSURFACEDESC ddsd;
        ddsd.dwSize = sizeof(ddsd);
        if (SUCCEEDED(pDirectDraw->GetDisplayMode(&ddsd))) {
            for( int i = 0; i < sizeof(g_aPixelFormats)/sizeof(g_aPixelFormats[0]); i++ ) {
                if(memcmp(&g_aPixelFormats[i], &ddsd.ddpfPixelFormat, sizeof(g_aPixelFormats[i])) == 0) {
                    return &g_aPixelFormats[i];
	        }
            }
        }
    }
    return &g_aPixelFormats[0];
}

//
// Helper function converts a DirectDraw surface to a media type.
// The surface description must have:
//  Height
//  Width
//  lPitch -- Only used if DDSD_PITCH is set
//  PixelFormat

// Initialise our output type based on the DirectDraw surface. As DirectDraw
// only deals with top down display devices so we must convert the height of
// the surface returned in the DDSURFACEDESC into a negative height. This is
// because DIBs use a positive height to indicate a bottom up image. We also
// initialise the other VIDEOINFO fields although they're hardly ever needed
//
// pmtTemplate is used to resolve any ambiguous mappings when we don't
// want to change the connection type

HRESULT ConvertSurfaceDescToMediaType(const DDSURFACEDESC *pSurfaceDesc,
                                      IDirectDrawPalette *pPalette,
                                      const RECT *pRect, BOOL bInvertSize, AM_MEDIA_TYPE **ppMediaType,
                                      AM_MEDIA_TYPE *pmtTemplate)
{
    *ppMediaType = NULL;
    AM_MEDIA_TYPE *pMediaType = AllocVideoMediaType(NULL);
    if (pMediaType == NULL) {
	return E_OUTOFMEMORY;
    }
    if (!VideoSubtypeFromPixelFormat(&pSurfaceDesc->ddpfPixelFormat, &pMediaType->subtype)) {
        DeleteMediaType(pMediaType);
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    VIDEOINFO *pVideoInfo = (VIDEOINFO *)pMediaType->pbFormat;
    BITMAPINFOHEADER *pbmiHeader = &pVideoInfo->bmiHeader;

    // Convert a DDSURFACEDESC into a BITMAPINFOHEADER (see notes later). The
    // bit depth of the surface can be retrieved from the DDPIXELFORMAT field
    // in the DDpSurfaceDesc-> The documentation is a little misleading because
    // it says the field is permutations of DDBD_*'s however in this case the
    // field is initialised by DirectDraw to be the actual surface bit depth

    pbmiHeader->biSize      = sizeof(BITMAPINFOHEADER);
    if (pSurfaceDesc->dwFlags & DDSD_PITCH) {
        pbmiHeader->biWidth = pSurfaceDesc->lPitch;
        // Convert the pitch from a byte count to a pixel count.
        // For some weird reason if the format is not a standard bit depth the
        // width field in the BITMAPINFOHEADER should be set to the number of
        // bytes instead of the width in pixels. This supports odd YUV formats
        // like IF09 which uses 9bpp.
        int bpp = pSurfaceDesc->ddpfPixelFormat.dwRGBBitCount;
        if (bpp == 8 || bpp == 16 || bpp == 24 || bpp == 32) {
            pbmiHeader->biWidth /= (bpp / 8);   // Divide by number of BYTES per pixel.
        }
    } else {
        pbmiHeader->biWidth = pSurfaceDesc->dwWidth;
        // BUGUBUG -- Do something odd here with strange YUV pixel formats?  Or does it matter?
    }


    pbmiHeader->biHeight    = pSurfaceDesc->dwHeight;
    if (bInvertSize) {
	pbmiHeader->biHeight = -pbmiHeader->biHeight;
    }
    pbmiHeader->biPlanes        = 1;
    pbmiHeader->biBitCount      = (USHORT) pSurfaceDesc->ddpfPixelFormat.dwRGBBitCount;
    pbmiHeader->biCompression   = pSurfaceDesc->ddpfPixelFormat.dwFourCC;
    //pbmiHeader->biXPelsPerMeter = 0;
    //pbmiHeader->biYPelsPerMeter = 0;
    //pbmiHeader->biClrUsed       = 0;
    //pbmiHeader->biClrImportant  = 0;

    // For true colour RGB formats tell the source there are bit fields
    // unless it's regular RGB555
    //
    // Try to preserve BI_RGB for RGB32 from template in case
    // connection wasn't queried for a BI_BITFIELDS -> BI_RGB switch

    _ASSERTE(!pmtTemplate || pmtTemplate->formattype == FORMAT_VideoInfo);
    DWORD dwSrcComp = pmtTemplate ?
        ((VIDEOINFO *)pmtTemplate->pbFormat)->bmiHeader.biCompression :
        (DWORD)-1;

    if (pbmiHeader->biCompression == BI_RGB) {
        if (pbmiHeader->biBitCount == 16 &&
            pMediaType->subtype != MEDIASUBTYPE_RGB555 ||
	    pbmiHeader->biBitCount == 32 && dwSrcComp == BI_BITFIELDS) {
	    pbmiHeader->biCompression = BI_BITFIELDS;
        }
    }

    if (PALETTISED(pVideoInfo)) {
	pbmiHeader->biClrUsed = 1 << pbmiHeader->biBitCount;
        if (pPalette) {
            pPalette->GetEntries(0, 0, pbmiHeader->biClrUsed, (LPPALETTEENTRY)&pVideoInfo->bmiColors);
            for (unsigned int i = 0; i < pbmiHeader->biClrUsed; i++) {
                BYTE tempRed = pVideoInfo->bmiColors[i].rgbRed;
                pVideoInfo->bmiColors[i].rgbRed = pVideoInfo->bmiColors[i].rgbBlue;
                pVideoInfo->bmiColors[i].rgbBlue = tempRed;
            }
        }
    }

    // The RGB bit fields are in the same place as for YUV formats

    if (pbmiHeader->biCompression != BI_RGB) {
        pVideoInfo->dwBitMasks[0] = pSurfaceDesc->ddpfPixelFormat.dwRBitMask;
        pVideoInfo->dwBitMasks[1] = pSurfaceDesc->ddpfPixelFormat.dwGBitMask;
        pVideoInfo->dwBitMasks[2] = pSurfaceDesc->ddpfPixelFormat.dwBBitMask;
    }

    pbmiHeader->biSizeImage = DIBSIZE(*pbmiHeader);

    // Complete the rest of the VIDEOINFO fields

    //pVideoInfo->dwBitRate = 0;
    //pVideoInfo->dwBitErrorRate = 0;
    //pVideoInfo->AvgTimePerFrame = 0;

    // And finish it off with the other media type fields

    // pMediaType->formattype = FORMAT_VideoInfo;
    pMediaType->lSampleSize = pbmiHeader->biSizeImage;
    pMediaType->bFixedSizeSamples = TRUE;
    //pMediaType->bTemporalCompression = FALSE;

    // Initialise the source and destination rectangles


    if (pRect) {
        pVideoInfo->rcSource.right = pRect->right - pRect->left;
        pVideoInfo->rcSource.bottom = pRect->bottom - pRect->top;
        pVideoInfo->rcTarget = *pRect;
    } else {
        //pVideoInfo->rcTarget.left = pVideoInfo->rcTarget.top = 0;
        pVideoInfo->rcTarget.right = pSurfaceDesc->dwWidth;
        pVideoInfo->rcTarget.bottom = pSurfaceDesc->dwHeight;
        //pVideoInfo->rcSource.left = pVideoInfo->rcSource.top = 0;
        pVideoInfo->rcSource.right = pSurfaceDesc->dwWidth;
        pVideoInfo->rcSource.bottom = pSurfaceDesc->dwHeight;
    }

    *ppMediaType = pMediaType;
    return S_OK;
}


bool PixelFormatFromVideoSubtype(REFGUID refSubType, DDPIXELFORMAT *pPixelFormat)
{
    for( int i = 0; i < sizeof(g_aFormats)/sizeof(g_aFormats[0]); i++ )
    {
	if (*g_aFormats[i] == refSubType)
	{
            *pPixelFormat = g_aPixelFormats[i];
	    return TRUE;
	}
    }
    return FALSE;
}




HRESULT ConvertMediaTypeToSurfaceDesc(const AM_MEDIA_TYPE *pmt,
                                      IDirectDraw *pDD,
                                      IDirectDrawPalette **ppPalette,
                                      LPDDSURFACEDESC pSurfaceDesc)
{
    *ppPalette = NULL;

    if (pmt->majortype != MEDIATYPE_Video ||
        pmt->formattype != FORMAT_VideoInfo) {
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    VIDEOINFO *pVideoInfo = (VIDEOINFO *)pmt->pbFormat;
    BITMAPINFOHEADER *pbmiHeader = &pVideoInfo->bmiHeader;

    pSurfaceDesc->dwFlags = DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;

    // Should really look at rcTarget here if it's not empty but there are
    // very few valid cases where it makes sense so rather than risk
    // regressions we're not going to change it.

    pSurfaceDesc->dwHeight = (pbmiHeader->biHeight > 0) ? pbmiHeader->biHeight : -pbmiHeader->biHeight;
    pSurfaceDesc->dwWidth  = pbmiHeader->biWidth;

    if (PixelFormatFromVideoSubtype(pmt->subtype, &pSurfaceDesc->ddpfPixelFormat)) {
        if (pDD && pSurfaceDesc->ddpfPixelFormat.dwRGBBitCount == 8) {
            //
            //  The RGBQUAD and PALETTEENTRY sturctures have Red and Blue swapped so
            //  we can't do a simple memory copy.
            //
            PALETTEENTRY aPaletteEntry[256];
            int iEntries = min(256, pVideoInfo->bmiHeader.biClrUsed);
            if (0 == iEntries && pmt->cbFormat >=
                (DWORD)FIELD_OFFSET(VIDEOINFO, bmiColors[256])) {
                iEntries = 256;
            }
            ZeroMemory(aPaletteEntry, sizeof(aPaletteEntry));
            for (int i = 0; i < iEntries; i++) {
                aPaletteEntry[i].peRed = pVideoInfo->bmiColors[i].rgbRed;
                aPaletteEntry[i].peGreen = pVideoInfo->bmiColors[i].rgbGreen;
                aPaletteEntry[i].peBlue = pVideoInfo->bmiColors[i].rgbBlue;
            }
            return pDD->CreatePalette(DDPCAPS_8BIT | DDPCAPS_ALLOW256, aPaletteEntry, ppPalette, NULL);
        }
        return S_OK;
    } else {
        return VFW_E_TYPE_NOT_ACCEPTED;
    }
}


//  Helper to compare pixel formats
bool ComparePixelFormats(const DDPIXELFORMAT *pFormat1,
                         const DDPIXELFORMAT *pFormat2)
{
    //  Compare the flags
    if (pFormat1->dwSize != pFormat2->dwSize) {
        return false;
    }
    if ((pFormat1->dwFlags ^ pFormat2->dwFlags) & (DDPF_RGB |
                                                   DDPF_PALETTEINDEXED8 |
                                                   DDPF_PALETTEINDEXED4 |
                                                   DDPF_PALETTEINDEXED2 |
                                                   DDPF_PALETTEINDEXED1 |
                                                   DDPF_PALETTEINDEXEDTO8 |
                                                   DDPF_YUV)
        ) {
        return false;
    }
    return (0 == memcmp(&pFormat1->dwFourCC, &pFormat2->dwFourCC,
                        FIELD_OFFSET(DDPIXELFORMAT, dwRGBAlphaBitMask) -
                        FIELD_OFFSET(DDPIXELFORMAT, dwFourCC))
           );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\bmp.c ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved.
 *
 *  File:       bmp.c
 *  Content:    Bitmap reader
 *
 ***************************************************************************/
#include "foxbear.h"

/*
 * gfxLoadBitmap
 */
GFX_HBM gfxLoadBitmap(LPSTR szFileName)
{
    HFASTFILE                  pfile;   
    BITMAPFILEHEADER UNALIGNED *pbf;
    BITMAPINFOHEADER UNALIGNED *pbi;
    GFX_HBM                    hbm; 
    BOOL                       trans = FALSE;

    pfile = FastFileOpen( szFileName );

    if( pfile == NULL )
    {
        return NULL;
    }

    pbf = (BITMAPFILEHEADER *)FastFileLock(pfile, 0, 0);
    pbi = (BITMAPINFOHEADER *)(pbf+1);

    if (pbf->bfType != 0x4d42 ||
        pbi->biSize != sizeof(BITMAPINFOHEADER))
    {
                Msg("Failed to load");
                Msg(szFileName);
        FastFileClose( pfile );
        return NULL;
    }

    /*
     * TOTAL HACK for FoxBear, FoxBear does not use any masks, it draws
     * sprites with transparent colors, but the code still loads the masks
     * if a mask exists the sprite is transparent, else it is not, so
     * you cant get rid of the masks or nothing will be transparent!!
     *
     * if the code tries to load a mask, just return a non-zero value.
     */

    if( pbi->biBitCount == 1 )
    {
        Msg("some code is still using masks, stop that!");
        FastFileClose( pfile );
        return NULL;
    }

    /*
     * ANOTHER TOTAL HACK for FoxBear, some of the bitmaps in FoxBear
     * are a solid color, detect these and dont waste VRAM on them.
     */
    if( !bTransDest && pbi->biBitCount == 8 )
    {
        int x,y;
        BYTE c;
        BYTE UNALIGNED *pb = (LPBYTE)pbi + pbi->biSize + 256 * sizeof(COLORREF);
        RGBQUAD UNALIGNED *prgb = (RGBQUAD *)((LPBYTE)pbi + pbi->biSize);
        COLORREF rgb;

        c = *pb;

        for(y=0; y<(int)pbi->biHeight; y++ )
        {
            for( x=0; x<(int)pbi->biWidth; x++ )
            {
                if (c != *pb++)
                    goto not_solid;
            }
            pb += ((pbi->biWidth + 3) & ~3) - pbi->biWidth;
        }

        rgb = RGB(prgb[c].rgbRed,prgb[c].rgbGreen,prgb[c].rgbBlue);
        hbm = gfxCreateSolidColorBitmap(rgb);

        FastFileClose( pfile );
        return hbm;
    }
not_solid:

    /*
     * figure out iff the bitmap has the transparent color in it.
     */
    if( pbi->biBitCount == 8 )
    {
        int x,y;
        BYTE UNALIGNED *pb = (LPBYTE)pbi + pbi->biSize + 256 * sizeof(COLORREF);
        DWORD UNALIGNED *prgb = (DWORD *)((LPBYTE)pbi + pbi->biSize);

        for(y=0; y<(int)pbi->biHeight && !trans; y++ )
        {
            for( x=0; x<(int)pbi->biWidth && !trans; x++ )
            {
                if (prgb[*pb++] == 0x00FFFFFF)
                    trans=TRUE;
            }
            pb += ((pbi->biWidth + 3) & ~3) - pbi->biWidth;
        }
    }

    hbm = gfxCreateVramBitmap(pbi, trans);

    if( hbm == NULL )
    {
        FastFileClose( pfile );
        return GFX_FALSE;
    }

#if 0
    {
        DDSCAPS ddscaps;

        IDirectDrawSurface_GetCaps(((GFX_BITMAP *)hbm)->lpSurface, &ddscaps);

        if( !(ddscaps.dwCaps & DDSCAPS_VIDEOMEMORY) )
        {
            Msg( "%s is in system memory", szFileName );
        }
    }
#endif

    FastFileClose( pfile );

    return hbm;

} /* gfxLoadBitmap */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\ddraw.c ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved.
 *
 *  File:       ddraw.c
 *  Content:    Misc. Direct Draw access routines
 *
 ***************************************************************************/
#include "foxbear.h"

BOOL    bUseEmulation;
BOOL    bUseSysMem;
int     nBufferCount;
int     CmdLineBufferCount;
BOOL    bTransDest;
BOOL    bColorFill;

HRESULT CALLBACK EnumDisplayModesCallback(LPDDSURFACEDESC pddsd, LPVOID Context);

/*
 * DDEnable
 */
BOOL DDEnable( void )
{
    LPDIRECTDRAW        lpdd;
    DDCAPS              ddcaps;
    HRESULT             ddrval;
    BOOL                use_dest;

    nBufferCount = GetProfileInt( "FoxBear", "buffers", CmdLineBufferCount);
    bUseEmulation = GetProfileInt( "FoxBear", "use_emulation", bUseEmulation);
    bUseSysMem = GetProfileInt( "FoxBear", "sysmem", 0);
    use_dest = GetProfileInt( "FoxBear", "use_dest", 0 );

    if (lpDD == NULL)
    {
        if( bUseEmulation )
        {
            ddrval = DirectDrawCreate( (LPVOID) DDCREATE_EMULATIONONLY, &lpdd, NULL );
        }
        else
        {
            ddrval = DirectDrawCreate( NULL, &lpdd, NULL );
        }
    }
    else
    {
        lpdd = lpDD;
        ddrval = DD_OK;
    }

    if( ddrval != DD_OK )
    {
        Msg("DirectDrawCreate failed err=%d", ddrval);
        goto error;
    }

    /*
     * grab exclusive mode if we are going to run as fullscreen
     * otherwise grab normal mode.
     */
    if (lpDD == NULL)
    {
        NumModes = 0;

        if (bFullscreen)
        {
            ddrval = IDirectDraw_SetCooperativeLevel( lpdd, hWndMain,
                            DDSCL_ALLOWMODEX |
                            DDSCL_EXCLUSIVE |
                            DDSCL_FULLSCREEN );

            // in fullscreen mode, enumeratte the available modes
            IDirectDraw_EnumDisplayModes(lpdd, 0, NULL, 0, EnumDisplayModesCallback);
        }
        else
        {
            ddrval = IDirectDraw_SetCooperativeLevel( lpdd, hWndMain,
                            DDSCL_NORMAL );

            // in normal windowed mode, just add some "stock" window
            // sizes

            ModeList[NumModes].w = 320;
            ModeList[NumModes].h = 200;
            NumModes++;

            ModeList[NumModes].w = 320;
            ModeList[NumModes].h = 240;
            NumModes++;

            ModeList[NumModes].w = 512;
            ModeList[NumModes].h = 384;
            NumModes++;

            ModeList[NumModes].w = 640;
            ModeList[NumModes].h = 400;
            NumModes++;

            ModeList[NumModes].w = 640;
            ModeList[NumModes].h = 480;
            NumModes++;
        }

        if( ddrval != DD_OK )
        {
            Msg("SetCooperativeLevel failed err=%d", ddrval);
            goto error;
        }
    }

    if (bFullscreen)
    {
        Msg("SetDisplayMode %d %d %d",GameMode.cx,GameMode.cy, GameBPP);
        ddrval = IDirectDraw_SetDisplayMode( lpdd,
            GameMode.cx, GameMode.cy, GameBPP);

        if (ddrval != DD_OK && (GameMode.cx != 640 || GameMode.cy != 480))
        {
            Msg( "cant set mode trying 640x480" );

            GameMode.cx = 640;
            GameMode.cy = 480;
            GameSize = GameMode;

            ddrval = IDirectDraw_SetDisplayMode( lpdd,
                GameMode.cx, GameMode.cy, GameBPP);
        }

        if (ddrval != DD_OK && GameBPP != 8)
        {
            Msg( "cant set mode trying 640x480x8" );

            GameBPP = 8;

            ddrval = IDirectDraw_SetDisplayMode( lpdd,
                GameMode.cx, GameMode.cy, GameBPP);
        }

        if (ddrval != DD_OK && GameBPP != 16)
        {
            Msg( "cant set mode trying 640x480x16" );

            GameBPP = 16;

            ddrval = IDirectDraw_SetDisplayMode( lpdd,
                GameMode.cx, GameMode.cy, GameBPP);
        }

        if( ddrval != DD_OK )
        {
            Msg("SetMode failed err=%d", ddrval);
            goto error;
        }
    }
    else
    {
        RECT rcWork;
        RECT rc;
        HDC hdc;
        DWORD dwStyle;

        //
        //  when in rome (I mean when in windows) we should use the
        //  current mode
        //
        hdc = GetDC(NULL);
        GameBPP = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);
        ReleaseDC(NULL, hdc);

        //
        // if we are still a WS_POPUP window we should convert to a
        // normal app window so we look like a windows app.
        //
        dwStyle = GetWindowStyle(hWndMain);
        dwStyle &= ~WS_POPUP;
        dwStyle |= WS_OVERLAPPED | WS_CAPTION | WS_THICKFRAME | WS_MINIMIZEBOX;
        SetWindowLong(hWndMain, GWL_STYLE, dwStyle);

        if (bStretch)
            SetRect(&rc, 0, 0, GameMode.cx*2, GameMode.cy*2);
        else
            SetRect(&rc, 0, 0, GameMode.cx, GameMode.cy);

        AdjustWindowRectEx(&rc,
            GetWindowStyle(hWndMain),
            GetMenu(hWndMain) != NULL,
            GetWindowExStyle(hWndMain));

        SetWindowPos(hWndMain, NULL, 0, 0, rc.right-rc.left, rc.bottom-rc.top,
            SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

        SetWindowPos(hWndMain, HWND_NOTOPMOST, 0, 0, 0, 0,
            SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);

        //
        //  make sure our window does not hang outside of the work area
        //  this will make people who have the tray on the top or left
        //  happy.
        //
        SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWork, 0);
        GetWindowRect(hWndMain, &rc);
        if (rc.left < rcWork.left) rc.left = rcWork.left;
        if (rc.top  < rcWork.top)  rc.top  = rcWork.top;
        SetWindowPos(hWndMain, NULL, rc.left, rc.top, 0, 0,
            SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    /*
     * check capabilites
     */
    ddcaps.dwSize = sizeof( ddcaps );
    ddrval = IDirectDraw_GetCaps( lpdd, &ddcaps, NULL );

    if( ddrval != DD_OK )
    {
        Msg("GetCaps failed err=%d", ddrval);
        goto error;
    }

    if( ddcaps.dwCaps & DDCAPS_NOHARDWARE )
    {
        Msg( "No hardware support at all" );
    }

    if( ddcaps.dwCaps & DDCAPS_BLTCOLORFILL )
    {
        bColorFill = TRUE;
        Msg( "Device supports color fill" );
    }
    else
    {
        bColorFill = FALSE;
        Msg( "Device does not support color fill" );
    }

    /*
     * default to double buffered on 1mb, triple buffered
     * on > 1mb
     */
    if (nBufferCount == 0)
    {
        if( ddcaps.dwVidMemTotal <= 1024L*1024L*(GameBPP/8) ||
            GameMode.cx > 640 )
        {
            Msg("double buffering (not enough memory)");
            nBufferCount = 2;
        }
        else
        {
            Msg("triple buffering");
            nBufferCount = 3;
        }
    }

    if( ddcaps.dwCaps & DDCAPS_COLORKEY )
    {
        if( ddcaps.dwCKeyCaps & DDCKEYCAPS_SRCBLT )
        {
            Msg( "Can do Src colorkey in hardware" );
        }

        if( ddcaps.dwCKeyCaps & DDCKEYCAPS_DESTBLT )
        {
            Msg( "Can do Dest colorkey in hardware" );
            if( use_dest || !(ddcaps.dwCKeyCaps & DDCKEYCAPS_SRCBLT) )
            {
                /*
                 * since direct draw doesn't support
                 * destination color key in emulation, only
                 * use it if there is enough vram ...
                 */
                if( ddcaps.dwVidMemTotal >= 2 * 1024L*1024L*(GameBPP/8) )
                {
                    Msg( "Using destination color key" );
                    bTransDest = TRUE;
                }
            }
        }
    }
    else
    {
        Msg( "Can't do color key in hardware!" );
    }

    lpDD = lpdd;
    return TRUE;

error:
    return FALSE;

} /* DDEnable */

/*
 * DDDisable
 */
BOOL DDDisable( BOOL fFinal )
{
    if( lpClipper )
    {
        IDirectDrawClipper_Release(lpClipper);
        lpClipper = NULL;
    }

    if( lpBackBuffer )
    {
        IDirectDrawSurface_Release(lpBackBuffer);
        lpBackBuffer = NULL;
    }

    if( lpFrontBuffer )
    {
        IDirectDrawSurface_Release(lpFrontBuffer);
        lpFrontBuffer = NULL;
    }

    if( lpStretchBuffer )
    {
        IDirectDrawSurface_Release(lpStretchBuffer);
        lpStretchBuffer = NULL;
    }

    //
    // fFinal is TRUE when the app is exiting, FALSE if we are
    // just seting a new game size..
    //
    if ( fFinal )
    {
        if( lpDD != NULL )
        {
            IDirectDraw_Release( lpDD );
            lpDD = NULL;
        }
    }

    return TRUE;
}

/*
 * DDClear
 *
 * clear the front buffer and all backbuffers.
 */
BOOL DDClear( void )
{
    DDBLTFX     ddbltfx;
    int         i;
    HRESULT     ddrval;

    UpdateWindow(hWndMain);

    ddbltfx.dwSize = sizeof( ddbltfx );
    ddbltfx.dwFillColor = DDColorMatch(lpBackBuffer, RGB(0, 0, 200));

    if (bFullscreen)
    {
        /*
         * do it for all buffers, we either have 1 or 2 back buffers
         * make sure we get them all, 4 is plenty!
         */
        for( i=0; i<4; i++ )
        {
            ddrval = IDirectDrawSurface_Blt(
                            lpBackBuffer,           // dest surface
                            NULL,                   // dest rect
                            NULL,                   // src surface
                            NULL,                   // src rect
                            DDBLT_COLORFILL | DDBLT_WAIT,
                            &ddbltfx);

            if( ddrval != DD_OK )
            {
                Msg("Fill failed ddrval =0x%08lX", ddrval);
                return FALSE;
            }

            ddrval = IDirectDrawSurface_Flip(lpFrontBuffer, NULL, DDFLIP_WAIT);

            if( ddrval != DD_OK )
            {
                Msg("Flip failed ddrval =0x%08lX", ddrval );
                return FALSE;
            }
        }
    }
    else
    {
        ddrval = IDirectDrawSurface_Blt(
                        lpFrontBuffer,          // dest surface
                        &rcWindow,              // dest rect
                        NULL,                   // src surface
                        NULL,                   // src rect
                        DDBLT_COLORFILL | DDBLT_WAIT,
                        &ddbltfx);

        if( ddrval != DD_OK )
        {
            Msg("Fill failed ddrval =0x%08lX", ddrval);
            return FALSE;
        }
    }

    return TRUE;

} /* DDClear */

/*
 * DDCreateFlippingSurface
 *
 * create a FrontBuffer and a BackBuffer(s)
 *
 */
BOOL DDCreateFlippingSurface( void )
{
    DDPIXELFORMAT       ddpf;
    DDSURFACEDESC       ddsd;
    HRESULT             ddrval;
    DDSCAPS             ddscaps;
    DDCAPS              ddcaps;

    ddcaps.dwSize = sizeof( ddcaps );

    if( IDirectDraw_GetCaps( lpDD, &ddcaps, NULL ) != DD_OK )
        return FALSE;

    /*
     * fill in surface desc:
     * want a primary surface with 2 back buffers
     */
    ZeroMemory( &ddsd, sizeof( ddsd ) );
    ddsd.dwSize = sizeof( ddsd );

    if (bFullscreen && nBufferCount > 1)
    {
        //
        //  fullscreen case, create a primary (ie front) and
        //  either 1  or 2 back buffers
        //
        ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT;
        ddsd.dwBackBufferCount = nBufferCount-1;
        ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE |
                DDSCAPS_FLIP | DDSCAPS_COMPLEX;

        OutputDebugString("Creating multiple backbuffer primary\n\r");
        ddrval = IDirectDraw_CreateSurface( lpDD, &ddsd, &lpFrontBuffer, NULL );

        if( ddrval != DD_OK )
        {
            Msg( "CreateSurface FAILED! %08lx", ddrval );
            return FALSE;
        }

        /*
         * go find the back buffer
         */
        ddscaps.dwCaps = DDSCAPS_BACKBUFFER;
        ddrval = IDirectDrawSurface_GetAttachedSurface(
                    lpFrontBuffer,
                    &ddscaps,
                    &lpBackBuffer );

        if( ddrval != DD_OK )
        {
            Msg( "GetAttachedSurface failed! err=%d",ddrval );
            return FALSE;
        }

        /*
         *  if we are stretching create a buffer to stretch into
         *
         *  NOTE we always make this buffer in system memory because
         *  we render to the backbuffer (in VRAM) at half the size
         *  now we need to stretch into the backbuffer.  we could just
         *  do a VRAM->VRAM stretch, but this is REAL REAL REAL slow on
         *  some cards (banked cards..)
         */
        if( bStretch && (ddcaps.dwCaps & DDCAPS_BANKSWITCHED) )
        {
            Msg( "On bank switched hardware, creating stretch buffer" );
            lpStretchBuffer = DDCreateSurface( GameSize.cx, GameSize.cy,
                                                TRUE, FALSE );
        }
    }
    else if (bFullscreen && nBufferCount == 1)
    {
        ddsd.dwFlags = DDSD_CAPS;
        ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

        OutputDebugString("Creating no backbuffer primary\n\r");
        ddrval = IDirectDraw_CreateSurface( lpDD, &ddsd, &lpFrontBuffer, NULL );

        if( ddrval != DD_OK )
        {
            Msg( "CreateSurface FAILED! %08lx", ddrval );
            return FALSE;
        }

        IDirectDrawSurface_AddRef(lpFrontBuffer);
        lpBackBuffer = lpFrontBuffer;
    }
    else
    {
        //
        //  window case, create the primary surface
        //  and create a backbuffer in offscreen memory.
        //
        ddsd.dwFlags = DDSD_CAPS;
        ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

        ddrval = IDirectDraw_CreateSurface( lpDD, &ddsd, &lpFrontBuffer, NULL );

        if( ddrval != DD_OK )
        {
            Msg( "CreateSurface FAILED! %08lx", ddrval );
            return FALSE;
        }

        lpBackBuffer = DDCreateSurface( GameSize.cx, GameSize.cy, FALSE, FALSE );

        if( lpBackBuffer == NULL )
        {
            Msg( "Cant create the backbuffer" );
            return FALSE;
        }

        //
        // now create a DirectDrawClipper object.
        //
        ddrval = IDirectDraw_CreateClipper(lpDD, 0, &lpClipper, NULL);

        if( ddrval != DD_OK )
        {
            Msg("Cant create clipper");
            return FALSE;
        }

        ddrval = IDirectDrawClipper_SetHWnd(lpClipper, 0, hWndMain);

        if( ddrval != DD_OK )
        {
            Msg("Cant set clipper window handle");
            return FALSE;
        }

        ddrval = IDirectDrawSurface_SetClipper(lpFrontBuffer, lpClipper);

        if( ddrval != DD_OK )
        {
            Msg("Cant attach clipper to front buffer");
            return FALSE;
        }
    }

    /*
     * init the color key
     */
    ddpf.dwSize = sizeof(ddpf);
    IDirectDrawSurface_GetPixelFormat(lpFrontBuffer, &ddpf);

    /*
     * we use white as the color key, if we are in a 8bpp mode, we know
     * what white is (because we use a 332 palette) if we are not in a
     * a 8bpp mode we dont know what white is and we need to figure it
     * out from the device (remember 16bpp comes in two common flavors
     * 555 and 565).  if we wanted to any random color as the color key
     * we would call DDColorMatch (see below) to convert a RGB into a
     * physical color.
     */
    if (ddpf.dwRGBBitCount == 8)
        dwColorKey = 0xff;
    else
        dwColorKey = ddpf.dwRBitMask | ddpf.dwGBitMask | ddpf.dwBBitMask;

    Msg("dwColorKey = 0x%08lX", dwColorKey);

    if( bTransDest )
    {
        DDCOLORKEY              ddck;
        ddck.dwColorSpaceLowValue = dwColorKey;
        ddck.dwColorSpaceHighValue = dwColorKey;
        IDirectDrawSurface_SetColorKey( lpBackBuffer, DDCKEY_DESTBLT, &ddck);
    }

    return TRUE;

} /* DDCreateFlippingSurface */

/*
 * DDCreateSurface
 */
LPDIRECTDRAWSURFACE DDCreateSurface(
                DWORD width,
                DWORD height,
                BOOL sysmem,
                BOOL trans )
{
    DDSURFACEDESC       ddsd;
    HRESULT             ddrval;
    DDCOLORKEY          ddck;
    LPDIRECTDRAWSURFACE psurf;


    /*
     * fill in surface desc
     */
    memset( &ddsd, 0, sizeof( ddsd ) );
    ddsd.dwSize = sizeof( ddsd );
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT |DDSD_WIDTH;

    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
    if( sysmem || bUseSysMem )
    {
        ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
    }

    ddsd.dwHeight = height;
    ddsd.dwWidth = width;

    ddrval = IDirectDraw_CreateSurface( lpDD, &ddsd, &psurf, NULL );

    /*
     * set the color key for this bitmap
     */
    if( ddrval == DD_OK )
    {
        if( trans && !bTransDest )
        {
            ddck.dwColorSpaceLowValue = dwColorKey;
            ddck.dwColorSpaceHighValue = dwColorKey;
            IDirectDrawSurface_SetColorKey( psurf, DDCKEY_SRCBLT, &ddck);
        }
    }
    else
    {
        Msg( "CreateSurface FAILED, rc = %ld", (DWORD) LOWORD( ddrval ) );
        psurf = NULL;
    }

     return psurf;

} /* DDCreateSurface */

DWORD DDColorMatch(IDirectDrawSurface *pdds, COLORREF rgb)
{
    COLORREF rgbT;
    HDC hdc;
    DWORD dw = CLR_INVALID;
    DDSURFACEDESC ddsd;
    HRESULT hres;

    if (IDirectDrawSurface_GetDC(pdds, &hdc) == DD_OK)
    {
        rgbT = GetPixel(hdc, 0, 0);
        SetPixel(hdc, 0, 0, rgb);
        IDirectDrawSurface_ReleaseDC(pdds, hdc);
    }

    ddsd.dwSize = sizeof(ddsd);
    hres = IDirectDrawSurface_Lock(
        pdds, NULL, &ddsd, DDLOCK_WAIT, NULL);

    if (hres == DD_OK)
    {
        dw  = *(DWORD *)ddsd.lpSurface;
        if(ddsd.ddpfPixelFormat.dwRGBBitCount != 32)
            dw &= (1 << ddsd.ddpfPixelFormat.dwRGBBitCount)-1;
        IDirectDrawSurface_Unlock(pdds, NULL);
    }
    else
    {
        IDirectDrawSurface_GetSurfaceDesc(pdds,&ddsd);
        if(ddsd.ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
            Msg("Failed to lock Primary Surface!");
        else
            Msg("Failed to lock NON-PRIMARY Surface!");
    }

    if (IDirectDrawSurface_GetDC(pdds, &hdc) == DD_OK)
    {
        SetPixel(hdc, 0, 0, rgbT);
        IDirectDrawSurface_ReleaseDC(pdds, hdc);
    }

    return dw;
}

/*
 * ReadPalFile
 *
 * Create a DirectDrawPalette from a palette file
 *
 * if the palette files cant be found, make a default 332 palette
 */
LPDIRECTDRAWPALETTE ReadPalFile( char *fname )
{
    int                 i;
    int                 fh;
    HRESULT             ddrval;
    IDirectDrawPalette *ppal;

    struct  {
        DWORD           dwRiff;
        DWORD           dwFileSize;
        DWORD           dwPal;
        DWORD           dwData;
        DWORD           dwDataSize;
        WORD            palVersion;
        WORD            palNumEntries;
        PALETTEENTRY    ape[256];
    }   pal;

    pal.dwRiff = 0;

    if (fname)
    {
        fh = _lopen( fname, OF_READ);

        if (fh != -1)
        {
            _lread(fh, &pal, sizeof(pal));
            _lclose(fh);
        }
    }

    /*
     * if the file is not a palette file, or does not exist
     * default to a 332 palette
     */
    if (pal.dwRiff != 0x46464952 || // 'RIFF'
        pal.dwPal  != 0x204C4150 || // 'PAL '
        pal.dwData != 0x61746164 || // 'data'
        pal.palVersion != 0x0300 ||
        pal.palNumEntries > 256  ||
        pal.palNumEntries < 1)
    {
        Msg("Can't open palette file, using default 332.");

        for( i=0; i<256; i++ )
        {
            pal.ape[i].peRed   = (BYTE)(((i >> 5) & 0x07) * 255 / 7);
            pal.ape[i].peGreen = (BYTE)(((i >> 2) & 0x07) * 255 / 7);
            pal.ape[i].peBlue  = (BYTE)(((i >> 0) & 0x03) * 255 / 3);
            pal.ape[i].peFlags = (BYTE)0;
        }
    }

    ddrval = IDirectDraw_CreatePalette(
                            lpDD,
                            DDPCAPS_8BIT,
                            pal.ape,
                            &ppal,
                            NULL );
    return ppal;

} /* ReadPalFile */


/*
 * Splash
 *
 * Draw a splash screen during startup
 * NOTE the screen has been cleared in DDCreateFlippingSurface
 */
void Splash( void )
{
    HDC hdc;
    HRESULT err;

    DDClear();

    if ((err = IDirectDrawSurface_GetDC(lpFrontBuffer, &hdc)) == DD_OK)
    {
        char *szMsg = "FoxBear is loading.......please wait.";
        SetTextColor(hdc, RGB(255,255,255));
        SetBkMode(hdc, TRANSPARENT);
        TextOut(hdc, rcWindow.left, rcWindow.top, szMsg, lstrlen(szMsg));
        IDirectDrawSurface_ReleaseDC(lpFrontBuffer, hdc);
    }
    else
    {
        Msg("GetDC failed! 0x%x",err);
    }

} /* Splash */

/*
 * MEMORY ALLOCATION ROUTINES...
 */

/*
 * MemAlloc
 */
LPVOID MemAlloc( UINT size )
{
    LPVOID      ptr;

    ptr = LocalAlloc( LPTR, size );
    return ptr;

} /* MemAlloc */

/*
 * CMemAlloc
 */
LPVOID CMemAlloc( UINT cnt, UINT isize )
{
    DWORD       size;
    LPVOID      ptr;

    size = cnt * isize;
    ptr = LocalAlloc( LPTR, size );
    return ptr;

} /* CMemAlloc */

/*
 * MemFree
 */
void MemFree( LPVOID ptr )
{
    if( ptr != NULL )
    {
        LocalFree( ptr );
    }

} /* MemFree */

HRESULT CALLBACK EnumDisplayModesCallback(LPDDSURFACEDESC pddsd, LPVOID Context)
{
    Msg("Mode: %dx%dx%d", pddsd->dwWidth, pddsd->dwHeight,pddsd->ddpfPixelFormat.dwRGBBitCount);
    if(
        (ModeList[NumModes-1].w == (int)pddsd->dwWidth)&&
        (ModeList[NumModes-1].h == (int)pddsd->dwHeight)&&
        (ModeList[NumModes-1].bpp == (int)pddsd->ddpfPixelFormat.dwRGBBitCount)
      )
        return DDENUMRET_OK;
    ModeList[NumModes].w   = pddsd->dwWidth;
    ModeList[NumModes].h   = pddsd->dwHeight;
    ModeList[NumModes].bpp = pddsd->ddpfPixelFormat.dwRGBBitCount;
    NumModes++;

    return DDENUMRET_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\dsutil.h ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsutil.cpp
 *  Content:    Routines for dealing with sounds from resources
 *
 *
 ***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// DSLoadSoundBuffer    Loads an IDirectSoundBuffer from a Win32 resource in
//                      the current application.
//
// Params:
//  pDS         -- Pointer to an IDirectSound that will be used to create
//                 the buffer.
//
//  lpName      -- Name of WAV resource to load the data from.  Can be a
//                 resource id specified using the MAKEINTRESOURCE macro.
//
// Returns an IDirectSoundBuffer containing the wave data or NULL on error.
//
// example:
//  in the application's resource script (.RC file)
//      Turtle WAV turtle.wav
//
//  some code in the application:
//      IDirectSoundBuffer *pDSB = DSLoadSoundBuffer(pDS, "Turtle");
//
//      if (pDSB)
//      {
//          IDirectSoundBuffer_Play(pDSB, 0, 0, DSBPLAY_TOEND);
//          /* ... */
//
///////////////////////////////////////////////////////////////////////////////
IDirectSoundBuffer *DSLoadSoundBuffer(IDirectSound *pDS, LPCTSTR lpName);

///////////////////////////////////////////////////////////////////////////////
//
// DSReloadSoundBuffer  Reloads an IDirectSoundBuffer from a Win32 resource in
//                      the current application. normally used to handle
//                      a DSERR_BUFFERLOST error.
// Params:
//  pDSB        -- Pointer to an IDirectSoundBuffer to be reloaded.
//
//  lpName      -- Name of WAV resource to load the data from.  Can be a
//                 resource id specified using the MAKEINTRESOURCE macro.
//
// Returns a BOOL indicating whether the buffer was successfully reloaded.
//
// example:
//  in the application's resource script (.RC file)
//      Turtle WAV turtle.wav
//
//  some code in the application:
//  TryAgain:
//      HRESULT hres = IDirectSoundBuffer_Play(pDSB, 0, 0, DSBPLAY_TOEND);
//
//      if (FAILED(hres))
//      {
//          if ((hres == DSERR_BUFFERLOST) &&
//              DSReloadSoundBuffer(pDSB, "Turtle"))
//          {
//              goto TryAgain;
//          }
//          /* deal with other errors... */
//      }
//
///////////////////////////////////////////////////////////////////////////////
BOOL DSReloadSoundBuffer(IDirectSoundBuffer *pDSB, LPCTSTR lpName);

///////////////////////////////////////////////////////////////////////////////
//
// DSGetWaveResource    Finds a WAV resource in a Win32 module.
//
// Params:
//  hModule     -- Win32 module handle of module containing WAV resource.
//                 Pass NULL to indicate current application.
//
//  lpName      -- Name of WAV resource to load the data from.  Can be a
//                 resource id specified using the MAKEINTRESOURCE macro.
//
//  ppWaveHeader-- Optional pointer to WAVEFORMATEX * to receive a pointer to
//                 the WAVEFORMATEX header in the specified WAV resource.
//                 Pass NULL if not required.
//
//  ppbWaveData -- Optional pointer to BYTE * to receive a pointer to the
//                 waveform data in the specified WAV resource.  Pass NULL if
//                 not required.
//
//  pdwWaveSize -- Optional pointer to DWORD to receive the size of the
//                 waveform data in the specified WAV resource.  Pass NULL if
//                 not required.
//
// Returns a BOOL indicating whether a valid WAV resource was found.
//
///////////////////////////////////////////////////////////////////////////////
BOOL DSGetWaveResource(HMODULE hModule, LPCTSTR lpName,
    WAVEFORMATEX **ppWaveHeader, BYTE **ppbWaveData, DWORD *pdwWaveSize);

///////////////////////////////////////////////////////////////////////////////
//
// HSNDOBJ             Handle to a SNDOBJ object.
//
//  SNDOBJs are implemented in dsutil as an example layer built on top
//      of DirectSound.
//
//      A SNDOBJ is generally used to manage individual
//      sounds which need to be played multiple times concurrently.  A
//      SNDOBJ represents a queue of IDirectSoundBuffer objects which
//      all refer to the same buffer memory.
//
//      A SNDOBJ also automatically reloads the sound resource when
//      DirectSound returns a DSERR_BUFFERLOST
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _HSNDOBJ_DEFINED
DECLARE_HANDLE32(HSNDOBJ);
#endif

///////////////////////////////////////////////////////////////////////////////
//
// SndObjCreate     Loads a SNDOBJ from a Win32 resource in
//                  the current application.
//
// Params:
//  pDS         -- Pointer to an IDirectSound that will be used to create
//                 the SNDOBJ.
//
//  lpName      -- Name of WAV resource to load the data from.  Can be a
//                 resource id specified using the MAKEINTRESOURCE macro.
//
//  iConcurrent -- Integer representing the number of concurrent playbacks of
//                 to plan for.  Attempts to play more than this number will
//                 succeed but will restart the least recently played buffer
//                 even if it is not finished playing yet.
//
// Returns an HSNDOBJ or NULL on error.
//
// NOTES:
//      SNDOBJs automatically restore and reload themselves as required.
//
///////////////////////////////////////////////////////////////////////////////
HSNDOBJ SndObjCreate(IDirectSound *pDS, LPCTSTR lpName, int iConcurrent);

///////////////////////////////////////////////////////////////////////////////
//
// SndObjDestroy  Frees a SNDOBJ and releases all of its buffers.
//
// Params:
//  hSO         -- Handle to a SNDOBJ to free.
//
///////////////////////////////////////////////////////////////////////////////
void SndObjDestroy(HSNDOBJ hSO);

///////////////////////////////////////////////////////////////////////////////
//
// SndObjPlay   Plays a buffer in a SNDOBJ.
//
// Params:
//  hSO         -- Handle to a SNDOBJ to play a buffer from.
//
//  dwPlayFlags -- Flags to pass to IDirectSoundBuffer::Play.  It is not
//                 legal to play an SndObj which has more than one buffer
//                 with the DSBPLAY_LOOPING flag.  Pass 0 to stop playback.
//
///////////////////////////////////////////////////////////////////////////////
BOOL SndObjPlay(HSNDOBJ hSO, DWORD dwPlayFlags);

///////////////////////////////////////////////////////////////////////////////
//
// SndObjStop   Stops one or more buffers in a SNDOBJ.
//
// Params:
//  hSO         -- Handle to a SNDOBJ to play a buffer from.
//
///////////////////////////////////////////////////////////////////////////////
BOOL SndObjStop(HSNDOBJ hSO);

///////////////////////////////////////////////////////////////////////////////
//
// SndObjGetFreeBuffer      returns one of the cloned buffers that is
//                          not currently playing
//
// Params:
//  hSO         -- Handle to a SNDOBJ
//
// NOTES:
//  This function is provided so that callers can set things like pan etc
//  before playing the buffer.
//
// EXAMPLE:
//  ...
//
///////////////////////////////////////////////////////////////////////////////
IDirectSoundBuffer *SndObjGetFreeBuffer(HSNDOBJ hSO);

///////////////////////////////////////////////////////////////////////////////
//
// helper routines
//
///////////////////////////////////////////////////////////////////////////////

BOOL DSFillSoundBuffer(IDirectSoundBuffer *pDSB, BYTE *pbWaveData, DWORD dwWaveSize);
BOOL DSParseWaveResource(void *pvRes, WAVEFORMATEX **ppWaveHeader, BYTE **ppbWaveData, DWORD *pdwWaveSize);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\fbsound.c ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fbsound.c
 *  Content:    Game sound effect routines
 *
 ***************************************************************************/
#include "foxbear.h"
    
/*
 * Array of pointers to our sound effects
 */
LPDIRECTSOUND           lpDS;
LPDIRECTSOUNDBUFFER     lpSoundEffects[NUM_SOUND_EFFECTS];

char szSoundEffects[NUM_SOUND_EFFECTS][MAX_PATH] =
{
    "STOP",
    "THROW",
    "JUMP",
    "STUNNED",
    "STRIKE02",
    "MISS02"
};

/*
 * DSEnable
 *
 * Figures out whether or not to use DirectSound, based on an entry
 * in WIN.INI.  Sets a module-level flag and goes about creating the
 * DirectSound object if necessary.  Returns TRUE if successful.
 */
BOOL DSEnable( HWND hwnd )
{
    HRESULT             dsrval;
    BOOL                bUseDSound;

    bUseDSound = GetProfileInt("FoxBear", "use_dsound", bWantSound);

    if (!bUseDSound)
    {
        lpDS = NULL;
        return TRUE;
    }

    if (lpDS != NULL)
    {
        Msg( "DSEnable, already enabled" );
        return TRUE;
    }

    dsrval = DirectSoundCreate(NULL, &lpDS, NULL);

    if (dsrval != DS_OK)
    {
        Msg("DirectSoundCreate FAILED");
        return FALSE;
    }


    dsrval = IDirectSound_SetCooperativeLevel(lpDS, hwnd, DSSCL_NORMAL);

    if (dsrval != DS_OK)
    {
        DSDisable();
        Msg("SetCooperativeLevel FAILED");
        return FALSE;
    }

    return TRUE;

} /* DSEnable */


/*
 * DSDisable
 *
 * Turn off DirectSound
 */
BOOL DSDisable( void )
{
    if (lpDS == NULL)
    {
        return TRUE;
    }

    IDirectSound_Release(lpDS);
    lpDS = NULL;

    return TRUE;

} /* DSDisable */

/*
 * InitSound
 *
 * Sets up the DirectSound object and loads all sounds into secondary
 * DirectSound buffers.  Returns FALSE on error, or TRUE if successful
 */
BOOL InitSound( HWND hwndOwner )
{
    int idx;
    DSBUFFERDESC dsBD;
    IDirectSoundBuffer *lpPrimary;

    DSEnable(hwndOwner);

    if (lpDS == NULL)
        return TRUE;

    /*
     * Load all sounds -- any that can't load for some reason will have NULL
     * pointers instead of valid SOUNDEFFECT data, and we will know not to
     * play them later on.
     */
    for( idx = 0; idx < NUM_SOUND_EFFECTS; idx++ )
    {
        if (SoundLoadEffect((EFFECT)idx))
        {
            DSBCAPS  caps;

            caps.dwSize = sizeof(caps);
            IDirectSoundBuffer_GetCaps(lpSoundEffects[idx], &caps);

            if (caps.dwFlags & DSBCAPS_LOCHARDWARE)
                Msg( "Sound effect %s in hardware", szSoundEffects[idx]);
            else
                Msg( "Sound effect %s in software", szSoundEffects[idx]);
        }
        else
        {
            Msg( "cant load sound effect %s", szSoundEffects[idx]);
        }
    }

    /*
     * get the primary buffer and start it playing
     *
     * by playing the primary buffer, DirectSound knows to keep the
     * mixer active, even though we are not making any noise.
     */

    ZeroMemory( &dsBD, sizeof(DSBUFFERDESC) );
    dsBD.dwSize = sizeof(dsBD);
    dsBD.dwFlags = DSBCAPS_PRIMARYBUFFER;

    if (SUCCEEDED(IDirectSound_CreateSoundBuffer(lpDS, &dsBD, &lpPrimary, NULL)))
    {
        if (!SUCCEEDED(IDirectSoundBuffer_Play(lpPrimary, 0, 0, DSBPLAY_LOOPING)))
        {
            Msg("Unable to play Primary sound buffer");
        }

        IDirectSoundBuffer_Release(lpPrimary);
    }
    else
    {
        Msg("Unable to create Primary sound buffer");
    }

    return TRUE;

} /* InitSound */

/*
 * DestroySound
 *
 * Undoes everything that was done in a InitSound call
 */
BOOL DestroySound( void )
{
    DWORD       idxKill;
    
    for( idxKill = 0; idxKill < NUM_SOUND_EFFECTS; idxKill++ )
    {
        SoundDestroyEffect( (EFFECT)idxKill );
    }

    DSDisable();
    return TRUE;

} /* DestroySound */

/*
 * SoundDestroyEffect
 *
 * Frees up resources associated with a sound effect
 */
BOOL SoundDestroyEffect( EFFECT sfx )
{
    if(lpSoundEffects[sfx])
    {
        IDirectSoundBuffer_Release(lpSoundEffects[sfx]);
        lpSoundEffects[sfx] = NULL;
    }
    return TRUE;

} /* SoundDestryEffect */

/*
 * SoundLoadEffect
 *
 * Initializes a sound effect by loading the WAV file from a resource
 */
BOOL SoundLoadEffect( EFFECT sfx )
{
    if (lpDS && lpSoundEffects[sfx] == NULL && *szSoundEffects[sfx])
    {
        //
        //  use DSLoadSoundBuffer (in ..\misc\dsutil.c) to load
        //  a sound from a resource.
        //
        lpSoundEffects[sfx] = DSLoadSoundBuffer(lpDS, szSoundEffects[sfx]);
    }

    return lpSoundEffects[sfx] != NULL;

} /* SoundLoadEffect */

/*
 * SoundPlayEffect
 *
 * Plays the sound effect specified.  
 * Returns TRUE if succeeded.
 */
BOOL SoundPlayEffect( EFFECT sfx )
{
    HRESULT     dsrval;
    IDirectSoundBuffer *pdsb = lpSoundEffects[sfx];
    
    if( !lpDS || !pdsb )
    {
        return FALSE;
    }
    
    /*
     * Rewind the play cursor to the start of the effect, and play
     */
    IDirectSoundBuffer_SetCurrentPosition(pdsb, 0);
    dsrval = IDirectSoundBuffer_Play(pdsb, 0, 0, 0);

    if (dsrval == DSERR_BUFFERLOST)
    {
        Msg("** %s needs restored", szSoundEffects[sfx]);

        dsrval = IDirectSoundBuffer_Restore(pdsb);

        if (dsrval == DS_OK)
        {
            if (DSReloadSoundBuffer(pdsb, szSoundEffects[sfx]))
            {
                Msg("** %s has been restored", szSoundEffects[sfx]);
                IDirectSoundBuffer_SetCurrentPosition(pdsb, 0);
                dsrval = IDirectSoundBuffer_Play(pdsb, 0, 0, 0);
            }
            else
            {
                dsrval = E_FAIL;
            }
        }
    }

    return (dsrval == DS_OK);

} /* SoundPlayEffect */

/*
 * SoundStopEffect
 *
 * Stops the sound effect specified.
 * Returns TRUE if succeeded.
 */
BOOL SoundStopEffect( EFFECT sfx )
{
    HRESULT     dsrval;

    if( !lpDS || !lpSoundEffects[sfx] )
    {
        return FALSE;
    }

    dsrval = IDirectSoundBuffer_Stop(lpSoundEffects[sfx]);

    return SUCCEEDED(dsrval);

} /* SoundStopEffect */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\fastfile.h ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fastfile.h
 *  Content:    Definitions for fastfile access.
 *
 * THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTBILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 ***************************************************************************/

typedef LPVOID  HFASTFILE;

extern BOOL __cdecl FastFileInit( LPSTR fname, int max_handles );
extern void __cdecl FastFileFini( void );
extern HFASTFILE __cdecl FastFileOpen( LPSTR name );
extern BOOL __cdecl FastFileClose( HFASTFILE pfe );
extern BOOL __cdecl FastFileRead( HFASTFILE pfh, LPVOID ptr, int size );
extern BOOL __cdecl FastFileSeek( HFASTFILE pfe, int off, int how );
extern long __cdecl FastFileTell( HFASTFILE pfe );
extern LPVOID __cdecl FastFileLock( HFASTFILE pfe, int off, int len );
extern BOOL __cdecl FastFileUnlock( HFASTFILE pfe, int off, int len );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\dsutil.c ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsutil.cpp
 *  Content:    Routines for dealing with sounds from resources
 *
 *
 ***************************************************************************/

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <dsound.h>

typedef struct
{
    BYTE *pbWaveData;               // pointer into wave resource (for restore)
    DWORD cbWaveSize;               // size of wave data (for restore)
    int iAlloc;                     // number of buffers.
    int iCurrent;                   // current buffer
    IDirectSoundBuffer* Buffers[1]; // list of buffers

} SNDOBJ, *HSNDOBJ;

#define _HSNDOBJ_DEFINED
#include "dsutil.h"

static const char c_szWAV[] = "WAV";

///////////////////////////////////////////////////////////////////////////////
//
// DSLoadSoundBuffer
//
///////////////////////////////////////////////////////////////////////////////

IDirectSoundBuffer *DSLoadSoundBuffer(IDirectSound *pDS, LPCTSTR lpName)
{
    IDirectSoundBuffer *pDSB = NULL;
    DSBUFFERDESC dsBD = {0};
    BYTE *pbWaveData;

    if (DSGetWaveResource(NULL, lpName, &dsBD.lpwfxFormat, &pbWaveData, &dsBD.dwBufferBytes))
    {
        dsBD.dwSize = sizeof(dsBD);
        dsBD.dwFlags = DSBCAPS_STATIC | DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY | DSBCAPS_GETCURRENTPOSITION2;

        if (SUCCEEDED(IDirectSound_CreateSoundBuffer(pDS, &dsBD, &pDSB, NULL)))
        {
            if (!DSFillSoundBuffer(pDSB, pbWaveData, dsBD.dwBufferBytes))
            {
                IDirectSoundBuffer_Release(pDSB);
                pDSB = NULL;
            }
        }
        else
        {
            pDSB = NULL;
        }
    }

    return pDSB;
}

///////////////////////////////////////////////////////////////////////////////
//
// DSReloadSoundBuffer
//
///////////////////////////////////////////////////////////////////////////////

BOOL DSReloadSoundBuffer(IDirectSoundBuffer *pDSB, LPCTSTR lpName)
{
    BOOL result=FALSE;
    BYTE *pbWaveData;
    DWORD cbWaveSize;

    if (DSGetWaveResource(NULL, lpName, NULL, &pbWaveData, &cbWaveSize))
    {
        if (SUCCEEDED(IDirectSoundBuffer_Restore(pDSB)) &&
            DSFillSoundBuffer(pDSB, pbWaveData, cbWaveSize))
        {
            result = TRUE;
        }
    }

    return result;
}

///////////////////////////////////////////////////////////////////////////////
//
// DSGetWaveResource
//
///////////////////////////////////////////////////////////////////////////////

BOOL DSGetWaveResource(HMODULE hModule, LPCTSTR lpName,
    WAVEFORMATEX **ppWaveHeader, BYTE **ppbWaveData, DWORD *pcbWaveSize)
{
    HRSRC hResInfo;
    HGLOBAL hResData;
    void *pvRes;

    if (((hResInfo = FindResource(hModule, lpName, c_szWAV)) != NULL) &&
        ((hResData = LoadResource(hModule, hResInfo)) != NULL) &&
        ((pvRes = LockResource(hResData)) != NULL) &&
        DSParseWaveResource(pvRes, ppWaveHeader, ppbWaveData, pcbWaveSize))
    {
        return TRUE;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// SndObj fns
///////////////////////////////////////////////////////////////////////////////

SNDOBJ *SndObjCreate(IDirectSound *pDS, LPCTSTR lpName, int iConcurrent)
{
    SNDOBJ *pSO = NULL;
    LPWAVEFORMATEX pWaveHeader;
    BYTE *pbData;
    UINT cbData;

    if (DSGetWaveResource(NULL, lpName, &pWaveHeader, &pbData, &cbData))
    {
        if (iConcurrent < 1)
            iConcurrent = 1;

        if ((pSO = (SNDOBJ *)LocalAlloc(LPTR, sizeof(SNDOBJ) +
            (iConcurrent-1) * sizeof(IDirectSoundBuffer *))) != NULL)
        {
            int i;

            pSO->iAlloc = iConcurrent;
            pSO->pbWaveData = pbData;
            pSO->cbWaveSize = cbData;
            pSO->Buffers[0] = DSLoadSoundBuffer(pDS, lpName);

            for (i=1; i<pSO->iAlloc; i++)
            {
                if (FAILED(IDirectSound_DuplicateSoundBuffer(pDS,
                    pSO->Buffers[0], &pSO->Buffers[i])))
                {
                    pSO->Buffers[i] = DSLoadSoundBuffer(pDS, lpName);
                    if (!pSO->Buffers[i]) {
                        SndObjDestroy(pSO);
                        pSO = NULL;
                        break;
                    }
                }
            }
        }
    }

    return pSO;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

void SndObjDestroy(SNDOBJ *pSO)
{
    if (pSO)
    {
        int i;

        for (i=0; i<pSO->iAlloc; i++)
        {
            if (pSO->Buffers[i])
            {
                IDirectSoundBuffer_Release(pSO->Buffers[i]);
                pSO->Buffers[i] = NULL;
            }
        }
        LocalFree((HANDLE)pSO);
    }
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

IDirectSoundBuffer *SndObjGetFreeBuffer(SNDOBJ *pSO)
{
    IDirectSoundBuffer *pDSB;

    if (pSO == NULL)
        return NULL;

    if (pDSB = pSO->Buffers[pSO->iCurrent])
    {
        HRESULT hres;
        DWORD dwStatus;

        hres = IDirectSoundBuffer_GetStatus(pDSB, &dwStatus);

        if (FAILED(hres))
            dwStatus = 0;

        if ((dwStatus & DSBSTATUS_PLAYING) == DSBSTATUS_PLAYING)
        {
            if (pSO->iAlloc > 1)
            {
                if (++pSO->iCurrent >= pSO->iAlloc)
                    pSO->iCurrent = 0;

                pDSB = pSO->Buffers[pSO->iCurrent];
                hres = IDirectSoundBuffer_GetStatus(pDSB, &dwStatus);

                if (SUCCEEDED(hres) && (dwStatus & DSBSTATUS_PLAYING) == DSBSTATUS_PLAYING)
                {
                    IDirectSoundBuffer_Stop(pDSB);
                    IDirectSoundBuffer_SetCurrentPosition(pDSB, 0);
                }
            }
            else
            {
                pDSB = NULL;
            }
        }

        if (pDSB && (dwStatus & DSBSTATUS_BUFFERLOST))
        {
            if (FAILED(IDirectSoundBuffer_Restore(pDSB)) ||
                !DSFillSoundBuffer(pDSB, pSO->pbWaveData, pSO->cbWaveSize))
            {
                pDSB = NULL;
            }
        }
    }

    return pDSB;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

BOOL SndObjPlay(SNDOBJ *pSO, DWORD dwPlayFlags)
{
    BOOL result = FALSE;

    if (pSO == NULL)
        return FALSE;

    if ((!(dwPlayFlags & DSBPLAY_LOOPING) || (pSO->iAlloc == 1)))
    {
        IDirectSoundBuffer *pDSB = SndObjGetFreeBuffer(pSO);
        if (pDSB != NULL) {
            result = SUCCEEDED(IDirectSoundBuffer_Play(pDSB, 0, 0, dwPlayFlags));
        }
    }

    return result;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

BOOL SndObjStop(SNDOBJ *pSO)
{
    int i;

    if (pSO == NULL)
        return FALSE;

    for (i=0; i<pSO->iAlloc; i++)
    {
        IDirectSoundBuffer_Stop(pSO->Buffers[i]);
        IDirectSoundBuffer_SetCurrentPosition(pSO->Buffers[i], 0);
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

BOOL DSFillSoundBuffer(IDirectSoundBuffer *pDSB, BYTE *pbWaveData, DWORD cbWaveSize)
{
    if (pDSB && pbWaveData && cbWaveSize)
    {
        LPVOID pMem1, pMem2;
        DWORD dwSize1, dwSize2;

        if (SUCCEEDED(IDirectSoundBuffer_Lock(pDSB, 0, cbWaveSize,
            &pMem1, &dwSize1, &pMem2, &dwSize2, 0)))
        {
            CopyMemory(pMem1, pbWaveData, dwSize1);

            if ( 0 != dwSize2 )
                CopyMemory(pMem2, pbWaveData+dwSize1, dwSize2);

            IDirectSoundBuffer_Unlock(pDSB, pMem1, dwSize1, pMem2, dwSize2);
            return TRUE;
        }
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

BOOL DSParseWaveResource(void *pvRes, WAVEFORMATEX **ppWaveHeader, BYTE **ppbWaveData,DWORD *pcbWaveSize)
{
    DWORD *pdw;
    DWORD *pdwEnd;
    DWORD dwRiff;
    DWORD dwType;
    DWORD dwLength;

    if (ppWaveHeader)
        *ppWaveHeader = NULL;

    if (ppbWaveData)
        *ppbWaveData = NULL;

    if (pcbWaveSize)
        *pcbWaveSize = 0;

    pdw = (DWORD *)pvRes;
    dwRiff = *pdw++;
    dwLength = *pdw++;
    dwType = *pdw++;

    if (dwRiff != mmioFOURCC('R', 'I', 'F', 'F'))
        goto exit;      // not even RIFF

    if (dwType != mmioFOURCC('W', 'A', 'V', 'E'))
        goto exit;      // not a WAV

    pdwEnd = (DWORD *)((BYTE *)pdw + dwLength-4);

    while (pdw < pdwEnd)
    {
        dwType = *pdw++;
        dwLength = *pdw++;

        switch (dwType)
        {
        case mmioFOURCC('f', 'm', 't', ' '):
            if (ppWaveHeader && !*ppWaveHeader)
            {
                if (dwLength < sizeof(WAVEFORMAT))
                    goto exit;      // not a WAV

                *ppWaveHeader = (WAVEFORMATEX *)pdw;

                if ((!ppbWaveData || *ppbWaveData) &&
                    (!pcbWaveSize || *pcbWaveSize))
                {
                    return TRUE;
                }
            }
            break;

        case mmioFOURCC('d', 'a', 't', 'a'):
            if ((ppbWaveData && !*ppbWaveData) ||
                (pcbWaveSize && !*pcbWaveSize))
            {
                if (ppbWaveData)
                    *ppbWaveData = (LPBYTE)pdw;

                if (pcbWaveSize)
                    *pcbWaveSize = dwLength;

                if (!ppWaveHeader || *ppWaveHeader)
                    return TRUE;
            }
            break;
        }

        pdw = (DWORD *)((BYTE *)pdw + ((dwLength+1)&~1));
    }

exit:
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\fbsound.h ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fbsound.h
 *  Content:    Includes for FoxBear DirectSound support
 *
 ***************************************************************************/
#ifndef __FBSOUND_INCLUDED__
#define __FBSOUND_INCLUDED__

/*
 * types of sound effects
 */
typedef enum enum_EFFECT
{
    SOUND_STOP = 0,
    SOUND_THROW,
    SOUND_JUMP,
    SOUND_STUNNED,
    SOUND_BEARSTRIKE,
    SOUND_BEARMISS,
} EFFECT;

#define NUM_SOUND_EFFECTS       6

/*
 * fn prototypes
 */
BOOL InitSound( HWND );
BOOL DestroySound( void );
BOOL DSDisable( void );
BOOL DSEnable( HWND );
BOOL SoundLoadEffect( EFFECT );
BOOL SoundPlayEffect( EFFECT );
BOOL SoundStopEffect( EFFECT );
BOOL SoundDestroyEffect( EFFECT );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\foxbear.c ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved.
 *
 *  File:       winfox.c
 *  Content:    Windows fox sample game
 *
 ***************************************************************************/
#include "foxbear.h"
#include "rcids.h"      // for FOX_ICON

LPDIRECTDRAWSURFACE     lpFrontBuffer;
LPDIRECTDRAWSURFACE     lpBackBuffer;
LPDIRECTDRAWCLIPPER     lpClipper;
LPDIRECTDRAWSURFACE     lpStretchBuffer;
LPDIRECTDRAWSURFACE     lpFrameRate;
LPDIRECTDRAWSURFACE     lpInfo;
LPDIRECTDRAWPALETTE     lpPalette;
LPDIRECTDRAW            lpDD;
SHORT                   lastInput = 0;
HWND                    hWndMain;
RECT                    rcWindow;
BOOL                    bShowFrameCount=TRUE;
BOOL                    bIsActive;
BOOL                    bPaused;

BOOL                    bStretch;
BOOL                    bFullscreen=TRUE;
BOOL                    bStress=FALSE;     // just keep running if true
BOOL                    bHelp=FALSE;       // help requested
RECT                    GameRect;          // game rect
SIZE                    GameSize;          // game is this size
SIZE                    GameMode;          // display mode size
UINT                    GameBPP;           // the bpp we want
DWORD                   dwColorKey;        // our color key
DWORD                   AveFrameRate;
DWORD                   AveFrameRateCount;
BOOL                    bWantSound = TRUE;


#define OUR_APP_NAME  "Win Fox Application"

#define ODS OutputDebugString

BOOL InitGame(void);
void ExitGame(void);
void initNumSurface(void);


/*
 * PauseGame()
 */
void PauseGame()
{
    Msg("**** PAUSE");
    bPaused = TRUE;
    InvalidateRect(hWndMain, NULL, TRUE);
}

/*
 * UnPauseGame()
 */
void UnPauseGame()
{
    if (GetForegroundWindow() == hWndMain)
    {
        Msg("**** UNPAUSE");
        bPaused = FALSE;
    }
}

/*
 * RestoreGame()
 */
BOOL RestoreGame()
{
    if (lpFrontBuffer == NULL || IDirectDrawSurface_Restore(lpFrontBuffer) != DD_OK)
    {
        Msg("***** cant restore FrontBuffer");
        return FALSE;
    }

    if (!bFullscreen)
    {
        if (lpBackBuffer == NULL || IDirectDrawSurface_Restore(lpBackBuffer) != DD_OK)
        {
            Msg("***** cant restore BackBuffer");
            return FALSE;
        }
    }

    if (lpStretchBuffer && IDirectDrawSurface_Restore(lpStretchBuffer) != DD_OK)
    {
        Msg("***** cant restore StretchBuffer");
        return FALSE;
    }

    if (lpFrameRate == NULL || lpInfo == NULL ||
        IDirectDrawSurface_Restore(lpFrameRate) != DD_OK ||
        IDirectDrawSurface_Restore(lpInfo) != DD_OK)
    {
        Msg("***** cant restore frame rate stuff");
        return FALSE;
    }
    initNumSurface();

    if (!gfxRestoreAll())
    {
        Msg("***** cant restore art");
        return FALSE;
    }

    return TRUE;
}

/*
 * ProcessFox
 */
BOOL ProcessFox(SHORT sInput)
{
    if ((lpFrontBuffer && IDirectDrawSurface_IsLost(lpFrontBuffer) == DDERR_SURFACELOST) ||
        (lpBackBuffer && IDirectDrawSurface_IsLost(lpBackBuffer) == DDERR_SURFACELOST))
    {
        if (!RestoreGame())
        {
            PauseGame();
            return FALSE;
        }
    }


    ProcessInput(sInput);
    NewGameFrame();
    return TRUE;

} /* ProcessFox */

static HFONT    hFont;

DWORD   dwFrameCount;
DWORD   dwFrameTime;
DWORD   dwFrames;
DWORD   dwFramesLast;
SIZE    sizeFPS;
SIZE    sizeINFO;
int     FrameRateX;
char    szFPS[]   = "FPS %02d";
char    szINFO[]  = "%dx%dx%d%s     F6=mode F8=x2 ALT+ENTER=Window";
char    szINFOW[] = "%dx%dx%d%s     F6=mode F8=x2 ALT+ENTER=Fullscreen";

char    szFrameRate[128];
char    szInfo[128];

COLORREF InfoColor      = RGB(0,152,245);
COLORREF FrameRateColor = RGB(255,255,0);
COLORREF BackColor      = RGB(255,255,255);

/*
 * initNumSurface
 */
void initNumSurface( void )
{
    HDC        hdc;
    RECT        rc;
    int         len;

    dwFramesLast = 0;

    len = wsprintf(szFrameRate, szFPS, 0, 0);

    if( lpFrameRate && IDirectDrawSurface_GetDC(lpFrameRate, &hdc ) == DD_OK )
    {
        SelectObject(hdc, hFont);
        SetTextColor(hdc, FrameRateColor);
        SetBkColor(hdc, BackColor);
        SetBkMode(hdc, OPAQUE);
        SetRect(&rc, 0, 0, 10000, 10000);
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, szFrameRate, len, NULL);
        GetTextExtentPoint(hdc, szFrameRate, 4, &sizeFPS);
        FrameRateX = sizeFPS.cx;
        GetTextExtentPoint(hdc, szFrameRate, len, &sizeFPS);

        IDirectDrawSurface_ReleaseDC(lpFrameRate, hdc);
    }

    if (bFullscreen)
        len = wsprintf(szInfo, szINFO,
                       GameSize.cx, GameSize.cy, GameBPP,bStretch ? " x2" : "");
    else
        len = wsprintf(szInfo, szINFOW,
                       GameSize.cx, GameSize.cy, GameBPP,bStretch ? " x2" : "");

    if( lpInfo && IDirectDrawSurface_GetDC(lpInfo, &hdc ) == DD_OK )
    {
        SelectObject(hdc, hFont);
        SetTextColor(hdc, InfoColor);
        SetBkColor(hdc, BackColor);
        SetBkMode(hdc, OPAQUE);
        SetRect(&rc, 0, 0, 10000, 10000);
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, szInfo, len, NULL);
        GetTextExtentPoint(hdc, szInfo, len, &sizeINFO);

        IDirectDrawSurface_ReleaseDC(lpInfo, hdc);
    }

} /* initNumSurface */

/*
 * makeFontStuff
 */
static BOOL makeFontStuff( void )
{
    DDCOLORKEY          ddck;
    HDC                 hdc;

    if (hFont != NULL)
    {
        DeleteObject(hFont);
    }

    hFont = CreateFont(
        GameSize.cx <= 512 ? 12 : 24,
        0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
        ANSI_CHARSET,
        OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS,
        NONANTIALIASED_QUALITY, // DEFAULT_QUALITY,
        VARIABLE_PITCH,
        "Arial" );

    /*
     * make a sample string so we can measure it with the current font.
     */
    initNumSurface();

    hdc = GetDC(NULL);
    SelectObject(hdc, hFont);
    GetTextExtentPoint(hdc, szFrameRate, lstrlen(szFrameRate), &sizeFPS);
    GetTextExtentPoint(hdc, szInfo, lstrlen(szInfo), &sizeINFO);
    ReleaseDC(NULL, hdc);

    /*
     * Create a surface to copy our bits to.
     */
    lpFrameRate = DDCreateSurface(sizeFPS.cx, sizeFPS.cy, FALSE,TRUE);
    lpInfo = DDCreateSurface(sizeINFO.cx, sizeINFO.cy, FALSE,TRUE);

    if( lpFrameRate == NULL || lpInfo == NULL )
    {
        return FALSE;
    }

    /*
     * now set the color key, we use a totaly different color than
     * the rest of the app, just to be different so drivers dont always
     * get white or black as the color key...
     *
     * dont forget when running on a dest colorkey device, we need
     * to use the same color key as the rest of the app.
     */
    if( bTransDest )
        BackColor = RGB(255,255,255);
    else
        BackColor = RGB(128,64,255);

    ddck.dwColorSpaceLowValue  = DDColorMatch(lpInfo, BackColor);
    ddck.dwColorSpaceHighValue = ddck.dwColorSpaceLowValue;

    IDirectDrawSurface_SetColorKey( lpInfo, DDCKEY_SRCBLT, &ddck);
    IDirectDrawSurface_SetColorKey( lpFrameRate, DDCKEY_SRCBLT, &ddck);

    /*
     * now draw the text for real
     */
    initNumSurface();

    return TRUE;
}

/*
 * DisplayFrameRate
 */
void DisplayFrameRate( void )
{
    DWORD               time2;
    char                buff[256];
    HDC                 hdc;
    HRESULT             ddrval;
    RECT                rc;
    DWORD               dw;

    if( !bShowFrameCount )
    {
        return;
    }

    dwFrameCount++;
    time2 = timeGetTime() - dwFrameTime;
    if( time2 > 1000 )
    {
        dwFrames = (dwFrameCount*1000)/time2;
        dwFrameTime = timeGetTime();
        dwFrameCount = 0;

        AveFrameRate += dwFrames;
        AveFrameRateCount++;
    }

    if( dwFrames == 0 )
    {
        return;
    }

    if( dwFrames != dwFramesLast )
    {
        dwFramesLast = dwFrames;

        if( IDirectDrawSurface_GetDC(lpFrameRate, &hdc ) == DD_OK )
        {
            buff[0] = (char)((dwFrames / 10) + '0');
            buff[1] = (char)((dwFrames % 10) + '0');

            SelectObject(hdc, hFont);
            SetTextColor(hdc, FrameRateColor);
            SetBkColor(hdc, BackColor);
            TextOut(hdc, FrameRateX, 0, buff, 2);

            IDirectDrawSurface_ReleaseDC(lpFrameRate, hdc);
        }
    }

    /*
     * put the text on the back buffer.
     */
    if (bTransDest)
        dw = DDBLTFAST_DESTCOLORKEY | DDBLTFAST_WAIT;
    else
        dw = DDBLTFAST_SRCCOLORKEY | DDBLTFAST_WAIT;

    SetRect(&rc, 0, 0, sizeFPS.cx, sizeFPS.cy);
    ddrval = IDirectDrawSurface_BltFast(lpBackBuffer,
           GameRect.left + (GameSize.cx - sizeFPS.cx)/2, GameRect.top + 20,
           lpFrameRate, &rc, dw);

    SetRect(&rc, 0, 0, sizeINFO.cx, sizeINFO.cy);
    ddrval = IDirectDrawSurface_BltFast(lpBackBuffer,
           GameRect.left + 10, GameRect.bottom - sizeINFO.cy - 10,
           lpInfo, &rc, dw);

} /* DisplayFrameRate */

/*
 * MainWndProc
 *
 * Callback for all Windows messages
 */
long FAR PASCAL MainWndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    PAINTSTRUCT ps;
    HDC         hdc;
    int         i;

    switch( message )
    {
    case WM_SIZE:
    case WM_MOVE:
        if (IsIconic(hWnd))
        {
            Msg("FoxBear is minimized, pausing");
            PauseGame();
        }

        if (bFullscreen)
        {
            SetRect(&rcWindow, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
        }
        else
        {
            GetClientRect(hWnd, &rcWindow);
            ClientToScreen(hWnd, (LPPOINT)&rcWindow);
            ClientToScreen(hWnd, (LPPOINT)&rcWindow+1);
        }
        Msg("WINDOW RECT: [%d,%d,%d,%d]", rcWindow.left, rcWindow.top, rcWindow.right, rcWindow.bottom);
        break;

    case WM_ACTIVATEAPP:
        bIsActive = (BOOL)wParam && GetForegroundWindow() == hWnd;

        if (bIsActive)
            Msg("FoxBear is active");
        else
            Msg("FoxBear is not active");

        //
        // while we were not-active something bad happened that caused us
        // to pause, like a surface restore failing or we got a palette
        // changed, now that we are active try to fix things
        //
        if (bPaused && bIsActive)
        {
            if (RestoreGame())
            {
                UnPauseGame();
            }
            else
            {
               if (GetForegroundWindow() == hWnd)
               {
                    //
                    //  we are unable to restore, this can happen when
                    //  the screen resolution or bitdepth has changed
                    //  we just reload all the art again and re-create
                    //  the front and back buffers.  this is a little
                    //  overkill we could handle a screen res change by
                    //  just recreating the front and back buffers we dont
                    //  need to redo the art, but this is way easier.
                    //
                    if (InitGame())
                    {
                        UnPauseGame();
                    }
                }
            }
        }
        break;

    case WM_QUERYNEWPALETTE:
        //
        //  we are getting the palette focus, select our palette
        //
        if (!bFullscreen && lpPalette && lpFrontBuffer)
        {
            HRESULT ddrval;

            ddrval = IDirectDrawSurface_SetPalette(lpFrontBuffer,lpPalette);
            if( ddrval == DDERR_SURFACELOST )
            {
                IDirectDrawSurface_Restore( lpFrontBuffer );

                ddrval= IDirectDrawSurface_SetPalette(lpFrontBuffer,lpPalette);
                if( ddrval == DDERR_SURFACELOST )
                {
                   Msg("  Failed to restore palette after second try");
                }
            }

            //
            // Restore normal title if palette is ours
            //

            if( ddrval == DD_OK )
            {
                SetWindowText( hWnd, OUR_APP_NAME );
            }
        }
        break;

    case WM_PALETTECHANGED:
        //
        //  if another app changed the palette we dont have full control
        //  of the palette. NOTE this only applies for FoxBear in a window
        //  when we are fullscreen we get all the palette all of the time.
        //
        if ((HWND)wParam != hWnd)
        {
            if( !bFullscreen )
            {
                if( !bStress )
                {
                    Msg("***** PALETTE CHANGED, PAUSING GAME");
                    PauseGame();
                }
                else
                {
                    Msg("Lost palette but continuing");
                    SetWindowText( hWnd, OUR_APP_NAME
                                 " - palette changed COLORS PROBABLY WRONG" );
                }
            }
        }
        break;

    case WM_DISPLAYCHANGE:
        break;

    case WM_CREATE:
        break;

    case WM_SETCURSOR:
        if (bFullscreen && bIsActive)
        {
            SetCursor(NULL);
            return TRUE;
        }
        break;

    case WM_SYSKEYUP:
        switch( wParam )
        {
        // handle ALT+ENTER (fullscreen)
        case VK_RETURN:
            bFullscreen = !bFullscreen;
            ExitGame();
            DDDisable(TRUE);        // destroy DirectDraw object
            InitGame();
            break;
        }
        break;

    case WM_KEYDOWN:
        switch( wParam )
        {
        case VK_NUMPAD5:
            lastInput=KEY_STOP;
            break;
        case VK_DOWN:
        case VK_NUMPAD2:
            lastInput=KEY_DOWN;
            break;
        case VK_LEFT:
        case VK_NUMPAD4:
            lastInput=KEY_LEFT;
            break;
        case VK_RIGHT:
        case VK_NUMPAD6:
            lastInput=KEY_RIGHT;
            break;
        case VK_UP:
        case VK_NUMPAD8:
            lastInput=KEY_UP;
            break;
        case VK_HOME:
        case VK_NUMPAD7:
            lastInput=KEY_JUMP;
            break;
        case VK_NUMPAD3:
            lastInput=KEY_THROW;
            break;
        case VK_F5:
            bShowFrameCount = !bShowFrameCount;
            if( bShowFrameCount )
            {
                dwFrameCount = 0;
                dwFrameTime = timeGetTime();
            }
            break;

        case VK_F6:
            //
            // find our current mode in the mode list
            //
                        if(bFullscreen)
                        {
                    for (i=0; i<NumModes; i++)
                    {
                        if (ModeList[i].bpp == (int)GameBPP &&
                            ModeList[i].w   == GameSize.cx &&
                            ModeList[i].h   == GameSize.cy)
                        {
                            break;
                        }
                    }
                    }else
                        {
                    for (i=0; i<NumModes; i++)
                    {
                        if (ModeList[i].w   == GameSize.cx &&
                            ModeList[i].h   == GameSize.cy)
                        {
                            break;
                        }
                    }
            }
            //
                // now step to the next mode, wrapping to the first one.
            //
                if (++i >= NumModes)
                i = 0;
Msg("ModeList %d %d",i,NumModes);
            GameMode.cx = ModeList[i].w;
            GameMode.cy = ModeList[i].h;
            GameBPP     = ModeList[i].bpp;
            bStretch    = FALSE;
            InitGame();
            break;

        case VK_F7:
            GameBPP = GameBPP == 8 ? 16 : 8;
            InitGame();
            break;

        case VK_F8:
            if (bFullscreen)
            {
                bStretch = !bStretch;
                InitGame();
            }
            else
            {
                RECT rc;

                GetClientRect(hWnd, &rc);

                bStretch = (rc.right  != GameSize.cx) ||
                           (rc.bottom != GameSize.cy);

                if (bStretch = !bStretch)
                    SetRect(&rc, 0, 0, GameMode.cx*2, GameMode.cy*2);
                else
                    SetRect(&rc, 0, 0, GameMode.cx, GameMode.cy);

                AdjustWindowRectEx(&rc,
                    GetWindowStyle(hWnd),
                    GetMenu(hWnd) != NULL,
                    GetWindowExStyle(hWnd));

                SetWindowPos(hWnd, NULL, 0, 0, rc.right-rc.left, rc.bottom-rc.top,
                    SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
            }
            break;

        case VK_F4:
            // treat F4 like ALT+ENTER (fullscreen)
            PostMessage(hWnd, WM_SYSKEYUP, VK_RETURN, 0);
            break;

        case VK_F3:
            bPaused = !bPaused;
            break;

        case VK_ESCAPE:
        case VK_F12:
            PostMessage(hWnd, WM_CLOSE, 0, 0);
            return 0;
        }
        break;

    case WM_PAINT:
        hdc = BeginPaint( hWnd, &ps );
        if (bPaused)
        {
            char *sz = "Game is paused, this is not a bug.";
            TextOut(ps.hdc, 0, 0, sz, lstrlen(sz));
        }
        EndPaint( hWnd, &ps );
        return 1;

    case WM_DESTROY:
        hWndMain = NULL;
        lastInput=0;
        DestroyGame();          // end of game
        DDDisable(TRUE);        // destroy DirectDraw object
        PostQuitMessage( 0 );
        break;
    }

    return DefWindowProc(hWnd, message, wParam, lParam);

} /* MainWndProc */

/*
 * initApplication
 *
 * Do that Windows initialization stuff...
 */
static BOOL initApplication( HINSTANCE hInstance, int nCmdShow )
{
    WNDCLASS wc;
    BOOL     rc;

    wc.style = CS_DBLCLKS;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon( hInstance, MAKEINTATOM(FOX_ICON));
    wc.hCursor = LoadCursor( NULL, IDC_ARROW );
    wc.hbrBackground = GetStockObject(BLACK_BRUSH);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = "WinFoxClass";
    rc = RegisterClass( &wc );
    if( !rc )
    {
        return FALSE;
    }


    hWndMain = CreateWindowEx(
        WS_EX_APPWINDOW,
        "WinFoxClass",
        OUR_APP_NAME,
        WS_VISIBLE |    // so we dont have to call ShowWindow
        WS_SYSMENU |    // so we get a icon in in our tray button
        WS_POPUP,
        0,
        0,
        GetSystemMetrics(SM_CXSCREEN),
        GetSystemMetrics(SM_CYSCREEN),
        NULL,
        NULL,
        hInstance,
        NULL );

    if( !hWndMain )
    {
        return FALSE;
    }

    UpdateWindow( hWndMain );
    SetFocus( hWndMain );

    return TRUE;

} /* initApplication */

/*
 * ExitGame
 *
 * Exiting current game, clean up
 */
void ExitGame( void )
{
    if( lpFrameRate )
    {
        IDirectDrawSurface_Release(lpFrameRate);
        lpFrameRate = NULL;
    }

    if( lpInfo )
    {
        IDirectDrawSurface_Release(lpInfo);
        lpInfo = NULL;
    }

    if( lpPalette )
    {
        IDirectDrawSurface_Release(lpPalette);
        lpPalette = NULL;
    }

    DestroyGame();

} /* ExitGame */

/*
 * InitGame
 *
 * Initializing current game
 */
BOOL InitGame( void )
{
    ExitGame();

    GameSize = GameMode;

    /*
     * initialize sound
     */
    InitSound( hWndMain );

    /*
     * init DirectDraw, set mode, ...
     * NOTE GameMode might be set to 640x480 if we cant get the asked for mode.
     */
    if( !PreInitializeGame() )
    {
        return FALSE;
    }

    if (bStretch && bFullscreen)
    {
        GameSize.cx     = GameMode.cx / 2;
        GameSize.cy     = GameMode.cy / 2;
        GameRect.left   = GameMode.cx - GameSize.cx;
        GameRect.top    = GameMode.cy - GameSize.cy;
        GameRect.right  = GameMode.cx;
        GameRect.bottom = GameMode.cy;

        if (lpStretchBuffer)
            Msg("Stretching using a system-memory stretch buffer");
        else
            Msg("Stretching using a VRAM->VRAM blt");
    }
    else
    {
        GameRect.left   = (GameMode.cx - GameSize.cx) / 2;
        GameRect.top    = (GameMode.cy - GameSize.cy) / 2;
        GameRect.right  = GameRect.left + GameSize.cx;
        GameRect.bottom = GameRect.top + GameSize.cy;
    }

    /*
     * setup our palette
     */
    if( GameBPP == 8 )
    {
        lpPalette = ReadPalFile( NULL );        // create a 332 palette

        if( lpPalette == NULL )
        {
            Msg( "Palette create failed" );
            return FALSE;
        }

        IDirectDrawSurface_SetPalette( lpFrontBuffer, lpPalette );
    }

    /*
     *  load all the art and things.
     */
    if( !InitializeGame() )
    {
        return FALSE;
    }

    /*
     * init our code to draw the FPS
     */
    makeFontStuff();

    /*
     * spew some stats
     */
    {
        DDCAPS  ddcaps;
        ddcaps.dwSize = sizeof( ddcaps );
        IDirectDraw_GetCaps( lpDD, &ddcaps, NULL );
        Msg( "Total=%ld, Free VRAM=%ld", ddcaps.dwVidMemTotal, ddcaps.dwVidMemFree );
        Msg( "Used = %ld", ddcaps.dwVidMemTotal- ddcaps.dwVidMemFree );
    }

    return TRUE;

} /* InitGame */

#define IS_NUM(c)     ((c) >= '0' && (c) <= '9')
#define IS_SPACE(c)   ((c) == ' ' || (c) == '\r' || (c) == '\n' || (c) == '\t' || (c) == 'x')

int getint(char**p, int def)
{
    int i=0;

    while (IS_SPACE(**p))
        (*p)++;

    if (!IS_NUM(**p))
        return def;

    while (IS_NUM(**p))
        i = i*10 + *(*p)++ - '0';

    while (IS_SPACE(**p))
        (*p)++;

    return i;
}

/*
 * WinMain
 */
int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,
                        int nCmdShow )
{
    MSG                 msg;

    while( lpCmdLine[0] == '-' )
    {
        int iMoviePos = 0;
        BOOL bDone = FALSE;
        lpCmdLine++;

        switch (*lpCmdLine++)
        {
        case 'c':
            bCamera = TRUE;
            break;

        case 'm':
            bMovie = TRUE;
            for (;!bDone;) {
                switch (*lpCmdLine) {
                case ' ':
                case 0:
                case '-':
                case '\n':
                case '\r':
                    bDone = TRUE;
                    break;
                default:
                    wszMovie[iMoviePos++] = (unsigned char)*lpCmdLine++;
                    break;
                }
            }
            wszMovie[iMoviePos] = 0;
            break;
        case 'e':
            bUseEmulation = TRUE;
            break;
        case 'w':
            bFullscreen = FALSE;
            break;
        case 'f':
            bFullscreen = TRUE;
            break;
        case '1':
            CmdLineBufferCount = 1;
            break;
        case '2':
        case 'd':
            CmdLineBufferCount = 2;
            break;
        case '3':
            CmdLineBufferCount = 3;
            break;
        case 's':
            bStretch = TRUE;
            break;
        case 'S':
            bWantSound = FALSE;
            break;
        case 'x':
            bStress= TRUE;
            break;
        case '?':
            bHelp= TRUE;
            bFullscreen= FALSE;  // give help in windowed mode
            break;
        }

        while( IS_SPACE(*lpCmdLine) )
        {
            lpCmdLine++;
        }
    }

    GameMode.cx = getint(&lpCmdLine, 640);
    GameMode.cy = getint(&lpCmdLine, 480);
    GameBPP = getint(&lpCmdLine, 8);

    /*
     * create window and other windows things
     */
    if( !initApplication(hInstance, nCmdShow) )
    {
        return FALSE;
    }

    /*
     * Give user help if asked for
     *
     * This is ugly for now because the whole screen is black
     * except for the popup box.  This could be fixed with some
     * work to get the window size right when it was created instead
     * of delaying that work. see ddraw.c
     *
     */

    if( bHelp )
    {
        MessageBox(hWndMain,
                   "F12 - Quit\n"
                   "NUMPAD 2  - crouch\n"
                   "NUMPAD 3  - apple\n"
                   "NUMPAD 4  - right\n"
                   "NUMPAD 5  - stop\n"
                   "NUMPAD 6  - left\n"
                   "NUMPAD 7  - jump\n"
                   "\n"
                   "Command line parameters\n"
                   "\n"
                    "-e   Use emulator\n"
                    "-S   No Sound\n"
                    "-1   No backbuffer\n"
                    "-2   One backbuffer\n"
                    "-4   Three backbuffers\n"
                    "-s   Use stretch\n"
                    "-x   Demo or stress mode\n"
                    "-mfoo.bar Movie name\n"
                    "-c   Overlay camera input\n",
                   OUR_APP_NAME, MB_OK );
    }

    /*
     * initialize for game play
     */
    if( !InitGame() )
    {
        return FALSE;
    }

    dwFrameTime = timeGetTime();

    while( 1 )
    {
        if (PeekMessage( &msg, NULL, 0, 0, PM_NOREMOVE))
        {
            if (!GetMessage( &msg, NULL, 0, 0))
            {
                break;
            }
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        else if (!bPaused && (bIsActive || !bFullscreen))
        {
            ProcessFox(lastInput);
            lastInput=0;
        }
        else
        {
            WaitMessage();
        }
    }

    if (AveFrameRateCount)
    {
        AveFrameRate = AveFrameRate / AveFrameRateCount;
        Msg("Average frame rate: %d", AveFrameRate);
    }

    return msg.wParam;

} /* WinMain */

#ifdef DEBUG

/*
 * Msg
 */
void __cdecl Msg( LPSTR fmt, ... )
{
    char    buff[256];
    va_list  va;

    va_start(va, fmt);

    //
    // format message with header
    //

    lstrcpy( buff, "FOXBEAR:" );
    wvsprintf( &buff[lstrlen(buff)], fmt, va );
    lstrcat( buff, "\r\n" );

    //
    // To the debugger unless we need to be quiet
    //

    if( !bStress )
    {
        OutputDebugString( buff );
    }

} /* Msg */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\foxbear.h ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved.
 *
 *  File:       foxbear.h
 *  Content:    main include file
 *
 ***************************************************************************/
#ifndef __FOXBEAR_INCLUDED__
#define __FOXBEAR_INCLUDED__

//#define WIN32_LEAN_AND_MEAN
#define COBJMACROS
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <ddraw.h>
#include <dsound.h>
#include "strmif.h"
#include "uuids.h"
#include "MMSTREAM.H"
#include "AMSTREAM.H"
#include "DDSTREAM.H"
#include "gfx.h"
#include "fbsound.h"
#include "gameproc.h"
#include "vidsrc.h"
#include "fastfile.h"
#include "dsutil.h"

int getint(char**p, int def);

#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) "):" str

/*
 * keyboard commands
 */
enum
{
    KEY_STOP = 1,
    KEY_DOWN,
    KEY_LEFT,
    KEY_RIGHT,
    KEY_UP,
    KEY_JUMP,
    KEY_THROW
};

/*
 * global data
 */
extern LPDIRECTDRAW             lpDD;
extern LPDIRECTDRAWSURFACE      lpFrontBuffer;
extern LPDIRECTDRAWSURFACE      lpBackBuffer;
extern LPDIRECTDRAWSURFACE      lpStretchBuffer;
extern LPDIRECTDRAWCLIPPER      lpClipper;
extern DWORD                    lastKey;
extern BOOL                     bModeX;         // we are in a modex mode
extern BOOL                     bColorFill;     // device supports color fill
extern BOOL                     bTransDest;     // we should use dest color key
extern BOOL                     bColorFill;     // device supports color fill
extern int                      nBufferCount;   // buffer count
extern int                      CmdLineBufferCount;   // buffer count
extern BOOL                     bStretch;       // stretch
extern BOOL                     bFullscreen;    // run in fullscreen mode
extern BOOL                     bStress;        // just keep running
extern BOOL                     bUseEmulation;  // dont use HW use SW
extern BOOL                     bMovie;         // Use a movie
extern BOOL                     bCamera;        // Use camera input
extern RECT                     GameRect;       // game is here
extern SIZE                     GameSize;       // game is this size
extern SIZE                     GameMode;       // display mode size
extern UINT                     GameBPP;        // the bpp we want
extern DWORD                    dwColorKey;     // the color key
extern HWND                     hWndMain;       // the foxbear window
extern RECT                     rcWindow;       // where the FoxBear window is.
extern BOOL                     bIsActive;      // we are the active app.
extern BOOL                     bPaused;        //
extern BOOL                                             bWantSound;     // Set the default action in DSEnable
extern WCHAR                    wszMovie[100];

/*
 * list of display modes
 */
struct {int w, h, bpp;} ModeList[100];
int NumModes;

/*
 * map a point that assumes 640x480 to the current game size.
 */
#define MapDX(x) (((x) * GameSize.cx) / C_SCREEN_W)
#define MapDY(y) (((y) * GameSize.cy) / C_SCREEN_H)
#define MapX(x)  (GameRect.left + MapDX(x))
#define MapY(y)  (GameRect.top  + MapDY(y))
#define MapRX(x) ((GameSize.cx == C_SCREEN_W) ? x : MapDX(x)+1)
#define MapRY(y) ((GameSize.cy == C_SCREEN_H) ? y : MapDY(y)+1)

void PauseGame(void);
void UnPauseGame(void);


/*
 * fn prototypes
 */
/* ddraw.c */
extern BOOL DDEnable( void );
extern BOOL DDDisable( BOOL );
extern LPDIRECTDRAWSURFACE DDCreateSurface( DWORD width, DWORD height, BOOL sysmem, BOOL trans );
extern BOOL DDCreateFlippingSurface( void );
extern BOOL DDClear( void );
extern DWORD DDColorMatch(IDirectDrawSurface *pdds, COLORREF rgb);
extern void Splash( void );

extern LPVOID CMemAlloc( UINT cnt, UINT isize );
extern LPVOID MemAlloc( UINT size );
extern void   MemFree( LPVOID ptr );

#ifdef DEBUG
extern void __cdecl Msg( LPSTR fmt, ... );
#else
#define Msg ; / ## /
#endif

LPDIRECTDRAWPALETTE ReadPalFile( char *fname );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\gameproc.h ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved.
 *
 *  File:       gameproc.h
 *  Content:    include file for game processing info
 *
 ***************************************************************************/
#ifndef __GAMEPROC_INCLUDED__
#define __GAMEPROC_INCLUDED__


typedef enum enum_POSITION {
    P_ABSOLUTE,
    P_RELATIVE,
    P_AUTOMATIC
} POSITION;

typedef enum enum_SWITCHING {
    HOR,
    VER,
    TIMESWITCH
} SWITCHING;

typedef enum enum_DIRECTION {
    SAME,
    RIGHT,
    LEFT
} DIRECTION;

typedef enum enum_ACTION {
    NONE,
    STILL,
    WALK,
    RUN,
    JUMP,
    THROW,
    CROUCH,
    STOP,
    STUNNED,
    JUMPTHROW,
    CROUCHWALK,
    BLURR,
    STRIKE,
    MISS,
    CHEW,
} ACTION;

typedef SHORT HPOSLIST;
typedef BOOL HSURFACELIST;

typedef struct struct_HPLANE {
    GFX_HBM *hBM;
    BOOL    *surface;
    LONG     x;
    LONG     y;
    USHORT   width;
    USHORT   height;
    LONG     xv;
    LONG     xslide;
    LONG     xincrem;
    USHORT   denom;
} HPLANE, FAR *LPHPLANE;

typedef struct struct_HSPRITE_BM {
    GFX_HBM   hBM;
    ACTION    action;
    DIRECTION direction;
    SHORT     x;
    SHORT     y;
    USHORT    width;
    USHORT    height;
} HSPRITE_BM;

typedef struct struct_HSPRITE {
    HSPRITE_BM *hSBM;
    USHORT      bitmapCount;
    ACTION      currentAction;
    DIRECTION   currentDirection;
    USHORT      currentBitmap;
    BOOL        active;
    LONG        x;
    LONG        y;
    USHORT      width;
    USHORT      height;
    LONG        xv;
    LONG        yv;
    LONG        xa;
    LONG        ya;
    SHORT       xmax;
    SHORT       ymax;
    LONG        absSwitch;
    LONG        relSwitch;
    SWITCHING   switchType;
    BOOL        switchForward;
    BOOL        switchDone;
} HSPRITE, FAR *LPHSPRITE, FAR * FAR *LPLPHSPRITE;


typedef struct struct_HBITMAPLIST 
{
    GFX_HBM *hBM;
} HBITMAPLIST, FAR *LPHBITMAPLIST;


#include "tile.h"
#include "plane.h"
#include "sprite.h"

#define C_UNIT        (LONG) 65536    

#define C_TILE_W                32
#define C_TILE_H                32
#define C_SCREEN_W             640
#define C_SCREEN_H             480

#define C_FORE_W                80
#define C_FORE_H                15
#define C_MID_W                 40
#define C_MID_H                 15
#define C_BACK_W                25
#define C_BACK_H                15
#define C_WORLD_W               20
#define C_WORLD_H               15 

#define C_BACK_DENOM            12
#define C_MID_DENOM              3
#define C_FORE_DENOM             1

#define C_TILETOTAL            123      // TILE BITMAP TOTAL
#define C_FBT                  112      // FOX BITMAP TOTAL
#define C_BBT                   26      // BEAR BITMAP TOTAL

#define C_FOXSTILL               1      // NUMBER OF BITMAPS
#define C_FOXWALK               12
#define C_FOXRUN                16
#define C_FOXJUMP                4
#define C_FOXTHROW               2
#define C_FOXCROUCH              1
#define C_FOXSTOP                1
#define C_FOXSTUNNED             1
#define C_FOXJUMPTHROW           2
#define C_FOXCROUCHWALK         12
#define C_FOXBLURR               4

#define C_BEARMISS               2
#define C_BEARWALK              12
#define C_BEARSTRIKE            12


#define C_FOX_XMOVE          (LONG)   C_UNIT / 4

#define C_BOUNDINCREM        (LONG)     5 * C_UNIT
#define C_BOUNDDIF           (LONG)   240 * C_UNIT

#define C_FOX_STARTX         (LONG)   150 * C_UNIT     
#define C_FOX_STARTY         (LONG)   318 * C_UNIT

#define C_FOX_WALKMOVE       (LONG)     6 * C_UNIT
#define C_FOX_RUNMOVE        (LONG)    18 * C_UNIT
#define C_FOX_JUMPMOVE       (LONG)     9 * C_UNIT

#define C_FOX_WALKSWITCH     (LONG)     6 * C_UNIT
#define C_FOX_JUMPSWITCH     (LONG)     9 * C_UNIT
#define C_FOX_THROWSWITCH    (LONG)    15 * C_UNIT
#define C_FOX_RUNSWITCH      (LONG)    18 * C_UNIT 
#define C_FOX_BLURRSWITCH    (LONG)    18 * C_UNIT 

#define C_FOX_WALKTORUN      (LONG)     4 * C_UNIT
#define C_FOX_RUNTOBLURR     (LONG)    14 * C_UNIT

#define C_BEAR_STARTX        (LONG)   600 * C_UNIT
#define C_BEAR_STARTY        (LONG)   329 * C_UNIT

#define C_BEAR_WALKMOVE      (LONG)     1 * C_UNIT

#define C_BEAR_WALKSWITCH    (LONG)     6 * C_UNIT
#define C_BEAR_STRIKESWITCH  (LONG)     8 * C_UNIT
#define C_BEAR_MISSSWITCH    (LONG)    10 * C_UNIT
 

extern void ErrorMessage( LPSTR );
extern BOOL InitBuffer( GFX_HBM* );
extern void DestroyBuffer( GFX_HBM );
extern HBITMAPLIST *LoadBitmaps( void );
extern void InitTiles( HBITMAPLIST**, HBITMAPLIST*, USHORT );
extern void InitPlane( HPLANE**, HPOSLIST**, CHAR*, USHORT, USHORT, USHORT );
extern void InitSurface( HSURFACELIST**, CHAR*, USHORT, USHORT );
extern void InitFox( HSPRITE**, HBITMAPLIST* );
extern void InitBear( HSPRITE**, HBITMAPLIST* );
extern void InitApple( HSPRITE**, HBITMAPLIST* );
extern BOOL PreInitializeGame( void );
extern BOOL InitializeGame( void );
extern BOOL GetInput( void );
extern BOOL ProcessInput ( SHORT input );
extern int NewGameFrame( void );
extern void DestroyGame( void );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\gameproc.c ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved.
 *
 *  File:       gameproc.c
 *  Content:    Game processing routines
 *
 ***************************************************************************/
#include "foxbear.h"

GFX_HBM         hBuffer;
HBITMAPLIST     *hBitmapList;
HBITMAPLIST     *hTileList;
HPOSLIST        *hForePosList;
HPOSLIST        *hMidPosList;
HPOSLIST        *hBackPosList;
HSURFACELIST    *hSurfaceList;
HPLANE          *hForeground;
HPLANE          *hMidground;
HPLANE          *hBackground;
HSPRITE         *hFox;
HSPRITE         *hBear;
HSPRITE         *hApple;
USHORT          chewCount;
LONG            chewDif;
IDirectDrawStreamSample  *g_pMovieSource = NULL;


/*
 * ErrorMessage
 */
void ErrorMessage( CHAR *pText )
{
    char ach[128];

    wsprintf( ach, "FOXBEAR FATAL ERROR: %s\r\n", pText );
    OutputDebugString(ach);
    gfxEnd( hBuffer );
    exit( 0 );

} /* ErrorMessage */

/*
 * InitBuffer
 */
BOOL InitBuffer( GFX_HBM *hBuffer )
{
    *hBuffer = gfxBegin();

    if( *hBuffer == NULL )
    {
        ErrorMessage( "gfxBegin failed" );
        return FALSE;
    }
    return TRUE;

} /* InitBuffer */

/*
 * DestroyBuffer
 */
void DestroyBuffer ( GFX_HBM hBuffer )
{
    if( gfxEnd( hBuffer ) == FALSE )
    {
        ErrorMessage( "gfxEnd in DestroyBuffer" );
    }

} /* DestroyBuffer */

/*
 * LoadBitmaps
 */
HBITMAPLIST *LoadBitmaps( void )
{
    HBITMAPLIST *hBitmapList;
    CHAR         fileName[32];
    USHORT       i;
    USHORT       n;

    if( !FastFileInit( "foxbear.art", 5 ) )
    {
        Msg( "Could not load art file err=%08lX" , GetLastError());
        return NULL;
    }
    hBitmapList = CMemAlloc( C_TILETOTAL + C_FBT + C_BBT, sizeof (HBITMAPLIST) );

    Msg( "Loading tiles" );
    for( i = 0; i < C_TILETOTAL; ++i )
    {
        wsprintf( fileName, "%03u.BMP", i + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n = C_TILETOTAL;

    Msg( "Loading FoxWalk" );
    for( i = n; i < n + C_FOXWALK; ++i )
    {
        wsprintf( fileName, "FW%02uR.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXWALK;

    Msg( "Loading FoxWalk2" );
    for( i = n; i < n + C_FOXWALK; ++i )
    {
        wsprintf( fileName, "FW%02uL.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXWALK;

    Msg( "Loading FoxRun" );
    for( i = n; i < n + C_FOXRUN; ++i )
    {
        wsprintf( fileName, "FR%02uR.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXRUN;

    Msg( "Loading FoxRun2" );
    for( i = n; i < n + C_FOXRUN; ++i )
    {
        wsprintf( fileName, "FR%02uL.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXRUN;

    Msg( "Loading FoxStill" );
    for( i = n; i < n + C_FOXSTILL; ++i )
    {
        wsprintf( fileName, "FS%1uR.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXSTILL;

    Msg( "Loading FoxStill2" );
    for( i = n; i < n + C_FOXSTILL; ++i )
    {
        wsprintf( fileName, "FS%1uL.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXSTILL;

    Msg( "Loading FoxStunned" );
    for( i = n; i < n + C_FOXSTUNNED; ++i )
    {
        wsprintf( fileName, "FK%1uR.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXSTUNNED;

    Msg( "Loading FoxStunned2" );
    for( i = n; i < n + C_FOXSTUNNED; ++i )
    {
        wsprintf( fileName, "FK%1uL.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXSTUNNED;

    Msg( "Loading FoxCrouch" );
    for( i = n; i < n + C_FOXCROUCH; ++i )
    {
        wsprintf( fileName, "FC%1uR.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXCROUCH;

    Msg( "Loading FoxCrouch2" );
    for( i = n; i < n + C_FOXCROUCH; ++i )
    {
        wsprintf( fileName, "FC%1uL.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXCROUCH;

    Msg( "Loading FoxStop" );
    for( i = n; i < n + C_FOXSTOP; ++i )
    {
        wsprintf( fileName, "FCD%1uR.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXSTOP;

    Msg( "Loading FoxStop2" );
    for( i = n; i < n + C_FOXSTOP; ++i )
    {
        wsprintf( fileName, "FCD%1uL.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXSTOP;

    Msg( "Loading FoxThrow" );
    for( i = n; i < n + C_FOXTHROW; ++i )
    {
        wsprintf( fileName, "FT%1uR.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXTHROW;

    Msg( "Loading FoxThrow2" );
    for( i = n; i < n + C_FOXTHROW; ++i )
    {
        wsprintf( fileName, "FT%1uL.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXTHROW;

    Msg( "Loading FoxJumpThrow" );
    for( i = n; i < n + C_FOXJUMPTHROW; ++i )
    {
        wsprintf( fileName, "FJT%1uR.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXJUMPTHROW;

    Msg( "Loading FoxJumpThrow2" );
    for( i = n; i < n + C_FOXJUMPTHROW; ++i )
    {
        wsprintf( fileName, "FJT%1uL.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXJUMPTHROW;

    Msg( "Loading FoxJump" );
    for( i = n; i < n + C_FOXJUMP; ++i )
    {
        wsprintf( fileName, "FJ%1uR.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXJUMP;

    Msg( "Loading FoxJump2" );
    for( i = n; i < n + C_FOXJUMP; ++i )
    {
        wsprintf( fileName, "FJ%1uL.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXJUMP;

    Msg( "Loading FoxCrouchWalk" );
    for( i = n; i < n + C_FOXCROUCHWALK; ++i )
    {
        wsprintf( fileName, "FCW%02uR.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXCROUCHWALK;

    Msg( "Loading FoxCrouchWalk2" );
    for( i = n; i < n + C_FOXCROUCHWALK; ++i )
    {
        wsprintf( fileName, "FCW%02uL.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXCROUCHWALK;

    Msg( "Loading FoxBlurr" );
    for( i = n; i < n + C_FOXBLURR; ++i )
    {
        wsprintf( fileName, "FB%02uR.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXBLURR;

    Msg( "Loading FoxBlurr2" );
    for( i = n; i < n + C_FOXBLURR; ++i )
    {
        wsprintf( fileName, "FB%02uL.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_FOXBLURR;

    Msg( "Loading BearMiss" );
    for( i = n; i < n + C_BEARMISS; ++i )
    {
        wsprintf( fileName, "BM%1uL.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_BEARMISS;

    Msg( "Loading BearStrike" );
    for( i = n; i < n + C_BEARSTRIKE; ++i )
    {
        wsprintf( fileName, "BS%02uL.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_BEARSTRIKE;

    Msg( "Loading BearWalk" );
    for( i = n; i < n + C_BEARWALK; ++i )
    {
        wsprintf( fileName, "BW%02uL.BMP", i - n + 1 );
        hBitmapList[i].hBM = gfxLoadBitmap( fileName );
    }
    n += C_BEARWALK;

    FastFileFini();

    return hBitmapList;

} /* LoadBitmaps */

/*
 * InitTiles
 */
void InitTiles(
                HBITMAPLIST **hTileList,
                HBITMAPLIST *hBitmapList,
                USHORT tileCount )
{
    *hTileList = CreateTiles( hBitmapList, tileCount );

} /* InitTiles */

/*
 * InitPlane
 */
void InitPlane(
                HPLANE **hPlane,
                HPOSLIST **hPosList,
                LPSTR szFileName,
                USHORT width,
                USHORT height,
                USHORT denom )
{
    *hPlane   = CreatePlane( width, height, denom );
    *hPosList = CreatePosList( szFileName, width, height );

} /* InitPlane */

/*
 * InitSurface
 */
void InitSurface(
        HSURFACELIST **pphSurfaceList,
        CHAR *szFileName,
        USHORT width,
        USHORT height )
{
    *pphSurfaceList = CreateSurfaceList( szFileName, width, height );

} /* InitSurface */

/*
 * InitFox
 */
void InitFox ( HSPRITE **pphFox, HBITMAPLIST *phBitmapList )
{
    GFX_HBM   hBM;
    GFX_HBM   hBM_src;
    ACTION    action;
    DIRECTION direction;
    USHORT    i;

    LONG      startX    = C_FOX_STARTX;
    LONG      startY    = C_FOX_STARTY;
    USHORT    boundW    = 108;
    USHORT    boundH    = 105;
    LONG      as        =   6;
    SHORT     x[C_FBT]  = {  7, 15, 18, 11,  6,  3,  7, 15, 17, 11,  6,  3,
                             7, 15, 18, 11,  6,  3,  7, 15, 17, 11,  6,  3,
                            10,  3,  5, 16,  9, 13, 31, 24,  9,  3,  5, 16, 10, 13, 33, 23,
                            10,  3,  5, 16,  9, 13, 31, 24,  9,  3,  5, 16, 10, 13, 33, 23,
                            11, 11, 31, 31,  7,  7, 27, 27,  8, 10,  8, 10,
                            26,  6, 26,  6, 17, 21, 21, 24, 17, 21, 21, 24,
                             1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  1,  1,
                             1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  1,  1,
                             2,  2, -1,  0,  2,  2, -1,  0 };
    SHORT     y[C_FBT]  = { 20, 24, 26, 25, 27, 19, 20, 25, 26, 25, 29, 21,
                            20, 24, 26, 25, 27, 19, 20, 25, 26, 25, 29, 21,
                            42, 42, 31, 19, 13, 11, 20, 33, 40, 43, 31, 19, 14, 12, 20, 33,
                            42, 42, 31, 19, 13, 11, 20, 33, 40, 43, 31, 19, 14, 12, 20, 33,
                            14, 14, 20, 20, 58, 58, 26, 26, 20, 24, 20, 24,
                             0,  9,  0,  9, 20, 11, 10,  9, 20, 11, 10,  9,
                            61, 61, 61, 61, 60, 60, 61, 61, 61, 61, 60, 60,
                            61, 61, 61, 61, 60, 60, 61, 61, 61, 61, 60, 60,
                            45, 45, 45, 45, 45, 45, 45, 45 };
    USHORT    w[C_FBT]  = { 75, 73, 73, 82, 92, 84, 74, 74, 73, 81, 91, 84,
                            75, 73, 73, 82, 92, 84, 74, 74, 73, 81, 91, 84,
                            88, 92, 88, 78, 80, 78, 70, 84, 88, 92, 88, 78, 79, 79, 68, 85,
                            88, 92, 88, 78, 80, 78, 70, 84, 88, 92, 88, 78, 79, 79, 68, 85,
                            65, 65, 61, 61, 88, 88, 72, 72, 57, 86, 57, 86,
                            54, 92, 54, 92, 59, 57, 57, 52, 59, 57, 57, 52,
                            98, 99, 99, 99,100,100, 98,101,100, 99,100, 98,
                            98, 99, 99, 99,100,100, 98,101,100, 99,100, 98,
                            94, 94, 97, 96, 94, 94, 97, 96 };
    USHORT    h[C_FBT]  = { 78, 74, 72, 73, 71, 79, 78, 73, 72, 73, 69, 77,
                            78, 74, 72, 73, 71, 79, 78, 73, 72, 73, 69, 77,
                            56, 56, 67, 79, 85, 87, 78, 65, 58, 55, 67, 79, 84, 86, 78, 65,
                            56, 56, 67, 79, 85, 87, 78, 65, 58, 55, 67, 79, 84, 86, 78, 65,
                            84, 84, 85, 85, 40, 40, 72, 72, 78, 74, 78, 74,
                            88, 82, 88, 82, 84, 87, 86, 85, 84, 87, 86, 85,
                            37, 37, 37, 37, 38, 38, 37, 37, 37, 37, 38, 38,
                            37, 37, 37, 37, 38, 38, 37, 37, 37, 37, 38, 38,
                            54, 53, 51, 54, 54, 53, 51, 54 };

    *pphFox = CreateSprite( C_FBT, startX, startY, boundW, boundH, C_FORE_W * C_TILE_W, C_FORE_H * C_TILE_H, (SHORT) as, TRUE);

    for( i = 0; i < C_FBT; ++i )
    {
        hBM_src = phBitmapList[i + C_TILETOTAL].hBM;

        if( i < 12 )
        {
            action = WALK;
            direction = RIGHT;
        }
        else if( (i >= 12) && (i < 24) )
        {
            action = WALK;
            direction = LEFT;
        }
        else if( (i >= 24) && (i < 40) )
        {
            action = RUN;
            direction = RIGHT;
        }
        else if( (i >= 40) && (i < 56) )
        {
            action = RUN;
            direction = LEFT;
        }
        else if( i == 56 )
        {
            action = STILL;
            direction = RIGHT;
        }
        else if( i == 57 )
        {
            action = STILL;
            direction = LEFT;
        }
        else if( i == 58 )
        {
            action = STUNNED;
            direction = RIGHT;
        }
        else if( i == 59 )
        {
            action = STUNNED;
            direction = LEFT;
        }
        else if( i == 60 )
        {
            action = CROUCH;
            direction = RIGHT;
        }
        else if( i == 61 )
        {
            action = CROUCH;
            direction = LEFT;
        }
        else if( i == 62 )
        {
            action = STOP;
            direction = RIGHT;
        }
        else if( i == 63 )
        {
            action = STOP;
            direction = LEFT;
        }
        else if( (i >= 64) && (i < 66) )
        {
            action = THROW;
            direction = RIGHT;
        }
        else if( (i >= 66) && (i < 68) )
        {
            action = THROW;
            direction = LEFT;
        }
        else if( (i >= 68) && (i < 70) )
        {
            action = JUMPTHROW;
            direction = RIGHT;
        }
        else if( (i >= 70) && (i < 72) )
        {
            action = JUMPTHROW;
            direction = LEFT;
        }
        else if( (i >= 72) && (i < 76) )
        {
            action = JUMP;
            direction = RIGHT;
        }
        else if( (i >= 76) && (i < 80) )
        {
            action = JUMP;
            direction = LEFT;
        }
        else if( (i >= 80) && (i < 92) )
        {
            action = CROUCHWALK;
            direction = RIGHT;
        }
        else if( (i >= 92) && (i < 104) )
        {
            action = CROUCHWALK;
            direction = LEFT;
        }
        else if( (i >= 104) && (i < 108) )
        {
            action = BLURR;
            direction = RIGHT;
        }
        else if( (i >= 108) && (i < 112) )
        {
            action = BLURR;
            direction = LEFT;
        }

        hBM = hBM_src;

        BitBltSprite(
            *pphFox,
            hBM,
            action,
            direction,
            x[i],
            y[i],
            w[i],
            h[i] );
    }
    SetSpriteAction( *pphFox, STILL, RIGHT );

} /* InitFox */

/*
 * InitBear
 */
void InitBear( HSPRITE **pphBear, HBITMAPLIST *phBitmapList )
{
    GFX_HBM   hBM_src;
    ACTION    action;
    DIRECTION direction;
    USHORT    i;

    LONG      startX    = C_BEAR_STARTX;
    LONG      startY    = C_BEAR_STARTY;
    USHORT    boundW    = 196;
    USHORT    boundH    =  88;
    LONG      as        =   6;
    USHORT    x[C_BBT]  = { 14, 10,
                             8, 12, 13, 14, 10, 10,  9,  9,  9,  9,  8, 9,
                            11,  6,  1,  0,  3, 13, 11,  7,  1,  1,  3, 14 };
    USHORT    y[C_BBT]  = {  7,  7,
                             3,  8,  9,  7,  7,  3,  3,  3,  3,  3,  3,  3,
                             1,  1,  2,  2,  3,  1,  0,  1,  1,  2,  3,  2 };
    USHORT    w[C_BBT]  = {127,129,
                           127,153,183,153,129,138,146,150,152,151,143,139,
                           131,136,140,141,136,125,131,135,140,140,136,126 };
    USHORT    h[C_BBT]  = { 80, 80,
                            84, 79, 78, 80, 80, 84, 84, 84, 84, 84, 84, 84,
                            86, 86, 86, 85, 84, 86, 87, 86, 87, 85, 84, 86 };

    *pphBear = CreateSprite( C_BBT, startX, startY, boundW, boundH, C_FORE_W * C_TILE_W, C_FORE_H * C_TILE_H, (SHORT) as, TRUE);

    for( i = 0; i < C_BBT; ++i )
    {
        hBM_src = phBitmapList[i + C_TILETOTAL + C_FBT].hBM;

        if( i < 2 )
        {
            action = MISS;
            direction = LEFT;
        }
        else if( (i >= 2) && (i < 8) )
        {
            action = STRIKE;
            direction = LEFT;
        }
        else if( (i >= 8) && (i < 14) )
        {
            action = CHEW;
            direction = LEFT;
        }
        else if( (i >= 14) && (i < 26) )
        {
            action = WALK;
            direction = LEFT;
        }

        BitBltSprite (
            *pphBear,
            hBM_src,
            action,
            direction,
            x[i],
            y[i],
            w[i],
            h[i] );
    }

    SetSpriteAction( *pphBear, WALK, LEFT );
    SetSpriteVelX( *pphBear, -C_BEAR_WALKMOVE, P_ABSOLUTE );
    SetSpriteSwitch( *pphBear, C_BEAR_WALKSWITCH, P_ABSOLUTE );

} /* InitBear */

/*
 * InitApple
 */
VOID InitApple ( HSPRITE **pphApple, HBITMAPLIST *phBitmapList )
{

    // CREATE THE DIRECTDRAW SOURCE HERE!!! AND REPLACE FINAL NULL WITH POITNER!
    *pphApple = CreateSprite( 1, 50 * C_UNIT, 390 * C_UNIT, 32, 32, C_FORE_W * C_TILE_W, C_FORE_H * C_TILE_H, 0, FALSE);

    BitBltSprite( *pphApple, phBitmapList[61].hBM, NONE, RIGHT, 0, 0, 32, 32 );

    SetSpriteAction( *pphApple, NONE, RIGHT );

} /* InitApple */


/*
 * PreInitializeGame
 */
BOOL PreInitializeGame( void )
{
    return InitBuffer( &hBuffer);

} /* PreInitializeGame */


/*
 * InitializeGame
 */
BOOL InitializeGame ( void )
{
    CoInitialize(NULL);
    Splash();

    hBitmapList = LoadBitmaps();
    if( hBitmapList == NULL )
    {
        return FALSE;
    }

    InitTiles( &hTileList, hBitmapList, C_TILETOTAL );

    InitPlane( &hForeground, &hForePosList, "FORELIST", C_FORE_W, C_FORE_H, C_FORE_DENOM );
    TilePlane( hForeground, hTileList, hForePosList );

    InitPlane( &hMidground, &hMidPosList, "MIDLIST", C_MID_W, C_MID_H, C_MID_DENOM );
    TilePlane( hMidground, hTileList, hMidPosList );

    InitPlane( &hBackground, &hBackPosList, "BACKLIST", C_BACK_W, C_BACK_H, C_BACK_DENOM );
    TilePlane( hBackground, hTileList, hBackPosList );

    InitSurface( &hSurfaceList, "SURFLIST", C_FORE_W, C_FORE_H );
    SurfacePlane( hForeground, hSurfaceList );

    InitFox( &hFox, hBitmapList );
    InitBear( &hBear, hBitmapList );
    InitApple( &hApple, hBitmapList );

    CreateVideoSource (&g_pMovieSource, L"\\msamovdk\\movies\\aninm.mpg");

    DDClear();      // clear all the backbuffers.

    return TRUE;

} /* InitializeGame */

extern void DisplayFrameRate( void );

/*
 * NewGameFrame
 */
int NewGameFrame( void )
{

    SetSpriteX( hFox, 0, P_AUTOMATIC );
    SetSpriteY( hFox, 0, P_AUTOMATIC );

    SetPlaneVelX( hBackground, GetSpriteVelX(hFox), P_ABSOLUTE );
    SetPlaneVelX( hMidground,  GetSpriteVelX(hFox), P_ABSOLUTE );
    SetPlaneVelX( hForeground, GetSpriteVelX(hFox), P_ABSOLUTE );

    SetPlaneX( hBackground, 0, P_AUTOMATIC );
    SetPlaneX( hMidground,  0, P_AUTOMATIC );
    SetPlaneX( hForeground, 0, P_AUTOMATIC );

    SetSpriteX( hBear,  0, P_AUTOMATIC );
    SetSpriteX( hApple, 0, P_AUTOMATIC );
    SetSpriteY( hApple, 0, P_AUTOMATIC );

    /*
     * once all sprites are processed, display them
     *
     * If we are using destination transparency instead of source
     * transparency, we need to paint the background with the color key
     * and then paint our sprites and planes in reverse order.
     *
     * Since destination transparency will allow you to only write pixels
     * on the destination if the transparent color is present, reversing
     * the order (so that the topmost bitmaps are drawn first instead of
     * list) causes everything to come out ok.
     */
    if( bTransDest )
    {
        gfxFillBack( dwColorKey );

        DisplayFrameRate();

        DisplaySprite( hBuffer, hApple, GetPlaneX(hForeground) );
        DisplaySprite( hBuffer, hBear,  GetPlaneX(hForeground) );
        DisplaySprite( hBuffer, hFox,   GetPlaneX(hForeground) );

        DisplayPlane( hBuffer, hForeground );
        DisplayPlane( hBuffer, hMidground );
        DisplayPlane( hBuffer, hBackground );
    }
    else
    {

        DisplayPlane( hBuffer, hBackground );
        DisplayPlane( hBuffer, hMidground );
        DisplayVideoSource(g_pMovieSource);
        DisplayPlane( hBuffer, hForeground );

        DisplaySprite( hBuffer, hFox,   GetPlaneX(hForeground) );
        DisplaySprite( hBuffer, hBear,  GetPlaneX(hForeground) );
        DisplaySprite( hBuffer, hApple, GetPlaneX(hForeground) );

        DisplayFrameRate();
    }

    gfxSwapBuffers();

    return 0;

} /* NewGameFrame */

/*
 * DestroyGame
 */
void DestroyGame()
{
    if (hBuffer)
    {
        DestroyTiles( hTileList );
        DestroyPlane( hForeground );
        DestroyPlane( hMidground );
        DestroyPlane( hBackground );
        DestroyBuffer( hBuffer );
        DestroySound();

        if (g_pMovieSource) {
            IDirectDrawStreamSample_Release(g_pMovieSource);
            g_pMovieSource = NULL;
        }

        hTileList   = NULL;
        hForeground = NULL;
        hMidground  = NULL;
        hBackground = NULL;
        hBuffer     = NULL;
    }

} /* DestroyGame */

/*
 * ProcessInput
 */
BOOL ProcessInput( SHORT input )
{
    static BOOL fBearPlaying = FALSE;
    LONG      foxSpeedX;
    LONG      foxSpeedY;
    LONG      foxX;
    LONG      foxY;
    LONG      bearX;
    LONG      bearY;
    LONG      appleX;
    LONG      appleY;
    ACTION    foxAction;
    DIRECTION foxDir;
    BOOL      cont = TRUE;

    foxSpeedX = GetSpriteVelX( hFox );
    foxAction = GetSpriteAction( hFox );
    foxDir    = GetSpriteDirection( hFox );

    if( (GetSpriteActive(hFox) == FALSE) && (input != 4209) )
    {
        input = 0;
    }
    switch( input )
    {
    case KEY_DOWN:
        if( foxAction == STOP )
        {
            break;
        }
        else if( foxAction == STILL )
        {
            SetSpriteAction( hFox, CROUCH, SAME );
        }
        else if( foxAction == WALK )
        {
            SetSpriteAction( hFox, CROUCHWALK, SAME );
        }
        break;

    case KEY_LEFT:
        if( foxAction == STOP )
        {
            break;
        }
        else if( foxSpeedX == 0 )
        {
            if( foxAction == STILL )
            {
                if( foxDir == RIGHT )
                {
                    ChangeSpriteDirection( hFox );
                    SetPlaneSlideX( hForeground, -C_BOUNDDIF, P_RELATIVE );
                    SetPlaneSlideX( hMidground, -C_BOUNDDIF, P_RELATIVE );
                    SetPlaneSlideX( hBackground, -C_BOUNDDIF, P_RELATIVE );
                    SetPlaneIncremX( hForeground, C_BOUNDINCREM, P_ABSOLUTE );
                    SetPlaneIncremX( hBackground, C_BOUNDINCREM, P_ABSOLUTE );
                    SetPlaneIncremX( hMidground, C_BOUNDINCREM, P_ABSOLUTE );
                }
                else
                {
                    SetSpriteAction( hFox, WALK, LEFT );
                    SetSpriteSwitch( hFox, C_FOX_WALKSWITCH, P_ABSOLUTE );
                    SetSpriteVelX( hFox, -C_FOX_XMOVE, P_RELATIVE );
                }
            }
            else if( foxAction == CROUCH )
            {
                if( foxDir == RIGHT )
                {
                    ChangeSpriteDirection( hFox );
                    SetPlaneSlideX( hForeground, -C_BOUNDDIF, P_RELATIVE );
                    SetPlaneSlideX( hMidground, -C_BOUNDDIF, P_RELATIVE );
                    SetPlaneSlideX( hBackground, -C_BOUNDDIF, P_RELATIVE );
                    SetPlaneIncremX( hForeground, C_BOUNDINCREM, P_ABSOLUTE );
                    SetPlaneIncremX( hBackground, C_BOUNDINCREM, P_ABSOLUTE );
                    SetPlaneIncremX( hMidground, C_BOUNDINCREM, P_ABSOLUTE );
                }
                else
                {
                    SetSpriteAction( hFox, CROUCHWALK, LEFT );
                    SetSpriteSwitch( hFox, C_FOX_WALKSWITCH, P_ABSOLUTE );
                    SetSpriteVelX( hFox, -C_FOX_XMOVE, P_RELATIVE );
                }
            }
            else
            {
                SetSpriteVelX( hFox, -C_FOX_XMOVE, P_RELATIVE );
            }
        } else {
            SetSpriteVelX( hFox, -C_FOX_XMOVE, P_RELATIVE );
        }
        break;

    case KEY_RIGHT:
        if( foxAction == STOP )
        {
            break;
        }
        else if( foxSpeedX == 0 )
        {
            if( foxAction == STILL )
            {
                if( foxDir == LEFT )
                {
                    ChangeSpriteDirection( hFox );
                    SetPlaneSlideX( hForeground, C_BOUNDDIF, P_RELATIVE );
                    SetPlaneSlideX( hMidground, C_BOUNDDIF, P_RELATIVE );
                    SetPlaneSlideX( hBackground, C_BOUNDDIF, P_RELATIVE );
                    SetPlaneIncremX( hForeground, C_BOUNDINCREM, P_ABSOLUTE );
                    SetPlaneIncremX( hBackground, C_BOUNDINCREM, P_ABSOLUTE );
                    SetPlaneIncremX( hMidground, C_BOUNDINCREM, P_ABSOLUTE );
                }
                else
                {
                    SetSpriteAction( hFox, WALK, RIGHT );
                    SetSpriteSwitch( hFox, C_FOX_WALKSWITCH, P_ABSOLUTE );
                    SetSpriteVelX( hFox, C_FOX_XMOVE, P_RELATIVE );
                }
            }
            else if( foxAction == CROUCH )
            {
                if( foxDir == LEFT )
                {
                    ChangeSpriteDirection( hFox );
                    SetPlaneSlideX( hForeground, C_BOUNDDIF, P_RELATIVE );
                    SetPlaneSlideX( hMidground, C_BOUNDDIF, P_RELATIVE );
                    SetPlaneSlideX( hBackground, C_BOUNDDIF, P_RELATIVE );
                    SetPlaneIncremX( hForeground, C_BOUNDINCREM, P_ABSOLUTE );
                    SetPlaneIncremX( hBackground, C_BOUNDINCREM, P_ABSOLUTE );
                    SetPlaneIncremX( hMidground, C_BOUNDINCREM, P_ABSOLUTE );
                }
                else
                {
                    SetSpriteAction( hFox, CROUCHWALK, RIGHT );
                    SetSpriteSwitch( hFox, C_FOX_WALKSWITCH, P_ABSOLUTE );
                    SetSpriteVelX( hFox, C_FOX_XMOVE, P_RELATIVE );
                }
            }
            else
            {
                SetSpriteVelX( hFox, C_FOX_XMOVE, P_RELATIVE );
            }
        }
        else
        {
            SetSpriteVelX( hFox, C_FOX_XMOVE, P_RELATIVE );
        }
        break;

    case KEY_STOP:
        if( foxAction == STOP )
        {
            break;
        }
        else if( (foxAction == RUN) || (foxAction == BLURR) )
        {
            SetSpriteAction( hFox, STOP, SAME );
            SetSpriteAccX( hFox, -foxSpeedX / 25, P_ABSOLUTE );
            SoundPlayEffect( SOUND_STOP );
        } else {
            SetSpriteVelX( hFox, 0, P_ABSOLUTE );
        }
        break;

    case KEY_UP:
        if( foxAction == STOP )
        {
            break;
        }
        else if( foxAction == CROUCH )
        {
            SetSpriteAction( hFox, STILL, SAME );
        }
        else if( foxAction == CROUCHWALK )
        {
            SetSpriteAction( hFox, WALK, SAME );
        }
        break;

    case KEY_JUMP:
        if( foxAction == STOP )
        {
            break;
        }
        else
        if( (foxAction == STILL) || (foxAction == WALK) ||
            (foxAction == RUN) || (foxAction == CROUCH) ||
            (foxAction == CROUCHWALK) )
        {
            SetSpriteAction( hFox, JUMP, SAME );
            SetSpriteSwitchType( hFox, TIMESWITCH );
            SetSpriteSwitch( hFox, C_FOX_JUMPSWITCH, P_ABSOLUTE );
            SetSpriteVelY( hFox, -C_FOX_JUMPMOVE, P_ABSOLUTE );
            SetSpriteAccY( hFox, C_UNIT / 2, P_ABSOLUTE );
            SoundPlayEffect( SOUND_JUMP );
        }
        break;

    case KEY_THROW:
        if( foxAction == STOP )
        {
            break;
        }
        else if( (foxAction == STILL) || (foxAction == WALK) ||
                 (foxAction == RUN) || (foxAction == CROUCH) ||
                 (foxAction == CROUCHWALK) )
        {
            SetSpriteAction( hFox, THROW, SAME );
            SetSpriteSwitch( hFox, C_FOX_THROWSWITCH, P_ABSOLUTE );
            SetSpriteVelX( hFox, 0, P_ABSOLUTE );
            SetSpriteSwitchType( hFox, TIMESWITCH );
        }
        else if( foxAction == JUMP )
        {
            SetSpriteAccY( hFox, 0, P_ABSOLUTE );
            SetSpriteSwitch( hFox, C_FOX_THROWSWITCH, P_ABSOLUTE );
            SetSpriteAction( hFox, JUMPTHROW, SAME );
            SetSpriteVelY( hFox, 0, P_ABSOLUTE );
            SetSpriteSwitchDone( hFox, FALSE );
            SetSpriteSwitchForward( hFox, TRUE );
        }
        break;

    default:
        break;
    }

    /*
     * Fox actions follow...
     */
    if( GetSpriteActive(hFox) == FALSE )
    {
        goto bearActions;
    }

    if( abs(GetSpriteVelX( hFox )) < C_FOX_XMOVE )
    {
        SetSpriteVelX( hFox, 0, P_ABSOLUTE );
    }

    foxAction = GetSpriteAction( hFox );

    if( GetSpriteVelY(hFox) == 0 )
    {
        if( GetSurface( hForeground, hFox ) == FALSE )
        {
            if( (foxAction == WALK) || (foxAction == RUN) ||
                (foxAction == CROUCHWALK) )
            {
                SetSpriteAccY( hFox, C_UNIT / 2, P_ABSOLUTE );
            }
            else if( foxAction == STOP )
            {
                SetSpriteAccY( hFox, C_UNIT / 2, P_ABSOLUTE );
                SetSpriteAccX( hFox, 0, P_ABSOLUTE );
            }
        }
    }
    else if( GetSpriteVelY(hFox) > 2 * C_UNIT )
    {
        if( (foxAction == WALK) || (foxAction == RUN) ||
            (foxAction == CROUCHWALK) )
        {
            SetSpriteSwitchForward( hFox, FALSE );
            SetSpriteAction( hFox, JUMP, SAME );
            SetSpriteSwitchType( hFox, TIMESWITCH );
            SetSpriteSwitch( hFox, C_FOX_JUMPSWITCH, P_ABSOLUTE );
        }
        if( foxAction == STOP )
        {
            SetSpriteAction( hFox, STUNNED, SAME );
            SetSpriteAccX( hFox, -GetSpriteVelX(hFox) / 25, P_ABSOLUTE );
            SoundPlayEffect( SOUND_STUNNED );
        }
    }

    foxSpeedX = GetSpriteVelX( hFox );
    foxSpeedY = GetSpriteVelY( hFox );
    foxAction = GetSpriteAction( hFox );
    foxDir    = GetSpriteDirection( hFox );

    switch( foxAction ) {
    case STUNNED:
        if( (GetSpriteVelY(hFox) >= 0) &&
            (!GetSurface( hForeground, hFox ) == FALSE) )
        {
            SetSpriteAccY( hFox, 0, P_ABSOLUTE );
            SetSpriteAction( hFox, STOP, SAME );
            SetSpriteVelY( hFox, 0, P_ABSOLUTE );
            SetSpriteAccX( hFox, -foxSpeedX / 25, P_ABSOLUTE );
            // SetSurface( hForeground, hFox );
            SoundPlayEffect( SOUND_STOP );
        }
        break;

    case CROUCHWALK:
        if( foxSpeedX == 0 )
        {
            SetSpriteAction( hFox, CROUCH, SAME );
        }
        else if( foxSpeedX > C_FOX_WALKMOVE )
        {
            SetSpriteVelX( hFox, C_FOX_WALKMOVE, P_ABSOLUTE );
        }
        else if( foxSpeedX < -C_FOX_WALKMOVE )
        {
            SetSpriteVelX( hFox, -C_FOX_WALKMOVE, P_ABSOLUTE );
        }
        break;

    case STOP:
        if( foxSpeedX == 0 )
        {
            SetSpriteAction( hFox, STILL, SAME );
            SetSpriteAccX( hFox, 0, P_ABSOLUTE );
        }
        break;

    case RUN:
        if( (foxSpeedX < C_FOX_WALKTORUN ) && (foxSpeedX > 0) )
        {
            SetSpriteAction( hFox, WALK, RIGHT );
            SetSpriteSwitch( hFox, C_FOX_WALKSWITCH, P_ABSOLUTE );
        }
        else if( foxSpeedX > C_FOX_RUNTOBLURR )
        {
            SetSpriteAction( hFox, BLURR, RIGHT );
            SetSpriteSwitch( hFox, C_FOX_BLURRSWITCH, P_ABSOLUTE );
        }
        else if( (foxSpeedX > -C_FOX_WALKTORUN ) && (foxSpeedX < 0) )
        {
            SetSpriteAction( hFox, WALK, LEFT );
            SetSpriteSwitch( hFox, C_FOX_WALKSWITCH, P_ABSOLUTE );
        }
        else if( foxSpeedX < -C_FOX_RUNTOBLURR )
        {
            SetSpriteAction( hFox, BLURR, LEFT );
            SetSpriteSwitch( hFox, C_FOX_BLURRSWITCH, P_ABSOLUTE );
        }
        break;

    case WALK:
        if( foxSpeedX == 0 )
        {
            SetSpriteAction( hFox, STILL, SAME );
        }
        else if( foxSpeedX > C_FOX_WALKTORUN )
        {
            SetSpriteAction( hFox, RUN, RIGHT );
            SetSpriteSwitch( hFox, C_FOX_RUNSWITCH, P_ABSOLUTE );
        }
        else if( foxSpeedX < -C_FOX_WALKTORUN )
        {
            SetSpriteAction( hFox, RUN, LEFT );
            SetSpriteSwitch( hFox, C_FOX_RUNSWITCH, P_ABSOLUTE );
        }
        break;

    case BLURR:
        if( (foxSpeedX < C_FOX_RUNTOBLURR ) && (foxSpeedX > C_FOX_WALKTORUN) )
        {
            SetSpriteAction( hFox, RUN, RIGHT );
            SetSpriteSwitch( hFox, C_FOX_RUNSWITCH, P_ABSOLUTE );
        }
        else if( (foxSpeedX > -C_FOX_RUNTOBLURR ) && (foxSpeedX < -C_FOX_WALKTORUN) )
        {
            SetSpriteAction( hFox, RUN, LEFT );
            SetSpriteSwitch( hFox, C_FOX_RUNSWITCH, P_ABSOLUTE );
        }
        break;

    case JUMPTHROW:
        if( !GetSpriteSwitchDone(hFox) == FALSE )
        {
            SetSpriteSwitchForward( hFox, FALSE );
            SetSpriteAction( hFox, JUMP, SAME );
            SetSpriteSwitch( hFox, C_FOX_JUMPSWITCH, P_ABSOLUTE );
            SetSpriteSwitchDone( hFox, FALSE );
            SetSpriteAccY( hFox, C_UNIT / 2, P_ABSOLUTE );
            SoundPlayEffect( SOUND_THROW );
        }
        else
        if( (GetSpriteBitmap(hFox) == 1) &&
            (GetSpriteDirection(hFox) == RIGHT) )
        {
            SetSpriteActive( hApple, TRUE );
            SetSpriteX( hApple, GetSpriteX(hFox) + 60 * C_UNIT, P_ABSOLUTE );
            SetSpriteY( hApple, GetSpriteY(hFox) + 30 * C_UNIT, P_ABSOLUTE );
            SetSpriteVelX( hApple, 8 * C_UNIT, P_ABSOLUTE );
            SetSpriteVelY( hApple, -4 * C_UNIT, P_ABSOLUTE );
            SetSpriteAccX( hApple, 0, P_ABSOLUTE );
            SetSpriteAccY( hApple, C_UNIT / 4, P_ABSOLUTE );
        }
        else if( (GetSpriteBitmap(hFox) == 1) &&
                 (GetSpriteDirection(hFox) == LEFT) )
        {
            SetSpriteActive( hApple, TRUE );
            SetSpriteX( hApple, GetSpriteX(hFox) + 15 * C_UNIT, P_ABSOLUTE );
            SetSpriteY( hApple, GetSpriteY(hFox) + 30 * C_UNIT, P_ABSOLUTE );
            SetSpriteVelX( hApple, -8 * C_UNIT, P_ABSOLUTE );
            SetSpriteVelY( hApple, -4 * C_UNIT, P_ABSOLUTE );
            SetSpriteAccX( hApple, 0, P_ABSOLUTE );
            SetSpriteAccY( hApple, C_UNIT / 4, P_ABSOLUTE );
        }
        break;

    case THROW:
        if( !GetSpriteSwitchDone(hFox) == FALSE )
        {
            SetSpriteAction( hFox, STILL, SAME );
            SetSpriteSwitchType( hFox, HOR );
            SetSpriteSwitch( hFox, 0, P_ABSOLUTE );
            SetSpriteSwitchDone( hFox, FALSE );
            SoundPlayEffect( SOUND_THROW );
        }
        else if( (GetSpriteBitmap(hFox) == 1) &&
                 (GetSpriteDirection(hFox) == RIGHT) )
        {
            SetSpriteActive( hApple, TRUE );
            SetSpriteX( hApple, GetSpriteX(hFox) + 60 * C_UNIT, P_ABSOLUTE );
            SetSpriteY( hApple, GetSpriteY(hFox) + 50 * C_UNIT, P_ABSOLUTE );
            SetSpriteVelX( hApple, 8 * C_UNIT, P_ABSOLUTE );
            SetSpriteVelY( hApple, -4 * C_UNIT, P_ABSOLUTE );
            SetSpriteAccX( hApple, 0, P_ABSOLUTE );
            SetSpriteAccY( hApple, C_UNIT / 4, P_ABSOLUTE );
        }
        else if( (GetSpriteBitmap(hFox) == 1) &&
                 (GetSpriteDirection(hFox) == LEFT) )
        {
            SetSpriteActive( hApple, TRUE );
            SetSpriteX( hApple, GetSpriteX(hFox) + 20 * C_UNIT, P_ABSOLUTE );
            SetSpriteY( hApple, GetSpriteY(hFox) + 50 * C_UNIT, P_ABSOLUTE );
            SetSpriteVelX( hApple, -8 * C_UNIT, P_ABSOLUTE );
            SetSpriteVelY( hApple, -4 * C_UNIT, P_ABSOLUTE );
            SetSpriteAccX( hApple, 0, P_ABSOLUTE );
            SetSpriteAccY( hApple, C_UNIT / 4, P_ABSOLUTE );
        }
        break;

    case JUMP:
        if( (foxSpeedY >= 0) && (!GetSpriteSwitchForward( hFox ) == FALSE) )
        {
            SetSpriteSwitchForward( hFox, FALSE );
        }
        else if( GetSpriteSwitchForward( hFox ) == FALSE )
        {
            if( (!GetSurface( hForeground, hFox ) == FALSE) ||
                (!GetSurface( hForeground, hFox ) == FALSE) )
            {
                if( foxSpeedX >= C_FOX_RUNMOVE )
                {
                    SetSpriteAction( hFox, RUN, SAME );
                    SetSpriteSwitch( hFox, C_FOX_RUNSWITCH, P_ABSOLUTE );
                }
                else if( foxSpeedX == 0 )
                {
                    SetSpriteAction( hFox, STILL, SAME );
                    SetSpriteSwitch( hFox, C_FOX_WALKSWITCH, P_ABSOLUTE );
                }
                else
                {
                    SetSpriteAction( hFox, WALK, SAME );
                    SetSpriteSwitch( hFox, C_FOX_WALKSWITCH, P_ABSOLUTE );
                }

                SetSpriteAccY( hFox, 0, P_ABSOLUTE );
                SetSpriteVelY( hFox, 0, P_ABSOLUTE );
                SetSpriteSwitchType( hFox, HOR );
                SetSpriteSwitchForward( hFox, TRUE );
//              SetSurface( hForeground, hFox );
                SetSpriteSwitchDone( hFox, FALSE );
            }
        }
        break;

    }

    /*
     * Bear Actions
     */
    bearActions:

    foxX   = GetSpriteX( hFox );
    foxY   = GetSpriteY( hFox );
    bearX  = GetSpriteX( hBear );
    bearY  = GetSpriteY( hBear );
    appleX = GetSpriteX( hApple );
    appleY = GetSpriteY( hApple );

    switch( GetSpriteAction( hBear ) ) {
    case STRIKE:
        if( GetSpriteBitmap( hBear ) == 2 )
        {
            if( (bearX > foxX - C_UNIT * 30) && (bearX < foxX + C_UNIT * 40) &&
                (bearY < foxY + C_UNIT * 60) )
            {
                SetSpriteActive( hFox, FALSE );
                if( !fBearPlaying )
                {
                    SoundPlayEffect( SOUND_BEARSTRIKE );
                    fBearPlaying = TRUE;
                }
            }
            else
            {
                SetSpriteAction( hBear, MISS, SAME );
                SetSpriteSwitch( hBear, C_BEAR_MISSSWITCH, P_ABSOLUTE );
                SetSpriteSwitchDone( hBear, FALSE );
            }
        }
        else if( !GetSpriteSwitchDone( hBear ) == FALSE )
        {
            SetSpriteAction( hBear, CHEW, SAME );
            SetSpriteSwitchDone( hBear, FALSE );
            chewCount = 0;
            fBearPlaying = FALSE;
        }
        break;

    case MISS:
        if( !fBearPlaying )
        {
            SoundPlayEffect( SOUND_BEARMISS );
            fBearPlaying = TRUE;
        }
        if( !GetSpriteSwitchDone( hBear ) == FALSE )
        {
            SetSpriteAction( hBear, WALK, SAME );
            SetSpriteVelX( hBear, -C_BEAR_WALKMOVE, P_ABSOLUTE );
            SetSpriteSwitch( hBear, C_BEAR_WALKSWITCH, P_ABSOLUTE );
            SetSpriteSwitchType( hBear, HOR );
            fBearPlaying = FALSE;
        }
        break;

    case WALK:
        if( (!GetSpriteActive(hApple) == FALSE) && (appleX > bearX) &&
            (appleX > bearX + 80 * C_UNIT) && (appleY > bearY + 30 * C_UNIT) )
        {
            SetSpriteAction( hBear, STRIKE, SAME );
            SetSpriteVelX( hBear, 0, P_ABSOLUTE );
            SetSpriteSwitchType( hBear, TIMESWITCH );
            SetSpriteSwitch( hBear, C_BEAR_STRIKESWITCH, P_ABSOLUTE );
            SetSpriteSwitchDone( hBear, FALSE );
        }
        else if( (bearX > foxX - C_UNIT * 30) &&
                 (bearX < foxX + C_UNIT * 30) &&
                 (bearY < foxY + C_UNIT * 60) )
        {
            SetSpriteAction( hBear, STRIKE, SAME );
            SetSpriteVelX( hBear, 0, P_ABSOLUTE );
            SetSpriteSwitchType( hBear, TIMESWITCH );
            SetSpriteSwitch( hBear, C_BEAR_STRIKESWITCH, P_ABSOLUTE );
            SetSpriteSwitchDone( hBear, FALSE );
        }
        break;

    case CHEW:
        ++chewCount;
        if( chewCount >= 200 )
        {
            SetSpriteAction( hBear, STRIKE, SAME );
            SetSpriteSwitch( hBear, C_BEAR_STRIKESWITCH, P_ABSOLUTE );
            SetSpriteVelX( hBear, 0, P_ABSOLUTE );
            SetSpriteSwitchDone( hBear, FALSE );

            if( GetSpriteDirection(hFox) == RIGHT )
            {
                SetPlaneSlideX( hForeground, -C_BOUNDDIF, P_RELATIVE );
                SetPlaneSlideX( hMidground,  -C_BOUNDDIF, P_RELATIVE );
                SetPlaneSlideX( hBackground, -C_BOUNDDIF, P_RELATIVE );
            }

            chewDif = GetSpriteX(hFox);

            SetSpriteActive( hFox, TRUE );
            SetSpriteAction( hFox, STUNNED, LEFT );
            SetSpriteX( hFox, GetSpriteX(hBear), P_ABSOLUTE );
            SetSpriteY( hFox, GetSpriteY(hBear), P_ABSOLUTE );
            SetSpriteAccX( hFox, 0, P_ABSOLUTE );
            SetSpriteAccY( hFox, C_UNIT / 2, P_ABSOLUTE );
            SetSpriteVelX( hFox, -8 * C_UNIT, P_ABSOLUTE );
            SetSpriteVelY( hFox, -10 * C_UNIT, P_ABSOLUTE );
            SetSpriteSwitch( hFox, 0, P_ABSOLUTE );
            SoundPlayEffect( SOUND_STUNNED );

            chewDif -= GetSpriteX(hFox);

            SetPlaneSlideX( hForeground, -chewDif, P_RELATIVE );
            SetPlaneSlideX( hMidground,  -chewDif, P_RELATIVE );
            SetPlaneSlideX( hBackground, -chewDif, P_RELATIVE );
            SetPlaneIncremX( hForeground, C_BOUNDINCREM, P_ABSOLUTE );
            SetPlaneIncremX( hMidground,  C_BOUNDINCREM, P_ABSOLUTE );
            SetPlaneIncremX( hBackground, C_BOUNDINCREM, P_ABSOLUTE );
        }
        break;
    }

    /*
     * Apple actions...
     */
    if( (GetSpriteVelY(hApple) != 0) && (GetSpriteY(hApple) >= 420 * C_UNIT) )
    {
        SetSpriteX( hApple, 0, P_ABSOLUTE );
        SetSpriteY( hApple, 0, P_ABSOLUTE );
        SetSpriteAccX( hApple, 0, P_ABSOLUTE );
        SetSpriteAccY( hApple, 0, P_ABSOLUTE );
        SetSpriteVelX( hApple, 0, P_ABSOLUTE );
        SetSpriteVelY( hApple, 0, P_ABSOLUTE );
        SetSpriteActive( hApple, FALSE );
    }

    return cont;

} /* ProcessInput */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\gfx.h ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved.
 *
 *  File:       gfx.h
 *  Content:    graphics routines include file
 *
 ***************************************************************************/
#ifndef __GFX_INCLUDED__
#define __GFX_INCLUDED__

#define GFX_FALSE ((GFX_HBM)0)
#define GFX_TRUE  ((GFX_HBM)1)

typedef struct _GFX_BITMAP
{
    struct _GFX_BITMAP      *link;      // linked in a chain for restore.
    DWORD                   dwColor;    // solid fill color
    BOOL                    bTrans;     // transparent?
    LPDIRECTDRAWSURFACE     lpSurface;  // the DirectDrawSurface.
    LPBITMAPINFOHEADER      lpbi;       // the DIB to restore from.

} GFX_BITMAP;

typedef VOID *GFX_HBM;


//
// Prototypes
//

GFX_HBM gfxLoadBitmap(LPSTR);
GFX_HBM gfxCreateVramBitmap(BITMAPINFOHEADER UNALIGNED * ,BOOL);
GFX_HBM gfxCreateSolidColorBitmap(COLORREF rgb);
BOOL    gfxDestroyBitmap(GFX_HBM);
BOOL    gfxSwapBuffers(void);
GFX_HBM gfxBegin(VOID);
BOOL    gfxEnd(GFX_HBM);
void    gfxFillBack( DWORD dwColor );
///BOOL    gfxUpdate(GFX_HBM bm, IDirectDrawStreamSample *pSource);
BOOL    gfxBlt(RECT *dst, GFX_HBM bm, POINT *src);
BOOL    gfxRestore(GFX_HBM bm);
BOOL    gfxRestoreAll(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\gfx.c ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved.
 *
 *  File:       gfx.c
 *  Content:    graphics API
 *
 ***************************************************************************/
#include "foxbear.h"

GFX_BITMAP  *lpVRAM;

static BOOL fForceRestore = FALSE;

/*****
BOOL gfxUpdate(GFX_HBM bm, IVideoSource *pSource)
{
    GFX_BITMAP* pbm = (GFX_BITMAP*)bm;
    IDirectDrawSurface *pSurface = pbm->lpSurface;

    if (!pSurface) {
        return FALSE;
    }
    if (SUCCEEDED(pSource->lpVtbl->SetSurface(pSource, pSurface))) {
        pSource->lpVtbl->Update(pSource, 0, NULL);
    }
    return TRUE;
}

  ***/

/*
 * gfxBlt
 */
BOOL gfxBlt(RECT *dst, GFX_HBM bm, POINT *src)
{
    GFX_BITMAP* pbm = (GFX_BITMAP*)bm;
    HRESULT     ddrval;
    DWORD       bltflags;
    RECT        rc;
    int         x,y,dx,dy;

    if( GameSize.cy == C_SCREEN_H )
    {
        x         = dst->left;
        y         = dst->top;
        dx        = dst->right  - dst->left;
        dy        = dst->bottom - dst->top;
        rc.left   = src->x;
        rc.top    = src->y;
        rc.right  = rc.left + dx;
        rc.bottom = rc.top  + dy;
    }
    else
    {
        x         = MapX(dst->left);
        y         = MapY(dst->top);
        dx        = MapX(dst->right) - x;
        dy        = MapY(dst->bottom) - y;
        rc.left   = MapDX(src->x);
        rc.top    = MapDY(src->y);
        rc.right  = rc.left + dx;
        rc.bottom = rc.top  + dy;
    }

    if( dx == 0 || dy == 0 )
    {
        return TRUE;
    }

    if (pbm->lpSurface)
    {
        if( pbm->bTrans )
            bltflags = bTransDest ? DDBLTFAST_DESTCOLORKEY : DDBLTFAST_SRCCOLORKEY;
        else
            bltflags = bTransDest ? DDBLTFAST_DESTCOLORKEY : DDBLTFAST_NOCOLORKEY;

        ddrval = IDirectDrawSurface_BltFast(
                        lpBackBuffer, x, y,
                        pbm->lpSurface, &rc, bltflags | DDBLTFAST_WAIT);

        if (ddrval != DD_OK)
        {
            Msg("BltFast failed err=%d", ddrval);
        }
    }
    else
    {
        DDBLTFX     ddbltfx;

        rc.left   = x;
        rc.top    = y;
        rc.right  = rc.left + dx;
        rc.bottom = rc.top  + dy;

        ddbltfx.dwSize = sizeof( ddbltfx );
        ddbltfx.dwFillColor = pbm->dwColor;

        ddrval = IDirectDrawSurface_Blt(
                        lpBackBuffer,           // dest surface
                        &rc,                    // dest rect
                        NULL,                   // src surface
                        NULL,                   // src rect
                        DDBLT_COLORFILL | DDBLT_WAIT,
                        &ddbltfx);
    }

    return TRUE;

} /* gfxBlt */

/*
 * gfxCreateSolidColorBitmap
 */
GFX_HBM gfxCreateSolidColorBitmap(COLORREF rgb)
{
    GFX_BITMAP *pvram;

    pvram = MemAlloc( sizeof( *pvram ) );

    if( pvram == NULL )
    {
        return NULL;
    }

    pvram->dwColor = DDColorMatch(lpBackBuffer, rgb);
    pvram->lpSurface = NULL;
    pvram->lpbi = NULL;
    pvram->bTrans = FALSE;

    pvram->link = lpVRAM;
    lpVRAM = pvram;

    return (GFX_HBM) pvram;

} /* gfxCreateSolidColorBitmap */

/*
 * gfxCreateBitmap
 */
GFX_HBM gfxCreateVramBitmap(BITMAPINFOHEADER UNALIGNED *lpbi,BOOL bTrans)
{
    GFX_BITMAP *pvram;

    pvram = MemAlloc( sizeof( *pvram ) );

    if( pvram == NULL )
    {
        return NULL;
    }
    pvram->lpSurface = DDCreateSurface(MapRX(lpbi->biWidth),
                                       MapRY(lpbi->biHeight), FALSE, TRUE);
    pvram->lpbi = lpbi;
    pvram->dwColor = 0;
    pvram->bTrans = bTrans;

    if( pvram->lpSurface == NULL )
    {
        return NULL;
    }

    pvram->link = lpVRAM;
    lpVRAM = pvram;
    gfxRestore((GFX_HBM) pvram);

    return (GFX_HBM) pvram;

} /* gfxCreateVramBitmap */

/*
 * gfxDestroyBitmap
 */
BOOL gfxDestroyBitmap ( GFX_HBM hbm )
{
    GFX_BITMAP *p = (GFX_BITMAP *)hbm;

    if (hbm == NULL || hbm == GFX_TRUE)
    {
        return FALSE;
    }

    if (p->lpSurface)
    {
        IDirectDrawSurface_Release(p->lpSurface);
        p->lpSurface = NULL;
    }

    if (p->lpbi)
    {
        p->lpbi = NULL;
    }

    MemFree((VOID *)p);

    return TRUE;

} /* gfxDestroyBitmap */

/*
 * gfxStretchBackBuffer()
 */
BOOL gfxStretchBackbuffer()
{
    if (lpStretchBuffer)
    {
        IDirectDrawSurface_Blt(
                            lpStretchBuffer,        // dest surface
                            NULL,                   // dest rect (all of it)
                            lpBackBuffer,           // src surface
                            &GameRect,              // src rect
                            DDBLT_WAIT,
                            NULL);

        IDirectDrawSurface_Blt(
                            lpBackBuffer,           // dest surface
                            NULL,                   // dest rect (all of it)
                            lpStretchBuffer,        // src surface
                            NULL,                   // src rect
                            DDBLT_WAIT,
                            NULL);
    }
    else
    {
        IDirectDrawSurface_Blt(
                        lpBackBuffer,           // dest surface
                        NULL,                   // dest rect (all of it)
                        lpBackBuffer,           // src surface
                        &GameRect,              // src rect
                        DDBLT_WAIT,
                        NULL);
    }

    return TRUE;

} /* gfxStretchBackbuffer */

/*
 * gfxFlip
 */
BOOL gfxFlip( void )
{
    HRESULT     ddrval;

    ddrval = IDirectDrawSurface_Flip( lpFrontBuffer, NULL, DDFLIP_WAIT );
    if( ddrval != DD_OK )
    {
        Msg( "Flip FAILED, rc=%08lx", ddrval );
        return FALSE;
    }
    return TRUE;

} /* gfxFlip */

/*
 * gfxUpdateWindow
 */
BOOL gfxUpdateWindow()
{
    HRESULT     ddrval;

    ddrval = IDirectDrawSurface_Blt(
                    lpFrontBuffer,          // dest surface
                    &rcWindow,              // dest rect
                    lpBackBuffer,           // src surface
                    NULL,                   // src rect (all of it)
                    DDBLT_WAIT,
                    NULL);

    return ddrval == DD_OK;

} /* gfxUpdateWindow */

/*
 * gfxSwapBuffers
 *
 * this is called when the game loop has rendered a frame into
 * the backbuffer, its goal is to display something for the user to see.
 *
 * there are four cases...
 *
 * Fullscreen:
 *      we just call IDirectDrawSurface::Flip(lpFrontBuffer)
 *      being careful to handle return code right.
 *
 * Fullscreen (stretched):
 *      the game loop has rendered a frame 1/2 the display
 *      size, we do a Blt to stretch the frame to the backbuffer
 *      the we just call IDirectDrawSurface::Flip(lpFrontBuffer)
 *
 * Window mode (foreground palette):
 *      in this case we call IDirectDrawSurface::Blt to copy
 *      the back buffer to the window.
 *
 * Window mode (background palette):
 *      in this case we are in a window, but we dont own the
 *      palette. all our art was loaded to a specific palette
 *      IDirectDrawSurface::Blt does not do color translation
 *      we have a few options in this case...
 *
 *          reload or remap the art to the the current palette
 *          (we can do this easily with a GetDC, StetchDIBits)
 *          FoxBear has *alot* of art, so this would be too slow.
 *
 *          use GDI to draw the backbuffer, GDI will handle
 *          the color conversion so things will look correct.
 *
 *          pause the game (this is what we do so this function
 *          will never be called)
 *
 */
BOOL gfxSwapBuffers( void )
{
    if( bFullscreen )
    {
        if( bStretch )
        {
            gfxStretchBackbuffer();
        }

        if (nBufferCount > 1)
            return gfxFlip();
        else
            return TRUE;
    }
    else
    {
        return gfxUpdateWindow();
    }

} /* gfxSwapBuffers */

/*
 * gfxBegin
 */
GFX_HBM gfxBegin( void )
{
    if( !DDEnable() )
    {
        return NULL;
    }

    if( !DDCreateFlippingSurface() )
    {
        DDDisable(TRUE);
        return NULL;
    }
    Splash();

    return GFX_TRUE;

} /* gfxBegin */

/*
 * gfxEnd
 */
BOOL gfxEnd ( GFX_HBM hbm )
{
    GFX_BITMAP  *curr;
    GFX_BITMAP  *next;

    for( curr = lpVRAM; curr; curr=next )
    {
        next = curr->link;
        gfxDestroyBitmap ((GFX_HBM)curr);
    }

    lpVRAM = NULL;

    return DDDisable(FALSE);

    return TRUE;

} /* gfxEnd */

/*
 * gfxRestore
 *
 * restore the art when one or more surfaces are lost
 */
BOOL gfxRestore(GFX_HBM bm)
{
    GFX_BITMAP *pbm = (GFX_BITMAP*)bm;
    HRESULT     ddrval;
    HDC hdc;
    LPVOID lpBits;
    RGBQUAD *prgb;
    int i,w,h;
    RECT rc;

    struct {
        BITMAPINFOHEADER bi;
        RGBQUAD          ct[256];
    }   dib;

    IDirectDrawSurface *pdds = pbm->lpSurface;
    BITMAPINFOHEADER   UNALIGNED *pbi  = pbm->lpbi;

    if (pdds == NULL)
        return TRUE;

    if (IDirectDrawSurface_Restore(pdds) != DD_OK)
        return FALSE;

    if (pbi == NULL)
        return TRUE;

    //
    // in 8bbp mode if we get switched away from while loading
    // (and palette mapping) our art, the colors will not be correct
    // because some app may have changed the system palette.
    //
    // if we are in stress mode, just keep going.  It is more important
    // to make progress than to get the colors right.
    //

    if (!bFullscreen &&
         GameBPP == 8 && 
         GetForegroundWindow() != hWndMain && 
         !bStress )
    {
        Msg("gfxRestore: **** foreground window changed while loading art!");
        fForceRestore = TRUE;
        PauseGame();
        return FALSE;
    }

    dib.bi = *pbi;

    prgb = (RGBQUAD *)((LPBYTE)pbi + pbi->biSize);
    lpBits = (LPBYTE)(prgb + pbi->biClrUsed);

    if( pbi->biClrUsed == 0 && pbi->biBitCount <= 8 )
    {
        lpBits = (LPBYTE)(prgb + (1<<pbi->biBitCount));
    }

    w = MapRX(pbi->biWidth);
    h = MapRY(pbi->biHeight);
    /*
     * hack to make sure fox off-white doesn't become
     * pure white (which is transparent)
     */
    for( i=0; i<256; i++ )
    {
        dib.ct[i] = prgb[i];

        if( dib.ct[i].rgbRed   == 0xff &&
            dib.ct[i].rgbGreen == 0xff &&
            dib.ct[i].rgbBlue  == 224 )
        {
            dib.ct[i].rgbBlue = 0x80;
        }
        else
        if( dib.ct[i].rgbRed   == 251 &&
            dib.ct[i].rgbGreen == 243 &&
            dib.ct[i].rgbBlue  == 234 )
        {
            dib.ct[i].rgbBlue = 0x80;
        }
    }

    /*
     * if we are in 8bit mode we know the palette is 332 we can
     * do the mapping our self.
     *
     * NOTE we can only do this in fullscreen mode
     * in windowed mode, we have to share the palette with
     * the window manager and we dont get all of the colors
     * in the order we assume.
     *
     */
    if (bFullscreen && GameBPP == pbi->biBitCount && GameBPP == 8 )
    {
        BYTE xlat332[256];
        DDSURFACEDESC ddsd;
        int x,y,dib_pitch;
        BYTE *src, *dst;
        BOOL stretch;
        IDirectDrawSurface *pdds1;
        HDC hdc1;

        stretch = w != pbi->biWidth || h != pbi->biHeight;

        for( i=0;i<256;i++ )
        {
            xlat332[i] =
                ((dib.ct[i].rgbRed   >> 0) & 0xE0 ) |
                ((dib.ct[i].rgbGreen >> 3) & 0x1C ) |
                ((dib.ct[i].rgbBlue  >> 6) & 0x03 );
        }

        /*
         * if we are stretching copy into the back buffer
         * then use GDI to stretch later.
         */
        if( stretch )
        {
            pdds1 = lpBackBuffer;
        }
        else
        {
            pdds1 = pdds;
        }

        ddsd.dwSize = sizeof(ddsd);
        ddrval = IDirectDrawSurface_Lock(
            pdds1, NULL, &ddsd, DDLOCK_WAIT, NULL);

        if( ddrval == DD_OK )
        {
            dib_pitch = (pbi->biWidth+3)&~3;
            src = (BYTE *)lpBits + dib_pitch * (pbi->biHeight-1);
            dst = (BYTE *)ddsd.lpSurface;
            for( y=0; y<(int)pbi->biHeight; y++ )
            {
                for( x=0; x<(int)pbi->biWidth; x++ )
                {
                    dst[x] = xlat332[src[x]];
                }
                dst += ddsd.lPitch;
                src -= dib_pitch;
            }
            IDirectDrawSurface_Unlock(pdds1, NULL);
        }
        else
        {
            Msg("Lock failed err=%d", ddrval);
            return FALSE;
        }

        if( stretch )
        {
            if( IDirectDrawSurface_GetDC(pdds,&hdc) == DD_OK )
            {
                if( IDirectDrawSurface_GetDC(pdds1,&hdc1) == DD_OK )
                {
                    SetStretchBltMode(hdc, COLORONCOLOR);
                    StretchBlt(hdc, 0, 0, w, h,
                        hdc1, 0, 0, pbi->biWidth, pbi->biHeight, SRCCOPY);
                    IDirectDrawSurface_ReleaseDC(pdds1,hdc1);
                }
                IDirectDrawSurface_ReleaseDC(pdds,hdc);
            }
        }
    }
    else if( IDirectDrawSurface_GetDC(pdds,&hdc) == DD_OK )
    {
        SetStretchBltMode(hdc, COLORONCOLOR);
        StretchDIBits(hdc, 0, 0, w, h,
            0, 0, pbi->biWidth, pbi->biHeight,
            lpBits, (BITMAPINFO *)&dib.bi, DIB_RGB_COLORS, SRCCOPY);

        IDirectDrawSurface_ReleaseDC(pdds,hdc);
    }

    /*
     * show the art while loading...
     */
    rc.left = rcWindow.left,
    rc.top  = rcWindow.top + 20;
    rc.right = rc.left + w;
    rc.bottom = rc.top + h;
    IDirectDrawSurface_Blt(lpFrontBuffer, &rc, pdds, NULL, DDBLT_WAIT, NULL);

    return TRUE;

} /* gfxRestore */

/*
 * gfxRestoreAll
 *
 * restore the art when one or more surfaces are lost
 */
BOOL gfxRestoreAll()
{
    GFX_BITMAP  *curr;
    HWND hwndF = GetForegroundWindow();

    Splash();

    for( curr = lpVRAM; curr != NULL; curr = curr->link)
    {
        if (curr->lpSurface &&
            (fForceRestore || IDirectDrawSurface_IsLost(curr->lpSurface) == DDERR_SURFACELOST))
        {
            if( !gfxRestore(curr) )
            {
                Msg( "gfxRestoreAll: ************ Restore FAILED!" );
                return FALSE;
            }
        }
    }

    DDClear();
    fForceRestore = FALSE;
    return TRUE;

} /* gfxRestoreAll */

/*
 * gfxFillBack
 */
void gfxFillBack( DWORD dwColor )
{
    DDBLTFX     ddbltfx;

    ddbltfx.dwSize = sizeof( ddbltfx );
    ddbltfx.dwFillColor = dwColor;

    IDirectDrawSurface_Blt(
                        lpBackBuffer,           // dest surface
                        NULL,                   // dest rect
                        NULL,                   // src surface
                        NULL,                   // src rect
                        DDBLT_COLORFILL | DDBLT_WAIT,
                        &ddbltfx);

} /* gfxFillBack */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\plane.h ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved.
 *
 *  File:       plane.h
 *  Content:    planes include file
 *
 ***************************************************************************/
#ifndef __PLANE_INCLUDED__
#define __PLANE_INCLUDED__

HPLANE *CreatePlane( USHORT, USHORT, USHORT );
BOOL    TilePlane( HPLANE*, HBITMAPLIST*, HPOSLIST* );
BOOL    SurfacePlane( HPLANE*, HSURFACELIST* );
BOOL    SetSurface( HPLANE*, HSPRITE* );
BOOL    GetSurface( HPLANE*, HSPRITE* );
BOOL    SetPlaneX( HPLANE*, LONG, POSITION );
LONG    GetPlaneX( HPLANE* );
BOOL    SetPlaneY( HPLANE*, LONG, POSITION );
LONG    GetPlaneY( HPLANE* );
BOOL    SetPlaneSlideX( HPLANE*, LONG, POSITION );
BOOL    SetPlaneVelX( HPLANE*, LONG, POSITION );
BOOL    SetPlaneIncremX( HPLANE*, LONG, POSITION );
BOOL    ScrollPlane( HSPRITE* );
BOOL    DisplayPlane( GFX_HBM, HPLANE* );
BOOL    DestroyPlane( HPLANE* );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\rcids.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#define FOX_ICON        101
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\plane.c ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved.
 *
 *  File:       plane.c
 *  Content:    plane manipulation functions
 *
 ***************************************************************************/
#include "foxbear.h"

/*
 * CreatePlane
 */
HPLANE *CreatePlane ( USHORT width, USHORT height, USHORT denom )
{
    HPLANE      *hPlane;
    USHORT      num_elems;
    USHORT      elem_size;

    num_elems = width * height;
    elem_size = sizeof (GFX_HBM);

    hPlane = MemAlloc( sizeof (HPLANE) );
    if( hPlane == NULL )
    {
        ErrorMessage( "hPlane in CreatePlane" );
    }

    hPlane->hBM  = CMemAlloc( num_elems, elem_size );
    hPlane->surface = CMemAlloc( num_elems, sizeof hPlane->surface );
    hPlane->x = 0;
    hPlane->y = 0;
    hPlane->width = width;
    hPlane->height = height;
    hPlane->denom = denom;
    hPlane->xslide = 0;
    hPlane->xincrem = 0;
    hPlane->xv = 0;

    if( hPlane->hBM == NULL )
    {
        MemFree( hPlane );
        ErrorMessage( "hPlane->hBM in CreatePlane" );
    }

    return hPlane;

} /* CreatePlane */


/*
 * TilePlane
 */
BOOL TilePlane( HPLANE *hPlane, HBITMAPLIST *hTileList, HPOSLIST *posList )
{
    USHORT i;

    for( i = 0; i < hPlane->width * hPlane->height; ++i )
    {
        hPlane->surface[i] = FALSE;

        if( posList[i] >= 0 )
        {
            hPlane->hBM[i] = hTileList[ posList[i] ].hBM;
        }
        else
        {
            hPlane->hBM[i] = NULL;
        }
    }

    return TRUE;

} /* TilePlane */

/*
 * SurfacePlane
 */
BOOL SurfacePlane( HPLANE *hPlane, HSURFACELIST *hSurfaceList )
{
    USHORT i;

    for( i = 0; i < hPlane->width * hPlane->height; ++i )
    {
        if( hSurfaceList[i] == FALSE )
        {
            hPlane->surface[i] = FALSE;
        }
        else
        {
            hPlane->surface[i] = TRUE;
        }
    }

    return TRUE;

} /* SurfacePlane */

/*
 * SetSurface
 */
BOOL SetSurface( HPLANE  *hPlane, HSPRITE *hSprite )
{
    SHORT c;
    SHORT n;
    SHORT x;
    SHORT y;

    c = hSprite->currentBitmap;
    x = (hSprite->x >> 16) / C_TILE_W;
    y = (SHORT) hSprite->y >> 16;

    y += hSprite->hSBM[c].y + hSprite->hSBM[c].height;
    y /= C_TILE_H;

    n = (x % hPlane->width) + y * hPlane->width;

    if( hPlane->surface[n] == FALSE )
    {
        if( !hPlane->surface[n + hPlane->width] == FALSE )
        {
            y += 1;
        }
        if( !hPlane->surface[n - hPlane->width] == FALSE )
        {
            y -= 1;
        }
    }
    
    y *= C_TILE_H;
    y -= hSprite->hSBM[c].y + hSprite->hSBM[c].height;

    SetSpriteY( hSprite, y << 16, P_ABSOLUTE );

    return TRUE;

} /* SetSurface */

/*
 * GetSurface
 */
BOOL GetSurface( HPLANE *hPlane, HSPRITE *hSprite )
{   
    SHORT  c;
    SHORT  x;
    SHORT  y;

    c = hSprite->currentBitmap;
    x = ((hSprite->x >> 16) + hSprite->width / 2) / C_TILE_H;
    y = ((hSprite->y >> 16) + hSprite->hSBM[c].y + hSprite->hSBM[c].height) / C_TILE_W;

    return hPlane->surface[(x % hPlane->width) + y * hPlane->width];

} /* GetSurface */

/*
 * SetPlaneX
 */
BOOL SetPlaneX( HPLANE *hPlane, LONG x, POSITION position )
{
    LONG xincrem;    

    if( position == P_ABSOLUTE )
    {
        hPlane->x = x;
    }
    else if( position == P_RELATIVE )
    {
        hPlane->x += x;
    }
    else if( position == P_AUTOMATIC )
    {
        if( hPlane->xslide > 0 )
        {
            xincrem = hPlane->xincrem;
        }
        else if( hPlane->xslide < 0 )
        {
            xincrem = -hPlane->xincrem;
        }
        else
        {
            xincrem = 0;
        }

        hPlane->x += (hPlane->xv + xincrem) / hPlane->denom;
        hPlane->xslide -= xincrem;
        hPlane->xv = 0;

        if( abs(hPlane->xslide) < hPlane->xincrem )
        {
            hPlane->x += hPlane->xslide / hPlane->denom;
            hPlane->xslide = 0;
            hPlane->xincrem = 0;
        }
    }

    if( hPlane->x < 0 )
    {
        hPlane->x += (hPlane->width * C_TILE_W) << 16;
    }
    else if( hPlane->x >= (hPlane->width * C_TILE_W) << 16 )
    {
        hPlane->x -= (hPlane->width * C_TILE_W) << 16;
    }

    return TRUE;

} /* SetPlaneX */

/*
 * GetPlaneX
 */
LONG GetPlaneX( HPLANE *hPlane )
{
    return hPlane->x;

} /* GetPlaneX */

/*
 * SetPlaneY
 */
BOOL SetPlaneY( HPLANE *hPlane, LONG y, POSITION position )
{
    if( position == P_ABSOLUTE )
    {
        hPlane->y = y;
    }
    else
    {
        hPlane->y += y;
    }

    if( hPlane->y < 0 )
    {
        hPlane->y += (hPlane->height * C_TILE_H) << 16;
    }
    else if( hPlane->y >= (hPlane->height * C_TILE_H) << 16 )
    {
        hPlane->y -= (hPlane->height * C_TILE_H) << 16;
    }

    return TRUE;

} /* SetPlaneY */

/*
 * GetPlaneY
 */
LONG GetPlaneY( HPLANE *hPlane )
{
    return hPlane->y;

} /* GetPlaneY */

/*
 * SetPlaneSlideX
 */
BOOL SetPlaneSlideX( HPLANE *hPlane, LONG xslide, POSITION position )
{
    if( position == P_ABSOLUTE )
    {
        hPlane->xslide = xslide;
    }
    else if( position == P_RELATIVE )
    {
        hPlane->xslide += xslide;
    }
    return TRUE;

} /* SetPlaneSlideX */

/*
 * SetPlaneVelX
 */
BOOL SetPlaneVelX( HPLANE *hPlane, LONG xv, POSITION position )
{
    if( position == P_ABSOLUTE )
    {
        hPlane->xv = xv;
    }
    else if( position == P_RELATIVE )
    {
        hPlane->xv += xv;
    }

    return TRUE;
} /* SetPlaneVelX */

/*
 * SetPlaneIncremX
 */
BOOL SetPlaneIncremX( HPLANE *hPlane, LONG xincrem, POSITION position )
{
    if( position == P_ABSOLUTE )
    {
        hPlane->xincrem = xincrem;
    }
    else if( position == P_RELATIVE )
    {
        hPlane->xincrem += xincrem;
    }

    return TRUE;

} /* SetPlaneIncremX */

/*
 * ScrollPlane
 */
BOOL ScrollPlane( HSPRITE *hSprite )
{
    if( (GetSpriteX(hSprite) <= C_FOX_STARTX) && (GetSpriteVelX(hSprite) < 0) )
    {
        return TRUE;
    }

    if( (GetSpriteX(hSprite) >= C_FOX_STARTX) && (GetSpriteVelX(hSprite) > 0) )
    {
        return TRUE;
    }
    return FALSE;

} /* ScrollPlane */


/*
 * DisplayPlane
 */
BOOL DisplayPlane ( GFX_HBM  hBuffer, HPLANE *hPlane )
{
    USHORT      n;
    USHORT      i;
    USHORT      j;
    USHORT      x1;
    USHORT      y1;
    USHORT      x2;
    USHORT      y2;
    USHORT      xmod;
    USHORT      ymod;
    POINT       src;
    RECT        dst;


    x1 = (hPlane->x >> 16) / C_TILE_W;          
    y1 = (hPlane->y >> 16) / C_TILE_H;
    x2 = x1 + C_SCREEN_W / C_TILE_W;
    y2 = y1 + C_SCREEN_H / C_TILE_H;
    xmod = (hPlane->x >> 16) % C_TILE_W;
    ymod = (hPlane->y >> 16) % C_TILE_H;

    for( j = y1; j < y2; ++j )
    {
        for( i = x1; i <= x2; ++i )
        {
            n = (i % hPlane->width) + j * hPlane->width;
            if( hPlane->hBM[n] != NULL )
            {
                if( i == x1 )
                {
                    dst.left  = 0;
                    dst.right = dst.left + C_TILE_W - xmod;
                    src.x     = xmod;
                }
                else if( i == x2 )
                {
                    dst.left  = (i - x1) * C_TILE_W - xmod;
                    dst.right = dst.left + xmod;
                    src.x     = 0;
                } else {
                    dst.left  = (i - x1) * C_TILE_W - xmod;
                    dst.right = dst.left + C_TILE_W;
                    src.x     = 0;
                }
    
                if( j == y1 )
                {
                    dst.top    = 0;
                    dst.bottom = dst.top + C_TILE_H - ymod;
                    src.y      = ymod;
                }
                else if( j == y2 )
                {
                    dst.top    = (j - y1) * C_TILE_H - ymod;
                    dst.bottom = dst.top + ymod;
                    src.y      = 0;
                } else {
                    dst.top    = (j - y1) * C_TILE_H - ymod;
                    dst.bottom = dst.top + C_TILE_H;
                    src.y      = 0;
                }
         
                gfxBlt(&dst,hPlane->hBM[n],&src);
            }
        }
    }

    return TRUE;

} /* DisplayPlane */

/*
 * DestroyPlane
 */
BOOL DestroyPlane ( HPLANE *hPlane )
{
    if( hPlane == NULL )
    {
        ErrorMessage( "hPlane in DestroyPlane" );
    }

    if( hPlane->hBM == NULL )
    {
        ErrorMessage( "hPlane->hBM in DestroyPlane" );
    }

    MemFree( hPlane->hBM );
    MemFree( hPlane );

    return TRUE;

} /* DestroyPlane */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\tile.h ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved.
 *
 *  File:       tile.h
 *  Content:    tile include file
 *
 ***************************************************************************/
#ifndef TILE__H__
#define TILE__H__

HBITMAPLIST  *CreateTiles( HBITMAPLIST*, USHORT );
void          ReloadTiles( HBITMAPLIST*, USHORT );
BOOL          DestroyTiles( HBITMAPLIST* );
HPOSLIST     *CreatePosList( CHAR*, USHORT, USHORT );
HSURFACELIST *CreateSurfaceList( CHAR*, USHORT, USHORT );
BOOL          DestroyPosList( HPOSLIST* );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\sprite.h ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved.
 *
 *  File:       sprite.h
 *  Content:    sprite include file
 *
 ***************************************************************************/
#ifndef __SPRITE_INCLUDED__
#define __SPRITE_INCLUDED__

HSPRITE  *CreateSprite( USHORT, LONG, LONG, USHORT, USHORT, USHORT, USHORT, SHORT, BOOL );
BOOL      BitBltSprite( HSPRITE*, GFX_HBM, ACTION, DIRECTION, SHORT, SHORT, USHORT, USHORT );
BOOL      SetSpriteAction( HSPRITE*, ACTION, DIRECTION );
ACTION    GetSpriteAction( HSPRITE* );
BOOL      ChangeSpriteDirection( HSPRITE* );
DIRECTION GetSpriteDirection( HSPRITE* );
BOOL      SetSpriteBitmap( HSPRITE*, USHORT );
USHORT    GetSpriteBitmap( HSPRITE* );
BOOL      SetSpriteActive( HSPRITE*, BOOL );
BOOL      GetSpriteActive( HSPRITE* );
BOOL      SetSpriteVelX( HSPRITE*, LONG, POSITION );
LONG      GetSpriteVelX( HSPRITE* );
BOOL      SetSpriteVelY( HSPRITE*, LONG, POSITION );
LONG      GetSpriteVelY( HSPRITE* );
BOOL      SetSpriteAccX( HSPRITE*, LONG, POSITION );
LONG      GetSpriteAccX( HSPRITE* );
BOOL      SetSpriteAccY( HSPRITE*, LONG, POSITION );
LONG      GetSpriteAccY( HSPRITE* );
BOOL      SetSpriteX( HSPRITE*, LONG, POSITION );
LONG      GetSpriteX( HSPRITE* );
BOOL      SetSpriteY( HSPRITE*, LONG, POSITION );
LONG      GetSpriteY( HSPRITE* );
BOOL      SetSpriteSwitch( HSPRITE*, LONG, POSITION );
BOOL      IncrementSpriteSwitch( HSPRITE*, LONG );
BOOL      SetSpriteSwitchType( HSPRITE*, SWITCHING );
SWITCHING GetSpriteSwitchType( HSPRITE* );
BOOL      SetSpriteSwitchForward( HSPRITE*, BOOL );
BOOL      GetSpriteSwitchForward( HSPRITE* );
BOOL      SetSpriteSwitchDone( HSPRITE*, BOOL );
BOOL      GetSpriteSwitchDone( HSPRITE* );
BOOL      DisplaySprite( GFX_HBM, HSPRITE*, LONG );
BOOL      DestroySprite( HSPRITE* );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\sprite.c ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved.
 *
 *  File:       sprite.c
 *  Content:    sprite manipulation functions
 *
 ***************************************************************************/
#include "foxbear.h"

/*
 * CreateSprite
 */
HSPRITE *CreateSprite (
    USHORT    bitmapCount,
    LONG      x,
    LONG      y,
    USHORT    width,
    USHORT    height,
    USHORT    xmax,
    USHORT    ymax,
    SHORT     as,
    BOOL      active )
{
    HSPRITE *hSprite;
    USHORT   i;

    hSprite = MemAlloc( sizeof (HSPRITE) );
    if( hSprite == NULL )
    {
        ErrorMessage( "hSprite in CreateSprite" );
    }

    hSprite->hSBM = CMemAlloc( bitmapCount, sizeof (HSPRITE_BM) );
    if( hSprite->hSBM == NULL )
    {
        MemFree( hSprite );
        ErrorMessage( "hSprite->hSBM in CreateSprite" );
    }
    
    hSprite->active        = active;
    hSprite->bitmapCount   = bitmapCount;
    hSprite->x             = x;
    hSprite->y             = y;
    hSprite->width         = width;
    hSprite->height        = height;
    hSprite->xv            = 0;
    hSprite->yv            = 0;
    hSprite->xa            = 0;
    hSprite->ya            = 0;
    hSprite->xmax          = xmax;
    hSprite->ymax          = ymax;
    hSprite->absSwitch     = as;
    hSprite->relSwitch     = 0;
    hSprite->switchType    = HOR;
    hSprite->switchForward = TRUE;
    hSprite->switchDone    = FALSE;

    for( i = 0; i < bitmapCount; ++i )
    {
        hSprite->hSBM[i].hBM = NULL;
    }

    return hSprite;

} /* CreateSprite */

/*
 * BitBltSprite
 */
BOOL BitBltSprite (
    HSPRITE   *hSprite,
    GFX_HBM    hBM,
    ACTION     action,
    DIRECTION  direction,
    SHORT      x,
    SHORT      y,
    USHORT     w,
    USHORT     h )
{
    USHORT count;

    if( hSprite == NULL )
    {
        ErrorMessage( "hSprite in BitBltSprite" );
    }

    if( hBM == NULL )
    {
        ErrorMessage( "hBM in BitBltSprite" );
    }

    if( (x >= hSprite->width) || (y >= hSprite->height) )
    {
        ErrorMessage( "x or y in BitBltSprite" );
    }

    count = 0;
    while( hSprite->hSBM[count].hBM != NULL )
    {
        count++;
        if( count >= hSprite->bitmapCount )
        {
            ErrorMessage( "Bitmap overflow in BitBltSprite" );
        }
    }

    hSprite->hSBM[count].hBM       = hBM;
    hSprite->hSBM[count].action    = action;
    hSprite->hSBM[count].direction = direction;
    hSprite->hSBM[count].x         = x;
    hSprite->hSBM[count].y         = y;
    hSprite->hSBM[count].width     = w; 
    hSprite->hSBM[count].height    = h; 

    return TRUE;

} /* BitBltSprite */

/*
 * SetSpriteAction
 */
BOOL SetSpriteAction ( HSPRITE *hSprite, ACTION action, DIRECTION direction )
{
    USHORT c;

    c = 0;

    if( direction == SAME )
    {
        direction = hSprite->currentDirection;
    }

    while( (hSprite->hSBM[c].action != action) || (hSprite->hSBM[c].direction != direction) )
    {
        ++c;
    }

    hSprite->currentAction    = action;
    hSprite->currentDirection = direction;
    hSprite->currentBitmap    = c;
    hSprite->relSwitch        = 0;

    return TRUE;

} /* SetSpriteAction */

/*
 * ChangeSpriteDirection
 */
BOOL ChangeSpriteDirection( HSPRITE *hSprite )
{
    DIRECTION direction;

    if( hSprite->currentDirection == RIGHT )
    {
        direction = LEFT;
    }
    else
    {
        direction = RIGHT;
    }

    SetSpriteAction( hSprite, hSprite->currentAction, direction );

    return TRUE;

} /* ChangeSpriteDirection */

/*
 * GetSpriteAction
 */
ACTION GetSpriteAction( HSPRITE *hSprite )
{
    return hSprite->currentAction;

} /* GetSpriteAction */


/*
 * GetSpriteDirection
 */
DIRECTION GetSpriteDirection( HSPRITE *hSprite )         
{
    return hSprite->currentDirection;

} /* GetSpriteDirection */

/*
 * SetSpriteActive
 */
BOOL SetSpriteActive( HSPRITE *hSprite, BOOL active )
{
    hSprite->active = active;
    
    if( active == FALSE )
    {
        hSprite->xv = 0;
        hSprite->yv = 0;
        hSprite->xa = 0;
        hSprite->ya = 0;
    }

    return TRUE;

} /* SetSpriteActive */

/*
 * GetSpriteActive
 */
BOOL GetSpriteActive( HSPRITE *hSprite )
{
    return hSprite->active;

} /* GetSpriteActive */

/*
 * SetSpriteVelX
 */
BOOL SetSpriteVelX( HSPRITE *hSprite, LONG xv, POSITION position )
{
    if( hSprite->active == FALSE )
    {
        return FALSE;
    }

    if( position == P_ABSOLUTE )
    {
        hSprite->xv = xv;
    }
    else if( position == P_RELATIVE )
    {
        hSprite->xv += xv;
    }

    return TRUE;

} /* SetSpriteVelX */

/*
 * GetSpriteVelX
 */
LONG GetSpriteVelX( HSPRITE *hSprite )
{
    return hSprite->xv;

} /* GetSpriteVelX */

/*
 * SetSpriteVelY
 */
BOOL SetSpriteVelY( HSPRITE *hSprite, LONG  yv, POSITION position )
{
    if( hSprite->active == FALSE )
    {
        return FALSE;
    }

    if( position == P_ABSOLUTE )
    {
        hSprite->yv = yv;
    }
    else if( position == P_RELATIVE )
    {
        hSprite->yv += yv;
    }

    return TRUE;

} /* SetSpriteVelY */

/*
 * GetSpriteVelY
 */
LONG GetSpriteVelY( HSPRITE *hSprite )
{
    return hSprite->yv;

} /* GetSpriteVelY */

/*
 * SetSpriteAccX
 */
BOOL SetSpriteAccX ( HSPRITE *hSprite, LONG xa, POSITION position )
{
    if( position == P_ABSOLUTE )
    {
        hSprite->xa = xa;
    }
    else if( position == P_RELATIVE )
    {
        hSprite->xa += xa;
    }
    return TRUE;

} /* SetSpriteAccX */

/*
 * GetSpriteAccX
 */
LONG GetSpriteAccX( HSPRITE *hSprite )
{
    return hSprite->xa;

} /* GetSpriteAccX */

/*
 * SetSpriteAccY
 */
BOOL SetSpriteAccY ( HSPRITE *hSprite, LONG ya, POSITION position )
{
    if( position == P_ABSOLUTE )
    {
        hSprite->ya = ya;
    }
    else if( position == P_RELATIVE )
    {
        hSprite->ya += ya;
    }
    return TRUE;

} /* SetSpriteAccY */

/*
 * GetSpriteAccY
 */
LONG GetSpriteAccY( HSPRITE *hSprite )
{
    return hSprite->ya;

} /* GetSpriteAccY */

/*
 * SetSpriteX
 */
BOOL SetSpriteX( HSPRITE *hSprite, LONG x, POSITION position )
{
    if( hSprite->active == FALSE )
    {
        return FALSE;
    }

    if( position == P_AUTOMATIC )
    {
        hSprite->xv += hSprite->xa;
        hSprite->x  += hSprite->xv;
    }
    else if( position == P_ABSOLUTE )
    {
        hSprite->x = x;
    }
    else if( position == P_RELATIVE )
    {
        hSprite->x += x;
    }

    if( hSprite->x < 0 )
    {
        hSprite->x += hSprite->xmax << 16;
    }
    else if( hSprite->x >= hSprite->xmax << 16 )
    {
        hSprite->x -= hSprite->xmax << 16;
    }
    return TRUE;

} /* SetSpriteX */

/*
 * GetSpriteX
 */
LONG GetSpriteX( HSPRITE *hSprite )
{
    return hSprite->x;

} /* GetSpriteX */

/*
 * SetSpriteY
 */
BOOL SetSpriteY ( HSPRITE *hSprite, LONG y, POSITION position )
{
    if( hSprite->active == FALSE )
    {
        return FALSE;
    }

    if( position == P_AUTOMATIC )
    {
        hSprite->yv += hSprite->ya;
        hSprite->y  += hSprite->yv;
    }
    else if( position == P_ABSOLUTE )
    {
        hSprite->y = y;
    }
    else if( position == P_RELATIVE )
    {
        hSprite->y += y;
    }

    if( hSprite->y < 0 )
    {
        hSprite->y += hSprite->ymax << 16;
    }
    else if( hSprite->y >= hSprite->ymax << 16 )
    {
        hSprite->y -= hSprite->ymax << 16;
    }

    return TRUE;

} /* SetSpriteY */

/*
 * GetSpriteY
 */
LONG GetSpriteY( HSPRITE *hSprite )
{
    return hSprite->y;

} /* GetSpriteY */

/*
 * SetSpriteSwitch
 */
BOOL SetSpriteSwitch ( HSPRITE *hSprite, LONG absSwitch, POSITION position )               
{
    if( position == P_ABSOLUTE )
    {
        hSprite->absSwitch = absSwitch;
    }
    else if( position == P_RELATIVE )
    {
        hSprite->absSwitch += absSwitch;
    }
    return TRUE;

} /* SetSpriteSwitch */


/*
 * IncrementSpriteSwitch
 */
BOOL IncrementSpriteSwitch ( HSPRITE *hSprite, LONG n )
{
    hSprite->relSwitch += n;
    return TRUE;

} /* IncrementSpriteSwitch */

/*
 * SetSpriteSwitchType
 */
BOOL SetSpriteSwitchType( HSPRITE *hSprite, SWITCHING switchType )
{
    hSprite->switchType = switchType;
    hSprite->relSwitch  = 0;
    return TRUE;

} /* SetSpriteSwitchType */


/*
 * GetSpriteSwitchType
 */
SWITCHING GetSpriteSwitchType ( HSPRITE *hSprite )
{
    return hSprite->switchType;

} /* GetSpriteSwitchType */

/*
 * SetSpriteSwitchForward
 */
BOOL SetSpriteSwitchForward( HSPRITE *hSprite, BOOL switchForward )
{
    hSprite->switchForward = switchForward;

    return TRUE;

} /* SetSpriteSwitchForward */

/*
 * GetSpriteSwitchForward
 */
BOOL GetSpriteSwitchForward( HSPRITE *hSprite )
{
    return hSprite->switchForward;

} /* GetSpriteSwitchForward */

/*
 * SetSpriteSwitchDone
 */
BOOL SetSpriteSwitchDone( HSPRITE *hSprite, BOOL switchDone )
{
    hSprite->switchDone = switchDone;
    return TRUE;

} /* SetSpriteSwitchDone */


/*
 * GetSpriteSwitchDone
 */
BOOL GetSpriteSwitchDone( HSPRITE *hSprite )
{
    return hSprite->switchDone;

} /* GetSpriteSwitchDone */

/*
 * SetSpriteBitmap
 */
BOOL SetSpriteBitmap ( HSPRITE *hSprite, USHORT currentBitmap )
{
    USHORT c;

    c = 0;
    while( (hSprite->currentAction != hSprite->hSBM[c].action) ||
           (hSprite->currentDirection != hSprite->hSBM[c].direction) )
    {
        ++c;
    }
    hSprite->currentBitmap = c + currentBitmap;
    return TRUE;

} /* SetSpriteBitmap */

/*
 * GetSpriteBitmap
 */
USHORT GetSpriteBitmap( HSPRITE *hSprite )
{
    USHORT count;

    count = 0;
    while( (hSprite->currentAction != hSprite->hSBM[count].action) ||
           (hSprite->currentDirection != hSprite->hSBM[count].direction) )
    {
        ++count;
    }
    return hSprite->currentBitmap - count;

} /* GetSpriteBitmap */

/*
 * advanceSpriteBitmap
 */
static BOOL advanceSpriteBitmap( HSPRITE *hSprite )
{
    SHORT       c;
    SHORT       n;
    ACTION      curAct;
    ACTION      act;
    DIRECTION   curDir;
    DIRECTION   dir;

    curAct = hSprite->currentAction;
    curDir = hSprite->currentDirection;

        //
        // See if we're cycling forward or backward though the images.
        //
    if( hSprite->switchForward ) // Are we cycling forward?
    {
        c   = hSprite->currentBitmap + 1;

                // Does the next image exceed the number of images we have?
        if( c >= hSprite->bitmapCount )
                {
                        // if the next image is past the end of the list,
                        // we need to set it to the start of the series.
            SetSpriteBitmap( hSprite, 0 );
                        c   = hSprite->currentBitmap;
        }
                else
                {
                        act = hSprite->hSBM[c].action;
                        dir = hSprite->hSBM[c].direction;

                        // By examining the action and direction fields we can tell
                        // if we've past the current series of images and entered 
                        // another series.
                        if( (curAct != act) || (curDir != dir) )
                        {
                                        SetSpriteBitmap( hSprite, 0 );
                        } 
                        else // We're still in the series, use the next image.
                        {
                                hSprite->currentBitmap = c;
                        }
                }
    }
        else //cycling backwards
        {
        c   = hSprite->currentBitmap - 1;

        if( c < 0 ) // Is the next image past the beginning of the list?
                {
            n = 0;
                        
                        // Find the last bitmap in the series
            while( (n <= hSprite->bitmapCount) &&
                               (curAct == hSprite->hSBM[n].action) &&
                       (curDir == hSprite->hSBM[n].direction) )
                        {
                                ++n;                            
                        }

            hSprite->currentBitmap = n - 1;
        }

                else
                {
                        act = hSprite->hSBM[c].action;
                        dir = hSprite->hSBM[c].direction;
                        // Is the next image past the of the series
                        if( (curAct != act) || (curDir != dir) ) 
                        {
                                n = c + 1;
                                while( (n <= hSprite->bitmapCount) &&
                                           (curAct == hSprite->hSBM[n].action) &&
                                   (curDir == hSprite->hSBM[n].direction) )
                                {
                                        ++n;                            
                                }

                                hSprite->currentBitmap = n - 1;
                        }
                        else  // The next image is fine, use it.
                        {
                                hSprite->currentBitmap = c;
                        }
                }
    }
    return TRUE;

} /* advanceSpriteBitmap */

/*
 * DisplaySprite
 */
BOOL DisplaySprite ( GFX_HBM hBuffer, HSPRITE *hSprite, LONG xPlane )
{
    USHORT      count;
    SHORT       left;
    SHORT       right;
    SHORT       shortx;
    SHORT       shorty;
    SHORT       planex;
    POINT       src;
    RECT        dst;

    if( hSprite->active == FALSE )
    {
        return FALSE;
    }

    count = hSprite->currentBitmap;
    shortx = (SHORT) (hSprite->x >> 16);
    shorty = (SHORT) (hSprite->y >> 16);
    planex = (SHORT) (xPlane >> 16);
    src.x = 0;
    src.y = 0;

    if( shortx < planex - C_SCREEN_W )
    {
        shortx += hSprite->xmax;
    }
    else if( shortx >= planex + C_SCREEN_W )
    {
        shortx -= hSprite->xmax;
    }

    left = shortx - planex;
    
    if( hSprite->currentDirection == RIGHT )
    {
        left += hSprite->hSBM[count].x;
    }
    else
    {
        left += hSprite->width - hSprite->hSBM[count].x - hSprite->hSBM[count].width;
    }

    right = left + hSprite->hSBM[count].width;

    if( left > C_SCREEN_W )
    {
        left = C_SCREEN_W;
    }
    else if( left < 0 )
    {
        src.x = -left;
        left = 0;
    }

    if( right > C_SCREEN_W )
    {
        right = C_SCREEN_W;
    }
    else if( right < 0 )
    {
        right = 0;
    }

    dst.left   = left;
    dst.right  = right;
    dst.top    = shorty + hSprite->hSBM[count].y;
    dst.bottom = dst.top + hSprite->hSBM[count].height;

    gfxBlt(&dst,hSprite->hSBM[count].hBM,&src);

    if( hSprite->switchType == HOR )
    {
        hSprite->relSwitch += abs(hSprite->xv);

        if( hSprite->relSwitch >= hSprite->absSwitch )
        {
            hSprite->relSwitch = 0;
            advanceSpriteBitmap( hSprite );
        }
    }
    else if( hSprite->switchType == VER )
    {
        hSprite->relSwitch += abs(hSprite->yv);

        if( hSprite->relSwitch >= hSprite->absSwitch )
        {
            hSprite->relSwitch = 0;
            advanceSpriteBitmap( hSprite );

            if( GetSpriteBitmap( hSprite ) == 0 )
                {
                SetSpriteSwitchDone( hSprite, TRUE );
            }
        }
    }
    else if( hSprite->switchType == TIMESWITCH )
    {
        hSprite->relSwitch += C_UNIT;

        if( hSprite->relSwitch >= hSprite->absSwitch )
            {
            hSprite->relSwitch = 0;
            advanceSpriteBitmap( hSprite );
            
            if( GetSpriteBitmap( hSprite ) == 0 )
                {
                SetSpriteSwitchDone( hSprite, TRUE );
            }
        }
    }

    return TRUE;

} /* DisplaySprite */

/*
 * DestroySprite
 */
BOOL DestroySprite ( HSPRITE *hSprite )
{
    USHORT i;

    if( hSprite == NULL )
    {
        ErrorMessage( "hSprite in DestroySprite" );
    }

    if( hSprite->hSBM == NULL )
    {
        ErrorMessage( "hSprite->hSBM in DestroySprite" );
    }

    for( i = 0; i < hSprite->bitmapCount; ++i )
    {
        if( !gfxDestroyBitmap( hSprite->hSBM[i].hBM ) )
            {
            ErrorMessage( "gfxDestroyBitmap (hBM) in DestroySprite" );
        }
    }

    MemFree( hSprite->hSBM );
    MemFree( hSprite );

    return TRUE;

} /* DestroySprite */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\vidsrc.c ===
/* Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved. */
#include "foxbear.h"

BOOL            bMovie;
BOOL            bCamera;
WCHAR           wszMovie[100];

#define RELEASE(x) if ((x) != NULL) (x)->lpVtbl->Release(x);
#ifdef DEBUG
    HRESULT __inline check_error(HRESULT hr, LPSTR psz)
    {
	if (FAILED(hr)) {
	    char sz[200];
	    wsprintf(sz, "%s failed code 0x%8.8X\n", psz, hr);
	    OutputDebugString(sz);
	}
	return hr;
    }
#else
    HRESULT __inline check_error(HRESULT hr, LPSTR psz)
    {
	UNREFERENCED_PARAMETER(psz);
	return hr;
    }
#endif
#define CHECK_ERROR(x) if (FAILED(hr = check_error(x, #x))) goto Exit;

HRESULT FindCaptureDevice(IMoniker **ppMoniker)
{
    ICreateDevEnum *pCreateDevEnum;
    IEnumMoniker *pEm;
    ULONG cFetched;

    HRESULT hr = CoCreateInstance(
			  &CLSID_SystemDeviceEnum,
			  NULL,
			  CLSCTX_INPROC_SERVER,
			  &IID_ICreateDevEnum,
			  (void**)&pCreateDevEnum);
    if (FAILED(hr))
	return hr;

    hr = ICreateDevEnum_CreateClassEnumerator(pCreateDevEnum,
					      &CLSID_CVidCapClassManager,
					      &pEm,
					      0);
    ICreateDevEnum_Release(pCreateDevEnum);
    if (FAILED(hr)) {
	return hr;
    }

    hr = IEnumMoniker_Next(pEm, 1, ppMoniker, &cFetched);
    IEnumMoniker_Release(pEm);
    return S_OK == hr ? hr : E_FAIL;
}

BOOL CreateVideoSource(IDirectDrawStreamSample **ppVideoSource, WCHAR * szFileName)
{
    HRESULT hr;
    IAMMultiMediaStream *pAMStream = NULL;
    IMediaStream *pVideoStream = NULL;
    IDirectDrawMediaStream *pDDVideoStream = NULL;
    IDirectDrawSurface *pSurface = NULL;
    IMoniker *pMoniker = NULL;
    IDirectDrawPalette *pPalette = NULL;
    IBindCtx *pCtx = NULL;
    DDSURFACEDESC ddsd;

    CHECK_ERROR(CoCreateInstance(&CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER,
				 &IID_IAMMultiMediaStream, (void **)&pAMStream));

    CHECK_ERROR(IAMMultiMediaStream_Initialize(pAMStream, STREAMTYPE_READ, 0, NULL));
    CHECK_ERROR(IAMMultiMediaStream_AddMediaStream(pAMStream, (IUnknown*)lpDD, &MSPID_PrimaryVideo, 0, &pVideoStream));

    CHECK_ERROR(IAMMultiMediaStream_AddMediaStream(pAMStream, NULL, &MSPID_PrimaryAudio, AMMSF_ADDDEFAULTRENDERER, NULL));
    if (bCamera) {
        CreateBindCtx(0, &pCtx);
	CHECK_ERROR(FindCaptureDevice(&pMoniker));
	CHECK_ERROR(IAMMultiMediaStream_OpenMoniker(
	    pAMStream, pCtx, pMoniker, AMMSF_RENDERTOEXISTING));
    } else {
	CHECK_ERROR(IAMMultiMediaStream_OpenFile(
	    pAMStream, bMovie ? wszMovie : szFileName, AMMSF_RENDERTOEXISTING));
    }

    CHECK_ERROR(IMediaStream_QueryInterface(pVideoStream, &IID_IDirectDrawMediaStream, (void **)&pDDVideoStream));

    ddsd.dwSize = sizeof(ddsd);
    CHECK_ERROR(IDirectDrawMediaStream_GetFormat(pDDVideoStream, &ddsd, NULL, NULL, NULL));

    pSurface = DDCreateSurface(ddsd.dwWidth, ddsd.dwHeight, FALSE, TRUE);
    hr = IDirectDrawSurface_GetPalette(lpFrontBuffer, &pPalette);
    if (SUCCEEDED(hr)) {
	CHECK_ERROR(IDirectDrawSurface_SetPalette(pSurface, pPalette));
    }
    CHECK_ERROR(IDirectDrawMediaStream_CreateSample(pDDVideoStream, pSurface, NULL, DDSFF_PROGRESSIVERENDER, ppVideoSource));

    CHECK_ERROR(IAMMultiMediaStream_SetState(pAMStream, STREAMSTATE_RUN));

    CHECK_ERROR(IDirectDrawStreamSample_Update(*ppVideoSource, SSUPDATE_ASYNC | SSUPDATE_CONTINUOUS, NULL, NULL, 0));


Exit:
    RELEASE(pAMStream);
    RELEASE(pVideoStream);
    RELEASE(pDDVideoStream);
    RELEASE(pSurface);
    RELEASE(pMoniker);
    RELEASE(pPalette);
    RELEASE(pCtx);

    return hr == S_OK ? TRUE : FALSE;
}


BOOL DisplayVideoSource(IDirectDrawStreamSample *pVideoSource)
{
    if (pVideoSource) {
	RECT        rc;
	IDirectDrawSurface *pSurface;

	HRESULT CompStatus = IDirectDrawStreamSample_CompletionStatus(pVideoSource, COMPSTAT_NOUPDATEOK | COMPSTAT_WAIT, INFINITE);

	if (SUCCEEDED(CompStatus)) {
	    HRESULT hr = IDirectDrawStreamSample_GetSurface(pVideoSource, &pSurface, &rc);
	    if (hr == S_OK) {
		IDirectDrawSurface_BltFast(lpBackBuffer, 240, 180,
					   pSurface, &rc, DDBLTFAST_SRCCOLORKEY | DDBLTFAST_WAIT);
		IDirectDrawSurface_Release(pSurface);
	    }
	}

	if (CompStatus == MS_S_ENDOFSTREAM) {
	    IMediaStream *pStream;
	    IMultiMediaStream *pMMStream;
	    IDirectDrawStreamSample_GetMediaStream(pVideoSource, &pStream);
	    IMediaStream_GetMultiMediaStream(pStream, &pMMStream);
	    IMultiMediaStream_Seek(pMMStream, 0);
	    IMediaStream_Release(pStream);
	    IMultiMediaStream_Release(pMMStream);
	}
	IDirectDrawStreamSample_Update(pVideoSource, SSUPDATE_ASYNC | SSUPDATE_CONTINUOUS, NULL, NULL, 0);
	return TRUE;
    } else {
	return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\idl\makefile.inc ===
$(ROOT)\sdk\lib\amstrmid.lib: $(ROOT)\lib$(BUILD_ALT_DIR)\$(TARGET_DIRECTORY)\$(@F)
    copy $** $@

$(SDK_LIB_PATH)\amstrmid.lib: $(ROOT)\lib$(BUILD_ALT_DIR)\$(TARGET_DIRECTORY)\$(@F)
    copy $** $@

$(SDK_INC_PATH)\mmstream.h : $(PASS0_HEADERDIR)\mmstream.h
    copy /v $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\vidsrc.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#ifndef __VIDSRC_INCLUDED__
#define __VIDSRC_INCLUDED__

BOOL CreateVideoSource(IDirectDrawStreamSample **ppVideoSource, WCHAR * szFileName);
BOOL DisplayVideoSource(IDirectDrawStreamSample *pVideoSource);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\foxbear\tile.c ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
 *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved.
 *
 *  File:       tile.c
 *  Content:    tile loading and initialization functions
 *
 ***************************************************************************/
#include "foxbear.h"

/*
 * CreateTiles
 */
HBITMAPLIST *CreateTiles( HBITMAPLIST *phBitmapList, USHORT n )
{
    HBITMAPLIST *hTileList;
    USHORT       i;

    hTileList = CMemAlloc( n, sizeof (HBITMAPLIST) );

    if( hTileList == NULL )
    {
        ErrorMessage( "hTileList in CreateTiles" );
    }

    for( i = 0; i < n; ++i )
    {
        hTileList[i].hBM = phBitmapList[i].hBM;
    }
    return hTileList;

} /* CreateTiles */

/*
 * DestroyTiles
 */
BOOL DestroyTiles( HBITMAPLIST *phTileList )
{
    MemFree( phTileList );

    return TRUE;

} /* DestroyTiles */

/*
 * getData
 */
LPSTR getData(LPSTR fileName)
{
    LPSTR       p = NULL;
    HRSRC       hRes;

    hRes = FindResource(NULL, fileName, RT_RCDATA);

    if( hRes != NULL )
    {
        p = LockResource(LoadResource(NULL, hRes));
    }

    return p;

} /* getData */

/*
 * CreatePosList
 */
HPOSLIST *CreatePosList( LPSTR fileName, USHORT width, USHORT height )
{
    HPOSLIST    *hPosList;
    USHORT      pos;
    LPSTR       p;

    p = getData( fileName );

    if( p == NULL )
    {
        ErrorMessage( "p in CreatePosList" );
    }

    hPosList = CMemAlloc( width * height, sizeof (USHORT) );

    if( hPosList == NULL )
    {
        ErrorMessage( "posList in CreatePosList" );
    }

    for( pos = 0; pos < width * height; ++pos )
    {
        hPosList[pos] = (USHORT) getint(&p, 0) - 1;
    }

    return hPosList;

} /* CreatePosList */

/*
 * CreateSurfaceList
 */
HSURFACELIST *CreateSurfaceList( LPSTR fileName, USHORT width, USHORT height )
{
    HSURFACELIST        *hSurfaceList;
    USHORT              pos;
    USHORT              value;
    LPSTR               p;

    p = getData( fileName );

    if( p == NULL )
    {
        ErrorMessage( "p in CreateSurfaceList" );
    }

    hSurfaceList = CMemAlloc( width * height, sizeof (HSURFACELIST) );

    if( hSurfaceList == NULL )
    {
        ErrorMessage( "posList in CreateSurfaceList" );
    }

    for( pos = 0; pos < width * height; ++pos )
    {
        value = (USHORT) getint(&p, 0);

        if( value == 0 )
        {
            hSurfaceList[pos] = FALSE;
        }
        else
        {
            hSurfaceList[pos] = TRUE;
        }
    }

    return hSurfaceList;

} /* CreateSurfaceList */

/*
 * DestoryPosList
 */
BOOL DestroyPosList ( HPOSLIST *posList )
{
    if( posList == NULL )
    {
        ErrorMessage( "posList in DestroyPosList" );
    }

    MemFree( posList );
    return TRUE;

} /* DestroyPosList */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\idl\uuids.c ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.
//
// this file is compiled to contain the definitions of the standard
// media type GUIDs, and wellknown class ids.

#include <windows.h>
#include <ddraw.h>

#include <amstream_i.c>
#include <mmstream_i.c>
#include <ddstream_i.c>
#include <austream_i.c>
#include <initguid.h>   // forces definition instead of declaration
#include <amstream.h>

// -- that's it ---
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\strmobjs\resource.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by strmobjs.rc
//
#define IDS_PROJNAME                    100
#define IDR_SFILTER                     101
#define IDR_MMSTREAM                    102
#define IDR_STREAM                      103
#define IDR_AUDIOSTREAM                 104
#define IDR_AUDIODATA                   105
#define IDR_MTSTREAM                    106

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\strmobjs\amguids.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#ifndef _AMGUIDS_H_
#define _AMGUIDS_H_
DEFINE_GUID( CLSID_MediaStreamFilter, /* 49c47ce0-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47ce0,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
#if 0
DEFINE_GUID( , /* 49c47ce6-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47ce6,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47ce7-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47ce7,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47ce8-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47ce8,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47ce9-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47ce9,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cea-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cea,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47ceb-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47ceb,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cec-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cec,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47ced-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47ced,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cee-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cee,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cef-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cef,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf0-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf0,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf1-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf1,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf2-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf2,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf3-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf3,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf4-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf4,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf5-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf5,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf6-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf6,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf7-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf7,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf8-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf8,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf9-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf9,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cfa-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cfa,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cfb-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cfb,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cfc-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cfc,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cfd-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cfd,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cfe-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cfe,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cff-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cff,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d00-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d00,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d01-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d01,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d02-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d02,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d03-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d03,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d04-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d04,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d05-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d05,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d06-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d06,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d07-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d07,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d08-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d08,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d09-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d09,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d0a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d0a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d0b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d0b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d0c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d0c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d0d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d0d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d0e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d0e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d0f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d0f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d10-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d10,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d11-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d11,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d12-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d12,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d13-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d13,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d14-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d14,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d15-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d15,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d16-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d16,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d17-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d17,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d18-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d18,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d19-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d19,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d1a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d1a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d1b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d1b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d1c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d1c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d1d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d1d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d1e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d1e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d1f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d1f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d20-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d20,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d21-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d21,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d22-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d22,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d23-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d23,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d24-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d24,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d25-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d25,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d26-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d26,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d27-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d27,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d28-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d28,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d29-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d29,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d2a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d2a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d2b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d2b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d2c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d2c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d2d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d2d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d2e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d2e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d2f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d2f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d30-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d30,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d31-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d31,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d32-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d32,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d33-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d33,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d34-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d34,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d35-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d35,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d36-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d36,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d37-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d37,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d38-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d38,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d39-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d39,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d3a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d3a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d3b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d3b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d3c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d3c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d3d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d3d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d3e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d3e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d3f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d3f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d40-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d40,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d41-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d41,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d42-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d42,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d43-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d43,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d44-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d44,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d45-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d45,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d46-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d46,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d47-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d47,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d48-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d48,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d49-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d49,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d4a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d4a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d4b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d4b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d4c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d4c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d4d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d4d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d4e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d4e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d4f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d4f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d50-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d50,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d51-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d51,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d52-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d52,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d53-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d53,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d54-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d54,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d55-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d55,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d56-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d56,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d57-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d57,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d58-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d58,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d59-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d59,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d5a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d5a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d5b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d5b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d5c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d5c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d5d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d5d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d5e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d5e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d5f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d5f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d60-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d60,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d61-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d61,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d62-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d62,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d63-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d63,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d64-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d64,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d65-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d65,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d66-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d66,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d67-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d67,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d68-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d68,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d69-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d69,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d6a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d6a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d6b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d6b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d6c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d6c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d6d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d6d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d6e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d6e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d6f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d6f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d70-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d70,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d71-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d71,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d72-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d72,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d73-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d73,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d74-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d74,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d75-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d75,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d76-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d76,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d77-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d77,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d78-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d78,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d79-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d79,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d7a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d7a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d7b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d7b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d7c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d7c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d7d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d7d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d7e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d7e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d7f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d7f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d80-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d80,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d81-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d81,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d82-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d82,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d83-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d83,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d84-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d84,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d85-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d85,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d86-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d86,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d87-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d87,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d88-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d88,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d89-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d89,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d8a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d8a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d8b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d8b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d8c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d8c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d8d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d8d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d8e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d8e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d8f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d8f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d90-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d90,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d91-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d91,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d92-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d92,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d93-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d93,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d94-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d94,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d95-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d95,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d96-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d96,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d97-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d97,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d98-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d98,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d99-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d99,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d9a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d9a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d9b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d9b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d9c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d9c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d9d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d9d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d9e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d9e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d9f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d9f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47da0-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47da0,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47da1-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47da1,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47da2-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47da2,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47da3-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47da3,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47da4-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47da4,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47da5-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47da5,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47da6-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47da6,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47da7-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47da7,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
 #endif

#endif // _AMGUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\raltest\main.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#define INIT_GUID
#define INTTGUIDS
#define INITGUID
#define INIT_GUIDS
#include <windows.h>
#include <stdio.h>
#include "ddraw.h"
#include "mmstream.h"
#include "amstream.h"
#include "ddstream.h"


#define RELEASE(x) if (x) (x)->Release();
#define CHECK_ERROR(x) if (FAILED(hr = (x))) goto Exit;


HRESULT RenderFileToMMStream(const char * pszFileName, IMultiMediaStream **ppMMStream, IDirectDraw *pDD)
{
    *ppMMStream = NULL;
    IAMMultiMediaStream *pAMStream;
    HRESULT hr;

    CHECK_ERROR(CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER,
                                 IID_IAMMultiMediaStream, (void **)&pAMStream));
    CHECK_ERROR(pAMStream->Initialize(STREAMTYPE_READ, NULL));
    CHECK_ERROR(pAMStream->AddMediaStream(pDD, MSPID_PrimaryVideo, 0, NULL));
    CHECK_ERROR(pAMStream->AddMediaStream(NULL, MSPID_PrimaryAudio, AMMSF_ADDDEFAULTRENDERER, NULL));

    WCHAR	wPath[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, pszFileName, -1, wPath, sizeof(wPath)/sizeof(wPath[0]));

    CHECK_ERROR(pAMStream->OpenFile(wPath, 0));
//    CHECK_ERROR(pAMStream->SetState(STREAMSTATE_RUN));

    *ppMMStream = pAMStream;
    pAMStream->AddRef();

Exit:
    RELEASE(pAMStream);
    return hr;
}




HRESULT RenderStreamToSurface(IDirectDraw *pDD, IDirectDrawSurface *pPrimary, IMultiMediaStream *pMMStream)
{

    HRESULT hr;
    IMediaStream *pPrimaryVidStream = NULL;
    IDirectDrawMediaStream *pDDStream = NULL;
    IDirectDrawSurface *pSurface = NULL;
    IDirectDrawStreamSample *pSample = NULL;

    CHECK_ERROR(pMMStream->GetMediaStream(MSPID_PrimaryVideo, &pPrimaryVidStream));
    CHECK_ERROR(pPrimaryVidStream->QueryInterface(IID_IDirectDrawMediaStream, (void **)&pDDStream));
    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);

    CHECK_ERROR(pDDStream->GetFormat(&ddsd, NULL, NULL));
    RECT rect;
    rect.top = rect.left = 0;
    rect.bottom = ddsd.dwHeight;
    rect.right = ddsd.dwWidth;

    CHECK_ERROR(pDD->CreateSurface(&ddsd, &pSurface, NULL));

    CHECK_ERROR(pDDStream->CreateSample(pSurface, NULL, 0, &pSample));
    
    while (true) {
        if (pSample->Update(0, NULL, NULL, 0) != S_OK) {
            break;
        }
        pPrimary->Blt(&rect, pSurface, &rect, DDBLT_WAIT, NULL);
    }

Exit:
    RELEASE(pPrimaryVidStream);
    RELEASE(pDDStream);
    RELEASE(pSample);
    RELEASE(pSurface);

    return hr;
}


int _CRTAPI1
main(
    int argc,
    char *argv[]
    )
{
    if (argc < 2) {
        printf("Usage : mmtest foo.bar\n");
        exit(0);
    }
    CoInitialize(NULL);
    IDirectDraw *pDD;

    HRESULT hr = DirectDrawCreate(NULL, &pDD, NULL);
    if (SUCCEEDED(hr)) {
    	DDSURFACEDESC ddsd;
    	IDirectDrawSurface *pPrimarySurface;

    	pDD->SetCooperativeLevel(GetDesktopWindow(), DDSCL_NORMAL);

    	ddsd.dwSize = sizeof(ddsd);
    	ddsd.dwFlags = DDSD_CAPS;
    	ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
    	hr = pDD->CreateSurface(&ddsd, &pPrimarySurface, NULL);
    	if (SUCCEEDED(hr)) {
            IMultiMediaStream *pMMStream;
            hr = RenderFileToMMStream(argv[1], &pMMStream, pDD);
            if (SUCCEEDED(hr)) {
                RenderStreamToSurface(pDD, pPrimarySurface, pMMStream);
                pMMStream->Release();
            }
    	    pPrimarySurface->Release();
    	}
    	pDD->Release();
    }
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\simple\main.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include <windows.h>
#include <stdio.h>
#include "ddraw.h"
#include "mmstream.h"
#include "amstream.h"
#include "ddstream.h"


#define RELEASE(x) if (x) (x)->Release();
#define CHECK_ERROR(x)     \
   if (FAILED(hr = (x))) { \
       printf(#x "  failed with HRESULT(0x%8.8X)\n", hr); \
       goto Exit;          \
   }


HRESULT OpenMMStream(const char * pszFileName, IDirectDraw *pDD, IMultiMediaStream **ppMMStream)
{
    *ppMMStream = NULL;
    IAMMultiMediaStream *pAMStream;
    HRESULT hr;

    CHECK_ERROR(CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER,
				 IID_IAMMultiMediaStream, (void **)&pAMStream));
    CHECK_ERROR(pAMStream->Initialize(STREAMTYPE_READ, 0, NULL));
    CHECK_ERROR(pAMStream->AddMediaStream(pDD, &MSPID_PrimaryVideo, 0, NULL));
    CHECK_ERROR(pAMStream->AddMediaStream(NULL, &MSPID_PrimaryAudio, AMMSF_ADDDEFAULTRENDERER, NULL));

    WCHAR       wPath[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, pszFileName, -1, wPath, sizeof(wPath)/sizeof(wPath[0]));

    CHECK_ERROR(pAMStream->OpenFile(wPath, 0));

    *ppMMStream = pAMStream;
    pAMStream->AddRef();

Exit:
    if (pAMStream == NULL) {
	printf("Could not create a CLSID_MultiMediaStream object\n"
	       "Check you have run regsvr32 amstream.dll\n");
    }
    RELEASE(pAMStream);
    return hr;
}




HRESULT RenderStreamToSurface(IDirectDraw *pDD, IDirectDrawSurface *pPrimary,
			      IMultiMediaStream *pMMStream)
{

    HRESULT hr;
    IMediaStream *pPrimaryVidStream = NULL;
    IDirectDrawMediaStream *pDDStream = NULL;
    IDirectDrawSurface *pSurface = NULL;
    IDirectDrawStreamSample *pSample = NULL;

    RECT rect;

    CHECK_ERROR(pMMStream->GetMediaStream(MSPID_PrimaryVideo, &pPrimaryVidStream));
    CHECK_ERROR(pPrimaryVidStream->QueryInterface(IID_IDirectDrawMediaStream, (void **)&pDDStream));

    CHECK_ERROR(pDDStream->CreateSample(NULL, NULL, 0, &pSample));
    CHECK_ERROR(pSample->GetSurface(&pSurface, &rect));
    
    CHECK_ERROR(pMMStream->SetState(STREAMSTATE_RUN));

    while (true) {
	if (pSample->Update(0, NULL, NULL, 0) != S_OK) {
	    break;
	}
	pPrimary->Blt(&rect, pSurface, &rect, DDBLT_WAIT, NULL);
    }

Exit:
    RELEASE(pPrimaryVidStream);
    RELEASE(pDDStream);
    RELEASE(pSample);
    RELEASE(pSurface);

    return hr;
}


int _CRTAPI1
main(
    int argc,
    char *argv[]
    )
{
    if (argc < 2) {
	printf("Usage : simple movie.ext\n");
	exit(0);
    }
    CoInitialize(NULL);
    IDirectDraw *pDD;

    HRESULT hr = DirectDrawCreate(NULL, &pDD, NULL);
    if (SUCCEEDED(hr)) {
	DDSURFACEDESC ddsd;
	IDirectDrawSurface *pPrimarySurface;

	pDD->SetCooperativeLevel(GetDesktopWindow(), DDSCL_NORMAL);

	ddsd.dwSize = sizeof(ddsd);
	ddsd.dwFlags = DDSD_CAPS;
	ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
	hr = pDD->CreateSurface(&ddsd, &pPrimarySurface, NULL);
	if (SUCCEEDED(hr)) {
	    IMultiMediaStream *pMMStream;
	    hr = OpenMMStream(argv[1], pDD, &pMMStream);
	    if (SUCCEEDED(hr)) {
		RenderStreamToSurface(pDD, pPrimarySurface, pMMStream);
		pMMStream->Release();
	    }
	    pPrimarySurface->Release();
	}
	pDD->Release();
    } else {
	printf("Could not open DirectDraw - check it is installed\n");
    }
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\strmobjs\ammstrm.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// MMStream.h : Declaration of the CMMStream

#ifndef __AMMSTRM_H_
#define __AMMSTRM_H_

#define _DEBUG 1
#include "resource.h"       // main symbols
#include "atlctl.h"

/////////////////////////////////////////////////////////////////////////////
// CMMStream
class ATL_NO_VTABLE CMMStream :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMMStream, &CLSID_AMMultiMediaStream>,
	public IAMMultiMediaStream,
        public IDispatchImpl<IDirectShowStream, &IID_IDirectShowStream, &LIBID_DirectShowStreamLib>,
        public IPersistPropertyBag,
        public IObjectSafety,
        public IAMClockAdjust
{
public:
	typedef CComObjectRootEx<CComMultiThreadModel> _BaseClass;
	CMMStream();
	HRESULT FinalConstruct();
        ULONG InternalRelease()
        {
            return CComObjectRootEx<CComMultiThreadModel>::InternalRelease();
        }

public:

DECLARE_GET_CONTROLLING_UNKNOWN()
DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_REGISTRY_RESOURCEID(IDR_MMSTREAM)

BEGIN_COM_MAP(CMMStream)
        COM_INTERFACE_ENTRY2(IMultiMediaStream, IAMMediaStream)
	COM_INTERFACE_ENTRY(IAMMultiMediaStream)
        COM_INTERFACE_ENTRY2(IMultiMediaStream, IAMMultiMediaStream)
        COM_INTERFACE_ENTRY(IDirectShowStream)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IPersistPropertyBag)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY(IAMClockAdjust)
END_COM_MAP()


        //  IAMMMStream
        STDMETHODIMP Initialize(
           STREAM_TYPE StreamType,
           DWORD dwFlags,
           IGraphBuilder *pFilterGraph
        );

        STDMETHODIMP GetFilterGraph(
            IGraphBuilder **ppGraphBuilder
        );

        STDMETHODIMP GetFilter(
           IMediaStreamFilter **ppFilter
        );

        STDMETHODIMP AddMediaStream(
           IUnknown *pStreamObject,
           const MSPID *pOptionalPurposeId,
           DWORD dwFlags,
           IMediaStream **ppNewStream
        );

        STDMETHODIMP OpenFile(
           LPCWSTR pszFileName,
           DWORD dwFlags
        );

        STDMETHODIMP OpenMoniker(
           IBindCtx *pCtx,
           IMoniker *pMoniker,
           DWORD dwFlags
        );

        STDMETHODIMP Render(
           DWORD dwFlags
        );

        // IMultiMediaStream

        STDMETHODIMP GetInformation(
           DWORD *pdwFlags,
           STREAM_TYPE *pStreamType
        );

        STDMETHODIMP GetMediaStream(
           REFMSPID idPurpose,
           IMediaStream **ppMediaStream
        );

        STDMETHODIMP EnumMediaStreams(
           long Index,
           IMediaStream **ppMediaStream
        );

        STDMETHODIMP GetState(
            STREAM_STATE *pCurrentState
        );

        STDMETHODIMP SetState(
           STREAM_STATE NewState
        );

        STDMETHODIMP GetTime(
           STREAM_TIME *pCurrentTime
        );

        STDMETHODIMP GetDuration(
           STREAM_TIME *pDuration
        );

        STDMETHODIMP Seek(
           STREAM_TIME SeekTime
        );

        STDMETHODIMP GetEndOfStreamEventHandle(
            HANDLE *phEOS
        );


        //   IAMClockAdjust
        STDMETHODIMP SetClockDelta(REFERENCE_TIME rtAdjust);

        //
        //   IDirectShowStream
        //
        STDMETHODIMP get_FileName(BSTR *pVal);
        STDMETHODIMP put_FileName(BSTR newVal);
        STDMETHODIMP get_Video(OUTPUT_STATE *pVal);
        STDMETHODIMP put_Video(OUTPUT_STATE newVal);
        STDMETHODIMP get_Audio(OUTPUT_STATE *pVal);
        STDMETHODIMP put_Audio(OUTPUT_STATE newVal);


        //
        //  IPersistPropertyBag
        //
        STDMETHODIMP GetClassID(CLSID *pClsId);
        STDMETHODIMP InitNew(void);
        STDMETHODIMP Load(IPropertyBag* pPropBag, IErrorLog* pErrorLog);
        STDMETHODIMP Save(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);


        //
	// IObjectSafety
	//
	STDMETHODIMP GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
	STDMETHODIMP SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);

private:
       HRESULT SetStreamState(REFMSPID, OUTPUT_STATE, OUTPUT_STATE *);
       HRESULT CompleteOpen(IBaseFilter *pSource, DWORD dwFlags);
       HRESULT AddFilter(REFCLSID clsidFilter, IBaseFilter **ppFilter);
       HRESULT AddDefaultRenderer(REFMSPID PurposeId, DWORD dwFlags, IMediaStream **ppNewStream);
       HRESULT AddAMMediaStream(IAMMediaStream *pAMStream, REFMSPID PurposeId, IMediaStream **ppNewStream);
       HRESULT AddDefaultStream(
                 IUnknown *pStreamObject,
                 DWORD dwFlags,
                 REFMSPID PurposeId,
                 IMediaStream **ppNewStream);
       HRESULT GetClsidFromPurposeid(REFMSPID PurposeId, bool bRenderer, CLSID * pclsid);
       void CompleteAddGraph();
       HRESULT CheckGraph();
       void SetSeeking();

   private:

       /*  Be careful of the ordering here
           The first one we declare will be released last
       */

       /*  Can't release this in the constructor because this
           is what holds the object in place
       */
       CComPtr<IGraphBuilder>      m_pGraphBuilder;
       CComPtr<IMediaSeeking>      m_pMediaSeeking;
       CComPtr<IMediaControl>      m_pMediaControl;

       CComPtr<IMediaStreamFilter> m_pMediaStreamFilter;
       CComPtr<IBaseFilter>        m_pBaseFilter;

       /*  Type of stream we've been initialized to */
       STREAM_TYPE                  m_StreamType;
       DWORD                        m_dwInitializeFlags;
       bool                         m_StreamTypeSet;
       bool                         m_bSeekingSet;
       OUTPUT_STATE                 m_VideoState;
       OUTPUT_STATE                 m_AudioState;
       CComBSTR                     m_bstrFileName;

       DWORD                        m_dwIDispSafety;
       DWORD                        m_dwIPropBagSafety;

       /*  List of default filters added */
       CDynamicArray<IBaseFilter *, CComPtr<IBaseFilter> > m_FilterList;

       /*  End of stream handle */
       HANDLE                       m_hEOS;
       STREAM_STATE                 m_MMStreamState;
};


#endif //__AMMSTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\strmobjs\sfilter.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// SFilter.cpp : Implementation of CMediaStreamFilter
#include "stdafx.h"
#include "strmobjs.h"
#include <amstream.h>
#include <strmif.h>
#include <control.h>
#include <uuids.h>
#include <evcode.h>
#include <vfwmsgs.h>
#include <amutil.h>
#include "amguids.h"
#include "SFilter.h"


//
//   Note on locking of the filter
//
//   The whole object lock is always acquired before the callback
//   lock (m_csCallback) if it is acquired at all.  This 2 level
//   scheme is to prevent deadlocks when the streams call the filter
//   back for:
//
//       Flush
//       EndOfStream
//       WaitUntil
//       GetCurrentStreamTime
//
//   State changes, changes to the list of pins are protected by
//   the whole object lock
//
//   The clock, alarmlist, end of stream and flushing
//   member variables are protected by m_csCallback
//



CAlarm::CAlarm() :
    m_pNext(NULL),
    m_hEvent(NULL),
    m_bKilled(false)
{
}

CAlarm::~CAlarm()
{
    if (m_hEvent) {
        CloseHandle(m_hEvent);
    }
}

HRESULT CAlarm::CreateNewAlarm(CAlarm **ppNewEvent)
{
    *ppNewEvent = NULL;
    CAlarm *pNew = new CAlarm();
    if (pNew) {
        pNew->m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (pNew->m_hEvent) {
            *ppNewEvent = pNew;
            return S_OK;
        }
        delete pNew;
    }
    return E_OUTOFMEMORY;
}


/////////////////////////////////////////////////////////////////////////////
// CMediaStreamFilter



/* Constructor */

CMediaStreamFilter::CMediaStreamFilter() :
    m_State(State_Stopped),
    m_pGraph(NULL),
    m_pUnknownSeekAgg(NULL),
    m_rtStart(0),
    m_pFirstFreeAlarm(NULL),
    m_pFirstActiveAlarm(NULL),
    m_nAtEOS(0)
{
}


void CMediaStreamFilter::FinalRelease()
{
    if (m_pUnknownSeekAgg) {
        m_pUnknownSeekAgg->Release();
    }
    _ASSERTE(m_pFirstActiveAlarm == NULL);
    CAlarm *pCurAlarm = m_pFirstFreeAlarm;
    while (pCurAlarm) {
        CAlarm *pNext = pCurAlarm->m_pNext;
        delete pCurAlarm;
        pCurAlarm = pNext;
    }
}

//// IPERSIST

STDMETHODIMP CMediaStreamFilter::GetClassID(CLSID *pClsID)
{
    *pClsID = GetObjectCLSID();
    return NOERROR;
}



/////////////// IBASEFILTER

HRESULT CMediaStreamFilter::SyncSetState(FILTER_STATE State)
{
    AUTO_CRIT_LOCK;
    if (State == m_State) {
        return S_OK;
    }
    const FILTER_STATE fsOld = m_State;
    m_State = State;
    //
    //  We want to stop the streams first so that they will decommit their allocators BEFORE
    //  we kill the timers, which could wake them up out of a GetBuffer call.
    //
    for (int i = 0; i < m_Streams.Size(); i++) {
        m_Streams.Element(i)->SetState(State);
    }
    if (State == State_Stopped) {
        m_nAtEOS = 0;
        FlushTimers();
    } else {
        CheckComplete();
    }
    return S_OK;
}

STDMETHODIMP CMediaStreamFilter::Stop()
{
    return SyncSetState(State_Stopped);
}

STDMETHODIMP CMediaStreamFilter::Pause()
{
    return SyncSetState(State_Paused);
}

STDMETHODIMP CMediaStreamFilter::Run(REFERENCE_TIME tStart)
{
    AUTO_CRIT_LOCK;
    m_rtStart = tStart;
    return SyncSetState(State_Running);
}

STDMETHODIMP CMediaStreamFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    *State = m_State;
    if (m_State == State_Paused) {

        //  Since we don't sending data until we're running for write
        //  streams just say we can't cue
        if (m_Streams.Size() != 0) {
            STREAM_TYPE Type;
            m_Streams.Element(0)->GetInformation(NULL, &Type);
            if (Type == STREAMTYPE_WRITE) {
                return VFW_S_CANT_CUE;
            }
        }
    }
    return S_OK;
}

STDMETHODIMP CMediaStreamFilter::SetSyncSource(IReferenceClock *pClock)
{
    CAutoLock lck(&m_csCallback);
    m_pClock = pClock;
    return NOERROR;
}

STDMETHODIMP CMediaStreamFilter::GetSyncSource(IReferenceClock **pClock)
{
    CAutoLock lck(&m_csCallback);
    if (m_pClock) {
        m_pClock->AddRef();
    }
    *pClock = m_pClock;
    return NOERROR;
}

STDMETHODIMP CMediaStreamFilter::EnumPins(IEnumPins ** ppEnum)
{
    if (ppEnum == NULL) {
        return E_POINTER;
    }
    *ppEnum = NULL;

    /* Create a new ref counted enumerator */

    typedef CComObject<CAMEnumInterface<IEnumPins,
                                        &IID_IEnumPins,
                                        IPin
                                       >
                      > _CEnumPins;

    _CEnumPins *pEnum = new _CEnumPins;
    if (pEnum == NULL) {
        return E_OUTOFMEMORY;
    }
    HRESULT hr = pEnum->FinalConstruct();
    if (SUCCEEDED(hr)) {
        for (int i = 0; i < m_Streams.Size(); i++) {
            if (!pEnum->Add((PPIN)CComQIPtr<IPin, &IID_IPin>(m_Streams.Element(i)))) {
                delete pEnum;
                return E_OUTOFMEMORY;
            }
        }
    } else {
        delete pEnum;
        return hr;
    }

    return pEnum->QueryInterface(IID_IEnumPins, (void **)ppEnum);
}

STDMETHODIMP CMediaStreamFilter::FindPin(LPCWSTR Id, IPin ** ppPin)
{
    if (ppPin == NULL) {
        return E_POINTER;
    }

    AUTO_CRIT_LOCK;
    IEnumPins *pEnum;
    HRESULT hr = EnumPins(&pEnum);
    if (FAILED(hr)) {
        return hr;
    }
    IPin *pPin;
    hr = VFW_E_NOT_FOUND;
    for ( ; ; ) {
        ULONG cFetched;
        if (S_OK != pEnum->Next(1, &pPin, &cFetched)) {
            break;
        }
        LPWSTR lpszId;
        if (SUCCEEDED(pPin->QueryId(&lpszId))) {
            if (0 == lstrcmpW(lpszId, Id)) {
                *ppPin = pPin;
                CoTaskMemFree(lpszId);
                hr = S_OK;
                break;
            }
            CoTaskMemFree(lpszId);
        }
        pPin->Release();
    }
    pEnum->Release();
    return hr;
}


STDMETHODIMP CMediaStreamFilter::QueryFilterInfo(FILTER_INFO * pInfo)
{
    AUTO_CRIT_LOCK;
    pInfo->achName[0] = L'\0';
    pInfo->pGraph = m_pGraph;
    if (pInfo->pGraph) {
        pInfo->pGraph->AddRef();
    }
    return NOERROR;
}

STDMETHODIMP CMediaStreamFilter::JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName)
{
    AUTO_CRIT_LOCK;
    m_pGraph = pGraph;
    for (int i = 0; i < m_Streams.Size(); i++) {
        //  This will not fail
        m_Streams.Element(i)->JoinFilterGraph(pGraph);
    }
    return NOERROR;
}



///////// IMediaStreamFILTER ///////////////


STDMETHODIMP CMediaStreamFilter::AddMediaStream(IAMMediaStream *pAMMediaStream)
{
    AUTO_CRIT_LOCK;
    IMediaStream *pMediaStream;
    HRESULT hr = pAMMediaStream->QueryInterface(
        IID_IMediaStream, (void **)&pMediaStream);
    if (FAILED(hr)) {
        return hr;
    }
    MSPID PurposeID;
    EXECUTE_ASSERT(SUCCEEDED(pMediaStream->GetInformation(&PurposeID, NULL)));
    IMediaStream *pStreamTemp;

    //  Note - this test covers the case of being passed the same object
    //  twice if you think about it
    if (S_OK == GetMediaStream(PurposeID, &pStreamTemp)) {
        pStreamTemp->Release();
        return MS_E_PURPOSEID;
    }
    pMediaStream->Release();

    hr = pAMMediaStream->JoinFilter(this);
    if (SUCCEEDED(hr)) {
        hr = pAMMediaStream->JoinFilterGraph(m_pGraph);
        if (SUCCEEDED(hr)) {
            /*  Add() will Addref through the copy constructor
                of CComPtr
            */
            if (!m_Streams.Add(pAMMediaStream)) {
                pAMMediaStream->JoinFilterGraph(NULL);
                pAMMediaStream->JoinFilter(NULL);
                hr = E_OUTOFMEMORY;
            }
        } else {
            pAMMediaStream->JoinFilter(NULL);
        }
    }
    return hr;
}

STDMETHODIMP CMediaStreamFilter::EnumMediaStreams(
    long lIndex,
    IMediaStream **ppMediaStream
)
{
    AUTO_CRIT_LOCK;
    if (lIndex < 0 || lIndex >= m_Streams.Size()) {
        return S_FALSE;
    }
    return m_Streams.Element(lIndex)->QueryInterface(
        IID_IMediaStream,
        (void **)ppMediaStream);
}
STDMETHODIMP CMediaStreamFilter::GetMediaStream(REFGUID PurposeId, IMediaStream ** ppMediaStream)
{
    AUTO_CRIT_LOCK;
    if (ppMediaStream == NULL) {
        return E_POINTER;
    }
    int i = 0;
    HRESULT hr = MS_E_NOSTREAM;
    while (i < m_Streams.Size()) { // Does not addref!!!
        IMediaStream *pStream;
        GUID ThisPurpose;
        EXECUTE_ASSERT(SUCCEEDED(m_Streams.Element(i)->
            QueryInterface(IID_IMediaStream, (void **)&pStream)));
        EXECUTE_ASSERT(SUCCEEDED(pStream->GetInformation(&ThisPurpose, NULL)));
        if (ThisPurpose == PurposeId) {
            *ppMediaStream = pStream;
            hr = S_OK;
            break;
        } else {
            pStream->Release();
        }
        i++;
    }
    return hr;
}

STDMETHODIMP CMediaStreamFilter::SupportSeeking(BOOL fRenderer)
{
    // Look for a stream that supports seeking
    HRESULT hrResult = E_NOINTERFACE;
    if (m_pUnknownSeekAgg != NULL) {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }
    for (int i = 0; FAILED(hrResult) && i < m_Streams.Size(); i++) {
        IAMMediaStream *pAMMediaStream = m_Streams.Element(i);
        IPin *pPin;
        HRESULT hr = pAMMediaStream->QueryInterface(IID_IPin, (void **)&pPin);
        if (SUCCEEDED(hr)) {

            //  See if it supports GetDuration() so we get a real
            //  seeking pin
            IPin *pConnected;
            hr = pPin->ConnectedTo(&pConnected);
            if (SUCCEEDED(hr)) {
                IMediaSeeking *pSeeking;
                hr = pConnected->QueryInterface(IID_IMediaSeeking, (void **)&pSeeking);
                if (SUCCEEDED(hr)) {
                    LONGLONG llDuration;
                    if (S_OK != pSeeking->GetDuration(&llDuration)) {
                        hr = E_FAIL;
                    }
                    pSeeking->Release();
                }
                pConnected->Release();
            }
            if (SUCCEEDED(hr)) {
                hr = CoCreateInstance(CLSID_SeekingPassThru, GetControllingUnknown(), CLSCTX_INPROC_SERVER, IID_IUnknown,
                                      (void **)&m_pUnknownSeekAgg);
            }
            if (SUCCEEDED(hr)) {
                ISeekingPassThru *pSeekingPassThru;
                hr = m_pUnknownSeekAgg->QueryInterface(IID_ISeekingPassThru, (void **)&pSeekingPassThru);
                if (SUCCEEDED(hr)) {
                    hrResult = pSeekingPassThru->Init(fRenderer, pPin);
                    pSeekingPassThru->Release();
                } else {
                    m_pUnknownSeekAgg->Release();
                    m_pUnknownSeekAgg = NULL;
                }
            }
            pPin->Release();
        }
    }
    return hrResult;

}


STDMETHODIMP CMediaStreamFilter::ReferenceTimeToStreamTime(REFERENCE_TIME *pTime)
{
    CAutoLock lck(&m_csCallback);
    if (m_pClock) {
        *pTime -= m_rtStart;
        return S_OK;
    } else {
        return S_FALSE;
    }
}

STDMETHODIMP CMediaStreamFilter::GetCurrentStreamTime(REFERENCE_TIME *pCurrentStreamTime)
{
    CAutoLock lck(&m_csCallback);
    if (m_pClock && m_State == State_Running) {
        m_pClock->GetTime(pCurrentStreamTime);
        *pCurrentStreamTime -= m_rtStart;
        return S_OK;
    } else {
        *pCurrentStreamTime = 0;
        return S_FALSE;
    }
}


STDMETHODIMP CMediaStreamFilter::WaitUntil(REFERENCE_TIME WaitTime)
{
    HRESULT hr;

    //  OK to lock here because the caller should not lock during a wait
    m_csCallback.Lock();
    if (!m_pClock) {
        hr = E_FAIL;
    } else {
        if (!m_pFirstFreeAlarm) {
            hr = CAlarm::CreateNewAlarm(&m_pFirstFreeAlarm);
            if (FAILED(hr)) {
                m_csCallback.Unlock();
                return hr;
            }
        }
        CAlarm *pAlarm = m_pFirstFreeAlarm;
        ResetEvent(pAlarm->m_hEvent);
        hr = m_pClock->AdviseTime(WaitTime, m_rtStart, (HEVENT)pAlarm->m_hEvent, &pAlarm->m_dwStupidCookie);
        if (SUCCEEDED(hr)) {
            m_pFirstFreeAlarm = pAlarm->m_pNext;
            pAlarm->m_bKilled = false;
            pAlarm->m_pNext = m_pFirstActiveAlarm;
            m_pFirstActiveAlarm = pAlarm;
            m_csCallback.Unlock();
            WaitForSingleObject(pAlarm->m_hEvent, INFINITE);
            m_csCallback.Lock();
            CAlarm **ppCurrent = &m_pFirstActiveAlarm;
            while (*ppCurrent != pAlarm) {
                ppCurrent = &(*ppCurrent)->m_pNext;
                _ASSERTE(*ppCurrent != NULL);
            }
            *ppCurrent = pAlarm->m_pNext;
            pAlarm->m_pNext = m_pFirstFreeAlarm;
            m_pFirstFreeAlarm = pAlarm;
            hr = pAlarm->m_bKilled ? S_FALSE : S_OK;
        }
    }
    m_csCallback.Unlock();
    return hr;
}


STDMETHODIMP CMediaStreamFilter::Flush(BOOL bCancelEOS)
{
    CAutoLock lck(&m_csCallback);

    if (bCancelEOS) {
        m_nAtEOS--;
    }
    _ASSERTE(m_nAtEOS >= 0);
    FlushTimers();
    return S_OK;
}

STDMETHODIMP CMediaStreamFilter::EndOfStream()
{
    CAutoLock lck(&m_csCallback);

    _ASSERTE(m_nAtEOS < m_Streams.Size());
    m_nAtEOS++;
    CheckComplete();
    return S_OK;
}

void CMediaStreamFilter::FlushTimers(void)
{
    CAutoLock lck(&m_csCallback);
    for (CAlarm *pCurAlarm = m_pFirstActiveAlarm; pCurAlarm; pCurAlarm = pCurAlarm->m_pNext) {
        pCurAlarm->m_bKilled = (m_pClock->Unadvise(pCurAlarm->m_dwStupidCookie) == S_OK);
        SetEvent(pCurAlarm->m_hEvent);
    }
}


void CMediaStreamFilter::CheckComplete()
{
    if (m_State == State_Running && m_nAtEOS == m_Streams.Size() &&
        //  Must support IMediaSeeking to be a renderer
        m_pUnknownSeekAgg != NULL
       ) {
        IMediaEventSink *pSink;
        HRESULT hr = m_pGraph->QueryInterface(IID_IMediaEventSink, (void **)&pSink);
        if (SUCCEEDED(hr)) {
            pSink->Notify(EC_COMPLETE, 0, 0);
            pSink->Release();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\strmobjs\mmstream.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// MMStream.cpp : Implementation of CMMStream
#include "stdafx.h"
#include <ddraw.h>
#include "strmobjs.h"
#include <strmif.h>
#include <control.h>
#include <uuids.h>
#include <vfwmsgs.h>
#include <amutil.h>
#include <ddrawex.h>
#include <util.h>
#include "ammstrm.h"
#include "amguids.h"


/////////////////////////////////////////////////////////////////////////////
// Utilities

#if 0
int
WINAPI
lstrcmpWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    do {
    WCHAR c1 = *lpString1;
    WCHAR c2 = *lpString2;
    if (c1 != c2)
        return (int) c1 - (int) c2;
    } while (*lpString1++ && *lpString2++);
    return 0;
}
#endif

/*  Helper - get the major type of a pin */
void GetMajorType(IPin *pPin, GUID *pmajortype)
{
    IEnumMediaTypes *pEnum;
    *pmajortype = GUID_NULL;
    if (SUCCEEDED(pPin->EnumMediaTypes(&pEnum))) {
        AM_MEDIA_TYPE *pmt;
        DWORD dwReturned;
        if (S_OK == pEnum->Next(1, &pmt, &dwReturned)) {
            *pmajortype = pmt->majortype;
            DeleteMediaType(pmt);
        }
        pEnum->Release();
    }
}


/*  Hack to try to connect all the pins of a filter up */
HRESULT ConnectToAPin(IGraphBuilder *pBuilder, IPin *pThisPin)
{
    /*  Try and get the pin's type */
    IMediaStream *pStream;
    GUID majortype;
    GetMajorType(pThisPin, &majortype);
    CComPtr<IEnumFilters> pEnumFilters;
    HRESULT hr = pBuilder->EnumFilters(&pEnumFilters);
    if (FAILED(hr)) {
        return hr;
    }
    for (; ; ) {
        ULONG nFilters;
        CComPtr<IBaseFilter> pFilter;
        HRESULT hrNext = pEnumFilters->Next(1, &pFilter, &nFilters);
        if (hrNext == VFW_E_ENUM_OUT_OF_SYNC) {
            pEnumFilters->Reset();
            continue;
        }
        if (S_OK != hrNext) {
            return VFW_E_CANNOT_CONNECT;
        }
        CComPtr<IEnumPins> pEnumPins;
        if (S_OK != pFilter->EnumPins(&pEnumPins)) {
            return VFW_E_CANNOT_CONNECT;
        }
        for (; ; ) {
            ULONG nPins;
            CComPtr<IPin> pPin;
            if (S_OK != pEnumPins->Next(1, &pPin, &nPins)) {
                break;
            }
            /*
                Reject all pins which are not default rendered
            */
            {
                PIN_INFO PinInfo;
                pPin->QueryPinInfo(&PinInfo);
                if (PinInfo.pFilter) {
                    PinInfo.pFilter->Release();
                }
                if (PinInfo.dir != PINDIR_OUTPUT || PinInfo.achName[0] == L'~') {
                    continue;
                }
            }

            /*  Check the type - this is a big HACK to speed things up
                - otherwise we bring in a ton of audio codecs to render
                video!
            */
            GUID majortype2;
            if (majortype != GUID_NULL) {
                GetMajorType(pPin, &majortype2);
                if (majortype != majortype2 && majortype2 != GUID_NULL &&
                    majortype2 != MEDIATYPE_Stream) {
                }
            }

            if (SUCCEEDED(pBuilder->Connect(pPin, pThisPin))) {
                /*  Set the latency */
                IAMBufferNegotiation *pNegotiate;
                if (SUCCEEDED(pPin->QueryInterface(IID_IAMBufferNegotiation,
                                                   (void **)&pNegotiate))) {
                    ALLOCATOR_PROPERTIES prop;
                    prop.cBuffers = 1;    /*  For Audio? */
                    prop.cbBuffer = -1;
                    prop.cbAlign = -1;
                    prop.cbPrefix = -1;
                    pNegotiate->SuggestAllocatorProperties(&prop);
                    pNegotiate->Release();
                }
                return S_OK;
            }
        }
    }
}


HRESULT ConnectFilterPins(IGraphBuilder *pBuilder, IBaseFilter *pFilter)
{
    HRESULT hrTotal = VFW_E_CANNOT_CONNECT;
    /*  For each pin try to connect it up - just once */
    CComPtr<IEnumPins> pEnumPins;
    HRESULT hr = pFilter->EnumPins(&pEnumPins);
    if (FAILED(hr)) {
        return S_OK;
    }
    for (; ; ) {
        ULONG nPins;
        CComPtr<IPin> pPin;
        if (S_OK != pEnumPins->Next(1, &pPin, &nPins)) {
            return hrTotal;
        }
        hr = ConnectToAPin(pBuilder, pPin);
        if (S_OK == hr) {
            hrTotal = hr;
        }
    }
}
/////////////////////////////////////////////////////////////////////////////
// CMMStream


CMMStream::CMMStream() :
    m_StreamTypeSet(false),
    m_bSeekingSet(false),
    m_dwInitializeFlags(0),
    m_StreamType(STREAMTYPE_READ),
    m_hEOS(NULL),
    m_dwIDispSafety(0),
    m_dwIPropBagSafety(0),
    m_AudioState(Disabled),
    m_VideoState(Disabled),
    m_MMStreamState(STREAMSTATE_STOP)
{
}


/*  Create things here */
HRESULT CMMStream::FinalConstruct()
{
    HRESULT hr = _BaseClass::FinalConstruct();
    if (FAILED(hr)) {
        return hr;
    }
    hr = CoCreateInstance(
             CLSID_MediaStreamFilter,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IMediaStreamFilter,
             (void **)&m_pMediaStreamFilter
         );

    EXECUTE_ASSERT(SUCCEEDED(m_pMediaStreamFilter->QueryInterface(
        IID_IBaseFilter,
        (void **)&m_pBaseFilter)));
    return S_OK;
}

//  IAMMMStream
STDMETHODIMP CMMStream::Initialize(
    STREAM_TYPE StreamType,
    DWORD dwFlags,
    IGraphBuilder *pFilterGraph
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::Initialize(%d, 0x%8.8X, 0x%8.8X)\n"),
              StreamType, dwFlags, pFilterGraph);
    AUTO_CRIT_LOCK;
    if (m_StreamTypeSet && StreamType != m_StreamType ||
        (0 != (dwFlags & ~AMMSF_NOGRAPHTHREAD))) {
        return E_INVALIDARG;
    }
    if (m_pGraphBuilder && pFilterGraph != NULL) {
        return E_INVALIDARG;
    }
    m_dwInitializeFlags = dwFlags;
    if (pFilterGraph) {
        m_pGraphBuilder = pFilterGraph;
        CompleteAddGraph();
    }

    m_StreamTypeSet = true;
    m_StreamType = StreamType;
    return S_OK;
}

STDMETHODIMP CMMStream::GetFilter(
    IMediaStreamFilter **ppFilter
)
{
    TRACEINTERFACE(_T("IAMMultiMediaStream::GetFilter(0x%8.8X)\n"), ppFilter);
    if (ppFilter == NULL) {
        return E_POINTER;
    }
    m_pMediaStreamFilter->AddRef();
    *ppFilter = m_pMediaStreamFilter;
    return S_OK;
}

STDMETHODIMP CMMStream::GetFilterGraph(IGraphBuilder **ppGraphBuilder)
{
    TRACEINTERFACE(_T("AMIMultiMediaStream::GetFilterGraph(0x%8.8X)\n"), ppGraphBuilder);
    if (ppGraphBuilder == NULL) {
        return E_POINTER;
    }
    if (m_pGraphBuilder) {
        m_pGraphBuilder->AddRef();
        *ppGraphBuilder = m_pGraphBuilder;
    } else {
        *ppGraphBuilder = NULL;
    }
    return S_OK;
}


HRESULT CMMStream::AddDefaultRenderer(REFMSPID PurposeId, DWORD dwFlags, IMediaStream **ppNewStream)
{
    TRACEFUNC(_T("IAMMultiMediaStream::AddDefaultRenderer(%s, 0x%8.8X, 0x%8.8X)\n"),
                   TextFromPurposeId(PurposeId), dwFlags, ppNewStream);
    HRESULT hr;
    if (ppNewStream) {
        hr = E_INVALIDARG;
    } else {
        CLSID clsid;
        hr = GetClsidFromPurposeid(PurposeId, true, &clsid);
        if (SUCCEEDED(hr)) {
            hr = AddFilter(clsid, NULL);
        }
    }
    return hr;
}

HRESULT CMMStream::AddAMMediaStream(IAMMediaStream *pAMStream, REFMSPID PurposeId, IMediaStream **ppNewStream)
{
    TRACEFUNC(_T("IMultiMediaStream::AddAMMediaStream(0x%8.8X, %s, 0x%8.8X)\n"),
                   pAMStream, TextFromPurposeId(PurposeId), ppNewStream);
    HRESULT hr;
    MSPID StreamPurposeId;
    EXECUTE_ASSERT(SUCCEEDED(pAMStream->GetInformation(&StreamPurposeId, NULL)));
    if (PurposeId != StreamPurposeId) {
        hr = MS_E_PURPOSEID;
    } else {
        hr = pAMStream->JoinAMMultiMediaStream(this);
        if (SUCCEEDED(hr)) {
            hr = m_pMediaStreamFilter->AddMediaStream(pAMStream);
            if (SUCCEEDED(hr)) {
                if (ppNewStream) {
                    pAMStream->AddRef();
                    *ppNewStream = pAMStream;
                }
            } else {
                pAMStream->JoinAMMultiMediaStream(NULL);
            }
        }
    }
    return hr;
}


HRESULT CMMStream::AddDefaultStream(
                 IUnknown *pStreamObject,
                 DWORD dwFlags,
                 REFMSPID PurposeId,
                 IMediaStream **ppNewStream)
{
    TRACEFUNC(_T("IMultiMediaStream::AddDefaultStream(0x%8.8X, %8.8X, %s, 0x%8.8X)\n"),
                   pStreamObject, dwFlags, TextFromPurposeId(PurposeId), ppNewStream);
    CLSID clsidStreamObject;
    HRESULT hr = GetClsidFromPurposeid(PurposeId, false, &clsidStreamObject);
    if (SUCCEEDED(hr)) {
        IAMMediaStream *pMediaStream;
        hr = CoCreateInstance(
             clsidStreamObject,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IAMMediaStream,
             (void **)&pMediaStream
        );
        if (SUCCEEDED(hr)) {
            hr = pMediaStream->Initialize(pStreamObject, dwFlags, PurposeId, m_StreamType);
            if (SUCCEEDED(hr)) {
                hr = AddAMMediaStream(pMediaStream, PurposeId, ppNewStream);
            }
            pMediaStream->Release();
        }
    }
    return hr;
}




//
//  This call can take on various flavors depending upon the flags and the pStreamObject
//  passed to it.  Basically the algorithm is:
//
//  If flag "add default renderer" then
//      Add renderer associated with purpose ID
//  else
//      If flag "add peer" then
//          (pStreamObject must be an IMediaStream object)
//          if PurposeId != NULL then
//              Create default stream for purpose ID
//          else
//              Get purpose ID of pStreamObject
//              Create default stream for that purpose ID
//          Initialize new stream
//      else
//          If pStreamObject is an IAMMediaStream then
//              Add it to our media stream
//          else
//              Attempt to create an IAMMediaStream by looking up the purpose ID
//
//

STDMETHODIMP CMMStream::AddMediaStream(
    IUnknown *pStreamObject,
    const MSPID *pOptionalPurposeId,
    DWORD dwFlags,
    IMediaStream **ppNewStream
)
{
    if (dwFlags & ~(AMMSF_ADDDEFAULTRENDERER |
                    AMMSF_CREATEPEER |
                    AMMSF_STOPIFNOSAMPLES |
                    AMMSF_NOSTALL)
        ) {
        return E_INVALIDARG;
    }
    TRACEINTERFACE(_T("IAMMultiMediaStream::AddMediaStream(0x%8.8X, %s, %8.8X, 0x%8.8X)\n"),
                   pStreamObject,
                   pOptionalPurposeId ? TextFromPurposeId(*pOptionalPurposeId) : _T("NULL"),
                   dwFlags, ppNewStream);
    AUTO_CRIT_LOCK;
    if (ppNewStream) {
        *ppNewStream = NULL;
    }

    HRESULT hr = CheckGraph();
    CComPtr<IMediaStream> pSourceMediaStream;
    CComPtr<IAMMediaStream> pSourceAMMediaStream;
    if (pStreamObject) {
        pStreamObject->QueryInterface(IID_IMediaStream, (void **)&pSourceMediaStream);
        pStreamObject->QueryInterface(IID_IAMMediaStream, (void **)&pSourceAMMediaStream);
    }

    if (SUCCEEDED(hr)) {
        MSPID PurposeId;
        if (pOptionalPurposeId) {
            PurposeId = *pOptionalPurposeId;
        } else {
            hr = pSourceMediaStream ? pSourceMediaStream->GetInformation(&PurposeId, NULL) : E_INVALIDARG;
        }
        if (SUCCEEDED(hr)) {
            if (dwFlags & AMMSF_ADDDEFAULTRENDERER) {
                hr = AddDefaultRenderer(PurposeId, dwFlags, ppNewStream);
            } else {
                if (pSourceAMMediaStream && ((dwFlags & AMMSF_CREATEPEER) == 0)) {
                    hr = AddAMMediaStream(pSourceAMMediaStream, PurposeId, ppNewStream);
                } else {
                    hr = AddDefaultStream(pStreamObject, dwFlags, PurposeId, ppNewStream);
                }
            }
        }
    }
    return hr;
}





//  Note that backout in this area is extemely tricky
STDMETHODIMP CMMStream::OpenFile(
    LPCWSTR pszFileName,
    DWORD dwFlags
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::OpenFile(%ls, 0x%8.8X)\n"),
                    pszFileName, dwFlags);
    if (m_StreamType == STREAMTYPE_WRITE) {
        return MS_E_INVALIDSTREAMTYPE;
    }
    if (pszFileName == NULL) {
        return E_POINTER;
    }
    AUTO_CRIT_LOCK;
    HRESULT hr = CheckGraph();
    if (FAILED(hr)) {
        return hr;
    }

    CComPtr<IBaseFilter> pSource;

    hr = m_pGraphBuilder->AddSourceFilter(
                     pszFileName,
                     L"Source",
                     &pSource
                 );

    if (SUCCEEDED(hr)) {
        hr =  CompleteOpen(pSource, dwFlags);
        if (FAILED(hr)) {
            m_pGraphBuilder->RemoveFilter(pSource);
        }
    }
    return hr;

}

STDMETHODIMP CMMStream::OpenMoniker(
    IBindCtx *pCtx,
    IMoniker *pMoniker,
    DWORD dwFlags
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::OpenMoniker(0x%8.8X, 0x%8.8X, 0x%8.8X)\n"),
                    pCtx, pMoniker, dwFlags);
    if (m_StreamType == STREAMTYPE_WRITE) {
        return MS_E_INVALIDSTREAMTYPE;
    }
    AUTO_CRIT_LOCK;
    HRESULT hr = CheckGraph();
    if (FAILED(hr)) {
        return hr;
    }
    IFilterGraph2 *pGraph2;
    hr = m_pGraphBuilder->QueryInterface(
                     IID_IFilterGraph2,
                     (void **)&pGraph2);
    if (FAILED(hr)) {
        return hr;
    }

    CComPtr<IBaseFilter> pFilter;

    hr = pGraph2->AddSourceFilterForMoniker(
            pMoniker,
            pCtx,
            L"Source",
            &pFilter);

    pGraph2->Release();
    if (FAILED(hr)) {
        return hr;
    }

    if (SUCCEEDED(hr)) {
        hr =  CompleteOpen(pFilter, dwFlags);
        if (FAILED(hr)) {
            m_pGraphBuilder->RemoveFilter(pFilter);
        }
    }
    return hr;
}

STDMETHODIMP CMMStream::Render(
    DWORD dwFlags
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::Render(0x%8.8X)\n"),
                    dwFlags);
    if ((dwFlags & ~AMMSF_NOCLOCK) && m_StreamType == STREAMTYPE_WRITE) {
        return E_INVALIDARG;
    }
    AUTO_CRIT_LOCK;

    HRESULT hr = CheckGraph();
    if (FAILED(hr)) {
        return hr;
    }

    if (m_StreamType == STREAMTYPE_READ) {
        /*  Render all the filters we can find */
        IEnumFilters *pEnum;
        HRESULT hr = m_pGraphBuilder->EnumFilters(&pEnum);
        if (SUCCEEDED(hr)) {
            hr = VFW_E_CANNOT_CONNECT;
            IBaseFilter *pFilter;
            ULONG nFilters;
            for (; ; ) {
                HRESULT hrNext = pEnum->Next(1, &pFilter, &nFilters);
                if (hrNext == VFW_E_ENUM_OUT_OF_SYNC) {
                    pEnum->Reset();
                } else if (hrNext == S_OK) {
                    if (S_OK == CompleteOpen(pFilter, dwFlags)) {
                        hr = S_OK;
                    }
                    pFilter->Release();
                } else {
                    break;
                }
            }
            pEnum->Release();
        }
        return hr;
    }

    for (int iStream = 0; ; iStream++) {
        CComPtr<IMediaStream> pStream;
        hr = EnumMediaStreams(iStream, &pStream);
        if (S_OK == hr) {
            CComQIPtr <IPin, &IID_IPin> pOutputPin(pStream);
            if (pOutputPin) {

                //  Some streams may already have been rendered

                IPin *pConnected;
                if (SUCCEEDED(pOutputPin->ConnectedTo(&pConnected))) {
                    pConnected->Release();
                } else {
                    hr = m_pGraphBuilder->Render(pOutputPin);
                }
                if (FAILED(hr)) {

                    //  Kind of difficult to back out!
                    return hr;
                }
            }
        } else {
            hr = S_OK;
            break;
        }
    }

    if (dwFlags & AMMSF_NOCLOCK) {
        CComPtr<IMediaFilter> pMediaFilter;
        EXECUTE_ASSERT(SUCCEEDED(m_pGraphBuilder->QueryInterface(
                IID_IMediaFilter, (void **)&pMediaFilter)));
        EXECUTE_ASSERT(SUCCEEDED(pMediaFilter->SetSyncSource(NULL)));
    }

    return hr;
}



// IMultiMediaStream

STDMETHODIMP CMMStream::GetInformation(
    DWORD *pdwFlags,
    STREAM_TYPE *pStreamType
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::GetInformation(0x%8.8X, 0x%8.8X)\n"),
                    pdwFlags, pStreamType);
    AUTO_CRIT_LOCK;
    if (m_pGraphBuilder == NULL) {
        return E_UNEXPECTED;
    }
    DWORD dwFlags = MMSSF_ASYNCHRONOUS;
    IReferenceClock *pClock;
    IMediaFilter *pGraphFilter;
    if (SUCCEEDED(m_pGraphBuilder->QueryInterface(
                      IID_IMediaFilter, (void **)&pGraphFilter))) {
        if (S_OK == pGraphFilter->GetSyncSource(&pClock)) {
            if (pClock) {
                pClock->Release();
            }
            dwFlags |= MMSSF_HASCLOCK;
        }
        pGraphFilter->Release();
    }
    if (m_pMediaSeeking) {
        LONGLONG llDuration;
        if (S_OK == m_pMediaSeeking->GetDuration(&llDuration)) {
            dwFlags |= MMSSF_SUPPORTSEEK;
        }
    }
    if (pdwFlags) {
        *pdwFlags = dwFlags;
    }
    if (pStreamType) {
        *pStreamType = m_StreamType;
    }
    return S_OK;
}

STDMETHODIMP CMMStream::GetMediaStream(
    REFMSPID idPurpose,
    IMediaStream **ppMediaStream
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::GetMediaStream(%s, 0x%8.8X)\n"),
                    TextFromPurposeId(idPurpose), ppMediaStream);
    return m_pMediaStreamFilter->GetMediaStream(idPurpose, ppMediaStream);
}

STDMETHODIMP CMMStream::EnumMediaStreams(
    long Index,
    IMediaStream **ppMediaStream
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::EnumMediaStreams(%d, 0x%8.8X)\n"),
                    Index, ppMediaStream);
    return m_pMediaStreamFilter->EnumMediaStreams(Index, ppMediaStream);
}

//
//  WARNING!  Do NOT take the cricical section in this function since InternalUpdate
//  from the base sample Update() method calls this.
//
STDMETHODIMP CMMStream::GetState(STREAM_STATE *pCurrentState)
{
    TRACEINTERFACE(_T("IMultiMediaStream::GetState(0x%8.8X)\n"),
                    pCurrentState);
    *pCurrentState = m_MMStreamState;
    return S_OK;
}

STDMETHODIMP CMMStream::SetState(
    STREAM_STATE NewState
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::SetState(%d)\n"),
                    NewState);
    HRESULT hr;
    switch (NewState) {
    case STREAMSTATE_STOP:
        hr = m_pMediaControl->Stop();
        break;
    case STREAMSTATE_RUN:
        hr = m_pMediaControl->Pause();
        if (SUCCEEDED(hr)) {
            long state;

            //  Wait 1 second if necessary
            m_pMediaControl->GetState(1000 * 10000, &state);
            hr = m_pMediaControl->Run();
        }
        break;
    default:
        hr = E_INVALIDARG;
        break;
    }
    if (SUCCEEDED(hr)) {
        m_MMStreamState = NewState;
    }
    return hr;
}


STDMETHODIMP CMMStream::GetTime(
    STREAM_TIME *pCurrentTime
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::GetTime(0x%8.8X)\n"),
                    pCurrentTime);
    //  This is supposed to return the time that matches the
    //  samples so use ISeeking
    HRESULT hr = E_NOTIMPL;
    if (m_pMediaSeeking != NULL) {
        REFERENCE_TIME tStop;

        //  This can return E_NOTIMPL for non-seekable graphs
        hr = m_pMediaSeeking->GetPositions((REFERENCE_TIME *)pCurrentTime,
                                           &tStop);
    }
    if (hr == E_NOTIMPL) {
        if (m_pMediaStreamFilter) {
            hr = m_pMediaStreamFilter->GetCurrentStreamTime(pCurrentTime);
        }
    }
    return hr;
}

STDMETHODIMP CMMStream::GetDuration(
    STREAM_TIME *pDuration
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::GetDuration(0x%8.8X)\n"),
                    pDuration);
    SetSeeking();
    if (m_pMediaSeeking == NULL) {
        return E_NOINTERFACE;
    }
    *pDuration = 0;
    if (m_StreamType != STREAMTYPE_READ) {
        return MS_E_INVALIDSTREAMTYPE;
    }
    return SUCCEEDED(m_pMediaSeeking->GetDuration(pDuration)) ?
        S_OK : S_FALSE;
}

STDMETHODIMP CMMStream::Seek(
    STREAM_TIME SeekTime
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::Seek(%dms)\n"),
                    (LONG)(SeekTime / 10000));
    SetSeeking();
    if (m_pMediaSeeking == NULL) {
        return E_NOINTERFACE;
    }
    return m_pMediaSeeking->SetPositions(
               &SeekTime,
               AM_SEEKING_AbsolutePositioning,
               NULL,
               AM_SEEKING_NoPositioning
           );
}

STDMETHODIMP CMMStream::GetEndOfStreamEventHandle(
    HANDLE *phEOS
)
{
    TRACEINTERFACE(_T("IAMMultiMediaStream::GetEndOfStreamEventHandle(0x%8.8X)\n"),
                    phEOS);
    if (phEOS == NULL) {
        return E_POINTER;
    }
    HRESULT hr = CheckGraph();
    if (FAILED(hr)) {
        return hr;
    }
    _ASSERTE(m_hEOS != NULL);
    *phEOS = m_hEOS;
    return S_OK;
}

STDMETHODIMP CMMStream::SetClockDelta(
    REFERENCE_TIME rtAdjust
)
{
    //  Get the clock and see if it supports it
    IMediaFilter *pGraphFilter;
    HRESULT hr =  m_pGraphBuilder->QueryInterface(
                      IID_IMediaFilter, (void **)&pGraphFilter);
    if (SUCCEEDED(hr)) {
        IReferenceClock *pClock;
        if (S_OK == pGraphFilter->GetSyncSource(&pClock)) {
            if (pClock) {
                IAMClockAdjust *pAdjust;
                hr = pClock->QueryInterface(IID_IAMClockAdjust, (void **)&pAdjust);
                if (SUCCEEDED(hr)) {
                    hr = pAdjust->SetClockDelta(rtAdjust);
                    pAdjust->Release();
                }
                pClock->Release();
            }
        }
        pGraphFilter->Release();
    }
    return hr;
}

HRESULT CMMStream::AddFilter(REFCLSID rclsidFilter, IBaseFilter **ppFilter)
{
    TRACEFUNC(_T("CMMStream::AddFilter(%s, 0x%8.8X)\n"),
                    rclsidFilter, ppFilter);
    IBaseFilter *pFilter;
    _ASSERTE(m_pGraphBuilder != NULL);
    HRESULT hr = CoCreateInstance(
                         rclsidFilter,
                         NULL,
                         CLSCTX_INPROC_SERVER,
                         IID_IBaseFilter,
                         (void **)&pFilter
                 );
    if (FAILED(hr)) {
        return hr;
    }

    hr = m_pGraphBuilder->AddFilter(pFilter, NULL);
    m_FilterList.Add(pFilter);
    if (ppFilter) {
        *ppFilter = pFilter;
    }
    pFilter->Release();
    return hr;
}


//
//  Potential future work -- this could look in the registry
//
HRESULT CMMStream::GetClsidFromPurposeid(REFMSPID PurposeId, bool bRenderer, CLSID * pclsid)
{
    TRACEFUNC(_T("CMMStream::GetClsidFromPurposeid(%s, %d, 0x%8.8X)\n"),
                    TextFromPurposeId(PurposeId), bRenderer, pclsid);
    if (bRenderer) {
        if (PurposeId == MSPID_PrimaryAudio) {
            *pclsid = CLSID_DSoundRender;
        } else {
            return MS_E_PURPOSEID;
        }
    } else {
        if (PurposeId == MSPID_PrimaryVideo) {
            *pclsid = CLSID_AMDirectDrawStream;
        } else {
            if (PurposeId == MSPID_PrimaryAudio) {
                *pclsid = CLSID_AMAudioStream;
            } else {
                return MS_E_PURPOSEID;
            }
        }
    }
    return NOERROR;
}



void CMMStream::CompleteAddGraph()
{
    _ASSERTE(m_pMediaSeeking == NULL);
    m_pGraphBuilder->QueryInterface(IID_IMediaSeeking, (void **)&m_pMediaSeeking);
    m_pGraphBuilder->QueryInterface(IID_IMediaControl, (void **)&m_pMediaControl);

    /*  Add our filter ! */
    m_pGraphBuilder->AddFilter(m_pBaseFilter, L"MediaStreamFilter");

    /*  Get IMediaEvent to get the event handle */
    IMediaEventEx *pEvent;
    HRESULT hr = m_pGraphBuilder->QueryInterface(IID_IMediaEventEx, (void **)&pEvent);
    if (SUCCEEDED(hr)) {
        pEvent->GetEventHandle((OAEVENT *)&m_hEOS);
        pEvent->SetNotifyFlags(AM_MEDIAEVENT_NONOTIFY);
        pEvent->Release();
    }
}

//  Call this after adding the source/sink to the graph
HRESULT CMMStream::CompleteOpen(IBaseFilter *pSource, DWORD dwFlags)
{
    HRESULT hrTotal = VFW_E_CANNOT_CONNECT;
    {
        //  Find the output pin
        CComPtr<IEnumPins> pEnumPins;
        HRESULT hr = pSource->EnumPins(&pEnumPins);
        if (FAILED(hr)) {
            return hr;
        }
        for ( ; ; ) {
            CComPtr<IPin> pPin;
            ULONG nPins = 0;
            if (S_OK != pEnumPins->Next(1, &pPin, &nPins)) {
                break;
            }
            _ASSERTE(nPins == 1);

            switch (dwFlags & AMMSF_RENDERTYPEMASK) {
            case AMMSF_NORENDER:
                break;

            case AMMSF_RENDERTOEXISTING:
            case AMMSF_RENDERALLSTREAMS:


                //  Do it the hard way
                hr = ConnectFilterPins(m_pGraphBuilder, m_pBaseFilter);
                if (SUCCEEDED(hr)) {
                    for (int i = 0; i < m_FilterList.Size(); i++ ) {
                        HRESULT hr =
                            ConnectFilterPins(m_pGraphBuilder,
                                              m_FilterList.Element(i));
                    }
                }
                //  Performance is no good with this
                //  We need to render to existing renderers which is only in
                //  IFilterGraph2
                if (FAILED(hr)) {
                    CComQIPtr<IFilterGraph2, &IID_IFilterGraph2> pGraph2(m_pGraphBuilder);
                    hr = pGraph2->RenderEx(
                        pPin,
                        (dwFlags & AMMSF_RENDERTYPEMASK) ==
                            AMMSF_RENDERALLSTREAMS ?
                            0 : AM_RENDEREX_RENDERTOEXISTINGRENDERERS,
                        NULL);
                }
                if (SUCCEEDED(hr)) {
                    hr = S_OK;
                }
                break;
            }
            if (S_OK == hr) {
                hrTotal = hr;
            }
        }
    }


    if (SUCCEEDED(hrTotal)) {
        m_StreamTypeSet = true;
        if (dwFlags & AMMSF_NOCLOCK) {
            CComPtr<IMediaFilter> pMediaFilter;
            EXECUTE_ASSERT(SUCCEEDED(m_pGraphBuilder->QueryInterface(
                    IID_IMediaFilter, (void **)&pMediaFilter)));
            EXECUTE_ASSERT(SUCCEEDED(pMediaFilter->SetSyncSource(NULL)));
        } else {
            //  Make it have a clock now or we'll get confused later
            m_pGraphBuilder->SetDefaultSyncSource();
        }

        // Make sure seeking is set up
        SetSeeking();
        if (dwFlags & AMMSF_RUN) {
            hrTotal = SetState(STREAMSTATE_RUN);
        }
    }
    return hrTotal;
}

HRESULT CMMStream::CheckGraph()
{
    if (m_MMStreamState != STREAMSTATE_STOP) {
        return MS_E_BUSY;
    }
    if (m_pGraphBuilder == NULL) {
        // Make our own filter graph
        HRESULT hr = CoCreateInstance(
                         m_dwInitializeFlags & AMMSF_NOGRAPHTHREAD ?
                             CLSID_FilterGraphNoThread :
                             CLSID_FilterGraph,
                         NULL,
                         CLSCTX_INPROC_SERVER,
                         IID_IGraphBuilder,
                         (void **)&m_pGraphBuilder
                     );
        if (FAILED(hr)) {
            return hr;
        }
        CompleteAddGraph();
    }
    return S_OK;
}

void CMMStream::SetSeeking()
{

    if (!m_bSeekingSet) {
        if (m_StreamType != STREAMTYPE_WRITE && m_pMediaStreamFilter != NULL) {
            m_pMediaStreamFilter->SupportSeeking(m_StreamType == STREAMTYPE_READ);
        }
        m_bSeekingSet = TRUE;
    }
}


STDMETHODIMP CMMStream::get_FileName(BSTR *pVal)
{
    TRACEINTERFACE(_T("IDirectShowStream::get_FileName(0x%8.8X)\n"),
                   pVal);
    *pVal = m_bstrFileName.Copy();
    return S_OK;
}

STDMETHODIMP CMMStream::put_FileName(BSTR newVal)
{
    TRACEINTERFACE(_T("IDirectShowStream::put_FileName(%ls\n"),
                   newVal);
    HRESULT hr = OpenFile(newVal, 0);
    if (SUCCEEDED(hr)) {
        m_bstrFileName = newVal;
    }
    return hr;
}

HRESULT CMMStream::SetStreamState(REFMSPID PurposeId, OUTPUT_STATE NewState, OUTPUT_STATE * pCurVal)
{
    HRESULT hr = S_OK;
    if (*pCurVal != NewState) {
        switch (NewState) {
        case Disabled:
            hr = E_FAIL;    // Currently no way to force this
            break;
        case ReadData:
            hr = AddMediaStream(NULL, &PurposeId, 0, NULL);
            break;
        case RenderData:
            hr = AddMediaStream(NULL, &PurposeId, AMMSF_ADDDEFAULTRENDERER, NULL);
            break;
        default:
            hr = E_INVALIDARG;
        }
        if (SUCCEEDED(hr)) {
            *pCurVal = NewState;
        }
    }
    return hr;
}

STDMETHODIMP CMMStream::get_Video(OUTPUT_STATE *pVal)
{
    TRACEINTERFACE(_T("IDirectShowStream::get_Video(0x%8.8X\n"),
                   pVal);
    *pVal = m_VideoState;
    return S_OK;
}

STDMETHODIMP CMMStream::put_Video(OUTPUT_STATE newVal)
{
    TRACEINTERFACE(_T("IDirectShowStream::put_Video(%d\n"),
                   newVal);
    return SetStreamState(MSPID_PrimaryVideo, newVal, &m_VideoState);
}

STDMETHODIMP CMMStream::get_Audio(OUTPUT_STATE *pVal)
{
    TRACEINTERFACE(_T("IDirectShowStream::get_Audio(0x%8.8X\n"),
                   pVal);
    *pVal = m_AudioState;
    return S_OK;
}

STDMETHODIMP CMMStream::put_Audio(OUTPUT_STATE newVal)
{
    TRACEINTERFACE(_T("IDirectShowStream::put_Audio(%d\n"),
                   newVal);
    return SetStreamState(MSPID_PrimaryAudio, newVal, &m_AudioState);
}



//
//  Property bag goop
//


STDMETHODIMP CMMStream::GetClassID(CLSID *pClsId)
{
    *pClsId = CLSID_AMMultiMediaStream;
    return S_OK;
}

STDMETHODIMP CMMStream::InitNew(void)
{
    return S_OK;    // initialize new property bag goop
}


const WCHAR g_szVideo[] = L"Video";
const WCHAR g_szAudio[] = L"Audio";
const WCHAR g_szFileName[] = L"FileName";

STDMETHODIMP CMMStream::Load(IPropertyBag* pPropBag, IErrorLog* pErrorLog)
{
    TRACEINTERFACE(_T("IPersistPropertyBag::Load"));
    CComVariant var;
    if (pPropBag->Read(g_szVideo, &var, pErrorLog) == S_OK) {
        var.ChangeType(VT_I4);
        put_Video((OUTPUT_STATE)var.lVal);
        var.Clear();
    }
    if (pPropBag->Read(g_szAudio, &var, pErrorLog) == S_OK) {
        var.ChangeType(VT_I4);
        put_Audio((OUTPUT_STATE)var.lVal);
        var.Clear();
    }
    if (pPropBag->Read(g_szFileName, &var, pErrorLog) == S_OK) {
        var.ChangeType(VT_BSTR);
        put_FileName(var.bstrVal);
        var.Clear();
    }
    return S_OK;
}

STDMETHODIMP CMMStream::Save(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    TRACEINTERFACE(_T("IPersistPropertyBag::Save"));
    CComVariant var(m_VideoState);
    HRESULT hr = pPropBag->Write(g_szVideo, &var);
    if (SUCCEEDED(hr)) {
        var = m_AudioState;
        hr = pPropBag->Write(g_szAudio, &var);
        if (SUCCEEDED(hr)) {
            var.ChangeType(VT_BSTR | VT_BYREF);
            var.bstrVal = m_bstrFileName;
            hr = pPropBag->Write(g_szFileName, &var);
        }
    }
    return hr;
}



//
//  IObjectSafety
//
STDMETHODIMP CMMStream::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    TRACEINTERFACE(_T("IObjectSafety::GetInterfaceSafetyOptions"));
    if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL) {
        return E_POINTER;
    }
    HRESULT hr = S_OK;
    *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    if (riid == IID_IDispatch) {
        *pdwEnabledOptions = m_dwIDispSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    } else {
        if (riid == IID_IPersistPropertyBag) {
	    *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	    *pdwEnabledOptions = m_dwIPropBagSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        } else {
	    *pdwSupportedOptions = 0;
	    *pdwEnabledOptions = 0;
	    hr = E_NOINTERFACE;
        }
    }
    return hr;
}

STDMETHODIMP CMMStream::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    TRACEINTERFACE(_T("IObjectSafety::SetInterfaceSafetyOptions"));
    HRESULT hr = S_OK;
    if (riid == IID_IDispatch)
    {
	m_dwIDispSafety = dwEnabledOptions & dwOptionSetMask;
    } else {
        if (riid == IID_IPersistPropertyBag) {
	    m_dwIPropBagSafety = dwEnabledOptions & dwOptionSetMask;
        } else {
            hr = E_NOINTERFACE;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\strmobjs\stdafx.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#define DO_OUR_GUIDS
#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

//#undef _WINGDI_ // Avoid declaration bug in ATL
#include <atlimpl.cpp>

#if 0
//  HACK to make it build with libcmt.lib
int _CRTAPI1 main(int argc, char *argv[])
{
    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\strmobjs\strmobjs.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Mar 13 14:07:13 1997
 */
/* Compiler settings for strmobjs.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __strmobjs_h__
#define __strmobjs_h__

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

#ifndef __STRMOBJSLib_LIBRARY_DEFINED__
#define __STRMOBJSLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: STRMOBJSLib
 * at Thu Mar 13 14:07:13 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */



EXTERN_C const IID LIBID_STRMOBJSLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_SFilter;

class DECLSPEC_UUID("242C8F4F-9AE6-11D0-8212-00C04FC32C45")
SFilter;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_MMStream;

class DECLSPEC_UUID("FF146E02-9AED-11D0-8212-00C04FC32C45")
MMStream;
#endif
#endif /* __STRMOBJSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\test\teststrm.cpp ===
/*  Test AM streams stuff */

#include <windows.h>
#include <uuids.h>
#include <ddraw.h>
#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>
#include <initguid.h>
#include <amstream.h>
#include <mmstream.h>
#include <ddstream.h>
#include <austream.h>
#include <wave.h>

#define CHECK_RESULT(_x_)                    \
   {                                         \
       HRESULT hr = check_result(_x_, #_x_); \
       if (FAILED(hr)) {                     \
           return hr;                        \
       }                                     \
   }

inline check_result(HRESULT _x_, LPCTSTR sz)
{
    if (FAILED(_x_)) {
        AtlTrace(_T("%s failed code %8.8X\n"), sz);
    }
    return _x_;
}

HRESULT FindCaptureDevice(IMoniker **ppMoniker)
{
    CComPtr<ICreateDevEnum> pCreateDevEnum;
    HRESULT hr = CoCreateInstance(
                          CLSID_SystemDeviceEnum,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ICreateDevEnum,
                          (void**)&pCreateDevEnum);
    if (hr != NOERROR)
	return FALSE;

    CComPtr<IEnumMoniker> pEm;
    hr = pCreateDevEnum->CreateClassEnumerator(CLSID_CVidCapClassManager,
                                               &pEm,
                                               0);
    if (hr != NOERROR)
	return hr;

    ULONG cFetched;
    return pEm->Next(1, ppMoniker, &cFetched);
}

HRESULT LoadCapture(DWORD dwFlags, IAMMultiMediaStream *pMMStream)
{
    CComPtr<IMoniker> pMoniker;
    HRESULT hr = FindCaptureDevice(&pMoniker);
    AtlTrace(_T("FindCaptureDevice returned %8.8X\n"), hr);
    if (S_OK !=  hr) {
        return E_FAIL;
    }

    hr = pMMStream->OpenMoniker(
             pMoniker,
             dwFlags
         );
    AtlTrace("OpenMoniker returned 0x%8.8X\n", hr);
    return hr;
}

HRESULT LoadFile(LPCSTR lpsz, DWORD dwFlags, IAMMultiMediaStream *pMMStream)
{
    /*  Load our file */
    WCHAR wsz[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, lpsz, -1, wsz, MAX_PATH);
    HRESULT hr = pMMStream->OpenFile(
                     wsz,
                     dwFlags
                 );
    AtlTrace("OpenFile returned 0x%8.8X\n", hr);
    return hr;
}

HRESULT CreateAMMMStream(IAMMultiMediaStream **ppMMStream)
{
    /*  Create the mmstream object */
    HRESULT hr = CoCreateInstance(
        CLSID_AMMultiMediaStream,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IAMMultiMediaStream,
        (void **)ppMMStream
    );
    AtlTrace(_T("CreateAMMMStream returned 0x%8.8X\n"), hr);
    return hr;
}

HRESULT AddAudioStream(IAMMultiMediaStream *pAMMStream)
{
    return pAMMStream->AddMediaStream(
        NULL,
        MSPID_PrimaryAudio,
        0,
        NULL);
}
HRESULT AddDDStream(IAMMultiMediaStream *pAMMStream)
{
    CComPtr<IDirectDraw> pDDraw;
    HRESULT hr = DirectDrawCreate(NULL, &pDDraw, NULL);
    if (FAILED(hr)) {
        return hr;
    }
    hr = pDDraw->SetCooperativeLevel(HWND_DESKTOP, DDSCL_NORMAL);
    if (FAILED(hr)) {
        return hr;
    }
    return pAMMStream->AddMediaStream(
               pDDraw,
               MSPID_PrimaryVideo,
               0,
               NULL);
}

//  Create a random surface
HRESULT CreateARandomSurface(
    IDirectDraw *pDDraw,
    LPDDSURFACEDESC pDesc,
    IDirectDrawSurface **ppSurface
)
{
    return pDDraw->CreateSurface(pDesc, ppSurface, NULL);
}

HRESULT PlayAudio(IMultiMediaStream *pMMStream)
{
    //  Find the audio stream
    CComPtr<IMediaStream> pMediaStream;
    _ASSERTE(S_OK == pMMStream->GetMediaStream(MSPID_PrimaryAudio, &pMediaStream));
    //  Get the audio interface and create our sample
    CComPtr<IAudioMediaStream> pAudioStream;
    CHECK_RESULT(pMediaStream->QueryInterface(IID_IAudioMediaStream, (void**)&pAudioStream));
    WAVEFORMATEX wfx;
    CHECK_RESULT(pAudioStream->GetFormat(&wfx));
    #define NBUFFERS 1
    CComPtr<IAudioData> pAudioData[NBUFFERS];
    CComPtr<IAudioStreamSample> pSample[NBUFFERS];
    PBYTE pBuffer[NBUFFERS];
    HANDLE hEvent[NBUFFERS];
    for (int i = 0; i < NBUFFERS; i++) {
        #define DATA_SIZE 5000
        pBuffer[i] = new BYTE[DATA_SIZE];
        CHECK_RESULT(CoCreateInstance(CLSID_AMAudioData,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      IID_IAudioData,
                                      (void**)&pAudioData[i]));
        CHECK_RESULT(pAudioData[i]->Init(DATA_SIZE, pBuffer[i], 0));
        CHECK_RESULT(pAudioData[i]->SetFormat(&wfx));
        CHECK_RESULT(pAudioStream->CreateSample(
            pAudioData[i],
            0,
            &pSample[i]));
        hEvent[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
    }

    //  Make a player
    CWaveOut WaveOut(&wfx, 4, 2048);

    #define MAX_PLAY_TIME 3
    for (int Times = 0; Times < 3; Times++) {
        DWORD dwStart = timeGetTime();
        for (; ; ) {
            HRESULT hr = pSample[0]->Update(0, hEvent[0], NULL, 0);
            if (FAILED(hr) || hr == MS_S_ENDOFSTREAM) {
                break;
            }
            WaitForSingleObject(hEvent[0], INFINITE);
            CHECK_RESULT(pSample[0]->CompletionStatus(0, 0));
            if ((LONG)(timeGetTime() - dwStart) > MAX_PLAY_TIME * 1000) {
                break;
            }
            DWORD dwLength;
            CHECK_RESULT(pAudioData[0]->GetInfo(NULL, NULL, &dwLength));
            _ASSERTE(dwLength == DATA_SIZE || S_OK != hr);
            WaveOut.Write(pBuffer[0], dwLength);
#if 0
            if (S_OK != hr) {
                _ASSERTE(hr == MS_S_ENDOFSTREAM || hr == S_FALSE);
                break;
            }
#endif
        }
        pMMStream->Seek(0);
    }
    WaveOut.Wait();
    return S_OK;
}

//  Play a multimedia stream
HRESULT PlayVideo(IMultiMediaStream *pMMStream)
{
    //  First get the video stream
    CComPtr<IMediaStream> pMediaStream;
    HRESULT hr = pMMStream->GetMediaStream(MSPID_PrimaryVideo, &pMediaStream);
    if (FAILED(hr)) {
        return hr;
    }
    CComPtr<IDirectDrawMediaStream> pDDStream;
    //  Get the dd stream
    hr = pMediaStream->QueryInterface(IID_IDirectDrawMediaStream, (void **)&pDDStream);
    if (FAILED(hr)) {
        return hr;
    }

    //  Now create our surface and play with it
    CComPtr<IDirectDraw> pDDraw;
    hr = pDDStream->GetDirectDraw(&pDDraw);
    if (FAILED(hr)) {
        return hr;
    }
    //  Find out the movie size
    DDSURFACEDESC ddFormat;
    ddFormat.dwSize = sizeof(ddFormat);
    hr = pDDStream->GetFormat(&ddFormat, NULL, NULL);
    if (FAILED(hr)) {
        return hr;
    }
    CComPtr<IDirectDrawSurface> pSurface;
    hr = CreateARandomSurface(pDDraw, &ddFormat, &pSurface);
    if (FAILED(hr)) {
        return hr;
    }
    CComPtr<IDirectDrawStreamSample> pSample;
    hr = pDDStream->CreateSample(pSurface, NULL, NULL, &pSample);
    if (FAILED(hr)) {
        return hr;
    }
    for (; ; ) {
        HRESULT hr = pSample->Update(0, NULL, NULL, 0);
        if (S_OK != hr) {
            AtlTrace(_T("Update returned 0x%8.8X\n"), hr);
            return S_OK;
        }
        Sleep(10);
        hr = pSample->CompletionStatus(COMPSTAT_NOUPDATEOK |
                                       COMPSTAT_WAIT,
                                       0);
    }
}

void DoTests(LPSTR lpszFileName)
{
    CComPtr<IAMMultiMediaStream> pAMMStream;
    //  Create an AMStream
    HRESULT hr = CreateAMMMStream(&pAMMStream);

    //  Now try to create a stream
    CComPtr<IAMMediaStream> pDDStream;
    hr = AddAudioStream(pAMMStream);
    AtlTrace(_T("CreateDDStream returned 0x%8.8X\n"), hr);

    hr = lpszFileName ?
             LoadFile(lpszFileName, AMMSF_RENDERTOEXISTING, pAMMStream) :
             LoadCapture(AMMSF_RENDERTOEXISTING, pAMMStream);

    if (SUCCEEDED(hr)) {
        HRESULT hr = pAMMStream->Initialize(STREAMTYPE_READ, NULL);
        CComQIPtr<IMultiMediaStream, &IID_IMultiMediaStream> pMMStream(
            pAMMStream);
        DWORD dwFlags;
        STREAM_TYPE Type;
        hr = pMMStream->GetInformation(&dwFlags, &Type);
        _ASSERTE(Type == STREAMTYPE_READ);
        CComPtr<IMediaStream> pStream;
        hr = pMMStream->GetMediaStream(MSPID_PrimaryAudio, &pStream);
        pStream = NULL;
        hr = pMMStream->GetMediaStream(MSPID_PrimaryVideo, &pStream);
        hr = pMMStream->SetState(STREAMSTATE_RUN);
        AtlTrace(_T("SetState(STREAMSTATE_RUN) returned 0x%8.8X\n"), hr);
        hr = PlayAudio(pMMStream);
        Sleep(5000);
        hr = pMMStream->SetState(STREAMSTATE_STOP);
        AtlTrace(_T("SetState(STREAMSTATE_STOP) returned 0x%8.8X\n"), hr);
    }
}
int _CRTAPI1 main(int argc, char *argv[])
{
    CoInitialize(NULL);
    DoTests(argc < 2 ? NULL : argv[1]);
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\strmobjs\sfilter.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// SFilter.h : Declaration of the CMediaStreamFilter

#ifndef __SFILTER_H_
#define __SFILTER_H_

#include "resource.h"       // main symbols

class CMediaStreamFilter;

class CAlarm
{
friend CMediaStreamFilter;
public:
    CAlarm();
    ~CAlarm();
    static HRESULT CreateNewAlarm(CAlarm **ppNewAlarm);
public:
    CAlarm          *m_pNext;
    HANDLE          m_hEvent;
    DWORD_PTR       m_dwStupidCookie;
    bool            m_bKilled;
};


/////////////////////////////////////////////////////////////////////////////
// CMediaStreamFilter
class ATL_NO_VTABLE CMediaStreamFilter :
        public CComObjectRootEx<CComMultiThreadModel>,
        public CComCoClass<CMediaStreamFilter, &CLSID_MediaStreamFilter>,
        public IMediaStreamFilter
{
public:
        DECLARE_GET_CONTROLLING_UNKNOWN()
        CMediaStreamFilter();
#ifdef DEBUG
        ~CMediaStreamFilter() {}
#endif
        void FinalRelease();

        //  IPersist
        STDMETHODIMP GetClassID(CLSID *pClsID);

        //  IBaseFilter
        STDMETHODIMP Stop();
        STDMETHODIMP Pause();
        STDMETHODIMP Run(REFERENCE_TIME tStart);
        STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);
        STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
        STDMETHODIMP GetSyncSource(IReferenceClock **pClock);
        STDMETHODIMP EnumPins(IEnumPins ** ppEnum);
        STDMETHODIMP FindPin(LPCWSTR Id, IPin ** ppPin);
        STDMETHODIMP QueryFilterInfo(FILTER_INFO * pInfo);
        STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

        //  We're not a general purpose filter so we don't need this
        STDMETHODIMP QueryVendorInfo(LPWSTR* pVendorInfo) {return E_NOTIMPL;};

        //  IMediaStreamFilter
        STDMETHODIMP AddMediaStream(IAMMediaStream *pMediaStream);
        STDMETHODIMP GetMediaStream(REFGUID PurposeID, IMediaStream ** ppMediaStream);
        STDMETHODIMP EnumMediaStreams(long Index, IMediaStream ** ppMediaStream);
        STDMETHODIMP SupportSeeking(BOOL fRenderer);
        STDMETHODIMP ReferenceTimeToStreamTime(REFERENCE_TIME *pTime);
        STDMETHODIMP GetCurrentStreamTime(REFERENCE_TIME *pCurrentStreamTime);
        STDMETHODIMP WaitUntil(REFERENCE_TIME WaitStreamTime);
        STDMETHODIMP Flush(BOOL bCancelEOS);
        STDMETHODIMP EndOfStream();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_SFILTER)

BEGIN_COM_MAP(CMediaStreamFilter)
        COM_INTERFACE_ENTRY(IMediaStreamFilter)
        COM_INTERFACE_ENTRY2(IMediaFilter, IMediaStreamFilter)
        COM_INTERFACE_ENTRY2(IBaseFilter, IMediaStreamFilter)
        COM_INTERFACE_ENTRY2(IPersist, IMediaStreamFilter)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMediaSeeking, m_pUnknownSeekAgg)
END_COM_MAP()

private:
        void FlushTimers();
        void CheckComplete();
        HRESULT SyncSetState(FILTER_STATE State);

        //  Different lower level lock for being called back from streams
        //  otherwise we deadlock
        //  Also declare this first in case it gets used when the
        //  streams get destroyed
        CCritSec                 m_csCallback;


        CDynamicArray<IAMMediaStream *, CComPtr<IAMMediaStream> > m_Streams;
        FILTER_STATE    	 m_State;

        IFilterGraph    	*m_pGraph;
        CComPtr<IMediaPosition>	 m_pMediaPosition;
        CComPtr<IReferenceClock> m_pClock;
        REFERENCE_TIME          m_rtStart;

        //  Unknown goes first since it is released last
        IUnknown *                m_pUnknownSeekAgg;

        //
        //  Alarm lists
        //
        CAlarm                  *m_pFirstFreeAlarm;
        CAlarm                  *m_pFirstActiveAlarm;

        //  End of stream tracking
        int                      m_nAtEOS;

};

#endif //__SFILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\strmobjs\stdafx.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#define _ATL_STATIC_REGISTRY
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__242C8F45_9AE6_11D0_8212_00C04FC32C45__INCLUDED_)
#define AFX_STDAFX_H__242C8F45_9AE6_11D0_8212_00C04FC32C45__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
//#include "crtfree.h"
#include <atlcom.h>
#include <ddraw.h>
#include <mmstream.h>
#include <ddstream.h>
#include <amstream.h>
#include <austream.h>


//  Debugging
#ifdef DEBUG
extern BOOL bDbgTraceFunctions;
extern BOOL bDbgTraceInterfaces;
extern BOOL bDbgTraceTimes;
LPWSTR inline TextFromGUID(REFGUID guid) {
    WCHAR *pch = (WCHAR *)_alloca((CHARS_IN_GUID + 1) * sizeof(WCHAR));
    StringFromGUID2(guid, pch, (CHARS_IN_GUID + 1) * sizeof(TCHAR));
    return pch;
}
LPTSTR inline TextFromPurposeId(REFMSPID guid) {
    if (guid == MSPID_PrimaryAudio) {
        return _T("MSPID_PrimaryAudio");
    } else
    if (guid == MSPID_PrimaryVideo) {
        return _T("MSPID_PrimaryVideo");
    } else
    {
        return _T("Unrecognized PurposeId");
    }
}
#define TRACEFUNC  if (bDbgTraceFunctions) ATLTRACE(_T("AMSTREAM.DLL : ")), ATLTRACE
#define TRACEINTERFACE if (bDbgTraceFunctions || bDbgTraceInterfaces) ATLTRACE(_T("AMSTREAM.DLL : ")), ATLTRACE
#else
#define TRACEFUNC ATLTRACE
#define TRACEINTERFACE ATLTRACE
#define TextFromGUID(_x_) 0
#define TextFromPurposeId(_x_) 0
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__242C8F45_9AE6_11D0_8212_00C04FC32C45__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\strmobjs\strmobjs.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
// strmobjs.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f strmobjsps.mk in the project directory.

#define CPP_FUNCTIONS
#include "stdafx.h"
#include <ddraw.h>
#include "resource.h"
#include "strmobjs.h"
//#include "strmobjs_i.c"
#include <strmif.h>
#include <control.h>
#include <uuids.h>
#include <vfwmsgs.h>
#include <amutil.h>
#include "stream.h"
#include "ddstrm.h"
#include "sample.h"
#include "util.h"
#include "bytestrm.h"
#include "austrm.h"
#include <initguid.h>
#include "ddrawex.h"
#include "amguids.h"
#include "SFilter.h"
#include "ammstrm.h"
#include "mss.h"
#include "medsampl.h"

CComModule _Module;

//  Debugging
#ifdef DEBUG
BOOL bDbgTraceFunctions;
BOOL bDbgTraceInterfaces;
BOOL bDbgTraceTimes;
#endif

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_MediaStreamFilter, CMediaStreamFilter)
    OBJECT_ENTRY(CLSID_AMMultiMediaStream, CMMStream)
    OBJECT_ENTRY(CLSID_AMDirectDrawStream, CDDStream)
    OBJECT_ENTRY(CLSID_AMAudioStream, CAudioStream)
    OBJECT_ENTRY(CLSID_AMAudioData, CAudioData)
    OBJECT_ENTRY(CLSID_AMMediaTypeStream, CAMMediaTypeStream)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
#ifdef DEBUG
        bDbgTraceFunctions = GetProfileInt(_T("AMSTREAM"), _T("Functions"), 0);
        bDbgTraceInterfaces = GetProfileInt(_T("AMSTREAM"), _T("Interfaces"), 0);
        bDbgTraceTimes = GetProfileInt(_T("AMSTREAM"), _T("TimeStamps"), 0);
#endif
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();

    TRACEFUNC(_T("DllEntryPoint(0x%8.8X, %d, 0x%8.8X\n)"),
              hInstance, dwReason, 0);
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    TRACEFUNC(_T("DllCanUnloadNow\n"));
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    TRACEFUNC(_T("DllGetClassObject(%s, %s, 0x%8.8X)\n"),
              TextFromGUID(rclsid), TextFromGUID(riid), ppv);
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    TRACEFUNC(_T("DllRegisterServer\n"));
    // registers object, typelib and all interfaces in typelib
    HRESULT hr = _Module.RegisterServer(TRUE);
    // Don't care if the typelib doesn't load on win95 gold
    if (hr == TYPE_E_INVDATAREAD || hr == TYPE_E_CANTLOADLIBRARY) {
        hr = S_OK;
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    TRACEFUNC(_T("DllUnregisterServer\n"));
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\writer\write.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include <windows.h>
#include <stdio.h>
#include "strmif.h"
#include "uuids.h"
#include "ddraw.h"
#include "mmstream.h"
#include "amstream.h"
#include "ddstream.h"

typedef HRESULT (STDAPICALLTYPE * PFNSAMPLECALLBACK) (IStreamSample *pSource,
                                                      IStreamSample *pDest,
                                                      void * pvContext);

#define RELEASE(x) if (x) { (x)->Release(); (x) = NULL; };
#define CHECK_ERROR(x)     \
   if (FAILED(hr = (x))) { \
       printf(#x "  failed with HRESULT(0x%8.8X)\n", hr); \
       goto Exit;          \
   }


#define MAX_COPY_STREAMS 5

class CopyPair {
public:
    IStreamSample *pSource;
    IStreamSample *pDest;
    PFNSAMPLECALLBACK pCallback;
    void * pCallbackContext;
    HRESULT hrLastStatus;
    bool    bReading;
};



class CCopyEngine
{
public:
    CCopyEngine() : m_cNumPairs(0) {};
    ~CCopyEngine();

    HRESULT CopyMediaStream(IMultiMediaStream *pSourceStream,
                            IMultiMediaStream *pDestStream,
                            REFMSPID PurposeId,
                            PFNSAMPLECALLBACK pCallback = NULL,
                            void * pContext = NULL);

    HRESULT AddCopyPair(IStreamSample *pSource, IStreamSample *pDest,
                        PFNSAMPLECALLBACK pCallback = NULL, void * pvContext = NULL);
    HRESULT CopyStreamData();

private:
    CopyPair        m_aPair[MAX_COPY_STREAMS];
    HANDLE          m_aEvent[MAX_COPY_STREAMS];
    int             m_cNumPairs;
};

HRESULT CCopyEngine::AddCopyPair(IStreamSample *pSource, IStreamSample *pDest,
                                 PFNSAMPLECALLBACK pCallback, void * pContext)
{
    if (m_cNumPairs >= MAX_COPY_STREAMS) {
        return E_FAIL;
    }
    HANDLE hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!hEvent) {
        return E_OUTOFMEMORY;
    }
    pSource->AddRef();
    pDest->AddRef();
    m_aEvent[m_cNumPairs] = hEvent;
    m_aPair[m_cNumPairs].pSource = pSource;
    m_aPair[m_cNumPairs].pDest = pDest;
    m_aPair[m_cNumPairs].pCallback = pCallback;
    m_aPair[m_cNumPairs].pCallbackContext = pContext;
    m_cNumPairs++;
    return NOERROR;
}


HRESULT CCopyEngine::CopyMediaStream(IMultiMediaStream *pSourceMMStream,
                                     IMultiMediaStream *pDestMMStream,
                                     REFMSPID PurposeId,
                                     PFNSAMPLECALLBACK pCallback, void * pContext)
{
    HRESULT hr = E_FAIL;    // Assume it won't work.
    IMediaStream *pSource;
    if (pSourceMMStream->GetMediaStream(PurposeId, &pSource) == NOERROR) {
        IMediaStream *pDest;
        if (pDestMMStream->GetMediaStream(PurposeId, &pDest) == NOERROR) {
            IStreamSample *pSourceSample;
            hr = pSource->AllocateSample(0, &pSourceSample);
            if (SUCCEEDED(hr)) {
                IStreamSample *pDestSample;
                hr = pDest->CreateSharedSample(pSourceSample, 0, &pDestSample);
                if (SUCCEEDED(hr)) {
                    hr = AddCopyPair(pSourceSample, pDestSample, pCallback, pContext);
                    pDestSample->Release();
                }
                pSourceSample->Release();                    
            }
            pDest->Release();
        }
        pSource->Release();
    }
    return hr;
}

HRESULT CCopyEngine::CopyStreamData()
{
    if (m_cNumPairs == 0) {
        return S_FALSE;
    }
    int i;
    for (i = 0; i < m_cNumPairs; i++) {
        m_aPair[i].hrLastStatus = NOERROR;
        m_aPair[i].bReading = true;
        m_aPair[i].pSource->Update(0, m_aEvent[i], NULL, 0);
    }
    int NumRunning = i;
    while (NumRunning > 0) {
        DWORD dwWaitRet = WaitForMultipleObjects(m_cNumPairs, m_aEvent, FALSE, INFINITE);
        if (dwWaitRet >= WAIT_OBJECT_0 && dwWaitRet < WAIT_OBJECT_0 + m_cNumPairs) {
            int iCompleted = dwWaitRet - WAIT_OBJECT_0;
            CopyPair *pPair = &m_aPair[iCompleted];
            IStreamSample *pDone = pPair->bReading ? pPair->pSource : pPair->pDest;
            pPair->hrLastStatus = pDone->CompletionStatus(0, 0);
            if (pPair->hrLastStatus == NOERROR) {
                if (pPair->bReading) {
                    STREAM_TIME stStart, stStop;
                    if (pPair->pCallback) {
                        pPair->pCallback(pPair->pSource, pPair->pDest, pPair->pCallbackContext);
                    }
                    pPair->pSource->GetSampleTimes(&stStart, &stStop, NULL);
                    pPair->pDest->SetSampleTimes(&stStart, &stStop);
                    pPair->pDest->Update(0, m_aEvent[iCompleted], NULL, 0);
                    pPair->bReading = false;
                } else {
                    pPair->pSource->Update(0, m_aEvent[iCompleted], NULL, 0);
                    pPair->bReading = true;
                }
            } else {
                if (pPair->bReading && pPair->hrLastStatus == MS_S_ENDOFSTREAM) {
                    IMediaStream *pStream;
                    pPair->pDest->GetMediaStream(&pStream);
                    pStream->SendEndOfStream(0);
                    pStream->Release();
                    ResetEvent(m_aEvent[iCompleted]);
                }
                NumRunning--;
            }
        }
    }
    return NOERROR;
}


CCopyEngine::~CCopyEngine()
{
    int i;
    for (i = 0; i < m_cNumPairs; i++) {
        CloseHandle(m_aEvent[i]);
        m_aPair[i].pSource->Release();
        m_aPair[i].pDest->Release();
    }
}





HRESULT STDAPICALLTYPE ArcEffect(IStreamSample *pSource, IStreamSample *pDest, void * pvPrimarySurface)
{
    static int iFrame = 0;
    IDirectDrawStreamSample *pSample;
    if (pSource->QueryInterface(IID_IDirectDrawStreamSample, (void **)&pSample) == NOERROR) {
        IDirectDrawSurface *pSurface;
        IDirectDrawSurface *pPrimarySurface = (IDirectDrawSurface *)pvPrimarySurface;
        RECT rect;
        if (SUCCEEDED(pSample->GetSurface(&pSurface, &rect))) {
            HDC hdc;
            if (SUCCEEDED(pSurface->GetDC(&hdc))) {
                Ellipse(hdc, 0, 0, (iFrame * 2) % rect.right, iFrame % rect.bottom);
                pSurface->ReleaseDC(hdc);
            }
            pPrimarySurface->Blt(&rect, pSurface, &rect, DDBLT_WAIT, NULL);
            pSurface->Release();
        }
        pSample->Release();
    }
    iFrame ++;
    return NOERROR;
}


/*

HRESULT PolylineEffectToSample(IDirectDrawStreamSample *pSample)
{
    IDirectDrawSurface *pSurface = NULL;
    RECT rect;
    HRESULT hr;
    POINT pt[2] = {0};
    HDC hdc;
    
    CHECK_ERROR(pSample->GetSurface(&pSurface, &rect));
    pt[1].x = iFrame % rect.right;
    pt[1].y = rect.bottom;
    CHECK_ERROR(pSurface->GetDC(&hdc));
    Polyline(hdc, pt, 2);
    pSurface->ReleaseDC(hdc);
    iFrame ++;

Exit:
    RELEASE(pSurface);
    return hr;
}

*/

HRESULT FindCompressor(REFCLSID rcidCategory,
                       int Index,
                       IBaseFilter **ppFilter)
{
    *ppFilter = NULL;
    ICreateDevEnum *pCreateDevEnum = NULL;
    IEnumMoniker *pEm = NULL;
    IMoniker *pMoniker = NULL;
    ULONG cFetched;
    HRESULT hr;

    CHECK_ERROR(CoCreateInstance(
			  CLSID_SystemDeviceEnum,
			  NULL,
			  CLSCTX_INPROC_SERVER,
			  IID_ICreateDevEnum,
			  (void**)&pCreateDevEnum));
    CHECK_ERROR(pCreateDevEnum->CreateClassEnumerator(rcidCategory, &pEm, 0));
    if (Index) {
        pEm->Skip(Index);
    }
    CHECK_ERROR(pEm->Next(1, &pMoniker, &cFetched));
    if (cFetched == 1) {
        hr = pMoniker->BindToObject(NULL, NULL, IID_IBaseFilter, (void **)ppFilter);
    }
Exit:
    RELEASE(pMoniker);
    RELEASE(pCreateDevEnum);
    RELEASE(pEm);
    return hr;
}

HRESULT CreateStreamWithSameFormat(IAMMultiMediaStream *pAMStream,
                                   IMultiMediaStream *pSourceMMStream,
                                   REFMSPID PurposeId,
                                   IMediaStream **ppNewMediaStream)
{
    IMediaStream *pSource;
    HRESULT hr = pSourceMMStream->GetMediaStream(PurposeId, &pSource);
    if (SUCCEEDED(hr)) {
        hr = pAMStream->AddMediaStream(pSource, &PurposeId, AMMSF_CREATEPEER, ppNewMediaStream);
        pSource->Release();
    }
    return hr;
}

HRESULT CreateWriterStream(const char * pszOutputFileName,
                           IMultiMediaStream *pSourceMMStream,
                           IDirectDraw *pDD,
                           IMultiMediaStream **ppMMStream)
{
	static LPWSTR szVideoRender = L"@device:sw:CLSID\\{083863F1-70DE-11D0-BD40-00A0C911CE86}\\Instance\\{70E102B0-5556-11CE-97C0-00AA0055595A}";
    *ppMMStream = NULL;
    IAMMultiMediaStream *pAMStream = NULL;
    IMediaStream *pVideoStream = NULL;
    IMediaStream *pAudioStream = NULL;
    ICaptureGraphBuilder *pBuilder = NULL;
    IGraphBuilder *pFilterGraph = NULL;
    IFileSinkFilter *pFileSinkWriter = NULL;
    IBaseFilter *pVideoCompressFilter = NULL;
    IBaseFilter *pMuxFilter = NULL;
    
    HRESULT hr;
    WCHAR       wPath[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, pszOutputFileName, -1, wPath, sizeof(wPath)/sizeof(wPath[0]));

    CHECK_ERROR(CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER,
				 IID_IAMMultiMediaStream, (void **)&pAMStream));
    CHECK_ERROR(pAMStream->Initialize(STREAMTYPE_WRITE, 0, NULL));

    CHECK_ERROR(CreateStreamWithSameFormat(pAMStream, pSourceMMStream, MSPID_PrimaryVideo, &pVideoStream));
    CHECK_ERROR(CreateStreamWithSameFormat(pAMStream, pSourceMMStream, MSPID_PrimaryAudio, &pAudioStream));

    CHECK_ERROR(pAMStream->GetFilterGraph(&pFilterGraph));

	// Create a new Bind Context (connects a file to an object type)
	LPBC lpBC;
	CreateBindCtx(0, &lpBC);

	ULONG cchEaten;
	IMoniker *pMoniker;
	hr = MkParseDisplayName(lpBC, szVideoRender, &cchEaten, &pMoniker);
	if( SUCCEEDED(hr) ) {
		IBaseFilter *pVideoRenderFilter = 0;
		hr = pMoniker->BindToObject(0, 0, IID_IBaseFilter, (void**)&pVideoRenderFilter);
		if( SUCCEEDED(hr) ) {
			pFilterGraph->AddFilter(pVideoRenderFilter, L"Video Renderer");
			pVideoRenderFilter->Release();
		}			
		pMoniker->Release();
	}

	pAMStream->Render(0);
	/*
    CHECK_ERROR(CoCreateInstance(CLSID_CaptureGraphBuilder, NULL, CLSCTX_INPROC_SERVER,
                                 IID_ICaptureGraphBuilder, (void **)&pBuilder));

    CHECK_ERROR(pBuilder->SetFiltergraph(pFilterGraph));
    
    CHECK_ERROR(pBuilder->SetOutputFileName(&MEDIASUBTYPE_Avi, wPath, &pMuxFilter, &pFileSinkWriter));

    CHECK_ERROR(FindCompressor(CLSID_VideoCompressorCategory, 1, &pVideoCompressFilter));
    CHECK_ERROR(pFilterGraph->AddFilter(pVideoCompressFilter, L"Video Compression filter"))

    CHECK_ERROR(pBuilder->RenderCompressionStream(pVideoStream, pVideoCompressFilter, pMuxFilter));
    CHECK_ERROR(pBuilder->RenderCompressionStream(pAudioStream, NULL, pMuxFilter));
*/
    *ppMMStream = pAMStream;
    pAMStream->AddRef();

Exit:
    if (pAMStream == NULL) {
	printf("Could not create a CLSID_MultiMediaStream object\n"
	       "Check you have run regsvr32 amstream.dll\n");
    }
    RELEASE(pAMStream);
    RELEASE(pBuilder);
    RELEASE(pFilterGraph);
    RELEASE(pFileSinkWriter);
    RELEASE(pVideoCompressFilter);
    RELEASE(pMuxFilter);
    RELEASE(pVideoStream);
    RELEASE(pAudioStream);
    
    return hr;
}


HRESULT OpenReadMMStream(const char * pszFileName, IDirectDraw *pDD, IMultiMediaStream **ppMMStream)
{
    *ppMMStream = NULL;
    IAMMultiMediaStream *pAMStream;
    HRESULT hr;

    CHECK_ERROR(CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER,
				 IID_IAMMultiMediaStream, (void **)&pAMStream));
    CHECK_ERROR(pAMStream->Initialize(STREAMTYPE_READ, 0, NULL));
    CHECK_ERROR(pAMStream->AddMediaStream(pDD, &MSPID_PrimaryVideo, 0, NULL));
    CHECK_ERROR(pAMStream->AddMediaStream(NULL, &MSPID_PrimaryAudio, 0, NULL));

    WCHAR       wPath[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, pszFileName, -1, wPath, sizeof(wPath)/sizeof(wPath[0]));

    CHECK_ERROR(pAMStream->OpenFile(wPath, 0));

    *ppMMStream = pAMStream;
    pAMStream->AddRef();

Exit:
    if (pAMStream == NULL) {
	printf("Could not create a CLSID_MultiMediaStream object\n"
	       "Check you have run regsvr32 amstream.dll\n");
    }
    RELEASE(pAMStream);
    return hr;
}



HRESULT RenderStreamToSurface(IDirectDraw *pDD, IDirectDrawSurface *pPrimary,
			      IMultiMediaStream *pReadStream,
                              IMultiMediaStream *pWriteStream)
{
    HRESULT hr;
    CCopyEngine Engine;

    CHECK_ERROR(Engine.CopyMediaStream(pReadStream, pWriteStream, MSPID_PrimaryVideo, ArcEffect, pPrimary));
    CHECK_ERROR(Engine.CopyMediaStream(pReadStream, pWriteStream, MSPID_PrimaryAudio));

    CHECK_ERROR(pReadStream->SetState(STREAMSTATE_RUN));
    CHECK_ERROR(pWriteStream->SetState(STREAMSTATE_RUN));

    Engine.CopyStreamData();

    pReadStream->SetState(STREAMSTATE_STOP);
    pWriteStream->SetState(STREAMSTATE_STOP);

Exit:
    return hr;
}


int _CRTAPI1
main(
    int argc,
    char *argv[]
    )
{
    if (argc < 2) {
	printf("Usage : writer movie.ext\n");
	exit(0);
    }
    CoInitialize(NULL);
    IDirectDraw *pDD;

    HRESULT hr = DirectDrawCreate(NULL, &pDD, NULL);
    if (SUCCEEDED(hr)) {
	DDSURFACEDESC ddsd;
	IDirectDrawSurface *pPrimarySurface;

	pDD->SetCooperativeLevel(GetDesktopWindow(), DDSCL_NORMAL);

	ddsd.dwSize = sizeof(ddsd);
	ddsd.dwFlags = DDSD_CAPS;
	ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
//	ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
	hr = pDD->CreateSurface(&ddsd, &pPrimarySurface, NULL);
	if (SUCCEEDED(hr)) {
	    IMultiMediaStream *pReadStream;
	    hr = OpenReadMMStream(argv[1], pDD, &pReadStream);
	    if (SUCCEEDED(hr)) {
                IMultiMediaStream *pWriteStream;
                hr = CreateWriterStream("C:\\TEST.AVI", pReadStream, pDD, &pWriteStream);
                if (SUCCEEDED(hr)) {
		    RenderStreamToSurface(pDD, pPrimarySurface, pReadStream, pWriteStream);
                    pWriteStream->Release();
                }
                pReadStream->Release();
	    }
	    pPrimarySurface->Release();
	}
	pDD->Release();
    } else {
	printf("Could not open DirectDraw - check it is installed\n");
    }
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\streams\writer\main.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include <windows.h>
#include <stdio.h>
#include "strmif.h"
#include "uuids.h"
#include "ddraw.h"
#include "mmstream.h"
#include "amstream.h"
#include "ddstream.h"

typedef HRESULT (STDAPICALLTYPE * PFNSAMPLECALLBACK) (IStreamSample *pSource,
                                                      IStreamSample *pDest,
                                                      void * pvContext);

#define RELEASE(x) if (x) { (x)->Release(); (x) = NULL; };
#define CHECK_ERROR(x)     \
   if (FAILED(hr = (x))) { \
       printf(#x "  failed with HRESULT(0x%8.8X)\n", hr); \
       goto Exit;          \
   }


#define MAX_COPY_STREAMS 5

class CopyPair {
public:
    IStreamSample *pSource;
    IStreamSample *pDest;
    PFNSAMPLECALLBACK pCallback;
    void * pCallbackContext;
    HRESULT hrLastStatus;
    bool    bReading;
};



class CCopyEngine
{
public:
    CCopyEngine() : m_cNumPairs(0) {};
    ~CCopyEngine();

    HRESULT CopyMediaStream(IMultiMediaStream *pSourceStream,
                            IMultiMediaStream *pDestStream,
                            REFMSPID PurposeId,
                            PFNSAMPLECALLBACK pCallback = NULL,
                            void * pContext = NULL);

    HRESULT AddCopyPair(IStreamSample *pSource, IStreamSample *pDest,
                        PFNSAMPLECALLBACK pCallback = NULL, void * pvContext = NULL);
    HRESULT CopyStreamData();

private:
    CopyPair        m_aPair[MAX_COPY_STREAMS];
    HANDLE          m_aEvent[MAX_COPY_STREAMS];
    int             m_cNumPairs;
};

HRESULT CCopyEngine::AddCopyPair(IStreamSample *pSource, IStreamSample *pDest,
                                 PFNSAMPLECALLBACK pCallback, void * pContext)
{
    if (m_cNumPairs >= MAX_COPY_STREAMS) {
        return E_FAIL;
    }
    HANDLE hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!hEvent) {
        return E_OUTOFMEMORY;
    }
    pSource->AddRef();
    pDest->AddRef();
    m_aEvent[m_cNumPairs] = hEvent;
    m_aPair[m_cNumPairs].pSource = pSource;
    m_aPair[m_cNumPairs].pDest = pDest;
    m_aPair[m_cNumPairs].pCallback = pCallback;
    m_aPair[m_cNumPairs].pCallbackContext = pContext;
    m_cNumPairs++;
    return NOERROR;
}


HRESULT CCopyEngine::CopyMediaStream(IMultiMediaStream *pSourceMMStream,
                                     IMultiMediaStream *pDestMMStream,
                                     REFMSPID PurposeId,
                                     PFNSAMPLECALLBACK pCallback, void * pContext)
{
    HRESULT hr = E_FAIL;    // Assume it won't work.
    IMediaStream *pSource;
    if (pSourceMMStream->GetMediaStream(PurposeId, &pSource) == NOERROR) {
        IMediaStream *pDest;
        if (pDestMMStream->GetMediaStream(PurposeId, &pDest) == NOERROR) {
            IStreamSample *pSourceSample;
            hr = pSource->AllocateSample(0, &pSourceSample);
            if (SUCCEEDED(hr)) {
                IStreamSample *pDestSample;
                hr = pDest->CreateSharedSample(pSourceSample, 0, &pDestSample);
                if (SUCCEEDED(hr)) {
                    hr = AddCopyPair(pSourceSample, pDestSample, pCallback, pContext);
                    pDestSample->Release();
                }
                pSourceSample->Release();
            }
            pDest->Release();
        }
        pSource->Release();
    }
    return hr;
}

HRESULT CCopyEngine::CopyStreamData()
{
    if (m_cNumPairs == 0) {
        return S_FALSE;
    }
    int i;
    for (i = 0; i < m_cNumPairs; i++) {
        m_aPair[i].hrLastStatus = NOERROR;
        m_aPair[i].bReading = true;
        m_aPair[i].pSource->Update(0, m_aEvent[i], NULL, 0);
    }
    int NumRunning = i;
    while (NumRunning > 0) {
        DWORD dwWaitRet = WaitForMultipleObjects(m_cNumPairs, m_aEvent, FALSE, INFINITE);
        if (dwWaitRet >= WAIT_OBJECT_0 && dwWaitRet < WAIT_OBJECT_0 + m_cNumPairs) {
            int iCompleted = dwWaitRet - WAIT_OBJECT_0;
            CopyPair *pPair = &m_aPair[iCompleted];
            IStreamSample *pDone = pPair->bReading ? pPair->pSource : pPair->pDest;
            pPair->hrLastStatus = pDone->CompletionStatus(0, 0);
            if (pPair->hrLastStatus == NOERROR) {
                if (pPair->bReading) {
                    STREAM_TIME stStart, stStop;
                    if (pPair->pCallback) {
                        pPair->pCallback(pPair->pSource, pPair->pDest, pPair->pCallbackContext);
                    }
                    pPair->pSource->GetSampleTimes(&stStart, &stStop, NULL);
                    pPair->pDest->SetSampleTimes(&stStart, &stStop);
                    pPair->pDest->Update(0, m_aEvent[iCompleted], NULL, 0);
                    pPair->bReading = false;
                } else {
                    pPair->pSource->Update(0, m_aEvent[iCompleted], NULL, 0);
                    pPair->bReading = true;
                }
            } else {
                if (pPair->bReading && pPair->hrLastStatus == MS_S_ENDOFSTREAM) {
                    IMediaStream *pStream;
                    pPair->pDest->GetMediaStream(&pStream);
                    pStream->SendEndOfStream(0);
                    pStream->Release();
                    ResetEvent(m_aEvent[iCompleted]);
                }
                NumRunning--;
            }
        }
    }
    return NOERROR;
}


CCopyEngine::~CCopyEngine()
{
    int i;
    for (i = 0; i < m_cNumPairs; i++) {
        CloseHandle(m_aEvent[i]);
        m_aPair[i].pSource->Release();
        m_aPair[i].pDest->Release();
    }
}





HRESULT STDAPICALLTYPE ArcEffect(IStreamSample *pSource, IStreamSample *pDest, void * pvPrimarySurface)
{
    static int iFrame = 0;
    IDirectDrawStreamSample *pSample;
    if (pSource->QueryInterface(IID_IDirectDrawStreamSample, (void **)&pSample) == NOERROR) {
        IDirectDrawSurface *pSurface;
        IDirectDrawSurface *pPrimarySurface = (IDirectDrawSurface *)pvPrimarySurface;
        RECT rect;
        if (SUCCEEDED(pSample->GetSurface(&pSurface, &rect))) {
            HDC hdc;
            if (SUCCEEDED(pSurface->GetDC(&hdc))) {
                Ellipse(hdc, 0, 0, (iFrame * 2) % rect.right, iFrame % rect.bottom);
            }
            pSurface->ReleaseDC(hdc);
            pPrimarySurface->Blt(&rect, pSurface, &rect, DDBLT_WAIT, NULL);
            pSurface->Release();
        }
        pSample->Release();
    }
    iFrame ++;
    return NOERROR;
}


/*

HRESULT PolylineEffectToSample(IDirectDrawStreamSample *pSample)
{
    IDirectDrawSurface *pSurface = NULL;
    RECT rect;
    HRESULT hr;
    POINT pt[2] = {0};
    HDC hdc;

    CHECK_ERROR(pSample->GetSurface(&pSurface, &rect));
    pt[1].x = iFrame % rect.right;
    pt[1].y = rect.bottom;
    CHECK_ERROR(pSurface->GetDC(&hdc));
    Polyline(hdc, pt, 2);
    pSurface->ReleaseDC(hdc);
    iFrame ++;

Exit:
    RELEASE(pSurface);
    return hr;
}

*/

HRESULT FindCompressor(REFCLSID rcidCategory,
                       int Index,
                       IBaseFilter **ppFilter)
{
    *ppFilter = NULL;
    ICreateDevEnum *pCreateDevEnum = NULL;
    IEnumMoniker *pEm = NULL;
    IMoniker *pMoniker = NULL;
    ULONG cFetched;
    HRESULT hr;

    CHECK_ERROR(CoCreateInstance(
			  CLSID_SystemDeviceEnum,
			  NULL,
			  CLSCTX_INPROC_SERVER,
			  IID_ICreateDevEnum,
			  (void**)&pCreateDevEnum));
    CHECK_ERROR(pCreateDevEnum->CreateClassEnumerator(rcidCategory, &pEm, 0));
    if (Index) {
        pEm->Skip(Index);
    }
    CHECK_ERROR(pEm->Next(1, &pMoniker, &cFetched));
    if (cFetched == 1) {
        hr = pMoniker->BindToObject(NULL, NULL, IID_IBaseFilter, (void **)ppFilter);
    }
Exit:
    RELEASE(pMoniker);
    RELEASE(pCreateDevEnum);
    RELEASE(pEm);
    return hr;
}

HRESULT CreateStreamWithSameFormat(IAMMultiMediaStream *pAMStream,
                                   IMultiMediaStream *pSourceMMStream,
                                   REFMSPID PurposeId,
                                   IMediaStream **ppNewMediaStream)
{
    IMediaStream *pSource;
    HRESULT hr = pSourceMMStream->GetMediaStream(PurposeId, &pSource);
    if (SUCCEEDED(hr)) {
        hr = pAMStream->AddMediaStream(pSource, &PurposeId, AMMSF_CREATEPEER, ppNewMediaStream);
        pSource->Release();
    }
    return hr;
}

HRESULT CreateWriterStream(const char * pszOutputFileName,
                           IMultiMediaStream *pSourceMMStream,
                           IDirectDraw *pDD,
                           IMultiMediaStream **ppMMStream)
{
    *ppMMStream = NULL;
    IAMMultiMediaStream *pAMStream = NULL;
    IMediaStream *pVideoStream = NULL;
    IMediaStream *pAudioStream = NULL;
    ICaptureGraphBuilder *pBuilder = NULL;
    IGraphBuilder *pFilterGraph = NULL;
    IFileSinkFilter *pFileSinkWriter = NULL;
    IBaseFilter *pVideoCompressFilter = NULL;
    IBaseFilter *pMuxFilter = NULL;

    HRESULT hr;
    WCHAR       wPath[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, pszOutputFileName, -1, wPath, sizeof(wPath)/sizeof(wPath[0]));

    CHECK_ERROR(CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER,
				 IID_IAMMultiMediaStream, (void **)&pAMStream));
    CHECK_ERROR(pAMStream->Initialize(STREAMTYPE_WRITE, 0, NULL));

    CHECK_ERROR(CreateStreamWithSameFormat(pAMStream, pSourceMMStream, MSPID_PrimaryVideo, &pVideoStream));
    CHECK_ERROR(CreateStreamWithSameFormat(pAMStream, pSourceMMStream, MSPID_PrimaryAudio, &pAudioStream));

    CHECK_ERROR(CoCreateInstance(CLSID_CaptureGraphBuilder, NULL, CLSCTX_INPROC_SERVER,
                                 IID_ICaptureGraphBuilder, (void **)&pBuilder));

    CHECK_ERROR(pAMStream->GetFilterGraph(&pFilterGraph));
    CHECK_ERROR(pBuilder->SetFiltergraph(pFilterGraph));

    CHECK_ERROR(pBuilder->SetOutputFileName(&MEDIASUBTYPE_Avi, wPath, &pMuxFilter, &pFileSinkWriter));

    CHECK_ERROR(FindCompressor(CLSID_VideoCompressorCategory, 1, &pVideoCompressFilter));
    CHECK_ERROR(pFilterGraph->AddFilter(pVideoCompressFilter, L"Video Compression filter"))

    CHECK_ERROR(pBuilder->RenderStream(NULL, NULL, pVideoStream, pVideoCompressFilter, pMuxFilter));
    CHECK_ERROR(pBuilder->RenderStream(NULL, NULL, pAudioStream, NULL, pMuxFilter));

    *ppMMStream = pAMStream;
    pAMStream->AddRef();

Exit:
    if (pAMStream == NULL) {
	printf("Could not create a CLSID_MultiMediaStream object\n"
	       "Check you have run regsvr32 amstream.dll\n");
    }
    RELEASE(pAMStream);
    RELEASE(pBuilder);
    RELEASE(pFilterGraph);
    RELEASE(pFileSinkWriter);
    RELEASE(pVideoCompressFilter);
    RELEASE(pMuxFilter);
    RELEASE(pVideoStream);
    RELEASE(pAudioStream);

    return hr;
}


HRESULT OpenReadMMStream(const char * pszFileName, IDirectDraw *pDD, IMultiMediaStream **ppMMStream)
{
    *ppMMStream = NULL;
    IAMMultiMediaStream *pAMStream;
    HRESULT hr;

    CHECK_ERROR(CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER,
				 IID_IAMMultiMediaStream, (void **)&pAMStream));
    CHECK_ERROR(pAMStream->Initialize(STREAMTYPE_READ, 0, NULL));
    CHECK_ERROR(pAMStream->AddMediaStream(pDD, &MSPID_PrimaryVideo, 0, NULL));
    CHECK_ERROR(pAMStream->AddMediaStream(NULL, &MSPID_PrimaryAudio, 0, NULL));

    WCHAR       wPath[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, pszFileName, -1, wPath, sizeof(wPath)/sizeof(wPath[0]));

    CHECK_ERROR(pAMStream->OpenFile(wPath, AMMSF_NOCLOCK));

    *ppMMStream = pAMStream;
    pAMStream->AddRef();

Exit:
    if (pAMStream == NULL) {
	printf("Could not create a CLSID_MultiMediaStream object\n"
	       "Check you have run regsvr32 amstream.dll\n");
    }
    RELEASE(pAMStream);
    return hr;
}



HRESULT RenderStreamToSurface(IDirectDraw *pDD, IDirectDrawSurface *pPrimary,
			      IMultiMediaStream *pReadStream,
                              IMultiMediaStream *pWriteStream)
{
    HRESULT hr;
    CCopyEngine Engine;

    CHECK_ERROR(Engine.CopyMediaStream(pReadStream, pWriteStream, MSPID_PrimaryVideo, ArcEffect, pPrimary));
    CHECK_ERROR(Engine.CopyMediaStream(pReadStream, pWriteStream, MSPID_PrimaryAudio));

    CHECK_ERROR(pReadStream->SetState(STREAMSTATE_RUN));
    CHECK_ERROR(pWriteStream->SetState(STREAMSTATE_RUN));

    Engine.CopyStreamData();

    pReadStream->SetState(STREAMSTATE_STOP);
    pWriteStream->SetState(STREAMSTATE_STOP);

Exit:
    return hr;
}


int _CRTAPI1
main(
    int argc,
    char *argv[]
    )
{
    if (argc < 2) {
	printf("Usage : writer movie.ext\n");
	exit(0);
    }
    CoInitialize(NULL);
    IDirectDraw *pDD;

    HRESULT hr = DirectDrawCreate(NULL, &pDD, NULL);
    if (SUCCEEDED(hr)) {
	DDSURFACEDESC ddsd;
	IDirectDrawSurface *pPrimarySurface;

	pDD->SetCooperativeLevel(GetDesktopWindow(), DDSCL_NORMAL);

	ddsd.dwSize = sizeof(ddsd);
	ddsd.dwFlags = DDSD_CAPS;
	ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
	hr = pDD->CreateSurface(&ddsd, &pPrimarySurface, NULL);
	if (SUCCEEDED(hr)) {
	    IMultiMediaStream *pReadStream;
	    hr = OpenReadMMStream(argv[1], pDD, &pReadStream);
	    if (SUCCEEDED(hr)) {
                IMultiMediaStream *pWriteStream;
                hr = CreateWriterStream("C:\\TEST.AVI", pReadStream, pDD, &pWriteStream);
                if (SUCCEEDED(hr)) {
		    RenderStreamToSurface(pDD, pPrimarySurface, pReadStream, pWriteStream);
                    pWriteStream->Release();
                }
                pReadStream->Release();
	    }
	    pPrimarySurface->Release();
	}
	pDD->Release();
    } else {
	printf("Could not open DirectDraw - check it is installed\n");
    }
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\timecode\tchelper.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
/**********************************************************************
Timecode helper routines

With a bit of care to not overflow or bruise the potentialy large numbers...
**********************************************************************/
#include <wtypes.h> // LONGLONG
#include <stdio.h>

LONGLONG extrapolate(LONGLONG sample1, LONGLONG time1, 
                     LONGLONG sample2, LONGLONG time2, LONGLONG sampleN)
{
LONGLONG sampleTime;

/* NOTE: deltas should be fairly small so we don't mind losing the bits */
double deltaSample = (double)(sample2 - sample1);
double deltaTime   = (double)(time2   - time1);
double ratio;

ratio = deltaTime / deltaSample;  // floating point ratio

sampleTime = LONGLONG((double)(sampleN - sample1) * ratio);

sampleTime+= time1; // add the offset

return(sampleTime);
}


#ifdef TEST
// XXX flesh out the test code!
main()
{
LONGLONG foo = extrapolate(1, 1, 6, 3, 2);

printf("%d",(int)foo);
}
#endif /* TEST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\timecode\ltcdcode.cpp ===
/**********************************************************************
Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.

LtcDecode, Ken Greenebaum, November 1996

A generic linear timecode decoder.  Pass it 16 bit mono PCM raw audio
samples and it will decode the LTC timecode encoded therein.

This code based on the LTC description in John Ratcliff's Timecode; A user's
 guide by  (second edition)
**********************************************************************/
#include <stdio.h>
#include <wtypes.h>
#include "ltcdcode.h"


/**********************************************************************
helper function to decode raw LTC bits found in the circular bit buffer
**********************************************************************/
int
compute(int begin, int bitNumber, int numBits, bitData ringBuffer[])
{
    int value = 0;
    int count;
    int index;

    index = (begin + bitNumber) % 80;
    for(count = 0; count < numBits; count++) {
        value+= ringBuffer[index].value << count;
        index = (index+1)%80;
    }

    return(value);
}


/**********************************************************************
initialize internal state
**********************************************************************/
LTCdecoder::LTCdecoder()
{
// XXX these should all be initialy computed based on format!
_bitWidth        =    0; // this will get set at the first bit...
_verticalEpsilon = 1024;

// values to reset
_waveState       =    0; // doesn't really matter where we start it
_sampleWidth     =    0; // reset bit width
_lastBit         =    0; // must be zero so we can legaly have a one!
_onesCount       =    0; // reset the sync detector
_samplesProcessed=    0; // total number of audio samples processed
_bitsRecorded    =    0;
_bufferIndex     =    0;
_syncSample      =    0;
_validTimeCode   =    0; // no, we don't have a valid timecode, yet
}


/**********************************************************************
Decode and return the user bits from the raw LTC decoded bits in the
ring buffer.

Returns True if there is a valid timecode in the ring buffer

In general this is only true immediately after the decode method returns
a non-zero timecode sample sync

See timecode page 33
**********************************************************************/
int 
LTCdecoder::getUserBits(LTCuserBits *bits)
{
    if(_validTimeCode) { // verify that valid timecode is in buffer
        int begin = (_bufferIndex - 78 + 80) % 80; // point to beggining of timecode

        bits->user1 = compute(begin,   4, 4, _ringBuffer);
        bits->user2 = compute(begin,  12, 4, _ringBuffer);
        bits->user3 = compute(begin,  20, 4, _ringBuffer);
        bits->user4 = compute(begin,  28, 4, _ringBuffer);
        bits->user5 = compute(begin,  36, 4, _ringBuffer);
        bits->user6 = compute(begin,  44, 4, _ringBuffer);
        bits->user7 = compute(begin,  52, 4, _ringBuffer);
        bits->user8 = compute(begin,  60, 4, _ringBuffer);
    }
    return(_validTimeCode);
}


/**********************************************************************
Return the audio sample corresponding to the beggining and the end of
the timecode.  

We should return a double when we want to get sub-sample accuracy and
split hairs!
**********************************************************************/
int
LTCdecoder::getStartStopSample(LONGLONG *start, LONGLONG *stop)
{
    if(_validTimeCode) { // verify that valid timecode is in buffer
        *start = _syncSample;
        *stop  = _endSample;
    }

    return(_validTimeCode);
}


/**********************************************************************
Decode and return the TimeCode from the raw LTC decoded bits in the
ring buffer.

Returns True if there is a valid timecode in the ring buffer

In general this is only true immediately after the decode method returns
a non-zero timecode sample sync

See timecode page 33
**********************************************************************/
int
LTCdecoder::getTimeCode(TimeCode *tc)
{
    if(_validTimeCode) { // verify that valid timecode is in buffer
        int hour, minute, second, frame;
        int begin = (_bufferIndex - 78 + 80) % 80; // point to beggining of timecode

        frame  =    compute(begin,  0, 4, _ringBuffer); // frame units 0-3 1,2,4,8
        frame += 10*compute(begin,  8, 2, _ringBuffer); // frame tens  0-1 1,2

        second =    compute(begin, 16, 4, _ringBuffer);
        second+= 10*compute(begin, 24, 3, _ringBuffer);

        minute =    compute(begin, 32, 4, _ringBuffer);
        minute+= 10*compute(begin, 40, 3, _ringBuffer);

        hour   =    compute(begin, 48, 4, _ringBuffer);
        hour  += 10*compute(begin, 56, 2, _ringBuffer);

        tc->SetTime(hour, minute, second, frame);   // XXX for now
    }
    return(_validTimeCode);
}


/**********************************************************************
add a bit to the ringbuffer.

Will return true if the sync bits at the end of a timecode are encountered.

NOTE: we don't have to reset _onesCount after finding sync, the next 0 will!
**********************************************************************/
int LTCdecoder::_addBuffer(int bit, LONGLONG sample)
{
_bitsRecorded++;
_ringBuffer[_bufferIndex].value  = bit;
_ringBuffer[_bufferIndex++].sample = sample;
_bufferIndex%=80;
_onesCount = bit ? (_onesCount + 1) : 0;

return((_onesCount==12)&&(_bitsRecorded>77));
}


/**********************************************************************
Accept a new hunk of audio, decode the bits present in it, and return
the sample number corresponding to the timeCode synch (Rising edge of Bit
Zero) if a timeCode was completed being decoded.
**********************************************************************/
int
LTCdecoder::decodeBuffer(short **buf, int *bufferSize)
{
int index;
int timeCodeFound = 0;
short *buffer = *buf;
int newWaveState;
int bit;

for(index = 0; (index < *bufferSize) && (!timeCodeFound); index++) {
   _samplesProcessed++; // another day another sample

   newWaveState = _waveState?(buffer[index]+_verticalEpsilon)>0
                            :(buffer[index]-_verticalEpsilon)>0;

   if(newWaveState==_waveState) {
      _sampleWidth++;
   }
   else { // new bit
       _waveState = newWaveState;

       if(4*_sampleWidth > 3 * _bitWidth) { // long?
           bit = 0;
           _bitWidth = _sampleWidth;
       }
       else {                               // short
           bit = (_lastBit==1)?2:1;           // only a valid one if following 0
           _bitWidth = 2*_sampleWidth;
       }
       _lastBit = bit;

#ifdef DEBUG
#if 0
       if(bit!=2)
           printf("%8d %d width= %d samples\n", 
               _bitsRecorded, bit, _sampleWidth);
#endif
#endif
       _sampleWidth = 0;

       if(bit!=2) { // valid bit
           if(this->_addBuffer(bit, _samplesProcessed-2)) { // add bit to the buffer
               // found sync!
               int begin = (_bufferIndex - 78 + 80) % 80; // beggining of timecode
               _syncSample = _ringBuffer[begin].sample; // return the sample at bit zero!

               // XXX this is not terribly accurate!  
               // Since we greedy decode tc before the final 2 bits are read
               // we add an approximate 2 bits of samples back in!
               // Since at 44.1KHz 2 bits is approximately 60 samples we
               // have definitely lost some accuracy.
               // (If people care about this value, we should wait until the
               //  entire TC is decoded and accurately determine this value!)
               _endSample = _samplesProcessed + 2 * _bitWidth;

               timeCodeFound = 1;
               _validTimeCode = 1;
           } /* sync found */
       } /* valid bit */
       else {
           _validTimeCode = 0;
       }
   } /* new bit */
}

*bufferSize-= index; 
(*buf)+= index;

return(timeCodeFound);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\timecode\ltcdcode.h ===
/**********************************************************************
Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved

LtcDecode, Ken Greenebaum, November 1996
**********************************************************************/
#ifndef _H_LTCDECODER
#define _H_LTCDECODER

#include <wtypes.h>
#include "timecode.h"

typedef struct bitData {
    int       value;
    LONGLONG sample;
} foo;


typedef struct LTCuserBits {
    int user1:4;
    int user2:4;
    int user3:4;
    int user4:4;
    int user5:4;
    int user6:4;
    int user7:4;
    int user8:4;
} bar;


class LTCdecoder {
  public:
    LTCdecoder(); // XXX really should spec format, rate...
    int decodeBuffer(short **buffer, int *bufferSize);
    int getTimeCode(TimeCode *tc); // convert LTC bits to SMPTE timecode
    int getUserBits(LTCuserBits *bits);
    int getStartStopSample(LONGLONG *start, LONGLONG *end);

  private:
    int _addBuffer(int bit, LONGLONG sample);    // store the bit and detect sync

    int _bitWidth;           // dynamicaly adjusted bit width
    int _sampleWidth;        // length of the state we are sampling
    int _verticalEpsilon;    // how close we have to be to the rail
    int _waveState;          // high or low
    int _lastBit;            // width of last bit (0-long, 1-short, 2-2nd short)

    // ring buffer
    bitData _ringBuffer[80];// this is where we keep our bits!
    int _bufferIndex;
    int _bitsRecorded;       // total number of bits intered (morbid, eh?)
    LONGLONG _samplesProcessed;   // number of audio samples processed
    int _validTimeCode;      // set if the ringBuffer contains a timecode

    // sync detector
    int _onesCount;          // track number of consequiative ones! (12==sync)
    LONGLONG _syncSample;    // the sample corresponding to the LTC sync
    LONGLONG _endSample;     // the sample corresponding to end of LTC

};

#endif /* _H_LTCDECODER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\timecode\tchelper.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
/**********************************************************************
Timecode helper routines
**********************************************************************/
#include <wtypes.h> // LONGLONG

LONGLONG extrapolate(LONGLONG sample1, LONGLONG time1, 
                     LONGLONG sample2, LONGLONG time2, LONGLONG sampleN);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\timecode\timecode.cpp ===
/**********************************************************************
Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.

TimeCode

A class to describe and manipulate SMPTE timecodes.

If we extend this class, fix its bugs, and use it in all applications,
then we will have consistent and error free code!

NOTE:  I have provided the dropframe math derivations in the code along
       with references to the appropriate texts.

TODO:  PAL Dropframe math. (fairly consistent, base it on the NTSC drop code)
       Check values and generate EXCEPTIONS on errs!
       Extend timecode class to other video types/rates
       Flesh out the operator overloads (+=,-=,+,- all make good sense)

Ken Greenebaum, November 1996
**********************************************************************/
#include <wtypes.h>
#include <stdio.h>
#include "timecode.h"

// Initialize constants!
const char TimeCode::NTSC_MODE         = (char)0x01;
const char TimeCode::PAL_MODE          = (char)0x00;
const char TimeCode::FORMAT_MASK       = (char)0xFE;

const char TimeCode::DROPFRAME_MODE    = (char)0x02;
const char TimeCode::NO_DROPFRAME_MODE = (char)0x00;
const char TimeCode::DROPFRAME_MASK    = (char)0xFD;

const char TimeCode::NTSC_NODROP       = NTSC_MODE | NO_DROPFRAME_MODE;
const char TimeCode::NTSC_DROP         = NTSC_MODE | DROPFRAME_MODE;
const char TimeCode::PAL_NODROP        = PAL_MODE  | NO_DROPFRAME_MODE;
const char TimeCode::PAL_DROP          = PAL_MODE  | DROPFRAME_MODE;


TimeCode::TimeCode()
{
    SetFormat(TRUE, FALSE); // NTSC, no dropframe
    SetTime(0, 0, 0, 0);    // 00:00:00:00
}


TimeCode::TimeCode(char *string, BOOL ntsc, BOOL drop)
{
    SetFormat(ntsc, drop);
    SetTime(string);
}


TimeCode::TimeCode(int h, int m, int s, int f, BOOL ntsc, BOOL d)
{
    SetFormat(ntsc, d);
    SetTime(h, m, s, f);
}


void 
TimeCode::operator++(int unusedPostfixThingy)      // postfix
{
    operator++(); // call the prefix operator for the sake of consistency
}


void 
TimeCode::operator++()      // prefix
{
    if(_frames.dirty)
        _FramesFromHMSF();

    _frames.frames++;
    _frames.dirty = FALSE;
    _hmsf.dirty   = TRUE;
}


void 
TimeCode::operator--(int unusedPostfixThingy)      // postfix
{
    operator--(); // call the prefix operator for the sake of consistency
}


void 
TimeCode::operator--()      // prefix
{
    if(_frames.dirty)
        _FramesFromHMSF();

    _frames.frames--;       // XXX shouldn't we check for wrap?
    _frames.dirty = FALSE;
    _hmsf.dirty   = TRUE;
}


void
TimeCode::SetFormat(BOOL ntsc, BOOL drop)
{
    _timeCodeFormat = (ntsc ? NTSC_MODE      : PAL_MODE) | 
                      (drop ? DROPFRAME_MODE : NO_DROPFRAME_MODE);
}


void
TimeCode::SetTime(int hours, int minutes, int seconds, int frames)
{
    _hmsf.hours   = hours;
    _hmsf.minutes = minutes;
    _hmsf.seconds = seconds;
    _hmsf.frames  = frames;
    _hmsf.dirty   = FALSE;
    _frames.dirty = TRUE;    // invalidate the frames cache

    // XXX should we sanity check the timecode value?
}


void
TimeCode::SetTime(char *string)
{
    sscanf(string, "%d:%d:%d:%d", 
        &_hmsf.hours, &_hmsf.minutes, &_hmsf.seconds, &_hmsf.frames);
    _hmsf.dirty   = FALSE;
    _frames.dirty = TRUE;    // invalidate the frames cache

    // XXX should we sanity check the timecode value?
}


void
TimeCode::GetTime(int *hours, int *minutes, int *seconds, int *frames)
{
    if(_hmsf.dirty)
        _HMSFfromFrames();

     *hours   = _hmsf.hours;
     *minutes = _hmsf.minutes;
     *seconds = _hmsf.seconds;
     *frames  = _hmsf.frames;
}


LONGLONG
TimeCode::GetTime()
{
    if(_frames.dirty)
        _FramesFromHMSF();

    return(_frames.frames);
}


void
TimeCode::GetString(char *string) {
    if(_hmsf.dirty)
        _HMSFfromFrames();

    wsprintf(string, "%02d:%02d:%02d:%02d",
         _hmsf.hours, _hmsf.minutes, _hmsf.seconds, _hmsf.frames);
}

/**********************************************************************
Dropframe math derivation:

NTSC dropframe Pg208 Video Demystified:

   To resolve the color timing error, the first two frame numbers 
(0, and 1) at the start of each minute, except for minutes 0, 10, 20, 30,
40, and 50, are omitted from the count.

So:

The number of frames of video in an NTSC dropframe hour = 
30 frames/second * 60 seconds/minute * 60 minutes/hour
   - 60 minutes * 2 frames dropped/minute
   +  6 excepted minutes * 2 frames not dropped

   = 107892

The number of frames of video in an NTSC dropframe minute = 
30 frames/second * 60 seconds/minute - 2 if minute != 0,10,20,30,40 or 50!

There are 6 10 minute cycles in an hour.

Each cycle has 17982 frames:
 9 dropframe min * ((30 frames/sec * 60 sec/min) - 2 dropframes/min) frames/min
 1   nondrop min * 30 frames/second * 60 sec/min

**********************************************************************/
void
TimeCode::_HMSFfromFrames()
{
    LONGLONG frames = _frames.frames;
    int units;
    int tmp;

    switch(_timeCodeFormat) {
        case NTSC_NODROP:
            _hmsf.hours   = (int)(frames / 108000.0); 
            frames-= _hmsf.hours   * 108000;

            _hmsf.minutes = (int)(frames /   1800.0); 
            frames-= _hmsf.minutes *   1800;

            _hmsf.seconds = (int)(frames /     30.0);            
            frames-= _hmsf.seconds *     30;

            _hmsf.frames  = (int)frames;
        break;

        case NTSC_DROP:
            _hmsf.hours   =      (int)(frames / 107892.0); 
            frames-= _hmsf.hours   * 107892;

            // remove 10 minute cycles
            tmp = (int)(frames /   17982.0); 
            _hmsf.minutes = 10 * tmp;
            frames-= tmp *   17982;

            // remaining minutes < complete 10 minute cycle

            // first minute (0) would not drop frames
            if(frames >= 1800) {
                _hmsf.minutes++;
                frames-=1800;

                tmp =      (int)(frames /   1798.0); 
                _hmsf.minutes+= tmp;
                frames-= tmp *   1798;
            }


            // remaining seconds <= 60

            _hmsf.seconds = 0;
            units = _hmsf.minutes - 10*(_hmsf.minutes/10); // remove 10s
            if(!units) { // the 0, 10, 20, 30, 40, 50 minute
                _hmsf.seconds = (int)(frames /     30.0);            
                frames-= _hmsf.seconds *     30;
            }
            else { // not an exception min(the 1st secof this min has 28frames)
                if(frames>=28) {
                    frames-=28;
                    _hmsf.seconds = 1;

                    // the rest are 30 frame seconds
                    _hmsf.seconds+= (int)(frames /   30.0); 
                    frames-= (_hmsf.seconds-1) *   30;
                }

            }

            _hmsf.frames  = (int)frames;
            _hmsf.frames += ((units)&&(_hmsf.seconds==0))?2:0; // a drop second
        break;

        case PAL_NODROP:
            _hmsf.hours   = (int)(frames /  90000.0); 
            frames-= _hmsf.hours   *  90000;

            _hmsf.minutes = (int)(frames /   1500.0); 
            frames-= _hmsf.minutes *   1500;

            _hmsf.seconds = (int)(frames /     25.0);            
            frames-= _hmsf.seconds *     25;

            _hmsf.frames  = (int)frames;
        break;

        case PAL_DROP: fprintf(stderr,
                "TimeCode::_HMSfromFrames: PAL_DROP not implemented!\n");
        break;

        default:
            // XXX really should throw an exception!
            fprintf(stderr, 
                "TimeCode::_HMSfromFrames: unknown _timeCodeFormat %d\n",
                _timeCodeFormat);
        break;
    }
    _hmsf.dirty = FALSE;
}


void
TimeCode::_FramesFromHMSF()
{
    LONGLONG frames;
    //int exceptionalMinutes;

    switch(_timeCodeFormat) {
        case NTSC_NODROP:
            frames = _hmsf.frames;
            frames+= _hmsf.seconds *     30;
            frames+= _hmsf.minutes *   1800; // 30f/s * 60s/min
            frames+= _hmsf.hours   * 108000; //30f/s*60s/min*60min/hr
        break;

        case NTSC_DROP: // see derivation for details!
            frames = _hmsf.hours   * 107892; // for every hour
            frames+= _hmsf.minutes *   1800; // for every minute, except...

            // now take away 2 frames per non-exempted minute!
            frames-= ((_hmsf.minutes - _hmsf.minutes/10) * 2);

            frames+= _hmsf.seconds *     30;
            frames+= _hmsf.frames;
        break;

        case PAL_NODROP:
            frames = _hmsf.frames;
            frames+= _hmsf.seconds *     25;
            frames+= _hmsf.minutes *   1500; // 25f/s * 60s/min
            frames+= _hmsf.hours   *  90000; //25f/s*60s/min*60min/hr
        break;

        case PAL_DROP: fprintf(stderr,
                "TimeCode::_HMSfromFrames: PAL_DROP not implemented!\n");
        break;

        default:
            // XXX really should throw an exception!
            fprintf(stderr, 
                "TimeCode::_HMSfromFrames: unknown _timeCodeFormat %d\n",
                _timeCodeFormat);
        break;
    }

    _frames.frames = frames;  // ;)
    _frames.dirty  = FALSE;
}


#ifdef TEST
#include <string.h>
#include <stdio.h>

__cdecl 
main()
{
    // TimeCode tc;   // NTSC nondrop
    // TimeCode tc("0:0:0:0", TRUE, FALSE); // NTSC nondrop
    // TimeCode tc("0:0:0:0", FALSE, FALSE); // PAL nondrop
    TimeCode tc1("0:0:0:0", TRUE, TRUE); // NTSC drop
    TimeCode tc2("0:0:0:0", TRUE, TRUE); // NTSC drop

    char string[TIMECODE_STRING_LENGTH];

    /* strcpy(string, "1:2:3:4"); */
    strcpy(string, "0:0:0:0");

    tc1.SetTime(string);
    tc1.GetString(string);
    printf("timecode = <%s>\n", string);

    int x;
    for (x= 0; x < 200000; x++) {
        tc1++;
        tc1.GetString(string);

        tc2.SetTime(string);

        printf("timecode = <%s> %s (%d)\n",
            string, tc1==tc2?"ok":"BAD!!!", (int)tc1.GetTime());
    }

    return(0);
}

#endif /* TEST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\timecode\test.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
/**********************************************************************
Code to test timecode routines
**********************************************************************/
#include <stdio.h>
#include "timecode.h"
#include "ltcdcode.h"

__cdecl
main(int argc)
{
    LTCdecoder decoder;
    TimeCode timeCode(0,0,0,0);
    // LTCuserBits userBits;
    char string[TIMECODE_STRING_LENGTH];
    const int BUFFERSIZE = 1024;
    short buffer[BUFFERSIZE];
    int bufferSize;

    if(argc>1) _asm int 3;  // XXX debug a program w/input from stdin!

    int done = 0;
    while(!done) {
        int index;

        // scoop up a buffer from stdin
        for(index = 0; (index < BUFFERSIZE) && (!done); index++) {
            done = (scanf("%d", &buffer[index])== -1);
            // printf("%d %d\n", index, buffer[index]);
        }

        short *ptr;
        for(bufferSize = index, ptr = buffer; bufferSize; ) {
            LONGLONG syncSample, endSample;

            // send buffer off to be decoded
            if(decoder.decodeBuffer(&ptr, &bufferSize)) {
                decoder.getStartStopSample(&syncSample, &endSample);
                decoder.getTimeCode(&timeCode);
                timeCode.GetString(string);
                printf("tc: %s (%d/%d)\n", 
                    string, (int)syncSample, (int)endSample);

#ifdef PRINTUSERBITS
                if(decoder.getUserBits(&userBits)) {
                    printf("%04x %04x %04x %04x %04x %04x %04x %04x\n",
                        userBits.user1, userBits.user2, userBits.user3,
                        userBits.user4, userBits.user5, userBits.user6,
                        userBits.user7, userBits.user8);
                }
#endif 

                //printf("ptr= 0x%X (0x%X), bufferSize= %d\n", 
                    //ptr, buffer, bufferSize);
            }
        }
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\timecode\timecode.h ===
/**********************************************************************
Copyright (c) Microsoft Corporation 1996. All Rights Reserved

Timecode header file

Format: NTSC, PAL or Film
        Dropframe or not
        Rates: 29.97 -> NTSC (4 field drop), Brazilian M-PAL (8 field drop)
               30    -> NTSC, Brazilian PAL     (non-dropframe)
               24    -> Film
               25    -> PAL

Ken Greenebaum, November 1996
**********************************************************************/
#ifndef _H_TIMECODE
#define _H_TIMECODE

#include <wtypes.h>


#define TIMECODE_STRING_LENGTH 12 // 00:00:00:00 (XXX this is temporary?)
class TimeCode {
  public:
    TimeCode();
    TimeCode(int hours, int min, int sec, int frames, 
        BOOL ntsc=TRUE, BOOL drop=FALSE);
    TimeCode(char *string, BOOL ntsc=TRUE, BOOL drop=FALSE);

    void operator--();     // prefix
    void operator--(int);  // postfix
    void operator++();     // prefix
    void operator++(int);  // postfix

    int operator==(TimeCode tc) 
        {_GetFrame(); return(_frames.frames == tc.GetTime()); }

    int operator>(TimeCode tc)
        {_GetFrame(); return(_frames.frames >  tc.GetTime()); }

    int operator<(TimeCode tc)
        {_GetFrame(); return(_frames.frames <  tc.GetTime()); }

    int operator<=(TimeCode tc)
        {_GetFrame(); return(_frames.frames <= tc.GetTime()); }

    int operator>=(TimeCode tc)
        {_GetFrame(); return(_frames.frames >= tc.GetTime()); }

    void SetTime(int hours, int minutes, int seconds, int frames);
    void SetTime(char *string);
    void SetFormat(BOOL ntsc, BOOL dropframe);

    void     GetTime(int *hours, int *minutes, int *seconds, int *frames);
    LONGLONG GetTime();

    void     GetString(char *string);

  private:
    struct {
        int hours;
        int minutes;
        int seconds;
        int frames;
        BOOL dirty;
    } _hmsf;

    struct {
        LONGLONG frames;
        BOOL dirty;
    } _frames;

    void _HMSFfromFrames();
    void _FramesFromHMSF();
    inline void _GetFrame() { if(_frames.dirty) _FramesFromHMSF(); }

    static const char NTSC_MODE;
    static const char PAL_MODE;
    static const char FORMAT_MASK;

    static const char DROPFRAME_MODE;
    static const char NO_DROPFRAME_MODE;
    static const char DROPFRAME_MASK;

    static const char NTSC_NODROP;
    static const char NTSC_DROP;
    static const char PAL_NODROP;
    static const char PAL_DROP;
    unsigned char _timeCodeFormat; // describe format based on the above consts
};
#endif /* _H_TIMECODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\timecode\vtcdcode.cpp ===
/**********************************************************************
Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.

VITCDecode, Ken Greenebaum / David Maymudes, November 1996

A generic vertical interval timecode decoder.  Pass it 8 bit video lines
samples and it will decode the VITC timecode encoded therein.

This code based on the VITC description in John Ratcliff's Timecode; A user's
 guide  (second edition)
**********************************************************************/
#include <stdio.h>
#include <wtypes.h>
#include "vtcdcode.h"


/**********************************************************************
helper function to decode raw VITC bits found in the bit buffer
**********************************************************************/
int
compute(int bitNumber, int numBits, int bits[])
{
    int value = 0;
    int count;
    int index;

    index = bitNumber;
    for(count = 0; count < numBits; count++) {
        value+= bits[index] << count;
        index = (index+1);
    }
    
    return(value);
}


/**********************************************************************
initialize internal state
**********************************************************************/
VITCdecoder::VITCdecoder()
{
    // values to reset
    _validTimeCode   =    0; // no, we don't have a valid timecode, yet

    // should scan buffer for these
    // !!! completely arbitrary!
    _low = 80;
    _high = 120;
}


/**********************************************************************
Decode and return the user bits from the raw VITC decoded bits in the
ring buffer.

Returns True if there is a valid timecode in the ring buffer

In general this is only true immediately after the decode method returns
a non-zero timecode sample sync
**********************************************************************/
int 
VITCdecoder::getUserBits(VITCuserBits *bits)
{
    if(_validTimeCode) { // verify that valid timecode is in buffer
        bits->user1 = compute( 6, 4, _bits);
        bits->user2 = compute(16, 4, _bits);
        bits->user3 = compute(26, 4, _bits);
        bits->user4 = compute(36, 4, _bits);
        bits->user5 = compute(46, 4, _bits);
        bits->user6 = compute(56, 4, _bits);
        bits->user7 = compute(66, 4, _bits);
        bits->user8 = compute(76, 4, _bits);
    }
    return(_validTimeCode);
}


/**********************************************************************
Decode and return the TimeCode from the raw VITC decoded bits.

Returns True if there is a valid timecode,,

In general this is only true immediately after the decode method returns
a non-zero timecode sample sync

**********************************************************************/
int
VITCdecoder::getTimeCode(TimeCode *tc)
{
    if(_validTimeCode) { // verify that valid timecode is in buffer
        int hour, minute, second, frame;

        frame  =    compute( 2, 4, _bits); // frame units 0-3 1,2,4,8
        frame += 10*compute(12, 2, _bits); // frame tens  0-1 1,2

        second =    compute(22, 4, _bits);
        second+= 10*compute(32, 3, _bits);

        minute =    compute(42, 4, _bits);
        minute+= 10*compute(52, 3, _bits);

        hour   =    compute(62, 4, _bits);
        hour  += 10*compute(72, 2, _bits);

        tc->SetTime(hour, minute, second, frame);   // XXX for now
    }
    return(_validTimeCode);
}


// !!! really this should be adaptive, by looking for the first bit transition.

// this formula found by looking at VITC data from one tape on a BT-848, I found that
// bits took 1/96th of a line, starting at 3.5/96ths in.
int bitStart(int bit, int lineWidth)
{
    return (lineWidth * (bit + 3) + lineWidth / 2) / 96;
}


/**********************************************************************
Accept a new line of video, decode the bits present in it, and return
whether a timeCode was completed being decoded.
**********************************************************************/
int
VITCdecoder::decodeBuffer(BYTE *buf, int bufferSize)
{
    int bit;
    int badbits = 0;
    
    int startPos = bitStart(0, bufferSize);
    
    for (bit = 0; bit < 90; bit++) {
	int endPos = bitStart(bit+1, bufferSize);

	// !!! arbitrarily don't look at first/last two pixels so as to avoid
	// edges of bits
	int len = endPos - startPos - 4;
	DWORD total = 0;
	for (int pos = startPos+2; pos < endPos-2; pos++) {
	    total += (DWORD) buf[pos];
	}

	// printf("bit %d: %d  (%d-%d)\n", bit, total / len, startPos, endPos); 
	if (total < _low * len) {
	    // record 0
	    _bits[bit] = 0;
	} else if (total > _high * len) {
	    // record 1
	    _bits[bit] = 1;
	} else {
	    // record error
	    _bits[bit] = -1;
	    badbits++;
	}
	startPos = endPos;



	// !!! should terminate loop immediately if there's a problem to save time
    }

    // printf("%d bad bits\n", badbits);

    _validTimeCode = (badbits == 0);

    // check sync bits
    if (badbits == 0) {
	for (bit = 0; bit < 90; bit += 10) {
	    if (_bits[bit] != 1) {
		// printf("bit %d should be 1\n", bit);
		_validTimeCode = 0;
	    }

	    if (_bits[bit+1] != 0) {
		// printf("bit %d should be 0\n", bit+1);
		_validTimeCode = 0;
	    }
	}
    }

    // !!! should also check CRC in last few bits
    
    return _validTimeCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\timecode\vtcdcode.h ===
/**********************************************************************
Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.

VitcDecode, Ken Greenebaum, November 1996
**********************************************************************/
#ifndef _H_VITCDECODER
#define _H_VITCDECODER

#include <wtypes.h>
#include "timecode.h"

typedef struct VITCuserBits {
    int user1:4;
    int user2:4;
    int user3:4;
    int user4:4;
    int user5:4;
    int user6:4;
    int user7:4;
    int user8:4;
} bar;


class VITCdecoder {
  public:
    VITCdecoder(); // XXX really should spec format, rate...
    int decodeBuffer(BYTE *buf, int bufferSize);
    int getTimeCode(TimeCode *tc); // convert VITC bits to SMPTE timecode
    int getUserBits(VITCuserBits *bits);

  private:

    // threshold values for detection
    int _low;
    int _high;
    
    int _bits[90];
    int _validTimeCode;      // set if the ringBuffer contains a timecode
};

#endif /* _H_VITCDECODER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\timecode\tcdec\tcdec.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved
// Timecode decoder, David Maymudes, November 1996
//
//

#include <streams.h>
#include <mmsystem.h>


// XXX using backslashes since makedepend is broken!
#include "..\timecode.h"
#include "..\ltcdcode.h"
#include "..\tchelper.h"

#ifdef FILTER_DLL
// define the GUIDs for streams and my CLSID in this file
#include <initguid.h>
#endif

extern const AMOVIESETUP_FILTER sudTCDecode;

// Class ID for CTCDecode objects
//
//   6a08cf9f-0e18-11cf-a24d-0020afd79767

DEFINE_GUID(CLSID_TCDecoder,
0x6a08cf9f, 0x0e18, 0x11cf, 0xa2, 0x4d, 0x0, 0x20, 0xaf, 0xd7, 0x97, 0x67);

const int TIMECODE_SIZE	= 50;	// max size of a timecode string
   
class CTCDecode : public CTransformFilter
{
  public:
    CTCDecode(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CTCDecode();

    DECLARE_IUNKNOWN

    HRESULT Transform(IMediaSample * pIn, IMediaSample * pOut);
    HRESULT Receive( IMediaSample *pInSample );

    // check if you can support mtIn
    HRESULT CheckInputType(const CMediaType* mtIn);

    // check if you can support the transform from this input to
    // this output
    HRESULT CheckTransform(const CMediaType* mtIn, const CMediaType* mtOut);

    // called from CBaseOutputPin to prepare the allocator's count
    // of buffers and sizes
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);

    // optional overrides - we want to know when streaming starts and stops
    HRESULT StartStreaming();
    HRESULT StopStreaming();

    // overriden to suggest OUTPUT pin media types
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    // this goes in the factory template table to create new instances
    static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

  private:
    LTCdecoder	decoder;
    DWORD	m_nSamplesPerSec;
    DWORD	m_nBlockAlign;
    LONGLONG	_sampleNumber;
};



//*****************************************************************************
//*****************************************************************************
// setup data

const AMOVIESETUP_MEDIATYPE
sudInTypes = { &MEDIATYPE_Audio      // clsMajorType
              , &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_MEDIATYPE
sudOutTypes = { &MEDIATYPE_Text      // clsMajorType
              , &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_PIN sudpPins [] =
{
    { L"Input"             // strName
      , FALSE              // bRendered
      , FALSE              // bOutput
      , FALSE              // bZero
      , FALSE              // bMany
      , &CLSID_NULL        // clsConnectsToFilter
      , L"Output"          // strConnectsToPin
      , 1                  // nTypes
      , &sudInTypes       // lpTypes
    },
    { L"Output"            // strName
      , FALSE              // bRendered
      , TRUE               // bOutput
      , FALSE              // bZero
      , FALSE              // bMany
      , &CLSID_NULL        // clsConnectsToFilter
      , L"Input"           // strConnectsToPin
      , 1                  // nTypes
      , &sudOutTypes       // lpTypes
    }
};


const AMOVIESETUP_FILTER sudTCDecode =
{ &CLSID_TCDecoder     // clsID
, L"Timecode decoder"  // strName
, MERIT_NORMAL         // dwMerit
, 2                    // nPins
, sudpPins };          // lpPin


//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

#ifdef FILTER_DLL
// List of class IDs and creator functions for class factory
CFactoryTemplate g_Templates[] =
{
    { L"Timecode Decoder"
	    , &CLSID_TCDecoder
	    , CTCDecode::CreateInstance
	    , NULL
	    , &sudTCDecode
    }
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
// exported entry points for registration and unregistration (in this case they
// only call through to default implmentations).
//

STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}

#endif

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//
// CreateInstance()
//
//

CUnknown *CTCDecode::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    DbgLog((LOG_TRACE, 2, TEXT("CTCDecode::CreateInstance")));

    return new CTCDecode(TEXT("LTC decoder"), pUnk, phr);
}


//*****************************************************************************
//
// NonDelegatingQueryInterface()
//
//

STDMETHODIMP CTCDecode::NonDelegatingQueryInterface( REFIID riid, void **ppv )
{
    return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
}


//*****************************************************************************
//
// CTCDecode()
//
//

CTCDecode::CTCDecode( TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr )
    : CTransformFilter( pName,
                        pUnk,
                        CLSID_TCDecoder)
{
    _sampleNumber = 0;
    DbgLog((LOG_TRACE,3,TEXT("CTCDecode")));
}


//*****************************************************************************
//
// ~CTCDecode()
//
//

CTCDecode::~CTCDecode()
{
    DbgLog((LOG_TRACE,3,TEXT("~CTCDecode")));

}


//*****************************************************************************
//
// CheckInputType()
//
//

HRESULT CTCDecode::CheckInputType(const CMediaType* pmtIn)
{
    DbgLog((LOG_TRACE, 3, TEXT("CTCDecode::CheckInputType")));

    DisplayType("pmtIn details:", pmtIn);

    WAVEFORMATEX * pwfx = (WAVEFORMATEX *)pmtIn->Format();

    if (pmtIn->majortype != MEDIATYPE_Audio) {
	DbgLog((LOG_ERROR, 1, TEXT("*** CheckInputType only takes audio")));
	return E_INVALIDARG;
    }

    if( *pmtIn->FormatType() != FORMAT_WaveFormatEx ) {
	DbgLog((LOG_ERROR, 1, TEXT("  pmtOut->FormatType != FORMAT_WaveFormatEx!")));
	return E_INVALIDARG;
    }

    if (pmtIn->FormatLength() < sizeof(PCMWAVEFORMAT)) {
	DbgLog((LOG_ERROR, 1, TEXT("*** pmtIn->FormatLength < PCMWAVEFORMAT")));
	return E_INVALIDARG;
    }

    // only accept mono 16 bit data
    if (pwfx->wFormatTag != WAVE_FORMAT_PCM || pwfx->wBitsPerSample != 16 ||
	pwfx->nChannels != 1)
	return E_INVALIDARG;
    
    return S_OK;
}


//*****************************************************************************
//
// GetMediaType()
//

HRESULT CTCDecode::GetMediaType( int iPosition, CMediaType *pmt )
{
    DbgLog((LOG_TRACE, 3, TEXT("CTCDecode::GetMediaType")));
    DbgLog((LOG_TRACE, 3, TEXT("  iPosition = %d"),iPosition));

    if( iPosition != 0 ) {
	return E_INVALIDARG;
    }
    
    pmt->SetType( &MEDIATYPE_Text );
    pmt->SetSubtype( &GUID_NULL );
    pmt->SetFormatType( &GUID_NULL );

    return S_OK;
}


//*****************************************************************************
//
// CheckTransform()
//
//

HRESULT CTCDecode::CheckTransform(const CMediaType* pmtIn,
				    const CMediaType* pmtOut)
{
    HRESULT hr = CheckInputType(pmtIn);

    if (FAILED(hr))
	return hr;
    
    DisplayType("pmtOut:", pmtOut);

    if (pmtOut->majortype != MEDIATYPE_Text) {
	DbgLog((LOG_ERROR, 1, TEXT("*** output type must be text")));
	return E_INVALIDARG;
    }

    return S_OK;
}


//*****************************************************************************
//
// DecideBufferSize()
//

HRESULT CTCDecode::DecideBufferSize( IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties )
{
    DbgLog((LOG_TRACE, 3, TEXT("CTCDecode::DecideBufferSize")));
  
    if (pProperties->cBuffers < 4)
	pProperties->cBuffers = 4;
    if (pProperties->cbBuffer < TIMECODE_SIZE)
	pProperties->cbBuffer     = TIMECODE_SIZE;
    if (pProperties->cbAlign < 1)
	pProperties->cbAlign      = 1;

    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);

    if (FAILED(hr)) {
	return hr;
    }

    return S_OK;
}


//*****************************************************************************
//
// StartStreaming()
//
//

HRESULT CTCDecode::StartStreaming()
{
    CAutoLock    lock(&m_csFilter);

    DbgLog((LOG_TRACE, 3, TEXT("CTCDecode::StartStreaming")));

    WAVEFORMATEX *pwfx = (WAVEFORMATEX *)m_pInput->CurrentMediaType().Format();
    m_nSamplesPerSec = pwfx->nSamplesPerSec ;
    m_nBlockAlign = pwfx->nBlockAlign ;

    // !!! decoder.Reset();
    
    return S_OK;
}


//*****************************************************************************
//
// StopStreaming()
//
//

HRESULT CTCDecode::StopStreaming()
{
    CAutoLock lock(&m_csFilter);

    DbgLog((LOG_TRACE, 3, TEXT("CTCDecode::StopStreaming")));

    return NOERROR;
 }


HRESULT CTCDecode::Transform( IMediaSample *pIn, IMediaSample *pOut )
{
    DbgLog((LOG_ERROR, 1, TEXT("*** CTCDecode->Transform() called!")));
    ASSERT(0);  // !!! shouldn't be called!

    return E_FAIL;
}


HRESULT CTCDecode::Receive( IMediaSample *pInSample )
{
    HRESULT      hr = NOERROR;
    REFERENCE_TIME inBufStartTime;  // start/stop time of input buffer
    REFERENCE_TIME inBufStopTime;
    REFERENCE_TIME tcStartTime;     // start/stop time of the timecode
    REFERENCE_TIME tcStopTime; 
    LONGLONG startTCsample, stopTCsample; // 1st, last sample of timecode
    BYTE *pbSample;
    LONG  cbSampleLength, cbLeft;


    DbgLog((LOG_TRACE, 4, TEXT("CTCDecode::Receive")));


    // get input start and stop times

    pInSample->GetTime(&inBufStartTime, &inBufStopTime);
    pInSample->GetPointer( &pbSample );

    DbgLog((LOG_TRACE, 3, TEXT("Total Sample: Start = %s End = %s"),
	    (LPCTSTR)CDisp((LONGLONG)(inBufStartTime),CDISP_HEX),
	    (LPCTSTR)CDisp((LONGLONG)(inBufStopTime),CDISP_HEX)));


    cbSampleLength = pInSample->GetActualDataLength() / m_nBlockAlign;
    cbLeft = cbSampleLength;

    // sample number of the last sample in buf
    LONGLONG lastSampleNumber= _sampleNumber + cbSampleLength;
    
    DbgLog((LOG_TRACE, 4, TEXT("  cbSampleLength = %d"),cbSampleLength));

    while (cbLeft > 0) {
	TimeCode tc;
	LONGLONG syncSample;  // the audio sample that this tc corresponds to
	
	if (decoder.decodeBuffer((short **) &pbSample, (int *) &cbLeft)) {
	    IMediaSample *pOutSample;

	    decoder.getTimeCode(&tc);
            decoder.getStartStopSample(&startTCsample, &stopTCsample);

	    hr = m_pOutput->GetDeliveryBuffer( &pOutSample, NULL, NULL, 0 );
	    if( FAILED(hr) )
	    {
		DbgLog((LOG_ERROR, 1, TEXT("GetDeliveryBuffer(pOutSample) failed, hr = %u"),hr));
		return hr;
	    }

	    pOutSample->SetSyncPoint( pInSample->IsSyncPoint() == S_OK );
	    // not really right....
	    pOutSample->SetDiscontinuity( pInSample->IsDiscontinuity() == S_OK );

	    tcStartTime = extrapolate(_sampleNumber, inBufStartTime, // begin bf
	                          lastSampleNumber, inBufStopTime,  // end bf
	                          startTCsample);  // samnumber of desired time

	    tcStopTime  = extrapolate(_sampleNumber, inBufStartTime, // begin bf
	                          lastSampleNumber, inBufStopTime,  // end bf
	                          stopTCsample);   // samnumber of desired time

	    // !!! really should be last tStop of the last timecode sent....
	    // XXX realy? I am not so sure...
	    pOutSample->SetTime(&tcStartTime, &tcStopTime);

	    DbgLog((LOG_TRACE, 4, TEXT("  Breaking up: Start = %s End = %s"),
		   (LPCTSTR)CDisp((LONGLONG)(tcStartTime),CDISP_HEX),
		   (LPCTSTR)CDisp((LONGLONG)(tcStopTime),CDISP_HEX)));

	    BYTE *pbOut;
	    pOutSample->GetPointer( &pbOut );

	    tc.GetString((char *) pbOut);
	    pOutSample->SetActualDataLength(lstrlen((char *) pbOut) + 1);
	    
	    hr = m_pOutput->Deliver(pOutSample);

	    // release the output buffer. If the connected pin still needs it,
	    // it will have addrefed it itself.
	    pOutSample->Release();
	    
	    if (FAILED(hr))
		return hr;
	}

    }
    // sample count of 1st sample in decode buffer
    // needed because the synch will occur in a PREVIOUS buffer (or 1st samp)
    _sampleNumber += cbSampleLength;
    return S_OK;
}



// !!! do we need special EOS handling?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\timecode\vitcdec\vitcdec.cpp ===
// Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.
// Video Timecode decoder, David Maymudes, January 1997
//
//

#include <streams.h>
#include <mmsystem.h>


// XXX using backslashes since makedepend is broken!
#include "..\timecode.h"
#include "..\vtcdcode.h"
#include "..\tchelper.h"

#ifdef FILTER_DLL
// define the GUIDs for streams and my CLSID in this file
#include <initguid.h>
#endif

extern const AMOVIESETUP_FILTER sudVITCDecode;

// Class ID for CVITCDecode objects
//
//   6a08cfa0-0e18-11cf-a24d-0020afd79767

DEFINE_GUID(CLSID_VITCDecoder,
0x6a08cfa0, 0x0e18, 0x11cf, 0xa2, 0x4d, 0x0, 0x20, 0xaf, 0xd7, 0x97, 0x67);

const int TIMECODE_SIZE	= 50;	// max size of a timecode string
   
class CVITCDecode : public CTransformFilter
{
  public:
    CVITCDecode(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CVITCDecode();

    DECLARE_IUNKNOWN

    HRESULT Transform(IMediaSample * pIn, IMediaSample * pOut);
    HRESULT Receive( IMediaSample *pInSample );

    // check if you can support mtIn
    HRESULT CheckInputType(const CMediaType* mtIn);

    // check if you can support the transform from this input to
    // this output
    HRESULT CheckTransform(const CMediaType* mtIn, const CMediaType* mtOut);

    // called from CBaseOutputPin to prepare the allocator's count
    // of buffers and sizes
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);

    // optional overrides - we want to know when streaming starts and stops
    HRESULT StartStreaming();
    HRESULT StopStreaming();

    // overriden to suggest OUTPUT pin media types
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    // this goes in the factory template table to create new instances
    static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

  private:
    VITCdecoder	decoder;

    DWORD	m_nWidth;
    DWORD	m_nHeight;
    int		m_nLine;
    BOOL	m_bTimecodeSeen;



    // !!! statistics....

    LONG	m_lStartTime;
    int		m_iFrames, m_iErrors;
    
};



//*****************************************************************************
//*****************************************************************************
// setup data

const AMOVIESETUP_MEDIATYPE
sudInTypes = { &MEDIATYPE_Video      // clsMajorType
              , &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_MEDIATYPE
sudOutTypes = { &MEDIATYPE_Text      // clsMajorType
              , &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_PIN sudpPins [] =
{
    { L"Input"             // strName
      , FALSE              // bRendered
      , FALSE              // bOutput
      , FALSE              // bZero
      , FALSE              // bMany
      , &CLSID_NULL        // clsConnectsToFilter
      , L"Output"          // strConnectsToPin
      , 1                  // nTypes
      , &sudInTypes       // lpTypes
    },
    { L"Output"            // strName
      , FALSE              // bRendered
      , TRUE               // bOutput
      , FALSE              // bZero
      , FALSE              // bMany
      , &CLSID_NULL        // clsConnectsToFilter
      , L"Input"           // strConnectsToPin
      , 1                  // nTypes
      , &sudOutTypes       // lpTypes
    }
};


const AMOVIESETUP_FILTER sudVITCDecode =
{ &CLSID_VITCDecoder     // clsID
, L"Video Timecode decoder"  // strName
, MERIT_NORMAL         // dwMerit
, 2                    // nPins
, sudpPins };          // lpPin


//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

#ifdef FILTER_DLL
// List of class IDs and creator functions for class factory
CFactoryTemplate g_Templates[] =
{
    { L"Video Timecode Decoder"
	    , &CLSID_VITCDecoder
	    , CVITCDecode::CreateInstance
	    , NULL
	    , &sudVITCDecode
    }
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
// exported entry points for registration and unregistration (in this case they
// only call through to default implmentations).
//

STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}

#endif

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//
// CreateInstance()
//
//

CUnknown *CVITCDecode::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    DbgLog((LOG_TRACE, 2, TEXT("CVITCDecode::CreateInstance")));

    return new CVITCDecode(TEXT("VITC decoder"), pUnk, phr);
}


//*****************************************************************************
//
// NonDelegatingQueryInterface()
//
//

STDMETHODIMP CVITCDecode::NonDelegatingQueryInterface( REFIID riid, void **ppv )
{
    return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
}


//*****************************************************************************
//
// CVITCDecode()
//
//

CVITCDecode::CVITCDecode( TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr )
    : CTransformFilter( pName,
                        pUnk,
                        CLSID_VITCDecoder)
{
    DbgLog((LOG_TRACE,3,TEXT("CVITCDecode")));
}


//*****************************************************************************
//
// ~CVITCDecode()
//
//

CVITCDecode::~CVITCDecode()
{
    DbgLog((LOG_TRACE,3,TEXT("~CVITCDecode")));
\
}


//*****************************************************************************
//
// CheckInputType()
//
//

HRESULT CVITCDecode::CheckInputType(const CMediaType* pmtIn)
{
    DbgLog((LOG_TRACE, 3, TEXT("CVITCDecode::CheckInputType")));

    DisplayType("pmtIn details:", pmtIn);

    if (pmtIn->majortype != MEDIATYPE_Video) {
	DbgLog((LOG_ERROR, 1, TEXT("*** CheckInputType only takes video")));
	return E_INVALIDARG;
    }

    if( *pmtIn->FormatType() != FORMAT_VideoInfo ) {
	DbgLog((LOG_ERROR, 1, TEXT("  pmtOut->FormatType != FORMAT_VideoInfo!")));
	return E_INVALIDARG;
    }

    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *)pmtIn->Format();
    if( pvi->bmiHeader.biWidth < 400 || abs(pvi->bmiHeader.biHeight) > 20 ) {
	DbgLog((LOG_ERROR, 1, TEXT("  video not right shape for VBI data")));
	return E_INVALIDARG;
    }

    if (pvi->bmiHeader.biCompression != BI_RGB && pvi->bmiHeader.biCompression != BI_BITFIELDS) {
	DbgLog((LOG_ERROR, 1, TEXT("  video not uncompressed")));
	return E_INVALIDARG;
    }
    
    return S_OK;
}


//*****************************************************************************
//
// GetMediaType()
//

HRESULT CVITCDecode::GetMediaType( int iPosition, CMediaType *pmt )
{
    DbgLog((LOG_TRACE, 3, TEXT("CVITCDecode::GetMediaType")));
    DbgLog((LOG_TRACE, 3, TEXT("  iPosition = %d"),iPosition));

    if( iPosition != 0 ) {
	return E_INVALIDARG;
    }
    
    pmt->SetType( &MEDIATYPE_Text );
    pmt->SetSubtype( &GUID_NULL );
    pmt->SetFormatType( &GUID_NULL );

    return S_OK;
}


//*****************************************************************************
//
// CheckTransform()
//
//

HRESULT CVITCDecode::CheckTransform(const CMediaType* pmtIn,
				    const CMediaType* pmtOut)
{
    HRESULT hr = CheckInputType(pmtIn);

    if (FAILED(hr))
	return hr;
    
    DisplayType("pmtOut:", pmtOut);

    if (pmtOut->majortype != MEDIATYPE_Text) {
	DbgLog((LOG_ERROR, 1, TEXT("*** output type must be text")));
	return E_INVALIDARG;
    }

    return S_OK;
}


//*****************************************************************************
//
// DecideBufferSize()
//

HRESULT CVITCDecode::DecideBufferSize( IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties )
{
    DbgLog((LOG_TRACE, 3, TEXT("CVITCDecode::DecideBufferSize")));
  
    if (pProperties->cBuffers < 4)
	pProperties->cBuffers = 4;
    if (pProperties->cbBuffer < TIMECODE_SIZE)
	pProperties->cbBuffer     = TIMECODE_SIZE;
    if (pProperties->cbAlign < 1)
	pProperties->cbAlign      = 1;

    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);

    if (FAILED(hr)) {
	return hr;
    }

    return S_OK;
}


//*****************************************************************************
//
// StartStreaming()
//
//

HRESULT CVITCDecode::StartStreaming()
{
    CAutoLock    lock(&m_csFilter);

    DbgLog((LOG_TRACE, 3, TEXT("CVITCDecode::StartStreaming")));

    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *)m_pInput->CurrentMediaType().Format();
    m_nWidth = pvi->bmiHeader.biWidth * pvi->bmiHeader.biBitCount / 8;
    m_nHeight = pvi->bmiHeader.biHeight;

    m_nLine = -1;

    m_bTimecodeSeen = FALSE;
    
    m_lStartTime = timeGetTime();
    m_iFrames = m_iErrors = 0;
    
    return S_OK;
}


//*****************************************************************************
//
// StopStreaming()
//
//

HRESULT CVITCDecode::StopStreaming()
{
    CAutoLock lock(&m_csFilter);

    DbgLog((LOG_TRACE, 3, TEXT("CVITCDecode::StopStreaming")));

    DbgLog((LOG_TRACE, 1, TEXT("Total time: %d:  %d frames, %d errors"),
	    timeGetTime() - m_lStartTime, m_iFrames, m_iErrors));
    
    return NOERROR;
 }


HRESULT CVITCDecode::Transform( IMediaSample *pIn, IMediaSample *pOut )
{
    DbgLog((LOG_ERROR, 1, TEXT("*** CVITCDecode->Transform() called!")));
    ASSERT(0);  // !!! shouldn't be called!

    return E_FAIL;
}


HRESULT CVITCDecode::Receive( IMediaSample *pInSample )
{
    HRESULT      hr = NOERROR;
    REFERENCE_TIME StartTime;  // start/stop time of input buffer
    REFERENCE_TIME StopTime;
    BYTE *pbSample;

    DbgLog((LOG_TRACE, 4, TEXT("CVITCDecode::Receive")));


    // get input start and stop times

    pInSample->GetTime(&StartTime, &StopTime);
    pInSample->GetPointer( &pbSample );

    // !!! if we haven't decided what line the timecode is on, search for it.
    if (m_nLine == -1) {
	for (int iLine = 0; iLine < (int) m_nHeight; iLine++) {
	    if (decoder.decodeBuffer(pbSample + iLine * m_nWidth, m_nWidth)) {
		m_nLine = iLine;
		DbgLog((LOG_TRACE, 1, TEXT("Found VITC on line %d"), m_nLine));
		break;
	    }
	}
    }

    // !!! should we output something like "error" if no VITC?
    BOOL bHaveTimecode = (m_nLine >= 0 &&
			  decoder.decodeBuffer(pbSample + m_nLine * m_nWidth, m_nWidth));

    if (bHaveTimecode) {
	m_bTimecodeSeen = TRUE;
    } else {
	// potentially search for new line if enough errors?
	++m_iErrors;
    }
    ++m_iFrames;
    

    // !!! perhaps if we get enough errors in a row we should re-start the
    // search for the right line?
    
    if (TRUE /* bHaveTimecode */) {
	IMediaSample *pOutSample;

	TimeCode tc;

	decoder.getTimeCode(&tc);

	hr = m_pOutput->GetDeliveryBuffer( &pOutSample, NULL, NULL, 0 );
	if( FAILED(hr) )
	{
	    DbgLog((LOG_ERROR, 1, TEXT("GetDeliveryBuffer(pOutSample) failed, hr = %u"),hr));
	    return hr;
	}

	pOutSample->SetSyncPoint( TRUE );
	// not really right....
	pOutSample->SetDiscontinuity( pInSample->IsDiscontinuity() == S_OK );

	pOutSample->SetTime(&StartTime, &StopTime);

	BYTE *pbOut;
	pOutSample->GetPointer( &pbOut );

	*pbOut = '\0';
	
	if (m_bTimecodeSeen) {
	    tc.GetString((char *) pbOut);
	}

	if (!bHaveTimecode) {
	    lstrcat((char *) pbOut, "   <error>");
	}

	pOutSample->SetActualDataLength(lstrlen((char *) pbOut) + 1);

	hr = m_pOutput->Deliver(pOutSample);

	// release the output buffer. If the connected pin still needs it,
	// it will have addrefed it itself.
	pOutSample->Release();

	if (FAILED(hr))
	    return hr;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dmotst\dmotestcases.cpp ===
#include <stdio.h>
#include <windows.h>
#include <commctrl.h>
#include <s98inc.h> 
#include "DmoTestCases.h"
#include "dmotest.h"


/*=============================================================================
|	MEMBER FUNCTION DEFINITIONS
|------------------------------------------------------------------------------
|	CDmoTestCase1
\============================================================================*/
/*-----------------------------------------------------------------------------
|	Function:	CDmoTestCase1
|	Purpose:	Constructor (wrapper for CDmoTestCase function)
|	Arguments:	ID, Name, and container class, Function to be called by RunTest
|	Returns:	Void
\----------------------------------------------------------------------------*/


CDmoTestCase1::CDmoTestCase1(	LPSTR pszNewCaseID, 
							LPSTR pszNewName,
							DMOTESTFNPROC1 pfnNewTest,
							CDmoTest* dmoTest)

		: CDmoTestCase(pszNewCaseID, pszNewName, dmoTest),
		  pfnTest(pfnNewTest)
{

}

/*-----------------------------------------------------------------------------
|	Function:	~CDmoTestCase1
|	Purpose:	Destructor
|	Arguments:	None
|	Returns:	Void
\----------------------------------------------------------------------------*/

CDmoTestCase1::~CDmoTestCase1() 
{

}

/*-----------------------------------------------------------------------------
|	Function:	RunTest
|	Purpose:	called by runtest
|	Arguments:	None
|	Returns:	0
\----------------------------------------------------------------------------*/



DWORD
CDmoTestCase1::RunTest()
{
	LPSTR	szDmoName;
	LPSTR	szDmoClsid;
	int		iNumTestFiles;
	LPSTR	szFileName;
	DWORD   dwResult = FNS_PASS;

	int iNumComponent = m_pDmoTest->GetNumComponent();
	int iNumSelectedComponent = m_pDmoTest->GetNumSelectedDmo();
	if(iNumSelectedComponent == 0)	
	{
		        MessageBox(
                NULL,
                "No DMOs selected.",
                "Error!",
                MB_OK | MB_ICONINFORMATION);

				return FNS_FAIL;
	}

	for(int i=0; i<iNumComponent; i++)
	{
		szDmoName = m_pDmoTest->GetDmoName(i);

		if( m_pDmoTest->IsDmoSelected(i))
		{
			g_IShell->Log(1, "\n<=====DMO Under Test: %s.=====> \n", szDmoName);

			szDmoClsid = m_pDmoTest->GetDmoClsid(i);
			iNumTestFiles = m_pDmoTest->GetNumTestFile(i);

			if( iNumTestFiles == 0)
			{

				MessageBox(
							NULL,
							"No test files selected.",
							"Error!",
							MB_OK | MB_ICONINFORMATION);
				return FNS_FAIL;
			}

			for (int j=0; j< iNumTestFiles; j++)
			{	

				szFileName = m_pDmoTest->GetFileName(i, j);

				if( pfnTest(szDmoClsid, szFileName) != FNS_PASS)
					dwResult = FNS_FAIL;
			}
		}
	}

	return dwResult;
}

/*=============================================================================
|	MEMBER FUNCTION DEFINITIONS
|------------------------------------------------------------------------------
|	CDmoTestCase2
\============================================================================*/
/*-----------------------------------------------------------------------------
|	Function:	CDmoTestCase2
|	Purpose:	Constructor (wrapper for CDmoTestCase function)
|	Arguments:	ID, Name, and container class, Function to be called by RunTest
|	Returns:	Void
\----------------------------------------------------------------------------*/

CDmoTestCase2::CDmoTestCase2(	LPSTR pszNewCaseID, 
							LPSTR pszNewName,
							DMOTESTFNPROC2 pfnNewTest,
							CDmoTest* dmoTest)

		: CDmoTestCase(pszNewCaseID, pszNewName, dmoTest),
		  pfnTest(pfnNewTest)
{

}

/*-----------------------------------------------------------------------------
|	Function:	~CDmoTestCase2
|	Purpose:	Destructor
|	Arguments:	None
|	Returns:	Void
\----------------------------------------------------------------------------*/

	
CDmoTestCase2::~CDmoTestCase2() 
{

}

/*-----------------------------------------------------------------------------
|	Function:	RunTest
|	Purpose:	called by runtest
|	Arguments:	None
|	Returns:	0
\----------------------------------------------------------------------------*/

DWORD
CDmoTestCase2::RunTest()
{
	LPSTR	szDmoName;
	LPSTR	szDmoClsid;
	DWORD   dwResult = FNS_PASS;

	int iNumComponent = m_pDmoTest->GetNumComponent();
	int iNumSelectedComponent = m_pDmoTest->GetNumSelectedDmo();
	if(iNumSelectedComponent == 0)	
	{
		        MessageBox(
                NULL,
                "No DMOs selected.",
                "Error!",
                MB_OK | MB_ICONINFORMATION);

				return FNS_FAIL;
	}
	for(int i=0; i<iNumComponent; i++)
	{
		szDmoName = m_pDmoTest->GetDmoName(i);

		if( m_pDmoTest->IsDmoSelected(i))
		{
			g_IShell->Log(1, "\n<=====DMO Under Test: %s.=====> \n", szDmoName);
			szDmoClsid = m_pDmoTest->GetDmoClsid(i);

			if(pfnTest(szDmoClsid) != FNS_PASS)
				dwResult = FNS_FAIL;
	
		}
	}

	return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dmotst\dmotest.cpp ===
/*=============================================================================
|
|	File: dmotest.cpp
|
|	Copyright (c) 2000 Microsoft Corporation.  All rights reserved
|
|	Abstract:
|		bridge code between dmo test case functions and shell98
|
|	Contents:
|
|	History:
|		5/3/2000   wendyliu   initial version
|
|
\============================================================================*/
#include <stdio.h>
#include <windows.h>
#include <commctrl.h>
#include <s98inc.h> 
#include <cderr.h>      // controls which shell (EXE or DLL form) is used 
#include <commdlg.h>    // includes common dialog functionality
#include <dlgs.h>       // includes common dialog template defines

#include "dmotest.h"	// Derives a variable passing test module Class
						// from CTreeModule 
#include "dmoApiTst.h"	// test case functions
#include "resource.h"

#include "DmoTestCases.h"


BOOL AddListViewItems(HWND hLV);
BOOL AddTestFilesInListView(HWND hLV);
BOOL GetTestFileName(  HWND hWnd, HWND hLV );

BOOL GetInOutFileName(  HWND hWnd, HWND hLV );
BOOL SaveSelectedTestFiles(HWND hLV);
BOOL WriteSelectedDmos();
BOOL GetRegisteredDmos();

int  g_dwNumOfComponents;
int  g_dwNumOfSelectedComponents;

//struct of components to be tested 
typedef struct
{
	char szComName[MAX_LEN];
	char szClsid[MAX_LEN];
	int  iSelectedForTest;
	int  iNumTestFiles;
	char szInputFile[MAX_LEN][MAX_LEN];
} ComInfo;

ComInfo g_component[MAX_LEN];

CDmoTest* pThis = NULL;

HWND	CDmoTest::m_hSelectFilesDlg = NULL;
HWND	CDmoTest::m_hSelectDmoDlg = NULL;
HWND	CDmoTest::m_hMediaTypeDlg = NULL;
HWND    CDmoTest::m_hDataGenDlg = NULL;
/*=============================================================================
| Test file selection dialog stuff
|------------------------------------------------------------------------------
|	
\============================================================================*/

typedef struct _MYDATA
{
	char szTest1[80];		// a test buffer containing the file selected
	char szTest2[80];       // a test buffer containing the file path
} MYDATA, FAR * LPMYDATA;

MYDATA sMyData;			// an instance of a MYDATA

CFactoryTemplate g_Templates[2]= { { 0         // CFactoryTemplate.m_name
                                   , 0            // CFactoryTemplate.m_ClsID 
                                   , 0  // CFactoryTemplate.m_lpfnNew
								   , NULL                     // CFactoryTemplate.m_lpfnInit
								   , 0               // CFactoryTemplate.m_pAMovieSetup_Filter
                                   }
                                 };

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);


/*=============================================================================
| Shell98 / ModMgr98 stuff
|------------------------------------------------------------------------------
|	Notes:
|		The only things that should need to be changed in this area are the 
|		derived class name, the module name, and the App ID.
\============================================================================*/
static  LPSTR szModuleName = "DMO TEST";
static  DWORD dwAppID	   = 1104;
CTreeModule*  g_pVariableModule;

/*=============================================================================
|	Function:	InitCaseTree
|	Purpose:	
|	Arguments:	None
|	Returns:	None
|	Notes:
|		This function is called by the constructor of this Module, providing a central 
|		function from them.  Rather than statically	adding cases to a public 
|		structure, these functions	provide a consistent interface through which
|		to add cases to a test application.
|		Full descriptions of AddCase(), AddGroup(), EndGroup(), and EndBranch()
|		can be found in "treemod.cpp".
|	Additional:
|		In this particular version, through the use of CDmoTestCase (derived from
|		CTestNodeItem), AddCase has been overloaded to allow the
|		passing of the container dmotest to the test function. 
\============================================================================*/

void CDmoTest::InitCaseTree()
{
 
	AddGroup("DMOTest", 0);
		AddGroup("Functional Test",0);
			AddCase("1.0", "DMO Functional Test 1: Positive Timestamp Offset Test", FunctionalTest1, pThis );
			AddCase("1.1", "DMO Functional Test 2: Negative Timestamp Offset Test", FunctionalTest2, pThis );

			EndGroup();
			AddGroup("IMediaObject Interface Test",0); 
			AddCase("2.0", "Test GetStreamCount()", TestGetStreamCount, pThis );
			AddCase("2.1", "Test GetInputType()", TestGetTypes, pThis );
			AddCase("2.2", "Test Stream Index on GetInputStreamInfo()", TestStreamIndexOnGetInputStreamInfo, pThis);
			AddCase("2.3", "Test Stream Index on GetOutputStreamInfo()", TestStreamIndexOnGetOutputStreamInfo, pThis );
			AddCase("2.4", "Test Invalide Parameter on GetInputStreamInfo()", TestInvalidParamOnGetInputStreamInfo, pThis );
			AddCase("2.5", "Test Invalide Parameter on GetOutputStreamInfo()", TestInvalidParamOnGetOutputStreamInfo, pThis );
			EndGroup();
}




 
/*-----------------------------------------------------------------------------
|	Function:	DllMain
|	Purpose:     DLL initialization and exit code
|	Arguments:
|	Returns:     FALSE on failure, TRUE on success
|	Notes:
|		If this module ends up being used by ModMgr98 this will be needed.
|		If not it doesn't hurt.
\----------------------------------------------------------------------------*/

BOOL CALLBACK DllMain
(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved
)
{
    BOOL    fRes = TRUE;
	g_hInst = hinst;
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            break;
    }    

    return fRes;
}

ITestShell*     g_IShell;

/*-----------------------------------------------------------------------------
|	Function:	NewTestModule
|	Purpose:	Called as the shell loads to setup the derived test module 
|				class inside the shell
|	Arguments:	pShell		- Pointer to shell for tests' access
|				hInstDLL	-
|	Returns:	CTestModule* to this test module class 
\----------------------------------------------------------------------------*/

CTestModule* WINAPI
NewTestModule
(
    CTestShell* pShell,
    HINSTANCE   hInstDLL
)
{
    g_IShell = (ITestShell*)pShell;
    g_pVariableModule = new CDmoTest(pShell, hInstDLL);
	g_hInst = hInstDLL;
    return (CTestModule*)g_pVariableModule;
}


/*-----------------------------------------------------------------------------
|	Function:	CDmoTest::CDmoTest
|	Purpose:	Constructor for derived module class.  
|	Arguments:	pShell		- Pointer to shell for tests' access
|				hInstDLL	-
|	Returns:	None 
|	Notes:		Additional Initialization for this module should
|				_NOT_ be put here 
\----------------------------------------------------------------------------*/
CDmoTest::CDmoTest
(
    CTestShell* pShell,
    HINSTANCE   hInstDLL
) : CTreeModule(pShell, hInstDLL)
{
    m_dwAppID        = dwAppID;  
    m_pstrModuleName = szModuleName;
	
	InitCaseTree();
	g_hInst = hInstDLL;
    m_nIconID = APPICON;
    m_dwModuleType = STTYPE_DSOUND | STTYPE_DSCAPTURE | STTYPE_WAVEOUT | STTYPE_WAVEIN | STTYPE_MIXER;
}

/*-----------------------------------------------------------------------------
|	Function:	CDmoTest::~CDmoTest
|	Purpose:	Destructor for derived module class.  
|	Arguments:	None
|	Returns:	None 
|	Notes:		Any clean up from the Initialize function should be put here.
\----------------------------------------------------------------------------*/
CDmoTest::~CDmoTest
(
    void
)
{	
	SaveSettings(" ", " ");
}

/*-----------------------------------------------------------------------------
|	Function:	CDmoTest::Initialize
|	Purpose:	Initialize derived module class  
|	Arguments:	None
|	Returns:	0 = Success, otherwise failure 
|	Notes:		Additional Initialization for this module should be put here 
\----------------------------------------------------------------------------*/
DWORD
CDmoTest::Initialize
(
    void
)
{
    return 0;
}


//wrapper for AddCase in tree module
void 
CDmoTest::AddCase(LPSTR pszCaseID, LPSTR pszName, DMOTESTFNPROC1 pfnTest, CDmoTest* pDmoTest)
{
	AddNode(new CDmoTestCase1(pszCaseID, pszName, pfnTest, pDmoTest));
}



//wrapper for AddCase in tree module
void 
CDmoTest::AddCase(LPSTR pszCaseID, LPSTR pszName, DMOTESTFNPROC2 pfnTest, CDmoTest* pDmoTest)
{
	AddNode(new CDmoTestCase2(pszCaseID, pszName, pfnTest, pDmoTest));
}

// access function
int 
CDmoTest::GetNumComponent()
{

	return g_dwNumOfComponents;
}

// access function
LPSTR 
CDmoTest::GetDmoName(int i)
{

	return g_component[i].szComName;
}
// access function
LPSTR 
CDmoTest::GetDmoClsid(int i)
{
	return g_component[i].szClsid;

}
// access function
BOOL 
CDmoTest::IsDmoSelected(int i)
{

	if(0 != ListView_GetCheckState(
									pThis->m_hDmoList,
									i))
	{
		return TRUE;
	}
	return FALSE;
}
// access function
int
CDmoTest::GetNumTestFile(int i)
{

	return g_component[i].iNumTestFiles ;
}
// access function
LPSTR 
CDmoTest::GetFileName(int comIndex, int fileIndex)
{

	return g_component[comIndex].szInputFile[fileIndex];
}
// access function
HWND
CDmoTest::GetWindowHandle()
{

	return 	m_pShell->m_hwndShell;

}
// access function
int
CDmoTest::GetNumSelectedDmo()
{
	return g_dwNumOfSelectedComponents;
}
/*-----------------------------------------------------------------------------
|	Function:	CDmoTest::SaveSettings
|	Purpose:	Save the custom entries to the profile or ini file
|	Arguments:	pszFileName - Profile Name or ini file name
|				pzsSection - section name	
|	Returns:	0 = Success, otherwise failure 
|	Notes:		Additional custom entries for this module should be saved here 
\----------------------------------------------------------------------------*/
DWORD CDmoTest::SaveSettings(LPSTR pszFileName, LPSTR pszSetction)
{
	char szEntryStr[MAX_LEN];
	char szNumTestFiles[MAX_NUM];
	char szNumFiles[MAX_NUM];
	char szSelected[MAX_NUM];



	sprintf(szEntryStr, "%s", TX_NO_OF_COMPONENTS_ENTRY);
	_itoa(g_dwNumOfComponents, szNumFiles, 10);
	g_IShell->WriteProfileString( szEntryStr, szNumFiles );

	sprintf(szEntryStr, "%s", TX_NO_OF_SELECTED_COMPONENTS_ENTRY);
	_itoa(g_dwNumOfSelectedComponents, szNumFiles, 10);
	g_IShell->WriteProfileString( szEntryStr, szNumFiles );

	for(int i = 0; i< g_dwNumOfComponents; i++)
	{
		sprintf(szEntryStr, "%s.%d", TX_COMPONENT_ENTRY, i);
		g_IShell->WriteProfileString( szEntryStr, g_component[i].szComName );

		sprintf(szEntryStr, "%s.%d", TX_CLASSID_ENTRY, i);
		g_IShell->WriteProfileString( szEntryStr, g_component[i].szClsid );

		sprintf(szEntryStr, "%s.%d", TX_SELECTED_FOR_TEST, i);
		_itoa(g_component[i].iSelectedForTest, szSelected, 10);
		g_IShell->WriteProfileString( szEntryStr, szSelected );

		sprintf(szEntryStr, "%s.%d", TX_NO_OF_TEST_FILES_ENTRY, i);
		_itoa(g_component[i].iNumTestFiles, szNumFiles, 10);
		g_IShell->WriteProfileString( szEntryStr, szNumFiles );

		if( g_component[i].iSelectedForTest != 0 ) // selected
		{

			for (int j = 0; j<g_component[i].iNumTestFiles; j++)
			{
				sprintf(szEntryStr, "%s.%d.%d", TX_FILENAME_ENTRY, i, j);
				g_IShell->WriteProfileString( szEntryStr, g_component[i].szInputFile[j] );
			}
		}
	}

 
    return 0;
} 
/*-----------------------------------------------------------------------------
|	Function:	CDmoTest::LoadSettings
|	Purpose:	Load the custom entries from the profile or ini file
|	Arguments:	pszFileName - Profile Name or ini file name
|				pzsSection - section name	
|	Returns:	0 = Success, otherwise failure 
|	Notes:		Additional custom entries for this module should be loaded here 
\----------------------------------------------------------------------------*/

DWORD
CDmoTest::LoadSettings(LPSTR pszFileName, LPSTR pszSetction)
{
	char szEntryStr[MAX_LEN];
	char szNumFiles[MAX_NUM];
	int iSelected;
	char szComName[MAX_NUM];

	GetRegisteredDmos();

	int iNumOfComponentsInProfile = g_IShell->GetProfileInt( TX_NO_OF_COMPONENTS_ENTRY,0 );
	g_dwNumOfSelectedComponents = g_IShell->GetProfileInt(TX_NO_OF_SELECTED_COMPONENTS_ENTRY,0);

	//get component name, classid, test file name for each component
	if( g_dwNumOfSelectedComponents > 0)

	{
		for( int i=0; i<iNumOfComponentsInProfile; i++)
		{	
			// check if the component was selected for test
			sprintf(szEntryStr, "%s.%d", TX_SELECTED_FOR_TEST, i);
			iSelected = g_IShell->GetProfileInt(szEntryStr, 0 );

			if(iSelected != 0 ) // selected
			{
				sprintf(szEntryStr, "%s.%d", TX_COMPONENT_ENTRY, i);
				g_IShell->GetProfileString(szEntryStr, TX_NOT_EXIST, szComName, 256 );
		
				for(int j=0; j<g_dwNumOfComponents; j++)
				{
					if(0 == lstrcmp( szComName, g_component[j].szComName))
					{
						g_component[j].iSelectedForTest = 1;
				
						// get test file num for this selected DMO
						sprintf(szEntryStr, "%s.%d", TX_NO_OF_TEST_FILES_ENTRY, i);	
						g_component[j].iNumTestFiles = g_IShell->GetProfileInt(szEntryStr, 0 );
						//	g_IShell->GetProfileString(szEntryStr, TX_NOT_EXIST, szNumFiles , 256 );	
						//	= atoi( szNumFiles);
					
						for (int k = 0; k<g_component[j].iNumTestFiles; k++)
						{
							sprintf(szEntryStr, "%s.%d.%d", TX_FILENAME_ENTRY, j, k);
							g_IShell->GetProfileString( szEntryStr, TX_NOT_EXIST, g_component[j].szInputFile[k], 256);
						}
					}
				}
		
			}
		}
	}

    return 0;
}


//=====================================================================
//
// run the test cases for each of the selected components 
//
//=====================================================================
DWORD
CDmoTest::RunTest
(
    DWORD   dwTestID
)
{
    DWORD   dw;	
    m_pShell->IncrementIndent();
	
	PPCDmoTestCase CaseArray = ((PPCDmoTestCase)m_rgTestCaseInfo);

	dw = CaseArray[dwTestID]->RunTest();
    m_pShell->DecrementIndent();
    return(dw);
}

/*-----------------------------------------------------------------------------
|	Function:	CDmoTest::OnInitialUpdate
|	Purpose:	create event window  
|	Arguments:	None
|	Returns:	0 = Success, otherwise failure 
\----------------------------------------------------------------------------*/
DWORD
CDmoTest::OnInitialUpdate()
{

    // install customized menu item
    m_pShell->InstallMenuItem("&Tests", "Select DMOs ...", IDM_SELECTDMO);
    m_pShell->InstallMenuItem("&Tests", "Generate DMO Data ...", IDM_DATAGEN);

	
	m_hSelectDmoDlg = CreateDialogParam(m_hInstance,
										MAKEINTRESOURCE(IDD_DMODIALOG),
										m_pShell->m_hwndShell,
										SelectDmoDialogProc,
										(LPARAM)this);

	m_hSelectFilesDlg = CreateDialogParam(m_hInstance,
										MAKEINTRESOURCE(IDD_TESTFILEDIALOG),
										m_pShell->m_hwndShell,
										SelectTestFileDialogProc,
										(LPARAM)this);
	m_hMediaTypeDlg = CreateDialogParam(m_hInstance,
										MAKEINTRESOURCE(IDD_MEDIATYPEDIALOG),
										m_pShell->m_hwndShell,
										MediaTypeDialogProc,
										(LPARAM)this);

	m_hDataGenDlg = CreateDialogParam(m_hInstance,
										MAKEINTRESOURCE(IDD_DATAGENDIALOG),
										m_pShell->m_hwndShell,
										DataGenDialogProc,
										(LPARAM)this);
																																

    return FNS_PASS;
}

/*-----------------------------------------------------------------------------
|	Function:	CDmoTest::ProcessMenuItem
|	Purpose:	processing custom menuitem
\----------------------------------------------------------------------------*/
void CDmoTest::ProcessMenuItem(DWORD   nID, 
									  HWND    hWndCtl, 
									  DWORD   codeNotify, 
									  HMENU   hOptionMenu)
{
 
	switch(nID) 
	{
    case IDM_SELECTDMO:
		pThis->InitListView( pThis->m_hDmoList);
        ShowWindow(m_hSelectDmoDlg, SW_SHOW);
        break;
    case IDM_DATAGEN:
		//pThis->InitListView( pThis->m_hDmoList);
        ShowWindow(m_hDataGenDlg, SW_SHOW);
        break;

    default:
        break;
    }
	
    return;
}

/*-----------------------------------------------------------------------------
|	Function:	CDmoTest::SelectDmoDialogProc
|	Purpose:	processing messages for Play path/Duration window  
\----------------------------------------------------------------------------*/
INT_PTR CALLBACK
CDmoTest::SelectDmoDialogProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) 
{
	
	static HWND hwndEdit;

	INT dIndex = 0;
	int iMarkedDmo = 0;
	int iItemNum = 0;

	switch( msg ) 
	{	
	case WM_INITDIALOG:
		pThis = (CDmoTest*) lParam;
		pThis->m_hDmoList = ::GetDlgItem(hDlg, IDC_DMOLIST);
		ListView_SetExtendedListViewStyle(pThis->m_hDmoList,
											LVS_EX_CHECKBOXES);
		return TRUE;

 
    case WM_NOTIFY:
            switch (wParam)
            {
                 case IDC_DMOLIST:
                
                    POINT           p;
                    LPNM_LISTVIEW   pnlv = (LPNM_LISTVIEW)lParam;

                    switch (pnlv->hdr.code)
					{
                        case NM_RCLICK:
                            HMENU   hMenu;
                            hMenu = CreatePopupMenu();
                            AppendMenu(hMenu,
										MF_ENABLED | MF_STRING,
										ID_GETTESTFILE,
										(LPSTR)&"&Select Test File");

                           AppendMenu(hMenu,
										MF_ENABLED | MF_STRING,
										ID_GETPROPERTY,
										(LPSTR)&"&Get Properties");
									
                            GetCursorPos(&p);
                            TrackPopupMenu(hMenu,
                                TPM_LEFTBUTTON,
                                p.x,
                                p.y,
                                0,
                                hDlg,
                                NULL);

                            DestroyMenu(hMenu);
                            break;
 
						default:
                            break;
                    }
            } // end switch (wParam)


    case WM_COMMAND:
		switch (LOWORD(wParam))
		{ 

           case ID_GETTESTFILE:

				// get registered DMO names and display them 
				// delete previous content from list view and load new content from memory for display

 				ListView_DeleteAllItems(pThis->m_hTestFileList);

				pThis->InitTestFileListView( pThis->m_hTestFileList );
				ShowWindow(m_hSelectFilesDlg, SW_SHOW);
				break;

			case ID_GETPROPERTY:
				// get the CLSID of the selected DMO
				UINT ii;
				LPSTR szDmoClsid;

				ii = ListView_GetItemCount(pThis->m_hDmoList);
				for(; ii; ii--)
				{
					if(0!= ListView_GetItemState(
							pThis->m_hDmoList,
							ii-1,
							LVIS_SELECTED))
					{
						szDmoClsid = pThis->GetDmoClsid(ii-1);
						
					}
				}
			
				// clean the MEDIATYPELIST
				iItemNum = SendMessage(pThis->m_hMediaTypeList, LB_GETCOUNT, 0,0);
			
				if(iItemNum > 0)
				{
				for(int i = 0; i< iItemNum; i++)
					SendMessage(pThis->m_hMediaTypeList, LB_DELETESTRING, (WPARAM)0,0);
				}
				// add types to the media type list
				GetDmoTypeInfo(szDmoClsid,pThis->m_hMediaTypeList);
				ShowWindow(m_hMediaTypeDlg, SW_SHOW);
  				break; 
			case IDOK:

				// get a list of selected DMOs and test files (struct)
				// and write to the profile:
				WriteSelectedDmos();
				EndDialog(hDlg, TRUE);
				return TRUE ; 
				
			case IDCANCEL:
				EndDialog(hDlg, TRUE);
				return TRUE;
		}	
		break;
     }
	return FALSE;
}
/******************************************************************************

   InitListView

******************************************************************************/

BOOL 
CDmoTest::InitListView(HWND hwndListView)
{
	LV_COLUMN   lvColumn;
	int         i;
	TCHAR       szString[3][MAX_LEN] = {"DMO Component", "Class ID", "Number of Test Files Selected"};


	//empty the list
	ListView_DeleteAllItems(hwndListView);

	for(i = 0; i < NUM_OF_DMO_SUBITEM_COLUMN; i++)
	{
		ListView_DeleteColumn(hwndListView, 0);
	}



	//initialize the columns
	lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.cx = 200;
	for(i = 0; i < NUM_OF_DMO_SUBITEM_COLUMN; i++)
	{
		lvColumn.pszText = szString[i];
		lvColumn.iSubItem = 0;
		ListView_InsertColumn(hwndListView, i, &lvColumn);
	}

	// set the number of items in the list
	ListView_SetItemCount(hwndListView, ITEM_COUNT);
	
	AddListViewItems(pThis->m_hDmoList);

	return TRUE;
}









//*****************************************************************
BOOL AddListViewItems(HWND hLV)
{
	
	LVITEM lvI;
	INT dIndex;
	char szNumFile[MAX_NUM];



	for(int i = g_dwNumOfComponents-1; i>=0;i--)
	{
		lvI.mask = LVIF_TEXT|LVIF_IMAGE;
		lvI.iItem = 0;
		lvI.iSubItem = 0;
		lvI.pszText = g_component[i].szComName;
    
		dIndex = ListView_InsertItem(hLV,&lvI);

		if( g_component[i].iSelectedForTest != 0 ) // selected
		{
			ListView_SetCheckState(	pThis->m_hDmoList,
								 dIndex,
								TRUE);
		}

		lvI.mask = TVIF_TEXT;
		lvI.iItem = dIndex;
		lvI.iSubItem = 1;
		lvI.pszText = g_component[i].szClsid;
		ListView_SetItem(hLV,&lvI);





		_itoa( g_component[i].iNumTestFiles, szNumFile, 10);

		lvI.mask = TVIF_TEXT;
		lvI.iItem = dIndex;		
		lvI.iSubItem = 2;
		lvI.pszText = szNumFile;
		ListView_SetItem(hLV,&lvI);


	}
	return TRUE;
}


/*-----------------------------------------------------------------------------
|	Function:	CQAsfModule::SelectDmoDialogProc
|	Purpose:	processing messages for Play path/Duration window  
\----------------------------------------------------------------------------*/
INT_PTR CALLBACK
CDmoTest::SelectTestFileDialogProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) 
{
	
//	static HWND hwndEdit;
	INT dIndex = 0;
	int iSelectedDmo = ListView_GetSelectionMark( pThis->m_hDmoList );

	switch( msg ) 
	{	
	case WM_INITDIALOG:
		pThis = (CDmoTest*) lParam;
		pThis->m_hTestFileList = ::GetDlgItem(hDlg, IDC_TESTFILELIST);
		return TRUE;

    case WM_COMMAND:
		switch (LOWORD(wParam))
		{ 

           case ID_ADDFILE:              			
				// Call the FileOpen common dialog to get test files
				// and display in file selection dialog
				GetTestFileName( hDlg, pThis->m_hTestFileList );
				break;
  
			case IDOK:
				//save selected files in global variables.
				SaveSelectedTestFiles(pThis->m_hTestFileList);
				EndDialog(hDlg, TRUE);
				return TRUE ; 

			case IDREMOVEALL:
				ListView_DeleteAllItems(pThis->m_hTestFileList);
				return TRUE;

			case ID_REMOVEFILE:
				UINT ii;
				ii = ListView_GetItemCount(pThis->m_hTestFileList);
				for(; ii; ii--)
				{
					if(0!= ListView_GetItemState(
							pThis->m_hTestFileList,
							ii-1,
							LVIS_SELECTED))
					{
						ListView_DeleteItem(pThis->m_hTestFileList, ii-1);
						
					}
				}
				return TRUE;
				
			case IDCANCEL:
				EndDialog(hDlg, TRUE);
				return TRUE;
		}
	
		break;
     }

	return FALSE;
}

/******************************************************************************

   InitListView

******************************************************************************/

BOOL 
CDmoTest::InitTestFileListView(HWND hwndListView)
{
	LV_COLUMN   lvColumn;
	int         i;
	TCHAR       szString[2][20] = {"File Name", "Media Format"};

	//empty the list
	ListView_DeleteAllItems(hwndListView);

	//initialize the columns
	lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.cx = 400;
	for(i = 0; i < NUM_OF_FILE_SUBITEM_COLUMN+1; i++)
	{
		lvColumn.pszText = szString[i];
		ListView_InsertColumn(hwndListView, i, &lvColumn);
	}

	//set the number of items in the list
	ListView_SetItemCount(hwndListView, ITEM_COUNT);

	// get and highlight selected DMOs from ini or profile
	// TBD
	AddTestFilesInListView(hwndListView);
	return TRUE;
}
/******************************************************************************

   InsertListViewItems

******************************************************************************/
BOOL AddTestFilesInListView(HWND hLV)
{


	LVITEM lvI;
	int	iNumDmo = 0;
	CHAR szFileNum[81];

  	int iSelectedDmo = ListView_GetSelectionMark( pThis->m_hDmoList );

	for(int i=g_component[iSelectedDmo].iNumTestFiles-1; i>=0; i--)
	{

		lvI.mask = LVIF_TEXT|LVIF_IMAGE;
		lvI.iItem = i;
		lvI.iSubItem = 0;
		lvI.pszText = (LPSTR)(g_component[iSelectedDmo].szInputFile[i]);		
		//lvI.pszText = " ";
		ListView_InsertItem(hLV,&lvI);	
	}
	return TRUE;
}







/*-----------------------------------------------------------------------------
|	Function:	CQAsfModule::SelectDmoDialogProc
|	Purpose:	processing messages for Play path/Duration window  
\----------------------------------------------------------------------------*/
INT_PTR CALLBACK
CDmoTest::MediaTypeDialogProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) 
{

	switch( msg ) 
	{	
	case WM_INITDIALOG:
		pThis = (CDmoTest*) lParam;
		pThis->m_hMediaTypeList = ::GetDlgItem(hDlg, IDC_MEDIATYPELIST);
		return TRUE;

    case WM_COMMAND:
		switch (LOWORD(wParam))
		{ 

			case IDOK:

				EndDialog(hDlg, TRUE);
				return TRUE ; 

				
			case IDCANCEL:
				EndDialog(hDlg, TRUE);
				return TRUE;
		}
	
		break;
     }

	return FALSE;
}





/*-----------------------------------------------------------------------------
|	Function:	CDmoTest::DataGenDialogProc
|	Purpose:	processing messages for Play path/Duration window  
\----------------------------------------------------------------------------*/
INT_PTR CALLBACK
CDmoTest::DataGenDialogProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) 
{
	
    char lpszInFilename[100]; 
    DWORD dwInFilenameLen; 
    char lpszOutFilename[100]; 
    DWORD dwOutFilenameLen; 


	switch( msg ) 
	{	
	case WM_INITDIALOG:
		pThis = (CDmoTest*) lParam;
		pThis->m_hInputFileField = ::GetDlgItem(hDlg, IDC_INPUTFIELD);
		pThis->m_hOutputFileField = ::GetDlgItem(hDlg, IDC_OUTPUTFIELD);
		return TRUE;

    case WM_COMMAND:
		switch (LOWORD(wParam))
		{ 
			case IDC_INPUTBROWSE:              			
				// Call the FileOpen common dialog to get test files
				// and display in DataGenDialog
				GetInOutFileName( hDlg, pThis->m_hInputFileField);
				break;
			case IDC_OUTPUTBROWSE:              			
				// Call the FileOpen common dialog to get test files
				// and display in DataGenDialog
				GetInOutFileName( hDlg, pThis->m_hOutputFileField);
				break;

			case IDOK:

				// get the input/output file names and use spliter and data dump filter
				// to generate output data
				//TBD


                    // Get number of characters. 

                dwInFilenameLen = (DWORD) SendDlgItemMessage(hDlg, 
															IDC_INPUTFIELD, 
															EM_LINELENGTH, 
															(WPARAM) 0, 
															(LPARAM) 0); 
                dwOutFilenameLen = (DWORD) SendDlgItemMessage(hDlg, 
															IDC_OUTPUTFIELD, 
															EM_LINELENGTH, 
															(WPARAM) 0, 
															(LPARAM) 0); 


                if (dwInFilenameLen == 0) 
                { 
					MessageBox(hDlg, 
								"No characters entered.", 
								"Error", 
								MB_OK); 
                    EndDialog(hDlg, TRUE); 
                    return FALSE; 
                } 
                if (dwOutFilenameLen == 0) 
                { 
					MessageBox(hDlg, 
								"No characters entered.", 
								"Error", 
								MB_OK); 
                    EndDialog(hDlg, TRUE); 
                    return FALSE; 
                } 
                   

                    // Get the characters. 
                 SendDlgItemMessage(hDlg, 
									IDC_INPUTFIELD, 
									EM_GETLINE, 
									(WPARAM) 0,       // line 0 
									(LPARAM) lpszInFilename); 

                 SendDlgItemMessage(hDlg, 
									IDC_OUTPUTFIELD, 
									EM_GETLINE, 
									(WPARAM) 0,       // line 0 
									(LPARAM) lpszOutFilename); 

                // Null-terminate the string. 
				lpszInFilename[dwInFilenameLen] = 0; 
				lpszOutFilename[dwOutFilenameLen] = 0; 

				g_IShell->Log(1, "retrieved input filename is %s", lpszInFilename);
				g_IShell->Log(1, "retrieved output filename is %s", lpszOutFilename);

				EndDialog(hDlg, TRUE);
				return TRUE ; 

				
			case IDCANCEL:
				EndDialog(hDlg, TRUE);
				return TRUE;
		}
	
		break;
     }

	return FALSE;
}








//
//   FUNCTION: OpenTheFile(HWND hwnd, HWND hwndEdit)
//
//   PURPOSE: Invokes common dialog function to open a file and opens it.
//
//   COMMENTS:
//
//	This function initializes the OPENFILENAME structure and calls
//            the GetOpenFileName() common dialog function.  
//	
//    RETURN VALUES:
//        TRUE - The file was opened successfully and read into the buffer.
//        FALSE - No files were opened.
//
//
unsigned int CALLBACK ComDlg32DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

	switch (uMsg)
	{
		case WM_INITDIALOG:
			break;

		case WM_DESTROY:
			break;

		case WM_NOTIFY:

		default:
			return FALSE;
	}
	return TRUE;
}

/******************************************************************************

**********************************************************************************/
BOOL GetTestFileName( HWND hWnd, HWND hLV )
{
    HANDLE hFile;
    DWORD dwBytesRead;
	DWORD dwFileSize;
	OPENFILENAME OpenFileName;
	TCHAR         szFile[MAX_PATH]      = "\0";
	char *lpBufPtr;
	DWORD ret = 0;
    strcpy( szFile, "");

	// Fill in the OPENFILENAME structure to support a template and hook.
	OpenFileName.lStructSize       = sizeof(OPENFILENAME);
    OpenFileName.hwndOwner         = hWnd;
    OpenFileName.hInstance         = g_hInst;
    OpenFileName.lpstrFilter       = NULL;
    OpenFileName.lpstrCustomFilter = NULL;
    OpenFileName.nMaxCustFilter    = 0;
    OpenFileName.nFilterIndex      = 0;
    OpenFileName.lpstrFile         = szFile;
    OpenFileName.nMaxFile          = sizeof(szFile);
    OpenFileName.lpstrFileTitle    = NULL;
    OpenFileName.nMaxFileTitle     = 0;
    OpenFileName.lpstrInitialDir   = NULL;
    OpenFileName.lpstrTitle        = "Open a File";
    OpenFileName.nFileOffset       = 0;
    OpenFileName.nFileExtension    = 0;
    OpenFileName.lpstrDefExt       = NULL;
    OpenFileName.lCustData         = (LPARAM)&sMyData;
//	OpenFileName.lpfnHook 		   = pThis->SelectDmoDialogProc;
//	OpenFileName.lpfnHook = ComDlg32DlgProc;
	OpenFileName.lpTemplateName    = MAKEINTRESOURCE(IDD_DMODIALOG);
    OpenFileName.Flags             = OFN_EXPLORER|OFN_ALLOWMULTISELECT; //OFN_SHOWHELP | OFN_EXPLORER | OFN_ENABLEHOOK | OFN_ENABLETEMPLATE;

	// add error checking ...
	if (GetOpenFileName(&OpenFileName) == 0)
	{
		char buffer[20];
		ret = CommDlgExtendedError();
		sprintf(buffer,"(%x)",ret);
		OutputDebugStringA(buffer);
	}

	// display selected files
	LVITEM lvI;
	INT dIndex;
	// get the file path and names from OpenFileName.lpstrFile:
	char szPath[MAX_LEN];
	char szFileNames[MAX_NUM][MAX_LEN]={0};
	char szFullFileName[MAX_NUM][MAX_LEN]={0};
	int iNumFiles = 0;
	int offset = 0;
	char* strFile;

	lstrcpyn( szPath, (LPSTR)OpenFileName.lpstrFile,OpenFileName.nFileOffset );

	for(;;)
	{
		lstrcpy(szFileNames[iNumFiles], OpenFileName.lpstrFile + OpenFileName.nFileOffset + offset);
		int size = lstrlen(szFileNames[iNumFiles]);
		if (size == 0)
			break;
		
		sprintf(szFullFileName[iNumFiles], "%s\\%s", szPath, szFileNames[iNumFiles]);
		offset += size + 1; 
		
		lvI.mask = LVIF_TEXT|LVIF_IMAGE;
		lvI.iItem = iNumFiles;
		lvI.iSubItem = 0;
		lvI.pszText = (LPSTR)(szFullFileName[iNumFiles]);		
    
		dIndex = ListView_InsertItem(hLV,&lvI);	

		iNumFiles++;
	}


	return TRUE;
}






BOOL GetInOutFileName( HWND hWnd, HWND hLV )
{
    HANDLE hFile;
    DWORD dwBytesRead;
	DWORD dwFileSize;
	OPENFILENAME OpenFileName;
	TCHAR         szFile[MAX_PATH]      = "\0";
	char *lpBufPtr;
	DWORD ret = 0;
    strcpy( szFile, "");

	// Fill in the OPENFILENAME structure to support a template and hook.
	OpenFileName.lStructSize       = sizeof(OPENFILENAME);
    OpenFileName.hwndOwner         = hWnd;
    OpenFileName.hInstance         = g_hInst;
    OpenFileName.lpstrFilter       = NULL;
    OpenFileName.lpstrCustomFilter = NULL;
    OpenFileName.nMaxCustFilter    = 0;
    OpenFileName.nFilterIndex      = 0;
    OpenFileName.lpstrFile         = szFile;
    OpenFileName.nMaxFile          = sizeof(szFile);
    OpenFileName.lpstrFileTitle    = NULL;
    OpenFileName.nMaxFileTitle     = 0;
    OpenFileName.lpstrInitialDir   = NULL;
    OpenFileName.lpstrTitle        = "Open a File";
    OpenFileName.nFileOffset       = 0;
    OpenFileName.nFileExtension    = 0;
    OpenFileName.lpstrDefExt       = NULL;
    OpenFileName.lCustData         = (LPARAM)&sMyData;
//	OpenFileName.lpfnHook 		   = pThis->SelectDmoDialogProc;
//	OpenFileName.lpfnHook = ComDlg32DlgProc;
	OpenFileName.lpTemplateName    = MAKEINTRESOURCE(IDD_DATAGENDIALOG);
    OpenFileName.Flags             = OFN_EXPLORER|OFN_ALLOWMULTISELECT; //OFN_SHOWHELP | OFN_EXPLORER | OFN_ENABLEHOOK | OFN_ENABLETEMPLATE;

	// add error checking ...
	if (GetOpenFileName(&OpenFileName) == 0)
	{
		char buffer[20];
		ret = CommDlgExtendedError();
		sprintf(buffer,"(%x)",ret);
		OutputDebugStringA(buffer);
	}

	// display selected files

	// get the file path and names from OpenFileName.lpstrFile:
	char szPath[MAX_LEN];
	char szFileNames[MAX_NUM][MAX_LEN]={0};
	char szFullFileName[MAX_NUM][MAX_LEN]={0};
	int iNumFiles = 0;
	int offset = 0;
	char* strFile;

	lstrcpyn( szPath, (LPSTR)OpenFileName.lpstrFile, OpenFileName.nFileOffset );

	for(;;)
	{
		lstrcpy(szFileNames[iNumFiles], OpenFileName.lpstrFile + OpenFileName.nFileOffset + offset);
		int size = lstrlen(szFileNames[iNumFiles]);
		
		if (size == 0)
			break;
		
		sprintf(szFullFileName[iNumFiles], "%s\\%s", szPath, szFileNames[iNumFiles]);
		offset += size + 1; 

		g_IShell->Log(1, "%d selected files is %s", iNumFiles, szFullFileName[iNumFiles]);
		SendMessage(hLV, WM_SETTEXT, 0, (LPARAM) szFullFileName[iNumFiles]); 

		iNumFiles++;
	}


	return TRUE;
}

/*********************************************************************************
Save selected test files:

********************************************************************************/

BOOL SaveSelectedTestFiles(HWND hLV)
{
	// save the selected test files and number in global variables:
	int iSelectedDmo = ListView_GetSelectionMark( pThis->m_hDmoList );
	g_component[iSelectedDmo].iNumTestFiles = ListView_GetItemCount(hLV);
	
	for(int j= 0; j<g_component[iSelectedDmo].iNumTestFiles; j++)
	{
		ListView_GetItemText( hLV, 
							  j,
							  0, 
							  g_component[iSelectedDmo].szInputFile[j],
							  MAX_LEN);
	}

	// display the number of test files in the DMO selection dialog
	LVITEM lvDmoItem;
	char szNumFiles[MAX_NUM];
	_itoa(g_component[iSelectedDmo].iNumTestFiles, szNumFiles, 10);

	lvDmoItem.mask = TVIF_TEXT;
	lvDmoItem.iItem = iSelectedDmo;
	lvDmoItem.iSubItem = 2;
	lvDmoItem.pszText = szNumFiles;
	ListView_SetItem(pThis->m_hDmoList,&lvDmoItem);

	return TRUE;

}


/*************************************************************************************

// get a list of selected DMOs and test files, save to global variables
// and write to the .ini file:

**************************************************************************************/
BOOL WriteSelectedDmos()
{
	int count = 0;
	for(int i=0; i<g_dwNumOfComponents; i++)
	{
		if(0 != ListView_GetCheckState(pThis->m_hDmoList,	i))
		{
			g_component[i].iSelectedForTest = 1;
			count++;
		}
		else
		{
			g_component[i].iSelectedForTest = 0;
		}

	}

	g_dwNumOfSelectedComponents = count;
	pThis->SaveSettings(" "," ");
	return TRUE;
			
}

/*************************************************************************************

// get a list of registered DMOs, save to global variables


**************************************************************************************/
BOOL GetRegisteredDmos()
{
	DMOINFO rgDmoInfo[ITEM_COUNT];
	int	iNumDmo = 0;
	LPSTR pDMO[1000];

	OutputDMOs( &iNumDmo, rgDmoInfo );


	g_dwNumOfComponents = iNumDmo;

	for(int i=0; i<iNumDmo; i++)
	{
		lstrcpy( g_component[i].szComName, rgDmoInfo[i].szName);
		lstrcpy( g_component[i].szClsid, rgDmoInfo[i].szClsId);
	}

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dmotst\dmotest.h ===
#ifndef _VARIABLE_INC_
#define _VARIABLE_INC_
/*=============================================================================
|
|	File: dmotest.h
|
|	Copyright (c) 2000 Microsoft Corporation.  All rights reserved
|
|	Abstract:
|		Example of deriving of CTreeModule and CTestNodeItem classes to create
|		a test application with the ability to pass variables to the test functions
|
|	Contents:
|		
|
|	History:
|		5/1/2000    wendyliu    First version 
|
\============================================================================*/


#include <windows.h>
#include <treemod.h>


/*=============================================================================
|	RESOURCES 
\============================================================================*/

#define APPICON                    101
#define ITEM_COUNT                 100
#define NUM_OF_DMO_SUBITEM_COLUMN  3
#define NUM_OF_FILE_SUBITEM_COLUMN 1
#define MAX_LEN                    255
#define MAX_NUM                    50

#define TX_NO_OF_COMPONENTS_ENTRY				"No of Components"
#define TX_NO_OF_SELECTED_COMPONENTS_ENTRY		"No of Selected Components"

#define TX_COMPONENT_ENTRY				"Component Name"
#define TX_CLASSID_ENTRY				"Class ID"
#define TX_SELECTED_FOR_TEST            "Selected for Test"

#define TX_NO_OF_TEST_FILES_ENTRY		"No of Test Files"

#define TX_FILENAME_ENTRY				"Input File Name"
#define TX_NOT_EXIST				    "Not Exist"



class CTestNodeItem;
class CDmoTestCase;

//typedef CTestNodeItem *PCTestNodeItem;
//typedef PCTestNodeItem *PPCTestNodeItem;

typedef CDmoTestCase *PCDmoTestCase;
typedef PCDmoTestCase *PPCDmoTestCase;

//the type of function that will be called by RunTest
typedef DWORD (*DMOTESTFNPROC1)(LPSTR pszVar1, LPSTR pszVar2);
typedef DWORD (*DMOTESTFNPROC2)(LPSTR pszVar1);

/*=============================================================================
|	CLASS DEFINITIONS
\============================================================================*/
/*-----------------------------------------------------------------------------
|	Class:		CDmoTest
|	Purpose:	Derive CTestModule for more reusable form
|	Notes:		This is admittedly not the best implementation but the 
|				interface is what matters.  Most of the functions are wrappers
|				for functionality provided by CTestNodeItem and its
|				derivitives.
\----------------------------------------------------------------------------*/

class CDmoTest : public CTreeModule
{

private:
	char m_szScriptFileName[256];

protected:
	//wrapper for AddCase in this module
	void AddCase(LPSTR pszCaseID,	LPSTR pszName, DMOTESTFNPROC1 pfnTest, CDmoTest* dmoTest);

	//overloaded variable passing version of AddCase
	void AddCase(LPSTR pszCaseID, LPSTR pszName, DMOTESTFNPROC2 pfnTest, CDmoTest* dmoTest);

	// Defined for each module by user
    virtual void InitCaseTree();



public:
    CDmoTest(CTestShell* pShell, HINSTANCE hInstDLL);
    virtual ~CDmoTest(void);


	// event display dialog proc
	static INT_PTR CALLBACK SelectDmoDialogProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
	static INT_PTR CALLBACK SelectTestFileDialogProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
	static INT_PTR CALLBACK MediaTypeDialogProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
	static INT_PTR CALLBACK DataGenDialogProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);



	DWORD LoadSettings(LPSTR pszFileName, LPSTR pszSetction);
	DWORD SaveSettings(LPSTR pszFileName, LPSTR pszSetction);

	BOOL InitListView(HWND hListView);
	BOOL InitTestFileListView(HWND hListView);

    virtual DWORD Initialize(void);
	DWORD   RunTest(DWORD dwTestID);

	DWORD OnInitialUpdate(void);
    void ProcessMenuItem(DWORD nID, HWND hWndCtl, DWORD codeNotify, HMENU hOptionMenu);

	int GetNumComponent();
	LPSTR GetDmoName(int index);
	LPSTR GetDmoClsid(int index);
	BOOL IsDmoSelected(int index);
	int  GetNumTestFile(int index);
	LPSTR GetFileName(int comIndex, int fileIndex);
	HWND  GetWindowHandle();
	int GetNumSelectedDmo();

	static HWND	    m_hSelectDmoDlg;
	static HWND		m_hSelectFilesDlg;
	static HWND     m_hMediaTypeDlg;
	static HWND     m_hDataGenDlg;

	HWND		    m_hDmoList;
	HWND		    m_hTestFileList;
	HWND			m_hMediaTypeList;
	HWND			m_hInputFileField;
	HWND			m_hOutputFileField;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dmotst\dmotestnode.h ===
#ifndef _DMOTESTNODE_H
#define _DMOTESTNODE_H
/*=============================================================================
|
|	File: DmoTestNode.h
|
|	Copyright (c) 2000 Microsoft Corporation.  All rights reserved
|
|	Abstract:
|		Redifining CTestCaseInfo in the process of creating a
|		test application
|
|	Contents:
|		
|
|	History:
|		5/16/2000   wendyliu    initial version 
|
|
\============================================================================*/

#include <windows.h>
#include <CaseNode.h>
#include "dmotest.h"

/*=============================================================================
|	CLASS DEFINITIONS
\============================================================================*/
/*-----------------------------------------------------------------------------
|	Class:		CDmoTestCase
|	Purpose:	Defines VarTestcase node for use in the test case tree
|	Notes:		This is an example of add a new type of node of use in the 
|				test case tree.  It keeps the container object as protected 
|				member variable, used by its subclass to get the information
|				(DMO and test file name) for the runtest method.
\----------------------------------------------------------------------------*/



class CDmoTestCase : public CTestNodeItem
{
protected:
	CDmoTest*       m_pDmoTest;

public:

	CDmoTestCase(	LPSTR pszNewCaseID, 
					LPSTR pszNewName,
					CDmoTest* dmoTest);

	virtual ~CDmoTestCase();
	virtual DWORD   RunTest(void) = 0;
};


inline
CDmoTestCase::CDmoTestCase(	LPSTR pszNewCaseID, 
							LPSTR pszNewName,
							CDmoTest* dmoTest)

		: CTestNodeItem(false, pszNewCaseID, pszNewName, 0),
		  m_pDmoTest(dmoTest)
{

}

inline	
CDmoTestCase::~CDmoTestCase() 
{

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dmotst\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by temp2.rc
//
#define ID_ADDFILE                      3
#define ID_REMOVEFILE                   4
#define IDREMOVEALL                     5
#define APPICON                         101
#define IDD_DMODIALOG                   102
#define IDD_TESTFILEDIALOG              103
#define IDD_MEDIATYPEDIALOG             105
#define IDD_DATAGENDIALOG               106
#define IDC_DMOLIST                     1000
#define ID_GETTESTFILE                  1001
#define IDC_TESTFILELIST                1002
#define IDC_MEDIATYPELIST               1003
#define ID_GETPROPERTY                  1004
#define IDC_INPUTBROWSE                 1005
#define IDC_OUTPUTFIELD                 1006
#define IDC_OUTPUTBROWSE                1007
#define IDC_INFO                        1008
#define IDC_INPUT                       1009
#define IDC_OUTPUT                      1010
#define IDC_INPUTLIST                   1011
#define IDC_INPUTFIELD                  1012
#define IDM_SELECTDMO                   4001
#define IDM_DATAGEN                     4002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1013
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dmotst\dmotestcases.h ===
#ifndef _DMOTESTCASES_H
#define _DMOTESTCASES_H
/*=============================================================================
|
|	File: DmoTestCases.h
|
|	Copyright (c) 2000 Microsoft Corporation.  All rights reserved
|
|	Abstract:
|		Redifining CDmoTestCase in the process of creating a
|		test application
|
|	Contents:
|		
|
|	History:
|		5/16/2000   wendyliu    initial version 
|
|
\============================================================================*/
#include <windows.h>
#include "DmoTestNode.h"

/*=============================================================================
|	CLASS DEFINITIONS
\============================================================================*/
/*-----------------------------------------------------------------------------
|	Class:		CDmoTestCase1
|	Purpose:	Defines CDmoTestCase1 node for use in the test case tree
|	Notes:		adds a new type of node of use in the 
|				test case tree.  It gets the DMO and test file name information
|				from the container object.
\----------------------------------------------------------------------------*/


class CDmoTestCase1 : public CDmoTestCase
{
private:
    DMOTESTFNPROC1	pfnTest;


public:

	CDmoTestCase1(	LPSTR pszNewCaseID, 
					LPSTR pszNewName,
					DMOTESTFNPROC1 pfnNewTest, 
					CDmoTest* dmoTest);

	virtual ~CDmoTestCase1();
	DWORD   RunTest(void);
};
/*=============================================================================
|	CLASS DEFINITIONS
\============================================================================*/
/*-----------------------------------------------------------------------------
|	Class:		CDmoTestCase1
|	Purpose:	Defines CDmoTestCase1 node for use in the test case tree
|	Notes:		adds a new type of node of use in the 
|				test case tree.  It gets the DMO  information
|				from the container object.
\----------------------------------------------------------------------------*/
class CDmoTestCase2 : public CDmoTestCase
{
private:
    DMOTESTFNPROC2	pfnTest;


public:

	CDmoTestCase2(	LPSTR pszNewCaseID, 
					LPSTR pszNewName,
					DMOTESTFNPROC2 pfnNewTest, 
					CDmoTest* dmoTest);

	virtual ~CDmoTestCase2();
	DWORD   RunTest(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\common.inc ===
# This file contains everything that's common between all AMovie directories.

SOURCES_USED=$(ROOT)\common.inc

SDK_ROOT=$(BASEDIR)\public\sdk\amovie

UMTYPE=windows

# Use NT4/Win95 base API's with IE4 addon support.

WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400

WIN32_IE_VERSION=0x0400

NOT_LEAN_AND_MEAN=1

# Runs on NT4/Win95 or better

SUBSYSTEM_VERSION=4.00

!if "$(BUILD_PRODUCT)" != "NT"
C_DEFINES=$(C_DEFINES) -DSTRICT -DWINVER=0x0400 -DNT_BUILD -DDIRECTDRAW_VERSION=0x0300 -DDIRECTSOUND_VERSION=0x0300 -DFINAL=1 -DOFFICIAL=1
!else
C_DEFINES=$(C_DEFINES) -DSTRICT -DWINVER=0x0500 -DNT_BUILD -DDIRECTDRAW_VERSION=0x0300 -DDIRECTSOUND_VERSION=0x0700 -DFINAL=1 -DOFFICIAL=1
!endif

!if !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG
LINKER_NOICF      = 1           # ICF is s-l-o-w
!endif

INCLUDES= \
    $(SDK_ROOT)\inc; \
    $(ROOT)\h;


!if exist( "$(ROOT)\qbuild.ver" )
C_DEFINES=$(C_DEFINES) -DQBUILD_VER
INCLUDES = $(INCLUDES)$(ROOT);
!endif

MSC_WARNING_LEVEL=/W3

# unfortunately sources files define PRECOMPILED_INCLUDE after this
# file is preprocessed, and there doesn't appear to be a way to delay
# its evaluation
!ifndef PRECOMPILED_INCLUDE
!ifndef DISABLE_PCH
USER_C_FLAGS=/Yustreams.h /Fp$(SDK_ROOT)\lib$(BUILD_ALT_DIR)\$(TARGET_DIRECTORY)\streams.pch $(USER_C_FLAGS)
!endif
!endif

USE_MSVCRT=1

QUARTZ_LIB_DIR = $(ROOT)\lib$(BUILD_ALT_DIR)\$(TARGET_DIRECTORY)

!ifdef PERF
C_DEFINES=$(C_DEFINES) -DPERF
QUARTZ_PERF_LIB=$(QUARTZ_LIB_DIR)\measure.lib
!endif

# allow mixing debug/retail strmbase.lib in our builds only. the NT
# tree pulls it from nt\public\sdk\lib
#STRMBASE_LIB=$(SDK_ROOT)\lib$(BUILD_ALT_DIR)\$(TARGET_DIRECTORY)\strmbase.lib

!if "$(BUILD_ALT_DIR)" == "d"
STRMBASE_LIB=$(SDK_LIB_PATH)\strmbasd.lib
!else
STRMBASE_LIB=$(SDK_LIB_PATH)\strmbase.lib
!endif

!if "$(BUILD_PRODUCT)" != "NT"
!if !$(FREEBUILD)
DEBUG_CRTS=1
!endif
!else
!ifndef NEVER_UNICODE
C_DEFINES=-DUNICODE -D_UNICODE $(C_DEFINES)
WIN32_WINNT_VERSION=0x0500
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\dshowreg\dsreg.cpp ===
#include <windows.h>
#include <tchar.h>
#include <objbase.h> // CoCreateInstance
#include <wtypes.h> // WINAPI
#include <uuids.h>  // AM CLSIDs (ActiveMovieCategories)
#include <strmif.h> // AM IIDs (IFilterMapper)
#include "dmocom.h"
#include "dmoreg.h"
#include "dmodshow.h"
#include "moniker.h"
#include "dmoutils.h"

class CDMOFilterCategory : public CComBase, public ICreateDevEnum {
public:
   static CComBase* CALLBACK CreateInstance(LPUNKNOWN, HRESULT*);
   CDMOFilterCategory(LPUNKNOWN pUnk, HRESULT *phr);
   DECLARE_IUNKNOWN;
   STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
   STDMETHODIMP CreateClassEnumerator (REFCLSID clsidDeviceClass,
                                      IEnumMoniker **ppEnumMoniker,
                                      DWORD dwFlags);
};

class CDMOEnumMoniker : public IEnumMoniker {
public:
   CDMOEnumMoniker(HRESULT *phr);
   ~CDMOEnumMoniker();
   STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
   STDMETHODIMP_(ULONG) AddRef();
   STDMETHODIMP_(ULONG) Release();
   STDMETHODIMP Next(ULONG celt, IMoniker **ppMonikers, ULONG *pceltFetched);
   STDMETHODIMP Skip(ULONG celt);
   STDMETHODIMP Reset(void);
   STDMETHODIMP Clone(IEnumMoniker ** ppenum);
private:
   IEnumDMO *m_pEnum; // DMO CLSID enumerator
   volatile long m_cRef;
};

CComBase* CDMOFilterCategory::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr) {
   *phr = NOERROR;
   return new CDMOFilterCategory(pUnk, phr);
}

CDMOFilterCategory::CDMOFilterCategory(LPUNKNOWN pUnk, HRESULT *phr)
   : CComBase(pUnk)
{
}

HRESULT CDMOFilterCategory::CreateClassEnumerator (REFCLSID clsidDeviceClass,
                                    IEnumMoniker **ppEnumMoniker,
                                    DWORD dwFlags) {
   HRESULT hr;
   CDMOEnumMoniker *pEnum = new CDMOEnumMoniker(&hr);
   if (SUCCEEDED(hr)) {
      pEnum->AddRef();
      *ppEnumMoniker = (IEnumMoniker*)pEnum;
   }
   else {
      delete pEnum;
   }
   return hr;
}

HRESULT CDMOFilterCategory::NDQueryInterface(REFIID riid, void **ppv) {
   if (riid == IID_ICreateDevEnum)
       return GetInterface((ICreateDevEnum *) this, ppv);
   else
       return CComBase::NDQueryInterface(riid, ppv);
}

CDMOEnumMoniker::CDMOEnumMoniker(HRESULT *phr) {
   m_cRef = 0;
   *phr = DMOEnum(
      GUID_NULL, // all categories
      0, // flags
      0, // no input types
      NULL,
      0, // no output types
      NULL,
      &m_pEnum // DMO CLSID enumerator
   );
   if (SUCCEEDED(*phr)) {
      if (!m_pEnum)
         *phr = E_FAIL;
   }
}


CDMOEnumMoniker::~CDMOEnumMoniker() {
   if (m_pEnum)
      m_pEnum->Release();
}

ULONG CDMOEnumMoniker::AddRef() {
   return InterlockedIncrement(&m_cRef);
}

ULONG CDMOEnumMoniker::Release() {
   long l = InterlockedDecrement(&m_cRef);
   if (l == 0)
      delete this;
   return l;
}

HRESULT CDMOEnumMoniker::QueryInterface(REFIID riid, void **ppv) {
   if (riid == IID_IUnknown)
      *ppv = (IUnknown*)this;
   else if (riid == IID_IEnumMoniker)
      *ppv = (IEnumMoniker*)this;
   else
      return E_NOINTERFACE;
   AddRef();
   return NOERROR;
}

class CAutoReleaseArrayPtr {
public:
   CAutoReleaseArrayPtr(void** pp) {m_pp = pp;}
   ~CAutoReleaseArrayPtr() {if (*m_pp) delete[] *m_pp;}
   void** m_pp;
};

HRESULT CDMOEnumMoniker::Next(ULONG celt, IMoniker **ppMonikers, ULONG *pceltFetched) {
   CLSID *pCLSIDs = new CLSID[celt];
   WCHAR** pszNames = new WCHAR* [celt];
   CAutoReleaseArrayPtr p1((void**)&pCLSIDs);
   CAutoReleaseArrayPtr p2((void**)&pszNames);

   if (!pCLSIDs || !pszNames)
      return E_OUTOFMEMORY;

   // Get CLSIDs from the DMO CLSIDs enumerator
   HRESULT hr = m_pEnum->Next(celt, pCLSIDs, pszNames, pceltFetched);
   if (FAILED(hr))
      return hr;
   if (*pceltFetched > celt) {
      *pceltFetched = 0;
      return E_UNEXPECTED;
   }

   // Now create some monikers
   for (unsigned i = 0; i < *pceltFetched; i++) {
      ppMonikers[i] = new CDMOMoniker(pCLSIDs[i], pszNames[i]);
      if (pszNames[i])
         CoTaskMemFree(pszNames[i]);
      if (ppMonikers[i] == NULL) {

         // error - free any already created monikers
         for (unsigned j = 0; j < i; j++)
            ppMonikers[j]->Release();
         // free any remaining name strings
         for (j = i + 1; j < *pceltFetched; j++)
            if (pszNames[j])
               CoTaskMemFree(pszNames[j]);
         *pceltFetched = 0;
         return E_OUTOFMEMORY;
      }
   }

   // all happy if we get here
   return (*pceltFetched == celt) ? S_OK : S_FALSE;
}

HRESULT CDMOEnumMoniker::Skip(ULONG celt) {
   return m_pEnum->Skip(celt);
}

HRESULT CDMOEnumMoniker::Reset(void) {
   return m_pEnum->Reset();
}

HRESULT CDMOEnumMoniker::Clone(IEnumMoniker ** ppenum) {
   return E_NOTIMPL;
}

HRESULT InstantiateDMOAsFilter(REFCLSID clsidDMO, REFIID riid, void **ppv) {
   HRESULT hr;

   IDMOWrapperFilter *pFilter;
   hr = CoCreateInstance(CLSID_DMOWrapperFilter,
                         NULL,
                         CLSCTX_INPROC_SERVER,
                         IID_IDMOWrapperFilter,
                         (void**)&pFilter);
   if (FAILED(hr))
      return hr;

   hr = pFilter->Init(clsidDMO);
   if (FAILED(hr)) {
      pFilter->Release();
      return hr;
   }

   hr = pFilter->QueryInterface(riid,ppv);
   pFilter->Release();
   if (FAILED(hr))
      return hr;

   return NOERROR;
}

//
// COM DLL stuff
//
CComClassTemplate g_ComClassTemplates[] =
{
    {
       &CLSID_DMOFilterCategory,
       CDMOFilterCategory::CreateInstance
    }
};
int g_cComClassTemplates = 1;

STDAPI DllRegisterServer(void) {
   HRESULT hr;

   // register as a COM object
   hr = CreateCLSIDRegKey(CLSID_DMOFilterCategory, "DirectShow Media Objects category enumerator");
   if (FAILED(hr))
      return hr;

   // Now register with DShow
   IFilterMapper2 *pFM;
   hr = CoCreateInstance(CLSID_FilterMapper2,
                         NULL,
                         CLSCTX_INPROC_SERVER,
                         IID_IFilterMapper2,
                         (void**)&pFM);
   if (FAILED(hr))
      return hr;
   hr = pFM->CreateCategory(CLSID_DMOFilterCategory,
                            MERIT_NORMAL,
                            L"DirectShow Media Objects");

   // Create some DMO category names
   HKEY hMainKey;
   CAutoHKey key1(HKEY_LOCAL_MACHINE, DMO_REGISTRY_PATH, &hMainKey);
   if (hMainKey == NULL)
      return E_FAIL;
   
   TCHAR szGuid[80];
   TCHAR *szName;
   
   szName = TEXT("audio decoders");
   DMOGuidToStr(szGuid, DMOCATEGORY_AUDIO_DECODER);
   RegSetValue(hMainKey, szGuid, REG_SZ, szName, _tcslen(szName));
   szName = TEXT("audio encoders");
   DMOGuidToStr(szGuid, DMOCATEGORY_AUDIO_ENCODER);
   RegSetValue(hMainKey, szGuid, REG_SZ, szName, _tcslen(szName));
   szName = TEXT("video decoders");
   DMOGuidToStr(szGuid, DMOCATEGORY_VIDEO_DECODER);
   RegSetValue(hMainKey, szGuid, REG_SZ, szName, _tcslen(szName));
   szName = TEXT("video encoders");
   DMOGuidToStr(szGuid, DMOCATEGORY_VIDEO_ENCODER);
   RegSetValue(hMainKey, szGuid, REG_SZ, szName, _tcslen(szName));
   szName = TEXT("audio effects");
   DMOGuidToStr(szGuid, DMOCATEGORY_AUDIO_EFFECT);
   RegSetValue(hMainKey, szGuid, REG_SZ, szName, _tcslen(szName));
   szName = TEXT("video effects");
   DMOGuidToStr(szGuid, DMOCATEGORY_VIDEO_EFFECT);
   RegSetValue(hMainKey, szGuid, REG_SZ, szName, _tcslen(szName));

   pFM->Release();
   return hr;
}

STDAPI DllUnregisterServer(void) {
   return S_OK; // BUGBUG - unregister !
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\dshowreg\moniker.cpp ===
#include "dmodshow.h"
#include "moniker.h"
#include "dmoutils.h"

HRESULT InstantiateDMOAsFilter(REFCLSID clsidDMO, REFIID riid, void **ppv);

CDMOMoniker::CDMOMoniker(REFCLSID clsid, WCHAR szName[80]) {
   if (szName)
      wcscpy(m_szName, szName);
   else
      wcscpy(m_szName, L"");
   m_clsid = clsid;
   m_cRef = 1;
}
           
// IUnknown
HRESULT CDMOMoniker::QueryInterface(REFIID riid, void **ppv) {
   if (riid == IID_IUnknown)
      *ppv = (IUnknown*)(IMoniker*)this;
   else if (riid == IID_IPersist)
      *ppv = (IPersist*)this;
   else if (riid == IID_IPersistStream)
      *ppv = (IPersist*)this;
   else if (riid == IID_IMoniker)
      *ppv = (IMoniker*)this;
   else if (riid == IID_IPropertyBag)
      *ppv = (IPropertyBag*)this;
   else
      return E_NOINTERFACE;
   AddRef();
   return NOERROR;
}
ULONG CDMOMoniker::AddRef() {
   return InterlockedIncrement((long*)&m_cRef);
}
ULONG CDMOMoniker::Release() {
   long l = InterlockedDecrement((long*)&m_cRef);
   if (l == 0) {
      delete this;
   }
   return l;
}

// IPersist
HRESULT CDMOMoniker::GetClassID(CLSID *pClassID) {
   // bugbug: I don't think this what they want
   *pClassID = m_clsid;
   return NOERROR;
}

// IPersistStream
HRESULT CDMOMoniker::IsDirty() {
   return S_FALSE; // bugbug
}
HRESULT CDMOMoniker::Load(IStream *pStm) {
   return E_NOTIMPL;
}
HRESULT CDMOMoniker::Save(IStream *pStm, BOOL fClearDirty) {
   return E_NOTIMPL;
}
HRESULT CDMOMoniker::GetSizeMax(ULARGE_INTEGER *pcbSize) {
   return E_NOTIMPL;
}

// IMoniker
HRESULT CDMOMoniker::BindToObject(IBindCtx *pbc, IMoniker *pmkToLeft, REFIID riid, void **ppv) {
   return InstantiateDMOAsFilter(m_clsid, riid, ppv);
}
HRESULT CDMOMoniker::BindToStorage(IBindCtx *pbc, IMoniker *pmkToLeft, REFIID riid, void **ppv) {
   if (riid == IID_IPropertyBag)
      return QueryInterface(riid, ppv);
   else
      return InstantiateDMOAsFilter(m_clsid, riid, ppv);
}
HRESULT CDMOMoniker::Reduce(IBindCtx *pbc, DWORD dwReduceHowFar, IMoniker **ppmkToLeft, IMoniker **ppmkReduced) {
   return E_NOTIMPL;
}
HRESULT CDMOMoniker::ComposeWith(IMoniker *pmkRight, BOOL bOnlyIfNotGeneric, IMoniker **ppmkComposite) {
   return E_NOTIMPL;
}
HRESULT CDMOMoniker::Enum(BOOL fForward, IEnumMoniker **ppenumMoniker) {
   return E_NOTIMPL;
}
HRESULT CDMOMoniker::IsEqual(IMoniker *pmkOtherMoniker)  {
   return S_FALSE;
}
HRESULT CDMOMoniker::Hash(DWORD *pdwHash) {
   return E_NOTIMPL;
}
HRESULT CDMOMoniker::IsRunning(IBindCtx *pbc, IMoniker *pmkToLeft, IMoniker *pmkNewlyRunning) {
   return E_NOTIMPL;
}
HRESULT CDMOMoniker::GetTimeOfLastChange(IBindCtx *pbc, IMoniker *pmkToLeft, FILETIME *pFileTime) {
   return E_NOTIMPL;
}
HRESULT CDMOMoniker::Inverse(IMoniker **ppmk) {
   return E_NOTIMPL;
}
HRESULT CDMOMoniker::CommonPrefixWith(IMoniker *pmkOther, IMoniker **ppmkPrefix) {
   return E_NOTIMPL;
}
HRESULT CDMOMoniker::RelativePathTo(IMoniker *pmkOther, IMoniker **ppmkRelPath) {
   return E_NOTIMPL;
}
HRESULT CDMOMoniker::GetDisplayName(IBindCtx *pbc, IMoniker *pmkToLeft, LPOLESTR *ppszDisplayName) {
   WCHAR *szName = (WCHAR*)CoTaskMemAlloc((80 + 6) * sizeof(WCHAR));
   *ppszDisplayName = szName;
   if (!szName)
      return E_OUTOFMEMORY;
   wcscpy(szName, m_szName);
   wcscat(szName, L" (...)");
   return NOERROR;
}
HRESULT CDMOMoniker::ParseDisplayName(IBindCtx *pbc, IMoniker *pmkToLeft, LPOLESTR psxDisplayName, ULONG *pchEaten, IMoniker **ppmkOut) {
   return E_NOTIMPL;
}
HRESULT CDMOMoniker::IsSystemMoniker(DWORD *pdwMksys) {
   return S_FALSE;
}

// IPropertyBag
HRESULT CDMOMoniker::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog* pErrorLog) {
   if (!lstrcmpW(pszPropName, L"FriendlyName")) {
      //pVar->bstrVal = SysAllocString(m_szName);
      pVar->bstrVal = SysAllocStringLen(NULL, 80 + 6);
      wcscpy(pVar->bstrVal, m_szName);
      wcscat(pVar->bstrVal, L" (DMO)");
      return NOERROR;
   }
   else
      return E_FAIL;
}
HRESULT CDMOMoniker::Write(LPCOLESTR pszPropName, VARIANT *pVar) {
   return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\dshowreg\moniker.h ===
#ifndef __MONIKER_H__
#define __MONIKER_H__

class CDMOMoniker : public IMoniker, public IPropertyBag {
public:
   CDMOMoniker(REFCLSID clsid, WCHAR szName[80]);
   // IUnknown
   STDMETHODIMP QueryInterface(REFIID iid, void **ppv);
   STDMETHODIMP_(ULONG) AddRef();
   STDMETHODIMP_(ULONG) Release();
   // IPersist
   STDMETHODIMP GetClassID(CLSID *pClassID);
   // IPersistStream
   STDMETHODIMP IsDirty();
   STDMETHODIMP Load(IStream *pStm);
   STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
   STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);
   // IMoniker
   STDMETHODIMP BindToObject(IBindCtx *pbc, IMoniker *pmkToLeft, REFIID riid, void **ppv);
   STDMETHODIMP BindToStorage(IBindCtx *pbc, IMoniker *pmkToLeft, REFIID riid, void **ppv);
   STDMETHODIMP Reduce(IBindCtx *pbc, DWORD dwReduceHowFar, IMoniker **ppmkToLeft, IMoniker **ppmkReduced);
   STDMETHODIMP ComposeWith(IMoniker *pmkRight, BOOL bOnlyIfNotGeneric, IMoniker **ppmkComposite);
   STDMETHODIMP Enum(BOOL fForward, IEnumMoniker **ppenumMoniker);
   STDMETHODIMP IsEqual(IMoniker *pmkOtherMoniker);
   STDMETHODIMP Hash(DWORD *pdwHash);
   STDMETHODIMP IsRunning(IBindCtx *pbc, IMoniker *pmkToLeft, IMoniker *pmkNewlyRunning);
   STDMETHODIMP GetTimeOfLastChange(IBindCtx *pbc, IMoniker *pmkToLeft, FILETIME *pFileTime);
   STDMETHODIMP Inverse(IMoniker **ppmk);
   STDMETHODIMP CommonPrefixWith(IMoniker *pmkOther, IMoniker **ppmkPrefix);
   STDMETHODIMP RelativePathTo(IMoniker *pmkOther, IMoniker **ppmkRelPath);
   STDMETHODIMP GetDisplayName(IBindCtx *pbc, IMoniker *pmkToLeft, LPOLESTR *ppszDisplayName);
   STDMETHODIMP ParseDisplayName(IBindCtx *pbc, IMoniker *pmkToLeft, LPOLESTR psxDisplayName, ULONG *pchEaten, IMoniker **ppmkOut);
   STDMETHODIMP IsSystemMoniker(DWORD *pdwMksys);
   // IPropertyBag
   STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog* pErrorLog);
   STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar);
private:
   ULONG m_cRef;
   CLSID m_clsid;
   WCHAR m_szName[80];
};

#endif //__MONIKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\dvenc\encode.h ===
// flags for in encoder capability
#define AM_DVENC_Full		0x00000001
#define AM_DVENC_Half       0x00000002
#define AM_DVENC_Quarter    0x00000004
#define AM_DVENC_DC	        0x00000008

#define AM_DVENC_NTSC		0x00000010	    //encoder can output NTSC DV stream
#define AM_DVENC_PAL		0x00000020	    //encoder can output PAL DV stream

#define AM_DVENC_YUY2		0x00000040	    //encoder can take any YUY2 video as input
#define AM_DVENC_UYVY	    0x00000080	    //encoder can take any UYVY video as input
#define AM_DVENC_RGB24		0x00000100	    //encoder can take any RGB24 video as input
#define AM_DVENC_RGB565		0x00000200	    //encoder can take any RGB565 video as input
#define AM_DVENC_RGB555		0x00000400	    //encoder can take any RGB555 video as input
#define AM_DVENC_RGB8		0x00000800	    //encoder can take any RGB8 video as input
#define AM_DVENC_Y41P		0x00001000	    //encoder can take any y41p video as input


#define AM_DVENC_DVSD		0x00002000	    //encoder can output dvsd
#define AM_DVENC_DVHD		0x00004000	    //encoder can output dvhd
#define AM_DVENC_DVSL		0x00008000	    //encoder can output dvsl


#define AM_DVENC_DV			0x00010000
#define AM_DVENC_DVCPRO		0x00020000

#define AM_DVENC_AnyWidHei	0x00040000	    //encoder can take any width and height input
#define AM_DVENC_MMX		0x01000000				

				
typedef unsigned long DWORD;

int  InitMem4Encoder(char **ppMem,DWORD dwEncReq);

void TermMem4Encoder(char *pMem);

DWORD GetEncoderCapabilities(  );


//extern "C" int	__fastcall DvEncodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem );

extern "C" int	__stdcall DvEncodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem );
//extern "C" int	__cdecl DvEncodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\guidlib\dmoguids.c ===
#include <initguid.h>
#include "dmoreg.h"
#include "dmodshow.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\dvenc\dvenc.cpp ===
#include <dmocom.h>
#define DMO_NOATL // the base class needs this to work w/o ATL
#include <dmobase.h>
#include "encode.h"
#include <amvideo.h>
#include "resource.h"
#include "strmif.h" // DVINFO


#include "initguid.h"
DEFINE_GUID(CLSID_DVEncDMO, 0xdf2a27da,0x3cbc,0x4c2c,0xa8,0x1f,0x99,0x2c,0x6f,0x09,0x6f,0xa6);

#ifndef SIZEOF_ARRAY
    #define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))
#endif // !defined(SIZEOF_ARRAY)

//
// Instead of letting the base class handle mediatype and size info
// negotiation, this DMO overrides the corresponding IMediaObject methods and
// does everything itself.  Therefore most values in the following stream
// descriptors are unused.
//
INPUTSTREAMDESCRIPTOR InputStreams[] =
{
    {
        0, // # of input types - unused, we do mediatypes ourselves
        NULL, // input types - unused, we do mediatypes ourselves
        1, // minimum buffer size - unused since we override SizeInfo
        FALSE, // "holds buffers" - we don't
        0  // lookahead - unused since we override the SizeInfo methods
    }
};

OUTPUTSTREAMDESCRIPTOR OutputStreams[] =
{
    {
        0, // # of output types  - unused, we do mediatypes ourselves
        NULL, // output types - unused, we do mediatypes ourselves
        0, // minimum buffer size - unused since we override SizeInfo
    }
};

class CDVEnc : public CComBase,
            public CGenericDMO
{
public:
   DECLARE_IUNKNOWN;
   STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
   static CComBase *CreateInstance(IUnknown *pUnk, HRESULT *phr);
   CDVEnc(IUnknown *pUnk, HRESULT *phr);
   ~CDVEnc();
   
   // override type methods because we have complicated type requirements
   STDMETHODIMP SetInputType(ULONG ulInputStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags);
   STDMETHODIMP SetOutputType(ULONG ulOutputStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags);
   STDMETHODIMP GetInputType(ULONG ulInputStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
   STDMETHODIMP GetOutputType(ULONG ulOutputStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
   STDMETHODIMP GetInputCurrentType(ULONG ulInputStreamIndex, DMO_MEDIA_TYPE *pmt);
   STDMETHODIMP GetOutputCurrentType(ULONG ulOutputStreamIndex, DMO_MEDIA_TYPE *pmt);

   // override size info methods because size depends on type
   STDMETHODIMP GetInputSizeInfo(ULONG ulInputStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment);
   STDMETHODIMP GetOutputSizeInfo(ULONG ulOutputStreamIndex, ULONG *pulSize, ULONG *pulAlignment);

   // entry point called by the base class
   HRESULT DoProcess(INPUTBUFFER*, OUTPUTBUFFER*);

   // internal methods
   HRESULT MapInputTypeToOutputType(const DMO_MEDIA_TYPE *pmtIn, DMO_MEDIA_TYPE *pmtOut);
   HRESULT PrepareForStreaming();
   HRESULT ProcessOneFrame(BYTE* pIn, BYTE* pOut);
private:
   DWORD m_EncCap;
   long		m_lPicWidth;
   long		m_lPicHeight;
   BOOL m_bInputTypeSet;
   BOOL m_bOutputTypeSet;
   DMO_MEDIA_TYPE m_InputType;
   DMO_MEDIA_TYPE m_OutputType;
   int m_iVideoFormat;
   char m_fConvert;
   BYTE m_fDVInfo;
   int m_iDVFormat;
   DVINFO		m_sDVInfo;
   DWORD		    m_EncReq;	    //what users want it to do
   DWORD m_InputReq;
   DWORD m_OutputReq;
   DWORD m_tmpOutputReq;
   char *		    m_pMem4Convert;
   char		*m_pMem4Enc;
   int m_iResolution;
};

CComBase* CDVEnc::CreateInstance(IUnknown *pUnk, HRESULT *phr) {
   return new CDVEnc(pUnk, phr);
}

// link to vfw32.lib to get this function....
extern "C" void FAR PASCAL StretchDIB(
	LPBITMAPINFOHEADER biDst,   //	BITMAPINFO of destination
	LPVOID	lpDst,		    //	The destination bits
	int	DstX,		    //	Destination origin - x coordinate
	int	DstY,		    //	Destination origin - y coordinate
	int	DstXE,		    //	x extent of the BLT
	int	DstYE,		    //	y extent of the BLT
	LPBITMAPINFOHEADER biSrc,   //	BITMAPINFO of source
	LPVOID	lpSrc,		    //	The source bits
	int	SrcX,		    //	Source origin - x coordinate
	int	SrcY,		    //	Source origin - y coordinate
	int	SrcXE,		    //	x extent of the BLT
	int	SrcYE 	    //	y extent of the BLT
);

DWORD GetEncoderCapabilities()
{
    return AM_DVENC_Full	|
	        AM_DVENC_DV		| 
	        AM_DVENC_DVCPRO	|
	        AM_DVENC_DVSD	|
	        AM_DVENC_NTSC	|
	        AM_DVENC_PAL	   |
	        AM_DVENC_MMX	   |
	        AM_DVENC_RGB24  |
           AM_DVENC_RGB565 |
           AM_DVENC_RGB555 |
           AM_DVENC_RGB8;
}

/***********************************************************************\
* IsMMXCPU
*
* Function to check if the current processor is an MMX processor.
*
\***********************************************************************/
BOOL IsMMXCPU() {
#ifdef _X86_
    //
    // If this is an Intel platform we need to make sure that we
    // are running on a machine that supports MMX instructions
    //
    __try {

    __asm _emit 0fh;
    __asm _emit 77h;

    return TRUE;

    }
     __except(EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }
#else
    return FALSE;
#endif
}

CDVEnc::CDVEnc(IUnknown *pUnk, HRESULT *phr)
  : CComBase(pUnk, phr),
    m_EncCap(GetEncoderCapabilities()),
    m_bInputTypeSet(FALSE),
    m_bOutputTypeSet(FALSE),
    m_iVideoFormat(IDC_NTSC),
    m_fConvert(0),
    m_iDVFormat(IDC_dvsd),
    m_fDVInfo(FALSE),
    m_pMem4Convert(NULL),
    m_pMem4Enc(NULL),
    m_iResolution(IDC_720x480)
{
   //set DVInfo to 0xff
   memset(&m_sDVInfo, 0xff, sizeof(DVINFO) );
   
   HRESULT hr;

   hr = CreateInputStreams(InputStreams, SIZEOF_ARRAY(InputStreams));
   if (FAILED(hr)) {
      *phr = hr;
      return;
   }

   hr = CreateOutputStreams(OutputStreams, SIZEOF_ARRAY(OutputStreams));
   if (FAILED(hr)) {
      *phr = hr;
      return;
   }
}

CDVEnc::~CDVEnc() {
   if (m_bInputTypeSet)
      MoFreeMediaType(&m_InputType);
   if (m_bOutputTypeSet)
      MoFreeMediaType(&m_OutputType);
   if (m_pMem4Convert)
      delete[] m_pMem4Convert;
   if (m_pMem4Enc)
      delete[] m_pMem4Enc;
}

HRESULT CDVEnc::NDQueryInterface(REFIID riid, void **ppv) {
   if (riid == IID_IMediaObject)
      return GetInterface((IMediaObject*)this, ppv);
   else
      return CComBase::NDQueryInterface(riid, ppv);
}

//
// Mediatype handling methods
//

// Check if we like this type at all (whether for input or for output)
BOOL TypeValid(const DMO_MEDIA_TYPE *pmt) {
   if (pmt->majortype != MEDIATYPE_Video)
      return FALSE;

   // check format block
   if ((pmt->formattype != FORMAT_VideoInfo) ||
       (pmt->cbFormat < SIZE_VIDEOHEADER) ||
       (pmt->pbFormat == NULL))
      return FALSE;

   return TRUE;
}

HRESULT CDVEnc::MapInputTypeToOutputType(const DMO_MEDIA_TYPE *pmtIn, DMO_MEDIA_TYPE *pmtOut) {
   //get input format
   VIDEOINFO *InVidInfo = (VIDEOINFO *)(pmtIn->pbFormat);

   //allocate memory for output format
   int iSize;

   if(m_fDVInfo==TRUE)
      iSize = SIZE_VIDEOHEADER + sizeof(DVINFO);
   else
      iSize = SIZE_VIDEOHEADER;

   MoInitMediaType(pmtOut, iSize);

   // copy input format block
   memcpy(pmtOut->pbFormat, pmtIn->pbFormat, min(pmtOut->cbFormat, pmtIn->cbFormat));

   VIDEOINFO* pVideoInfo = (VIDEOINFO*)pmtOut->pbFormat;
   if (pVideoInfo == NULL)
       return E_OUTOFMEMORY;
   

   LPBITMAPINFOHEADER lpbi = HEADER(pVideoInfo);

   if(m_fDVInfo==TRUE)
      iSize = sizeof(BITMAPINFOHEADER)+sizeof(DVINFO);
   else
      iSize = sizeof(BITMAPINFOHEADER);

   lpbi->biSize          = (DWORD) iSize;

   lpbi->biWidth         = 720;	

   if( m_iVideoFormat == IDC_NTSC )
      lpbi->biHeight        = 480;	
   else
      lpbi->biHeight        = 576;

   lpbi->biPlanes        = 1;
   lpbi->biBitCount      = 24;			//dvdecoder, avi mux or dv mux write do not matter, 24 for strechDIB func
   lpbi->biXPelsPerMeter = 0;
   lpbi->biYPelsPerMeter = 0;
   lpbi->biCompression   = BI_RGB;		//dvdecoder,avi mux or dv mux write do not care, BI_RGB only for StrechDIB func
// how to build an explicit FOURCC
#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                 (((DWORD)(ch4) & 0xFF00) << 8) |    \
                 (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                 (((DWORD)(ch4) & 0xFF000000) >> 24))

   //lpbi->biCompression     =FCC('dvsd');       //7/19/20, Ivan maltz cares this in his application, we will set this to BI_RGB for stretchDIB and switch back.
   lpbi->biSizeImage     = DIBSIZE(*lpbi);
   
   if(m_fDVInfo==TRUE)
   {
      unsigned char *pc   =(unsigned char *)( lpbi+ sizeof(BITMAPINFOHEADER));
      unsigned char *pDV  =(unsigned char *)&m_sDVInfo;
      
      //copy DVINFO
      memcpy(pc,pDV,sizeof(DVINFO) ); 
   }
   
   //pVideoInfo->bmiHeader.biClrUsed = STDPALCOLOURS;
   //pVideoInfo->bmiHeader.biClrImportant = STDPALCOLOURS;
     
   pVideoInfo->rcSource.top	= 0;
   pVideoInfo->rcSource.left	= 0;
   pVideoInfo->rcSource.right	= lpbi->biWidth;			
   pVideoInfo->rcSource.bottom = lpbi->biHeight;			
   pVideoInfo->AvgTimePerFrame = InVidInfo->AvgTimePerFrame;		//copy input's avgTimePerFrame
   pVideoInfo->rcTarget	= pVideoInfo->rcSource;

   //
   // The "bit" rate is image size in bytes times 8 (to convert to bits)
   // divided by the AvgTimePerFrame.  This result is in bits per 100 nSec,
   // so we multiply by 10000000 to convert to bits per second, this multiply
   // is combined with "times" 8 above so the calculations becomes:
   //
   // BitRate = (biSizeImage * 80000000) / AvgTimePerFrame
   //
   LARGE_INTEGER li;
   li.QuadPart = pVideoInfo->AvgTimePerFrame;
   pVideoInfo->dwBitRate = MulDiv(lpbi->biSizeImage, 80000000, li.LowPart);
   pVideoInfo->dwBitErrorRate = 0L;

   pmtOut->majortype = MEDIATYPE_Video;
   pmtOut->formattype = FORMAT_VideoInfo;

   // m_tmpOutputReq is later picked up by SetOutputType() unless
   // SetOutputType() was called with the TEST_ONLY flag.
   if(m_iDVFormat == IDC_dvsd) {
      pmtOut->subtype = MEDIASUBTYPE_dvsd;
      m_tmpOutputReq = AM_DVENC_DVSD;
   }
   else 	if(m_iDVFormat == IDC_dvhd) {
      pmtOut->subtype = MEDIASUBTYPE_dvhd;
      m_tmpOutputReq |= AM_DVENC_DVHD;
   }
   else	if(m_iDVFormat == IDC_dvsl) {
      pmtOut->subtype = MEDIASUBTYPE_dvsl;
      m_tmpOutputReq |= AM_DVENC_DVSL;
   }
   else 
     assert(!"bad m_iDVFormat");
   
   //
   // This block assumes that lpbi has been set up to point to a valid
   // bitmapinfoheader and that cmt has been copied into *pmt.
   // This is taken care of in the switch statement above.  This should
   // kept in mind when new formats are added.
   //
   //150*80*10 or *12
   pmtOut->lSampleSize = HEADER(pVideoInfo)->biSizeImage;

   return S_OK;
}

HRESULT CDVEnc::GetInputType(ULONG ulInputStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
   if (ulInputStreamIndex > 0) // we have only one input stream
      return DMO_E_INVALIDSTREAMINDEX;

   // This DMO does not advertise any input types because it supports lots
   // of different video subtypes, and it would be pointless to list all of them.
   return DMO_E_NO_MORE_ITEMS;
}

HRESULT CDVEnc::GetOutputType(ULONG ulOutputStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
   if (ulOutputStreamIndex > 0) // we have only one output stream
      return DMO_E_INVALIDSTREAMINDEX;
   
   // Will not negotiate any output types until the input type has been set
   if (!m_bInputTypeSet) 
      return DMO_E_TYPE_NOT_SET;

   // Although in principle we support several output subtypes, only one of
   // them can be used with any particular input type.
   if (ulTypeIndex > 0)
      return DMO_E_NO_MORE_ITEMS;

   return MapInputTypeToOutputType(&m_InputType, pmt);
}

HRESULT CDVEnc::SetInputType(ULONG ulInputStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
   if (ulInputStreamIndex > 0) // we have only one input stream
      return DMO_E_INVALIDSTREAMINDEX;

   if (!TypeValid(pmt))
      return DMO_E_TYPE_NOT_ACCEPTED;

   DWORD dwTmp=0;
   if (pmt->subtype == MEDIASUBTYPE_UYVY)
      dwTmp = AM_DVENC_UYVY;
   else if (pmt->subtype == MEDIASUBTYPE_YUY2)
      dwTmp = AM_DVENC_YUY2;
   else if (pmt->subtype == MEDIASUBTYPE_RGB565)
      dwTmp = AM_DVENC_RGB565;
   else if (pmt->subtype == MEDIASUBTYPE_RGB555)
      dwTmp = AM_DVENC_RGB565;
   else if (pmt->subtype == MEDIASUBTYPE_RGB24)
      dwTmp = AM_DVENC_RGB24;
   else if (pmt->subtype == MEDIASUBTYPE_Y41P)
      dwTmp = AM_DVENC_Y41P;
   else 
      return DMO_E_TYPE_NOT_ACCEPTED;   //only converting RGB now.
         
   if(!(m_EncCap & dwTmp))
      return DMO_E_TYPE_NOT_ACCEPTED;   //only converting RGB now.
 
   //check image size
   VIDEOINFO *videoInfo = (VIDEOINFO *)pmt->pbFormat;
   
   long lPicWidth = videoInfo->bmiHeader.biWidth;
   long lPicHeight = videoInfo->bmiHeader.biHeight;
   char fConvert;
 
   if(((lPicWidth == 720) && (lPicHeight == 480) && (m_iVideoFormat==IDC_NTSC)) ||	
      ((lPicWidth == 720) && (lPicHeight == 576) && (m_iVideoFormat==IDC_PAL))  ||	
      (m_EncCap & AM_DVENC_AnyWidHei)) {
        fConvert =0;
   }
   else
   {
      if (pmt->subtype != MEDIASUBTYPE_RGB24 )
         return DMO_E_TYPE_NOT_ACCEPTED; //only converting RGB now.
      fConvert =1;
   }
 
   if (dwFlags & DMO_SET_TYPEF_TEST_ONLY)
      return NOERROR;

   m_InputReq = dwTmp;

   m_lPicWidth = lPicWidth;
   m_lPicHeight = lPicHeight;
   m_fConvert = fConvert;
   
   if (m_bInputTypeSet) // free any previous format block
      MoFreeMediaType(&m_InputType);
   MoCopyMediaType(&m_InputType, pmt);
   m_bInputTypeSet = TRUE;

   return NOERROR;
}

HRESULT CDVEnc::SetOutputType(ULONG ulOutputStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
   DMO_MEDIA_TYPE mtSupported;
   
   // Synthesize a valid output format based on the currently set input type.
   // This will verify that the input type is set and check the stream index.
   HRESULT hr = GetOutputType(ulOutputStreamIndex, 0, &mtSupported);
   if (FAILED(hr))
      return hr;
   
   //bugbug - is memcmp a valid way to compare VideoInfo headers ?
   if ((mtSupported.majortype  != pmt->majortype) ||
       (mtSupported.subtype    != pmt->subtype) ||
       (mtSupported.formattype != pmt->formattype) ||
       (mtSupported.cbFormat   > pmt->cbFormat) ||
       memcmp(mtSupported.pbFormat, pmt->pbFormat, SIZE_VIDEOHEADER))
   { 
      MoFreeMediaType(&mtSupported);
      return DMO_E_TYPE_NOT_ACCEPTED;
   }
   MoFreeMediaType(&mtSupported);

   if (dwFlags & DMO_SET_TYPEF_TEST_ONLY)
      return NOERROR;

   // remember this type
   if (m_bOutputTypeSet) // free any previous format block
      MoFreeMediaType(&m_OutputType);
   MoCopyMediaType(&m_OutputType, pmt);
   m_bOutputTypeSet = TRUE;

   // pick up the value set by MapInputTypeToOutputType()
   m_OutputReq = m_tmpOutputReq;

   // Now that both types have been set, prepare for streaming
   hr = PrepareForStreaming();
   if (FAILED(hr))
      return hr;

   return NOERROR;
}

HRESULT CDVEnc::GetInputCurrentType(ULONG ulInputStreamIndex, DMO_MEDIA_TYPE *pmt) {
   if (ulInputStreamIndex > 0) // we have only one input stream
      return DMO_E_INVALIDSTREAMINDEX;
   if (!m_bInputTypeSet)
      return DMO_E_TYPE_NOT_SET;
   return MoCopyMediaType(pmt, &m_InputType);
}

HRESULT CDVEnc::GetOutputCurrentType(ULONG ulOutputStreamIndex, DMO_MEDIA_TYPE *pmt) {
   if (ulOutputStreamIndex > 0) // we have only one output stream
      return DMO_E_INVALIDSTREAMINDEX;
   if (!m_bOutputTypeSet)
      return DMO_E_TYPE_NOT_SET;
   return MoCopyMediaType(pmt, &m_OutputType);
}

HRESULT CDVEnc::GetInputSizeInfo(ULONG ulInputStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
   if (ulInputStreamIndex > 0) // we have only one input stream
      return DMO_E_INVALIDSTREAMINDEX;
   if (!m_bInputTypeSet) // cannot talk about size without knowing the type
      return DMO_E_TYPE_NOT_SET;

   BITMAPINFOHEADER* bmi = &(((VIDEOINFO *)(m_InputType.pbFormat))->bmiHeader);
   *pulSize = bmi->biWidth * bmi->biHeight * 3; // use bmi->biBitCount/8 ?

   *pulAlignment = 1; // no alignment requirements
   *pcbMaxLookahead = 0; // this is not used because we don't hold buffers
   return NOERROR;
}

HRESULT CDVEnc::GetOutputSizeInfo(ULONG ulOutputStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {
   if (ulOutputStreamIndex > 0) // we have only one output stream
      return DMO_E_INVALIDSTREAMINDEX;
   if (!m_bOutputTypeSet) // cannot talk about size without knowing the type
      return DMO_E_TYPE_NOT_SET;
   
   if( m_iVideoFormat == IDC_NTSC )
      *pulSize = 150*80*10;
   else
      *pulSize = 150*80*12;
   
   *pulAlignment = 1; // no alignment requirements
   return NOERROR;
}

HRESULT CDVEnc::PrepareForStreaming() {
   // Initialize m_EncReq
   m_EncReq = m_InputReq | m_OutputReq | AM_DVENC_DV;

    //NTSC or PAL 		
   if(m_iVideoFormat == IDC_NTSC )
      m_EncReq |= (AM_DVENC_NTSC);	
   else
      m_EncReq |= AM_DVENC_PAL;	

   // resolution
   if(m_iResolution ==  IDC_720x480 )
      m_EncReq |= AM_DVENC_Full;
   else if(m_iResolution ==  IDC_360x240 )
      m_EncReq |= AM_DVENC_Half;
   else if(m_iResolution ==  IDC_180x120 )
      m_EncReq |= AM_DVENC_Quarter;
   else if(m_iResolution ==  IDC_88x60 )
      m_EncReq |= AM_DVENC_DC;

   // MMX
   if (IsMMXCPU() && (m_EncCap & AM_DVENC_MMX))
     m_EncReq |= AM_DVENC_MMX;
   
   // free any previously allocated memory (in case this happens > once)
   if (m_pMem4Convert)
      delete[] m_pMem4Convert;
   if (m_pMem4Enc)
      delete[] m_pMem4Enc;

   // allocate buffers
   m_pMem4Enc = new char[720*576*2];
   if (!m_pMem4Enc)
      return E_OUTOFMEMORY;

   if (m_fConvert) {
      m_pMem4Convert =  new char [720*576*3];
      if (!m_pMem4Convert) {
         delete[] m_pMem4Enc;
         return E_OUTOFMEMORY;
      }
   }
   
   return NOERROR;
}

/*
//
// DoProcess performs various buffer size checks / flag manipulations and
// calls ProcessOneFrame() to do any DV-specific processing.
//
// This code would be perfect for use in a base class for DMOs that work with
// fixed size frames.  Such DMOs could then implement ProcessOneFrame only.
//
HRESULT CDVEnc::DoProcess(INPUTBUFFER *pInput, OUTPUTBUFFER *pOutput) {
   HRESULT hr;
   //
   // Check buffer size.  GetSizeInfo() will also make sure the types are set
   //
   ULONG ulInputSize, ulOutputSize, ulDummy;
   hr = GetInputSizeInfo(0, &ulInputSize, &ulDummy, &ulDummy);
   if (FAILED(hr))
      return hr;
   hr = GetOutputSizeInfo(0, &ulOutputSize, &ulDummy);
   if (FAILED(hr))
      return hr;

   pOutput->dwFlags = 0; // initialize this

   // How many input frames were we given ?
   ULONG cInFrames = pInput->cbSize / ulInputSize;
   // How many output frames did they give us room for ?
   ULONG cOutFrames = pOutput->cbSize / ulOutputSize;
   // The smaller of the above numbers is how many we will try to process
   ULONG cFramesToProcess = (cInFrames < cOutFrames) ? cInFrames : cOutFrames;
   
   if (cOutFrames < cInFrames) // could have produced more - set incomplete
      pOutput->dwFlags != DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;

   if (cFramesToProcess == 0) { // alright, which buffer is too small ?
      if (pOutput->cbSize < ulOutputSize) {
         // We explicitly specified a minimum output buffer size in
         // GetOutputSizeInfo(), so it is an error to supply less.
         return E_INVALIDARG;
      }
      if (pInput->cbSize < ulInputSize) {
         // Not enough input to do any processing.  This is technically an
         // error, but we will be nice and let them try again.
         pInput->cbUsed = 0;
         pOutput->cbUsed = 0;
         pOutput->dwFlags = 0;
         pInput->dwFlags |= INPUT_STATUSF_RESIDUAL;
         return NOERROR;
      }
      assert(!"code bug in buffer size check");
   }
   
   DWORD cActuallyProcessed;
   for (cActuallyProcessed = 0; cActuallyProcessed < cFramesToProcess; cActuallyProcessed++) {
      hr = ProcessOneFrame(pInput->pData + cActuallyProcessed * ulInputSize,
                           pOutput->pData + cActuallyProcessed * ulOutputSize);
      if (FAILED(hr))
         break;
   }
   if (cActuallyProcessed == 0) // could not process anything at all
      return hr;

   // indicate how much of each buffer we have used
   pOutput->cbUsed = cActuallyProcessed * ulOutputSize;
   pInput->cbUsed = cActuallyProcessed * ulInputSize;
   if (pInput->cbSize > pInput->cbUsed)
      pInput->dwFlags |= INPUT_STATUSF_RESIDUAL;

   // Copy any timestamps / flags
   if (pInput->dwFlags & DMO_INPUT_DATA_BUFFERF_SYNCPOINT)
      pOutput->dwFlags |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
   if (pInput->dwFlags & DMO_INPUT_DATA_BUFFERF_TIME) {
      pOutput->dwFlags |= DMO_OUTPUT_DATA_BUFFERF_TIME;
      pOutput->rtTimestamp = pInput->rtTimestamp;
   }
   if (pInput->dwFlags & DMO_INPUT_DATA_BUFFERF_TIMELENGTH) {
      pOutput->dwFlags |= DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH;
      pOutput->rtTimelength = pInput->rtTimelength;
   }

   if (cActuallyProcessed == cFramesToProcess)
      return S_OK;
   else // return partial success if we could not process all the frames
      return S_FALSE;
}
*/

HRESULT CDVEnc::DoProcess(INPUTBUFFER *pInput, OUTPUTBUFFER *pOutput) {
   HRESULT hr;
   //
   // Check buffer size.  GetSizeInfo() will also make sure the types are set
   //
   ULONG ulSize, ulDummy;
   hr = GetInputSizeInfo(0, &ulSize, &ulDummy, &ulDummy);
   if (FAILED(hr))
      return hr;
   if (pInput->cbSize < ulSize)
      return E_INVALIDARG;
   hr = GetOutputSizeInfo(0, &ulSize, &ulDummy);
   if (FAILED(hr))
      return hr;
   if (pOutput->cbSize < ulSize)
      return E_INVALIDARG;

   hr = ProcessOneFrame(pInput->pData, pOutput->pData);
   if (FAILED(hr))
      return hr;

   // indicate how much of each buffer we have used
   pOutput->cbUsed = ulSize;
   pInput->cbUsed = pInput->cbSize;

   // Copy any timestamps / flags
   pOutput->dwFlags = 0;
   if (pInput->dwFlags & DMO_INPUT_DATA_BUFFERF_SYNCPOINT)
      pOutput->dwFlags |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
   if (pInput->dwFlags & DMO_INPUT_DATA_BUFFERF_TIME) {
      pOutput->dwFlags |= DMO_OUTPUT_DATA_BUFFERF_TIME;
      pOutput->rtTimestamp = pInput->rtTimestamp;
   }
   if (pInput->dwFlags & DMO_INPUT_DATA_BUFFERF_TIMELENGTH) {
      pOutput->dwFlags |= DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH;
      pOutput->rtTimelength = pInput->rtTimelength;
   }

   return S_OK;
}


HRESULT CDVEnc::ProcessOneFrame(BYTE* pSrc, BYTE* pDst) {
   // if the source not standard 720*480 or 720*576, 
   // a convertion is nneded
   if( m_fConvert){

      // this code will stretch any RGB format, and the most popular YUV formats.
      // we stretch YUV by treating it as a 32-bit bitmap that's half as wide as the original. 
      BITMAPINFOHEADER *pbiOut = HEADER(m_OutputType.pbFormat);
      BITMAPINFOHEADER *pbiIn = HEADER(m_InputType.pbFormat);

      // normal RGB case
      DWORD dwIn = pbiIn->biCompression;
      DWORD dwOut = pbiOut->biCompression;
      pbiIn->biCompression = BI_RGB;
      pbiOut->biCompression = BI_RGB;

      StretchDIB(pbiOut, 
         m_pMem4Convert,
         0, 
         0, 
         pbiOut->biWidth, 
         pbiOut->biHeight,
         pbiIn,
         pSrc, 
         0, 
         0, 
         pbiIn->biWidth, 
         pbiIn->biHeight
      );

      //put original data back
      pbiIn->biCompression = dwIn;
      pbiOut->biCompression = dwOut;

      pSrc=(unsigned char *)m_pMem4Convert;
   }

   return DvEncodeAFrame(pSrc, pDst, m_EncReq, m_pMem4Enc);
}

//
// COM DLL stuff
//
struct CComClassTemplate g_ComClassTemplates[] = {
   {
      &CLSID_DVEncDMO,
      CDVEnc::CreateInstance
   }
};

int g_cComClassTemplates = 1;

STDAPI DllRegisterServer(void) {
   HRESULT hr;
   
   // Register as a COM class
   hr = CreateCLSIDRegKey(CLSID_DVEncDMO, "DV encoder media object");
   if (FAILED(hr))
      return hr;
   
   // Now register as a DMO
   return DMORegister(L"DV encoder", CLSID_DVEncDMO, DMOCATEGORY_VIDEO_ENCODER, 0, 0, NULL, 0, NULL);
}

STDAPI DllUnregisterServer(void) {
   // BUGBUG - implement !
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\simple\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\dvenc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by display.rc
//
#define IDS_TITLE                       2
#define IDD_DVEnc                       201
#define IDC_NTSC                        2000
#define IDC_PAL                         2001
#define IDC_RESOLUTION                  2006
#define IDC_dvsd                        2007
#define IDC_dvhd                        2008
#define IDC_dvsl                        2009
#define IDC_DVFORMAT                    2010
#define IDC_VIDEOFORMAT                 2011
#define IDC_720x480                     2012
#define IDC_360x240                     2013
#define IDC_180x12                      2014
#define IDC_180x120                     2014
#define IDC_88x60                       2015
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\sample\sample.cpp ===
#include <windows.h>
#include <mmreg.h>
#include "uuids.h"
#include "dmo.h"
#include "appstrm.h"

#include "initguid.h"
DEFINE_GUID(CLSID_Simple,0xCE13AE3C,0x097B,0x11D3,0xB3,0x0B,0x44,0x45,0x53,0x54,0x00,0x01);

HRESULT CreateAndInitializeObject(IMediaObject **ppObject) {
   WAVEFORMATEX WaveFmt = {
      WAVE_FORMAT_PCM,
      1,     // nChannels
      22050, // nSamplesPerSec
      44100, // nAvgBytesPerSec
      2,     // nBlockAlign
      16,    // wBitsPerSample
      0      // size of additional stuff at the end of this structure
   };
/* // Why did the compiler not like these GUID initializations ?
   DMO_MEDIA_TYPE mt = {MEDIATYPE_Audio,     // majortype
                       MEDIASUBTYPE_PCM,    // subtype
                       FALSE,  // bFixedSizeSamples    - ignored by media objects
                       FALSE, // bTemporalCompression  - ignored by media objects
                       0,     // lSampleSize           - ignored by media objects
                       FORMAT_WaveFormatEx, // format guid
                       NULL,  // IUnknown pointer - not used
                       sizeof (WAVEFORMATEX),
                       &WaveFmt // our WAVEFORMATEX
   };
*/
   DMO_MEDIA_TYPE mt;
   mt.majortype  = MEDIATYPE_Audio;
   mt.subtype    = MEDIASUBTYPE_PCM;
   mt.formattype = FORMAT_WaveFormatEx;
   mt.cbFormat = sizeof(WAVEFORMATEX);
   mt.pbFormat = (BYTE*)(&WaveFmt);
   mt.pUnk = NULL; // CopyMediaType will crash if we don't intialize this

   HRESULT hr = CoCreateInstance(CLSID_Simple,
                         NULL,
                         CLSCTX_INPROC,
                         IID_IMediaObject,
                         (void **) ppObject);
   if (FAILED(hr))
       return hr;
   
   hr = (*ppObject)->SetInputType(0, &mt, 0);
   if (FAILED(hr))
       return hr;

   hr = (*ppObject)->SetOutputType(0, &mt, 0);
   if (FAILED(hr))
       return hr;

   return NOERROR;
}

//
// CMyStream - streams data from one hFile to another using a CLSID_Simple media object
//
class CMyStream : public CAppStream {
public:
   CMyStream(HRESULT *phr) :
      CAppStream(phr)
   {

      m_pObject = NULL;
      m_pInBuffer = NULL;
      m_pOutBuffer = NULL;

   }
   ~CMyStream() {
      if (m_pObject)
         m_pObject->Release();
      if (m_pInBuffer)
         delete m_pInBuffer;
      if (m_pOutBuffer)
         delete m_pOutBuffer;
   }

   HRESULT Init(HANDLE hFileInput, HANDLE hFileOutput) {
      HRESULT hr;
      m_hInFile = hFileInput;
      m_hOutFile = hFileOutput;

      // some odd numbers to stress the code in CAppStream::Stream()
      m_ulInBufferSize = 65317;
      m_ulOutBufferSize = 29311;

      hr = CreateAndInitializeObject(&m_pObject);
      if (FAILED(hr))
         return hr;
      
      m_pInBuffer = new BYTE[m_ulInBufferSize];
      m_pOutBuffer = new BYTE[m_ulOutBufferSize];
      if (!(m_pInBuffer && m_pOutBuffer))
         return E_OUTOFMEMORY;

      return CAppStream::Init(m_pInBuffer, m_ulInBufferSize, m_pOutBuffer, m_ulOutBufferSize, m_pObject);
   }
   //
   // CAppStream::Stream() calls this to get data from us
   //
   HRESULT GetInputData(BYTE *pBuffer, DWORD dwBytesWanted, DWORD *pdwBytesSupplied, DWORD *pdwStatus) {
      *pdwStatus = 0;
      if (ReadFile(m_hInFile, pBuffer, dwBytesWanted, pdwBytesSupplied, NULL)) {
         // Non-zero return indicates success
         if (!*pdwBytesSupplied)
            *pdwStatus |= APPSTRM_STATUSF_END_OF_STREAM;
         return NOERROR;
      }
      else {
         *pdwBytesSupplied = 0;
         *pdwStatus |= APPSTRM_STATUSF_END_OF_STREAM;
         return E_FAIL;
      }
   }
   //
   // CAppStream::Stream() calls this to let us pick up output data.
   // We must do something with it before returning from here, since
   // the buffer will be reused as soon as we return.
   //
   HRESULT AcceptOutputData(BYTE *pBuffer, DWORD dwBytesProduced) {
      if (dwBytesProduced == 0)
         return NOERROR;
         
      DWORD dwWritten;
      if (WriteFile(m_hOutFile, pBuffer, dwBytesProduced, &dwWritten, NULL)) {
         // Non-zero return indicates success
         if (dwWritten == dwBytesProduced)
            return NOERROR;
         else
            return E_FAIL;
      }
      else
         return E_FAIL;
   }

private:
   IMediaObject *m_pObject;
   HANDLE m_hInFile;
   HANDLE m_hOutFile;
   BYTE *m_pInBuffer;
   BYTE *m_pOutBuffer;
   ULONG m_ulInBufferSize;
   ULONG m_ulOutBufferSize;
};

HRESULT StreamData(HANDLE hFileInput, HANDLE hFileOutput)
{
    HRESULT hr;

    CMyStream *pStream = new CMyStream(&hr);
    if (!pStream)
       return E_OUTOFMEMORY;
    
    if (FAILED(hr)) {
       delete pStream;
       return hr;
    }

    hr = pStream->Init(hFileInput, hFileOutput);
    if (FAILED(hr)) {
       delete pStream;
       return hr;
    }

    hr = pStream->Stream();
    
    delete pStream;
    return hr;
}



/*  Use our object */
HRESULT StreamFile(LPSTR lpszFileInput, LPSTR lpszFileOutput)
{
    HANDLE hFileInput = CreateFile(lpszFileInput,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   NULL);
    if (INVALID_HANDLE_VALUE == hFileInput) {
        return E_FAIL;
    }
    HANDLE hFileOutput = CreateFile(lpszFileOutput,
                                    GENERIC_WRITE,
                                    0,
                                    NULL,
                                    CREATE_ALWAYS,
                                    0,
                                    NULL);
    if (INVALID_HANDLE_VALUE == hFileInput) {
        CloseHandle(hFileInput);
        return E_FAIL;
    }
    
    HRESULT hr = StreamData(hFileInput, hFileOutput);
    
    CloseHandle(hFileInput);
    CloseHandle(hFileOutput);
    return hr;
}

int __cdecl main(int argc, char *argv[])
{
    CoInitialize(NULL);
    StreamFile(argv[1], argv[2]);
    CoUninitialize();
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\firtest\firtest.cpp ===
#include <dmocom.h>
#define DMO_NOATL // the base class needs this to work w/o ATL
#include <dmobase.h>

#include "initguid.h"
DEFINE_GUID(CLSID_FIRtest, 0xfb74ee25,0x4329,0x43d9,0xba,0xbe,0x48,0xe0,0xb7,0x5d,0xf8,0x56);

class CFIRtest : public CComBase,
                 public CPCMDMO
{
public:
   DECLARE_IUNKNOWN;
   STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
   static CComBase *CreateInstance(IUnknown *pUnk, HRESULT *phr);
   CFIRtest(IUnknown *pUnk, HRESULT *phr);
   
   // All of these methods are called by the base class
   HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
   void GetWindowParams(DWORD *pdwMaxLookahead, DWORD *pdwMaxLookbehind);
   BOOL CheckPCMParams(BOOL b8bit, DWORD cChannels, DWORD dwSamplesPerSec);
};

CFIRtest::CFIRtest(IUnknown *pUnk, HRESULT *phr)
  : CComBase(pUnk, phr)
{
}

// Really all we need is lookbehind of 21 and out lookahead is zero.
// To test the base class, we arbitrarily split it between the two.
// That means output will be shifted relative to input by 4 samples.
#define LOOKAHEAD 4
#define LOOKBEHIND 17

void CFIRtest::GetWindowParams(DWORD *pdwMaxLookahead, DWORD *pdwMaxLookbehind) {
   *pdwMaxLookahead  = LOOKAHEAD;
   *pdwMaxLookbehind = LOOKBEHIND;
}

BOOL CFIRtest::CheckPCMParams(BOOL b8bit, DWORD cChannels, DWORD dwSamplesPerSec) {
   if (dwSamplesPerSec != 44100)
      return FALSE; // my FIR coefficients assume 44100, sorry
   if (b8bit)
      return FALSE; // I don't want to deal with 8 bit values
   return TRUE;
}

// This is a 4dB 1/2 octave peak at 12.5k and a 8dB 1/2 octave trough at 15k.
signed short coefficients[LOOKBEHIND + 1 + LOOKAHEAD] = {
   -1,0,3,0,-7,-1,20,6,-58,1,157,-74,-353,368,601,-1097,-565,
   2369,
   -444,-3122,2640,15967
};
// Point to the logically zeroth coefficient
signed short *c = &(coefficients[LOOKBEHIND]);

//
// We specified a lookahead of 4 and a lookbehind of 17.  That means we are
// allowed to dereference samples in the input buffer up to 4 positions ahead
// of the current sample and up to 17 positions back from the current sample,
// even when at the boundary of the input buffer.  The base class made sure
// that the data there is valid for us.
//
HRESULT CFIRtest::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut) {
   DWORD cSample, cChannel;
   signed short* in = (signed short*)pIn;
   signed short* out = (signed short*)pOut;
   for (cSample = 0; cSample < cSamples; cSample++) {
      for (cChannel = 0; cChannel < m_cChannels; cChannel++) {
         double Accum = 0.0;
         for (int i = -LOOKBEHIND; i <= +LOOKAHEAD; i++) {
            double val = in[(cSample + i) * m_cChannels + cChannel];
            double coeff = ((double) c[i]) / 16384.0;
            Accum += val * coeff;
         }
         out[cSample * m_cChannels + cChannel] = (signed short) Accum;
      }
   }
   return NOERROR;
}

//
// COM stuff
//
CComBase* CFIRtest::CreateInstance(IUnknown *pUnk, HRESULT *phr) {
   return new CFIRtest(pUnk, phr);
}
HRESULT CFIRtest::NDQueryInterface(REFIID riid, void **ppv) {
   if (riid == IID_IMediaObject)
      return GetInterface((IMediaObject*)this, ppv);
   else
      return CComBase::NDQueryInterface(riid, ppv);
}
struct CComClassTemplate g_ComClassTemplates[] = {
   {
      &CLSID_FIRtest,
      CFIRtest::CreateInstance
   }
};
int g_cComClassTemplates = 1;
STDAPI DllRegisterServer(void) {
   HRESULT hr;
   
   // Register as a COM class
   hr = CreateCLSIDRegKey(CLSID_FIRtest, "FIRtest media object");
   if (FAILED(hr))
      return hr;
   
   // Now register as a DMO
   return DMORegister(L"audio FIR filter", CLSID_FIRtest, DMOCATEGORY_AUDIO_EFFECT, 0, 0, NULL, 0, NULL);
}
STDAPI DllUnregisterServer(void) {
   // BUGBUG - implement !
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\simple\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xform.rc
//
#define IDS_PROJNAME                    100
#define IDR_SIMPLE                      101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\simple\simple.cpp ===
// Simple.cpp : Implementation of CSimple
#include <stdafx.h>
#include <dmobase.h>
#include "Xform.h"
#include "Simple.h"

/////////////////////////////////////////////////////////////////////////////
// CSimple

// Our only supported WAVE format
WAVEFORMATEX wfmtFormat = {
   WAVE_FORMAT_PCM,
   2, // nChannels
   44100, // nSamplesPerSec
   176400, // nAvgBytesPerSec
   4, // nBlockAlign
   16, // wBitsPerSample
   0 // extra
};

FORMATENTRY InputFormats[] =
{
    {
        &MEDIATYPE_Audio, &MEDIASUBTYPE_PCM, &FORMAT_WaveFormatEx, sizeof(WAVEFORMATEX), (BYTE*)&wfmtFormat
    }
};

FORMATENTRY OutputFormats[] =
{
    {
        &MEDIATYPE_Audio, &MEDIASUBTYPE_PCM, &FORMAT_WaveFormatEx, sizeof(WAVEFORMATEX), (BYTE*)&wfmtFormat
    }
};

INPUTSTREAMDESCRIPTOR InputStreams[] =
{
    {
        1, // 1 format
        InputFormats,
        4, // minimum buffer size
        FALSE, // holds buffers
        0  // lookahead - doesn't apply because we don't hold buffers
    }
};

OUTPUTSTREAMDESCRIPTOR OutputStreams[] =
{
    {
        1,
        OutputFormats,
        16384 // minimum buffer size
    }
};

//
// Verify that our object supports this format
//
HRESULT VerifyFormat(WAVEFORMATEX *pWaveFormat, ULONG ulSize) {
   if (ulSize != sizeof(WAVEFORMATEX)) {
      return E_FAIL;
   }
   if (pWaveFormat->wFormatTag != WAVE_FORMAT_PCM) {
      return E_FAIL;
   }
   if ((pWaveFormat->nChannels != 1) && (pWaveFormat->nChannels != 2)) {
      return E_FAIL;
   }
   if ((pWaveFormat->wBitsPerSample != 8) && (pWaveFormat->wBitsPerSample != 16)) {
      return E_FAIL;
   }
   if ((pWaveFormat->nSamplesPerSec < 2000) || (pWaveFormat->nSamplesPerSec > 500000)) {
      return E_FAIL;
   }
   return NOERROR;
}

HRESULT CSimple::SetFormat(WAVEFORMATEX *pWaveFormat) {
   m_bFormatSet = TRUE;
   m_nChannels = pWaveFormat->nChannels;
   m_b8bit = (pWaveFormat->wBitsPerSample == 8);
   m_dwSamplingRate = pWaveFormat->nSamplesPerSec;
   
   return NOERROR;
}

HRESULT CSimple::CompareFormat(WAVEFORMATEX *pWaveFormat) {
   if (m_bFormatSet) {
      if (pWaveFormat->nChannels != m_nChannels) {
         return E_FAIL;
      }
      if ((pWaveFormat->wBitsPerSample == 8) != m_b8bit) {
         return E_FAIL;
      }
      if (pWaveFormat->nSamplesPerSec != m_dwSamplingRate) {
         return E_FAIL;
      }
      return NOERROR;
   }
   else {
      return NOERROR; // nothing to compare to
   }
}

/*
HRESULT CSimple::InputSetType(long lStreamIndex, DMO_MEDIA_TYPE *pmt) {
   HRESULT hr;
   
   hr = CGenericDMO::InputSetType(lStreamIndex, pmt);
   if (FAILED(hr))
      return hr;

   hr = VerifyFormat((WAVEFORMATEX*)(pmt->pbFormat), pmt->cbFormat);
   if (FAILED(hr))
      return hr;

   return SetFormat((WAVEFORMATEX*)(pmt->pbFormat));

}

HRESULT CSimple::OutputSetType(long lStreamIndex, DMO_MEDIA_TYPE *pmt) {
   HRESULT hr;

   hr = CGenericDMO::OutputSetType(lStreamIndex, pmt);
   if (FAILED(hr))
      return hr;

   hr = VerifyFormat(((WAVEFORMATEX*)pmt->pbFormat), pmt->cbFormat);
   if (FAILED(hr))
      return hr;

   if (m_bFormatSet) {
      //
      // Accept this output format only if it matches the one already set.
      // I.e., once a format has been set it must be changed on the input pin,
      // then on the output pin.
      //
      return CompareFormat((WAVEFORMATEX*)(pmt->pbFormat));
   }
   else {
      return SetFormat((WAVEFORMATEX*)pmt->pbFormat);
   }
}
*/

#ifndef SIZEOF_ARRAY
    #define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))
#endif // !defined(SIZEOF_ARRAY)

HRESULT CSimple::SetupStreams()
{
    HRESULT hr;

    hr = CreateInputStreams(InputStreams, SIZEOF_ARRAY(InputStreams));
    if (FAILED(hr)) {
       return hr;
    }

    hr = CreateOutputStreams(OutputStreams, SIZEOF_ARRAY(OutputStreams));
    if (FAILED(hr)) {
       return hr;
    }

    // bugbug - not quite the right place to initialize these
    m_bFormatSet = TRUE;
    m_nChannels = 2;
    m_b8bit = FALSE;
    m_dwSamplingRate = 44100;
    
    m_Phase = 0;
    m_Period = 2000;
    m_Shape = 0;
    m_pBuffer = NULL;
    
    return S_OK;
}

HRESULT CSimple::DoProcess(INPUTBUFFER *pInput, OUTPUTBUFFER *pOutput) {
   if (!m_bFormatSet)
      return DMO_E_TYPE_NOT_SET;

   //
   // Figure out how many bytes we can process
   //
   DWORD dwProcess = (pInput->cbSize  < pOutput->cbSize) ? pInput->cbSize : pOutput->cbSize; // min
   DWORD dwGranularity = (m_b8bit ? 1 : 2) * m_nChannels;
   DWORD dwSamples = dwProcess / dwGranularity;
   dwProcess = dwSamples * dwGranularity; // process whole samples only

   pOutput->cbUsed = dwProcess;
   pInput->cbUsed = dwProcess;
   if (pInput->cbSize - dwProcess < dwGranularity)
      // anything we didn't process is useless by itself
      pInput->dwFlags = INPUT_STATUSF_RESIDUAL;
   else
      pInput->dwFlags = 0;

   // Copy any timestamps / flags
   pOutput->dwFlags = 0;
   if (pInput->dwFlags & DMO_INPUT_DATA_BUFFERF_SYNCPOINT)
      pOutput->dwFlags |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
   if (pInput->dwFlags & DMO_INPUT_DATA_BUFFERF_TIME) {
      pOutput->dwFlags |= DMO_OUTPUT_DATA_BUFFERF_TIME;
      pOutput->rtTimestamp = pInput->rtTimestamp;
   }
   if (pInput->dwFlags & DMO_INPUT_DATA_BUFFERF_TIMELENGTH) {
      pOutput->dwFlags |= DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH;
      pOutput->rtTimelength = pInput->rtTimelength;
   }

   Gargle(pInput->pData, pOutput->pData, dwSamples);

   return NOERROR;
}

void CSimple::Gargle(BYTE *pIn, BYTE *pOut, DWORD dwSamples) {
   //
   // Gargle !
   //
   DWORD cSample, cChannel;
   for (cSample = 0; cSample < dwSamples; cSample++) {
      // If m_Shape is 0 (triangle) then we multiply by a triangular waveform
      // that runs 0..Period/2..0..Period/2..0... else by a square one that
      // is either 0 or Period/2 (same maximum as the triangle) or zero.
      //
      // m_Phase is the number of samples from the start of the period.
      // We keep this running from one call to the next,
      // but if the period changes so as to make this more
      // than Period then we reset to 0 with a bang.  This may cause
      // an audible click or pop (but, hey! it's only a sample!)
      //
      ++m_Phase;
      if (m_Phase>m_Period) m_Phase = 0;

      int M = m_Phase;      // m is what we modulate with

      if (m_Shape ==0 ) {   // Triangle
          if (M>m_Period/2) M = m_Period-M;  // handle downslope
      } else {             // Square wave
          if (M<=m_Period/2) M = m_Period/2; else M = 0;
      }

      for (cChannel = 0; cChannel < m_nChannels; cChannel++) {
         if (m_b8bit==1) {
             // 8 bit sound uses 0..255 representing -128..127
             // Any overflow, even by 1, would sound very bad.
             // so we clip paranoically after modulating.
             // I think it should never clip by more than 1
             //
             int i = pIn[cSample * m_nChannels + cChannel] - 128;               // sound sample, zero based
             i = (i*M*2)/m_Period;            // modulate
             if (i>127) i = 127;            // clip
             if (i<-128) i = -128;
   
             pOut[cSample * m_nChannels + cChannel] = (unsigned char)(i+128);  // reset zero offset to 128
   
         } else {
             // 16 bit sound uses 16 bits properly (0 means 0)
             // We still clip paranoically
             //
             int i = ((short*)pIn)[cSample * m_nChannels + cChannel];// in a register, we might hope
             i = (i*M*2)/m_Period;            // modulate
             if (i>32767) i = 32767;        // clip
             if (i<-32768) i = -32768;
             ((short*)pOut)[cSample * m_nChannels + cChannel] = (short)i;
         }
      }
   }
}

/*
HRESULT CSimple::DoProcess(BYTE *pIn,
                           DWORD dwAvailable,
                           DWORD *pdwConsumed,
                           BOOL fInEOS,
                           BYTE *pOut,
                           DWORD dwBufferSize,
                           DWORD *pdwProduced,
                           BOOL *pfOutEOS) {

   if (!m_bFormatSet)
      return SHELLOBJECT_E_TYPE_NOT_SET;

   if (dwAvailable == 0) {
      *pdwProduced = 0;
      return NOERROR; // this is normal after EndOfStream
   }

   //
   // Find out how many samples/bytes we want to process
   //
   DWORD dwProcess = (dwAvailable < dwBufferSize) ? dwAvailable : dwBufferSize; // min
   DWORD dwGranularity = (m_b8bit ? 1 : 2) * m_nChannels;
   DWORD dwSamples = dwProcess / dwGranularity;
   dwProcess = dwSamples * dwGranularity; // process whole samples only

   //
   // This object does not buffer anything, so an EnfOfStream
   // on the input translates directly into one on the output.
   // Unless the output buffer is too short to process all of
   // the input.
   //
   if (dwProcess / dwGranularity < dwAvailable / dwGranularity)
      *pfOutEOS = FALSE; // can't process everything.
   else
      *pfOutEOS = fInEOS;

   
   *pdwConsumed = dwProcess;
   *pdwProduced = dwProcess;

   return NOERROR;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\simple\simple.h ===
// Simple.h : Declaration of the CSimple

#ifndef __SIMPLE_H_
#define __SIMPLE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSimple
class CSimple :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSimple, &CLSID_Simple>,
    //public IDispatchImpl<CGenericDMO, &IID_IMediaObject, &LIBID_XFORMLib>
    public CGenericDMO
{
public:
    CSimple()
    {
        m_pUnkMarshaler = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SIMPLE)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSimple)
    //COM_INTERFACE_ENTRY(ISimple)
    //COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IMediaObject)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        //  Set up our table stuff
        HRESULT hr = SetupStreams();
        if (FAILED(hr)) {
            return hr;
        }
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    STDMETHODIMP Flush()
    {
        //  Clear our streaming info
        return CGenericDMO::Flush();
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    HRESULT DoProcess(INPUTBUFFER *pInput, OUTPUTBUFFER *pOutput);
    void Gargle(BYTE *pIn, BYTE *pOut, DWORD dwSamples);
    /*
    HRESULT DoProcess(BYTE *pIn,
                      DWORD dwAvailable,
                      DWORD *pdwConsumed,
                      BOOL fInEOS,
                      BYTE *pOut,
                      DWORD dwBufferSize,
                      DWORD *pdwProduced,
                      BOOL *pfOutEOS);
    */
    HRESULT SetupStreams();

    HRESULT CSimple::SetFormat(WAVEFORMATEX *pWaveFormat);
    HRESULT CSimple::CompareFormat(WAVEFORMATEX *pWaveFormat);
/*
    STDMETHODIMP CSimple::InputSetType(long lStreamIndex, DMO_MEDIA_TYPE *pmt);
    STDMETHODIMP CSimple::OutputSetType(long lStreamIndex, DMO_MEDIA_TYPE *pmt);
*/

protected:
   // format stuff
   BOOL m_bFormatSet;
   WORD m_nChannels;
   BOOL m_b8bit;
   DWORD m_dwSamplingRate;

   // streaming stuff
   IMediaBuffer *m_pBuffer;

   // gargle properties
   int m_Phase;
   int m_Period;
   int m_Shape;

    CComPtr<IUnknown> m_pUnkMarshaler;

// ISimple
public:
};

#endif //__SIMPLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\simple\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__CE13AE32_097B_11D3_B30B_444553540001__INCLUDED_)
#define AFX_STDAFX_H__CE13AE32_097B_11D3_B30B_444553540001__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CE13AE32_097B_11D3_B30B_444553540001__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\simple\xform.cpp ===
// xform.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f xformps.mk in the project directory.

#include <stdafx.h>
#include <dmobase.h>
#include "xform.h"
#include "Simple.h"
#include "resource.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Simple, CSimple)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_XFORMLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    DMORegister(L"simple", CLSID_Simple, DMOCATEGORY_AUDIO_EFFECT, 0, 0, NULL, 0, NULL);
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\filter\dump.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
//
// What this sample illustrates
//
// A renderer that dumps the samples it gets into a text file
//
//
// Summary
//
// We are a generic renderer that can be attached to any data stream that
// uses IMemInputPin data transport. For each sample we receive we write
// it's contents including it's properties into a dump file. The file we
// will write into is specified when the dump filter is created. Graphedt
// creates a file open dialog automatically when it sees a filter being
// created that supports the ActiveMovie defined IFileSinkFilter interface
//
//
// Implementation
//
// Pretty straightforward really, we have our own input pin class so that
// we can override Receive, all that does is to write the properties and
// data into a raw data file (using the Write function). We don't keep
// the file open when we are stopped so the flags to the open function
// ensure that we open a file if already there otherwise we create it.
//
//
// Demonstration instructions
//
// Start GRAPHEDT available in the ActiveMovie SDK tools. Drag and drop any
// MPEG, AVI or MOV file into the tool and it will be rendered. Then go to
// the filters in the graph and find the filter (box) titled "Video Renderer"
// This is the filter we will be replacing with the dump renderer. Then click
// on the box and hit DELETE. After that go to the Graph menu and select the
// "Insert Filters", from the dialog box find and select the "Dump Filter".
//
// You will be asked to supply a filename where you would like to have the
// data dumped, the data we receive in this filter is dumped in text form.
// Then dismiss the dialog. Back in the graph layout find the output pin of
// the filter that used to be connected to the input of the video renderer
// you just deleted, right click and do "Render". You should see it being
// connected to the input pin of the dump filter you just inserted.
//
// Click Pause and Run and then a little later stop on the GRAPHEDT frame and
// the data being passed to the renderer will be dumped into a file. Stop the
// graph and dump the filename that you entered when inserting the filter into
// the graph, the data supplied to the renderer will be displayed as raw data
//
//
// Files
//
// dump.cpp             Main implementation of the dump renderer
// dump.def             What APIs the DLL will import and export
// dump.h               Class definition of the derived renderer
// dump.rc              Version information for the sample DLL
// dumpuids.h           CLSID for the dump filter
// makefile             How to build it...
//
//
// Base classes used
//
// CBaseFilter          Base filter class supporting IMediaFilter
// CRenderedInputPin    An input pin attached to a renderer
// CUnknown             Handle IUnknown for our IFileSinkFilter
// CPosPassThru         Passes seeking interfaces upstream
// CCritSec             Helper class that wraps a critical section
//
//

#include <windows.h>
#include <malloc.h>
#include <commdlg.h>
#include <streams.h>
#include <mediaobj.h>
#include <initguid.h>
#include <filefmt.h>
#include <filerw.h>
#include "dumpuids.h"
#include "dump.h"


// Setup data

const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_NULL,            // Major type
    &MEDIASUBTYPE_NULL          // Minor type
};

const AMOVIESETUP_PIN sudPins =
{
    L"Input",                   // Pin string name
    FALSE,                      // Is it rendered
    FALSE,                      // Is it an output
    FALSE,                      // Allowed none
    FALSE,                      // Likewise many
    &CLSID_NULL,                // Connects to filter
    L"Output",                  // Connects to pin
    1,                          // Number of types
    &sudPinTypes                // Pin information
};

const AMOVIESETUP_FILTER sudDump =
{
    &CLSID_Dump,                // Filter CLSID
    L"DMO Data Dump",                    // String name
    MERIT_DO_NOT_USE,           // Filter merit
    1,                          // Number pins
    &sudPins                    // Pin details
};


//
//  Object creation stuff
//
CFactoryTemplate g_Templates[]= {
    L"DMO Data Dump", &CLSID_Dump, CDump::CreateInstance, NULL, &sudDump
};
int g_cTemplates = 1;


// Constructor

CDumpFilter::CDumpFilter(CDump *pDump,
                         LPUNKNOWN pUnk,
                         CCritSec *pLock,
                         HRESULT *phr) :
    CBaseFilter(NAME("CDumpFilter"), pUnk, pLock, CLSID_Dump),
    m_pDump(pDump)
{
}


//
// GetPin
//
CBasePin * CDumpFilter::GetPin(int n)
{
    if (n == 0) {
        return m_pDump->m_pPin;
    } else {
        return NULL;
    }
}


//
// GetPinCount
//
int CDumpFilter::GetPinCount()
{
    return 1;
}


//
// Stop
//
// Overriden to close the dump file
//
STDMETHODIMP CDumpFilter::Stop()
{
    CAutoLock cObjectLock(m_pLock);
    m_pDump->CloseFile();
    return CBaseFilter::Stop();
}


//
// Pause
//
// Overriden to open the dump file
//
STDMETHODIMP CDumpFilter::Pause()
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped) {
        return CBaseFilter::Pause();
    }
    m_pDump->OpenFile();
    HRESULT hr = CBaseFilter::Pause();
    if (SUCCEEDED(hr)) {
        hr = m_pDump->m_File.WriteMediaType(0, &m_pDump->m_pPin->Type());
    }
	return hr;
}


//
// Run
//
// Overriden to open the dump file
//
STDMETHODIMP CDumpFilter::Run(REFERENCE_TIME tStart)
{
    CAutoLock cObjectLock(m_pLock);
    return CBaseFilter::Run(tStart);
}


//
//  Definition of CDumpInputPin
//
CDumpInputPin::CDumpInputPin(CDump *pDump,
                             LPUNKNOWN pUnk,
                             CBaseFilter *pFilter,
                             CCritSec *pLock,
                             CCritSec *pReceiveLock,
                             HRESULT *phr) :

    CRenderedInputPin(NAME("CDumpInputPin"),
                  pFilter,                   // Filter
                  pLock,                     // Locking
                  phr,                       // Return code
                  L"Input"),                 // Pin name
    m_pReceiveLock(pReceiveLock),
    m_pDump(pDump),
    m_tLast(0)
{
}


//
// CheckMediaType
//
// Check if the pin can support this specific proposed type and format
//
HRESULT CDumpInputPin::CheckMediaType(const CMediaType *)
{
    return S_OK;
}


//
// BreakConnect
//
// Break a connection
//
HRESULT CDumpInputPin::BreakConnect()
{
    if (m_pDump->m_pPosition != NULL) {
        m_pDump->m_pPosition->ForceRefresh();
    }
    return CRenderedInputPin::BreakConnect();
}


//
// ReceiveCanBlock
//
// We don't hold up source threads on Receive
//
STDMETHODIMP CDumpInputPin::ReceiveCanBlock()
{
    return S_FALSE;
}


//
// Receive
//
// Do something with this media sample
//
STDMETHODIMP CDumpInputPin::Receive(IMediaSample *pSample)
{
    CAutoLock lock(m_pReceiveLock);

    HRESULT hr = CRenderedInputPin::Receive(pSample);
    if (S_OK != hr) {
        return hr;
    }

    REFERENCE_TIME tStart, tStop;
    pSample->GetTime(&tStart, &tStop);
    DbgLog((LOG_TRACE, 1, TEXT("tStart(%s), tStop(%s), Diff(%d ms), Bytes(%d)"),
           (LPCTSTR) CDisp(tStart),
           (LPCTSTR) CDisp(tStop),
           (LONG)((tStart - m_tLast) / 10000),
           pSample->GetActualDataLength()));

    m_tLast = tStart;

    // Copy the data to the file
    return m_pDump->WriteSample(pSample);
}


//
// EndOfStream
//
STDMETHODIMP CDumpInputPin::EndOfStream(void)
{
    CAutoLock lock(m_pReceiveLock);
    return CRenderedInputPin::EndOfStream();

} // EndOfStream


//
// NewSegment
//
// Called when we are seeked
//
STDMETHODIMP CDumpInputPin::NewSegment(REFERENCE_TIME tStart,
                                       REFERENCE_TIME tStop,
                                       double dRate)
{
    m_tLast = 0;
    return S_OK;

} // NewSegment


//
//  CDump class
//
CDump::CDump(LPUNKNOWN pUnk, HRESULT *phr) :
    CUnknown(NAME("CDump"), pUnk),
    m_pFilter(NULL),
    m_pPin(NULL),
    m_pPosition(NULL),
    m_pFileName(0)
{
    m_pFilter = new CDumpFilter(this, GetOwner(), &m_Lock, phr);
    if (m_pFilter == NULL) {
        *phr = E_OUTOFMEMORY;
        return;
    }

    m_pPin = new CDumpInputPin(this,GetOwner(),
                               m_pFilter,
                               &m_Lock,
                               &m_ReceiveLock,
                               phr);
    if (m_pPin == NULL) {
        *phr = E_OUTOFMEMORY;
        return;
    }
}


//
// SetFileName
//
// Implemented for IFileSinkFilter support
//
STDMETHODIMP CDump::SetFileName(LPCOLESTR pszFileName,const AM_MEDIA_TYPE *pmt)
{
    // Is this a valid filename supplied

    CheckPointer(pszFileName,E_POINTER);
    if(wcslen(pszFileName) > MAX_PATH)
        return ERROR_FILENAME_EXCED_RANGE;

    // Take a copy of the filename

    m_pFileName = new WCHAR[1+lstrlenW(pszFileName)];
    if (m_pFileName == 0)
        return E_OUTOFMEMORY;
    lstrcpyW(m_pFileName,pszFileName);

    // Create the file then close it

    HRESULT hr = OpenFile();
    CloseFile();
    return hr;

} // SetFileName


//
// GetCurFile
//
// Implemented for IFileSinkFilter support
//
STDMETHODIMP CDump::GetCurFile(LPOLESTR * ppszFileName,AM_MEDIA_TYPE *pmt)
{
    CheckPointer(ppszFileName, E_POINTER);
    *ppszFileName = NULL;
    if (m_pFileName != NULL) {
        *ppszFileName = (LPOLESTR)
        QzTaskMemAlloc(sizeof(WCHAR) * (1+lstrlenW(m_pFileName)));
        if (*ppszFileName != NULL) {
            lstrcpyW(*ppszFileName, m_pFileName);
        }
    }

    if(pmt) {
        ZeroMemory(pmt, sizeof(*pmt));
        pmt->majortype = MEDIATYPE_NULL;
        pmt->subtype = MEDIASUBTYPE_NULL;
    }
    return S_OK;

} // GetCurFile


// Destructor

CDump::~CDump()
{
    CloseFile();
    delete m_pPin;
    delete m_pFilter;
    delete m_pPosition;
    delete m_pFileName;
}


//
// CreateInstance
//
// Provide the way for COM to create a dump filter
//
CUnknown * WINAPI CDump::CreateInstance(LPUNKNOWN punk, HRESULT *phr)
{
    CDump *pNewObject = new CDump(punk, phr);
    if (pNewObject == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return pNewObject;

} // CreateInstance


//
// NonDelegatingQueryInterface
//
// Override this to say what interfaces we support where
//
STDMETHODIMP CDump::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);
    CAutoLock lock(&m_Lock);

    // Do we have this interface

    if (riid == IID_IFileSinkFilter) {
        return GetInterface((IFileSinkFilter *) this, ppv);
    } else if (riid == IID_IBaseFilter || riid == IID_IMediaFilter || riid == IID_IPersist) {
	return m_pFilter->NonDelegatingQueryInterface(riid, ppv);
    } else if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
        if (m_pPosition == NULL) {

            HRESULT hr = S_OK;
            m_pPosition = new CPosPassThru(NAME("Dump Pass Through"),
                                           (IUnknown *) GetOwner(),
                                           (HRESULT *) &hr, m_pPin);
            if (m_pPosition == NULL) {
                return E_OUTOFMEMORY;
            }

            if (FAILED(hr)) {
                delete m_pPosition;
                m_pPosition = NULL;
                return hr;
            }
        }
        return m_pPosition->NonDelegatingQueryInterface(riid, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface


//
// OpenFile
//
// Opens the file ready for dumping
//
HRESULT CDump::OpenFile()
{
    TCHAR *pFileName = NULL;

    // Has a filename been set yet
    if (m_pFileName == NULL) {
        return ERROR_INVALID_NAME;
    }

    // Convert the UNICODE filename if necessary

#if defined(WIN32) && !defined(UNICODE)
    char convert[MAX_PATH];
    if(!WideCharToMultiByte(CP_ACP,0,m_pFileName,-1,convert,MAX_PATH,0,0))
        return ERROR_INVALID_NAME;
    pFileName = convert;
#else
    pFileName = m_pFileName;
#endif

    // Try to open the file

    return m_File.Open(pFileName);

} // Open


//
// CloseFile
//
// Closes any dump file we have opened
//
HRESULT CDump::CloseFile()
{
    m_File.Close();
    return NOERROR;

} // Open


//
// Write
//
// Write stuff to the file
//
HRESULT CDump::WriteSample(IMediaSample *pSample)
{
    //  See if we need to write a media type
    AM_MEDIA_TYPE *pmt;
    if (S_OK == pSample->GetMediaType(&pmt)) {
        HRESULT hr = m_File.WriteMediaType(0, pmt);
		DeleteMediaType(pmt);
        if (FAILED(hr)) {
            return hr;
        }
    }
    //  Write timestamps etc
    REFERENCE_TIME rtStart = 0, rtStop = 0;
    HRESULT hr = pSample->GetTime(&rtStart, &rtStop);
    DWORD dwFlags =0;
    if (S_OK == hr) {
        dwFlags = DMO_INPUT_DATA_BUFFERF_TIME +
                  DMO_INPUT_DATA_BUFFERF_TIMELENGTH;
    } else
    if (hr == VFW_S_NO_STOP_TIME) {
        dwFlags = DMO_INPUT_DATA_BUFFERF_TIME;
    }
    if (S_OK == pSample->IsSyncPoint()) {
        dwFlags |= DMO_INPUT_DATA_BUFFERF_SYNCPOINT;
    }

    PBYTE pbData;
    hr = pSample->GetPointer(&pbData);
    if (FAILED(hr)) {
        return hr;
    }
    hr = m_File.WriteSample(
                  0,
                  pbData,
                  pSample->GetActualDataLength(),
                  dwFlags,
                  rtStart,
                  rtStop);

    return hr;
}

//
// DllRegisterSever
//
// Handle the registration of this filter
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );

} // DllRegisterServer


//
// DllUnregisterServer
//
STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );

} // DllUnregisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\filter\dumpuids.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// The CLSID used by the dump filter

// { e3cd3e20-9436-11d3-b30b-444553540000}

DEFINE_GUID(CLSID_Dump,
0xe3cd3e20, 0x9436, 0x11d3, 0xb3, 0x0b, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\include\filefmt.h ===
//  Special file format for DMO test data

/*

    The file is a sequence of (unaligned):

    DWORD dwLength;
    DWORD dwType;
    BYTE[dwLength - 8]

    Each 'chunk' has a defined format
*/

/*  GUID to start the file */
/* 3a337620-9497-11d3-b30b-444553540000 */
DEFINE_GUID(GUID_DMOFile,
0x3a337620, 0x9497, 0x11d3, 0xb3, 0x0b, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);


//  Use a class to define a scope
class CFileFormat {
public:
	 enum {
        MediaType = MAKEFOURCC('T','Y','P','E'),
        Sample = MAKEFOURCC('D','A','T','A')
    };

    class CHeader {
    public:
        DWORD dwLength;
        //  One of the chunk types
        DWORD dwType;
        DWORD dwStreamId;
        DWORD dwPadding;
    };

    class CMediaType : public CHeader
    {
    public:
        DMO_MEDIA_TYPE mt;
    };

    class CSample : public CHeader
    {
    public:
        //  Use DMO_INPUT_BUFFERF_... flags for dwFlags
        //  DMO_INPUT_DATA_BUFFERF_SYNCPOINT       = 0x00000001
        //  DMO_INPUT_DATA_BUFFERF_TIME            = 0x00000002
        //  DMO_INPUT_DATA_BUFFERF_TIMELENGTH      = 0x00000004
        DWORD dwFlags;
        DWORD dwPadding;
        LONGLONG llStartTime;
        LONGLONG llLength;
        //BYTE bData[];
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\include\filerw.h ===
inline HRESULT LastError()
{
    return MAKE_HRESULT(SEVERITY_ERROR,
                        FACILITY_WIN32,
                        GetLastError());
}

class CTestFileRead
{
public:
    CTestFileRead() {
        m_hFile = INVALID_HANDLE_VALUE;
        m_pHeader = NULL;
        m_pszFile = NULL;
        m_llOffset = 0;
    }
    ~CTestFileRead() {
        Close();
    }
	void Close()
	{
		if (m_hFile != INVALID_HANDLE_VALUE) {
            CloseHandle(m_hFile);
            m_hFile = INVALID_HANDLE_VALUE;
        }
        delete [] (BYTE *)m_pHeader;
        m_pHeader = NULL;
        delete [] m_pszFile;
        m_pszFile = NULL;
	}
    HRESULT Open(LPCTSTR lpszFile)
    {
        if (m_pszFile) {
            Close();
        }
        m_pszFile = new TCHAR[lstrlen(lpszFile) + 1];
        if (m_pszFile == NULL) {
            //Error(ERROR_TYPE_TEST, E_OUTOFMEMORY, TEXT("Could not allocate file name string"));
            return E_OUTOFMEMORY;
        }
        lstrcpy(m_pszFile, lpszFile);
        m_hFile = CreateFile(lpszFile,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL);
        if (INVALID_HANDLE_VALUE == m_hFile) {
            //TCHAR sz[1000];
            //wsprintf(sz, TEXT("Error opening test data file for read %s"),
            //         lpszFile);
            //Error(ERROR_TYPE_TEST, hr, sz);
            return LastError();
        }

        //  Check it's one of ours
        DWORD dwReadSize = 0;
        GUID guidFile;
        ReadFile(m_hFile, &guidFile, sizeof(guidFile), &dwReadSize, NULL);
        m_llOffset += dwReadSize;
        if (dwReadSize != sizeof(guidFile) ||
            guidFile != GUID_DMOFile) {
            Close();
            return E_INVALIDARG;
        }
        return S_OK;
    }

    HRESULT Next()
    {
        //  Read the next chunk
        DWORD dwRead;
        DWORD dwLen;

        if (!ReadFile(m_hFile, &dwLen, sizeof(dwLen), &dwRead, NULL)) {
            // Error(ERROR_TYPE_TESTDATA, hr, TEXT("Problem reading test data file %s"), m_pszFile);
            return LastError();
        }

        m_llOffset += dwRead;

        // From ReadFile()'s documentation in MSDN "If the return value is nonzero and the 
        // number of bytes read is zero, the file pointer was beyond the current end of
        // the file at the time of the read operation."

        // Have we read all the data in the file?
        if (0 == dwRead) {
            return S_FALSE;
        }

        if (dwRead != sizeof(dwLen)) {
           return E_FAIL;
        }

        if (dwLen < sizeof(CFileFormat::CHeader)) {
            return E_FAIL;
        }

        delete [] (BYTE *)m_pHeader;
        m_pHeader = (CFileFormat::CHeader *)new BYTE[dwLen];
        m_pHeader->dwLength = dwLen;

        //  Now read for the length
        if (!ReadFile(m_hFile, (PBYTE)m_pHeader + sizeof(DWORD),
                      dwLen - sizeof(DWORD), &dwRead, NULL)) {
            //Error(ERROR_TYPE_TESTDATA, hr, TEXT("Problem reading test data file %s"), m_pszFile);
            return LastError();
        }

        m_llOffset += dwRead;

        if ((dwLen - sizeof(DWORD)) != dwRead) {
            return E_FAIL;
        }

        //  Now check out the chunks we know about
        DWORD dwExpectedLen;
        switch (m_pHeader->dwType) {
        case CFileFormat::MediaType:
            {
                CFileFormat::CMediaType *pmt =
                    static_cast<CFileFormat::CMediaType *>(m_pHeader);

                dwExpectedLen = sizeof(CFileFormat::CMediaType) + pmt->mt.cbFormat;
                if (dwLen != dwExpectedLen) {
                    //Error(ERROR_TYPE_TEST_DATA, E_FAIL,
                    //      TEXT("Invalid media type length - was %d, expected %d"),
                    //      dwLen, dwExpectedLen);
                    return E_FAIL;
                }

                //  Set pbFormat correct
                pmt->mt.pbFormat = (BYTE *)(pmt+1);

                //  Make sure the pUnk is 0
                pmt->mt.pUnk = NULL;
            }
            break;

        case CFileFormat::Sample:
            {
                if (dwLen < sizeof(CFileFormat::CSample)) {
                    //Error(ERROR_TYPE_TEST_DATA, E_FAIL,
                    //      TEXT("Invalid Sample length - was %d, expected >= %d"),
                    //      dwLen, sizeof(CFileFormat::CSample));
                    return E_FAIL;
                }
            }
            break;

        default:
            return E_UNEXPECTED;
        }

        return S_OK;
    }

    //  Lots of helpers
    DWORD Type()
    {
        if (NULL == m_pHeader) {
            //Error(ERROR_TYPE_INTERNAL, E_FAIL,
            //      TEXT("Invalid call to CTestFile::Type"));
            return 0;
        }
        return m_pHeader->dwType;
    }
    DWORD Stream()
    {
        if (NULL == m_pHeader) {
            //Error(ERROR_TYPE_INTERNAL, E_FAIL,
            //      TEXT("Invalid call to CTestFile::Stream"));
            return 0;
        }
        return m_pHeader->dwStreamId;
    }
    DMO_MEDIA_TYPE *MediaType()
    {
        if (NULL == m_pHeader || m_pHeader->dwType != CFileFormat::MediaType) {
            //Error(ERROR_TYPE_INTERNAL, E_FAIL,
            //      TEXT("Invalid call to MediaType"));
            return 0;
        }
        return &(static_cast<CFileFormat::CMediaType *>(m_pHeader))->mt;
    }

    CFileFormat::CSample *Sample()
    {
        if (NULL == m_pHeader || m_pHeader->dwType != CFileFormat::Sample) {
            //Error(ERROR_TYPE_INTERNAL, E_FAIL,
            //      TEXT("Invalid call to Sample"));
            return 0;
        }
        return (static_cast<CFileFormat::CSample *>(m_pHeader));
    }

    CFileFormat::CHeader *Header()
    {
        return m_pHeader;
    }

    LONGLONG Offset() const
    {
        return m_llOffset;
    }

    CFileFormat::CHeader *m_pHeader;
    TCHAR *m_pszFile;
    HANDLE m_hFile;
    LONGLONG m_llOffset;
};

class CTestFileWrite
{
public:
    CTestFileWrite() {
        m_hFile = INVALID_HANDLE_VALUE;
        m_pHeader = NULL;
        m_pszFile = NULL;
    }
    ~CTestFileWrite() {
        Close();
    }
    void Close()
    {
        if (m_hFile != INVALID_HANDLE_VALUE) {
            CloseHandle(m_hFile);
            m_hFile = INVALID_HANDLE_VALUE;
        }
        delete [] (BYTE *)m_pHeader;
        m_pHeader = NULL;
        delete [] m_pszFile;
        m_pszFile = NULL;
    }
    HRESULT Open(LPCTSTR lpszFile)
    {
        m_pszFile = new TCHAR[lstrlen(lpszFile) + 1];
        if (m_pszFile == NULL) {
            //Error(ERROR_TYPE_TEST, E_OUTOFMEMORY, TEXT("Could not allocate file name string"));
            return E_OUTOFMEMORY;
        }
        lstrcpy(m_pszFile, lpszFile);
        m_hFile = CreateFile(lpszFile,
                             GENERIC_WRITE,
                             0,
                             NULL,
                             CREATE_ALWAYS,
                             0,
                             NULL);
        if (INVALID_HANDLE_VALUE == m_hFile) {
            //TCHAR sz[1000];
            //wsprintf(sz, TEXT("Error opening test data file for write %s"),
            //         lpszFile);
            //Error(ERROR_TYPE_TEST, sz, hr);
            return LastError();
        }

        //  Write our signature
        DWORD dwWriteSize = 0;
        if (!WriteFile(m_hFile, &GUID_DMOFile, sizeof(GUID_DMOFile), &dwWriteSize, NULL)) {
            HRESULT hr = LastError();
            Close();
            return hr;
        }
        return S_OK;
    }

    HRESULT WriteMediaType(
        DWORD dwStreamId,
        const DMO_MEDIA_TYPE *pType
    )
    {
        DWORD dwLength = sizeof(CFileFormat::CMediaType) +
                         pType->cbFormat;
        CFileFormat::CMediaType* pFileType = (CFileFormat::CMediaType *) new BYTE[dwLength];
        if( NULL == pFileType ) {
            return E_OUTOFMEMORY;
        }

        ZeroMemory(pFileType, sizeof(CFileFormat::CMediaType));
        pFileType->dwLength = dwLength;
        pFileType->dwType = CFileFormat::MediaType;
        pFileType->dwStreamId;
        pFileType->mt = *pType;
        CopyMemory(pFileType + 1, pType->pbFormat, pType->cbFormat);
        DWORD dwBytesWritten;
        if (!WriteFile(m_hFile,
                       pFileType,
                       dwLength,
                       &dwBytesWritten,
                       NULL)) {
            //Error(ERROR_TYPE_TESTDATA, hr, TEXT("Problem writing test data file %s"), m_pszFile);
            delete [] pFileType;
            return LastError();
        }

        delete [] pFileType;

        return S_OK;
    }

    HRESULT WriteSample(
        DWORD dwStreamId,
        const BYTE *pbData,
        DWORD cbData,
        DWORD dwFlags,
        LONGLONG llStartTime,
        LONGLONG llLength
    )
    {
        DWORD dwLength = sizeof(CFileFormat::CSample) +
                         cbData;
        CFileFormat::CSample* pFileSample = (CFileFormat::CSample *) new BYTE[dwLength];
        if( NULL == pFileSample ) {
            return E_OUTOFMEMORY;
        }

        ZeroMemory(pFileSample, sizeof(CFileFormat::CSample));
        pFileSample->dwLength = dwLength;
        pFileSample->dwType = CFileFormat::Sample;
        pFileSample->dwStreamId;
        pFileSample->dwFlags = dwFlags;
        pFileSample->llStartTime = llStartTime;
        pFileSample->llLength = llLength;
        CopyMemory(pFileSample + 1, pbData, cbData);
        DWORD dwBytesWritten;
        if (!WriteFile(m_hFile,
                       pFileSample,
                       dwLength,
                       &dwBytesWritten,
                       NULL)) {
            //Error(ERROR_TYPE_TESTDATA, hr, TEXT("Problem writing test data file %s"), m_pszFile);
            delete [] pFileSample;
            return LastError();
        }

        delete [] pFileSample;

        return S_OK;
    }

    HANDLE m_hFile;
    CFileFormat::CHeader *m_pHeader;
    TCHAR *m_pszFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\filter\dump.h ===
///==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

class CDumpInputPin;
class CDump;
class CDumpFilter;


// Main filter object

class CDumpFilter : public CBaseFilter
{
    CDump * const m_pDump;

public:

    // Constructor
    CDumpFilter(CDump *pDump,
                LPUNKNOWN pUnk,
                CCritSec *pLock,
                HRESULT *phr);

    // Pin enumeration
    CBasePin * GetPin(int n);
    int GetPinCount();

    // Open and close the file as necessary
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP Pause();
    STDMETHODIMP Stop();
};


//  Pin object

class CDumpInputPin : public CRenderedInputPin
{
    CDump    * const m_pDump;           // Main renderer object
    CCritSec * const m_pReceiveLock;    // Sample critical section
    REFERENCE_TIME m_tLast;             // Last sample receive time

public:

    CDumpInputPin(CDump *pDump,
                  LPUNKNOWN pUnk,
                  CBaseFilter *pFilter,
                  CCritSec *pLock,
                  CCritSec *pReceiveLock,
                  HRESULT *phr);

    // Do something with this media sample
    STDMETHODIMP Receive(IMediaSample *pSample);
    STDMETHODIMP EndOfStream(void);
    STDMETHODIMP ReceiveCanBlock();

    // Check if the pin can support this specific proposed type and format
    HRESULT CheckMediaType(const CMediaType *);

    // Break connection
    HRESULT BreakConnect();

    // Track NewSegment
    STDMETHODIMP NewSegment(REFERENCE_TIME tStart,
                            REFERENCE_TIME tStop,
                            double dRate);

    AM_MEDIA_TYPE& Type()
    {
        return m_mt;
    }
};


//  CDump object which has filter and pin members

class CDump : public CUnknown, public IFileSinkFilter
{
    friend class CDumpFilter;
    friend class CDumpInputPin;

    CDumpFilter *m_pFilter;         // Methods for filter interfaces
    CDumpInputPin *m_pPin;          // A simple rendered input pin
    CCritSec m_Lock;                // Main renderer critical section
    CCritSec m_ReceiveLock;         // Sublock for received samples
    CPosPassThru *m_pPosition;      // Renderer position controls
    CTestFileWrite m_File;          // File to dump into
    LPOLESTR m_pFileName;           // The filename where we dump to

public:

    DECLARE_IUNKNOWN

    CDump(LPUNKNOWN pUnk, HRESULT *phr);
    ~CDump();

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    HRESULT WriteSample(IMediaSample *pSample);

    // Implements the IFileSinkFilter interface
    STDMETHODIMP SetFileName(LPCOLESTR pszFileName,const AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetCurFile(LPOLESTR * ppszFileName,AM_MEDIA_TYPE *pmt);

private:

    // Overriden to say what interfaces we support where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // Open and write to the file
    HRESULT OpenFile();
    HRESULT CloseFile();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\dmoapitst.cpp ===
#include "dmoApiTst.h"
#include <atlbase.h>
#include <mediaerr.h>
#include "nptst.h"
#include "testobj.h"

//static void DisplayBasicInformation( const CLSID& clsidDMO );

const DWORD MAX_DMO_NAME_LENGTH = 80;


HRESULT ProcessOutputs(CDMOObject *pObject);

#define CNV_GUID(clsid) GuidToEnglish((clsid), (char *)_alloca(1024))

struct NamedGuid
{
    const GUID *pguid;
    const char *psz;
};

static const NamedGuid rgng[] =
{
    {&AMPROPSETID_Pin, "AMPROPSETID_Pin"},
    {&AM_INTERFACESETID_Standard, "AM_INTERFACESETID_Standard"},
    {&AM_KSCATEGORY_AUDIO, "AM_KSCATEGORY_AUDIO"},
    {&AM_KSCATEGORY_CAPTURE, "AM_KSCATEGORY_CAPTURE"},
    {&AM_KSCATEGORY_CROSSBAR, "AM_KSCATEGORY_CROSSBAR"},
    {&AM_KSCATEGORY_DATACOMPRESSOR, "AM_KSCATEGORY_DATACOMPRESSOR"},
    {&AM_KSCATEGORY_RENDER, "AM_KSCATEGORY_RENDER"},
    {&AM_KSCATEGORY_TVAUDIO, "AM_KSCATEGORY_TVAUDIO"},
    {&AM_KSCATEGORY_TVTUNER, "AM_KSCATEGORY_TVTUNER"},
    {&AM_KSCATEGORY_VIDEO, "AM_KSCATEGORY_VIDEO"},
    {&AM_KSPROPSETID_AC3, "AM_KSPROPSETID_AC3"},
    {&AM_KSPROPSETID_CopyProt, "AM_KSPROPSETID_CopyProt"},
    {&AM_KSPROPSETID_DvdSubPic, "AM_KSPROPSETID_DvdSubPic"},
    {&AM_KSPROPSETID_TSRateChange, "AM_KSPROPSETID_TSRateChange"},
    {&CLSID_ACMWrapper, "CLSID_ACMWrapper"},
    {&CLSID_AMovie, "CLSID_AMovie"},
    {&CLSID_AVICo, "CLSID_AVICo"},
    {&CLSID_AVIDec, "CLSID_AVIDec"},
    {&CLSID_AVIDoc, "CLSID_AVIDoc"},
    {&CLSID_AVIDraw, "CLSID_AVIDraw"},
    {&CLSID_AVIMIDIRender, "CLSID_AVIMIDIRender"},
    {&CLSID_ActiveMovieCategories, "CLSID_ActiveMovieCategories"},
    {&CLSID_AnalogVideoDecoderPropertyPage, "CLSID_AnalogVideoDecoderPropertyPage"},
    {&CLSID_WMAsfReader, "CLSID_WMAsfReader"},
    {&CLSID_WMAsfWriter, "CLSID_WMAsfWriter"},
    {&CLSID_AsyncReader, "CLSID_AsyncReader"},
    {&CLSID_AudioCompressorCategory, "CLSID_AudioCompressorCategory"},
    {&CLSID_AudioInputDeviceCategory, "CLSID_AudioInputDeviceCategory"},
    {&CLSID_AudioProperties, "CLSID_AudioProperties"},
    {&CLSID_AudioRecord, "CLSID_AudioRecord"},
    {&CLSID_AudioRender, "CLSID_AudioRender"},
    {&CLSID_AudioRendererCategory, "CLSID_AudioRendererCategory"},
    {&CLSID_AviDest, "CLSID_AviDest"},
    {&CLSID_AviMuxProptyPage, "CLSID_AviMuxProptyPage"},
    {&CLSID_AviMuxProptyPage1, "CLSID_AviMuxProptyPage1"},
    {&CLSID_AviReader, "CLSID_AviReader"},
    {&CLSID_AviSplitter, "CLSID_AviSplitter"},
    {&CLSID_CAcmCoClassManager, "CLSID_CAcmCoClassManager"},
    {&CLSID_CDeviceMoniker, "CLSID_CDeviceMoniker"},
    {&CLSID_CIcmCoClassManager, "CLSID_CIcmCoClassManager"},
    {&CLSID_CMidiOutClassManager, "CLSID_CMidiOutClassManager"},
    {&CLSID_CMpegAudioCodec, "CLSID_CMpegAudioCodec"},
    {&CLSID_CMpegVideoCodec, "CLSID_CMpegVideoCodec"},
    {&CLSID_CQzFilterClassManager, "CLSID_CQzFilterClassManager"},
    {&CLSID_CVidCapClassManager, "CLSID_CVidCapClassManager"},
    {&CLSID_CWaveOutClassManager, "CLSID_CWaveOutClassManager"},
    {&CLSID_CWaveinClassManager, "CLSID_CWaveinClassManager"},
    {&CLSID_CameraControlPropertyPage, "CLSID_CameraControlPropertyPage"},
    {&CLSID_CaptureGraphBuilder, "CLSID_CaptureGraphBuilder"},
    {&CLSID_CaptureProperties, "CLSID_CaptureProperties"},
    {&CLSID_Colour, "CLSID_Colour"},
    {&CLSID_CrossbarFilterPropertyPage, "CLSID_CrossbarFilterPropertyPage"},
    {&CLSID_DSoundRender, "CLSID_DSoundRender"},
    {&CLSID_DVDHWDecodersCategory, "CLSID_DVDHWDecodersCategory"},
    {&CLSID_DVDNavigator, "CLSID_DVDNavigator"},
    {&CLSID_DVDecPropertiesPage, "CLSID_DVDecPropertiesPage"},
    {&CLSID_DVEncPropertiesPage, "CLSID_DVEncPropertiesPage"},
    {&CLSID_DVMux, "CLSID_DVMux"},
    {&CLSID_DVMuxPropertyPage, "CLSID_DVMuxPropertyPage"},
    {&CLSID_DVSplitter, "CLSID_DVSplitter"},
    {&CLSID_DVVideoCodec, "CLSID_DVVideoCodec"},
    {&CLSID_DVVideoEnc, "CLSID_DVVideoEnc"},
    {&CLSID_DirectDraw, "CLSID_DirectDraw"},
    {&CLSID_DirectDrawClipper, "CLSID_DirectDrawClipper"},
    {&CLSID_DirectDrawProperties, "CLSID_DirectDrawProperties"},
    {&CLSID_Dither, "CLSID_Dither"},
    {&CLSID_DvdGraphBuilder, "CLSID_DvdGraphBuilder"},
    {&CLSID_FGControl, "CLSID_FGControl"},
    {&CLSID_FileSource, "CLSID_FileSource"},
    {&CLSID_FileWriter, "CLSID_FileWriter"},
    {&CLSID_FilterGraph, "CLSID_FilterGraph"},
    {&CLSID_FilterGraphNoThread, "CLSID_FilterGraphNoThread"},
    {&CLSID_FilterMapper, "CLSID_FilterMapper"},
    {&CLSID_FilterMapper2, "CLSID_FilterMapper2"},
    {&CLSID_InfTee, "CLSID_InfTee"},
    {&CLSID_LegacyAmFilterCategory, "CLSID_LegacyAmFilterCategory"},
    {&CLSID_Line21Decoder, "CLSID_Line21Decoder"},
    {&CLSID_MOVReader, "CLSID_MOVReader"},
    {&CLSID_MPEG1Doc, "CLSID_MPEG1Doc"},
    {&CLSID_MPEG1PacketPlayer, "CLSID_MPEG1PacketPlayer"},
    {&CLSID_MPEG1Splitter, "CLSID_MPEG1Splitter"},
    {&CLSID_MediaPropertyBag, "CLSID_MediaPropertyBag"},
    {&CLSID_MemoryAllocator, "CLSID_MemoryAllocator"},
    {&CLSID_MidiRendererCategory, "CLSID_MidiRendererCategory"},
    {&CLSID_ModexProperties, "CLSID_ModexProperties"},
    {&CLSID_ModexRenderer, "CLSID_ModexRenderer"},
    {&CLSID_OverlayMixer, "CLSID_OverlayMixer"},
    {&CLSID_PerformanceProperties, "CLSID_PerformanceProperties"},
    {&CLSID_PersistMonikerPID, "CLSID_PersistMonikerPID"},
    {&CLSID_ProtoFilterGraph, "CLSID_ProtoFilterGraph"},
    {&CLSID_QualityProperties, "CLSID_QualityProperties"},
    {&CLSID_SeekingPassThru, "CLSID_SeekingPassThru"},
    {&CLSID_SmartTee, "CLSID_SmartTee"},
    {&CLSID_SystemClock, "CLSID_SystemClock"},
    {&CLSID_SystemDeviceEnum, "CLSID_SystemDeviceEnum"},
    {&CLSID_TVAudioFilterPropertyPage, "CLSID_TVAudioFilterPropertyPage"},
    {&CLSID_TVTunerFilterPropertyPage, "CLSID_TVTunerFilterPropertyPage"},
    {&CLSID_TextRender, "CLSID_TextRender"},
    {&CLSID_URLReader, "CLSID_URLReader"},
    {&CLSID_VBISurfaces, "CLSID_VBISurfaces"},
    {&CLSID_VPObject, "CLSID_VPObject"},
    {&CLSID_VPVBIObject, "CLSID_VPVBIObject"},
    {&CLSID_VfwCapture, "CLSID_VfwCapture"},
    {&CLSID_VideoCompressorCategory, "CLSID_VideoCompressorCategory"},
    {&CLSID_VideoInputDeviceCategory, "CLSID_VideoInputDeviceCategory"},
    {&CLSID_VideoProcAmpPropertyPage, "CLSID_VideoProcAmpPropertyPage"},
    {&CLSID_VideoRenderer, "CLSID_VideoRenderer"},
    {&CLSID_VideoStreamConfigPropertyPage, "CLSID_VideoStreamConfigPropertyPage"},
    {&FORMAT_AnalogVideo, "FORMAT_AnalogVideo"},
    {&FORMAT_DVD_LPCMAudio, "FORMAT_DVD_LPCMAudio"},
    {&FORMAT_DolbyAC3, "FORMAT_DolbyAC3"},
    {&FORMAT_DvInfo, "FORMAT_DvInfo"},
    {&FORMAT_MPEG2Audio, "FORMAT_MPEG2Audio"},
    {&FORMAT_MPEG2Video, "FORMAT_MPEG2Video"},
    {&FORMAT_MPEG2_VIDEO, "FORMAT_MPEG2_VIDEO"},
    {&FORMAT_MPEGStreams, "FORMAT_MPEGStreams"},
    {&FORMAT_MPEGVideo, "FORMAT_MPEGVideo"},
    {&FORMAT_None, "FORMAT_None"},
    {&FORMAT_VIDEOINFO2, "FORMAT_VIDEOINFO2"},
    {&FORMAT_VideoInfo, "FORMAT_VideoInfo"},
    {&FORMAT_VideoInfo2, "FORMAT_VideoInfo2"},
    {&FORMAT_WaveFormatEx, "FORMAT_WaveFormatEx"},
    {&IID_IAMDirectSound, "IID_IAMDirectSound"},
    {&IID_IAMLine21Decoder, "IID_IAMLine21Decoder"},
    {&IID_IBaseVideoMixer, "IID_IBaseVideoMixer"},
    {&IID_IDDVideoPortContainer, "IID_IDDVideoPortContainer"},
    {&IID_IDirectDraw, "IID_IDirectDraw"},
    {&IID_IDirectDraw2, "IID_IDirectDraw2"},
    {&IID_IDirectDrawClipper, "IID_IDirectDrawClipper"},
    {&IID_IDirectDrawColorControl, "IID_IDirectDrawColorControl"},
    {&IID_IDirectDrawKernel, "IID_IDirectDrawKernel"},
    {&IID_IDirectDrawPalette, "IID_IDirectDrawPalette"},
    {&IID_IDirectDrawSurface, "IID_IDirectDrawSurface"},
    {&IID_IDirectDrawSurface2, "IID_IDirectDrawSurface2"},
    {&IID_IDirectDrawSurface3, "IID_IDirectDrawSurface3"},
    {&IID_IDirectDrawSurfaceKernel, "IID_IDirectDrawSurfaceKernel"},
    {&IID_IDirectDrawVideo, "IID_IDirectDrawVideo"},
    {&IID_IFullScreenVideo, "IID_IFullScreenVideo"},
    {&IID_IFullScreenVideoEx, "IID_IFullScreenVideoEx"},
    {&IID_IKsDataTypeHandler, "IID_IKsDataTypeHandler"},
    {&IID_IKsInterfaceHandler, "IID_IKsInterfaceHandler"},
    {&IID_IKsPin, "IID_IKsPin"},
    {&IID_IMixerPinConfig, "IID_IMixerPinConfig"},
    {&IID_IMixerPinConfig2, "IID_IMixerPinConfig2"},
    {&IID_IMpegAudioDecoder, "IID_IMpegAudioDecoder"},
    {&IID_IQualProp, "IID_IQualProp"},
    {&IID_IVPConfig, "IID_IVPConfig"},
    {&IID_IVPControl, "IID_IVPControl"},
    {&IID_IVPNotify, "IID_IVPNotify"},
    {&IID_IVPNotify2, "IID_IVPNotify2"},
    {&IID_IVPObject, "IID_IVPObject"},
    {&IID_IVPVBIConfig, "IID_IVPVBIConfig"},
    {&IID_IVPVBINotify, "IID_IVPVBINotify"},
    {&IID_IVPVBIObject, "IID_IVPVBIObject"},
    {&LOOK_DOWNSTREAM_ONLY, "LOOK_DOWNSTREAM_ONLY"},
    {&LOOK_UPSTREAM_ONLY, "LOOK_UPSTREAM_ONLY"},
    {&MEDIASUBTYPE_AIFF, "MEDIASUBTYPE_AIFF"},
    {&MEDIASUBTYPE_AU, "MEDIASUBTYPE_AU"},
    {&MEDIASUBTYPE_AnalogVideo_NTSC_M, "MEDIASUBTYPE_AnalogVideo_NTSC_M"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_B, "MEDIASUBTYPE_AnalogVideo_PAL_B"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_D, "MEDIASUBTYPE_AnalogVideo_PAL_D"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_G, "MEDIASUBTYPE_AnalogVideo_PAL_G"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_H, "MEDIASUBTYPE_AnalogVideo_PAL_H"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_I, "MEDIASUBTYPE_AnalogVideo_PAL_I"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_M, "MEDIASUBTYPE_AnalogVideo_PAL_M"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_N, "MEDIASUBTYPE_AnalogVideo_PAL_N"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_B, "MEDIASUBTYPE_AnalogVideo_SECAM_B"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_D, "MEDIASUBTYPE_AnalogVideo_SECAM_D"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_G, "MEDIASUBTYPE_AnalogVideo_SECAM_G"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_H, "MEDIASUBTYPE_AnalogVideo_SECAM_H"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_K, "MEDIASUBTYPE_AnalogVideo_SECAM_K"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_K1, "MEDIASUBTYPE_AnalogVideo_SECAM_K1"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_L, "MEDIASUBTYPE_AnalogVideo_SECAM_L"},
    {&MEDIASUBTYPE_Asf, "MEDIASUBTYPE_Asf"},
    {&MEDIASUBTYPE_Avi, "MEDIASUBTYPE_Avi"},
    {&MEDIASUBTYPE_CFCC, "MEDIASUBTYPE_CFCC"},
    {&MEDIASUBTYPE_CLJR, "MEDIASUBTYPE_CLJR"},
    {&MEDIASUBTYPE_CPLA, "MEDIASUBTYPE_CPLA"},
    {&MEDIASUBTYPE_DOLBY_AC3, "MEDIASUBTYPE_DOLBY_AC3"},
    {&MEDIASUBTYPE_DVCS, "MEDIASUBTYPE_DVCS"},
    {&MEDIASUBTYPE_DVD_LPCM_AUDIO, "MEDIASUBTYPE_DVD_LPCM_AUDIO"},
    {&MEDIASUBTYPE_DVD_NAVIGATION_DSI, "MEDIASUBTYPE_DVD_NAVIGATION_DSI"},
    {&MEDIASUBTYPE_DVD_NAVIGATION_PCI, "MEDIASUBTYPE_DVD_NAVIGATION_PCI"},
    {&MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER, "MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER"},
    {&MEDIASUBTYPE_DVD_SUBPICTURE, "MEDIASUBTYPE_DVD_SUBPICTURE"},
    {&MEDIASUBTYPE_DVSD, "MEDIASUBTYPE_DVSD"},
    {&MEDIASUBTYPE_DssAudio, "MEDIASUBTYPE_DssAudio"},
    {&MEDIASUBTYPE_DssVideo, "MEDIASUBTYPE_DssVideo"},
    {&MEDIASUBTYPE_IF09, "MEDIASUBTYPE_IF09"},
    {&MEDIASUBTYPE_IJPG, "MEDIASUBTYPE_IJPG"},
    {&MEDIASUBTYPE_Line21_BytePair, "MEDIASUBTYPE_Line21_BytePair"},
    {&MEDIASUBTYPE_Line21_GOPPacket, "MEDIASUBTYPE_Line21_GOPPacket"},
    {&MEDIASUBTYPE_Line21_VBIRawData, "MEDIASUBTYPE_Line21_VBIRawData"},
    {&MEDIASUBTYPE_MDVF, "MEDIASUBTYPE_MDVF"},
    {&MEDIASUBTYPE_MJPG, "MEDIASUBTYPE_MJPG"},
    {&MEDIASUBTYPE_MPEG1Audio, "MEDIASUBTYPE_MPEG1Audio"},
    {&MEDIASUBTYPE_MPEG1AudioPayload, "MEDIASUBTYPE_MPEG1AudioPayload"},
    {&MEDIASUBTYPE_MPEG1Packet, "MEDIASUBTYPE_MPEG1Packet"},
    {&MEDIASUBTYPE_MPEG1Payload, "MEDIASUBTYPE_MPEG1Payload"},
    {&MEDIASUBTYPE_MPEG1System, "MEDIASUBTYPE_MPEG1System"},
    {&MEDIASUBTYPE_MPEG1Video, "MEDIASUBTYPE_MPEG1Video"},
    {&MEDIASUBTYPE_MPEG1VideoCD, "MEDIASUBTYPE_MPEG1VideoCD"},
    {&MEDIASUBTYPE_MPEG2_AUDIO, "MEDIASUBTYPE_MPEG2_AUDIO"},
    {&MEDIASUBTYPE_MPEG2_PROGRAM, "MEDIASUBTYPE_MPEG2_PROGRAM"},
    {&MEDIASUBTYPE_MPEG2_TRANSPORT, "MEDIASUBTYPE_MPEG2_TRANSPORT"},
    {&MEDIASUBTYPE_MPEG2_VIDEO, "MEDIASUBTYPE_MPEG2_VIDEO"},
    {&MEDIASUBTYPE_None, "MEDIASUBTYPE_None"},
    {&MEDIASUBTYPE_Overlay, "MEDIASUBTYPE_Overlay"},
    {&MEDIASUBTYPE_PCM, "MEDIASUBTYPE_PCM"},
    {&MEDIASUBTYPE_PCMAudio_Obsolete, "MEDIASUBTYPE_PCMAudio_Obsolete"},
    {&MEDIASUBTYPE_Plum, "MEDIASUBTYPE_Plum"},
    {&MEDIASUBTYPE_QTJpeg, "MEDIASUBTYPE_QTJpeg"},
    {&MEDIASUBTYPE_QTMovie, "MEDIASUBTYPE_QTMovie"},
    {&MEDIASUBTYPE_QTRle, "MEDIASUBTYPE_QTRle"},
    {&MEDIASUBTYPE_QTRpza, "MEDIASUBTYPE_QTRpza"},
    {&MEDIASUBTYPE_QTSmc, "MEDIASUBTYPE_QTSmc"},
    {&MEDIASUBTYPE_RGB1, "MEDIASUBTYPE_RGB1"},
    {&MEDIASUBTYPE_RGB24, "MEDIASUBTYPE_RGB24"},
    {&MEDIASUBTYPE_RGB32, "MEDIASUBTYPE_RGB32"},
    {&MEDIASUBTYPE_RGB4, "MEDIASUBTYPE_RGB4"},
    {&MEDIASUBTYPE_RGB555, "MEDIASUBTYPE_RGB555"},
    {&MEDIASUBTYPE_RGB565, "MEDIASUBTYPE_RGB565"},
    {&MEDIASUBTYPE_RGB8, "MEDIASUBTYPE_RGB8"},
    {&MEDIASUBTYPE_TVMJ, "MEDIASUBTYPE_TVMJ"},
    {&MEDIASUBTYPE_UYVY, "MEDIASUBTYPE_UYVY"},
    {&MEDIASUBTYPE_VPVBI, "MEDIASUBTYPE_VPVBI"},
    {&MEDIASUBTYPE_VPVideo, "MEDIASUBTYPE_VPVideo"},
    {&MEDIASUBTYPE_WAKE, "MEDIASUBTYPE_WAKE"},
    {&MEDIASUBTYPE_WAVE, "MEDIASUBTYPE_WAVE"},
    {&MEDIASUBTYPE_Y211, "MEDIASUBTYPE_Y211"},
    {&MEDIASUBTYPE_Y411, "MEDIASUBTYPE_Y411"},
    {&MEDIASUBTYPE_Y41P, "MEDIASUBTYPE_Y41P"},
    {&MEDIASUBTYPE_YUY2, "MEDIASUBTYPE_YUY2"},
    {&MEDIASUBTYPE_YV12, "MEDIASUBTYPE_YV12"},
    {&MEDIASUBTYPE_YVU9, "MEDIASUBTYPE_YVU9"},
    {&MEDIASUBTYPE_YVYU, "MEDIASUBTYPE_YVYU"},
    {&MEDIASUBTYPE_dvhd, "MEDIASUBTYPE_dvhd"},
    {&MEDIASUBTYPE_dvsd, "MEDIASUBTYPE_dvsd"},
    {&MEDIASUBTYPE_dvsl, "MEDIASUBTYPE_dvsl"},
    {&MEDIATYPE_AUXLine21Data, "MEDIATYPE_AUXLine21Data"},
    {&MEDIATYPE_AnalogAudio, "MEDIATYPE_AnalogAudio"},
    {&MEDIATYPE_AnalogVideo, "MEDIATYPE_AnalogVideo"},
    {&MEDIATYPE_Audio, "MEDIATYPE_Audio"},
    {&MEDIATYPE_DVD_ENCRYPTED_PACK, "MEDIATYPE_DVD_ENCRYPTED_PACK"},
    {&MEDIATYPE_DVD_NAVIGATION, "MEDIATYPE_DVD_NAVIGATION"},
    {&MEDIATYPE_File, "MEDIATYPE_File"},
    {&MEDIATYPE_Interleaved, "MEDIATYPE_Interleaved"},
    {&MEDIATYPE_LMRT, "MEDIATYPE_LMRT"},
    {&MEDIATYPE_MPEG1SystemStream, "MEDIATYPE_MPEG1SystemStream"},
    {&MEDIATYPE_MPEG2_PES, "MEDIATYPE_MPEG2_PES"},
    {&MEDIATYPE_Midi, "MEDIATYPE_Midi"},
    {&MEDIATYPE_ScriptCommand, "MEDIATYPE_ScriptCommand"},
    {&MEDIATYPE_Stream, "MEDIATYPE_Stream"},
    {&MEDIATYPE_Text, "MEDIATYPE_Text"},
    {&MEDIATYPE_Timecode, "MEDIATYPE_Timecode"},
    {&MEDIATYPE_URL_STREAM, "MEDIATYPE_URL_STREAM"},
    {&MEDIATYPE_Video, "MEDIATYPE_Video"},
    {&PIN_CATEGORY_ANALOGVIDEOIN, "PIN_CATEGORY_ANALOGVIDEOIN"},
    {&PIN_CATEGORY_CAPTURE, "PIN_CATEGORY_CAPTURE"},
    {&PIN_CATEGORY_CC, "PIN_CATEGORY_CC"},
    {&PIN_CATEGORY_EDS, "PIN_CATEGORY_EDS"},
    {&PIN_CATEGORY_NABTS, "PIN_CATEGORY_NABTS"},
    {&PIN_CATEGORY_PREVIEW, "PIN_CATEGORY_PREVIEW"},
    {&PIN_CATEGORY_STILL, "PIN_CATEGORY_STILL"},
    {&PIN_CATEGORY_TELETEXT, "PIN_CATEGORY_TELETEXT"},
    {&PIN_CATEGORY_TIMECODE, "PIN_CATEGORY_TIMECODE"},
    {&PIN_CATEGORY_VBI, "PIN_CATEGORY_VBI"},
    {&PIN_CATEGORY_VIDEOPORT, "PIN_CATEGORY_VIDEOPORT"},
    {&PIN_CATEGORY_VIDEOPORT_VBI, "PIN_CATEGORY_VIDEOPORT_VBI"},
    {&TIME_FORMAT_BYTE, "TIME_FORMAT_BYTE"},
    {&TIME_FORMAT_FIELD, "TIME_FORMAT_FIELD"},
    {&TIME_FORMAT_FRAME, "TIME_FORMAT_FRAME"},
    {&TIME_FORMAT_MEDIA_TIME, "TIME_FORMAT_MEDIA_TIME"},
    {&TIME_FORMAT_NONE, "TIME_FORMAT_NONE"},
    {&TIME_FORMAT_SAMPLE, "TIME_FORMAT_SAMPLE"},
};

//char * GuidToEnglish(const CLSID *const pclsid, char *buf)
char * GuidToEnglish(CLSID *pclsid, char *buf)
{
    WCHAR szGuid[39];
    StringFromGUID2(pclsid ? *pclsid : GUID_NULL, szGuid, 39);

    if(pclsid == 0)
    {
        wsprintf(buf, "%S", szGuid);
        return buf;
    }

    for(int i = 0; i < NUMELMS(rgng); i++)
    {
        if(*pclsid == *(rgng[i].pguid))
        {
            wsprintf(buf, "%s %S", rgng[i].psz, szGuid);
            return buf;
        }
    }
    if(FOURCCMap(pclsid->Data1) == *pclsid)
    {
        if(pclsid->Data1 > 0xffff)
        {
            wsprintf(buf, "fourcc (%08x) %c%c%c%c %S",
                     pclsid->Data1,
                     ((char *)pclsid)[0],
                     ((char *)pclsid)[1],
                     ((char *)pclsid)[2],
                     ((char *)pclsid)[3],
                     szGuid);
        }
        else
        {
            wsprintf(buf, "fourcc (%08x) %S",
                     pclsid->Data1,
                     szGuid);
        }
        return buf;
    }
    else
    {
        wsprintf(buf, "(%S)", szGuid);
        return buf;
    }

}




//  Helper to compare files - we should expand this
//  to compare media files
HRESULT CompareFiles(LPCTSTR pszFile1, LPCTSTR pszFile2)
{
    CTestFileRead File1;
    CTestFileRead File2;

    HRESULT hr = File1.Open(pszFile1);
    if (FAILED(hr)) {
        Error(ERROR_TYPE_TEST, 0, TEXT("Failed to open file(%s)"), pszFile1);
        return hr;
    }

    hr = File2.Open(pszFile2);
    if (FAILED(hr)) {
        Error(ERROR_TYPE_TEST, 0, TEXT("Failed to open file(%s)"), pszFile2);
        return hr;
    }

    for (; ; ) {
        HRESULT hr1 = File1.Next();
        if( FAILED( hr1 ) ) {
            return hr1;
        }

        HRESULT hr2 = File2.Next();
        if( FAILED( hr2 ) ) {
            return hr2;
        }

        if (S_FALSE == hr1 || S_FALSE == hr2) {
            if (hr1 != hr2) {
                Error(ERROR_TYPE_DMO, 0, TEXT("Different amounts of data"));
                break;
            } else {
                return S_OK;
            }            
        }

        if (File1.Header()->dwLength != File2.Header()->dwLength ||
            0 != memcmp(File1.Header(), File2.Header(), File1.Header()->dwLength)) {
            Error(ERROR_TYPE_DMO, 0, TEXT("Different entries at offset %d"),
                  (DWORD)File1.Offset());
            break;
        }
    }
    return hr;
}

//  Run the tests
//  How do we find out which DMO to test?
//  Easiest is probably a web page with the test in it??


extern "C" DWORD FunctionalTest1(LPSTR clsidStr, LPSTR szTestFile)
{
	DWORD dwresult = FNS_FAIL;
	CoInitialize(NULL);
    USES_CONVERSION;

	CLSID rclsidObject;
    HRESULT hr = CLSIDFromString(A2OLE(clsidStr), &rclsidObject);
    if (FAILED(hr)) {
        CoUninitialize();
        g_IShell->Log(1,"Test ERROR:First agrument must be the CLSID of the object to test\n");
		return dwresult;
    }
	g_IShell->Log(1, "\n**** Test File:  %s.****",  szTestFile);

    TCHAR szTempFile1[MAX_PATH];
	TCHAR szTempFile2[MAX_PATH];
    //  Create some temp files
    if (0 == GetTempFileName(TEXT("."),
                             TEXT("Out"),
                             0,
                             szTempFile1)) {
		g_IShell->Log(1, "TEST ERROR: Failed to create temp file");
        //return HRESULT_FROM_WIN32(GetLastError());
		return dwresult;
    }
    //  Create some temp files
    if (0 == GetTempFileName(TEXT("."),
                             TEXT("Out"),
                             0,
                             szTempFile2)) {
		g_IShell->Log(1, "TEST ERROR: Failed to create temp file");
        //return HRESULT_FROM_WIN32(GetLastError());
		return dwresult;
    }

    //  For now make a dialog by listing the DMOs by category

    //  Save the test data to file
    //  The compare a time shifted version
	g_IShell->Log(1, " **Process input file with no time shift.**");
    hr = CTestSaveToFile(rclsidObject, szTestFile, szTempFile1, 0).Save();

    if (SUCCEEDED(hr)) {
		g_IShell->Log(1, " **Process input file with positive time shift.**");
        HRESULT hr = CTestSaveToFile(rclsidObject, szTestFile, szTempFile2, 0x123456789AB).Save();
        if (SUCCEEDED(hr)) {
            //  See if they're the same
			g_IShell->Log(1, " **Compare the file with no time shift and the file with positive time shift.**");
            if (S_FALSE == CompareFiles(szTempFile1, szTempFile2)) {
                Error(ERROR_TYPE_DMO, E_FAIL,
                      TEXT("Failed positive timestamp offset test"));
				g_IShell->Log(1, "DMO ERROR: Failed positive timestamp offset test");
			}

			dwresult = FNS_PASS;
        }

    }


    DeleteFile(szTempFile1);
    DeleteFile(szTempFile2);

    return dwresult;
}





extern "C" DWORD FunctionalTest2(LPSTR clsidStr, LPSTR szTestFile)
{
	DWORD dwresult = FNS_FAIL;
	
	CoInitialize(NULL);
    USES_CONVERSION;


	CLSID rclsidObject;
    HRESULT hr = CLSIDFromString(A2OLE(clsidStr), &rclsidObject);
    if (FAILED(hr)) {
        CoUninitialize();
        g_IShell->Log(1,"Test ERROR:First agrument must be the CLSID of the object to test\n");
        return dwresult;
    }
	g_IShell->Log(1, "\n*** Test File:  %s.***",  szTestFile);
    TCHAR szTempFile1[MAX_PATH];
    TCHAR szTempFile2[MAX_PATH];
    //  Create some temp files
    if (0 == GetTempFileName(TEXT("."),
                             TEXT("Out"),
                             0,
                             szTempFile1)) {
		g_IShell->Log(1, "TEST ERROR: Failed to create temp file");
        //return HRESULT_FROM_WIN32(GetLastError());
		return dwresult;
    }
    if (0 == GetTempFileName(TEXT("."),
                             TEXT("Out"),
                             0,
                             szTempFile2)) {
        //Error(ERROR_TYPE_TEST, E_FAIL, TEXT("Failed to create temp file"));
		g_IShell->Log(1, "TEST ERROR: Failed to create temp file");
        //return HRESULT_FROM_WIN32(GetLastError());
		return dwresult;
    }


    //  For now make a dialog by listing the DMOs by category

    //  Save the test data to file
    //  The compare a time shifted version
	g_IShell->Log(1, " **Process input file with no time shift.**");
    hr = CTestSaveToFile(rclsidObject, szTestFile, szTempFile1, 0).Save();
    if (SUCCEEDED(hr)) {
		g_IShell->Log(1, " **Process input file with negative time shift.**");
        HRESULT hr = CTestSaveToFile(rclsidObject, szTestFile, szTempFile2, -0x123456789AB).Save();
		if (SUCCEEDED(hr)) {
			//  See if they're the same
			g_IShell->Log(1, " **Compare the file with no time shift and the file with positive time shift.**");
			if (S_FALSE == CompareFiles(szTempFile1, szTempFile2)) {
				Error(ERROR_TYPE_DMO, E_FAIL,
					  TEXT("Failed negative timestamp offset test"));
				g_IShell->Log(1, "DMO ERROR: Failed negative timestamp offset test");
			}
			dwresult = FNS_PASS;	
		}
    }


    DeleteFile(szTempFile1);
    DeleteFile(szTempFile2);

    return dwresult;
}





/******************************************************************************

Test_GetStreamCount

    Test_GetStreamCount() preforms a series of tests to ensure the DMO 
supports correctly inplements IMediaObject::GetStreamCount().

Parameters:
- pDMO [in]
    The Direct Media Object (DMO) being tested.

Return Value:
        S_OK - The DMO successfully passed the tests.
        S_FALSE - The DMO failed one or more tests.
        If an unexpected error occurs, an error HRESULT is returned.

******************************************************************************/
extern "C" DWORD TestGetStreamCount( LPSTR clsidStr )
{
	DWORD dwresult = FNS_FAIL;

	g_IShell->Log(1, "Starting Invalid Parameter Test on GetStreamCount() ...\n");

	CoInitialize(NULL);
    USES_CONVERSION;


    /*  CLSID passed in */
    CLSID clsid;
    HRESULT hr = CLSIDFromString(A2OLE(clsidStr), &clsid);
    if (FAILED(hr)) {
        CoUninitialize();
        g_IShell->Log(1,"TEST ERROR:First agrument must be the CLSID of the object to test\n");
        return dwresult;
    }

    CComPtr<IMediaObject> pDMO;

    hr = CoCreateInstance( clsid,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IMediaObject,
                           (void**)&pDMO );
    if( FAILED( hr ) ) {
        CoUninitialize();
        g_IShell->Log(1,"Failed in CoCreateInstance\n");
        return dwresult;  
    }

    CGetStreamCountNPT cGetStreamCountNPT( pDMO );

    hr = cGetStreamCountNPT.RunTests();
	
	if( FAILED( hr ) ) {
        CoUninitialize();
        g_IShell->Log(1,"DMO ERROR: Failed in GetStreamCount().hr = %#08x\n", hr);
        return dwresult;  
    }

	CoUninitialize();

	dwresult = FNS_PASS;
	return dwresult;
}

extern "C" DWORD TestGetTypes( LPSTR clsidStr )
{
	DWORD dwresult = FNS_FAIL;
	g_IShell->Log(1, "Starting Invalid Parameter Test on GetStreamType ...\n");

	CoInitialize(NULL);
    USES_CONVERSION;


    /*  CLSID passed in */
    CLSID clsid;
    HRESULT hr = CLSIDFromString(A2OLE(clsidStr), &clsid);
    if (FAILED(hr)) {
        CoUninitialize();
        g_IShell->Log(1,"First agrument must be the CLSID of the object to test\n");
        return dwresult;
    }

    CComPtr<IMediaObject> pDMO;

    hr = CoCreateInstance( clsid,
                                   NULL,
                                   CLSCTX_INPROC,
                                   IID_IMediaObject,
                                   (void**)&pDMO );
    if( FAILED( hr ) ) {
        CoUninitialize();
        g_IShell->Log(1,"Failed in CoCreateInstance\n");
        return dwresult;  
    }


    // CGetInputTypesInvalidStreamTest::CGetInputTypesInvalidStreamTest() only modifies hr if an error occurs.
    hr = S_OK;

    CGetInputTypesInvalidStreamTest cGetInputTypeTestInvalidStreams( pDMO, &hr );
	if( FAILED( hr ) ) {
        CoUninitialize();
        g_IShell->Log(1,"TEST ERROR: Failed in CGetInputTypesInvalidStreamTest\n");
        return dwresult;
    }

    hr = cGetInputTypeTestInvalidStreams.RunTests();
	if( FAILED( hr ) ) {
        CoUninitialize();
        g_IShell->Log(1,"DMO ERROR: Failed in GetStreamType().hr = %#08x\n", hr);
        return dwresult;
    }
	CoUninitialize();

	dwresult = FNS_PASS;
	return dwresult;
}

/******************************************************************************

TestGetStreamInfo

    TestGetStreamInfo() preforms a series of tests to ensure the DMO 
supports correctly inplements IMediaObject::GetInputStreamInfo() and 
IMediaObject::GetOutputStreamInfo().

Parameters:
- pDMO [in]
    The Direct Media Object (DMO) being tested.

Return Value:
        S_OK - The DMO successfully passed the tests.
        S_FALSE - The DMO failed one or more tests.
        If an unexpected error occurs, an error HRESULT is returned.

******************************************************************************/
extern "C" DWORD TestStreamIndexOnGetInputStreamInfo( LPSTR clsidStr )
{
	DWORD dwresult = FNS_FAIL;
    g_IShell->Log(1, "\nStarting Stream Index Tests on GetInputStreamInfo ...");
	CoInitialize(NULL);
    USES_CONVERSION;


    /*  CLSID passed in */
    CLSID clsid;
    HRESULT hr = CLSIDFromString(A2OLE(clsidStr), &clsid);
    if (FAILED(hr)) {
        CoUninitialize();
        g_IShell->Log(1,"First agrument must be the CLSID of the object to test\n");
		return dwresult;
    }



    CComPtr<IMediaObject> pDMO;
    hr = CoCreateInstance( clsid,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IMediaObject,
                           (void**)&pDMO );
    if( FAILED( hr ) ) {
        CoUninitialize();
        g_IShell->Log(1,"Failed in CoCreateInstance\n");
		return dwresult;
    }

    // CSITGetInputStreamInfo::CSITGetInputStreamInfo() only modifies hr if an error occurs.
    hr = S_OK;
    
    CSITGetInputStreamInfo cGetInputStreamInfoStreamIndexTests( pDMO, &hr );
    if( FAILED( hr ) ) {
		g_IShell->Log(1,"TEST ERROR: Failed in creating CSITGetInputStreamInfo. hr = %#08x\n", hr);
        return dwresult;
    }

    HRESULT hrTestResults = S_OK;
    hr = cGetInputStreamInfoStreamIndexTests.RunTests();
    if( FAILED( hr ) ) {
        return dwresult;
    } else if( S_FALSE == hr ) {
        hrTestResults = S_FALSE;
    }


  	CoUninitialize();  

	dwresult = FNS_PASS;
    return dwresult;
}
/******************************************************************************

TestGetStreamInfo

    TestGetStreamInfo() preforms a series of tests to ensure the DMO 
supports correctly inplements IMediaObject::GetInputStreamInfo() and 
IMediaObject::GetOutputStreamInfo().

Parameters:
- pDMO [in]
    The Direct Media Object (DMO) being tested.

Return Value:
        S_OK - The DMO successfully passed the tests.
        S_FALSE - The DMO failed one or more tests.
        If an unexpected error occurs, an error HRESULT is returned.

******************************************************************************/

extern "C" DWORD TestStreamIndexOnGetOutputStreamInfo( LPSTR clsidStr )
{
	DWORD dwresult = FNS_FAIL;
    g_IShell->Log(1, "\nStarting Stream Index Tests on GetOutputputStreamInfo ...");
	CoInitialize(NULL);
    USES_CONVERSION;


    /*  CLSID passed in */
    CLSID clsid;
    HRESULT hr = CLSIDFromString(A2OLE(clsidStr), &clsid);
    if (FAILED(hr)) {
        CoUninitialize();
        g_IShell->Log(1,"First agrument must be the CLSID of the object to test\n");
		return dwresult;
    }

    CComPtr<IMediaObject> pDMO;

    hr = CoCreateInstance( clsid,
                                   NULL,
                                   CLSCTX_INPROC,
                                   IID_IMediaObject,
                                   (void**)&pDMO );
    if( FAILED( hr ) ) {
        CoUninitialize();
        g_IShell->Log(1,"Failed in CoCreateInstance\n");
		return dwresult;
    }


    // CSITGetOutputStreamInfo::CSITGetOutputStreamInfo() only modifies hr if an error occurs.
    hr = S_OK;

    CSITGetOutputStreamInfo cGetOutputStreamInfoStreamIndexTests( pDMO, &hr );
    if( FAILED( hr ) ) {
		g_IShell->Log(1,"TEST ERROR: Failed in creating CSITGetOutputStreamInfo. hr = %#08x\n", hr);
        return dwresult;
    }


    HRESULT hrTestResults = S_OK;

    hr = cGetOutputStreamInfoStreamIndexTests.RunTests();
    if( FAILED( hr ) ) {
        return dwresult;
    } else if( S_FALSE == hr ) {
       hrTestResults = S_FALSE;
    }

  	CoUninitialize();  

	dwresult = FNS_PASS;
    return dwresult;
}


/******************************************************************************

TestGetStreamInfo

    TestGetStreamInfo() preforms a series of tests to ensure the DMO 
supports correctly inplements IMediaObject::GetInputStreamInfo() and 
IMediaObject::GetOutputStreamInfo().

Parameters:
- pDMO [in]
    The Direct Media Object (DMO) being tested.

Return Value:
        S_OK - The DMO successfully passed the tests.
        S_FALSE - The DMO failed one or more tests.
        If an unexpected error occurs, an error HRESULT is returned.

******************************************************************************/
extern "C" DWORD TestInvalidParamOnGetInputStreamInfo( LPSTR clsidStr )
{
	DWORD dwresult = FNS_FAIL;
	g_IShell->Log(1, "\nStarting Invalid Parameter Test on GetInputStreamInfo ...");
	CoInitialize(NULL);
    USES_CONVERSION;


    /*  CLSID passed in */
    CLSID clsid;
    HRESULT hr = CLSIDFromString(A2OLE(clsidStr), &clsid);
    if (FAILED(hr)) {
        CoUninitialize();
        g_IShell->Log(1,"First agrument must be the CLSID of the object to test\n");
		return dwresult;
    }

    CComPtr<IMediaObject> pDMO;

    hr = CoCreateInstance( clsid,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IMediaObject,
                           (void**)&pDMO );
    if( FAILED( hr ) ) {
        CoUninitialize();
        g_IShell->Log(1,"Failed in CoCreateInstance\n");
		return dwresult;
    }


    DWORD dwCurrentStream;
    DWORD dwNumInputStreams;
    DWORD dwNumOutputStreams;

    hr = pDMO->GetStreamCount( &dwNumInputStreams, &dwNumOutputStreams );
    if( FAILED( hr ) ) {
        g_IShell->Log(1,"Failed in GetStreamCount()\n");
        return dwresult;
    }

	HRESULT hrTestResults = S_OK;

    for( dwCurrentStream = 0; dwCurrentStream < dwNumInputStreams; dwCurrentStream++ ) {
		g_IShell->Log(1, "Input stream %d:", dwCurrentStream);
        CGetStreamInfoNPT cGetInputStreamInfoNullParameterTests( pDMO, ST_INPUT_STREAM, dwCurrentStream );
        hr = cGetInputStreamInfoNullParameterTests.RunTests();
        if( FAILED( hr ) ) {
            return dwresult;
        } else if( S_FALSE == hr ) {
            hrTestResults = S_FALSE;
        }
    }

  	CoUninitialize();  

	dwresult = FNS_PASS;
    return dwresult;
}


/******************************************************************************

TestGetStreamInfo

    TestGetStreamInfo() preforms a series of tests to ensure the DMO 
supports correctly inplements IMediaObject::GetInputStreamInfo() and 
IMediaObject::GetOutputStreamInfo().

Parameters:
- pDMO [in]
    The Direct Media Object (DMO) being tested.

Return Value:
        S_OK - The DMO successfully passed the tests.
        S_FALSE - The DMO failed one or more tests.
        If an unexpected error occurs, an error HRESULT is returned.

******************************************************************************/
extern "C" DWORD TestInvalidParamOnGetOutputStreamInfo( LPSTR clsidStr )
{
	DWORD dwresult = FNS_FAIL;
	g_IShell->Log(1, "\nStarting Invalid Parameter Test on GetOutputStreamInfo ...");
	CoInitialize(NULL);
    USES_CONVERSION;

    /*  CLSID passed in */
    CLSID clsid;
    HRESULT hr = CLSIDFromString(A2OLE(clsidStr), &clsid);
    if (FAILED(hr)) {
        CoUninitialize();
        g_IShell->Log(1,"First agrument must be the CLSID of the object to test\n");
		return dwresult;
    }

    CComPtr<IMediaObject> pDMO;

    hr = CoCreateInstance( clsid,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IMediaObject,
                           (void**)&pDMO );
    if( FAILED( hr ) ) {
        CoUninitialize();
        g_IShell->Log(1,"Failed in CoCreateInstance\n");
		return dwresult;
    }


    DWORD dwCurrentStream;
    DWORD dwNumInputStreams;
    DWORD dwNumOutputStreams;

    hr = pDMO->GetStreamCount( &dwNumInputStreams, &dwNumOutputStreams );
    if( FAILED( hr ) ) {
        g_IShell->Log(1,"Failed in GetStreamCount().\n");
        return dwresult;
    }

	HRESULT hrTestResults = S_OK;



    for( dwCurrentStream = 0; dwCurrentStream < dwNumOutputStreams; dwCurrentStream++ ) {

		g_IShell->Log(1, "Output stream %d:", dwCurrentStream);
        CGetStreamInfoNPT cGetOutputStreamInfo( pDMO, ST_OUTPUT_STREAM, dwCurrentStream );
        hr = cGetOutputStreamInfo.RunTests();
        if( FAILED( hr ) ) {
            return dwresult;
        } else if( S_FALSE == hr ) {
            hrTestResults = S_FALSE;
        }
    }
  	CoUninitialize();  

	dwresult = FNS_PASS;
    return dwresult;
}




extern "C" DWORD OutputDMOs( int* iNumDmo, DMOINFO* rdmoinfo)
{
	USES_CONVERSION;
	HRESULT hr = ::CoInitialize(0); 
    if( FAILED( hr ) ) {
		g_IShell->Log(1, " CoInitialize() failed.");
        return hr;
    } 

    #ifdef ENABLE_SECURE_DMO
    // wmsdk not supported on non-x86 and WIN64 platforms, for those just return success
    #ifdef _X86
    //::wprintf( L"Secure DMO support has been enabled.\n" );
	g_IShell->Log(1, "\nSecure DMO support has been enabled.\n");
    #endif _X86
    #endif // ENABLE_SECURE_DMO


    IEnumDMO* pEveryRegisterDMOEnum; 

    // Enerate all the registered DMOs.
    hr = DMOEnum( GUID_NULL,
                          DMO_ENUMF_INCLUDE_KEYED,
                          0, // Number of input partial media types.
                          NULL,
                          0, // Number of output partial media types.
                          NULL,
                          &pEveryRegisterDMOEnum );
    if( FAILED( hr ) ) {
		g_IShell->Log(1, "DMOEnum() failed.");
        return hr;
    }

    HRESULT hrNext;
    ULONG ulNumInfoReturned;
    CLSID aclsidCurrentDMO[1];
	LPOLESTR szCLSID;

    WCHAR* apszDMOName[1];

	g_IShell->Log(1, "*****outputDMOs");

    do
    {
        hrNext = pEveryRegisterDMOEnum->Next( 1, aclsidCurrentDMO, apszDMOName, &ulNumInfoReturned );
        if( FAILED( hrNext ) ) {
            pEveryRegisterDMOEnum->Release();
            return hrNext;
        }
    
        if( S_OK == hrNext ) {

			hr = StringFromCLSID( aclsidCurrentDMO[0], &szCLSID );
			if( FAILED( hr ) ) {
				//wprintf( L"ERROR: An error occured converting %s's clsid to a string.  StringFromCLSID() returned %#010x\n", apszDMOName[0], hr );
				g_IShell->Log(1, "TEST ERROR: An error occured converting %s's clsid to a string.  StringFromCLSID() returned %#010x\n", apszDMOName[0], hr );
				return 0;
			}

		lstrcpy(rdmoinfo[*iNumDmo].szName,  W2A(apszDMOName[0]));
		lstrcpy(rdmoinfo[*iNumDmo].szClsId , W2A(szCLSID)) ;

 			
		(*iNumDmo)++;

		::CoTaskMemFree( apszDMOName[0] );
		::CoTaskMemFree( szCLSID );
        }

    } while( S_OK == hrNext );

    pEveryRegisterDMOEnum->Release();

	CoUninitialize();
    return 0;
}







//extern "C" DWORD GetDmoTypeInfo( LPSTR clsidStr, String pLineStr[], int* iLineNum)
extern "C" DWORD GetDmoTypeInfo( LPSTR clsidStr,HWND MediaTypeList)
{
	DWORD dwresult = FNS_FAIL;
	
	CoInitialize(NULL);
    USES_CONVERSION;

	
    //  CLSID passed in 
    CLSID clsid;
    HRESULT hr = CLSIDFromString(A2OLE(clsidStr), &clsid);
    if (FAILED(hr)) {
        CoUninitialize();
        g_IShell->Log(1,"First agrument must be the CLSID of the object to test\n");
		return dwresult;
    }

    CComPtr<IMediaObject> pDMO;

    hr = CoCreateInstance( clsid,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IMediaObject,
                           (void**)&pDMO );
    if( FAILED( hr ) ) {
        CoUninitialize();
        g_IShell->Log(1,"Failed in CoCreateInstance\n");
		return dwresult;
    }


    DWORD dwNumInputStreams;
    DWORD dwNumOutputStreams;
	DWORD type;

	DMO_MEDIA_TYPE mt;


    hr = pDMO->GetStreamCount( &dwNumInputStreams, &dwNumOutputStreams );
    if( FAILED( hr ) ) {
        g_IShell->Log(1,"Failed in GetStreamCount()\n");
        return dwresult;
    }


	char buffer[1024];

	for (DWORD i = 0; i < dwNumInputStreams; i++)
	{
		type = 0;

		g_IShell->Log(1, "*Input stream %d:", i);
		wsprintf(buffer, "*Input stream %d:", i);
		SendMessage(MediaTypeList, LB_ADDSTRING, 0, (LPARAM) buffer);


	//	while ( !FAILED(dwresult=pDMO->GetInputType(i, type, &mt) ) )
		for(;;)
		{
			SAFE_CALL( pDMO, GetInputType( i, type, &mt ) );

			if(  hr == DMO_E_NO_MORE_ITEMS  ) {
				break;
			}
			g_IShell->Log(1, "  type %d's majortype = %s", type, CNV_GUID(&(mt.majortype)));
			wsprintf(buffer, "  type %d's majortype = %s", type, CNV_GUID(&(mt.majortype)));
			SendMessage(MediaTypeList, LB_ADDSTRING, 0, (LPARAM) buffer);	
			
			g_IShell->Log(1, "  type %d's subtype = %s", type, CNV_GUID(&(mt.subtype)));
			wsprintf(buffer, "  type %d's subtype = %s", type, CNV_GUID(&(mt.subtype)));
			SendMessage(MediaTypeList, LB_ADDSTRING, 0, (LPARAM) buffer);
			
			MoFreeMediaType(&mt);
			
			type++;
		}
	}

/*	
	DMO_MEDIA_TYPE out_mt;


	for (i = 0; i < dwNumOutputStreams; i++)
	{
		type = 0;

		g_IShell->Log(1, "*Output stream %d:", i);
		wsprintf(buffer, "*Output stream %d:", i);
		SendMessage(MediaTypeList, LB_ADDSTRING, 0, (LPARAM) buffer);

	//	while ( (dwresult =pDMO->GetOutputType(i, type, &out_mt)) != DMO_E_NO_MORE_ITEMS)
		for(;;)
		{
			SAFE_CALL( pDMO, GetOutputType( i, type, &out_mt ) );
			if( hr == DMO_E_NO_MORE_ITEMS ) {
				break;
			}
			g_IShell->Log(1, "  type %d's majortype = %s", type, CNV_GUID(&(out_mt.majortype)));
			wsprintf(buffer, "  type %d's majortype = %s", type, CNV_GUID(&(out_mt.majortype)));
			SendMessage(MediaTypeList, LB_ADDSTRING, 0, (LPARAM) buffer);

			g_IShell->Log(1, "  type %d's subtype = %s", type, CNV_GUID(&(out_mt.subtype)));
			wsprintf(buffer, "  type %d's subtype = %s", type, CNV_GUID(&(out_mt.subtype)));
			SendMessage(MediaTypeList, LB_ADDSTRING, 0, (LPARAM) buffer);
		

			MoFreeMediaType(&out_mt);
			
			type++;
		}
	}
*/
  	CoUninitialize();  

	dwresult = FNS_PASS;
    return dwresult;
}



/******************************************************************************

TestGetStreamInfo

    TestGetStreamInfo() preforms a series of tests to ensure the DMO 
supports correctly inplements IMediaObject::GetInputStreamInfo() and 
IMediaObject::GetOutputStreamInfo().

Parameters:
- pDMO [in]
    The Direct Media Object (DMO) being tested.

Return Value:
        S_OK - The DMO successfully passed the tests.
        S_FALSE - The DMO failed one or more tests.
        If an unexpected error occurs, an error HRESULT is returned.

******************************************************************************/
extern "C" DWORD TestZeroSizeBuffer( LPSTR clsidStr )
{
	DWORD dwresult = FNS_FAIL;
	g_IShell->Log(1, "\nStarting Zero Size Buffer Test ...");
	CoInitialize(NULL);
    USES_CONVERSION;

    /*  CLSID passed in */
    CLSID clsid;
    HRESULT hr = CLSIDFromString(A2OLE(clsidStr), &clsid);
    if (FAILED(hr)) {
        CoUninitialize();
        g_IShell->Log(1,"First agrument must be the CLSID of the object to test\n");
		return dwresult;
    }
/*
    CComPtr<IMediaObject> pDMO;

    hr = CoCreateInstance( clsid,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IMediaObject,
                           (void**)&pDMO );
    if( FAILED( hr ) ) {
        CoUninitialize();
        g_IShell->Log(1,"Failed in CoCreateInstance\n");
		return dwresult;
    }
*/

	CDMOObject *pObject;
	pObject = new CDMOObject;
	if(pObject == NULL){
		CoUninitialize();
		g_IShell->Log(1,"Not enough memory\n");
		return E_OUTOFMEMORY;
	}
	pObject->Create( clsid, FALSE );












	// allocates input buffers:
    //  First create an IMediaBuffer
	DWORD cbData = 0;
    CMediaBuffer *pInputBuffer;
    hr = pObject->CreateInputBuffer(cbData, &pInputBuffer);
    if (FAILED(hr)) {
        return hr;
    }
	// fills the input buffers with input data and calls ProcessInput
    pInputBuffer->m_cbLength = cbData;

	DWORD dwFlags = 0;
    LONGLONG llStartTime = 0;
    LONGLONG llLength = 0;
	DWORD dwStreamId = 0;


    hr = pObject->ProcessInput(dwStreamId,
                                 pInputBuffer,
                                 dwFlags,
                                 llStartTime,
                                 llLength);

    //  BUGBUG check ref count

    pInputBuffer->Release();
/*    if (hr == DMO_E_NOTACCEPTING) {
        //Error(ERROR_TYPE_DMO, hr, TEXT("ProcessInput failed"));
		g_IShell->Log(1, "DMO ERROR: ProcessInput() Failed. hr =%#08x", hr);
      
    }

    //  Now suck any data out
    if (S_FALSE == hr) {
        //  No data to process
		g_IShell->Log(1, "No data to process. ProcessOutput() will not be called.");
    } 
	else */
    if (SUCCEEDED(hr) || hr == DMO_E_NOTACCEPTING) 	
	{
		//g_IShell->Log(1, "DMO ERROR: ProcessInput() succeeded . hr =%#08x", hr);

		// calls ProcessOutput and retrieves the output data
        hr = ProcessOutputs(pObject);
    }


  	CoUninitialize();  

	dwresult = FNS_PASS;
    return dwresult;
}

HRESULT ProcessOutputs(CDMOObject *m_pObject)
{
    HRESULT hr = S_OK;
    //  Filter out other success codes??

	


    //  Find the number of output streams

    DWORD cInputStreams, cOutputStreams;
    hr = m_pObject->GetStreamCount(&cInputStreams, &cOutputStreams);
	if(cOutputStreams >=1)
		cOutputStreams = 1;

 
    CMediaBuffer **ppOutputBuffers =
        (CMediaBuffer **)_alloca(cOutputStreams * sizeof(CMediaBuffer*));

    //  Create the regular structures
    DMO_OUTPUT_DATA_BUFFER *pDataBuffers =
        (DMO_OUTPUT_DATA_BUFFER *)
        _alloca(cOutputStreams * sizeof(DMO_OUTPUT_DATA_BUFFER));

    for (DWORD dwOutputStreamIndex = 0; dwOutputStreamIndex < cOutputStreams;
         dwOutputStreamIndex++) {

         //  Get the expected buffer sizes - need to test these
         //  don't change between type changes
         DWORD dwOutputBufferSize;
         DWORD dwOutputAlignment;
         hr = m_pObject->GetOutputSizeInfo(dwOutputStreamIndex,
                                           &dwOutputBufferSize,
                                           &dwOutputAlignment);
         if (FAILED(hr)) {
             //Error(ERROR_TYPE_DMO, hr, TEXT("Failed to get output size info"));
			 g_IShell->Log(1, "DMO ERROR, Failed in GetOutputSizeInfo(). hr=%#08x", hr);
             break;
         }


         hr = CreateBuffer(
                   dwOutputBufferSize,
                   &ppOutputBuffers[dwOutputStreamIndex]);
         if (FAILED(hr)) {
			 g_IShell->Log(1, "TEST ERROR: Out of Memory.");
             break;
         }
         pDataBuffers[dwOutputStreamIndex].pBuffer =
             ppOutputBuffers[dwOutputStreamIndex];
         pDataBuffers[dwOutputStreamIndex].dwStatus = 0xFFFFFFFF;
         pDataBuffers[dwOutputStreamIndex].rtTimestamp = -1;
         pDataBuffers[dwOutputStreamIndex].rtTimelength = -1;
    }

    //  Process until no more data
    BOOL bContinue;
    if (SUCCEEDED(hr)) do
    {
        if (SUCCEEDED(hr)) {
            DWORD dwStatus;
            hr = m_pObject->ProcessOutput(
                0,
                cOutputStreams,
                pDataBuffers,
                &dwStatus);

            if (FAILED(hr)) {
                //Error(ERROR_TYPE_DMO, hr, TEXT("ProcessOutput failed"));
				g_IShell->Log(1, "DMO ERROR, ProcessOutput() failed. hr = %#08x", hr);
				return hr;
            }
        }

        // IMediaObject::ProcessOutput() returns S_FALSE if there is not more data to process.
   /*     if (SUCCEEDED(hr) && (S_FALSE != hr)) {
            for (DWORD dwIndex = 0; dwIndex < cOutputStreams; dwIndex++ ) {
                hr = ProcessOutput(dwIndex,
                                   pDataBuffers[dwIndex].dwStatus,
                                   ppOutputBuffers[dwIndex]->m_pbData,
                                   ppOutputBuffers[dwIndex]->m_cbLength,
                                   pDataBuffers[dwIndex].rtTimestamp,
                                   pDataBuffers[dwIndex].rtTimelength);
                if (FAILED(hr)) {
					g_IShell->Log(1, "DMO ERROR, ProcessOutput() failed. hr=%#08x",hr);
                    return hr;
                }

                hr = pDataBuffers[dwIndex].pBuffer->SetLength( 0 );
                if (FAILED(hr)) {
                    break;
                }
            }
            if (FAILED(hr)) {
                break;
            }
        }*/

        //  Continue if any stream says its incomplete
        bContinue = FALSE;
        for (DWORD dwIndex = 0; dwIndex < cOutputStreams; dwIndex++) {
            if (pDataBuffers[dwIndex].dwStatus &
                DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE) {
                bContinue = TRUE;
            }
        }
    } while (bContinue);
    //  Free any buffers we allocated
    for (DWORD dwIndex = 0; dwIndex < dwOutputStreamIndex; dwIndex++) {
        ppOutputBuffers[dwIndex]->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\dmoapitst.h ===
#ifndef TSTMAIN_H
#define TSTMAIN_H

#include <stdio.h>
#include <windows.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>
#include <initguid.h>
#include <mediaobj.h>
#include <streams.h>
#include <dmoreg.h>
#include <filefmt.h>
#include <filerw.h>
#include <s98inc.h>
#include <tchar.h>
#include "dmort.h"

#include "testobj.h"
#include "tests.h"
#include "Error.h"
#include "TstGSI.h"
#include "NPTST.h" 
#include "GTIVST.h"

typedef char *String;
typedef struct tagDMOINFO
{
	char szName[30];
	char szClsId[100];
//	char szNumInputStreams[10];
 //   char szNumOutputStreams[10];
}DMOINFO;



enum DMO_TEST_CASE_FLAGS {
    DMO_TEST_ACCEPT_DATA_FLAG				= 0x00000001
 //   DMO_TEST_DATA_BUFFERF_TIME            = 0x00000002,
 //   DMO_TEST_DATA_BUFFERF_TIMELENGTH      = 0x00000004
};



//static void DisplayBasicInformation( const CLSID& clsidDMO );

//  Helper to compare files - we should expand this
//  to compare media files
HRESULT CompareFiles(LPCTSTR pszFile1, LPCTSTR pszFile2);

//extern "C" DWORD tstmain(LPSTR clsidStr, LPSTR fileName);


//extern "C" DWORD GetDmoTypeInfo( LPSTR clsidStr, String pLineStr[], int *iLineNum );
extern "C" DWORD GetDmoTypeInfo( LPSTR clsidStr, HWND MediaTypeList );


extern "C" DWORD TestGetStreamCount( LPSTR clsid );

extern "C" DWORD TestGetTypes( LPSTR clsidStr );

extern "C" DWORD FunctionalTest1(LPSTR clsidStr, LPSTR szTestFile);
extern "C" DWORD FunctionalTest2(LPSTR clsidStr, LPSTR szTestFile);

extern "C" DWORD TestStreamIndexOnGetInputStreamInfo( LPSTR clsidStr);
extern "C" DWORD TestStreamIndexOnGetOutputStreamInfo( LPSTR clsidStr );

extern "C" DWORD TestInvalidParamOnGetInputStreamInfo( LPSTR clsidStr );
extern "C" DWORD TestInvalidParamOnGetOutputStreamInfo( LPSTR clsidStr );

extern "C" DWORD OutputDMOs(int* iNumDmo, DMOINFO* rdmoinfo);

extern "C" DWORD TestZeroSizeBuffer( LPSTR clsidStr );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\gtivst.h ===
#ifndef GetTypesInvalidStreamTest_h
#define GetTypesInvalidStreamTest_h

#include "IVSTRM.h"

class CGetInputTypesInvalidStreamTest : public CInputStreamIndexTests
{
public:
    CGetInputTypesInvalidStreamTest( IMediaObject* pDMO, HRESULT* phr );

private:
    HRESULT PreformOperation( DWORD dwStreamIndex );
    const TCHAR* GetOperationName( void ) const;

    HRESULT GetNumTypes( IMediaObject* pDMO, DWORD dwStreamIndex, DWORD* pdwNumMediaTypes );
    HRESULT PreformOperation( IMediaObject* pDMO, DWORD dwNumMediaTypes, DWORD dwStreamIndex, DWORD dwMediaTypeIndex );

};

#endif // GetTypesInvalidStreamTest_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\error.h ===
#ifndef Error_h
#define Error_h

#include <MediaObj.h>
#include <stdio.h>

typedef enum {
    ERROR_TYPE_TEST = 1,
    ERROR_TYPE_DMO = 2,
    ERROR_TYPE_WARNING = 3
} ERROR_TYPE;

inline void __cdecl Error(ERROR_TYPE eType, HRESULT hr, LPCTSTR lpsz, ...)
{
    va_list va;
    va_start(va, lpsz);
    TCHAR sz[2000];
    wvsprintf(sz, lpsz, va);
    va_end(va);
    printf(sz);
    printf(" HRESULT %x\n", hr);
}

inline void __cdecl Error(ERROR_TYPE eType, LPCTSTR lpsz, ...)
{
    va_list va;
    va_start(va, lpsz);
    TCHAR sz[2000];
    wvsprintf(sz, lpsz, va);
    va_end(va);
    printf(sz);
    printf("\n");
}

namespace DMOErrorMsg
{
    void OutputInvalidGetInputTypeReturnValue( HRESULT hrGetInputType, DWORD dwStreamIndex, DWORD dwMediaTypeIndex, DMO_MEDIA_TYPE* pmtDMO );
};

#endif // Error_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\error.cpp ===
#include <windows.h>
#include "Error.h"

void DMOErrorMsg::OutputInvalidGetInputTypeReturnValue( HRESULT hrGetInputType, DWORD dwStreamIndex, DWORD dwMediaTypeIndex, DMO_MEDIA_TYPE* pmtDMO )
{
    Error( ERROR_TYPE_DMO,
           TEXT("IMediaObject::GetInputType( %d, %d, %#08x ) returned %#08x but %#08x is not a valid return value."),
           dwStreamIndex,
           dwMediaTypeIndex,
           pmtDMO,
           hrGetInputType,
           hrGetInputType );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\gtstidx.h ===
#ifndef GenerateTestIndexs_h
#define GenerateTestIndexs_h

class CGenerateTestIndices
{
public:
    CGenerateTestIndices( DWORD dwNumLegalIndices, DWORD dwTotalNumOfIndicesNeeded, HRESULT* phr );
    ~CGenerateTestIndices();
    
    DWORD GetNextIndex( void );
    DWORD GetNumUnusedIndices( void ) const;
    
private:
    DWORD* m_padwIndicesArray;
    DWORD m_dwNumUnusedIndices;

};

#endif // GenerateTestIndexs_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\ivstrm.cpp ===
#include <stdlib.h>
#include <limits.h>
#include <mediaobj.h>
#include <streams.h>
#include "Error.h"
#include "GTstIdx.h"
#include "IVSTRM.h"

CStreamIndexTests::CStreamIndexTests( IMediaObject* pDMO ) :
    m_pDMO(pDMO)
{
    // The caller should always pass in a valid media object.
    ASSERT( NULL != pDMO );

    pDMO->AddRef();
}

CStreamIndexTests::~CStreamIndexTests()
{
    m_pDMO->Release();
}

HRESULT CStreamIndexTests::RunTests( void )
{
    const DWORD NUM_ADDITION_STREAM_INDICES_WANTED = 100;

    DWORD dwNumIndicesNeeded = NUM_ADDITION_STREAM_INDICES_WANTED + GetNumStreams();
    
    // CGenerateTestIndices::CGenerateTestIndices() only changes the value of hr if an error occurs.
    HRESULT hr = S_OK;
    
    CGenerateTestIndices tstidxTestIndices( GetNumStreams(), dwNumIndicesNeeded, &hr );
    if( FAILED( hr ) ) {
        return hr;
    }
    
    HRESULT hrTestResults = S_OK;

    DWORD dwCurrentStreamIndex;

    while( tstidxTestIndices.GetNumUnusedIndices() > 0 ) {
        dwCurrentStreamIndex = tstidxTestIndices.GetNextIndex();
  

        hr = PreformOperation( dwCurrentStreamIndex );
        if( FAILED( hr ) ) {
            return hr;
        } else if( S_FALSE == hr ) {
           hrTestResults = S_FALSE;    
        }
    }

    return hrTestResults;
}



/******************************************************************************
    CInputStreamIndexTests
******************************************************************************/
CInputStreamIndexTests::CInputStreamIndexTests( IMediaObject* pDMO, HRESULT* phr ) :
    CStreamIndexTests( pDMO ),
    m_dwNumInputStreams(0)
{
    // Callers should passin valid non-NULL parameters to this constructor.
    ASSERT( NULL != pDMO );
    ASSERT( NULL != phr );

    DWORD dwNumInputStreams;
    DWORD dwNumOutputStreams;

    HRESULT hr = pDMO->GetStreamCount( &dwNumInputStreams, &dwNumOutputStreams );
    if( FAILED( hr ) ) {
        *phr = hr;  
        return;
    }

    m_dwNumInputStreams = dwNumInputStreams;
}


/******************************************************************************
    COutputStreamIndexTests
******************************************************************************/
COutputStreamIndexTests::COutputStreamIndexTests( IMediaObject* pDMO, HRESULT* phr ) :
    CStreamIndexTests( pDMO ),
    m_dwNumOutputStreams(0)
{
    // Callers should passin valid non-NULL parameters to this constructor.
    ASSERT( NULL != pDMO );
    ASSERT( NULL != phr );

    DWORD dwNumInputStreams;
    DWORD dwNumOutputStreams;

    HRESULT hr = pDMO->GetStreamCount( &dwNumInputStreams, &dwNumOutputStreams );
    if( FAILED( hr ) ) {
        *phr = hr;  
        return;
    }

    m_dwNumOutputStreams = dwNumOutputStreams;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\dmotestnode.h ===
#ifndef _DMOTESTNODE_H
#define _DMOTESTNODE_H
/*=============================================================================
|
|	File: CaseInfo.h
|
|	Copyright (c) 1999 Microsoft Corporation.  All rights reserved
|
|	Abstract:
|		An exmple of redifining CTestCaseInfo in the process of creating a
|		test application
|
|	Contents:
|		
|
|	History:
|		7/21/99    liamn    Started 
|		7/28/99    liamn    First Working Version 
|		7/30/99    liamn	Finished commenting
|		8/03/99    liamn	Additional Comments
|
\============================================================================*/

#include <windows.h>
#include <CaseNode.h>
#include "dmotest.h"

/*=============================================================================
|	CLASS DEFINITIONS
\============================================================================*/
/*-----------------------------------------------------------------------------
|	Class:		CVarTestCase
|	Purpose:	Defines VarTestcase node for use in the test case tree
|	Notes:		This is an example of add a new type of node of use in the 
|				test case tree.  As you can see very few changes need to be
|				made and the correct run test will be used depending on what 
|				type of testcase node is used.
\----------------------------------------------------------------------------*/



class CDmoTestCase : public CTestNodeItem
{
protected:
	CDmoTest*       m_pDmoTest;

public:

	CDmoTestCase(	LPSTR pszNewCaseID, 
					LPSTR pszNewName,
					CDmoTest* dmoTest);

	virtual ~CDmoTestCase();
	virtual DWORD   RunTest(void) = 0;
};


inline
CDmoTestCase::CDmoTestCase(	LPSTR pszNewCaseID, 
							LPSTR pszNewName,
							CDmoTest* dmoTest)

		: CTestNodeItem(false, pszNewCaseID, pszNewName, 0),
		  m_pDmoTest(dmoTest)
{

}

inline	
CDmoTestCase::~CDmoTestCase() 
{

}










class CDmoTestCase1 : public CDmoTestCase
{
private:
    DMOTESTFNPROC1	pfnTest;


public:

	CDmoTestCase1(	LPSTR pszNewCaseID, 
					LPSTR pszNewName,
					DMOTESTFNPROC1 pfnNewTest, 
					CDmoTest* dmoTest);

	virtual ~CDmoTestCase1();
	DWORD   RunTest(void);
};


/*=============================================================================
|	MEMBER FUNCTION DEFINITIONS
|------------------------------------------------------------------------------
|	CTestCase
\============================================================================*/
/*-----------------------------------------------------------------------------
|	Function:	CTestCase
|	Purpose:	Constructor (wrapper for CTestNodeItem function)
|	Arguments:	ID, Name, and Flags for HW, Function to be called by RunTest
|	Returns:	Void
\----------------------------------------------------------------------------*/

inline
CDmoTestCase1::CDmoTestCase1(	LPSTR pszNewCaseID, 
							LPSTR pszNewName,
							DMOTESTFNPROC1 pfnNewTest,
							CDmoTest* dmoTest)

		: CDmoTestCase(pszNewCaseID, pszNewName, dmoTest),
		  pfnTest(pfnNewTest)
{

}

/*-----------------------------------------------------------------------------
|	Function:	~CTestCase
|	Purpose:	Destructor
|	Arguments:	None
|	Returns:	Void
\----------------------------------------------------------------------------*/

inline	
CDmoTestCase1::~CDmoTestCase1() 
{

}

/*-----------------------------------------------------------------------------
|	Function:	RunTest
|	Purpose:	This should never get called for any group, but must be defined
|	Arguments:	None
|	Returns:	0
\----------------------------------------------------------------------------*/


inline 
DWORD
CDmoTestCase1::RunTest()
{
	LPSTR	szDmoName;
	LPSTR	szDmoClsid;
	int		iNumTestFiles;
	LPSTR	szFileName;
	DWORD   dwResult = FNS_PASS;

	int iNumComponent = m_pDmoTest->GetNumComponent();

	for(int i=0; i<iNumComponent; i++)
	{
		szDmoName = m_pDmoTest->GetDmoName(i);

		if( m_pDmoTest->IsDmoSelected(i))
		{
			szDmoClsid = m_pDmoTest->GetDmoClsid(i);
			iNumTestFiles = m_pDmoTest->GetNumTestFile(i);
			for (int j=0; j< iNumTestFiles; j++)
			{	
				szFileName = m_pDmoTest->GetFileName(i, j);
				if( pfnTest(szDmoClsid, szFileName) != FNS_PASS)
					dwResult = FNS_FAIL;
			}
		}
	}

	return dwResult;
}

/*********************************************************
**********************************************************/

class CDmoTestCase2 : public CDmoTestCase
{
private:
    DMOTESTFNPROC2	pfnTest;


public:

	CDmoTestCase2(	LPSTR pszNewCaseID, 
					LPSTR pszNewName,
					DMOTESTFNPROC2 pfnNewTest, 
					CDmoTest* dmoTest);

	virtual ~CDmoTestCase2();
	DWORD   RunTest(void);
};

inline
CDmoTestCase2::CDmoTestCase2(	LPSTR pszNewCaseID, 
							LPSTR pszNewName,
							DMOTESTFNPROC2 pfnNewTest,
							CDmoTest* dmoTest)

		: CDmoTestCase(pszNewCaseID, pszNewName, dmoTest),
		  pfnTest(pfnNewTest)
{

}

/*-----------------------------------------------------------------------------
|	Function:	~CTestCase
|	Purpose:	Destructor
|	Arguments:	None
|	Returns:	Void
\----------------------------------------------------------------------------*/

inline	
CDmoTestCase2::~CDmoTestCase2() 
{

}

/*-----------------------------------------------------------------------------
|	Function:	RunTest
|	Purpose:	This should never get called for any group, but must be defined
|	Arguments:	None
|	Returns:	0
\----------------------------------------------------------------------------*/

inline 
DWORD
CDmoTestCase2::RunTest()
{
	LPSTR	szDmoName;
	LPSTR	szDmoClsid;
	DWORD   dwResult = FNS_PASS;

	int iNumComponent = m_pDmoTest->GetNumComponent();

	for(int i=0; i<iNumComponent; i++)
	{
		szDmoName = m_pDmoTest->GetDmoName(i);

		if( m_pDmoTest->IsDmoSelected(i))
		{
			szDmoClsid = m_pDmoTest->GetDmoClsid(i);

			if(pfnTest(szDmoClsid) != FNS_PASS)
				dwResult = FNS_FAIL;
	
		}
	}

	return dwResult;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\gtstidx.cpp ===
#include <windows.h>
#include <streams.h>
#include <limits.h>
#include "GTstIdx.h"

CGenerateTestIndices::CGenerateTestIndices( DWORD dwNumLegalIndices, DWORD dwTotalNumOfIndicesNeeded, HRESULT* phr ) :
    m_padwIndicesArray(NULL),
    m_dwNumUnusedIndices(0)
{
    // The caller should pass in reasonable values to the constructor.  Their is no reason to 
    // create an instance of this class if the caller knows that it doesn't want any indices 
    // created.
    ASSERT( 0 < dwTotalNumOfIndicesNeeded );

    m_padwIndicesArray = new DWORD[dwTotalNumOfIndicesNeeded];
    if( NULL == m_padwIndicesArray ) {
        *phr = E_OUTOFMEMORY;
        return;
    }

    DWORD dwCurrentIndex;
    DWORD dwFirstRandomIndex;

    if( dwNumLegalIndices > 0 ) {
        // The m_padwIndicesArray must contain at least two illegal indices 
        // if there are any legal indices in the array.
        const DWORD REQUIRED_SPACE_FOR_ILLEGAL_INDICES = 2;

        // This class assumes that the caller wants to create at least 
        // (dwNumLegalIndices + REQUIRED_SPACE_FOR_ILLEGAL_INDICES) indices.
        ASSERT( (dwNumLegalIndices + REQUIRED_SPACE_FOR_ILLEGAL_INDICES) <= dwTotalNumOfIndicesNeeded );

        // rand() returns numbers between 0 and RAND_MAX.  Make sure that rand() can return all 
        // the valid indices.
        ASSERT( dwNumLegalIndices <= RAND_MAX );

        DWORD dwMaxIndex = dwNumLegalIndices - 1;

        // Put all legal stream numbers in the array.
        for( dwCurrentIndex = 0; dwCurrentIndex <= dwMaxIndex; dwCurrentIndex++ ) {
            m_padwIndicesArray[dwCurrentIndex] = dwCurrentIndex;
        }

        // Put illegal values in the array.
        dwCurrentIndex = dwMaxIndex + 1;
        m_padwIndicesArray[dwCurrentIndex] = dwMaxIndex + 1;
        dwCurrentIndex++;
        m_padwIndicesArray[dwCurrentIndex] = ULONG_MAX;
    
        dwFirstRandomIndex = dwMaxIndex + REQUIRED_SPACE_FOR_ILLEGAL_INDICES + 1;
    } else {
        dwFirstRandomIndex = 0;        
    }

    for( dwCurrentIndex = dwFirstRandomIndex; dwCurrentIndex < dwTotalNumOfIndicesNeeded; dwCurrentIndex++ ) {
        m_padwIndicesArray[dwCurrentIndex] = ::rand();
    }

    m_dwNumUnusedIndices = dwTotalNumOfIndicesNeeded;
}

CGenerateTestIndices::~CGenerateTestIndices()
{
    delete m_padwIndicesArray;
}

DWORD CGenerateTestIndices::GetNextIndex( void )
{
    // Make sure the object was successfully initialized.
    ASSERT( NULL != m_padwIndicesArray );

    // This function assumes that there are between 1 and RAND_MAX elements in m_padwIndicesArray.
    ASSERT( (0 != GetNumUnusedIndices()) && (GetNumUnusedIndices() <= RAND_MAX) );

    DWORD dwReturnIndexNum = ((::rand() * (GetNumUnusedIndices() - 1)) / RAND_MAX);
        
    // Make sure the dwCurrentIndex is a valid index between 0 and (GetNumUnusedIndices() - 1).
    ASSERT( (0 <= dwReturnIndexNum) && (dwReturnIndexNum <= (GetNumUnusedIndices() - 1)) );

    DWORD dwLastUnusedIndex = m_padwIndicesArray[GetNumUnusedIndices() - 1];

    DWORD dwReturnIndex = m_padwIndicesArray[dwReturnIndexNum];
    m_padwIndicesArray[dwReturnIndexNum] = dwLastUnusedIndex;

    m_dwNumUnusedIndices--;

    return dwReturnIndex;    
}

DWORD CGenerateTestIndices::GetNumUnusedIndices( void ) const
{
    return m_dwNumUnusedIndices;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\gtivst.cpp ===
#include <mediaobj.h>
#include <streams.h>
#include <DMort.h>
#include <mediaerr.h>
#include <s98inc.h>
#include "GTIVST.h"
#include "Error.h"
#include "Utility.h"
#include "GTstIdx.h"

const TCHAR szGetInputTypeName[] = TEXT("IMediaObject::GetInputType()");

CGetInputTypesInvalidStreamTest::CGetInputTypesInvalidStreamTest( IMediaObject* pDMO, HRESULT* phr ) :
    CInputStreamIndexTests( pDMO, phr )
{
}

HRESULT CGetInputTypesInvalidStreamTest::PreformOperation( DWORD dwStreamIndex )
{
    HRESULT hr;
    DWORD dwNumMediaTypes;

    if( StreamExists( dwStreamIndex ) ) {
        hr = GetNumTypes( GetDMO(), dwStreamIndex, &dwNumMediaTypes );
        if( FAILED( hr ) ) {
            return hr;
        }    
    } else {
        dwNumMediaTypes = 0;
    }

    // We want at least 1000 random indices in addition to any legal indices.
    DWORD dwNumIndicesWanted = dwNumMediaTypes + 1000;

    // CGenerateTestIndices::CGenerateTestIndices() only changes the value of hr if an error occurs.
    hr = S_OK;

    CGenerateTestIndices tstidxMediaType( dwNumMediaTypes, dwNumIndicesWanted, &hr );

    if( FAILED( hr ) ) {
        return hr;
    }

    HRESULT hrTestResult;
    DWORD dwCurrentMediaTypeIndex;

    hrTestResult = S_OK;

    while( tstidxMediaType.GetNumUnusedIndices() > 0 ) {
        dwCurrentMediaTypeIndex = tstidxMediaType.GetNextIndex();
        hr = PreformOperation( GetDMO(), dwNumMediaTypes, dwStreamIndex, dwCurrentMediaTypeIndex );
        if( FAILED( hr ) ) {
            return hr;
        } else if( S_FALSE == hr ) {
            hrTestResult = S_FALSE;
        }
    }
 
    return hrTestResult;
}

const TCHAR* CGetInputTypesInvalidStreamTest::GetOperationName( void ) const
{
    return szGetInputTypeName;
}

HRESULT CGetInputTypesInvalidStreamTest::GetNumTypes( IMediaObject* pDMO, DWORD dwStreamIndex, DWORD* pdwNumMediaTypes )
{
    HRESULT hr;
    DWORD dwNumMediaTypes;
    DWORD dwCurrentMediaTypeIndex;
    DMO_MEDIA_TYPE mtDMO;

    dwNumMediaTypes = 0;
    dwCurrentMediaTypeIndex = 0;

    do
    {
        hr = pDMO->GetInputType( dwStreamIndex, dwCurrentMediaTypeIndex, &mtDMO );
        if( SUCCEEDED( hr ) ) {
            MoFreeMediaType( &mtDMO );
            dwNumMediaTypes++;
        } else if( (hr != DMO_E_NO_MORE_ITEMS) && FAILED(hr) ) {
            return hr;
        }
    
        dwCurrentMediaTypeIndex++;

    } while( hr != DMO_E_NO_MORE_ITEMS );        

    *pdwNumMediaTypes = dwNumMediaTypes;

    return S_OK;
}



HRESULT CGetInputTypesInvalidStreamTest::PreformOperation( IMediaObject* pDMO, DWORD dwNumMediaTypes, DWORD dwStreamIndex, DWORD dwMediaTypeIndex )
{
    // 
    // Interpreting return codes from IMediaObject::GetInputType()
    //
    // IMediaObject::GetInputType()'s pmt parameter should not affect the return value unless
    // it cannot allocate the format data in the DMO_MEDIA_TYPE structure.  In this case,
    // GetInputType() should return E_OUTOFMEMORY.
    // 
    // 
    // 
    //                  Expected GetInputType() return values when there is enough memory to
    //                      store a new copy the input stream's media type format.
    //
    // Stream Index             Media Type Index            GetInputType( ... , pmt )   
    // ---------------------------------------------------------------------------------
    // Stream Exists            Media Type Exists           S_OK                        
    // Stream Exists            Media Type Doesn't Exist    DMO_E_NO_MORE_ITEMS                     
    // Stream Doesn't Exist     Media Type Exists           DMO_E_INVALIDSTREAMINDEX    
    // Stream Doesn't Exist     Media Type Exists           DMO_E_INVALIDSTREAMINDEX    
    // 
    // 
    // 
    //               Expected GetInputType() return values when there is _NOT_ enough memory to
    //                      store a new copy the input stream's media type format.
    //
    // Stream Index             Media Type Index            GetInputType( ... , pmt )   
    // ---------------------------------------------------------------------------------
    // Stream Exists            Media Type Exists           E_OUTOFMEMORY               
    // Stream Exists            Media Type Doesn't Exist    DMO_E_NO_MORE_ITEMS                     
    // Stream Doesn't Exist     Media Type Exists           DMO_E_INVALIDSTREAMINDEX    
    // Stream Doesn't Exist     Media Type Exists           DMO_E_INVALIDSTREAMINDEX    
    // 

    DMO_MEDIA_TYPE mtDMO;

    HRESULT hr = pDMO->GetInputType( dwStreamIndex, dwMediaTypeIndex, &mtDMO );
    if( SUCCEEDED( hr ) ) {
        MoFreeMediaType( &mtDMO );
    }

    if( !DMODataValidation::ValidGetInputTypeReturnValue( hr ) ) {
        //DMOErrorMsg::OutputInvalidGetInputTypeReturnValue( hr, dwStreamIndex, dwMediaTypeIndex, &mtDMO );
		g_IShell->Log(1, "DMO ERROR:ImdediaObject::GetInputType(%d, %d, %#08x ) returned %#08x, which is not a valid return value.", dwStreamIndex, dwMediaTypeIndex,&mtDMO, hr );
        return E_FAIL;
    }

    if( StreamExists( dwStreamIndex ) ) {
        
        // If the media type EXISTS and GetInputTypes()'s return value
        // indicates that it EXISTS.
        if( (dwMediaTypeIndex < dwNumMediaTypes) && (S_OK == hr) ) {
            return S_OK;
        // If the media type DOES NOT EXIST and GetInputTypes()'s return
        // values indicates that it DOES NOT EXIST.
        } else if( (dwMediaTypeIndex >= dwNumMediaTypes) && (DMO_E_NO_MORE_ITEMS == hr) ) {
            return S_OK;
        
        // If the number of media types and GetInputTypes()'s return value are inconsistent? (i.e. one 
        // indicates that the media type should exist and the other indicates that 
        // it should not)
        } else if( ((dwMediaTypeIndex >= dwNumMediaTypes) && (S_OK == hr)) ||
                   ((dwMediaTypeIndex < dwNumMediaTypes) && (DMO_E_NO_MORE_ITEMS == hr)) ) {
            DWORD dwResentNumMediaTypes;

            // Check to see if the number of media types changed.
            HRESULT hrGetNumTypes = GetNumTypes( GetDMO(), dwStreamIndex, &dwResentNumMediaTypes );
            if( FAILED( hrGetNumTypes ) ) {
                return hrGetNumTypes;
            }

            if( dwNumMediaTypes != dwResentNumMediaTypes ) {
              /*  Error( ERROR_TYPE_DMO,
                       TEXT("ERROR: The number of input media types changed.  There used to be %lu media type(s) but now there are %lu media type(s)."),
                       dwNumMediaTypes,
                       dwResentNumMediaTypes );*/
				g_IShell->Log(1, "DMO ERROR: The number of input media types changed.  There used to be %lu media type(s) but now there are %lu media type(s).",
                       dwNumMediaTypes,
                       dwResentNumMediaTypes );
                return E_FAIL;
            }

            if( hr == DMO_E_NO_MORE_ITEMS ) {
              /*  Error( ERROR_TYPE_DMO,
                       TEXT("ERROR: Input stream %d supports %d media types but IMediaObject::GetInputType( %d, %d, NULL ) returned DMO_E_NO_MORE_ITEMS eventhough the media type exists."),
                       dwStreamIndex,
                       dwNumMediaTypes,
                       dwStreamIndex, 
                       dwMediaTypeIndex );*/
				g_IShell->Log(1, "DMO ERROR: Input stream %d supports %d media types but IMediaObject::GetInputType( %d, %d, NULL ) returned DMO_E_NO_MORE_ITEMS eventhough the media type exists.",
                       dwStreamIndex,
                       dwNumMediaTypes,
                       dwStreamIndex, 
                       dwMediaTypeIndex );
                return E_FAIL;
            } else {
               /* Error( ERROR_TYPE_DMO,
                       TEXT("ERROR: Input stream %d supports %d media types but IMediaObject::GetInputType( %d, %d, NULL ) returned S_OK eventhough the media type does not exist."),
                       dwStreamIndex,
                       dwNumMediaTypes,
                       dwStreamIndex, 
                       dwMediaTypeIndex );*/

				g_IShell->Log(1, "DMO ERROR: Input stream %d supports %d media types but IMediaObject::GetInputType( %d, %d, NULL ) returned S_OK eventhough the media type does not exist.",
                       dwStreamIndex,
                       dwNumMediaTypes,
                       dwStreamIndex, 
                       dwMediaTypeIndex );
                return E_FAIL;
            }
        } else {
            // All of the possible success case should have been taken care in the above if statements.
            ASSERT( FAILED( hr ) );

            //Error( ERROR_TYPE_DMO, hr, TEXT("ERROR: %s's stream index parameter contained a valid value but the function failed."), GetOperationName() );
			g_IShell->Log(1, "DMO ERROR: %s's stream index parameter contained a valid value but the function failed. hr = %#08x", GetOperationName(), hr );
            return E_FAIL;
        }
    } else {
        // The current stream number is illegal.
        if( DMO_E_INVALIDSTREAMINDEX == hr ) {
            return S_OK;
        } else if( FAILED( hr ) ) {
            //Error( ERROR_TYPE_WARNING, hr, TEXT("WARNING: %s's stream index parameter contained an invalid value but %s did not return DMO_E_INVALIDSTREAMINDEX."), GetOperationName(), GetOperationName() );
			g_IShell->Log(1, "WARNING: %s's stream index parameter contained an invalid value but %s did not return DMO_E_INVALIDSTREAMINDEX.", GetOperationName(), GetOperationName(), hr );
			return S_OK;
        } else {
            //Error( ERROR_TYPE_DMO, hr, TEXT("ERROR: %s's stream index parameter contained an invalid value but the function succeeded.  It should have returned DMO_E_INVALIDSTREAMINDEX."), GetOperationName() );
			g_IShell->Log(1, "DMO ERROR: %s's stream index parameter contained an invalid value but the function succeeded.  It should have returned DMO_E_INVALIDSTREAMINDEX.", GetOperationName(), hr );
			return E_FAIL;
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\nptst.cpp ===
#include <mediaobj.h>
#include <streams.h>
#include <s98inc.h>
#include "Utility.h"
#include "Error.h"
#include "NPTST.h"

/******************************************************************************
    CNullParameterTest
******************************************************************************/

const DWORD MAX_NUM_SUPPORTED_PARAMETERS = 31;
const DWORD NUM_GET_STREAM_INFO_POINTER_PARAMETERS = 1;
const DWORD NUM_GET_STREAM_COUNT_POINTER_PARAMETERS = 2;

const TCHAR GET_STREAM_COUNT_NAME[] = TEXT("IMediaObject::GetStreamCount()");
const TCHAR GET_INPUT_STREAM_INFO_NAME[] = TEXT("IMediaObject::GetInputStreamInfo()");
const TCHAR GET_OUTPUT_STREAM_INFO_NAME[] = TEXT("IMediaObject::GetOutputStreamInfo()");

CNullParameterTest::CNullParameterTest( IMediaObject* pDMO, DWORD dwNumPointerParameters ) :
    m_pDMO(pDMO),
    m_dwNumPointerParameters(dwNumPointerParameters)
{
    // The caller should pass in a valid DMO.
    ASSERT( NULL != pDMO );
    
    // The algorithm used by this class is exponential.  It's extreamly slow if a function
    // has more than 10 parameters which accept pointers.  Users should not use this class if
    // a function does not have any parameters which accept NULL pointers.
    ASSERT( (1 <= dwNumPointerParameters) && (dwNumPointerParameters <= 10) );

    m_pDMO->AddRef();
}

CNullParameterTest::~CNullParameterTest()
{
    if( NULL != m_pDMO ) {
         m_pDMO->Release();
    }
}

HRESULT CNullParameterTest::RunTests( void )
{
    // The exponentiation code used by this function only works if 
    // m_dwNumPointerParameters is less than or equal to 31.
    ASSERT( m_dwNumPointerParameters <= MAX_NUM_SUPPORTED_PARAMETERS );

    DWORD dwNumTestCases = (0x1) << m_dwNumPointerParameters;

    // Make sure there is more than one test case.
    ASSERT( 0 != dwNumTestCases );

    HRESULT hr;
    HRESULT hrTestResults;
    DWORD dwCurrentTestCase;

    hrTestResults = S_OK;

    for( dwCurrentTestCase = 0; dwCurrentTestCase < dwNumTestCases; dwCurrentTestCase++ ) {
		g_IShell->Log(1, "   Null Parameter Test Case %d:", dwCurrentTestCase);

        hr = PreformOperation( m_pDMO, dwCurrentTestCase );

        if( SomeParametersNull( dwCurrentTestCase ) ) {
            if( SUCCEEDED( hr ) ) {
                //Error( ERROR_TYPE_DMO, hr, TEXT("ERROR: Some of %s's parameters were NULL but the function still succeeded.  It should return E_POINTER in this case."), GetOperationName() );
				g_IShell->Log(1, "DMO ERROR: Some of %s's parameters were NULL but the function still succeeded.  It should return E_POINTER in this case.\n", GetOperationName() );
				hrTestResults = E_FAIL;
            } else if( FAILED( hr ) && (E_POINTER != hr) ) {
                //Error( ERROR_TYPE_WARNING, hr, TEXT("WARNING: Some of %s's parameters were NULL but the function did not return E_POINTER."), GetOperationName() );
				g_IShell->Log(1, "WARNING: Some of %s's parameters were NULL but the function did not return E_POINTER.\n", GetOperationName() );
				hrTestResults = E_FAIL;
			}
        } else {
            if( FAILED( hr ) ) {
                //Error( ERROR_TYPE_WARNING, hr, TEXT("ERROR: None of %s's parameters were NULL but the function failed."), GetOperationName() );
				g_IShell->Log(1, "WARNING: None of %s's parameters were NULL but the function failed.", GetOperationName() );
				hrTestResults = E_FAIL;
            } else if( S_FALSE == hr ) {
                hrTestResults = E_FAIL;
            }
        }
    }

    return hrTestResults;
}

bool CNullParameterTest::SomeParametersNull( DWORD dwNullParameterMask )
{
    // This function only supports values between 1 and MAX_NUM_SUPPORTED_PARAMETERS.
    ASSERT( (0 < m_dwNumPointerParameters) && (m_dwNumPointerParameters <= MAX_NUM_SUPPORTED_PARAMETERS) );

    const DWORD adwNoNullParameterBitMaskTable[] = 
    {
        0x00000001,
        0x00000003,
        0x00000007,
        0x0000000F,
        0x0000001F,
        0x0000003F,
        0x0000007F,
        0x000000FF,
        0x000001FF,
        0x000003FF,
        0x000007FF,
        0x00000FFF,
        0x00001FFF,
        0x00003FFF,
        0x00007FFF,
        0x0000FFFF,
        0x0001FFFF,
        0x0003FFFF,
        0x0007FFFF,
        0x000FFFFF,
        0x001FFFFF,
        0x003FFFFF,
        0x007FFFFF,
        0x00FFFFFF,
        0x01FFFFFF,
        0x03FFFFFF,
        0x07FFFFFF,
        0x0FFFFFFF,
        0x1FFFFFFF,
        0x3FFFFFFF,
        0x7FFFFFFF
    };

    // This function assumes that adwNoNullParameterBitMaskTable has MAX_NUM_SUPPORTED_PARAMETERS entries.
    ASSERT( NUMELMS( adwNoNullParameterBitMaskTable ) == MAX_NUM_SUPPORTED_PARAMETERS );

    DWORD dwALLParametersNotNULLMask = adwNoNullParameterBitMaskTable[m_dwNumPointerParameters-1];

    if( (dwALLParametersNotNULLMask & dwNullParameterMask) == dwALLParametersNotNULLMask ) {
        return false;
    } else {
        return true;
    }
}

bool CNullParameterTest::IsParameterNull( DWORD dwPointerParameterNum, DWORD dwNullParameterMask )
{
    // Make sure the caller passes in a valid parameter number.
    // Parameters are numbered between 1 and m_dwNumPointerParameters.
    ASSERT( (1 <= dwPointerParameterNum) && (dwPointerParameterNum <= m_dwNumPointerParameters) );

    // This function assumes that every function has atmost MAX_NUM_SUPPORTED_PARAMETERS paraneters.
    ASSERT( (0 < m_dwNumPointerParameters) && (m_dwNumPointerParameters <= MAX_NUM_SUPPORTED_PARAMETERS) );

    DWORD dwParameterMask = 0x1 << (dwPointerParameterNum - 1);
    
    if( dwParameterMask & dwNullParameterMask ) {
        return false;
    } else {
        return true;
    }
}

void CNullParameterTest::DeterminePointerParameterValue
    (
    DWORD dwPointerParameterNum,
    DWORD dwNullParameterMask,
    void* pNonNullPointer,
    void** ppParameter
    )
{
    // Make sure the caller passes in a valid parameter number.
    // Parameters are numbered between 1 and m_dwNumPointerParameters.
    ASSERT( (1 <= dwPointerParameterNum) && (dwPointerParameterNum <= m_dwNumPointerParameters) );

    if( IsParameterNull( dwPointerParameterNum, dwNullParameterMask ) ) {
        *ppParameter = NULL;
    } else {
        *ppParameter = pNonNullPointer;
    }
}

/******************************************************************************
    CGetStreamCountNPT
******************************************************************************/
CGetStreamCountNPT::CGetStreamCountNPT( IMediaObject* pDMO ) :
    CNullParameterTest( pDMO, NUM_GET_STREAM_COUNT_POINTER_PARAMETERS )
{
}
    
HRESULT CGetStreamCountNPT::PreformOperation( IMediaObject* pDMO, DWORD dwNullParameterMask )
{
    DWORD dwNumInputStreams;
    DWORD dwNumOutputStreams;

    DWORD* pdwParameterOne;
    DWORD* pdwParameterTwo;

    DeterminePointerParameterValue( 1, dwNullParameterMask, &dwNumInputStreams, (void**)&pdwParameterOne );
    DeterminePointerParameterValue( 2, dwNullParameterMask, &dwNumOutputStreams, (void**)&pdwParameterTwo );

	g_IShell->Log(1, "    First input parameter = %#08x, Second input parameter = %#08x", pdwParameterOne,pdwParameterTwo);

    HRESULT hr;   
    SAFE_CALL( pDMO, GetStreamCount( pdwParameterOne, pdwParameterTwo ) );
	return hr;
}

const TCHAR* CGetStreamCountNPT::GetOperationName( void ) const
{
    return GET_STREAM_COUNT_NAME;
}

/******************************************************************************
    CGetStreamInfoNPT
******************************************************************************/
CGetStreamInfoNPT::CGetStreamInfoNPT( IMediaObject* pDMO, STREAM_TYPE st, DWORD dwStreamIndex  ) :
    CNullParameterTest( pDMO, NUM_GET_STREAM_INFO_POINTER_PARAMETERS ),
    m_dwStreamIndex(dwStreamIndex),
    m_stStreamType(st)
{
    // Make sure st contains a legal value.
    ASSERT( DMODataValidation::ValidateStreamType( st ) );

    #ifdef DEBUG
    {
        DWORD dwNumInputStreams;
        DWORD dwNumOutputStreams;

        HRESULT hr = pDMO->GetStreamCount( &dwNumInputStreams, &dwNumOutputStreams );
        if( SUCCEEDED( hr ) ) {

            // Streams are numbered from 0 to (dwNumInputStreams - 1).  Make sure the stream actually exists.
            if( ST_INPUT_STREAM == st ) {
                ASSERT( dwStreamIndex < dwNumInputStreams );
            } else {
                ASSERT( dwStreamIndex < dwNumOutputStreams );
            }
            
        } else {
            DbgLog(( LOG_ERROR, 5, TEXT("WARNING in CGetInputStreamInfoNPT::CGetInputStreamInfoNPT(): IMediaObject::GetStreamCount() returned %#08x."), hr ));
        }
    }
    #endif DEBUG
}

HRESULT CGetStreamInfoNPT::PreformOperation( IMediaObject* pDMO, DWORD dwNullParameterMask )
{
    DWORD dwStreamInfoFlags;
    DWORD* pdwPointerParameterOne;

    DeterminePointerParameterValue( 1, dwNullParameterMask, &dwStreamInfoFlags, (void**)&pdwPointerParameterOne );
    
    HRESULT hr;

    if( ST_INPUT_STREAM == m_stStreamType ) {
        SAFE_CALL( pDMO, GetInputStreamInfo( m_dwStreamIndex, pdwPointerParameterOne ) );
    } else {
        SAFE_CALL( pDMO, GetOutputStreamInfo( m_dwStreamIndex, pdwPointerParameterOne ) );
    }

    if( SUCCEEDED( hr ) && (NULL != pdwPointerParameterOne) ) {
    
        if( !ValidateGetStreamInfoFlags( *pdwPointerParameterOne ) ) {
           /* Error( ERROR_TYPE_DMO,
                   hr,
                   TEXT("ERROR in CGetStreamInfoNPT::PreformOperation().  %s succeeded but it returned the following invalid flags: %#08x"),
                   GetOperationName(),
                   *pdwPointerParameterOne );*/
			g_IShell->Log(1, " DMO ERROR in CGetStreamInfoNPT::PreformOperation().  %s succeeded but it returned the following invalid flags: %#08x",
                   GetOperationName(),
                   *pdwPointerParameterOne );
            hr = E_FAIL;
        }
    }

    return hr;
}

bool CGetStreamInfoNPT::ValidateGetStreamInfoFlags( DWORD dwFlags )
{
    if( ST_INPUT_STREAM == m_stStreamType ) {
        return DMODataValidation::ValidGetInputStreamInfoFlags( dwFlags );
    } else {
        return DMODataValidation::ValidGetOutputStreamInfoFlags( dwFlags );
    }    
}

const TCHAR* CGetStreamInfoNPT::GetOperationName( void ) const
{
    if( ST_INPUT_STREAM == m_stStreamType ) {
        return GET_INPUT_STREAM_INFO_NAME;
    } else {
        return GET_OUTPUT_STREAM_INFO_NAME;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\ivstrm.h ===
#ifndef StreamIndexTests
#define StreamIndexTests

#include "Types.h"

class CStreamIndexTests
{
public:
    CStreamIndexTests( IMediaObject* pDMO );
    ~CStreamIndexTests();

    HRESULT RunTests( void );

protected:
    /******************************************************************************

    PreformOperation

        PreformOperation() calls a function an interprets the results.  See the
    documentation for derviced classes for more information on what operation
    PreformOperation() preforms.

    Parameters:
    - dwStreamIndex [in]
        The stream number the operation should use.  This number may be valid or
    invalid.

    Return Value:
        S_OK - The operation succeeded and it returned the expected values.
        S_FALSE - The operation failed because it returned invalid or inconsistent data. 
        An error code - An unexpected error occured executing the operation or an 
                        error occured setting up an operation.  

    ******************************************************************************/
    virtual HRESULT PreformOperation( DWORD dwStreamIndex ) = 0;
    virtual DWORD GetNumStreams( void ) = 0;
    virtual const TCHAR* GetOperationName( void ) const = 0;

    bool StreamExists( DWORD dwStreamIndex );
    IMediaObject* GetDMO( void );

private:
    IMediaObject* m_pDMO;

};



class CInputStreamIndexTests : public CStreamIndexTests
{
protected:
    CInputStreamIndexTests( IMediaObject* pDMO, HRESULT* phr );
    DWORD GetNumStreams( void );

private:
    DWORD m_dwNumInputStreams;

};



class COutputStreamIndexTests : public CStreamIndexTests
{
protected:
    COutputStreamIndexTests( IMediaObject* pDMO, HRESULT* phr );
    DWORD GetNumStreams( void );

private:
    DWORD m_dwNumOutputStreams;

};



inline IMediaObject* CStreamIndexTests::GetDMO( void )
{
    // Make sure m_pDMO conatins a valid DMO pointer.
    ASSERT( NULL != m_pDMO );

    return m_pDMO;
}

inline bool CStreamIndexTests::StreamExists( DWORD dwStreamIndex )
{
    // Streams are numbered between 0 and (GetNumStreams()-1).
    return (dwStreamIndex < GetNumStreams());
}


inline DWORD CInputStreamIndexTests::GetNumStreams( void )
{
    #ifdef DEBUG
    {
        DWORD dwInputStreams;
        DWORD dwOutputStreams;

        HRESULT hr = GetDMO()->GetStreamCount( &dwInputStreams, &dwOutputStreams );
        if( SUCCEEDED( hr ) ) {
            // Make sure the DMO did not change the number of streams it supports.
            ASSERT( dwInputStreams == m_dwNumInputStreams );
        } else {
            DbgBreak( "IMediaObject::GetStreamCount() failed eventhough the caller passed in valid parameters." );
        }
    }
    #endif // DEBUG 

    return m_dwNumInputStreams;
}



inline DWORD COutputStreamIndexTests::GetNumStreams( void )
{
    #ifdef DEBUG
    {
        DWORD dwInputStreams;
        DWORD dwOutputStreams;

        HRESULT hr = GetDMO()->GetStreamCount( &dwInputStreams, &dwOutputStreams );
        if( SUCCEEDED( hr ) ) {
            // Make sure the DMO did not change the number of streams it supports.
            ASSERT( dwOutputStreams == m_dwNumOutputStreams );
        } else {
            DbgBreak( "IMediaObject::GetStreamCount() failed eventhough the caller passed in valid parameters." );
        }
    }
    #endif // DEBUG 

    return m_dwNumOutputStreams;
}


#endif // StreamIndexTests
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\nptst.h ===
#ifndef NullParameterTest_h
#define NullParameterTest_h

#define SAFE_CALL(_obj_, _method_) \
	if( _obj_ == NULL ) \
		Error(ERROR_TYPE_DMO, E_POINTER, TEXT("Null object pointer")); \
    __try { \
        hr=_obj_->_method_;   \
    } __except(EXCEPTION_EXECUTE_HANDLER) { \
        Error(ERROR_TYPE_DMO, E_FAIL, TEXT(#_obj_) TEXT("->") TEXT(#_method_) TEXT(" exception code %d"),\
              GetExceptionCode()); \
	return E_FAIL; \
    } \


#include "Types.h"

class CNullParameterTest
{
public:
    CNullParameterTest( IMediaObject* pDMO, DWORD dwNumPointerParameters );
    ~CNullParameterTest();

    HRESULT RunTests( void );

protected:
    virtual HRESULT PreformOperation( IMediaObject* pDMO, DWORD dwNullParameterMask ) = 0;
    virtual const TCHAR* GetOperationName( void ) const = 0;

    void DeterminePointerParameterValue
        (
        DWORD dwPointerParameterNum,
        DWORD dwNullParameterMask,
        void* pNonNullPointer,
        void** ppParameter
        );

private:
    bool SomeParametersNull( DWORD dwNullParameterMask );
    bool IsParameterNull( DWORD dwPointerParameterNum, DWORD dwNullParameterMask );

    DWORD m_dwNumPointerParameters;
    IMediaObject* m_pDMO;

};


class CGetStreamCountNPT : public CNullParameterTest
{
public:
    CGetStreamCountNPT( IMediaObject* pDMO );
    
private:
    HRESULT PreformOperation( IMediaObject* pDMO, DWORD dwNullParameterMask );
    const TCHAR* GetOperationName( void ) const;
    
};


class CGetStreamInfoNPT : public CNullParameterTest
{
public:
    CGetStreamInfoNPT( IMediaObject* pDMO, STREAM_TYPE st, DWORD dwStreamIndex  );

private:
    HRESULT PreformOperation( IMediaObject* pDMO, DWORD dwNullParameterMask );
    bool ValidateGetStreamInfoFlags( DWORD dwFlags );
    const TCHAR* GetOperationName( void ) const;

    DWORD m_dwStreamIndex;
    STREAM_TYPE m_stStreamType;
};

#endif // NullParameterTest_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\testobj.cpp ===
#include <windows.h>
#include <mediaobj.h>
#include <atlbase.h>
#include <s98inc.h>
extern CComModule _Module;
#include <atlcom.h>
#include <initguid.h>

#include <atlconv.h>

#include <filefmt.h>
#include <filerw.h>
#include <tchar.h>
#include "testobj.h"
#include "dmort.h"
#include "Error.h"
#include <streams.h>
//#include <wmsdkidl.h>
#include <mediaerr.h>

#ifdef ENABLE_SECURE_DMO
#include <wmsdkidl.h>
#endif
int interval = 100;

CDMOObject::CDMOObject() :
     m_pInputBuffers(NULL),
	 m_processCounter(0)
{
}

HRESULT CDMOObject::Create(REFCLSID rclsidObject, BOOL bAggregated)
{
    HRESULT hr;

    if (bAggregated) {
        CComObject<CMyAggregator> *pObject = new CComObject<CMyAggregator>;
        if (pObject == NULL) {
            //Error(ERROR_TYPE_TEST, E_OUTOFMEMORY, TEXT("Out of memory"));
			g_IShell->Log(1, "TEST ERROR, Out of Memory.");
            return E_OUTOFMEMORY;
        }

        hr = pObject->SetCLSID(rclsidObject);
        if (FAILED(hr)) {
            return hr;
        }

        hr = pObject->GetControllingUnknown()->QueryInterface(
                         IID_IMediaObject, (void **)&m_pMediaObject);

        if (FAILED(hr)) {
            //Error(ERROR_TYPE_DMO, hr, TEXT("Create aggregated failed"));
			g_IShell->Log(1, "DMO ERROR, Create Aggregated Failed.");
            return hr;
        }

    } else {
         //  See if we can create it
        HRESULT hr = CoCreateInstance(rclsidObject,
                                      NULL,
                                      CLSCTX_INPROC,
                                      IID_IMediaObject,
                                      (void **)&m_pMediaObject);
        if (FAILED(hr)) {
            Error(ERROR_TYPE_DMO, hr, TEXT("Create non-aggregated failed"));
			g_IShell->Log(1, "DMO ERROR, Create non-aggregated failed.");
            return hr;
        }
    }
    
    #ifdef ENABLE_SECURE_DMO
    hr = CreateSecureChannel( m_pMediaObject, &m_pCertUnknown, &m_pTestAppSecureChannel );
    if( FAILED( hr ) ) {
        Error(ERROR_TYPE_DMO, hr, TEXT("The test application could not create a secure channel."));
		g_IShell->Log(1, "DMO ERROR, The test application could not create a secure channel.");
		return hr;
    }

    // CreateSecureChannel() has two valid success values: S_OK and S_FALSE.
    ASSERT( (S_OK == hr) || (S_FALSE == hr) );

    #endif // ENABLE_SECURE_DMO
    
    return S_OK;
}

#if 0
HRESULT CDMOObject::Stream(LPCTSTR lpszFile)
{
    //  Open the index and real files
    FILE *hFileIndex = _tfopen(lpszIndex, TEXT("r"));
    if (hFileIndex == NULL) {
        TCHAR szText[1000];
        wsprintf(szFile, TEXT("Could not open index file %s"), lpszIndex);
        Error(ERROR_TYPE_TEST, E_FAIL, szText);
        return E_FAIL;
    }

    //  Open the real file
    HANDLE hFile = CreateFile(lpszFile,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL);

    if (hFile == INVALID_FILE_HANDLE) {
        DWORD dwError = GetLastError();
        TCHAR szText[1000];
        wsprintf(szFile, TEXT("Could not open index file %s"), lpszIndex);
        Error(ERROR_TYPE_TEST, szText, E_FAIL);

        return E_FAIL;
    }


    //
}
#endif

#define CALL_WITH_HANDLER(_method_, _x_) \
    HRESULT hr; \
    __try { \
        hr = m_pMediaObject->_method_ _x_;   \
    } __except(EXCEPTION_EXECUTE_HANDLER) { \
        hr = E_FAIL; \
        Error(ERROR_TYPE_DMO, E_FAIL, TEXT(#_method_) TEXT(" exception code %d"),\
              GetExceptionCode()); \
		g_IShell->Log(1, "DMO ERROR: Exception Code %d", GetExceptionCode()); \
    } \

#define CALL_OBJECT_WITH_HANDLER(_object_, _method_, _x_) \
    HRESULT hr; \
    __try { \
        hr = _object_->_method_ _x_;   \
    } __except(EXCEPTION_EXECUTE_HANDLER) { \
        hr = E_FAIL; \
        Error(ERROR_TYPE_DMO, E_FAIL, TEXT(#_method_) TEXT(" exception code %d"),\
              GetExceptionCode()); \
		g_IShell->Log(1, "DMO ERROR: Exception Code %d", GetExceptionCode()); \
    } \


//  Shadow IMediaObject
HRESULT CDMOObject::GetStreamCount(
        DWORD *pcInputStreams,
        DWORD *pcOutputStreams
)
{
	if(m_processCounter%interval == 0)
		g_IShell->Log(1, "  Testing GetStreamCount()");

    CALL_WITH_HANDLER(GetStreamCount, (pcInputStreams, pcOutputStreams))
    return hr;
}
HRESULT CDMOObject::GetInputStreamInfo(
        DWORD dwInputStreamIndex, // 0-based
        DWORD *pdwFlags // HOLDS_BUFFERS
)
{
	if(m_processCounter%interval == 0)
		g_IShell->Log(1, "  Testing GetInputStreamInfo()");
    CALL_WITH_HANDLER(GetInputStreamInfo, (dwInputStreamIndex, pdwFlags))

    if (pdwFlags == NULL && hr != E_POINTER) {
        Error(ERROR_TYPE_DMO, hr, TEXT("GetInputStreamInfo returned %x when passed in NULL pointer"),
              hr);
		g_IShell->Log(1, "DMO ERROR: GetInputStreamInfo returned %x when passed in NULL pointer",
   hr);

    }

    //  Check flags
    if (SUCCEEDED(hr) && pdwFlags && 
        (*pdwFlags & ~
          (DMO_INPUT_STREAMF_WHOLE_SAMPLES |
           DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
           DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE |
           DMO_INPUT_STREAMF_HOLDS_BUFFERS
          )
        )
       ){
        Error(ERROR_TYPE_DMO, E_FAIL, TEXT("Invalid GetStreamInfo flags %x"), *pdwFlags);
		g_IShell->Log(1, "DMO ERROR: Invalid GetStreamInfo flags %x", *pdwFlags);
    }


    return hr;
}
HRESULT CDMOObject::GetOutputStreamInfo(
        DWORD dwOutputStreamIndex, // 0-based
        DWORD *pdwFlags      // Media object sets to 0
)
{
	if(m_processCounter%interval == 0)
	g_IShell->Log(1, "  Testing GetOutputStreamInfo()");
    CALL_WITH_HANDLER(GetOutputStreamInfo, (dwOutputStreamIndex, pdwFlags))
    return hr;
}


//
// GetType - iterate through media types supported by a stream.
// Returns S_FALSE if the type index is out of range ("no more types").
//
HRESULT CDMOObject::GetInputType(
        DWORD dwInputStreamIndex,
        DWORD dwTypeIndex, // 0-based
        DMO_MEDIA_TYPE *pmt
)
{

	g_IShell->Log(1, "  Testing GetInputType");
    CALL_WITH_HANDLER(GetInputType, (dwInputStreamIndex, dwTypeIndex, pmt));
    return hr;
}
HRESULT CDMOObject::GetOutputType(
        DWORD dwOutputStreamIndex,
        DWORD dwTypeIndex, // 0-based
        DMO_MEDIA_TYPE *pmt
)
{

		g_IShell->Log(1, "  Testing GetOutputType");
	CALL_WITH_HANDLER(GetOutputType, (dwOutputStreamIndex, dwTypeIndex, pmt));
    return hr;
}

//
// SetType - tell the object the type of data it will work with.
//
HRESULT CDMOObject::SetInputType(
        DWORD dwInputStreamIndex,
        const DMO_MEDIA_TYPE *pmt,
        DWORD dwFlags // test only
)
{

	g_IShell->Log(1, "  Testing SetInputType");
    CALL_WITH_HANDLER(SetInputType, (dwInputStreamIndex, pmt, dwFlags));
    return hr;
}
HRESULT CDMOObject::SetOutputType(
        DWORD dwOutputStreamIndex,
        const DMO_MEDIA_TYPE *pmt,
        DWORD dwFlags // test only
)
{

	g_IShell->Log(1, "  Testing SetOutputType");
    CALL_WITH_HANDLER(SetOutputType, (dwOutputStreamIndex, pmt, dwFlags));
    return hr;
}

//
// GetCurrentType - get the last mediatype supplied via SetType.
// Returns S_FALSE if SetType has not been called.
//
HRESULT CDMOObject::GetInputCurrentType(
        DWORD dwInputStreamIndex,
        DMO_MEDIA_TYPE *pmt
)
{

	g_IShell->Log(1, "  Testing GetInputCurrentType");
    CALL_WITH_HANDLER(GetInputCurrentType, (dwInputStreamIndex, pmt));
    return hr;
}
HRESULT CDMOObject::GetOutputCurrentType(
        DWORD dwOutputStreamIndex,
        DMO_MEDIA_TYPE *pmt
)
{

	g_IShell->Log(1, "  Testing GetOutputCurrentType");
    CALL_WITH_HANDLER(GetOutputCurrentType, (dwOutputStreamIndex, pmt));
    return hr;
}



//
// GetSizeInfo - Get buffer size requirementes of a stream.
//
// If buffer size depends on the media type used, the object should
// base its response on the most recent media type set for this stream.
// If no mediatype has been set, the object may return an error.
//
HRESULT CDMOObject::GetInputSizeInfo(
        DWORD dwInputStreamIndex,
        DWORD *pcbSize, // size of input 'quantum'
        DWORD *pcbMaxLookahead, // max total bytes held
        DWORD *pcbAlignment  // buffer alignment requirement
)
{

	g_IShell->Log(1, "  Testing GetInputSizeInfo");
    CALL_WITH_HANDLER(GetInputSizeInfo, (dwInputStreamIndex, pcbSize,pcbMaxLookahead, pcbAlignment));
    return hr;
}
HRESULT CDMOObject::GetOutputSizeInfo(
        DWORD dwOutputStreamIndex,
        DWORD *pcbSize, // size of output 'quantum'
        DWORD *pcbAlignment  // buffer alignment requirement
)
{
	if(m_processCounter%interval == 0)
	g_IShell->Log(1, "  Testing GetOutputSizeInfo");
    CALL_WITH_HANDLER(GetOutputSizeInfo, (dwOutputStreamIndex, pcbSize, pcbAlignment))
    return hr;
}



HRESULT CDMOObject::GetInputMaxLatency(
        DWORD dwInputStreamIndex,
        REFERENCE_TIME *prtMaxLatency
)
{

	g_IShell->Log(1, "  Testing GetInputMaxLatency");
    CALL_WITH_HANDLER(GetInputMaxLatency, (dwInputStreamIndex, prtMaxLatency))
    return hr;
}
HRESULT CDMOObject::SetInputMaxLatency(
        DWORD dwInputStreamIndex,
        REFERENCE_TIME rtMaxLatency
)
{

	g_IShell->Log(1, "  Testing SetInputMaxLatency");
    CALL_WITH_HANDLER(SetInputMaxLatency, (dwInputStreamIndex, rtMaxLatency))
    return hr;
}


//
// Flush() - discard any buffered data.
//
HRESULT CDMOObject::Flush()
{

	g_IShell->Log(1, "  Testing Flush" );
    CALL_WITH_HANDLER(Flush, ());
    if (m_pInputBuffers) {
        Error(ERROR_TYPE_DMO, E_FAIL,
              TEXT("Holding on to buffers after Flush()"));
	g_IShell->Log(1, "DMO ERROR: Holding on to buffers after Flush()");
    }
    return hr;
}

//
// Send a discontinuity to an input stream.  The object will not
// accept any more data on this input stream until the discontinuity
// has been completely processed, which may involve multiple
// ProcessOutput() calls.
//
HRESULT CDMOObject::Discontinuity(DWORD dwInputStreamIndex)
{
	g_IShell->Log(1, "  Testing Discontinuity ");
    CALL_WITH_HANDLER(Discontinuity, (dwInputStreamIndex))
    return hr;
}

//
// If a streaming object needs to perform any time consuming
// initialization before it can stream data, it should do it inside
// AllocateStreamingResources() rather than during the first process
// call.
//
// This method is NOT guaranteed to be called before streaming
// starts.  If it is not called, the object should perform any
// required initialization during a process call.
//
HRESULT CDMOObject::AllocateStreamingResources()
{
	g_IShell->Log(1, "  Testing AllocateStreamingResources()");
    CALL_WITH_HANDLER(AllocateStreamingResources, ())
    return hr;
}

// Free anything allocated in AllocateStreamingResources().
HRESULT CDMOObject::FreeStreamingResources()
{
	g_IShell->Log(1, "  Testing FreeStreamingResources()");
    CALL_WITH_HANDLER(FreeStreamingResources, ())
    return hr;
}

// GetInputStatus - the only flag defined right now is ACCEPT_DATA.
HRESULT CDMOObject::GetInputStatus(
        DWORD dwInputStreamIndex,
        DWORD *dwFlags // ACCEPT_DATA
)
{
	g_IShell->Log(1, "  Testing GetInputStatus");
    CALL_WITH_HANDLER(GetInputStatus, (dwInputStreamIndex, dwFlags));
    return hr;
}

//
// Pass one new buffer to an input stream
//
HRESULT CDMOObject::ProcessInput(
        DWORD dwInputStreamIndex,
        IMediaBuffer *pBuffer, // must not be NULL
        DWORD dwFlags, // DMO_INPUT_DATA_BUFFERF_XXX (syncpoint, etc.)
        REFERENCE_TIME rtTimestamp, // valid if flag set
        REFERENCE_TIME rtTimelength // valid if flag set
)
{

    IMediaBuffer* pBufferUsed = pBuffer;

    #ifdef ENABLE_SECURE_DMO

    // Encrypt the buffer pointer if this is a secure DMO,
    if( m_pTestAppSecureChannel ) { // NULL != m_pTestAppSecureChannel

        IMediaBuffer* pEncryptedBuffer = pBuffer;
		//g_IShell->Log(1, "Encrypt the buffer pointer if this is a secure DMO");
        CALL_OBJECT_WITH_HANDLER( m_pTestAppSecureChannel, WMSC_Encrypt, ((BYTE*)&pEncryptedBuffer, sizeof(IMediaBuffer*)) );
        if( FAILED( hr ) ) {
            return hr;
        }
        
        pBufferUsed = pEncryptedBuffer;
    }
    #endif // ENABLE_SECURE_DMO

	if(m_processCounter%interval == 0)
	g_IShell->Log(1, "  Testing ProcessInput().");
    CALL_WITH_HANDLER(ProcessInput, (dwInputStreamIndex, pBufferUsed, dwFlags,
                      rtTimestamp, rtTimelength))


/*	HRESULT hr;
	hr = m_pMediaObject->ProcessInput(dwInputStreamIndex, pBufferUsed, dwFlags,
                      rtTimestamp, rtTimelength);*/
    return hr;
}

//
// ProcessOutput() - generate output for current input buffers
//
// Output stream specific status information is returned in the
// dwStatus member of each buffer wrapper structure.
//
HRESULT CDMOObject::ProcessOutput(
        DWORD dwReserved, // must be 0
        DWORD cOutputBufferCount, // # returned by GetStreamCount()
        DMO_OUTPUT_DATA_BUFFER *pOutputBuffers, // one per stream
        DWORD *pdwStatus  // TBD, must be set to 0
)
{
	if(m_processCounter%interval == 0)
	g_IShell->Log(1, "  Testing ProcessOutput().");
    DMO_OUTPUT_DATA_BUFFER* pOutputBuffersUsed = pOutputBuffers;

    #ifdef ENABLE_SECURE_DMO

    // Encrypt the buffer pointer if this is a secure DMO,
    if( m_pTestAppSecureChannel ) { // NULL != m_pTestAppSecureChannel

        DMO_OUTPUT_DATA_BUFFER* pEncryptedOutputBuffers = pOutputBuffers;

        CALL_OBJECT_WITH_HANDLER( m_pTestAppSecureChannel, WMSC_Encrypt, ((BYTE*)&pEncryptedOutputBuffers, sizeof(DMO_OUTPUT_DATA_BUFFER*)) );
        if( FAILED( hr ) ) {
            return hr;
        }
        
        pOutputBuffersUsed = pEncryptedOutputBuffers;
    }
    #endif // ENABLE_SECURE_DMO

    CALL_WITH_HANDLER(ProcessOutput, (dwReserved, cOutputBufferCount, pOutputBuffersUsed, pdwStatus))
    if (SUCCEEDED(hr)) {
        DWORD dwInputStreams = 0, dwOutputStreams = 0;

        //  Check outputs
        BOOL bMore = FALSE;

        for (DWORD dwIndex = 0; dwIndex < cOutputBufferCount; dwIndex++) {
            if (pOutputBuffers[dwIndex].dwStatus &
                DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE) {
                bMore = TRUE;
            }
		}
        
        if (bMore && S_FALSE == hr) {
            Error(ERROR_TYPE_DMO, E_FAIL,
                  TEXT("ProcessOutput returned S_FALSE but the output stream has DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE flag."));
			g_IShell->Log(1, "DMO ERROR: ProcessOutput returned S_FALSE but stream incomplete");
        }
        if (!bMore && !HoldsOnToBuffers()) {
            //  Check if we hold on to buffers
            if (m_pInputBuffers) {

                Error(ERROR_TYPE_DMO, E_FAIL,
                      TEXT("Holding on to buffers after ProcessOutput"));
			g_IShell->Log(1, "DMO ERROR: Holding on to buffers after ProcessOutput");
            }
        }
	
    }


    return hr;
}

HRESULT CDMOObject::CreateInputBuffer(
    DWORD dwSize,
    CMediaBuffer **ppBuffer)
{

    HRESULT hr = CreateBuffer(dwSize, ppBuffer, this);
    if (SUCCEEDED(hr)) {
        //  Add it to the tail
        CMediaBuffer **pSearch = &m_pInputBuffers;
        while (*pSearch) {
            pSearch = &(*pSearch)->m_pNext;
        }
        *pSearch = *ppBuffer;
    }
    return hr;
}

BOOL CDMOObject::HoldsOnToBuffers()
{
    BOOL bHoldsOnToBuffers = FALSE;
    DWORD cInputStreams = 0, cOutputStreams = 0;
    GetStreamCount(&cInputStreams, &cOutputStreams);
    for (DWORD dwIndex = 0; dwIndex < cInputStreams; dwIndex++) {
        DWORD dwFlags;
        GetInputStreamInfo(dwIndex, &dwFlags);
        if (dwFlags & DMO_INPUT_STREAMF_HOLDS_BUFFERS) {
            bHoldsOnToBuffers = TRUE;
        }
    }
    return bHoldsOnToBuffers;
}

HRESULT CDMOObject::SetDefaultOutputTypes() {

    HRESULT hrGet;
    HRESULT hrSet;
    DMO_MEDIA_TYPE mt;
    DWORD dwOutputTypeIndex;

	DWORD cInputStreams = 0, cOutputStreams = 0;
    GetStreamCount(&cInputStreams, &cOutputStreams);


	// try on each preferred type of the each of output stream.

	
	for(DWORD dwStreamIndex = 0; dwStreamIndex < cOutputStreams; dwStreamIndex++)
	{
	
		dwOutputTypeIndex = 0;

		DWORD dwFlags = 0;

        HRESULT hr = GetOutputStreamInfo(dwStreamIndex, &dwFlags);

         if (FAILED(hr)) {
             //Error(ERROR_TYPE_DMO, hr, TEXT("Failed to get output size info"));
			 g_IShell->Log(1, "DMO ERROR, Failed in GetOutputStreamInfo() for stream %d. hr=%#08x",dwStreamIndex, hr);
             break;
         }

		do {
			hrGet = GetOutputType( dwStreamIndex, dwOutputTypeIndex, &mt );
			if( FAILED( hrGet ) && (DMO_E_NO_MORE_ITEMS != hrGet) ) {
				return hrGet;
			}
			wchar_t tempStr[50];
			TCHAR tempStr2[50];

			int r = ::StringFromGUID2(mt.formattype, tempStr, 50);

			wcstombs(tempStr2, tempStr,50);

			::CoTaskMemFree( tempStr );

		

			if( mt.formattype == FORMAT_VideoInfo)
			{
			//	g_IShell->Log(1, "formattype = FORMAT_VideoInfo");	
			//	g_IShell->Log(1, "before set: dwBitRate = %d", ((VIDEOINFOHEADER *)(mt.pbFormat))->dwBitRate);
				((VIDEOINFOHEADER *)(mt.pbFormat))->dwBitRate = 18140; //18140 22998 25913
			//	g_IShell->Log(1, "after set: dwBitRate = %d", ((VIDEOINFOHEADER *)(mt.pbFormat))->dwBitRate);

			}


			if( S_OK == hrGet ) {
				hrSet = SetOutputType( dwStreamIndex, &mt, 0 );
				MoFreeMediaType(&mt);
				dwOutputTypeIndex++;
			}
		} while( (hrGet != DMO_E_NO_MORE_ITEMS) && FAILED( hrSet ) );

	
		if( FAILED( hrSet ) ) {
			//Error( ERROR_TYPE_DMO, TEXT("ERROR: Stream 0's inplementation of IMediaObject::SetOutputType() will not accept any of the media types returned by IMediaObject::GetOutputType().") );
			g_IShell->Log(1, "DMO ERROR: Stream %d's implementation of IMediaObject::SetOutputType() will not accept any of the media types returned by IMediaObject::GetOutputType().",dwStreamIndex);
			return E_FAIL;
		}    
	}


    return S_OK;
}

#ifdef ENABLE_SECURE_DMO
HRESULT CDMOObject::CreateSecureChannel( IMediaObject* pMediaObject, IUnknown** ppCertUnknown, IWMSecureChannel** ppSecureChannel )
{
    // Acknoledgements: This code is based on the CMediaWrapperFilter::SetupSecureChannel() function
    // which is located in the Direct Show DMO Wrapper Filter.

    // Make sure the caller does not use random data.
    *ppCertUnknown = NULL;
    *ppSecureChannel = NULL;

#ifdef _X86

    // next check whether this is a secure dmo
    CComPtr<IWMGetSecureChannel> pGetSecureChannel;

    HRESULT hr = pMediaObject->QueryInterface( IID_IWMGetSecureChannel, (void**)&pGetSecureChannel );
    if( SUCCEEDED( hr ) )
    {
        CComPtr<IUnknown> pCertUnknown;
        
        hr = WMCreateCertificate( &pCertUnknown );
        if( SUCCEEDED( hr ) )
        {

            // pass app certification to dmo through secure channel
            CComPtr<IWMSecureChannel> pCodecSecureChannel;

            hr = pGetSecureChannel->GetPeerSecureChannelInterface( &pCodecSecureChannel );
            if ( SUCCEEDED( hr ) )
            {
                CComPtr<IWMSecureChannel> pSecureChannel;

                // setup a secure channel on our side (the dmo wrapper side)
                hr = WMCreateSecureChannel( &pSecureChannel );
                if( SUCCEEDED( hr ) )
                {
                    CComPtr<IWMAuthorizer> pAuthorizer;

                    hr = pCertUnknown->QueryInterface( IID_IWMAuthorizer, (void**)&pAuthorizer );
                    if( SUCCEEDED( hr ) )
                    {

                        // pass the channel the app certificate
                        hr = pSecureChannel->WMSC_AddCertificate( pAuthorizer );
                        if( SUCCEEDED( hr ) )
                        {
                            // connect the dmo wrapper's secure channel to the codec's
                            hr = pSecureChannel->WMSC_Connect( pCodecSecureChannel );
                            if( SUCCEEDED( hr ) )
                            {
                                *ppCertUnknown = pCertUnknown;
                                *ppSecureChannel = pSecureChannel;

                                (*ppCertUnknown)->AddRef();
                                (*ppSecureChannel)->AddRef();
                            }                   
                        }
                    }
                }
            }
        }
    }
    else
    {
        // this dmo's not secure so just return success and continue on
        hr = S_FALSE;
    }

    return hr;
#else // !_X86
    // wmsdk not supported on non-x86 and WIN64 platforms, for those just return success
    return S_FALSE;
#endif // !_X86
}
#endif // ENABLE_SECURE_DMO

//  End shadow IMediaObject

HRESULT CreateBuffer(
    DWORD cbMaxLength,
    CMediaBuffer **ppBuffer,
    CDMOObject *pObject)
{
    CMediaBuffer *pBuffer = new CMediaBuffer(cbMaxLength, pObject);
    if (pBuffer == NULL || FAILED(pBuffer->Init())) {
        delete pBuffer;
        *ppBuffer = NULL;
        Error(ERROR_TYPE_TEST, E_OUTOFMEMORY, TEXT("Could not allocate buffer size %d"), cbMaxLength);
		g_IShell->Log(1, "TEST ERROR, Could not allocate buffer size %d", cbMaxLength);
        return E_OUTOFMEMORY;
    }
    *ppBuffer = pBuffer;
    (*ppBuffer)->AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\tests.cpp ===
#include <windows.h>
#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>
#include <mediaobj.h>
#include <streams.h>
#include <filefmt.h>
#include <filerw.h>
#include <s98inc.h>
#include <mediaerr.h>
#include "testobj.h"
#include "tests.h"

int iInterval = 100;

//  Media object tests

//  Simple stream test

HRESULT CTest::SimpleStream()
{
	
    //  Make the object
    HRESULT hr = InitObject();
    if (FAILED(hr)) {
		g_IShell->Log(1, "TEST ERROR: Can not create object.");
        return hr;
    }

    //  Make the file
    CTestFileRead File;
    hr = File.Open(m_pszTestFile);
    if (FAILED(hr)) {
		g_IShell->Log(1, "TEST ERROR: Can not open test file %s.", m_pszTestFile);
        return hr;
    }

    //  Process the file through the object
    for (; ; ) {

        hr = File.Next();
        if (S_FALSE == hr) {
            break;
        }
        if (FAILED(hr)) {
            return hr;
        }

        hr = S_OK;

        //  Drive the object
        if (File.Type() == CFileFormat::MediaType) {
            hr = ProcessType(File.Stream(), File.MediaType());
        }

        //  Process sample data
        else if (File.Type() == CFileFormat::Sample) {
            hr = ProcessSample(File.Stream(),
                               File.Sample()->dwFlags,
                               File.Sample()->llStartTime,
                               File.Sample()->llLength,
                               (PBYTE)(File.Sample() + 1),
                               File.Sample()->dwLength -
                                   sizeof(CFileFormat::CSample)
                               );
        }
        if (FAILED(hr)) {
            return hr;
        }
    }
	// signals a discontinuity and processes any remaining output:
    return EndOfData();
}

//  Process a media type:sets media types for all the streams
//  set the appropriate input stream's type and change the default (0's)
// output stream's media type
HRESULT CTest::ProcessType(DWORD dwStream, DMO_MEDIA_TYPE *pmt)
{

/*
	g_IShell->Log(1, "\nStart testing DMO_SET_TYPEF_CLEAR flag.");
    //  Try setting the type
    HRESULT hr = m_pObject->SetInputType(dwStream, pmt, 0);
    if (FAILED(hr)) {
	   	g_IShell->Log(1, "DMO ERROR: Failed in SetInputType(). hr = %#08x", hr);
       return hr;
    }

	DWORD dwFlag = 0;
	dwFlag |= DMO_SET_TYPEF_CLEAR;
	DMO_MEDIA_TYPE CurrentMt;

	if(pmt != NULL)
	{
		hr = m_pObject->SetInputType(dwStream, NULL, dwFlag);
		if (FAILED(hr)) {
	   		g_IShell->Log(1, "DMO ERROR: Failed in SetInputType(). hr = %#08x", hr);
			return hr;
		}
	}
	
	hr = m_pObject->GetInputCurrentType(dwStream, &CurrentMt);
    if (FAILED(hr)) {
	   	g_IShell->Log(1, "DMO ERROR: Failed in GetInputCurrentType(). hr = %#08x", hr);
       return hr;
    }
	if(&CurrentMt != NULL)
	{
		g_IShell->Log(1, "DMO_SET_TYPEF_CLEAR flag failed to clear the current media type");

	}
	g_IShell->Log(1, "End testing DMO_SET_TYPEF_CLEAR flag.");
*/
	g_IShell->Log(1, "-->Process Type.");

    //  Try setting the type
    HRESULT hr = m_pObject->SetInputType(dwStream, pmt, 0);
    if (FAILED(hr)) {
	   	g_IShell->Log(1, "DMO ERROR: Failed in SetInputType(). hr = %#08x", hr);
       return hr;
    }
/*	DMO_MEDIA_TYPE CurrentMt;
	hr = m_pObject->GetInputCurrentType(dwStream, &CurrentMt);
    if (FAILED(hr)) {
	   	g_IShell->Log(1, "DMO ERROR: Failed in GetInputCurrentType(). hr = %#08x", hr);
        return hr;
    }*/
    //  Urk - what output type should we use?
    //  For now use the first output type they propose
    //  or their current type if they still have one

    
	
	hr = m_pObject->SetDefaultOutputTypes();
    return hr;
}

HRESULT CTest::ProcessSample(
    DWORD dwStreamId,
    DWORD dwFlags,
    LONGLONG llStartTime,
    LONGLONG llLength,
    BYTE *pbData,
    DWORD cbData
)
{


	HRESULT hr;



	// testing zero size buffer:
	if(m_sampleCounter == 0)
	{
		g_IShell->Log(1, "\nStart testing Zero size buffer");

		// allocates input buffers:
		//  First create an IMediaBuffer
		DWORD cbDataZero = 0;
		CMediaBuffer *pInputBufferZero;
		hr = m_pObject->CreateInputBuffer(cbDataZero, &pInputBufferZero);
		if (FAILED(hr)) {
			return hr;
		}
		// fills the input buffers with input data and calls ProcessInput
		pInputBufferZero->m_cbLength = cbDataZero;

		DWORD dwFlagZero = 0;
		DWORD dwStreamId = 0;

		hr = m_pObject->ProcessInput(dwStreamId,
                                 pInputBufferZero,
                                 dwFlagZero,
                                 llStartTime,
                                 llLength);

		//  BUGBUG check ref count

		pInputBufferZero->Release();

		hr = m_pObject->Flush();
		if (FAILED(hr)) {
			//Error(ERROR_TYPE_DMO, hr, TEXT("ProcessInput failed"));
			g_IShell->Log(1, "DMO ERROR: Flush() failed" );
			return hr;
		}

		if (SUCCEEDED(hr) || hr == DMO_E_NOTACCEPTING) 	
		{
			// calls ProcessOutput and retrieves the output data
			hr = ProcessOutputZero();
		}
		g_IShell->Log(1, "End Testing Zero Size Buffer");
	}



	//check consistency of 'can accept data' flags, using the first sample
	//(pass some when they say they can't and check return when they say they can)


	if(m_sampleCounter == 0)
	{
		g_IShell->Log(1, "\nStart testing 'can accept data' flags");

		// start testing 'can accept data' flag:
		// allocates input buffers:
		//  First create an IMediaBuffer
		CMediaBuffer *pInputBuffer;
		hr = m_pObject->CreateInputBuffer(cbData, &pInputBuffer);
		if (FAILED(hr)) {
			return hr;
		}
		// fills the input buffers with input data and calls ProcessInput
		CopyMemory(pInputBuffer->m_pbData, pbData, cbData);
		pInputBuffer->m_cbLength = cbData;


		DWORD dwAcceptDataFlag = 0;

		hr = m_pObject->GetInputStatus( dwStreamId, &dwAcceptDataFlag );
		if (FAILED(hr)) {
			g_IShell->Log(1, "GetInputStatus() failed");
		}
		g_IShell->Log(1, "dwAcceptDataFlag = %#08x", dwAcceptDataFlag);
		while( dwAcceptDataFlag&DMO_INPUT_STATUSF_ACCEPT_DATA )
		{
			
			hr = m_pObject->ProcessInput(dwStreamId,
									pInputBuffer,
									dwFlags,
									llStartTime + m_llTimeOffset,
									llLength);

			if(hr == DMO_E_NOTACCEPTING)
			{
				g_IShell->Log(1, "DMO ERROR: GetInputStatus returns DMO_INPUT_STATUSF_ACCEPT_DATA flag, but ProcessInput returns DMO_E_NOTACCEPTING");
			}

		
			hr = m_pObject->GetInputStatus( dwStreamId, &dwAcceptDataFlag );
			g_IShell->Log(1, "dwAcceptDataFlag = %#08x", dwAcceptDataFlag);
		}
		g_IShell->Log(1, "End testing 'can accept data' flags\n");
		g_IShell->Log(1, "\nStart testing 'can not accept data' flags");
		hr = m_pObject->ProcessInput(dwStreamId,
									pInputBuffer,
									dwFlags,
									llStartTime + m_llTimeOffset,
									llLength);

		if(SUCCEEDED(hr))
		{
			g_IShell->Log(1, "DMO ERROR: GetInputStatus does not return DMO_INPUT_STATUSF_ACCEPT_DATA flag, but ProcessInput returns DMO_E_NOTACCEPTING");
		
		}

		//  BUGBUG check ref count
		pInputBuffer->Release();

	
		hr = m_pObject->Flush();
		if (FAILED(hr)) {
			//Error(ERROR_TYPE_DMO, hr, TEXT("ProcessInput failed"));
			g_IShell->Log(1, "DMO ERROR: Flush() failed" );
			return hr;
		}
		//end of testing 'can accept data' flag:
		g_IShell->Log(1, "End testing 'can not accept data' flags\n");
	}

	if(	m_sampleCounter%iInterval == 0)
	g_IShell->Log(1, "-->Process Sample %d.", m_sampleCounter);
	m_sampleCounter++;

	
	// allocates input buffers:
    //  First create an IMediaBuffer
    CMediaBuffer *pInputBuffer;
    hr = m_pObject->CreateInputBuffer(cbData, &pInputBuffer);
    if (FAILED(hr)) {
        return hr;
    }
	// fills the input buffers with input data and calls ProcessInput
    CopyMemory(pInputBuffer->m_pbData, pbData, cbData);
    pInputBuffer->m_cbLength = cbData;



	hr = m_pObject->ProcessInput(dwStreamId,
									pInputBuffer,
									dwFlags,
									llStartTime + m_llTimeOffset,
									llLength);
	

	//  BUGBUG check ref count

	pInputBuffer->Release();
	if (FAILED(hr)) {
		//Error(ERROR_TYPE_DMO, hr, TEXT("ProcessInput failed"));
		g_IShell->Log(1, "DMO ERROR: ##ProcessInput() Failed at sample %d for stream %d. hr =%#08x", m_sampleCounter,dwStreamId, hr);
		return hr;
	}

	//  Now suck any data out
	if (S_FALSE == hr) {
		//  No data to process
		g_IShell->Log(1, "No data to process. ProcessOutput() will not be called.");
	} else {
		// calls ProcessOutput and retrieves the output data
		hr = ProcessOutputs();
	}
	
	m_pObject->m_processCounter++;
	
	return hr;
}

HRESULT CTest::ProcessOutputs()
{
    HRESULT hr = S_OK;
    //  Filter out other success codes??

	


    //  Find the number of output streams
    DWORD cInputStreams, cOutputStreams;
    hr = m_pObject->GetStreamCount(&cInputStreams, &cOutputStreams);

    CMediaBuffer **ppOutputBuffers =
        (CMediaBuffer **)_alloca(cOutputStreams * sizeof(CMediaBuffer*));
    //  Create the regular structures

    DMO_OUTPUT_DATA_BUFFER *pDataBuffers =
        (DMO_OUTPUT_DATA_BUFFER *)
        _alloca(cOutputStreams * sizeof(DMO_OUTPUT_DATA_BUFFER));

    for (DWORD dwOutputStreamIndex = 0; dwOutputStreamIndex < cOutputStreams;
         dwOutputStreamIndex++) {

         //  Get the expected buffer sizes - need to test these
         //  don't change between type changes
         DWORD dwOutputBufferSize;
         DWORD dwOutputAlignment;
         hr = m_pObject->GetOutputSizeInfo(dwOutputStreamIndex,
                                           &dwOutputBufferSize,
                                           &dwOutputAlignment);
         if (FAILED(hr)) {
             //Error(ERROR_TYPE_DMO, hr, TEXT("Failed to get output size info"));
			 g_IShell->Log(1, "DMO ERROR, Failed in GetOutputSizeInfo() at sample %d for stream %d. hr=%#08x",m_sampleCounter,dwOutputStreamIndex, hr);
             break;
         }

		 DWORD dwFlags = 0;

        hr = m_pObject->GetOutputStreamInfo(dwOutputStreamIndex, &dwFlags);

	
         if (FAILED(hr)) {
             //Error(ERROR_TYPE_DMO, hr, TEXT("Failed to get output size info"));
			 g_IShell->Log(1, "DMO ERROR, Failed in GetOutputStreamInfo() at sample %d for stream %d. hr=%#08x",m_sampleCounter,dwOutputStreamIndex, hr);
             break;
         }




         hr = CreateBuffer(
                   dwOutputBufferSize,
                   &ppOutputBuffers[dwOutputStreamIndex]);
         if (FAILED(hr)) {
			 g_IShell->Log(1, "TEST ERROR: Out of Memory.");
             break;
         }
         pDataBuffers[dwOutputStreamIndex].pBuffer =
             ppOutputBuffers[dwOutputStreamIndex];
         pDataBuffers[dwOutputStreamIndex].dwStatus = 0xFFFFFFFF;
         pDataBuffers[dwOutputStreamIndex].rtTimestamp = -1;
         pDataBuffers[dwOutputStreamIndex].rtTimelength = -1;
    }

    //  Process until no more data
    BOOL bContinue;
    if (SUCCEEDED(hr)) do
    {
        if (SUCCEEDED(hr)) {
            DWORD dwStatus;
            hr = m_pObject->ProcessOutput(
                0,
                cOutputStreams,
                pDataBuffers,
                &dwStatus);

            if (FAILED(hr)) {
                //Error(ERROR_TYPE_DMO, hr, TEXT("ProcessOutput failed"));
				g_IShell->Log(1, "DMO ERROR, ProcessOutput() failed at sample %d. hr = %#08x",m_sampleCounter, hr);
				return hr;
            }
        }

        // IMediaObject::ProcessOutput() returns S_FALSE if there is not more data to process.
        if (SUCCEEDED(hr) && (S_FALSE != hr)) {
            for (DWORD dwIndex = 0; dwIndex < cOutputStreams; dwIndex++ ) {
                hr = ProcessOutput(dwIndex,
                                   pDataBuffers[dwIndex].dwStatus,
                                   ppOutputBuffers[dwIndex]->m_pbData,
                                   ppOutputBuffers[dwIndex]->m_cbLength,
                                   pDataBuffers[dwIndex].rtTimestamp,
                                   pDataBuffers[dwIndex].rtTimelength);
                if (FAILED(hr)) {
					g_IShell->Log(1, "DMO ERROR, ProcessOutput() failed at sample %d for stream %d. hr=%#08x",m_sampleCounter, dwIndex,hr);
                    return hr;
                }

                hr = pDataBuffers[dwIndex].pBuffer->SetLength( 0 );
                if (FAILED(hr)) {
                    break;
                }
            }
            if (FAILED(hr)) {
                break;
            }
        }

        //  Continue if any stream says its incomplete
        bContinue = FALSE;
        for (DWORD dwIndex = 0; dwIndex < cOutputStreams; dwIndex++) {
            if (pDataBuffers[dwIndex].dwStatus &
                DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE) {
                bContinue = TRUE;
            }
        }
    } while (bContinue);
    //  Free any buffers we allocated
    for (DWORD dwIndex = 0; dwIndex < dwOutputStreamIndex; dwIndex++) {
        ppOutputBuffers[dwIndex]->Release();
    }
    return hr;
}














HRESULT CTest::ProcessOutputZero()
{
    HRESULT hr = S_OK;
    //  Filter out other success codes??

    //  Find the number of output streams
    DWORD cInputStreams;
	DWORD cOutputStreams=1;
    //hr = m_pObject->GetStreamCount(&cInputStreams, &cOutputStreams);

    CMediaBuffer **ppOutputBuffers =
        (CMediaBuffer **)_alloca(cOutputStreams * sizeof(CMediaBuffer*));
    //  Create the regular structures

    DMO_OUTPUT_DATA_BUFFER *pDataBuffers =
        (DMO_OUTPUT_DATA_BUFFER *)
        _alloca(cOutputStreams * sizeof(DMO_OUTPUT_DATA_BUFFER));

    for (DWORD dwOutputStreamIndex = 0; dwOutputStreamIndex < cOutputStreams;
         dwOutputStreamIndex++) {

         //  Get the expected buffer sizes - need to test these
         //  don't change between type changes
         DWORD dwOutputBufferSize;
         DWORD dwOutputAlignment;
         hr = m_pObject->GetOutputSizeInfo(dwOutputStreamIndex,
                                           &dwOutputBufferSize,
                                           &dwOutputAlignment);
         if (FAILED(hr)) {
             //Error(ERROR_TYPE_DMO, hr, TEXT("Failed to get output size info"));
			 g_IShell->Log(1, "DMO ERROR, Failed in GetOutputSizeInfo() at sample %d for stream %d. hr=%#08x",m_sampleCounter,dwOutputStreamIndex, hr);
             break;
         }

		 DWORD dwFlags = 0;

        hr = m_pObject->GetOutputStreamInfo(dwOutputStreamIndex, &dwFlags);

	
         if (FAILED(hr)) {
             //Error(ERROR_TYPE_DMO, hr, TEXT("Failed to get output size info"));
			 g_IShell->Log(1, "DMO ERROR, Failed in GetOutputStreamInfo() at sample %d for stream %d. hr=%#08x",m_sampleCounter,dwOutputStreamIndex, hr);
             break;
         }




         hr = CreateBuffer(
                   dwOutputBufferSize,
                   &ppOutputBuffers[dwOutputStreamIndex]);
         if (FAILED(hr)) {
			 g_IShell->Log(1, "TEST ERROR: Out of Memory.");
             break;
         }
         pDataBuffers[dwOutputStreamIndex].pBuffer =
             ppOutputBuffers[dwOutputStreamIndex];
         pDataBuffers[dwOutputStreamIndex].dwStatus = 0xFFFFFFFF;
         pDataBuffers[dwOutputStreamIndex].rtTimestamp = -1;
         pDataBuffers[dwOutputStreamIndex].rtTimelength = -1;
    }

    //  Process until no more data
    BOOL bContinue;
    if (SUCCEEDED(hr)) do
    {
        if (SUCCEEDED(hr)) {
            DWORD dwStatus;
            hr = m_pObject->ProcessOutput(
                0,
                cOutputStreams,
                pDataBuffers,
                &dwStatus);

			if(hr == S_OK){
				g_IShell->Log(1, "DMO ERROR, ProcessOutput() succeeded, even though ProcessInput uses Zero size buffer.");
				return E_FAIL;
            }
        }


        //  Continue if any stream says its incomplete
        bContinue = FALSE;
        for (DWORD dwIndex = 0; dwIndex < cOutputStreams; dwIndex++) {
            if (pDataBuffers[dwIndex].dwStatus &
                DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE) {
                bContinue = TRUE;
            }
        }
    } while (bContinue);
    //  Free any buffers we allocated
    for (DWORD dwIndex = 0; dwIndex < dwOutputStreamIndex; dwIndex++) {
        ppOutputBuffers[dwIndex]->Release();
    }
    return hr;
}























HRESULT CTest::ProcessOutput(
    DWORD dwOutputStreamIndex,
    DWORD dwFlags,
    PBYTE pbData,
    DWORD cbData,
    LONGLONG llTime,
    LONGLONG llLength
)
{
    //  Write to file or check against saved file
    return S_OK;
}

HRESULT CTest::EndOfData()
{
    //  Send Discontinuity on all streams
    DWORD cInputStreams = 0, cOutputStreams = 0;
    HRESULT hr = m_pObject->GetStreamCount(&cInputStreams, &cOutputStreams);
    for (DWORD dwIndex = 0; dwIndex < cInputStreams; dwIndex++) {
        hr = m_pObject->Discontinuity(dwIndex);
        if (FAILED(hr)) {
            //Error(ERROR_TYPE_DMO, hr, TEXT("Discontinuity Failed"));
			g_IShell->Log(1, "DMO ERROR, Discontinuity Failed. hr = %#08x", hr);
        }
    }
    hr = ProcessOutputs();

    //  Check there's no more data
    if (!m_pObject->CheckInputBuffersFree()) {
        //Error(ERROR_TYPE_DMO, E_FAIL, TEXT("Buffers not free after discontinuity"));
		g_IShell->Log(1, "DMO ERROR, Buffers not free after discontinuity.");
    }
    return hr;
}

HRESULT CTestSaveToFile::Save()
{
    //  Open the output file
    HRESULT hr = m_FileWrite.Open(m_pszOutputFile);
    if (FAILED(hr)) {
		g_IShell->Log(1, "TEST ERROR: Can not open output file.");
        return hr;
    }

    //  Stream our data
    return SimpleStream();
}

HRESULT CTestSaveToFile::ProcessOutput(
    DWORD dwOutputStreamIndex,
    DWORD dwFlags,
    PBYTE pbData,
    DWORD cbData,
    LONGLONG llTime,
    LONGLONG llLength)
{
    // The caller should only use this function if it actually has data to write.
    ASSERT( 0 != cbData );

    // pbData should always be a valid pointer.
    ASSERT( NULL != pbData );

    // It does not make sense to have a negative length.
    ASSERT( llLength >= 0 );

    //  Write this to our output file
    return m_FileWrite.WriteSample(
               dwOutputStreamIndex,
               pbData,
               cbData,
               dwFlags,

               //  Subtract time offset so we can see if files
               //  are in sync

               llTime - m_llTimeOffset,
               llLength);
}

HRESULT CTestSaveToFile::ProcessOutputTypeChange(
     DWORD dwOutputStreamIndex,
     const DMO_MEDIA_TYPE *pmt)
{
    return m_FileWrite.WriteMediaType(
               dwOutputStreamIndex,
               pmt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\tests.h ===
//  This is a class to stream data cusomizable by
//  the things we want to vary :
//
//   Data
//   Iterations
//

#include "Error.h"

class CTest
{
public:
    CTest(LPCTSTR lpszCurrentTest,
          REFCLSID rclsidObject,
          LPCTSTR lpszTestFile,
          LONGLONG llTimeOffset = 0) :
        m_lpszCurrentTest(lpszCurrentTest),
        m_pszTestFile(lpszTestFile),
        m_pObject(NULL),
        m_clsid(rclsidObject),
        m_llTimeOffset(llTimeOffset),
		m_sampleCounter(0)
        {}

    ~CTest() {
        delete m_pObject;
        m_pObject = NULL;
    }

    HRESULT SimpleStream();

    virtual HRESULT InitObject()
    {
        m_pObject = new CDMOObject;
        if (m_pObject == NULL) {
            Error(ERROR_TYPE_TEST, E_OUTOFMEMORY, TEXT("Not enough memory"));
			g_IShell->Log(1, "TEST ERROR: Not enough memory");
			return E_OUTOFMEMORY;
        }
        return m_pObject->Create(m_clsid, FALSE);
    }

    virtual HRESULT ProcessType(DWORD dwStreamId,  DMO_MEDIA_TYPE *pmt);
    virtual HRESULT ProcessSample(DWORD dwStreamId,
                                  DWORD dwFlags,
                                  LONGLONG llStartTime,
                                  LONGLONG llLength,
                                  BYTE *pbData,
                                  DWORD cbData);
    virtual HRESULT ProcessOutput(DWORD dwOutputStreamIndex,
                                  DWORD dwFlags,
                                  PBYTE pbData,
                                  DWORD cbData,
                                  LONGLONG llTime,
                                  LONGLONG llLength);
    virtual HRESULT ProcessOutputTypeChange(
                                  DWORD dwOutputStreamIndex,
                                  const DMO_MEDIA_TYPE *pmt) = 0;

    virtual HRESULT EndOfData();

    HRESULT ProcessOutputs();
	HRESULT ProcessOutputZero();
    //  Object
    CDMOObject *m_pObject;

    //  clsid
    CLSID m_clsid;

    //  Test name - should this be thread local?
    LPCTSTR m_lpszCurrentTest;

    //  Test file
    LPCTSTR m_pszTestFile;

    //  Time offset
    LONGLONG m_llTimeOffset;

	// sample counter
	int m_sampleCounter;
};

//  Save to disk simple test
class CTestSaveToFile : public CTest
{
public:
    CTestSaveToFile(
        REFCLSID rclsidObject,
        LPCTSTR lpszInputDataFile,
        LPCTSTR lpszOutputDataFile,
        LONGLONG llTimeOffset
    ) :
        CTest(TEXT("Save data to file"),
              rclsidObject,
              lpszInputDataFile,
              llTimeOffset),
        m_pszOutputFile(lpszOutputDataFile)
    {
    }

    HRESULT ProcessOutput(DWORD dwOutputStreamIndex,
                          DWORD dwFlags,
                          PBYTE pbData,
                          DWORD cbData,
                          LONGLONG llTime,
                          LONGLONG llLength);

	HRESULT ProcessOutputTypeChange(
                          DWORD dwOutputStreamIndex,
                          const DMO_MEDIA_TYPE *pmt);



    HRESULT Save();

    LPCTSTR m_pszOutputFile;

    CTestFileWrite m_FileWrite;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\testobj.h ===
#ifndef TESTOBJ_h
#define TESTOBJ_h

#ifdef ENABLE_SECURE_DMO
#include <wmsecure.h>
#endif // ENABLE_SECURE_DMO

class CMediaBuffer;

//  Class to aggregate people
class ATL_NO_VTABLE CMyAggregator :
    public CComCoClass<CMyAggregator, &CLSID_NULL>,
	public CComObjectRootEx<CComMultiThreadModel>

{
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    DECLARE_GET_CONTROLLING_UNKNOWN()
public:
    CMyAggregator() {
	}
    HRESULT SetCLSID(REFCLSID rclsid) {
        m_clsid = rclsid;
		return CoCreateInstance(rclsid, GetControllingUnknown(), CLSCTX_INPROC_SERVER, IID_IUnknown,
			                    (void **)&m_pObject);
    }

    //  Stream from a file using an index
    HRESULT Stream(LPCTSTR lpszFile, LPCSTR lpszIndex);

BEGIN_COM_MAP(CMyAggregator)
    COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_pObject)
END_COM_MAP()

private:
    CLSID m_clsid;
	CComPtr<IUnknown> m_pObject;
    //  Buffers stuff
};

//  Class to simplify loading and running DMOs

class CDMOObject
{
public:
    CDMOObject();

    HRESULT Create(REFCLSID rclsidObject, BOOL bAggregated = FALSE);

    //  Stream stuff

    //  Shadow IMediaObject
    HRESULT GetStreamCount(
            DWORD *pcInputStreams,
            DWORD *pcOutputStreams
    );
    HRESULT GetInputStreamInfo(
            DWORD dwInputStreamIndex, // 0-based
            DWORD *pdwFlags // HOLDS_BUFFERS
    );
    HRESULT GetOutputStreamInfo(
            DWORD dwOutputStreamIndex, // 0-based
            DWORD *pdwFlags      // Media object sets to 0
    );


    //
    // GetType - iterate through media types supported by a stream.
    // Returns S_FALSE if the type index is out of range ("no more types").
    //
    HRESULT GetInputType(
            DWORD dwInputStreamIndex,
            DWORD dwTypeIndex, // 0-based
            DMO_MEDIA_TYPE *pmt
    );
    HRESULT GetOutputType(
            DWORD dwOutputStreamIndex,
            DWORD dwTypeIndex, // 0-based
            DMO_MEDIA_TYPE *pmt
    );

    //
    // SetType - tell the object the type of data it will work with.
    //
    HRESULT SetInputType(
            DWORD dwInputStreamIndex,
            const DMO_MEDIA_TYPE *pmt,
            DWORD dwFlags // test only
    );
    HRESULT SetOutputType(
            DWORD dwOutputStreamIndex,
            const DMO_MEDIA_TYPE *pmt,
            DWORD dwFlags // test only
    );

    //
    // GetCurrentType - get the last mediatype supplied via SetType.
    // Returns S_FALSE if SetType has not been called.
    //
    HRESULT GetInputCurrentType(
            DWORD dwInputStreamIndex,
            DMO_MEDIA_TYPE *pmt
    );
    HRESULT GetOutputCurrentType(
            DWORD dwOutputStreamIndex,
            DMO_MEDIA_TYPE *pmt
    );



    //
    // GetSizeInfo - Get buffer size requirementes of a stream.
    //
    // If buffer size depends on the media type used, the object should
    // base its response on the most recent media type set for this stream.
    // If no mediatype has been set, the object may return an error.
    //
    HRESULT GetInputSizeInfo(
            DWORD dwInputStreamIndex,
            DWORD *pcbSize, // size of input 'quantum'
            DWORD *pcbMaxLookahead, // max total bytes held
            DWORD *pcbAlignment  // buffer alignment requirement
    );
    HRESULT GetOutputSizeInfo(
            DWORD dwOutputStreamIndex,
            DWORD *pcbSize, // size of output 'quantum'
            DWORD *pcbAlignment  // buffer alignment requirement
    );



    HRESULT GetInputMaxLatency(
            DWORD dwInputStreamIndex,
            REFERENCE_TIME *prtMaxLatency
    );
    HRESULT SetInputMaxLatency(
            DWORD dwInputStreamIndex,
            REFERENCE_TIME rtMaxLatency
    );


    //
    // Flush() - discard any buffered data.
    //
    HRESULT Flush();

    //
    // Send a discontinuity to an input stream.  The object will not
    // accept any more data on this input stream until the discontinuity
    // has been completely processed, which may involve multiple
    // ProcessOutput() calls.
    //
    HRESULT Discontinuity(DWORD dwInputStreamIndex);

    //
    // If a streaming object needs to perform any time consuming
    // initialization before it can stream data, it should do it inside
    // AllocateStreamingResources() rather than during the first process
    // call.
    //
    // This method is NOT guaranteed to be called before streaming
    // starts.  If it is not called, the object should perform any
    // required initialization during a process call.
    //
    HRESULT AllocateStreamingResources();

    // Free anything allocated in AllocateStreamingResources().
    HRESULT FreeStreamingResources();

    // GetInputStatus - the only flag defined right now is ACCEPT_DATA.
    HRESULT GetInputStatus(
            DWORD dwInputStreamIndex,
            DWORD *dwFlags // ACCEPT_DATA
    );

    //
    // Pass one new buffer to an input stream
    //
    HRESULT ProcessInput(
            DWORD dwInputStreamIndex,
            IMediaBuffer *pBuffer, // must not be NULL
            DWORD dwFlags, // DMO_INPUT_DATA_BUFFERF_XXX (syncpoint, etc.)
            REFERENCE_TIME rtTimestamp, // valid if flag set
            REFERENCE_TIME rtTimelength // valid if flag set
    );

    //
    // ProcessOutput() - generate output for current input buffers
    //
    // Output stream specific status information is returned in the
    // dwStatus member of each buffer wrapper structure.
    //
    HRESULT ProcessOutput(
            DWORD dwReserved, // must be 0
            DWORD cOutputBufferCount, // # returned by GetStreamCount()
            DMO_OUTPUT_DATA_BUFFER *pOutputBuffers, // one per stream
    	    DWORD *pdwStatus  // TBD, must be set to 0
    );

    //  End shadow IMediaObject

	//  Does any stream hold on to buffers?
	BOOL HoldsOnToBuffers();

    //  Make a buffer
    HRESULT CreateInputBuffer(DWORD dwSize, CMediaBuffer **ppBuffer);

    BOOL CheckInputBuffersFree()
    {
        if (m_pInputBuffers) {
            return FALSE;
        } else {
            return TRUE;
        }
    }

    HRESULT SetDefaultOutputTypes();

    //  Buffers stuff
    CMediaBuffer  *m_pInputBuffers;

	int m_processCounter;

private:
    #ifdef ENABLE_SECURE_DMO
    HRESULT CreateSecureChannel
        (
        IMediaObject* pMediaObject,
        IUnknown** ppCertUnknown,
        IWMSecureChannel** ppSecureChannel
        );

    CComPtr<IUnknown> m_pCertUnknown;
    CComPtr<IWMSecureChannel> m_pTestAppSecureChannel;
    #endif // ENABLE_SECURE_DMO

    CComPtr<IMediaObject> m_pMediaObject;
};

//  CMediaBuffer object
class CMediaBuffer : public IMediaBuffer
{
public:
    CMediaBuffer(DWORD cbMaxLength, CDMOObject *pObject = NULL) :
        m_cRef(0),
        m_cbMaxLength(cbMaxLength),
        m_cbLength(0),
        m_pbData(NULL),
        m_pDMOObject(pObject),
        m_pNext(NULL)
    {
    }
    ~CMediaBuffer()
    {
        if (m_pbData) {
            ZeroMemory(m_pbData, m_cbMaxLength);
            delete [] m_pbData;
            m_pbData = NULL;
        }

        //  Remove ourselves from the list
        if (m_pDMOObject) {
            CMediaBuffer **pSearch = &m_pDMOObject->m_pInputBuffers;
            while (*pSearch) {
                if (*pSearch = this) {
                    *pSearch = m_pNext;
                    break;
                }
                pSearch = &(*pSearch)->m_pNext;
            }
        }
    }
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
    {
        if (ppv == NULL) {
            return E_POINTER;
        }
        if (riid == IID_IMediaBuffer || riid == IID_IUnknown) {
            *ppv = static_cast<IMediaBuffer *>(this);
            AddRef();
            return S_OK;
        }
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if (m_cRef <= 0) {
            DebugBreak();
        }
        LONG lRef = InterlockedDecrement(&m_cRef);
        if (lRef == 0) {
            delete this;
        }
        return lRef;
    }

    STDMETHODIMP SetLength(DWORD cbLength)
    {
        if (cbLength > m_cbMaxLength) {
            return E_INVALIDARG;
        } else {
            m_cbLength = cbLength;
            return S_OK;
        }
    }
    STDMETHODIMP GetMaxLength(DWORD *pcbMaxLength)
    {
        if (pcbMaxLength == NULL) {
            return E_POINTER;
        }
        *pcbMaxLength = m_cbMaxLength;
        return S_OK;
    }
    STDMETHODIMP GetBufferAndLength(BYTE **ppbBuffer, DWORD *pcbLength)
    {
        if (ppbBuffer == NULL || pcbLength == NULL) {
            return E_POINTER;
        }
        *ppbBuffer = m_pbData;
        *pcbLength = m_cbLength;
        return S_OK;
    }

    HRESULT Init()
    {
        m_pbData = new BYTE[m_cbMaxLength];
        if (NULL == m_pbData) {
            return E_OUTOFMEMORY;
        } else {
            return S_OK;
        }
    }

    DWORD         m_cbLength;
    const         DWORD m_cbMaxLength;
    LONG          m_cRef;
    BYTE         *m_pbData;
    CMediaBuffer *m_pNext;
	CDMOObject   *m_pDMOObject;
};

HRESULT CreateBuffer(DWORD cbMaxLength, CMediaBuffer **ppBuffer, CDMOObject *pObject = NULL);

#endif // TESTOBJ_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\tstgsi.cpp ===
#include <streams.h>
#include <mediaobj.h>
#include <mediaerr.h>
#include <s98inc.h>
#include "TSTGSI.h"
#include "Utility.h"
#include "Error.h"

const TCHAR GET_INPUT_STREAM_INFO_NAME[] = TEXT("IMediaObject::GetInputStreamInfo()");
const TCHAR GET_OUTPUT_STREAM_INFO_NAME[] = TEXT("IMediaObject::GetOutputStreamInfo()");

/******************************************************************************
    CSITGetInputStreamInfo
******************************************************************************/
CSITGetInputStreamInfo::CSITGetInputStreamInfo( IMediaObject* pDMO, HRESULT* phr ) :
    CInputStreamIndexTests( pDMO, phr )
{
}

HRESULT CSITGetInputStreamInfo::PreformOperation( DWORD dwStreamIndex )
{
    DWORD dwStreamFlags;

    HRESULT hr = GetDMO()->GetInputStreamInfo( dwStreamIndex, &dwStreamFlags );

    // Is the current stream number illegal?  Streams are numbered between 0 and (dwNumStreams-1).
    if( !StreamExists( dwStreamIndex ) ) {

        // The current stream number is illegal.
        if( (DMO_E_INVALIDSTREAMINDEX != hr) && FAILED( hr ) ) {
             //Error( ERROR_TYPE_WARNING, hr, TEXT("WARNING: %s's stream index parameter contained an invalid value but %s did not return DMO_E_INVALIDSTREAMINDEX."), GetOperationName(), GetOperationName() );
			 g_IShell->Log(1, "WARNING: %s's stream index parameter contained an invalid value, but did not return DMO_E_INVALIDSTREAMINDEX.", GetOperationName() );
		} else if( SUCCEEDED( hr ) ) {
             //Error( ERROR_TYPE_DMO, hr, TEXT("ERROR: %s's stream index parameter contained an invalid value but the function succeeded.  It should have returned DMO_E_INVALIDSTREAMINDEX."), GetOperationName() );
             g_IShell->Log(1, "DMO ERROR: %s's stream index parameter contained an invalid value but the function succeeded.  It should have returned DMO_E_INVALIDSTREAMINDEX.", GetOperationName() );

             return E_FAIL;
        } 
    } else {
        if( FAILED( hr ) ) {
            //Error( ERROR_TYPE_DMO, hr, TEXT("ERROR: %s's stream index parameter contained a valid value but the function failed."), GetOperationName() );
			g_IShell->Log(1, "DMO ERROR: %s's stream index parameter contained a valid value but the function failed.", GetOperationName() );
			return E_FAIL;
        } 

        if( !DMODataValidation::ValidGetInputStreamInfoFlags( dwStreamFlags ) ) {
            //Error( ERROR_TYPE_DMO, hr, TEXT("ERROR: %s returned illegal flags."), GetOperationName() );
 			g_IShell->Log(1, "DMO ERROR: %s returned illegal flags.", GetOperationName() );
			return E_FAIL;
        }
    }

    return S_OK;
}

const TCHAR* CSITGetInputStreamInfo::GetOperationName( void ) const 
{
    return GET_INPUT_STREAM_INFO_NAME;
}

/******************************************************************************
    CSITGetOutputStreamInfo
******************************************************************************/
CSITGetOutputStreamInfo::CSITGetOutputStreamInfo( IMediaObject* pDMO, HRESULT* phr ) :
    COutputStreamIndexTests( pDMO, phr )
{
}

HRESULT CSITGetOutputStreamInfo::PreformOperation( DWORD dwStreamIndex )
{
    DWORD dwStreamFlags;

    HRESULT hr = GetDMO()->GetOutputStreamInfo( dwStreamIndex, &dwStreamFlags );

    // Is the current stream number illegal?  Streams are numbered between 0 and (dwNumStreams-1).
    if( !StreamExists( dwStreamIndex ) ) {

        // The current stream number is illegal.
        if( (DMO_E_INVALIDSTREAMINDEX != hr) && FAILED( hr ) ) {
             //Error( ERROR_TYPE_WARNING, hr, TEXT("WARNING: %s's stream index parameter contained an invalid value but %s did not return DMO_E_INVALIDSTREAMINDEX."), GetOperationName(), GetOperationName() );
			 g_IShell->Log(1, "WARNING: %s's stream index parameter contained an invalid value but %s did not return DMO_E_INVALIDSTREAMINDEX.", 
				 GetOperationName(), GetOperationName() );
		} else if( SUCCEEDED( hr ) ) {
             //Error( ERROR_TYPE_DMO, hr, TEXT("ERROR: %s's stream index parameter contained an invalid value but the function succeeded.  It should have returned DMO_E_INVALIDSTREAMINDEX."), GetOperationName() );
	         g_IShell->Log(1, "DMO ERROR: %s's stream index parameter contained an invalid value but the function succeeded.  It should have returned DMO_E_INVALIDSTREAMINDEX.", GetOperationName() );
			 return E_FAIL;
        } 
    } else {
        if( FAILED( hr ) ) {
            //Error( ERROR_TYPE_DMO, hr, TEXT("ERROR: %s's stream index parameter contained a valid value but the function failed."), GetOperationName() );
		    g_IShell->Log(1, "DMO ERROR: %s's stream index parameter contained a valid value but the function failed.", GetOperationName() );
            return E_FAIL;
        } 

        if( !DMODataValidation::ValidGetOutputStreamInfoFlags( dwStreamFlags ) ) {
            //Error( ERROR_TYPE_DMO, hr, TEXT("ERROR: %s returned illegal flags."), GetOperationName() );
		    g_IShell->Log(1, "DMO ERROR: %s's stream index parameter contained a valid value but the function returned illegal flags.", GetOperationName() );
			return E_FAIL;
        }
    }

    return S_OK;
}

const TCHAR* CSITGetOutputStreamInfo::GetOperationName( void ) const 
{
    return GET_OUTPUT_STREAM_INFO_NAME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\tstgsi.h ===
#ifndef TestGetStreamInfo_h
#define TestGetStreamInfo_h

#include "IVSTRM.h"

class CSITGetInputStreamInfo : public CInputStreamIndexTests
{
public:
    CSITGetInputStreamInfo( IMediaObject* pDMO, HRESULT* phr );

private:
    HRESULT PreformOperation( DWORD dwStreamIndex );
    const TCHAR* GetOperationName( void ) const;

};

class CSITGetOutputStreamInfo : public COutputStreamIndexTests
{
public:
    CSITGetOutputStreamInfo( IMediaObject* pDMO, HRESULT* phr );

private:
    HRESULT PreformOperation( DWORD dwStreamIndex );
    const TCHAR* GetOperationName( void ) const;

};

#endif // TestGetInputStreamInfo_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\types.h ===
#ifndef TestAppDataTypes_h
#define TestAppDataTypes_h 

enum STREAM_TYPE {
    ST_INPUT_STREAM,
    ST_OUTPUT_STREAM
};

#endif // TestAppDataTypes_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\utility.h ===
#ifndef Utility_h
#define Utility_h

#include "Types.h"

namespace DMODataValidation
{
    bool ValidGetInputStreamInfoFlags( DWORD dwFlags );
    bool ValidGetOutputStreamInfoFlags( DWORD dwFlags );
    bool ValidateStreamType( STREAM_TYPE st );

    bool ValidGetInputTypeReturnValue( HRESULT hrGetInputType );
};

#endif // Utility_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dmotest\dshowmediaobj\test\testapp\utility.cpp ===
#include <windows.h>
#include <mediaobj.h>
#include "Utility.h"

/******************************************************************************
    Internal Function Declarations
******************************************************************************/
static bool ValidateFlags( DWORD dwFlags, DWORD dwValidFlagsMask );

/******************************************************************************
    Function Inplementation
******************************************************************************/
bool DMODataValidation::ValidGetInputStreamInfoFlags( DWORD dwFlags )
{
    const DWORD VALID_FLAGS_MASK = DMO_INPUT_STREAMF_WHOLE_SAMPLES |
                                   DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                   DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE |
                                   DMO_INPUT_STREAMF_HOLDS_BUFFERS;
    return ValidateFlags( dwFlags, VALID_FLAGS_MASK );
}

bool DMODataValidation::ValidGetOutputStreamInfoFlags( DWORD dwFlags )
{

    const DWORD VALID_FLAGS_MASK = DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                                   DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                   DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE |
								   DMO_OUTPUT_STREAMF_DISCARDABLE |
								   DMO_OUTPUT_STREAMF_OPTIONAL;
    return ValidateFlags( dwFlags, VALID_FLAGS_MASK );
}

bool DMODataValidation::ValidateStreamType( STREAM_TYPE st )
{
    return (ST_INPUT_STREAM == st) || (ST_OUTPUT_STREAM == st);
}

bool DMODataValidation::ValidGetInputTypeReturnValue( HRESULT hrGetInputType )
{
    // IMediaObject::GetInputType() can return any failure value and it can return S_OK.
    return (S_OK == hrGetInputType) || FAILED(hrGetInputType);
}

bool ValidateFlags( DWORD dwFlags, DWORD dwValidFlagsMask )
{
    return (dwFlags == (dwFlags & dwValidFlagsMask));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dsperf\dsperf.cpp ===
/*++

Copyright  2000 Microsoft Corporation

Module Name:

    dsperf.c

Abstract:

    This module contains the implementation of the DShow performance counter
    provider. It acts as a WMI event tracing controller and consumer and exposes
    standard NT performance counters.

Author:

    Arthur Zwiegincew (arthurz) 05-Oct-00

Revision History:

    05-Oct-00 - Created

--*/

#include <windows.h>
#include <winperf.h>
#include <stdio.h>
#include <wmistr.h>
#include <evntrace.h>
#include <initguid.h>
#include <math.h>
#include "dscounters.h"

#define WMIPERF
#include <perfstruct.h>

typedef LONG LOGICAL;

GUID KmixerGuid = 
{ 0xe5a43a19, 0x6de0, 0x44f8, 0xb0, 0xd7, 0x77, 0x2d, 0xbd, 0xe4, 0x6c, 0xc0 };

GUID PortclsGuid =
{ 0x9d447297, 0xc576, 0x4015, 0x87, 0xb5, 0xa5, 0xa6, 0x98, 0xfd, 0x4d, 0xd1 };

GUID UsbaudioGuid =
{ 0xd6464a84, 0xa358, 0x4013, 0xa1, 0xe8, 0x6e, 0x2f, 0xb4, 0x8a, 0xab, 0x93 };

//
// Video glitch threshold. When abs(PresentationTime - RenderTime) > this value,
// we consider the event a glitch.
//

#define GLITCH_THRESHOLD 30 /* ms */ * 10000 /* 1 ms / 100 ns */

//
// Performance data.
//

ULONG VideoGlitches;
ULONG VideoGlitchesPerSec;
ULONG VideoFrameRate;
ULONG VideoJitter;
ULONG DsoundGlitches;
ULONG KmixerGlitches;
ULONG PortclsGlitches;
ULONG UsbaudioGlitches;

ULONG VideoGlitchesSinceLastMeasurement;
ULONG FramesRendered;
ULONGLONG LastMeasurementTime;

#define JITTER_HISTORY_BUFFER_SIZE 200
LONGLONG FrameJitterHistory[JITTER_HISTORY_BUFFER_SIZE];
ULONG NextJitterEntry;

//
// DSHOW WMI provider GUID.
//

GUID ControlGuid = GUID_DSHOW_CTL;

//
// Event tracing-related globals.
//

HANDLE MonitorThread;
HANDLE ResetThread;
TRACEHANDLE LoggerHandle;
TRACEHANDLE ConsumerHandle;
EVENT_TRACE_LOGFILE Logfile;
ULONGLONG LastBufferFlushTime;

//
// Performance monitoring structures.
//

typedef struct _DSHOW_PERF_DATA_DEFINITION {

    PERF_OBJECT_TYPE ObjectType;
    PERF_COUNTER_DEFINITION VideoGlitches;
    PERF_COUNTER_DEFINITION VideoGlitchesPerSec;
    PERF_COUNTER_DEFINITION VideoFrameRate;
    PERF_COUNTER_DEFINITION VideoJitter;
    PERF_COUNTER_DEFINITION DsoundGlitches;
    PERF_COUNTER_DEFINITION KmixerGlitches;
    PERF_COUNTER_DEFINITION PortclsGlitches;
    PERF_COUNTER_DEFINITION UsbaudioGlitches;

} DSHOW_PERF_DATA_DEFINITION, *PDSHOW_PERF_DATA_DEFINITION;

typedef struct _DSHOW_PERF_COUNTERS {

    PERF_COUNTER_BLOCK CounterBlock;
    ULONG Pad;
    ULONG VideoGlitches;
    ULONG VideoGlitchesPerSec;
    ULONG VideoFrameRate;
    ULONG VideoJitter;
    ULONG DsoundGlitches;
    ULONG KmixerGlitches;
    ULONG PortclsGlitches;
    ULONG UsbaudioGlitches;
    //ULONG Pad2;
    //ULONG Pad3;

} DSHOW_PERF_COUNTERS, *PDSHOW_PERF_COUNTERS;

//
// Perfmon-related globals.
//

DSHOW_PERF_DATA_DEFINITION DshowPerfDataDefinition;
LONG OpenCount = 0;       // Keeps track of how many threads have open ds counters.
LOGICAL Initialized = 0;  // Fixes an initialization race condition.

//
// Function prototypes.
//

PM_OPEN_PROC PerfOpen;
PM_CLOSE_PROC PerfClose;
PM_COLLECT_PROC PerfCollect;

DWORD
WINAPI
MonitorThreadProc (
    LPVOID Param
    );

DWORD
WINAPI
ResetThreadProc (
    LPVOID Param
    );

VOID
TerminateLogging (
    VOID
    );

////////////////////////////////////////////////////////////////////////////

ULONG
APIENTRY
PerfOpen (
    LPWSTR DevNames
    )

/*++

Routine Description:

    This routine initializes data collection.

Arguments:

    DevNames - Supplies a REG_MULTISZ of object IDs of the devices to be opened.

Return Value:

    ERROR_SUCCESS - OK.
    
    <multiple failure codes> - initialization failed.
    
Note:

    On remote connections, this function may be called more than once
    by multiple threads.

--*/

{
    PDSHOW_PERF_DATA_DEFINITION Def = &DshowPerfDataDefinition;
    ULONG FirstCounter;
    ULONG FirstHelp;
    HKEY PerfKey;
    LOGICAL WasInitialized;
    ULONG Type;
    ULONG Size;
    LONG status;

    //
    // Initialize counters.
    //
    
    VideoGlitches = 0;
    VideoGlitchesSinceLastMeasurement = 0;
    VideoFrameRate = 0;
    DsoundGlitches = 0;
    KmixerGlitches = 0;
    PortclsGlitches = 0;
    UsbaudioGlitches = 0;
    FramesRendered = 0;
    NextJitterEntry = 0;
    GetSystemTimeAsFileTime ((FILETIME*)&LastMeasurementTime);

    //
    // Since WinLogon is multithreaded and will call this routine in order to
    // service remote performance queries, this library must keep track of how
    // many threads have accessed it). The registry routines will limit access
    // to the initialization routine to only one thread at a time.
    //

    WasInitialized = InterlockedCompareExchange (&Initialized, 0, 0);

    if (!WasInitialized) {
    
        //
        // Create the monitor thread.
        //
        
        MonitorThread = CreateThread (NULL, 0, MonitorThreadProc, 0, 0, NULL);
        if (MonitorThread == NULL) {
            return GetLastError();
        }
    
        //
        // Create the reset thread.
        //
        
        ResetThread = CreateThread (NULL, 0, ResetThreadProc, 0, 0, NULL);
        if (ResetThread == NULL) {
            return GetLastError();
        }

        //
        // Get counter and help index base values from the registry.
        //
        
        status = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               "SYSTEM\\CurrentControlSet\\Services\\DSPerf\\Performance",
                               0L, KEY_READ, &PerfKey);

        if (status != ERROR_SUCCESS) {
            return status;
        }

        Size = sizeof (ULONG);
        status = RegQueryValueEx (PerfKey, "First Counter", 0L, &Type,
                                  (LPBYTE) &FirstCounter, &Size);

        if (status != ERROR_SUCCESS) {
            RegCloseKey (PerfKey);
            return status;
        }

        Size = sizeof (ULONG);
        status = RegQueryValueEx (PerfKey, "First Help", 0L, &Type,
                                  (LPBYTE) &FirstHelp, &Size);

        if (status != ERROR_SUCCESS) {
            RegCloseKey (PerfKey);
            return status;
        }

        RegCloseKey (PerfKey);

        //
        // Fill the data definition structure.
        //

        Def->ObjectType.TotalByteLength = sizeof (DSHOW_PERF_DATA_DEFINITION) +
                                          sizeof (DSHOW_PERF_COUNTERS);
        Def->ObjectType.DefinitionLength = sizeof (DSHOW_PERF_DATA_DEFINITION);
        Def->ObjectType.HeaderLength = sizeof (PERF_OBJECT_TYPE);
        Def->ObjectType.ObjectNameTitleIndex = DSHOWPERF_OBJ + FirstCounter;
        Def->ObjectType.ObjectNameTitle = NULL;
        Def->ObjectType.ObjectHelpTitleIndex = DSHOWPERF_OBJ + FirstHelp;
        Def->ObjectType.ObjectHelpTitle = NULL;
        Def->ObjectType.DetailLevel = PERF_DETAIL_NOVICE;
        Def->ObjectType.NumCounters = (sizeof (DSHOW_PERF_DATA_DEFINITION) -
                                       sizeof (PERF_OBJECT_TYPE)) /
                                      sizeof (PERF_COUNTER_DEFINITION);
        Def->ObjectType.DefaultCounter = -1;
        Def->ObjectType.NumInstances = PERF_NO_INSTANCES;
        Def->ObjectType.CodePage = 0;
        Def->ObjectType.PerfFreq.QuadPart = 10000000;

        ///

        Def->VideoGlitches.ByteLength = sizeof (PERF_COUNTER_DEFINITION);
        Def->VideoGlitches.CounterNameTitleIndex = DSHOWPERF_VIDEO_GLITCHES + FirstCounter;
        Def->VideoGlitches.CounterNameTitle = NULL;
        Def->VideoGlitches.CounterHelpTitleIndex = DSHOWPERF_VIDEO_GLITCHES + FirstHelp;
        Def->VideoGlitches.CounterHelpTitle = NULL;
        Def->VideoGlitches.DefaultScale = -1;
        Def->VideoGlitches.DetailLevel = PERF_DETAIL_NOVICE;
        Def->VideoGlitches.CounterType = PERF_COUNTER_RAWCOUNT;
        Def->VideoGlitches.CounterSize = sizeof (ULONG);
        Def->VideoGlitches.CounterOffset = FIELD_OFFSET (DSHOW_PERF_COUNTERS, VideoGlitches);

        ///

        Def->VideoGlitchesPerSec.ByteLength = sizeof (PERF_COUNTER_DEFINITION);
        Def->VideoGlitchesPerSec.CounterNameTitleIndex = DSHOWPERF_VIDEO_GLITCHES_SEC + FirstCounter;
        Def->VideoGlitchesPerSec.CounterNameTitle = NULL;
        Def->VideoGlitchesPerSec.CounterHelpTitleIndex = DSHOWPERF_VIDEO_GLITCHES_SEC + FirstHelp;
        Def->VideoGlitchesPerSec.CounterHelpTitle = NULL;
        Def->VideoGlitchesPerSec.DefaultScale = 0;
        Def->VideoGlitchesPerSec.DetailLevel = PERF_DETAIL_NOVICE;
        Def->VideoGlitchesPerSec.CounterType = PERF_COUNTER_RAWCOUNT;
        Def->VideoGlitchesPerSec.CounterSize = sizeof (ULONG);
        Def->VideoGlitchesPerSec.CounterOffset = FIELD_OFFSET (DSHOW_PERF_COUNTERS, VideoGlitchesPerSec);

        ///

        Def->VideoFrameRate.ByteLength = sizeof (PERF_COUNTER_DEFINITION);
        Def->VideoFrameRate.CounterNameTitleIndex = DSHOWPERF_FRAME_RATE + FirstCounter;
        Def->VideoFrameRate.CounterNameTitle = NULL;
        Def->VideoFrameRate.CounterHelpTitleIndex = DSHOWPERF_FRAME_RATE + FirstHelp;
        Def->VideoFrameRate.CounterHelpTitle = NULL;
        Def->VideoFrameRate.DefaultScale = 0;
        Def->VideoFrameRate.DetailLevel = PERF_DETAIL_NOVICE;
        Def->VideoFrameRate.CounterType = PERF_COUNTER_RAWCOUNT;
        Def->VideoFrameRate.CounterSize = sizeof (ULONG);
        Def->VideoFrameRate.CounterOffset = FIELD_OFFSET (DSHOW_PERF_COUNTERS, VideoFrameRate);

        ///

        Def->VideoJitter.ByteLength = sizeof (PERF_COUNTER_DEFINITION);
        Def->VideoJitter.CounterNameTitleIndex = DSHOWPERF_JITTER + FirstCounter;
        Def->VideoJitter.CounterNameTitle = NULL;
        Def->VideoJitter.CounterHelpTitleIndex = DSHOWPERF_JITTER + FirstHelp;
        Def->VideoJitter.CounterHelpTitle = NULL;
        Def->VideoJitter.DefaultScale = 1;
        Def->VideoJitter.DetailLevel = PERF_DETAIL_NOVICE;
        Def->VideoJitter.CounterType = PERF_COUNTER_RAWCOUNT;
        Def->VideoJitter.CounterSize = sizeof (ULONG);
        Def->VideoJitter.CounterOffset = FIELD_OFFSET (DSHOW_PERF_COUNTERS, VideoJitter);

        ///

        Def->DsoundGlitches.ByteLength = sizeof (PERF_COUNTER_DEFINITION);
        Def->DsoundGlitches.CounterNameTitleIndex = DSHOWPERF_DSOUND_GLITCHES + FirstCounter;
        Def->DsoundGlitches.CounterNameTitle = NULL;
        Def->DsoundGlitches.CounterHelpTitleIndex = DSHOWPERF_DSOUND_GLITCHES + FirstHelp;
        Def->DsoundGlitches.CounterHelpTitle = NULL;
        Def->DsoundGlitches.DefaultScale = -1;
        Def->DsoundGlitches.DetailLevel = PERF_DETAIL_NOVICE;
        Def->DsoundGlitches.CounterType = PERF_COUNTER_RAWCOUNT;
        Def->DsoundGlitches.CounterSize = sizeof (ULONG);
        Def->DsoundGlitches.CounterOffset = FIELD_OFFSET (DSHOW_PERF_COUNTERS, DsoundGlitches);

        ///

        Def->KmixerGlitches.ByteLength = sizeof (PERF_COUNTER_DEFINITION);
        Def->KmixerGlitches.CounterNameTitleIndex = DSHOWPERF_KMIXER_GLITCHES + FirstCounter;
        Def->KmixerGlitches.CounterNameTitle = NULL;
        Def->KmixerGlitches.CounterHelpTitleIndex = DSHOWPERF_KMIXER_GLITCHES + FirstHelp;
        Def->KmixerGlitches.CounterHelpTitle = NULL;
        Def->KmixerGlitches.DefaultScale = -1;
        Def->KmixerGlitches.DetailLevel = PERF_DETAIL_NOVICE;
        Def->KmixerGlitches.CounterType = PERF_COUNTER_RAWCOUNT;
        Def->KmixerGlitches.CounterSize = sizeof (ULONG);
        Def->KmixerGlitches.CounterOffset = FIELD_OFFSET (DSHOW_PERF_COUNTERS, KmixerGlitches);

        ///

        Def->PortclsGlitches.ByteLength = sizeof (PERF_COUNTER_DEFINITION);
        Def->PortclsGlitches.CounterNameTitleIndex = DSHOWPERF_PORTCLS_GLITCHES + FirstCounter;
        Def->PortclsGlitches.CounterNameTitle = NULL;
        Def->PortclsGlitches.CounterHelpTitleIndex = DSHOWPERF_PORTCLS_GLITCHES + FirstHelp;
        Def->PortclsGlitches.CounterHelpTitle = NULL;
        Def->PortclsGlitches.DefaultScale = -1;
        Def->PortclsGlitches.DetailLevel = PERF_DETAIL_NOVICE;
        Def->PortclsGlitches.CounterType = PERF_COUNTER_RAWCOUNT;
        Def->PortclsGlitches.CounterSize = sizeof (ULONG);
        Def->PortclsGlitches.CounterOffset = FIELD_OFFSET (DSHOW_PERF_COUNTERS, PortclsGlitches);

        ///

        Def->UsbaudioGlitches.ByteLength = sizeof (PERF_COUNTER_DEFINITION);
        Def->UsbaudioGlitches.CounterNameTitleIndex = DSHOWPERF_USBAUDIO_GLITCHES + FirstCounter;
        Def->UsbaudioGlitches.CounterNameTitle = NULL;
        Def->UsbaudioGlitches.CounterHelpTitleIndex = DSHOWPERF_USBAUDIO_GLITCHES + FirstHelp;
        Def->UsbaudioGlitches.CounterHelpTitle = NULL;
        Def->UsbaudioGlitches.DefaultScale = -1;
        Def->UsbaudioGlitches.DetailLevel = PERF_DETAIL_NOVICE;
        Def->UsbaudioGlitches.CounterType = PERF_COUNTER_RAWCOUNT;
        Def->UsbaudioGlitches.CounterSize = sizeof (ULONG);
        Def->UsbaudioGlitches.CounterOffset = FIELD_OFFSET (DSHOW_PERF_COUNTERS, UsbaudioGlitches);
    }

    InterlockedExchange (&Initialized, 1);
    InterlockedIncrement (&OpenCount);

    return ERROR_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////

ULONG
APIENTRY
PerfClose (
    VOID
    )

/*++

Routine Description:

    This routine cleans up after data collection.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS.
    
Note:

    On remote connections, this function may be called more than once
    by multiple threads.

--*/

{
    ULONG NewOpenCount;

    NewOpenCount = InterlockedDecrement (&OpenCount);

    if (NewOpenCount == 0) {

        //
        // Last thread has closed the counter. Perform cleanup here.
        //

        TerminateLogging();
    }

    return ERROR_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////

ULONG
APIENTRY
PerfCollect (
    IN LPWSTR ValueName,
    IN OUT LPVOID* PData,
    IN OUT LPDWORD TotalBytes,
    OUT LPDWORD NumObjectTypes
    )

/*++

Routine Description:

    This routine provides perf mon data.

Arguments:

    ValueName - Supplies a string specified by the performance monitor program
                in a call to the RegQueryValueEx function.

    PData - Supplies the address of the buffer to receive the completed
            PERF_DATA_BLOCK and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *PData.

            Receives the pointer to the first byte after the data structure
            added by this routine.

    TotalBytes - Supplies the size in bytes of the buffer referenced by PData.
               
                 Receives the number of bytes added by this routine.

    NumObjectTypes - Receives the number of objects added by this routine.

Return Value:

    ERROR_MORE_DATA - if the buffer passed is too small to hold data.
    
    ERROR_SUCCESS - if success or any other error.
      
    Errors are also reported to the event log. AZFIX

--*/

{
    PDSHOW_PERF_DATA_DEFINITION PerfDataDefinition;
    PDSHOW_PERF_COUNTERS PerfCounters;
    FILETIME FileTime;
    ULONG SpaceNeeded;

    SpaceNeeded = sizeof (DSHOW_PERF_DATA_DEFINITION) +
                  sizeof (DSHOW_PERF_COUNTERS);

    if (!Initialized) {
        *TotalBytes = 0;
        *NumObjectTypes = 0;
        return ERROR_SUCCESS;    // This is OK.
    }

    if (*TotalBytes < SpaceNeeded) {
        *TotalBytes = 0;
        *NumObjectTypes = 0;
        return ERROR_MORE_DATA;
    }

    //
    // Copy the object and counter definitions.
    //
    
    PerfDataDefinition = (PDSHOW_PERF_DATA_DEFINITION)(*PData);

    RtlMoveMemory (PerfDataDefinition, &DshowPerfDataDefinition,
                   sizeof (DSHOW_PERF_DATA_DEFINITION));

    GetSystemTimeAsFileTime (&FileTime);
    RtlCopyMemory (&PerfDataDefinition->ObjectType.PerfTime.QuadPart,
                   &FileTime, sizeof (LONGLONG));

    PerfDataDefinition->ObjectType.NumInstances = -1;
    PerfDataDefinition->ObjectType.TotalByteLength = SpaceNeeded;

    //
    // Fill in counter data.
    //

    PerfCounters = (PDSHOW_PERF_COUNTERS)(PerfDataDefinition + 1);
    PerfCounters->CounterBlock.ByteLength = sizeof (DSHOW_PERF_COUNTERS);
    PerfCounters->VideoGlitches = VideoGlitches;
    PerfCounters->VideoGlitchesPerSec = VideoGlitchesPerSec;
    PerfCounters->VideoFrameRate = VideoFrameRate;
    PerfCounters->VideoJitter = VideoJitter;
    PerfCounters->DsoundGlitches = DsoundGlitches;
    PerfCounters->KmixerGlitches = KmixerGlitches;
    PerfCounters->PortclsGlitches = PortclsGlitches;
    PerfCounters->UsbaudioGlitches = UsbaudioGlitches;

    //
    // Update out parameters.
    //

    *PData = (PVOID)(PerfCounters + 1);
    *TotalBytes = SpaceNeeded;
    *NumObjectTypes = 1;

    return ERROR_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////

VOID
TerminateLogging (
    VOID
    )
{
    ULONG status;
    int i;
    struct EVENT_TRACE_INFO {
        EVENT_TRACE_PROPERTIES TraceProperties;
        char Logger[256];
        char LogFileName[256];
    } Info;

    ZeroMemory (&Info, sizeof (Info));
    Info.TraceProperties.LoggerNameOffset = sizeof (EVENT_TRACE_PROPERTIES);
    Info.TraceProperties.LogFileNameOffset = sizeof (EVENT_TRACE_PROPERTIES) + 256;
    Info.TraceProperties.Wnode.BufferSize = sizeof (Info);

    ControlTrace (0, "DSPerf", &Info.TraceProperties, EVENT_TRACE_CONTROL_QUERY);
    ControlTraceA (LoggerHandle, NULL, &Info.TraceProperties, EVENT_TRACE_CONTROL_STOP);

    if (MonitorThread != NULL) {
        EnableTrace (FALSE, 0, 0, &ControlGuid, LoggerHandle);
        TerminateThread (MonitorThread, 0);
    }

    if (ResetThread != NULL) {
        TerminateThread (ResetThread, 0);
    }

    for (i = 0; i < 100; i += 1) {
        Sleep (50);
        status = CloseTrace (ConsumerHandle);
        if (status == ERROR_SUCCESS) {
            break;
        }
    }
    
    EnableTrace (FALSE, 0, 0, &ControlGuid, LoggerHandle);
}

////////////////////////////////////////////////////////////////////////////

VOID
WINAPI
EventCallback (
    IN PEVENT_TRACE Event
    )
{
    PPERFINFO_DSHOW_AVREND PerfInfoAvRend;
    PPERFINFO_DSHOW_AUDIOGLITCH PerfInfoAudioGlitch;
    ULONG i;
    LONGLONG PresentationDelta;

    if (IsEqualGUID (Event->Header.Guid, GUID_VIDEOREND)) {

        FramesRendered += 1;

        PerfInfoAvRend = (PPERFINFO_DSHOW_AVREND)Event->MofData;
        PresentationDelta = PerfInfoAvRend->dshowClock - PerfInfoAvRend->sampleTime;
        FrameJitterHistory[NextJitterEntry] = PresentationDelta;
        if (NextJitterEntry < JITTER_HISTORY_BUFFER_SIZE - 1) {
            NextJitterEntry += 1;
        }

        if (labs ((int)PresentationDelta) > GLITCH_THRESHOLD) {

            //
            // Video glitch.
            //

            VideoGlitches += 1;
            VideoGlitchesSinceLastMeasurement += 1;
        }
    }
    else if (IsEqualGUID (Event->Header.Guid, GUID_DSOUNDGLITCH)) {

         PerfInfoAudioGlitch = (PPERFINFO_DSHOW_AUDIOGLITCH)Event->MofData;

         if (PerfInfoAudioGlitch->glitchType == 1) {
             DsoundGlitches += 1;
         }
    }
    else if (IsEqualGUID (Event->Header.Guid, KmixerGuid)) {
         PerfInfoAudioGlitch = (PPERFINFO_DSHOW_AUDIOGLITCH)Event->MofData;
         KmixerGlitches += 1;
    }
    else if (IsEqualGUID (Event->Header.Guid, PortclsGuid)) {
         PerfInfoAudioGlitch = (PPERFINFO_DSHOW_AUDIOGLITCH)Event->MofData;
         PortclsGlitches += 1;
    }
    else if (IsEqualGUID (Event->Header.Guid, UsbaudioGuid)) {
         PerfInfoAudioGlitch = (PPERFINFO_DSHOW_AUDIOGLITCH)Event->MofData;
         UsbaudioGlitches += 1;
    }
}

////////////////////////////////////////////////////////////////////////////

ULONG
WINAPI
BufferCallback (
    PEVENT_TRACE_LOGFILE Log
    )
{
    ULONGLONG CurrentTime;
    double TimeDelta;
    double JitterMean;
    double Jitter;
    double x;
    ULONG i;

    //
    // Extend the reset timer (indirectly).
    //
    
    GetSystemTimeAsFileTime ((FILETIME*)&LastBufferFlushTime);

    //
    // Calculate rates.
    //
    
    GetSystemTimeAsFileTime ((FILETIME*)&CurrentTime);
    TimeDelta = (double)(CurrentTime - LastMeasurementTime) / 10000000.0L;

    if (CurrentTime > LastMeasurementTime) {
        VideoGlitchesPerSec = (ULONG)((double)VideoGlitchesSinceLastMeasurement / TimeDelta);
        VideoFrameRate = (ULONG)((double)FramesRendered / TimeDelta);
    }
    else {
        VideoGlitchesPerSec = 0;
        VideoFrameRate = 0;
    }

    //
    // Calculate jitter.
    //

    if (NextJitterEntry > 1) {

        JitterMean = 0.0L;
        for (i = 0; i < NextJitterEntry; i += 1) {
            JitterMean += (double)FrameJitterHistory[i];
        }
        JitterMean /= (double)NextJitterEntry;
    
        Jitter = 0.0L;
        for (i = 0; i < NextJitterEntry; i += 1) {
            x = (double)FrameJitterHistory[i] - JitterMean;
            Jitter += (x * x);
        }
        Jitter /= (double)(NextJitterEntry - 1);
        Jitter = sqrt (Jitter) / 10000.0L;
        VideoJitter = (ULONG)Jitter;
    }
    else {
        VideoJitter = 0;
    }

    LastMeasurementTime = CurrentTime;
    VideoGlitchesSinceLastMeasurement = 0;
    FramesRendered = 0;
    NextJitterEntry = 0;

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
MonitorThreadProc (
    LPVOID Param
    )
{
    struct EVENT_TRACE_INFO {
        EVENT_TRACE_PROPERTIES TraceProperties;
        char Logger[256];
    } Info;

    UNREFERENCED_PARAMETER (Param);

    ULONG status;

    //
    // Start the controller.
    //
    
    ZeroMemory (&Info, sizeof (Info));
    Info.TraceProperties.Wnode.BufferSize = sizeof (Info);
    Info.TraceProperties.Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    Info.TraceProperties.Wnode.Guid = ControlGuid;
    Info.TraceProperties.BufferSize = 4096;
    Info.TraceProperties.MinimumBuffers = 8;
    Info.TraceProperties.MaximumBuffers = 16;
    Info.TraceProperties.LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
    Info.TraceProperties.FlushTimer = 1;
    Info.TraceProperties.EnableFlags = 1;
    Info.TraceProperties.AgeLimit = 1;
    Info.TraceProperties.LoggerNameOffset = sizeof (Info.TraceProperties);
    strcpy (Info.Logger, "DSPerf");

    status = StartTrace (&LoggerHandle, "DSPerf", &Info.TraceProperties);
    if (status != ERROR_SUCCESS) {
        return 0;
    }

    status = EnableTrace (TRUE, 0x1f, 0, &ControlGuid, LoggerHandle);
    if (status != ERROR_SUCCESS) {
        return 0;
    }

    //
    // Start the consumer.
    //
    
    ZeroMemory (&Logfile, sizeof (Logfile));
    Logfile.LoggerName = "DSPerf";
    Logfile.LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
    Logfile.BufferCallback = BufferCallback;
    Logfile.EventCallback = EventCallback;

    ConsumerHandle = OpenTrace (&Logfile);
    if (ConsumerHandle == (TRACEHANDLE)INVALID_HANDLE_VALUE) {
        return 0;
    }

    //
    // Consume. This call returns when logging is stopped.
    //

    status = ProcessTrace (&ConsumerHandle, 1, NULL, NULL);
    if (status != ERROR_SUCCESS) {
        return 1;
    }

    return 1;
}

////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
ResetThreadProc (
    LPVOID Param
    )
{
    ULONGLONG Time;

    for (;;) {
        Sleep (500);
        GetSystemTimeAsFileTime ((FILETIME*)&Time);
        if (Time - LastBufferFlushTime > 15000000I64) {
            FramesRendered = 0;
            NextJitterEntry = 0;
            VideoGlitchesPerSec = 0;
            VideoFrameRate = 0;
            VideoJitter = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\bnetfilt.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
// bnetfilt.cpp : defines random Quartz additions to BoxNet
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static enum Mode { MODE_SOURCE, MODE_SINK, MODE_SINK2 };
static BOOL PromptUser(OLECHAR *oszFileName, Mode mode, UINT nIDTitle, bool *pfTruncate = 0);

//
// AttemptFileOpen
//
// Checks if this filter needs a file opening for it.
// If so, it asks the user for a filename and opens it.
void AttemptFileOpen(IBaseFilter *pFilter)
{
    OLECHAR oszFileName[MAX_PATH];
    HRESULT hr;
    IFileSourceFilter *pIFileSource = NULL;
    hr = pFilter->QueryInterface(IID_IFileSourceFilter, (void**) &pIFileSource);
    if(SUCCEEDED(hr))
    {
        if(PromptUser(oszFileName, MODE_SOURCE, IDS_SOURCE_DIALOG_TITLE))
        {
            hr = pIFileSource->Load(oszFileName, NULL);
            if (FAILED(hr))
                DisplayQuartzError( IDS_FAILED_FILTER_FILE_LOAD, hr );
        }
        pIFileSource->Release();
    }

    IFileSinkFilter2 *pIFileSink2 = NULL;
    hr = pFilter->QueryInterface(IID_IFileSinkFilter2, (void**) &pIFileSink2);
    if(SUCCEEDED(hr))
    {
        bool fTruncate;
        if(PromptUser(oszFileName, MODE_SINK2, IDS_SINK_DIALOG_TITLE, &fTruncate))
        {
            hr = pIFileSink2->SetFileName(oszFileName, NULL);
            if (FAILED(hr))
                DisplayQuartzError( IDS_FAILED_FILTER_FILE_LOAD, hr );
            hr = pIFileSink2->SetMode(fTruncate ? AM_FILE_OVERWRITE : 0);
            if (FAILED(hr))
                DisplayQuartzError( IDS_FAILED_FILTER_FILE_LOAD, hr );
        }
        pIFileSink2->Release();
    }
    else
    {
  
        IFileSinkFilter *pIFileSink = NULL;
        hr = pFilter->QueryInterface(IID_IFileSinkFilter, (void**) &pIFileSink);
        if(SUCCEEDED(hr))
        {
            if(PromptUser(oszFileName, MODE_SINK, IDS_SINK_DIALOG_TITLE))
            {
                hr = pIFileSink->SetFileName(oszFileName, NULL);
                if (FAILED(hr))
                    DisplayQuartzError( IDS_FAILED_FILTER_FILE_LOAD, hr );
            }
            pIFileSink->Release();
        }
    }
}

// handle the custom truncate button in the file-save dialog
UINT_PTR CALLBACK TruncateDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
      case WM_INITDIALOG:
          // Save off the long pointer to the OPENFILENAME structure.
          SetWindowLongPtr(hDlg, DWLP_USER, lParam);

          {
              LPOPENFILENAME lpOFN = (LPOPENFILENAME)lParam;
              DWORD *pfSink2 = (DWORD *)(lpOFN->lCustData);

              if(!(*pfSink2))
              {
                  Edit_Enable(GetDlgItem(hDlg, IDC_TRUNCATE), FALSE);
              }
          }

          break;

      case WM_DESTROY:
      {
          LPOPENFILENAME lpOFN = (LPOPENFILENAME)GetWindowLongPtr(hDlg, DWLP_USER);
          DWORD *pfTruncate = (DWORD *)(lpOFN->lCustData);

          HWND hButtonWnd = ::GetDlgItem(hDlg, IDC_TRUNCATE);
          *pfTruncate = ::SendMessage(hButtonWnd, BM_GETCHECK, 0, 0) == BST_CHECKED;
      }
      break;

      default:
          return FALSE;
    }
    return TRUE;
    
}

// Helper to prompt user for a file name and return it
BOOL PromptUser(OLECHAR* oszFileName, Mode mode, UINT nIDTitle, bool *pfTruncate)
{
    CString strTitle;
    TCHAR tszFile[MAX_PATH];
    tszFile[0] = TEXT('\0');
    DWORD fTruncate;

    OPENFILENAME    ofn;
    ZeroMemory (&ofn, sizeof ofn);	

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = AfxGetMainWnd()->GetSafeHwnd();

    TCHAR tszMediaFileMask[201];

    int iSize = ::LoadString(AfxGetInstanceHandle(), IDS_MEDIA_FILES, tszMediaFileMask, 198);
    ofn.lpstrFilter = tszMediaFileMask;
    // avoid LoadString problems with \0\0
    tszMediaFileMask[iSize] = TEXT('\0');
    tszMediaFileMask[iSize + 1] = TEXT('\0');

    // win95 seems to be confused otherwise
    tszMediaFileMask[iSize + 2] = TEXT('\0');
    
    strTitle.LoadString( nIDTitle );

    ofn.nFilterIndex = 1;
    ofn.lpstrFile = tszFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = strTitle;

    if(mode == MODE_SOURCE)
    {
        ofn.Flags = OFN_FILEMUSTEXIST;
    }
    else if(mode == MODE_SINK || mode== MODE_SINK2)
    {
        DWORD &fSink2 = fTruncate;
        fSink2 = (mode == MODE_SINK2);
            
        ofn.lCustData         = (LPARAM)&fTruncate;
	ofn.lpfnHook 	       = TruncateDlgProc;
	ofn.lpTemplateName    = MAKEINTRESOURCE(IDD_TRUNCATE);        
        ofn.Flags = OFN_EXPLORER | OFN_ENABLEHOOK | OFN_ENABLETEMPLATE | OFN_HIDEREADONLY ;
        ofn.hInstance = AfxGetInstanceHandle();
    }

    // Get the user's selection

    if (!GetOpenFileName(&ofn)) {
        DWORD dw = CommDlgExtendedError();
        return FALSE;
    }

    if(pfTruncate)
    {
        *pfTruncate = !!fTruncate;
    }

#ifdef UNICODE

    wcscpy(oszFileName, tszFile);
#else

    MultiByteToWideChar(CP_ACP, 0, tszFile, -1, oszFileName, MAX_PATH);
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dsperf\dscounters.h ===
/*++

Copyright  2000 Microsoft Corporation

Module Name:

    DsCounters.h

Abstract:

    Performance counter offset definition file.
    
    These offsets must start at 0 and be even. In the PerfOpen function,
    they will be added to the "First Counter" and "First Help" values of the
    device they belong to, in order to determine the absolute location of the
    counter and object names and corresponding help text in the registry.
    
    This file is used by the perf counter code as wess as the counter name
    and help text definition file (.INI) that is used by LODCTR.EXE to load
    the names into the registry.

Author:

    Arthur Zwiegincew (arthurz) 07-Oct-00

Revision History:

    07-Oct-00 - Created

--*/

#define DSHOWPERF_OBJ                        0
#define DSHOWPERF_VIDEO_GLITCHES             2
#define DSHOWPERF_VIDEO_GLITCHES_SEC         4
#define DSHOWPERF_FRAME_RATE                 6
#define DSHOWPERF_JITTER                     8
#define DSHOWPERF_DSOUND_GLITCHES           10
#define DSHOWPERF_KMIXER_GLITCHES           12
#define DSHOWPERF_PORTCLS_GLITCHES          14
#define DSHOWPERF_USBAUDIO_GLITCHES         16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\dstrace\dstrace.cpp ===
/*++

Copyright  2000 Microsoft Corporation

Module Name:

    dstrace.cpp

Abstract:

    DShow performance monitor.

Author:

    Arthur Zwiegincew (arthurz) 22-Sep-00

Revision History:

    22-Sep-00 - Created

--*/

#include <windows.h>
#include <stdio.h>
#include <wmistr.h>
#include <evntrace.h>
#include <initguid.h>
#include <math.h>

#define WMIPERF
#include <perfstruct.h>

GUID KmixerGuid = 
{ 0xe5a43a19, 0x6de0, 0x44f8, 0xb0, 0xd7, 0x77, 0x2d, 0xbd, 0xe4, 0x6c, 0xc0 };

GUID PortclsGuid =
{ 0x9d447297, 0xc576, 0x4015, 0x87, 0xb5, 0xa5, 0xa6, 0x98, 0xfd, 0x4d, 0xd1 };

GUID UsbaudioGuid =
{ 0xd6464a84, 0xa358, 0x4013, 0xa1, 0xe8, 0x6e, 0x2f, 0xb4, 0x8a, 0xab, 0x93 };

//
// Video glitch threshold. When abs(PresentationTime - RenderTime) > this value,
// we consider the event a glitch.
//

#define GLITCH_THRESHOLD 30 /* ms */ * 10000 /* 1 ms / 100 ns */

//
// Define our private ConsoleCtrlHandler() control type to indicate failed initialization.
// We'll call with this constant directly. Used to centralize cleanup code.
//

#define CTRL_INITIALIZATION_ERROR 0xDeadBeef

//
// DSHOW WMI provider GUID.
//

GUID ControlGuid = GUID_DSHOW_CTL;

//
// Global state.
//

HANDLE MonitorThread;
TRACEHANDLE LoggerHandle;
TRACEHANDLE ConsumerHandle;
EVENT_TRACE_LOGFILE Logfile;

////////////////////////////////////////////////////////////////////////////

VOID
TerminateLogging (
    VOID
    )
{
    ULONG status;
    int i;
    struct EVENT_TRACE_INFO {
        EVENT_TRACE_PROPERTIES TraceProperties;
        char Logger[256];
        char LogFileName[256];
    } Info;

    ZeroMemory (&Info, sizeof (Info));
    Info.TraceProperties.LoggerNameOffset = sizeof (EVENT_TRACE_PROPERTIES);
    Info.TraceProperties.LogFileNameOffset = sizeof (EVENT_TRACE_PROPERTIES) + 256;
    Info.TraceProperties.Wnode.BufferSize = sizeof (Info);

    status = ControlTrace (0, "DSTrace", &Info.TraceProperties, EVENT_TRACE_CONTROL_QUERY);
    if (status != ERROR_SUCCESS) {
        printf ("QueryTrace failed=>%d\n", status);
    }

    status = ControlTraceA (LoggerHandle, NULL, &Info.TraceProperties, EVENT_TRACE_CONTROL_STOP);
    if (status != ERROR_SUCCESS) {
        printf ("StopTrace failed=>%d\n", status);
    }

    if (MonitorThread != NULL) {
        EnableTrace (FALSE, 0, 0, &ControlGuid, LoggerHandle);
        TerminateThread (MonitorThread, 0);
    }

    for (i = 0; i < 100; i += 1) {
        Sleep (50);
        status = CloseTrace (ConsumerHandle);
        if (status != ERROR_SUCCESS) {
            printf ("CloseTrace failed=>%d\n", status);
        }
        else {
            break;
        }
    }
    
    status = EnableTrace (FALSE, 0, 0, &ControlGuid, LoggerHandle);
    if (status != ERROR_SUCCESS) {
        printf ("EnableTrace failed=>%d\n", status);
    }
}

////////////////////////////////////////////////////////////////////////////

BOOL
WINAPI
ConsoleCtrlHandler (
    DWORD CtrlType
    )
{
    static BOOL Exiting = FALSE;

    if (Exiting) {
        return TRUE;
    }

    Exiting = TRUE;

    if (CtrlType == CTRL_INITIALIZATION_ERROR) {
        printf ("Failed to initialize.");
    }
    else {
        printf ("Exiting.\n");
    }

    TerminateLogging();
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////

VOID
WINAPI
EventCallback (
    IN PEVENT_TRACE Event
    )
{
    PPERFINFO_DSHOW_AVREND PerfInfoAvRend;
    PPERFINFO_DSHOW_AUDIOGLITCH PerfInfoAudioGlitch;
    ULONG i;
    LONGLONG PresentationDelta;

    if (IsEqualGUID (Event->Header.Guid, GUID_VIDEOREND)) {

        printf (".");

        PerfInfoAvRend = (PPERFINFO_DSHOW_AVREND)Event->MofData;
        PresentationDelta = PerfInfoAvRend->dshowClock - PerfInfoAvRend->sampleTime;
        if (labs ((int)PresentationDelta) > GLITCH_THRESHOLD) {
            printf ("Video glitch on sample time %I64d; delta: %f\n",
                    PerfInfoAvRend->sampleTime,
                    (double)PresentationDelta / 10000.0L);
        }
    }
    else if (IsEqualGUID (Event->Header.Guid, GUID_DSOUNDGLITCH)) {

        PerfInfoAudioGlitch = (PPERFINFO_DSHOW_AUDIOGLITCH)Event->MofData;
        printf ("[DSound] Audio glitch type %d [time %d].\n",
                PerfInfoAudioGlitch->glitchType, GetTickCount());
    }
    else if (IsEqualGUID (Event->Header.Guid, KmixerGuid)) {

        PerfInfoAudioGlitch = (PPERFINFO_DSHOW_AUDIOGLITCH)Event->MofData;
        printf ("[KMixer] Audio glitch type %d [time %d].\n",
                PerfInfoAudioGlitch->glitchType, GetTickCount());
    }
    else if (IsEqualGUID (Event->Header.Guid, PortclsGuid)) {

        PerfInfoAudioGlitch = (PPERFINFO_DSHOW_AUDIOGLITCH)Event->MofData;
        printf ("[PortCls] Audio glitch type %d [time %d].\n",
                PerfInfoAudioGlitch->glitchType, GetTickCount());
    }
    else if (IsEqualGUID (Event->Header.Guid, UsbaudioGuid)) {

        PerfInfoAudioGlitch = (PPERFINFO_DSHOW_AUDIOGLITCH)Event->MofData;
        printf ("[UsbAudio] Audio glitch type %d [time %d].\n",
                PerfInfoAudioGlitch->glitchType, GetTickCount());
    }
    else {
        printf ("Other: GUID %08X-%08X-%08X-%08X\n",
                *((DWORD*)(&Event->Header.Guid)),
                *((DWORD*)(&Event->Header.Guid) + 1),
                *((DWORD*)(&Event->Header.Guid) + 2),
                *((DWORD*)(&Event->Header.Guid) + 3));
    }
}

////////////////////////////////////////////////////////////////////////////

ULONG
WINAPI
BufferCallback (
    PEVENT_TRACE_LOGFILE Log
    )
{
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
MonitorThreadProc (
    LPVOID Param
    )
{
    struct EVENT_TRACE_INFO {
        EVENT_TRACE_PROPERTIES TraceProperties;
        char Logger[256];
    } Info;

    UNREFERENCED_PARAMETER (Param);

    ULONG status;

    //
    // Start the controller.
    //
    
    ZeroMemory (&Info, sizeof (Info));
    Info.TraceProperties.Wnode.BufferSize = sizeof (Info);
    Info.TraceProperties.Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    Info.TraceProperties.Wnode.Guid = ControlGuid;
    Info.TraceProperties.BufferSize = 4096;
    Info.TraceProperties.MinimumBuffers = 8;
    Info.TraceProperties.MaximumBuffers = 32;
    Info.TraceProperties.LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
    Info.TraceProperties.FlushTimer = 1;
    Info.TraceProperties.EnableFlags = 1;
    Info.TraceProperties.AgeLimit = 1;
    Info.TraceProperties.LoggerNameOffset = sizeof (Info.TraceProperties);
    strcpy (Info.Logger, "DSTrace");

    status = StartTrace (&LoggerHandle, "DSTrace", &Info.TraceProperties);
    if (status != ERROR_SUCCESS) {
        printf ("StartTrace failed=>%d\n", status);
        goto RETURN;
    }

    status = EnableTrace (TRUE, 0x1f, 0, &ControlGuid, LoggerHandle);
    if (status != ERROR_SUCCESS) {
        printf ("EnableTrace failed=>%d\n", status);
        goto RETURN;
    }

    //
    // Start the consumer.
    //
    
    ZeroMemory (&Logfile, sizeof (Logfile));
    Logfile.LoggerName = "DSTrace";
    Logfile.LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
    Logfile.BufferCallback = BufferCallback;
    Logfile.EventCallback = EventCallback;

    ConsumerHandle = OpenTrace (&Logfile);
    if (ConsumerHandle == (TRACEHANDLE)INVALID_HANDLE_VALUE) {
        printf ("OpenTrace failed=>%d\n", GetLastError());
        goto RETURN;
    }

    printf ("Trace opened.\n");

    //
    // Consume. This call returns when logging is stopped.
    //

    status = ProcessTrace (&ConsumerHandle, 1, NULL, NULL);
    if (status != ERROR_SUCCESS) {
        printf ("ProcessTrace failed=>%d\n", status);
        return 0;
    }

    //
    // Clean up.
    //

RETURN:
    ConsoleCtrlHandler (CTRL_INITIALIZATION_ERROR);

    return 0;
}

////////////////////////////////////////////////////////////////////////////

VOID
__cdecl
main (
    VOID
    )
{
    ULONG status;

    status = SetConsoleCtrlHandler (ConsoleCtrlHandler, TRUE);
    if (!status) {
        printf ("Failed to initialize.");
        return;
    }

    //
    // Create the monitor thread and block.
    //
    
    MonitorThread = CreateThread (NULL, 0, MonitorThreadProc, 0, 0, NULL);
    if (MonitorThread == NULL) {
        return;
    }

    WaitForSingleObject (MonitorThread, INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\bnetdoc.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// bnetdoc.cpp : defines CBoxNetDoc
//

#include "stdafx.h"
#include <wininet.h>
#include "rndrurl.h"
#include "congraph.h"
#include <evcode.h>
#include "filtervw.h"
#include "gstats.h"
#include "DCF.h"
#include <atlimpl.cpp>
#include "Reconfig.h"
#include "GEErrors.h"

#ifndef OATRUE
#define OATRUE (-1)
#define OAFALSE (0)
#endif

#define INITIAL_ZOOM    3   /* 100% zoom */

// !!!! should be in public header!
EXTERN_GUID(IID_IXMLGraphBuilder,
0x1bb05960, 0x5fbf, 0x11d2, 0xa5, 0x21, 0x44, 0xdf, 0x7, 0xc1, 0x0, 0x0);

interface IXMLGraphBuilder : IUnknown
{
    STDMETHOD(BuildFromXML) (IGraphBuilder *pGraph, IXMLElement *pxml) = 0;
    STDMETHOD(SaveToXML) (IGraphBuilder *pGraph, BSTR *pbstrxml) = 0;
    STDMETHOD(BuildFromXMLFile) (IGraphBuilder *pGraph, WCHAR *wszFileName, WCHAR *wszBaseURL) = 0;
};

// CLSID_XMLGraphBuilder
// {1BB05961-5FBF-11d2-A521-44DF07C10000}
EXTERN_GUID(CLSID_XMLGraphBuilder,
0x1bb05961, 0x5fbf, 0x11d2, 0xa5, 0x21, 0x44, 0xdf, 0x7, 0xc1, 0x0, 0x0);
// !!!!!!!!!!!!!!!
// !!!!!!!!!

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CBoxNetDoc, CDocument)

static BOOL GetErrorText( CString& str, HRESULT hr )
{
    UINT nResource;

    switch( hr ){
    case STG_E_FILENOTFOUND:
        nResource = IDS_FILENOTFOUND;
        break;

    case STG_E_ACCESSDENIED:
        nResource = IDS_ACCESSDENIED;
        break;

    case STG_E_FILEALREADYEXISTS:
        nResource = IDS_NOTSTORAGEOBJECT;;
        break;

    case STG_E_TOOMANYOPENFILES:
        nResource = IDS_TOOMANYOPENFILES;
        break;

    case STG_E_INSUFFICIENTMEMORY:
        nResource = IDS_INSUFFICIENTMEMORY;
        break;

    case STG_E_INVALIDNAME:
        nResource = IDS_INVALIDNAME;
        break;

    case STG_E_SHAREVIOLATION:
    case STG_E_LOCKVIOLATION:
        nResource = IDS_FILE_ALREADY_OPEN;
        break;

    case HRESULT_FROM_WIN32( ERROR_NOT_READY ):
        nResource = IDS_DEVICE_NOT_READY;
        break;

    default:
        return FALSE;
    }

    str.LoadString( nResource );
    return TRUE;

}

static void DisplayErrorMessage( HRESULT hr )
{
    CString str;

    if( GetErrorText( str, hr ) )
        AfxMessageBox( str );
    else
        DisplayQuartzError( IDS_GENERAL_FILE_OPEN, hr );
}

//
// Constructor
//
CBoxNetDoc::CBoxNetDoc()
    : m_pGraph(NULL)
    , m_pMediaEvent(NULL)
    , m_hThread(NULL)
    , m_hWndPostMessage(NULL)
    , m_bNewFilenameRequired(FALSE)
    , m_State(Stopped)
    , m_fUsingClock(FALSE)
    , m_fConnectSmart(TRUE)
    , m_fAutoArrange(TRUE)
    , m_fRegistryChanged(FALSE)
    , m_pMarshalStream(NULL)
    , m_psockSelected(NULL)
    , m_hPendingReconnectBlockEvent(NULL)
    , m_nCurrentSize(INITIAL_ZOOM)
{

    m_phThreadData[0] = NULL;
    m_phThreadData[1] = NULL;
    m_phThreadData[2] = NULL;

    m_tszStgPath[0] = TEXT('\0');
    m_lSourceFilterCount=0;

    //
    // I am assuming that OLECHAR == WCHAR
    //  (which is true for WIN32 && !OLE2ANSI - which is true since MFC40)
    //
    ASSERT(sizeof(OLECHAR) == sizeof(WCHAR));
}

const OLECHAR CBoxNetDoc::m_StreamName[] = L"ActiveMovieGraph"; // DON'T LOCALISE

//
// m_iMaxInsertFilters
//
// the maximum length of the insert menu
// need hard coded restriction for message map
const int CBoxNetDoc::m_iMaxInsertFilters = 1000;


//
// Destructor
//
CBoxNetDoc::~CBoxNetDoc() {
    ASSERT(m_lstUndo.GetCount() == 0);
    ASSERT(m_lstRedo.GetCount() == 0);
    ASSERT(m_lstLinks.GetCount() == 0);
    ASSERT(m_lstBoxes.GetCount() == 0);
    CFilterView::DelFilterView();
    CGraphStats::DelGraphStats();

    ReleaseReconnectResources( ASYNC_RECONNECT_UNBLOCK );
}


//
// OnNewDocument
//
// Instantiate a graph and mapper for this document.
BOOL CBoxNetDoc::OnNewDocument() {

    if (!CDocument::OnNewDocument())
        return FALSE;

    //
    // We don't have a path to the storage anymore
    //
    m_tszStgPath[0] = TEXT('\0');

    if (!CreateGraphAndMapper()) {
        AfxMessageBox(IDS_CANTINITQUARTZ);
        return FALSE;
    }

    m_State = Stopped;

    // saves are allowed even if there is nothing to be saved.
    m_bNewFilenameRequired = FALSE;

    return TRUE;
}

void CBoxNetDoc::OnCloseDocument( )
{
    // We need to close down the thread here as the view window
    // (and thus m_hWndPostMessage) will have been destroyed by the time
    // that CDocument::OnCloseDocument calls DeleteContents.
    CloseDownThread();
    CDocument::OnCloseDocument();
}

//
// DeleteContents
//
// Release the Quartz Graph & mapper
// NB DeleteContents & OnNewDocument are not called symmetrically,
//    so treat the interface pointers with care.
void CBoxNetDoc::DeleteContents(void) {

    ReleaseReconnectResources( ASYNC_RECONNECT_UNBLOCK );

    // !!! why do we think we need to disconnect everything here?
    CloseDownThread();

    // flush the Undo & redo lists, as the graph & mapper interfaces the commands
    // use are about to become invalid.
    m_lstUndo.DeleteRemoveAll();
    m_lstRedo.DeleteRemoveAll();

    //
    // Disconnect each link item and delete it
    //
    while ( m_lstLinks.GetCount() > 0 ) {
        delete m_lstLinks.RemoveHead();
    }

    m_lstBoxes.DeleteRemoveAll();

    delete m_pGraph, m_pGraph = NULL;

    delete m_pMediaEvent, m_pMediaEvent = NULL;
}

//
// CloseDownThread
//
void CBoxNetDoc::CloseDownThread()
{
    //
    // Tell the thread which waits for graph notifications to terminate
    // itself. If it is done, close the handles
    //
    if (m_phThreadData[1] && m_hThread) {
        SetEvent(m_phThreadData[1]);
        WaitForSingleObject(m_hThread, INFINITE);
    }

    //
    // The thread is closed. Remove all remaining WM_USER_EC_EVENT
    // message from the message queue and free the memory we allocated.
    //
    if( m_hWndPostMessage ){
        MSG Msg;
        while ( PeekMessage(&Msg, m_hWndPostMessage, WM_USER_EC_EVENT, WM_USER_EC_EVENT, PM_REMOVE) ) {
            NetDocUserMessage *plParams = (NetDocUserMessage *)Msg.lParam;
            // should call this function, so that filter graph manager can cleanup
            IEvent()->FreeEventParams(plParams->lEventCode, plParams->lParam1, plParams->lParam2);
            delete plParams;
            plParams = NULL;
        }
        m_hWndPostMessage = NULL;
    }


    if (m_hThread) {
        if (!CloseHandle(m_hThread)) {
            TRACE("Closing thread handle failed\n");
        }
        m_hThread = NULL;
    }

    //
    // Don't close m_phThreadData[0], as it is owned by GetEventHandle
    //

    if (m_phThreadData[1] != NULL) {
        if (!CloseHandle(m_phThreadData[1])) {
            TRACE("Closing event handle 1 failed\n");
        }
        m_phThreadData[1] = NULL;
    }
    if (m_phThreadData[2] != NULL) {
        if (!CloseHandle(m_phThreadData[2])) {
            TRACE("Closing event handle 2 failed\n");
        }
        m_phThreadData[2] = NULL;
    }
}

BOOL CBoxNetDoc::AttemptFileRender( LPCTSTR lpszPathName)
{
    if (!OnNewDocument())
        return FALSE;

    CmdDo(new CCmdRenderFile(CString(lpszPathName)) );

    // BUG? What if that failed? We have destroyed our previous graph for nothing

    SetModifiedFlag( FALSE );
    m_State = Stopped;

    m_bNewFilenameRequired = TRUE;

    return TRUE;
}


//
// OnOpenDocument
//
// If this file is a storage, look for a "Graph" stream in it.
// If found, try passing it to the graph as a serialized graph.
// If not found, fail (wrong format file)
// If not a storage, try renderfile'ing it into the current document.
BOOL CBoxNetDoc::OnOpenDocument(LPCTSTR lpszPathName) {

    HRESULT hr;

    if (!CreateGraphAndMapper()) {
        AfxMessageBox(IDS_CANTINITQUARTZ);
        return FALSE;
    }

    WCHAR * pwcFileName;

#ifndef UNICODE
    WCHAR wszPathName[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, lpszPathName, -1, wszPathName, MAX_PATH);
    pwcFileName = wszPathName;
#else
    pwcFileName = lpszPathName;
#endif

    if (0 == lstrcmpi(lpszPathName + lstrlen(lpszPathName) - 3, TEXT("xgr"))) {
        BeginWaitCursor();

        IXMLGraphBuilder *pxmlgb;
        HRESULT hr = CoCreateInstance(CLSID_XMLGraphBuilder, NULL, CLSCTX_INPROC_SERVER,
                      IID_IXMLGraphBuilder, (void**)&pxmlgb);

        if (SUCCEEDED(hr)) {
            DeleteContents();

            if (!CreateGraphAndMapper()) {
                pxmlgb->Release();

                AfxMessageBox(IDS_CANTINITQUARTZ);
                return FALSE;
            }

            hr = pxmlgb->BuildFromXMLFile(IGraph(), pwcFileName, NULL);

            pxmlgb->Release();

            SetModifiedFlag(FALSE);
        }

        UpdateFilters();

        EndWaitCursor();

        if (SUCCEEDED(hr))
            return TRUE;

        DisplayQuartzError( IDS_FAILED_TO_LOAD_GRAPH, hr );

        return FALSE;
    } else if (0 != lstrcmpi(lpszPathName + lstrlen(lpszPathName) - 3, TEXT("grf"))) {
        return AttemptFileRender( lpszPathName );
    }

    CComPtr<IStorage> pStr;

    hr = StgOpenStorage( pwcFileName
                         , NULL
                         ,  STGM_TRANSACTED | STGM_READ
                         , NULL
                         , 0
                         , &pStr
                         );


    // If it is not a storage object. Try render it...
    if( hr == STG_E_FILEALREADYEXISTS ) {
        return AttemptFileRender( lpszPathName );
    }

    // Other error
    if( FAILED( hr ) ){
        DisplayErrorMessage( hr );
        return FALSE;
    }

    // else open must have suceeded.
    DeleteContents();

    try{

        if (!CreateGraphAndMapper()) {
            AfxMessageBox(IDS_CANTINITQUARTZ);
            return FALSE;
        }

        // Get an interface to the graph's IPersistStream and ask it to load
        CQCOMInt<IPersistStream> pips(IID_IPersistStream, IGraph());

        IStream * pStream;

        // Open the filtergraph stream in the file
        hr = pStr->OpenStream( m_StreamName
                                      , NULL
                                      , STGM_READ|STGM_SHARE_EXCLUSIVE
                                      , 0
                                      , &pStream
                                      );

        // Something went wrong. Attempt to render the file
        if( FAILED( hr ) ) {
            return AttemptFileRender( lpszPathName );
        }

        hr = pips->Load(pStream);
        pStream->Release();

        if (SUCCEEDED(hr)) {    // the graph liked it. we're done
            m_State = Stopped;
            UpdateFilters();
            UpdateClockSelection();
            SetModifiedFlag(FALSE);

            //
            // remember the path to this storage
            //
            _tcsncpy(m_tszStgPath, lpszPathName, MAX_PATH);

            return TRUE;
        }

        //
        // Might have been a valid graph, but we are missing the media
        // files used in the graph.
        //
        if ((HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND)
            || (HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND))
        {
            AfxMessageBox(IDS_MISSING_FILE_IN_GRAPH);
        } else {
            DisplayQuartzError( IDS_FAILED_TO_LOAD_GRAPH, hr );
        }

    }
    catch (CHRESULTException) {
        AfxMessageBox(IDS_NOINTERFACE);
    }

    return FALSE;
}


void CBoxNetDoc::OnConnectToGraph()
{
    IUnknown *punkGraph;
#if 0
    // experimental code to connect to garph on other machines....
    COSERVERINFO server;
    server.dwReserved1 = 0;
    server.pwszName = L"\\\\davidmay9";
    server.pAuthInfo = NULL;
    server.dwReserved2 = 0;

    MULTI_QI mqi;
    mqi.pIID = &IID_IUnknown;
    mqi.pItf = NULL;

    HRESULT hr = CoCreateInstanceEx(CLSID_FilterGraph, NULL,
                                    CLSCTX_REMOTE_SERVER, &server,
                                    1, &mqi);

    if (FAILED(hr))
        return;
    punkGraph = mqi.pItf;

#else
#if 0
    {
        const TCHAR szRegKey[] = TEXT("Software\\Microsoft\\Multimedia\\ActiveMovie Filters\\FilterGraph");
        const TCHAR szRegName[] = TEXT("Add To ROT on Create");

        HKEY hKey = 0;
        LONG lRet;

        DWORD dwValue = 0;
        DWORD dwDisp;
        lRet = RegCreateKeyEx(HKEY_CURRENT_USER, szRegKey, 0, NULL, REG_OPTION_NON_VOLATILE,
                              MAXIMUM_ALLOWED, NULL, &hKey, &dwDisp);

        if (lRet == ERROR_SUCCESS) {
            DWORD   dwType, dwLen;

            dwLen = sizeof(DWORD);
            RegQueryValueEx(hKey, szRegName, 0L, &dwType, (LPBYTE)&dwValue, &dwLen);
        }
        if (!dwValue) {
            int iChoice = AfxMessageBox(IDS_GRAPHSPY_NOT_ENABLED, MB_YESNO);

            if (iChoice == IDYES) {
                // change registry entry

                dwValue = 1;
                lRet = RegSetValueEx( hKey, szRegName, 0, REG_DWORD,
                                      (unsigned char *)&dwValue, sizeof(dwValue) );

            }

            // in either case, it won't work this time
            return;
        }

        if (hKey) {
            RegCloseKey(hKey);
        }
    }
#endif

    IMoniker *pmk;

    IRunningObjectTable *pirot;
    if (FAILED(GetRunningObjectTable(0, &pirot)))
        return;

    CConGraph dlgConnectToGraph(&pmk, pirot, AfxGetMainWnd());

    if (dlgConnectToGraph.DoModal() != IDOK || pmk == NULL) {
        pirot->Release();
        return;
    }

    HRESULT hr = pirot->GetObject(pmk, &punkGraph);
    pirot->Release();
#endif

    if (SUCCEEDED(hr)) {
        IGraphBuilder *pGraph;

        hr = punkGraph->QueryInterface(IID_IGraphBuilder, (void **) &pGraph);
        punkGraph->Release();

        if (SUCCEEDED(hr)) {
            DeleteContents();

            m_pGraph = new CQCOMInt<IGraphBuilder>(IID_IGraphBuilder, pGraph);
            pGraph->Release();

            // really just create all *but* the graph, of course
            if (!CreateGraphAndMapper()) {
                AfxMessageBox(IDS_CANTINITQUARTZ);
                return;
            }

            m_State = Stopped; // !!! get from graph?
            m_bNewFilenameRequired = TRUE;

            UpdateFilters();
            SetModifiedFlag(FALSE);
        }
    }
}


//
// SaveModified
//
// Only save the document if the filter graph needs saving
BOOL CBoxNetDoc::SaveModified(void) {

    // HRESULT hr = (*m_pPerStorage)->IsDirty();
    HRESULT hr = S_OK;
    if (hr == S_OK) {
// Disable Save
        return CDocument::SaveModified();
    }
    else if (hr == S_FALSE) {
        return TRUE;
    }
    else {
        //
        // We need to return here to allow file.new / file.exit
        // - this can happen after a unsucessful load on a storage
        //   (eg missing media file in the graph)
        return TRUE;
    }
}

// WriteString
//
// Helper function to facilitate writing text to a file
//
void CBoxNetDoc::WriteString(HANDLE hFile, LPCTSTR lptstr, ...)
{
    DWORD cbWritten = 0;
    TCHAR atchBuffer[MAX_STRING_LEN];

    /* Format the variable length parameter list */

    va_list va;
    va_start(va, lptstr);

    wvsprintf(atchBuffer, lptstr, va);

    DWORD cbToWrite=lstrlen(atchBuffer)*sizeof(TCHAR);

    if (!WriteFile(hFile, atchBuffer, cbToWrite, &cbWritten, NULL) ||
            (cbWritten != cbToWrite))
        AfxMessageBox(IDS_SAVE_HTML_ERR);
}

// GetNextOutFilter
//
// This function does a linear search and returns in iOutFilter the index of
// first filter in the filter information table  which has zero unconnected
// input pins and atleast one output pin  unconnected.
// Returns FALSE when there are none o.w. returns TRUE
//
BOOL CBoxNetDoc::GetNextOutFilter(FILTER_INFO_TABLE &fit, int *iOutFilter)
{
    for (int i=0; i < fit.iFilterCount; ++i) {
        if ((fit.Item[i].dwUnconnectedInputPins == 0) &&
                (fit.Item[i].dwUnconnectedOutputPins > 0)) {
            *iOutFilter=i;
            return TRUE;
        }
    }

    // then things with more outputs than inputs
    for (i=0; i < fit.iFilterCount; ++i) {
        if (fit.Item[i].dwUnconnectedOutputPins > fit.Item[i].dwUnconnectedInputPins) {
            *iOutFilter=i;
            return TRUE;
        }
    }

    // if that doesn't work, find one that at least has unconnected output pins....
    for (i=0; i < fit.iFilterCount; ++i) {
        if (fit.Item[i].dwUnconnectedOutputPins > 0) {
            *iOutFilter=i;
            return TRUE;
        }
    }
    return FALSE;
}

// LocateFilterInFIT
//
// Returns the index into the filter information table corresponding to
// the given IBaseFilter
//
int CBoxNetDoc::LocateFilterInFIT(FILTER_INFO_TABLE &fit, IBaseFilter *pFilter)
{
    int iFilter=-1;
    for (int i=0; i < fit.iFilterCount; ++i) {
        if (fit.Item[i].pFilter == pFilter)
            iFilter=i;
    }

    return iFilter;
}

// MakeScriptableFilterName
//
// Replace any spaces and minus signs in the filter name with an underscore.
// If it is a source filtername than it actually is a file path (with the
// possibility of some stuff added at the end for uniqueness), we create a good filter
// name for it here.
//
void CBoxNetDoc::MakeScriptableFilterName(WCHAR awch[], BOOL bSourceFilter)
{
    if (bSourceFilter) {
        WCHAR awchBuf[MAX_FILTER_NAME];
        BOOL bExtPresentInName=FALSE;
        int iBuf=0;
        for (int i=0; awch[i] != L'\0';++i) {
            if (awch[i]==L'.' && awch[i+1]!=L')') {
                for (int j=1; j <=3; awchBuf[iBuf]=towupper(awch[i+j]),++j,++iBuf);
                awchBuf[iBuf++]=L'_';
                wcscpy(&(awchBuf[iBuf]), L"Source_");
                bExtPresentInName=TRUE;
                break;
            }
        }

        // If we have a filename with no extension than create a suitable name

        if (!bExtPresentInName) {
            wcscpy(awchBuf, L"Source_");
        }

        // make source filter name unique by appending digit always, we don't want to
        // bother to make it unique only if its another instance of the same source
        // filter
        WCHAR awchSrcFilterCnt[10];
        wcscpy(&(awchBuf[wcslen(awchBuf)]),
                _ltow(m_lSourceFilterCount++, awchSrcFilterCnt, 10));
        wcscpy(awch, awchBuf);
    } else {

        for (int i = 0; i < MAX_FILTER_NAME; i++) {
            if (awch[i] == L'\0')
                break;
            else if ((awch[i] == L' ') || (awch[i] == L'-'))
                awch[i] = L'_';
        }
    }
}

// PopulateFIT
//
// Scans through all the filters in the graph, storing the number of input and out
// put pins for each filter, and identifying the source filters in the filter
// inforamtion table. The object tag statements are also printed here
//
void CBoxNetDoc::PopulateFIT(HANDLE hFile, IFilterGraph *pGraph, TCHAR atchBuffer[],
        FILTER_INFO_TABLE *pfit)
{
    HRESULT hr;
    IEnumFilters *penmFilters=NULL;
    if (FAILED(hr=pGraph->EnumFilters(&penmFilters))) {
        WriteString(hFile, TEXT("'Error[%x]:EnumFilters failed!\r\n"), hr);
    }

    IBaseFilter *pFilter;
    ULONG n;
    while (penmFilters && (penmFilters->Next(1, &pFilter, &n) == S_OK)) {
    pfit->Item[pfit->iFilterCount].pFilter = pFilter;

        // Get the input and output pin counts for this filter

        IEnumPins *penmPins=NULL;
        if (FAILED(hr=pFilter->EnumPins(&penmPins))) {
            WriteString(hFile, TEXT("'Error[%x]: EnumPins for Filter Failed !\r\n"), hr);
        }

        IPin *ppin = NULL;
        while (penmPins && (penmPins->Next(1, &ppin, &n) == S_OK)) {
            PIN_DIRECTION pPinDir;
            if (SUCCEEDED(hr=ppin->QueryDirection(&pPinDir))) {
                if (pPinDir == PINDIR_INPUT)
                    pfit->Item[pfit->iFilterCount].dwUnconnectedInputPins++;
                else
                    pfit->Item[pfit->iFilterCount].dwUnconnectedOutputPins++;
            } else {
                WriteString(hFile, TEXT("'Error[%x]: QueryDirection Failed!\r\n"), hr);
            }

            ppin->Release();
        }

        if (penmPins)
            penmPins->Release();

        // Mark the source filters, remember at this point any filters that have
        // all input pins connected (or don't have any input pins) must be sources

        if (pfit->Item[pfit->iFilterCount].dwUnconnectedInputPins==0)
            pfit->Item[pfit->iFilterCount].IsSource=TRUE;


    if (FAILED(hr=pFilter->QueryFilterInfo(&pfit->Item[pfit->iFilterCount].finfo))) {
        WriteString(hFile, atchBuffer,TEXT("'Error[%x]: QueryFilterInfo Failed!\r\n"),hr);

    } else {
            if (pfit->Item[pfit->iFilterCount].finfo.pGraph) {
                pfit->Item[pfit->iFilterCount].finfo.pGraph->Release();
            }

            MakeScriptableFilterName(pfit->Item[pfit->iFilterCount].finfo.achName,
                    pfit->Item[pfit->iFilterCount].IsSource);
    }

    pfit->iFilterCount++;
    }

    if (penmFilters)
        penmFilters->Release();
}

void CBoxNetDoc::PrintFilterObjects(HANDLE hFile, TCHAR atchBuffer[], FILTER_INFO_TABLE *pfit)
{
    for (int i=0; i < pfit->iFilterCount; i++) {
        IPersist *pPersist = NULL;

        IBaseFilter *pFilter = pfit->Item[i].pFilter;
        HRESULT hr;

        if (SUCCEEDED(hr=pFilter->QueryInterface(IID_IPersist, (void**) &pPersist))) {
            CLSID clsid;

            if (SUCCEEDED(hr=pPersist->GetClassID(&clsid))) {
                WCHAR szGUID[100];
                StringFromGUID2(clsid, szGUID, 100);
                szGUID[37] = L'\0';
                WriteString(hFile, TEXT("<OBJECT ID=%ls CLASSID=\"CLSID:%ls\">"
                       "</OBJECT>\r\n"),
                       pfit->Item[i].finfo.achName, szGUID+1);
            } else {
                WriteString(hFile, TEXT("'Error[%x]: GetClassID for Filter Failed !\r\n"), hr);
            }

            pPersist->Release();
        } else {
            WriteString(hFile, TEXT("'Error[%x]: Filter doesn't support IID_IPersist!\r\n"), hr);
        }
    }
}

//
// PrintGraphAsHTML
//
// Writes an HTML page which instantiates the graph and different filters
// using the <OBJECT> tag and VB script methods to add the different filters
// to the graph and make the connections.
//
void CBoxNetDoc::PrintGraphAsHTML(HANDLE hFile)
{
    HRESULT hr;
    ULONG n;
    IFilterGraph *pGraph = IGraph();
    FILTER_INFO_TABLE fit;
    TCHAR atchBuffer[MAX_STRING_LEN];
    atchBuffer[0]=L'\0';
    ZeroMemory(&fit, sizeof(fit));

    // write the initial header tags and instantiate the filter graph
    WriteString(hFile, TEXT("<HTML>\r\n<HEAD>\r\n<TITLE> Saved Graph </TITLE>\r\n"
            "</HEAD>\r\n<BODY>\r\n<OBJECT ID=Graph CLASSID="
            "\"CLSID:E436EBB3-524F-11CE-9F53-0020AF0BA770\"></OBJECT>\r\n"));

    // Fill up the Filter information table and also print the <OBJECT> tag
    // filter instantiations
    PopulateFIT(hFile, pGraph, atchBuffer, &fit);

    PrintFilterObjects(hFile, atchBuffer, &fit);

    WriteString(hFile, TEXT("<SCRIPT language=\"VBScript\">\r\n<!--\r\n"
            "Dim bGraphRendered\r\nbGraphRendered=False\r\n"
            "Sub Window_OnLoad()\r\n"));

    // write the declarations (Dim statement) for the FilterInfo variables
    // which will be returned by AddFilter
    int i;
    for (i = 0; i < fit.iFilterCount; i++) {
        if (fit.Item[i].IsSource) {
            WriteString(hFile, TEXT("\tDim %ls_Info\r\n"), fit.Item[i].finfo.achName);
        }
    }

    // Put the conditional if statement for adding filters and connecting, we don't
    // want to reconnect every the user comes back to this page and Window_OnLoad()
    // gets called
    WriteString(hFile, TEXT("\tif bGraphRendered = False Then\r\n"));

    // write the statements for adding the different filters to the graph, make
    // sure we treat the source filters special since they also will need a
    // a filename
    for (i = fit.iFilterCount-1; i >=0 ; i--) {
        if (fit.Item[i].IsSource) {
            WriteString(hFile, TEXT("\t\tset %ls_Info=Graph.AddFilter(%ls, \"%ls\")\r\n"),
                    fit.Item[i].finfo.achName, fit.Item[i].finfo.achName,
                    fit.Item[i].finfo.achName);

            IFileSourceFilter *pFileSourceFilter=NULL;
            if (FAILED(hr=fit.Item[i].pFilter->QueryInterface(IID_IFileSourceFilter,
                        reinterpret_cast<void **>(&pFileSourceFilter)))) {
                WriteString(hFile, TEXT("'Error[%x]: Couldn't get IFileSourceFilter interface"
                        "from source filter!\r\n"), hr);
            } else {

                LPWSTR lpwstr;
                hr = pFileSourceFilter->GetCurFile(&lpwstr, NULL);
                pFileSourceFilter->Release();

                if (FAILED(hr)) {
                WriteString(hFile,
                            TEXT("'Error[%x]: IFileSourceFilter::GetCurFile failed\r\n"), hr);
                } else {
                    WriteString(hFile, TEXT("\t\t%ls_Info.Filename=\"%ls\"\r\n"),
                            fit.Item[i].finfo.achName, lpwstr);
                    CoTaskMemFree(lpwstr);
                }
            }
        } else {
            WriteString(hFile, TEXT("\t\tcall Graph.AddFilter(%ls, \"%ls\")\r\n"),
                    fit.Item[i].finfo.achName, fit.Item[i].finfo.achName);
        }
    }

    // Find a filter with zero unconnected input pins and > 0 unconnected output pins
    // Connect the output pins and subtract the connections counts for that filter.
    // Quit when there is no such filter left
    for (i=0; i< fit.iFilterCount; i++) {
        int iOutFilter=-1; // index into the fit
        if (!GetNextOutFilter(fit, &iOutFilter))
            break;
        ASSERT(iOutFilter !=-1);
        IEnumPins *penmPins=NULL;
        if (FAILED(hr=fit.Item[iOutFilter].pFilter->EnumPins(&penmPins))) {
            WriteString(hFile, TEXT("'Error[%x]: EnumPins failed for Filter!\r\n"), hr);
        }
        IPin *ppinOut=NULL;
        while (penmPins && (penmPins->Next(1, &ppinOut, &n)==S_OK)) {
            PIN_DIRECTION pPinDir;
            if (FAILED(hr=ppinOut->QueryDirection(&pPinDir))) {
                WriteString(hFile, TEXT("'Error[%x]: QueryDirection Failed!\r\n"), hr);
                ppinOut->Release();
                continue;
            }
            if (pPinDir == PINDIR_OUTPUT) {
                LPWSTR pwstrOutPinID;
                LPWSTR pwstrInPinID;
                IPin *ppinIn=NULL;
                PIN_INFO pinfo;
                FILTER_INFO finfo;
                if (FAILED(hr=ppinOut->QueryId(&pwstrOutPinID))) {
                    WriteString(hFile, TEXT("'Error[%x]: QueryId Failed! \r\n"), hr);
                    ppinOut->Release();
                    continue;
                }
                if (FAILED(hr= ppinOut->ConnectedTo(&ppinIn))) {

                    // It is ok if a particular pin is not connected since we allow
                    // a pruned graph to be saved
                    if (hr == VFW_E_NOT_CONNECTED) {
                        fit.Item[iOutFilter].dwUnconnectedOutputPins--;
                    } else {
                        WriteString(hFile, TEXT("'Error[%x]: ConnectedTo Failed! \r\n"), hr);
                    }
                    ppinOut->Release();
                    continue;
                }
                if (FAILED(hr= ppinIn->QueryId(&pwstrInPinID))) {
                    WriteString(hFile, TEXT("'Error[%x]: QueryId Failed! \r\n"), hr);
                    ppinOut->Release();
                    ppinIn->Release();
                    continue;
                }
                if (FAILED(hr=ppinIn->QueryPinInfo(&pinfo))) {
                    WriteString(hFile, TEXT("'Error[%x]: QueryPinInfo Failed! \r\n"), hr);
                    ppinOut->Release();
                    ppinIn->Release();
                    continue;
                }
                ppinIn->Release();
                if (pinfo.pFilter) {
                    pinfo.pFilter->Release();
                }
                int iToFilter = LocateFilterInFIT(fit, pinfo.pFilter);
                ASSERT(iToFilter < fit.iFilterCount);
                if (FAILED(hr=pinfo.pFilter->QueryFilterInfo(&finfo))) {
                    WriteString(hFile, TEXT("'Error[%x]: QueryFilterInfo Failed! \r\n"), hr);
                    ppinOut->Release();
                    continue;
                }
                if (finfo.pGraph) {
                    finfo.pGraph->Release();
                }
                MakeScriptableFilterName(finfo.achName, fit.Item[iToFilter].IsSource);
                WriteString(hFile, TEXT("\t\tcall Graph.ConnectFilters(%ls,"
                        "\"%ls\", %ls,\"%ls\")\r\n"), fit.Item[iOutFilter].finfo.achName,
                        pwstrOutPinID, finfo.achName, pwstrInPinID);

                CoTaskMemFree(pwstrOutPinID);
                CoTaskMemFree(pwstrInPinID);

                // decrement the count for the unconnected pins for these two filters
                fit.Item[iOutFilter].dwUnconnectedOutputPins--;
                fit.Item[iToFilter].dwUnconnectedInputPins--;
            }
            ppinOut->Release();
        }
        if (penmPins)
            penmPins->Release();
    }

    // Release all the filters in the fit
    for (i = 0; i < fit.iFilterCount; i++)
        fit.Item[i].pFilter->Release();

    WriteString(hFile, TEXT("\t\tbGraphRendered=True\r\n\tend if\r\n"
            "\t'Graph.Control.Run\r\nEnd Sub\r\n"
            "Sub Window_OnUnLoad()\r\n\t'Graph.Control.Stop\r\n"
            "\t'Graph.Position.CurrentPosition=0\r\nEnd Sub\r\n"
            "-->\r\n</SCRIPT>\r\n</BODY>\r\n</HTML>\r\n"));
}


// OnSaveGraphAsHTML
//
// Called when the user selects "Save As HTML" in the File Menu. Puts up
// a Save File dialog, retrieves the filename selected(entered) and opens
// (creates) a file and calls PrintGraphAsHTML for actually saving the graph
// as HTML text.
//
void CBoxNetDoc::OnSaveGraphAsHTML()
{
    CString strExt, strFilter;
    HANDLE hFile;

    strExt.LoadString(IDS_SAVE_HTML_EXT);
    strFilter.LoadString(IDS_SAVE_HTML_FILTER);
    CFileDialog dlgSaveAsHTML(FALSE, strExt, m_strHTMLPath, 0, strFilter,
            AfxGetMainWnd());

    if (dlgSaveAsHTML.DoModal() != IDOK)
        return;

    m_strHTMLPath=dlgSaveAsHTML.GetPathName();

    if ((hFile=CreateFile(m_strHTMLPath, GENERIC_WRITE, FILE_SHARE_READ,
            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
    {
        AfxMessageBox(IDS_SAVE_HTML_FILE_ERR);
        return;
    }

    m_lSourceFilterCount=0;

    HRESULT hr = SafePrintGraphAsHTML( hFile );

    CloseHandle(hFile);

    if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
        return;
    }
}

// OnSaveGraphAsXML
//
// Called when the user selects "Save As XML" in the File Menu. Puts up
// a Save File dialog, retrieves the filename selected(entered) and opens
// (creates) a file and calls PrintGraphAsXML for actually saving the graph
// as XML text.
//
void CBoxNetDoc::OnSaveGraphAsXML()
{
    CString strExt, strFilter;
    HANDLE hFile;

    strExt.LoadString(IDS_SAVE_XML_EXT);
    strFilter.LoadString(IDS_SAVE_XML_FILTER);
    CFileDialog dlgSaveAsXML(FALSE, strExt, m_strXMLPath, OFN_OVERWRITEPROMPT, strFilter,
            AfxGetMainWnd());

    if (dlgSaveAsXML.DoModal() != IDOK)
        return;

    m_strXMLPath=dlgSaveAsXML.GetPathName();

    if ((hFile=CreateFile(m_strXMLPath, GENERIC_WRITE, FILE_SHARE_READ,
            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
    {
        AfxMessageBox(IDS_SAVE_XML_FILE_ERR);
        return;
    }

    IXMLGraphBuilder *pxmlgb;
    HRESULT hr = CoCreateInstance(CLSID_XMLGraphBuilder, NULL, CLSCTX_INPROC_SERVER,
                  IID_IXMLGraphBuilder, (void**)&pxmlgb);

    if (SUCCEEDED(hr)) {
        BSTR bstrXML;
        hr = pxmlgb->SaveToXML(IGraph(), &bstrXML);

        if (SUCCEEDED(hr)) {
            DWORD cbToWrite = SysStringLen(bstrXML) * 2 + 1;
            char *pszXML = new char[cbToWrite];

            if (pszXML) {
                WideCharToMultiByte(CP_ACP, 0,
                                    bstrXML, -1,
                                    pszXML, cbToWrite,
                                    NULL, NULL);
                cbToWrite = lstrlenA(pszXML);

                DWORD cbWritten;
                if (!WriteFile(hFile, pszXML, cbToWrite, &cbWritten, NULL) ||
                    (cbWritten != cbToWrite)) {

                    hr = E_FAIL;
                }

                delete[] pszXML;
            }

            SysFreeString(bstrXML);
        }
        pxmlgb->Release();
    }

    if (FAILED(hr)) {
        AfxMessageBox(IDS_SAVE_XML_FILE_ERR);
    }

    CloseHandle(hFile);
    return;
}

//
// OnSaveDocument
//
// This method will be called during the SAVE and SAVE AS operations.
//
//
BOOL CBoxNetDoc::OnSaveDocument(LPCTSTR lpszPathName) {


    HRESULT hr;

        //
        // SAVE AS
        //

        LPOLESTR oleszPath;

#ifndef UNICODE
        WCHAR wszPath[MAX_PATH];

        MultiByteToWideChar(CP_ACP, 0, lpszPathName, -1, wszPath, MAX_PATH);

        oleszPath = wszPath;
#else
        oleszPath = (LPOLESTR) lpszPathName;  // cast away const
#endif

    CComPtr<IStorage> pStr = NULL;
    hr = StgCreateDocfile( oleszPath
                           ,  STGM_CREATE
                           | STGM_TRANSACTED
                           | STGM_READWRITE
                           | STGM_SHARE_EXCLUSIVE
                           , 0
                           , &pStr
                           );
    if(FAILED(hr)) {
        DisplayErrorMessage( hr );
        return (FALSE);
    }

    IStream * pStream;

    // Open the filtergraph stream in the file
    hr = pStr->CreateStream( m_StreamName
                             , STGM_WRITE|STGM_CREATE|STGM_SHARE_EXCLUSIVE
                             , 0
                             , 0
                             , &pStream
                             );
    if (FAILED(hr)) {
        DisplayErrorMessage( hr );
        return (FALSE);
    }

    // Get an interface to the graph's IPersistStream
    CQCOMInt<IPersistStream> pips(IID_IPersistStream, IGraph());

    hr = pips->Save(pStream, TRUE);

    pStream->Release();

    if (FAILED(hr)) {
        DisplayErrorMessage( hr );
        return (FALSE);
    }

    hr = pStr->Commit(STGC_DEFAULT);
    if (FAILED(hr)) {
        DisplayErrorMessage( hr );
        return (FALSE);
    }

    m_bNewFilenameRequired = FALSE;
    SetModifiedFlag(FALSE);

    return TRUE;
}

void CBoxNetDoc::SetTitle( LPCTSTR lpszTitle )
{
    if( m_bNewFilenameRequired ){
        CString strTitle( lpszTitle );
        CString strUntitled;

        strUntitled.LoadString(AFX_IDS_UNTITLED);

        if( strUntitled != strTitle ){
            CString strReadOnly;

            strReadOnly.LoadString( IDS_READ_ONLY );
            strTitle += strReadOnly;
        }

        CDocument::SetTitle( strTitle );
    }
    else
        CDocument::SetTitle( lpszTitle );

}


/////////////////////////////////////////////////////////////////////////////
// diagnostics


#ifdef _DEBUG
void CBoxNetDoc::AssertValid() const
{
    CDocument::AssertValid();
}
#endif //_DEBUG


#ifdef _DEBUG
void CBoxNetDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);

    dc << TEXT("IFilterGraph :") << IGraph() << TEXT("\n");
    dc << m_lstLinks;
    dc << m_lstBoxes;

}

void CBoxNetDoc::MyDump(CDumpContext& dc) const
{
    dc << TEXT("========= BNETDOC Dump =============\n");
    dc << TEXT("FilterGraph:  ") << (void *)IGraph() << TEXT("\n");

    //
    // Output box information
    //
    dc << TEXT("-------- Boxes --------------\n");

    POSITION pos = m_lstBoxes.GetHeadPosition();
    while (pos != NULL) {
        CBox * pBox = m_lstBoxes.GetNext(pos);

        pBox->MyDump(dc);
    }

    //
    // Output link informatin
    //
    dc << TEXT("--------- Links ---------------\n");

    pos = m_lstLinks.GetHeadPosition();
    while (pos != NULL) {
        CBoxLink * pLink = m_lstLinks.GetNext(pos);

        pLink->MyDump(dc);
    }

    dc << TEXT("========== (end) ============\n");

}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// general functions


/* ModifiedDoc(pSender, lHint, pHint)
 *
 * Indicates that the document has been modified.  The parameters are passed
 * to UpdateAllViews().
 */
void CBoxNetDoc::ModifiedDoc(CView* pSender, LPARAM lHint, CObject* pHint)
{
    SetModifiedFlag(TRUE);
    UpdateAllViews(pSender, lHint, pHint);
}


/* DeselectAll()
 *
 * Deselect all objects that can be selected, including objects for which
 * the document maintains the selection state and document for which
 * views maintain the selection state.
 */
void CBoxNetDoc::DeselectAll()
{
    UpdateAllViews(NULL, CBoxNetDoc::HINT_CANCEL_VIEWSELECT);
    SelectBox(NULL, FALSE);
    SelectLink(NULL, FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// CBox lists and box selection


/* GetBoundingRect(prc, fBoxSel)
 *
 * Set <*prc> to be the bounding rectangle around all items
 * (if <fBoxSel> is FALSE) or around selected boxes (if <fBoxSel>
 * is TRUE).  If there are no items in the bounding rectangle,
 * the null rectangle (all fields zero) is returned.
 */
void CBoxNetDoc::GetBoundingRect(CRect *prc, BOOL fBoxSel)
{
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc
    BOOL            fNoBoxFoundYet = TRUE;

    for (pos = m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = (CBox *) m_lstBoxes.GetNext(pos);
        if (!fBoxSel || pbox->IsSelected())
        {
            if (fNoBoxFoundYet)
            {
                *prc = pbox->GetRect();
                fNoBoxFoundYet = FALSE;
            }
            else
                prc->UnionRect(prc, &pbox->GetRect());
        }
    }

    if (fNoBoxFoundYet)
        prc->SetRectEmpty();
}


/* SelectBox(pbox, fSelect)
 *
 * Select <pbox> if <fSelect> is TRUE, deselect if <fSelect> is FALSE.
 * If <pbox> is NULL, do the same for all boxes in the document.
 */
void CBoxNetDoc::SelectBox(CBox *pbox, BOOL fSelect)
{
    if (pbox == NULL)
    {
        POSITION        pos;            // position in linked list

        // enumerate all boxes in document
        for (pos = m_lstBoxes.GetHeadPosition(); pos != NULL; )
        {
            pbox = (CBox *) m_lstBoxes.GetNext(pos);
            SelectBox(pbox, fSelect);
        }

        return;
    }

    // do nothing if box is already selected/deselected as requested
    if (fnorm(fSelect) == fnorm(pbox->IsSelected()))
        return;

    // repaint <pbox>
    pbox->SetSelected(fSelect);
    UpdateAllViews(NULL, CBoxNetDoc::HINT_DRAW_BOX, pbox);

    if (pbox->IsSelected()) {   // select its links

        CBoxSocket *psock;
        CSocketEnum NextSocket(pbox);
        while ( 0 != (psock = NextSocket())) {

            if (psock->IsConnected()) {
                SelectLink(psock->m_plink, TRUE);
            }
        }
    }

}


//
// SelectLink
//
// do plink->SetSelected(fSelect) iff plink !=NULL
// otherwise SetSelect all links
void CBoxNetDoc::SelectLink(CBoxLink *plink, BOOL fSelect) {

    if (plink == NULL) {    // select all

        POSITION posNext = m_lstLinks.GetHeadPosition();

        while (posNext != NULL) {

             SelectLink(m_lstLinks.GetNext(posNext), fSelect);
        }
        return;
    }

    if (fnorm(fSelect) == fnorm(plink->IsSelected())) {
        return; // already as requested
    }

    plink->SetSelected(fSelect);
    UpdateAllViews(NULL, CBoxNetDoc::HINT_DRAW_LINK, plink);
}


//
// IsBoxSelectionEmpty
//
// Return TRUE if no boxes are selected, FALSE otherwise.
BOOL CBoxNetDoc::IsBoxSelectionEmpty() {

    POSITION pos = m_lstBoxes.GetHeadPosition();

    while (pos != NULL) {

        CBox *pbox = m_lstBoxes.GetNext(pos);
        if (pbox->IsSelected())
            return FALSE;
    }

    // no selected box found
    return TRUE;
}


//
// IsLinkSelectionEmpty
//
// Return TRUE if no links are selected, FALSE otherwise.
BOOL CBoxNetDoc::IsLinkSelectionEmpty() {

    POSITION    pos = m_lstLinks.GetHeadPosition();

    while (pos != NULL) {

        CBoxLink *plink = m_lstLinks.GetNext(pos);
        if (plink->IsSelected()) {
            return FALSE;
        }
    }

    // no selected link found
    return TRUE;
}

/* GetBoxes(plstDst, fSelected)
 *
 * Call RemoveAll() on <plstDst>, then add pointers to each selected CBox
 * (if <fSelected> is TRUE) or each CBox (if <fSelected> is FALSE) in the
 * CBoxNetDoc to <plstDst>.
 */
void CBoxNetDoc::GetBoxes(CBoxList *plstDst, BOOL fSelected)
{
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc

    plstDst->RemoveAll();
    for (pos = m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = m_lstBoxes.GetNext(pos);
        if (!fSelected || pbox->IsSelected())
            plstDst->AddTail(pbox);
    }
}


/* SetBoxes(plstSrc, fSelected)
 *
 * Set the selection (if <fSelected> is TRUE) or the current list of boxes
 * (if <fSelected> is FALSE) to be the elements in <plstSrc> (which should be
 * a list of CBox pointers).  In the latter case, <plstSrc> is copied, so
 * the caller is responsible for later freeing <plstSrc>.
 */
void CBoxNetDoc::SetBoxes(CBoxList *plstSrc, BOOL fSelected)
{
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc

    if (fSelected)
    {
        DeselectAll();

        // select all in <plstSrc>
        for (pos = plstSrc->GetHeadPosition(); pos != NULL; )
        {
            pbox = plstSrc->GetNext(pos);
            SelectBox(pbox, TRUE);
        }
    }
    else
    {
        // empty the list of boxes in the document
        m_lstBoxes.RemoveAll();

        // set the list to be a copy of <plstSrc>
        for (pos = plstSrc->GetHeadPosition(); pos != NULL; )
        {
            pbox = plstSrc->GetNext(pos);
            m_lstBoxes.AddTail(pbox);
            pbox->AddToGraph();
            // pins could have changed
            pbox->Refresh();
        }
    }
}


//
// SelectBoxes
//
// Select the boxes in the supplied list
void CBoxNetDoc::SelectBoxes(CList<CBox *, CBox*> *plst) {

    POSITION posNext = plst->GetHeadPosition();

    while (posNext != NULL) {

        CBox *pbox = plst->GetNext(posNext);
        SelectBox(pbox, TRUE);
    }
}


//
// SelectLinks
//
// Select the links on the supplied list
void CBoxNetDoc::SelectLinks(CList<CBoxLink *, CBoxLink *> *plst) {

    POSITION posNext = plst->GetHeadPosition();

    while (posNext != NULL) {

        CBoxLink *plink = plst->GetNext(posNext);
        SelectLink(plink, TRUE);
    }
}


/* InvalidateBoxes(plst)
 *
 * Causes all boxes in <plst> (a list of CBox objects) to be redrawn.
 */
void CBoxNetDoc::InvalidateBoxes(CBoxList *plst)
{
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc

    for (pos = plst->GetHeadPosition(); pos != NULL; )
    {
        pbox = plst->GetNext(pos);
        UpdateAllViews(NULL, CBoxNetDoc::HINT_DRAW_BOX, pbox);
    }
}


/* MoveBoxSelection(sizOffset)
 *
 * Move each selected box by <sizOffset> pixels.
 */
void CBoxNetDoc::MoveBoxSelection(CSize sizOffset)
{
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc
    CBoxLink *      plink;          // a link in CBoxNetDoc

    // move each box by <sizOffset>
    for (pos = m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = (CBox *) m_lstBoxes.GetNext(pos);
        if (pbox->IsSelected())
        {
            // erase box
            ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_BOXANDLINKS, pbox);

            // move box
            pbox->Move(sizOffset);

            // draw box in new location
            ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_BOXANDLINKS, pbox);
        }
    }

    // move by <sizOffset> each link that connects two selected boxes
    for (pos = m_lstLinks.GetHeadPosition(); pos != NULL; )
    {
        plink = m_lstLinks.GetNext(pos);
        if (plink->m_psockTail->m_pbox->IsSelected() &&
            plink->m_psockHead->m_pbox->IsSelected())
        {
            // erase link
            ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_LINK, plink);

            // draw link in new location
            ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_LINK, plink);
        }
    }
}


//
// --- Command Processing ---
//
// The way the user affects the state of this document

//
// CmdDo(pcmd)
//
// Do command <pcmd>, and add it to the undo stack.  <pcmd> needs to have
// been allocated by the "new" operator.
void CBoxNetDoc::CmdDo(CCmd *pcmd) {

#ifdef _DEBUG
    CString strCmd;
    strCmd.LoadString(pcmd->GetLabel());
    TRACE("CmdDo '%s'\n", (LPCSTR) strCmd);
#endif

    // cancel modes in all views
    UpdateAllViews(NULL, HINT_CANCEL_MODES, NULL);

    // do command
    pcmd->Do(this);

    if (pcmd->CanUndo(this))
    {
        // command supports Undo, so add it to the undo stack
        pcmd->m_fRedo = FALSE;
        m_lstUndo.AddHead(pcmd);
    }
    else
    {
        // command can't be undone, so disable Undo
        m_lstUndo.DeleteRemoveAll();

    delete pcmd;
    }

    // delete the redo stack
    m_lstRedo.DeleteRemoveAll();
}


//
// CmdUndo()
//
// Undo the last command.
void CBoxNetDoc::CmdUndo() {

    ASSERT(CanUndo());

    CCmd *      pcmd;

    // cancel modes in all views
    UpdateAllViews(NULL, HINT_CANCEL_MODES, NULL);

    // pop the undo stack
    pcmd = (CCmd *) m_lstUndo.RemoveHead();

#ifdef _DEBUG
    CString strCmd;
    strCmd.LoadString(pcmd->GetLabel());
    TRACE("CmdUndo '%s'\n", (LPCSTR) strCmd);
#endif

    // undo the command
    pcmd->Undo(this);

    // add command to the redo stack
    pcmd->m_fRedo = TRUE;
    m_lstRedo.AddHead(pcmd);
}


//
// CanUndo()
//
// Return TRUE iff CmdUndo() can be performed.
BOOL CBoxNetDoc::CanUndo() {

    return !m_lstUndo.IsEmpty();
}


//
// CmdRedo()
//
// Redo the last undone command.  This is only valid if the redo stack
// is not empty.
void CBoxNetDoc::CmdRedo() {

    ASSERT(CanRedo());

    CCmd *      pcmd;

    // cancel modes in all views
    UpdateAllViews(NULL, HINT_CANCEL_MODES, NULL);

    // pop the redo stack
    pcmd = (CCmd *) m_lstRedo.RemoveHead();

#ifdef _DEBUG
    CString strCmd;
    strCmd.LoadString(pcmd->GetLabel());
    TRACE("CmdRedo '%s'\n", (LPCSTR) strCmd);
#endif

    // redo the command
    pcmd->Redo(this);

    // add command to the undo stack
    pcmd->m_fRedo = FALSE;
    m_lstUndo.AddHead(pcmd);
}


//
// CanRedo()
//
// Return TRUE iff CmdRedo() can be performed.
BOOL CBoxNetDoc::CanRedo() {

    return !m_lstRedo.IsEmpty();
}


//
// CmdRepeat()
//
// Repeat the last command.  This is only valid if you can repeat
void CBoxNetDoc::CmdRepeat() {

    ASSERT(CanRepeat());

    CCmd *      pcmd;
    CCmd *      pcmdRepeat;

    // cancel modes in all views
    UpdateAllViews(NULL, HINT_CANCEL_MODES, NULL);

    // get the command at the top of the undo stack
    pcmd = (CCmd *) m_lstUndo.GetHead();

#ifdef _DEBUG
    CString strCmd;
    strCmd.LoadString(pcmd->GetLabel());
    TRACE("CmdRepeat '%s'\n", (LPCSTR) strCmd);
#endif

    // create a duplicate of the command
    pcmdRepeat = pcmd->Repeat(this);

    // do command
    pcmdRepeat->Do(this);

    // add command to the undo stack
    pcmdRepeat->m_fRedo = FALSE;
    m_lstUndo.AddHead(pcmdRepeat);
}


//
// CanRepeat()
//
// Return TRUE iff CmdRepeat() can be performed.
BOOL CBoxNetDoc::CanRepeat() {

    // can't do Repeat if the undo stack is empty (no command to repeat)
    // or the redo stack is empty (can't Repeat after Undo)
    if (m_lstUndo.IsEmpty() || !m_lstRedo.IsEmpty())
        return FALSE;

    // can only repeat commands that support Repeat()
    CCmd *pcmd = (CCmd *) m_lstUndo.GetHead();
    return pcmd->CanRepeat(this);
}


/////////////////////////////////////////////////////////////////////////////
// generated message map

BEGIN_MESSAGE_MAP(CBoxNetDoc, CDocument)
    //{{AFX_MSG_MAP(CBoxNetDoc)
    ON_COMMAND(ID_FILE_RENDER, OnFileRender)
    ON_COMMAND(ID_URL_RENDER, OnURLRender)
    ON_UPDATE_COMMAND_UI(ID_FILE_RENDER, OnUpdateFileRender)
    ON_UPDATE_COMMAND_UI(ID_URL_RENDER, OnUpdateURLRender)
    ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateFileSave)
    ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
    ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
    ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
    ON_UPDATE_COMMAND_UI(ID_EDIT_SELECT_ALL, OnUpdateEditSelectAll)
    ON_COMMAND(ID_QUARTZ_DISCONNECT, OnQuartzDisconnect)
    ON_COMMAND(ID_QUARTZ_RUN, OnQuartzRun)
    ON_UPDATE_COMMAND_UI(ID_QUARTZ_DISCONNECT, OnUpdateQuartzDisconnect)
    ON_COMMAND(ID_WINDOW_REFRESH, OnWindowRefresh)
    ON_COMMAND(ID_WINDOW_ZOOM25, OnWindowZoom25)
    ON_COMMAND(ID_WINDOW_ZOOM50, OnWindowZoom50)
    ON_COMMAND(ID_WINDOW_ZOOM75, OnWindowZoom75)
    ON_COMMAND(ID_WINDOW_ZOOM100, OnWindowZoom100)
    ON_COMMAND(ID_WINDOW_ZOOM150, OnWindowZoom150)
    ON_COMMAND(ID_WINDOW_ZOOM200, OnWindowZoom200)
    ON_COMMAND(ID_INCREASE_ZOOM, IncreaseZoom)
    ON_COMMAND(ID_DECREASE_ZOOM, DecreaseZoom)
    ON_UPDATE_COMMAND_UI(ID_QUARTZ_RUN, OnUpdateQuartzRun)
    ON_UPDATE_COMMAND_UI(ID_QUARTZ_PAUSE, OnUpdateQuartzPause)
    ON_UPDATE_COMMAND_UI(ID_QUARTZ_STOP, OnUpdateQuartzStop)
    ON_COMMAND(ID_QUARTZ_STOP, OnQuartzStop)
    ON_COMMAND(ID_QUARTZ_PAUSE, OnQuartzPause)
    ON_UPDATE_COMMAND_UI(ID_USE_CLOCK, OnUpdateUseClock)
    ON_COMMAND(ID_USE_CLOCK, OnUseClock)
    ON_UPDATE_COMMAND_UI(ID_CONNECT_SMART, OnUpdateConnectSmart)
    ON_COMMAND(ID_CONNECT_SMART, OnConnectSmart)
    ON_UPDATE_COMMAND_UI(ID_AUTOARRANGE, OnUpdateAutoArrange)
    ON_COMMAND(ID_AUTOARRANGE, OnAutoArrange)
    ON_COMMAND(ID_GRAPH_ADDFILTERTOCACHE, OnGraphAddFilterToCache)
    ON_UPDATE_COMMAND_UI(ID_GRAPH_ADDFILTERTOCACHE, OnUpdateGraphAddFilterToCache)
    ON_COMMAND(ID_GRAPH_ENUMCACHEDFILTERS, OnGraphEnumCachedFilters)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_INSERT_FILTER, OnInsertFilter)
    ON_COMMAND(ID_CONNECT_TO_GRAPH, OnConnectToGraph)
    ON_COMMAND(ID_GRAPH_STATS, OnGraphStats)

    // -- pin properties menu --
    ON_UPDATE_COMMAND_UI(ID_RENDER, OnUpdateQuartzRender)
    ON_COMMAND(ID_RENDER, OnQuartzRender)

    ON_UPDATE_COMMAND_UI(ID_RECONNECT, OnUpdateReconnect)
    ON_COMMAND(ID_RECONNECT, OnReconnect)

    ON_COMMAND(ID_FILE_SAVE_AS_HTML, OnSaveGraphAsHTML)
    ON_COMMAND(ID_FILE_SAVE_AS_XML, OnSaveGraphAsXML)

END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// message callback helper functions


/* UpdateEditUndoRedoRepeat(pCmdUI, fEnable, idStringFmt, plst)
 *
 * Update the menu item UI for the Undo, Redo, and Repeat commands.
 * <pCmdUI> is the CCmdUI for the menu item.  <fEnable> is TRUE iff
 * the command can be enabled.  <idStringFmt> is the ID of the string
 * resource containing the wsprintf() format string to use for the
 * menu item (e.g. "Undo %s").  <plst> is the CCmd list containing the
 * command; the head of this list will be examined to get the name of
 * the command for use in the menu item text (e.g. "Undo Delete Boxes").
 */
void CBoxNetDoc::UpdateEditUndoRedoRepeat(CCmdUI* pCmdUI, BOOL fEnable,
    unsigned idStringFmt, CMaxList *plst)
{
    CString         strCmd;         // command label
    CString         strMenuFmt;     // menu item label (wsprint format)
    char            achMenu[100];   // result menu item label

    // load the string item that represents  the command (e.g. "Delete Boxes")
    // used in the menu item (e.g. "Undo Delete Boxes")
    strMenuFmt.LoadString(idStringFmt);
    if (fEnable)
        strCmd.LoadString(((CCmd *) plst->GetHead())->GetLabel());
    else
        strCmd = "";                // can't undo/redo/repeat
    wsprintf(achMenu, strMenuFmt, (LPCSTR) strCmd);
    pCmdUI->SetText(achMenu);

    // enable/disable the menu item
    pCmdUI->Enable(fEnable);
}


/////////////////////////////////////////////////////////////////////////////
// message callback functions


void CBoxNetDoc::OnEditUndo()
{
    CmdUndo();
}


void CBoxNetDoc::OnUpdateEditUndo(CCmdUI* pCmdUI)
{
    UpdateEditUndoRedoRepeat(pCmdUI, CanUndo(), IDS_MENU_UNDO, &m_lstUndo);
}


void CBoxNetDoc::OnEditRedo()
{
    if( CanRedo() )
        CmdRedo();
    else
        CmdRepeat();
}


void CBoxNetDoc::OnUpdateEditRedo(CCmdUI* pCmdUI)
{
    // The Redo command may be a Repeat command depending on the context
    // The changing of the status bar text is handled by CMainFrame::GetMessageString
    if( CanRedo() )
        UpdateEditUndoRedoRepeat(pCmdUI, CanRedo(), IDS_MENU_REDO, &m_lstRedo);
    else
        UpdateEditUndoRedoRepeat(pCmdUI, CanRepeat(), IDS_MENU_REPEAT, &m_lstUndo);

}

void CBoxNetDoc::OnEditSelectAll()
{
    // deselect all, select all boxes
    // !!!! need to select all links....
    DeselectAll();
    SelectBox(NULL, TRUE);
}


void CBoxNetDoc::OnUpdateEditSelectAll(CCmdUI* pCmdUI)
{
    // check if there are any boxes to select
    pCmdUI->Enable(m_lstBoxes.GetCount() != 0);
}

//
// OnInsertFilter
//
// Display a list view which allows the user to select a filter to insert
// into the graph.
//
void CBoxNetDoc::OnInsertFilter()
{
    //
    // Make sure common controls are available
    //
    InitCommonControls();

    CFilterView::GetFilterView( this, AfxGetMainWnd() );
}

//
// OnGraphStas
//
// Display a list of graph-wide statistics.
//
void CBoxNetDoc::OnGraphStats()
{
    CGraphStats::GetGraphStats( this, AfxGetMainWnd() );
}

//
// OnQuartzDisconnect
//
// user wants everything disconnected
void CBoxNetDoc::OnQuartzDisconnect()
{
    CmdDo(new CCmdDisconnectAll());

}


//
// OnQuartzRun
//
// Play the graph
void CBoxNetDoc::OnQuartzRun (void) {

    try {

        HRESULT hr;
        CQCOMInt<IMediaControl> IMC(IID_IMediaControl, IGraph());

        hr = IMC->Run();
        if (FAILED(hr)) {
            DisplayQuartzError( IDS_CANTPLAY, hr );
            TRACE("Run failed hr = %x\n", hr);

            OAFilterState state;
            IMC->GetState(0, &state);
            switch (state) {
            case State_Stopped:
                m_State = Stopped;
                break;
            case State_Paused:
                m_State = Paused;
                break;
            case State_Running:
                m_State = Playing;
                break;
            }

        return;
        }

        // Calling Run on the filtergraph will have it call Pause if we have
        // not already done so. Calling Pause on the video renderer will make
        // it show its video window because of the auto show property there
        // is in IVideoWindow. Showing the window will send an EC_REPAINT as
        // it needs an image to draw. So if we show the window manually we
        // must do so after calling Run/Pause otherwise we get an EC_REPAINT
        // sent just before we call Run/Pause ourselves which is redundant
        // (because the repaint has the graph stopped and paused all over!)

        CQCOMInt<IVideoWindow> IVW(IID_IVideoWindow, IGraph());
        IVW->SetWindowForeground(OATRUE);
        m_State = Playing;
    }
    catch (CHRESULTException hre) {

        DisplayQuartzError( IDS_CANTPLAY, hre.Reason() );
    }

    return;

}


//
// OnQuartzPause
//
// Change state between play & pause
void CBoxNetDoc::OnQuartzPause (void) {

    try {

        HRESULT hr;
        CQCOMInt<IMediaControl> IMC(IID_IMediaControl, IGraph());

        hr = IMC->Pause();
        if (FAILED(hr)) {
            DisplayQuartzError( IDS_CANTPAUSE, hr );
            TRACE("Pause failed hr = %x\n", hr);

            OAFilterState state;
            IMC->GetState(0, &state);
            switch (state) {
            case State_Stopped:
                m_State = Stopped;
                break;
            case State_Paused:
                m_State = Paused;
                break;
            case State_Running:
                m_State = Playing;
                break;
            }

        return;
        }

        // Calling Run on the filtergraph will have it call Pause if we have
        // not already done so. Calling Pause on the video renderer will make
        // it show its video window because of the auto show property there
        // is in IVideoWindow. Showing the window will send an EC_REPAINT as
        // it needs an image to draw. So if we show the window manually we
        // must do so after calling Run/Pause otherwise we get an EC_REPAINT
        // sent just before we call Run/Pause ourselves which is redundant
        // (because the repaint has the graph stopped and paused all over!)

        CQCOMInt<IVideoWindow> IVW(IID_IVideoWindow, IGraph());
        IVW->SetWindowForeground(OATRUE);
        m_State = Paused;
    }
    catch (CHRESULTException hre) {

        DisplayQuartzError( IDS_CANTPAUSE, hre.Reason() );
    }

    return;
}


//
// OnUpdateQuartzDisconnect
//
// Are there any links to disconnect?
void CBoxNetDoc::OnUpdateQuartzDisconnect(CCmdUI* pCmdUI)
{
    pCmdUI->Enable( CCmdDisconnectAll::CanDo(this) );
}

#ifdef DSHOW_USE_WM_CERT

#include <..\..\..\filters\asf\wmsdk\inc\wmsdkidl.h>

// note: this object is a SEMI-COM object, and can only be created statically.
class CKeyProvider : public IServiceProvider {
public:
    STDMETHODIMP_(ULONG) AddRef() { return 2; }
    STDMETHODIMP_(ULONG) Release() { return 1; }

    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)
    {
        if (riid == IID_IServiceProvider || riid == IID_IUnknown) {
            *ppv = (void *) static_cast<IServiceProvider *>(this);
            return NOERROR;
        }
        return E_NOINTERFACE;
    }


    STDMETHODIMP QueryService(REFIID siid, REFIID riid, void **ppv)
    {
        if (siid == __uuidof(IWMReader) && riid == IID_IUnknown) {

            IUnknown *punkCert;

            HRESULT hr = WMCreateCertificate( &punkCert );
            if (SUCCEEDED(hr)) {
                *ppv = (void *) punkCert;
            }
            return hr;
        }
        return E_NOINTERFACE;
    }

} g_keyprov;

#endif

//
// CreateGraphAndMapper
//
// CoCreates the filtergraph and mapper. Called by new documents
// and loading documents. Can be called multiple times harmlessly.
BOOL CBoxNetDoc::CreateGraphAndMapper(void) {

    if (m_pGraph && m_pMediaEvent) { // already been done.
        return TRUE;
    }

    try {

        HRESULT hr; // return code

        ASSERT(m_pMediaEvent == NULL);

        if (!m_pGraph)
            m_pGraph = new CQCOMInt<IGraphBuilder>(IID_IGraphBuilder, CLSID_FilterGraph);

        m_pMediaEvent = new CQCOMInt<IMediaEvent>(IID_IMediaEvent, IGraph());

        //
        // Creation of a seperate thread which will translate event signals
        // to messages. This is used to avoid busy polling of the event
        // states in the OnIdle method.
        //

        //
        // the event handle that is signalled when event notifications arrive
        // is created by the filter graph, but we can get it ourselves.
        //
        hr = IEvent()->GetEventHandle((OAEVENT*)&m_phThreadData[0]);
        if (FAILED(hr)) {
            TRACE("Failed to get event handle\n");
            throw CHRESULTException();
        }

        ASSERT(m_phThreadData[0]);
        ASSERT(!m_phThreadData[1]);
        ASSERT(!m_phThreadData[2]);

        m_phThreadData[1] = CreateEvent(NULL, FALSE, FALSE, NULL);
        m_phThreadData[2] = CreateEvent(NULL, FALSE, FALSE, NULL);
        RegNotifyChangeKeyValue(HKEY_CLASSES_ROOT, TRUE,
        REG_NOTIFY_CHANGE_LAST_SET, m_phThreadData[2], TRUE);

        if (m_phThreadData[1] == NULL) {
            //
            // Failed to create event - we'll go on anyway but GraphEdt
            // won't respond to EC_ notifications (not a major problem)
            //
        }
        else {
            // Old quartz.dll will hang if we don't support IMarshal
            IMarshal *pMarshal;
            HRESULT hr = IGraph()->QueryInterface(IID_IMarshal, (void **)&pMarshal);
            if (SUCCEEDED(hr)) {
                pMarshal->Release();
                //
                // Start up the thread which just waits for
                // any EC_  notifications and translate them into messages
                // for our message loop.
                //
                CoMarshalInterThreadInterfaceInStream(IID_IMediaEvent, IEvent(), &m_pMarshalStream);
            }
            DWORD dw;
            m_hThread = CreateThread(NULL, 0, NotificationThread,
                                     (LPVOID) this, 0, &dw);
        }
#ifdef DSHOW_USE_WM_CERT
        IObjectWithSite* pObjectWithSite = NULL;
        HRESULT hrKey = IGraph()->QueryInterface(IID_IObjectWithSite, (void**)&pObjectWithSite);
        if (SUCCEEDED(hrKey))
        {
            pObjectWithSite->SetSite((IUnknown *) &g_keyprov);
            pObjectWithSite->Release();
        }
#endif
        UpdateClockSelection();

        ASSERT(m_pGraph != NULL);
        ASSERT(m_pMediaEvent != NULL);
    }
    catch (CHRESULTException) {

        delete m_pGraph, m_pGraph = NULL;

        delete m_pMediaEvent, m_pMediaEvent = NULL;

        return FALSE;
    }

    return TRUE;
}


//
// GetFiltersInGraph
//
// If an 'intelligent' feature is used the graph may add filters without
// telling us. Therefore enumerate the filters and links
// in the graph
HRESULT CBoxNetDoc::GetFiltersInGraph( void )
{
    m_lstLinks.DeleteRemoveAll();

    POSITION posNext;
    CBox *pCurrentBox;
    POSITION posCurrent;

    // We want the list to allocate at least one unit each time
    // a box is added to the list.
    int nListAllocationBlockSize = max( m_lstBoxes.GetCount(), 1 );

    // The list deletes any boxes which are left on the list when the
    // function exists.
    CBoxList lstExistingBoxes( TRUE, nListAllocationBlockSize );

    // Copy the boxes on m_lstBoxes to lstExistingBoxes.
    posNext = m_lstBoxes.GetHeadPosition();

    while( posNext != NULL ) {
        posCurrent = posNext;
        pCurrentBox = m_lstBoxes.GetNext( posNext );

        try {
            lstExistingBoxes.AddHead( pCurrentBox );
        } catch( CMemoryException* pOutOfMemory ) {
            pOutOfMemory->Delete();
            return E_OUTOFMEMORY;
        }

        m_lstBoxes.RemoveAt( posCurrent );

        pCurrentBox = NULL;
    }

    // m_lstBoxes should be empty.
    ASSERT( 0 == m_lstBoxes.GetCount() );

    // Put all the filters in the filter graph on the box list.
    // Each box corresponds to a filter.  The boxes list's order is
    // the same as the filter graph enumerator's order.  The box list
    // must be in this order because SetBoxesHorizontally() will not
    // display the boxes correctly if the box list and the filter graph
    // enumerator have a different order.

    CComPtr<IEnumFilters> pFiltersInGraph;

    HRESULT hr = IGraph()->EnumFilters( &pFiltersInGraph );
    if( FAILED( hr ) ) {
        return hr;
    }

    CBox* pNewBox;
    HRESULT hrNext;
    IBaseFilter* apNextFiler[1];
    CComPtr<IBaseFilter> pNextFilter;

    do
    {
        ULONG ulNumFiltersEnumerated;

        hrNext = pFiltersInGraph->Next( 1, apNextFiler, &ulNumFiltersEnumerated );
        if( FAILED( hrNext ) ) {
            return hrNext;
        }

        // IEnumFilters::Next() only returns two success values: S_OK and S_FALSE.
        ASSERT( (S_OK == hrNext) || (S_FALSE == hrNext) );

        // IEnumFilters::Next() returns S_OK if it has not finished enumerating the
        // filters in the filter graph.
        if( S_OK == hrNext ) {

            pNextFilter.Attach( apNextFiler[0] );
            apNextFiler[0] = NULL;

            try {
                if( !lstExistingBoxes.RemoveBox( pNextFilter, &pNewBox ) ) {
                    // This is a new filter Graph Edit has not previously seen.
                    // CBox::CBox() can throw a CHRESULTException.  new can throw a CMemoryException.
                    pNewBox = new CBox( pNextFilter, this );
                } else {
                    hr = pNewBox->Refresh();
                    if( FAILED( hr ) ) {
                        delete pNewBox;
                        return hr;
                    }
                }

                // AddHead() can throw a CMemoryException.
                m_lstBoxes.AddHead( pNewBox );

                pNewBox = NULL;
                pNextFilter = NULL;

            } catch( CHRESULTException chr ) {
                return chr.Reason();
            } catch( CMemoryException* pOutOfMemory ) {
                pOutOfMemory->Delete();
                delete pNewBox;
                return E_OUTOFMEMORY;
            }
        }

    } while( S_OK == hrNext );

    return NOERROR;
}


//
// GetLinksInGraph
//
// For each filter see what its pins are connected to.
// I only check output pins. Each link in the graph _Must_ be between an
// input/output pair, so by checking only output pins I get all the links,
// but see no duplicates.
HRESULT CBoxNetDoc::GetLinksInGraph(void) {

    POSITION posBox = m_lstBoxes.GetHeadPosition();
    while (posBox != NULL) {

        CBox *pbox = m_lstBoxes.GetNext(posBox);

        CSocketEnum NextSocket(pbox, CSocketEnum::Output);
        CBoxSocket *psock;
        while (0 != (psock = NextSocket())) {

            CBoxSocket *psockHead = psock->Peer();

            if (psockHead != NULL) {

                CBoxLink *plink = new CBoxLink(psock, psockHead, TRUE);

                m_lstLinks.AddTail(plink);
            }
        }
    }
    return NOERROR;
}

//
// FilterDisplay
//
// Lines the filters across the screen.
HRESULT CBoxNetDoc::FilterDisplay(void) {

    if (m_fAutoArrange) {

        SetBoxesHorizontally();
        SetBoxesVertically();

        RealiseGrid();      // the filters are currently at 1 pixel spacings.
                            // lay them out allowing for their width.
    }

    return NOERROR;
}

//
// SetBoxesVertically
//
void CBoxNetDoc::SetBoxesVertically(void) {

    CList<CBox *, CBox *>   lstPositionedBoxes;

    POSITION posOld = m_lstBoxes.GetHeadPosition();

    while (posOld != NULL) {

        CBox *pbox = m_lstBoxes.GetNext(posOld);

        pbox->CalcRelativeY();

        POSITION    posNew = lstPositionedBoxes.GetTailPosition();
        POSITION    prev = posNew;
        CBox        *pboxPositioned;

        while (posNew != NULL) {

            prev = posNew;  // store posNew, because GetPrev side effects it.

            pboxPositioned = lstPositionedBoxes.GetPrev(posNew);

            if (pboxPositioned->nzX() < pbox->nzX())
                break;

            //cyclic-looking graphs throw this assert
            //ASSERT(pboxPositioned->nzX() == pbox->nzX());

            if (pboxPositioned->RelativeY() <= pbox->RelativeY())
                break;

            pboxPositioned->Y(pboxPositioned->Y() + 1);
        }

        if (prev == NULL) { // we fell of the head of the list
            pbox->Y(0);
            lstPositionedBoxes.AddHead(pbox);
        }
        else if (pboxPositioned->X() < pbox->X()) {
            pbox->Y(0);
            lstPositionedBoxes.InsertAfter(prev, pbox);
        }
        else {
            pbox->Y(pboxPositioned->Y() + 1);
            lstPositionedBoxes.InsertAfter(prev, pbox);
        }
    }

    m_lstBoxes.RemoveAll();
    m_lstBoxes.AddHead(&lstPositionedBoxes);

}

//
// SetBoxesHorizontally
//
void CBoxNetDoc::SetBoxesHorizontally(void) {

    CList<CBox *, CBox *> lstXPositionedBoxes;

    POSITION    pos = m_lstBoxes.GetHeadPosition();
    while (pos != NULL) {

        CBox *pbox = (CBox *) m_lstBoxes.GetNext(pos);

        pbox->Location(CPoint(0,0));                        // a box starts at the origin

        CSocketEnum NextInput(pbox, CSocketEnum::Input);    // input pin enumerator

        CBoxSocket  *psock;
        int     iX = 0;             // the point this box will be placed at
        int     iXClosestPeer = -1; // the closest box to an input pin on this box
                        //  #a# --------]
                        //              +---#c#
                        //       #b# ---]
                        // ie b is closest peer to c

        while (0 != (psock = NextInput())) {

            if (psock->IsConnected()) { // find out what to.

                CBoxSocket *pPeer = psock->Peer();
                if ( pPeer) {
                    if ( pPeer->pBox()->nzX() > iXClosestPeer ) {
                        iXClosestPeer = pPeer->pBox()->nzX();
                    }
                }
            }
        }

        iX = iXClosestPeer + 1;
        pbox->nzX(iX);

        // insert pbox into the correct place on the sorted list.
        POSITION    posSorted = lstXPositionedBoxes.GetHeadPosition();
        POSITION    prev = posSorted;
        BOOL        fInserted = FALSE;

        while (posSorted != NULL) 
        {
            prev = posSorted;
            CBox *pboxSorted = lstXPositionedBoxes.GetNext(posSorted);

            if (pboxSorted->nzX() >= pbox->nzX()) { // this is where we want to put it
                lstXPositionedBoxes.InsertAfter(prev, pbox);
                fInserted = TRUE;
                break;
            }
        }
        if ((posSorted == NULL) && !fInserted) {    // we fell off the end without adding
            lstXPositionedBoxes.AddTail(pbox);
        }
    }

    m_lstBoxes.RemoveAll();
    m_lstBoxes.AddHead(&lstXPositionedBoxes);
}


//
// RealiseGrid
//
// pre: m_lstBoxes is sorted by X(), then Y() of each box.
//  The boxes are laid out on a grid at 1 pixel intervals
//  The origin is at 0,0 and no positions are negative
//
// post:    m_lstBoxes are laid out so that there are
//      gaps between each box and sufficient room allowed
//      for the biggest box on screen.
//
// Lines up the columns neatly, but not rows. this would require
// another pass over the list.
void CBoxNetDoc::RealiseGrid(void) {

    int iColumnX = 0;   // the left edge of this column
    int iColumnY = 0;   // the top edge of the next box to be placed in
                        // this column.
    int iNextColumnX = 0;   // the left edge of the next column.
    int iCurrentColumn = 0;
    const int iColumnGap = 30;
    const int iRowGap = 15;

    POSITION pos = m_lstBoxes.GetHeadPosition();

    while (pos != NULL) {

        CBox *pbox = m_lstBoxes.GetNext(pos);

        if (iCurrentColumn < pbox->nzX()) {   // we've got to the next column
            iColumnY = 0;
            iColumnX = iNextColumnX;
        }

        iCurrentColumn = pbox->nzX();

        //
        // Make sure that the document doesn't exceed the document size.
        // This case will be VERY, VERY rare and thus we don't do any fancy
        // layout, but just pile them on top of each other at the end of
        // the document.
        //
        if ((iColumnX + pbox->Width()) > MAX_DOCUMENT_SIZE ) {
            iColumnX = MAX_DOCUMENT_SIZE - pbox->Width();
        }

        if ((iColumnY + pbox->Height()) > MAX_DOCUMENT_SIZE ) {
            iColumnY = MAX_DOCUMENT_SIZE - pbox->Height();
        }

        // Set the REAL X,Y coordinates (not column indices)
        pbox->X(iColumnX);
        pbox->Y(iColumnY);

        iNextColumnX = max(iNextColumnX, pbox->X() + pbox->Width() + iColumnGap);
        iColumnY += pbox->Height() + iRowGap;
    }
}


//
// UpdateFilters
//
// A quartz operation has just changed the filters in the graph, such that the display
// may not reflect the filters in the graph. May occur, for example, after intelligent
// connect.
// Refreshes the box & link lists and repaints the doc.
HRESULT CBoxNetDoc::UpdateFilters(void)
{
    IGraphConfigCallback* pUpdateFiltersCallback = CUpdateFiltersCallback::CreateInstance();
    if( NULL == pUpdateFiltersCallback ) {
        return E_FAIL;
    }

    HRESULT hr = IfPossiblePreventStateChangesWhileOperationExecutes( IGraph(), pUpdateFiltersCallback, (void*)this );

    pUpdateFiltersCallback->Release();

    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}

void CBoxNetDoc::UpdateFiltersInternal(void) {

    BeginWaitCursor();

    GetFiltersInGraph();
    GetLinksInGraph();
    FilterDisplay();

    ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_ALL, NULL);

    EndWaitCursor();
}


//
// OnUpdateQuartzRender
//
void CBoxNetDoc::OnUpdateQuartzRender(CCmdUI* pCmdUI) {

    pCmdUI->Enable(CCmdRender::CanDo(this));
}


//
// OnQuartzRender
//
// Attempt to render the pin the user just clicked on.
void CBoxNetDoc::OnQuartzRender() {

    CmdDo(new CCmdRender());

}


//
// OnWindowRefresh
//
// Lay out the filter graph for the user.
void CBoxNetDoc::OnWindowRefresh() {

    UpdateFilters();
}


//
// OnUpdateQuartzRun
//
// Updates the 'Play' menu position
void CBoxNetDoc::OnUpdateQuartzRun(CCmdUI* pCmdUI) {

    if (  (m_State == Paused) || (m_State == Unknown)
        ||(m_State == Stopped)) {
        pCmdUI->Enable(TRUE);
    }
    else {
        pCmdUI->Enable(FALSE);
    }
}


void CBoxNetDoc::OnUpdateQuartzPause(CCmdUI* pCmdUI)
{
    if (  (m_State == Playing) || (m_State == Unknown)
        ||(m_State == Stopped)) {
    pCmdUI->Enable(TRUE);
    }
    else {
        pCmdUI->Enable(FALSE);
    }

}

void CBoxNetDoc::OnUpdateQuartzStop(CCmdUI* pCmdUI)
{
    if (  (m_State == Playing) || (m_State == Unknown)
        ||(m_State == Paused)) {
        pCmdUI->Enable(TRUE);
    }
    else {
        pCmdUI->Enable(FALSE);
    }

}


//
// stop the graph, but don't rewind visibly as there has been either
// an error (in which case we shouldn't mess with the graph) or the
// window has been closed.
void CBoxNetDoc::OnQuartzAbortStop()
{
    try {

        HRESULT hr;
        CQCOMInt<IMediaControl> IMC(IID_IMediaControl, IGraph());


        hr = IMC->Stop();
        if (FAILED(hr)) {
            DisplayQuartzError( IDS_CANTSTOP, hr );
            TRACE("Stop failed hr = %x\n", hr);
        }

        m_State = Stopped;

        IMediaPosition* pMP;
        hr = IMC->QueryInterface(IID_IMediaPosition, (void**)&pMP);
        if (SUCCEEDED(hr)) {
            pMP->put_CurrentPosition(0);
            pMP->Release();
        }


    }
    catch (CHRESULTException hre) {
        DisplayQuartzError( IDS_CANTSTOP, hre.Reason() );
    }

    return;

}

// Graphedt does not have any notion of seeking so when we stop we do the
// intuitive thing to reset the current position back to the start of the
// stream. If play is to continue from the current position then the user
// can press Pause (and Run). To process the Stop we first Pause then set
// the new start position (while paused) and finally Stop the whole graph

void CBoxNetDoc::OnQuartzStop()
{
    try {

        HRESULT hr;
        CQCOMInt<IMediaControl> IMC(IID_IMediaControl, IGraph());

        hr = IMC->Pause();

        if (SUCCEEDED(hr)) {
            // Reset our position to the start again

            IMediaPosition* pMP;
            hr = IMC->QueryInterface(IID_IMediaPosition, (void**)&pMP);
            if (SUCCEEDED(hr)) {
                pMP->put_CurrentPosition(0);
                pMP->Release();
            }

            // Wait for the Pause to complete. If it does not complete within the
            // specified time we ask the user if (s)he wants to wait a little longer
            // or attempt to stop anyway.
            for(;;){
                const int iTimeout = 10 * 1000;
                OAFilterState state;

                hr = IMC->GetState(iTimeout, &state);
                if( hr == S_OK || hr == VFW_S_CANT_CUE )
                    break;

                if( IDCANCEL == AfxMessageBox( IDS_PAUSE_TIMEOUT, MB_RETRYCANCEL | MB_ICONSTOP ) )
                    break;
            }
        } else
            DisplayQuartzError( IDS_CANTPAUSE, hr );

        // And finally stop the graph

        hr = IMC->Stop();
        if (FAILED(hr)) {
            DisplayQuartzError( IDS_CANTSTOP, hr );
            TRACE("Stop failed hr = %x\n", hr);
            OAFilterState state;
            IMC->GetState(0, &state);
            switch (state) {
            case State_Stopped:
                m_State = Stopped;
                break;
            case State_Paused:
                m_State = Paused;
                break;
            case State_Running:
                m_State = Playing;
                break;
            }
        } else
            m_State = Stopped;
    }
    catch (CHRESULTException hre) {
        DisplayQuartzError( IDS_CANTSTOP, hre.Reason() );
    }

    return;

}
//
// GetSize
//
// Use the co-ordinates of the boxes to decide the document
// size needed to lay out this graph.
CSize CBoxNetDoc::GetSize(void) {

    CSize DocSize(0,0);
    POSITION pos;

    pos = m_lstBoxes.GetHeadPosition();

    // Scan the list for the extreme edges.
    while (pos != NULL) {

        CRect rect = m_lstBoxes.GetNext(pos)->GetRect();
        if (rect.right > DocSize.cx) {
            DocSize.cx = rect.right;
        }
        if (rect.bottom > DocSize.cy) {
            DocSize.cy = rect.bottom;
        }
    }

    return DocSize;
}


//
// NotificationThread
//
// This thread just blocks and waits for the event handle from
// IMediaEvent and waits for any events.
//
// There is a second event handle which will be signal as soon as this
// thread should exit.
//
DWORD WINAPI CBoxNetDoc::NotificationThread(LPVOID lpData)
{
    CoInitialize(NULL);

    //  Open a scope to make sure pMediaEvent is released before we call
    //  CoUninitialize
    {
        CBoxNetDoc * pThis = (CBoxNetDoc *) lpData;

        IMediaEvent * pMediaEvent;

        //  Unmarshal our interface
        if (pThis->m_pMarshalStream) {
            CoGetInterfaceAndReleaseStream(
                pThis->m_pMarshalStream, IID_IMediaEvent, (void **)&pMediaEvent);
            pThis->m_pMarshalStream = NULL;
        } else {
            pMediaEvent = pThis->IEvent();
            pMediaEvent->AddRef();
        }

        BOOL fExitOk = FALSE;

        while (!fExitOk) {
            DWORD dwReturn;
            dwReturn = WaitForMultipleObjects(3, pThis->m_phThreadData, FALSE, INFINITE);

            switch (dwReturn) {

            case WAIT_OBJECT_0:
                {
//                    TRACE("Event signaled to Thread\n");

                    //
                    // Get the event now and post a message to our window proc
                    // which will deal with the event. Use post message to
                    // avoid a dead lock once the main thread has decided to
                    // close us down and waits for us to exit.
                    //

                    NetDocUserMessage * pEventParams = new NetDocUserMessage;
                    if (!pEventParams) {
                        // no more memory - let others deal with it.
                        break;
                    }

                    // Must have an IEvent - otherwise signalling of this message
                    // would have been impossible.
                    HRESULT hr;
                    hr = pMediaEvent->GetEvent(&pEventParams->lEventCode, &pEventParams->lParam1, &pEventParams->lParam2, 0);

                    if (FAILED(hr)) {
                        delete pEventParams;
                        break;
                    }

                    BOOL fSuccess = FALSE;
                    if (pThis->m_hWndPostMessage && IsWindow(pThis->m_hWndPostMessage)) {
                        fSuccess =
                            ::PostMessage(pThis->m_hWndPostMessage, WM_USER_EC_EVENT, 0, (LPARAM) pEventParams);
                    }

                    if (!fSuccess) {
                        // should call this function, so that filter graph manager can cleanup
                        pMediaEvent->FreeEventParams(pEventParams->lEventCode, pEventParams->lParam1, pEventParams->lParam2);
                        delete pEventParams;
                    }

                }

                break;

            case (WAIT_OBJECT_0 + 1):
                fExitOk = TRUE;
                break;

            case (WAIT_OBJECT_0 + 2):
            pThis->m_fRegistryChanged = TRUE;

            // reset the registry notification
            RegNotifyChangeKeyValue(HKEY_CLASSES_ROOT, TRUE,
                                        REG_NOTIFY_CHANGE_LAST_SET,
                                        pThis->m_phThreadData[2], TRUE);

            break;

            case (WAIT_FAILED):
                // one of our objects has gone - no need to hang around further
                fExitOk = TRUE;
                break;

            default:
                ASSERT(!"Unexpected return value");
            }
        }
        pMediaEvent->Release();

    }

    CoUninitialize();

    return(0);
}

//
// OnWM_USER
//
void CBoxNetDoc::OnWM_USER(NetDocUserMessage * lParam)
{
    switch (lParam->lEventCode) {
#ifdef DEVICE_REMOVAL
      case EC_DEVICE_LOST:
      {
          IUnknown *punk = (IUnknown *)lParam->lParam1;
          IBaseFilter *pf;
          HRESULT hr = punk->QueryInterface(IID_IBaseFilter, (void **)&pf);
          ASSERT(hr == S_OK);
          FILTER_INFO fi;
          hr = pf->QueryFilterInfo(&fi);
          pf->Release();
          ASSERT(hr == S_OK);
          if(fi.pGraph) {
              fi.pGraph->Release();
          }

          TCHAR szTmp[100];
          wsprintf(szTmp, "device %ls %s.", fi.achName, lParam->lParam2 ?
                   TEXT("arrived") : TEXT("removed"));
          MessageBox(0, szTmp, TEXT("device removal  notification"), 0);
      }
          break;
#endif

    case EC_ERRORABORT:
    DisplayQuartzError( (UINT) IDS_EC_ERROR_ABORT, (HRESULT) lParam->lParam1 );
        /* fall through */

    case EC_USERABORT:
        // stop without the rewind or we will re-show the window
        OnQuartzAbortStop();
        // post dummy message to update the UI (mfc needs this help)
        ::PostMessage( m_hWndPostMessage, WM_NULL, 0, 0);
        break;

    case EC_COMPLETE:
        OnQuartzStop();
        // post dummy message to update the UI (mfc needs this help)
        ::PostMessage( m_hWndPostMessage, WM_NULL, 0, 0);
        break;

    case EC_ERROR_STILLPLAYING:
        {
            int iChoice = AfxMessageBox(IDS_IS_GRAPH_PLAYING, MB_YESNO);
            if (iChoice == IDNO) {
                OnQuartzAbortStop();
            }
        }
        break;

    case EC_CLOCK_CHANGED:
        UpdateClockSelection();
        break;

    case EC_GRAPH_CHANGED:
        UpdateFilters();
        SetModifiedFlag(FALSE);
        break;

    default:
        break;
    }
    // should call this function, so that filter graph manager can cleanup
    IEvent()->FreeEventParams(lParam->lEventCode, lParam->lParam1, lParam->lParam2);
    delete lParam;
}


//
// OnUpdateUseClock
//
void CBoxNetDoc::OnUpdateUseClock(CCmdUI* pCmdUI)  {

    pCmdUI->SetCheck(m_fUsingClock);

}

//
// OnUseClock
//
// if we are using the clock, set no clock.
// if we are not using a clock ask for the default
void CBoxNetDoc::OnUseClock() {

    try {

        CQCOMInt<IMediaFilter> IMF(IID_IMediaFilter, IGraph());

        if (m_fUsingClock) {
            // we don't want to use the clock anymore

            HRESULT hr;

            hr = IMF->SetSyncSource(NULL);
            if (FAILED(hr)) {
                DisplayQuartzError( IDS_CANTSETCLOCK, hr );
                TRACE("SetSyncSource(NULL) failed hr = %x\n", hr);
                return;
            }
        }
        else {
            HRESULT hr = IGraph()->SetDefaultSyncSource();

            if (FAILED(hr)) {
                DisplayQuartzError( IDS_CANTSETCLOCK, hr );
                TRACE("SetDefaultSyncSource failed hr = %x\n", hr);
                return;
            }
        }

        // m_fUsing clock will be updated on the EC_CLOCK_CHANGED notification
    }
    catch (CHRESULTException) {
        // just catch it...
    }
}


//
// OnUpdateConnectSmart
//
void CBoxNetDoc::OnUpdateConnectSmart(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_fConnectSmart);
}

//
// OnConnectSmart
//
// Only need to invert the flag. All the magic is done elsewhere.
//
void CBoxNetDoc::OnConnectSmart()
{
    m_fConnectSmart = !m_fConnectSmart;
}

//
// OnUpdateConnectSmart
//
void CBoxNetDoc::OnUpdateAutoArrange(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_fAutoArrange);
}

//
// OnAutoArrange
//
// Toggle automatic graph re-arrangement.
void CBoxNetDoc::OnAutoArrange() {

    m_fAutoArrange = !m_fAutoArrange;
}

//
// OnFileRender
//
void CBoxNetDoc::OnFileRender()
{
    char szNameOfFile[MAX_PATH];
    szNameOfFile[0] = 0;

    OPENFILENAME ofn;

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize   = sizeof(OPENFILENAME);
    ofn.hwndOwner     = AfxGetMainWnd()->GetSafeHwnd();

    TCHAR tszMediaFileMask[201];
    int iSize = ::LoadString(AfxGetInstanceHandle(), IDS_MEDIA_FILES, tszMediaFileMask, 198);
    ASSERT(iSize);
    // Load String has problems with the 2nd \0 at the end
    tszMediaFileMask[iSize] = 0;
    tszMediaFileMask[iSize + 1] = 0;
    tszMediaFileMask[iSize + 2] = 0;

    ofn.lpstrFilter   = tszMediaFileMask;

    ofn.nFilterIndex  = 1;
    ofn.lpstrFile     = szNameOfFile;
    ofn.nMaxFile      = MAX_PATH;
    ofn.lpstrTitle    = TEXT("Select a file to be rendered.");
    ofn.Flags         = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    // get users selection
    if (!GetOpenFileName(&ofn)) {
        // no file selected - continue
        return;
    }

    WCHAR szwName[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, szNameOfFile, -1, szwName, MAX_PATH);

    CmdDo( new CCmdRenderFile(szwName) );

    SetModifiedFlag();
}

//
// OnURLRender
//
void CBoxNetDoc::OnURLRender()
{
    char szNameOfFile[INTERNET_MAX_URL_LENGTH];
    CRenderURL dlgRenderURL(szNameOfFile, INTERNET_MAX_URL_LENGTH, AfxGetMainWnd());

    if (dlgRenderURL.DoModal() != IDOK)
        return;

    WCHAR szwName[INTERNET_MAX_URL_LENGTH];
    MultiByteToWideChar(CP_ACP, 0, szNameOfFile, -1, szwName, INTERNET_MAX_URL_LENGTH);

    CmdDo( new CCmdRenderFile(szwName) );

    SetModifiedFlag();
}

//
// OnUpdateFileRender
//
void CBoxNetDoc::OnUpdateFileRender(CCmdUI *pCmdUI)
{
    pCmdUI->Enable(m_State == Stopped);
}

//
// OnUpdateURLRender
//
void CBoxNetDoc::OnUpdateURLRender(CCmdUI *pCmdUI)
{
    pCmdUI->Enable(m_State == Stopped);
}

void CBoxNetDoc::OnUpdateFileSave(CCmdUI *pCmdUI)
{
    pCmdUI->Enable( !m_bNewFilenameRequired );
}


//
// SetSelectClock
//
// Sets the Graphs clock to the one found in pBox and removes the dialog
// box if we succeeded.
//
void CBoxNetDoc::SetSelectClock(CBox *pBox)
{
    if (!pBox->HasClock()) {
        AfxMessageBox(IDS_NO_REFCLOCK);
        return;
    }

    try {
        CQCOMInt<IMediaFilter> pMF(IID_IMediaFilter, IGraph());
        CQCOMInt<IReferenceClock> pRC(IID_IReferenceClock, pBox->pIFilter());

        HRESULT hr = pMF->SetSyncSource(pRC);
        if (FAILED(hr)) {
            throw CE_FAIL();
        }

    }
    catch (CHRESULTException hre) {
        DisplayQuartzError( IDS_FAILED_SETSYNC, hre.Reason() );
    }
}


//
// UpdateClockSelection
//
// Sets the CBox::m_fClockSelected flag of the filter that provides the
// current clock to true.
//
void CBoxNetDoc::UpdateClockSelection()
{
    // Get current clock
    CQCOMInt<IMediaFilter> pMF(IID_IMediaFilter, IGraph());

    IReferenceClock * pRefClock;

    if (FAILED(pMF->GetSyncSource(&pRefClock))) {
        pRefClock = NULL;
    }

    m_fUsingClock = (pRefClock != NULL);

    // iterate through all boxes (filters) in the graph
    POSITION pos = m_lstBoxes.GetHeadPosition();
    while (pos) {
        CBox *pbox = m_lstBoxes.GetNext(pos);

        pbox->m_fClockSelected = FALSE;

        if (pbox->HasClock()) {
            try {
                // pbox has a IReferenceClock interface
                CQCOMInt<IReferenceClock> pRC(IID_IReferenceClock, pbox->pIFilter());

                ASSERT(pRC);

                pbox->m_fClockSelected = ((IReferenceClock *) pRC == pRefClock);
            }
            catch (CHRESULTException) {
                // failed to get IReferenceClock
                ASSERT(!pbox->m_fClockSelected);
            }
        }
    }

    if (pRefClock) {
        pRefClock->Release();
    }

    //
    // Redraw the whole filter graph.
    //
    UpdateAllViews(NULL, HINT_DRAW_ALL);
}

#pragma warning(disable:4514)

void CBoxNetDoc::OnGraphAddFilterToCache()
{
    CCmdAddFilterToCache* pCmdAddFilterToCache;

    try
    {
        pCmdAddFilterToCache = new CCmdAddFilterToCache;
    }
    catch( CMemoryException* peOutOfMemory )
    {
        DisplayQuartzError( E_OUTOFMEMORY );
        peOutOfMemory->Delete();
        return;
    }

    CmdDo( pCmdAddFilterToCache );
}

void CBoxNetDoc::OnUpdateGraphAddFilterToCache(CCmdUI* pCmdUI)
{
    pCmdUI->Enable( CCmdAddFilterToCache::CanDo( this ) );
}

void CBoxNetDoc::OnGraphEnumCachedFilters()
{
    HRESULT hr = SafeEnumCachedFilters();
    if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
    }
}

void CBoxNetDoc::OnGraphEnumCachedFiltersInternal()
{
    IGraphConfig* pGraphConfig;

    HRESULT hr = IGraph()->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
        return;
    }

    hr = S_OK;
    CDisplayCachedFilters dlgCurrentCachedFilters( pGraphConfig, &hr );
    if( FAILED( hr ) )
    {
        pGraphConfig->Release();
        DisplayQuartzError( hr );
        return;
    }

    INT_PTR nReturnValue = dlgCurrentCachedFilters.DoModal();

    // Handle the return value from DoModal
    switch( nReturnValue )
    {
    case -1:
        // CDialog::DoModal() returns -1 if it cannot create the dialog box.
        AfxMessageBox( IDS_CANT_CREATE_DIALOG );
        break;

    case IDABORT:
        // An error occured while the dialog box was being displayed.
        // CDisplayCachedFilters handles all internal errors.
        break;

    case IDOK:
        // No error occured.  The user finished looking at the dialog box.
        break;

    default:
        // This code should never be executed.
        ASSERT( false );
        break;
    }

    pGraphConfig->Release();
}

void CBoxNetDoc::OnViewSeekBar()
{
   POSITION pos = GetFirstViewPosition();
   while (pos != NULL)
   {
      CBoxNetView * pView = (CBoxNetView*) GetNextView(pos);
      pView->ShowSeekBar( );
   }
}

void CBoxNetDoc::OnUpdateReconnect( CCmdUI* pCmdUI )
{
    pCmdUI->Enable( CCmdReconnect::CanDo(this) );
}

void CBoxNetDoc::OnReconnect( void )
{
    CCmdReconnect* pCmdReconnect;

    try
    {
        pCmdReconnect = new CCmdReconnect;
    }
    catch( CMemoryException* peOutOfMemory )
    {
        DisplayQuartzError( E_OUTOFMEMORY );
        peOutOfMemory->Delete();
        return;
    }

    CmdDo( pCmdReconnect );
}

HRESULT CBoxNetDoc::StartReconnect( IGraphBuilder* pFilterGraph, IPin* pOutputPin )
{
    if( AsyncReconnectInProgress() ) {
        return E_FAIL;
    }

    CComPtr<IPinFlowControl> pDynamicOutputPin;

    HRESULT hr = pOutputPin->QueryInterface( IID_IPinFlowControl, (void**)&pDynamicOutputPin );
    if( FAILED( hr ) ) {
        return hr;
    }

    SECURITY_ATTRIBUTES* DEFAULT_SECURITY_ATTRIBUTES = NULL;
    const BOOL AUTOMATIC_RESET = FALSE;
    const BOOL INITIALLY_UNSIGNALED = FALSE;
    const LPCTSTR UNNAMED_EVENT = NULL;

    HANDLE hBlockEvent = ::CreateEvent( DEFAULT_SECURITY_ATTRIBUTES, AUTOMATIC_RESET, INITIALLY_UNSIGNALED, UNNAMED_EVENT );
    if( NULL == hBlockEvent ) {
        DWORD dwLastWin32Error = ::GetLastError();
        return AmHresultFromWin32( dwLastWin32Error );
    }

    hr = pDynamicOutputPin->Block( AM_PIN_FLOW_CONTROL_BLOCK, hBlockEvent );
    if( FAILED( hr ) ) {
        // This call should not fail because we have access to hBlockEvent and hBlockEvent is a valid event.
        EXECUTE_ASSERT( ::CloseHandle( hBlockEvent ) );

        return hr;
    }

    const DWORD PIN_BLOCKED = WAIT_OBJECT_0;

    // There are 200 milliseconds in one fifth of a second.
    const DWORD ONE_FIFTH_OF_A_SECOND = 200;

    DWORD dwReturnValue = ::WaitForSingleObject( hBlockEvent, ONE_FIFTH_OF_A_SECOND );

    if( WAIT_TIMEOUT != dwReturnValue ) {
        if( PIN_BLOCKED != dwReturnValue ) {
            // Block() should not fail because we are unblocking the pin and
            // we are passing in valid arguments.
            EXECUTE_ASSERT( SUCCEEDED( pDynamicOutputPin->Block(0, NULL) ) );
        }

        // This call should not fail because we have access to hBlockEvent
        // and hBlockEvent is a valid event.
        EXECUTE_ASSERT( ::CloseHandle( hBlockEvent ) );
    }

    switch( dwReturnValue ) {
    case PIN_BLOCKED:
        // EndReconnect() always unblocks the output pin.
        hr = EndReconnect( pFilterGraph, pDynamicOutputPin );
        if( FAILED( hr ) ) {
            return hr;
        }

        return S_OK;

    case WAIT_TIMEOUT:
        {
            const TIMERPROC NO_TIMER_PROCEDURE = NULL;

            // SetTimer() returns 0 if an error occurs.
            if( 0 == ::SetTimer( m_hWndPostMessage, CBoxNetView::TIMER_PENDING_RECONNECT, ONE_FIFTH_OF_A_SECOND, NO_TIMER_PROCEDURE ) ) {
                // Block() should not fail because we are unblocking the pin and
                // we are passing in valid arguments.
                EXECUTE_ASSERT( SUCCEEDED( pDynamicOutputPin->Block(0, NULL) ) );

                // This call should not fail because we have access to hBlockEvent and hBlockEvent is a valid event.
                EXECUTE_ASSERT( ::CloseHandle( hBlockEvent ) );

                DWORD dwLastWin32Error = ::GetLastError();
                return AmHresultFromWin32( dwLastWin32Error );
            }
        }

        m_hPendingReconnectBlockEvent = hBlockEvent;
        m_pPendingReconnectOutputPin = pDynamicOutputPin; // CComPtr::operator=() will automatically addref this pin.
        return GE_S_RECONNECT_PENDING;

    case WAIT_FAILED:
        {
            DWORD dwLastWin32Error = ::GetLastError();
            return AmHresultFromWin32( dwLastWin32Error );
        }

    case WAIT_ABANDONED:
    default:
        DbgBreak( "An Unexpected case occured in CBoxNetDoc::StartReconnect()." );
        return E_UNEXPECTED;
    }
}

HRESULT CBoxNetDoc::EndReconnect( IGraphBuilder* pFilterGraph, IPinFlowControl* pDynamicOutputPin )
{
    HRESULT hr = EndReconnectInternal( pFilterGraph, pDynamicOutputPin );

    // Unblock the output pin.
    HRESULT hrBlock = pDynamicOutputPin->Block( 0, NULL );

    if( FAILED( hr ) ) {
        return hr;
    } else if( FAILED( hrBlock ) ) {
        return hrBlock;
    }

    return S_OK;
}

HRESULT CBoxNetDoc::EndReconnectInternal( IGraphBuilder* pFilterGraph, IPinFlowControl* pDynamicOutputPin )
{
    CComPtr<IGraphConfig> pGraphConfig;

    HRESULT hr = pFilterGraph->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( FAILED( hr ) ) {
        return hr;
    }

    CComPtr<IPin> pOutputPin;

    hr = pDynamicOutputPin->QueryInterface( IID_IPin, (void**)&pOutputPin );
    if( FAILED( hr ) ) {
        return hr;
    }

    hr = pGraphConfig->Reconnect( pOutputPin, NULL, NULL, NULL, NULL, AM_GRAPH_CONFIG_RECONNECT_CACHE_REMOVED_FILTERS );

    UpdateFilters();

    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}

HRESULT CBoxNetDoc::ProcessPendingReconnect( void )
{
    // ::KillTimer() does not remove WM_TIMER messages which have already been posted to a
    // window's message queue.  Therefore, it is possible to receive WM_TIMER messages after
    // the pin has been reconnected.
    if( !AsyncReconnectInProgress() ) {
        return S_FALSE;
    }

    const DWORD DONT_WAIT = 0;
    const DWORD PIN_BLOCKED = WAIT_OBJECT_0;

    DWORD dwReturnValue = ::WaitForSingleObject( m_hPendingReconnectBlockEvent, DONT_WAIT );

    if( (WAIT_TIMEOUT != dwReturnValue) && (PIN_BLOCKED != dwReturnValue) ) {
        ReleaseReconnectResources( ASYNC_RECONNECT_UNBLOCK );
    }

    switch( dwReturnValue ) {
    case WAIT_TIMEOUT:
        return S_FALSE;

    case PIN_BLOCKED:
        {
            HRESULT hr = EndReconnect( IGraph(), m_pPendingReconnectOutputPin );

            ReleaseReconnectResources( ASYNC_RECONNECT_NO_FLAGS );

            if( FAILED( hr ) ) {
                return hr;
            }

            return S_OK;
        }

    case WAIT_FAILED:
        {
            DWORD dwLastWin32Error = ::GetLastError();
            return AmHresultFromWin32( dwLastWin32Error );
        }

    case WAIT_ABANDONED:
    default:
        DbgBreak( "An Unexpected case occured in CBoxNetDoc::ProcessPendingReconnect()." );
        return E_UNEXPECTED;
    }
}

void CBoxNetDoc::ReleaseReconnectResources( ASYNC_RECONNECT_FLAGS arfFlags )
{
    if( !AsyncReconnectInProgress() ) {
        return;
    }

    if( arfFlags & ASYNC_RECONNECT_UNBLOCK ) {
        // Block() should not fail because we are unblocking the pin and
        // we are passing in valid arguments.
        EXECUTE_ASSERT( SUCCEEDED( m_pPendingReconnectOutputPin->Block(0, NULL) ) );
    }

    m_pPendingReconnectOutputPin = NULL; // Release our reference on the output pin.

    // This call should not fail because we have access to hBlockEvent and hBlockEvent is a valid event.
    EXECUTE_ASSERT( ::CloseHandle( m_hPendingReconnectBlockEvent ) );
    m_hPendingReconnectBlockEvent = NULL;

    // Since the timer exists and m_hWndPostMessage is a valid window handle, this function
    // should not fail.
    EXECUTE_ASSERT( ::KillTimer( m_hWndPostMessage, CBoxNetView::TIMER_PENDING_RECONNECT ) );
}

bool CBoxNetDoc::AsyncReconnectInProgress( void ) const
{
    // Make sure the pending reconnect state is consitent.  Either the user is waiting on event
    // m_hPendingReconnectBlockEvent and m_pPendingReconnectOutputPin contains the pin being
    // reconnected or both variables should be unused.
    ASSERT( ( m_pPendingReconnectOutputPin && (NULL != m_hPendingReconnectBlockEvent) ) ||
            ( !m_pPendingReconnectOutputPin && (NULL == m_hPendingReconnectBlockEvent) ) );

    return (m_pPendingReconnectOutputPin && (NULL != m_hPendingReconnectBlockEvent));
}

HRESULT CBoxNetDoc::SafePrintGraphAsHTML( HANDLE hFile )
{
    CPrintGraphAsHTMLCallback::PARAMETERS_FOR_PRINTGRAPHASHTMLINTERNAL sPrintGraphAsHTMLInternalParameters;

    sPrintGraphAsHTMLInternalParameters.pDocument = this;
    sPrintGraphAsHTMLInternalParameters.hFileHandle = hFile;

    IGraphConfigCallback* pPrintGraphAsHTMLCallback = CPrintGraphAsHTMLCallback::CreateInstance();
    if( NULL == pPrintGraphAsHTMLCallback ) {
        return E_FAIL;
    }

    HRESULT hr = IfPossiblePreventStateChangesWhileOperationExecutes( IGraph(), pPrintGraphAsHTMLCallback, (void*)&sPrintGraphAsHTMLInternalParameters );

    pPrintGraphAsHTMLCallback->Release();

    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}

HRESULT CBoxNetDoc::SafeEnumCachedFilters( void )
{
    IGraphConfigCallback* pEnumFilterCacheCallback = CEnumerateFilterCacheCallback::CreateInstance();
    if( NULL == pEnumFilterCacheCallback ) {
        return E_FAIL;
    }

    HRESULT hr = PreventStateChangesWhileOperationExecutes( IGraph(), pEnumFilterCacheCallback, (void*)this );

    pEnumFilterCacheCallback->Release();

    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}


/* Constants used by zooming code */
const int MAX_ZOOM=6;
const int nItemCount=6;
const int nZoomLevel[nItemCount] = {25, 50, 75, 100, 150, 200};
const UINT nZoomItems[nItemCount] = {ID_WINDOW_ZOOM25,  ID_WINDOW_ZOOM50,  ID_WINDOW_ZOOM75,
                               ID_WINDOW_ZOOM100, ID_WINDOW_ZOOM150, ID_WINDOW_ZOOM200 };

void CBoxNetDoc::IncreaseZoom()
{
    if (m_nCurrentSize < MAX_ZOOM-1)
    {
        OnWindowZoom(nZoomLevel[m_nCurrentSize+1], nZoomItems[m_nCurrentSize+1]);
    }
}

void CBoxNetDoc::DecreaseZoom()
{
    if (m_nCurrentSize > 0)
    {
        OnWindowZoom(nZoomLevel[m_nCurrentSize-1], nZoomItems[m_nCurrentSize-1]);
    }
}

void CBoxNetDoc::OnWindowZoom(int iZoom, UINT iMenuItem)
{
    // Get main window handle
    CWnd* pMain = AfxGetMainWnd();

    if (pMain != NULL)
    {
        // Get the main window's menu
        CMenu* pMainMenu = pMain->GetMenu();

        // Get the handle of the "View" menu
        CMenu *pMenu = pMainMenu->GetSubMenu(2);        

        // Update the zoom check marks.  Check the selection and uncheck all others.
        if (pMenu != NULL)
        {
            // Set/clear checkboxes that indicate the zoom ratio
            for (int i=0; i<nItemCount; i++)
            {
                if (iMenuItem == nZoomItems[i])
                {
                    pMenu->CheckMenuItem(iMenuItem, MF_CHECKED | MF_BYCOMMAND);
                    m_nCurrentSize = i;
                }
                else
                    pMenu->CheckMenuItem(nZoomItems[i], MF_UNCHECKED | MF_BYCOMMAND);
            }
        }   
    }

    // Zoom to the requested ratio
    CBox::SetZoom(iZoom);
    OnWindowRefresh();    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\boxdraw.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// boxdraw.cpp : defines CBoxDraw
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// Global (shared) CBoxDraw object

CBoxDraw * gpboxdraw;


/////////////////////////////////////////////////////////////////////////////
// CBoxDraw constants


// background color of boxes and container
const COLORREF  CBoxDraw::m_crBkgnd(RGB(192, 192, 192));

// margins (left/right, top/bottom) around box labels and box tab labels
const CSize     CBoxDraw::m_sizLabelMargins(2, 0);

// hit test: "close enough" if this many pixels away
const int       CBoxDraw::m_iHotZone(3);

// box tab labels: font face, height (pixels) for box labels and box tab labels
const CString   CBoxDraw::m_stBoxFontFace("Arial");
const int       CBoxDraw::m_iBoxLabelHeight(16);
const int       CBoxDraw::m_iBoxTabLabelHeight(14);

// color of unhighlighted links and highlighted links
const COLORREF  CBoxDraw::m_crLinkNoHilite(RGB(0, 0, 0));
const COLORREF  CBoxDraw::m_crLinkHilite(RGB(0, 0, 255));

// radius of circle used to highlight bends
const int       CBoxDraw::m_iHiliteBendsRadius(3);



/////////////////////////////////////////////////////////////////////////////
// CBoxDraw construction and destruction


CBoxDraw::CBoxDraw() {
}


/* Init()
 *
 * Initialize the object.  May throw an exception, so don't call from
 * a constructor.
 */
void CBoxDraw::Init()
{
    // load composite bitmaps
    if (!m_abmEdges[FALSE].LoadBitmap(IDB_EDGES) ||
        !m_abmEdges[TRUE].LoadBitmap(IDB_EDGES_HILITE) ||
        !m_abmTabs[FALSE].LoadBitmap(IDB_TABS) ||
        !m_abmTabs[TRUE].LoadBitmap(IDB_TABS_HILITE) ||
        !m_abmClocks[FALSE].LoadBitmap(IDB_CLOCK) ||
        !m_abmClocks[TRUE].LoadBitmap(IDB_CLOCK_SELECT))
            AfxThrowResourceException();

    // get the size of each bitmap (just look at the unhighlighted versions
    // since unhighlighted and highlighted versions are the same size)
    // and compute the size of a single "tile" within the composite bitmap
    BITMAP bm;
    m_abmEdges[FALSE].GetObject(sizeof(bm), &bm);
    m_sizEdgesTile.cx = bm.bmWidth / 3;
    m_sizEdgesTile.cy = bm.bmHeight / 3;
    m_abmTabs[FALSE].GetObject(sizeof(bm), &bm);
    m_sizTabsTile.cx = bm.bmWidth / 3;
    m_sizTabsTile.cy = bm.bmHeight / 3;
    m_abmClocks[FALSE].GetObject(sizeof(bm), &bm);
    m_sizClock.cx = bm.bmWidth;
    m_sizClock.cy = bm.bmHeight;

    // create the brushes and pens for drawing links
    m_abrLink[FALSE].CreateSolidBrush(m_crLinkNoHilite);
    m_abrLink[TRUE].CreateSolidBrush(m_crLinkHilite);
    m_apenLink[FALSE].CreatePen(PS_SOLID, 1, m_crLinkNoHilite);
    m_apenLink[TRUE].CreatePen(PS_SOLID, 1, m_crLinkHilite);

    RecreateFonts();
}

void CBoxDraw::RecreateFonts()
{
    // create the font for box labels
    if (!m_fontBoxLabel.CreateFont(m_iBoxLabelHeight * CBox::s_Zoom / 100, 0, 0, 0, FW_NORMAL,
            FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_TT_PRECIS,
            CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FF_SWISS, m_stBoxFontFace))
        AfxThrowResourceException();

    // create the font for tab labels
    if (!m_fontTabLabel.CreateFont(m_iBoxTabLabelHeight * CBox::s_Zoom / 100, 0, 0, 0, FW_NORMAL,
            FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_TT_PRECIS,
            CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FF_SWISS, m_stBoxFontFace))
        AfxThrowResourceException();
}

/* Exit()
 *
 * Free the resources held by the object.
 */
void CBoxDraw::Exit() {

}



/////////////////////////////////////////////////////////////////////////////
// box drawing


/* GetOrInvalBoundRect(pbox, prc, [fLinks], [pwnd])
 *
 * Set <*prc> to be a bounding rectangle around <pbox>.  If <fLinks> is TRUE
 * then include the bounding rectangles of the links to/from <pbox>.
 *
 * If <pwnd> is not NULL, then invalidate the area covering <pbox> (and the
 * links to/from <pbox>, if <fLinks> is TRUE).  This is usually more efficient
 * than invalidating all of <pwnd>, for links that have at least one bend.
 */
void CBoxDraw::GetOrInvalBoundRect(CBox *pbox, CRect *prc, BOOL fLinks,
    CScrollView *pScroll)
{
    CRect               rc;

    // get the bounding rect of <pbox>; invalidate if requested
    *prc = pbox->GetRect();
    if (pScroll != NULL)
        pScroll->InvalidateRect(&(*prc - pScroll->GetScrollPosition()), TRUE);

    if (fLinks)
    {
        // include the bounding rect of each link; invalidate if requested
	CSocketEnum Next(pbox);
	CBoxSocket *psock;

	while (0 != (psock = Next()))
	{
            if (psock->m_plink != NULL)
            {
                // socket is connected via a link
                GetOrInvalLinkRect(psock->m_plink, &rc, pScroll);
                prc->UnionRect(prc, &rc);
            }
        }
    }
}


/* DrawCompositeFrame(hdcDst, xDst, yDst, cxDst, cyDst,
 *  hdcSrc, cxTile, cyTile, fMiddle)
 *
 * Draw a <cxDst> by <cyDst> pixel "frame" (as specified below) at (xDst,yDst)
 * in <hdcDst>.
 *
 * Assume <hdcSrc> is a DC onto a bitmap that contains a 3x3 grid of "tiles"
 * that each is <cxTile> pixels wide and <cyTile> pixels high.  The corner
 * tiles contain images of the corners.  The center top, bottom, left, and
 * right tiles contain images that are stretched to compose the corresponding
 * sides of the frame.
 *
 * If <fMiddle> is TRUE then the middle tile is stretched to fill the middle
 * of the frame, otherwise the middle of the frame is left undrawn.
 */
void NEAR PASCAL
DrawCompositeFrame(HDC hdcDst, int xDst, int yDst, int cxDst, int cyDst,
    HDC hdcSrc, int cxTile, int cyTile, BOOL fMiddle)
{
    // draw upper-left, upper-right, lower-left, lower-right corners
    BitBlt(hdcDst, xDst + 0, yDst + 0,
        cxTile, cyTile,
        hdcSrc, cxTile * 0, cyTile * 0, SRCCOPY);
    BitBlt(hdcDst, xDst + cxDst - cxTile, yDst + 0,
        cxTile, cyTile,
        hdcSrc, cxTile * 2, cyTile * 0, SRCCOPY);
    BitBlt(hdcDst, xDst + 0, yDst + cyDst - cyTile,
        cxTile, cyTile,
        hdcSrc, cxTile * 0, cyTile * 2, SRCCOPY);
    BitBlt(hdcDst, xDst + cxDst - cxTile, yDst + cyDst - cyTile,
        cxTile, cyTile,
        hdcSrc, cxTile * 2, cyTile * 2, SRCCOPY);

    // draw left, right, top, and bottom edges
    SetStretchBltMode(hdcDst, COLORONCOLOR);
    StretchBlt(hdcDst, xDst + 0, yDst + cyTile * 1,
        cxTile, cyDst - cyTile - cyTile,
        hdcSrc, cxTile * 0, cyTile * 1,
        cxTile, cyTile, SRCCOPY);
    StretchBlt(hdcDst, xDst + cxDst - cxTile, yDst + cyTile * 1,
        cxTile, cyDst - cyTile - cyTile,
        hdcSrc, cxTile * 2, cyTile * 1,
        cxTile, cyTile, SRCCOPY);
    StretchBlt(hdcDst, xDst + cxTile * 1, yDst + 0,
        cxDst - cxTile - cxTile, cyTile,
        hdcSrc, cxTile * 1, cyTile * 0,
        cxTile, cyTile, SRCCOPY);
    StretchBlt(hdcDst, xDst + cxTile * 1, yDst + cyDst - cyTile,
        cxDst - cxTile - cxTile, cyTile,
        hdcSrc, cxTile * 1, cyTile * 2,
        cxTile, cyTile, SRCCOPY);

    if (fMiddle)
    {
        // draw middle tile
        StretchBlt(hdcDst, xDst + cxTile * 1, yDst + cyTile * 1,
            cxDst - cxTile - cxTile,
            cyDst - cyTile - cyTile,
            hdcSrc, cxTile * 1, cyTile * 1,
            cxTile, cyTile, SRCCOPY);
    }
}


/* DrawFrame(pbox, prc, pdc, fDraw)
 *
 * Set <*prc> to be the bounding rectangle around the frame of <pbox>.
 *
 * Then, if <fDraw> is TRUE, draw the frame.  In this case, <pdc> must be a
 * DC onto the window containing the box network.
 *
 * If <fDraw> is FALSE, then only set <*prc>.  In this case, <pdc> is ignored.
 */
void CBoxDraw::DrawFrame(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw)
{
    CDC         dcBitmap;

    GetFrameRect(pbox, prc);

    if (fDraw)
    {
        dcBitmap.CreateCompatibleDC(NULL);
        dcBitmap.SelectObject(&m_abmEdges[fnorm(pbox->IsSelected())]);
        DrawCompositeFrame(pdc->m_hDC, prc->left, prc->top,
            prc->Width(), prc->Height(),
            dcBitmap.m_hDC, m_sizEdgesTile.cx, m_sizEdgesTile.cy, FALSE);
    }
}


/* DrawBoxLabel(pbox, prc, pdc, fDraw)
 *
 * Set <*prc> to be the bounding rectangle around the box label of <pbox>.
 *
 * Then, if <fDraw> is TRUE, draw the box label -- note that this will also
 * cause the *entire* box to be filled with the background color, not just the
 * bounding rectangle of the box.  In this case, <pdc> must be a DC onto the
 * window containing the box network.
 *
 * If <fDraw> is FALSE, then only set <*prc>.  In this case, <pdc> may be any
 * screen DC.
 *
 * Also deals with the clock icon.
 */
void CBoxDraw::DrawBoxLabel(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw)
{
    CRect       rcBox;          // inside rectangle of <pbox>

    // select the font used to draw the box label
    pdc->SelectObject(&m_fontBoxLabel);

    // set <*prc> to be the bounding rectangle of the box label
    GetInsideRect(pbox, &rcBox);

    // calculate how much space we need for label and clock icon
    CSize sizeLabel = pdc->GetTextExtent(pbox->m_stLabel, pbox->m_stLabel.GetLength());

    INT iDiff = 0;

    if (pbox->HasClock()) {
        // increase label size by clock width + small gap
        sizeLabel.cx += m_sizClock.cx + 5;

        // make sure label height is at least clock height high
        if (m_sizClock.cy > sizeLabel.cy) {
            iDiff = m_sizClock.cy - sizeLabel.cy;
            sizeLabel.cy = m_sizClock.cy;
        }
    }

    *prc = CRect(rcBox.TopLeft(), sizeLabel);
    CSize siz = rcBox.Size() - prc->Size();
    prc->OffsetRect(siz.cx / 2, siz.cy / 2);

    if (fDraw)
    {
        // draw the box label
        pdc->SetBkColor(m_crBkgnd);
        pdc->ExtTextOut(prc->left, prc->top, ETO_OPAQUE, rcBox,
            pbox->m_stLabel, pbox->m_stLabel.GetLength(), NULL);

        if (pbox->HasClock()) {
            // draw clock behind filter name
            CDC dcBitmap;
            dcBitmap.CreateCompatibleDC(NULL);

            // select the appropriate bitmap
            if (pbox->HasSelectedClock())
                dcBitmap.SelectObject(&m_abmClocks[1]);
            else
                dcBitmap.SelectObject(&m_abmClocks[0]);

            pdc->BitBlt(prc->left + sizeLabel.cx - m_sizClock.cx,
                        prc->top + iDiff / 2,
                        m_sizClock.cx, m_sizClock.cy,
                        &dcBitmap, 0, 0, SRCCOPY);
        }
    }
}

/* DrawBoxFile(pbox, prc, pdc, fDraw)
 *
 * Set <*prc> to be the bounding rectangle around the box label of <pbox>.
 *
 * Then, if <fDraw> is TRUE, draw the box label -- note that this will also
 * cause the *entire* box to be filled with the background color, not just the
 * bounding rectangle of the box.  In this case, <pdc> must be a DC onto the
 * window containing the box network.
 *
 * If <fDraw> is FALSE, then only set <*prc>.  In this case, <pdc> may be any
 * screen DC.
 */
/*void CBoxDraw::DrawBoxFile(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw)
{
    CRect       rcBox;          // inside rectangle of <pbox>

    // select the font used to draw the box label
    pdc->SelectObject(&m_fontBoxLabel);

    // set <*prc> to be the bounding rectangle of the box label
    GetInsideRect(pbox, &rcBox);

    *prc = CRect(rcBox.TopLeft(), pdc->GetTextExtent(pbox->m_stFilename, pbox->m_stFilename.GetLength()));
    CSize siz = rcBox.Size() - prc->Size();
    prc->OffsetRect(siz.cx / 2, siz.cy * 3 / 4);

    if (fDraw)
    {
        // draw the box label
        pdc->SetBkColor(m_crBkgnd);
        pdc->ExtTextOut(prc->left, prc->top, ETO_OPAQUE, rcBox,
            pbox->m_stFilename, pbox->m_stFilename.GetLength(), NULL);
    }
}
*/

/* DrawTabLabel(pbox, psock, prc, pdc, fDraw)
 *
 * Set <*prc> to be the bounding rectangle around the box tab label of
 * socket <psock> of box <pbox>.
 *
 * Then, if <fDraw> is TRUE, draw the tab label.  In this case, <pdc> must
 * be a DC onto the window containing the box network.
 *
 * If <fDraw> is FALSE, then only set <*prc>.  In this case, <pdc> may be any
 * screen DC.
 */
void CBoxDraw::DrawTabLabel(CBox *pbox, CBoxSocket *psock, CRect *prc, CDC *pdc,
    BOOL fDraw)
{
    CRect       rcBox;          // inside rectangle of <pbox>
    CPoint      pt;             // point on edge of <pbox> corresp. to <psock>

    // select the font used to draw the box label
    pdc->SelectObject(&m_fontTabLabel);

    // set <*prc> to be the bounding rectangle of the tab label
    GetInsideRect(pbox, &rcBox);
    pt = BoxTabPosToPoint(pbox, psock->m_tabpos);
    *prc = CRect(pt,
        pdc->GetTextExtent(psock->m_stLabel, psock->m_stLabel.GetLength()));
    if (psock->m_tabpos.m_fLeftRight)
    {
        // center label vertically beside <pt>, set flush to box left or right
        // (adjusting for margins)
        prc->OffsetRect((psock->m_tabpos.m_fLeftTop ? m_sizLabelMargins.cx
                        : -(prc->Width() + m_sizLabelMargins.cx)),
            -prc->Height() / 2);
    }
    else
    {
        // center label horizontally beside <pt>, set flush to box top or bottom
        // (adjusting for margins)
        prc->OffsetRect(-prc->Width() / 2,
            (psock->m_tabpos.m_fLeftTop ? m_sizLabelMargins.cy
             : -(prc->Height() + m_sizLabelMargins.cy)));
    }

    if (fDraw)
    {
        // draw the tab label
        pdc->SetBkColor(m_crBkgnd);
        pdc->ExtTextOut(prc->left, prc->top, ETO_OPAQUE, prc,
            psock->m_stLabel, psock->m_stLabel.GetLength(), NULL);
    }
}


/* DrawTab(psock, prc, pdc, fDraw, fHilite)
 *
 * Set <*prc> to be the bounding rectangle around the box tab <psock>.
 *
 * Then, if <fDraw> is TRUE, draw the tab.  In this case, <pdc> must
 * be a DC onto the window containing the box network.
 *
 * If <fHilite> is TRUE, then the tab is drawn in a hilited state.
 *
 * If <fDraw> is FALSE, then only set <*prc>.  In this case, <pdc> is unused.
 */
void CBoxDraw::DrawTab(CBoxSocket *psock, CRect *prc, CDC *pdc,
    BOOL fDraw, BOOL fHilite)
{
    CRect       rcBox;          // inside rectangle of <psock->m_pbox>
    CPoint      pt;             // point on edge of box corresp. to <psock>

    // set <*prc> to be the bounding rectangle of the tab
    GetInsideRect(psock->m_pbox, &rcBox);
    pt = BoxTabPosToPoint(psock->m_pbox, psock->m_tabpos);
    *prc = CRect(pt, m_sizTabsTile);
    if (psock->m_tabpos.m_fLeftRight)
    {
        // center tab vertically beside <pt>, set flush to box left or right
        prc->OffsetRect((psock->m_tabpos.m_fLeftTop ? -m_sizTabsTile.cx : 0),
            -prc->Height() / 2);
    }
    else
    {
        // center tab horizontally beside <pt>, set flush to box top or bottom
        prc->OffsetRect(-prc->Width() / 2,
            (psock->m_tabpos.m_fLeftTop ? -m_sizTabsTile.cy : 0));
    }

    if (fDraw)
    {
        // set <rcTile> to the rectangle in the bitmap containing the tile;
        // note that, in the 3x3 tiled bitmap, only 4 of the 9 tiles are used:
        //
        //      unused  top     unused
        //      left    unused  right
        //      unused  bottom  unused
        //
        CRect rcTile(CPoint(0, 0), m_sizTabsTile);
        if (psock->m_tabpos.m_fLeftRight)
        {
            // tile is on left or right side of bitmap
            rcTile.OffsetRect(0, m_sizTabsTile.cy);
            if (!psock->m_tabpos.m_fLeftTop)
                rcTile.OffsetRect(2 * m_sizTabsTile.cx, 0);
        }
        else
        {
            // tile is on top or bottom of bitmap
            rcTile.OffsetRect(m_sizTabsTile.cx, 0);
            if (!psock->m_tabpos.m_fLeftTop)
                rcTile.OffsetRect(0, 2 * m_sizTabsTile.cy);
        }

        // draw the tab
        CDC dcBitmap;
        dcBitmap.CreateCompatibleDC(NULL);
        dcBitmap.SelectObject(&m_abmTabs[fnorm(fHilite)]);
        pdc->BitBlt(prc->left, prc->top, prc->Width(), prc->Height(),
            &dcBitmap, rcTile.left, rcTile.top, SRCCOPY);
    }
}


/* pt = GetTabCenter(psock)
 *
 * Return the coordinates of the center of the box tab <psock>.
 */
CPoint CBoxDraw::GetTabCenter(CBoxSocket *psock)
{
    CRect           rc;         // bounding rectangle of tab

    DrawTab(psock, &rc, NULL, FALSE, FALSE);
    return CPoint((rc.left + rc.right) / 2, (rc.top + rc.bottom) / 2);
}


/* tabpos = BoxTabPosFromPoint(pbox, pt, piError)
 *
 * Figure out which edge of <pbox> <pt> is closest to, and return the
 * CBoxTabPos position that represents the point on that edge closest
 * to <pt>, and set <*piError> to the distance between that point and <pt>.
 */
CBoxTabPos CBoxDraw::BoxTabPosFromPoint(CBox *pbox, CPoint pt, LPINT piError)
{
    CRect       rcBox;          // inside rectangle of <pbox>
    int         dxLeft, dxRight, dyTop, dyBottom;
    CBoxTabPos  tabpos;

    // CTabPos::GetPos() values are relative to the height or width
    // of the inside of the box
    GetInsideRect(pbox, &rcBox);

    // calculate the distance to each edge
    dxLeft = iabs(pt.x - rcBox.left);
    dxRight = iabs(pt.x - rcBox.right);
    dyTop = iabs(pt.y - rcBox.top);
    dyBottom = iabs(pt.y - rcBox.bottom);

    // figure out which edge <pt> is closest to
    if (imin(dxLeft, dxRight) < imin(dyTop, dyBottom))
    {
        tabpos.m_fLeftRight = TRUE;
        // <pt> is closest to the left or right edge
        tabpos.SetPos(ibound(pt.y, rcBox.top, rcBox.bottom) - rcBox.top,
            rcBox.Height());
        if (dxLeft < dxRight)
        {
            tabpos.m_fLeftTop = TRUE;
            *piError = dxLeft;
        }
        else
        {
            tabpos.m_fLeftTop = FALSE;
            *piError = dxRight;
        }
        *piError = max(*piError, ioutbound(pt.y, rcBox.top, rcBox.bottom));
    }
    else
    {
        tabpos.m_fLeftRight = FALSE;
        // <pt> is closest to the top or bottom edge
        tabpos.SetPos(ibound(pt.x, rcBox.left, rcBox.right) - rcBox.left,
            rcBox.Width());
        if (dyTop < dyBottom)
        {
            tabpos.m_fLeftTop = TRUE;
            *piError = dyTop;
        }
        else
        {
            tabpos.m_fLeftTop = FALSE;
            *piError = dyBottom;
        }
        *piError = max(*piError, ioutbound(pt.x, rcBox.left, rcBox.right));
    }

    return tabpos;
}


/* pt = BoxTabPosToPoint(pbox, tabpos)
 *
 * Convert <tabpos>, a box tab position on <pbox>, to a point that's
 * on one of the inside edges of <pbox>, and return the point.
 */
CPoint CBoxDraw::BoxTabPosToPoint(const CBox *pbox, CBoxTabPos tabpos)
{
    CRect       rcBox;          // inside rectangle of <pbox>
    CPoint      pt;

    // CTabPos::GetPos() values are relative to the height or width
    // of the inside of the box
    GetInsideRect(pbox, &rcBox);

    pt = rcBox.TopLeft();
    if (tabpos.m_fLeftRight)
    {
        // tab is on left or right edge
        pt.y += tabpos.GetPos(rcBox.Height());
        if (!tabpos.m_fLeftTop)
            pt.x = rcBox.right;
    }
    else
    {
        // tab is on top or bottom edge
        pt.x += tabpos.GetPos(rcBox.Width());
        if (!tabpos.m_fLeftTop)
            pt.y = rcBox.bottom;
    }

    return pt;
}


/* DrawBox(pbox, pdc, [psockHilite], [psizGhostOffset])
 *
 * Draw the box <pbox> in <pdc> (a DC onto the window containing the box
 * network), and then exclude the portion that was painted from the
 * clipping region of <pdc>.
 *
 * If <psockHilite> is not NULL, then highlight socket tab <psockHilite>
 * if <pbox> contains it.
 *
 * If <psizGhostOffset> not NULL then, instead of drawing the box, draw a
 * "ghost" version of the box, offset by <*psizGhostOffset>, by inverting
 * destination pixels; calling DrawBox() again with the same value of
 * <psizGhostOffset> will invert the same pixels again and return <pdc>
 * to its original state.
 */
void CBoxDraw::DrawBox(CBox *pbox, CDC *pdc, CBoxSocket *psockHilite,
    CSize *psizGhostOffset)
{
    CRect       rc;

    /* if <psizGhostOffset> specified, just invert the pixels between the
     * frame and the inside of the box (all offset by <psizGhostOffset>)
     */
    if (psizGhostOffset)
    {
        CRect rcFrame, rcInside;
        GetFrameRect(pbox, &rcFrame);
        rcFrame.OffsetRect(*psizGhostOffset);
        GetInsideRect(pbox, &rcInside);
        rcInside.OffsetRect(*psizGhostOffset);
        InvertFrame(pdc, &rcFrame, &rcInside);
        return;
    }

    CSocketEnum Next(pbox);
    CBoxSocket *psock;
    // draw each socket's tab and tab label
    while (0 != (psock = Next()))
    {
        DrawTab(psock, &rc, pdc, TRUE, (psock == psockHilite));
        pdc->ExcludeClipRect(&rc);
        DrawTabLabel(pbox, psock, &rc, pdc, TRUE);
	// TBD: don't invalidate the clip rect here if printing
	// (or printer drops box label later)
	if (!pdc->IsPrinting())
	    pdc->ExcludeClipRect(&rc);
    }

    // draw the box filename
//    DrawBoxFile(pbox, &rc, pdc, TRUE);
//    pdc->ExcludeClipRect(&rc);

    // draw the box label
    DrawBoxLabel(pbox, &rc, pdc, TRUE);
    pdc->ExcludeClipRect(&rc);

    // draw the box frame
    DrawFrame(pbox, &rc, pdc, TRUE);
    pdc->ExcludeClipRect(&rc);
}


/* eHit = HitTestBox(pbox, pt, ptabpos, ppsock)
 *
 * See if <pt> hits some part of <pbox>.  Return the following hit-test code:
 *
 *   HT_MISS        didn't hit anything
 *   HT_TAB         hit a box tab (set <*ppsock> to it)
 *   HT_EDGE        hit the edge of the box (set <*ptabpos> to it)
 *   HT_TABLABEL    hit a box tab label (set <*ppsock> to it)
 *   HT_BOXLABEL    hit the box label
 *   HT_BOXFILE     hit the box filename
 *   HT_BOX         hit elsewhere on the box
 */
CBoxDraw::EHit CBoxDraw::HitTestBox(CBox *pbox, CPoint pt,
    CBoxTabPos *ptabpos, CBoxSocket **ppsock)
{
    CClientDC       dc(CWnd::GetDesktopWindow()); // to get label sizes etc.
    int             iError;
    CRect           rc;

    // for efficiency, before continuing further, first check if <pt> is even
    // in the bounding rectangle of the box
    if (!pbox->GetRect().PtInRect(pt))
        return HT_MISS;

    // see if <pt> is in a tab or tab label
    CSocketEnum Next(pbox);
    while (0 != (*ppsock = Next())) {

        DrawTab(*ppsock, &rc, &dc, FALSE, FALSE);
	rc.InflateRect(1,1);	// give users more chance of hitting tabs.
        if (rc.PtInRect(pt))
            return HT_TAB;
        DrawTabLabel(pbox, *ppsock, &rc, &dc, FALSE);
        if (rc.PtInRect(pt))
            return HT_TABLABEL;
    }

    // see if <pt> is in the box label
    DrawBoxLabel(pbox, &rc, &dc, FALSE);
    if (rc.PtInRect(pt))
        return HT_BOXLABEL;

    // see if <pt> is in the box label
//    DrawBoxFile(pbox, &rc, &dc, FALSE);
//    if (rc.PtInRect(pt))
//        return HT_BOXFILE;

    // see if <pt> is near the edge of the box
    *ptabpos = BoxTabPosFromPoint(pbox, pt, &iError);
    if (iError <= 3/*close-enough-zone*/)
        return HT_EDGE;

    // see if <pt> is anywhere else in the box
    DrawFrame(pbox, &rc, &dc, FALSE);
    if (rc.PtInRect(pt))
        return HT_BOX;

    return HT_MISS;
}


/////////////////////////////////////////////////////////////////////////////
// Link drawing and hit testing


/* An arrow is drawn as a pie (a slice of a circle) of radius ARROW_RADIUS.
 * The angle of the arrow pie slice is twice the slope "rise/run", where
 * "rise" is ARROW_SLOPERISE and "run" is ARROW_SLOPERUN.
 */


#define ARROW_RADIUS        12  // radius of pie for 1-wide line arrow
#define ARROW_SLOPERISE     3   // "rise" of arrow angle
#define ARROW_SLOPERUN      8   // "run" of arrow angle


/* DrawArrowHead(hdc, ptTip, ptTail, fPixel)
 *
 * Imagine a line drawn from <ptTip> to <ptTail>, with an arrowhead with its
 * tip at <ptTip>.  Draw this arrowhead.
 *
 * If <fPixel> is TRUE, then the arrowhead points to the pixel at <ptTip>
 * i.e. the rectangle (ptTip.x,ptTip.y, ptTip.x+1,ptTip.y+1); a one-pixel-wide
 * horizontal or vertical line drawn to <ptTip> should line up with this
 * rectangle, and the arrowhead should not obscure this rectangle.
 *
 * If <fPixel> is FALSE, then the arrowhead points to the gridline intersection
 * at <ptTip>, not the pixel at <ptTip>.  (One implication of this is that the
 * pixel at <ptTip>, will be obscured by the arrowhead when the tail of the
 * arrow is to the right and below the tip.)
 *
 * In order for DrawArrowHead() to function correctly, the current pen
 * must be non-null and one unit thick.
 */
void NEAR PASCAL
DrawArrowHead(HDC hdc, POINT ptTip, POINT ptTail, BOOL fPixel)
{
    int     dxLine, dyLine;     // delta from tip to end of line
    POINT   ptBoundA, ptBoundB; // ends of boundary lines
    int     dxBound, dyBound;

    // adjust for the way Windows draws pies
    if (ptTail.x >= ptTip.x)
        ptTip.x++;
    if (ptTail.y >= ptTip.y)
        ptTip.y++;
    if (fPixel)
    {
        if (ptTail.x > ptTip.x)
            ptTip.x++;
        if (ptTail.y > ptTip.y)
            ptTip.y++;
    }

    // calculate the extent of the line
    dxLine = ptTip.x - ptTail.x;
    dyLine = ptTip.y - ptTail.y;

    if ((iabs(dxLine) < ARROW_RADIUS) && (iabs(dyLine) < ARROW_RADIUS))
        return;         // line too short to draw arrow

    // calculate <ptBoundA> and <ptBoundB>; if you draw a line from
    // <ptTip> to <ptBoundA>, that line will touch one side of the
    // arrow; if you draw a line from <ptTip> to <ptBoundB>, that line
    // will touch the other side of the arrow; the first line will
    // always come before the second line if you orbit <ptTip>
    // counterclockwise (like Pie() does)
    dxBound = ((2 * dyLine * ARROW_SLOPERISE + ARROW_SLOPERUN)
        / ARROW_SLOPERUN) / 2;
    dyBound = ((2 * dxLine * ARROW_SLOPERISE + ARROW_SLOPERUN)
        / ARROW_SLOPERUN) / 2;
    ptBoundA.x = ptTail.x + dxBound;
    ptBoundA.y = ptTail.y - dyBound;
    ptBoundB.x = ptTail.x - dxBound;
    ptBoundB.y = ptTail.y + dyBound;

    // draw the arrowhead
    Pie(hdc, ptTip.x - ARROW_RADIUS, ptTip.y - ARROW_RADIUS,
             ptTip.x + ARROW_RADIUS, ptTip.y + ARROW_RADIUS,
         ptBoundA.x, ptBoundA.y, ptBoundB.x, ptBoundB.y);
}


/* GetOrInvalLinkRect(plink, prc, [pwnd])
 *
 * Set <*prc> to be a bounding rectangle around <plink>.  If <pwnd> is not
 * NULL, then invalidate the area covering at least <plink> in <pwnd>.
 * (This is usually more efficient than invalidating all of <pwnd>,
 * for links that have at least one bend.)
 */
void CBoxDraw::GetOrInvalLinkRect(CBoxLink *plink, CRect *prc, CScrollView *pScroll)
{
    CPoint          ptPrev, ptCur;  // endpoints of current line segment
    int             iSeg = 0;       // current line segment (0, 1, 2, ...)
    CRect           rc;
    const int       iLineWidth = 1;

    // enumerate the line segments of the link, starting at the arrowtail
    ptPrev = GetTabCenter(plink->m_psockTail);
    ptCur = GetTabCenter(plink->m_psockHead);

    // set <rc> to be the rectangle with corners at <ptPrev> and <ptCur>
    rc.TopLeft() = ptPrev;
    rc.BottomRight() = ptCur;
    NormalizeRect(&rc);

    // inflate <rc> to account for arrowheads, line width, and hilited bends
    const int iInflate = max(ARROW_SLOPERISE, m_iHiliteBendsRadius) + 1;
    rc.InflateRect(iInflate, iInflate);

    // enlarge <prc> as necessary to include <rc>
    if (iSeg++ == 0)
        *prc = rc;
    else
        prc->UnionRect(prc, &rc);

    // invalidate <rc> if requested
    if (pScroll != NULL)
        pScroll->InvalidateRect(&(rc - pScroll->GetScrollPosition()), TRUE);

    ptPrev = ptCur;
}


/* SelectLinkBrushAndPen(pdc, fHilite)
 *
 * Select the brush and pen used to draw links into <pdc>.  If <fHilite>,
 * select the brush and pen used to draw highlighted links.
 */
void CBoxDraw::SelectLinkBrushAndPen(CDC *pdc, BOOL fHilite)
{
    pdc->SelectObject(&m_abrLink[fnorm(fHilite)]);
    pdc->SelectObject(&m_apenLink[fnorm(fHilite)]);
}


/* DrawArrow(pdc, ptTail, ptHead, [fGhost], [fArrowhead], [fHilite])
 *
 * Draw an arrow from <ptTail> to <ptHead>.  If <fGhost> is FALSE, draw in
 * the normal color for links (if <fHilite> is FALSE) or the highlight color
 * for links (if <fHilite> is TRUE).  Otherwise, draw by inverting destination
 * pixels so that calling DrawGhostArrow() again with the same parameters will
 * return <pdc> to its original state.
 *
 * If <fArrowhead>, draw the arrowhead.  Otherwise, just draw a line with
 * no arrowhead.
 */
void CBoxDraw::DrawArrow(CDC *pdc, CPoint ptTail, CPoint ptHead, BOOL fGhost,
    BOOL fArrowhead, BOOL fHilite)
{
    // draw in "xor" mode if <fGhost>, black otherwise
    int iPrevROP = pdc->SetROP2(fGhost ? R2_NOT : R2_COPYPEN);

    // select brush and pen
    SelectLinkBrushAndPen(pdc, fHilite);

    // draw line
    pdc->MoveTo(ptTail);
    pdc->LineTo(ptHead);

    // draw arrowhead (if requested)
    if (fArrowhead)
        DrawArrowHead(pdc->m_hDC, ptHead, ptTail, FALSE);

    // revert to previous raster operation
    pdc->SetROP2(iPrevROP);
}


/* DrawLink(plink, pdc, [fHilite], [psizGhostOffset])
 *
 * Draw the link <plink> in <pdc> (a DC onto the window containing the box
 * network), using the normal color for links (if <fHilite> is FALSE) or
 * the using the highlight color for links (if <fHilite> is TRUE). and also draw
 * the head and tail the same way.
 *
 * If <psizGhostOffset> not NULL then, instead of drawing the link, draw a
 * "ghost" version of the link, offset by <*psizGhostOffset>, by inverting
 * destination pixels; calling DrawLink() again with the same value of
 * <psizGhostOffset> will invert the same pixels again and return <pdc>
 * to its original state.  Special case: if <psizeGhostOffset> is not NULL,
 * then for each end of the link (arrowtail and arrowhead), if that end
 * is connected to a box that is not selected, don't offset that end
 * (so that, during a box-move operation, links to boxes that aren't selected
 * are shown still connected to those boxes).
 */
void CBoxDraw::DrawLink(CBoxLink *plink, CDC *pdc, BOOL fHilite, CSize *psizGhostOffset)
{
    CSize           sizOffset;      // amount to offset vertices by
    CPoint          pt1, pt2;

    if (psizGhostOffset == NULL) {	// reflect true state, unless drawing ghost
        fHilite = plink->IsSelected();	//!!! override paramter!
    }

    // set <sizOffset> to the amount to offset link drawing by
    if (psizGhostOffset != NULL)
        sizOffset = *psizGhostOffset;
    else
        sizOffset = CSize(0, 0);

    // draw all line segments, except for the line segment containing the
    // arrowhead, starting from the tail end of the link
    CPoint pt = GetTabCenter(plink->m_psockTail);
    BOOL fMovingBothEnds = (plink->m_psockTail->m_pbox->IsSelected() &&
                            plink->m_psockHead->m_pbox->IsSelected());

    // draw the line segment that includes the arrowhead
    CPoint ptHead = GetTabCenter(plink->m_psockHead);
    pt1 = pt + (plink->m_psockTail->m_pbox->IsSelected()
                    ? sizOffset : CSize(0, 0));
    pt2 = ptHead + (plink->m_psockHead->m_pbox->IsSelected()
                    ? sizOffset : CSize(0, 0));

    DrawArrow(pdc, pt1, pt2, (psizGhostOffset != NULL), TRUE, fHilite);
}


/* iNew = RestrictRange(i, i1, i2)
 *
 * If <i> is between <i1> or <i2> (or equal to <i1> or <i2>), return <i>.
 * Otherwise, return whichever of <i1> or <i2> that <i> is closest to.
 */
int NEAR PASCAL
RestrictRange(int i, int i1, int i2)
{
    if (i1 < i2)
        return ibound(i, i1, i2);
    else
        return ibound(i, i2, i1);

    return i;
}


/* lSq = Square(l)
 *
 * Return the sqare of <l>.
 */
inline long Square(long l)
{
    return l * l;
}


/* iSqDist = SquareDistance(pt1, pt2)
 *
 * Return the square of the distance between <pt1> and <pt2>.
 */
inline long SquareDistance(POINT pt1, POINT pt2)
{
    return Square(pt1.x - pt2.x) + Square(pt1.y - pt2.y);
}


/* ptProject = ProjectPointToLineSeg(pt1, pt2, pt3)
 *
 * Return the point nearest to <pt3> that lies on the line segment between
 * <pt1> and <pt2>.  This is equivalent to projecting <pt3> onto line <pt1pt2>,
 * except that if the projected point lies on <pt1pt2> but not between <pt1>
 * and <pt2> then return whichever of <pt1> or <pt3> that the projected point
 * is nearest to.
 */
POINT NEAR PASCAL
ProjectPointToLineSeg(POINT pt1, POINT pt2, POINT pt3)
{
    POINT       ptProject;  // <pt3> projected on <pt1pt2>

    // calculate <l12s>, <l13s>, and <l23s> (the square of the distance
    // between <pt1> and <pt2>, <pt1> and <pt3>, and <pt2> and pt3>,
    // respectively), using the Pythagorean Theorem
    long l12s = SquareDistance(pt1, pt2);
    long l13s = SquareDistance(pt1, pt3);
    long l23s = SquareDistance(pt2, pt3);

    // Based on the Pythagorean Theorm, and using the fact that
    // triangles <pt1pt3> and <pt2pt3> have a right angle at vertex
    // <ptProject>, the distance <pt1ptProject> is:
    //
    //     (l12s + l13s - l23s) / (2 * square_root(l12s))
    //
    // This value is needed to compute <ptProject> below, but by doing
    // some substitution below it turns out we only need the numerator
    // <lNum> of this expression:
    long lNum = l12s + l13s - l23s;

    // special case: if line is zero-length, then return either end
    if (l12s == 0)
        return pt1;

    // calculate <ptProject.x> based on similar triangles pt1ptProjectptQ
    // and pt1pt2ptR, where points <ptQ> and <ptR> are projections of
    // points <ptProject> and <pt2>, respectively, onto the x axis;
    // calculate <ptProject.y> similarly
    ptProject.x = (int) (((pt2.x - pt1.x) * lNum) / (2 * l12s) + pt1.x);
    ptProject.y = (int) (((pt2.y - pt1.y) * lNum) / (2 * l12s) + pt1.y);

    // <ptProject> is on the line <pt1pt2>; now see if <ptProject> is
    // on the line segment <pt1pt2> (i.e. between <pt1> and <pt2>);
    // if not, return whichever of <pt1> or <pt2> <ptProject> is closest to
    ptProject.x = RestrictRange(ptProject.x, pt1.x, pt2.x);
    ptProject.y = RestrictRange(ptProject.y, pt1.y, pt2.y);

    return ptProject;
}


/* eHit = HitTestLink(plink, pt, pptProject, ppbend)
 *
 * See if <pt> hits some part of <plink>.  Return the following hit-test code:
 *
 *   HT_MISS        didn't hit anything
 *   HT_LINKLINE    hit test: hit a link line (set <*pplink> to it; set
 *                  <*ppbend> to the bend at the end of the line segment
 *                  toward the arrowhead, or to NULL if it's the line segment
 *                  with the arrowhead)
 *   HT_LINKBEND    hit test: hit a bend in the link (set <*ppbend> to it;
 *                  set <*pplink> to the link)
 *
 * If something other than HT_MISS is returned, <*pptProject> is set to
 * the point nearest to <pt> on a line segment of the link.
 */
CBoxDraw::EHit CBoxDraw::HitTestLink(CBoxLink *plink, CPoint pt, CPoint *pptProject)
{
    CPoint          ptPrev, ptCur;  // endpoints of current line segment
    CPoint          ptProject;      // <pt> projected onto a line segment

    // these variables keep track of the closest line segment to <pt>
    long            lSqDistSeg;
    long            lSqDistSegMin = 0x7fffffff;
    CPoint          ptProjectSeg;

    // these variables keep track of the closest bend point to <pt>
    CPoint          ptProjectBend;

    // enumerate the line segments of the link, starting at the arrowtail
    ptPrev = GetTabCenter(plink->m_psockTail);

    ptCur = GetTabCenter(plink->m_psockHead);
    // see how close <pt> is to line segment (ptPrev,ptCur)
    ptProject = ProjectPointToLineSeg(ptPrev, ptCur, pt);
    lSqDistSeg = SquareDistance(ptProject, pt);
    if (lSqDistSegMin > lSqDistSeg) {
        lSqDistSegMin = lSqDistSeg;
        ptProjectSeg = ptProject;
    }

    ptPrev = ptCur;

    // see if <pt> was close enough to the closest line segment
    if (lSqDistSegMin <= Square(m_iHotZone))
    {
        *pptProject = ptProjectSeg;
        return HT_LINKLINE;
    }

    return HT_MISS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\bnetvw.h ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
// bnetvw.h : declares CBoxNetView
//

/////////////////////////////////////////////////////////////////////////////
// CBoxNetView
//

// forward declaration
class CPropDlg;

class CBoxNetView : public CScrollView
{
    DECLARE_DYNCREATE(CBoxNetView)

public:
    // construction and destruction
    CBoxNetView();
    virtual ~CBoxNetView();

public:
    // diagnostics
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

public:
    // View updatiing, & drawing

    virtual void           OnInitialUpdate(void);
    virtual void           OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    virtual void           OnDraw(CDC* pdc);  // overridden to draw this view

    // What, if anything, is under the point pt?
    virtual CBoxDraw::EHit HitTest(CPoint	pt,
                                   CBox		**ppbox,
                                   CBoxTabPos	*ptabpos,
                                   CBoxSocket	**ppsock,
                                   CBoxLink	**pplink,
                                   CPoint	*pptProject
                                   );

protected:
    // general protected functions
    CBoxNetDoc* CBoxNetView::GetDocument(void) { ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CBoxNetDoc)));
                                                 return (CBoxNetDoc*) m_pDocument;
                                               }
    void CancelModes();

protected:
    // printing support
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pdc, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pdc, CPrintInfo* pInfo);

public:
    // IDs for timers used by view
    enum
    {
        TIMER_MOVE_SEL_PENDING = 1,  // used during move-selection-pending mode
        TIMER_SEEKBAR = 2,
        TIMER_PENDING_RECONNECT = 3
    };

protected:

    // view modes that are cancelled when the mouse button is released
    BOOL        m_fMouseDrag;       // mouse is being dragged in window?
    BOOL        m_fMoveBoxSelPending; // waiting to enter move-sel mode?
    BOOL        m_fMoveBoxSel;      // currently moving selection of boxes?
    BOOL        m_fGhostSelection;  // there is currently a ghost selection?
    BOOL        m_fSelectRect;      // draw a rectangle round boxes to select?
    BOOL        m_fNewLink;         // create a new link?
    BOOL        m_fGhostArrow;      // there is currently a ghost arrow?
    CBoxSocket *m_psockHilite;      // currently-hilited socket tab (or NULL)

private:
    // context menus

    void	PreparePinMenu(CMenu *pmenuPopup);
    void        PrepareLinkMenu(CMenu *pmenuPopup);
    void	PrepareFilterMenu(CMenu *pmenuPopup, CBox *);

protected:
    // state/functions for mouse-drag mode (iff <m_fMouseDrag>)
    BOOL        m_fMouseShift;      // user shift-clicked?
    CPoint      m_ptMouseAnchor;    // where mouse drag began
    CPoint      m_ptMousePrev;      // where mouse was previously
    CBox *      m_pboxMouse;        // box clicked on at start of drag
    BOOL        m_fMouseBoxSel;     // clicked-on box was initally selected?
    void MouseDragBegin(UINT nFlags, CPoint pt, CBox *pboxMouse);
    void MouseDragContinue(CPoint pt);
    void MouseDragEnd();

protected:
    // state/functions for move-selection-pending mode
    // (iff <m_fMoveBoxSelPending>)
    CRect       m_rcMoveSelPending; // start move-selection when outside this
    void MoveBoxSelPendingBegin(CPoint pt);
    void MoveBoxSelPendingContinue(CPoint pt);
    void MoveBoxSelPendingEnd(BOOL fCancel);

protected:
    // state/functions for move-selection mode
    // (iff <m_fMoveBoxSel>)
    void MoveBoxSelBegin();
    void MoveBoxSelContinue(CSize sizOffset);
    void MoveBoxSelEnd(BOOL fCancel);
    void MoveBoxSelection(CSize sizOffset);
    CSize ConstrainMoveBoxSel(CSize sizOffset, BOOL fCalcSelBoundRect);

protected:
    // state/functions for ghost-selection mode
    // (iff <m_fGhostSelection>)
    CSize       m_sizGhostSelOffset; // ghost sel. offset from sel. this much
    CRect       m_rcSelBound;       // bounding rectangle around non-ghost sel.
    void GhostSelectionCreate();
    void GhostSelectionMove(CSize sizOffset);
    void GhostSelectionDestroy(void);
    void GhostSelectionDraw(CDC *pdc);

protected:
    // state/functions for select-rectangle mode
    // (iff <m_fSelectRect>)
    CPoint      m_ptSelectRectAnchor; // where select-rect drag began
    CPoint      m_ptSelectRectPrev; // previous mouse drag location
    void SelectRectBegin(CPoint pt);
    void SelectRectContinue(CPoint pt);
    void SelectRectEnd(BOOL fCancel);
    void SelectRectDraw(CDC *pdc);
    void SelectBoxesIntersectingRect(CRect *prc);

protected:
    // state/functions for new-link mode
    // (iff <m_fNewLink>)
    CBoxSocket *m_psockNewLinkAnchor; // clicked-on socket tab
    void NewLinkBegin(CPoint pt, CBoxSocket *psock);
    void NewLinkContinue(CPoint pt);
    void NewLinkEnd(BOOL fCancel);

protected:
    // state/functions for ghost-arrow mode
    // (iff <m_fGhostArrow>)
    CPoint      m_ptGhostArrowTail; // tail of ghost arrow
    CPoint      m_ptGhostArrowHead; // head of ghost arrow
    void GhostArrowBegin(CPoint pt);
    void GhostArrowContinue(CPoint pt);
    void GhostArrowEnd();
    void GhostArrowDraw(CDC *pdc);

protected:
    // state/functions for highlight-tab mode (iff <m_psockHilite> not NULL)
    void SetHiliteTab(CBoxSocket *psock);

protected:
    // performace logging module handle. NULL if not present
    HINSTANCE	m_hinstPerf;

protected:
    // Drag and drop attributes
    COleDropTarget      m_DropTarget;
    DROPEFFECT          m_DropEffect;
    CLIPFORMAT          m_cfClipFormat;

public:
    // Drag and drop functions
    virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
    virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);

protected:
    // message callback functions
    //{{AFX_MSG(CBoxNetView)
    afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
    afx_msg BOOL OnEraseBkgnd(CDC* pdc);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnTimer(UINT nIDEvent);
    afx_msg void OnCancelModes();
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
    afx_msg void OnEditDelete();
    afx_msg void OnUpdateSavePerfLog(CCmdUI* pCmdUI);
    afx_msg void OnSavePerfLog();
    afx_msg void OnUpdateNewPerfLog(CCmdUI* pCmdUI);
    afx_msg void OnNewPerfLog();
	afx_msg void OnFileSetLog();
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg void OnViewSeekbar();
	//}}AFX_MSG

    afx_msg void OnProperties();
    afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
    afx_msg void OnSelectClock();
    afx_msg LRESULT OnUser(WPARAM, LPARAM);

    DECLARE_MESSAGE_MAP()

    CBox * m_pSelectClockFilter;

public:

    void ShowSeekBar( );
    void CheckSeekBar( );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\bnetdoc.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// bnetdoc.h : declares CBoxNetDoc
//


// forward declarations
class CCmd;
class CRegFilter;
class CPropObject;


const int MAX_STRING_LEN=1000;
const int MAXFILTERS = 100;
typedef struct { //fit
    int iFilterCount;
    struct {
        DWORD dwUnconnectedInputPins;
        DWORD dwUnconnectedOutputPins;
        FILTER_INFO finfo;
        IBaseFilter * pFilter;
        bool IsSource;
    } Item[MAXFILTERS];
} FILTER_INFO_TABLE;

// for passing internal messages (see bnetdoc.cpp, search WM_USER_EC_EVENT)
struct NetDocUserMessage
{
    long        lEventCode;
    LONG_PTR    lParam1;
    LONG_PTR    lParam2;
};

// *
// * CBoxNetDoc
// *

// A CBoxNetDoc is intended to reflect the contents of the graph it instantiates
// and allows the user to interact with.
// Therefore it maintains a list of all the filters and connections(links) that are
// currently in the graph.
class CBoxNetDoc : public CDocument {

    DECLARE_DYNCREATE(CBoxNetDoc)

public:

    // <lHint> codes for ModifiedDoc(), UpdateAllViews(), etc.
    enum EHint
    {
        HINT_DRAW_ALL = 0,              // redraw entire view (must be zero!)
        HINT_CANCEL_VIEWSELECT,         // cancel any view-specific selection
        HINT_CANCEL_MODES,              // cancel any current modes
        HINT_DRAW_BOX,                  // draw only specified box
        HINT_DRAW_BOXANDLINKS,          // draw only box and connected links
        HINT_DRAW_BOXTAB,               // draw only specified box tab
        HINT_DRAW_LINK                  // draw only specified box link
    };

public:
    // contents of the document
    CBoxList        m_lstBoxes;         // each CBox in document
    CLinkList       m_lstLinks;         // each CBoxLink in document
    int             m_nCurrentSize;

    CSize       GetSize(void);  // the document's current size (pixels)

protected:
    // undo/redo stacks
    CMaxList        m_lstUndo;          // each CCmd in undo stack
    CMaxList        m_lstRedo;          // each CCmd in redo stack

public:
    // construction and destruction
                 CBoxNetDoc();
    virtual      ~CBoxNetDoc();
    virtual void DeleteContents();  // release quartz mapper & graph
    virtual void OnCloseDocument();

    virtual BOOL OnNewDocument();   // get quartz mapper & graph

    // storage & serialization
    virtual BOOL AttemptFileRender(LPCTSTR lpszPathName);
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
    virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);  

    virtual BOOL SaveModified(void);

    static DWORD WINAPI NotificationThread(LPVOID lpData);

private:
    virtual void CloseDownThread();     // close the notification thread

    BOOL m_bNewFilenameRequired;

    // This constant is NOT localisable
    static const OLECHAR m_StreamName[];

public:
    // diagnostics
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
    void MyDump(CDumpContext& dc) const;
#endif

public:
    // general public functions
    void ModifiedDoc(CView* pSender, LPARAM lHint = 0L,
        CObject* pHint = NULL);
    void DeselectAll();

public:
    // CBox lists and box selection
    void GetBoundingRect(CRect *prc, BOOL fBoxSel);
    void SelectBox(CBox *pbox, BOOL fSelect);
    void SelectLink(CBoxLink *plink, BOOL fSelect);
    BOOL IsSelectionEmpty() { return (IsLinkSelectionEmpty() && IsBoxSelectionEmpty()); }
    BOOL IsBoxSelectionEmpty();
    void GetBoxes(CBoxList *plstDst, BOOL fSelected = FALSE);
    void GetBoxSelection(CBoxList *plstDst)
        { GetBoxes(plstDst, TRUE); }
    void SetBoxes(CBoxList *plstSrc, BOOL fSelected = FALSE);
    void InvalidateBoxes(CBoxList *plst);
    void SetBoxSelection(CBoxList *plstDst)
        { SetBoxes(plstDst, TRUE); }
    void MoveBoxSelection(CSize sizOffset);

    void SelectBoxes(CList<CBox *, CBox*> *plst);
    void SelectLinks(CList<CBoxLink *, CBoxLink *> *plst);
    void OnWindowZoom(int iZoom, UINT iMenuItem);
    void IncreaseZoom();
    void DecreaseZoom();

private:
    BOOL IsLinkSelectionEmpty();

public:
    // command processing
    void CmdDo(CCmd *pcmd);
    void CmdUndo();
    BOOL CanUndo();
    void CmdRedo();
    BOOL CanRedo();
    void CmdRepeat();
    BOOL CanRepeat();

protected:
    // message callback helper functions
    void UpdateEditUndoRedoRepeat(CCmdUI* pCmdUI, BOOL fEnable,
        unsigned idStringFmt, CMaxList *plst);

    virtual void SetTitle( LPCTSTR lpszTitle );

protected:
    void OnQuartzAbortStop();

    // message callback functions
    //{{AFX_MSG(CBoxNetDoc)
    afx_msg void OnFileRender();
    afx_msg void OnURLRender();
    afx_msg void OnUpdateFileRender(CCmdUI*);
    afx_msg void OnUpdateURLRender(CCmdUI *);
    afx_msg void OnUpdateFileSave(CCmdUI*);
    afx_msg void OnEditUndo();
    afx_msg void OnEditRedo();
    afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
    afx_msg void OnEditSelectAll();
    afx_msg void OnUpdateEditSelectAll(CCmdUI* pCmdUI);
    afx_msg void OnQuartzDisconnect();
    afx_msg void OnQuartzRun();
    afx_msg void OnUpdateQuartzDisconnect(CCmdUI* pCmdUI);
    afx_msg void OnWindowRefresh();
    afx_msg void OnWindowZoom25()  { OnWindowZoom(25,  ID_WINDOW_ZOOM25); }
    afx_msg void OnWindowZoom50()  { OnWindowZoom(50,  ID_WINDOW_ZOOM50); }
    afx_msg void OnWindowZoom75()  { OnWindowZoom(75,  ID_WINDOW_ZOOM75); }
    afx_msg void OnWindowZoom100() { OnWindowZoom(100, ID_WINDOW_ZOOM100); }
    afx_msg void OnWindowZoom150() { OnWindowZoom(150, ID_WINDOW_ZOOM150); }
    afx_msg void OnWindowZoom200() { OnWindowZoom(200, ID_WINDOW_ZOOM200); }
    afx_msg void OnViewSeekBar();
    afx_msg void OnUpdateQuartzRun(CCmdUI* pCmdUI);
    afx_msg void OnUpdateQuartzPause(CCmdUI* pCmdUI);
    afx_msg void OnUpdateQuartzStop(CCmdUI* pCmdUI);
    afx_msg void OnQuartzStop();
    afx_msg void OnQuartzPause();
    afx_msg void OnUpdateUseClock(CCmdUI* pCmdUI);
    afx_msg void OnUseClock();
    afx_msg void OnUpdateConnectSmart(CCmdUI* pCmdUI);
    afx_msg void OnConnectSmart();
    afx_msg void OnUpdateAutoArrange(CCmdUI* pCmdUI);
    afx_msg void OnAutoArrange();
    afx_msg void OnSaveGraphAsHTML();
    afx_msg void OnSaveGraphAsXML();
    afx_msg void OnConnectToGraph();
    afx_msg void OnGraphStats();
    afx_msg void OnGraphAddFilterToCache();
    afx_msg void OnUpdateGraphAddFilterToCache(CCmdUI* pCmdUI);
    afx_msg void OnGraphEnumCachedFilters();
    //}}AFX_MSG

    afx_msg void OnInsertFilter();

    // -- Pin properties menu --
    afx_msg void OnUpdateQuartzRender(CCmdUI* pCmdUI);
    afx_msg void OnQuartzRender();

    afx_msg void OnUpdateReconnect( CCmdUI* pCmdUI );
    afx_msg void OnReconnect( void );

    DECLARE_MESSAGE_MAP()

    // --- Quartz Stuff ---
public:
    void OnGraphEnumCachedFiltersInternal( void );

    IGraphBuilder  *IGraph(void) const {
        ASSERT(m_pGraph);
        return (*m_pGraph).operator IGraphBuilder*();
    }
    IMediaEvent *IEvent(void) const {
        ASSERT(m_pMediaEvent);
        return (*m_pMediaEvent).operator IMediaEvent *();
    }

    void OnWM_USER(NetDocUserMessage *);
    HRESULT UpdateFilters(void);
    void UpdateFiltersInternal(void);
    void      SelectedSocket(CBoxSocket *psock) { m_psockSelected = psock; }
    CBoxSocket    *SelectedSocket(void) { ASSERT_VALID(m_psockSelected); return m_psockSelected; }
    void      CurrentPropObject(CPropObject *pPropObject) { m_pCurrentPropObject = pPropObject; }
    CPropObject   *CurrentPropObject(void) { ASSERT(m_pCurrentPropObject); return m_pCurrentPropObject; }

    // Unknown state used after failure of Play, Pause or Stop. In this
    // case some filters might have changed state while others haven't.
    enum State { Playing, Paused, Stopped, Unknown };


    BOOL      IsStopped(void) { return m_State == Stopped; }
    State     GetState(void) { return m_State; }

    static const int m_iMaxInsertFilters;   // the maximum length of the insert menu
                            // need hard coded restriction for message map
    BOOL        m_fConnectSmart;        // true -> use Connect
                                        // false -> use ConnectDirect
    BOOL        m_fAutoArrange;         // true -> re-arrange graph view on refresh
                                        // false -> don't re-arrange graph view
    BOOL        m_fRegistryChanged;     // true -> registry has changed since last insert filters
                                        // false -> registry hasn't changed
    //
    // Array which holds the three Handles passed to the thread.
    // 1 = event handle for EC_ notifications,
    // 2 = event handle to terminate thread,
    // 3 = event handle to registry change
    //
    HANDLE  m_phThreadData[3];

    // The window our thread posts a message to
    HWND        m_hWndPostMessage;

    void SetSelectClock(CBox *pBox);  // Notification of which clock was selected
    void UpdateClockSelection();


    void ConnectToGraph();

    void PrintGraphAsHTML(HANDLE hFile);

    HRESULT ProcessPendingReconnect( void );
    HRESULT StartReconnect( IGraphBuilder* pFilterGraph, IPin* pOutputPin );

private:

    BOOL    CreateGraphAndMapper(void);

    CQCOMInt<IGraphBuilder> *m_pGraph;
    CQCOMInt<IMediaEvent>       *m_pMediaEvent;
    IStream                     *m_pMarshalStream;

    CBoxSocket  *m_psockSelected;   // the socket the user last right clicked on.
    CPropObject *m_pCurrentPropObject;  // the property object the user last right clicked on

    HRESULT GetFiltersInGraph(void);
    HRESULT GetLinksInGraph(void);  
    HRESULT FilterDisplay(void);
    void    SetBoxesHorizontally(void);
    void    SetBoxesVertically(void);
    void    RealiseGrid(void);

    void WriteString(HANDLE hFile, LPCTSTR lpctstr, ...);

    void PrintFilterObjects(HANDLE hFile, TCHAR atchBuffer[], FILTER_INFO_TABLE *pfit);
    void PopulateFIT(HANDLE hFile, IFilterGraph *pGraph, TCHAR atchBuffer[],
            FILTER_INFO_TABLE *pfit);
    BOOL GetNextOutFilter(FILTER_INFO_TABLE &fit, int *iOutFilter);
    int LocateFilterInFIT(FILTER_INFO_TABLE &fit, IBaseFilter *pFilter);
    void MakeScriptableFilterName(WCHAR awch[], BOOL bSourceFilter);

    HRESULT SafePrintGraphAsHTML( HANDLE hFile );
    HRESULT SafeEnumCachedFilters( void );

    State   m_State;

    // Handle to the thread
    HANDLE      m_hThread;

    BOOL    m_fUsingClock;          // true (default) if using the default clock

    TCHAR m_tszStgPath[MAX_PATH];  // remember the path to our storage
    CString m_strHTMLPath; // remember the last html doc we saved
    CString m_strXMLPath; // remember the last html doc we saved
    long m_lSourceFilterCount; // Append digits to source filter names to make them unique


    // Internal Reconnect Functions.
    enum ASYNC_RECONNECT_FLAGS
    {
        ASYNC_RECONNECT_NO_FLAGS = 0,
        ASYNC_RECONNECT_UNBLOCK = 1
    };

    HRESULT EndReconnect( IGraphBuilder* pFilterGraph, IPinFlowControl* pDynamicOutputPin );
    HRESULT EndReconnectInternal( IGraphBuilder* pFilterGraph, IPinFlowControl* pDynamicOutputPin );
    void ReleaseReconnectResources( ASYNC_RECONNECT_FLAGS arfFlags );

public:
    bool AsyncReconnectInProgress( void ) const;

private:
    HANDLE m_hPendingReconnectBlockEvent;
    CComPtr<IPinFlowControl> m_pPendingReconnectOutputPin;
};

// Our message number
#define WM_USER_EC_EVENT WM_USER + 73


// a CRect's width or height must not exceed 0x8000
#define MAX_DOCUMENT_SIZE 32767
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\box.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// box.h : declares CBoxTabPos, CBoxSocket, CBox
//

// forward declarations
class CBox;
class CBoxLink;
class CBoxNetDoc;

extern void AttemptFileOpen(IBaseFilter *m_pFilter);


/////////////////////////////////////////////////////////////////////////////
// CBoxTabPos
//
// A value of this class represents the position of a box tab along the edge
// of a box.  (A box tab is the graphical representation of a box network
// socket.)  The position is represented as a fraction of the length of the
// edge, so that resizing the box will retain the tab's relative position.
//
// To use CBoxTabPos:
//   -- <m_fLeftRight> is set to TRUE if the tab is on the left or right edge
//      of the box, FALSE if the tab is on the top or the bottom edge.
//   -- <m_fLeftTop> is set to TRUE if the tab is on the left or top edge
//      of the box, FALSE if the tab is on the right or bottom edge.
//   -- SetPos(uiVal, uiValMax) sets the position of the tab to be the fraction
//      (uiVal/uiValMax) of the way along the edge.
//   -- GetPos(uiValMax) returns a value <uiVal> such that the tab is
//      (uiVal/uiValMax) of the way along the edge.
//   -- Package() packages a CBoxTabPos into a form acceptable to the CArchive
//      << and >> operators.
// Internally, a CBoxTabPos is represented as two flags plus a CBTP_BITS-bit
// number that represents the tab position along the inside edge of the box,
// scaled to be in the range 0 to 1<<CBTP_BITS, (inclusive -- to allow 1.0
// to be representable).
//
// A simple way to create a CBoxTabPos is via a constructor, e.g.
//      CBoxTabPos pos(CBoxTabPos::TOP_EDGE, 2, 3); // 2/3rds across top edge
//

class CBoxTabPos
{

protected:
    // private constants
    enum {CBTP_BITS = 13};      // no. bits of precision in <m_ulPos>

public:
    // identify a box edge
    enum EEdge
    {
        BOTTOM_EDGE = 0, // m_fLeftRight=FALSE, m_fLeftTop=FALSE
        TOP_EDGE    = 1, // m_fLeftRight=FALSE, m_fLeftTop=TRUE
        RIGHT_EDGE  = 2, // m_fLeftRight=TRUE,  m_fLeftTop=FALSE
        LEFT_EDGE   = 3 // m_fLeftRight=TRUE,  m_fLeftTop=TRUE
    };

public:
    // which side of box is tab on?
    BOOL        m_fLeftRight:1; // tab is on left or right edge of box
    BOOL        m_fLeftTop:1;   // tab is on left or top edge of box

protected:
    // how far along the edge is the tab?
    unsigned    m_ulPos:CBTP_BITS+1; // position along edge (0 == top/left end)

public:
    // construction
    CBoxTabPos() {};
    CBoxTabPos(EEdge eEdge, unsigned uiVal, unsigned uiValMax)
        { m_fLeftRight = fnorm(eEdge & 2);
          m_fLeftTop = fnorm(eEdge & 1);
          SetPos(uiVal, uiValMax); }

public:
    // operations
    void SetPos(unsigned uiVal, unsigned uiValMax)
        { m_ulPos = (unsigned) (((long) uiVal << CBTP_BITS) / uiValMax); }
    unsigned GetPos(unsigned uiValMax)
        { return (int) (((long) m_ulPos * uiValMax) >> CBTP_BITS); }

public:
    // convert object to a WORD reference (for easier serialization)
    WORD & Package() { return (WORD &) *this; }

#ifdef _DEBUG
    virtual void Dump(CDumpContext& dc) const {
        dc << "Left: " <<  m_fLeftTop  << "m_ulPos: " << m_ulPos << "\n";
    }

#endif // _DEBUG
};


/////////////////////////////////////////////////////////////////////////////
// CBoxSocket
//
// Logically, a socket is a place on a CBox that you can connect a link to.
// (A link connects a socket on one box to a socket on another box.)
//
//
// A CBoxSocket object contains a pointer <m_pbox> back to the parent box,
// and a pointer <m_plink> to the link that connects the socket to another
// socket (or NULL if the socket is not currently linked).  <m_stLabel> is
// a string label, and <m_tabpos> indicates where on the box the tab
// (the visual reprentation of the socket) and the label should be placed.
//

class CBoxSocket : public CPropObject {

public:
    // pointer back to parent box, pointer to connected link (if any)
    CBox	*m_pbox;             // box that contains socket
    CBoxLink	*m_plink;            // link connected to the socket (or NULL)

    CBox *pBox(void) const { return m_pbox; };

public:
    // socket user interface
    CString     m_stLabel;          // socket label

    CString	Label(void) const { return m_stLabel; }
    void	Label(CString st) { m_stLabel = st; }

    CBoxTabPos  m_tabpos;           // socket tab position along an edge

    // -- Quartz --


    IPin	*pIPin(void) const { return m_IPin; }	// NB not addref'd
    IUnknown	*pUnknown(void) const { return m_IPin; }	// NB not addref'd
    CBoxSocket	*Peer(void);
    BOOL	IsConnected(void);
    PIN_DIRECTION	GetDirection(void);

private:

    CQCOMInt<IPin>	m_IPin;		// The pin this socket minds.

    friend class CBox;

public:
    // construction
    CBoxSocket(const CBoxSocket& sock, CBox *pbox);
    CBoxSocket( CBox *pbox
              , CString stLabel
              , CBoxTabPos::EEdge eEdge
              , unsigned uiVal
              , unsigned uiValMax
              , IPin *pPin);
    ~CBoxSocket();

public:

    #ifdef _DEBUG
    
    // diagnostics
    virtual void Dump(CDumpContext& dc) const
    {
        CPropObject::Dump(dc);
        dc << m_stLabel << "\n";

        m_tabpos.Dump(dc);
    }

    void MyDump(CDumpContext& dc) const;

    virtual void AssertValid(void) const;
    
    #endif // _DEBUG

private:
    CBoxSocket(const CBoxSocket&); // the plain copy constructor is not allowed
};


// *
// * CBoxSocketList
// *

// Provides a way of getting a socket via an IPin

class CBoxSocketList : public CDeleteList<CBoxSocket *, CBoxSocket *> {
public:

    CBoxSocket *GetSocket(IPin *pPin) const;
    BOOL	IsIn(IPin *pPin) const { return (GetSocket(pPin) != NULL); }
};


/////////////////////////////////////////////////////////////////////////////
// CBox
//
// A box is a node in a box network.  Boxes contain sockets (CBoxSocket
// objects); sockets of different boxes may be connected using a CBoxLink.
//
// A CBox object contains a list <m_lstSockets> of CBoxSocket objects,
// a bounding rectangle <m_rcBound> which locates the box in its container,
// and a string label.
//
// A box also contains a flag <m_fSelected> indicating whether or not the
// box is selected.  This implies that box selection is an attribute of a
// document (containing boxes), not an attribute of a view onto such a
// document.
//
// A box manages a single Quartz Filter.

class CBox : public CPropObject {

    // -- box user interface --
    CRect       m_rcBound;          // box bounding rectangle

//#define ZOOM(x) ((x) * s_Zoom / 100)    
//#define UNZOOM(x) ((x) * 100 / s_Zoom)
    
#define ZOOM(x) ((int) ((float) (x) * (float) s_Zoom / 100.0))    
#define UNZOOM(x) ((int) ((float) (x) * 100.0 / (float) s_Zoom))


public:
    static int s_Zoom;

    static void SetZoom(int iZoom);
    
    CRect   GetRect() const { return CRect(ZOOM(m_rcBound.left),  ZOOM(m_rcBound.top),
                                           ZOOM(m_rcBound.right), ZOOM(m_rcBound.bottom)); }
 
    CPoint	Location(void) const { return CPoint(ZOOM(m_rcBound.left), ZOOM(m_rcBound.top)); }
    void	Location(CPoint pt) { X(pt.x); Y(pt.y); }

    int		nzX(void) const { return m_rcBound.left; }
    void	nzX(int x) { m_rcBound.SetRect(x, m_rcBound.top, m_rcBound.Width() + x, m_rcBound.bottom); }

    int		X(void) const { return ZOOM(m_rcBound.left); }
    int		Y(void) const { return ZOOM(m_rcBound.top); }

    void	X(int x) { m_rcBound.SetRect(UNZOOM(x), m_rcBound.top, m_rcBound.Width() + UNZOOM(x), m_rcBound.bottom);  }
    void	Y(int y) { m_rcBound.SetRect(m_rcBound.left, UNZOOM(y), m_rcBound.right, m_rcBound.Height() + UNZOOM(y)); }


    void    Move(CSize siz) { m_rcBound.OffsetRect(UNZOOM(siz.cx), UNZOOM(siz.cy)); }
    int		Width(void) const { return ZOOM(m_rcBound.Width()); }
    int		Height(void) const { return ZOOM(m_rcBound.Height()); }

    CString     m_stLabel;          // box label
    CString     m_stFilter;         // filter name

    void	Label(CString st) { m_stLabel = st; }
    CString	Label(void) const { return m_stLabel; }

    void	SetSelected(BOOL fSelected) { m_fSelected = fSelected; }
    BOOL	IsSelected(void) { return m_fSelected; }

    // CPropObject overrides - distribute requests to our sockets
    virtual void ShowDialog();
    virtual void HideDialog();

    BOOL        HasClock() { return m_fHasClock; }
    BOOL        HasSelectedClock() { return m_fClockSelected; }

private:
    BOOL        m_fSelected;        // box is selected?
    BOOL        m_fHasClock;
    BOOL        m_fClockSelected; // this filters clock is the current one


    // -- Automatic layout helpers --
public:
    void	CalcRelativeY(void);	// y position relative to input peers
    float	RelativeY(void) const { return m_RelativeY; }

private:

    float	m_RelativeY;


    // -- Quartz --
public:

    CBoxNetDoc	*pDoc(void) const {ASSERT(m_pDoc); return m_pDoc;}
    IBaseFilter	*pIFilter(void) const { return m_IFilter; } 	// NB not addref'd
    IUnknown	*pUnknown(void) const { return m_IFilter; }	// NB not addref'd

    HRESULT	Refresh(void);

    HRESULT	AddToGraph(void);
    HRESULT	RemoveFromGraph(void);

private:

    CQCOMInt<IBaseFilter>	m_IFilter;	    // While this box exists the filter is instantiated
    LONG		m_lInputTabPos;
    LONG		m_lOutputTabPos;
    int			m_iTotalInput;
    int			m_iTotalOutput;
    CBoxNetDoc		*m_pDoc;

    void CalcTabPos(void);
    void UpdateSockets(void);


    // -- construction and destruction --
public:

    CBox(const CBox& box);    // copy constructor
    CBox(IBaseFilter *pFilter, CBoxNetDoc *pDoc);
    CBox(IBaseFilter *pFilter, CBoxNetDoc *pDoc, CString *pName, CPoint point = CPoint(-1, -1));
    ~CBox();


    // -- operations --
public:

    void AddSocket(CString stLabel, CBoxTabPos::EEdge eEdge,
        unsigned uiVal, unsigned uiValMax, IPin *pPin);
    HRESULT RemoveSocket(POSITION, BOOL bForceIt = FALSE);

    BOOL operator==(const CBox& box) const;
    BOOL operator!=(const CBox& box) const { return !(*this == box); }

    // return the socket managing this pin
    CBoxSocket *GetSocket(IPin *pPin) { return m_lstSockets.GetSocket(pPin); }

    void GetLabelFromFilter( CString *pstLabel );


    // -- Diagnostics --
public:
#ifdef _DEBUG
    virtual void Dump(CDumpContext& dc) const;
    void MyDump(CDumpContext& dc) const;

    virtual void AssertValid(void) const;
#endif // _DEBUG

private:
    // sockets to hold connections to other boxes
    CBoxSocketList   m_lstSockets;       // list of CBoxSocket objects

    friend class CSocketEnum;	// iterates each socket in turn
    friend class CBoxNetDoc;    // to update m_fClockSelected
};



// *
// * CBoxList
// *

// A list where you can find elements by IBaseFilter
class CBoxList : public CDeleteList<CBox *, CBox *> {

public:

    CBoxList(BOOL bDestructDelete = TRUE) : CDeleteList<CBox *, CBox *>(bDestructDelete) {}
    CBoxList(BOOL bDestructDelete, int nBlockSize) : CDeleteList<CBox *, CBox *>(bDestructDelete, nBlockSize) {}

    BOOL IsIn(IBaseFilter *pFilter) const;	// is one of the boxes in this list managing
    					// this filter?
    CBox *GetBox(IBaseFilter *pFilter) const;
    CBox *GetBox(CLSID clsid) const;

    BOOL RemoveBox( IBaseFilter* pFilter, CBox** ppBox );

#ifdef _DEBUG
    virtual void Dump(CDumpContext& dc) const;
#endif // _DEBUG

};


// *
// * CSocketEnum
// *

// Returns each socket on this box, one by one. returns NULL
// when there are no more sockets.
// Can return a specific direction (input or output)
class CSocketEnum {
public:

    enum DirType {Input, Output, All};

    CSocketEnum(CBox *pbox, DirType Type = All);
    ~CSocketEnum() {};

    CBoxSocket *operator() (void);

private:

    CBox	*m_pbox;
    POSITION	m_pos;
    DirType	m_Type;
    PIN_DIRECTION	m_EnumDir;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\box.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
//
// box.cpp : defines CBoxTabPos, CBoxSocket, CBox
//

#include "stdafx.h"
#include <streams.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

int CBox::s_Zoom = 100;

void CBox::SetZoom(int iZoom) {
    s_Zoom = iZoom;
    gpboxdraw->RecreateFonts();
}


// these lines copied from SDK\CLASSES\BASE\FILTER.H
#define QueryFilterInfoReleaseGraph(fi) if ((fi).pGraph) (fi).pGraph->Release();
#define QueryPinInfoReleaseFilter(pi) if ((pi).pFilter) (pi).pFilter->Release();

// *
// * CBoxSocket
// *

//
// 'Copy' Constructor
//
// Duplicate this socket, inc. addref of the IPin
// It only makes sense to copy a socket onto a new box, so
// we need a CBox * as well.
CBoxSocket::CBoxSocket(const CBoxSocket& sock, CBox *pbox)
    : m_pbox(pbox)
    , m_plink(NULL)                     // no links copied.
    , m_stLabel(sock.m_stLabel)
    , m_tabpos(sock.m_tabpos)
    , m_IPin(sock.m_IPin) {

   ASSERT(*m_pbox != *pbox);

   ASSERT_VALID(this);

}


//
// Constructor
//
CBoxSocket::CBoxSocket(CBox *pbox,
                       CString stLabel,
                       CBoxTabPos::EEdge eEdge,
                       unsigned uiVal,          // positon as fraction
                       unsigned uiValMax,       // along edge uiVal/uiValMax
                       IPin *pPin)
    : m_pbox(pbox),
      m_stLabel(stLabel),
      m_tabpos(eEdge, uiVal, uiValMax),
      m_plink(NULL),
      m_IPin(pPin) {

    ASSERT_VALID(this);

}


//
// Destructor
//
CBoxSocket::~CBoxSocket() {

    ASSERT_VALID(this);

}

#ifdef _DEBUG
//
// AssertValid
//
void CBoxSocket::AssertValid(void) const {

    CPropObject::AssertValid();

    ASSERT(m_pbox);

}
#endif // _DEBUG

//
// GetDirection
//
PIN_DIRECTION CBoxSocket::GetDirection(void) {

    HRESULT hr;

    PIN_DIRECTION pd;
    hr = pIPin()->QueryDirection(&pd);
    if (FAILED(hr)) {
        throw CHRESULTException(hr);
    }

    ASSERT( (pd == PINDIR_INPUT) || (pd == PINDIR_OUTPUT) );

    return pd;
}


//
// IsConnected
//
BOOL CBoxSocket::IsConnected(void) {

    HRESULT hr;
    IPin *pConnected;
    hr = pIPin()->ConnectedTo(&pConnected);
    if (FAILED(hr)) {   // not connected.
        ASSERT(m_plink == NULL);
        return FALSE;
    }
    else if (hr == S_OK) {
        pConnected->Release();
        return TRUE;
    }
    else {
        TRACE("ConnectedTo Error\n");
        throw CHRESULTException(hr);
        return FALSE;   // need this to keep the compiler happy...
    }
}


//
// Peer
//
// return the socket this is connected to.
// only valid if connected.
// returns null in error case.
CBoxSocket *CBoxSocket::Peer(void) {

    IPin *pConnected;
    HRESULT hr = pIPin()->ConnectedTo(&pConnected);
    if(FAILED(hr)) {
       return NULL;     // should only fail if not connected
    }

    PIN_INFO piPeer;
    hr = pConnected->QueryPinInfo(&piPeer);
    if (FAILED(hr)) {
        pConnected->Release();
        return NULL;
    }

    CBox *pbox = m_pbox->pDoc()->m_lstBoxes.GetBox(piPeer.pFilter);
    QueryPinInfoReleaseFilter(piPeer);
    if (pbox == NULL) {
        pConnected->Release();
        return NULL;
    }

    CBoxSocket *pSocket = pbox->GetSocket(pConnected);
    pConnected->Release();
    return pSocket;
}


// *
// * CBoxSocketList
// *

//
// GetSocket
//
// Return the socket on this list that manages this pin. Return
// NULL if not present.
CBoxSocket *CBoxSocketList::GetSocket(IPin *pPin) const {

    POSITION pos = GetHeadPosition();

    while (pos != NULL) {

        CBoxSocket *psock = GetNext(pos);
        if ( CIPin(pPin) == CIPin(psock->pIPin()) )
            return psock;

    }

    return NULL;
}


// *
// * CBox
// *

//
// Copy Constructor
//
CBox::CBox(const CBox& box)
    : m_fSelected(box.m_fSelected)
    , m_fHasClock(box.m_fHasClock)
    , m_fClockSelected(FALSE)
    , m_IFilter(box.m_IFilter)
    , m_rcBound(box.m_rcBound)
    , m_stLabel(box.m_stLabel)
    , m_pDoc(box.m_pDoc)
    , m_RelativeY(box.m_RelativeY)
    , m_lInputTabPos(box.m_lInputTabPos)
    , m_lOutputTabPos(box.m_lOutputTabPos)
    , m_iTotalInput(box.m_iTotalInput)
    , m_iTotalOutput(box.m_iTotalOutput) {

    POSITION posNext = box.m_lstSockets.GetHeadPosition();

    while (posNext != NULL) {

        CBoxSocket *psock = (CBoxSocket *) box.m_lstSockets.GetNext(posNext);
        CBoxSocket *psockNew = new CBoxSocket(*psock, this);
        m_lstSockets.AddTail(psockNew);
    }
}


//
// CBox::Constructor
//
CBox::CBox(IBaseFilter *pFilter, CBoxNetDoc *pDoc, CString *pName, CPoint point)
    : m_IFilter(pFilter)
    , m_fSelected(FALSE)
    , m_fClockSelected(FALSE)
    , m_pDoc(pDoc)
    , m_rcBound(point, CSize(0,0))
    , m_RelativeY(0.0f)
{

    //
    // Do we have a IReferenceClock
    //
    IReferenceClock * pClock;
    HRESULT hr = pIFilter()->QueryInterface(IID_IReferenceClock, (void **) &pClock);
    m_fHasClock = SUCCEEDED(hr);
    if (SUCCEEDED(hr)) {
        pClock->Release();
    }

    m_stFilter = *pName;

    // See if this filter needs a file opening
    // needs a better soln - what about other interfaces?
    AttemptFileOpen(pIFilter());

    GetLabelFromFilter( &m_stLabel );
    UpdateSockets();

    //
    // If point was not (-1, -1) then we can exit now.
    //
    if ((point.x != -1) || (point.y != -1)) {
        return;
    }

    //
    // We need to place the box out of the way from other boxes in the
    // view.
    //

    CWnd *pWnd;
    CScrollView * pScrollView;
    {
        // Get the only view from the document and recast it into a CWnd.
        // the view.
        POSITION pos = pDoc->GetFirstViewPosition();
        ASSERT(pos);

        pScrollView = (CScrollView *) pDoc->GetNextView(pos);
        pWnd = (CWnd *) pScrollView;
        ASSERT(!pos);
    }

    // Get the dimension of the window in device units.
    RECT rectWndSize;
    pWnd->GetClientRect(&rectWndSize);

    // Use the DC to convert from device units to logical units
    CDC * pDC   = pWnd->GetDC();
    pDC->DPtoLP(&rectWndSize);
    pWnd->ReleaseDC(pDC);

    //
    // Place the box at the bottom of the window minus the size of the box
    // minus a bit. Note that the window size equals to the size needed to
    // contain all filters.
    //
    int newPosition = rectWndSize.bottom - Height();

    if (newPosition < 0) {
        newPosition = 0;
    }

    //
    // If there are no filters above us, we can move further up.
    //
    CSize pSize = pScrollView->GetTotalSize();
    CPoint pt = pScrollView->GetScrollPosition();

    if (newPosition > pSize.cy) {
        newPosition = pSize.cy;
    }

    Location(CPoint(pt.x, newPosition));
}

//
// Constructor(IBaseFilter *)
//
CBox::CBox(IBaseFilter *pFilter, CBoxNetDoc *pDoc)
    : m_pDoc(pDoc)
    , m_IFilter(pFilter)
    , m_fSelected(FALSE)
    , m_fClockSelected(FALSE)
    , m_rcBound(0,0,0,0)
{

    //
    // Do we have a IReferenceClock
    //
    IReferenceClock * pClock;
    HRESULT hr = pIFilter()->QueryInterface(IID_IReferenceClock, (void **) &pClock);
    m_fHasClock = SUCCEEDED(hr);
    if (SUCCEEDED(hr)) {
        pClock->Release();
    }

    GetLabelFromFilter( &m_stLabel );

    UpdateSockets();
}

// CBox::GetFilterLabel
//
// Get the filters name from the filter or the registry
//
void CBox::GetLabelFromFilter( CString *pstLabel )
{
    // Try and get the filter name
    if (m_stFilter == "") {
        FILTER_INFO fi;
        m_IFilter->QueryFilterInfo( &fi );
        QueryFilterInfoReleaseGraph( fi );

        if ((fi.achName != NULL) && (fi.achName[0] != 0)) {
            // the filter has a name
            m_stFilter = CString( fi.achName );
        }
        else {
            // If that lot failed attempt to get the name from the ClsID
            // get the name through the clsid
            CLSID clsidTemp;
            m_IFilter->GetClassID(&clsidTemp);
            WCHAR szGuid[40];
            StringFromGUID2(clsidTemp, szGuid, 40 );
            m_stFilter = szGuid;
        }
    }

    // Try and get the box label (either the filter name
    // or the filename of the source/sink file)
    if (*pstLabel != m_stFilter) {
        IFileSourceFilter *pIFileSource;
        IFileSinkFilter *pIFileSink;
        BOOL bSource, bSink, bGotLabel = FALSE;
        LPOLESTR poszName;
        AM_MEDIA_TYPE mtNotUsed;

        bSource = SUCCEEDED(m_IFilter->QueryInterface(IID_IFileSourceFilter, (void **) &pIFileSource));
        bSink   = SUCCEEDED(m_IFilter->QueryInterface(IID_IFileSinkFilter, (void **) &pIFileSink));

        ASSERT( bSource || !pIFileSource );
        ASSERT( bSink   || !pIFileSink   );

        // If we have a source but no sink attempt to get the source filename
        if( bSource && !bSink ){
            if (SUCCEEDED(pIFileSource->GetCurFile(&poszName, &mtNotUsed)) && poszName){
                *pstLabel = (LPCWSTR) poszName;
                CoTaskMemFree(poszName);
                bGotLabel = TRUE;
            }
        } else if( bSink && !bSource ){
            // Else if we have a sink but no ssource attempt to get the sink filename
                if (SUCCEEDED(pIFileSink->GetCurFile(&poszName, &mtNotUsed)) &&
                    poszName){
                *pstLabel = (LPCWSTR) poszName;
                CoTaskMemFree(poszName);
                bGotLabel = TRUE;
            }
        }

        // If a label was set, remove the path of the source/sink filename
        if (bGotLabel)
        {
            CString str(*pstLabel);   // Copy the label
            TCHAR ch=TEXT('\\');

            str.MakeReverse();        // Reverse string
            int nSlash = str.Find(ch);// Look for '\' path character
            if (nSlash != -1)
            {
                ch = TEXT('\0');
                str.SetAt(nSlash, ch);  // Null-terminate
               
                str.MakeReverse();      // Return to original order
                int nLength = str.GetLength();
                str.Delete(nSlash, nLength - nSlash);

                *pstLabel = str;        // Copy new string to original
                pstLabel->FreeExtra();
            }
        }

        if( pIFileSource ) pIFileSource->Release();
        if( pIFileSink   ) pIFileSink  ->Release();

        if (!bGotLabel) {
            *pstLabel = m_stFilter;
        }
    }
}


//
// Destructor
//
CBox::~CBox() {

    //
    // Remove all Sockets from out box
    //
    while ( NULL != m_lstSockets.GetHeadPosition() ) {
        RemoveSocket( m_lstSockets.GetHeadPosition(), TRUE );
    }

    HideDialog();

    TRACE("~CBox: %x\n", this);

}


//
// Refresh
//
// re-calculate the sockets we need if the pins have changed
HRESULT CBox::Refresh(void) {

    // update box's label (properties may have changed it)
    GetLabelFromFilter(&m_stLabel);

    try {

        UpdateSockets();
    }
    catch (CHRESULTException chr) {
        return chr.Reason();
    }

    return NOERROR;
}


//
// CBox::operator==
//
BOOL CBox::operator==(const CBox& box) const {

    ASSERT_VALID(&box);
    ASSERT_VALID(this);

    // need to make a meaningful descision about socket list
    // equality.

    return (  (m_rcBound       == box.m_rcBound)
            &&(m_IFilter       == (IUnknown *)box.m_IFilter)
            &&(m_stLabel       == box.m_stLabel)
            &&(m_lInputTabPos  == box.m_lInputTabPos)
            &&(m_lOutputTabPos == box.m_lOutputTabPos)
            &&(m_pDoc          == box.m_pDoc)
           );
}


//
// AddToGraph
//
// Adds this filter to the graph
HRESULT CBox::AddToGraph(void) {

    ASSERT(m_pDoc);
    ASSERT(pIFilter());

    TRACE("Adding filter (@: %x)\n", pIFilter());

    // Add the filter. Use it's own name (not our label) as its name
#ifdef _UNICODE
    HRESULT hr = m_pDoc->IGraph()->AddFilter(pIFilter(), (LPCTSTR) m_stFilter);
#else
    WCHAR wszName[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR) m_stFilter, -1, wszName, MAX_PATH);

    HRESULT hr = m_pDoc->IGraph()->AddFilter(pIFilter(), wszName);
#endif

    if (FAILED(hr)) {
        TRACE("Failed to add filter (@: %x)\n", pIFilter());
        return hr;
    }

    return NOERROR;
}


//
// RemoveFromGraph
//
// Removes filter from graph
HRESULT CBox::RemoveFromGraph(void) {

    TRACE("Removing Filter (@: %x)\n", pIFilter());

    ASSERT(m_pDoc);
    ASSERT(pIFilter());

    return m_pDoc->IGraph()->RemoveFilter(pIFilter());

}


//
// CalcTabPos
//
// Decide how many socket positions to have on box edge
void CBox::CalcTabPos(void) {

    PIN_INFO   pi;              // Information about each pin
    IPin      *pPin;            // Holds next pin obtained
    CPinEnum  NextInput(pIFilter(), CPinEnum::Input);   // Pin enumerator

    int iMaxOutputLabel = 0;  // biggest size of output pin names
    int iMaxInputLabel = 0;   // biggest size of input pin names

    m_iTotalInput = m_iTotalOutput = 0;
    m_lInputTabPos = m_lOutputTabPos = 0;

    while (0 != (pPin = NextInput())) {
        m_iTotalInput++;

        if (!FAILED(pPin->QueryPinInfo(&pi))) {
            iMaxInputLabel = max(iMaxInputLabel, (int) wcslen(pi.achName));
            QueryPinInfoReleaseFilter(pi);
        }

        pPin->Release();
    }

    CPinEnum  NextOutput(pIFilter(), CPinEnum::Output); // Pin enumerator
    while (0 != (pPin = NextOutput())) {
        m_iTotalOutput++;

        if (!FAILED(pPin->QueryPinInfo(&pi))) {
            iMaxOutputLabel = max(iMaxOutputLabel, (int) wcslen(pi.achName));
            QueryPinInfoReleaseFilter(pi);
        }

        pPin->Release();
    }

    m_lInputTabPos = m_iTotalInput;
    m_lOutputTabPos = m_iTotalOutput;

    // looks better if there are an even no of pin positions....
    if (m_lInputTabPos % 2 == 1)
        m_lInputTabPos++;

    if (m_lOutputTabPos % 2 == 1)
        m_lOutputTabPos++;

    // set the box size appropriately
    // inflate the rectangle by the differnce between the old height
    // and width and the new dimentions.

    // X should be at least 100 and be able to hold the name of the box
    // and the names of all pins.
    //
    // Note + 20 and + 30 are gaps, so that the labels don't glue to the
    // border.
    //
    int iNewXSize = max ((iMaxOutputLabel + iMaxInputLabel) * 6 + 20, 100);
    iNewXSize = max (iNewXSize, 10*m_stLabel.GetLength() + 30);

    int IncreaseXBy = iNewXSize - m_rcBound.Width();
    int IncreaseYBy = 60 + 20 * max(m_lInputTabPos, m_lOutputTabPos) - m_rcBound.Height();

    CPoint NewBottomRight(m_rcBound.BottomRight().x + IncreaseXBy,
                          m_rcBound.BottomRight().y + IncreaseYBy);

    m_rcBound.SetRect( m_rcBound.TopLeft().x
                     , m_rcBound.TopLeft().y
                     , NewBottomRight.x
                     , NewBottomRight.y
                     );
}


//
// UpdateSockets
//
// Updates the set of sockets to match the pins on this filter
void CBox::UpdateSockets(void) {

    CalcTabPos();

    //
    // Pins might be removed from the filter due to some other deletions.
    // The sockets associated to pins that disappeared must also be removed.
    //
    // We can only determine which pins are still present by enumerating
    // all and comparing them with our sockets. Because of efficiency we
    // don't want to enumerate all pins for each socket we need to verify.
    //
    // We therefore delete all sockets that represent unconnected pins.
    // Note that there might still be a link associated to the socket and
    // those links are removed as well (since they are obsolete).
    //
    // In the second phase we enumerate all pins and if they don't have
    // already a socket, add their socket to the box.
    //

    //
    // Remove all sockets with unconnected pins.
    //
    POSITION posSocket = m_lstSockets.GetHeadPosition();

    while (posSocket) {
        //
        // Remember the current item, then get the next one
        // then delete the current one.
        // We need to do it this way, because we have to get
        // the next item before we delete the current one.
        //
        POSITION posTemp = posSocket;

        m_lstSockets.GetNext(posSocket);
        RemoveSocket(posTemp); // will only be removed if unconnected pin
    }

    //
    // Now we enumerate all pins of the filter and add sockets for
    // those pins which don't have sockets in this box.
    //
    // Note that pin's of new sockets might be connected, but we
    // are not going to add the links till all boxes have been updated.
    //

    CPinEnum    Next(pIFilter());
    IPin        *pPin;
    int         nInputNow = 0, nOutputNow = 0;

    while (0 != (pPin = Next())) {

        HRESULT hr;
        PIN_INFO pi;
        hr = pPin->QueryPinInfo(&pi);

        if (FAILED(hr)) {
            pPin->Release();
            throw CHRESULTException(hr);
        }
        QueryPinInfoReleaseFilter(pi);

        //
        // We need to increment the input or ouput pin counter even
        // if we don't add the socket.
        //
        if (pi.dir == PINDIR_INPUT) {
            nInputNow++;
        }
        else {
            nOutputNow++;
        }

        //
        // If the pin has already a socket, update its tab.
        // (the box might have changed in size).
        //
        // If there is no socket, then add a new socket.
        //
        if (m_lstSockets.IsIn(pPin)) {
            //
            // Update the position of the pins on the filter.
            //
            CBoxSocket * pSocket = m_lstSockets.GetSocket(pPin);

            if (pi.dir == PINDIR_INPUT) {
                pSocket->m_tabpos.SetPos(nInputNow, 1 + m_lInputTabPos);
            }
            else {
                pSocket->m_tabpos.SetPos(nOutputNow, 1 + m_lOutputTabPos);
            }
        }
        else {
            //
            // we need a new socket
            //
            char achName[100];
            WideCharToMultiByte(CP_ACP, 0,
                                pi.achName, -1,
                                achName, sizeof(achName),
                                NULL, NULL);
        
            if (pi.dir == PINDIR_INPUT) {
                AddSocket(achName,
                          CBoxTabPos::LEFT_EDGE,
                          nInputNow,
                          1 + m_lInputTabPos,
                          pPin);
            }
            else {
                AddSocket(achName,
                          CBoxTabPos::RIGHT_EDGE,
                          nOutputNow,
                          1 + m_lOutputTabPos,
                          pPin);
            }
        }

        pPin->Release();
    }
}


//
// CalcRelativeY
//
// the Y position a box has relative to its upstream connections
void CBox::CalcRelativeY(void) {

    CSocketEnum NextInput(this, CSocketEnum::Input);
    CBoxSocket  *psock;

    m_RelativeY = 0.0f;

    while (0 !=(psock = NextInput())) {

        // !!! still broken
        CBoxSocket *pPeer;
        if (psock->IsConnected() && (pPeer = psock->Peer()) != NULL) {
            m_RelativeY += (pPeer->pBox()->Y() / m_iTotalInput);

            // adjust slightly based on which output pin the connection
            // attaches to on the other side, to avoid crossings
            CSocketEnum NextOutput(pPeer->pBox(), CSocketEnum::Output);
            int         socketNum = 0;
            CBoxSocket *psock2;
            while (0 != (psock2 = NextOutput())) {
                if (psock2 == pPeer) {
                    m_RelativeY += 0.01f * socketNum;
                }
                socketNum++;
            }
        }
    }
}


#ifdef _DEBUG

void CBox::AssertValid(void) const {

    CPropObject::AssertValid();

    ASSERT(pIFilter());
    ASSERT(m_pDoc);

    ASSERT(m_rcBound.Width() > 0);
    ASSERT(m_rcBound.Height() > 0);
}

void CBox::Dump(CDumpContext& dc) const {

    CPropObject::Dump(dc);

    dc << TEXT("x = ") << X() << TEXT(", y = ") << Y() << TEXT("\n");

    dc << TEXT("Name: ") << m_stLabel << TEXT("\n");
    dc << TEXT("IFilter :") << pIFilter() << TEXT("\n");
    dc << m_lstSockets;
}

void CBox::MyDump(CDumpContext& dc) const
{
    dc << TEXT("*** Box ***\n");
    dc << TEXT("    Location: ") << (void *) this << TEXT("\n");
    dc << TEXT("    Name    : ") << m_stLabel << TEXT("\n");
    dc << TEXT("    IBaseFilter : ") << (void *) pIFilter() << TEXT("\n");
    dc << TEXT("    ----- Sockets / Pins -----\n");

    POSITION pos = m_lstSockets.GetHeadPosition();
    while (pos) {
        CBoxSocket * pSocket = m_lstSockets.GetNext(pos);
        pSocket->MyDump(dc);
    }
    dc << TEXT("    ----- (end) ---------------\n");
}

void CBoxSocket::MyDump(CDumpContext& dc) const
{
    dc << TEXT("        Socket at ") << (void *) this    << TEXT("\n");
    dc << TEXT("           - Pin  ") << (void *) pIPin() << TEXT("\n");
    dc << TEXT("           - Link ") << (void *) m_plink << TEXT("\n");
    dc << TEXT("           - Box  ") << (void *) m_pbox  << TEXT("\n");
}

#endif // _DEBUG

//
// RemoveSocket
//
// Remove the socket from the boxes list of sockets.
// Only sockets which have an unconnected pin are allowed to be
// removed. We will also remove any existing link.
//
// If parameter <bForceIt> is true, any connection of the socket's pin
// will be disconnected.
//
// returns:
//  S_OK - Socket was removed
//  S_FALSE - Pin of socket was still connected therefore no removal.
//
HRESULT CBox::RemoveSocket(POSITION posSocket, BOOL bForceIt)
{
    CBoxSocket *pSocket = m_lstSockets.GetAt(posSocket);

    //
    // Test whether the socket's pin is unconnected.
    //
    IPin *pTempPin;
    pSocket->pIPin()->ConnectedTo(&pTempPin);

    if (NULL != pTempPin) {
        //
        // Pin is still connected.
        //

        if (!bForceIt) {
            // we are not allowed to disconnect it.
            pTempPin->Release();

            return(S_FALSE);
        }

        POSITION posTemp = pDoc()->m_lstLinks.Find(pSocket->m_plink);
        if (posTemp != NULL) {
            //
            // We need to check for posTemp != NULL here because
            // if we get called during DeleteContents, all links might
            // have been deleted - no matter of successfully disconnected
            // or not.
            //
            pDoc()->m_lstLinks.RemoveAt(posTemp);

            pSocket->m_plink->Disconnect();

            delete pSocket->m_plink;
            pSocket->m_plink = NULL;
        }

        pTempPin->Release();
    }

    //
    // Remove any links
    //
    if (pSocket->m_plink) {
        //
        // Need to remove the link from the CBoxNetDoc's <m_lstLinks> list.
        //
        POSITION posDelete = pDoc()->m_lstLinks.Find(pSocket->m_plink);
        pDoc()->m_lstLinks.RemoveAt(posDelete);

        // The destructor sets the head and tail socket's pointers to the link
        // to NULL.

        delete pSocket->m_plink;  // no disconnect needed
    }

    //
    // Remove the socket from m_lstSockets and delete it
    //
    m_lstSockets.RemoveAt(posSocket);
    delete pSocket;

    return(S_OK);
}

//
// AddSocket
//
void CBox::AddSocket(CString stLabel,
                     CBoxTabPos::EEdge eEdge,
                     unsigned uiVal,
                     unsigned uiValMax,
                     IPin *pPin) {

    CBoxSocket * pSocket;
    pSocket = new CBoxSocket(this, stLabel, eEdge, uiVal, uiValMax, pPin);

    m_lstSockets.AddTail(pSocket);
}


//
// ShowDialog
//
// Show our own dialog, and pass the request on to our sockets
void CBox::ShowDialog(void) {

    CPropObject::ShowDialog();

    CSocketEnum Next(this);
    CBoxSocket  *psock;
    while (0 != (psock = Next())) {

        psock->ShowDialog();
    }
}


//
// HideDialog
//
// Hide our dialog and pass the request to our sockets
void CBox::HideDialog(void) {

    CPropObject::HideDialog();

    CSocketEnum Next(this);
    CBoxSocket  *psock;
    while (0 != (psock = Next())) {

        psock->HideDialog();
    }
}


// *
// * CBoxList
// *

// A CList, with the ability to query the list for partiular _filters_


//
// IsIn
//
// Is this filter in this list?
BOOL CBoxList::IsIn(IBaseFilter *pFilter) const {

    if (GetBox(pFilter) != NULL) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


//
// GetBox
//
// Return the box that manages this filter. NULL if not present.
CBox *CBoxList::GetBox(IBaseFilter *pFilter) const {

    POSITION pos = GetHeadPosition();

    while (pos != NULL) {

        CBox *pbox = GetNext(pos);

        if (CQCOMInt<IBaseFilter>(pFilter) == (IUnknown *)CQCOMInt<IBaseFilter>(pbox->pIFilter())) {
            return pbox;
        }
    }

    return NULL;
}


//
// GetBox
//
// Return the box managing the filter with the supplied clsid
CBox *CBoxList::GetBox(CLSID clsid) const {

    POSITION pos = GetHeadPosition();

    while (pos != NULL) {

        CBox *pbox = GetNext(pos);
        CQCOMInt<IPersist> IPer(IID_IPersist, pbox->pIFilter());

        CLSID clsidThis;
        IPer->GetClassID(&clsidThis);

        if (clsidThis == clsid) {
            return pbox;
        }
    }

    return NULL;
}


BOOL CBoxList::RemoveBox( IBaseFilter* pFilter, CBox** ppBox )
{
    POSITION posNext;
    CBox* pCurrentBox;
    POSITION posCurrent;

    // Prevent the caller from accessing random memory.
    *ppBox = NULL;

    posNext = GetHeadPosition();

    while( NULL != posNext ) {
        posCurrent = posNext;

        pCurrentBox = GetNext( posNext );
    
        if( IsEqualObject( pCurrentBox->pIFilter(), pFilter ) ) {
            RemoveAt( posCurrent );
            *ppBox = pCurrentBox;
            return TRUE;
        } 
    }

    return FALSE;
}

#ifdef _DEBUG
//
// Dump
//
void CBoxList::Dump( CDumpContext& dc ) const {

    CDeleteList<CBox *, CBox *>::Dump(dc);

}
#endif // _DEBUG

// *
// * CSocketEnum
// *

//
// CSocketEnum::Constructor
//
CSocketEnum::CSocketEnum(CBox *pbox, DirType Type)
    : m_Type(Type),
      m_pbox(pbox) {

    ASSERT(pbox);

    m_pos =  m_pbox->m_lstSockets.GetHeadPosition();

    if (m_Type == Input)
        m_EnumDir = ::PINDIR_INPUT;
    else if (m_Type == Output)
        m_EnumDir = ::PINDIR_OUTPUT;
}


//
// operator()
//
// return the next socket of the requested sense, NULL if no more.
CBoxSocket *CSocketEnum::operator() (void) {

    CBoxSocket *psock;

    do {
        if (m_pos != NULL) {
            psock = m_pbox->m_lstSockets.GetNext(m_pos);
        }
        else {  // no more sockets
            return NULL;
        }

        ASSERT(psock);

    } while (   (m_Type != All)
             && (psock->GetDirection() != m_EnumDir)
            );

    return psock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\boxdraw.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// boxdraw.h : declares CBoxDraw
//

/////////////////////////////////////////////////////////////////////////////
// CBoxDraw
//
// A CBoxDraw object maintains resources etc. used to draw and hit-test
// boxes and links.  Note that CBoxDraw is not a view of a box or link --
// it is a collection of pens, brushes, bitmaps, and functions to draw
// boxes and links.
//
// This application maintains a single, global CBoxDraw object, <gpboxdraw>.
//

class CBoxDraw
{

protected:
    // private constants (see definition in .cpp file for more information)
    static const COLORREF   m_crBkgnd;
    static const CSize      m_sizLabelMargins;
    static const int        m_iHotZone;
    static const CString    m_stBoxFontFace;
    static const int        m_iBoxLabelHeight;
    static const int        m_iBoxTabLabelHeight;
    static const COLORREF   m_crLinkNoHilite;
    static const COLORREF   m_crLinkHilite;
    static const int        m_iHiliteBendsRadius;

public:
    // constants returned by hit-test functions
    enum EHit
    {
        HT_MISS,                    // didn't hit anything
        HT_TAB,                     // hit a box tab
        HT_EDGE,                    // hit the edge of the box
        HT_TABLABEL,                // hit a box tab label
        HT_BOXLABEL,                // hit the box label
        HT_BOXFILE,                 // hit the box filename
        HT_BOX,                     // hit elsewhere on the box
        HT_LINKLINE,                // hit a link line segment
    };

protected:
    // <m_abmEdges> and <m_abmTabs> are two bitmaps (element 0 for
    // unhighlighted, element 1 for highlighted state) that each
    // contain 3x3 tiles used to draw boxes (see DrawCompositeFrame())
    CBitmap         m_abmEdges[2];  // composite bm. for drawing box edges
    CBitmap         m_abmTabs[2];   // composite bm. for drawing box tabs
    CBitmap         m_abmClocks[2]; // clock icon to show IReferenceClock filters
    SIZE            m_sizEdgesTile; // size of one of the tiles
    SIZE            m_sizTabsTile;  // size of one of the tiles
    SIZE            m_sizClock;     // size of the clock bitmap

protected:
    // fonts used to draw box labels and box tab labels
    CFont           m_fontBoxLabel; // font for box label
    CFont           m_fontTabLabel; // font for box tabs

protected:
    // brushes and pens used to draw links (element 0 for unhighlighted,
    // element 1 for highlighted state)
    CBrush          m_abrLink[2];   // brushes used to draw links
    CPen            m_apenLink[2];  // pens used to draw links

public:
    // construction and destruction
    CBoxDraw();
    ~CBoxDraw() { Exit(); };
    void Init();
    void RecreateFonts();
    void Exit();

public:
    // general functions
    COLORREF GetBackgroundColor()
        { return m_crBkgnd; }

public:
    // functions for box drawing and hit testing
    void GetInsideRect(const CBox *pbox, CRect *prc)
        { *prc = pbox->GetRect();
          prc->InflateRect(-m_sizTabsTile.cx, -m_sizTabsTile.cy); }

    void GetFrameRect(CBox *pbox, CRect *prc)
        { GetInsideRect(pbox, prc);
          prc->InflateRect(m_sizEdgesTile.cx, m_sizEdgesTile.cy); }

    void GetOrInvalBoundRect(CBox *pbox, CRect *prc, BOOL fLinks=FALSE,
        CScrollView *pScroll=NULL);

    void DrawFrame(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw);

    void DrawBoxLabel(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw);

//    void DrawBoxFile(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw);

    void DrawTabLabel(CBox *pbox, CBoxSocket *psock, CRect *prc,
        CDC *pdc, BOOL fDraw);

    void DrawTab(CBoxSocket *psock, CRect *prc, CDC *pdc,
        BOOL fDraw, BOOL fHilite);

    void InvalidateBoundRect(CBox *pbox, CWnd *pwnd)
        { pwnd->InvalidateRect(&pbox->GetRect(), TRUE); }

    CPoint GetTabCenter(CBoxSocket *psock);

    CBoxTabPos BoxTabPosFromPoint(CBox *pbox, CPoint pt, LPINT piError);

    CPoint BoxTabPosToPoint(const CBox *pbox, CBoxTabPos tabpos);

    void DrawBox(CBox *pbox, CDC *pdc,  CBoxSocket *psockHilite=NULL,
        CSize *psizGhostOffset=NULL);

    EHit HitTestBox(CBox *pbox, CPoint pt, CBoxTabPos *ptabpos,
        CBoxSocket **ppsock);

public:
    // functions for link drawing and hit testing

    void GetOrInvalLinkRect(CBoxLink *plink, CRect *prc, CScrollView *pScroll=NULL);

    void SelectLinkBrushAndPen(CDC *pdc, BOOL fHilite);

    void DrawArrow(CDC *pdc, CPoint ptTail, CPoint ptHead, BOOL fGhost=FALSE,
        BOOL fArrowhead=TRUE, BOOL fHilite=FALSE);

    void DrawLink(CBoxLink *plink, CDC *pdc, BOOL fHilite=FALSE, CSize *psizGhostOffset=NULL);

    EHit HitTestLink(CBoxLink *plink, CPoint pt, CPoint *pptProject);
};


/////////////////////////////////////////////////////////////////////////////
// Global (shared) CBoxDraw object

extern CBoxDraw * gpboxdraw;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\bnetvw.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// bnetvw.cpp : defines CBoxNetView
//

#include "stdafx.h"
#include <activecf.h>                   // Quartz clipboard definitions
#include <measure.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CBoxNetView, CScrollView)

/////////////////////////////////////////////////////////////////////////////
// construction and destruction


CBoxNetView::CBoxNetView() :
    m_fMouseDrag(FALSE),
    m_fMoveBoxSelPending(FALSE),
    m_fMoveBoxSel(FALSE),
    m_fGhostSelection(FALSE),
    m_fSelectRect(FALSE),
    m_pSelectClockFilter(NULL),
    m_fNewLink(FALSE),
    m_fGhostArrow(FALSE),
    m_psockHilite(NULL)
{
    CString szMeasurePath;
    szMeasurePath.LoadString(IDS_MEASURE_DLL);

    m_hinstPerf = LoadLibrary(szMeasurePath);

}


//
// Destructor
//
CBoxNetView::~CBoxNetView() {
#if 0
// THIS DOES NOT BELONG HERE!!
// THIS HAS TO BE AT THE VERY END OF THE APPLICATION
// THINGS GO ON *AFTER* THIS POINT AND THEY ACCESS VIOLATE WITH THIS HERE
    if (m_hinstPerf) {
        // allow perf library to clean up!
        CString szTerminateProc;
        szTerminateProc.LoadString(IDS_TERMINATE_PROC);

        typedef void WINAPI MSR_TERMINATE_PROC(void);

        MSR_TERMINATE_PROC *TerminateProc;
        TerminateProc =
            (MSR_TERMINATE_PROC *) GetProcAddress(m_hinstPerf, szTerminateProc);

        if (TerminateProc) {
            TerminateProc();
        }
        else {
            AfxMessageBox(IDS_NO_TERMINATE_PROC);
        }

        FreeLibrary(m_hinstPerf);
    }
#endif
}


/////////////////////////////////////////////////////////////////////////////
// diagnostics


#ifdef _DEBUG
void CBoxNetView::AssertValid() const
{
    CScrollView::AssertValid();
}
#endif //_DEBUG


#ifdef _DEBUG
void CBoxNetView::Dump(CDumpContext& dc) const
{
    CScrollView::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// general public functions

//
// OnInitialUpdate
//
// Set the initial scroll size
void CBoxNetView::OnInitialUpdate(void) {

    SetScrollSizes(MM_TEXT, GetDocument()->GetSize());

    CScrollView::OnInitialUpdate();

    GetDocument()->m_hWndPostMessage = m_hWnd;

    CGraphEdit * pMainFrame = (CGraphEdit*) AfxGetApp( );
    CWnd * pMainWnd = pMainFrame->m_pMainWnd;
    CMainFrame * pF = (CMainFrame*) pMainWnd;

    pF->ToggleSeekBar( 0 );

    // If the seek timer is NOT already running, start it
    pF->m_hwndTimer = m_hWnd;
    if ((!pF->m_nSeekTimerID) && (pF->m_bSeekEnabled))
        pF->m_nSeekTimerID = ::SetTimer( m_hWnd, TIMER_SEEKBAR, 200, NULL );
}


/* OnUpdate()
 *
 * pHint can be a pointer to a CBox, if only that CBox needs to be redrawn.
 */
void CBoxNetView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
    CBox *      pbox;
    CBoxSocket *psock;
    CBoxLink *  plink;
    CRect       rc;

    SetScrollSizes(MM_TEXT, GetDocument()->GetSize());

    switch ((int) lHint)
    {

    case CBoxNetDoc::HINT_DRAW_ALL:

        // repaint entire window
//        TRACE("HINT_DRAW_ALL\n");
        InvalidateRect(NULL, TRUE);
        break;

    case CBoxNetDoc::HINT_CANCEL_VIEWSELECT:

        // cancel any selection maintained by the view
//        TRACE("HINT_CANCEL_VIEWSELECT\n");
        break;

    case CBoxNetDoc::HINT_CANCEL_MODES:

        // cancel modes like select rectangle, drag boxes, etc.
//        TRACE("HINT_CANCEL_MODES\n");
        CancelModes();
        break;

    case CBoxNetDoc::HINT_DRAW_BOX:

        // repaint given box
        pbox = (CBox *) pHint;
        gpboxdraw->GetOrInvalBoundRect(pbox, &rc, FALSE, this);
//        TRACE("HINT_DRAW_BOX: (%d,%d,%d,%d)\n", rc.left, rc.top, rc.right, rc.bottom);
        break;

    case CBoxNetDoc::HINT_DRAW_BOXANDLINKS:

        // repaint given box
        pbox = (CBox *) pHint;
        gpboxdraw->GetOrInvalBoundRect(pbox, &rc, TRUE, this);
//        TRACE("HINT_DRAW_BOXANDLINKS: (%d,%d,%d,%d)\n", rc.left, rc.top, rc.right, rc.bottom);
        break;

    case CBoxNetDoc::HINT_DRAW_BOXTAB:

        // repaint given box tab
        psock = (CBoxSocket *) pHint;
        gpboxdraw->DrawTab(psock, &rc, NULL, FALSE, FALSE);
//        TRACE("HINT_DRAW_BOXTAB\n");
        InvalidateRect(&(rc - GetScrollPosition()), TRUE);
        break;

    case CBoxNetDoc::HINT_DRAW_LINK:

        // repaint given link
        plink = (CBoxLink *) pHint;
        gpboxdraw->GetOrInvalLinkRect(plink, &rc, this);
//        TRACE("HINT_DRAW_LINK\n");
        break;



    }
}


void CBoxNetView::OnDraw(CDC* pdc)
{
    CBoxNetDoc *    pdoc = GetDocument();
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc
    CBoxLink *      plink;          // a link in CBoxNetDoc
    CRect           rc;

    if (pdc->IsPrinting()) {
        pdc->SetMapMode(MM_ISOTROPIC);

        CSize DocSize = GetDocument()->GetSize();
        CSize PrintSize(pdc->GetDeviceCaps(HORZRES),pdc->GetDeviceCaps(VERTRES));

        if ((DocSize.cx != 0) && (DocSize.cy != 0)) {
            // choose smaller of PrintX/docX or PrintY/DocY as isotropic scale factor
            if (PrintSize.cx * DocSize.cy < PrintSize.cy * DocSize.cx) {
                PrintSize.cy = (DocSize.cy * PrintSize.cx) / DocSize.cx;
                PrintSize.cx = (DocSize.cx * PrintSize.cx) / DocSize.cx;
            }
            else {
                PrintSize.cx = (DocSize.cx * PrintSize.cy) / DocSize.cx;
                PrintSize.cy = (DocSize.cy * PrintSize.cy) / DocSize.cx;
            }
        }

        pdc->SetWindowExt(DocSize);
        pdc->SetViewportExt(PrintSize);
    }
    else {
        pdc->SetMapMode(MM_TEXT);
    }

    // save the clipping region
    pdc->SaveDC();

    // draw all boxes in list that might be within clipping region
    for (pos = pdoc->m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = (CBox *) pdoc->m_lstBoxes.GetNext(pos);
        if (pdc->RectVisible(pbox->GetRect()))
        {
//            TRACE("draw box 0x%08lx\n", (LONG) (LPCSTR) pbox);
            gpboxdraw->DrawBox(pbox, pdc, m_psockHilite);
        }
    }

    if (!pdc->IsPrinting()) {
        // fill the unpainted portion of the window with background color
        pdc->GetClipBox(&rc);
        CBrush br(gpboxdraw->GetBackgroundColor());
        CBrush *pbrPrev = pdc->SelectObject(&br);
        pdc->PatBlt(rc.left, rc.top, rc.Width(), rc.Height(), PATCOPY);
        if (pbrPrev != NULL)
            pdc->SelectObject(pbrPrev);
    }

    // restore the clipping region
    pdc->RestoreDC(-1);

    // draw all links that might be within clipping region
    for (pos = pdoc->m_lstLinks.GetHeadPosition(); pos != NULL; )
    {
        plink = (CBoxLink *) pdoc->m_lstLinks.GetNext(pos);
        gpboxdraw->GetOrInvalLinkRect(plink, &rc);
        if (pdc->RectVisible(&rc))
        {
//            TRACE("draw link 0x%08lx\n", (LONG) (LPCSTR) plink);
            gpboxdraw->DrawLink(plink, pdc);
        }
    }

    // paint the ghost selection (if it's currently visible)
    if (m_fGhostSelection)
        GhostSelectionDraw(pdc);

    // paint the ghost arrow (if it's currently visible)
    if (m_fGhostArrow)
        GhostArrowDraw(pdc);

    // paint the select-rectangle rectangle (if we're in that mode)
    if (m_fSelectRect)
        SelectRectDraw(pdc);
}


/* eHit = HitTest(pt, ppbox, ptabpos, ppsock, pplink, pptProject, ppbend)
 *
 * See if <pt> hits something in the view.
 *
 * If <pt> hits a link, return the HT_XXX code, and set <**pplink>,
 * <*pptProject>, and/or <*ppbend>, as defined by CBoxDraw::HitTestLink().
 * If not, set <*pplink> to NULL.
 *
 * If <pt> hits a box, return the HT_XXX code, set <*ppbox>, <*ptabpos> and/or
 * <*ppsock>, as defined by CBoxDraw::HitTestBox().  If not, set <*ppbox>
 * to NULL.
 *
 * If <pt> hits nothing, return HT_MISS.
 */
CBoxDraw::EHit CBoxNetView::HitTest(CPoint pt, CBox **ppbox,
    CBoxTabPos *ptabpos, CBoxSocket **ppsock, CBoxLink **pplink,
    CPoint *pptProject)
{
    CBoxNetDoc *    pdoc = GetDocument();
    CBoxDraw::EHit  eHit;           // hit-test result code
    POSITION        pos;            // position in linked list

    // these pointers must be NULL if they aren't valid
    *ppbox = NULL;
    *pplink = NULL;

    // adjust for the current scroll position
    pt += CSize(GetDeviceScrollPosition());

    // see if <pt> hits any box
    for (pos = pdoc->m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        *ppbox = (CBox *) pdoc->m_lstBoxes.GetNext(pos);
        eHit = gpboxdraw->HitTestBox(*ppbox, pt, ptabpos, ppsock);
        if (eHit != CBoxDraw::HT_MISS)
            return eHit;
    }
    *ppbox = NULL;

    // see if <pt> hits any link
    for (pos = pdoc->m_lstLinks.GetHeadPosition(); pos != NULL; )
    {
        *pplink = (CBoxLink *) pdoc->m_lstLinks.GetNext(pos);
        eHit = gpboxdraw->HitTestLink(*pplink, pt, pptProject);
        if (eHit != CBoxDraw::HT_MISS)
            return eHit;
    }
    *pplink = NULL;

    // hit the background
    return CBoxDraw::HT_MISS;
}



/* CancelModes()
 *
 * Cancel all CBoxNetView modes (e.g. mouse-drag mode, move-selection mode,
 * etc.), including deselecting anything selected in the view (but not
 * including items for which the document maintains the selection state).
 * This is a superset of CancelViewSelection().
 */
void CBoxNetView::CancelModes()
{
    if (m_fMouseDrag)
        MouseDragEnd();
    if (m_fMoveBoxSelPending)
        MoveBoxSelPendingEnd(TRUE);
    if (m_fMoveBoxSel)
        MoveBoxSelEnd(TRUE);
    if (m_fGhostSelection)
        GhostSelectionDestroy();
    if (m_fSelectRect)
        SelectRectEnd(TRUE);
    if (m_fNewLink)
        NewLinkEnd(TRUE);
    if (m_fGhostArrow)
        GhostArrowEnd();
    if (m_psockHilite != NULL)
        SetHiliteTab(NULL);
}


/////////////////////////////////////////////////////////////////////////////
// printing support


BOOL CBoxNetView::OnPreparePrinting(CPrintInfo* pInfo)
{
    // default preparation
    return DoPreparePrinting(pInfo);
}


void CBoxNetView::OnBeginPrinting(CDC* /*pdc*/, CPrintInfo* /*pInfo*/)
{
}


void CBoxNetView::OnEndPrinting(CDC* /*pdc*/, CPrintInfo* /*pInfo*/)
{
}


/////////////////////////////////////////////////////////////////////////////
// mouse-drag mode


/* MouseDragBegin(nFlags, pt, pboxMouse)
 *
 * Enter mouse-drag mode.  In this mode, the mouse is captured, and the
 * following information is maintained:
 *   -- <m_fMouseShift>: TRUE if Shift held down when mouse clicked;
 *   -- <m_ptMouseAnchor>: the point at which the click occurred;
 *   -- <m_ptMousePrev>: the previous position of the mouse (as specified
 *      in the previous call to MouseDragBegin() or MouseDragContinue();
 *   -- <m_pboxMouse>: set to <pboxMouse>, which should point to the
 *      initially clicked-on box (or NULL if none);
 *   -- <m_fMouseBoxSel>: TRUE if clicked-on box was initially selected.
 */
void CBoxNetView::MouseDragBegin(UINT nFlags, CPoint pt, CBox *pboxMouse)
{
    m_fMouseDrag = TRUE;
    m_fMouseShift = ((nFlags & MK_SHIFT) != 0);
    m_ptMouseAnchor = m_ptMousePrev = pt;
    m_pboxMouse = pboxMouse;
    m_fMouseBoxSel = (pboxMouse == NULL ? FALSE : pboxMouse->IsSelected());
    SetCapture();
}


/* MouseDragContinue(pt)
 *
 * Continue mouse-drag mode (initiated by MouseDragBegin()), and specify
 * that the current mouse position is at <pt> (which causes <m_ptMousePrev>
 * to be set to this value).
 */
void CBoxNetView::MouseDragContinue(CPoint pt)
{
    m_ptMousePrev = pt;
}


/* MouseDragEnd()
 *
 * End mouse-drag mode (initiated by MouseDragBegin().
 */
void CBoxNetView::MouseDragEnd()
{
    m_fMouseDrag = FALSE;
    if (this == GetCapture())
        ReleaseCapture();
}


/////////////////////////////////////////////////////////////////////////////
// move-selection-pending mode (for use within mouse-drag mode)

/* MoveBoxSelPendingBegin(pt)
 *
 * Enter move-selection-pending mode.  In this mode, if the user waits long
 * enough, or drags the mouse far enough, the user enters move-selection mode
 * (in which the selected boxes and connected links are dragged to a new
 * location).  If not (i.e. if the user releases the mouse button quickly,
 * without dragging far) then if the user shift-clicked on a selected box then
 * the box is deselected.
 *
 * <pt> is the current location of the mouse.
 */
void CBoxNetView::MoveBoxSelPendingBegin(CPoint pt)
{
    m_fMoveBoxSelPending = TRUE;

    // set <m_rcMoveSelPending>; if the mouse leaves this rectangle
    // end move-selection-pending mode and begin move-selection mode
    CSize siz = CSize(GetSystemMetrics(SM_CXDOUBLECLK),
                      GetSystemMetrics(SM_CYDOUBLECLK));
    m_rcMoveSelPending = CRect(pt - siz, siz + siz);

    // set a timer to potentially end move-selection-pending mode
    // and begin move-selection mode
    SetTimer(TIMER_MOVE_SEL_PENDING, GetDoubleClickTime(), NULL);

    MFGBL(SetStatus(IDS_STAT_MOVEBOX));
}


/* MoveBoxSelPendingContinue(pt)
 *
 * Continue move-selection-pending mode.  See if the user dragged the mouse
 * (which is at <pt>) far enough to enter move-selection mode.
 */
void CBoxNetView::MoveBoxSelPendingContinue(CPoint pt)
{
    if (!m_rcMoveSelPending.PtInRect(pt))
    {
        // mouse moved far enough -- end move-selection-pending mode
        MoveBoxSelPendingEnd(FALSE);
    }
}


/* MoveBoxSelPendingEnd(fCancel)
 *
 * End move-selection-pending mode.  If <fCancel> is FALSE, then enter
 * move-selection mode.  If <fCancel> is TRUE, then if the user shift-clicked
 * on a selecte box, deselect it.
 */
void CBoxNetView::MoveBoxSelPendingEnd(BOOL fCancel)
{
    CBoxNetDoc *    pdoc = GetDocument();

    // end move-selection-pending mode
    m_fMoveBoxSelPending = FALSE;
    KillTimer(TIMER_MOVE_SEL_PENDING);

    if (fCancel)
    {
        // if the user shift-clicked a selected box, deselect it
        if (m_fMouseShift && m_fMouseBoxSel)
            pdoc->SelectBox(m_pboxMouse, FALSE);
    }
    else
    {
        // begin move-selection mode
        MoveBoxSelBegin();

        // give the user some feedback immediately (rather than waiting until
        // they move the mouse)
        CPoint pt;
        ::GetCursorPos(&pt);
        ScreenToClient(&pt);
        MoveBoxSelContinue(pt - m_ptMouseAnchor);
    }
}


/////////////////////////////////////////////////////////////////////////////
// move-selection mode


/* MoveBoxSelBegin()
 *
 * Enter into move-selection mode.  While in this mode, the selection is
 * not actually moved (until the mode is ended).  Instead, a ghost selection
 * is moved.
 */
void CBoxNetView::MoveBoxSelBegin()
{
    GhostSelectionCreate();
    m_fMoveBoxSel = TRUE;
    MFGBL(SetStatus(IDS_STAT_MOVEBOX));
}


/* MoveBoxSelContinue(sizOffset)
 *
 * Continue move-selection mode.  Request that the ghost selection (showing
 * where the selection would be moved to if it were dropped right now)
 * move to offset <sizOffset> from the selection location.
 */
void CBoxNetView::MoveBoxSelContinue(CSize sizOffset)
{
    GhostSelectionMove(sizOffset);
}


/* MoveBoxSelEnd(fCancel)
 *
 * End move-selection mode.  If <fCancel> is FALSE, then move the selection
 * to where the ghost selection was moved by calls to MoveBoxSelContinue().
 * If <fCancel> is TRUE, don't move the selection.
 */
void CBoxNetView::MoveBoxSelEnd(BOOL fCancel)
{
    GhostSelectionDestroy();

    m_fMoveBoxSel = FALSE;

    if (!fCancel)
        MoveBoxSelection(m_sizGhostSelOffset);
}


/* MoveBoxSelection(sizOffset)
 *
 * Create and execute a command to move each selected box by <sizOffset>.
 */
void CBoxNetView::MoveBoxSelection(CSize sizOffset)
{
    CBoxNetDoc *    pdoc = GetDocument();

    pdoc->CmdDo(new CCmdMoveBoxes(sizOffset));
}


/* sizOffsetNew = ConstrainMoveBoxSel(sizOffset, fCalcSelBoundRect)
 *
 * Assume you want to move the current selection by <sizOffset>.
 * This function returns the offset that you should actually move the
 * current selection by, if you want to be restricted to being below and
 * to the right of (0,0).
 *
 * If <fCalcSelBoundRect> is TRUE, then set <m_rcSelBound> to the
 * bounding rectangle of the current selection (required in order to
 * constrain the selection).  Otherwise, assume <m_rcSelBound> has already
 * been calculated.
 *
 * We restrict the selection to be moved no further than 0 for top and
 * left and to MAX_DOCUMENT_SIZE for right and bottom.
 *
 * In this function we restrict the user's ability to exceed the maximum
 * size of the ScrollView. Note that Filters are only added to the
 * visible part of the existing ScrollView.
 *
 * The only place where a further check has to be made is in the
 * automatic filter layout. (bnetdoc.cpp CBoxNetDoc::
 *
 */
CSize CBoxNetView::ConstrainMoveBoxSel(CSize sizOffset,
    BOOL fCalcSelBoundRect)
{
    CBoxNetDoc *    pdoc = GetDocument();

    if (fCalcSelBoundRect)
        pdoc->GetBoundingRect(&m_rcSelBound, TRUE);

    // constrain <sizOffset> to be below and to the right of (0,0)
    CRect rc(m_rcSelBound);
    rc.OffsetRect(sizOffset);
    if (rc.left < 0)
        sizOffset.cx -= rc.left;
    if (rc.top < 0)
        sizOffset.cy -= rc.top;
    if (rc.right > MAX_DOCUMENT_SIZE)
        sizOffset.cx -= (rc.right - MAX_DOCUMENT_SIZE);
    if (rc.bottom > MAX_DOCUMENT_SIZE)
        sizOffset.cy -= (rc.bottom - MAX_DOCUMENT_SIZE);

    return sizOffset;
}


/////////////////////////////////////////////////////////////////////////////
// ghost-selection mode


/* GhostSelectionCreate()
 *
 * Create a "ghost selection", which appears to the user as a copy of the
 * current selection, but only drawn in "skeletal form" (e.g. only the
 * outline of boxes), and drawn with pixels inverted.
 *
 * Start the ghost selection at the same location as the current
 * selection.
 */
void CBoxNetView::GhostSelectionCreate()
{
    CBoxNetDoc *    pdoc = GetDocument();
    CClientDC       dc(this);       // DC onto window

    CPoint Offset = GetDeviceScrollPosition();
    dc.OffsetViewportOrg(-Offset.x,-Offset.y);

    // draw the ghost selection
    m_sizGhostSelOffset = CSize(0, 0);
    GhostSelectionDraw(&dc);

    // get the bounding rectangle for the box selection
    pdoc->GetBoundingRect(&m_rcSelBound, TRUE);
}


/* GhostSelectionMove(sizOffset)
 *
 * Move the ghost selection (created by GhostSelectionCreate()) to the
 * location of the current selection, but offset by <sizOffset> pixels.
 * The ghost selection will be restricted to being below and to the
 * right of (0,0), and will snap to the current grid setting.
 */
void CBoxNetView::GhostSelectionMove(CSize sizOffset)
{
    CClientDC       dc(this);       // DC onto window

    CPoint Offset = GetDeviceScrollPosition();
    dc.OffsetViewportOrg(-Offset.x,-Offset.y);

    // keep below/right of (0,0) and snap to grid
    sizOffset = ConstrainMoveBoxSel(sizOffset, FALSE);

    // erase previous ghost selection
    GhostSelectionDraw(&dc);

    // move and redraw ghost selection
    m_sizGhostSelOffset = sizOffset;
    GhostSelectionDraw(&dc);
}


/* GhostSelectionDestroy()
 *
 * Destroy the ghost selection (created by GhostSelectionCreate()).
 */
void CBoxNetView::GhostSelectionDestroy()
{
    CClientDC       dc(this);       // DC onto window

    CPoint Offset = GetDeviceScrollPosition();
    dc.OffsetViewportOrg(-Offset.x,-Offset.y);

    // erase current ghost selection
    GhostSelectionDraw(&dc);
}


/* GhostSelectionDraw(pdc)
 *
 * Draw the current ghost selection in <pdc>.
 */
void CBoxNetView::GhostSelectionDraw(CDC *pdc)
{
    CBoxNetDoc *    pdoc = GetDocument();
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc
    CBoxLink *      plink;          // a link in CBoxNetDoc

    // draw all selected boxes in "ghost form"
    for (pos = pdoc->m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = (CBox *) pdoc->m_lstBoxes.GetNext(pos);
        if (pbox->IsSelected())
            gpboxdraw->DrawBox(pbox, pdc, NULL, &m_sizGhostSelOffset);
    }

    // draw all links to selected boxes in "ghost form"
    for (pos = pdoc->m_lstLinks.GetHeadPosition(); pos != NULL; )
    {
        plink = (CBoxLink *) pdoc->m_lstBoxes.GetNext(pos);
        if (plink->m_psockTail->m_pbox->IsSelected() ||
            plink->m_psockHead->m_pbox->IsSelected())
            gpboxdraw->DrawLink(plink, pdc, FALSE, &m_sizGhostSelOffset);
    }
}


/////////////////////////////////////////////////////////////////////////////
// select-rectangle mode


/* SelectRectBegin(pt)
 *
 * Enter into select-rectangle mode.  While in this mode, a rectangle is drawn
 * in the window.  When the mode ends, all boxes that intersect the rectangle
 * will be selected.
 *
 * <pt> defines the anchor point, i.e. the point to use to start drawing the
 * rectangle (i.e. it must be one of the corners of the desired rectangle).
 */
void CBoxNetView::SelectRectBegin(CPoint pt)
{
    CClientDC       dc(this);       // DC onto window

    // exit select-rectangle mode
    m_fSelectRect = TRUE;
    m_ptSelectRectAnchor = m_ptSelectRectPrev = pt;

    // draw the initial selection rectangle
    SelectRectDraw(&dc);

    MFGBL(SetStatus(IDS_STAT_SELECTRECT));
}


/* SelectRectContinue(pt)
 *
 * Continue select-rectangle mode.  Draw the rectangle from the anchor point
 * (specified in SelectRectBegin()) to <pt>.
 */
void CBoxNetView::SelectRectContinue(CPoint pt)
{
    CClientDC       dc(this);       // DC onto window

    // move the selection rectangle
    SelectRectDraw(&dc);
    m_ptSelectRectPrev = pt;
    SelectRectDraw(&dc);
}


/* SelectRectEnd(fCancel)
 *
 * End select-rectangle mode.  If <fCancel> is FALSE, then select all boxes
 * that intersect the rectangle.
 */
void CBoxNetView::SelectRectEnd(BOOL fCancel)
{
    CClientDC       dc(this);       // DC onto window

    // erase the selection rectangle
    SelectRectDraw(&dc);

    // exit select-rectangle mode
    m_fSelectRect = FALSE;

    if (!fCancel)
    {
        // select all boxes intersecting the rectangle
        CRect rc(m_ptSelectRectAnchor.x, m_ptSelectRectAnchor.y,
            m_ptSelectRectPrev.x, m_ptSelectRectPrev.y);
        NormalizeRect(&rc);
        rc.OffsetRect(GetDeviceScrollPosition());
        SelectBoxesIntersectingRect(&rc);
    }
}


/* SelectRectDraw(pdc)
 *
 * Draw the current select-rectangle rectangle (assuming that we are in
 * select-rectangle mode, initiated by SelectRectBegin()).  Calling this
 * function again will erase the rectangle (assuming that <m_ptSelectRectPrev>
 * and <m_ptSelectRectAnchor> haven't changed).
 */
void CBoxNetView::SelectRectDraw(CDC *pdc)
{
    // use DrawFocusRect() to invert the pixels in a rectangle frame
    CRect rc(m_ptSelectRectAnchor.x, m_ptSelectRectAnchor.y,
        m_ptSelectRectPrev.x, m_ptSelectRectPrev.y);
    NormalizeRect(&rc);
    pdc->DrawFocusRect(&rc);
}


/* SelectBoxesIntersectingRect(CRect *prc)
 *
 * Select all boxes that intersect <*prc>.
 */
void CBoxNetView::SelectBoxesIntersectingRect(CRect *prc)
{
    CBoxNetDoc *    pdoc = GetDocument();
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc
    CRect           rcTmp;

    for (pos = pdoc->m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = (CBox *) pdoc->m_lstBoxes.GetNext(pos);
        if (rcTmp.IntersectRect(&pbox->GetRect(), prc))
            pdoc->SelectBox(pbox, TRUE);

    }
}


/////////////////////////////////////////////////////////////////////////////
// new-link mode


/* NewLinkBegin(CPoint pt, CBoxSocket *psock)
 *
 * Enter into new-link mode.  While in this mode, the user is dragging from
 * one socket to another socket to create a link.  A ghost arrow is displayed
 * (from the clicked-on socket to the current mouse location) to give the user
 * feedback.
 *
 * <pt> is the clicked-on point; <psock> is the clicked-on socket.
 */
void CBoxNetView::NewLinkBegin(CPoint pt, CBoxSocket *psock)
{
    CBoxNetDoc *    pdoc = GetDocument();

    GetDocument()->DeselectAll();
    m_fNewLink = TRUE;
    m_psockNewLinkAnchor = psock;
    GhostArrowBegin(pt);
    MFGBL(SetStatus(IDS_STAT_DRAGLINKEND));
}


/* NewLinkContinue(pt)
 *
 * Continue new-link mode.  Draw the ghost arrow from the anchor socket
 * (specified in SelectRectBegin()) to <pt>.
 */
void CBoxNetView::NewLinkContinue(CPoint pt)
{
    CBoxNetDoc *    pdoc = GetDocument();
    CBox *          pbox;           // a box in CBoxNetDoc
    CBoxTabPos      tabpos;         // the position of a socket tab on a box
    CBoxSocket *    psock;          // a socket in a box
    CBoxLink *      plink;          // a link in CBoxNetDoc
    CPoint          ptProject;      // point on link line segment nearest <pt>

    GhostArrowContinue(pt);

    // set <psock> to the socket <pt> is over (NULL if none)
    if (HitTest(pt, &pbox, &tabpos, &psock, &plink, &ptProject)
        != CBoxDraw::HT_TAB)
        psock = NULL;

    // if <pt> is over a socket that is not already connected, highlight it
    if ((psock == NULL) || (psock->m_plink != NULL))
    {
        SetHiliteTab(NULL);
        MFGBL(SetStatus(IDS_STAT_DRAGLINKEND));
    }
    else
    {
        SetHiliteTab(psock);
        MFGBL(SetStatus(IDS_STAT_DROPLINKEND));
    }
}


/* NewLinkEnd(fCancel)
 *
 * End new-link mode.  If <fCancel> is FALSE, then create a link from
 * the anchor socket (specified in NewLinkBegin()) to <m_psockHilite>.
 */
void CBoxNetView::NewLinkEnd(BOOL fCancel)
{
    CBoxNetDoc *    pdoc = GetDocument();

    GhostArrowEnd();

    if (!fCancel)
    {
        // make link between <m_psockNewLinkAnchor> and <m_psockHilite>
        if (m_psockNewLinkAnchor->GetDirection()
             == m_psockHilite->GetDirection()) {
            //
            // We cannot connect pins of same direction
            // (different error messages for two input or output pins
            //
            if (m_psockNewLinkAnchor->GetDirection() == PINDIR_INPUT) {
                AfxMessageBox(IDS_CANTCONNECTINPUTS);
            }
            else {
                AfxMessageBox(IDS_CANTCONNECTOUTPUTS);
            }
        }
        else {
            pdoc->CmdDo(new CCmdConnect(m_psockNewLinkAnchor, m_psockHilite));
        }
    }

    // end new-link mode
    SetHiliteTab(NULL);
    m_fNewLink = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// ghost-arrow mode


/* GhostArrowBegin(pt)
 *
 * Create a ghost arrow that's initially got its head and tail at <pt>.
 * The ghost arrow appears to float above all boxes.  There can only be
 * one active ghost arrow in CBoxNetView at a time.
 */
void CBoxNetView::GhostArrowBegin(CPoint pt)
{
    CClientDC       dc(this);

    m_fGhostArrow = TRUE;
    m_ptGhostArrowTail = m_ptGhostArrowHead = pt;
    GhostArrowDraw(&dc);
}


/* GhostArrowContinue(pt)
 *
 * Move the head of the ghost arrow (created by GhostArrowCreate()) to <pt>.
 */
void CBoxNetView::GhostArrowContinue(CPoint pt)
{
    CClientDC       dc(this);

    GhostArrowDraw(&dc);
    m_ptGhostArrowHead = pt;
    GhostArrowDraw(&dc);
}


/* GhostArrowEnd()
 *
 * Erase the ghost arrow that was created by GhostArrowCreate().
 */
void CBoxNetView::GhostArrowEnd()
{
    CClientDC       dc(this);

    GhostArrowDraw(&dc);
    m_fGhostArrow = FALSE;
}


/* GhostArrowDraw(pdc)
 *
 * Draw the ghost arrow that was created by GhostArrowCreate().
 */
void CBoxNetView::GhostArrowDraw(CDC *pdc)
{
    gpboxdraw->DrawArrow(pdc, m_ptGhostArrowTail, m_ptGhostArrowHead, TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// highlight-tab mode


/* SetHiliteTab(psock)
 *
 * Set the currently-highlighted box socket tab to be <psock>
 * (NULL if no socket should be highlighted).
 */
void CBoxNetView::SetHiliteTab(CBoxSocket *psock)
{
    if (m_psockHilite == psock)
        return;
    if (m_psockHilite != NULL)
        OnUpdate(this, CBoxNetDoc::HINT_DRAW_BOXTAB, m_psockHilite);
    m_psockHilite = psock;
    if (m_psockHilite != NULL)
        OnUpdate(this, CBoxNetDoc::HINT_DRAW_BOXTAB, m_psockHilite);
}




/////////////////////////////////////////////////////////////////////////////
// generated message map

BEGIN_MESSAGE_MAP(CBoxNetView, CScrollView)
    //{{AFX_MSG_MAP(CBoxNetView)
    ON_WM_SETCURSOR()
    ON_WM_ERASEBKGND()
    ON_WM_LBUTTONDOWN()
    ON_WM_MOUSEMOVE()
    ON_WM_LBUTTONUP()
    ON_WM_TIMER()
    ON_COMMAND(ID_CANCEL_MODES, OnCancelModes)
        ON_WM_RBUTTONDOWN()
        ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE, OnUpdateEditDelete)
        ON_COMMAND(ID_EDIT_DELETE, OnEditDelete)
        ON_UPDATE_COMMAND_UI(IDM_SAVE_PERF_LOG, OnUpdateSavePerfLog)
        ON_COMMAND(IDM_SAVE_PERF_LOG, OnSavePerfLog)
        ON_UPDATE_COMMAND_UI(ID_NEW_PERF_LOG, OnUpdateNewPerfLog)
        ON_COMMAND(ID_NEW_PERF_LOG, OnNewPerfLog)
        ON_COMMAND(ID_FILE_SET_LOG, OnFileSetLog)
        ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_MOUSEWHEEL()
	ON_COMMAND(ID_VIEW_SEEKBAR, OnViewSeekbar)
	//}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CScrollView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CScrollView::OnFilePrintPreview)

    ON_COMMAND(ID__PROPERTIES, OnProperties)
    ON_UPDATE_COMMAND_UI(ID__PROPERTIES, OnUpdateProperties)
    ON_COMMAND(ID__SELECTCLOCK, OnSelectClock)


//    ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateSave)  // Disable Save
//    ON_UPDATE_COMMAND_UI(ID_FILE_SAVE_AS, OnUpdateSave) // Disable Save

    ON_MESSAGE(WM_USER_EC_EVENT, OnUser)   // event notification messages

END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// message callback functions


BOOL CBoxNetView::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
    CBoxNetDoc*     pdoc = GetDocument();
    CPoint          pt;             // point to hit-test
    CBoxDraw::EHit  eHit;           // hit-test result code
    CBox *          pbox;           // a box in CBoxNetDoc
    CBoxTabPos      tabpos;         // the position of a socket tab on a box
    CBoxSocket *    psock;          // a socket in a box
    CBoxLink *      plink;          // a link in CBoxNetDoc
    CPoint          ptProject;      // point on link line segment nearest <pt>

    // set <pt> to the location of the cursor
    ::GetCursorPos(&pt);
    ScreenToClient(&pt);

    // hit-test all items in document
    eHit = HitTest(pt, &pbox, &tabpos, &psock, &plink, &ptProject);

    // set the cursor and/or set status bar text accordingly
    switch(eHit)
    {

    case CBoxDraw::HT_MISS:         // didn't hit anything

        // default message
        MFGBL(SetStatus(AFX_IDS_IDLEMESSAGE));
        break;

    case CBoxDraw::HT_TAB:          // hit a box tab <*ppsock>

        MFGBL(SetStatus(IDS_STAT_BOXTABEMPTY));
        break;

    case CBoxDraw::HT_EDGE:         // hit the edge box (set <*ptabpos> to it)
    case CBoxDraw::HT_BOX:          // hit elsewhere on the box
    case CBoxDraw::HT_BOXLABEL:     // hit the box label
    case CBoxDraw::HT_BOXFILE:      // hit the box filename
    case CBoxDraw::HT_TABLABEL:     // hit box tab label <*ppsock>

        // can drag box to move it
        MFGBL(SetStatus(IDS_STAT_MOVEBOX));
        break;

    case CBoxDraw::HT_LINKLINE:     // hit a link line segment
        MFGBL(SetStatus(AFX_IDS_IDLEMESSAGE));
        break;
    }

    return CScrollView::OnSetCursor(pWnd, nHitTest, message);
}


BOOL CBoxNetView::OnEraseBkgnd(CDC* pdc)
{
    // do nothing -- OnDraw() draws the background
    return TRUE;
}


void CBoxNetView::OnLButtonDown(UINT nFlags, CPoint pt)
{
    CBoxNetDoc *    pdoc = GetDocument();
    CBoxDraw::EHit  eHit;           // hit-test result code
    CBox *          pbox;           // clicked-on box (NULL if none)
    CBoxTabPos      tabpos;         // the position of a socket tab on a box
    CBoxSocket *    psock;          // clicked-on socket tab (if applicable)
    CBoxLink *      plink;          // clicked-on link (if applicable)
    CPoint          ptProject;      // point on link line segment nearest <pt>
    CSize           siz;

    // see what item mouse clicked on
    eHit = HitTest(pt, &pbox, &tabpos, &psock, &plink, &ptProject);

    // enter mouse-drag mode
    MouseDragBegin(nFlags, pt, pbox);

    // figure out what action to take as a result of the click
    switch(eHit)
    {

    case CBoxDraw::HT_BOX:
    case CBoxDraw::HT_BOXLABEL:
    case CBoxDraw::HT_BOXFILE:
    case CBoxDraw::HT_TABLABEL:

        // user clicked on box <pbox>

        if (!pbox->IsSelected()) {      // user clicked on an unselected box

            if (!m_fMouseShift || pdoc->IsSelectionEmpty()) {   // deselect all, select this box

                GetDocument()->DeselectAll();
                pdoc->SelectBox(pbox, TRUE);
            }
            else {      // shift-click -- add box to selection

                pdoc->SelectBox(pbox, TRUE);
            }
        }

        // enter move-selection-pending mode (start moving the selection if
        // the user waits long enough or drags the mouse far enough)
        MoveBoxSelPendingBegin(pt);
        break;

    case CBoxDraw::HT_TAB:

        // user clicked on the box tab of socket <psock>
        if (psock->m_plink == NULL) {
            NewLinkBegin(pt, psock);            // enter new-link mode
        }

        break;

    case CBoxDraw::HT_LINKLINE:

        if (!m_fMouseShift || pdoc->IsSelectionEmpty()) { // deselect all, select this link

            GetDocument()->DeselectAll();
            pdoc->SelectLink(plink, TRUE);
        }
        else {  // shift-click -- add box to link

            pdoc->SelectLink(plink, TRUE);
        }

        break;

    default:

        // didn't click on anything -- deselect all items and enter
        // select-rectangle mode
        GetDocument()->DeselectAll();
        SelectRectBegin(pt);
        break;

    }

    CScrollView::OnLButtonDown(nFlags, pt);
}


void CBoxNetView::OnMouseMove(UINT nFlags, CPoint pt)
{
    // do nothing if not currently in mouse-drag mode
    if (!m_fMouseDrag)
        return;

    // update active modes
    if (m_fMoveBoxSelPending)
        MoveBoxSelPendingContinue(pt);
    if (m_fMoveBoxSel)
        MoveBoxSelContinue(pt - m_ptMouseAnchor);
    if (m_fSelectRect)
        SelectRectContinue(pt);
    if (m_fNewLink)
        NewLinkContinue(pt);

    // update drag state
    MouseDragContinue(pt);

    CScrollView::OnMouseMove(nFlags, pt);
}


void CBoxNetView::OnLButtonUp(UINT nFlags, CPoint pt) {

    // do nothing if not currently in mouse-drag mode
    if (!m_fMouseDrag)
        return;

    // update active modes
    if (m_fMoveBoxSelPending)
        MoveBoxSelPendingEnd(TRUE);
    if (m_fMoveBoxSel)
        MoveBoxSelEnd(FALSE);
    if (m_fSelectRect)
        SelectRectEnd(FALSE);
    if (m_fNewLink)
        NewLinkEnd(m_psockHilite == NULL);

    // update drag state
    MouseDragEnd();

    CScrollView::OnLButtonUp(nFlags, pt);
}


void CBoxNetView::OnTimer(UINT nIDEvent)
{
    // dispatch timer to code that created it
    switch (nIDEvent)
    {

    case TIMER_MOVE_SEL_PENDING:
        MoveBoxSelPendingEnd(FALSE);
        break;

    case TIMER_SEEKBAR:
        // In case KillTimer isn't working, check the global timer ID
        if (MFGBL(m_nSeekTimerID))  
            CheckSeekBar( );
        break;

    case TIMER_PENDING_RECONNECT:
        CBoxNetDoc* pDoc = GetDocument();

        HRESULT hr = pDoc->ProcessPendingReconnect();

        // ProcessPendingReconnect() returns S_OK if the output pin was successfully reconnected.
        if( S_OK == hr ) {
            AfxMessageBox( IDS_ASYNC_RECONNECT_SUCCEEDED );
        } else if( FAILED( hr ) ) {
            CString strErrorMessage;

            try
            {
                strErrorMessage.Format( IDS_ASYNC_RECONNECT_FAILED, hr );
                if( 0 == AfxMessageBox( (LPCTSTR)strErrorMessage ) ) {
                    TRACE( TEXT("WARNING: ProcessPendingReconnect() failed but the user could not be notified because AfxMessageBox() also failed.") );
                }

            } catch( CMemoryException* pOutOfMemory ) {
                pOutOfMemory->Delete();
                TRACE( TEXT("WARNING: ProcessPendingReconnect() failed but the user could not be notified because a CMemoryException was thrown.") );
            }
        }
   
        break;
    }

    CScrollView::OnTimer(nIDEvent);
}


void CBoxNetView::OnCancelModes() {

    CancelModes();
}


//
// OnRButtonDown
//
// Pop up a context sensitive shortcut menu
void CBoxNetView::OnRButtonDown(UINT nFlags, CPoint point)
{
    CBoxNetDoc      *pdoc = GetDocument();
    CBoxDraw::EHit  eHit;               // hit-test result code
    CBox            *pbox;              // clicked-on box (NULL if none)
    CBoxTabPos      tabpos;             // the position of a socket tab on a box
    CBoxSocket      *psock;             // clicked-on socket tab (if applicable)
    CBoxLink        *plink;             // clicked-on link (if applicable)
    CPoint          ptProject;          // point on link line segment nearest <pt>

    // see what item mouse clicked on
    eHit = HitTest(point, &pbox, &tabpos, &psock, &plink, &ptProject);

    // figure out what action to take as a result of the click
    switch(eHit)
    {

    case CBoxDraw::HT_BOX:
    case CBoxDraw::HT_BOXLABEL:
    case CBoxDraw::HT_BOXFILE:
    case CBoxDraw::HT_TABLABEL: {
            // user clicked on box <pbox>

            pdoc->CurrentPropObject(pbox);

            CMenu       menu;
            menu.LoadMenu(IDR_FILTERMENU);
            CMenu *menuPopup = menu.GetSubMenu(0);

            ASSERT(menuPopup != NULL);

            PrepareFilterMenu(menuPopup, pbox);

            // point is relative to our window origin, but we need it relative
            // to the screen origin
            CRect rcWindow;
            GetWindowRect(&rcWindow);
            CPoint ScreenPoint = rcWindow.TopLeft() + CSize(point);

            menuPopup->TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON
                                     , ScreenPoint.x
                                     , ScreenPoint.y
                                     , this
                                     );
        }
        break;

    case CBoxDraw::HT_TAB: {
            // user clicked on the box tab of socket <psock>

            pdoc->SelectedSocket(psock);        // set the selected socket, so the ui can be updated correctly
            pdoc->CurrentPropObject(psock);

            CMenu       menu;
            menu.LoadMenu(IDR_PINMENU);
            CMenu *menuPopup = menu.GetSubMenu(0);

            ASSERT(menuPopup != NULL);

            PreparePinMenu(menuPopup);

            // point is relative to our window origin, but we need it relative
            // to the screen origin
            CRect rcWindow;
            GetWindowRect(&rcWindow);
            CPoint ScreenPoint = rcWindow.TopLeft() + CSize(point);

            menuPopup->TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON
                                     , ScreenPoint.x
                                     , ScreenPoint.y
                                     , this
                                     );
        }
        break;

    case CBoxDraw::HT_LINKLINE: {       // the filter menu (properties) also applies
                                        // to links
            // user clicked on link <plink>

            pdoc->CurrentPropObject(plink);

            CMenu       menu;
            menu.LoadMenu(IDR_LINKMENU);
            CMenu *menuPopup = menu.GetSubMenu(0);

            ASSERT(menuPopup != NULL);

            PrepareLinkMenu(menuPopup);

            // point is relative to our window origin, but we need it relative
            // to the screen origin
            CRect rcWindow;
            GetWindowRect(&rcWindow);
            CPoint ScreenPoint = rcWindow.TopLeft() + CSize(point);

            menuPopup->TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON
                                     , ScreenPoint.x
                                     , ScreenPoint.y
                                     , this
                                     );
        }
        break;

    default:
        break;

    }

        
    CScrollView::OnRButtonDown(nFlags, point);
}


//
// OnUpdateProperties
//
void CBoxNetView::OnUpdateProperties(CCmdUI* pCmdUI) {

    pCmdUI->Enable(GetDocument()->CurrentPropObject()->CanDisplayProperties());
}

//
// OnProperties
//
// The user wants to  edit/view the properties of the
// selected object
void CBoxNetView::OnProperties() {

    GetDocument()->CurrentPropObject()->CreatePropertyDialog(this);
}

//
// OnUpdateSelectClock
//
//void CBoxNetView::OnUpdateSelectClock(CCmdUI* pCmdUI)
//{
//}

//
// OnSelectClock
//
void CBoxNetView::OnSelectClock()
{
    ASSERT (m_pSelectClockFilter);
    GetDocument()->SetSelectClock(m_pSelectClockFilter);

    m_pSelectClockFilter = NULL;
}


//
// PrepareLinkMenu
//
void CBoxNetView::PrepareLinkMenu(CMenu *menuPopup) {

    if (GetDocument()->CurrentPropObject()->CanDisplayProperties()) {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_ENABLED);
    }
    else {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_GRAYED);
    }
}

//
// PrepareFilterMenu
//
// The MFC OnUpdate routing does not get popups right. therefore
// DIY
void CBoxNetView::PrepareFilterMenu(CMenu *menuPopup, CBox *pbox) {

    if (GetDocument()->CurrentPropObject()->CanDisplayProperties()) {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_ENABLED);
    }
    else {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_GRAYED);
    }

    //
    // Only enable clock selection if the filter has a clock and it
    // is not yet selected.
    //
    if (pbox->HasClock() && !pbox->HasSelectedClock()) {
        menuPopup->EnableMenuItem(ID__SELECTCLOCK, MF_ENABLED);
    }
    else {
        menuPopup->EnableMenuItem(ID__SELECTCLOCK, MF_GRAYED);
    }

    m_pSelectClockFilter = pbox;
}


//
// PreparePinMenu
//
// The MFC OnUpdate routing does not get popups right. therefore
// DIY
void CBoxNetView::PreparePinMenu(CMenu *menuPopup) {

    if (GetDocument()->CurrentPropObject()->CanDisplayProperties()) {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_ENABLED);
    }
    else {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_GRAYED);
    }

    if (CCmdRender::CanDo(GetDocument())) {
        menuPopup->EnableMenuItem(ID_RENDER, MF_ENABLED);
    }
    else {
        menuPopup->EnableMenuItem(ID_RENDER, MF_GRAYED);
    }

    if (CCmdReconnect::CanDo(GetDocument())) {
        menuPopup->EnableMenuItem(ID_RECONNECT, MF_ENABLED);
    } else {
        menuPopup->EnableMenuItem(ID_RECONNECT, MF_GRAYED);
    }
}


void CBoxNetView::OnUpdateEditDelete(CCmdUI* pCmdUI) {
    // Delete is enabled if the selection is not empty
    pCmdUI->Enable( CCmdDeleteSelection::CanDo(GetDocument()) );
        
}


void CBoxNetView::OnEditDelete()  {

    GetDocument()->CmdDo(new CCmdDeleteSelection());

}

//
// OnUpdateSave
//
// Disable Save for BETA 1!
//
// void CBoxNetView::OnUpdateSave(CCmdUI* pCmdUI)
// {
//    pCmdUI->Enable(FALSE);         // Disable Save
// }


//
// --- Performance Logging ---
//
// I dynamically load measure.dll in the CBoxNetView constructor.
// if anyone uses it (staically or dynamically) they will get this
// copy of the dll. I provide access to the dump log procedure.

//
// OnUpdateSavePerfLog
//
// Enable dumping of the log when NOPERF is not defined
void CBoxNetView::OnUpdateSavePerfLog(CCmdUI* pCmdUI) {

    pCmdUI->Enable((m_hinstPerf != NULL));

}


//
// OnSavePerfLog
//
// Dump the performance log to the user specified file
void CBoxNetView::OnSavePerfLog() {

    CString strText;
    CString szDumpProc;
    szDumpProc.LoadString(IDS_DUMP_PROC);

    ASSERT(m_hinstPerf);

    MSR_DUMPPROC *DumpProc;
    DumpProc = (MSR_DUMPPROC *) GetProcAddress(m_hinstPerf, szDumpProc);
    if (DumpProc == NULL) {
        AfxMessageBox(IDS_NO_DUMP_PROC);
        return;
    }

    strText.LoadString( IDS_TEXT_FILES );

    CFileDialog SaveLogDialog(FALSE,
                              ".txt",
                              "PerfLog.txt",
                              0,
                              strText,
                              this);

    if( IDOK == SaveLogDialog.DoModal() ){
        HANDLE hFile = CreateFile(SaveLogDialog.GetPathName(),
                                  GENERIC_WRITE,
                                  0,
                                  NULL,
                                  CREATE_ALWAYS,
                                  0,
                                  NULL);

        if (hFile == INVALID_HANDLE_VALUE) {
            AfxMessageBox(IDS_BAD_PERF_LOG);
            return;
        }

        DumpProc(hFile);           // This writes the log out to the file

        CloseHandle(hFile);
    }
                
}


void CBoxNetView::OnFileSetLog( void ){
    CString strText;
    HANDLE hRenderLog;

    strText.LoadString( IDS_TEXT_FILES );

    CFileDialog SaveLogDialog(FALSE
                             ,".txt"
                             ,""
                                         ,0
                                         ,strText
                                         ,this
                             );

    if( IDOK == SaveLogDialog.DoModal() ){
        hRenderLog = CreateFile( SaveLogDialog.GetPathName()
                               , GENERIC_WRITE
                               , 0    // no sharing
                               , NULL // no security
                               , OPEN_ALWAYS
                               , 0    // no attributes, no flags
                               , NULL // no template
                               );

        if (hRenderLog!=INVALID_HANDLE_VALUE) {
            // Seek to end of file
            SetFilePointer(hRenderLog, 0, NULL, FILE_END);
            GetDocument()->IGraph()->SetLogFile((DWORD_PTR) hRenderLog);
        }
    }
}

//
// OnUpdateNewPerfLog
//
// Grey the item if measure.dll was not found
void CBoxNetView::OnUpdateNewPerfLog(CCmdUI* pCmdUI) {

    pCmdUI->Enable((m_hinstPerf != NULL));
        
}


//
// OnNewPerfLog
//
// Reset the contents of the one and only performance log.
void CBoxNetView::OnNewPerfLog() {

    CString szControlProc;
    szControlProc.LoadString(IDS_CONTROL_PROC);

    ASSERT(m_hinstPerf);

    MSR_CONTROLPROC *ControlProc;
    ControlProc = (MSR_CONTROLPROC *) GetProcAddress(m_hinstPerf, szControlProc);
    if (ControlProc == NULL) {
        AfxMessageBox(IDS_NO_CONTROL_PROC);
        return;
    }

    ControlProc(MSR_RESET_ALL);
}

// *** Drag and drop functions ***

//
// OnCreate
//
// Register this window as a drop target
int CBoxNetView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CView::OnCreate(lpCreateStruct) == -1)
        return -1;

    // We can handle CFSTR_VFW_FILTERLIST, the base class provides for
    // file drag and drop.
    m_cfClipFormat = (CLIPFORMAT) RegisterClipboardFormat( CFSTR_VFW_FILTERLIST );
    m_DropTarget.Register( this );
        
    return 0;
}


DROPEFFECT CBoxNetView::OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
    //
    // If the filter graph is not stopped we don't want filters to be
    // dropped onto GraphEdt
    //
    if (!CCmdAddFilter::CanDo(GetDocument())) {
        return(m_DropEffect = DROPEFFECT_NONE);
    }

    // Can we handle this format?
    if( pDataObject->IsDataAvailable( m_cfClipFormat ) )
        return (m_DropEffect = DROPEFFECT_COPY);

    // No, see if the base class can
    m_DropEffect = DROPEFFECT_NONE;
    return CView::OnDragEnter(pDataObject, dwKeyState, point);
}

DROPEFFECT CBoxNetView::OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
    // Can we handle this format?
    if( m_DropEffect == DROPEFFECT_COPY )
        return m_DropEffect;

    // No, see if the base class can
    return CView::OnDragEnter(pDataObject, dwKeyState, point);
}

//
// OnUser
//
// On event notifications from the filter graph a WM_USER message is
// being posted from a thread which waits for these notifications.
// We just pass the call on to the handler in the document.
//
// We need to return 1 to indicate that the message has been handled
//
afx_msg LRESULT CBoxNetView::OnUser(WPARAM wParam, LPARAM lParam)
{
    //
    // Call the handler on CBoxNetDoc
    //
    GetDocument()->OnWM_USER((NetDocUserMessage *) lParam);

    return(1);
}

void CBoxNetView::ShowSeekBar( )
{
    MFGBL(ToggleSeekBar( ));
}

void CBoxNetView::OnViewSeekbar() 
{
    MFGBL(ToggleSeekBar());
}

void CBoxNetView::CheckSeekBar( )
{
    CGraphEdit * pMainFrame = (CGraphEdit*) AfxGetApp( );
    CWnd * pMainWnd = pMainFrame->m_pMainWnd;
    CMainFrame * pF = (CMainFrame*) pMainWnd;
    CQCOMInt<IMediaSeeking> IMS( IID_IMediaSeeking, GetDocument()->IGraph() );
    if( !IMS )
    {
        return;
    }

    REFERENCE_TIME Duration = 0;
    if(FAILED(IMS->GetDuration( &Duration )) || Duration == 0) {
        return;
    }

    REFERENCE_TIME StartTime;
    REFERENCE_TIME StopTime;
    if( pF->m_wndSeekBar.DidPositionChange( ) )
    {
        double Pos = pF->m_wndSeekBar.GetPosition( );
        StartTime = REFERENCE_TIME( Pos * double( Duration ) );
        IMS->SetPositions( &StartTime, AM_SEEKING_AbsolutePositioning, NULL, AM_SEEKING_NoPositioning );
        if( pF->m_wndSeekBar.IsSeekingRandom( ) )
        {
            CQCOMInt<IMediaControl> IMC( IID_IMediaControl, GetDocument()->IGraph() );
            IMC->Run( );
        }
    }

    StartTime = 0;
    StopTime = 0;
    IMS->GetCurrentPosition( &StartTime );

    pF->m_wndSeekBar.SetPosition( double( StartTime ) / double( Duration ) );

}

void CBoxNetView::OnDestroy() 
{
	CScrollView::OnDestroy();
	
    // Fix Manbugs #33781
    //
    // This call used to live in the ~CBoxNetView destructor.
    // When running with debug MFC libraries, we would get an ASSERT failure
    // in CWnd::KillTimer.  Since the owning window had already been destroyed,
    // the inline ASSERT(::IsWindow(m_hWnd)) call failed.  
    //
    // Fix is to kill the timer during processing of WM_DESTROY, when 
    // the window handle is still valid.

    if (MFGBL(m_nSeekTimerID))  
    {
        int rc = ::KillTimer( MFGBL(m_hwndTimer), MFGBL(m_nSeekTimerID));
        MFGBL(m_nSeekTimerID) = 0;
    }
}


BOOL CBoxNetView::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt) 
{
    CBoxNetDoc *pdoc = GetDocument();

    // If it's a CTRL+Mouse wheel, adjust the zoom level
    if (nFlags & MK_CONTROL)
    {
        if (zDelta < 0)
            pdoc->IncreaseZoom();
        else
            pdoc->DecreaseZoom();
    }
    	
	return CScrollView::OnMouseWheel(nFlags, zDelta, pt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\cmd.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// cmd.h : declares CCmd and the CCmdXXX classes based on it
//


/////////////////////////////////////////////////////////////////////////////
// CCmd
//
// CCmd is a virtual class that implements an interface to commands performed
// on a CBoxNetDoc.
//
// A CCmd represents a command given to a CBoxNetDoc.  To perform a command,
// allocate a CCmdXXX structure and submit it to CBoxNetDoc::CmdDo(), which
// will call the Do() memeber function.  The Undo() and Redo() member functions
// get called when the user performs an Undo or Redo action, respectively.
// Repeat() should create a duplicate of the command, to perform a Repeat
// action; if this is not possible, return FALSE from CanRepeat().
// The destructor gets called when there is no chance the command will be
// undone or redone; at this time, <fRedo> will be TRUE if the command is on
// the redo stack (so e.g. the CBox in a CCmdNewBox command should be freed)
// or FALSE if the command is on the undo stack (so e.g. the CBox in a
// CCmdNewBox command should not be freed since it is currently in use by
// the document).
//
// CanUndo() returns TRUE iff Undo() is implemented.  CanRepeat() returns
// TRUE iff Repeat() can be called at that time (e.g. some commands depend
// on there being something selected at that time).
//
// Some subclasses of CCmd implement a static CanDo() method which returns
// TRUE if a command of that class can be created and Do() can be called at
// that time.
//

class CCmd : public CObject {
public:
    BOOL       m_fRedo;            // command is sitting in the Redo stack

public:

    CCmd(void) : m_fRedo(FALSE) {;}
    virtual ~CCmd() {;}
    virtual unsigned GetLabel() = 0;

    // Perform the command on this document
    virtual void Do(CBoxNetDoc *pdoc) = 0;

    // If CanUndo() then Undo & redo can be called
    virtual BOOL CanUndo(CBoxNetDoc *pdoc)	{ return FALSE; }
    virtual void Undo(CBoxNetDoc *pdoc)		{;}
    virtual void Redo(CBoxNetDoc *pdoc)		{;}

    virtual BOOL CanRepeat(CBoxNetDoc *pdoc)	{ return FALSE; }
    virtual CCmd *Repeat(CBoxNetDoc *pdoc)	{ return NULL; }
};


//
// --- CCmdAddFilter ---
//
class CCmdAddFilter : public CCmd {
protected:
    CBox        *m_pbox;        // box being created
    CBoxNetDoc  *m_pdoc;	// document to add it to
    BOOL	m_fAdded;	// TRUE iff filter added to graph

    CQCOMInt<IMoniker> m_pMoniker; // keep moniker so we can repeat
    CString	m_stLabel;	// keep label for repeat

public:
    virtual unsigned GetLabel(void)	{ return IDS_CMD_ADDFILTER; }
    CCmdAddFilter(IMoniker *pMon, CBoxNetDoc *pdoc, CPoint point = CPoint(-1, -1));
    virtual ~CCmdAddFilter();

    virtual void Do(CBoxNetDoc *pdoc);

    static BOOL CanDo(CBoxNetDoc *pdoc);
    virtual BOOL CanUndo(CBoxNetDoc *pdoc)	{ return TRUE; }
    virtual void Undo(CBoxNetDoc *pdoc);
    virtual void Redo(CBoxNetDoc *pdoc);

    virtual BOOL CanRepeat(CBoxNetDoc *pdoc) { return TRUE; }
    virtual CCmd *Repeat(CBoxNetDoc *pdoc);
};


//
// --- CCmdDeleteSelection ---
//
class CCmdDeleteSelection : public CCmd {

public:
    virtual unsigned GetLabel(void) { return IDS_CMD_DELETE; }

    static BOOL CanDo(CBoxNetDoc *pdoc);
    virtual void Do(CBoxNetDoc *pdoc);

    virtual BOOL CanRepeat(CBoxNetDoc *pdoc);
    virtual CCmd * Repeat(CBoxNetDoc *pdoc);

private:

    void DeleteFilters(CBoxNetDoc *pdoc);
    void DeleteLinks(CBoxNetDoc *pdoc);
};


//
// --- CCmdMoveBoxes ---
//
class CCmdMoveBoxes : public CCmd {
protected:
    CSize           m_sizOffset;        // how much selection is offset by
    CBoxList        m_lstBoxes;         // list containing each CBox to move

public:

    virtual unsigned GetLabel();
    CCmdMoveBoxes(CSize sizOffset);
    virtual ~CCmdMoveBoxes();

    static BOOL CanDo(CBoxNetDoc *pdoc);
    virtual void Do(CBoxNetDoc *pdoc);

    virtual BOOL CanUndo(CBoxNetDoc *pdoc) { return TRUE; }
    virtual void Undo(CBoxNetDoc *pdoc);
    virtual void Redo(CBoxNetDoc *pdoc);

    virtual BOOL CanRepeat(CBoxNetDoc *pdoc);
    virtual CCmd * Repeat(CBoxNetDoc *pdoc);
};


//
// --- CCmdConnect ---
//
class CCmdConnect : public CCmd {
protected:
    CBoxLink *      m_plink;            // link being created

public:
    virtual unsigned GetLabel(void) { return IDS_CMD_CONNECT; }
    CCmdConnect(CBoxSocket *psockTail, CBoxSocket *psockHead);

    virtual void Do(CBoxNetDoc *pdoc);
};


//
// --- CCmdDisconnectAll ---
//
class CCmdDisconnectAll : public CCmd {

public:

    CCmdDisconnectAll();
    virtual ~CCmdDisconnectAll();

    static BOOL CanDo(CBoxNetDoc *pdoc);
    virtual unsigned GetLabel(void) { return IDS_CMD_DISCONNECTALL; }
    virtual void Do(CBoxNetDoc *pdoc);

    virtual void Redo(CBoxNetDoc *pdoc);
};


//
// --- CCmdRender ---
//
class CCmdRender : public CCmd {

public:

    static BOOL		CanDo( CBoxNetDoc *pdoc );
    virtual unsigned	GetLabel() { return IDS_CMD_RENDER; }
    virtual void	Do(CBoxNetDoc *pdoc);

};


//
// --- CCmdRenderFile ---
//
class CCmdRenderFile : public CCmd {

public:

    CCmdRenderFile(CString FileName) : m_FileName(FileName) {}

    static BOOL		CanDo(void) { return TRUE; }
    virtual unsigned	GetLabel() { return IDS_CMD_RENDERFILE; }

    virtual void	Do(CBoxNetDoc *pdoc);

private:

    CString m_FileName;
};

class CCmdAddFilterToCache : public CCmd
{
public:
    unsigned GetLabel();

    static BOOL CanDo( CBoxNetDoc *pdoc );
    void Do( CBoxNetDoc *pdoc );

private:
    HRESULT IsCached( IGraphConfig* pFilterCache, IBaseFilter* pFilter );

};

class CCmdReconnect : public CCmd
{
public:
    unsigned CCmdReconnect::GetLabel();
    static BOOL CanDo( CBoxNetDoc* pDoc );
    void Do( CBoxNetDoc* pDoc );

private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\enum.cpp ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// enum.cpp
//
// A set of wrappers for COM enumerators.

#include "stdafx.h"

// *
// * CFilterEnum
// *

//
// CFilterEnum::Constructor
//
CFilterEnum::CFilterEnum(IFilterGraph *pGraph) {

    ASSERT(pGraph);

    HRESULT hr = pGraph->EnumFilters(&m_pEnum);
    if (FAILED(hr))
        throw CHRESULTException(hr);

}


//
// CFilterEnum::Destructor
//
CFilterEnum::~CFilterEnum(void) {

    ASSERT(m_pEnum);

    m_pEnum->Release();
}


//
// operator()
//
// Use to get next filter
// !!!Does this return AddRef()'d pointers?
IBaseFilter *CFilterEnum::operator() (void) {

    ASSERT(m_pEnum);

    ULONG	ulActual;
    IBaseFilter	*aFilter[1];

    HRESULT hr = m_pEnum->Next(1, aFilter, &ulActual);
    if (SUCCEEDED(hr) && (ulActual == 0) )	// no more filters
        return NULL;
    else if (FAILED(hr) || (ulActual != 1) )	// some unexpected problem occured
        throw CE_FAIL();

    return aFilter[0];
}


// *
// * CPinEnum
// *

// Enumerates a filters pins.

//
// Constructor
//
// Set the type of pins to provide - PINDIR_INPUT, PINDIR_OUTPUT or all
CPinEnum::CPinEnum(IBaseFilter *pFilter, DirType Type)
    : m_Type(Type) {

    if (Type == Input) {

        m_EnumDir = ::PINDIR_INPUT;
    }
    else if (Type == Output) {

        m_EnumDir = ::PINDIR_OUTPUT;
    }

    ASSERT(pFilter);

    HRESULT hr = pFilter->EnumPins(&m_pEnum);
    if (FAILED(hr)) {
        throw CHRESULTException(hr);
    }
}


//
// CPinEnum::Destructor
//
CPinEnum::~CPinEnum(void) {

    ASSERT(m_pEnum);

    m_pEnum->Release();
}


//
// operator()
//
// return the next pin, of the requested type. return NULL if no more pins.
IPin *CPinEnum::operator() (void) {

    ASSERT(m_pEnum);

    ULONG	ulActual;
    IPin	*aPin[1];
    PIN_DIRECTION pd;

    for (;;) {

        HRESULT hr = m_pEnum->Next(1, aPin, &ulActual);
        if (SUCCEEDED(hr) && (ulActual == 0) ) {	// no more filters
            return NULL;
        }
        else if (FAILED(hr) || (ulActual != 1) ) {	// some unexpected problem occured
            throw CE_FAIL();
        }

        hr = aPin[0]->QueryDirection(&pd);
        if (FAILED(hr)) {
	    aPin[0]->Release();
            throw CHRESULTException(hr);
        }

        // if m_Type == All return the first pin we find
        // otherwise return the first of the correct sense

        if (m_Type == All || pd == m_EnumDir) {
            return aPin[0];
        } else {
            aPin[0]->Release();
        }
    }
}


// *
// * CRegFilterEnum
// *

//
// Constructor
//
// Query the supplied mapper for an enumerator for the
// requested filters.
CRegFilterEnum::CRegFilterEnum(IFilterMapper	*pMapper,
                   		DWORD	dwMerit,		// See IFilterMapper->EnumMatchingFilters
                   		BOOL	bInputNeeded,	// for the meanings of these parameters.
                   		CLSID	clsInMaj,	// the defaults will give you all
                   		CLSID	clsInSub,	// filters
                   		BOOL	bRender,
                   		BOOL	bOutputNeeded,
                   		CLSID	clsOutMaj,
                   		CLSID	clsOutSub) {

    HRESULT hr = pMapper->EnumMatchingFilters(&m_pEnum,
                                              dwMerit,
                                              bInputNeeded,
                                              clsInMaj,
                                              clsInSub,
                                              bRender,
                                              bOutputNeeded,
                                              clsOutMaj,
                                              clsOutSub);
    if (FAILED(hr)) {
        throw CHRESULTException(hr);
    }
}


//
// Destructor
//
CRegFilterEnum::~CRegFilterEnum(void) {

    ASSERT(m_pEnum);

    m_pEnum->Release();
}


//
// operator()
//
CRegFilter *CRegFilterEnum::operator() (void) {

    ASSERT(m_pEnum);

    ULONG	ulActual;
    REGFILTER	*arf[1];

    HRESULT hr = m_pEnum->Next(1, arf, &ulActual);
    if (SUCCEEDED(hr) && (ulActual == 0)) {
        return NULL;
    }
    else if (FAILED(hr) || (ulActual != 1)) {
        throw CE_FAIL();
    }

    // transfer from TaskMem to 'new' mem

    CRegFilter *prf = new CRegFilter(arf[0]);
    if (prf == NULL) {
        throw CE_OUTOFMEMORY();
    }

    CoTaskMemFree(arf[0]);

    return prf;
}


// *
// * CRegFilter
// *


//
// Constructor
//
CRegFilter::CRegFilter(REGFILTER *prf)
    : m_Name(prf->Name),
      m_clsid(prf->Clsid) {
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\dcf.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#if !defined(AFX_DCF_H__845A3484_250D_11D3_A03B_006097DBEC02__INCLUDED_)
#define AFX_DCF_H__845A3484_250D_11D3_A03B_006097DBEC02__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CDisplayCachedFilters dialog

#define DCF_OUT_OF_MEMORY       -1;

class CFilterListBox;

class CDisplayCachedFilters : public CDialog
{
// Construction
public:
    CDisplayCachedFilters::CDisplayCachedFilters
        (
        IGraphConfig* pFilterCache,
        HRESULT* phr,
        CWnd* pParent = NULL
        );
    ~CDisplayCachedFilters();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDisplayCachedFilters)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CDisplayCachedFilters)
    virtual BOOL OnInitDialog();
    virtual void OnErrSpaceCachedFilters();
    afx_msg void OnRemoveFilter();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    HRESULT AddCachedFilterNamesToListBox( void );

    #ifdef _DEBUG
    static HRESULT IsCached( IGraphConfig* pFilterCache, IBaseFilter* pFilter );
    static HRESULT TestTheFilterCachesIEnumFiltersInterface( IEnumFilters* pCachedFiltersEnum, IBaseFilter* pCurrentFilter, DWORD dwNumFiltersExamended );
    #endif // _DEBUG

    IGraphConfig* m_pFilterCache;
    CFilterListBox* m_plbCachedFiltersList;

// Dialog Data
    //{{AFX_DATA(CDisplayCachedFilters)
    enum { IDD = IDD_CACHED_FILTERS };
    //}}AFX_DATA
};

#endif // !defined(AFX_DCF_H__845A3484_250D_11D3_A03B_006097DBEC02__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\enum.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// Filter enumerator
//

// Rather than throwing exceptions I could make the class fail silently...
class CFilterEnum {

public:

    CFilterEnum(IFilterGraph *pGraph);
    ~CFilterEnum();

    // returns the next filter, or NULL if there are no more.
    IBaseFilter * operator() (void);

private:

    IEnumFilters	*m_pEnum;
};


//
// Pin Enumerator.
//
// Can enumerate all pins, or just one direction (input or output)
class CPinEnum {

public:

    enum DirType {Input, Output, All};

    CPinEnum(IBaseFilter *pFilter, DirType Type = All);
    ~CPinEnum();

    // the returned interface is addref'd
    IPin *operator() (void);

private:

    PIN_DIRECTION m_EnumDir;
    DirType	m_Type;

    IEnumPins	*m_pEnum;
};


//
// CRegFilter
//
// The object you are passed back from operator() in
// CRegFilterEnum
class CRegFilter {
public:

    CRegFilter(REGFILTER *);	// copies what it needs from the
    				// supplied regfilter *


    CString Name(void) { return m_Name; }
    CLSID   Clsid(void) { return m_clsid; }

private:

    CString m_Name;
    CLSID   m_clsid;
};


//
// CRegFilterEnum
//
// Enumerates registered filters supplied by the mapper
class CRegFilterEnum {
public:

    CRegFilterEnum(IFilterMapper	*pMapper,
                   DWORD	dwMerit		= 0,		// See IFilterMapper->EnumMatchingFilters
                   BOOL		bInputNeeded	= FALSE,	// for the meanings of these parameters.
                   CLSID	clsInMaj	= CLSID_NULL,	// the defaults will give you all
                   CLSID	clsInSub	= CLSID_NULL,	// filters
                   BOOL		bRender		= FALSE,
                   BOOL		bOututNeeded	= FALSE,
                   CLSID	clsOutMaj	= CLSID_NULL,
                   CLSID	clsOutSub	= CLSID_NULL);
    ~CRegFilterEnum();

    // returns a pointer to a regfilter, that the caller
    // is responsible for freeing with delete
    CRegFilter *operator() (void);

private:

    IEnumRegFilters *m_pEnum;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\flb.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#if !defined(AFX_FILTERLISTBOX_H__45C6C059_F447_40B6_82F1_C954CB94596D__INCLUDED_)
#define AFX_FILTERLISTBOX_H__45C6C059_F447_40B6_82F1_C954CB94596D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// This error is returned if no filters are currently selected in the list box.
//#define GE_E_NO_FILTERS_ARE_SELECTED        MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0xFFFF )

class CFilterNameDictionary;

class CFilterListBox : public CListBox
{
public:
    CFilterListBox( HRESULT* phr );
    ~CFilterListBox();

    HRESULT AddFilter( IBaseFilter* pFilter );
    HRESULT GetSelectedFilter( IBaseFilter** ppSelectedFilter );
    HRESULT RemoveSelectedFilter( void );

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CFilterListBox)
    //}}AFX_VIRTUAL

private:
    HRESULT GetSelectedFilter( IBaseFilter** ppSelectedFilter, int* pnSelectedFilterIndex );

    CFilterNameDictionary* m_pfndFilterDictionary;
    CList<IBaseFilter*, IBaseFilter*>* m_pListedFilters;

    //{{AFX_MSG(CFilterListBox)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

#endif // !defined(AFX_FILTERLISTBOX_H__45C6C059_F447_40B6_82F1_C954CB94596D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\cmd.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// cmd.cpp : defines CCmd and the CCmdXXX classes based on it
//
// See cmd.h for a description of CCmd, the abstract class upon which
// all CCmdXXX classes are defined.
//

#include "stdafx.h"
#include "ReConfig.h"
#include "GEErrors.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static void MonGetName(IMoniker *pMon, CString *pStr)
{
    *pStr = "";
    IPropertyBag *pPropBag;
    HRESULT hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
    if(SUCCEEDED(hr))
    {
        VARIANT var;
        var.vt = VT_BSTR;
        hr = pPropBag->Read(L"FriendlyName", &var, 0);
        if(SUCCEEDED(hr))
        {
            *pStr = var.bstrVal;
            SysFreeString(var.bstrVal);
        }

        pPropBag->Release();
    }
}



//
// --- CCmdAddFilter ---
//
// Add a filter to the document.
// provide either a CLSID and the command will create
// the necessary UI element.


//
// Constructor
//
// CoCreate the filter and create its UI element
CCmdAddFilter::CCmdAddFilter(IMoniker *pMon, CBoxNetDoc *pdoc, CPoint point)
   :  m_pdoc(pdoc)
    , m_fAdded(FALSE)
    , m_pMoniker(pMon)
{
    {
        IBaseFilter *pFilter;
        HRESULT hr = pMon->BindToObject(0, 0, IID_IBaseFilter, (void **)&pFilter);
        if (FAILED(hr)) {
            throw CHRESULTException(hr);
        }

        CString szDevName;
        MonGetName(pMon, &szDevName);
        
        m_pbox = new CBox(pFilter, pdoc, &szDevName, point);
        pFilter->Release();
        if(m_pbox == 0) {       // !!! redundant?
            throw CHRESULTException(E_OUTOFMEMORY);
        }
    }
            
    
    m_pMoniker = pMon;          // addref automatic

    m_stLabel = m_pbox->Label();
}

//
// CanDo
//
// We can only add a filter if the filter graph is stopped
BOOL CCmdAddFilter::CanDo(CBoxNetDoc *pdoc)
{
    ASSERT(pdoc);

    return(pdoc->IsStopped());
}

//
// Do
//
// Add the box to the document, and add the filter to the graph
void CCmdAddFilter::Do(CBoxNetDoc *pdoc) {

    ASSERT(m_pdoc == pdoc);

    pdoc->DeselectAll();

    // select the box being added
    m_pbox->SetSelected(TRUE);

    HRESULT hr = m_pbox->AddToGraph();
    if (FAILED(hr)) {
        DisplayQuartzError( IDS_CANT_ADD_FILTER, hr );
	m_fAdded = FALSE;
	return;
    }
    // pins may have changed
    hr = m_pbox->Refresh();

    m_pbox->ShowDialog();	// show any property dialog

    // add the box to the document and update the view
    pdoc->m_lstBoxes.AddHead(m_pbox);
    pdoc->ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_BOX, m_pbox);

    m_fAdded = TRUE;

}


//
// Undo
//
void CCmdAddFilter::Undo(CBoxNetDoc *pdoc) {

    ASSERT(m_pdoc == pdoc);

    if (!m_fAdded) {
        return;		// the box was never added
    }

    // remove the box from the document and update the view
    pdoc->ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_BOX, m_pbox);

    pdoc->m_lstBoxes.RemoveHead();

    m_pbox->RemoveFromGraph();
    m_pbox->HideDialog();	// hide any property dialog
}


//
// Redo
//
void CCmdAddFilter::Redo(CBoxNetDoc *pdoc) {

    ASSERT(m_pdoc == pdoc);

    Do(pdoc);

}


//
// Repeat
//
// Construct an AddFilter command that adds the same filter
// to this document.
CCmd *CCmdAddFilter::Repeat(CBoxNetDoc *pdoc) {

    ASSERT(m_pdoc == pdoc);

    return new CCmdAddFilter(m_pMoniker, pdoc);
}


//
// Destructor
//
// delete m_pbox we are on the redo stack or if it was not added.
CCmdAddFilter::~CCmdAddFilter() {

    TRACE("~CCmdAddFilter() m_fRedo=%d\n", m_fRedo);

    if (m_fRedo) {	// on redo stack

        delete m_pbox;
    }
    else if (!m_fAdded) {	// on undo stack, but filter was not added

        delete m_pbox;
    }
}


//
// --- CCmdDeleteSelection ---
//


//
// CanDo
//
// Only possible if boxes are selected and the graph is stopped
BOOL CCmdDeleteSelection::CanDo(CBoxNetDoc *pdoc) {

    return ( !pdoc->IsSelectionEmpty() && pdoc->IsStopped() );
}


//
// Do
//
// 2 phases - Delete links, so that the neccessary connections are broken
//	    - Delete the filters. These are now unconnected, so safe to remove from the graph
void CCmdDeleteSelection::Do(CBoxNetDoc *pdoc) {

    DeleteLinks(pdoc);
    DeleteFilters(pdoc);

    //
    // Redraw the whole graph
    //
    pdoc->ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_ALL, NULL);
}


//
// DeleteLinks
//
// Remove the selected links from the document & disconnect them
//
void CCmdDeleteSelection::DeleteLinks(CBoxNetDoc *pdoc) {

    POSITION posNext = pdoc->m_lstLinks.GetHeadPosition();

    while (posNext != NULL) {

        POSITION posCurrent = posNext;
        CBoxLink *plink = (CBoxLink *) pdoc->m_lstLinks.GetNext(posNext);
	    if (plink->IsSelected()) {
	
    	    pdoc->m_lstLinks.RemoveAt(posCurrent);

            plink->Disconnect();

            delete plink;

            //
            // There might be links which where removed in the
            // Disconnect operation. We need to start from the beginning.
            //
            posNext = pdoc->m_lstLinks.GetHeadPosition();
	    }
    }
}


//
// DeleteFilters
//
// Remove the selected filters from the document & filtergraph
void CCmdDeleteSelection::DeleteFilters(CBoxNetDoc *pdoc) {

    POSITION posNext = pdoc->m_lstBoxes.GetHeadPosition();

    while (posNext != NULL) {

        POSITION posCurrent = posNext;
        CBox *pbox = pdoc->m_lstBoxes.GetNext(posNext);
        if (pbox->IsSelected()) {

	        pdoc->m_lstBoxes.RemoveAt(posCurrent);

	        pbox->RemoveFromGraph();
	        pbox->HideDialog();	// hide any property dialog on display

            delete pbox;
        }
    }
}


//
// Repeat
//
// Return a new DeleteSelection command
CCmd *CCmdDeleteSelection::Repeat(CBoxNetDoc *pdoc) {

    return (new CCmdDeleteSelection());
}


//
// CanRepeat
//
// If there is a selection this command is repeatable
BOOL CCmdDeleteSelection::CanRepeat(CBoxNetDoc *pdoc) {

    return CanDo(pdoc);
}


//
// --- CCmdMoveBoxes ---
//
// CCmdMoveBoxes(sizOffset) constructs a command to move the currently
// selected  boxes by <sizOffset> pixels.
//
// Member variables:
//  CSize           m_sizOffset;        // how much selection is offset by
//  CObList         m_lstBoxes;         // list containing each CBox to move
//
// <m_sizOffset> is the number of pixels the selection is to be offset by
// (in the x- and y-direction).  <m_lstBoxes> contains the list of boxes
// that will be moved.
//


BOOL CCmdMoveBoxes::CanDo(CBoxNetDoc *pdoc) {

    // can only move boxes if one or more boxes are selected
    return !pdoc->IsBoxSelectionEmpty();
}


unsigned CCmdMoveBoxes::GetLabel() {

    if (m_lstBoxes.GetCount() == 1)
        return IDS_CMD_MOVEBOX;             // singular form
    else
        return IDS_CMD_MOVEBOXES;           // plural form
}


CCmdMoveBoxes::CCmdMoveBoxes(CSize sizOffset)
    : m_lstBoxes(FALSE)		// don't want the boxes deleted with the command
    , m_sizOffset(sizOffset) {

}


void CCmdMoveBoxes::Do(CBoxNetDoc *pdoc) {

    // make a list of pointers to boxes that will be moved
    pdoc->GetBoxSelection(&m_lstBoxes);

    // move the boxes and update all views
    pdoc->MoveBoxSelection(m_sizOffset);
}


void CCmdMoveBoxes::Undo(CBoxNetDoc *pdoc) {

    // restore the original selection
    pdoc->SetBoxSelection(&m_lstBoxes);

    // move the boxes back to where they were and update all views
    pdoc->MoveBoxSelection(NegateSize(m_sizOffset));
}


void CCmdMoveBoxes::Redo(CBoxNetDoc *pdoc) {

    // restore the original selection
    pdoc->SetBoxSelection(&m_lstBoxes);

    // move the boxes and update all views
    pdoc->MoveBoxSelection(m_sizOffset);
}


CCmd * CCmdMoveBoxes::Repeat(CBoxNetDoc *pdoc) {

    return new CCmdMoveBoxes(m_sizOffset);
}


BOOL CCmdMoveBoxes::CanRepeat(CBoxNetDoc *pdoc) {

    return CanDo(pdoc);
}


CCmdMoveBoxes::~CCmdMoveBoxes() {

    TRACE("~CCmdMoveBoxes (%d,%d)\n", m_sizOffset.cx, m_sizOffset.cy);
}


//
// --- CCmdConnect ---
//
// Connect the two sockets. Construct the link with the arrow
// in the correct sense (connections always are output->input)
//
// If we connect intelligently the graph & doc will be updated, so
// we must delete this link.


//
// Constructor
//
// Construct the link with the correct direction sense
CCmdConnect::CCmdConnect(CBoxSocket *psock1, CBoxSocket *psock2)
{

    PIN_DIRECTION dir = psock1->GetDirection();

    if (dir == PINDIR_OUTPUT) {
        ASSERT((psock2->GetDirection()) == PINDIR_INPUT);

        m_plink = new CBoxLink(psock1, psock2);
    }
    else {
        ASSERT((psock1->GetDirection()) == PINDIR_INPUT);
        ASSERT((psock2->GetDirection()) == PINDIR_OUTPUT);

        m_plink = new CBoxLink(psock2, psock1);
    }
}


//
// Do
//
void CCmdConnect::Do(CBoxNetDoc *pdoc) {

    pdoc->BeginWaitCursor();

    // m_plink is our pointer to a _temporary_ link. Connect calls
    // DirectConnect and IntelligentConnect which, if sucessful, call
    // UpdateFilter. This calls GetLinksInGraph which will create
    // the permanent link
    HRESULT hr = m_plink->Connect();

    // We need to null these values out to avoid the link's destructor
    // nulling the connecting filters' pointers to the permanent link
    m_plink->m_psockHead = NULL;
    m_plink->m_psockTail = NULL;

    // And remove the temporary link
    delete m_plink;
    m_plink = NULL;

    if (FAILED(hr)) {

        DisplayQuartzError( IDS_CANTCONNECT, hr );

        // update all views, as link will dissapear
        pdoc->ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_ALL, NULL);

    }

    pdoc->EndWaitCursor();

}


//
// --- DisconnectAll ---
//
// Remove all connections from this graph


//
// Constructor
//
CCmdDisconnectAll::CCmdDisconnectAll()
{}


//
// Destructor
//
CCmdDisconnectAll::~CCmdDisconnectAll() {
    TRACE("~CCmdDisconnectAll() m_fRedo=%d\n", m_fRedo);
}


//
// CanDo
//
// This is only possible if there are links and we are stopped.
BOOL CCmdDisconnectAll::CanDo(CBoxNetDoc *pdoc) {

    return (  (pdoc->m_lstLinks.GetCount() > 0)
            && (pdoc->IsStopped())
           );
}


//
// Do
//
// Remove all the links from the document
void CCmdDisconnectAll::Do(CBoxNetDoc *pdoc) {

    ASSERT(pdoc->IsStopped());

    while (pdoc->m_lstLinks.GetCount() > 0) {
        CBoxLink *plink = pdoc->m_lstLinks.RemoveHead();
        plink->Disconnect();
        delete plink;
    }

    pdoc->ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_ALL, NULL);
}


//
// Redo
//
void CCmdDisconnectAll::Redo(CBoxNetDoc *pdoc) {
    Do(pdoc);
}


//
// --- CmdRender ---
//
// render this pin. Add whatever the filtergraph decides it needs to the document


//
// CanDo
//
BOOL CCmdRender::CanDo(CBoxNetDoc *pdoc) {

    return (   (pdoc->SelectedSocket()->GetDirection() == PINDIR_OUTPUT)
    	    && !(pdoc->SelectedSocket()->IsConnected())
            && (pdoc->IsStopped())
	   );
}


//
// Do
//
void CCmdRender::Do(CBoxNetDoc *pdoc) {

    pdoc->BeginWaitCursor();

    CBoxSocket *psock = pdoc->SelectedSocket();

    HRESULT hr = pdoc->IGraph()->Render(psock->pIPin());

    if (FAILED(hr)) {
        DisplayQuartzError( IDS_CANT_RENDER, hr );
    	pdoc->RestoreWaitCursor();
    }
    else {
        pdoc->UpdateFilters();
    }

    pdoc->EndWaitCursor();
}

//
// --- CCmdRenderFile ---
//
// Construct the graph to render this file

//
// Do
//
void CCmdRenderFile::Do(CBoxNetDoc *pdoc) {


    pdoc->BeginWaitCursor();

    HRESULT hr = pdoc->IGraph()->RenderFile( CMultiByteStr(m_FileName), NULL);
                                              // use default play list
    if (FAILED(hr)) {
        pdoc->EndWaitCursor();

        DisplayQuartzError( IDS_CANT_RENDER_FILE, hr );
        return;
    } else if( hr != NOERROR )
        DisplayQuartzError( hr );

    pdoc->UpdateFilters();

    pdoc->EndWaitCursor();
}

/******************************************************************************

CCmdAddFilterToCache

    This command adds a filter to the filter cache.  For more information on
the filter cache, see the IGraphConfig documentation in the Direct Show SDK.

******************************************************************************/
unsigned CCmdAddFilterToCache::GetLabel()
{
    return IDS_CMD_ADD_FILTER_TO_CACHE;
}

BOOL CCmdAddFilterToCache::CanDo( CBoxNetDoc *pdoc )
{
    return !pdoc->IsBoxSelectionEmpty();
}

void CCmdAddFilterToCache::Do( CBoxNetDoc *pdoc )
{
    CBox *pCurrentBox;

    IGraphConfig* pGraphConfig;

    HRESULT hr = pdoc->IGraph()->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
        return;
    }

    POSITION posNext = pdoc->m_lstBoxes.GetHeadPosition();
    POSITION posCurrent;

    while( posNext != NULL ) {
        posCurrent = posNext;
        pCurrentBox = pdoc->m_lstBoxes.GetNext( posNext );

        if( pCurrentBox->IsSelected() ) {
            hr = pGraphConfig->AddFilterToCache( pCurrentBox->pIFilter() );
            if( FAILED( hr ) ) {
                DisplayQuartzError( hr );
            }
        }
    }

    pdoc->UpdateFilters();

    pGraphConfig->Release();
}

/******************************************************************************

CCmdReconnect

    This command reconnects an output pin.  It works even if the filter graph
is running or paused.

******************************************************************************/
unsigned CCmdReconnect::GetLabel()
{
    return IDS_CMD_RECONNECT;
}

BOOL CCmdReconnect::CanDo( CBoxNetDoc* pDoc )
{
    if( pDoc->AsyncReconnectInProgress() ) {
        return FALSE;
    }

    CBoxSocket* pSelectedSocket = pDoc->SelectedSocket();
    if( NULL == pSelectedSocket ) {
        return FALSE;
    }

    if( pSelectedSocket->GetDirection() != PINDIR_OUTPUT ) {
        return FALSE;
    }

    if( !pSelectedSocket->IsConnected() ) {
        return FALSE;
    }

    CComPtr<IGraphConfig> pGraphConfig;

    HRESULT hr = pDoc->IGraph()->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( FAILED( hr ) ) {
        return FALSE;
    }

    IPin* pSelectedPin = pSelectedSocket->pIPin();
    CComPtr<IPinFlowControl> pOutputPin;
    
    hr = pSelectedPin->QueryInterface( IID_IPinFlowControl, (void**)&pOutputPin );
    if( FAILED( hr ) ) {
        return FALSE;
    }

    return TRUE;
}

void CCmdReconnect::Do( CBoxNetDoc* pDoc )
{
    pDoc->BeginWaitCursor();    

    CBoxSocket* pSelectedSocket = pDoc->SelectedSocket();
    if( NULL == pSelectedSocket ) {
        pDoc->EndWaitCursor();
        DisplayQuartzError( E_POINTER );  // TBD - Define GE_E_SELECTED_SOCKET_DOES_NOT_EXIST.
        return;
    }

    IPin* pSelectedPin = pSelectedSocket->pIPin();

    // A socket should always be assocaited with a valid pin.
    ASSERT( NULL != pSelectedPin );    

    HRESULT hr = pDoc->StartReconnect( pDoc->IGraph(), pSelectedPin );
    if( GE_S_RECONNECT_PENDING == hr ) {
        // AfxMessageBox() returns 0 if an error occurs.
        if( 0 == AfxMessageBox( IDS_RECONNECT_PENDING ) ) {
            TRACE( TEXT("WARNING: CBoxNetDoc::StartReconnect() returned GE_S_RECONNECT_PENDING but the user could not be notified because AfxMessageBox() failed.") );
        }
    } else if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
    }

    pDoc->EndWaitCursor();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\congraph.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "congraph.h"

BEGIN_MESSAGE_MAP(CConGraph, CDialog)
    ON_COMMAND(IDC_REFRESH, OnRefreshList)
    ON_LBN_DBLCLK(IDC_LIST1, OnDblclkGraphList)
    ON_WM_DESTROY()
END_MESSAGE_MAP()

//
// Constructor
//
CConGraph::CConGraph(IMoniker **ppmk, IRunningObjectTable *pirot, CWnd * pParent):
    CDialog(IDD_CONNECTTOGRAPH, pParent)
{
    m_ppmk = ppmk;
    *ppmk = 0;
    m_pirot = pirot;
}

CConGraph::~CConGraph()
{
}

void CConGraph::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFontPropPage)
        DDX_Control(pDX, IDC_LIST1, m_ListBox);
    //}}AFX_DATA_MAP
}

void CConGraph::ClearList()
{
    int i = m_ListBox.GetCount();
    while (i--) {
        IMoniker *pmkr = (IMoniker *) m_ListBox.GetItemData(i);

        pmkr->Release();
    }

    m_ListBox.ResetContent();
}

void CConGraph::OnRefreshList()
{
    ClearList();

    LPBINDCTX lpbc;

    CreateBindCtx(0, &lpbc);

    IEnumMoniker *pEnum;
    if (SUCCEEDED(m_pirot->EnumRunning(&pEnum))) {
        while (1) {
            IMoniker *pmkr;
            DWORD dwFetched = 0;
            pEnum->Next(1,&pmkr,&dwFetched);
            if (dwFetched != 1) {
                break;
            }

            // !!! need a bind context?
            WCHAR *lpwszName;
            if (SUCCEEDED(pmkr->GetDisplayName(lpbc, NULL, &lpwszName))) {
                TCHAR szName[MAX_PATH];
                WideCharToMultiByte(CP_ACP, 0, lpwszName, -1,
                                    szName, sizeof(szName), 0, 0);
                CoTaskMemFree(lpwszName);

//                if (0 == strncmp(szTestString, szName, lstrlenA(szTestString))) {
                    // !!! need to make sure we're not looking at GraphEdit's graph!

                DWORD dw, dwPID;
                if (2 == sscanf(szName, "!FilterGraph %x  pid %x", &dw, &dwPID) && dwPID != GetCurrentProcessId()) {
                    wsprintf(szName, "pid 0x%x (%d)  IFilterGraph = %08x", dwPID, dwPID, dw);
                    int item = m_ListBox.AddString(szName);
                    m_ListBox.SetItemData(item, (DWORD_PTR) pmkr);
                    pmkr->AddRef();  // hold moniker for later
                }
            }
            pmkr->Release();
        }
        pEnum->Release();
    }
    lpbc->Release();
}

void CConGraph::OnDestroy()
{
    ClearList();
}

BOOL CConGraph::OnInitDialog()
{
    CDialog::OnInitDialog();

    OnRefreshList();
    m_ListBox.SetFocus();

    return(0); // we set the focus our selves
}

void CConGraph::OnOK()
{
    // get the string in the edit box
    int curSel = m_ListBox.GetCurSel();

    if (curSel != LB_ERR) {
        *m_ppmk = (IMoniker *) m_ListBox.GetItemData(curSel);
        (*m_ppmk)->AddRef();
    }

    CDialog::OnOK();
}

void CConGraph::OnDblclkGraphList() 
{
    OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\filtervw.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
// Dialog to display all filters
//

#include "stdafx.h"
#include "filtervw.h"

#define SHOWTYPES 1
#ifdef SHOWTYPES

#include <malloc.h>
#include <assert.h>
#include <streams.h>
#include <aviriff.h>
#ifdef COLORCODED_FILTERS
#include <dmodshow.h>
#endif
#endif
#include <initguid.h>
#include <dmoreg.h>

BEGIN_MESSAGE_MAP(CFilterView, CDialog)
    ON_NOTIFY(TVN_ITEMEXPANDING, IDC_FILTER_TREE, OnItemExpanding)
#ifdef COLORCODED_FILTERS
    ON_NOTIFY(NM_CUSTOMDRAW, IDC_FILTER_TREE, OnCustomDraw)
#endif
    ON_COMMAND(ID_ADDFILTER, OnInsert)
#ifdef FILTER_FAVORITES
    ON_COMMAND(ID_ADDTOFAV, OnAddToFav)
#endif
    ON_WM_SIZE()
    ON_WM_GETMINMAXINFO()
END_MESSAGE_MAP()

CFilterView* CFilterView::m_pThis = 0;
WNDPROC CFilterView::m_pfnOldDialogProc;

// list of categories in registry ActiveMovie might care about
static const TCHAR szRegCategoryPath[] = "ActiveMovie Filter Categories";

struct _EXTRA_CATEGORY {
    const GUID  * pclsid;
    const TCHAR * pszCat;
};

//
// Extra categories that we'd like to enumerate from GraphEdt...
//
// Please use this for categories that you'd like to see in GraphEdt but that don't
// need to be enumerated for default runtime graph building.
//
static const _EXTRA_CATEGORY g_AppEnumeratedCategories[] = 
{
        { &DMOCATEGORY_AUDIO_EFFECT,         TEXT("DMO Audio Effects") },
        { &DMOCATEGORY_AUDIO_CAPTURE_EFFECT, TEXT("DMO Audio Capture Effects") },
        { &DMOCATEGORY_VIDEO_EFFECT,         TEXT("DMO Video Effects") },
        // NULL entry needed to flag end
        { NULL,                              TEXT("") }
};


//
// Constructor
//
CFilterView::CFilterView(
    CBoxNetDoc * pBoxNet,
    CWnd * pParent)

 :
   m_pBoxNet(pBoxNet)
 , m_hImgList(NULL)
 , m_bHadInitDialog( FALSE )
{
    //
    // There can only be one filter view dialog at a time. Thus
    // the initialisation in the constructor is ok (even desired).
    //
    ASSERT( m_pThis == 0 );
    m_pThis = this;
    m_pfnOldDialogProc = NULL;
    Create(IDD_FILTER_VIEW, pParent);
    ShowWindow( SW_SHOW );
}

CFilterView::~CFilterView()
{
    // Windows will automatically delete m_hImgList when the dialog
    // box is destroyed.
    m_pThis = 0;
}

CFilterView * CFilterView::GetFilterView(
    CBoxNetDoc * pBoxNet,
    CWnd * pParent)
{
    if (!m_pThis)
    {
        m_pThis = new CFilterView(pBoxNet, pParent);
    }
    else
    {
    	if (pBoxNet->m_fRegistryChanged) {
    	    pBoxNet->m_fRegistryChanged = FALSE;
    	    m_pThis->RedoList();
	}
        m_pThis->ShowWindow( SW_RESTORE );
    }
    return m_pThis;

}

void CFilterView::DelFilterView()
{
    if (m_pThis)
    {
        delete m_pThis;
        m_pThis = 0;
    }
}

static LONG
TreeView_GetSelectedItemData(HWND hwndTV)
{
    HTREEITEM       hItem;
    TV_ITEM         tvItem;

    if(!(hItem = TreeView_GetSelection(hwndTV)))
        return -1;

    tvItem.mask = TVIF_PARAM;
    tvItem.hItem = hItem;
    TreeView_GetItem(hwndTV, &tvItem);

    return (LONG) tvItem.lParam;
}

void CFilterView::OnInsert()
{
    BOOL fAnySuccess = FALSE;
    HWND hWndTree = ::GetDlgItem(m_hWnd, IDC_FILTER_TREE);
    ASSERT(hWndTree);
    LONG iItem = TreeView_GetSelectedItemData(hWndTree);
    if(iItem >= 0)
    {
        POSITION pos = m_lMoniker.GetHeadPosition();
        while(pos != 0 && iItem-- > 0)
        {
            m_lMoniker.GetNext(pos);
        }
        if(pos)
        {

            IMoniker *pMon = *m_lMoniker.GetAt(pos); // not addrefd

            try {
                m_pBoxNet->CmdDo(new CCmdAddFilter( pMon, m_pBoxNet));

                fAnySuccess = TRUE;
            }
            catch (CHRESULTException hre) {
                // Give accurate information on each failed insertion
                DisplayQuartzError( IDS_CANTCREATEFILTER, hre.Reason() );
            }
        }
    }

    //
    // Change the text of the IDCANCEL button to "close" if we added at
    // least one filter.
    //
    if (fAnySuccess) {
        CString stClose;
        stClose.LoadString(IDS_CLOSE);

        ::SetDlgItemText(m_hWnd, IDCANCEL, stClose);
    }
}

#ifdef FILTER_FAVORITES

extern const TCHAR *g_szRegFav;

HRESULT AddFavToReg(const TCHAR *szFilter, const TCHAR *szMonikerName)
{
    HKEY hk;
    LONG lResult = RegCreateKeyEx(
        HKEY_CURRENT_USER,
        g_szRegFav,
        0,                      // reserved
        0,                      // class string
        0,                      // options
        KEY_WRITE,
        0,                      // security
        &hk,
        0);                     // disposition
    if(lResult == ERROR_SUCCESS)
    {
        lResult = RegSetValueEx(
            hk,
            szFilter,
            0,                  // reserved
            REG_SZ,
            (BYTE *)szMonikerName,
            sizeof(TCHAR) * (lstrlen(szMonikerName) + 1));

        RegCloseKey(hk);
    }

    return S_OK;
}

void CFilterView::OnAddToFav()
{
    BOOL fAnySuccess = FALSE;
    HWND hWndTree = ::GetDlgItem(m_hWnd, IDC_FILTER_TREE);
    ASSERT(hWndTree);
    LONG iItem = TreeView_GetSelectedItemData(hWndTree);
    if(iItem >= 0)
    {
        POSITION pos = m_lMoniker.GetHeadPosition();
        while(pos != 0 && iItem-- > 0)
        {
            m_lMoniker.GetNext(pos);
        }
        if(pos)
        {

            IMoniker *pMon = *m_lMoniker.GetAt(pos); // not addrefd

            WCHAR *wszDisplayName;
            HRESULT hr= pMon->GetDisplayName(0, 0, &wszDisplayName);
            if(SUCCEEDED(hr))
            {

                CComVariant var;

                IPropertyBag *pPropBag;
                hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
                if(SUCCEEDED(hr))
                {
                    hr = pPropBag->Read(L"FriendlyName", &var, 0);
                    if(FAILED(hr )) {
                        printf("failed to get FriendlyName: %08x\n", hr);
                    }

                    pPropBag->Release();
                }

                if(SUCCEEDED(hr))
                {
                    CString szFilterName(var.bstrVal);
                    CString szDisplayName(wszDisplayName);

                    AddFavToReg(szFilterName, szDisplayName);
                }


                CoTaskMemFree(wszDisplayName);
            }


            if(FAILED(hr)) {
                DisplayQuartzError( IDS_CANTCREATEFILTER, CHRESULTException(hr).Reason() );
            }
        }
    }
}

#endif


BOOL CFilterView::OnInitDialog()
{
    BOOL fResult = CDialog::OnInitDialog();

    HWND hWndTree = ::GetDlgItem(m_hWnd, IDC_FILTER_TREE);
    ASSERT(hWndTree);

    // Subclass the tree view so we can handle double clicks.
    m_pfnOldDialogProc = (WNDPROC)
        ::SetWindowLongPtr(hWndTree, GWLP_WNDPROC, (LONG_PTR) DialogProc);

    //
    // Create the image list for the list view
    //
    m_hImgList = ImageList_Create(
        GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
        ILC_COLOR, 1, 1);

    ASSERT(m_hImgList);

    HICON hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_FILTER));
    m_iIcon = ImageList_AddIcon(m_hImgList, hIcon);

//     ::SendMessage(hWndTree, LVM_SETIMAGELIST, LVSIL_SMALL, (LPARAM) m_hImgList);

    RedoList();

    return( fResult );
}

#ifdef SHOWTYPES

#define CNV_GUID(clsid) GuidToEnglish((clsid), (char *)_alloca(1024))

struct NamedGuid
{
    const GUID *pguid;
    const char *psz;
};

static const NamedGuid rgng[] =
{
    {&AMPROPSETID_Pin, "AMPROPSETID_Pin"},
    {&AM_INTERFACESETID_Standard, "AM_INTERFACESETID_Standard"},
    {&AM_KSCATEGORY_AUDIO, "AM_KSCATEGORY_AUDIO"},
    {&AM_KSCATEGORY_CAPTURE, "AM_KSCATEGORY_CAPTURE"},
    {&AM_KSCATEGORY_CROSSBAR, "AM_KSCATEGORY_CROSSBAR"},
    {&AM_KSCATEGORY_DATACOMPRESSOR, "AM_KSCATEGORY_DATACOMPRESSOR"},
    {&AM_KSCATEGORY_RENDER, "AM_KSCATEGORY_RENDER"},
    {&AM_KSCATEGORY_TVAUDIO, "AM_KSCATEGORY_TVAUDIO"},
    {&AM_KSCATEGORY_TVTUNER, "AM_KSCATEGORY_TVTUNER"},
    {&AM_KSCATEGORY_VIDEO, "AM_KSCATEGORY_VIDEO"},
    {&AM_KSPROPSETID_AC3, "AM_KSPROPSETID_AC3"},
    {&AM_KSPROPSETID_CopyProt, "AM_KSPROPSETID_CopyProt"},
    {&AM_KSPROPSETID_DvdSubPic, "AM_KSPROPSETID_DvdSubPic"},
    {&AM_KSPROPSETID_TSRateChange, "AM_KSPROPSETID_TSRateChange"},
    {&CLSID_ACMWrapper, "CLSID_ACMWrapper"},
    {&CLSID_AVICo, "CLSID_AVICo"},
    {&CLSID_AVIDec, "CLSID_AVIDec"},
    {&CLSID_AVIDoc, "CLSID_AVIDoc"},
    {&CLSID_AVIDraw, "CLSID_AVIDraw"},
    {&CLSID_AVIMIDIRender, "CLSID_AVIMIDIRender"},
    {&CLSID_ActiveMovieCategories, "CLSID_ActiveMovieCategories"},
    {&CLSID_AnalogVideoDecoderPropertyPage, "CLSID_AnalogVideoDecoderPropertyPage"},
    {&CLSID_WMAsfReader, "CLSID_WMAsfReader"},
    {&CLSID_WMAsfWriter, "CLSID_WMAsfWriter"},
    {&CLSID_AsyncReader, "CLSID_AsyncReader"},
    {&CLSID_AudioCompressorCategory, "CLSID_AudioCompressorCategory"},
    {&CLSID_AudioInputDeviceCategory, "CLSID_AudioInputDeviceCategory"},
    {&CLSID_AudioProperties, "CLSID_AudioProperties"},
    {&CLSID_AudioRecord, "CLSID_AudioRecord"},
    {&CLSID_AudioRender, "CLSID_AudioRender"},
    {&CLSID_AudioRendererCategory, "CLSID_AudioRendererCategory"},
    {&CLSID_AviDest, "CLSID_AviDest"},
    {&CLSID_AviMuxProptyPage, "CLSID_AviMuxProptyPage"},
    {&CLSID_AviMuxProptyPage1, "CLSID_AviMuxProptyPage1"},
    {&CLSID_AviReader, "CLSID_AviReader"},
    {&CLSID_AviSplitter, "CLSID_AviSplitter"},
    {&CLSID_CAcmCoClassManager, "CLSID_CAcmCoClassManager"},
    {&CLSID_CDeviceMoniker, "CLSID_CDeviceMoniker"},
    {&CLSID_CIcmCoClassManager, "CLSID_CIcmCoClassManager"},
    {&CLSID_CMidiOutClassManager, "CLSID_CMidiOutClassManager"},
    {&CLSID_CMpegAudioCodec, "CLSID_CMpegAudioCodec"},
    {&CLSID_CMpegVideoCodec, "CLSID_CMpegVideoCodec"},
    {&CLSID_CQzFilterClassManager, "CLSID_CQzFilterClassManager"},
    {&CLSID_CVidCapClassManager, "CLSID_CVidCapClassManager"},
    {&CLSID_CWaveOutClassManager, "CLSID_CWaveOutClassManager"},
    {&CLSID_CWaveinClassManager, "CLSID_CWaveinClassManager"},
    {&CLSID_CameraControlPropertyPage, "CLSID_CameraControlPropertyPage"},
    {&CLSID_CaptureGraphBuilder, "CLSID_CaptureGraphBuilder"},
    {&CLSID_CaptureProperties, "CLSID_CaptureProperties"},
    {&CLSID_Colour, "CLSID_Colour"},
    {&CLSID_CrossbarFilterPropertyPage, "CLSID_CrossbarFilterPropertyPage"},
    {&CLSID_DSoundRender, "CLSID_DSoundRender"},
    {&CLSID_DVDHWDecodersCategory, "CLSID_DVDHWDecodersCategory"},
    {&CLSID_DVDNavigator, "CLSID_DVDNavigator"},
    {&CLSID_DVDecPropertiesPage, "CLSID_DVDecPropertiesPage"},
    {&CLSID_DVEncPropertiesPage, "CLSID_DVEncPropertiesPage"},
    {&CLSID_DVMux, "CLSID_DVMux"},
    {&CLSID_DVMuxPropertyPage, "CLSID_DVMuxPropertyPage"},
    {&CLSID_DVSplitter, "CLSID_DVSplitter"},
    {&CLSID_DVVideoCodec, "CLSID_DVVideoCodec"},
    {&CLSID_DVVideoEnc, "CLSID_DVVideoEnc"},
    {&CLSID_DirectDraw, "CLSID_DirectDraw"},
    {&CLSID_DirectDrawClipper, "CLSID_DirectDrawClipper"},
    {&CLSID_DirectDrawProperties, "CLSID_DirectDrawProperties"},
    {&CLSID_Dither, "CLSID_Dither"},
    {&CLSID_DvdGraphBuilder, "CLSID_DvdGraphBuilder"},
    {&CLSID_FGControl, "CLSID_FGControl"},
    {&CLSID_FileSource, "CLSID_FileSource"},
    {&CLSID_FileWriter, "CLSID_FileWriter"},
    {&CLSID_FilterGraph, "CLSID_FilterGraph"},
    {&CLSID_FilterGraphNoThread, "CLSID_FilterGraphNoThread"},
    {&CLSID_FilterMapper, "CLSID_FilterMapper"},
    {&CLSID_FilterMapper2, "CLSID_FilterMapper2"},
    {&CLSID_InfTee, "CLSID_InfTee"},
    {&CLSID_LegacyAmFilterCategory, "CLSID_LegacyAmFilterCategory"},
    {&CLSID_Line21Decoder, "CLSID_Line21Decoder"},
    {&CLSID_MOVReader, "CLSID_MOVReader"},
    {&CLSID_MPEG1Doc, "CLSID_MPEG1Doc"},
    {&CLSID_MPEG1PacketPlayer, "CLSID_MPEG1PacketPlayer"},
    {&CLSID_MPEG1Splitter, "CLSID_MPEG1Splitter"},
    {&CLSID_MediaPropertyBag, "CLSID_MediaPropertyBag"},
    {&CLSID_MemoryAllocator, "CLSID_MemoryAllocator"},
    {&CLSID_MidiRendererCategory, "CLSID_MidiRendererCategory"},
    {&CLSID_ModexProperties, "CLSID_ModexProperties"},
    {&CLSID_ModexRenderer, "CLSID_ModexRenderer"},
    {&CLSID_OverlayMixer, "CLSID_OverlayMixer"},
    {&CLSID_PerformanceProperties, "CLSID_PerformanceProperties"},
    {&CLSID_PersistMonikerPID, "CLSID_PersistMonikerPID"},
    {&CLSID_ProtoFilterGraph, "CLSID_ProtoFilterGraph"},
    {&CLSID_QualityProperties, "CLSID_QualityProperties"},
    {&CLSID_SeekingPassThru, "CLSID_SeekingPassThru"},
    {&CLSID_SmartTee, "CLSID_SmartTee"},
    {&CLSID_SystemClock, "CLSID_SystemClock"},
    {&CLSID_SystemDeviceEnum, "CLSID_SystemDeviceEnum"},
    {&CLSID_TVAudioFilterPropertyPage, "CLSID_TVAudioFilterPropertyPage"},
    {&CLSID_TVTunerFilterPropertyPage, "CLSID_TVTunerFilterPropertyPage"},
    {&CLSID_TextRender, "CLSID_TextRender"},
    {&CLSID_URLReader, "CLSID_URLReader"},
    {&CLSID_VBISurfaces, "CLSID_VBISurfaces"},
    {&CLSID_VPObject, "CLSID_VPObject"},
    {&CLSID_VPVBIObject, "CLSID_VPVBIObject"},
    {&CLSID_VfwCapture, "CLSID_VfwCapture"},
    {&CLSID_VideoCompressorCategory, "CLSID_VideoCompressorCategory"},
    {&CLSID_VideoInputDeviceCategory, "CLSID_VideoInputDeviceCategory"},
    {&CLSID_VideoProcAmpPropertyPage, "CLSID_VideoProcAmpPropertyPage"},
    {&CLSID_VideoRenderer, "CLSID_VideoRenderer"},
    {&CLSID_VideoStreamConfigPropertyPage, "CLSID_VideoStreamConfigPropertyPage"},
    {&FORMAT_AnalogVideo, "FORMAT_AnalogVideo"},
    {&FORMAT_DVD_LPCMAudio, "FORMAT_DVD_LPCMAudio"},
    {&FORMAT_DolbyAC3, "FORMAT_DolbyAC3"},
    {&FORMAT_DvInfo, "FORMAT_DvInfo"},
    {&FORMAT_MPEG2Audio, "FORMAT_MPEG2Audio"},
    {&FORMAT_MPEG2Video, "FORMAT_MPEG2Video"},
    {&FORMAT_MPEG2_VIDEO, "FORMAT_MPEG2_VIDEO"},
    {&FORMAT_MPEGStreams, "FORMAT_MPEGStreams"},
    {&FORMAT_MPEGVideo, "FORMAT_MPEGVideo"},
    {&FORMAT_None, "FORMAT_None"},
    {&FORMAT_VIDEOINFO2, "FORMAT_VIDEOINFO2"},
    {&FORMAT_VideoInfo, "FORMAT_VideoInfo"},
    {&FORMAT_VideoInfo2, "FORMAT_VideoInfo2"},
    {&FORMAT_WaveFormatEx, "FORMAT_WaveFormatEx"},
    {&IID_IAMDirectSound, "IID_IAMDirectSound"},
    {&IID_IAMLine21Decoder, "IID_IAMLine21Decoder"},
    {&IID_IBaseVideoMixer, "IID_IBaseVideoMixer"},
    {&IID_IDDVideoPortContainer, "IID_IDDVideoPortContainer"},
    {&IID_IDirectDraw, "IID_IDirectDraw"},
    {&IID_IDirectDraw2, "IID_IDirectDraw2"},
    {&IID_IDirectDrawClipper, "IID_IDirectDrawClipper"},
    {&IID_IDirectDrawColorControl, "IID_IDirectDrawColorControl"},
    {&IID_IDirectDrawKernel, "IID_IDirectDrawKernel"},
    {&IID_IDirectDrawPalette, "IID_IDirectDrawPalette"},
    {&IID_IDirectDrawSurface, "IID_IDirectDrawSurface"},
    {&IID_IDirectDrawSurface2, "IID_IDirectDrawSurface2"},
    {&IID_IDirectDrawSurface3, "IID_IDirectDrawSurface3"},
    {&IID_IDirectDrawSurfaceKernel, "IID_IDirectDrawSurfaceKernel"},
    {&IID_IDirectDrawVideo, "IID_IDirectDrawVideo"},
    {&IID_IFullScreenVideo, "IID_IFullScreenVideo"},
    {&IID_IFullScreenVideoEx, "IID_IFullScreenVideoEx"},
    {&IID_IKsDataTypeHandler, "IID_IKsDataTypeHandler"},
    {&IID_IKsInterfaceHandler, "IID_IKsInterfaceHandler"},
    {&IID_IKsPin, "IID_IKsPin"},
    {&IID_IMixerPinConfig, "IID_IMixerPinConfig"},
    {&IID_IMixerPinConfig2, "IID_IMixerPinConfig2"},
    {&IID_IMpegAudioDecoder, "IID_IMpegAudioDecoder"},
    {&IID_IQualProp, "IID_IQualProp"},
    {&IID_IVPConfig, "IID_IVPConfig"},
    {&IID_IVPControl, "IID_IVPControl"},
    {&IID_IVPNotify, "IID_IVPNotify"},
    {&IID_IVPNotify2, "IID_IVPNotify2"},
    {&IID_IVPObject, "IID_IVPObject"},
    {&IID_IVPVBIConfig, "IID_IVPVBIConfig"},
    {&IID_IVPVBINotify, "IID_IVPVBINotify"},
    {&IID_IVPVBIObject, "IID_IVPVBIObject"},
    {&LOOK_DOWNSTREAM_ONLY, "LOOK_DOWNSTREAM_ONLY"},
    {&LOOK_UPSTREAM_ONLY, "LOOK_UPSTREAM_ONLY"},
    {&MEDIASUBTYPE_AIFF, "MEDIASUBTYPE_AIFF"},
    {&MEDIASUBTYPE_AU, "MEDIASUBTYPE_AU"},
    {&MEDIASUBTYPE_AnalogVideo_NTSC_M, "MEDIASUBTYPE_AnalogVideo_NTSC_M"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_B, "MEDIASUBTYPE_AnalogVideo_PAL_B"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_D, "MEDIASUBTYPE_AnalogVideo_PAL_D"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_G, "MEDIASUBTYPE_AnalogVideo_PAL_G"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_H, "MEDIASUBTYPE_AnalogVideo_PAL_H"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_I, "MEDIASUBTYPE_AnalogVideo_PAL_I"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_M, "MEDIASUBTYPE_AnalogVideo_PAL_M"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_N, "MEDIASUBTYPE_AnalogVideo_PAL_N"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_B, "MEDIASUBTYPE_AnalogVideo_SECAM_B"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_D, "MEDIASUBTYPE_AnalogVideo_SECAM_D"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_G, "MEDIASUBTYPE_AnalogVideo_SECAM_G"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_H, "MEDIASUBTYPE_AnalogVideo_SECAM_H"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_K, "MEDIASUBTYPE_AnalogVideo_SECAM_K"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_K1, "MEDIASUBTYPE_AnalogVideo_SECAM_K1"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_L, "MEDIASUBTYPE_AnalogVideo_SECAM_L"},
    {&MEDIASUBTYPE_Asf, "MEDIASUBTYPE_Asf"},
    {&MEDIASUBTYPE_Avi, "MEDIASUBTYPE_Avi"},
    {&MEDIASUBTYPE_CFCC, "MEDIASUBTYPE_CFCC"},
    {&MEDIASUBTYPE_CLJR, "MEDIASUBTYPE_CLJR"},
    {&MEDIASUBTYPE_CPLA, "MEDIASUBTYPE_CPLA"},
    {&MEDIASUBTYPE_DOLBY_AC3, "MEDIASUBTYPE_DOLBY_AC3"},
    {&MEDIASUBTYPE_DVCS, "MEDIASUBTYPE_DVCS"},
    {&MEDIASUBTYPE_DVD_LPCM_AUDIO, "MEDIASUBTYPE_DVD_LPCM_AUDIO"},
    {&MEDIASUBTYPE_DVD_NAVIGATION_DSI, "MEDIASUBTYPE_DVD_NAVIGATION_DSI"},
    {&MEDIASUBTYPE_DVD_NAVIGATION_PCI, "MEDIASUBTYPE_DVD_NAVIGATION_PCI"},
    {&MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER, "MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER"},
    {&MEDIASUBTYPE_DVD_SUBPICTURE, "MEDIASUBTYPE_DVD_SUBPICTURE"},
    {&MEDIASUBTYPE_DVSD, "MEDIASUBTYPE_DVSD"},
    {&MEDIASUBTYPE_DssAudio, "MEDIASUBTYPE_DssAudio"},
    {&MEDIASUBTYPE_DssVideo, "MEDIASUBTYPE_DssVideo"},
    {&MEDIASUBTYPE_IF09, "MEDIASUBTYPE_IF09"},
    {&MEDIASUBTYPE_IJPG, "MEDIASUBTYPE_IJPG"},
    {&MEDIASUBTYPE_Line21_BytePair, "MEDIASUBTYPE_Line21_BytePair"},
    {&MEDIASUBTYPE_Line21_GOPPacket, "MEDIASUBTYPE_Line21_GOPPacket"},
    {&MEDIASUBTYPE_Line21_VBIRawData, "MEDIASUBTYPE_Line21_VBIRawData"},
    {&MEDIASUBTYPE_MDVF, "MEDIASUBTYPE_MDVF"},
    {&MEDIASUBTYPE_MJPG, "MEDIASUBTYPE_MJPG"},
    {&MEDIASUBTYPE_MPEG1Audio, "MEDIASUBTYPE_MPEG1Audio"},
    {&MEDIASUBTYPE_MPEG1AudioPayload, "MEDIASUBTYPE_MPEG1AudioPayload"},
    {&MEDIASUBTYPE_MPEG1Packet, "MEDIASUBTYPE_MPEG1Packet"},
    {&MEDIASUBTYPE_MPEG1Payload, "MEDIASUBTYPE_MPEG1Payload"},
    {&MEDIASUBTYPE_MPEG1System, "MEDIASUBTYPE_MPEG1System"},
    {&MEDIASUBTYPE_MPEG1Video, "MEDIASUBTYPE_MPEG1Video"},
    {&MEDIASUBTYPE_MPEG1VideoCD, "MEDIASUBTYPE_MPEG1VideoCD"},
    {&MEDIASUBTYPE_MPEG2_AUDIO, "MEDIASUBTYPE_MPEG2_AUDIO"},
    {&MEDIASUBTYPE_MPEG2_PROGRAM, "MEDIASUBTYPE_MPEG2_PROGRAM"},
    {&MEDIASUBTYPE_MPEG2_TRANSPORT, "MEDIASUBTYPE_MPEG2_TRANSPORT"},
    {&MEDIASUBTYPE_MPEG2_VIDEO, "MEDIASUBTYPE_MPEG2_VIDEO"},
    {&MEDIASUBTYPE_None, "MEDIASUBTYPE_None"},
    {&MEDIASUBTYPE_Overlay, "MEDIASUBTYPE_Overlay"},
    {&MEDIASUBTYPE_PCM, "MEDIASUBTYPE_PCM"},
    {&MEDIASUBTYPE_PCMAudio_Obsolete, "MEDIASUBTYPE_PCMAudio_Obsolete"},
    {&MEDIASUBTYPE_Plum, "MEDIASUBTYPE_Plum"},
    {&MEDIASUBTYPE_QTJpeg, "MEDIASUBTYPE_QTJpeg"},
    {&MEDIASUBTYPE_QTMovie, "MEDIASUBTYPE_QTMovie"},
    {&MEDIASUBTYPE_QTRle, "MEDIASUBTYPE_QTRle"},
    {&MEDIASUBTYPE_QTRpza, "MEDIASUBTYPE_QTRpza"},
    {&MEDIASUBTYPE_QTSmc, "MEDIASUBTYPE_QTSmc"},
    {&MEDIASUBTYPE_RGB1, "MEDIASUBTYPE_RGB1"},
    {&MEDIASUBTYPE_RGB24, "MEDIASUBTYPE_RGB24"},
    {&MEDIASUBTYPE_RGB32, "MEDIASUBTYPE_RGB32"},
    {&MEDIASUBTYPE_RGB4, "MEDIASUBTYPE_RGB4"},
    {&MEDIASUBTYPE_RGB555, "MEDIASUBTYPE_RGB555"},
    {&MEDIASUBTYPE_RGB565, "MEDIASUBTYPE_RGB565"},
    {&MEDIASUBTYPE_RGB8, "MEDIASUBTYPE_RGB8"},
    {&MEDIASUBTYPE_TVMJ, "MEDIASUBTYPE_TVMJ"},
    {&MEDIASUBTYPE_UYVY, "MEDIASUBTYPE_UYVY"},
    {&MEDIASUBTYPE_VPVBI, "MEDIASUBTYPE_VPVBI"},
    {&MEDIASUBTYPE_VPVideo, "MEDIASUBTYPE_VPVideo"},
    {&MEDIASUBTYPE_WAKE, "MEDIASUBTYPE_WAKE"},
    {&MEDIASUBTYPE_WAVE, "MEDIASUBTYPE_WAVE"},
    {&MEDIASUBTYPE_Y211, "MEDIASUBTYPE_Y211"},
    {&MEDIASUBTYPE_Y411, "MEDIASUBTYPE_Y411"},
    {&MEDIASUBTYPE_Y41P, "MEDIASUBTYPE_Y41P"},
    {&MEDIASUBTYPE_YUY2, "MEDIASUBTYPE_YUY2"},
    {&MEDIASUBTYPE_YV12, "MEDIASUBTYPE_YV12"},
    {&MEDIASUBTYPE_YVU9, "MEDIASUBTYPE_YVU9"},
    {&MEDIASUBTYPE_YVYU, "MEDIASUBTYPE_YVYU"},
    {&MEDIASUBTYPE_dvhd, "MEDIASUBTYPE_dvhd"},
    {&MEDIASUBTYPE_dvsd, "MEDIASUBTYPE_dvsd"},
    {&MEDIASUBTYPE_dvsl, "MEDIASUBTYPE_dvsl"},
    {&MEDIATYPE_AUXLine21Data, "MEDIATYPE_AUXLine21Data"},
    {&MEDIATYPE_AnalogAudio, "MEDIATYPE_AnalogAudio"},
    {&MEDIATYPE_AnalogVideo, "MEDIATYPE_AnalogVideo"},
    {&MEDIATYPE_Audio, "MEDIATYPE_Audio"},
    {&MEDIATYPE_DVD_ENCRYPTED_PACK, "MEDIATYPE_DVD_ENCRYPTED_PACK"},
    {&MEDIATYPE_DVD_NAVIGATION, "MEDIATYPE_DVD_NAVIGATION"},
    {&MEDIATYPE_File, "MEDIATYPE_File"},
    {&MEDIATYPE_Interleaved, "MEDIATYPE_Interleaved"},
    {&MEDIATYPE_LMRT, "MEDIATYPE_LMRT"},
    {&MEDIATYPE_MPEG1SystemStream, "MEDIATYPE_MPEG1SystemStream"},
    {&MEDIATYPE_MPEG2_PES, "MEDIATYPE_MPEG2_PES"},
    {&MEDIATYPE_Midi, "MEDIATYPE_Midi"},
    {&MEDIATYPE_ScriptCommand, "MEDIATYPE_ScriptCommand"},
    {&MEDIATYPE_Stream, "MEDIATYPE_Stream"},
    {&MEDIATYPE_Text, "MEDIATYPE_Text"},
    {&MEDIATYPE_Timecode, "MEDIATYPE_Timecode"},
    {&MEDIATYPE_URL_STREAM, "MEDIATYPE_URL_STREAM"},
    {&MEDIATYPE_Video, "MEDIATYPE_Video"},
    {&PIN_CATEGORY_ANALOGVIDEOIN, "PIN_CATEGORY_ANALOGVIDEOIN"},
    {&PIN_CATEGORY_CAPTURE, "PIN_CATEGORY_CAPTURE"},
    {&PIN_CATEGORY_CC, "PIN_CATEGORY_CC"},
    {&PIN_CATEGORY_EDS, "PIN_CATEGORY_EDS"},
    {&PIN_CATEGORY_NABTS, "PIN_CATEGORY_NABTS"},
    {&PIN_CATEGORY_PREVIEW, "PIN_CATEGORY_PREVIEW"},
    {&PIN_CATEGORY_STILL, "PIN_CATEGORY_STILL"},
    {&PIN_CATEGORY_TELETEXT, "PIN_CATEGORY_TELETEXT"},
    {&PIN_CATEGORY_TIMECODE, "PIN_CATEGORY_TIMECODE"},
    {&PIN_CATEGORY_VBI, "PIN_CATEGORY_VBI"},
    {&PIN_CATEGORY_VIDEOPORT, "PIN_CATEGORY_VIDEOPORT"},
    {&PIN_CATEGORY_VIDEOPORT_VBI, "PIN_CATEGORY_VIDEOPORT_VBI"},
    {&TIME_FORMAT_BYTE, "TIME_FORMAT_BYTE"},
    {&TIME_FORMAT_FIELD, "TIME_FORMAT_FIELD"},
    {&TIME_FORMAT_FRAME, "TIME_FORMAT_FRAME"},
    {&TIME_FORMAT_MEDIA_TIME, "TIME_FORMAT_MEDIA_TIME"},
    {&TIME_FORMAT_NONE, "TIME_FORMAT_NONE"},
    {&TIME_FORMAT_SAMPLE, "TIME_FORMAT_SAMPLE"},
};

char * GuidToEnglish(const CLSID *const pclsid, char *buf)
{
    WCHAR szGuid[39];
    StringFromGUID2(pclsid ? *pclsid : GUID_NULL, szGuid, 39);

    if(pclsid == 0)
    {
        wsprintf(buf, "%S", szGuid);
        return buf;
    }

    for(int i = 0; i < NUMELMS(rgng); i++)
    {
        if(*pclsid == *(rgng[i].pguid))
        {
            wsprintf(buf, "%s %S", rgng[i].psz, szGuid);
            return buf;
        }
    }
    if(FOURCCMap(pclsid->Data1) == *pclsid)
    {
        if(pclsid->Data1 > 0xffff)
        {
            wsprintf(buf, "fourcc (%08x) %c%c%c%c %S",
                     pclsid->Data1,
                     ((char *)pclsid)[0],
                     ((char *)pclsid)[1],
                     ((char *)pclsid)[2],
                     ((char *)pclsid)[3],
                     szGuid);
        }
        else
        {
            wsprintf(buf, "fourcc (%08x) %S",
                     pclsid->Data1,
                     szGuid);
        }
        return buf;
    }
    else
    {
        wsprintf(buf, "(%S)", szGuid);
        return buf;
    }

}

#include "fil_data.h"
#include "fil_data_i.c"
void DoFilterInfo(HWND hWndTree, HTREEITEM hti, IMoniker *pMon, IAMFilterData *pafd)
{

    HRESULT hr;
    LONG lRc;

    IPropertyBag *pPropBag;
    hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
    if(SUCCEEDED(hr))
    {

        VARIANT varFilData;
        varFilData.vt = VT_UI1 | VT_ARRAY;
        varFilData.parray = 0; // docs say zero this

        BYTE *pbFilterData = 0; // 0 if not read
        DWORD dwcbFilterDAta = 0; // 0 if not read
        hr = pPropBag->Read(L"FilterData", &varFilData, 0);
        if(SUCCEEDED(hr))
        {
            ASSERT(varFilData.vt == (VT_UI1 | VT_ARRAY));
            dwcbFilterDAta = varFilData.parray->rgsabound[0].cElements;

            HRESULT hrTmp = SafeArrayAccessData(varFilData.parray, (void **)&pbFilterData);
            ASSERT(hrTmp == S_OK);

            // used to determine whether to free varFilData
            ASSERT(pbFilterData);
        }
        else
        {
            ASSERT(dwcbFilterDAta == 0 && pbFilterData == 0);
        }


        if(SUCCEEDED(hr))
        {

            BYTE *pb;
            hr = pafd->ParseFilterData(pbFilterData, dwcbFilterDAta, &pb);
            if(SUCCEEDED(hr))
            {
                REGFILTER2 *pFil = ((REGFILTER2 **)pb)[0];

                if(pbFilterData)
                {
                    HRESULT hrTmp = SafeArrayUnaccessData(varFilData.parray);
                    ASSERT(hrTmp == S_OK);

                    hrTmp = VariantClear(&varFilData);
                    ASSERT(hrTmp == S_OK);
                }
                ASSERT(pFil->dwVersion == 2);

                char szTxt[1024];
                wsprintf(szTxt, "Merit: %08x", pFil->dwMerit);

                TV_INSERTSTRUCT tvis;
                tvis.hParent = hti;
                tvis.hInsertAfter = TVI_SORT;
                tvis.item.pszText = szTxt;
                tvis.item.lParam = -1;
                tvis.item.mask = TVIF_TEXT | TVIF_PARAM;

                //TreeView_InsertItem(hWndTree, &tvis);
                HTREEITEM htiMerit = (HTREEITEM)::SendMessage(
                    hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));


                wsprintf(szTxt, "Version: %d", pFil->dwVersion);

                HTREEITEM htiVersion = (HTREEITEM)::SendMessage(
                    hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                WCHAR *wszName;
                if(pMon->GetDisplayName(0, 0, &wszName) == S_OK)
                {

                    wsprintf(szTxt, "DisplayName: %S", wszName);

                    HTREEITEM htiVersion = (HTREEITEM)::SendMessage(
                        hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    CoTaskMemFree(wszName);
                }

                //
                // Display the filter's filename
                //
                //            
                // Read filter's CLSID from property bag.  This CLSID string will be
                // used to find the filter's filename in the registry.
                VARIANT varFilterClsid;
                varFilterClsid.vt = VT_BSTR;

                hr = pPropBag->Read(L"CLSID", &varFilterClsid, 0);
                if(SUCCEEDED(hr))
                {
                    TCHAR szKey[512];

                    // Convert BSTR to string and free variant storage
                    CString strQuery(varFilterClsid.bstrVal);
                    SysFreeString(varFilterClsid.bstrVal);

                    // Create key name for reading filename registry
                    wsprintf(szKey, TEXT("Software\\Classes\\CLSID\\%s\\InprocServer32\0"),
                             strQuery);

                    // Variables needed for registry query
                    HKEY hkeyFilter=0;
                    DWORD dwSize=MAX_PATH;
                    BYTE szFilename[MAX_PATH];
                    int rc=0;

                    // Open the CLSID key that contains information about the filter
                    rc = RegOpenKey(HKEY_LOCAL_MACHINE, szKey, &hkeyFilter);
                    if (rc == ERROR_SUCCESS)
                    {
                        rc = RegQueryValueEx(hkeyFilter, NULL,  // Read (Default) value
                                             NULL, NULL, szFilename, &dwSize);

                        if (rc == ERROR_SUCCESS)
                        {
                            // Add filename string to tree node
                            wsprintf(szTxt, "Filename: %s", szFilename);

                            HTREEITEM htiFilename = (HTREEITEM)::SendMessage(
                                hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));
                        }

                        rc = RegCloseKey(hkeyFilter);
                    }
                }
       

                for(UINT iPin = 0; iPin < pFil->cPins; iPin++)
                {
                    wsprintf(szTxt, "pin %02d:", iPin);

                    tvis.hParent = hti;

                    HTREEITEM htiPin = (HTREEITEM)::SendMessage(
                        hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    tvis.hParent = htiPin;

                    wsprintf(szTxt, "bRendered: %d ", !!(pFil->rgPins2[iPin].dwFlags & REG_PINFLAG_B_RENDERER));
                    ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    wsprintf(szTxt, "bOutput: %d ",  !!(pFil->rgPins2[iPin].dwFlags & REG_PINFLAG_B_OUTPUT));
                    ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    wsprintf(szTxt, "bMany: %d ",  !!(pFil->rgPins2[iPin].dwFlags & REG_PINFLAG_B_MANY));
                    ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    wsprintf(szTxt, "bZero: %d ",  !!(pFil->rgPins2[iPin].dwFlags & REG_PINFLAG_B_ZERO));
                    ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    WCHAR szGuid[39];
                    StringFromGUID2(pFil->rgPins2[iPin].clsPinCategory ? *pFil->rgPins2[iPin].clsPinCategory : GUID_NULL, szGuid, 39);
                    wsprintf(szTxt, "ClsPinCategory: %S ", szGuid );
                    ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    for(UINT iType = 0; iType < pFil->rgPins2[iPin].nMediaTypes; iType++)
                    {
                        tvis.hParent = htiPin;
                        wsprintf(szTxt, "type %02d", iType);
                        HTREEITEM htiType = (HTREEITEM)::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                        tvis.hParent = htiType;

                        wsprintf(szTxt, "major type: %s", CNV_GUID(pFil->rgPins2[iPin].lpMediaType[iType].clsMajorType));
                        ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                        wsprintf(szTxt, "subtype: %s", CNV_GUID(pFil->rgPins2[iPin].lpMediaType[iType].clsMinorType));
                        ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    }

                    for(UINT iMed = 0; iMed < pFil->rgPins2[iPin].nMediums; iMed++)
                    {
                        tvis.hParent = htiPin;
                        wsprintf(szTxt, "Medium %02d", iMed);
                        HTREEITEM htiType = (HTREEITEM)::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                        tvis.hParent = htiType;
                        WCHAR szGuid[39];

                        StringFromGUID2(pFil->rgPins2[iPin].lpMedium[iMed].clsMedium, szGuid, 39);
                        wsprintf(szTxt, "medium clsid: %S", szGuid);
                        ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                        wsprintf(szTxt, "Data1 Data2: %08x %08x", pFil->rgPins2[iPin].lpMedium[iMed].dw1, pFil->rgPins2[iPin].lpMedium[iMed].dw2);
                        ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    }
                }

                CoTaskMemFree((BYTE *)pFil);
                lRc = ERROR_SUCCESS;
            }
        }

        pPropBag->Release();
    }
}

#endif // SHOWTYPES

void CFilterView::DoOneCategory(
    const TCHAR *szCatDesc,
    HWND hWndTree,
    const GUID *pCatGuid,
    ICreateDevEnum *pCreateDevEnum)
{

    // !!! leaked.
    CLSID *pclsid = new CLSID;
    *pclsid = *pCatGuid;

    // enumerator returns S_FALSE if the category is empty
    TV_INSERTSTRUCT tvis;
    tvis.hParent = TVI_ROOT;
    tvis.hInsertAfter = TVI_SORT ;
    tvis.item.pszText = (char *)szCatDesc; // !!! can be wide
    tvis.item.lParam = (DWORD_PTR)pclsid;
    tvis.item.mask = TVIF_TEXT | TVIF_PARAM;

    //TreeView_InsertItem(hWndTree, &tvis);
    HTREEITEM htiParent = (HTREEITEM)::SendMessage(
        hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

    {

        TV_INSERTSTRUCT tvis;
        tvis.hParent = htiParent;
        tvis.hInsertAfter = TVI_SORT;
        tvis.item.pszText = "dummy";
        tvis.item.lParam = 0;
        tvis.item.mask = TVIF_TEXT | TVIF_PARAM;

        //TreeView_InsertItem(hWndTree, &tvis);
        HTREEITEM htx = (HTREEITEM)::SendMessage((hWndTree), TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));
    }

    return;
}

void CFilterView::RedoList()
{
    HWND hWndTree = ::GetDlgItem(m_hWnd, IDC_FILTER_TREE);
    ASSERT(hWndTree);

    m_lMoniker.DeleteRemoveAll();

    //
    // Add all filters to the list view
    //
    //TreeView_DeleteAllItems(hWndTree);
    ::SendMessage((hWndTree), TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT);

    //
    //
    //
    ICreateDevEnum *pCreateDevEnum;

    HRESULT hr;

    // !!! try getting mapper from graph instead of fresh....
    IFilterMapper3 *pMapper = NULL;

    // if we can, get the pCreateDevEnum from the graph, which may be remote
    m_pBoxNet->IGraph()->QueryInterface(IID_IFilterMapper3, (void **) &pMapper);

    if (pMapper) {
        hr = pMapper->GetICreateDevEnum(&pCreateDevEnum);
        pMapper->Release();
    } else {
        hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                              IID_ICreateDevEnum, (void**)&pCreateDevEnum);
    }


    if(SUCCEEDED(hr))
    {
        IEnumMoniker *pEmCat = 0;
        hr = pCreateDevEnum->CreateClassEnumerator(
            CLSID_ActiveMovieCategories,
            &pEmCat,
            0);

        if(hr == S_OK)
        {
            IMoniker *pMCat;
            ULONG cFetched;
            while(hr = pEmCat->Next(1, &pMCat, &cFetched),
                  hr == S_OK)
            {
                IPropertyBag *pPropBag;
                hr = pMCat->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
                if(SUCCEEDED(hr))
                {
                    VARIANT varCatClsid;
                    varCatClsid.vt = VT_BSTR;
                    hr = pPropBag->Read(L"CLSID", &varCatClsid, 0);
                    if(SUCCEEDED(hr))
                    {
                        CLSID clsidCat;
                        if(CLSIDFromString(varCatClsid.bstrVal, &clsidCat) == S_OK)
                        {
                            // use the guid if we can't get the name
                            WCHAR *wszTmpName;

                            VARIANT varCatName;
                            varCatName.vt = VT_BSTR;
                            hr = pPropBag->Read(L"FriendlyName", &varCatName, 0);
                            if(SUCCEEDED(hr))
                            {
                                wszTmpName = varCatName.bstrVal;
                            }
                            else
                            {
                                wszTmpName = varCatClsid.bstrVal;
                            }

                            TCHAR szCatDesc[MAX_PATH];

                            WideCharToMultiByte(
                                CP_ACP, 0, wszTmpName, -1,
                                szCatDesc, sizeof(szCatDesc), 0, 0);

                            if(SUCCEEDED(hr))
                            {
                                SysFreeString(varCatName.bstrVal);
                            }

                            DoOneCategory(
                                szCatDesc,
                                hWndTree,
                                &clsidCat,
                                pCreateDevEnum);

                        }

                        SysFreeString(varCatClsid.bstrVal);
                    }

                    pPropBag->Release();
                }
                else
                {
                    break;
                }

                pMCat->Release();
            } // for loop

            pEmCat->Release();
        }
        
        if( SUCCEEDED( hr ) )
        {
            // show any custom categories we'd like to see from GraphEdt...
            for( int i = 0; g_AppEnumeratedCategories[i].pclsid; i ++ )
            {    
                 DoOneCategory(
                     g_AppEnumeratedCategories[i].pszCat,
                     hWndTree,
                     g_AppEnumeratedCategories[i].pclsid,
                     pCreateDevEnum);
            }
        }

        pCreateDevEnum->Release();
    }
    
    // For resizing... All of our controls will be created by now so it is safe to
    // process OnSize messages.
    m_bHadInitDialog = TRUE;

    // Save our current size.
    CRect rcDialog;
    GetClientRect( &rcDialog );
    m_LastDialogSize = rcDialog.Size();

    // Work out that minimum size == dialog box with no list view object
    CRect rcTreeView;
    CWnd *pwndTreeView = GetDlgItem( IDC_FILTER_TREE );

    ASSERT( pwndTreeView );
    GetWindowRect( &rcDialog );
    pwndTreeView->GetWindowRect( &rcTreeView );

    m_MinDialogSize.cx = rcDialog.Width() - rcTreeView.Width();
    m_MinDialogSize.cy = rcDialog.Height() - rcTreeView.Height();
}

void CFilterView::OnSize( UINT nType, int cx, int cy )
{
    if( SIZE_RESTORED == nType ){
        if( m_bHadInitDialog ){
            CRect rcCancelButton, rcInsertButton, rcDialog, rcTreeView;

            CWnd *pwndCancelButton = GetDlgItem( IDCANCEL );
            CWnd *pwndInsertButton = GetDlgItem( ID_ADDFILTER );
            CWnd *pwndTreeView = GetDlgItem( IDC_FILTER_TREE );

            ASSERT( pwndCancelButton );
            ASSERT( pwndInsertButton );
            ASSERT( pwndTreeView );

            GetClientRect( &rcDialog );
            pwndCancelButton->GetWindowRect( &rcCancelButton );
            pwndInsertButton->GetWindowRect( &rcInsertButton );
            pwndTreeView->GetWindowRect( &rcTreeView );

            ScreenToClient( &rcCancelButton );
            ScreenToClient( &rcInsertButton );
            ScreenToClient( &rcTreeView );

            int iXInc = cx - m_LastDialogSize.cx;
            int iYInc = cy - m_LastDialogSize.cy;

            rcCancelButton.left += iXInc;
            rcCancelButton.right += iXInc;
            rcInsertButton.left += iXInc;
            rcInsertButton.right += iXInc;
            rcTreeView.right += iXInc;
            rcTreeView.bottom += iYInc;

            pwndCancelButton->MoveWindow( rcCancelButton );
            pwndInsertButton->MoveWindow( rcInsertButton );
            pwndTreeView->MoveWindow( rcTreeView );
        }

        m_LastDialogSize = CSize( cx, cy );
    }
}

void CFilterView::OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI )
{
    if( m_bHadInitDialog )
        lpMMI->ptMinTrackSize = *((POINT*)&m_MinDialogSize);
}

//
// DialogProc
//
INT_PTR CFilterView::DialogProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    ASSERT(m_pThis);

    if (msg == WM_LBUTTONDBLCLK) {
        //
        // The double click has selected the filter we want to insert.
        // Do the same as if we had pressed the insert button
        //
        m_pThis->OnInsert();

        // Don't return here - just fall through to the default handler.
        // This will allow the tree view control to handle the case where
        // we're double-clicking on a category name instead of a filter.
        // Returning here disables that default functionality.
    }


    return ::CallWindowProc(m_pfnOldDialogProc, hWnd, msg, wParam, lParam);
}

#ifdef COLORCODED_FILTERS
void CFilterView::OnCustomDraw (LPNMHDR lpn, LRESULT *pl)
{
    *pl = CDRF_DODEFAULT;
    LPNMLVCUSTOMDRAW lpCD = (LPNMLVCUSTOMDRAW)lpn;

    switch (lpCD->nmcd.dwDrawStage)
    {

      case CDDS_PREPAINT :
          *pl =  CDRF_NOTIFYITEMDRAW;
          return;

      case CDDS_ITEMPREPAINT:
      {
          LV_DISPINFO *pnmv = (LV_DISPINFO *) lpn;
          int iItem = (int)( pnmv->item.lParam );

          POSITION pos = m_lMoniker.GetHeadPosition();
          while(pos != 0 && iItem-- > 0)
          {
              m_lMoniker.GetNext(pos);
          }
          if(pos)
          {

              IMoniker *pMon = *m_lMoniker.GetAt(pos); // not addrefd
              if(pMon)
              {
                  IPropertyBag *pPropBag;
                  HRESULT hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
                  if(SUCCEEDED(hr))
                  {
                      VARIANT var;
                      var.vt = VT_BSTR;
                      hr = pPropBag->Read(L"CLSID", &var, 0);
                      if(SUCCEEDED(hr))
                      {
                        CLSID clsidFil;
                        if(CLSIDFromString(var.bstrVal, &clsidFil) == S_OK)
                        {
                            static CLSID CLSID_Proxy = {
                                0x17CCA71B, 0xECD7, 0x11D0,
                                {0xB9, 0x08, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96}
                            } ;

                            if(clsidFil == CLSID_Proxy) {
                                lpCD->clrText = RGB(255,128,128);
                            }

                        }
                          SysFreeString(var.bstrVal);

                      }
                      pPropBag->Release();

                      // dmo's don't have a CLSID value!???

                      WCHAR *wszName;
                      if(pMon->GetDisplayName(0, 0, &wszName) == S_OK)
                      {
                          if(wszName[0] == L'@' &&
                             wszName[1] == L'd' &&
                             wszName[2] == L'e' &&
                             wszName[3] == L'v' &&
                             wszName[4] == L'i' &&
                             wszName[5] == L'c' &&
                             wszName[6] == L'e' &&
                             wszName[7] == L':' &&
                             wszName[8] == L'd' &&
                             wszName[9] == L'm' &&
                             wszName[10] == L'o')
                          {

                              lpCD->clrText = RGB(0,128,0);
                          }
                          CoTaskMemFree(wszName);
                      }

                  }
              }

          }
      }
    }
}
#endif // COLORCODED_FILTERS

void CFilterView::OnItemExpanding (NMHDR* pnmh, LRESULT* pResult)
{
    NM_TREEVIEW* pnmtv = (NM_TREEVIEW*) pnmh;

    if(pnmtv->itemNew.state & TVIS_EXPANDEDONCE) {
        return;
    }

    HWND hWndTree = ::GetDlgItem(m_hWnd, IDC_FILTER_TREE);


    HTREEITEM htiParent = pnmtv->itemNew.hItem;

    HTREEITEM htiOwner = (HTREEITEM)::SendMessage((hWndTree), TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)htiParent);
    if(htiOwner != 0) {
        return;
    }

    // remove dummy node
    HTREEITEM htiChild = (HTREEITEM)::SendMessage((hWndTree), TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)htiParent);
    ::SendMessage((hWndTree), TVM_DELETEITEM, 0, (LPARAM)htiChild);

    CLSID *pCatGuid = (CLSID *)pnmtv->itemNew.lParam;

    // !!! try getting mapper from graph instead of fresh....
    IFilterMapper3 *pMapper = NULL;

    // if we can, get the pCreateDevEnum from the graph, which may be remote
    m_pBoxNet->IGraph()->QueryInterface(IID_IFilterMapper3, (void **) &pMapper);

    HRESULT hr;

    ICreateDevEnum *pCreateDevEnum;
    if (pMapper) {
        hr = pMapper->GetICreateDevEnum(&pCreateDevEnum);
        pMapper->Release();
    } else {
        hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                              IID_ICreateDevEnum, (void**)&pCreateDevEnum);
    }
    if(SUCCEEDED(hr))
    {

        IEnumMoniker *pEm;
        hr = pCreateDevEnum->CreateClassEnumerator(
            *pCatGuid,
            &pEm,
            0);
        if(SUCCEEDED(hr))
        {
            // remember hr is S_FALSE if pEm is null because there
            // would've been zero elements.
            //
            if(htiParent != 0 && pEm)
            {
                ULONG cFetched;
                IMoniker *pM;
                while(hr = pEm->Next(1, &pM, &cFetched),
                      hr == S_OK)
                {
                    IPropertyBag *pPropBag;
                    hr = pM->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
                    if(SUCCEEDED(hr))
                    {
                        VARIANT var;
                        var.vt = VT_BSTR;
                        hr = pPropBag->Read(L"FriendlyName", &var, 0);
                        if(SUCCEEDED(hr))
                        {
                            TCHAR szString[MAX_PATH];
                            WideCharToMultiByte(
                                CP_ACP, 0, var.bstrVal, -1,
                                szString, sizeof(szString), 0, 0);

                            TV_INSERTSTRUCT tvis;
                            tvis.hParent = htiParent;
                            tvis.hInsertAfter = TVI_SORT;
                            tvis.item.pszText = szString; // !!! can be wide
                            tvis.item.lParam = m_lMoniker.GetCount(); // use POS?
                            tvis.item.mask = TVIF_TEXT | TVIF_PARAM;

                            //TreeView_InsertItem(hWndTree, &tvis);
                            HTREEITEM htx = (HTREEITEM)::SendMessage((hWndTree), TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));
                            m_lMoniker.AddTail(new CQCOMInt<IMoniker>(pM));

#ifdef SHOWTYPES
                            // !!! aggregation broken -- cannot qi
                            // graph or mapper for IAMFilterData
                            IAMFilterData *pfd;
                            hr = CoCreateInstance(
                                CLSID_FilterMapper,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IAMFilterData,
                                (void **)&pfd);
                            if(SUCCEEDED(hr))
                            {
                                DoFilterInfo(hWndTree, htx, pM, pfd);
                                pfd->Release();
                            }
#endif

                            SysFreeString(var.bstrVal);
                        }
                        pPropBag->Release();
                    }

                    pM->Release();
                }

            }
            if(pEm) {
                pEm->Release();
            }
        }
        pCreateDevEnum->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\congraph.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// congraph.h

#ifndef __CONN_GRAPH__
#define __CONN_GRAPH__

class CConGraph : public CDialog
{
public:
    ~CConGraph();
    CConGraph(IMoniker **ppmk, IRunningObjectTable *pirot, CWnd * pParent = NULL );

protected:

    BOOL OnInitDialog();
    void OnDestroy();
    void DoDataExchange(CDataExchange* pDX);

    void ClearList();
    void OnRefreshList();

    virtual void OnOK();
    virtual void OnDblclkGraphList();

    DECLARE_MESSAGE_MAP()

private:
    CListBox m_ListBox;

    IMoniker **m_ppmk;
    IRunningObjectTable *m_pirot;
};

#endif // __CONN_GRAPH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\geerrors.h ===
#ifndef GraphEditErrors_h
#define GraphEditErrors_h

#define GE_S_RECONNECT_PENDING          MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_ITF, 0xFFFF )

#endif // GraphEditErrors_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\fnd.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef CFilterNameDictionary_h
#define CFilterNameDictionary_h

class CFilterNameDictionary
{
public:
    CFilterNameDictionary( HRESULT* phr );
    ~CFilterNameDictionary();

    HRESULT GetFilterName( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] );

private:
    HRESULT GetNameFromFilter( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] );
    HRESULT GetNameFromFilterNameTable( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] );
    HRESULT GetNameFromInterfacePointer( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] );

    static HRESULT GetFiltersNameAndCLSID
        (
        IMoniker* pFiltersMoniker,
        CLSID* pclsidFilter,
        WCHAR* pszFiltersName,
        DWORD dwMaxFilterNameLength
        );

    HRESULT BuildFilterNameTable( void );
    HRESULT AddNameToTable( CLSID& clsid, WCHAR* pszName );
    void DestroyFilterNameTable( void );

    static HRESULT GetFilterCLSID( IBaseFilter* pFilter, CLSID* pFilterCLSID );

    CMap<CLSID, CLSID&, WCHAR*, WCHAR*>* m_pFilterNames;

};

#endif // CFilterNameDictionary_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\filtervw.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
class CFilterView : public CDialog
{
public:
    static void DelFilterView();
    static CFilterView * GetFilterView(
        CBoxNetDoc * pBoxNet,
        CWnd * pParent = NULL );

protected:
    ~CFilterView();
    CFilterView(
        CBoxNetDoc * pBoxNet,
        CWnd * pParent = NULL );


    afx_msg void OnSize( UINT nType, int cx, int cy );
    afx_msg void OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI );

    afx_msg void OnInsert();
#ifdef FILTER_FAVORITES
    afx_msg void OnAddToFav();
#endif
    afx_msg void OnItemExpanding(NMHDR* pnmh, LRESULT* pResult);
#ifdef COLORCODED_FILTERS
    afx_msg void OnCustomDraw(NMHDR* pnmh, LRESULT* pResult);
#endif
    
    BOOL OnInitDialog();
    void RedoList();
    void DoOneCategory(
        const TCHAR *szCatDesc,
        HWND hWndTree,
        const GUID *pCatGuid,
        ICreateDevEnum *pCreateDevEnum);
    
    int m_iIcon;

    // can't get count without enumerating everything. so use list.
    CDeleteList<CQCOMInt<IMoniker>*, CQCOMInt<IMoniker>* > m_lMoniker;

    CBoxNetDoc * m_pBoxNet;
    HIMAGELIST m_hImgList;

    static CFilterView * m_pThis;
    static WNDPROC m_pfnOldDialogProc;
    static INT_PTR CALLBACK DialogProc(HWND, UINT, WPARAM, LPARAM);

    BOOL m_bHadInitDialog;         // Received OnInitDialog message?
    CSize m_LastDialogSize;        // Last known size of our dialog box
    CSize m_MinDialogSize;         // Minimum size of the dialog box

    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\dcf.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include <streams.h>
#include "DCF.h"
#include "FLB.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CDisplayCachedFilters, CDialog)
	//{{AFX_MSG_MAP(CDisplayCachedFilters)
	ON_LBN_ERRSPACE(IDC_CACHED_FILTERS, OnErrSpaceCachedFilters)
	ON_BN_CLICKED(ID_REMOVE_FILTER, OnRemoveFilter)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CDisplayCachedFilters::CDisplayCachedFilters
    (
    IGraphConfig* pFilterCache,
    HRESULT* phr,
    CWnd* pParent /*=NULL*/
    )
	: CDialog(CDisplayCachedFilters::IDD, pParent),
    m_pFilterCache(NULL),
    m_plbCachedFiltersList(NULL)
{
	//{{AFX_DATA_INIT(CDisplayCachedFilters)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    // This dialog box will not work correctly if a NULL pointer is passed in.
    ASSERT( NULL != pFilterCache );

    try
    {   
        m_plbCachedFiltersList = new CFilterListBox( phr );
    }
    catch( CMemoryException* pOutOfMemory )
    {
        m_plbCachedFiltersList = NULL;

        pOutOfMemory->Delete();
        *phr = E_OUTOFMEMORY;
        return;
    }  
 
    if( FAILED( *phr ) )
    {
        delete m_plbCachedFiltersList;
        m_plbCachedFiltersList = NULL;
        return;
    }

    m_pFilterCache = pFilterCache;
    m_pFilterCache->AddRef();
}

CDisplayCachedFilters::~CDisplayCachedFilters()
{
    delete m_plbCachedFiltersList;
    if( NULL != m_pFilterCache )
    {
        m_pFilterCache->Release();
    }
}

/////////////////////////////////////////////////////////////////////////////
// CDisplayCachedFilters message handlers

void CDisplayCachedFilters::OnErrSpaceCachedFilters() 
{
    DisplayQuartzError( E_OUTOFMEMORY );

    EndDialog( IDABORT );
}

BOOL CDisplayCachedFilters::OnInitDialog() 
{
    CDialog::OnInitDialog();

    HRESULT hr = AddCachedFilterNamesToListBox();
    if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
        EndDialog( IDABORT );
        return TRUE;
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDisplayCachedFilters::DoDataExchange(CDataExchange* pDX) 
{
    // This function exepects m_plbCachedFiltersList to be allocated.
    ASSERT( NULL != m_plbCachedFiltersList );

	CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CDisplayCachedFilters)
	DDX_Control(pDX, IDC_CACHED_FILTERS, *m_plbCachedFiltersList);
	//}}AFX_DATA_MAP
}

void CDisplayCachedFilters::OnRemoveFilter() 
{
    IBaseFilter* pSelectedFilter;

    HRESULT hr = m_plbCachedFiltersList->GetSelectedFilter( &pSelectedFilter );
    if( FAILED( hr ) )
    {
        ::MessageBeep( MB_ICONASTERISK );
        return;
    }

    hr = m_plbCachedFiltersList->RemoveSelectedFilter();
    if( FAILED( hr ) )
    {
        ::MessageBeep( MB_ICONASTERISK );
        return;
    } 

    hr = m_pFilterCache->RemoveFilterFromCache( pSelectedFilter );
    if( FAILED( hr ) || (S_FALSE == hr) )
    {
        ::MessageBeep( MB_ICONASTERISK );
        return;
    }
    pSelectedFilter->Release(); // Release the filter cache's reference.    
}

HRESULT CDisplayCachedFilters::AddCachedFilterNamesToListBox( void )
{
    HRESULT hr;
    
    IBaseFilter* pCurrentFilter;
    IEnumFilters* pFilterCacheEnum;
    
    hr = m_pFilterCache->EnumCacheFilter( &pFilterCacheEnum );
    if( FAILED( hr ) ) {
        return hr;
    }

    HRESULT hrEnum;

    do
    {
        hrEnum = pFilterCacheEnum->Next( 1, &pCurrentFilter, NULL );
        if( FAILED( hrEnum ) ) {
            pFilterCacheEnum->Release();
            return hrEnum;
        }
        
        if( S_OK == hrEnum ) {
            // This is a sanity check used to makesure the filter cache
            // is in a valid state.
            ASSERT( S_OK == IsCached( m_pFilterCache, pCurrentFilter ) );

            hr = m_plbCachedFiltersList->AddFilter( pCurrentFilter );
    
            pCurrentFilter->Release();
            pCurrentFilter = NULL;

            if( FAILED( hr ) )
            {
                pFilterCacheEnum->Release();
                return hr;
            }
        }
    } while( S_OK == hrEnum );

    pFilterCacheEnum->Release();

    return S_OK;
}

#ifdef _DEBUG
HRESULT CDisplayCachedFilters::IsCached( IGraphConfig* pFilterCache, IBaseFilter* pFilter )
{
    // This function does not handle NULL parameters.
    ASSERT( (NULL != pFilterCache) && (NULL != pFilter) );

    bool fFoundFilterInCache;
    IBaseFilter* pCurrentFilter;
    IEnumFilters* pCachedFiltersEnum;

    #ifdef _DEBUG
    DWORD dwNumFiltersCompared = 0;
    #endif // _DEBUG

    HRESULT hr = pFilterCache->EnumCacheFilter( &pCachedFiltersEnum );
    if( FAILED( hr ) ) {
        return hr;   
    }

    fFoundFilterInCache = false;

    do
    {
        hr = pCachedFiltersEnum->Next( 1, &pCurrentFilter, NULL );
        switch( hr )
        {
        case S_OK:
            if( ::IsEqualObject( pCurrentFilter, pFilter ) ) {
                fFoundFilterInCache = true;
            } else {
                fFoundFilterInCache = false;
            }
            
            #ifdef _DEBUG
            {
                dwNumFiltersCompared++;

                HRESULT hrDebug = TestTheFilterCachesIEnumFiltersInterface( pCachedFiltersEnum, pCurrentFilter, dwNumFiltersCompared );
    
                // Since this code in TestTheFilterCachesIEnumFiltersInterface() is only used to debug
                // the system, it does not affect the operation of this function.  Therefore, all failures
                // can be safely ignored (however, they SHOULD be investigated.
                ASSERT( SUCCEEDED( hrDebug ) || (VFW_E_ENUM_OUT_OF_SYNC == hrDebug) );
            }
            #endif // _DEBUG

            pCurrentFilter->Release();

            break;

        case S_FALSE:
            break;

        case VFW_E_ENUM_OUT_OF_SYNC:
            hr = pCachedFiltersEnum->Reset();

            #ifdef _DEBUG
            dwNumFiltersCompared = 0;
            #endif // _DEBUG

            break;

        default:
            // IEnumXXXX interface can only return two success codes,
            // S_OK and S_FALSE.
            ASSERT( FAILED( hr ) );
        }
            
    } while( SUCCEEDED( hr ) && (hr != S_FALSE) && !fFoundFilterInCache );

    pCachedFiltersEnum->Release();

    if( FAILED( hr ) ) {
        return hr;
    }
    
    if( fFoundFilterInCache ) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

HRESULT CDisplayCachedFilters::TestTheFilterCachesIEnumFiltersInterface( IEnumFilters* pCachedFiltersEnum, IBaseFilter* pCurrentFilter, DWORD dwNumFiltersExamended )
{
    IEnumFilters* pCloanedCachedFiltersEnum = NULL;
    IEnumFilters* pAnotherCloanedCachedFiltersEnum = NULL;
    IEnumFilters* pQueriedCachedFiltersInterface = NULL;

    HRESULT hr = pCachedFiltersEnum->QueryInterface( IID_IEnumFilters, (void**)&pQueriedCachedFiltersInterface );
    if( FAILED( hr ) )
    {
        return hr;
    }

    pQueriedCachedFiltersInterface->Release();
    pQueriedCachedFiltersInterface = NULL;

    hr = pCachedFiltersEnum->Clone( &pCloanedCachedFiltersEnum );
    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = pCloanedCachedFiltersEnum->Clone( &pAnotherCloanedCachedFiltersEnum );
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        return hr;
    }    

    hr = pCloanedCachedFiltersEnum->Reset();
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }    

    if( (dwNumFiltersExamended - 1) > 0 )
    {
        hr = pCloanedCachedFiltersEnum->Skip( dwNumFiltersExamended - 1 );
        if( FAILED( hr ) )
        {
            pCloanedCachedFiltersEnum->Release();
            pAnotherCloanedCachedFiltersEnum->Release();
            return hr;
        }
    }

    DWORD dwNumFiltersRetrieved;
    IBaseFilter* aCurrentFilter[1];

    hr = pCloanedCachedFiltersEnum->Next( 1, aCurrentFilter, &dwNumFiltersRetrieved );
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }

    // This should not be S_FALSE because the cache contains at least
    // dwNumFiltersExamended filtes.
    ASSERT( S_FALSE != hr );

    // IEnumFilters::Next() should return exactly one filter because 
    // that is all we asked for.
    ASSERT( 1 == dwNumFiltersRetrieved );    

    // The preceding code should get the same filter as the current filter.    
    ASSERT( ::IsEqualObject( pCurrentFilter, aCurrentFilter[0] ) );

    aCurrentFilter[0]->Release();
    aCurrentFilter[0] = NULL;

    const DWORD HUGE_NUMBER = 0x7FFFFFFF;

    hr = pCloanedCachedFiltersEnum->Skip( HUGE_NUMBER );
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }

    // This should be S_FALSE because the usually does not contain
    // HUGE_NUMBER of filters.  Ignore this ASSERT if you have at least
    // HUGE_NUMBER + dwNumFiltersExamended of filters in the cache.
    ASSERT( S_FALSE == hr );

    hr = pCloanedCachedFiltersEnum->Reset();
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }  

    IBaseFilter** ppCachedFilters;

    try
    {
        ppCachedFilters = new IBaseFilter*[dwNumFiltersExamended];
    }
    catch( CMemoryException* peOutOfMemory )
    {
        peOutOfMemory->Delete();

        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return E_OUTOFMEMORY;
    }

    hr = pCloanedCachedFiltersEnum->Next( dwNumFiltersExamended, ppCachedFilters, &dwNumFiltersRetrieved );
    if( FAILED( hr ) )
    {
        delete [] ppCachedFilters;
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }

    // This should not be S_FALSE because the cache contains at least
    // dwNumFiltersExamended filtes.
    ASSERT( S_FALSE != hr );

    // IEnumFilters::Next() should return exactly dwNumFiltersExamended filters because 
    // that is all we asked for.
    ASSERT( dwNumFiltersExamended == dwNumFiltersRetrieved );
    
    // The last filter in the array should be the same as the current filter.
    ASSERT( ::IsEqualObject( pCurrentFilter, ppCachedFilters[dwNumFiltersExamended-1] ) );

    for( DWORD dwCurrentFilter = 0; dwCurrentFilter < dwNumFiltersRetrieved; dwCurrentFilter++ )
    {
        ppCachedFilters[dwCurrentFilter]->Release();
        ppCachedFilters[dwCurrentFilter] = NULL;
    }

    delete [] ppCachedFilters;
    ppCachedFilters = NULL;

    hr = pCloanedCachedFiltersEnum->Next( 1, aCurrentFilter, &dwNumFiltersRetrieved );
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }

    DWORD dwAnotherNumFiltersRetrieved;
    IBaseFilter* aAnotherCurrentFilter[1];
    aAnotherCurrentFilter[0] = NULL;

    HRESULT hrAnother = pAnotherCloanedCachedFiltersEnum->Next( 1, aAnotherCurrentFilter, &dwAnotherNumFiltersRetrieved );
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        aCurrentFilter[0]->Release();
        return hr;
    }

    pCloanedCachedFiltersEnum->Release();
    pAnotherCloanedCachedFiltersEnum->Release();

    // Ensure the returned values are legal.
    ASSERT( (1 == dwAnotherNumFiltersRetrieved) || (0 == dwAnotherNumFiltersRetrieved) );
    ASSERT( (1 == dwNumFiltersRetrieved) || (0 == dwNumFiltersRetrieved) );
    ASSERT( ((hr == S_OK) && (1 == dwNumFiltersRetrieved)) ||
            ((hr == S_FALSE) && (0 == dwNumFiltersRetrieved)) );
    ASSERT( ((hrAnother == S_OK) && (1 == dwAnotherNumFiltersRetrieved)) ||
            ((hrAnother == S_FALSE) && (0 == dwAnotherNumFiltersRetrieved)) );

    // Since both enums should be in the exact same state, then every thing should be
    // equal.    
    ASSERT( hr == hrAnother );
    ASSERT( dwNumFiltersRetrieved == dwAnotherNumFiltersRetrieved );

    if( (1 == dwNumFiltersRetrieved) && (1 == dwAnotherNumFiltersRetrieved) )
    {
        ASSERT( ::IsEqualObject( aCurrentFilter[0], aAnotherCurrentFilter[0] ) );
    }

    if( S_OK == hr )
    {
        aCurrentFilter[0]->Release();
    }

    if( S_OK == hr )
    {
        aAnotherCurrentFilter[0]->Release();
    }

    return S_OK;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\fnd.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include <streams.h>
#include "FND.h"

template<> inline UINT AFXAPI HashKey<CLSID&>( CLSID& clsidKey )
{
	return ((UINT) *((BYTE*)&clsidKey));
}

CFilterNameDictionary::CFilterNameDictionary( HRESULT* phr )
{
    try
    {
        m_pFilterNames = new CMap<CLSID, CLSID&, WCHAR*, WCHAR*>;
    }
    catch( CMemoryException* eOutOfMemory )
    {
        m_pFilterNames = NULL;
        eOutOfMemory->Delete();
        *phr = E_OUTOFMEMORY;
        return;
    }
    
    HRESULT hr = BuildFilterNameTable();
    if( FAILED( hr ) )
    {
        DestroyFilterNameTable();
        *phr = hr;
        return;
    }
}

CFilterNameDictionary::~CFilterNameDictionary()
{
    DestroyFilterNameTable();
}

void CFilterNameDictionary::DestroyFilterNameTable( void )
{
    CLSID clsidCurrent;
    WCHAR* pszCurrentName;

    if( NULL != m_pFilterNames )
    {
        if( !m_pFilterNames->IsEmpty() )
        {
            POSITION posCurrent = m_pFilterNames->GetStartPosition();

            while( posCurrent != NULL )
            {
                m_pFilterNames->GetNextAssoc( posCurrent, clsidCurrent, pszCurrentName );
                delete [] pszCurrentName;
            }
        }

        m_pFilterNames->RemoveAll();

        delete m_pFilterNames;
        m_pFilterNames = NULL;
    }
}

HRESULT CFilterNameDictionary::GetFilterName( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] ) 
{
    HRESULT hr = GetNameFromFilter( pFilter, szFilterName );
    if( SUCCEEDED( hr ) )
    {
        return S_OK;
    }

    hr = GetNameFromFilterNameTable( pFilter, szFilterName );
    if( SUCCEEDED( hr ) )
    {
        return S_OK;
    }
    
    hr = GetNameFromInterfacePointer( pFilter, szFilterName ); 
    if( SUCCEEDED( hr ) )
    {
        return S_OK;
    }

    return E_FAIL;
}

HRESULT CFilterNameDictionary::GetNameFromFilter( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] )
{
    FILTER_INFO fiFilterInfo;

    HRESULT hr = pFilter->QueryFilterInfo( &fiFilterInfo );
    if( FAILED( hr ) ) {
        return hr;
    }

    if( NULL != fiFilterInfo.pGraph ) {
        fiFilterInfo.pGraph->Release();
        fiFilterInfo.pGraph = NULL;
    }

    // Check so see if the filter's name is empty.
    if( '\0' == fiFilterInfo.achName[0] )
    {
        return E_FAIL;         
    }   

    ::lstrcpynW( szFilterName, fiFilterInfo.achName, MAX_FILTER_NAME );

    // Ensure that the filter name is ALWAYS null terminated.
    szFilterName[MAX_FILTER_NAME - 1] = '\0';

    return S_OK;
}

HRESULT CFilterNameDictionary::GetNameFromFilterNameTable( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] )
{
    CLSID clsidFilter;

    HRESULT hr = GetFilterCLSID( pFilter, &clsidFilter );
    if( FAILED( hr ) )
    {
        return hr;
    }

    WCHAR* pszFilterNameInTable;

    if( !m_pFilterNames->Lookup( clsidFilter, pszFilterNameInTable ) )
    {
        return E_FAIL;
    }

    ::lstrcpynW( szFilterName, pszFilterNameInTable, MAX_FILTER_NAME );

    // Ensure that the filter name is ALWAYS null terminated.
    szFilterName[MAX_FILTER_NAME - 1] = '\0';

    return S_OK;
}

HRESULT CFilterNameDictionary::GetNameFromInterfacePointer( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] )
{
    IUnknown* pUnknown;

    HRESULT hr = pFilter->QueryInterface( IID_IUnknown, (void**)&pUnknown );
    if( FAILED( hr ) )
    {
        return hr;  
    }

    _snwprintf( szFilterName, MAX_FILTER_NAME, L"Filter's IUnkown Pointer: 0x%p", pUnknown );

    // Ensure that the filter name is ALWAYS null terminated.
    szFilterName[MAX_FILTER_NAME - 1] = '\0';

    pUnknown->Release();

    return S_OK;
}

HRESULT CFilterNameDictionary::BuildFilterNameTable( void )
{
    // This is the lowest possible merit.
    const DWORD MERIT_ANY_FILTER = 0x00000000;

    IFilterMapper2* pFilterMapper2;

    HRESULT hr = CoCreateInstance( CLSID_FilterMapper2,
                                   NULL, // This object will NOT be agregated.
                                   CLSCTX_INPROC_SERVER,  
                                   IID_IFilterMapper2,
                                   (void**)&pFilterMapper2 );
    if( FAILED( hr ) )
    {
        return hr;
    }

    IEnumMoniker* pAllRegisteredFilters;

    hr = pFilterMapper2->EnumMatchingFilters( &pAllRegisteredFilters,
                                              0, // No Flags
                                              FALSE, // No exact match
                                              MERIT_ANY_FILTER, 
                                              FALSE, // We do not care if the filter has any input pins.
                                              0,  
                                              NULL, // Since we don't care if the filter has an input pin, we accept any type.
                                              NULL, // We can use any input medium
                                              NULL, // We want pins from any category.
                                              FALSE, // The filter does not have to render the input.
                                              FALSE, // The filter does not need an output pin.
                                              0,
                                              NULL, // Since we don't care if the filter has an output pin, we accept any type.
                                              NULL, // We can use any output medium
                                              NULL ); // We want pins from any category.
    pFilterMapper2->Release();

    if( FAILED( hr ) )
    {
        return hr;
    }

    HRESULT hrEnum;
    CLSID clsidCurrentFilter;
    IMoniker* aCurrentFilterMoniker[1];

    do
    {
        hrEnum = pAllRegisteredFilters->Next( 1, &aCurrentFilterMoniker[0], NULL );
        if( FAILED( hrEnum ) )
        {
            pAllRegisteredFilters->Release();
            return hrEnum;
        }

        // IEnumMoniker::Next() returns S_OK if it successfully obtained the next moniker.
        if( S_OK == hrEnum )
        {
            WCHAR* pszFilterName;

            try
            {
                pszFilterName = new WCHAR[MAX_FILTER_NAME];
            }
            catch( CMemoryException* eOutOfMemory )
            {
                eOutOfMemory->Delete();
                aCurrentFilterMoniker[0]->Release();            
                pAllRegisteredFilters->Release();
                return E_OUTOFMEMORY;
            }

            hr = GetFiltersNameAndCLSID( aCurrentFilterMoniker[0],
                                         &clsidCurrentFilter,
                                         pszFilterName,
                                         MAX_FILTER_NAME );

            aCurrentFilterMoniker[0]->Release();            
    
            // GetFiltersNameAndCLSID() may fail because the filter can not be created.
            if( FAILED( hr ) )
            {
                delete [] pszFilterName;
                pszFilterName = NULL;
                continue;
            }

            hr = AddNameToTable( clsidCurrentFilter, pszFilterName );
            if( S_FALSE == hr )
            {
                delete [] pszFilterName;
                pszFilterName = NULL;
            }
            else if( FAILED( hr ) )
            {
                pAllRegisteredFilters->Release();
                delete [] pszFilterName;
                return hr;
            }
        }
    } while( S_OK == hrEnum );

    pAllRegisteredFilters->Release();
    
    return S_OK;
}


HRESULT CFilterNameDictionary::GetFiltersNameAndCLSID
    (
    IMoniker* pFiltersMoniker,
    CLSID* pclsidFilter,
    WCHAR* pszFiltersName,
    DWORD dwMaxFilterNameLength
    )
{
    CComPtr<IBindCtx> pBindContext;

    HRESULT hr = ::CreateBindCtx( 0, &pBindContext );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // Get the filter's name.
    CComPtr<IPropertyBag> pFilterPropertyBag;

    hr = pFiltersMoniker->BindToStorage( pBindContext,
                                         NULL,
                                         IID_IPropertyBag,
                                         (void**)&pFilterPropertyBag );
    if( FAILED( hr ) )
    {
        return hr;
    }

    VARIANT varFilterName;

    ::VariantInit( &varFilterName );
    varFilterName.vt = VT_BSTR;
    varFilterName.bstrVal = ::SysAllocString(NULL);

    hr = pFilterPropertyBag->Read( L"FriendlyName", &varFilterName, NULL );

    if( FAILED( hr ) )
    {
        ::VariantClear( &varFilterName );
        return hr;
    }

    VARIANT varFilterCLSID;

    ::VariantInit( &varFilterCLSID );
    varFilterCLSID.vt = VT_BSTR;
    varFilterCLSID.bstrVal = ::SysAllocString(NULL);

    hr = pFilterPropertyBag->Read( L"CLSID", &varFilterCLSID, NULL );

    if( FAILED( hr ) )
    {
        ::VariantClear( &varFilterName );
        ::VariantClear( &varFilterCLSID ); 
        return hr;
    }

    CLSID clsidFilter;

    hr = CLSIDFromString( varFilterCLSID.bstrVal, &clsidFilter );

    ::VariantClear( &varFilterCLSID ); 

    if( FAILED( hr ) ) {
        ::VariantClear( &varFilterName );
        return hr;
    }

    // The SysStringLen() length returned by SysStringLen() does not include the null
    // terminating character.
    DWORD dwFilterNameLength = ::SysStringLen( varFilterName.bstrVal ) + 1;
    
    // If this ASSERT fires, then the filter's name will be truncated.
    ASSERT( dwFilterNameLength < MAX_FILTER_NAME );

    ::lstrcpynW( pszFiltersName, varFilterName.bstrVal, min( dwFilterNameLength, dwMaxFilterNameLength ) );

    *pclsidFilter = clsidFilter;

    ::VariantClear( &varFilterName );

    return S_OK;
}

HRESULT CFilterNameDictionary::AddNameToTable( CLSID& clsid, WCHAR* pszName )
{
    WCHAR* pszStoredName; 
   
    // There should never be two names with the same CLSID.
    if( m_pFilterNames->Lookup( clsid, pszStoredName ) )
    {
        DbgLog(( LOG_TRACE, 0, "WARNING: Found two names with the same CLSID: %40ls  %40ls", pszStoredName, pszName ));
        return S_FALSE;
    }

    try
    {
        m_pFilterNames->SetAt( clsid, pszName );
    }
    catch( CMemoryException* eOutOfMemory )
    {
        eOutOfMemory->Delete();
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT CFilterNameDictionary::GetFilterCLSID( IBaseFilter* pFilter, CLSID* pFilterCLSID )
{
    IPersist* pFilterID;

    HRESULT hr = pFilter->QueryInterface( IID_IPersist, (void**)&pFilterID );

    if( FAILED( hr ) )
    {
        return hr;
    }

    CLSID clsidFilter;

    hr = pFilterID->GetClassID( &clsidFilter );

    pFilterID->Release();

    if( FAILED( hr ) )
    {
        return hr;
    }

    *pFilterCLSID = clsidFilter;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\flb.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "FND.h"
#include "FLB.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CFilterListBox, CListBox)
    //{{AFX_MSG_MAP(CFilterListBox)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CFilterListBox::CFilterListBox( HRESULT* phr )
    : m_pfndFilterDictionary(NULL),
      m_pListedFilters(NULL)
{
    try
    {
        m_pListedFilters = new CList<IBaseFilter*, IBaseFilter*>;
        m_pfndFilterDictionary = new CFilterNameDictionary( phr );
    }
    catch( CMemoryException* pOutOfMemory )
    {
        delete m_pListedFilters;
        delete m_pfndFilterDictionary;
        m_pListedFilters = NULL;
        m_pfndFilterDictionary = NULL;

        pOutOfMemory->Delete();
        *phr = E_OUTOFMEMORY;
        return;
    }
}

CFilterListBox::~CFilterListBox()
{
    IBaseFilter* pCurrentFilter;

    if( NULL != m_pListedFilters )
    {
        while( !m_pListedFilters->IsEmpty() )
        {
            pCurrentFilter = m_pListedFilters->GetHead();
            pCurrentFilter->Release();
            m_pListedFilters->RemoveAt( m_pListedFilters->GetHeadPosition() );
        }
    }

    delete m_pListedFilters;
    delete m_pfndFilterDictionary;
}

HRESULT CFilterListBox::AddFilter( IBaseFilter* pFilter )
{
    // This function assumes pFilter is a valid pointer.
    ASSERT( NULL != pFilter );

    WCHAR szCurrentFilterName[MAX_FILTER_NAME];

    HRESULT hr = m_pfndFilterDictionary->GetFilterName( pFilter, szCurrentFilterName );
    if( FAILED( hr ) )
    {
        return hr;
    }

    #ifdef _UNICODE
    int nNewItemIndex = AddString( szCurrentFilterName );
    #else // multibyte or ANSI.
    TCHAR szMultiByteFilterName[1024];

    // The filter's name must always fit in the szMultiByteFilterName buffer.
    ASSERT( sizeof(szCurrentFilterName) <= sizeof(szMultiByteFilterName) );

    int nNumBytesWritten = ::WideCharToMultiByte( CP_ACP,
                                                  0,
                                                  szCurrentFilterName,
                                                  -1, // WideCharToMultiByte() automatically calculates the 
                                                      // length of fiCurrentFilter.achName if this parameter equals -1.
                                                  szMultiByteFilterName,
                                                  sizeof(szMultiByteFilterName), 
                                                  NULL,
                                                  NULL ); 

    // An error occured if data was written off the end of the buffer.
    ASSERT( nNumBytesWritten <= sizeof(szMultiByteFilterName) );

    // ::WideCharToMultiByte() returns 0 if an error occurs.
    if( 0 == nNumBytesWritten ) {
        DWORD dwLastWin32Error = ::GetLastError();
        return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, dwLastWin32Error );
    }

    int nNewItemIndex = AddString( szMultiByteFilterName );
    #endif // _UNICODE

    if( (LB_ERR == nNewItemIndex) || (LB_ERRSPACE == nNewItemIndex) ) {
        return E_FAIL;
    }

    int nReturnValue = SetItemDataPtr( nNewItemIndex, pFilter );
    if( LB_ERR == nReturnValue )
    {
        nReturnValue = DeleteString( nNewItemIndex );

        // CListBox::DeleteString() only returns LB_ERR if nNewItemIndex is an
        // invalid item index.  See the MFC 4.2 documentation for more information.
        ASSERT( LB_ERR != nReturnValue );
        return E_FAIL;
    }

    try
    {
        m_pListedFilters->AddHead( pFilter );
    }
    catch( CMemoryException* pOutOfMemory )
    {
        nReturnValue = DeleteString( nNewItemIndex );

        // CListBox::DeleteString() only returns LB_ERR if nNewItemIndex is an
        // invalid item index.  See the MFC 4.2 documentation for more information.
        ASSERT( LB_ERR != nReturnValue );

        pOutOfMemory->Delete();
        return E_OUTOFMEMORY;
    }

    pFilter->AddRef();

    return S_OK;
}

HRESULT CFilterListBox::GetSelectedFilter( IBaseFilter** ppSelectedFilter )
{
    return GetSelectedFilter( ppSelectedFilter, NULL );
}

HRESULT CFilterListBox::GetSelectedFilter( IBaseFilter** ppSelectedFilter, int* pnSelectedFilterIndex )
{
    // This function assumes ppSelectedFilter is a valid pointer.
    ASSERT( NULL != ppSelectedFilter );

    *ppSelectedFilter = NULL;

    int nSelectedFilterIndex = GetCurSel();

    // CListBox::GetCurSel() returns LB_ERR if no items are selected.
    if( LB_ERR == nSelectedFilterIndex )
    {
        return E_FAIL; // GE_E_NO_FILTERS_ARE_SELECTED;
    }

    void* pSelectedFilter = GetItemDataPtr( nSelectedFilterIndex );

    // CListBox::GetItemDatePtr() returns LB_ERR if an error occurs.
    if( LB_ERR == (INT_PTR)pSelectedFilter )
    {
        return E_FAIL;
    }

    *ppSelectedFilter = (IBaseFilter*)pSelectedFilter;

    if( NULL != pnSelectedFilterIndex )
    {
        *pnSelectedFilterIndex = nSelectedFilterIndex;
    }

    return S_OK;
}

HRESULT CFilterListBox::RemoveSelectedFilter( void )
{
    int nSelectedFilterIndex;
    IBaseFilter* pSelectedFilter;

    HRESULT hr = GetSelectedFilter( &pSelectedFilter, &nSelectedFilterIndex );
    if( FAILED( hr ) )
    {
        return hr;
    }

    int nReturnValue = DeleteString( nSelectedFilterIndex );
    // CListBox::DeleteString() only returns LB_ERR if nNewItemIndex is an
    // invalid item index.  See the MFC 4.2 documentation for more information.
    ASSERT( LB_ERR != nReturnValue );

    POSITION posSelectedFilter = m_pListedFilters->Find( pSelectedFilter );

    // CList::Find() only returns NULL if it cannot find the filter.
    // It should always find the filter since all filters added to
    // the list box are also added to the m_pListedFilters list.
    // See CFilterListBox::AddFilter() for more information.
    ASSERT( NULL != posSelectedFilter );

    m_pListedFilters->RemoveAt( posSelectedFilter );

    pSelectedFilter->Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\gutil.cpp ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
// util.cpp
//
// Defines utility functions not specific to this application.
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/* NormalizeRect(prc)
 *
 * Swap the left and right edges of <prc>, and the top and bottom edges,
 * as required in order to make <prc->left> be less than <prc->right>
 * and <prc->top> to be less than <prc->bottom>.
 */
void FAR PASCAL
NormalizeRect(CRect *prc)
{
    if (prc->left > prc->right)
        iswap(&prc->left, &prc->right);
    if (prc->top > prc->bottom)
        iswap(&prc->top, &prc->bottom);
}


/* InvertFrame(pdc, prcOuter, prcInner)
 *
 * Invert the color of the pixels in <pdc> that are contained in <*prcOuter>
 * but that are not contained in <*prcInner>.
 */
void FAR PASCAL
InvertFrame(CDC *pdc, CRect *prcOuter, CRect *prcInner)
{
    pdc->PatBlt(prcOuter->left, prcOuter->top,
        prcOuter->Width(), prcInner->top - prcOuter->top, DSTINVERT);
    pdc->PatBlt(prcOuter->left, prcInner->bottom,
        prcOuter->Width(), prcOuter->bottom - prcInner->bottom, DSTINVERT);
    pdc->PatBlt(prcOuter->left, prcInner->top,
        prcInner->left - prcOuter->left, prcInner->Height(), DSTINVERT);
    pdc->PatBlt(prcInner->right, prcInner->top,
        prcOuter->right - prcInner->right, prcInner->Height(), DSTINVERT);
}


//
// --- Quartz Stuff ---
//

//
// CIPin
//


BOOL EqualPins(IPin *pFirst, IPin *pSecond)
{
    /*  Different objects can't have the same interface pointer for
        any interface
    */
    if (pFirst == pSecond) {
        return TRUE;
    }
    /*  OK - do it the hard way - check if they have the same
        IUnknown pointers - a single object can only have one of these
    */
    LPUNKNOWN pUnknown1;     // Retrieve the IUnknown interface
    LPUNKNOWN pUnknown2;     // Retrieve the other IUnknown interface
    HRESULT hr;              // General OLE return code

    ASSERT(pFirst);
    ASSERT(pSecond);

    /* See if the IUnknown pointers match */

    hr = pFirst->QueryInterface(IID_IUnknown,(void **) &pUnknown1);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pUnknown1);

    hr = pSecond->QueryInterface(IID_IUnknown,(void **) &pUnknown2);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pUnknown2);

    /* Release the extra interfaces we hold */

    pUnknown1->Release();
    pUnknown2->Release();
    return (pUnknown1 == pUnknown2);
}

//
// operator ==
//
// Test for equality. Pins are equal if they are on the same filter and have the
// same name. (case insensitive)
BOOL CIPin::operator== (CIPin& pin) {

    return EqualPins((*this), pin);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\link.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
// link.cpp : defines CBoxLinkBend, CBoxLink
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


void CBoxLink::MyDump(CDumpContext& dc) const
{
    dc << TEXT("*** Link ***\n");
    dc << TEXT("   Location:    ") << (void *) this << TEXT("\n");
    dc << TEXT("   Head Socket: ") << (void *) m_psockHead << TEXT("\n");
    dc << TEXT("   Tail Socket: ") << (void *) m_psockTail << TEXT("\n");
}


#endif



//
// CBoxLink::Constructor
//
// set fConnected (default FALSE) to true if constructing a
// link for an already connected pair of sockets.
CBoxLink::CBoxLink(CBoxSocket *psockTail, CBoxSocket *psockHead, BOOL fConnected)
    : m_psockTail(psockTail)
    , m_psockHead(psockHead)
    , m_fConnected(fConnected)
    , m_fSelected(  (psockTail->m_pbox->IsSelected())
                  ||(psockHead->m_pbox->IsSelected()))	// if either box is selected, then so is the link
    , m_pDoc(psockTail->m_pbox->pDoc()) {

    ASSERT(m_psockTail);
    ASSERT(m_psockHead);

    if (fConnected) {
        m_psockTail->m_plink = this;
        m_psockHead->m_plink = this;
    }

    ASSERT(m_pDoc);
	
    ASSERT(m_pDoc == psockHead->m_pbox->pDoc());
}


//
// CBoxLink::Destructor
//
// The link has a head and tail socket. We remove any references
// from the sockets to the link during deletion.
//
CBoxLink::~CBoxLink() {
    HideDialog();

    if (m_psockHead)
        m_psockHead->m_plink = NULL;

    if (m_psockTail)
        m_psockTail->m_plink = NULL;
}


//
// Connect
//
// Ask the filter graph to connect the filters at each end of this link
// Returns S_OK if directly connected
//         S_FALSE if indirectly (intelligently) connected
//         E_XXX in error cases.
HRESULT CBoxLink::Connect() {

    ASSERT_VALID(this);

    HRESULT hr = S_OK;

    if (!m_fConnected) {


	hr = DirectConnect();
	if (SUCCEEDED(hr)) {
	    return S_OK;
	}

        if (m_pDoc->m_fConnectSmart) {
            hr = IntelligentConnect();
            if (SUCCEEDED(hr)) {
                return S_FALSE;
            }
        }
    }

    return hr;	// may have been set to failure code by IntelligentConnect
}


//
// DirectConnect
//
// Connect this link to its sockets. Fail if a direct connection
// is not possible
HRESULT CBoxLink::DirectConnect(void) {

    ASSERT_VALID(this);

    if (!m_fConnected) {

        HRESULT hr;

	hr = m_pDoc->IGraph()->ConnectDirect(m_psockTail->pIPin(),	// i/p
					     m_psockHead->pIPin(),      // o/p
                                             NULL);
        if (FAILED(hr)) {
	    return hr;
	}

        // Even a direct connect can add extra connections from the deferred list.

#ifdef JoergsOldVersion
	m_psockHead->m_pbox->Refresh(); // refresh the box after a connection
	m_psockTail->m_pbox->Refresh(); // refresh the box after a connection

        // make the newly-connected sockets point to the link object
        m_psockTail->m_plink = this;
        m_psockHead->m_plink = this;
#endif
        m_pDoc->UpdateFilters();

        ASSERT(SUCCEEDED(hr));
	m_fConnected = TRUE;
    }

    return NOERROR;
}


//
// IntelligentConnect
//
// Ask the filter graph to connect the filters at each end of
// this link, using 'Intelligent connection'. If this suceeds you
// should delete this link, as the doc has had anything it needs added to it.
HRESULT CBoxLink::IntelligentConnect(void) {

    ASSERT_VALID(this);

    if (!m_fConnected) {

        TRACE("Trying intelligent connect\n");

        HRESULT hr = m_pDoc->IGraph()->Connect(m_psockTail->pIPin(),		// i/p
  				       m_psockHead->pIPin());
        if (FAILED(hr)) {
	    m_fConnected = FALSE;
	    TRACE("Error Connecting Filters\n");
	    return hr;
	}

        ASSERT(SUCCEEDED(hr));
	m_fConnected = FALSE;	// we have connected this link, but
				// it is about to be replaced by the stuff
				// the filtergraph added, so it is now 'hanging'

	m_pDoc->UpdateFilters();
    }

    return S_OK;
}


//
// Disconnect
//
// Ask the filter graph to disconnect the filters at each end of this link
//
// Only refreshes the boxes if fRefresh is TRUE.
//
HRESULT CBoxLink::Disconnect(BOOL fRefresh)
{

    ASSERT_VALID(this);

    HRESULT hr;

    //
    // m_psockHead & m_psockTail are both NULL or both non-NULL.
    //
    if (NULL == m_psockTail) {
        ASSERT(!m_psockHead);
        return(S_OK);
    }
    ASSERT(m_psockHead);

    hr = m_pDoc->IGraph()->Disconnect(m_psockTail->pIPin());
    ASSERT(SUCCEEDED(hr));

    hr = m_pDoc->IGraph()->Disconnect(m_psockHead->pIPin());
    ASSERT(SUCCEEDED(hr));

    m_psockHead->m_plink = NULL;
    m_psockTail->m_plink = NULL;

    if (fRefresh) {
        m_psockHead->m_pbox->Refresh(); // refresh the sockets after disconnect
        m_psockTail->m_pbox->Refresh(); // refresh the sockets after disconnect
    }

    m_psockHead = NULL;
    m_psockTail = NULL;

    m_fConnected = FALSE;

    return NOERROR;
}


#ifdef _DEBUG
void CBoxLink::AssertValid(void) const {

    CPropObject::AssertValid();

    ASSERT(m_pDoc);
    ASSERT(m_psockTail);
    ASSERT(m_psockHead);

    if (m_fConnected) {
        ASSERT(m_psockHead->m_plink == this);
	ASSERT(m_psockTail->m_plink == this);
    }
    else {
        ASSERT(m_psockHead->m_plink == NULL);
	ASSERT(m_psockTail->m_plink == NULL);
    }
}
#endif // _DEBUG

#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\link.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
// link.h : declares CBoxLink
//

// forward declaration
class CBoxNetDoc;

/////////////////////////////////////////////////////////////////////////////
// CBoxLink -- defines a link between two box sockets

class CBoxLink : public CPropObject {

public:
    // pointers to the box sockets that this link connects
    CBoxSocket     *m_psockHead;        // head end of the link
    CBoxSocket     *m_psockTail;        // tail end of the link
    CBoxNetDoc 	   *m_pDoc;		// The document we belong to

public:
    // CBoxLink user interface

    void	    SetSelected(BOOL fSelected) { m_fSelected = fSelected; }
    BOOL	    IsSelected(void) { return m_fSelected; }

public:
    // CPropObject Overrides

    // As I always have an IPin I can always display properties
    virtual BOOL CanDisplayProperties(void) { return TRUE; }

    virtual CString Label(void) const { return CString("Link"); }

    // return Iunknown from one of our pins. it doesnt matter which.
    virtual IUnknown *pUnknown(void) const { ASSERT(m_psockHead); return m_psockHead->pUnknown(); }

private:

    BOOL	m_fSelected;	// Is this link selected?

    // construction and destruction
public:
    CBoxLink(CBoxSocket *psockTail, CBoxSocket *psockHead, BOOL fConnected = FALSE);
    ~CBoxLink();

public:

    #ifdef _DEBUG

    // diagnostics
    void Dump(CDumpContext& dc) const {
        CPropObject::Dump(dc);
    }
    void MyDump(CDumpContext& dc) const;

    virtual void AssertValid(void) const;

    #endif  _DEBUG

public:

    // -- Quartz --

    HRESULT Connect(void);
    HRESULT IntelligentConnect(void);
    HRESULT DirectConnect(void);
    HRESULT Disconnect(BOOL fRefresh = TRUE);

    BOOL    m_fConnected;
};


// *
// * CLinkList
// *
// A list of CBoxLinks
class CLinkList : public CDeleteList<CBoxLink *, CBoxLink *> {

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\graphedt.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// graphedt.h : declares CGraphEdit
//

/////////////////////////////////////////////////////////////////////////////
// CGraphEdit
//


class CGraphEdit : public CWinApp
{

public:
    // construction, initialization, termination
    CGraphEdit();
    virtual BOOL InitInstance();
    virtual int ExitInstance();


protected:
    // message callback functions
    //{{AFX_MSG(CGraphEdit)
    afx_msg void OnAppAbout();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// application-global macros

// GBL(x) accesses member <x> of the global CGraphEdit
#define GBL(x) (((CGraphEdit *) AfxGetApp())->x)

// MFGBL(x) accesses member <x> of the global CMainFrame
#define MFGBL(x) (((CMainFrame *) GBL(m_pMainWnd))->x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\gstats.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//
// Dialog to display all filters
//

#include "stdafx.h"
#include "gstats.h"

BEGIN_MESSAGE_MAP(CGraphStats, CDialog)
    ON_WM_SIZE()
    ON_WM_GETMINMAXINFO()
    ON_COMMAND(IDC_REFRESH, RedoList)
    ON_COMMAND(IDC_RESET, ResetStats)
END_MESSAGE_MAP()

CGraphStats* CGraphStats::m_pThis = 0;
//
// Constructor
//
CGraphStats::CGraphStats(
    CBoxNetDoc * pBoxNet,
    CWnd * pParent)

 : 
   m_pBoxNet(pBoxNet)
 , m_bHadInitDialog( FALSE )
{
    //
    // There can only be one filter view dialog at a time. Thus
    // the initialisation in the constructor is ok (even desired).
    //
    ASSERT( m_pThis == 0 );
    m_pThis = this;
    Create(IDD_STATS, pParent);
    ShowWindow( SW_SHOW );
}

CGraphStats::~CGraphStats()
{
    // Windows will automatically delete m_hImgList when the dialog
    // box is destroyed.
    m_pThis = 0;
}

CGraphStats * CGraphStats::GetGraphStats(
    CBoxNetDoc * pBoxNet,
    CWnd * pParent)
{
    if (!m_pThis) 
    {
        m_pThis = new CGraphStats(pBoxNet, pParent);
    }
    else
    {
        m_pThis->RedoList();
        m_pThis->ShowWindow( SW_RESTORE );
    }
    return m_pThis;

}

void CGraphStats::DelGraphStats()
{
    if (m_pThis)
    {
        delete m_pThis;
        m_pThis = 0;
    }
}

BOOL CGraphStats::OnInitDialog()
{
    BOOL fResult = CDialog::OnInitDialog();

    RedoList();

    return( fResult );
}


void CGraphStats::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);    

    //{{AFX_DATA_MAP(CGraphStats)
        DDX_Control(pDX, IDC_LIST1, m_ListBox);
    //}}AFX_DATA_MAP
}


void CGraphStats::RedoList()
{
    IAMStats *pStats;

    if (FAILED(m_pBoxNet->IGraph()->QueryInterface(IID_IAMStats, (void **) &pStats)))
        return;

    m_ListBox.ResetContent();

    int tabs[] = {250, 300, 350, 400, 450, 500 };

    m_ListBox.SetTabStops(sizeof(tabs) / sizeof(tabs[0]), tabs);

    m_ListBox.AddString("Statistic\t   Count\t   Last\t   Average\t   StdDev\t   Min\t   Max");
    m_ListBox.AddString("---------\t   -----\t   ----\t   -------\t   ------\t   ---\t   ---");
    LONG lStats;
    if (SUCCEEDED(pStats->get_Count(&lStats))) {
        for (long lIndex = 0; lIndex < lStats; lIndex++) {
            BSTR szName;
            long lCount;
            double dLast;
            double dAverage;
            double dStdDev;
            double dMin;
            double dMax;

            if (FAILED(pStats->GetValueByIndex(lIndex, &szName, &lCount, &dLast,
                                               &dAverage, &dStdDev, &dMin, &dMax)))
                break;


            char achTemp[256];
#define FRAC(d)  ((int) (1000 * (d - (int) d)))
            wsprintf(achTemp, "%ls\t%5d\t%5d.%03d\t%5d.%03d\t%5d.%03d\t%5d.%03d\t%5d.%03d",
                     szName, lCount, (int) dLast, FRAC(dLast), (int) dAverage, FRAC(dAverage),
                     (int) dStdDev, FRAC(dStdDev), (int) dMin, FRAC(dMin), (int) dMax, FRAC(dMax));
            m_ListBox.AddString(achTemp);

            SysFreeString(szName);
        }
    }
    
    pStats->Release();
}

void CGraphStats::ResetStats()
{
    IAMStats *pStats;

    if (FAILED(m_pBoxNet->IGraph()->QueryInterface(IID_IAMStats, (void **) &pStats)))
        return;

    pStats->Reset();
    pStats->Release();

    RedoList();
}

void CGraphStats::OnSize( UINT nType, int cx, int cy )
{
    if( SIZE_RESTORED == nType ){
        if( m_bHadInitDialog ){
        }
    }
}

void CGraphStats::OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI )
{
    if( m_bHadInitDialog ) {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\gstats.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
class CGraphStats : public CDialog
{
public:
    static void DelGraphStats();
    static CGraphStats * GetGraphStats(
        CBoxNetDoc * pBoxNet,
        CWnd * pParent = NULL );

protected:
    ~CGraphStats();
    CGraphStats(
        CBoxNetDoc * pBoxNet,
        CWnd * pParent = NULL );


    afx_msg void OnSize( UINT nType, int cx, int cy );
    afx_msg void OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI );

    BOOL OnInitDialog();
    void RedoList();
    void ResetStats();

    CBoxNetDoc * m_pBoxNet;

    static CGraphStats * m_pThis;

    void DoDataExchange(CDataExchange* pDX);
    CListBox m_ListBox;

    BOOL m_bHadInitDialog;         // Received OnInitDialog message?

    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\propobj.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
//
// propobj.cpp
//

// Implementation of CPropObject. See propobj.h


#include "stdafx.h"

// *
// * CPropObject
// *

IMPLEMENT_DYNAMIC(CPropObject, CObject)

//
// Constructor
//
CPropObject::CPropObject()
    : m_pDlg(NULL) {
}


//
// Destructor
//
CPropObject::~CPropObject() {

    DestroyPropertyDialog();

}


#ifdef _DEBUG
//
// AssertValid
//
void CPropObject::AssertValid(void) const {

    CObject::AssertValid();

}

//
// Dump
//
// Output this object to the supplied dump context
void CPropObject::Dump(CDumpContext& dc) const {

    CObject::Dump(dc);

    if (m_pDlg != NULL) {
        dc << CString("Dialog exists");
    }
    else {
        dc << CString("No dialog exists");
    }
}
#endif // _DEBUG


//
// CanDisplayProperties
//
// returns true if this object has at least one of IPin,
// IFileSourceFilter, ISpecifyPropertyPages, and IFileSinkFilter
//
// !!! this function tends to throw a lot of exceptions. I think using
// CQCOMInt may be inapropriate, or perhaps needs a 'do you support
// this?' function.
BOOL CPropObject::CanDisplayProperties(void) {

    try {

        CQCOMInt<ISpecifyPropertyPages> Interface(IID_ISpecifyPropertyPages, pUnknown());
	return TRUE;
    }
    catch (CHRESULTException) {
        // probably E_NOINTERFACE. Eat it and try the next...
    }

    // we can display a page for each filters pin
    try {

        CQCOMInt<IBaseFilter> IFilt(IID_IBaseFilter, pUnknown());
        CPinEnum Next(IFilt);

        IPin *pPin;
	if (0 != (pPin = Next())) { // at least one pin
	    pPin->Release();
	    return TRUE;
	}
    }
    catch (CHRESULTException) {
        // probably E_NOINTERFACE. Eat it and try the next...
    }

    try {

        CQCOMInt<IFileSourceFilter> Interface(IID_IFileSourceFilter, pUnknown());
	return TRUE;
    }
    catch (CHRESULTException) {
        // probably E_NOINTERFACE. Eat it and try the next...
    }

    try {

        CQCOMInt<IFileSourceFilter> Interface(IID_IFileSinkFilter, pUnknown());
	return TRUE;
    }
    catch (CHRESULTException) {
        // probably E_NOINTERFACE. Eat it and try the next...
    }

    try {

        CQCOMInt<IPin> Interface(IID_IPin, pUnknown());
	return TRUE;
    }
    catch (CHRESULTException) {
        // probably E_NOINTERFACE. Eat it and try the next...
    }

    return FALSE;
}


//
// CreatePropertyDialog
//
// create & display the property dialog
// if called when the dialog exists, it shows the existing dialog
void CPropObject::CreatePropertyDialog(CWnd *pParent) {

    try {

        if (m_pDlg->GetSafeHwnd() == NULL) {

            CString szCaption = Label();
	    szCaption += CString(" Properties");

            delete m_pDlg;
            m_pDlg = new CVfWPropertySheet(pUnknown(), szCaption, pParent);

        }

    }
    catch (CHRESULTException) {

        AfxMessageBox(IDS_CANTDISPLAYPROPERTIES);
    }

    ShowDialog();

}


//
// DestroyPropertyDialog
//
// hide and destroy the property dialog
// Nul-op if the dialog does not exist
void CPropObject::DestroyPropertyDialog(void) {

    if (m_pDlg->GetSafeHwnd() != NULL) {
        m_pDlg->DestroyWindow();
    }

    delete m_pDlg;
    m_pDlg = NULL;
}


//
// ShowDialog
//
// show the dialog in screen. nul-op if already on screen
void CPropObject::ShowDialog(void) {

    if (m_pDlg->GetSafeHwnd() != NULL) {

        m_pDlg->ShowWindow(SW_SHOW);
	m_pDlg->SetForegroundWindow();
    }
}


//
// HideDialog
//
// hide the dialog. nul-op if already hidden
void CPropObject::HideDialog(void) {

    if (m_pDlg->GetSafeHwnd() != NULL) {

        m_pDlg->ShowWindow(SW_HIDE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\grftmpl.cpp ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// CGraphDocTemplate
//

#include "stdafx.h"

// A CSingleDocTemplate derived class that provides the custom
// behaviour required for renderfile.


//
// OpenDocumentFile
//
// A direct Cut & Paste of CSingleDocTemplate::OpenDocumentFile
// with the ability (by removing #ifdef _MAC) to set the
// modified flag to keep an untitled document. ie I want the
// same behaviour for RenderFile as a mac Stationery pad
CDocument *CGraphDocTemplate::OpenDocumentFile( LPCTSTR lpszPathName
                                              , BOOL bMakeVisible) {

    // if lpszPathName == NULL => create new file of this type
    CDocument *pDocument    = NULL;
    CFrameWnd *pFrame       = NULL;
    BOOL       bCreated     = FALSE;      // => doc and frame created
    BOOL       bWasModified = FALSE;

    if (m_pOnlyDoc != NULL) {
	
	// already have a document - reinit it
	pDocument = m_pOnlyDoc;
	if (!pDocument->SaveModified()) {
	    return NULL;        // leave the original one
	}

	pFrame = (CFrameWnd*)AfxGetMainWnd();
	ASSERT(pFrame != NULL);
	ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CFrameWnd)));
	ASSERT_VALID(pFrame);
    }
    else {
        // create a new document
        pDocument = CreateNewDocument();
        ASSERT(pFrame == NULL);     // will be created below
        bCreated = TRUE;
    }

    if (pDocument == NULL) {

        AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC);
        return NULL;
    }
    ASSERT(pDocument == m_pOnlyDoc);

    if (pFrame == NULL) {

        ASSERT(bCreated);

	// create frame - set as main document frame
	BOOL bAutoDelete = pDocument->m_bAutoDelete;
	pDocument->m_bAutoDelete = FALSE;
					// don't destroy if something goes wrong
	pFrame = CreateNewFrame(pDocument, NULL);
	pDocument->m_bAutoDelete = bAutoDelete;
	if (pFrame == NULL) {
			
	    AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC);
	    delete pDocument;       // explicit delete on error
	    return NULL;
	}
    }

    // all docs have the default title. this will be overriden if a real graph is opened.
    SetDefaultTitle(pDocument);

    if (lpszPathName == NULL) {
		
        // create a new document

        // avoid creating temporary compound file when starting up invisible
        if (!bMakeVisible) {
            pDocument->m_bEmbedded = TRUE;
	}

	if (!pDocument->OnNewDocument()) {

	    // user has been alerted to what failed in OnNewDocument
	    TRACE0("CDocument::OnNewDocument returned FALSE.\n");
	    if (bCreated) {
	        pFrame->DestroyWindow();    // will destroy document
	    }
	    return NULL;
	}
    }
    else {

	BeginWaitCursor();

	// open an existing document
	bWasModified = pDocument->IsModified();
	pDocument->SetModifiedFlag(FALSE);  // not dirty for open

	if (!pDocument->OnOpenDocument(lpszPathName)) {

	    // user has been alerted to what failed in OnOpenDocument
	    TRACE0("CDocument::OnOpenDocument returned FALSE.\n");
	    if (bCreated) {
	        pFrame->DestroyWindow();    // will destroy document
	    }
	    else if (!pDocument->IsModified()) {
		
	        // original document is untouched
	        pDocument->SetModifiedFlag(bWasModified);
	    }
	    else {
		
	        // we corrupted the original document
	        SetDefaultTitle(pDocument);

	        if (!pDocument->OnNewDocument()) {
			
	            TRACE0("Error: OnNewDocument failed after trying to open a document - trying to continue.\n");
		    // assume we can continue
		}
            }
		
	    EndWaitCursor();
	    return NULL;        // open failed
        }

	// if the document is dirty, we must have called RenderFile - don't
	// change the pathname because we want to treat the document as untitled
	if (!pDocument->IsModified()) {
	    pDocument->SetPathName(lpszPathName);
	}

	EndWaitCursor();
    }

    if (bCreated && AfxGetMainWnd() == NULL) {

        // set as main frame (InitialUpdateFrame will show the window)
        AfxGetThread()->m_pMainWnd = pFrame;
    }
    InitialUpdateFrame(pFrame, pDocument, bMakeVisible);

    return pDocument;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\gutil.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// gutil.h
//
// Defines utility functions not specific to this application.
//

/////////////////////////////////////////////////////////////////////////////
// Utility integer and boolean functions:
//
// imin(i, j) returns the minimum of i and j.
// imax(i, j) returns the maximum of i and j.
// iabs(i) returns the absolute value of i.
// ibound(i, iLower, iUpper) returns i restricted to the range [iLower,iUpper].
// ioutbound(i, iLower, iUpper) returns 0 if i is in the range [iLower,iUpper],
//      or the amount by which i is outside that range otherwise.
// isnap(i, iGrid) returns multiple of iGrid nearest to i
// iswap(pi, pj) swaps <*pi> with <*pj>
// fnorm(f) "normalizes" BOOL value f, i.e. turns nonzero values into 1.
//

inline int imin(int i1 , int i2)
{
    if (i1 < i2)
        return i1;
    else
        return i2;
}

inline int imax(int i1 , int i2)
{
    if (i1 > i2)
        return i1;
    else
        return i2;
}

inline int iabs(int i)
{
    if (i < 0)
        return -i;
    else
        return i;
}

inline int ibound(int i, int iLower, int iUpper)
{
    if (i < iLower)
        i = iLower;
    else
    if (i > iUpper)
        i = iUpper;

    return i;
}

inline int ioutbound(int i, int iLower, int iUpper)
{
    if (i < iLower)
        return iLower - i;
    else
    if (i > iUpper)
        return i - iUpper;
    else
        return 0;
}

inline int isnap(int i, int iGrid)
{
    BOOL fNeg = (i < 0);                    // "%" isn't reliable for i < 0
    int j = (fNeg ? -i : i) + iGrid / 2;    // add half of <iGrid>
    int k = j - j % iGrid;                  // round down
    return (fNeg ? -k : k);
}

inline void iswap(long *pi, long *pj)
{
    long        iTmp;

    iTmp = *pi;
    *pi = *pj;
    *pj = iTmp;
}

inline BOOL fnorm(BOOL f)
{
    if (f)
        return 1;
    else
        return 0;
}


/////////////////////////////////////////////////////////////////////////////
// other utility functions
//


CSize inline PASCAL NegateSize(CSize siz)
{
    return CSize(-siz.cx, -siz.cy);
}


void FAR PASCAL NormalizeRect(CRect *prc);
void FAR PASCAL InvertFrame(CDC *pdc, CRect *prcOuter, CRect *prcInner);


//
// CDeleteList
//
// A CList that will optionally delete the objects it is
// storing in its destructor. Construct with parameter TRUE (the default)
// if you want objects deleted, use FALSE otherwise.
// Also provides a member to do delete & remove each item on the list
template<class TYPE, class ARG_TYPE>
class CDeleteList : public CList<TYPE, ARG_TYPE> {

public:

    CDeleteList(BOOL DestructDelete = TRUE) : m_DestructDelete(DestructDelete) {}
    CDeleteList(BOOL DestructDelete, int nBlockSize) : CList<TYPE, ARG_TYPE>(nBlockSize),
                                                       m_DestructDelete(DestructDelete) {}


    ~CDeleteList() {

        if (m_DestructDelete) {
            FreeAll();
        }
    }

    void DeleteRemoveAll(void) {  FreeAll(); }

protected:

    BOOL m_DestructDelete;

    void FreeAll(void) {

        while(GetCount() > 0) {
            delete RemoveHead();
        }
    }
};


//
// CFreeList
//
// A CObject version of a CDeleteList. Deletes its stored objects
// on destruction
class CFreeList : public CDeleteList<CObject *, CObject *> {

};


//
// CMaxList
//
// A CFreeList that is restricted to at most m_cObjMax objects.
// It deletes any surplus _at the next call_ that adds something.
// therefore the list can be temporarily longer.
class CMaxList : public CFreeList {
public:

    CMaxList(int nBlockSize = 3) : m_cObjMax(nBlockSize) {}

    POSITION AddHead(CObject* pobj) {
        RestrictLength();
        return CFreeList::AddHead(pobj);
    }

    POSITION AddTail(CObject* pobj) {
        RestrictLength();
        return CFreeList::AddTail(pobj);
    }

    void AddHead(CObList* pNewList) {
        RestrictLength();
        CFreeList::AddHead(pNewList);
    }

    void AddTail(CObList* pNewList) {
        RestrictLength();
        CFreeList::AddTail(pNewList);
    }

    POSITION InsertBefore(POSITION pos, CObject* pobj) {
        RestrictLength();
        return CFreeList::InsertBefore(pos, pobj);
    }

    POSITION InsertAfter(POSITION pos, CObject* pobj) {
        RestrictLength();
        return CFreeList::InsertAfter(pos, pobj);
    }

private:

    const int   m_cObjMax;      // max. number of objects in list

    void RestrictLength(void) {

        while (GetCount() >= m_cObjMax) {

            TRACE(TEXT("restrict length\n"));
            delete RemoveTail();
        }
    }

};


//
// --- Quartz Utilities ---
//
typedef HRESULT STDAPICALLTYPE OLECOCREATEPROC(REFCLSID,LPUNKNOWN,DWORD,REFIID,LPVOID *);

//
// CQCOMInt
//
// CCOMInt style class that uses the _real_, UNICODE, version of CoCreateInstance
// so that I can hack around MFCANS32 (wonderful tool that it is)
template<class I>
class CQCOMInt {

public:

    // -- Constructors --

    // CoCreate
    CQCOMInt<I>( REFIID    riid					// get this interface
               , REFCLSID  rclsid				// get the interface
    								// from this object
	       , LPUNKNOWN pUnkOuter    = NULL			// controlling unknown
               , DWORD     dwClsContext = CLSCTX_INPROC_SERVER	// CoCreate options
               							// default is suitable
               							// for dll servers
               ) {

        //
        // Library will be FreeLibrary'ed in the destructor. We don't unload
        // before to avoid unnecessary load / unloads of the library.
        //
	m_hLibrary = LoadLibrary("OLE32.dll");

	OLECOCREATEPROC *CoCreate = (OLECOCREATEPROC *) GetProcAddress(m_hLibrary, "CoCreateInstance");

        HRESULT hr = CoCreate( rclsid
	                     , pUnkOuter
                             , dwClsContext
                             , riid
                             , (void **) &m_pInt
                             );
        if (FAILED(hr)) {
            throw CHRESULTException(hr);
        }
    }

    // QueryInterface
    CQCOMInt<I>( REFIID   riid	// get this interface
              , IUnknown *punk	// from this interface
              ) {
	m_hLibrary = 0;
        HRESULT hr = punk->QueryInterface(riid, (void **) &m_pInt);
        if (FAILED(hr)) {
            throw CHRESULTException(hr);
        }
    }

    // copy
    CQCOMInt<I>(const CQCOMInt<I> &com) {
	m_hLibrary = 0;
         m_pInt = com;
         (*this)->AddRef();

    }

    // existing pointer.
    CQCOMInt<I>(I *pInt) {
	m_hLibrary = 0;
        if (pInt == NULL) {
            throw CHRESULTException(E_NOINTERFACE);
        }

        m_pInt = pInt;

	(*this)->AddRef();
    }


    // assignment operator
    virtual CQCOMInt<I>& operator = (const CQCOMInt<I> &com) {

        if (this != &com) { 	// not i = i

	    (*this)->Release();
            m_pInt = com;
            (*this)->AddRef();
	}

        return *this;
    }


    // destructor
    virtual ~CQCOMInt<I>() {
        m_pInt->Release();

	if (m_hLibrary)
            FreeLibrary(m_hLibrary);
    }


    // -- comparison operators --
    virtual BOOL operator == (IUnknown *punk) const {

        CQCOMInt<IUnknown> IUnk1(IID_IUnknown, punk);
        CQCOMInt<IUnknown> IUnk2(IID_IUnknown, *this);

        return ( ((IUnknown *)IUnk1) == ((IUnknown *)IUnk2) );
    }

    virtual BOOL operator != (IUnknown *punk) const {

        return !(*this == punk);
    }


    // cast to interface pointer
    virtual operator I *() const { return m_pInt; }


    // dereference
    virtual I *operator->() { return m_pInt; }

    virtual I &operator*() { return *m_pInt; }

private:

    I *m_pInt;

    HINSTANCE m_hLibrary;    // remember the handle to the library for FreeLibrary

    // array dereferencing seems to make no sense.
    I &operator[] (int i) { throw CHRESULTException(); return *m_pInt; }
};


//
// CIPin
//
// Wrapper for the IPin interface
class CIPin : public CQCOMInt<IPin> {

public:

    CIPin(IPin *pIPin) : CQCOMInt<IPin>(pIPin) {}
    virtual ~CIPin() {}

    BOOL  operator == (CIPin& pin);	// tests the names to be equal.
    BOOL  operator != (CIPin& pin) { return !(pin == *this); }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\graphedt.cpp ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
// boxnet.cpp : defines CAboutDlg, CGraphEdit
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//
// the one and only CGraphEdit object
//
CGraphEdit theApp;

//
// CAboutDlg dialog used for App About
//
class CAboutDlg : public CDialog {

public:
    // construction
    CAboutDlg();
    virtual BOOL OnInitDialog();
};

//
// Constructor
//
CAboutDlg::CAboutDlg() : CDialog(IDD_ABOUTBOX)
{}

//
// OnInitDialog
//
// Obtains the version information from the binary file. Note that if
// we fail we just return. The template for the about dialog has a
// "Version not available" as default.
//
BOOL CAboutDlg::OnInitDialog()
{
    //
    // first call base method so we can return on errors
    //
    BOOL Result = CDialog::OnInitDialog();

    //
    // Find the version of this binary
    //
    TCHAR achFileName[128];
    if ( !GetModuleFileName(AfxGetInstanceHandle() , achFileName, sizeof(achFileName)) )
        return(Result);

    DWORD dwTemp;
    DWORD dwVerSize = GetFileVersionInfoSize( achFileName, &dwTemp );
    if ( !dwVerSize)
        return(Result);

    HLOCAL hTemp = LocalAlloc( LHND, dwVerSize );
    if (!hTemp)
        return(Result);

    LPVOID lpvVerBuffer = LocalLock( hTemp );
    if (!lpvVerBuffer) {
        LocalFree( hTemp );
        return(Result);
    }

    if ( !GetFileVersionInfo( achFileName, 0L, dwVerSize, lpvVerBuffer ) ) {
        LocalUnlock( hTemp );
        LocalFree( hTemp );
        return( Result );
    }

    // "040904E4" is the code page for US English (Andrew believes).
    LPVOID lpvValue;
    UINT uLen;
    if (VerQueryValue( lpvVerBuffer,
                   TEXT("\\StringFileInfo\\040904E4\\ProductVersion"),
                   (LPVOID *) &lpvValue, &uLen)) {

        //
        // Get creation date of executable (date of build)
        //
        CFileStatus fsFileStatus;
        if (CFile::GetStatus( achFileName, fsFileStatus)) {
            // put build date into string in YYMMDD format
            char szBuildDate[20];
            CTime * pTime = &fsFileStatus.m_mtime;

            sprintf(szBuildDate, " - Build: %2.2u%2.2u%2.2u",
                    pTime->GetYear() % 100, pTime->GetMonth(), pTime->GetDay());
                    strcat((LPSTR) lpvValue, szBuildDate);
        }

        SetDlgItemText(IDS_VERSION, (LPSTR)lpvValue);
    }

    LocalUnlock(hTemp);
    LocalFree(hTemp);

    return(Result);
}

// *
// * CGraphEdit
// *

//
// Constructor
//
CGraphEdit::CGraphEdit()
{
    // place all significant initialization in InitInstance
}


//
// InitInstance
//
BOOL CGraphEdit::InitInstance() {
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

    SetDialogBkColor();        // set dialog background color to gray
    LoadStdProfileSettings(8);  // Load standard INI file options (including MRU)

    // get MFCANS32 to wrap the Quartz interfaces also
    //HRESULT hr = Ole2AnsiSetFlags(  OLE2ANSI_WRAPCUSTOM
    //                              | OLE2ANSI_AGGREGATION
    //                             , NULL);
    //if (FAILED(hr)) {
    //    return FALSE;
    //}

    // Initialize OLE 2.0 libraries
    if (!AfxOleInit()) {
        return FALSE;
    }
	
    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    AddDocTemplate(new CGraphDocTemplate( IDR_GRAPH
                                        , RUNTIME_CLASS(CBoxNetDoc)
		                        , RUNTIME_CLASS(CMainFrame)
		                        , RUNTIME_CLASS(CBoxNetView)
		                        )
		  );

    // enable file manager drag/drop and DDE Execute open
    EnableShellOpen();
    RegisterShellFileTypes();

    // initialize box drawing code
    try {
        gpboxdraw = new CBoxDraw;
        gpboxdraw->Init();
    }
    catch(CException *e) {
        delete gpboxdraw, gpboxdraw = NULL;
 	    e->Delete();
	    return FALSE;
    }

    // simple command line parsing
    if (m_lpCmdLine[0] == '\0') {
	    // create a new (empty) document
	    OnFileNew();
    }
    else {
        //
        // command line string always seems to have a ' ' in front
        // parse over it and go back afterwards
        //

        UINT iBackup = 0;
        while ((*m_lpCmdLine) == TEXT(' ')) {
            m_lpCmdLine++;
            iBackup++;
        }

        if (   (m_lpCmdLine[0] == TEXT('-') || m_lpCmdLine[0] == TEXT('/'))
             && (m_lpCmdLine[1] == TEXT('e') || m_lpCmdLine[1] == TEXT('E'))
            ) {
        	// program launched embedded - wait for DDE or OLE open
        }
        else {
    	    // open an existing document
            OpenDocumentFile(m_lpCmdLine);
        }

        // reset pointer to command line string
        m_lpCmdLine -= iBackup;
    }

    return TRUE;
}



//
// ExitInstance
//
int CGraphEdit::ExitInstance() {

    if (gpboxdraw != NULL) {
        delete gpboxdraw, gpboxdraw = NULL;
    }
    AfxOleTerm();
	
    return CWinApp::ExitInstance();
}


//
// CGraphEdit generated message map
//
BEGIN_MESSAGE_MAP(CGraphEdit, CWinApp)
	//{{AFX_MSG_MAP(CGraphEdit)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()


//
// CGraphEdit callback functions
//

//
// OnAppAbout
//
// Display the modal about dialog
void CGraphEdit::OnAppAbout() {

    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\propobj.h ===
// Copyright (c) 1995  Microsoft Corporation.  All Rights Reserved.
//
// propobj.h
//

class CVfWPropertySheet;

//
// CPropObject
//
// A CObject derived class for objects that can display
// property page dialogs. classes such as CBoxLink, CBox &
// CBoxSocket are derived from this.
class CPropObject : public CObject {
protected:

    CPropObject();
    virtual ~CPropObject();

public:

#ifdef _DEBUG
    // -- CObject Derived diagnostics --
    virtual void AssertValid(void) const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    // -- Property Dialog support --

    // true if a property dialog can be created for display
    virtual BOOL CanDisplayProperties(void);

    // create & display the property dialog
    // if called when the dialog exists, it shows the existing dialog
    // if pParent is null then the apps main window is the parent
    virtual void CreatePropertyDialog(CWnd *pParent = NULL);

    // hide and destroy the property dialog
    // Nul-op if the dialog does not exist
    virtual void DestroyPropertyDialog(void);

    // show the dialog in screen. nul-op if already on screen
    virtual void ShowDialog(void);

    // hide the dialog. nul-op if already hidden
    virtual void HideDialog(void);

public:
    // -- required helper functions --
    // these should be defined in a superclass, but they are not...

    virtual CString Label(void) const = 0;
    virtual IUnknown *pUnknown(void) const = 0;

    DECLARE_DYNAMIC(CPropObject)

private:

    CVfWPropertySheet *m_pDlg;	// the property sheet for all property pages
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\grftmpl.h ===
// Copyright (c) 1995  Microsoft Corporation.  All Rights Reserved.
//
// CGraphDocTemplate
//

// A CSingleDocTemplate derived class that provides the custom
// behaviour required for renderfile.

class CGraphDocTemplate : public CSingleDocTemplate {

public:

    CGraphDocTemplate( UINT nIDResource
                     , CRuntimeClass* pDocClass
                     , CRuntimeClass* pFrameClass
                     , CRuntimeClass* pViewClass)
	: CSingleDocTemplate(nIDResource, pDocClass, pFrameClass, pViewClass) {}

    ~CGraphDocTemplate() {}

    virtual CDocument* OpenDocumentFile( LPCTSTR lpszPathName
                                       , BOOL bMakeVisible = TRUE);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\propsht.h ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
#ifndef _PROPSHT_H_
#define _PROPSHT_H_

//
// CVfWPropertySheet
//
// Modification of CPropertySheet to allow for OK, Cancel, Apply and Help
// buttons for modeless property sheets.
//
class CPropertySite;

class CVfWPropertySheet : public CPropertySheet {

public:
    // Pass IUnknown of the object we want the property sheet for.
    // CString holds the title of the property sheet and
    // CWnd indicates the parent window (NULL = the application window).
    CVfWPropertySheet(IUnknown *, CString, CWnd * = NULL);
    virtual ~CVfWPropertySheet();

    // CPropertySheet methods
    INT_PTR DoModal() { ASSERT(!TEXT("No modal mode supported")); return 0; }

    // CVfWPropertySheet methods
    void UpdateButtons(HRESULT hrIsDirty, BOOL fSupportHelp);

protected:

    // OK, Cancel, Apply and Help buttons
    CButton *m_butOK;
    CButton *m_butCancel;
    CButton *m_butApply;
    CButton *m_butHelp;

    // Flags on the state of all property pages.
    BOOL m_fAnyChanges;      // TRUE = some property page is dirty

    // Message handlers for the buttons
    void OnOK();
    void OnCancel();
    void OnApply();
    void OnHelp();

    // Helper methods to obtain property pages from IUnknown passed in
    // constructor.
    UINT AddSpecificPages(IUnknown *);
    UINT AddFilePage(IUnknown *);
    UINT AddPinPages(IUnknown *);

    // Return the active site
    CPropertySite * GetActiveSite() {
        return((CPropertySite *) GetActivePage());
    }

    // Free all memory of buttons and property sites.
    void Cleanup();

    // Add our own buttons
    afx_msg int OnCreate(LPCREATESTRUCT);
    afx_msg void OnDestroy();

    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fButtonsCreated;    // flag to indicate whether we can enable/disable
                               // the buttons yet.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\propsite.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
#ifndef _PROPSITE_H_
#define _PROPSITE_H_

//
// CPropertySite
//
// This class implements the individual property sites for each
// IPropertyPage we have got. Ie. it manages the OLE control property page
// object for the overall property pages frame.
//
// The IPropertyPage talks through this class' IPropertySite interface
// to the PropertySheet, the overall frame of all property pages.
//
// The base class of CPropertySite is CPropertyPage. This class is a
// MFC class and should not be confused with the IPropertyPage interface.
//
//      IPropertyPage = Interface of some objects whose property page we
//                      want to display.
//
//      CPropertyPage = MFC class which helps us to implement the wrapper
//                      around the IPropertyPage interface.
//
// Note that the property page of IPropertyPage is implemented at a different
// location and will differ for each object. We only know that it supports
// the IPropertyPage interface through which we communicate with these objects.
//

class CPropertySite : public CPropertyPage, public IPropertyPageSite {

public:

    //
    // IPropertySite interface
    //
    STDMETHODIMP OnStatusChange(DWORD flags);
    STDMETHODIMP GetLocaleID(LCID *pLocaleID);
    STDMETHODIMP GetPageContainer(IUnknown **ppUnknown);
    STDMETHODIMP TranslateAccelerator(LPMSG pMsg);

    //
    // IUnknown interface
    //
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // CPropertyPage overides
    //
    BOOL OnSetActive();     // This property page gains the focus.
    BOOL OnKillActive();    // This property page loses focus.
                            // Validate all data and return FALSE if an
                            // error occurs.
                            // Note, this does not commit the data!!

    int OnCreate(LPCREATESTRUCT);
    void OnDestroy();

    // Allow the size to be retrieved.
    SIZE GetSize( ){ return m_PropPageInfo.size; }

    //
    // OnOK and OnCancel are methods specified by CPropertyPage.
    // For modal property pages/sheets they get called from CPropertySheet.
    // Since we work with a modeless property sheet, they are of no use
    // for us. All OK and Cancel operations are managed by CPropertySheet
    //
    void OnOK() {}
    void OnCancel() {}

    //
    // CPropertySite methods
    //
    CPropertySite(CVfWPropertySheet *, const CLSID *);
    ~CPropertySite();

    HRESULT Initialise(ULONG, IUnknown **);       // must be called immeadetly after construction
    void InitialiseSize(SIZE size); // must be called before creating page
    
    void UpdateButtons();
    HRESULT CleanUp();

    void OnHelp();      // Called after the help button has been pressed.
    void OnSiteApply();     // Called after the apply button has been pressed.
    BOOL IsPageDirty();
    BOOL PreTranslateMessage(MSG *); // Called from CVfWPropertySheet.

protected:

    void HelpDirFromCLSID(const CLSID* clsID, LPTSTR pszPath, DWORD dwPathSize);

    CVfWPropertySheet * m_pPropSheet;  // pointer to the overall frame of all
                                // property sheets.

    //
    // Intelligent pointer to IPropertyPage. Creates the property page
    // object from a CLSID and Releases it on destruction.
    //
    CQCOMInt<IPropertyPage> m_pIPropPage;


    PROPPAGEINFO m_PropPageInfo; // Information on the property page we wrap

    //
    // m_hrDirtyPage indicates whether the page is dirty or clean
    //  -> (IPropertyPage::IsPageDirty == S_FALSE).
    // The state of this flag also specifies the appearance of the Apply
    // button. (S_FALSE = disabled, S_OK = enabled)
    //
    HRESULT m_hrDirtyPage;

    //
    // m_fHelp indicates whether the help button should be enabled.
    // This will be determined from the value of pszHelpFile in the
    // PROPPAGEINFO structure obtained from IPropertyPage::GetPageInfo
    //
    BOOL m_fHelp;

    //
    // Reference counter for IUnknown
    //
    ULONG m_cRef;

    // Rectangle of our site
    CRect m_rcRect;

    BOOL m_fShowHelp;     // True if we called WinHelp for this page

    // Flag whether this page is active - used to avoid duplicate calls
    // to IPropertyPage::Activate() (MFC calls OnSetActive twice).
    BOOL m_fPageIsActive;

    const CLSID* m_CLSID;

    // holds DLGTEMPLATE so we don't have to allocate it. dword
    // aligned.
    DWORD m_pbDlgTemplate[30];  

    DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\qerror.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

// qerror.cpp

#include "stdafx.h"


void DisplayQuartzError( HRESULT hr )
{
    /* Message example
     *  <Error returned by AMGetErrorText>
     *
     */
    TCHAR szQMessage[MAX_ERROR_TEXT_LEN];

    if( AMGetErrorText( hr, szQMessage, MAX_ERROR_TEXT_LEN) > 0 ){
        AfxMessageBox( szQMessage );
    }

}

void DisplayQuartzError( UINT nID, HRESULT hr )
{
    /* Message example
     *  Unable to stop graph
     *
     *  Unspecified error (0x80004005)
     */
    CString strMessage;
    CString strCode;
    CString strCodeMessage;
    TCHAR szQMessage[MAX_ERROR_TEXT_LEN];

    strMessage.LoadString( nID );
    strCode.FormatMessage( IDS_RETURN_CODE, hr );

    if( AMGetErrorText( hr, szQMessage, MAX_ERROR_TEXT_LEN) > 0 ){
        strCodeMessage = szQMessage + CString(" ");
    }

    strMessage += "\n\n" + strCodeMessage + strCode;

    AfxMessageBox( strMessage );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\qerror.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

// qerror.h

void DisplayQuartzError( HRESULT hr );
void DisplayQuartzError( UINT nID, HRESULT hr );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\reconfig.h ===
#ifndef Reconfigure_h
#define Reconfigure_h

#include <streams.h>

class CBoxNetDoc;

HRESULT PreventStateChangesWhileOperationExecutes
    (
    IGraphBuilder* pGraphBuilder,
    IGraphConfigCallback* pCallback,
    void* pReconfigureParameter
    );
HRESULT IfPossiblePreventStateChangesWhileOperationExecutes
    (
    IGraphBuilder* pGraphBuilder,
    IGraphConfigCallback* pCallback,
    void* pReconfigureParameter
    );

class CGraphConfigCallback : public CUnknown,
                             public IGraphConfigCallback
{
public:
    CGraphConfigCallback( const TCHAR* pName, LPUNKNOWN pUnk );

    DECLARE_IUNKNOWN;
    STDMETHODIMP NonDelegatingQueryInterface( REFIID riid, void** ppv );

private:
};

class CPrintGraphAsHTMLCallback : public CGraphConfigCallback 
{
public:
    CPrintGraphAsHTMLCallback();

    void SafePrintGraphAsHTML( HANDLE hFile );
    STDMETHODIMP Reconfigure( PVOID pvContext, DWORD dwFlags );

    static IGraphConfigCallback* CreateInstance( void );

    struct PARAMETERS_FOR_PRINTGRAPHASHTMLINTERNAL 
    {
        CBoxNetDoc* pDocument;
        HANDLE hFileHandle;
    };
};

class CUpdateFiltersCallback : public CGraphConfigCallback
{
public:
    CUpdateFiltersCallback();

    STDMETHODIMP Reconfigure( PVOID pvContext, DWORD dwFlags );

    static IGraphConfigCallback* CreateInstance( void );
};

class CEnumerateFilterCacheCallback : public CGraphConfigCallback
{
public:
    CEnumerateFilterCacheCallback();

    STDMETHODIMP Reconfigure( PVOID pvContext, DWORD dwFlags );

    static IGraphConfigCallback* CreateInstance( void );
};

#endif // Reconfigure_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\mainfrm.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
// mainfrm.h : declares CMainFrame
//

class CSeekDialog : public CDialogBar
{
    BOOL m_bDirty;

public:
    CSeekDialog( );
    ~CSeekDialog( );

   // overrides

   // Generated message map functions
   //{{AFX_MSG(CSeekDialog)
   virtual void OnCancel( );
   virtual void OnHScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar );
   virtual void OnTimer( UINT nTimer );
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

public:

   BOOL DidPositionChange( );
   double GetPosition( );
   void SetPosition( double pos );
   BOOL IsSeekingRandom( );
};

class CMainFrame : public CFrameWnd
{
    DECLARE_DYNCREATE(CMainFrame)

protected:
    // control bar embedded members
    CStatusBar      m_wndStatusBar;
    CToolBar        m_wndToolBar;
    CToolTipCtrl   *m_pToolTip;

    BOOL PreTranslateMessage(MSG* pMsg);
    BOOL InitializeTooltips();

public:

    CSeekDialog  m_wndSeekBar;
    bool m_bSeekInit;
    bool m_bSeekEnabled;
    int  m_nSeekTimerID;
    HWND m_hwndTimer;
    virtual void ToggleSeekBar( BOOL NoReset = TRUE );

public:
    // construction and destruction
    CMainFrame();
    virtual ~CMainFrame();

public:
    // diagnostics
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

public:
    // operations
    virtual void SetStatus(unsigned idString);
    virtual void GetMessageString( UINT nID, CString& rMessage ) const;

protected:
    // generated message map
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnClose();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    afx_msg void MyOnHelpIndex();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\rndrurl.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include <wininet.h>
#include "rndrurl.h"

char gszPersistPath[]="Software\\Microsoft\\ActiveMovie\\GraphEdit\\URLPersistList";

BEGIN_MESSAGE_MAP(CRenderURL, CDialog)
END_MESSAGE_MAP()

//
// Constructor
//
CRenderURL::CRenderURL(char *szURLName, int cb, CWnd * pParent): 
    CDialog(IDD_RENDER_URL, pParent) 
{
    m_iCurrentSel=0;
    m_iURLListLength=0;
    m_psz=szURLName;
    m_psz[0]='\0';
    m_cb = cb;
}

CRenderURL::~CRenderURL()
{
}

void CRenderURL::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);    

    //{{AFX_DATA_MAP(CFontPropPage)
        DDX_Control(pDX, IDC_URL_LIST, m_ComboBox);
    //}}AFX_DATA_MAP
}

BOOL CRenderURL::OnInitDialog()
{
    CDialog::OnInitDialog();

    //pre-allocate storage for the list box for efficiency
    m_ComboBox.InitStorage(URL_LIST_SIZE, INTERNET_MAX_URL_LENGTH);

    //set the max number of chars that will go in the edit box
    m_ComboBox.LimitText(sizeof(URLSTRING));

    // retrieve the persisted URL names from the registry
    HKEY hkey=NULL;
    DWORD dwaction=0;
    DWORD dwresult = RegCreateKeyEx(HKEY_CURRENT_USER, gszPersistPath,
    			0,
    			NULL, //class of the object type
    			REG_OPTION_NON_VOLATILE,
    			KEY_QUERY_VALUE,
    			NULL, // security attributes
    			&hkey,
    			&dwaction) ;
    if ( dwresult != ERROR_SUCCESS ) {
       AfxMessageBox("Failed to open/create registry key");
    }

    int i;
    for (i=0; i < URL_LIST_SIZE; ++i) {
        char szFile[10];
        char szFileNum[10];
        long lError;
        wsprintf(szFile, "URL%s", _itoa(i, szFileNum, 10));
        DWORD cb=INTERNET_MAX_URL_LENGTH;
        lError = RegQueryValueEx(hkey, szFile, NULL, NULL, reinterpret_cast<BYTE *>(m_rgszURL[i]), &cb);
        // We never have a break in the sequence of URL names, if there are fewer
        // names than URL_LIST_SIZE we must be done
        if (lError != ERROR_SUCCESS)
            break;
    }

    RegCloseKey(hkey);

    m_iURLListLength=i;

    // fill the list of the combo box with the persisted URLs, fill the most recent
    // as the first entry in the list
    for (i=m_iURLListLength-1; i >=0; --i)  {
        int iPos=m_ComboBox.InsertString(m_iURLListLength-1-i, m_rgszURL[i]);
        ASSERT(iPos == m_iURLListLength-1-i);
    }

    // show the most recent URL in the edit box set the initial focus on the
    // combo box

    if (m_iURLListLength)
        m_ComboBox.SetWindowText(m_rgszURL[m_iURLListLength-1]);

    m_ComboBox.SetFocus();

    return(0); // we set the focus our selves
}

void CRenderURL::OnOK()
{
    // get the string in the edit box
    m_ComboBox.GetWindowText(m_psz, m_cb);
    if (strlen(m_psz) == 0)
        return;

    //if this string is in the combo box list, then there is nothing new to
    // persist
    if (m_ComboBox.FindStringExact(0, m_psz) != CB_ERR) {         
        CDialog::OnOK();
        return;
    }

    // otherwise save this URL path in the registry URL list
    HKEY hkey=NULL;
    DWORD dwaction=0;
    DWORD dwresult = RegCreateKeyEx(HKEY_CURRENT_USER, gszPersistPath,
    			0,
    			NULL, //class of the object type
    			REG_OPTION_NON_VOLATILE,
    			KEY_SET_VALUE,
    			NULL, // security attributes
    			&hkey,
    			&dwaction) ;
    if ( dwresult != ERROR_SUCCESS ) {
       AfxMessageBox("Failed to open/create registry key");
       return;
    }

    // if we have a full list, we will follow MRU and throw away the oldest added
    // URL
    int iList = (m_iURLListLength == URL_LIST_SIZE) ? m_iURLListLength-1 : m_iURLListLength;
    char szFile[10];
    char szFileNum[10];
    long lError;
    for (int i=0; i < iList; ++i) {
        wsprintf(szFile, "URL%s", _itoa(i, szFileNum, 10));

        // if we have a full list, we will follow MRU and throw away the oldest added
        // URL
        if (m_iURLListLength == URL_LIST_SIZE)            
            lError= RegSetValueEx(hkey, szFile, NULL, REG_SZ,
                reinterpret_cast<BYTE *>(m_rgszURL[i+1]), sizeof(m_rgszURL[i+1]));
        else 
            lError= RegSetValueEx(hkey, szFile, NULL, REG_SZ,
                reinterpret_cast<BYTE *>(m_rgszURL[i]), sizeof(m_rgszURL[i]));

        if (lError != ERROR_SUCCESS) {
            AfxMessageBox("Failed to write to a registry key");
            RegCloseKey(hkey);
            return;
        }
    }

    // add the new URL to the list
    wsprintf(szFile, "URL%s", _itoa(i, szFileNum, 10));
    lError= RegSetValueEx(hkey, szFile, NULL, REG_SZ,
            reinterpret_cast<BYTE *>(m_psz), m_cb);

    RegCloseKey(hkey);

    if (lError != ERROR_SUCCESS) {
        AfxMessageBox("Failed to write to a registry key");
        return;
    }

    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\rndrurl.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
// rndrurl.h

#ifndef __RENDER_URL__
#define __RENDER_URL__

#define URL_LIST_SIZE 6

typedef char URLSTRING[INTERNET_MAX_URL_LENGTH];
class CRenderURL : public CDialog
{
public:
    ~CRenderURL();
    CRenderURL(char *szFileName, int cb, CWnd * pParent = NULL );

protected:

    BOOL OnInitDialog();
    void DoDataExchange(CDataExchange* pDX);

    virtual void OnOK();


    DECLARE_MESSAGE_MAP()

private:
    CComboBox m_ComboBox;
    int m_iURLListLength;
    int m_iCurrentSel;
    char *m_psz;
    int m_cb;
    URLSTRING m_rgszURL[URL_LIST_SIZE];
};

#endif // __RENDER_URL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\propsht.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
//
// propsht.cpp
//

#include "stdafx.h"

//
// Define the GUIDs for the property pages and their interfaces
//
#include <initguid.h>
#include <propguid.h>

BEGIN_MESSAGE_MAP(CVfWPropertySheet, CPropertySheet)

    ON_WM_CREATE()

    ON_COMMAND(IDOK, OnOK)
    ON_COMMAND(IDCANCEL, OnCancel)
    ON_COMMAND(IDC_APPLY, OnApply)
    ON_COMMAND(IDC_PROP_HELP, OnHelp)

END_MESSAGE_MAP()

//
// Constructor
//
// Through the IUnknown pointer passed to us we might be able to
// get:
//
//   IBaseFilter, IPin, IFileSourceFilter, IFileSinkFilter or ISpecifyPropertyPages
//
// each of these has at least one IPropertyPage interface for us.
// (the ones for IBaseFilter, IPin, IFileSinkFilter and IFileSourceFilter
// are provided by proppage.dll )
//
CVfWPropertySheet::CVfWPropertySheet(IUnknown *pUnknown, CString szCaption, CWnd * wnd)
  : m_butOK(NULL)
  , m_fButtonsCreated(FALSE)
  , m_butApply(NULL)
  , m_butCancel(NULL)
  , m_butHelp(NULL)
  , m_fAnyChanges(FALSE)
  , CPropertySheet(szCaption, wnd)
{
    UINT iPages = 0;

    try {
        //
        // Create the four buttons
        //
        m_butOK     = new CButton();
        m_butCancel = new CButton();
        m_butApply  = new CButton();
        m_butHelp   = new CButton();

        //
        // First check whether this is a connected pin to make sure 
        // that we search both pins for SpecificPages
        //
        try {
            CQCOMInt<IPin> pPin(IID_IPin, pUnknown);

            IPin * pConnected = NULL;
            HRESULT hr = pPin->ConnectedTo( &pConnected );
            if( SUCCEEDED( hr ) )
            {
                // handle the connected pin first
                iPages += AddSpecificPages(pConnected);
                pConnected->Release();
            }                
        }
        catch (CHRESULTException) {
            // do nothing
        }

        iPages += AddSpecificPages(pUnknown);
        iPages += AddFilePage(pUnknown);
        iPages += AddPinPages(pUnknown);

        if (0 == iPages) {
            throw CE_FAIL();
        }


        // compute dimensions large enough to hold largest
        // proppage. tell all proppages.
        // 
        SIZE sizeMax = {0, 0};
        CPropertyPage *ppTmp;
        for(int iPage = 0; iPage < GetPageCount() && (ppTmp = GetPage(iPage)); iPage++)
        {
            CPropertySite *pcps = (CPropertySite *)ppTmp;
            SIZE size = pcps->GetSize();
            sizeMax.cx = max(sizeMax.cx, size.cx);
            sizeMax.cy = max(sizeMax.cy, size.cy);
        }
        for(iPage = 0; iPage < GetPageCount() && (ppTmp = GetPage(iPage)); iPage++)
        {
            CPropertySite *pcps = (CPropertySite *)ppTmp;
            pcps->InitialiseSize(sizeMax);
        }



        // create the property sheet but leave it invisible as we
        // will have to add the buttons to it
        if (!Create(wnd, WS_SYSMENU | WS_POPUP | WS_CAPTION | DS_MODALFRAME)) {
            throw CE_FAIL();
        }

		ASSERT( GetActivePage() );
		ASSERT( GetActivePage()->m_hWnd );

        CRect rcBoxSize(0, 0, 50, 14);
        GetActivePage()->MapDialogRect(&rcBoxSize);

        CString szTemp;

        szTemp.LoadString(IDS_OK);
        m_butOK->Create(szTemp,
                        BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE
                        | WS_TABSTOP | WS_GROUP,
                        rcBoxSize, this, IDOK);

        szTemp.LoadString(IDS_CLOSE);
        m_butCancel->Create(szTemp,
                            BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE
                            | WS_TABSTOP | WS_GROUP,
                            rcBoxSize, this, IDCANCEL);

        szTemp.LoadString(IDS_APPLY);
        m_butApply->Create(szTemp,
                           BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE
                           | WS_TABSTOP | WS_GROUP | WS_DISABLED,
                           rcBoxSize, this, IDC_APPLY);

        szTemp.LoadString(IDS_HELP);
        m_butHelp->Create(szTemp,
                          BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE
                          | WS_TABSTOP | WS_GROUP | WS_DISABLED,
                          rcBoxSize, this, IDC_PROP_HELP);


        //
        // Position the buttons on the property sheet
        //
        // The buttons are in the order Ok, Cancel, Apply and Help.
        //
        // The y-coordinate is 2 dialog units + the buttons size from the
        // bottom of the client area.
        //
        // On the x-coordinate there is a gap of 4 dialog units before each
        // button. Thus the x-ths button has a gap of
        //
        //    x * iSpacing + (x-1) * ButtonWidth
        //
        // between itself and the lefthand corner.
        //
        CRect rc, rcClient;
        GetWindowRect(&rc);
        GetClientRect(&rcClient);

        CRect rcSpacing(4, 2, 0, 0);
        GetActivePage()->MapDialogRect(&rcSpacing);
        const int iXSpacing = rcSpacing.left;
        const int iYSpacing = rcSpacing.top;

        // Make sure that the property page is wide enough for the buttons
		int iRight = rcClient.left + ( rcBoxSize.Width() + iXSpacing) * 4;

        if( rcClient.right < iRight )
            rc.right += rcClient.left + (iRight - rcClient.right);

        // increase the property sheet so there is space for our
        // buttons
        rc.bottom += rcBoxSize.Height() + iYSpacing * 2;

		MoveWindow( &rc );

        // to position the buttons we need the client rect (window - title)
        GetClientRect( &rc );

        m_butOK->MoveWindow( iXSpacing,
                                rc.Height() - rcBoxSize.Height() - iYSpacing,
                                rcBoxSize.Width(),
                                rcBoxSize.Height(),
                                SWP_SHOWWINDOW );

        m_butCancel->MoveWindow( 2 * iXSpacing + rcBoxSize.Width(),
                                 rc.Height() - rcBoxSize.Height() - iYSpacing,
                                 rcBoxSize.Width(),
                                 rcBoxSize.Height());

        m_butApply->MoveWindow( 3* iXSpacing + 2 * rcBoxSize.Width(),
                                rc.Height() - rcBoxSize.Height() - iYSpacing,
                                rcBoxSize.Width(),
                                rcBoxSize.Height());

        m_butHelp->MoveWindow( 4* iXSpacing + 3 * rcBoxSize.Width(),
                               rc.Height() - rcBoxSize.Height() - iYSpacing,
                               rcBoxSize.Width(),
                               rcBoxSize.Height());

        m_fButtonsCreated = TRUE;

        GetActiveSite()->UpdateButtons();

        ShowWindow( SW_SHOW );

    }
    catch (CHRESULTException) {
        Cleanup();
        throw;
    }

}


//
// Destructor
//
// Call Cleanup again - might have been missed.
//
CVfWPropertySheet::~CVfWPropertySheet()
{
    Cleanup();
}


//
// AddSpecificPages
//
// Given an IUnknown pointer we try to obtain a ISpecifyPropertyPages inter-
// face.
//
// If successful, a CPropertySite object is created for each IPropertyPage
// interface we obtain and added to the property pages of CPropertySheet.
//
UINT CVfWPropertySheet::AddSpecificPages(IUnknown *pUnknown)
{
    UINT iPages = 0;

    CAUUID cauuid;

    try {
        HRESULT hr;

        CQCOMInt<ISpecifyPropertyPages> IPages(IID_ISpecifyPropertyPages, pUnknown);

        hr = IPages->GetPages(&cauuid);
        if (FAILED(hr)) {
            throw CHRESULTException(hr);
        }
    }
    catch (CHRESULTException) {
        // clean up in CVfWPropertySheet::CVfWPropertySheet (only place we get called from)
        return(0);  // no pages created
    }

    //
    // Get the array of GUIDs for the property pages this object supports.
    //
    // Try to create as many as possible.
    //

    for (UINT count = 0; count < cauuid.cElems; count++) {

        try {
            CPropertySite* pPropSite;

            try {
                pPropSite = new CPropertySite( this, &cauuid.pElems[count] );
            } catch( CMemoryException* pOutOfMemory ) {
                pOutOfMemory->Delete();
                continue;
            }

            // AddRef the site now else something in Initialise
            // might cause the site to delete itself
            pPropSite->AddRef();

            if (FAILED(pPropSite->Initialise(1, &pUnknown))) {
                pPropSite->CleanUp();
                pPropSite->Release();
                continue;
            }

            try {
                AddPage(pPropSite);
            } catch( CMemoryException* pOutOfMemory ) {
                pPropSite->CleanUp();
                pPropSite->Release();
                pOutOfMemory->Delete();
                continue;
            }

            iPages++;
        }
        catch (CHRESULTException) {
            // continue with next iteration
        }
    }
    
    // Free the memory allocated in ISpecifyPropertyPages::GetPages().
    ::CoTaskMemFree( cauuid.pElems );

    return(iPages);
}


//
// AddFilePage
//
// Queries IUnknown on whether it supports IFileSourceFilter. If this is
// the case add a file property page (from proppage.dll)
//
UINT CVfWPropertySheet::AddFilePage(IUnknown * pUnknown)
{
    UINT iPage = 0;

    try {
        CQCOMInt<IFileSourceFilter> IFileSource(IID_IFileSourceFilter, pUnknown);


        CPropertySite * pPropSite =
            new CPropertySite(this, &CLSID_FileSourcePropertyPage);

        if (pPropSite == NULL) {
            throw CE_OUTOFMEMORY();
        }

        pPropSite->AddRef();

        if (FAILED(pPropSite->Initialise(1, &pUnknown))) {
            pPropSite->CleanUp();
            pPropSite->Release();
            throw CE_FAIL();
        }

        AddPage(pPropSite);
        iPage++;
    }
    catch (CHRESULTException) {
        // clean up in CVfWPropertySheet::CVfWPropertySheet
    }

    try {
        CQCOMInt<IFileSinkFilter> IFileSink(IID_IFileSinkFilter, pUnknown);


        CPropertySite * pPropSite =
            new CPropertySite(this, &CLSID_FileSinkPropertyPage);

        if (pPropSite == NULL) {
            throw CE_OUTOFMEMORY();
        }

        pPropSite->AddRef();

        if (FAILED(pPropSite->Initialise(1, &pUnknown))) {
            pPropSite->CleanUp();
            pPropSite->Release();
            throw CE_FAIL();
        }

        AddPage(pPropSite);
        iPage++;
    }
    catch (CHRESULTException) {
        // clean up in CVfWPropertySheet::CVfWPropertySheet
    }

    return(iPage);
}

//
// AddPinPages
//
// Try to obtain IBaseFilter or IPin from IUnknown.
//
// For IBaseFilter, enumerate all pins and add for each a media type property
// page (provided by proppage.dll)
//
// For IPin, provide just one media type property page.
//
UINT CVfWPropertySheet::AddPinPages(IUnknown * pUnknown)
{
    UINT iPages = 0;
    IPin *pPin = NULL;

    //
    // First try to obtain the IBaseFilter interface
    //
    try {
        CQCOMInt<IBaseFilter> pFilter(IID_IBaseFilter, pUnknown);

        for (CPinEnum Next(pFilter); 0 != (pPin = Next()); iPages++) {

            CPropertySite *pPropSite =
                new CPropertySite(this, &CLSID_MediaTypePropertyPage);

            if (pPropSite == NULL) {
                throw CE_OUTOFMEMORY();
            }

            pPropSite->AddRef();
            if (FAILED(pPropSite->Initialise(1, (IUnknown **) &pPin))) {
                pPropSite->CleanUp();
                pPropSite->Release();
                throw CE_FAIL();
            }

            AddPage(pPropSite);
            iPages++;

            pPin->Release();
            pPin = NULL;
        }
    }
    catch (CHRESULTException) {
        if (pPin) {
            pPin->Release();
            pPin = NULL;
        }
    }

    //
    // Now try for IPin
    //
    try {
        CQCOMInt<IPin> pPin(IID_IPin, pUnknown);

        CPropertySite *pPropSite =
            new CPropertySite(this, &CLSID_MediaTypePropertyPage);

        if (pPropSite == NULL) {
            throw CE_OUTOFMEMORY();
        }

        IPin * pIPin;   // temporary pointer to get proper (IUnknown **)

        pIPin = (IPin *) pPin;

        pPropSite->AddRef();
        if (FAILED(pPropSite->Initialise(1, (IUnknown **) &pIPin))) {
            pPropSite->CleanUp();
            pPropSite->Release();
            throw CE_FAIL();
        }

        AddPage(pPropSite);
        iPages++;
    }
    catch (CHRESULTException) {
        // clean up in CVfWPropertySheet::CVfWPropertySheet
    }

    return(iPages);
}

//
// OnCreate
//
int CVfWPropertySheet::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CPropertySheet::OnCreate(lpCreateStruct) != 0) {
        return -1;
    }

	// DO NOT add buttons here! Changes made to the window's size are
	// reset after this call

    return 0;
}

//
// Cleanup
//
// Cleanup deletes all created buttons and removes all CPropertySites from
// the CPropertySheet.
//
// This method can be run multiple times.
//
void CVfWPropertySheet::Cleanup()
{
    //
    // Delete all page sites. Note, we don't use delete, since the page
    // sites will be deleted automatically through the Release method
    // of their IUnknown interface.
    //
    while (GetPageCount() > 0) {
        CPropertySite * pPropSite = (CPropertySite *) GetPage(0);

        //
        // NOTE NOTE NOTE
        //
        // Suspected MFC bug.
        //
        // Intended code:
        //
        //   RemovePage(0);
        //
        // This asserts for every iteration. I believe that in mfc\src\dlgprop.cpp
        // in CPropertySheet::RemovePage(int), the following change is necessary:
        //    ASSERT(m_nCurPage != nPage); -> ASSERT(m_hWnd == NULL || m_nCurPage != nPage);
        //
        // Until this is fixed I am deleting the page by myself. This uses
        // the knowlegde that CPropertySheet is storing its CPropertyPages
        // in the pointer array m_pages.
        //
        //
        // <start hack>
        m_pages.RemoveAt(0);      // replace with "RemovePage(0);" once bug is fixed.
        // <end hack>

        pPropSite->CleanUp();
        pPropSite->Release();
    }

    //
    // Delete the buttons
    //
    delete m_butOK, m_butOK = NULL;
    delete m_butCancel, m_butCancel = NULL;
    delete m_butApply, m_butApply = NULL;
    delete m_butHelp, m_butHelp = NULL;
}

//////////////////////////////////////////////////////////////////////////
//
// Button handlers
//
//////////////////////////////////////////////////////////////////////////

//
// OnOK
//
// We need to call IPropertyPage::Apply for the property page of each
// CPropertySite. If all return with S_OK we can close our property sheet.
// Otherwise we cannot close the sheet, since some changes might not been
// applied.
//
void CVfWPropertySheet::OnOK()
{
    UINT iPages = GetPageCount();
    BOOL fCanQuit = TRUE;

    //
    // Apply this site first, so we can stay on it if the data is not
    // valid.
    //
    GetActiveSite()->OnSiteApply();
    if (GetActiveSite()->IsPageDirty()) {
        //
        // Data on current page is not valid.
        // The page stays active.
        //

        return;
    }

    //
    // Apply each property page and verify that none remains dirty
    // after the apply.
    // If a page remains dirty we know that the data validation failed.
    //
    for (UINT count = 0; count < iPages; count++) {

        ((CPropertySite *) GetPage(count))->OnSiteApply();
        if (((CPropertySite *) GetPage(count))->IsPageDirty()) {
            fCanQuit = FALSE;
        }
    }

    if (fCanQuit) {
        //
        // All pages have been applied. We can destroy our pages by calling
        // the OnCancel method.
        //
        OnCancel();

        return;
    }
}

//
// OnCancel
//
// Just close the sheet. All changes since the last Apply() will not
// propagate to the objects.
//
void CVfWPropertySheet::OnCancel()
{
    //
    //
    //

    // don't use EndDialog, which is for modal dialog boxes
    DestroyWindow();

    // Do cleanup here, because in an OnDestroy method, we cannot
    // remove all property pages, since the last one requires
    // m_hWnd of CPropertySheet to be NULL.
    Cleanup();
}

//
// OnApply
//
// Only apply changes of present visible property page to object.
//
void CVfWPropertySheet::OnApply()
{
    //
    // Apply the changes
    //
    GetActiveSite()->OnSiteApply();

    //
    // Are there any pages left which are dirty? Set the m_fAnyChanges
    // flag accordingly.
    //
    m_fAnyChanges = FALSE;

    UINT iPages = GetPageCount();
    for (UINT count = 0; count < iPages; count++) {
        if ( ((CPropertySite *) GetPage(count))->IsPageDirty() ) {
            m_fAnyChanges = TRUE;
        }
    }
}

//
// OnHelp
//
// Delegate the call to CPropertySite::OnHelp
//
void CVfWPropertySheet::OnHelp()
{
    GetActiveSite()->OnHelp();
}


//
// UpdateButtons
//
void CVfWPropertySheet::UpdateButtons(HRESULT hrIsDirty, BOOL fSupportHelp)
{
    ASSERT(m_butApply && m_butCancel && m_butHelp);

    if (!m_fButtonsCreated) {
        return;
    }

    //
    // We can use this method to obtain notifications of dirty pages.
    //
    if (hrIsDirty == S_OK) {
        m_fAnyChanges = TRUE;
    }

    //
    // Update Apply button
    //
    if (hrIsDirty == S_OK) {
        // we have a dirty page - enable apply button
        m_butApply->EnableWindow();
    }
    else {
        m_butApply->EnableWindow(FALSE);
    }

    //
    // Update Cancel/Close button
    //
    CString szLabel;

    if (m_fAnyChanges) {
        szLabel.LoadString(IDS_CANCEL);
    }
    else {
        szLabel.LoadString(IDS_CLOSE);
    }

    m_butCancel->SetWindowText(szLabel);

    //
    // Update Help button
    //
    if (fSupportHelp) {
        m_butHelp->EnableWindow();
    }
    else {
        m_butHelp->EnableWindow(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\mainfrm.cpp ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
// mainfrm.h : defines CMainFrame
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


//IMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd)
IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars


// toolbar buttons - IDs are command buttons
static UINT BASED_CODE buttons[] =
{
    // same order as in the bitmap 'toolbar.bmp'
    ID_FILE_NEW,
    ID_FILE_OPEN,
    ID_FILE_SAVE,
        ID_SEPARATOR,
    ID_FILE_PRINT,
        ID_SEPARATOR,
    ID_EDIT_CUT,
    ID_EDIT_COPY,
    ID_EDIT_PASTE,
        ID_SEPARATOR,
    ID_QUARTZ_RUN,
    ID_QUARTZ_PAUSE,
    ID_QUARTZ_STOP,
        ID_SEPARATOR,
    ID_INSERT_FILTER,
    ID_QUARTZ_DISCONNECT,
        ID_SEPARATOR,    
    ID_CONNECT_TO_GRAPH,
//    ID_FILE_NEW,
        ID_SEPARATOR,    
    ID_WINDOW_REFRESH,
        ID_SEPARATOR,
    ID_APP_ABOUT,
};

#define NUM_BUTTONS  (sizeof(buttons) / sizeof(buttons[0]))


// indicators
static UINT BASED_CODE indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};


/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction


CMainFrame::CMainFrame()
{
}


CMainFrame::~CMainFrame()
{
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics


#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}
#endif //_DEBUG


#ifdef _DEBUG
void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// operations


/* SetStatus(idString)
 *
 * Set the status bar text to the string resource <idString>.
 */
void CMainFrame::SetStatus(unsigned idString)
{
    CString     str;

    try
    {
        str.LoadString(idString);
        m_wndStatusBar.SetPaneText(0, str);
    }
    catch (CException *e)
    {
        m_wndStatusBar.SetPaneText(0, "Warning: almost out of memory!", TRUE);
	e->Delete();
    }
}

void CMainFrame::GetMessageString( UINT nID, CString& rMessage ) const
{
    // The text displayed in the status bar when Edit..Redo is highlighted
    // depends on whether we are allowing a redo or a repeat.
    if( nID == ID_EDIT_REDO ){
        CBoxNetDoc *pDoc = (CBoxNetDoc *) ((CFrameWnd *)this)->GetActiveDocument();

        if( pDoc->CanRedo() )
            rMessage.LoadString( ID_EDIT_REDO );
        else
            rMessage.LoadString( ID_EDIT_REPEAT );
    } else
        CFrameWnd::GetMessageString( nID, rMessage );
}

        
        

/////////////////////////////////////////////////////////////////////////////
// generated message map

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
	ON_WM_CLOSE()
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP_INDEX, CMainFrame::MyOnHelpIndex)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// message callback functions


int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{

    EnableDocking(CBRS_FLOAT_MULTI);

    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!m_wndToolBar.Create(this) ||
        !m_wndToolBar.LoadBitmap(IDR_MAINFRAME) ||
        !m_wndToolBar.SetButtons(buttons, sizeof(buttons)/sizeof(UINT)))
    {
        TRACE("Failed to create toolbar\n");
        return -1;      // fail to create
    }

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE("Failed to create status bar\n");
        return -1;      // fail to create
    }

    DragAcceptFiles();

    m_bSeekInit = false;
    m_bSeekEnabled = true;
    m_nSeekTimerID = 0;

    InitializeTooltips();
    return 0;
}

BOOL CMainFrame::InitializeTooltips()
{
    int rc;

    // Create the tooltip control
    m_pToolTip = new CToolTipCtrl;
    if(!m_pToolTip->Create(this, TTS_ALWAYSTIP))
    {
       TRACE(TEXT("Unable To create ToolTip\n"));
       return FALSE;
    }

    // Set some tooltip defaults
    m_pToolTip->SetDelayTime(TTDT_AUTOPOP, 5000);  /* 5s  */
    m_pToolTip->SetDelayTime(TTDT_INITIAL, 1000);  /* 1s */

    // Add tooltip strings for the toolbar controls
    RECT rect;
    int ID[NUM_BUTTONS] = {
        ID_FILE_NEW,
        ID_FILE_OPEN,
        ID_FILE_SAVE,
            ID_SEPARATOR,
        ID_FILE_PRINT,
            ID_SEPARATOR,
        ID_EDIT_CUT,
        ID_EDIT_COPY,
        ID_EDIT_PASTE,
            ID_SEPARATOR,
        ID_QUARTZ_RUN,
        ID_QUARTZ_PAUSE,
        ID_QUARTZ_STOP,
            ID_SEPARATOR,
        ID_INSERT_FILTER,
        ID_QUARTZ_DISCONNECT,
            ID_SEPARATOR,    
        ID_CONNECT_TO_GRAPH,
            ID_SEPARATOR,    
        ID_WINDOW_REFRESH,
            ID_SEPARATOR,
        ID_APP_ABOUT,
    };

    // Loop through the toolbar buttons and add a tooltip for each
    for (int i=0; i<NUM_BUTTONS; i++)
    {
        // Don't add tooltips for separator items
        if (ID[i] == ID_SEPARATOR)
            continue;

        // Get the bounding rect for this button
        m_wndToolBar.GetItemRect(i, &rect);

        // Add a tooltip for this button, using its text ID, 
        // bounding rect, and resource ID
        rc = m_pToolTip->AddTool(&m_wndToolBar, ID[i], &rect, ID[i]); 
    }

    // Activate the tooltip control
    m_pToolTip->Activate(TRUE);
    return TRUE;
}

BOOL CMainFrame::PreTranslateMessage(MSG* pMsg) 
{
    // Let the tooltip process the message, if appropriate
    if (m_pToolTip)
        m_pToolTip->RelayEvent(pMsg);
	
    // Pass along all messages untouched
	return CFrameWnd::PreTranslateMessage(pMsg);
}


afx_msg void CMainFrame::MyOnHelpIndex()
{
    // get path to graphedt.exe and keep just the directory name
    TCHAR szHelpPath[MAX_PATH];
    GetModuleFileName(0, szHelpPath, MAX_PATH);
    *_tcsrchr(szHelpPath, TEXT('\\')) = 0;

    // note: if you change the name of the help file, change
    // IDS_CANT_LOAD_HELP in graphedt.rc to match
    
    HINSTANCE h = ShellExecute(NULL, // hwnd
                               NULL, // verb (usually defaults to "open")
                               TEXT("graphedit.chm"),
                               NULL, // arguments
                               szHelpPath,
                               SW_SHOWNORMAL);

    if(h <= (HINSTANCE)32)
    {
        // docs say ShellExecute doesn't set the last error (but the
        // complicated -Ex version does), so just report some generic
        // rather than trying to decode the SE_ errors

        CString strMessage;
        strMessage.LoadString( IDS_CANT_LOAD_HELP );
        AfxMessageBox( strMessage );
    }
}


void CMainFrame::OnClose() 
{
    // Disable and destroy the tooltip control
    if (m_pToolTip)
    {
        m_pToolTip->Activate(FALSE);
        delete m_pToolTip;
        m_pToolTip = 0;
    }
	
	CFrameWnd::OnClose();
}


void CMainFrame::ToggleSeekBar( BOOL bNoReset )
{
    // Create the seek bar the first time through
    if( !m_bSeekInit )
    {
        m_bSeekInit = true;
        m_wndSeekBar.Create( this, IDD_SEEKBAR, CBRS_TOP, IDD_SEEKBAR );

        HWND h = ::GetDlgItem( m_wndSeekBar.m_hWnd, IDC_SEEKSLIDER );
        m_wndSeekBar.ShowWindow( SW_SHOW );
        m_wndSeekBar.EnableDocking( 0 );

        ::SendMessage( h, TBM_SETRANGE, 0, MAKELONG( 0, 10000 ) );
        ::SendMessage( h, TBM_SETPAGESIZE, 0, 500 );

        return;
    }

    if( !bNoReset )
    {
        m_wndSeekBar.ShowWindow( SW_SHOW );
        return;
    }

    if( m_bSeekEnabled == true )
    {
        // Use the global ::Kill/::Set timer functions to avoid confusion
        // between CFrameWnd and CBoxNetDoc methods & handles
        int nKilled = ::KillTimer( m_hwndTimer, m_nSeekTimerID );
        m_nSeekTimerID = 0;
        m_wndSeekBar.EnableWindow(FALSE);
        m_bSeekEnabled = false;
    }
    else
    {
        m_bSeekEnabled = true;
        m_wndSeekBar.EnableWindow(TRUE);

        // If the seek timer is NOT already running, start it
        if (!m_nSeekTimerID)
            m_nSeekTimerID = ::SetTimer( m_hwndTimer, CBoxNetView::TIMER_SEEKBAR, 200, NULL );
    }

    // Get the handle of the "View" menu
    CMenu *pMainMenu = GetMenu();
    CMenu *pMenu = pMainMenu->GetSubMenu(2);        

    // Update the seekbar check mark
    if (pMenu != NULL)
    {
        if (m_bSeekEnabled)
            pMenu->CheckMenuItem(ID_VIEW_SEEKBAR, MF_CHECKED | MF_BYCOMMAND);
        else
            pMenu->CheckMenuItem(ID_VIEW_SEEKBAR, MF_UNCHECKED | MF_BYCOMMAND);
    }
}

BEGIN_MESSAGE_MAP(CSeekDialog, CDialogBar)
   //{{AFX_MSG_MAP(CSeekDialog)
    ON_WM_HSCROLL()
    ON_WM_TIMER()
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CSeekDialog::CSeekDialog()
: CDialogBar( )
{
    m_bDirty = FALSE;
}

CSeekDialog::~CSeekDialog( )
{
}

void CSeekDialog::OnCancel( )
{
    ShowWindow( FALSE );
}

BOOL CSeekDialog::DidPositionChange( )
{
    if( m_bDirty )
    {
        m_bDirty = false;
        return true;
    }
    return false;
}

double CSeekDialog::GetPosition( )
{
    HWND h = ::GetDlgItem( m_hWnd, IDC_SEEKSLIDER );
    if( !h )
    {
        return 0.0;
    }

    LRESULT Pos = ::SendMessage( h, TBM_GETPOS, 0, 0 );
    return double( Pos ) / 10000.0;
}

void CSeekDialog::SetPosition( double pos )
{
    HWND h = ::GetDlgItem( m_hWnd, IDC_SEEKSLIDER );
    if( !h )
    {
        long e = GetLastError( );
        return;
    }
    ::SendMessage( h, TBM_SETSEL, (WPARAM)(BOOL) TRUE, (LPARAM)MAKELONG( 0, pos * 10000 ) );
}

void CSeekDialog::OnHScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar )
{
    m_bDirty = true;
}

void CSeekDialog::OnTimer( UINT TimerID )
{
    static long counter = 0;
    counter++;
    if( counter < 30 )
    {
        return;
    }

    counter = 0;

    if( IsDlgButtonChecked( IDC_RANDOM ) )
    {
        long Pos = rand( ) % 10000;
        HWND h = ::GetDlgItem( m_hWnd, IDC_SEEKSLIDER );
        ::SendMessage( h, TBM_SETPOS, TRUE, Pos );
        m_bDirty = true;
    }
}

BOOL CSeekDialog::IsSeekingRandom( )
{
    return ::IsDlgButtonChecked( m_hWnd, IDC_RANDOM );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\stdafx.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h
//
// Include file for standard system include files, or project specific include
// files that are used frequently, but are changed infrequently.
//

#include <afxwin.h>             // MFC core and standard components
#include <afxext.h>             // MFC extensions (including VB)
#include <afxole.h>             // MFC OLE2
#include <afxcmn.h>

#include <objbase.h>
#include <afxtempl.h>

#include <atlbase.h>

#include <strmif.h>
#include <windowsx.h>
#include <control.h>
#include <evcode.h>
#include <uuids.h>
#include <vfwmsgs.h>
#include <errors.h>

#include <hrExcept.h>           // Exception classes
#include <comint.h>             // COM interface helper
#include <multistr.h>           // MultiByteToWideChar Helper

#include <olectl.h>

#include "resource.h"

#include "grftmpl.h"
#include "mainfrm.h"
#include "gutil.h"              // general utilities, list classes etc
#include "enum.h"               // IEnumXXX wrappers

#include "propobj.h"            // Objects which support property browsing
#include "propsht.h"        // Property Sheet class
#include "propsite.h"       // Property Site class
#include "box.h"                // filter & box objects
#include "link.h"               // connection/link objects
#include "cmd.h"
#include "bnetdoc.h"
#include "boxdraw.h"
#include "bnetvw.h"

#include "graphedt.h"

#include "qerror.h"         // Error handling
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\mp2demux\mp2prop.cpp ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        mp2prop.cpp

    Abstract:

        This module contains the property page implementations.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        06-Jul-1999     created

    Notes:

--*/

#include <streams.h>
#include <commctrl.h>       //  for the property pages
#include <tchar.h>
#include <mmreg.h>
#include <limits.h>
#include <bdaiface.h>
#include <ks.h>             //  for ksmedia.h
#include <ksmedia.h>        //  for bdamedia.h
#include <bdamedia.h>       //  for KSDATAFORMAT_TYPE_MPEG2_SECTIONS
#include "mp2res.h"
#include <initguid.h>
#include "mp2prop.h"
#include "uictrl.h"

//  XXXX
//  for swprintf () call ..
#include <stdio.h>

#define GOTO_NE(v,c,l)              if ((v) != (c)) { goto l ; }
#define RELEASE_AND_CLEAR(punk)     if (punk) { (punk)->Release(); (punk) = NULL; }

//  ---------------------------------------------------------------------------

//  define various contents of controls that appear in the properties
//  ---------------------------------------------------------------------------

static TCHAR g_szPID []         =   __TEXT("PID") ;
static TCHAR g_szStreamId []    =   __TEXT("stream_id") ;

#define DISTINCT_PID_COUNT      (1 << 13)
#define MAX_PID_VALUE           (DISTINCT_PID_COUNT - 1)
#define STREAM_ID_MIN           0xBA
#define STREAM_ID_MAX           0xFF

//static GUID g_MediaTypeMpeg2Sections = KSDATAFORMAT_TYPE_MPEG2_SECTIONS ;

typedef
struct {
    WCHAR * szTitle ;
    DWORD   dwWidth ;
} COL_DETAIL ;

#define LV_COL(title, width)  { L#title, (width) }

//  output pin listview for output pin & PID map property defined here

static
enum {
    PIN_COL_PIN,
    PIN_COL_COUNT
} ;

static
COL_DETAIL
g_OutputPinColumns [] = {
    LV_COL (Pin,     70),
} ;

//  ============================================================================
//  PID map enum listview for PID map property listview control defined here

static
enum {
    PID_COL_PID,
    PIN_COL_PID,
    MEDIA_SAMPLE_CONTENT_PID,
    PID_PIN_COL_COUNT           //  always last
} ;

static
COL_DETAIL
g_PIDMapColumns [] = {
    LV_COL (PID,        50),
    LV_COL (Pin,        60),
    LV_COL (Content,    180),
} ;
//  ============================================================================


//  ============================================================================
//  PID map enum listview for PID map property listview control defined here

static
enum {
    STREAM_ID_COL_STREAM,
    PIN_COL_STREAM,
    MEDIA_SAMPLE_CONTENT_STREAM,
    FILTER_COL_STREAM,
    OFFSET_COL_STREAM,
    STREAM_ID_PIN_COL_COUNT     //  always last
} ;

static
COL_DETAIL
g_StreamIdMapColumns [] = {
    LV_COL (stream_id,  60),
    LV_COL (Pin,        40),
    LV_COL (Content,    130),
    LV_COL (Filter,     40),
    LV_COL (Offset,     40),
} ;
//  ============================================================================

//  MEDIA_SAMPLE_CONTENT ids and descriptions
typedef
struct {
    LPWSTR  pszDescription ;
    DWORD   MediaSampleContent ;
} MEDIA_SAMPLE_CONTENT_DESC ;

//  !! NOTE !!  MediaSampleContent value (cast to an int) is used as an index, so
//  keep the order
static
MEDIA_SAMPLE_CONTENT_DESC
g_TransportMediaSampleContentDesc [] = {
    {
        L"Transport Packet (complete)",
        (DWORD) MEDIA_TRANSPORT_PACKET
    },
    {
        L"Elementary Stream (A/V only)",
        (DWORD) MEDIA_ELEMENTARY_STREAM
    },
    {
        L"MPEG2 PSI Sections",
        (DWORD) MEDIA_MPEG2_PSI
    },
    {
        L"Transport Packet Payload",
        (DWORD) MEDIA_TRANSPORT_PAYLOAD
    }
} ;

//  !! NOTE !!  MediaSampleContent value (cast to an int) is used as an index, so
//  keep the order
static
MEDIA_SAMPLE_CONTENT_DESC
g_ProgramMediaSampleContentDesc [] = {
    {
        L"Program Stream Map",
        (DWORD) MPEG2_PROGRAM_STREAM_MAP
    },
    {
        L"Elementary Stream (A/V only)",
        (DWORD) MPEG2_PROGRAM_ELEMENTARY_STREAM
    },
    {
        L"Directory PES Packet",
        (DWORD) MPEG2_PROGRAM_DIRECTORY_PES_PACKET
    },
    {
        L"Pack Header",
        (DWORD) MPEG2_PROGRAM_PACK_HEADER
    },
    {
        L"System Header",
        (DWORD) MPEG2_PROGRAM_SYSTEM_HEADER
    },
    {
        L"PES Stream",
        (DWORD) MPEG2_PROGRAM_PES_STREAM
    }
} ;

//  format blocks for the canned types

//  ac-3
static
WAVEFORMATEX
g_AC3WaveFormatEx = {
    WAVE_FORMAT_UNKNOWN,    //  wFormatTag
    2,                      //  nChannels
    48000,                  //  nSamplesPerSec (others: 96000)
    0,                      //  nAvgBytesPerSec
    0,                      //  nBlockAlign
    16,                     //  wBitsPerSample (others: 20, 24, 0)
    0                       //  cbSize
} ;

//  WaveFormatEx format block; generated with the following settings:
//
//  fwHeadFlags         = 0x1c;
//  wHeadEmphasis       = 1;
//  fwHeadModeExt       = 1;
//  fwHeadMode          = 1;
//  dwHeadBitrate       = 0x3e800;
//  fwHeadLayer         = 0x2;
//  wfx.cbSize          = 0x16;
//  wfx.wBitsPerSample  = 0;
//  wfx.nBlockAlign     = 0x300;
//  wfx.nAvgBytesPerSec = 0x7d00;
//  wfx.nSamplesPerSec  = 0xbb80;
//  wfx.nChannels       = 2;
//  wfx.wFormatTag      = 0x50;
//  dwPTSLow            = 0;
//  dwPTSHigh           = 0;
static
BYTE
g_MPEG1AudioFormat [] = {
    0x50, 0x00, 0x02, 0x00, 0x80, 0xBB, 0x00, 0x00,
    0x00, 0x7D, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x16, 0x00, 0x02, 0x00, 0x00, 0xE8, 0x03, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x1C, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
} ;

static
BYTE
g_Mpeg2ProgramVideo [] = {
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcSource.left              = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcSource.top               = 0x00000000
    0xD0, 0x02, 0x00, 0x00,                         //  .hdr.rcSource.right             = 0x000002d0
    0xE0, 0x01, 0x00, 0x00,                         //  .hdr.rcSource.bottom            = 0x000001e0
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.left              = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.top               = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.right             = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.bottom            = 0x00000000
    0x00, 0x09, 0x3D, 0x00,                         //  .hdr.dwBitRate                  = 0x003d0900
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwBitErrorRate             = 0x00000000
    0x63, 0x17, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, //  .hdr.AvgTimePerFrame            = 0x0000000000051763
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwInterlaceFlags           = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwCopyProtectFlags         = 0x00000000
    0x04, 0x00, 0x00, 0x00,                         //  .hdr.dwPictAspectRatioX         = 0x00000004
    0x03, 0x00, 0x00, 0x00,                         //  .hdr.dwPictAspectRatioY         = 0x00000003
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwReserved1                = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwReserved2                = 0x00000000
    0x28, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biSize           = 0x00000028
    0xD0, 0x02, 0x00, 0x00,                         //  .hdr.bmiHeader.biWidth          = 0x000002d0
    0xE0, 0x01, 0x00, 0x00,                         //  .hdr.bmiHeader.biHeight         = 0x00000000
    0x00, 0x00,                                     //  .hdr.bmiHeader.biPlanes         = 0x0000
    0x00, 0x00,                                     //  .hdr.bmiHeader.biBitCount       = 0x0000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biCompression    = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biSizeImage      = 0x00000000
    0xD0, 0x07, 0x00, 0x00,                         //  .hdr.bmiHeader.biXPelsPerMeter  = 0x000007d0
    0x27, 0xCF, 0x00, 0x00,                         //  .hdr.bmiHeader.biYPelsPerMeter  = 0x0000cf27
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biClrUsed        = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biClrImportant   = 0x00000000
    0x98, 0xF4, 0x06, 0x00,                         //  .dwStartTimeCode                = 0x0006f498
    0x56, 0x00, 0x00, 0x00,                         //  .cbSequenceHeader               = 0x00000056
    0x02, 0x00, 0x00, 0x00,                         //  .dwProfile                      = 0x00000002
    0x02, 0x00, 0x00, 0x00,                         //  .dwLevel                        = 0x00000002
    0x00, 0x00, 0x00, 0x00,                         //  .Flags                          = 0x00000000
                                                    //  .dwSequenceHeader [1]
    0x00, 0x00, 0x01, 0xB3, 0x2D, 0x01, 0xE0, 0x24,
    0x09, 0xC4, 0x23, 0x81, 0x10, 0x11, 0x11, 0x12,
    0x12, 0x12, 0x13, 0x13, 0x13, 0x13, 0x14, 0x14,
    0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
    0x18, 0x18, 0x18, 0x19, 0x18, 0x18, 0x18, 0x19,
    0x1A, 0x1A, 0x1A, 0x1A, 0x19, 0x1B, 0x1B, 0x1B,
    0x1B, 0x1B, 0x1C, 0x1C, 0x1C, 0x1C, 0x1E, 0x1E,
    0x1E, 0x1F, 0x1F, 0x21, 0x00, 0x00, 0x01, 0xB5,
    0x14, 0x82, 0x00, 0x01, 0x00, 0x00
} ;

static
BYTE
g_ATSCVideoFormat [] = {
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcSource.left              = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcSource.top               = 0x00000000
    0xC0, 0x02, 0x00, 0x00,                         //  .hdr.rcSource.right             = 0x000002c0
    0xE0, 0x01, 0x00, 0x00,                         //  .hdr.rcSource.bottom            = 0x000001e0
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.left              = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.top               = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.right             = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.bottom            = 0x00000000
    0x00, 0x1B, 0xB7, 0x00,                         //  .hdr.dwBitRate                  = 0x00b71b00
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwBitErrorRate             = 0x00000000
    0xB1, 0x8B, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, //  .hdr.AvgTimePerFrame            = 0x0000000000028bb1
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwInterlaceFlags           = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwCopyProtectFlags         = 0x00000000
    0x10, 0x00, 0x00, 0x00,                         //  .hdr.dwPictAspectRatioX         = 0x00000010
    0x09, 0x00, 0x00, 0x00,                         //  .hdr.dwPictAspectRatioY         = 0x00000009
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwReserved1                = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwReserved2                = 0x00000000
    0x28, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biSize           = 0x00000028
    0xC0, 0x02, 0x00, 0x00,                         //  .hdr.bmiHeader.biWidth          = 0x000002c0
    0xE0, 0x01, 0x00, 0x00,                         //  .hdr.bmiHeader.biHeight         = 0x000001e0
    0x00, 0x00,                                     //  .hdr.bmiHeader.biPlanes         = 0x0000
    0x00, 0x00,                                     //  .hdr.bmiHeader.biBitCount       = 0x0000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biCompression    = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biSizeImage      = 0x00000000
    0xD0, 0x07, 0x00, 0x00,                         //  .hdr.bmiHeader.biXPelsPerMeter  = 0x000007d0
    0x42, 0xD8, 0x00, 0x00,                         //  .hdr.bmiHeader.biYPelsPerMeter  = 0x0000d842
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biClrUsed        = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biClrImportant   = 0x00000000
    0xC0, 0x27, 0xC8, 0x00,                         //  .dwStartTimeCode                = 0x00c827c0
    0x4C, 0x00, 0x00, 0x00,                         //  .cbSequenceHeader               = 0x0000004c
    0xFF, 0xFF, 0xFF, 0xFF,                         //  .dwProfile                      = 0xffffffff
    0xFF, 0xFF, 0xFF, 0xFF,                         //  .dwLevel                        = 0xffffffff
    0x00, 0x00, 0x00, 0x00,                         //  .Flags                          = 0x00000000
                                                    //  .dwSequenceHeader [1]
    0x00, 0x00, 0x01, 0xB3, 0x2C, 0x01, 0xE0, 0x37,
    0x1D, 0x4C, 0x23, 0x81, 0x10, 0x11, 0x11, 0x12,
    0x12, 0x12, 0x13, 0x13, 0x13, 0x13, 0x14, 0x14,
    0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
    0x18, 0x18, 0x18, 0x19, 0x18, 0x18, 0x18, 0x19,
    0x1A, 0x1A, 0x1A, 0x1A, 0x19, 0x1B, 0x1B, 0x1B,
    0x1B, 0x1B, 0x1C, 0x1C, 0x1C, 0x1C, 0x1E, 0x1E,
    0x1E, 0x1F, 0x1F, 0x21, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00
} ;

//  canned types we support via the property page

//  order is important !  Keep these in the same order as the
//  detail declarations in g_CannedType.
static
enum {
    PIN_TYPE_ATSC_VIDEO,
    PIN_TYPE_MPEG2_PROGRAM_VIDEO,
    PIN_TYPE_MPEG1_AUDIO,
    PIN_TYPE_MPEG2_AUDIO,
    PIN_TYPE_ATSC_AUDIO,
    PIN_TYPE_DATA,
    PIN_TYPE_TRANSPORT_STREAM,
    PIN_TYPE_MPE,
    PIN_TYPE_MPEG2_PSI,
    NUM_CANNED_TYPE                     //  always last
} ;

//  keep these in the same order as the enum'd types above
static
struct {
    WCHAR * szDescription ;

    struct {
        const GUID *    pMajorType ;
        const GUID *    pSubType ;
        BOOL            bFixedSizeSamples ;
        const GUID *    pFormatType ;
        int             cbFormat ;
        BYTE *          pbFormat ;
    } MediaType ;

} g_CannedType [] = {

    //  PIN_TYPE_ATSC_VIDEO
    {
        L"ATSC Video",
        {
            & MEDIATYPE_Video,                  //  majortype
            & MEDIASUBTYPE_MPEG2_VIDEO,         //  subtype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_MPEG2Video,                //  formattype
            sizeof g_ATSCVideoFormat,           //  cbFormat
            g_ATSCVideoFormat                   //  pbFormat
        }
    },

    //  PIN_TYPE_MPEG2_PROGRAM_VIDEO
    {
        L"MPEG2 Program Video",
        {
            & MEDIATYPE_Video,                  //  majortype
            & MEDIASUBTYPE_MPEG2_VIDEO,         //  subtype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_MPEG2Video,                //  formattype
            sizeof g_Mpeg2ProgramVideo,         //  cbFormat
            g_Mpeg2ProgramVideo                 //  pbFormat
        }
    },

    //  PIN_TYPE_MPEG1_AUDIO
    {
        L"MPEG-1 Audio",
        {
            & MEDIATYPE_Audio,                  //  majortype
            & MEDIASUBTYPE_MPEG1Payload,        //  subtype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_WaveFormatEx,              //  formattype
            sizeof g_MPEG1AudioFormat,          //  cbFormat
            g_MPEG1AudioFormat                  //  pbFormat
        }
    },

    //  PIN_TYPE_MPEG2_AUDIO
    {
        L"MPEG-2 Audio",
        {
            & MEDIATYPE_Audio,                  //  majortype
            & MEDIASUBTYPE_MPEG2_AUDIO,         //  subtype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_WaveFormatEx,              //  formattype
            sizeof g_MPEG1AudioFormat,          //  cbFormat
            g_MPEG1AudioFormat                  //  pbFormat
        }
    },

    //  PIN_TYPE_ATSC_AUDIO
    {
        L"ATSC Audio (AC3)",
        {
            & MEDIATYPE_Audio,                  //  majortype
            & MEDIASUBTYPE_DOLBY_AC3,           //  subtype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_WaveFormatEx,              //  formattype
            sizeof g_AC3WaveFormatEx,           //  cbFormat
            (BYTE *) & g_AC3WaveFormatEx        //  pbFormat
        }
    },

    //  PIN_TYPE_DATA
    {
        L"Transport Payload",
        {
            & MEDIATYPE_NULL,                   //  majortype
            & MEDIASUBTYPE_NULL,                //  minortype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_None,                      //  formattype
            0,                                  //  cbFormat
            NULL                                //  pbFormat
        }
    },

    //  PIN_TYPE_TRANSPORT_STREAM
    {
        L"Transport Stream",
        {
            & MEDIATYPE_Stream,                 //  majortype
            & MEDIASUBTYPE_MPEG2_TRANSPORT,     //  minortype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_None,                      //  formattype
            0,                                  //  cbFormat
            NULL                                //  pbFormat
        }
    },

    //  PIN_TYPE_MPE
    {
        L"DVB MPE",
        {
            & KSDATAFORMAT_TYPE_MPEG2_SECTIONS, //  majortype
            & MEDIASUBTYPE_None,                //  minortype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_None,                      //  formattype
            0,                                  //  cbFormat
            NULL                                //  pbFormat
        }
    },
    //  PIN_TYPE_MPEG2_PSI
    {
        L"MPEG-2 PSI",
        {
            & KSDATAFORMAT_TYPE_MPEG2_SECTIONS, //  majortype
            & MEDIASUBTYPE_None,                //  minortype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_None,                      //  formattype
            0,                                  //  cbFormat
            NULL                                //  pbFormat
        }
    },
} ;

//  TRUE / FALSE for YES / NO
static
BOOL
MessageBoxQuestion (
    IN  TCHAR * title,
    IN  TCHAR * szfmt,
    ...
    )
{
    TCHAR   achbuffer [256] ;
    va_list va ;

    va_start (va, szfmt) ;
    wvsprintf (achbuffer, szfmt, va) ;

    return MessageBox (NULL, achbuffer, title, MB_YESNO | MB_ICONQUESTION) == IDYES ;
}

//  error conditions
static
void
MessageBoxError (
    IN  TCHAR * title,
    IN  TCHAR * szfmt,
    ...
    )
{
    TCHAR   achbuffer [256] ;
    va_list va ;

    va_start (va, szfmt) ;
    wvsprintf (achbuffer, szfmt, va) ;

    MessageBox (NULL, achbuffer, title, MB_OK | MB_ICONEXCLAMATION) ;
}

//  variable param
static
void
MessageBoxVar (
    IN  TCHAR * title,
    IN  TCHAR * szfmt,
    ...
    )
{
    TCHAR   achbuffer [256] ;
    va_list va ;

    va_start (va, szfmt) ;
    wvsprintf (achbuffer, szfmt, va) ;

    MessageBox (NULL, achbuffer, title, MB_OK) ;
}

//  ---------------------------------------------------------------------------
//      CMPEG2PropOutputPins
//  ---------------------------------------------------------------------------

CMPEG2PropOutputPins::CMPEG2PropOutputPins (
    IN  TCHAR *     pClassName,
    IN  IUnknown *  pIUnknown,
    IN  REFCLSID    rclsid,
    OUT HRESULT *   pHr
    ) : CBasePropertyPage       (
            pClassName,
            pIUnknown,
            IDD_MPG2SPLT_PROP_PINS,
            IDS_MPG2SPLT_PROP_PINS_TITLE
            ),
        m_hwnd                  (NULL),
        m_pIMpeg2Demultiplexer  (NULL)
{
    (* pHr) = S_OK ;
}

HRESULT
CMPEG2PropOutputPins::RefreshPinList_ (
    )
{
    CListview       OutputPins (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    ULONG           cFetched ;
    IBaseFilter *   pIBaseFilter ;
    IEnumPins *     pIEnumPins ;
    IPin *          pIPin ;
    HRESULT         hr ;
    PIN_INFO        PinInfo ;
    int             row ;

    hr = S_OK ;

    pIBaseFilter    = NULL ;
    pIEnumPins      = NULL ;
    pIPin           = NULL ;
    PinInfo.pFilter = NULL ;

    if (m_pIMpeg2Demultiplexer) {

        ASSERT (m_hwnd) ;

        //  obtain our pin enumeration interface
        hr = m_pIMpeg2Demultiplexer -> QueryInterface (
                    IID_IBaseFilter,
                    (void **) & pIBaseFilter
                    ) ;
        GOTO_NE (hr, S_OK, cleanup) ;

        ASSERT (pIBaseFilter) ;
        hr = pIBaseFilter -> EnumPins (
                                    & pIEnumPins
                                    ) ;
        GOTO_NE (hr, S_OK, cleanup) ;

        //  clear out the existing list
        hr = TearDownPinList_ () ;
        GOTO_NE (hr, S_OK, cleanup) ;

        ASSERT (pIEnumPins) ;
        for (;;) {
            hr = pIEnumPins -> Next (1, & pIPin, & cFetched) ;

            if (FAILED (hr)     ||
                hr == S_FALSE   ||
                cFetched == 0) {

                //  yuck ! set this to the lowest common denominator
                hr = hr == S_FALSE ? S_OK : hr ;
                pIPin = NULL ;

                break ;
            }

            ASSERT (pIPin) ;

            ZeroMemory (& PinInfo, sizeof PinInfo) ;

            //  retrieve our pin information
            hr = pIPin -> QueryPinInfo (
                                & PinInfo
                                ) ;
            GOTO_NE (hr, S_OK, cleanup) ;

            //  this assert checks that things are setup properly in the
            //  filter code
            ASSERT (PinInfo.pFilter == pIBaseFilter) ;

            //  we only care about output pins
            if (PinInfo.dir == PINDIR_OUTPUT) {

                //  populate the list view

                row = OutputPins.InsertRowTextW (PinInfo.achName, 0) ;

                //  if we succeeded, stash off the pIPin interface pointer in
                //  the listview, otherwise release it
                if (row != -1) {
                    pIPin -> AddRef () ;
                    OutputPins.SetData ((DWORD_PTR) pIPin, row) ;
                }
            }

            RELEASE_AND_CLEAR (pIPin) ;
            RELEASE_AND_CLEAR (PinInfo.pFilter) ;
        }
    }

    cleanup :

    RELEASE_AND_CLEAR (pIBaseFilter) ;
    RELEASE_AND_CLEAR (pIEnumPins) ;
    RELEASE_AND_CLEAR (PinInfo.pFilter) ;
    RELEASE_AND_CLEAR (pIPin) ;

    return hr ;
}

HRESULT
CMPEG2PropOutputPins::TearDownPinList_ (
    )
{
    CListview   OutputPins (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    IPin *      pIPin ;

    if (m_hwnd) {
        //  walk the list view, retrieving the IPin interface
        //  pointers and releasing them; we delete the rows at
        //  the same time, so always grab the 0th row
        while (OutputPins.GetItemCount () > 0) {

            pIPin = (IPin *) OutputPins.GetData (0) ;
            if (pIPin) {
                pIPin -> Release () ;
            }
            else {
                //  prefix bugfix
                return E_FAIL ;
            }

            if (!OutputPins.DeleteRow (0)) {
                return E_FAIL ;
            }
        }
    }

    return S_OK ;
}

HRESULT
CMPEG2PropOutputPins::PopulateComboBoxes_ (
    )
{
    CCombobox   PinType                 (m_hwnd, IDC_MPG2SPLT_PIN_TYPE) ;
    int         row ;
    int         i ;
    WCHAR       ach [32] ;

    if  (m_hwnd) {
        //  pin types
        for (i = 0; i < NUM_CANNED_TYPE; i++) {
            row = PinType.AppendW (g_CannedType [i].szDescription) ;
            if (row != CB_ERR) {

                //  i corresponds to the canned type enumeration and is used
                //  used later to index into the g_CannedType array to retrieve
                //  pin type information
                PinType.SetItemData (i, row) ;
            }
        }
        PinType.Focus (0) ;
    }

    return S_OK ;
}

HRESULT
CMPEG2PropOutputPins::OnCreatePin_ (
    )
{
    CCombobox       PinType     (m_hwnd, IDC_MPG2SPLT_PIN_TYPE) ;
    CListview       OutputPins  (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    CEditControl    PinName     (m_hwnd, IDC_MPG2SPLT_PIN_NAME) ;
    HRESULT         hr ;
    AM_MEDIA_TYPE   MediaType = {0} ;
    int             r ;
    DWORD           dw ;
    WCHAR           pszPinID [128] ;    //  128 = size of achName array in PIN_INFO
    DWORD_PTR       iCannedType ;
    DWORD_PTR       dwp ;
    IPin *          pIPin ;

    ASSERT (m_hwnd) ;

    hr = E_FAIL ;

    if (m_pIMpeg2Demultiplexer) {

        dwp = PinType.GetCurrentItemData (& iCannedType) ;
        if (dwp == CB_ERR) {
            return E_FAIL ;
        }

        ASSERT (iCannedType < NUM_CANNED_TYPE) ;

        //  setup the media type
        MediaType.majortype         = * g_CannedType [iCannedType].MediaType.pMajorType ;
        MediaType.subtype           = * g_CannedType [iCannedType].MediaType.pSubType ;
        MediaType.bFixedSizeSamples =   g_CannedType [iCannedType].MediaType.bFixedSizeSamples ;
        MediaType.formattype        = * g_CannedType [iCannedType].MediaType.pFormatType ;
        MediaType.cbFormat          =   g_CannedType [iCannedType].MediaType.cbFormat ;
        MediaType.pbFormat          =   g_CannedType [iCannedType].MediaType.pbFormat ;

        //  get the pin name
        PinName.GetTextW (pszPinID, 128) ;

        hr = m_pIMpeg2Demultiplexer -> CreateOutputPin (
                    & MediaType,
                    pszPinID,
                    & pIPin
                    ) ;

        if (SUCCEEDED (hr)) {
            ASSERT (pIPin) ;
            pIPin -> Release () ;
        }
        else {
            return hr ;
        }

        //  finally, we update the pin list in the properties
        hr = RefreshPinList_ () ;
    }

    return hr ;
}

void
CMPEG2PropOutputPins::SetDirty_ (
    IN  BOOL    fDirty
    )
{
    m_bDirty = fDirty ;

    if (m_pPageSite) {
        m_pPageSite -> OnStatusChange (fDirty ? PROPPAGESTATUS_DIRTY : PROPPAGESTATUS_CLEAN) ;
    }

}

//  always called after WM_INITDIALOG so we have a valid hwnd
HRESULT
CMPEG2PropOutputPins::OnActivate (
    )
{
    CListview   OutputPins (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    HRESULT     hr ;

    if (m_hwnd) {
        //  create the columns
        for (int i = 0; i < PIN_COL_COUNT; i++) {
            OutputPins.InsertColumnW (
                            g_OutputPinColumns [i].szTitle,
                            g_OutputPinColumns [i].dwWidth,
                            i
                            ) ;
        }


        hr = RefreshPinList_ () ;
        if (FAILED (hr)) {
            return hr ;
        }

        return PopulateComboBoxes_ () ;
    }

    return E_FAIL ;
}

HRESULT
CMPEG2PropOutputPins::OnDeactivate (
    )
{
    return S_OK ;
}

HRESULT
CMPEG2PropOutputPins::OnApplyChanges (
    )
{
    ASSERT (m_hwnd) ;
    return S_OK ;
}

HRESULT
CMPEG2PropOutputPins::OnConnect (
    IN  IUnknown *  pIUnknown
    )
{
    HRESULT hr ;

    ASSERT (pIUnknown) ;

    hr = pIUnknown -> QueryInterface (
                            IID_IMpeg2Demultiplexer,
                            (void **) & m_pIMpeg2Demultiplexer
                            ) ;

    return hr ;
}

HRESULT
CMPEG2PropOutputPins::OnDisconnect (
    )
{
    RELEASE_AND_CLEAR (m_pIMpeg2Demultiplexer) ;
    return S_OK ;
}

HRESULT
CMPEG2PropOutputPins::OnDeletePin_ (
    )
{
    CListview   Pins (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    int         iRow ;
    WCHAR       achPinName [128] ;          //  128 from PIN_INFO.achName
    HRESULT     hr ;

    iRow = Pins.GetSelectedRow () ;
    if (iRow == -1) {
        MessageBoxError (TEXT ("Output Pin Deletion"), TEXT ("No pin is selected.")) ;
        return E_FAIL ;
    }

    //  now the Pin name
    achPinName [0] = L'\0' ;
    Pins.GetRowTextW (iRow, 0, 128, achPinName) ;

    ASSERT (wcslen (achPinName) > 0) ;
    ASSERT (m_pIMpeg2Demultiplexer) ;

    hr = m_pIMpeg2Demultiplexer -> DeleteOutputPin (achPinName) ;

    if (SUCCEEDED (hr)) {
        hr = RefreshPinList_ () ;
    }
    else {
        MessageBoxError (TEXT (""), TEXT ("failed to delete selected output pin; hr = %08xh"), hr) ;
    }

    return hr ;
}

INT_PTR
CMPEG2PropOutputPins::OnReceiveMessage (
    IN  HWND    hwnd,
    IN  UINT    uMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            ASSERT (m_hwnd == NULL) ;
            m_hwnd = hwnd ;
            return TRUE ;
        }

        case WM_DESTROY :
        {
            TearDownPinList_ () ;
            m_hwnd = NULL ;
            break ;
        }

        case WM_COMMAND:
        {
            switch (LOWORD (wParam)) {
                case IDC_MPG2SPLT_CREATE_PIN :
                    OnCreatePin_ () ;
                    break ;

                case IDC_MPG2SPLT_PIN_TYPE :

                    switch (HIWORD (wParam)) {

                        case CBN_SELCHANGE :
                            break ;
                    } ;
                    break ;

                //case EN_CHANGE :
                //    SetDirty () ;

                case IDC_MPG2SPLT_DELETE_PIN :
                    OnDeletePin_ () ;
                    break ;
            } ;

            return TRUE ;
        }

    }
    return CBasePropertyPage::OnReceiveMessage (
                                hwnd,
                                uMsg,
                                wParam,
                                lParam
                                ) ;
}

//  static
CUnknown *
WINAPI
CMPEG2PropOutputPins::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   pHr
    )
{
    CMPEG2PropOutputPins *  pProp ;

    pProp = new CMPEG2PropOutputPins (
                        NAME ("CMPEG2PropOutputPins"),
                        pIUnknown,
                        CLSID_MPEG2DemuxPropOutputPins,
                        pHr
                        ) ;

    if (pProp == NULL) {
        * pHr = E_OUTOFMEMORY ;
    }

    return pProp ;
}

//  ---------------------------------------------------------------------------
//      CMpeg2PropStreamMap
//  ---------------------------------------------------------------------------

CMpeg2PropStreamMap::CMpeg2PropStreamMap (
    IN  TCHAR *     pClassName,
    IN  IUnknown *  pIUnknown,
    IN  REFCLSID    rclsid,
    IN  int         iTitleStringResource,
    OUT HRESULT *   pHr
    ) : CBasePropertyPage (
            pClassName,
            pIUnknown,
            IDD_MPG2SPLT_PROP_STREAM_MAP,
            iTitleStringResource
            ),
        m_hwnd          (NULL),
        m_pIUnknown     (NULL)
{
    * pHr = S_OK ;
}

HRESULT
CMpeg2PropStreamMap::TearDownPinList_ (
    )
{
    CCombobox   OutputPins (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    IPin *      pIPin ;

    if (m_hwnd) {
        //  walk the list view, retrieving the IPin interface
        //  pointers and releasing them; we delete the rows at
        //  the same time, so always grab the 0th row
        while (OutputPins.GetItemCount () > 0) {

            OutputPins.GetItemData ((DWORD_PTR *) & pIPin, 0) ;
            ASSERT (pIPin) ;
            pIPin -> Release () ;

            if (!OutputPins.DeleteRow (0)) {
                return E_FAIL ;
            }
        }
    }

    return S_OK ;
}

HRESULT
CMpeg2PropStreamMap::PopulatePinList_ (
    )
{
    CCombobox       OutputPins (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    ULONG           cFetched ;
    IBaseFilter *   pIBaseFilter ;
    IEnumPins *     pIEnumPins ;
    IPin *          pIPin ;
    HRESULT         hr ;
    PIN_INFO        PinInfo ;
    int             row ;
    int             i ;

    hr = S_OK ;

    pIBaseFilter    = NULL ;
    pIEnumPins      = NULL ;
    pIPin           = NULL ;
    PinInfo.pFilter = NULL ;

    if (m_pIUnknown) {

        ASSERT (m_hwnd) ;

        //  obtain our pin enumeration interface
        hr = m_pIUnknown -> QueryInterface (
                                    IID_IBaseFilter,
                                    (void **) & pIBaseFilter
                                    ) ;
        GOTO_NE (hr, S_OK, cleanup) ;

        ASSERT (pIBaseFilter) ;
        hr = pIBaseFilter -> EnumPins (
                                    & pIEnumPins
                                    ) ;
        GOTO_NE (hr, S_OK, cleanup) ;

        ASSERT (pIEnumPins) ;
        for (;;) {
            hr = pIEnumPins -> Next (1, & pIPin, & cFetched) ;

            if (FAILED (hr)     ||
                hr == S_FALSE   ||
                cFetched == 0) {

                //  yuck !
                hr = hr == S_FALSE ? S_OK : hr ;
                pIPin = NULL ;

                break ;
            }

            ASSERT (pIPin) ;

            ZeroMemory (& PinInfo, sizeof PinInfo) ;

            //  retrieve our pin information
            hr = pIPin -> QueryPinInfo (
                                & PinInfo
                                ) ;
            GOTO_NE (hr, S_OK, cleanup) ;

            //  this assert checks that things are setup properly in the
            //  filter code
            ASSERT (PinInfo.pFilter == pIBaseFilter) ;

            //  we only care about output pins
            if (PinInfo.dir == PINDIR_OUTPUT) {

                //  populate the combo box
                row = OutputPins.AppendW (PinInfo.achName) ;

                //  associate the pin interface
                if (row == CB_ERR) {
                    RELEASE_AND_CLEAR (pIPin) ;
                    RELEASE_AND_CLEAR (PinInfo.pFilter) ;

                    //  break if there was an error
                    break ;
                }

                //  store the pin's interface
                i = OutputPins.SetItemData ((DWORD_PTR) pIPin, row) ;
                if (i == CB_ERR) {
                    //  delete the row (does not contain a valid tuple)
                    OutputPins.DeleteRow (row) ;

                    RELEASE_AND_CLEAR (pIPin) ;
                    RELEASE_AND_CLEAR (PinInfo.pFilter) ;

                    //  break if there was an error
                    break ;
                }
            }
            else {
                //  input pin is not stashed
                RELEASE_AND_CLEAR (pIPin) ;
            }

            RELEASE_AND_CLEAR (PinInfo.pFilter) ;
        }

        OutputPins.Focus (0) ;
    }

    cleanup :

    RELEASE_AND_CLEAR (pIBaseFilter) ;
    RELEASE_AND_CLEAR (pIEnumPins) ;
    RELEASE_AND_CLEAR (PinInfo.pFilter) ;
    RELEASE_AND_CLEAR (pIPin) ;

    return hr ;
}

void
CMpeg2PropStreamMap::SetDirty (
    IN  BOOL    fDirty
    )
{
    m_bDirty = fDirty ;

    if (m_pPageSite) {
        m_pPageSite -> OnStatusChange (fDirty ? PROPPAGESTATUS_DIRTY : PROPPAGESTATUS_CLEAN) ;
    }

}

//  always called after WM_INITDIALOG so we have a valid hwnd
HRESULT
CMpeg2PropStreamMap::OnActivate (
    )
{
    HRESULT     hr ;
    CListview   StreamMap (m_hwnd, IDC_MPG2SPLT_STREAM_MAPPINGS) ;
    int         iColumnCount ;

    hr = E_FAIL ;

    if (m_hwnd) {

        iColumnCount = GetStreamMapColCount () ;

        //  stream map table
        for (int i = 0 ; i < iColumnCount ; i++) {
            StreamMap.InsertColumnW (
                            GetStreamMapColTitle (i),
                            GetStreamMapColWidth (i),
                            i
                            ) ;
        }

        //  pin list
        hr = PopulatePinList_ () ;
        if (FAILED (hr)) {
            return hr ;
        }

        //  possible streams list
        hr = PopulateStreamList_ () ;
        if (FAILED (hr)) {
            return hr ;
        }

        //  media sample content list
        hr = PopulateMediaSampleContentList_ () ;
        if (FAILED (hr)) {
            return hr ;
        }

        RefreshStreamMap_ () ;
    }

    return hr ;
}

HRESULT
CMpeg2PropStreamMap::OnDeactivate (
    )
/*++
    don't do the opposite of ::OnActivate() here because this method
    is not always called.  This method is only called when the property
    page is tabbed away.  It's not called when the user destroys the
    window.  Since we refcount IPin in ::OnActivate() (when we store it
    in a list), depending on this method to be called and Release'ing
    those refcounts doesn't work.  Instead, we tear down the pin list
    and Release each pin when a WM_DESTROY message is posted to the
    wndproc.  This happens when the user tabs away and when the property
    page is destroyed.
--*/
{
    return S_OK ;
}

HRESULT
CMpeg2PropStreamMap::OnApplyChanges (
    )
{
    ASSERT (m_hwnd) ;
    return S_OK ;
}

HRESULT
CMpeg2PropStreamMap::OnConnect (
    IN  IUnknown *  pIUnknown
    )
{
    ASSERT (pIUnknown) ;

    m_pIUnknown = pIUnknown ;

    //  our ref
    m_pIUnknown -> AddRef () ;

    return S_OK ;
}

HRESULT
CMpeg2PropStreamMap::OnDisconnect (
    )
{
    RELEASE_AND_CLEAR (m_pIUnknown) ;
    return S_OK ;
}

HRESULT
CMpeg2PropStreamMap::RefreshStreamMap_ (
    )
{
    CListview       StreamMap (m_hwnd, IDC_MPG2SPLT_STREAM_MAPPINGS) ;
    CCombobox       OutputPins (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    IPin *          pIPin ;
    HRESULT         hr ;
    DWORD           dwPinCount ;
    DWORD           i ;

    hr = S_OK ;

    if (m_hwnd) {

        TearDownStreamMap_ () ;

        dwPinCount = OutputPins.GetItemCount () ;
        for (i = 0; i < dwPinCount && SUCCEEDED (hr); i++) {

            OutputPins.GetItemData ((DWORD_PTR *) & pIPin, i) ;
            ASSERT (pIPin) ;

            hr = AppendStreamMaps (pIPin, & StreamMap) ;
        }
    }

    return hr ;
}

INT_PTR
CMpeg2PropStreamMap::OnReceiveMessage (
    IN  HWND    hwnd,
    IN  UINT    uMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            ASSERT (m_hwnd == NULL) ;
            m_hwnd = hwnd ;
            DialogInit_ () ;
            return TRUE ;
        }

        //  see ::OnDeactivate()'s comment block
        case WM_DESTROY :
        {
            TearDownPinList_ () ;
            TearDownStreamMap_ () ;
            m_hwnd = NULL ;
            break ;
        }

        case WM_COMMAND:
        {
            switch (LOWORD (wParam)) {
                case IDC_MPG2SPLT_MAP_STREAM :
                    OnMapStream_ () ;
                    break ;

                case IDC_MPG2SPLT_UNMAP_STREAM :
                    OnUnmapStream_ () ;
                    break ;
            } ;

            return TRUE ;
        }

    }
    return CBasePropertyPage::OnReceiveMessage (
                                hwnd,
                                uMsg,
                                wParam,
                                lParam
                                ) ;
}

//  ---------------------------------------------------------------------------
//      CMPEG2PropPIDMap
//  ---------------------------------------------------------------------------

CMPEG2PropPIDMap::CMPEG2PropPIDMap (
    IN  TCHAR *     pClassName,
    IN  IUnknown *  pIUnknown,
    IN  REFCLSID    rclsid,
    OUT HRESULT *   pHr
    ) : CMpeg2PropStreamMap (
            pClassName,
            pIUnknown,
            rclsid,
            IDS_MPG2SPLT_PROP_PID_MAP_TITLE,
            pHr
            ) {}

void
CMPEG2PropPIDMap::DialogInit_ (
    )
{
    SetWindowText (GetDlgItem (m_hwnd, IDC_MPG2SPLT_STREAMID_NAME), g_szPID) ;
}

HRESULT
CMPEG2PropPIDMap::PopulateStreamList_ (
    )
{
    HRESULT     hr ;
    CCombobox   PIDList (m_hwnd, IDC_MPG2SPLT_STREAMS) ;
    int         i ;
    int         row ;
    WCHAR       achbuffer [32] ;

    //  populate the PID list
    for (i = 0; i <= MAX_PID_VALUE; i++) {
        swprintf (achbuffer, L"0x%04x", i) ;
        row = PIDList.AppendW (achbuffer) ;
        if (row != CB_ERR) {
            PIDList.SetItemData (i, row) ;
        }
    }
    PIDList.Focus (0) ;

    return S_OK ;
}

HRESULT
CMPEG2PropPIDMap::TearDownStreamMap_ (
    )
{
    CListview   PIDMap (m_hwnd, IDC_MPG2SPLT_STREAM_MAPPINGS) ;
    int         i ;
    int         iPIDMapCount ;
    IPin *      pIPin ;

    iPIDMapCount = PIDMap.GetItemCount () ;

    for (i = 0; i < iPIDMapCount; i++) {
        pIPin = reinterpret_cast <IPin *> (PIDMap.GetData (i)) ;
        ASSERT (pIPin) ;
        pIPin -> Release () ;
    }

    PIDMap.ResetContent () ;

    return S_OK ;
}

HRESULT
CMPEG2PropPIDMap::AppendStreamMaps (
    IN  IPin *      pIPin,
    IN  CListview * plv
    )
{
    IEnumPIDMap *   pIEnumPIDMap ;
    HRESULT         hr ;
    IMPEG2PIDMap *  pIPinPIDMap ;
    OLECHAR *       pszPinID ;
    WCHAR           achbuffer [32] ;
    int             row ;
    PID_MAP         PIDMap ;
    DWORD           dwGot ;

    hr = pIPin -> QueryInterface (
            IID_IMPEG2PIDMap,
            (void **) & pIPinPIDMap
            ) ;
    if (SUCCEEDED (hr)) {
        hr = pIPinPIDMap -> EnumPIDMap (
                & pIEnumPIDMap
                ) ;

        if (SUCCEEDED (hr)) {
            hr = pIPin -> QueryId (& pszPinID) ;

            if (SUCCEEDED (hr)) {

                for (;;) {
                    hr = pIEnumPIDMap -> Next (
                            1,
                            & PIDMap,
                            & dwGot
                            ) ;
                    if (hr == S_FALSE ||
                        dwGot == 0) {

                        //  not a true failure of the call
                        hr = S_OK ;
                        break ;
                    }

                    if (FAILED (hr)) {
                        //  true failure
                        break ;
                    }

                    row = plv -> InsertRowValue (
                            reinterpret_cast <DWORD_PTR> (pIPin)
                            ) ;
                    if (row == -1) {
                        hr = E_FAIL ;
                        break ;
                    }

                    //  listview's ref
                    pIPin -> AddRef () ;

                    //  PID
                    swprintf (achbuffer, L"0x%04x", PIDMap.ulPID) ;
                    plv -> SetTextW (
                        achbuffer,
                        row,
                        PID_COL_PID
                        ) ;

                    //  pin
                    plv -> SetTextW (
                        pszPinID,
                        row,
                        PIN_COL_PID
                        ) ;

                    //  PID map content
                    ASSERT (PIDMap.MediaSampleContent <= MEDIA_TRANSPORT_PAYLOAD) ;
                    plv -> SetTextW (
                        g_TransportMediaSampleContentDesc [PIDMap.MediaSampleContent].pszDescription,
                        row,
                        MEDIA_SAMPLE_CONTENT_PID
                        ) ;
                }

                CoTaskMemFree (pszPinID) ;
            }

            pIEnumPIDMap -> Release () ;
        }

        pIPinPIDMap -> Release () ;
    }

    return hr ;
}

HRESULT
CMPEG2PropPIDMap::OnMapStream_ (
    )
{
    HRESULT                 hr ;
    CCombobox               PID             (m_hwnd, IDC_MPG2SPLT_STREAMS) ;
    CCombobox               MediaContent    (m_hwnd, IDC_MPG2SPLT_MEDIA_SAMPLE_CONTENT) ;
    CCombobox               OutputPins      (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    DWORD                   dwPID ;
    WCHAR                   achPin [128] ;              //  128 is PIN_INFO.achName length
    MEDIA_SAMPLE_CONTENT    MediaSampleContent ;
    DWORD_PTR               dwptr ;
    IMPEG2PIDMap *          pIMpeg2PIDMap ;
    IPin *                  pIPin ;

    //  gather the data

    MediaContent.GetCurrentItemData (& dwptr) ;
    MediaSampleContent = (MEDIA_SAMPLE_CONTENT) dwptr ;        //  safe cast

    PID.GetCurrentItemData (& dwptr) ;
    dwPID = (DWORD) dwptr ;                                 //  safe cast

    OutputPins.GetCurrentItemData (& dwptr) ;
    if (dwptr == CB_ERR) {
        return E_FAIL ;
    }

    pIPin = reinterpret_cast <IPin *> (dwptr) ;
    ASSERT (pIPin) ;

    hr = pIPin -> QueryInterface (
            IID_IMPEG2PIDMap,
            (void **) & pIMpeg2PIDMap
            ) ;
    if (SUCCEEDED (hr)) {
        hr = pIMpeg2PIDMap -> MapPID (
                1,
                & dwPID,
                MediaSampleContent
                ) ;

        pIMpeg2PIDMap -> Release () ;
    }

    if (SUCCEEDED (hr)) {
        RefreshStreamMap_ () ;
    }
    else {
        MessageBoxError (TEXT("PID Map"), TEXT("Could not map PID %04x; %08xh"), dwPID, hr) ;
    }

    return hr ;
}

HRESULT
CMPEG2PropPIDMap::OnUnmapStream_ (
    )
{
    HRESULT         hr ;
    CListview       PIDMaps (m_hwnd, IDC_MPG2SPLT_STREAM_MAPPINGS) ;
    DWORD           dwPID ;
    int             iRow ;
    WCHAR           achPinName [128] ;      //  128 from PIN_INFO.achName
    IMPEG2PIDMap *  pIMpeg2PIDMap ;
    IPin *          pIPin ;
    WCHAR           achbuffer [32] ;

    iRow = PIDMaps.GetSelectedRow () ;
    if (iRow == -1) {
        MessageBoxError (TEXT ("PID Map Deletion"), TEXT ("No PID mapping is selected.")) ;
        return E_FAIL ;
    }

    //  get the PID
    achbuffer [0] = L'\0' ;
    if (PIDMaps.GetRowTextW (iRow, PID_COL_PID, 32, achbuffer) > 0) {
        if (swscanf (achbuffer, L"0x%04x", & dwPID) == 0) {
            //  PREFIX fix
            return E_FAIL ;
        }
    }
    else {
        //  prefix bugfix
        return E_FAIL ;
    }

    //  dwPID now contains a valid PID

    //  and the pin to which it is mapped
    pIPin = reinterpret_cast <IPin *> (PIDMaps.GetData (iRow)) ;
    ASSERT (pIPin) ;

    //  the interface we're going to use
    hr = pIPin -> QueryInterface (
            IID_IMPEG2PIDMap,
            (void **) & pIMpeg2PIDMap
            ) ;
    if (SUCCEEDED (hr)) {
        //  unmap
        hr = pIMpeg2PIDMap -> UnmapPID (
                1,
                & dwPID
                ) ;

        pIMpeg2PIDMap -> Release () ;
    }

    if (SUCCEEDED (hr)) {
        RefreshStreamMap_ () ;
    }
    else {
        MessageBoxError (TEXT("PID Unmap"), TEXT("Could not unmap PID %04x; %08xh"), dwPID, hr) ;
    }

    return hr ;
}

WCHAR *
CMPEG2PropPIDMap::GetStreamMapColTitle (
    IN  int iCol
    )
{
    return g_PIDMapColumns [iCol].szTitle ;
}

int
CMPEG2PropPIDMap::GetStreamMapColCount (
    )
{
    return PID_PIN_COL_COUNT ;
}

int
CMPEG2PropPIDMap::GetStreamMapColWidth (
    IN  int iCol
    )
{
    return g_PIDMapColumns [iCol].dwWidth ;
}

HRESULT
CMPEG2PropPIDMap::PopulateMediaSampleContentList_ (
    )
{
    HRESULT     hr ;
    CCombobox   MediaSampleContent  (m_hwnd, IDC_MPG2SPLT_MEDIA_SAMPLE_CONTENT) ;
    int         row ;
    int         k, i ;
    WCHAR       achbuffer [32] ;

    //  populate the media sample content choices
    k = sizeof g_TransportMediaSampleContentDesc / sizeof MEDIA_SAMPLE_CONTENT_DESC ;
    for (i = 0; i < k; i++) {
        row = MediaSampleContent.AppendW (g_TransportMediaSampleContentDesc [i].pszDescription) ;
        if (row != CB_ERR) {
            MediaSampleContent.SetItemData (g_TransportMediaSampleContentDesc [i].MediaSampleContent, row) ;
        }
        else {
            return E_FAIL ;
        }
    }
    MediaSampleContent.Focus (0) ;

    return S_OK ;
}

//  static
CUnknown *
WINAPI
CMPEG2PropPIDMap::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   pHr
    )
{
    CMpeg2PropStreamMap *  pProp ;

    pProp = new CMPEG2PropPIDMap (
                        NAME ("CMPEG2PropPIDMap"),
                        pIUnknown,
                        CLSID_MPEG2DemuxPropPIDMap,
                        pHr
                        ) ;

    if (pProp == NULL) {
        * pHr = E_OUTOFMEMORY ;
    }

    return pProp ;
}

//  ---------------------------------------------------------------------------
//      CMPEG2PropStreamIdMap
//  ---------------------------------------------------------------------------

CMPEG2PropStreamIdMap::CMPEG2PropStreamIdMap (
    IN  TCHAR *     pClassName,
    IN  IUnknown *  pIUnknown,
    IN  REFCLSID    rclsid,
    OUT HRESULT *   pHr
    ) : CMpeg2PropStreamMap (
            pClassName,
            pIUnknown,
            rclsid,
            IDS_MPG2SPLT_PROP_STREAMID_MAP_TITLE,
            pHr
            ) {}

void
CMPEG2PropStreamIdMap::DialogInit_ (
    )
{
    int         i, k ;
    WCHAR       achbuffer [32] ;
    CCombobox   DataOffset (m_hwnd, IDC_MPG2SPLT_DATA_OFFSET) ;
    CCombobox   FilterValue (m_hwnd, IDC_MPG2SPLT_FILTER_VALUE) ;
    int         row, rowDefault ;

    SetWindowText (GetDlgItem (m_hwnd, IDC_MPG2SPLT_STREAMID_NAME), g_szStreamId) ;

    ShowWindow (GetDlgItem (m_hwnd, IDC_MPG2SPLT_FILTER_VALUE),          SW_SHOW) ;
    ShowWindow (GetDlgItem (m_hwnd, IDC_MPG2SPLT_FILTER_VALUE_LABEL),    SW_SHOW) ;
    ShowWindow (GetDlgItem (m_hwnd, IDC_MPG2SPLT_DATA_OFFSET),           SW_SHOW) ;
    ShowWindow (GetDlgItem (m_hwnd, IDC_MPG2SPLT_DATA_OFFSET_LABEL),     SW_SHOW) ;
    ShowWindow (GetDlgItem (m_hwnd, IDC_MPG2SPLT_SUBSTREAM_FRAME),       SW_SHOW) ;

    //  populate the controls as well
    for (i = 0; i < 11; i++) {
        swprintf (achbuffer, L"%d", i) ;
        row = DataOffset.AppendW (achbuffer) ;
        if (row != CB_ERR) {
            DataOffset.SetItemData (i, row) ;
        }
    }
    DataOffset.Focus (0) ;

    //  filter value

    swprintf (achbuffer, L"none") ;
    rowDefault = FilterValue.AppendW (achbuffer) ;
    if (rowDefault != CB_ERR) {
        FilterValue.SetItemData (SUBSTREAM_FILTER_VAL_NONE, rowDefault) ;
    }

    for (k = 0; k < 8; k++) {
        swprintf (achbuffer, L"0x%02x", 0x80 + k) ;
        row = FilterValue.AppendW (achbuffer) ;
        if (row != CB_ERR) {
            FilterValue.SetItemData (0x80 + k, row) ;
        }
    }
    FilterValue.Focus (rowDefault) ;
}

HRESULT
CMPEG2PropStreamIdMap::PopulateStreamList_ (
    )
{
    HRESULT     hr ;
    CCombobox   StreamIdList (m_hwnd, IDC_MPG2SPLT_STREAMS) ;
    int         i ;
    int         row ;
    WCHAR       achbuffer [32] ;

    //  populate the PID list
    for (i = STREAM_ID_MIN; i <= STREAM_ID_MAX; i++) {
        swprintf (achbuffer, L"0x%02X", i) ;
        row = StreamIdList.AppendW (achbuffer) ;
        if (row != CB_ERR) {
            StreamIdList.SetItemData (i, row) ;
        }
    }
    StreamIdList.Focus (0) ;

    return S_OK ;
}

HRESULT
CMPEG2PropStreamIdMap::TearDownStreamMap_ (
    )
{
    CListview   StreamMap (m_hwnd, IDC_MPG2SPLT_STREAM_MAPPINGS) ;
    int         i ;
    int         iStreamMapCount ;
    IPin *      pIPin ;

    iStreamMapCount = StreamMap.GetItemCount () ;

    for (i = 0; i < iStreamMapCount; i++) {
        pIPin = reinterpret_cast <IPin *> (StreamMap.GetData (i)) ;
        ASSERT (pIPin) ;
        pIPin -> Release () ;
    }

    StreamMap.ResetContent () ;

    return S_OK ;
}

HRESULT
CMPEG2PropStreamIdMap::AppendStreamMaps (
    IN  IPin *      pIPin,
    IN  CListview * plv
    )
{
    IEnumStreamIdMap *  pIEnumStreamIdMap ;
    HRESULT             hr ;
    IMPEG2StreamIdMap * pIPinStreamIdMap ;
    OLECHAR *           pszPinID ;
    WCHAR               achbuffer [32] ;
    int                 row ;
    STREAM_ID_MAP       StreamIdMap ;
    DWORD               dwGot ;

    //  media sample content is used as a 0-based index, so we assume the
    //  first is 0
    ASSERT (MPEG2_PROGRAM_STREAM_MAP == 0) ;

    hr = pIPin -> QueryInterface (
            IID_IMPEG2StreamIdMap,
            (void **) & pIPinStreamIdMap
            ) ;
    if (SUCCEEDED (hr)) {
        hr = pIPinStreamIdMap -> EnumStreamIdMap (
                & pIEnumStreamIdMap
                ) ;

        if (SUCCEEDED (hr)) {
            hr = pIPin -> QueryId (& pszPinID) ;

            if (SUCCEEDED (hr)) {

                for (;;) {
                    hr = pIEnumStreamIdMap -> Next (
                            1,
                            & StreamIdMap,
                            & dwGot
                            ) ;
                    if (hr == S_FALSE ||
                        dwGot == 0) {

                        //  not a true failure of the call
                        hr = S_OK ;
                        break ;
                    }

                    if (FAILED (hr)) {
                        //  true failure
                        break ;
                    }

                    row = plv -> InsertRowValue (
                            reinterpret_cast <DWORD_PTR> (pIPin)
                            ) ;
                    if (row == -1) {
                        hr = E_FAIL ;
                        break ;
                    }

                    //  listview's ref
                    pIPin -> AddRef () ;

                    //  stream_id
                    swprintf (achbuffer, L"0x%02X", StreamIdMap.stream_id) ;
                    plv -> SetTextW (
                        achbuffer,
                        row,
                        STREAM_ID_COL_STREAM
                        ) ;

                    //  pin
                    plv -> SetTextW (
                        pszPinID,
                        row,
                        PIN_COL_STREAM
                        ) ;

                    //  stream id map content
                    ASSERT (StreamIdMap.dwMediaSampleContent <= MPEG2_PROGRAM_ELEMENTARY_STREAM) ;
                    plv -> SetTextW (
                        g_ProgramMediaSampleContentDesc [StreamIdMap.dwMediaSampleContent].pszDescription,
                        row,
                        MEDIA_SAMPLE_CONTENT_STREAM
                        ) ;

                    //  filter

                    if (StreamIdMap.ulSubstreamFilterValue != SUBSTREAM_FILTER_VAL_NONE) {
                        swprintf (achbuffer, L"0x%02x", StreamIdMap.ulSubstreamFilterValue) ;
                    }
                    else {
                        swprintf (achbuffer, L"none") ;
                    }

                    plv -> SetTextW (
                        achbuffer,
                        row,
                        FILTER_COL_STREAM
                        ) ;

                    //  offset

                    swprintf (achbuffer, L"%d", StreamIdMap.iDataOffset) ;
                    plv -> SetTextW (
                        achbuffer,
                        row,
                        OFFSET_COL_STREAM
                        ) ;
                }

                CoTaskMemFree (pszPinID) ;
            }

            pIEnumStreamIdMap -> Release () ;
        }

        pIPinStreamIdMap -> Release () ;
    }

    return hr ;
}

HRESULT
CMPEG2PropStreamIdMap::OnMapStream_ (
    )
{
    HRESULT             hr ;
    CCombobox           StreamId        (m_hwnd, IDC_MPG2SPLT_STREAMS) ;
    CCombobox           MediaContent    (m_hwnd, IDC_MPG2SPLT_MEDIA_SAMPLE_CONTENT) ;
    CCombobox           OutputPins      (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    CCombobox           DataOffset      (m_hwnd, IDC_MPG2SPLT_DATA_OFFSET) ;
    CCombobox           FilterValue     (m_hwnd, IDC_MPG2SPLT_FILTER_VALUE) ;
    DWORD               dwStreamId ;
    WCHAR               achPin [128] ;              //  128 is PIN_INFO.achName length
    DWORD               MediaSampleContent ;
    DWORD_PTR           dwptr ;
    IMPEG2StreamIdMap * pIMpeg2StreamIdMap ;
    IPin *              pIPin ;
    DWORD               dwFilterVal ;
    int                 iDataOffset ;

    //  gather the data

    MediaContent.GetCurrentItemData (& dwptr) ;
    MediaSampleContent = (DWORD) dwptr ;     //  safe cast

    StreamId.GetCurrentItemData (& dwptr) ;
    dwStreamId = (DWORD) dwptr ;                                    //  safe cast

    OutputPins.GetCurrentItemData (& dwptr) ;
    if (dwptr == CB_ERR) {
        return E_FAIL ;
    }

    pIPin = reinterpret_cast <IPin *> (dwptr) ;
    ASSERT (pIPin) ;

    DataOffset.GetCurrentItemData (& dwptr) ;
    iDataOffset = (int) dwptr ;

    FilterValue.GetCurrentItemData (& dwptr) ;
    dwFilterVal = (DWORD) dwptr ;

    hr = pIPin -> QueryInterface (
            IID_IMPEG2StreamIdMap,
            (void **) & pIMpeg2StreamIdMap
            ) ;
    if (SUCCEEDED (hr)) {
        hr = pIMpeg2StreamIdMap -> MapStreamId (
                dwStreamId,
                MediaSampleContent,
                dwFilterVal,
                iDataOffset
                ) ;

        pIMpeg2StreamIdMap -> Release () ;
    }

    if (SUCCEEDED (hr)) {
        RefreshStreamMap_ () ;
    }
    else {
        MessageBoxError (TEXT("StreamId Map"), TEXT("Could not map stream_id %02x; %08xh"), dwStreamId, hr) ;
    }

    return hr ;
}

HRESULT
CMPEG2PropStreamIdMap::OnUnmapStream_ (
    )
{
    HRESULT             hr ;
    CListview           StreamMaps (m_hwnd, IDC_MPG2SPLT_STREAM_MAPPINGS) ;
    DWORD               dwStreamId ;
    int                 iRow ;
    WCHAR               achPinName [128] ;      //  128 from PIN_INFO.achName
    IMPEG2StreamIdMap * pIMpeg2StreamIdMap ;
    IPin *              pIPin ;
    WCHAR               achbuffer [32] ;

    iRow = StreamMaps.GetSelectedRow () ;
    if (iRow == -1) {
        MessageBoxError (TEXT ("Stream Map Deletion"), TEXT ("No stream mapping is selected.")) ;
        return E_FAIL ;
    }

    //  get the stream_id
    achbuffer [0] = L'\0' ;
    if (StreamMaps.GetRowTextW (iRow, STREAM_ID_COL_STREAM, 32, achbuffer) > 0) {
        if (swscanf (achbuffer, L"0x%04x", & dwStreamId) == 0) {
            //  PREFIX fix
            return E_FAIL ;
        }
    }
    else {
        //  PREFIX fix
        return E_FAIL ;
    }

    //  dwStreamId now contains a valid value

    //  and the pin to which it is mapped
    pIPin = reinterpret_cast <IPin *> (StreamMaps.GetData (iRow)) ;
    ASSERT (pIPin) ;

    //  the interface we're going to use
    hr = pIPin -> QueryInterface (
            IID_IMPEG2StreamIdMap,
            (void **) & pIMpeg2StreamIdMap
            ) ;
    if (SUCCEEDED (hr)) {
        //  unmap
        hr = pIMpeg2StreamIdMap -> UnmapStreamId (
                1,
                & dwStreamId
                ) ;

        pIMpeg2StreamIdMap -> Release () ;
    }

    if (SUCCEEDED (hr)) {
        RefreshStreamMap_ () ;
    }
    else {
        MessageBoxError (TEXT("PID Unmap"), TEXT("Could not unmap stream %04x; %08xh"), dwStreamId, hr) ;
    }

    return hr ;
}

int
CMPEG2PropStreamIdMap::GetStreamMapColCount (
    )
{
    return STREAM_ID_PIN_COL_COUNT ;
}


WCHAR *
CMPEG2PropStreamIdMap::GetStreamMapColTitle (
    IN  int iCol
    )
{
    return g_StreamIdMapColumns [iCol].szTitle ;
}

int
CMPEG2PropStreamIdMap::GetStreamMapColWidth (
    IN  int iCol
    )
{
    return g_StreamIdMapColumns [iCol].dwWidth ;
}

HRESULT
CMPEG2PropStreamIdMap::PopulateMediaSampleContentList_ (
    )
{
    HRESULT     hr ;
    CCombobox   MediaSampleContent  (m_hwnd, IDC_MPG2SPLT_MEDIA_SAMPLE_CONTENT) ;
    int         row ;
    int         k, i ;
    WCHAR       achbuffer [32] ;

    //  populate the media sample content choices
    k = sizeof g_ProgramMediaSampleContentDesc / sizeof MEDIA_SAMPLE_CONTENT_DESC ;
    for (i = 0; i < k; i++) {
        row = MediaSampleContent.AppendW (g_ProgramMediaSampleContentDesc [i].pszDescription) ;
        if (row != CB_ERR) {
            MediaSampleContent.SetItemData (g_ProgramMediaSampleContentDesc [i].MediaSampleContent, row) ;
        }
        else {
            return E_FAIL ;
        }
    }
    MediaSampleContent.Focus (0) ;

    return S_OK ;
}

//  static
CUnknown *
WINAPI
CMPEG2PropStreamIdMap::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   pHr
    )
{
    CMpeg2PropStreamMap *  pProp ;

    pProp = new CMPEG2PropStreamIdMap (
                        NAME ("CMPEG2PropStreamIdMap"),
                        pIUnknown,
                        CLSID_MPEG2DemuxPropStreamIdMap,
                        pHr
                        ) ;

    if (pProp == NULL) {
        * pHr = E_OUTOFMEMORY ;
    }

    return pProp ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\propsite.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
//
// Implementation of the CPropertySite class
//

#include "stdafx.h"

//
// CPropertySite Message Map
//

BEGIN_MESSAGE_MAP(CPropertySite, CPropertyPage)

    ON_WM_CREATE()
    ON_WM_DESTROY()

END_MESSAGE_MAP()


//
// Constructor
//
CPropertySite::CPropertySite
  (
    CVfWPropertySheet *pPropSheet,    // The class providing the frame dialog
    const CLSID *clsid         // CLSID of object providing IPropertyPage
  )
  : m_hrDirtyPage(S_FALSE)
  , m_fHelp(FALSE)
  , m_pPropSheet(pPropSheet)
  , m_pIPropPage(IID_IPropertyPage, *clsid)
  , m_cRef(0)
  , m_fShowHelp(FALSE)
  , m_fPageIsActive(FALSE)
  , m_CLSID(clsid)
  , CPropertyPage()
{
      ASSERT(pPropSheet);

      m_PropPageInfo.pszTitle = NULL;
      m_PropPageInfo.pszDocString = NULL;
      m_PropPageInfo.pszHelpFile = NULL;
}

// size in pixels
void CPropertySite::InitialiseSize(SIZE size)
{
    DLGTEMPLATE *pdt = (DLGTEMPLATE *)m_pbDlgTemplate;

    pdt->style           = WS_CHILD | WS_VISIBLE | WS_DISABLED | WS_CAPTION;
    pdt->dwExtendedStyle = 0L;
    pdt->cdit            = 0;
    pdt->x               = 0;
    pdt->y               = 0;

    // even though we're using a system font, this doesn't work. don't
    // know why. The CPropertyPage does change the font to match the
    // property sheet, so perhaps that's why. The property sheet
    // hasn't been created yet, so not sure how to go about finding
    // out its font
    
//      DWORD dwBaseUnits;
//      SIZE sizeBaseUnit;
//      dwBaseUnits = GetDialogBaseUnits();
//      sizeBaseUnit.cx = LOWORD(dwBaseUnits);
//      sizeBaseUnit.cy = HIWORD(dwBaseUnits);

//      pdt->cx              = (short)(size.cx * 4 / sizeBaseUnit.cx);
//      pdt->cy              = (short)(size.cy * 8 / sizeBaseUnit.cy);
    
    pdt->cx              = (short)size.cx * 2 /3 ;
    pdt->cy              = (short)size.cy * 2 /3;


      // Add menu array, class array, dlg title
    WORD* pw = (WORD*)(pdt + 1);
    *pw++ = 0;                // Menu array 
    *pw++ = 0;                // Class array
    *pw++ = 0;                // Dlgtitle

    // check we didn't go over the end of m_pbDlgTemplate.
    ASSERT((BYTE*)pw <= ((BYTE*)m_pbDlgTemplate + sizeof(m_pbDlgTemplate)));

    m_psp.pResource = pdt;
    m_psp.dwFlags |= PSP_DLGINDIRECT;
    
}

//
// Initialise
//
// Performs initialisation for IPropertyPage which can fail.
// Not in constructor, since constructor should not fail.
//
// Arguments as for IPropertyPage::SetObjects.
//
HRESULT CPropertySite::Initialise(ULONG cObjects, IUnknown **pUnknown)
{
    HRESULT hr;

    //
    // Pointer should be AddRef'ed in IPropertyPage::SetPageSite and
    // any existing pointer should be released.
    //
    hr = m_pIPropPage->SetPageSite( (IPropertyPageSite *) this );
    if (FAILED(hr)) {
        return(hr);
    }

    hr = m_pIPropPage->SetObjects(cObjects, pUnknown);
    if (FAILED(hr)) {
        return(hr);
    }

    hr = m_pIPropPage->GetPageInfo(&m_PropPageInfo);
    if (FAILED(hr)) {
        return(hr);
    }

    //
    // Set flag for help button
    //
    m_fHelp = (m_PropPageInfo.pszHelpFile != NULL);

    //
    // Set the caption of the dialog to the information found in
    // m_PropPageInfo. (the tab string)
    //
    WideCharToMultiByte( CP_ACP, 0, (LPCWSTR) m_PropPageInfo.pszTitle, -1,
                         m_strCaption.GetBufferSetLength(300), 300, NULL, NULL);

#ifndef USE_MSVC20
    m_psp.pszTitle = m_strCaption;
    m_psp.dwFlags |= PSP_USETITLE;
#endif

    return(hr);
}

//
// CleanUp
//
// This method notifies the IPropertyPage to release all pointers to us.
// This cannot be done in the destructor since the destructor will not
// be called unless we are released by the IPropertyPage.
//
HRESULT CPropertySite::CleanUp()
{
    m_pIPropPage->SetObjects(0,NULL);
    m_pIPropPage->SetPageSite(NULL);

    return( NOERROR );
}

//
// Destructor
//
CPropertySite::~CPropertySite()
{
    //
    // Have we displayed a help file?
    //
    if (m_fShowHelp) {
        ::WinHelp(GetSafeHwnd(), NULL, HELP_QUIT, 0);
    }

    //
    // Need to CoTaskMemFree all strings in the page info structure
    //
    if (m_PropPageInfo.pszTitle) {
        CoTaskMemFree(m_PropPageInfo.pszTitle);
    }

    if (m_PropPageInfo.pszDocString){
        CoTaskMemFree(m_PropPageInfo.pszDocString);
    }

    if (m_PropPageInfo.pszHelpFile) {
        CoTaskMemFree(m_PropPageInfo.pszHelpFile);
    }

    ASSERT(m_cRef == 0);
}

//
// OnSiteApply
//
// Called from CVfWPropertySheet when the apply button has been pressed.
//
void CPropertySite::OnSiteApply()
{
    //
    // Call the property page's apply function
    //
    m_pIPropPage->Apply();

    //
    // Update our m_hrDirtyPage flag
    //
    m_hrDirtyPage = m_pIPropPage->IsPageDirty();

    m_pPropSheet->UpdateButtons(m_hrDirtyPage, m_fHelp);
}

//
// OnHelp
//
// Called from CVfWPropertySheet when the help button has been pressed.
// First see if the IPropertyPage objects wants to handle the help
// itself, otherwise provide help with the help file specified in
// PROPERTYPAGEINFO.
//
void CPropertySite::OnHelp()
{
    TCHAR pszHelpPath[200];

    HelpDirFromCLSID( m_CLSID, pszHelpPath, sizeof(pszHelpPath));

    //
    // Let IPropertyPage deal with help first.
    //

    OLECHAR * polecHelpPath;

#ifndef UNICODE
    WCHAR cHelpPath[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, pszHelpPath, -1, cHelpPath, MAX_PATH);

    polecHelpPath = cHelpPath;
#else
    polecHelpPath = pszHelpPath;
#endif

    if (!FAILED(m_pIPropPage->Help( polecHelpPath ))) {
        m_fShowHelp = TRUE;

        return;
    }

    //
    // We have to provide help
    //

    //
    // Need to convert from OLECHAR (WCHAR) to TCHAR for WinHelp
    //
    TCHAR * ptchHelpFile;

#ifdef UNICODE
    ptchHelpFile = m_PropPageInfo.pszHelpFile;
#else
    char cHelpFile[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, m_PropPageInfo.pszHelpFile, -1, cHelpFile, MAX_PATH, NULL, NULL);

    ptchHelpFile = cHelpFile;
#endif

    m_fShowHelp = m_fShowHelp ||
        ::WinHelp(GetSafeHwnd(), ptchHelpFile, HELP_CONTEXT, 0);
}

//
// IsPageDirty
//
// Updates the m_hrDirtyPage variable and returns its new value
//
BOOL CPropertySite::IsPageDirty()
{
    m_hrDirtyPage = m_pIPropPage->IsPageDirty();

    return((m_hrDirtyPage == S_OK) ? TRUE : FALSE);
}

//////////////////////////////////////////////////////////////////////////
//
// IUnknown methods
//
//////////////////////////////////////////////////////////////////////////

//
// AddRef
//
ULONG CPropertySite::AddRef()
{
    return ++m_cRef;
}

//
// Release
//
ULONG CPropertySite::Release()
{
    ASSERT(m_cRef > 0);

    m_cRef--;

    if (m_cRef == 0) {
        delete this;

        // don't return m_cRef, because the object doesn't exist anymore
        return((ULONG) 0);
    }

    return(m_cRef);
}

//
// QueryInterface
//
// We only support IUnknown and IPropertyPageSite
//
HRESULT CPropertySite::QueryInterface(REFIID riid, void ** ppv)
{
    if ((riid != IID_IUnknown) && (riid != IID_IPropertyPageSite)) {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }

    *ppv = (void *) this;

    //
    // We have to addref ourself
    //
    AddRef();

    return(NOERROR);
}

//////////////////////////////////////////////////////////////////////////
//
// IPropertyPageSite methods
//
//////////////////////////////////////////////////////////////////////////

//
// OnStatusChange
//
HRESULT CPropertySite::OnStatusChange(DWORD flags)
{
    HRESULT hr;
    BOOL bDirty = FALSE, bHandled = FALSE;

    // atl sends us VALIDATE OR'd with DIRTY
    if( PROPPAGESTATUS_VALIDATE & flags )
    {
        m_pIPropPage->Apply();
        bDirty = TRUE;
        bHandled = TRUE;
    }
            
    if( PROPPAGESTATUS_DIRTY & flags || bDirty )
    {
        //
        // Update the Site's flags for apply and cancel button
        // and call the property sheets OnStatusChange function
        //
        hr = m_pIPropPage->IsPageDirty();
        if (FAILED(hr)) {
            return(hr);
        }

        m_hrDirtyPage = m_pIPropPage->IsPageDirty();
        m_pPropSheet->UpdateButtons(m_hrDirtyPage, m_fHelp);
        bHandled = TRUE;
    }
    
    return( bHandled ? S_OK : E_INVALIDARG );
}

//
// GetLocaleID
//
HRESULT CPropertySite::GetLocaleID(LCID *pLocaleID)
{
    if (pLocaleID == NULL) {
        return(E_POINTER);
    }

    *pLocaleID = GetThreadLocale();

    return(S_OK);
}

//
// GetPageContainer
//
// Function must fail by definition of IPropertyPageSite
//
HRESULT CPropertySite::GetPageContainer(IUnknown **ppUnknown)
{
    return(E_NOTIMPL);
}

//
// TranslateAccelerator
//
// We don't process the message, therefore we return S_FALSE.
//
HRESULT CPropertySite::TranslateAccelerator(LPMSG pMsg)
{
    return(S_FALSE);
}

//////////////////////////////////////////////////////////////////////////
//
// CPropertySite overrides
//
//////////////////////////////////////////////////////////////////////////

//
// OnSetActive
//
// Gets called from CVfWPropertySheet when our PropertyPage gains the focus.
// We call CPropertyPage::OnSetActive which will create a window for the
// page if not previously created.
//
// return:
//   Non-zero if the page was successfully set active.
//
BOOL CPropertySite::OnSetActive()
{
    if (!CPropertyPage::OnSetActive()) {
        return(FALSE);
    }

    if (!m_fPageIsActive) {
        if (FAILED(m_pIPropPage->Activate(GetSafeHwnd(), &m_rcRect, FALSE))) {
            return (FALSE);
        }
        if (FAILED(m_pIPropPage->Show(SW_SHOW))) {
            return (FALSE);
        }
    }

    m_fPageIsActive = TRUE;

    //
    // Also need to update the buttons
    //
    m_pPropSheet->UpdateButtons( m_hrDirtyPage, m_fHelp);

    return(TRUE);
}

//
// OnKillActive
//
// Called whenever our page loses the focus. At this point data verification
// should be made.
//
// return:
//   TRUE  - it is ok to lose focus
//   FALSE - keep the focus on our page
//
BOOL CPropertySite::OnKillActive()
{
    if (m_fPageIsActive) {
        HRESULT hr = m_pIPropPage->Deactivate();

        if (S_OK != hr) {
            return (FALSE);
        }
    }

    m_fPageIsActive = FALSE;

    return(CPropertyPage::OnKillActive());
}

//
// OnCreate
//
int CPropertySite::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    int iReturn = CPropertyPage::OnCreate(lpCreateStruct);
    if ( iReturn != 0) {
        return(iReturn);
    }

    GetClientRect(&m_rcRect);

    //
    // Leave space for a border
    //
    m_rcRect.InflateRect(-3, -2);

    return(0);
}

//
// OnDestroy
//
void CPropertySite::OnDestroy()
{
    CPropertyPage::OnDestroy();
}

//
// PreTranslateMessage
//
// Give IPropertyPage a chance to use the message. If not it has to pass
// it on to IPropertyPageSite (our interface), from where
// CPropertyPage::PreTranslateMessage is called.
//
// Conversions between HRESULT and BOOL and HRESULT have to be made.
//
// We expect as return value from IPropertyPage::TranslateAccelerator
//    S_OK - Message has been used.
//    S_FALSE - Message has not been used.
//    FAILED(hr) - Message has not been used.
//
// If the message has been used we return TRUE, otherwise FALSE.
// (our return value will determine whether this messages should still be
//  dispatched after we are finished with it).
//
BOOL CPropertySite::PreTranslateMessage(MSG *pMsg)
{
    if ( S_OK == m_pIPropPage->TranslateAccelerator(pMsg) ) {
        return(TRUE);
    }
    else {
        return( CPropertyPage::PreTranslateMessage(pMsg) );
    }
}


//
// HelpDirFromCLSID
//
// Get the help directory from the registry. First we look under
// "CLSID\<clsid>\HelpDir" if this is not given we will get the
// entry under "CLSID\<clsid>\InProcServer32" and remove the
// server file name.
//
// (this code is based on an example in MSDN, July 1995 - search for
// HelpDirFromCLSID in Title and Text)
//
// Note that dwPathSize should be given in Bytes.
//
void CPropertySite::HelpDirFromCLSID
 (
    const CLSID* clsID,
    LPTSTR pszPath,
    DWORD dwPathSize
 )

{
    TCHAR       szCLSID[80];
    TCHAR       szKey[512];
    HKEY        hKey;
    DWORD       dwLength;      // size of szCLSID in bytes and later
                               // temporary storage for dwPathSize
    long lReturn;

    //
    // Initialise pszPath
    //
    if (NULL==pszPath)
        return;

    *pszPath=0;

    //
    // Convert CLSID into a string
    //
    dwLength = sizeof(szCLSID) / sizeof(TCHAR);

#ifdef UNICODE
    StringFromGUID2(*clsID, szCLSID, dwLength);

#else
    WCHAR wszCLSID[128];
    StringFromGUID2(*clsID, wszCLSID, 128);

    WideCharToMultiByte(CP_ACP, 0, wszCLSID, -1, szCLSID, dwLength, NULL, NULL);
#endif

    //
    // Get handle to the HelpDir key.
    //
    wsprintf(szKey, TEXT("CLSID\\%s\\HelpDir"), szCLSID);

    lReturn = RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS == lReturn) {

        //
        // Get the value from the HelpDir key.
        //
        dwLength = dwPathSize;
        lReturn = RegQueryValueEx(hKey, NULL, NULL, NULL,
                                  (LPBYTE) pszPath, &dwLength);

        RegCloseKey(hKey);

        if (ERROR_SUCCESS == lReturn) {
            return;
        }
    }

    //
    // Failure - need to get the path from the InProcServer32 entry
    //
    // Get handle to the Inproc key.
    //
    wsprintf(szKey, TEXT("CLSID\\%s\\InprocServer32"), szCLSID);

    lReturn = RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS != lReturn) {
        // we failed to get any path - return an emtpy string
        pszPath[0] = 0;
        return;
    }

    //
    // Get value of Inproc key.
    //
    dwLength = dwPathSize;
    lReturn = RegQueryValueEx(hKey, NULL, NULL, NULL,
                              (LPBYTE) pszPath, &dwLength);

    RegCloseKey(hKey);

    if (ERROR_SUCCESS != lReturn) {
        // we failed to get any path - return an empty string
        pszPath[0] = 0;
        return;
    }

    //
    // We need to strip of the server filename from the path.
    //
    // The filename extends from the end to the first '\\' or ':' or
    // the beginning of the string. We can therefore just
    // go to the end of the pszPath and then step backwards as long
    // as we are not in the beginning of pszPath or the char in front of us
    // is not a ':' or a '\\'.
    //

    //
    // Find end of pszPath (ie find the terminating '\0')
    //
    TCHAR * pNewEnd = pszPath;

    while (0 != *pNewEnd) {
        pNewEnd++;
    }

    //
    // Now go backwards as long as we are not at the beginning of the
    // string or we don't have a '\\' or ':' before us.
    //
    while ((pszPath != pNewEnd) &&
           (*(pNewEnd - 1) != TEXT(':')) &&
           (*(pNewEnd - 1) != TEXT('\\')) ) {
        pNewEnd--;
    }

    //
    // pNewEnd now points to the new end of the string the path without the
    // filename.
    //
    *pNewEnd = 0;

    return;
}

//
// UpdateButtons
//
// Called from the property sheet to notify us to call the sheet's
// UpdateButtons method with our parameters.
//
void CPropertySite::UpdateButtons()
{
    m_pPropSheet->UpdateButtons(m_hrDirtyPage, m_fHelp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\reconfig.cpp ===
#include "stdafx.h"
#include "ReConfig.h"

/******************************************************************************
    Internal Constants
******************************************************************************/
static const DWORD RECONFIGURE_NO_FLAGS = 0;
static const HANDLE RECONFIGURE_NO_ABORT_EVENT = NULL;

/******************************************************************************
    Internal Declarations
******************************************************************************/
static HRESULT Reconnect( IGraphBuilder* pFilterGraph, IPin* pOutputPin );

template<class T> T* _CreateInstance( void )
{
    try
    {
        T* pNewObject = new T;
        pNewObject->AddRef();
        return pNewObject;
    } 
    catch( CMemoryException* pOutOfMemory )
    {
        pOutOfMemory->Delete();
        return NULL;
    }
}

/******************************************************************************
    Reconfigure Helper Functions
******************************************************************************/

/******************************************************************************

PreventStateChangesWhileOperationExecutes

    PreventStateChangesWhileOperationExecutes() ensures that other threads do 
not change the filter graph's state while IGraphConfigCallback::Reconfigure() 
executes.  If the current version of Direct Show does not support Dynamic Graph
Building, then this function fails.

Parameters:
- pGraphBuilder [in]
    The filter graph which WILL be locked.  Other threads cannot modify the
filter graph's state while it's locked.

- pCallback [in]
    The callback which will be called to preform a user defined operation.

- pReconfigureParameter [in]
    The pvConext parameters IGraphConfigCallback::Reconfigure() receives when
it's called.

Return Value:
    An HRESULT. S_OK if no error occur.  Otherwise, an error HRESULT.

******************************************************************************/
extern HRESULT PreventStateChangesWhileOperationExecutes
    (
    IGraphBuilder* pGraphBuilder,
    IGraphConfigCallback* pCallback,
    void* pReconfigureParameter
    )
{
    // The user should pass a valid IGraphBuilder object and a
    // valid IGraphConfigCallback object.
    ASSERT( (NULL != pGraphBuilder) && (NULL != pCallback) );

    IGraphConfig* pGraphConfig;

    // Does Direct Show supports Dynamic Graph Building?
    HRESULT hr = pGraphBuilder->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( FAILED( hr ) ) {
        return hr; 
    }

    hr = pGraphConfig->Reconfigure( pCallback,
                                    (void*)pReconfigureParameter,
                                    RECONFIGURE_NO_FLAGS,
                                    RECONFIGURE_NO_ABORT_EVENT );
    pGraphConfig->Release();

    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
} 

/******************************************************************************

IfPossiblePreventStateChangesWhileOperationExecutes

    If the current version of Direct Show supports Dynamic Graph Building, 
IfPossiblePreventStateChangesWhileOperationExecutes() ensures that other 
threads do not change the filter graph's state while 
IGraphConfigCallback::Reconfigure() executes.  If the current version of Direct
Show does not support Dynamic Graph Building, then the filter graph state 
should not change unless this thread changes it.  

Parameters:
- pGraphBuilder [in]
    The filter graph which MAY be locked.  Other threads cannot modify the
filter graph's state while it's locked.

- pCallback [in]
    The callback which will be called to preform a user defined operation.

- pReconfigureParameter [in]
    The pvConext parameters IGraphConfigCallback::Reconfigure() receives when
it's called.

Return Value:
    An HRESULT. S_OK if no error occur.  Otherwise, an error HRESULT.

******************************************************************************/
extern HRESULT IfPossiblePreventStateChangesWhileOperationExecutes
    (
    IGraphBuilder* pGraphBuilder,
    IGraphConfigCallback* pCallback,
    void* pReconfigureParameter
    )
{
    // The user should pass a valid IGraphBuilder object and a
    // valid IGraphConfigCallback object.
    ASSERT( (NULL != pGraphBuilder) && (NULL != pCallback) );

    IGraphConfig* pGraphConfig;

    // Does Direct Show supports Dynamic Graph Building?
    HRESULT hr = pGraphBuilder->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( SUCCEEDED( hr ) ) {
        // Dynamic Graph Building supported.
        hr = pGraphConfig->Reconfigure( pCallback,
                                        pReconfigureParameter,
                                        RECONFIGURE_NO_FLAGS,
                                        RECONFIGURE_NO_ABORT_EVENT );
        pGraphConfig->Release();
    
        if( FAILED( hr ) ) {
            return hr;
        }

    } else if( E_NOINTERFACE == hr ) {
        // Dynamic Graph Building is not supported.
        hr = pCallback->Reconfigure( pReconfigureParameter, RECONFIGURE_NO_FLAGS );
        if( FAILED( hr ) ) {
            return hr;
        }
       
    } else {
        return hr;
    }

    return S_OK;
}

/******************************************************************************
    CReconfigure Public Methods
******************************************************************************/

CGraphConfigCallback::CGraphConfigCallback( const TCHAR* pName, LPUNKNOWN pUnk ) :
    CUnknown( pName, pUnk )
{
}

STDMETHODIMP CGraphConfigCallback::NonDelegatingQueryInterface( REFIID riid, void** ppv )
{
    if( IID_IGraphConfigCallback == riid ) {
        return GetInterface( this, ppv );
    } else {
        return CUnknown::NonDelegatingQueryInterface( riid, ppv );
    }
}

/******************************************************************************
    CPrintGraphAsHTMLCallback Public Methods
******************************************************************************/
CPrintGraphAsHTMLCallback::CPrintGraphAsHTMLCallback() :
    CGraphConfigCallback( NAME("CPrintGraphAsHTMLCallback"), NULL )
{
}

STDMETHODIMP CPrintGraphAsHTMLCallback::Reconfigure( PVOID pvContext, DWORD dwFlags )
{
    // No valid flags have been defined.  Therefore, this parameter should be 0.
    ASSERT( 0 == dwFlags );

    PARAMETERS_FOR_PRINTGRAPHASHTMLINTERNAL* pParameters = (PARAMETERS_FOR_PRINTGRAPHASHTMLINTERNAL*)pvContext;
       
    CBoxNetDoc* pDoc = pParameters->pDocument;

    pDoc->PrintGraphAsHTML( pParameters->hFileHandle );

    return S_OK;
}

IGraphConfigCallback* CPrintGraphAsHTMLCallback::CreateInstance( void )
{
    return _CreateInstance<CPrintGraphAsHTMLCallback>();
}

/******************************************************************************
    CUpdateFiltersCallback Public Methods
******************************************************************************/
CUpdateFiltersCallback::CUpdateFiltersCallback() :
    CGraphConfigCallback( NAME("CUpdateFiltersCallback"), NULL )
{
}

STDMETHODIMP CUpdateFiltersCallback::Reconfigure( PVOID pvContext, DWORD dwFlags )
{
    // No valid flags have been defined.  Therefore, this parameter should be 0.
    ASSERT( 0 == dwFlags );

    CBoxNetDoc* pDoc = (CBoxNetDoc*)pvContext;

    pDoc->UpdateFiltersInternal();

    return S_OK;
}

IGraphConfigCallback* CUpdateFiltersCallback::CreateInstance( void )
{
    return _CreateInstance<CUpdateFiltersCallback>();
}

/******************************************************************************
    CEnumerateFilterCacheCallback Public Methods
******************************************************************************/
CEnumerateFilterCacheCallback::CEnumerateFilterCacheCallback() :
    CGraphConfigCallback( NAME("CEnumerateFilterCacheCallback"), NULL )
{
}

STDMETHODIMP CEnumerateFilterCacheCallback::Reconfigure( PVOID pvContext, DWORD dwFlags )
{
    // No valid flags have been defined.  Therefore, this parameter should be 0.
    ASSERT( 0 == dwFlags );

    CBoxNetDoc* pDoc = (CBoxNetDoc*)pvContext;

    pDoc->OnGraphEnumCachedFiltersInternal();

    return S_OK;
}

IGraphConfigCallback* CEnumerateFilterCacheCallback::CreateInstance( void )
{
    return _CreateInstance<CEnumerateFilterCacheCallback>();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\graphedt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by graphedt.rc
//
#define VERSION_RES_BLD_MAJOR           00
#define VER_DEBUG                       0
#define IDR_MAINFRAME                   2
#define VERSION_RES_VER_MINOR           02
#define IDR_GRAPH                       3
#define ID_REMOVE_FILTER                4
#define VERSION_RES_VER_MAJOR           4
#define IDS_STAT_DRAGLINKEND            11
#define IDS_STAT_DROPLINKEND            12
#define IDS_STAT_MOVEBOX                15
#define IDS_STAT_BOXTABEMPTY            17
#define IDS_STAT_SELECTRECT             19
#define IDD_ABOUTBOX                    100
#define IDC_APPLY                       101
#define ID_PROPBUTTONS                  102
#define IDB_EDGES                       103
#define IDC_PROP_HELP                   104
#define IDC_TRUNCATE                    105
#define IDB_TABS                        106
#define IDB_EDGES_HILITE                107
#define IDB_TABS_HILITE                 108
#define IDI_FILTER                      109
#define IDC_LIST1                       110
#define IDC_REFRESH                     111
#define IDR_PINMENU                     112
#define IDR_FILTERMENU                  113
#define IDR_LINKMENU                    114
#define IDI_DOC                         116
#define IDS_VERSION                     118
#define ID__SELECTCLOCK                 119
#define IDB_CLOCK                       120
#define IDB_CLOCK_SELECT                121
#define IDS_MISSING_FILE_IN_GRAPH       122
#define IDC_FILTER_TREE                 123
#define IDD_FILTER_VIEW                 124
#define ID_ADDFILTER                    125
#define IDD_CONNECTTOGRAPH              126
#define IDS_FILENOTFOUND                127
#define IDS_ACCESSDENIED                128
#define IDS_NOTSTORAGEOBJECT            129
#define IDS_TOOMANYOPENFILES            130
#define IDS_INSUFFICIENTMEMORY          131
#define IDS_INVALIDNAME                 132
#define IDS_GENERAL_FILE_OPEN           133
#define IDS_FILE_ALREADY_OPEN           134
#define IDS_READ_ONLY                   135
#define IDS_PAUSE_TIMEOUT               136
#define IDS_DEVICE_NOT_READY            137
#define IDD_RENDER_URL                  138
#define IDC_URL_LIST                    139
#define IDC_CACHED_FILTERS              140
#define IDD_CACHED_FILTERS              141
#define IDD_STATS                       142
#define IDC_RESET                       143
#define IDD_TRUNCATE                    144
#define IDC_RESET2                      145
#define IDS_FAILED_TO_LOAD_GRAPH        146
#define IDD_SEEKBAR                     147
#define IDC_SEEKSLIDER                  148
#define IDC_RANDOM                      150
#define IDS_CMD_RECONNECT               151
#define ID_RECONNECT                    152
#define IDS_ASYNC_RECONNECT_SUCCEEDED   153
#define IDS_ASYNC_RECONNECT_FAILED      154
#define IDS_RECONNECT_PENDING           155
#define ID_INCREASE_ZOOM                200
#define ID_DECREASE_ZOOM                201
#define VER_PRODUCTBUILD                500
#define IDS_CMD_MOVEBOX                 1000
#define IDS_CMD_MOVEBOXES               1001
#define IDS_CMD_ADDFILTER               1002
#define IDS_CMD_DELETE                  1003
#define IDS_CMD_CONNECT                 1005
#define IDS_CMD_ADD_FILTER_TO_CACHE     1006
#define VERSION_RES_LANGUAGE            0x409
#define stc32                           0x045f
#define VERSION_RES_CHARSET             1252
#define IDS_MENU_UNDO                   2000
#define IDS_MENU_REDO                   2001
#define IDS_MENU_REPEAT                 2002
#define IDS_MEDIA_FILES                 2003
#define IDS_TEXT_FILES                  2004
#define IDS_SOURCE_DIALOG_TITLE         2005
#define IDS_SINK_DIALOG_TITLE           2006
#define IDS_UNCATEGORIZED_FILTERS       2007
#define ID_CANCEL_MODES                 32769
#define ID_FILE_RENDER                  32770
#define ID_FILE_SET_LOG                 32771
#define ID_EDIT_DELETE                  32778
#define ID_QUARTZ_DISCONNECT            32783
#define ID_QUARTZ_PAUSE                 32785
#define ID_QUARTZ_RUN                   32786
#define IDM_RENDER_PIN                  32787
#define ID_RENDER                       32789
#define ID_AUTOARRANGE                  32800
#define ID_WINDOW_REFRESH               32801
#define ID__PROPERTIES                  32803
#define IDM_SAVE_PERF_LOG               32805
#define ID_QUARTZ_STOP                  32807
#define ID_USE_CLOCK                    32808
#define ID_NEW_PERF_LOG                 32809
#define ID_CONNECT_SMART                32810
#define ID_SELECT_CLOCK                 32811
#define ID_INSERT_FILTER                32812
#define ID_FILE_SAVE_AS_HTML            32813
#define ID_URL_RENDER                   32814
#define ID_FILE_SAVE_AS_XML             32815
#define ID_WINDOW_ZOOM25                32816
#define ID_WINDOW_ZOOM50                32817
#define ID_WINDOW_ZOOM100               32818
#define ID_WINDOW_ZOOM200               32819
#define ID_CONNECT_TO_GRAPH             32820
#define ID_GRAPH_STATS                  32821
#define ID_GRAPH_ADDFILTERTOCACHE       32822
#define ID_GRAPH_ENUMCACHEDFILTERS      32823
#define ID_BUTTON32825                  32825
#define ID_BUTTON32826                  32826
#define ID_BUTTON32827                  32827
#define ID_BUTTON32828                  32828
#define ID_BUTTON32829                  32829
#define ID_BUTTON32830                  32830
#define ID_BUTTON32831                  32831
#define ID_BUTTON32832                  32832
#define ID_BUTTON32833                  32833
#define ID_BUTTON32834                  32834
#define ID_BUTTON32835                  32835
#define ID_BUTTON32836                  32836
#define ID_BUTTON32837                  32837
#define ID_BUTTON32838                  32838
#define ID_BUTTON32839                  32839
#define ID_BUTTON32840                  32840
#define ID_WINDOW_ZOOM75                32841
#define ID_WINDOW_ZOOM150               32842
#define ID_BUTTON32843                  32843
#define ID_DISCONNECT_FROM_GRAPH        32844
#define ID_VIEW_SEEKBAR                 32847
#define IDS_CANTCONNECT                 61216
#define IDS_CANTINITQUARTZ              61217
#define IDS_CANTCREATEFILTER            61218
#define IDS_CANT_RENDER                 61219
#define IDS_CANT_RENDER_FILE            61220
#define IDS_CANT_ADD_SOURCE_FILE        61221
#define IDS_CANTCREATESOMEFILTER        61222
#define IDS_CANTPLAY                    61224
#define IDS_CANTPAUSE                   61225
#define IDS_CANTSTOP                    61226
#define IDS_CANTDISPLAYPROPERTIES       61227
#define IDS_CMD_DISCONNECTALL           61228
#define IDS_CMD_RENDER                  61229
#define IDS_CMD_RENDERFILE              61231
#define IDS_PINS_FAILED_TO_RENDER       61232
#define IDS_SAVE_PERF_LOG               61233
#define IDS_BAD_PERF_LOG                61234
#define IDS_EC_ERROR_ABORT              61235
#define IDS_IS_GRAPH_PLAYING            61236
#define IDS_NOINTERFACE                 61237
#define IDS_CLOSE                       61238
#define IDS_CANCEL                      61239
#define IDS_NO_DUMP_PROC                61240
#define IDS_DUMP_PROC                   61241
#define IDS_MEASURE_DLL                 61242
#define IDS_CANTSETCLOCK                61243
#define IDS_CONTROL_PROC                61244
#define IDS_NO_CONTROL_PROC             61245
#define IDS_CANT_ADD_FILTER             61246
#define IDS_CANTCONNECTINPUTS           61247
#define IDS_CANTCONNECTOUTPUTS          61248
#define IDS_OK                          61249
#define IDS_APPLY                       61250
#define IDS_HELP                        61251
#define IDS_NO_REFCLOCK                 61252
#define IDS_FAILED_SETSYNC              61253
#define IDS_FAILED_FILTER_FILE_LOAD     61254
#define IDS_FILE_SAVE_FAILED            61255
#define IDS_NO_TERMINATE_PROC           61256
#define IDS_TERMINATE_PROC              61257
#define IDS_RETURN_CODE                 61259
#define IDS_SAVE_HTML_EXT               61260
#define IDS_SAVE_HTML_FILTER            61261
#define IDS_SAVE_HTML_FILE_ERR          61262
#define IDS_SAVE_HTML_GRAPH_ERR         61263
#define IDS_SAVE_HTML_ERR               61264
#define IDS_SAVE_XML_EXT                61265
#define IDS_SAVE_XML_FILTER             61266
#define IDS_SAVE_XML_FILE_ERR           61267
#define IDS_SAVE_XML_GRAPH_ERR          61268
#define IDS_SAVE_XML_ERR                61269
#define IDS_CANT_CREATE_DIALOG          61270
#define IDS_GRAPHSPY_NOT_ENABLED        61273
#define IDS_CANT_LOAD_HELP              61274

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        157
#define _APS_NEXT_COMMAND_VALUE         32848
#define _APS_NEXT_CONTROL_VALUE         156
#define _APS_NEXT_SYMED_VALUE           156
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\mp2demux\mp2prop.h ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        mp2prop.h

    Abstract:

        This module contains the class declarations for the filter
        properties

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        06-Jul-1999     created

--*/

#ifndef _mp2demux__prop_h
#define _mp2demux__prop_h

//  forward declarations
class CMPEG2PropOutputPins ;
class CMPEG2PropPIDMap ;
class CListview ;

//  ---------------------------------------------------------------------------
//      property page GUIDs
//  ---------------------------------------------------------------------------

//  output pin manipulation
// {960F051B-A25C-4ac4-8D30-050CD47A814F}
DEFINE_GUID (CLSID_MPEG2DemuxPropOutputPins,
0x960f051b, 0xa25c, 0x4ac4, 0x8d, 0x30, 0x5, 0xc, 0xd4, 0x7a, 0x81, 0x4f) ;

//  PID mappings
// {ae83f13d-51b5-4a85-8c3a-ecc9f50c557a}
DEFINE_GUID (CLSID_MPEG2DemuxPropPIDMap,
0xae83f13d, 0x51b5, 0x4a85, 0x8c, 0x3a, 0xec, 0xc9, 0xf5, 0xc, 0x55, 0x7a) ;

//  stream_id mappings
// {E04BBB8F-CB77-499e-B815-468B1C3ED88F}
DEFINE_GUID(CLSID_MPEG2DemuxPropStreamIdMap,
0xe04bbb8f, 0xcb77, 0x499e, 0xb8, 0x15, 0x46, 0x8b, 0x1c, 0x3e, 0xd8, 0x8f) ;

//  ---------------------------------------------------------------------------
//      class declarations
//  ---------------------------------------------------------------------------

//  output pin manipulation property page
class CMPEG2PropOutputPins :
    public CBasePropertyPage
{
    IMpeg2Demultiplexer *   m_pIMpeg2Demultiplexer ;
    HWND                    m_hwnd ;

    HRESULT
    RefreshPinList_ (
        ) ;

    HRESULT
    PopulateComboBoxes_ (
        ) ;

    HRESULT
    TearDownPinList_ (
        ) ;

    HRESULT
    OnCreatePin_ (
        ) ;

    HRESULT
    OnDeletePin_ (
        ) ;

    void
    SetDirty_ (
        IN  BOOL    fDirty = TRUE
        ) ;

    public :

        CMPEG2PropOutputPins (
            IN  TCHAR *     pClassName,
            IN  IUnknown *  pIUnknown,
            IN  REFCLSID    rclsid,
            OUT HRESULT *   pHr
            ) ;

        HRESULT
        OnActivate (
            ) ;

        HRESULT
        OnApplyChanges (
            ) ;

        HRESULT
        OnConnect (
            IN  IUnknown *  pIUnknown
            ) ;

        HRESULT
        OnDeactivate (
            ) ;

        HRESULT
        OnDisconnect (
            ) ;

        INT_PTR
        OnReceiveMessage (
            IN  HWND    hwnd,
            IN  UINT    uMsg,
            IN  WPARAM  wParam,
            IN  LPARAM  lParam
            ) ;

        DECLARE_IUNKNOWN ;

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;
} ;

//  PID mappings property page
class CMpeg2PropStreamMap :
    public CBasePropertyPage
{
    HRESULT
    PopulatePinList_ (
        ) ;

    HRESULT
    TearDownPinList_ (
        ) ;

    protected :

        HRESULT
        RefreshStreamMap_ (
            );

        virtual
        HRESULT
        PopulateStreamList_ (
            ) = 0 ;

        virtual
        HRESULT
        PopulateMediaSampleContentList_ (
            ) = 0 ;

        virtual
        HRESULT
        OnMapStream_ (
            ) = 0 ;

        virtual
        HRESULT
        OnUnmapStream_ (
            ) = 0 ;

        virtual
        HRESULT
        TearDownStreamMap_ (
            ) = 0 ;

        virtual
        HRESULT
        AppendStreamMaps (
            IN  IPin *      pIPin,
            IN  CListview * plv
            ) = 0 ;

        virtual
        int
        GetStreamMapColCount (
            ) = 0 ;

        virtual
        WCHAR *
        GetStreamMapColTitle (
            IN  int iCol
            ) = 0 ;

        virtual
        int
        GetStreamMapColWidth (
            IN  int iCol
            ) = 0 ;

        virtual
        void
        DialogInit_ (
            ) = 0 ;

        HWND        m_hwnd ;
        IUnknown *  m_pIUnknown ;

    public :

        CMpeg2PropStreamMap (
            IN  TCHAR *     pClassName,
            IN  IUnknown *  pIUnknown,
            IN  REFCLSID    rclsid,
            IN  int         iTitleStringResource,
            OUT HRESULT *   pHr
            ) ;

        void
        SetDirty (
            IN  BOOL    fDirty = TRUE
            ) ;

        HRESULT
        OnActivate (
            ) ;

        HRESULT
        OnApplyChanges (
            ) ;

        HRESULT
        OnConnect (
            IN  IUnknown *  pIUnknown
            ) ;

        HRESULT
        OnDeactivate (
            ) ;

        HRESULT
        OnDisconnect (
            ) ;

        INT_PTR
        OnReceiveMessage (
            IN  HWND    hwnd,
            IN  UINT    uMsg,
            IN  WPARAM  wParam,
            IN  LPARAM  lParam
            ) ;
} ;

class CMPEG2PropPIDMap :
    public CMpeg2PropStreamMap
{
    virtual
    HRESULT
    PopulateStreamList_ (
        ) ;

    virtual
    HRESULT
    TearDownStreamMap_ (
        ) ;

    virtual
    HRESULT
    PopulateMediaSampleContentList_ (
        ) ;

    virtual
    HRESULT
    OnMapStream_ (
        ) ;

    virtual
    HRESULT
    OnUnmapStream_ (
        ) ;

    virtual
    HRESULT
    AppendStreamMaps (
        IN  IPin *      pIPin,
        IN  CListview * plv
        ) ;

    virtual
    int
    GetStreamMapColCount (
        ) ;

    virtual
    WCHAR *
    GetStreamMapColTitle (
        IN  int iCol
        ) ;

    virtual
    int
    GetStreamMapColWidth (
        IN  int iCol
        ) ;

    virtual
    void
    DialogInit_ (
        ) ;

    public :

        CMPEG2PropPIDMap (
            IN  TCHAR *     pClassName,
            IN  IUnknown *  pIUnknown,
            IN  REFCLSID    rclsid,
            OUT HRESULT *   pHr
            ) ;

        DECLARE_IUNKNOWN ;

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;
} ;

class CMPEG2PropStreamIdMap :
    public CMpeg2PropStreamMap
{
    virtual
    HRESULT
    PopulateStreamList_ (
        ) ;

    virtual
    HRESULT
    TearDownStreamMap_ (
        ) ;

    virtual
    HRESULT
    PopulateMediaSampleContentList_ (
        ) ;

    virtual
    HRESULT
    OnMapStream_ (
        ) ;

    virtual
    HRESULT
    OnUnmapStream_ (
        ) ;

    virtual
    HRESULT
    AppendStreamMaps (
        IN  IPin *      pIPin,
        IN  CListview * plv
        ) ;

    virtual
    WCHAR *
    GetStreamMapColTitle (
        IN  int iCol
        ) ;

    virtual
    int
    GetStreamMapColCount (
        ) ;

    virtual
    int
    GetStreamMapColWidth (
        IN  int iCol
        ) ;

    virtual
    void
    DialogInit_ (
        ) ;

    public :

        CMPEG2PropStreamIdMap (
            IN  TCHAR *     pClassName,
            IN  IUnknown *  pIUnknown,
            IN  REFCLSID    rclsid,
            OUT HRESULT *   pHr
            ) ;

        DECLARE_IUNKNOWN ;

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;
} ;

#endif  //  _mp2demux__prop_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\mp2demux\mp2res.h ===
#define IDS_MPG2SPLT_PROP_PINS_TITLE            1201
#define IDS_MPG2SPLT_PROP_PID_MAP_TITLE         1202
#define IDS_MPG2SPLT_PROP_STREAMID_MAP_TITLE    1203
#define IDD_MPG2SPLT_PROP_PINS                  1204
#define IDD_MPG2SPLT_PROP_STREAM_MAP            1205
#define IDC_MPG2SPLT_OUTPUT_PINS                1206
#define IDC_MPG2SPLT_DATA_OFFSET                1207
#define IDC_MPG2SPLT_FILTER_VALUE               1208
#define IDC_MPG2SPLT_CREATE_PIN                 1209
#define IDC_MPG2SPLT_DELETE_PIN                 1210
#define IDC_MPG2SPLT_PIN_NAME                   1211
#define IDC_MPG2SPLT_PIN_TYPE                   1212
#define IDC_MPG2SPLT_STREAMS                    1213
#define IDC_MPG2SPLT_MAP_STREAM                 1214
#define IDC_MPG2SPLT_UNMAP_STREAM               1215
#define IDC_MPG2SPLT_STREAM_MAPPINGS            1216
#define IDC_MPG2SPLT_MEDIA_SAMPLE_CONTENT       1217
#define IDC_MPG2SPLT_STREAMID_NAME              1218
#define IDC_MPG2SPLT_DATA_OFFSET_LABEL          1219
#define IDC_MPG2SPLT_FILTER_VALUE_LABEL         1220
#define IDC_MPG2SPLT_SUBSTREAM_FRAME            1221
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\mp2demux\uictrl.cpp ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        uictrl.cpp

    Abstract:

        This module contains the class implementations for thin win32
        control wrappers which are used on the property pages

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        06-Jul-1999     created

--*/

#include <streams.h>
#include <commctrl.h>
#include <tchar.h>
#include "uictrl.h"

static
LPWSTR
AnsiToUnicode (
    IN  LPCSTR  string,
    OUT LPWSTR  buffer,
    IN  DWORD   buffer_len
    )
{
	buffer [0] = L'\0';
	MultiByteToWideChar (CP_ACP, 0, string, -1, buffer, buffer_len);

	return buffer;
}

static
LPSTR
UnicodeToAnsi (
    IN  LPCWSTR string,
    OUT LPSTR   buffer,
    IN  DWORD   buffer_len
    )
{
	buffer [0] = '\0';
	WideCharToMultiByte (CP_ACP, 0, string, -1, buffer, buffer_len, NULL, FALSE);

	return buffer;
}

/*++
        C C o n t r o l B a s e
--*/

CControlBase::CControlBase (
    HWND    hwnd,
    DWORD   id
    )
{
    ASSERT (hwnd) ;

    m_hwnd = GetDlgItem (hwnd, id) ;
    m_id = id ;

#ifndef UNICODE
    m_pchScratch = & m_achBuffer [0] ;
    m_pchScratchMaxString = MAX_STRING ;
#endif  //  UNICODE
}

TCHAR *
CControlBase::ConvertToUIString_ (
    IN     WCHAR *  szIn
    )
{
    //  we convert or not based on what the UI is.  If UNICODE is defined
    //  the UI is unicode, and thus is compatible with the sz parameter.
    //  If UNICODE is not defined, then the UI is ansi and a conversion
    //  must be made.

#ifdef UNICODE
    return szIn ;         //  the easy case - UI is UNICODE
#else   //  ansi

    int     len ;
    char *  szOut ;

    //  compute required length and get a scratch buffer
    len = wcslen (szIn) + 1 ;           //  include null-terminator
    szOut = GetScratch_ (& len) ;

    //  we'll get _something_ via the above call
    ASSERT (szOut) ;

    return UnicodeToAnsi (
                szIn,
                szOut,
                len
                ) ;
#endif  //  UNICODE
}

//  called to obtain a UI-compatible buffer
TCHAR *
CControlBase::GetUICompatibleBuffer_ (
    IN  WCHAR *     sz,
    IN OUT int *    pLen
    )
{
#ifdef UNICODE  //  easy case
    return sz ;
#else   //  ansi
    return GetScratch_ (pLen) ;
#endif  //  UNICODE
}

//  called with a UI-filled buffer; ensures that szUnicode has what sz
//  points to; obtain sz via GetUICompatibleBuffer_ to minimize
//  string operations i.e. sz may be szUnicode
WCHAR *
CControlBase::ConvertToUnicodeString_ (
    IN  TCHAR * sz,             //  buffer to convert; null-terminated
    IN  WCHAR * szUnicode,      //  requested buffer
    IN  int     MaxLen          //  max length of szUnicode buffer
    )
{
#ifdef UNICODE
    //  assert assumes that sz was obtained via call to GetUICompatibleBuffer_ ()
    ASSERT (sz == szUnicode) ;
    return sz ;
#else   //  ansi
    //  assert assumes that sz was obtained via call to GetUICompatibleBuffer_ ()
    ASSERT ((LPVOID) & sz [0] != (LPVOID) & szUnicode [0]) ;
    return AnsiToUnicode (sz, szUnicode, MaxLen) ;
#endif  //  UNICODE
}

HWND
CControlBase::GetHwnd (
    )
{
    return m_hwnd ;
}

DWORD
CControlBase::GetId (
    )
{
    return m_id ;
}

/*++
        C E d i t C o n t r o l
--*/

CEditControl::CEditControl (
    HWND    hwnd,
    DWORD   id
    ) : CControlBase (hwnd, id)
{
    ASSERT (hwnd) ;
}

void
CEditControl::SetTextW (
    WCHAR * szText
    )
{
    ASSERT (szText) ;

    SetWindowText (m_hwnd, ConvertToUIString_ (szText)) ;
}

void
CEditControl::SetTextW (
    INT val
    )
{
    WCHAR achbuffer [32] ;
    SetTextW (_itow (val, achbuffer, 10)) ;
}

int
CEditControl::GetTextW (
    INT *   val
    )
{
    WCHAR   achbuffer [32] ;

    ASSERT (val) ;
    * val = 0 ;

    if (GetTextW (achbuffer, 31)) {
        * val = _wtoi (achbuffer) ;
    }

    return * val ;
}

int
CEditControl::GetTextW (
    WCHAR * ach,
    int     MaxChars
    )
{
    TCHAR * szUI ;
    int     len ;
    int     r ;

    //  get our UI compatible buffer
    len = MaxChars ;
    szUI = GetUICompatibleBuffer_ (ach, & len) ;

    ASSERT (szUI) ;
    ASSERT (len <= MaxChars) ;

    //  get the text (include null-terminator in length)
    r = GetWindowText (m_hwnd, szUI, len) ;

    //  make sure we have it in our UNICODE buffer
    //  include room for the null-terminator
    ConvertToUnicodeString_ (szUI, ach, r + 1) ;

    return r ;
}

LRESULT
CEditControl::ResetContent ()
{
    return SendMessage (m_hwnd, WM_CLEAR, 0, 0) ;
}

/*++
        C C o m b o b o x
--*/

CCombobox::CCombobox (
    HWND    hwnd,
    DWORD   id
    ) : CControlBase (hwnd, id)
{
}

int
CCombobox::AppendW (
    WCHAR *  sz
    )
{
    return (int) SendMessage (m_hwnd, CB_ADDSTRING, 0, (LPARAM) ConvertToUIString_ (sz)) ;
}

int
CCombobox::AppendW (
    INT val
    )
{
    WCHAR   achbuffer [32] ;        //  no numbers are longer

    return AppendW (_itow (val, achbuffer, 10)) ;
}

int
CCombobox::InsertW (
    WCHAR * sz,
    int     index)
{
    return (int) SendMessage (m_hwnd, CB_INSERTSTRING, (WPARAM) index, (LPARAM) ConvertToUIString_ (sz)) ;
}

int
CCombobox::InsertW (
    INT val,
    int index
    )
{
    WCHAR   achbuffer [32] ;        //  no numbers are longer

    return InsertW (_itow (val, achbuffer, 10), index) ;
}

BOOL
CCombobox::DeleteRow (
    int iRow
    )
{
    return (SendMessage (m_hwnd, CB_DELETESTRING, (WPARAM) iRow, 0) != CB_ERR) ;
}

int
CCombobox::GetItemCount (
    )
{
    return (int) SendMessage (m_hwnd, CB_GETCOUNT, 0, 0) ;
}

int
CCombobox::GetTextW (
    WCHAR * ach,
    int     MaxChars
    )
{
    int     index ;
    int     count ;
    int     len ;
    TCHAR * szUI ;

    index = GetCurrentItemIndex () ;
    if (index == CB_ERR) {
        //  might be that it's not a dropdown list - in which case we get;
        //  try to get just the edit control's text; if that fails, return
        //  a failure, otherwise we're ok

        //  first get a UI compatible buffer
        len = MaxChars ;
        szUI = GetUICompatibleBuffer_ (ach, & len) ;
        ASSERT (szUI) ;

        count = GetWindowText (m_hwnd, szUI, len) ;
        if (count == 0) {
            return CB_ERR ;
        }

        ASSERT (count <= len) ;
        ASSERT (len <= MaxChars) ;

        //  now convert back to UNICODE (include null-terminator)
        ConvertToUnicodeString_ (szUI, ach, count + 1) ;

        return count ;
    }

    //  make sure it will fit
    if (SendMessage (m_hwnd, CB_GETLBTEXTLEN, (WPARAM) index, 0) + 1 > MaxChars) {
        return CB_ERR ;
    }

    //  get a UI compatible buffer
    len = MaxChars ;
    szUI = GetUICompatibleBuffer_ (ach, & len) ;
    ASSERT (szUI) ;

    count = (int) SendMessage (m_hwnd, CB_GETLBTEXT, (WPARAM) index, (LPARAM) szUI) ;

    ASSERT (count < len) ;
    ASSERT (len <= MaxChars) ;

    //  include NULL terminator
    ConvertToUnicodeString_ (szUI, ach, count + 1) ;

    return count ;
}

int
CCombobox::GetTextW (
    int * val
    )
{
    WCHAR   achbuffer [32] ;

    ASSERT (val) ;
    * val = 0 ;

    if (GetTextW (achbuffer, 32)) {
        * val = _wtoi (achbuffer) ;
    }

    return * val ;
}

int
CCombobox::Focus (
    int index
    )
{
    return (int) SendMessage (m_hwnd, CB_SETCURSEL, (WPARAM) index, 0) ;
}

LRESULT
CCombobox::ResetContent (
    )
{
    return SendMessage (m_hwnd, CB_RESETCONTENT, 0, 0) ;
}

int
CCombobox::SetItemData (
    DWORD_PTR   val,
    int         index
    )
{
    return (int) SendMessage (m_hwnd, CB_SETITEMDATA, (WPARAM) index, (LPARAM) val) ;
}

int
CCombobox::GetCurrentItemIndex (
    )
{
    return (int) SendMessage (m_hwnd, CB_GETCURSEL, 0, 0) ;
}

DWORD_PTR
CCombobox::GetItemData (
    DWORD_PTR * pval,
    int         index
    )
{
    DWORD_PTR   dwp ;

    ASSERT (pval) ;

    dwp = SendMessage (m_hwnd, CB_GETITEMDATA, (WPARAM) index, 0) ;
    (* pval) = dwp ;

    return dwp ;
}

DWORD_PTR
CCombobox::GetCurrentItemData (
    DWORD_PTR * pval
    )
{
    int index ;

    index = GetCurrentItemIndex () ;
    if (index == CB_ERR) {
        (* pval) = CB_ERR ;
        return CB_ERR ;
    }

    return GetItemData (pval, index) ;
}


/*++
        C L i s t v i e w
--*/

CListview::CListview (
    HWND hwnd,
    DWORD id
    ) : CControlBase (hwnd, id),
        m_cColumns (0)
{
}

LRESULT
CListview::ResetContent (
    )
{
    return SendMessage (m_hwnd, LVM_DELETEALLITEMS, 0, 0) ;
}

BOOL
CListview::SetData (
    DWORD_PTR   dwData,
    int         iRow
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.iItem    = iRow ;
    lvItem.lParam   = (LPARAM) dwData ;

    return ListView_SetItem (m_hwnd, & lvItem) ;
}

BOOL
CListview::SetTextW (
    WCHAR * sz,
    int iRow,
    int iCol
    )
{
    LVITEM  lvItem = {0} ;

    ASSERT (sz) ;

    lvItem.mask     = LVIF_TEXT ;
    lvItem.iItem    = iRow ;
    lvItem.iSubItem = iCol ;
    lvItem.pszText  = ConvertToUIString_ (sz) ;

    return ListView_SetItem (m_hwnd, & lvItem) ;
}

int
CListview::InsertRowIcon (
    int iIcon
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_IMAGE ;
    lvItem.iImage   = iIcon ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

int
CListview::InsertRowValue (
    DWORD_PTR dwp
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.lParam   = (LPARAM) dwp ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

int
CListview::InsertRowNumber (
    int i,
    int iCol
    )
{
    WCHAR achbuffer [16] ;

    return InsertRowTextW (
                    _itow (i, achbuffer, 10),
                    iCol
                    ) ;
}

int
CListview::InsertRowTextW (
    WCHAR * sz,
    int iCol
    )
{
    LVITEM  lvItem = {0} ;

    ASSERT (sz) ;

    lvItem.mask     = LVIF_TEXT ;
    lvItem.iSubItem = iCol ;
    lvItem.pszText  = ConvertToUIString_ (sz) ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

BOOL
CListview::DeleteRow (
    int iRow
    )
{
    return ListView_DeleteItem (m_hwnd, iRow) ;
}

int
CListview::GetSelectedCount (
    )
{
    return ListView_GetSelectedCount (m_hwnd) ;
}

int
CListview::GetSelectedRow (
    int iStartRow
    )
{
    return ListView_GetNextItem (m_hwnd, iStartRow, LVNI_SELECTED) ;
}

DWORD_PTR
CListview::GetData (
    int iRow
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.iItem    = iRow ;
    lvItem.iSubItem = m_cColumns ;

    return ListView_GetItem (m_hwnd, & lvItem) ? lvItem.lParam : NULL ;
}

DWORD_PTR
CListview::GetData (
    )
{
    int iRow ;

    iRow = ListView_GetNextItem (m_hwnd, -1, LVNI_SELECTED) ;

    if (iRow == -1) {
        return NULL ;
    }

    return GetData (iRow) ;
}

DWORD
CListview::GetRowTextW (
    IN  int     iRow,
    IN  int     iCol,       //  0-based
    IN  int     cMax,
    OUT WCHAR * psz
    )
{
    int     len ;
    TCHAR * szUI ;

    len = cMax ;
    szUI = GetUICompatibleBuffer_ (psz, & len) ;
    ASSERT (szUI) ;

    //  leave room for the null-terminator
    ListView_GetItemText (m_hwnd, iRow, iCol, szUI, len - 1) ;

    ASSERT (len <= cMax) ;

    ConvertToUnicodeString_ (szUI, psz, len) ;

    return wcslen (psz) ;
}

int
CListview::GetRowTextW (
    IN  int     iRow,
    IN  int     iCol,       //  0-based
    OUT int *   val
    )
{
    WCHAR   achbuffer [32] ;

    ASSERT (val) ;
    * val = 0 ;

    if (GetRowTextW (iRow, iCol, 32, achbuffer)) {
        * val = _wtoi (achbuffer) ;
    }

    return (* val) ;
}

int
CListview::InsertColumnW (
    WCHAR * szColumnName,
    int ColumnWidth,
    int iCol
    )
{
    LVCOLUMN    lvColumn = {0} ;
    int         r ;

    ASSERT (szColumnName) ;

    lvColumn.mask       = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvColumn.fmt        = LVCFMT_LEFT;
    lvColumn.cx         = ColumnWidth ;
    lvColumn.pszText    = ConvertToUIString_ (szColumnName) ;

    r = ListView_InsertColumn (m_hwnd, iCol, & lvColumn) ;

    if (r != -1) {
        m_cColumns++ ;
    }

    return r ;
}

HIMAGELIST
CListview::SetImageList_ (
    HIMAGELIST  imgList,
    int         List
    )
{
    return ListView_SetImageList (m_hwnd, imgList, List) ;
}

HIMAGELIST
CListview::SetImageList_SmallIcons (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_SMALL) ;
}

HIMAGELIST
CListview::SetImageList_NormalIcons (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_NORMAL) ;
}

HIMAGELIST
CListview::SetImageList_State (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_STATE) ;
}

BOOL
CListview::SetState (
    int Index,
    int Row
    )
{
    //  setting or clearing ?
    if (Index > 0) {
        ListView_SetItemState (
                m_hwnd,
                Row,
                INDEXTOSTATEIMAGEMASK(Index),
                LVIS_STATEIMAGEMASK
                ) ;
    }
    else {
        ListView_SetItemState (m_hwnd, Row, 0, LVIS_STATEIMAGEMASK) ;
        ListView_RedrawItems (m_hwnd, Row, Row) ;
    }

    return TRUE ;
}

int
CListview::GetItemCount (
    )
{
    return (int) SendMessage (m_hwnd, LVM_GETITEMCOUNT, 0, 0) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\mp2demux\uictrl.h ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        uictrl.h

    Abstract:

        This module contains the class declarations for thin win32
        control wrappers which are used on the property pages

        MP2DEMUX is all unicode internally.  The COM interface string
        parameters are all unicode, so the only place where we may not
        be handling unicode strings is in the UI i.e. the property
        pages.  Consequently, we isolate the ansi <-> unicode functionality
        in these classes only.

        All calls into these classes are with UNICODE parameters.

        These classes are not thread-safe !!

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        06-Jul-1999     created 

--*/

#ifndef _mp2demux__uictrl_h
#define _mp2demux__uictrl_h

class CControlBase ;
class CEditControl ;
class CCombobox ;
class CListview ;

class AM_NOVTABLE CControlBase
{
    protected :

        HWND    m_hwnd ;
        DWORD   m_id ;

        //  include this only if we're ansi
#ifndef UNICODE     //  -------------------------------------------------------

        enum {
            MAX_STRING = 128        //  128 = max PIN_INFO.achName length
        } ;

        char    m_achBuffer [MAX_STRING] ;
        char *  m_pchScratch ;
        int     m_pchScratchMaxString ;

        char *
        GetScratch_ (
            IN OUT  int * pLen
            )
        /*++
            Fetches a scratch buffer.

            pLen
                IN      char count requested
                OUT     char count obtained
        --*/
        {
            //  the easy case
            if (* pLen <= m_pchScratchMaxString) {
                return m_pchScratch ;
            }
            //  a longer string than is currently available is requested
            else {
                ASSERT (* pLen > MAX_STRING) ;

                //  first free up m_pchScratch if it points to a 
                //  heap-allocated memory
                if (m_pchScratch != & m_achBuffer [0]) {
                    ASSERT (m_pchScratch != NULL) ;
                    delete [] m_pchScratch ;
                }

                //  allocate
                m_pchScratch = new char [* pLen] ;

                //  if the above call failed, we failover to the stack-
                //  allocated buffer
                if (m_pchScratch == NULL) {
                    m_pchScratch = & m_achBuffer [0] ;
                    * pLen = MAX_STRING ;
                }

                ASSERT (m_pchScratch != NULL) ;
                ASSERT (* pLen >= MAX_STRING) ;

                return m_pchScratch ;
            }
        }

#endif  //  UNICODE  ----------------------------------------------------------

        //  called when converting to UI char set
        TCHAR *
        ConvertToUIString_ (
            IN  WCHAR * sz
            ) ;

        //  called to obtain a UI-compatible buffer of the specified length
        TCHAR *
        GetUICompatibleBuffer_ (
            IN  WCHAR *     sz,
            IN OUT int *    pLen
            ) ;

        //  called with a UI-filled buffer; ensures that szUnicode has what sz
        //  points to; obtain sz via GetUICompatibleBuffer_ 
        WCHAR *
        ConvertToUnicodeString_ (
            IN  TCHAR * sz,             //  buffer to convert; null-terminated
            IN  WCHAR * szUnicode,      //  requested buffer
            IN  int     MaxLen          //  max length of szUnicode buffer
            ) ;

    public :

        CControlBase (
            HWND    hwnd, 
            DWORD   id
            ) ;

#ifndef UNICODE
        CControlBase::~CControlBase (
            )
        {
            //  if m_pchScratch points to heap-allocated memory, free it now
            if (m_pchScratch != & m_achBuffer [0]) {
                ASSERT (m_pchScratch != NULL) ;
                delete [] m_pchScratch ;
            }
        }
#endif  //  UNICODE

        HWND 
        GetHwnd (
            ) ;

        DWORD 
        GetId (
            ) ;

        virtual 
        LRESULT 
        ResetContent (
            ) = 0 ;
} ;

class CEditControl : 
    public CControlBase
{
    public :

        CEditControl (
            HWND    hwnd, 
            DWORD   id
            ) ;

        void
        SetTextW (
            WCHAR *
            ) ;

        void
        SetTextW (
            INT val
            ) ;

        int
        GetTextW (
            WCHAR *, 
            int MaxChars
            ) ;

        int
        GetTextW (
            INT *   val
            ) ;

        LRESULT
        ResetContent (
            ) ;
} ;

class CCombobox : 
    public CControlBase
{
    public :

        CCombobox (
            HWND    hwnd, 
            DWORD   id) ;

        int
        AppendW (
            WCHAR *
            ) ;

        int
        AppendW (
            INT val
            ) ;

        int
        InsertW (
            WCHAR *, 
            int index = 0
            ) ;

        int
        InsertW (
            INT val, 
            int index = 0
            ) ;

        BOOL
        DeleteRow (
            int 
            ) ;

        int
        GetItemCount (
            ) ;

        int
        GetTextW (
            WCHAR *, 
            int MaxChars
            ) ;

        int
        GetTextW (
            int *
            ) ;

        LRESULT
        ResetContent (
            ) ;

        int
        Focus (
            int index = 0
            ) ;

        int
        SetItemData (
            DWORD_PTR val, 
            int index
            ) ;

        DWORD_PTR
        GetCurrentItemData (
            DWORD_PTR *
            ) ;

        DWORD_PTR
        GetItemData (
            DWORD_PTR *, 
            int index
            ) ;

        int
        GetCurrentItemIndex (
            ) ;
} ;

class CListview : 
    public CControlBase
{
    int m_cColumns ;

    HIMAGELIST
    SetImageList_ (
        HIMAGELIST,
        int
        ) ;

    public :

        CListview (
            HWND hwnd, 
            DWORD id
            ) ;

        LRESULT
        ResetContent (
            ) ;

        HIMAGELIST
        SetImageList_SmallIcons (
            HIMAGELIST
            ) ;

        HIMAGELIST
        SetImageList_NormalIcons (
            HIMAGELIST
            ) ;

        HIMAGELIST
        SetImageList_State (
            HIMAGELIST
            ) ;

        int
        GetItemCount (
            ) ;

        BOOL
        SetState (
            int Index,      //  1-based; if 0, clears
            int Row
            ) ;

        int 
        InsertColumnW (
            WCHAR *, 
            int ColumnWidth, 
            int iCol = 0
            ) ;

        int
        InsertRowIcon (
            int
            ) ;

        int
        InsertRowTextW (
            WCHAR *, 
            int iCol = 1
            ) ;

        //  inserts a row, but converts the number to a string first
        int
        InsertRowNumber (
            int i,
            int iCol = 1
            ) ;

        int
        InsertRowValue (
            DWORD_PTR
            ) ;

        BOOL
        DeleteRow (
            int 
            ) ;

        BOOL
        SetData (
            DWORD_PTR   dwData, 
            int         iRow
            ) ;

        BOOL
        SetTextW (
            WCHAR *,
            int iRow, 
            int iCol
            ) ;

        int
        GetSelectedCount (
            ) ;

        int
        GetSelectedRow (
            int iStartRow = -1
            ) ;

        DWORD_PTR
        GetData (
            int iRow
            ) ;

        DWORD_PTR
        GetData (
            ) ;

        DWORD
        GetRowTextW (
            IN  int iRow,
            IN  int iCol,       //  0-based
            IN  int cMax,
            OUT WCHAR *
            ) ;

        int
        GetRowTextW (
            IN  int     iRow,
            IN  int     iCol,
            OUT int *   val
            ) ;
} ;


#endif  // _mp2demux__uictrl_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\atscproppage.cpp ===
// ATSCPropPage.cpp : Implementation of CATSCPropPage
#include "stdafx.h"
#include "NPPropPage.h"
#include "ATSCPropPage.h"

/////////////////////////////////////////////////////////////////////////////
// CATSCPropPage

void
CATSCPropPage::FillControlsFromLocator (
	IATSCLocator* pATSCLocator
	)
{
	if (!pATSCLocator)
		return;

	USES_CONVERSION;
	TCHAR	szText[MAX_PATH];
	CComBSTR genericString;
	long lGenericValue;
	HWND hwndControl;

	HRESULT hr = pATSCLocator->get_PhysicalChannel (&lGenericValue);
	if (SUCCEEDED (hr))
	{
		hwndControl = GetDlgItem (IDC_EDIT_PHYSICAL_CHANNEL);
		wsprintf (szText, _T("%ld"), lGenericValue);
		::SetWindowText (hwndControl,  szText);
	}
	hr = pATSCLocator->get_CarrierFrequency (&lGenericValue);
	if (SUCCEEDED (hr))
	{
		hwndControl = GetDlgItem (IDC_EDIT_CARRIER_FREQUENCY);
		wsprintf (szText, _T("%ld"), lGenericValue);
		::SetWindowText (hwndControl,  szText);
	}
	hr = pATSCLocator->get_SymbolRate (&lGenericValue);
	if (SUCCEEDED (hr))
	{
		hwndControl = GetDlgItem (IDC_EDIT_SYMBOL_RATE);
		wsprintf (szText, _T("%ld"), lGenericValue);
		::SetWindowText (hwndControl,  szText);
	}
	hr = pATSCLocator->get_TSID (&lGenericValue);
	if (SUCCEEDED (hr))
	{
		hwndControl = GetDlgItem (IDC_EDIT_TSID);
		wsprintf (szText, _T("%ld"), lGenericValue);
		::SetWindowText (hwndControl,  szText);
	}
	
	hwndControl = GetDlgItem (IDC_EDIT_MODULATION);
	::SetWindowText (hwndControl,  _T ("BDA_MOD_8VSB"));
}

void
CATSCPropPage::FillControlsFromTuneRequest (
	IATSCChannelTuneRequest* pTuneRequest
	)
{
	if (!pTuneRequest)
		return;
	
	//USES_CONVERSION;
	TCHAR	szText[MAX_PATH];
	long lChannel;
	HRESULT hr = pTuneRequest->get_Channel (&lChannel);
	//BUGBUG - add some error code stuff here
	if (SUCCEEDED (hr))
	{
		HWND hwndControl = GetDlgItem (IDC_EDIT_MAJOR_CHANNEL);
		wsprintf (szText, _T("%ld"), lChannel);
		::SetWindowText (hwndControl,  szText);
	}
	hr = pTuneRequest->get_MinorChannel (&lChannel);
	//BUGBUG - add some error code stuff here
	if (SUCCEEDED (hr))
	{
		HWND hwndControl = GetDlgItem (IDC_EDIT_MINOR_CHANNEL);
		wsprintf (szText, _T("%ld"), lChannel);
		::SetWindowText (hwndControl,  szText);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\dvbstunerequestpage.cpp ===
// DVBSTuneRequestPage.cpp : Implementation of CDVBSTuneRequestPage
#include "stdafx.h"
#include "NPPropPage.h"
#include "DVBSTuneRequestPage.h"
#include <comdef.h>
#include "misccell.h"


/////////////////////////////////////////////////////////////////////////////
// CDVBSTuneRequestPage

HRESULT
CDVBSTuneRequestPage::FillControlsFromTuneRequest (
    IDVBTuneRequest* pDVBSTuneRequest
    )
{
    HRESULT hr = S_OK;
    LONG lValue;
    hr = pDVBSTuneRequest->get_ONID (&lValue);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_FAILED_GET_ONID);
        return E_FAIL;
    }
    SetDlgItemInt (IDC_EDIT_ONID, lValue);
    
    hr = pDVBSTuneRequest->get_SID (&lValue);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_FAILED_GET_SID);
        return E_FAIL;
    }
    SetDlgItemInt (IDC_EDIT_SID, lValue);
    
    hr = pDVBSTuneRequest->get_TSID (&lValue);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_FAILED_GET_TSID);
        return E_FAIL;
    }
    SetDlgItemInt (IDC_EDIT_TSID, lValue);
    
    return hr;
}


HRESULT
CDVBSTuneRequestPage::FillControlFromLocator (
      IDVBSLocator* pLocator
      )
{
    //fill the combos
    FECMethod method;
    HRESULT hr = pLocator->get_InnerFEC (&method);
    if (SUCCEEDED (hr))
        SelectComboBoxFromString (IDC_COMBO_INNER_FEC, m_misc.ConvertFECMethodToString (method));
    hr = pLocator->get_InnerFEC (&method);
    BinaryConvolutionCodeRate binaryConv;
    hr = pLocator->get_InnerFECRate (&binaryConv);
    if (SUCCEEDED (hr))
        SelectComboBoxFromString (IDC_COMBO_FEC_RATE, m_misc.ConvertInnerFECRateToString (binaryConv));
    ModulationType modulation;
    hr = pLocator->get_Modulation (&modulation);
    if (SUCCEEDED (hr))
        SelectComboBoxFromString (IDC_COMBO_MODULATION, m_misc.ConvertModulationToString(modulation));
    hr = pLocator->get_OuterFEC (&method);
    if (SUCCEEDED (hr))
        SelectComboBoxFromString (IDC_COMBO_OUTER_FEC, m_misc.ConvertFECMethodToString (method));
    hr = pLocator->get_OuterFECRate (&binaryConv);
    if (SUCCEEDED (hr))
        SelectComboBoxFromString (IDC_COMBO_OUTER_FEC_RATE, m_misc.ConvertInnerFECRateToString (binaryConv));
    Polarisation polarisation;
    hr = pLocator->get_SignalPolarisation (&polarisation);
    if (SUCCEEDED (hr))
        SelectComboBoxFromString (IDC_COMBO_OUTER_SIGNAL_POLARISATION, m_misc.ConvertPolarisationToString(polarisation));
    //fill the edit boxes
    
    LONG lGeneric;
    hr = pLocator->get_CarrierFrequency (&lGeneric);
    if (SUCCEEDED (hr))
        SetDlgItemInt (IDC_EDIT_CARRIER_FREQUENCY, lGeneric);
    hr = pLocator->get_SymbolRate (&lGeneric);
    if (SUCCEEDED (hr))
        SetDlgItemInt (IDC_EDIT_SYMBOL_RATE, lGeneric);
    hr = pLocator->get_Azimuth (&lGeneric);
    if (SUCCEEDED (hr))
        SetDlgItemInt (IDC_EDIT_AZIMUTH, lGeneric);
    hr = pLocator->get_Elevation (&lGeneric);
    if (SUCCEEDED (hr))
        SetDlgItemInt (IDC_EDIT_ELEVATION, lGeneric);
    hr = pLocator->get_OrbitalPosition (&lGeneric);
    if (SUCCEEDED (hr))
        SetDlgItemInt (IDC_EDIT_ORBITAL_POSITION, lGeneric);
    //and finally the west position
    _variant_t var;
    var.vt = VT_BOOL;
    hr = pLocator->get_WestPosition (&var.boolVal);
    if (var.vt == VT_BOOL)
    {
        //weird - seems that -1 == TRUE
        CheckDlgButton (IDC_CHECK_WEST_POSITION, (var.boolVal == -1)?BST_CHECKED:BST_UNCHECKED);
    }
    return hr;
}

int 
CDVBSTuneRequestPage::AddItemToListBox (
    CComBSTR	strItem, 
    IDVBSTuningSpace* const dwData
    )
{
    USES_CONVERSION;
    HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
    int nIndex = ::SendMessage(
        hwndListBox, 
        LB_ADDSTRING, 
        0, 
        reinterpret_cast <LPARAM> (W2T(strItem))
        );
    ::SendMessage(
        hwndListBox, 
        LB_SETITEMDATA, 
        nIndex, 
        reinterpret_cast <LPARAM> (dwData)
        );
    //if we succeesfully inserted in the list
    if (nIndex != LB_ERR)
    {
        m_tunigSpaceList.push_back (dwData);
    }
    else
    {
        //seems that smtg went wrong
        ASSERT (FALSE);
        dwData->Release ();
    }
    return nIndex;
}

void
CDVBSTuneRequestPage::SelectComboBoxFromString (
    UINT nID, 
    CComBSTR strToFind
    )
{
    USES_CONVERSION;
    HWND hwndControl = GetDlgItem (nID);
    int nIndex = ::SendMessage (
        hwndControl,
        CB_FINDSTRING,
        -1,
        reinterpret_cast <LPARAM> (W2T(strToFind))
        );
    
    ::SendMessage (
        hwndControl,
        CB_SETCURSEL,
        nIndex,
        0
        );
}

CComBSTR 
CDVBSTuneRequestPage::GetComboText (
    UINT nID
    )
{
    HWND hwndControl = GetDlgItem (nID);
    int nIndex = ::SendMessage (
        hwndControl,
        CB_GETCURSEL,
        0,
        0
        );
    
    TCHAR	szText[MAX_PATH];
    ::SendMessage (
        hwndControl,
        CB_GETLBTEXT,
        nIndex,
        reinterpret_cast <LPARAM> (szText)
        );
    return CComBSTR (szText);
}

HRESULT
CDVBSTuneRequestPage::FillLocatorFromControls (
    IDVBSLocator* pLocator
    )
{
    USES_CONVERSION;
    //fill the combos
    CComBSTR genericString;
    genericString = GetComboText (IDC_COMBO_INNER_FEC);
    HRESULT hr = pLocator->put_InnerFEC (m_misc.ConvertStringToFECMethod (W2A(genericString.m_str)));
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_INNERFEC);
        return E_FAIL;
    }
    genericString = GetComboText (IDC_COMBO_FEC_RATE);
    hr = pLocator->put_InnerFECRate (m_misc.ConvertStringToBinConvol (W2A(genericString.m_str)));
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_INNERFECRATE);
        return E_FAIL;
    }
    genericString = GetComboText (IDC_COMBO_MODULATION);
    hr = pLocator->put_Modulation (m_misc.ConvertStringToModulation (W2A(genericString.m_str)));
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_MODULATION);
        return E_FAIL;
    }
    genericString = GetComboText (IDC_COMBO_OUTER_FEC);
    hr = pLocator->put_OuterFEC (m_misc.ConvertStringToFECMethod (W2A(genericString.m_str)));
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_OUTERFEC);
        return E_FAIL;
    }
    genericString = GetComboText (IDC_COMBO_OUTER_FEC_RATE);
    hr = pLocator->put_OuterFECRate (m_misc.ConvertStringToBinConvol (W2A(genericString.m_str)));
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_OUTERFECRATE);
        return E_FAIL;
    }
    genericString = GetComboText (IDC_COMBO_OUTER_SIGNAL_POLARISATION);
    hr = pLocator->put_SignalPolarisation (m_misc.ConvertStringToPolarisation (W2A(genericString.m_str)));
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_SIGNALPOLARISATION);
        return E_FAIL;
    }
    
    //edit boxes
    //cannot use C++ casts here
    LONG lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_CARRIER_FREQUENCY)));
    hr = pLocator->put_CarrierFrequency (lValue);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_CARRIERFREQUENCY);
        return E_FAIL;
    }
    lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_SYMBOL_RATE)));
    hr = pLocator->put_SymbolRate (lValue);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_SYMBOLRATE);
        return E_FAIL;
    }
    lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_AZIMUTH)));
    hr = pLocator->put_Azimuth (lValue);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_AZIMUTH);
        return E_FAIL;
    }
    lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_ELEVATION)));
    hr = pLocator->put_Elevation (lValue);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_ELEVATION);
        return E_FAIL;
    }
    lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_ORBITAL_POSITION)));
    hr = pLocator->put_OrbitalPosition (lValue);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_ORBITALPOSITION);
        return E_FAIL;
    }
    
    int nCheckState = IsDlgButtonChecked (IDC_CHECK_WEST_POSITION);
    _variant_t var;
    var.vt = VT_BOOL;
    var.boolVal = (nCheckState == BST_CHECKED)?TRUE:FALSE;
    hr = pLocator->put_WestPosition (var.boolVal);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_WESTPOSITION );
        return E_FAIL;
    }
    return hr;
}

HRESULT
CDVBSTuneRequestPage::FillTuneRequestFromControls (
   IDVBTuneRequest* pTuneRequest
   )
{
   HRESULT hr = S_OK;
   LONG lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_ONID)));
   hr = pTuneRequest->put_ONID (lValue);
   if (FAILED (hr))
   {
       MESSAGEBOX (this, IDS_CANNOT_SET_ONID);
       return E_FAIL;
   }
   lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_TSID)));
   hr = pTuneRequest->put_TSID (lValue);
   if (FAILED (hr))
   {
       MESSAGEBOX (this, IDS_CANNOT_SET_TSID);
       return E_FAIL;
   }
   lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_SID)));
   hr = pTuneRequest->put_SID (lValue);
   if (FAILED (hr))
   {
       MESSAGEBOX (this, IDS_CANNOT_SET_SID);
       return E_FAIL;
   }
   return hr;
}

void
CDVBSTuneRequestPage::ReleaseTuningSpaces ()
{
   TUNING_SPACES::iterator it;
   for (it = m_tunigSpaceList.begin (); it != m_tunigSpaceList.end ();)
   {
       (*it)->Release ();
       m_tunigSpaceList.erase (it);
       it = m_tunigSpaceList.begin ();
   }
}

void 
CDVBSTuneRequestPage::EnableControls (
   BOOL bValue
   )
{
    ::EnableWindow (GetDlgItem (IDC_EDIT_ONID), bValue);
    ::EnableWindow (GetDlgItem (IDC_SPIN_ONID), bValue);
    ::EnableWindow (GetDlgItem (IDC_EDIT_TSID), bValue);
    ::EnableWindow (GetDlgItem (IDC_SPIN_TSID), bValue);
    ::EnableWindow (GetDlgItem (IDC_EDIT_SID), bValue);
    ::EnableWindow (GetDlgItem (IDC_SPIN_SID), bValue);
    ::EnableWindow (GetDlgItem (IDC_EDIT_CARRIER_FREQUENCY), bValue);
    ::EnableWindow (GetDlgItem (IDC_SPIN_CARRIER), bValue);
    ::EnableWindow (GetDlgItem (IDC_EDIT_SYMBOL_RATE), bValue); 
    ::EnableWindow (GetDlgItem (IDC_SPIN_SYMBOL_RATE), bValue);
    ::EnableWindow (GetDlgItem (IDC_EDIT_AZIMUTH), bValue);
    ::EnableWindow (GetDlgItem (IDC_SPIN_AZIMUTH), bValue);
    ::EnableWindow (GetDlgItem (IDC_EDIT_ELEVATION), bValue);
    ::EnableWindow (GetDlgItem (IDC_SPIN_ELEVATION), bValue);
    ::EnableWindow (GetDlgItem (IDC_EDIT_ORBITAL_POSITION), bValue);
    ::EnableWindow (GetDlgItem (IDC_SPIN_ORBITAL_POSITION), bValue);
    ::EnableWindow (GetDlgItem (IDC_CHECK_WEST_POSITION), bValue);
    ::EnableWindow (GetDlgItem (IDC_COMBO_INNER_FEC), bValue);
    ::EnableWindow (GetDlgItem (IDC_COMBO_FEC_RATE), bValue);
    ::EnableWindow (GetDlgItem (IDC_COMBO_MODULATION), bValue);
    ::EnableWindow (GetDlgItem (IDC_COMBO_OUTER_FEC), bValue);
    ::EnableWindow (GetDlgItem (IDC_COMBO_OUTER_FEC_RATE), bValue);
    ::EnableWindow (GetDlgItem (IDC_COMBO_OUTER_SIGNAL_POLARISATION), bValue);
    ::EnableWindow (GetDlgItem (IDC_BUTTON_SUBMIT_TUNE_REQUEST), bValue);
    ::EnableWindow (GetDlgItem (IDC_BUTTON_REST_TO_DEFAULT_LOCATOR), bValue);
    ::EnableWindow (GetDlgItem (IDC_LIST_TUNING_SPACES), bValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\dvbstunerequestpage.h ===
// DVBSTuneRequestPage.h : Declaration of the CDVBSTuneRequestPage

#ifndef __DVBSTUNEREQUESTPAGE_H_
#define __DVBSTUNEREQUESTPAGE_H_

#include "resource.h"       // main symbols
#include "misccell.h"
#include <list>

EXTERN_C const CLSID CLSID_DVBSTuneRequestPage;

/////////////////////////////////////////////////////////////////////////////
// CDVBSTuneRequestPage
class ATL_NO_VTABLE CDVBSTuneRequestPage :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDVBSTuneRequestPage, &CLSID_DVBSTuneRequestPage>,
	public IPropertyPageImpl<CDVBSTuneRequestPage>,
	public CDialogImpl<CDVBSTuneRequestPage>,
    public IBroadcastEvent
{
public:
	CDVBSTuneRequestPage() 
	{
		m_dwTitleID = IDS_TITLEDVBSTuneRequestPage;
		m_dwHelpFileID = IDS_HELPFILEDVBSTuneRequestPage;
		m_dwDocStringID = IDS_DOCSTRINGDVBSTuneRequestPage;
	}

	~CDVBSTuneRequestPage ()
	{
		ReleaseTuningSpaces ();
	}

	enum {IDD = IDD_DVBSTUNEREQUESTPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DVBSTUNEREQUESTPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDVBSTuneRequestPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
    COM_INTERFACE_ENTRY(IBroadcastEvent)
END_COM_MAP()

BEGIN_MSG_MAP(CDVBSTuneRequestPage)
	CHAIN_MSG_MAP(IPropertyPageImpl<CDVBSTuneRequestPage>)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_HANDLER(IDC_BUTTON_REST_TO_DEFAULT_LOCATOR, BN_CLICKED, OnClickedButton_rest_to_default_locator)
	COMMAND_HANDLER(IDC_BUTTON_SUBMIT_TUNE_REQUEST, BN_CLICKED, OnClickedButton_submit_tune_request)
	COMMAND_HANDLER(IDC_LIST_TUNING_SPACES, LBN_SELCHANGE, OnSelchangeList_tuning_spaces)
END_MSG_MAP()

    typedef IPropertyPageImpl<CDVBSTuneRequestPage> PPGBaseClass;

	void
	ReleaseTuningSpaces ();

	STDMETHOD(SetObjects)(ULONG nObjects, IUnknown** ppUnk)
	{
		// Use SetObjects to perform basic sanity checks on the objects whose properties will be set

		// This page can only handle a single object
		// and that object must support the IBDA_NetworkProvider interface.
		// We return E_INVALIDARG in any other situation

		HRESULT hr = E_INVALIDARG;
		if (nObjects == 1)								// Single object
		{
			CComQIPtr<IBDA_NetworkProvider> pNP(ppUnk[0]);	// Must support IBDA_NetworkProvider
			if (pNP)
				hr = PPGBaseClass::SetObjects(nObjects, ppUnk);
		}
		return hr;
	}
			
    STDMETHOD(Activate)(HWND hWndParent, LPCRECT prc, BOOL bModal)
    {
        // If we don't have any objects, this method should not be called
        // Note that OleCreatePropertyFrame will call Activate even if a call to SetObjects fails, so this check is required
        if (!m_ppUnk)
            return E_UNEXPECTED;
        
        // Use Activate to update the property page's UI with information
        // obtained from the objects in the m_ppUnk array
        
        // We update the page to display the Name and ReadOnly properties of the document
        
        // Call the base class
        HRESULT hr = PPGBaseClass::Activate(hWndParent, prc, bModal);
        
        if (!m_ppUnk[0])
            return E_UNEXPECTED;

        //if already advised, unadvise
        if (m_pBroadcastEventService)
        {
            CComQIPtr <IConnectionPoint> pConPoint(m_pBroadcastEventService);
            if (pConPoint)
                pConPoint->Unadvise (m_dwEventCookie);
            m_pBroadcastEventService.Release ();
        }

        IBroadcastEvent* pEvent = NULL;
        //register for events
        hr = CBDAMiscellaneous::RegisterForEvents (
            m_ppUnk[0], 
            static_cast<IBroadcastEvent*>(this),
            &pEvent, 
            m_dwEventCookie
            );
        if (SUCCEEDED (hr))
            m_pBroadcastEventService.Attach (pEvent);

		m_pTuner = m_ppUnk[0];
        if (!m_pTuner)
            return E_FAIL;
        
        ReleaseTuningSpaces ();
        HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
        ::SendMessage (hwndListBox, LB_RESETCONTENT, NULL, NULL);
        
        //get the tunning spaces
        CComPtr <IEnumTuningSpaces> pTuneSpaces;
        hr = m_pTuner->EnumTuningSpaces (&pTuneSpaces);
        bool bFound = false;
        if (SUCCEEDED (hr) && (pTuneSpaces))
        {
            ITuningSpace* pTuneSpace = NULL;
            IDVBSTuningSpace* pDVBSTuningSpace;
            while (pTuneSpaces->Next (1, &pTuneSpace, 0) == S_OK)
            {
                hr = pTuneSpace->QueryInterface(__uuidof (IDVBSTuningSpace), reinterpret_cast <void**> (&pDVBSTuningSpace));
                if (FAILED (hr) || (!pDVBSTuningSpace))
                {
                    ASSERT (FALSE);
                    continue;
                }
                CComBSTR uniqueName;
                hr = pDVBSTuningSpace->get_UniqueName (&uniqueName.m_str);
                if (FAILED (hr))
                    continue;
                //don't bother to release the DVBSTuningSpace pointers
                //they will be added to a list that will be released later
                AddItemToListBox (uniqueName, pDVBSTuningSpace);//we will identify the items from the name
                bFound = true;
            }
        }
        if (!bFound)
        {
            //no available tuning space so just disable all controls
            EnableControls (FALSE);
            return S_OK;
        }
        
        if (!m_pTuneRequest)
        {
            //Now, let's see if there is any current tunerequest we can get
            CComPtr <ITuneRequest> pTuneRequest;
            hr = m_pTuner->get_TuneRequest (&pTuneRequest);
            m_pTuneRequest = pTuneRequest;
        }
        
        CComPtr <ILocator>	pLocator;
        if (m_pTuneRequest)
        {
            hr = m_pTuneRequest->get_Locator (&pLocator);
            if (FAILED (hr) || (!pLocator))
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            CComQIPtr <IDVBSLocator>	pDVBSLocator (pLocator);
            if (!pDVBSLocator)
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            FillControlFromLocator (pDVBSLocator);
            
            //try to find the coresponding tuning space from the list
            CComPtr <ITuningSpace> pReferenceTuneSpace;
            hr = m_pTuneRequest->get_TuningSpace (&pReferenceTuneSpace);
            if (FAILED (hr) || (!pReferenceTuneSpace))
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            CComQIPtr <IDVBSTuningSpace> pDVBSReferenceTuningSpace (pReferenceTuneSpace);
            if (!pDVBSReferenceTuningSpace)
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            CComBSTR refUniqueName;
            hr = pDVBSReferenceTuningSpace->get_UniqueName (&refUniqueName.m_str);
            if (FAILED (hr))
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            TUNING_SPACES::iterator it = m_tunigSpaceList.begin ();
            CComBSTR uniqueName;
            int nCount = 0;
            while (it != m_tunigSpaceList.end ())
            {
                //BUGBUG - should check for all properties not only for UniqueName
                hr = (*it)->get_UniqueName (&uniqueName.m_str);
                if (FAILED (hr))
                {
                    ASSERT (FALSE);
                    EnableControls (FALSE);
                    return S_OK;
                }
                if (uniqueName == refUniqueName)
                {
                    //we found it, so select the proper tuning space from the list
                    HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
                    ::SendMessage (hwndListBox, LB_SETCURSEL, nCount, NULL);
                    break;
                }
                ++it;
                ++nCount;
            }
            FillControlsFromTuneRequest (m_pTuneRequest);
        }
        else
        {
            //no tune request so get the first tuning space from the list
            HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
            ::SendMessage (hwndListBox, LB_SETCURSEL, 0, NULL);
            LRESULT dwData = ::SendMessage (hwndListBox, LB_GETITEMDATA, 0, NULL);
            if (dwData == LB_ERR)
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            IDVBSTuningSpace* pSelTuningSpace = reinterpret_cast <IDVBSTuningSpace*> (dwData);
            if (!pSelTuningSpace)
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            hr = pSelTuningSpace->get_DefaultLocator (&pLocator);
            if (FAILED (hr) || (!pLocator))
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            CComQIPtr <IDVBSLocator>	pDVBSLocator (pLocator);
            if (!pDVBSLocator)
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            FillControlFromLocator (pDVBSLocator);
            SetDlgItemInt (IDC_EDIT_ONID, -1);
            SetDlgItemInt (IDC_EDIT_TSID, -1);
            SetDlgItemInt (IDC_EDIT_SID, -1);
        }
        
        //if everything went fine
        EnableControls (true);
        return S_OK;
}
    
    STDMETHOD(Apply)(void)
	{
		//ATLTRACE(_T("CDVBS_TuneRequest::Apply\n"));
		for (UINT i = 0; i < m_nObjects; i++)
		{
			// Do something interesting here
		}
		m_bDirty = FALSE;
		return S_OK;
	}

private:
	CComQIPtr <IScanningTuner>			m_pTuner;
	CComQIPtr <IMediaEventEx>			m_pEventInterface;
	CBDAMiscellaneous					m_misc;
	CComQIPtr <IDVBTuneRequest>			m_pTuneRequest;
    CComPtr     <IBroadcastEvent>       m_pBroadcastEventService;
    DWORD                               m_dwEventCookie;
	bool								m_fFirstTime;
	typedef	std::list <IDVBSTuningSpace*> TUNING_SPACES;
	TUNING_SPACES						m_tunigSpaceList;//mantaing a list of available tuning spaces 
														//so we can access them easier


	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		USES_CONVERSION;
		//set the spins
		HWND hwndSpin = GetDlgItem (IDC_SPIN_SID);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_ONID);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_CARRIER);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_SYMBOL_RATE);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_TSID);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_AZIMUTH);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_ELEVATION);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_ORBITAL_POSITION);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);

		//fill the combos
		HWND hwndCombo = GetDlgItem (IDC_COMBO_INNER_FEC);
		int nIndex = 0;
		MAP_FECMethod::iterator it;
		for (it = m_misc.m_FECMethodMap.begin ();it != m_misc.m_FECMethodMap.end ();it++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it).first.c_str()))) 
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_FEC_RATE);
		nIndex = 0;
		MAP_BinaryConvolutionCodeRate::iterator it2;
		for (it2 = m_misc.m_BinaryConvolutionCodeRateMap.begin ();it2 != m_misc.m_BinaryConvolutionCodeRateMap.end ();it2++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it2).first.c_str()))) 
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it2).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_MODULATION);
		nIndex = 0;
		MAP_ModulationType::iterator it3;
		for (it3 = m_misc.m_ModulationTypeMap.begin ();it3 != m_misc.m_ModulationTypeMap.end ();it3++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it3).first.c_str()))) 
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it3).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_OUTER_FEC);
		nIndex = 0;
		MAP_FECMethod::iterator it4;
		for (it4 = m_misc.m_FECMethodMap.begin ();it4 != m_misc.m_FECMethodMap.end ();it4++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it4).first.c_str()))) 
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it4).second
				);
			++nIndex;
		}		
		
		hwndCombo = GetDlgItem (IDC_COMBO_OUTER_FEC_RATE);
		nIndex = 0;
		MAP_BinaryConvolutionCodeRate::iterator it5;
		for (it5 = m_misc.m_BinaryConvolutionCodeRateMap.begin ();it5 != m_misc.m_BinaryConvolutionCodeRateMap.end ();it5++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it5).first.c_str()))) 
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it5).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_OUTER_SIGNAL_POLARISATION);
		nIndex = 0;
		MAP_Polarisation::iterator it6;
		for (it6 = m_misc.m_PolarisationMap.begin ();it6 != m_misc.m_PolarisationMap.end ();it6++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it6).first.c_str()))) 
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it6).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_SPECTRAL_INVERSION);
		nIndex = 0;
		MAP_SpectralInversion::iterator it7;
		for (it7 = m_misc.m_SpectralInversionMap.begin ();it7 != m_misc.m_SpectralInversionMap.end ();it7++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it7).first.c_str()))) 
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it7).second
				);
			++nIndex;
		}
		
		//SetModifiedFlag (false);
		return 0;
	}

	void
	SetModifiedFlag (bool fValue)
	{
		//this will also set the m_bDirty flag
		SetDirty (fValue);
		HWND hwndSubmit = GetDlgItem (IDC_BUTTON_SUBMIT_TUNE_REQUEST);
		::EnableWindow (hwndSubmit, fValue);
	}

	HRESULT
	FillControlFromLocator (
		IDVBSLocator* pLocator
		);

	HRESULT
	FillControlsFromTuneRequest (
		IDVBTuneRequest* pDVBSTuneRequest
		);

	HRESULT
	FillLocatorFromControls (
		IDVBSLocator* pLocator
		);

	HRESULT
	FillTuneRequestFromControls (IDVBTuneRequest* pTuneRequest);

	int 
	AddItemToListBox (
		CComBSTR	strItem, 
		IDVBSTuningSpace* const dwData
		);

	void
	SelectComboBoxFromString (
		UINT nID, 
		CComBSTR strToFind
		);

	CComBSTR 
	GetComboText (
		UINT nID
		);

	void 
	EnableControls (
		BOOL bValue
		);

	HRESULT
	GetSelectedTuningSpace (IDVBSTuningSpace** pTuneSpace)
	{
		HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
		int nSelIndex = ::SendMessage (hwndListBox, LB_GETCURSEL, NULL, NULL);
		if (nSelIndex == LB_ERR)
		{
			ASSERT (FALSE);
			return E_FAIL;
		}
		LRESULT dwData = ::SendMessage (hwndListBox, LB_GETITEMDATA, nSelIndex, NULL);
		if (dwData == LB_ERR)
		{
			ASSERT (FALSE);
			return E_FAIL;
		}

		IDVBSTuningSpace* pSelTuningSpace = reinterpret_cast <IDVBSTuningSpace*> (dwData);
		if (!pSelTuningSpace)
		{
			ASSERT (FALSE);
			return E_FAIL;
		}
		*pTuneSpace = pSelTuningSpace;
		(*pTuneSpace)->AddRef ();
		return S_OK;
	}

	HRESULT
	GetDVBSLocatorFromTuningSpace (IDVBSTuningSpace* pTuneSpace, IDVBSLocator** pDVBSLoc)
	{
		CComPtr <ILocator>	pLocator;
		HRESULT hr = pTuneSpace->get_DefaultLocator (&pLocator);
		if (FAILED (hr) || (!pLocator))
		{
			MESSAGEBOX (this, IDS_CANNOT_GET_DEFLOC);
			return E_FAIL;
		}
		CComQIPtr <IDVBSLocator> pDVBSLocator (pLocator);
		if (!pDVBSLocator)
		{
			MESSAGEBOX (this, IDS_CANNOT_GET_DEF_DVBSLOCATOR);
			return E_FAIL;
		}
		*pDVBSLoc = pDVBSLocator;
		(*pDVBSLoc)->AddRef ();
		return S_OK;
	}

	LRESULT OnClickedButton_rest_to_default_locator(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		CComPtr <IDVBSTuningSpace> pTuneSpace;
		HRESULT  hr =  GetSelectedTuningSpace (&pTuneSpace);
		if (FAILED (hr) || (!pTuneSpace))
		{
			ASSERT (FALSE);
			return 0;
		}

		CComPtr <IDVBSLocator> pDVBSLocator;
		GetDVBSLocatorFromTuningSpace (pTuneSpace, &pDVBSLocator);
		//no error
		FillControlFromLocator (pDVBSLocator);
		return 0;
	}

	LRESULT OnClickedButton_submit_tune_request(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		CComPtr <IDVBSTuningSpace> pTuneSpace;
		HRESULT hr = GetSelectedTuningSpace (&pTuneSpace);
		if (FAILED (hr) || (!pTuneSpace))
		{
			ASSERT (FALSE);
			return 0;
		}

		CComPtr <IDVBSLocator> pSelDVBSLocator;
		hr = GetDVBSLocatorFromTuningSpace (pTuneSpace, &pSelDVBSLocator);
		if (FAILED (hr) || (!pSelDVBSLocator))
		{
			ASSERT (FALSE);
			return 0;
		}

		hr = FillLocatorFromControls (pSelDVBSLocator);
		if (FAILED (hr))
		{
			ASSERT (FALSE);
			return 0;
		}

		ASSERT (m_pTuner);
		CComPtr <ITuneRequest> pTuneRequest;
		hr = pTuneSpace->CreateTuneRequest (&pTuneRequest);
		if (FAILED (hr) || (!pTuneRequest))
		{
			MESSAGEBOX (this, IDS_CANNOT_CREATE_NEW_TUNEREQUEST);
			return 0;
		}
		CComQIPtr <IDVBTuneRequest> pDVBSTuneRequest (pTuneRequest);
		if (!pDVBSTuneRequest)
		{
			MESSAGEBOX (this, IDS_CANNOT_RETRIEVE_DVBSTUNEREQUEST);
			return 0;
		}
		hr = pDVBSTuneRequest->put_Locator (pSelDVBSLocator);
		if (FAILED (hr))
		{
			MESSAGEBOX (this, IDS_CANNOT_SET_LOCATOR_FOR_TUNEREQUEST);
			return 0;
		}
		hr = FillTuneRequestFromControls (pDVBSTuneRequest);
		if (FAILED (hr))
		{
			//already pop-up a message error dialog box
			return 0;
		}
		hr = m_pTuner->put_TuneRequest (pDVBSTuneRequest);
		if (FAILED (hr))
		{
			MESSAGEBOX (this, IDS_CANNOT_PUT_TUNE_REQUEST);
			return 0;
		}

		return 0;
	}
	LRESULT OnSelchangeList_tuning_spaces(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		CComPtr <IDVBSTuningSpace> pTuneSpace;
		HRESULT  hr =  GetSelectedTuningSpace (&pTuneSpace);
		if (FAILED (hr) || (!pTuneSpace))
		{
			ASSERT (FALSE);
			return 0;
		}

		CComPtr <IDVBSLocator> pDVBSLocator;
		GetDVBSLocatorFromTuningSpace (pTuneSpace, &pDVBSLocator);
		//no error
		FillControlFromLocator (pDVBSLocator);		
		return 0;
	}

    STDMETHOD(Fire)(GUID EventID)
    {
#ifdef DEBUG
        TCHAR szInfo[MAX_PATH];
        CComBSTR bstrEventID;
        USES_CONVERSION;
        StringFromCLSID (EventID, &bstrEventID);
        wsprintf (szInfo, _T("Notification received for %s"), OLE2T (bstrEventID));
        ATLTRACE (szInfo);
#endif
        if (EventID == EVENTID_TuningChanged)
        {
            ATLTRACE ("Starting to refresh");
            Refresh ();        
        }
        return S_OK;
    }

    HRESULT Refresh ()
    {
        //get the tunning spaces
        //1. get the current tuning space
        CComPtr <ITuningSpace> pTuneSpace;
        CComPtr <ITuneRequest> pTuneRequest;
        
        HRESULT hr = m_pTuner->get_TuneRequest (&pTuneRequest);
        if ((FAILED (hr)) || (!pTuneRequest))
            return E_FAIL;
        
        if (m_pTuneRequest)
            m_pTuneRequest.Release ();
        m_pTuneRequest = pTuneRequest;
        if (!m_pTuneRequest)
            //could be just the first tune request, we will get notification again..
            return S_OK;
        FillControlsFromTuneRequest (m_pTuneRequest);
        return S_OK;
    }

    virtual void OnFinalMessage( HWND hWnd )
    {
        if (m_pBroadcastEventService)
        {
            CComQIPtr <IConnectionPoint> pConPoint(m_pBroadcastEventService);
            pConPoint->Unadvise (m_dwEventCookie);
        }
    }
};

#endif //__DVBSTUNEREQUESTPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\lasterrorwin.cpp ===
// LastErrorWin.cpp: implementation of the CLastErrorWin class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "LastErrorWin.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLastErrorWin::CLastErrorWin()
{

}

CLastErrorWin::~CLastErrorWin()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\atscproppage.h ===
// ATSCPropPage.h : Declaration of the CATSCPropPage

#ifndef __ATSCPROPPAGE_H_
#define __ATSCPROPPAGE_H_

#include "resource.h"       // main symbols

EXTERN_C const CLSID CLSID_ATSCPropPage;
#include "misccell.h"

/////////////////////////////////////////////////////////////////////////////
// CATSCPropPage
class ATL_NO_VTABLE CATSCPropPage :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATSCPropPage, &CLSID_ATSCPropPage>,
	public IPropertyPageImpl<CATSCPropPage>,
	public CDialogImpl<CATSCPropPage>,
    public IBroadcastEvent
{
public:
	CATSCPropPage():
	  m_bFirstTime (true)
	{
		m_dwTitleID = IDS_TITLEATSCPropPage;
		m_dwHelpFileID = IDS_HELPFILEATSCPropPage;
		m_dwDocStringID = IDS_DOCSTRINGATSCPropPage;
	}

	enum {IDD = IDD_ATSCPROPPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_ATSCPROPPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CATSCPropPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
    COM_INTERFACE_ENTRY(IBroadcastEvent)
END_COM_MAP()

BEGIN_MSG_MAP(CATSCPropPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_HANDLER(IDC_BUTTON_VALIDATE, BN_CLICKED, OnValidateTuneRequest)
	COMMAND_HANDLER(IDC_BUTTON_SUBMIT_TUNE_REQUEST, BN_CLICKED, OnSubmitTuneRequest)
	CHAIN_MSG_MAP(IPropertyPageImpl<CATSCPropPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    typedef IPropertyPageImpl<CATSCPropPage> PPGBaseClass;

	STDMETHOD(SetObjects)(ULONG nObjects, IUnknown** ppUnk)
	{
		// Use SetObjects to perform basic sanity checks on the objects whose properties will be set

		// This page can only handle a single object
		// and that object must support the IBDA_NetworkProvider interface.
		// We return E_INVALIDARG in any other situation

		HRESULT hr = E_INVALIDARG;
		if (nObjects == 1)								// Single object
		{
			CComQIPtr<IBDA_NetworkProvider> pNP(ppUnk[0]);	// Must support IBDA_NetworkProvider
			if (pNP)
				hr = PPGBaseClass::SetObjects(nObjects, ppUnk);
		}
		return hr;
	}
			
	STDMETHOD(Activate)(HWND hWndParent, LPCRECT prc, BOOL bModal)
	{
		// If we don't have any objects, this method should not be called
		// Note that OleCreatePropertyFrame will call Activate even if a call to SetObjects fails, so this check is required
		if (!m_ppUnk)
			return E_UNEXPECTED;

		// Use Activate to update the property page's UI with information
		// obtained from the objects in the m_ppUnk array

		// We update the page to display the Name and ReadOnly properties of the document

		// Call the base class
		HRESULT hr = PPGBaseClass::Activate(hWndParent, prc, bModal);

        if (!m_ppUnk[0])
            return E_UNEXPECTED;

        //if already advised, unadvise
        if (m_pBroadcastEventService)
        {
            CComQIPtr <IConnectionPoint> pConPoint(m_pBroadcastEventService);
            if (pConPoint)
                pConPoint->Unadvise (m_dwEventCookie);
            m_pBroadcastEventService.Release ();
        }

        IBroadcastEvent* pEvent = NULL;
        //register for events
        hr = CBDAMiscellaneous::RegisterForEvents (
            m_ppUnk[0], 
            static_cast<IBroadcastEvent*>(this),
            &pEvent, 
            m_dwEventCookie
            );
        if (SUCCEEDED (hr))
            m_pBroadcastEventService.Attach (pEvent);

		m_pTuner = m_ppUnk[0];
        if (!m_pTuner)
            return E_FAIL;

        return Refresh ();
	}
    
    STDMETHOD(Apply)(void)
	{
		//ATLTRACE(_T("CNP_CommonPage::Apply\n"));
		for (UINT i = 0; i < m_nObjects; i++)
		{
			// Do something interesting here
		}
		m_bDirty = FALSE;
		return S_OK;
	}
	
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		USES_CONVERSION;
		//set the spins
		HWND hwndSpin = GetDlgItem (IDC_SPIN_PHYSICAL_CHANNEL);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000); 
		hwndSpin = GetDlgItem (IDC_SPIN_MINOR_CHANNEL);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000); 
		hwndSpin = GetDlgItem (IDC_SPIN_MAJOR_CHANNEL);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		return 0;
	}

private:
	CComQIPtr   <IScanningTuner>			m_pTuner;
	CComQIPtr   <IATSCChannelTuneRequest>	m_pCurrentTuneRequest;
	CComQIPtr   <IMediaEventEx>			    m_pEventInterface;
    CComPtr     <IBroadcastEvent>           m_pBroadcastEventService;
	bool								    m_bFirstTime;
    DWORD                                   m_dwEventCookie;

	void
	FillControlsFromLocator (
		IATSCLocator* pATSCLocator
		);

	void
	FillControlsFromTuneRequest (
		IATSCChannelTuneRequest* pTuneRequest
		);

	HRESULT
	UpdateTuneRequest ()
	{
		if (!m_pCurrentTuneRequest)
			return E_FAIL;

		USES_CONVERSION;
		
		LONG lMinorChannel = GetDlgItemInt (IDC_EDIT_MINOR_CHANNEL);
		LONG lMajorChannel = GetDlgItemInt (IDC_EDIT_MAJOR_CHANNEL);
		LONG lPhysicalChannel = GetDlgItemInt (IDC_EDIT_PHYSICAL_CHANNEL);
		if (FAILED (m_pCurrentTuneRequest->put_Channel (lMajorChannel)))
		{
            MESSAGEBOX (this, IDS_PUT_CHANNEL);
			return S_OK;
		}
		if (FAILED (m_pCurrentTuneRequest->put_MinorChannel (lMinorChannel)))
		{
			MESSAGEBOX (this, IDS_PUT_MINOR_CHANNEL);
			return S_OK;
		}
		CComPtr <ILocator> pLocator;
		m_pCurrentTuneRequest->get_Locator (&pLocator);
		CComQIPtr <IATSCLocator> pATSCLocator (pLocator);
		if (!pATSCLocator)
		{
			MESSAGEBOX (this, IDS_CANNOT_IATSCLOCATOR);
			return S_OK;
		}
		if (FAILED (pATSCLocator->put_PhysicalChannel (lPhysicalChannel)))
		{
			MESSAGEBOX (this, IDS_PUT_PHYSICAL);
			return S_OK;
		}

		return S_OK;
	}

	LRESULT OnValidateTuneRequest(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (SUCCEEDED (UpdateTuneRequest ()))
		{
			if (FAILED(m_pTuner->Validate (m_pCurrentTuneRequest)))
			{
				MESSAGEBOX (this, IDS_NOT_VALID_TUNE_REQUEST);
				return S_OK;
			}
		}
				
		return S_OK;
	}

	LRESULT OnSubmitTuneRequest(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (SUCCEEDED (UpdateTuneRequest ()))
		{
			if (FAILED(m_pTuner->put_TuneRequest (m_pCurrentTuneRequest)))
			{
				MESSAGEBOX (this, IDS_CANNOT_SUBMIT_TUNE_REQUEST);
				return S_OK;
			}
		}
				
		return S_OK;
	}	

    STDMETHOD(Fire)(GUID EventID)
    {
#ifdef DEBUG
        TCHAR szInfo[MAX_PATH];
        CComBSTR bstrEventID;
        USES_CONVERSION;
        StringFromCLSID (EventID, &bstrEventID);
        wsprintf (szInfo, _T("Notification received for %s"), OLE2T (bstrEventID));
        ATLTRACE (szInfo);
#endif
        if (EventID == EVENTID_TuningChanged)
        {
            ATLTRACE ("Starting to refresh");
            Refresh ();        
        }
        return S_OK;
    }

    HRESULT Refresh ()
    {
		//get the tunning spaces
		//1. get the current tuning space
		CComPtr <ITuningSpace> pTuneSpace;
		CComPtr <ITuneRequest> pTuneRequest;

		HRESULT hr = m_pTuner->get_TuneRequest (&pTuneRequest);
		if ((FAILED (hr)) || (!pTuneRequest))
			return E_FAIL;

		if (m_pCurrentTuneRequest)
			m_pCurrentTuneRequest.Release ();
		m_pCurrentTuneRequest = pTuneRequest;
		if (!m_pCurrentTuneRequest)
            //could be just the first tune request, we will get notification again..
			return S_OK;
		FillControlsFromTuneRequest (m_pCurrentTuneRequest);
		CComPtr <ILocator> pLocator;
		m_pCurrentTuneRequest->get_Locator (&pLocator);
		CComQIPtr <IATSCLocator> pATSCLocator(pLocator);
		if (!pATSCLocator)
			return E_FAIL;
		FillControlsFromLocator (pATSCLocator);
        return S_OK;
    }

    virtual void OnFinalMessage( HWND hWnd )
    {
        if (m_pBroadcastEventService)
        {
            CComQIPtr <IConnectionPoint> pConPoint(m_pBroadcastEventService);
            pConPoint->Unadvise (m_dwEventCookie);
        }
    }
};

#endif //__ATSCPROPPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\dvbstuningspaces.cpp ===
// DVBSTuningSpaces.cpp : Implementation of CDVBSTuningSpaces
#include "stdafx.h"
#include "NPPropPage.h"
#include "DVBSTuningSpaces.h"
#include <comdef.h>

/////////////////////////////////////////////////////////////////////////////
// CDVBSTuningSpaces

HRESULT
CDVBSTuningSpaces::FillControlsFromTuningSpace (
	IDVBSTuningSpace* pTuningSpace
	)
{
	HRESULT hr = S_OK;
	USES_CONVERSION;
	CComBSTR	genericName;
	hr = pTuningSpace->get_UniqueName (&genericName);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_UNIQUENAME);
		return E_FAIL;
	}
	SetDlgItemText (IDC_EDIT_UNIQUE_NAME , W2T (genericName));
	CComBSTR	FriendlyName;
	hr = pTuningSpace->get_FriendlyName (&FriendlyName);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_FRIENDLYNAME);
		return E_FAIL;
	}
	SetDlgItemText (IDC_EDIT_FRIENDLY_NAME, W2T (FriendlyName));

	CComBSTR FrequencyMapping;
	hr = pTuningSpace->get_FrequencyMapping (&FrequencyMapping);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_FREQUENCYMAPPING);
		return E_FAIL;
	}
	SetDlgItemText (IDC_EDIT_FREQUENCY_MAPPING, W2T (FrequencyMapping));
	LONG lGeneric;
	hr = pTuningSpace->get_NetworkID (&lGeneric);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_NETWORKID);
		return E_FAIL;
	}
	SetDlgItemInt (IDC_EDIT_NETWORKID, lGeneric);
	hr = pTuningSpace->get_HighOscillator (&lGeneric);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_HIGHOSCILATOR);
		return E_FAIL;
	}
	SetDlgItemInt (IDC_EDIT_HIGH_OSCILLATOR, lGeneric);
	hr = pTuningSpace->get_LNBSwitch (&lGeneric);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_LNBSWITCH);
		return E_FAIL;
	}
	SetDlgItemInt (IDC_EDIT_LNBSwitch, lGeneric);
	CComBSTR inputRange;
	hr = pTuningSpace->get_InputRange (&inputRange);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_INPUTRANGE);
		return E_FAIL;
	}
	SetDlgItemText (IDC_EDIT_INPUT_RANGE, W2T(inputRange));
	hr = pTuningSpace->get_LowOscillator (&lGeneric);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_LOWOSCILLATOR);
		return E_FAIL;
	}
	SetDlgItemInt (IDC_EDIT_LOW_OSCILATOR, lGeneric);	

	SpectralInversion	spectralInv;
	hr = pTuningSpace->get_SpectralInversion (&spectralInv);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_SPECTRALINVERSION);
		return E_FAIL;
	}
	SelectComboBoxFromString (IDC_COMBO_SPECTRAL_INVERSION, m_misc.ConvertSpectralInversionToString (spectralInv));

	CComQIPtr <ILocator>	pLocator;
	CComQIPtr <IDVBSLocator>	pDVBSLocator;
	hr = pTuningSpace->get_DefaultLocator (&pLocator);
	if (FAILED (hr) || !pLocator)
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_ILOCATOR);
		return E_FAIL;
	}
	pDVBSLocator = pLocator;
	if (!pDVBSLocator)
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_DVBSLOCATOR);
		return E_FAIL;
	}
	FillControlFromLocator (pDVBSLocator);
	return hr;
}

HRESULT
CDVBSTuningSpaces::FillControlFromLocator (IDVBSLocator* pLocator)
{
	//fill the combos
	FECMethod method;
	HRESULT hr = pLocator->get_InnerFEC (&method);
	if (SUCCEEDED (hr))
		SelectComboBoxFromString (IDC_COMBO_INNER_FEC, m_misc.ConvertFECMethodToString (method));
	hr = pLocator->get_InnerFEC (&method);
	BinaryConvolutionCodeRate binaryConv;
	hr = pLocator->get_InnerFECRate (&binaryConv);
	if (SUCCEEDED (hr))
		SelectComboBoxFromString (IDC_COMBO_FEC_RATE, m_misc.ConvertInnerFECRateToString (binaryConv));
	ModulationType modulation;
	hr = pLocator->get_Modulation (&modulation);
	if (SUCCEEDED (hr))
		SelectComboBoxFromString (IDC_COMBO_MODULATION, m_misc.ConvertModulationToString(modulation));
	hr = pLocator->get_OuterFEC (&method);
	if (SUCCEEDED (hr))
		SelectComboBoxFromString (IDC_COMBO_OUTER_FEC, m_misc.ConvertFECMethodToString (method));
	hr = pLocator->get_OuterFECRate (&binaryConv);
	if (SUCCEEDED (hr))
		SelectComboBoxFromString (IDC_COMBO_OUTER_FEC_RATE, m_misc.ConvertInnerFECRateToString (binaryConv));
	Polarisation polarisation;
	hr = pLocator->get_SignalPolarisation (&polarisation);
	if (SUCCEEDED (hr))
		SelectComboBoxFromString (IDC_COMBO_OUTER_SIGNAL_POLARISATION, m_misc.ConvertPolarisationToString(polarisation));
	//fill the edit boxes

	LONG lGeneric;
	hr = pLocator->get_CarrierFrequency (&lGeneric);
	if (SUCCEEDED (hr))
		SetDlgItemInt (IDC_EDIT_CARRIER_FREQUENCY, lGeneric);
	hr = pLocator->get_SymbolRate (&lGeneric);
	if (SUCCEEDED (hr))
		SetDlgItemInt (IDC_EDIT_SYMBOL_RATE, lGeneric);
	hr = pLocator->get_Azimuth (&lGeneric);
	if (SUCCEEDED (hr))
		SetDlgItemInt (IDC_EDIT_AZIMUTH, lGeneric);
	hr = pLocator->get_Elevation (&lGeneric);
	if (SUCCEEDED (hr))
		SetDlgItemInt (IDC_EDIT_ELEVATION, lGeneric);
	hr = pLocator->get_OrbitalPosition (&lGeneric);
	if (SUCCEEDED (hr))
		SetDlgItemInt (IDC_EDIT_ORBITAL_POSITION, lGeneric);
	//and finally the west position
	_variant_t var;
	var.vt = VT_BOOL;
	hr = pLocator->get_WestPosition (&var.boolVal);
	if (var.vt == VT_BOOL)
	{
		//weird - seems that -1 == TRUE
		CheckDlgButton (IDC_CHECK_WEST_POSITION, (var.boolVal == -1)?BST_CHECKED:BST_UNCHECKED);
	}
	return hr;
}


int 
CDVBSTuningSpaces::AddItemToListBox (
	CComBSTR	strItem, 
	IDVBSTuningSpace* const dwData
	)
{
	USES_CONVERSION;
	HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
	int nIndex = ::SendMessage(
		hwndListBox, 
		LB_ADDSTRING, 
		0, 
		reinterpret_cast <LPARAM> (W2T(strItem))
		);
	::SendMessage(
		hwndListBox, 
		LB_SETITEMDATA, 
		nIndex, 
		reinterpret_cast <LPARAM> (dwData)
		);
	//if we succeesfully inserted in the list
	if (nIndex != LB_ERR)
	{
		m_tunigSpaceList.push_back (dwData);
	}
	else
	{
		//seems that smtg went wrong
		ASSERT (FALSE);
		dwData->Release ();
	}
	return nIndex;
}

void
CDVBSTuningSpaces::SelectComboBoxFromString (
	UINT nID, 
	CComBSTR strToFind
	)
{
	USES_CONVERSION;
	HWND hwndControl = GetDlgItem (nID);
	int nIndex = ::SendMessage (
		hwndControl,
		CB_FINDSTRING,
		-1,
		reinterpret_cast <LPARAM> (W2T(strToFind))
		);
		
	::SendMessage (
		hwndControl,
		CB_SETCURSEL,
		nIndex,
		0
		);
}

CComBSTR 
CDVBSTuningSpaces::GetComboText (
	UINT nID
	)
{
	HWND hwndControl = GetDlgItem (nID);
	int nIndex = ::SendMessage (
		hwndControl,
		CB_GETCURSEL,
		0,
		0
		);
		
	TCHAR	szText[MAX_PATH];
	::SendMessage (
		hwndControl,
		CB_GETLBTEXT,
		nIndex,
		reinterpret_cast <LPARAM> (szText)
		);
	return CComBSTR (szText);
}

HRESULT
CDVBSTuningSpaces::FillLocatorFromControls (
	IDVBSLocator* pLocator
	)
{
	USES_CONVERSION;
	//fill the combos
	CComBSTR genericString;
	genericString = GetComboText (IDC_COMBO_INNER_FEC);
	HRESULT hr = pLocator->put_InnerFEC (m_misc.ConvertStringToFECMethod (W2A(genericString.m_str)));
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_INNERFEC);
		return E_FAIL;
	}
	genericString = GetComboText (IDC_COMBO_FEC_RATE);
	hr = pLocator->put_InnerFECRate (m_misc.ConvertStringToBinConvol (W2A(genericString.m_str)));
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_INNERFECRATE);
		return E_FAIL;
	}
	genericString = GetComboText (IDC_COMBO_MODULATION);
	hr = pLocator->put_Modulation (m_misc.ConvertStringToModulation (W2A(genericString.m_str)));
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_MODULATION);
		return E_FAIL;
	}
	genericString = GetComboText (IDC_COMBO_OUTER_FEC);
	hr = pLocator->put_OuterFEC (m_misc.ConvertStringToFECMethod (W2A(genericString.m_str)));
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_OUTERFEC);
		return E_FAIL;
	}
	genericString = GetComboText (IDC_COMBO_OUTER_FEC_RATE);
	hr = pLocator->put_OuterFECRate (m_misc.ConvertStringToBinConvol (W2A(genericString.m_str)));
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_OUTERFECRATE);
		return E_FAIL;
	}
	genericString = GetComboText (IDC_COMBO_OUTER_SIGNAL_POLARISATION);
	hr = pLocator->put_SignalPolarisation (m_misc.ConvertStringToPolarisation (W2A(genericString.m_str)));
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_SIGNALPOLARISATION);
		return E_FAIL;
	}

	//edit boxes
	//cannot use C++ casts here
    BOOL bTrans;
	LONG lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_CARRIER_FREQUENCY, &bTrans)));
    if (!bTrans)
        lValue = -1;
	hr = pLocator->put_CarrierFrequency (lValue);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_CARRIERFREQUENCY);
		return E_FAIL;
	}
	lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_SYMBOL_RATE, &bTrans)));
    if (!bTrans)
        lValue = -1;
	hr = pLocator->put_SymbolRate (lValue);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_SYMBOLRATE);
		return E_FAIL;
	}
	lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_AZIMUTH, &bTrans)));
    if (!bTrans)
        lValue = -1;
	hr = pLocator->put_Azimuth (lValue);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_AZIMUTH);
		return E_FAIL;
	}
	lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_ELEVATION, &bTrans)));
    if (!bTrans)
        lValue = -1;
	hr = pLocator->put_Elevation (lValue);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_ELEVATION);
		return E_FAIL;
	}
	lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_ORBITAL_POSITION, &bTrans)));
    if (!bTrans)
        lValue = -1;
	hr = pLocator->put_OrbitalPosition (lValue);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_ORBITALPOSITION);
		return E_FAIL;
	}
		
	int nCheckState = IsDlgButtonChecked (IDC_CHECK_WEST_POSITION);
	_variant_t var;
	var.vt = VT_BOOL;
	var.boolVal = (nCheckState == BST_CHECKED)?-1:0;
	hr = pLocator->put_WestPosition (var.boolVal);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_WESTPOSITION);
		return E_FAIL;
	}
	return hr;
}

HRESULT
CDVBSTuningSpaces::FillTuningSpaceFromControls (
	IDVBSTuningSpace* pTuningSpace
	)
{
	HRESULT hr = S_OK;
	USES_CONVERSION;
	CComBSTR	genericName;
	GetDlgItemText (IDC_EDIT_UNIQUE_NAME , genericName.m_str);
	hr = pTuningSpace->put_UniqueName (genericName);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_UNIQUENAME);
		return E_FAIL;
	}
	
	GetDlgItemText (IDC_EDIT_FRIENDLY_NAME, genericName.m_str);
	hr = pTuningSpace->put_FriendlyName (genericName);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_FRIENDLYNAME);
		return E_FAIL;
	}

	GetDlgItemText (IDC_EDIT_FREQUENCY_MAPPING, genericName.m_str);
    if (genericName.Length () == 0)
        genericName = L"-1";
	hr = pTuningSpace->put_FrequencyMapping (genericName);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_FREQUENCYMAPPING);
		return E_FAIL;
	}

	LONG lGeneric;
    BOOL bTrans;
	lGeneric = GetDlgItemInt (IDC_EDIT_NETWORKID, &bTrans);
    if (!bTrans)
        lGeneric = -1;
	hr = pTuningSpace->put_NetworkID (lGeneric);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_NETWORKID);
		return E_FAIL;
	}
	lGeneric = GetDlgItemInt (IDC_EDIT_HIGH_OSCILLATOR, &bTrans);
    if (!bTrans)
        lGeneric = -1;
	hr = pTuningSpace->put_HighOscillator (lGeneric);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_HIGHOSCILATOR);
		return E_FAIL;
	}
	lGeneric = GetDlgItemInt (IDC_EDIT_LNBSwitch, &bTrans);
    if (!bTrans)
        lGeneric = -1;
	hr = pTuningSpace->put_LNBSwitch (lGeneric);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_LNBSWITCH);
		return E_FAIL;
	}
	GetDlgItemText (IDC_EDIT_INPUT_RANGE, genericName.m_str);
    if (genericName.Length () == 0)
        genericName = L"-1";
	hr = pTuningSpace->put_InputRange (genericName);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_INPUTRANGE);
		return E_FAIL;
	}
	lGeneric = GetDlgItemInt (IDC_EDIT_LOW_OSCILATOR, &bTrans);
    if (!bTrans)
        lGeneric = -1;
	hr = pTuningSpace->put_LowOscillator (lGeneric);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_LOWOSCILLATOR);
		return E_FAIL;
	}

	genericName = GetComboText (IDC_COMBO_SPECTRAL_INVERSION);
	hr = pTuningSpace->put_SpectralInversion (m_misc.ConvertStringToSpectralInversion (W2A(genericName)));
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_SPECTRALINVERSION);
		return E_FAIL;
	}

	hr = pTuningSpace->put_NetworkType (m_bstrNetworkType);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_NETWORKTYPE);
		return E_FAIL;
	}
	return hr;
}

void
CDVBSTuningSpaces::FillDefaultControls ()
{
    //locator first
	SelectComboBoxFromString (IDC_COMBO_INNER_FEC, m_misc.ConvertFECMethodToString (BDA_FEC_METHOD_NOT_SET));
	SelectComboBoxFromString (IDC_COMBO_FEC_RATE, m_misc.ConvertInnerFECRateToString (BDA_BCC_RATE_NOT_SET));
	SelectComboBoxFromString (IDC_COMBO_MODULATION, m_misc.ConvertModulationToString(BDA_MOD_NOT_SET));
    SelectComboBoxFromString (IDC_COMBO_OUTER_FEC, m_misc.ConvertFECMethodToString (BDA_FEC_METHOD_NOT_SET));
	SelectComboBoxFromString (IDC_COMBO_OUTER_FEC_RATE, m_misc.ConvertInnerFECRateToString (BDA_BCC_RATE_NOT_SET));
	SelectComboBoxFromString (IDC_COMBO_OUTER_SIGNAL_POLARISATION, m_misc.ConvertPolarisationToString(BDA_POLARISATION_NOT_SET));
	//fill the edit boxes

	SetDlgItemInt (IDC_EDIT_CARRIER_FREQUENCY, -1);
	SetDlgItemInt (IDC_EDIT_SYMBOL_RATE, -1);
	SetDlgItemInt (IDC_EDIT_AZIMUTH, -1);
	SetDlgItemInt (IDC_EDIT_ELEVATION, -1);
	SetDlgItemInt (IDC_EDIT_ORBITAL_POSITION, -1);
    //fill the tuning space now...
	SetDlgItemInt (IDC_EDIT_NETWORKID, -1);
	SetDlgItemInt (IDC_EDIT_HIGH_OSCILLATOR, -1);
	SetDlgItemInt (IDC_EDIT_LNBSwitch, -1);
	SetDlgItemInt (IDC_EDIT_LOW_OSCILATOR, -1);
	SelectComboBoxFromString (IDC_COMBO_SPECTRAL_INVERSION, m_misc.ConvertSpectralInversionToString (BDA_SPECTRAL_INVERSION_NOT_SET));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\dvbstuningspaces.h ===
// DVBSTuningSpaces.h : Declaration of the CDVBSTuningSpaces

#ifndef __DVBSTUNINGSPACES_H_
#define __DVBSTUNINGSPACES_H_

#include "resource.h"       // main symbols
#include "misccell.h"
#include <list>

EXTERN_C const CLSID CLSID_DVBSTuningSpaces;

/////////////////////////////////////////////////////////////////////////////
// CDVBSTuningSpaces
class ATL_NO_VTABLE CDVBSTuningSpaces :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDVBSTuningSpaces, &CLSID_DVBSTuningSpaces>,
	public IPropertyPageImpl<CDVBSTuningSpaces>,
	public CDialogImpl<CDVBSTuningSpaces>
{
public:
	CDVBSTuningSpaces()
	{
		m_dwTitleID = IDS_TITLEDVBSTuningSpaces;
		m_dwHelpFileID = IDS_HELPFILEDVBSTuningSpaces;
		m_dwDocStringID = IDS_DOCSTRINGDVBSTuningSpaces;
		m_bstrNetworkType = L"{FA4B375A-45B4-4d45-8440-263957B11623}";//DVBS Network Type
	}

	~CDVBSTuningSpaces()
	{
		ReleaseTuningSpaces ();
	}


	enum {IDD = IDD_DVBSTUNINGSPACES};

DECLARE_REGISTRY_RESOURCEID(IDR_DVBSTUNINGSPACES)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDVBSTuningSpaces) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDVBSTuningSpaces)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	CHAIN_MSG_MAP(IPropertyPageImpl<CDVBSTuningSpaces>)
	COMMAND_HANDLER(IDC_BUTTON_NEW_TUNING_SPACE, BN_CLICKED, OnClickedButton_new_tuning_space)
	COMMAND_HANDLER(IDC_BUTTON_SUBMIT_TUNING_SPACE, BN_CLICKED, OnClickedButton_submit_tuning_space)
	COMMAND_HANDLER(IDC_LIST_TUNING_SPACES, LBN_SELCHANGE, OnSelchangeList_tuning_spaces)
	COMMAND_HANDLER(IDC_CHECK_WEST_POSITION, BN_CLICKED, OnClickedCheck_west_position)
	COMMAND_HANDLER(IDC_COMBO_FEC_RATE, CBN_SELCHANGE, OnSelchangeCombo_fec_rate)
	COMMAND_HANDLER(IDC_COMBO_INNER_FEC, CBN_SELCHANGE, OnSelchangeCombo_inner_fec)
	COMMAND_HANDLER(IDC_COMBO_MODULATION, CBN_SELCHANGE, OnSelchangeCombo_modulation)
	COMMAND_HANDLER(IDC_COMBO_OUTER_FEC, CBN_SELCHANGE, OnSelchangeCombo_outer_fec)
	COMMAND_HANDLER(IDC_COMBO_OUTER_FEC_RATE, CBN_SELCHANGE, OnSelchangeCombo_outer_fec_rate)
	COMMAND_HANDLER(IDC_COMBO_OUTER_SIGNAL_POLARISATION, CBN_SELCHANGE, OnSelchangeCombo_outer_signal_polarisation)
	COMMAND_HANDLER(IDC_COMBO_SPECTRAL_INVERSION, CBN_SELCHANGE, OnSelchangeCombo_spectral_inversion)
	COMMAND_HANDLER(IDC_EDIT_AZIMUTH, EN_CHANGE, OnChangeEdit_azimuth)
	COMMAND_HANDLER(IDC_EDIT_CARRIER_FREQUENCY, EN_CHANGE, OnChangeEdit_carrier_frequency)
	COMMAND_HANDLER(IDC_EDIT_ELEVATION, EN_CHANGE, OnChangeEdit_elevation)
	COMMAND_HANDLER(IDC_EDIT_FREQUENCY_MAPPING, EN_CHANGE, OnChangeEdit_frequency_mapping)
	COMMAND_HANDLER(IDC_EDIT_FRIENDLY_NAME, EN_CHANGE, OnChangeEdit_friendly_name)
	COMMAND_HANDLER(IDC_EDIT_HIGH_OSCILLATOR, EN_CHANGE, OnChangeEdit_high_oscillator)
	COMMAND_HANDLER(IDC_EDIT_INPUT_RANGE, EN_CHANGE, OnChangeEdit_input_range)
	COMMAND_HANDLER(IDC_EDIT_LNBSwitch, EN_CHANGE, OnChangeEdit_lnbswitch)
	COMMAND_HANDLER(IDC_EDIT_LOW_OSCILATOR, EN_CHANGE, OnChangeEdit_low_oscilator)
	COMMAND_HANDLER(IDC_EDIT_NETWORKID, EN_CHANGE, OnChangeEdit_networkid)
	COMMAND_HANDLER(IDC_EDIT_ORBITAL_POSITION, EN_CHANGE, OnChangeEdit_orbital_position)
	COMMAND_HANDLER(IDC_EDIT_SYMBOL_RATE, EN_CHANGE, OnChangeEdit_symbol_rate)
	COMMAND_HANDLER(IDC_EDIT_UNIQUE_NAME, EN_CHANGE, OnChangeEdit_unique_name)
    MESSAGE_HANDLER(WM_VKEYTOITEM, OnListKeyItem)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    typedef IPropertyPageImpl<CDVBSTuningSpaces> PPGBaseClass;

	void
	ReleaseTuningSpaces ()
	{
		TUNING_SPACES::iterator it;
		for (it = m_tunigSpaceList.begin (); it != m_tunigSpaceList.end ();)
		{
			(*it)->Release ();
			m_tunigSpaceList.erase (it);
			it = m_tunigSpaceList.begin ();
		}
	}

	STDMETHOD(SetObjects)(ULONG nObjects, IUnknown** ppUnk)
	{
		// Use SetObjects to perform basic sanity checks on the objects whose properties will be set

		// This page can only handle a single object
		// and that object must support the IBDA_NetworkProvider interface.
		// We return E_INVALIDARG in any other situation

		HRESULT hr = E_INVALIDARG;
		if (nObjects == 1)								// Single object
		{
			CComQIPtr<IBDA_NetworkProvider> pNP(ppUnk[0]);	// Must support IBDA_NetworkProvider
			if (pNP)
				hr = PPGBaseClass::SetObjects(nObjects, ppUnk);
		}
		return hr;
	}
			
	STDMETHOD(Activate)(HWND hWndParent, LPCRECT prc, BOOL bModal)
	{
		// If we don't have any objects, this method should not be called
		// Note that OleCreatePropertyFrame will call Activate even if a call to SetObjects fails, so this check is required
		if (!m_ppUnk)
			return E_UNEXPECTED;

		// Use Activate to update the property page's UI with information
		// obtained from the objects in the m_ppUnk array

		// We update the page to display the Name and ReadOnly properties of the document

		// Call the base class
		HRESULT hr = S_OK;
		if (!this->m_hWnd)
			hr = PPGBaseClass::Activate(hWndParent, prc, bModal);
		
		//if already been through this skip it
		if (m_pTuner)
			return S_OK;
		
		if (!m_ppUnk[0])
			return E_UNEXPECTED;

		m_pTuner = m_ppUnk[0];
		if (!m_pTuner)
			return E_FAIL;
				
		//clear the tuning spaces both from the list and memory
		ReleaseTuningSpaces ();
		HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
		::SendMessage (hwndListBox, LB_RESETCONTENT, NULL, NULL);

		//get the tunning spaces
		CComPtr <IEnumTuningSpaces> pTuneSpaces;
		hr = m_pTuner->EnumTuningSpaces (&pTuneSpaces);
		IDVBSTuningSpace* pDVBSTuningSpace = NULL;
		if (SUCCEEDED (hr) && (pTuneSpaces))
		{
			ITuningSpace* pTuneSpace = NULL;
			while (pTuneSpaces->Next (1, &pTuneSpace, 0) == S_OK)
			{
				hr = pTuneSpace->QueryInterface(__uuidof (IDVBSTuningSpace), reinterpret_cast <void**> (&pDVBSTuningSpace));
				if (FAILED (hr) || (!pDVBSTuningSpace))
				{
					ASSERT (FALSE);
					continue;
				}
				CComBSTR uniqueName;
				hr = pDVBSTuningSpace->get_UniqueName (&uniqueName.m_str);
				if (FAILED (hr))
					continue;
				//don't bother to release the DVBSTuningSpace pointers
				//they will be added to a list that will be released later
				AddItemToListBox (uniqueName, pDVBSTuningSpace);//we will identify the items from the name
			}
		}

		if (pDVBSTuningSpace)
		{
			//if there is any existing tuning space available,
			//select the last one

			//select the last tuning space
			int nCount = ::SendMessage (hwndListBox, LB_GETCOUNT , NULL, NULL);
			::SendMessage (hwndListBox, LB_SETCURSEL, nCount-1, NULL);

			//fill with the last tuning space we got
			FillControlsFromTuningSpace (pDVBSTuningSpace);
		}
        else
        {
            //fill with default values
            FillDefaultControls ();
        }

		SetModifiedFlag (false);
		return S_OK;
	}
    
    STDMETHOD(Apply)(void)
	{
		//ATLTRACE(_T("CNP_CommonPage::Apply\n"));
		for (UINT i = 0; i < m_nObjects; i++)
		{
			// Do something interesting here
		}
		m_bDirty = FALSE;
		return S_OK;
	}
	
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		USES_CONVERSION;
		//set the spins
		HWND hwndSpin = GetDlgItem (IDC_SPIN_NETWORKID);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000); 
		hwndSpin = GetDlgItem (IDC_SPIN_MINMINOR_CHANNEL);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000); 
		hwndSpin = GetDlgItem (IDC_SPIN_HIGH_OSCILLATOR);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_LNBSwitch);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_LOW_OSCILATOR);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_CARRIER);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_SYMBOL_RATE);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_TSID);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_AZIMUTH);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_ELEVATION);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_ORBITAL_POSITION);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);

		//fill the combos
		HWND hwndCombo = GetDlgItem (IDC_COMBO_INNER_FEC);
		int nIndex = 0;
		MAP_FECMethod::iterator it;
		for (it = m_misc.m_FECMethodMap.begin ();it != m_misc.m_FECMethodMap.end ();it++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it).first.c_str()))) 
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_FEC_RATE);
		nIndex = 0;
		MAP_BinaryConvolutionCodeRate::iterator it2;
		for (it2 = m_misc.m_BinaryConvolutionCodeRateMap.begin ();it2 != m_misc.m_BinaryConvolutionCodeRateMap.end ();it2++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it2).first.c_str())))
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it2).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_MODULATION);
		nIndex = 0;
		MAP_ModulationType::iterator it3;
		for (it3 = m_misc.m_ModulationTypeMap.begin ();it3 != m_misc.m_ModulationTypeMap.end ();it3++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it3).first.c_str())))
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it3).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_OUTER_FEC);
		nIndex = 0;
		MAP_FECMethod::iterator it4;
		for (it4 = m_misc.m_FECMethodMap.begin ();it4 != m_misc.m_FECMethodMap.end ();it4++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it4).first.c_str())))
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it4).second
				);
			++nIndex;
		}		
		
		hwndCombo = GetDlgItem (IDC_COMBO_OUTER_FEC_RATE);
		nIndex = 0;
		MAP_BinaryConvolutionCodeRate::iterator it5;
		for (it5 = m_misc.m_BinaryConvolutionCodeRateMap.begin ();it5 != m_misc.m_BinaryConvolutionCodeRateMap.end ();it5++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it5).first.c_str())))
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it5).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_OUTER_SIGNAL_POLARISATION);
		nIndex = 0;
		MAP_Polarisation::iterator it6;
		for (it6 = m_misc.m_PolarisationMap.begin ();it6 != m_misc.m_PolarisationMap.end ();it6++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it6).first.c_str())))
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it6).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_SPECTRAL_INVERSION);
		nIndex = 0;
		MAP_SpectralInversion::iterator it7;
		for (it7 = m_misc.m_SpectralInversionMap.begin ();it7 != m_misc.m_SpectralInversionMap.end ();it7++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it7).first.c_str())))
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it7).second
				);
			++nIndex;
		}
		
		SetModifiedFlag (false);
		return 0;
	}

	STDMETHOD(Deactivate)( )
	{
		//overwrite the default behavior that was destroying the window
		//all the time
		return S_OK;
	}

private:
	CComQIPtr <IScanningTuner>			m_pTuner;
	CComQIPtr <IMediaEventEx>			m_pEventInterface;
	CBDAMiscellaneous					m_misc;
	bool								m_fFirstTime;
	typedef	std::list <IDVBSTuningSpace*> TUNING_SPACES;
	TUNING_SPACES						m_tunigSpaceList;//mantaing a list of available tuning spaces 
														//so we can access them easier
	CComBSTR							m_bstrNetworkType;

	static UINT m_NotifyMessage;

    void
    FillDefaultControls ();

	int
	AddItemToListBox (
		CComBSTR	strItem, 
		IDVBSTuningSpace* const dwData
		);

	void
	SelectComboBoxFromString (
		UINT nID, 
		CComBSTR strToFind
		);

	CComBSTR 
	GetComboText (
		UINT nID
		);

	HRESULT
	FillControlsFromTuningSpace (IDVBSTuningSpace* pTuningSpace);

	HRESULT
	FillControlFromLocator (IDVBSLocator* pLocator);

	HRESULT
	FillLocatorFromControls (IDVBSLocator* pLocator);

	HRESULT
	FillTuningSpaceFromControls (IDVBSTuningSpace* pTuningSpace);

	void
	SetModifiedFlag (bool fValue)
	{
		//this will also set the m_bDirty flag
		SetDirty (fValue);
		HWND hwndSubmit = GetDlgItem (IDC_BUTTON_SUBMIT_TUNING_SPACE);
		::EnableWindow (hwndSubmit, fValue);
	}

	LRESULT OnClickedButton_new_tuning_space(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		//let's clear all fields
        HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
        int nSelIndex = ::SendMessage (hwndListBox, LB_GETCURSEL , NULL, NULL);
        if (nSelIndex >= 0)
        {//we already have a selection, so try a clone
            SetDlgItemText (IDC_EDIT_UNIQUE_NAME, _T(""));
        }
        else
        {
            FillDefaultControls ();
        }
		
        //clear the current selection so the user will not be confused
		int nVal = ::SendMessage (hwndListBox, LB_SETCURSEL , -1, NULL);
		SetModifiedFlag (true);
		return 0;
	}

	LRESULT OnClickedButton_submit_tuning_space(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
        HRESULT hr = S_OK;
        bool bIsNew = false;
        CComPtr <IDVBSTuningSpace> pTuningSpace;
		CComQIPtr <IDVBSLocator> pDVBSLocator;
        //try to get a tuning space, either from the list, either creating a new one
        HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
		int nTunIndex = ::SendMessage (hwndListBox, LB_GETCURSEL, NULL, NULL);
        if (nTunIndex == LB_ERR)
            bIsNew = true;

        //just create a tuning space so we can check if it's unique or not
        hr = CoCreateInstance (
			CLSID_DVBSTuningSpace, 
			NULL, 
			CLSCTX_INPROC_SERVER, 
			__uuidof (IDVBSTuningSpace),
			reinterpret_cast <PVOID*> (&pTuningSpace)
			);
		if (FAILED (hr) || (!pTuningSpace))
		{
			MESSAGEBOX (this, IDS_CANNOT_INSTANTIATE_DVBSTUNE);
			return 0;
		}
		hr = CoCreateInstance (
			CLSID_DVBSLocator, 
			NULL, 
			CLSCTX_INPROC_SERVER, 
			__uuidof (IDVBSLocator),
			reinterpret_cast <PVOID*> (&pDVBSLocator)
			);
		if (!pDVBSLocator)
		{
			MESSAGEBOX (this, IDS_CANNOT_GET_IDVBSLOCATOR);
			return 0;
		}

		if (FAILED (FillLocatorFromControls (pDVBSLocator)))
			return 0;
		pTuningSpace->put_DefaultLocator (pDVBSLocator);
		//fill the tuningSpace
		hr = FillTuningSpaceFromControls (pTuningSpace);
		if (FAILED (hr))
			return 0;
     	hr = pTuningSpace->put_SystemType (DVB_Satellite);

		//create the tuning space container so we can find the tuning space
		CComPtr <ITuningSpaceContainer> pTuningSpaceContainer;
		hr = CoCreateInstance (
						CLSID_SystemTuningSpaces, 
						NULL, 
						CLSCTX_INPROC_SERVER, 
						__uuidof (ITuningSpaceContainer),
						reinterpret_cast <PVOID*> (&pTuningSpaceContainer)
						);
		if (FAILED (hr) || (!pTuningSpaceContainer))
		{
			MESSAGEBOX (this, IDS_CANNOT_INSTANTIATE_TUNECONTAINER);
			return 0;
		}
		LONG lID;
		hr = pTuningSpaceContainer->FindID (pTuningSpace, &lID);
		if (FAILED (hr))
		{
            //looks like a new item
			int nIndex = 0;
			CComVariant varIndex (nIndex);
			hr = pTuningSpaceContainer->Add (pTuningSpace, &varIndex);
			if (SUCCEEDED (hr))
			{
				CComBSTR genericName;
				hr = pTuningSpace->get_UniqueName (&genericName.m_str);
				if (SUCCEEDED (hr))
				{
					int nTunIndex = AddItemToListBox (genericName, pTuningSpace);
					HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
					::SendMessage (hwndListBox, LB_SETCURSEL, nTunIndex, NULL);
					(*pTuningSpace).AddRef ();//need to addref since is a smart pointer
				}
			}
		}
        else
        {
            if (bIsNew)
            {
                MESSAGEBOX (this, IDS_ENTER_UNIQUE_NAME);
				return 0;
            }
            else
            {
                //looks like we can sumbmit this EXISTING item
                //release the old tuning space
                pTuningSpace.Release ();
                pTuningSpace = NULL;

                pTuningSpace = reinterpret_cast <IDVBSTuningSpace*> (
                    ::SendMessage (hwndListBox, LB_GETITEMDATA, nTunIndex, NULL));
                ASSERT (pTuningSpace);
                if (!pTuningSpace)
                    return NULL;
                CComPtr <ILocator> pLocator;
                pTuningSpace->get_DefaultLocator (&pLocator);
                pDVBSLocator = pLocator;
                if (!pDVBSLocator)
                {
                    ASSERT (FALSE);
                    return NULL;
                }
                CComBSTR uniqueName;
                hr = pTuningSpace->get_UniqueName (&uniqueName.m_str);
                if (FAILED(hr))
                {
			        MESSAGEBOX (this, IDS_CANNOT_RETRIEVE_UNIQUENAME);
			        return 0;
                }
                if (FAILED (FillLocatorFromControls (pDVBSLocator)))
                    return 0;
                pTuningSpace->put_DefaultLocator (pDVBSLocator);
                //fill the tuningSpace
                hr = FillTuningSpaceFromControls (pTuningSpace);
                if (FAILED (hr))
                    return 0;
                //replace with old name
                hr = pTuningSpace->put_UniqueName (uniqueName);
                if (FAILED(hr))
                {
			        MESSAGEBOX (this, IDS_CANNOT_SET_UNIQUE);
			        return 0;
                }
		        CComVariant varIndex (lID);
		        hr = pTuningSpaceContainer->put_Item (varIndex, pTuningSpace);
		        if (FAILED (hr))
		        {
			        MESSAGEBOX (this, IDS_CANNOT_SUBMIT_TUNE);
			        return 0;
		        }
            }
        }

        //disable the submit button
        ::EnableWindow (GetDlgItem (IDC_BUTTON_SUBMIT_TUNING_SPACE), FALSE);
        RefreshAll ();
		return 0;
	}

    void RefreshAll ()
    {
		HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
		int nIndex = ::SendMessage (hwndListBox, LB_GETCURSEL, NULL, NULL);
		if (nIndex == LB_ERR)
		{
			ASSERT (FALSE);
			return;
		}
		
		LRESULT dwData = ::SendMessage (hwndListBox, LB_GETITEMDATA, nIndex, NULL);
		if (dwData == LB_ERR)
		{
			ASSERT (FALSE);
			return;
		}
		IDVBSTuningSpace* pTuningSpace = reinterpret_cast <IDVBSTuningSpace*> (dwData);
		ASSERT (pTuningSpace);
		FillControlsFromTuningSpace (pTuningSpace);
    }

	LRESULT OnSelchangeList_tuning_spaces(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
        RefreshAll ();
        //disable the submit button
        ::EnableWindow (GetDlgItem (IDC_BUTTON_SUBMIT_TUNING_SPACE), FALSE);
        return 0; 
	}

	//standard 'dirty' messages
	LRESULT OnClickedCheck_west_position(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnSelchangeCombo_fec_rate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnSelchangeCombo_inner_fec(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnSelchangeCombo_modulation(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnSelchangeCombo_outer_fec(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnSelchangeCombo_outer_fec_rate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnSelchangeCombo_outer_signal_polarisation(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnSelchangeCombo_spectral_inversion(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}

	LRESULT OnChangeEdit_azimuth(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_carrier_frequency(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_elevation(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_frequency_mapping(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_friendly_name(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_high_oscillator(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_input_range(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_lnbswitch(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_low_oscilator(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_networkid(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_orbital_position(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_symbol_rate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}

	LRESULT OnChangeEdit_unique_name(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}

   	LRESULT OnListKeyItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		if (LOWORD(wParam) == VK_DELETE)
        {
    		HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
            int nIndex = ::SendMessage (hwndListBox, LB_GETCURSEL, NULL, NULL);
            if (nIndex != LB_ERR)
            {
                DWORD_PTR dwData = ::SendMessage (hwndListBox, LB_GETITEMDATA, nIndex, NULL);
                IDVBSTuningSpace* pTunSpace = reinterpret_cast <IDVBSTuningSpace*> (dwData);
		        TUNING_SPACES::iterator it;
		        for (it = m_tunigSpaceList.begin (); it != m_tunigSpaceList.end ();it++)
		        {
                    if (pTunSpace == *it)
                    {
		                CComPtr <ITuningSpaceContainer> pTuningSpaceContainer;
		                HRESULT hr = CoCreateInstance (
						                CLSID_SystemTuningSpaces, 
						                NULL, 
						                CLSCTX_INPROC_SERVER, 
						                __uuidof (ITuningSpaceContainer),
						                reinterpret_cast <PVOID*> (&pTuningSpaceContainer)
						                );
		                if (FAILED (hr) || (!pTuningSpaceContainer))
		                {
			                MESSAGEBOX (this, IDS_CANNOT_INSTANTIATE_TUNECONTAINER);
			                return 0;
		                }
		                LONG lID;
		                hr = pTuningSpaceContainer->FindID (pTunSpace, &lID);
		                if (FAILED (hr))
		                {
			                MESSAGEBOX (this, IDS_CANNOT_FIND_TUNE_IN_CONTAINER);
                            return 0;
                        }
			            CComVariant varIndex (lID);
			            hr = pTuningSpaceContainer->Remove (varIndex);
			            if (FAILED (hr))
			            {
			                MESSAGEBOX (this, IDS_CANNOT_REMOVE_TUNINGSPACE);
			                return 0;
                        }
			            (*it)->Release ();
			            m_tunigSpaceList.erase (it);
                        ::SendMessage (hwndListBox, LB_DELETESTRING, nIndex, NULL);
                        //looks like the list is empty//try to select the first item from the list
                        if (::SendMessage (hwndListBox, LB_SETCURSEL, 0, NULL) == LB_ERR)
                        {
                            //looks like the list is empty
                            FillDefaultControls ();
                            //set the unique name to an empty string so the user will enter it's own
                            SetDlgItemText (IDC_EDIT_UNIQUE_NAME, _T(""));
                        }
                        break;
                    }
		        }
            }
        }
		return 0;
	}

};

#endif //__DVBSTUNINGSPACES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\lasterrorwin.h ===
// LastErrorWin.h: interface for the CLastErrorWin class.
//	Implements the subclassed static control for the common prop page
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LASTERRORWIN_H__A23AB1D9_684C_48D4_A9D1_FD3DCEBD9D5B__INCLUDED_)
#define AFX_LASTERRORWIN_H__A23AB1D9_684C_48D4_A9D1_FD3DCEBD9D5B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "resource.h"       // main symbols

class CLastErrorWin : 
	public CWindowImpl<CLastErrorWin>
{
public:
	CLastErrorWin();
	virtual ~CLastErrorWin();
	BEGIN_MSG_MAP(CLastErrorWin)
		MESSAGE_HANDLER( OCM_CTLCOLORSTATIC, OnCtlColor )
		DEFAULT_REFLECTION_HANDLER ()
	END_MSG_MAP()	

	LRESULT OnCtlColor( UINT, WPARAM wParam, LPARAM, BOOL& ) 
	{
      // notify bit must be set to get STN_* notifications
      ModifyStyle( 0, SS_NOTIFY );
	  LOGBRUSH lb = 
	  {
			BS_SOLID,//style
			GetSysColor (COLOR_3DFACE),//color
			0//hatch
	  };
	  //make sure we're not leaking the process resources
      static HBRUSH hBrNormal = CreateBrushIndirect (&lb);
	  HDC dc = reinterpret_cast <HDC> (wParam);
	  SetTextColor (dc, RGB(255, 0, 0));
	  SetBkColor (dc, GetSysColor (COLOR_3DFACE));
      return reinterpret_cast <LRESULT> (hBrNormal);
   }

};

#endif // !defined(AFX_LASTERRORWIN_H__A23AB1D9_684C_48D4_A9D1_FD3DCEBD9D5B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\np_commonpage.cpp ===
// NP_CommonPage.cpp : Implementation of CNP_CommonPage
#include "stdafx.h"
#include "NPPropPage.h"
#include "NP_CommonPage.h"

/////////////////////////////////////////////////////////////////////////////
// CNP_CommonPage

UINT CNP_CommonPage::m_NotifyMessage = RegisterWindowMessage (_T ("CommonPageEventMessasge"));

//==================================================================
//	Returns a handle to the tree window
//	If there is no window will return NULL
//
//==================================================================
HWND 
CNP_CommonPage::GetSafeTreeHWND ()
{
	HWND	hwndTree = GetDlgItem (IDC_TREE_TUNING_SPACES);
	if (!::IsWindow (hwndTree))
	{
		ASSERT (FALSE);
		return NULL;
	}
	return hwndTree;
}

HWND 
CNP_CommonPage::GetSafeLastErrorHWND ()
{
	HWND	hwndTree = GetDlgItem (IDC_STATIC_HRESULT);
	if (!::IsWindow (hwndTree))
	{
		ASSERT (FALSE);
		return NULL;
	}
	return hwndTree;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\miscell.cpp ===
#include "stdafx.h"
#include "misccell.h"

using namespace std;

string	CBDAMiscellaneous::m_FECMethodString[] = {
	"METHOD_NOT_SET",
    "METHOD_NOT_DEFINED",
    "VITERBI", // FEC is a Viterbi Binary Convolution.
    "RS_204_188",  // The FEC is Reed-Solomon 204/188 (outer FEC).
    "MAX"
};

string CBDAMiscellaneous::m_BinaryConvolutionCodeRateString[] = {
    "NOT_SET",
    "NOT_DEFINED",
    "1/2",
    "2/3",
    "3/4",
    "3/5",
    "4/5",
    "5/6",
    "5/11",
    "7/8",
    "BDA_BCC_RATE_MAX"
};


string CBDAMiscellaneous::m_ModulationTypeString[] = {
    "NOT_SET",
    "NOT_DEFINED",
    "16QAM",
    "32QAM",
    "64QAM",
    "80QAM",
    "96QAM",
    "112QAM",
    "128QAM",
    "160QAM",
    "192QAM",
    "224QAM",
    "256QAM",
    "320QAM",
    "384QAM",
    "448QAM",
    "512QAM",
    "640QAM",
    "768QAM",
    "896QAM",
    "1024QAM",
    "QPSK",
    "BPSK",
    "OQPSK",
    "8VSB",
    "16VSB",
    "ANALOG_AMPLITUDE",
    "ANALOG_FREQUENCY",
    "MAX"
} ;

string CBDAMiscellaneous::m_TunerInputTypeString[] = {
	"TunerInputCable",
    "TunerInputAntenna"
};

string CBDAMiscellaneous::m_PolarisationString[] = {
	"NOT_SET",
    "NOT_DEFINED",
    "LINEAR_H",
    "LINEAR_V",
    "CIRCULAR_L",
    "CIRCULAR_R",
    "MAX"
};
	
string CBDAMiscellaneous::m_SpectralInversionString[] = {
	"NOT_SET",// = -1,
    "NOT_DEFINED",// = 0,
    "AUTOMATIC",// = 1,
    "NORMAL",
    "INVERTED",
    "MAX"
};


//and the values
FECMethod CBDAMiscellaneous::m_FECMethodValues [] = {
    BDA_FEC_METHOD_NOT_SET,// = -1,
    BDA_FEC_METHOD_NOT_DEFINED,// = 0,
    BDA_FEC_VITERBI,// = 1, // FEC is a Viterbi Binary Convolution.
    BDA_FEC_RS_204_188,//The FEC is Reed-Solomon 204/188 (outer FEC).
    BDA_FEC_MAX
};

BinaryConvolutionCodeRate CBDAMiscellaneous::m_BinaryConvolutionCodeRateValues[] = {
	BDA_BCC_RATE_NOT_SET,// = -1,
    BDA_BCC_RATE_NOT_DEFINED,// = 0,
    BDA_BCC_RATE_1_2,// = 1,
    BDA_BCC_RATE_2_3,// = 2,
    BDA_BCC_RATE_3_4,// = 3,
    BDA_BCC_RATE_3_5,// = 4,
    BDA_BCC_RATE_4_5,// = 5,
    BDA_BCC_RATE_5_6,// = 6,
    BDA_BCC_RATE_5_11,// = 7,
    BDA_BCC_RATE_7_8,// = 8,
    BDA_BCC_RATE_MAX// = 9
};

ModulationType CBDAMiscellaneous::m_ModulationTypeValues[] = {
	BDA_MOD_NOT_SET,// = -1,
    BDA_MOD_NOT_DEFINED,// = 0,
    BDA_MOD_16QAM,// = 1,
    BDA_MOD_32QAM,// = 2,
    BDA_MOD_64QAM,// = 3,
    BDA_MOD_80QAM,// = 4,
    BDA_MOD_96QAM,// = 5,
    BDA_MOD_112QAM,// = 6,
    BDA_MOD_128QAM,// = 7,
    BDA_MOD_160QAM,// = 8,
    BDA_MOD_192QAM,// = 9,
    BDA_MOD_224QAM,// = 10,
    BDA_MOD_256QAM,// = 11,
    BDA_MOD_320QAM,// = 12,
    BDA_MOD_384QAM,// = 13,
    BDA_MOD_448QAM,// = 14,
    BDA_MOD_512QAM,// = 15,
    BDA_MOD_640QAM,// = 16,
    BDA_MOD_768QAM,// = 17,
    BDA_MOD_896QAM,// = 18,
    BDA_MOD_1024QAM,// = 19,
    BDA_MOD_QPSK,// = 20,
    BDA_MOD_BPSK,// = 21,
    BDA_MOD_OQPSK,// = 22,
    BDA_MOD_8VSB,// = 23,
    BDA_MOD_16VSB,// = 24,
    BDA_MOD_ANALOG_AMPLITUDE,// = 25,
    BDA_MOD_ANALOG_FREQUENCY,// = 26,
    BDA_MOD_MAX// = 27
};

TunerInputType CBDAMiscellaneous::m_TunerInputTypeValues[] = {
	TunerInputCable,
    TunerInputAntenna
};

Polarisation CBDAMiscellaneous::m_PolarisationValues[] = {
	BDA_POLARISATION_NOT_SET,// = -1,
    BDA_POLARISATION_NOT_DEFINED,// = 0,
    BDA_POLARISATION_LINEAR_H,// = 1,
    BDA_POLARISATION_LINEAR_V,// = 2,
    BDA_POLARISATION_CIRCULAR_L,// = 3,
    BDA_POLARISATION_CIRCULAR_R,// = 4,
    BDA_POLARISATION_MAX// = 5
};

SpectralInversion	CBDAMiscellaneous::m_SpectralInversionValues[] = {
	BDA_SPECTRAL_INVERSION_NOT_SET, // = -1,
    BDA_SPECTRAL_INVERSION_NOT_DEFINED, // = 0,
    BDA_SPECTRAL_INVERSION_AUTOMATIC, // = 1,
    BDA_SPECTRAL_INVERSION_NORMAL,
    BDA_SPECTRAL_INVERSION_INVERTED,
    BDA_SPECTRAL_INVERSION_MAX
};


CBDAMiscellaneous::CBDAMiscellaneous ()
{
	//let's build the maps
	int nLen = sizeof (m_FECMethodValues)/sizeof (m_FECMethodValues[0]);
	for (int i=0;i<nLen;i++)
		m_FECMethodMap.insert (
			MAP_FECMethod::value_type (
				m_FECMethodString[i], m_FECMethodValues[i]
				)
			);

	nLen = sizeof (m_BinaryConvolutionCodeRateValues)/sizeof (m_BinaryConvolutionCodeRateValues[0]);
	for (i=0;i<nLen;i++)
		m_BinaryConvolutionCodeRateMap.insert (
			MAP_BinaryConvolutionCodeRate::value_type (
				m_BinaryConvolutionCodeRateString[i], 
				m_BinaryConvolutionCodeRateValues[i]
				)
			);
	nLen = sizeof (m_ModulationTypeValues)/sizeof (m_ModulationTypeValues[0]);
	for (i=0;i<nLen;i++)
		m_ModulationTypeMap.insert (
			MAP_ModulationType::value_type (
				m_ModulationTypeString[i], 
				m_ModulationTypeValues[i]
				)
			);
	nLen = sizeof (m_TunerInputTypeValues)/sizeof (m_TunerInputTypeValues[0]);
	for (i=0;i<nLen;i++)
		m_TunerInputTypeMap.insert (
			MAP_TunerInputType::value_type (
				m_TunerInputTypeString[i], 
				m_TunerInputTypeValues[i]
				)
			);
	nLen = sizeof (m_PolarisationValues)/sizeof (m_PolarisationValues[0]);
	for (i=0;i<nLen;i++)
		m_PolarisationMap.insert (
			MAP_Polarisation::value_type (
				m_PolarisationString[i], 
				m_PolarisationValues[i]
				)
			);
	nLen = sizeof (m_SpectralInversionValues)/sizeof (m_SpectralInversionValues[0]);
	for (i=0;i<nLen;i++)
		m_SpectralInversionMap.insert (
			MAP_SpectralInversion::value_type (
				m_SpectralInversionString[i], 
				m_SpectralInversionValues[i]
				)
			);
	
}


CComBSTR 
CBDAMiscellaneous::ConvertFECMethodToString (FECMethod	method)
{
	//the map is not used for this
	//we're using map only for coverting from 
	//a string to a integer representation
	MAP_FECMethod::iterator it;
	for (it = m_FECMethodMap.begin();it != m_FECMethodMap.end ();it++)
	{
		if ((*it).second == method)
			return (*it).first.c_str ();
	}
	ASSERT (FALSE);
	return _T("");
}

CComBSTR
CBDAMiscellaneous::ConvertInnerFECRateToString (BinaryConvolutionCodeRate	method)
{
	//the map is not used for this
	//we're using map only for coverting from 
	//a string to a integer representation
	MAP_BinaryConvolutionCodeRate::iterator it;
	for (it = m_BinaryConvolutionCodeRateMap.begin();it != m_BinaryConvolutionCodeRateMap.end ();it++)
	{
		if ((*it).second == method)
			return (*it).first.c_str ();
	}
	ASSERT (FALSE);
	return _T("");
}

CComBSTR
CBDAMiscellaneous::ConvertModulationToString (ModulationType	method)
{
	//the map is not used for this
	//we're using map only for coverting from 
	//a string to a integer representation
	MAP_ModulationType::iterator it;
	for (it = m_ModulationTypeMap.begin();it != m_ModulationTypeMap.end ();it++)
	{
		if ((*it).second == method)
			return (*it).first.c_str ();
	}
	ASSERT (FALSE);
	return _T("");
}

CComBSTR
CBDAMiscellaneous::ConvertTunerInputTypeToString (TunerInputType	method)
{
	//the map is not used for this
	//we're using map only for coverting from 
	//a string to a integer representation
	MAP_TunerInputType::iterator it;
	for (it = m_TunerInputTypeMap.begin();it != m_TunerInputTypeMap.end ();it++)
	{
		if ((*it).second == method)
			return (*it).first.c_str ();
	}
	ASSERT (FALSE);
	return _T("");
}

CComBSTR
CBDAMiscellaneous::ConvertPolarisationToString (Polarisation	method)
{
	//the map is not used for this
	//we're using map only for coverting from 
	//a string to a integer representation
	MAP_Polarisation::iterator it;
	for (it = m_PolarisationMap.begin();it != m_PolarisationMap.end ();it++)
	{
		if ((*it).second == method)
			return (*it).first.c_str ();
	}
	ASSERT (FALSE);
	return _T("");
}

CComBSTR
CBDAMiscellaneous::ConvertSpectralInversionToString (SpectralInversion	method)
{
	//the map is not used for this
	//we're using map only for coverting from 
	//a string to a integer representation
	MAP_SpectralInversion::iterator it;
	for (it = m_SpectralInversionMap.begin();it != m_SpectralInversionMap.end ();it++)
	{
		if ((*it).second == method)
			return (*it).first.c_str ();
	}
	ASSERT (FALSE);
	return _T("");
}

//and the map methods
FECMethod 
CBDAMiscellaneous::ConvertStringToFECMethod (string str)
{
	MAP_FECMethod::iterator it = 
		m_FECMethodMap.find (str);
	ASSERT (it != m_FECMethodMap.end());
	if (it == m_FECMethodMap.end())
		return BDA_FEC_METHOD_NOT_SET;
	return (*it).second;
}

BinaryConvolutionCodeRate
CBDAMiscellaneous::ConvertStringToBinConvol (string	str)
{
	MAP_BinaryConvolutionCodeRate::iterator it = 
		m_BinaryConvolutionCodeRateMap.find (str);
	ASSERT (it != m_BinaryConvolutionCodeRateMap.end());
	if (it == m_BinaryConvolutionCodeRateMap.end())
		return BDA_BCC_RATE_NOT_SET;
	return (*it).second;
}

ModulationType
CBDAMiscellaneous::ConvertStringToModulation (string str)
{
	MAP_ModulationType::iterator it = 
		m_ModulationTypeMap.find (str);
	ASSERT (it != m_ModulationTypeMap.end());
	if (it == m_ModulationTypeMap.end())
		return BDA_MOD_NOT_SET;
	return (*it).second;
}

TunerInputType
CBDAMiscellaneous::ConvertStringToTunerInputType (string str)
{
	MAP_TunerInputType::iterator it = 
		m_TunerInputTypeMap.find (str);
	ASSERT (it != m_TunerInputTypeMap.end());
	if (it == m_TunerInputTypeMap.end())
		return TunerInputCable;
	return (*it).second;
}

Polarisation
CBDAMiscellaneous::ConvertStringToPolarisation (string str)
{
	MAP_Polarisation::iterator it = 
		m_PolarisationMap.find (str);
	ASSERT (it != m_PolarisationMap.end());
	if (it == m_PolarisationMap.end())
		return BDA_POLARISATION_NOT_SET;
	return (*it).second;
}

SpectralInversion
CBDAMiscellaneous::ConvertStringToSpectralInversion (string str)
{
	MAP_SpectralInversion::iterator it = 
		m_SpectralInversionMap.find (str);
	ASSERT (it != m_SpectralInversionMap.end());
	if (it == m_SpectralInversionMap.end())
		return   BDA_SPECTRAL_INVERSION_NOT_SET;
	return (*it).second;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\misccell.h ===
#ifndef __MISCCELL_H__
#define __MISCCELL_H__

#include <map>
#include <string>
using namespace std;

	typedef map <string, FECMethod> MAP_FECMethod;
	typedef map <string, BinaryConvolutionCodeRate> MAP_BinaryConvolutionCodeRate;
	typedef map <string, ModulationType> MAP_ModulationType;
	typedef map <string, TunerInputType> MAP_TunerInputType;
	typedef map <string, Polarisation> MAP_Polarisation;
	typedef map <string, SpectralInversion> MAP_SpectralInversion;


class CBDAMiscellaneous
{
public:
	CBDAMiscellaneous ();


	MAP_FECMethod					m_FECMethodMap;
	MAP_BinaryConvolutionCodeRate	m_BinaryConvolutionCodeRateMap;
	MAP_ModulationType				m_ModulationTypeMap;
	MAP_TunerInputType				m_TunerInputTypeMap;
	MAP_Polarisation				m_PolarisationMap;
	MAP_SpectralInversion			m_SpectralInversionMap;

	static string m_FECMethodString[];
	static string m_BinaryConvolutionCodeRateString[];
	static string m_ModulationTypeString[];
	static string m_TunerInputTypeString[];
	static string m_PolarisationString[];
	static string m_SpectralInversionString[];

	static FECMethod				m_FECMethodValues[];
	static BinaryConvolutionCodeRate m_BinaryConvolutionCodeRateValues[];
	static ModulationType			m_ModulationTypeValues[];
	static TunerInputType			m_TunerInputTypeValues[];
	static Polarisation				m_PolarisationValues[];
	static SpectralInversion		m_SpectralInversionValues[];

	CComBSTR 
	ConvertFECMethodToString (FECMethod	method);

	CComBSTR
	ConvertInnerFECRateToString (BinaryConvolutionCodeRate	method);

	CComBSTR
	ConvertModulationToString (ModulationType	method);

	CComBSTR
	ConvertTunerInputTypeToString (TunerInputType	method);

	CComBSTR
	ConvertPolarisationToString (Polarisation	method);

	CComBSTR
	ConvertSpectralInversionToString (SpectralInversion	method);

	//and the map methods
	FECMethod 
	ConvertStringToFECMethod (string str);

	BinaryConvolutionCodeRate
	ConvertStringToBinConvol (string str);

	ModulationType
	ConvertStringToModulation (string str);

	TunerInputType
	ConvertStringToTunerInputType (string str);

	Polarisation
	ConvertStringToPolarisation (string str);

	SpectralInversion
	ConvertStringToSpectralInversion (string str);

    static HRESULT
    RegisterForEvents (
        IUnknown* pUnk,                         //IBaseFilter
        IBroadcastEvent*    pImplementation,    //current implementation
        IBroadcastEvent**   pBroadcastService,  //[out]
        DWORD& dwPublicCookie                   //[out]
        )
    {
        static CCritSec cssLockMe;
        HRESULT hr;
        DWORD dwCookie = 0;
        dwPublicCookie = 0;
        //register for events
        FILTER_INFO filterInfo;
        CComQIPtr <IBaseFilter> pFilter (pUnk);
        CComPtr <IBroadcastEvent> pBroadcastEventService;
        if (!pFilter)
        {
            return E_FAIL;
        }
        if (FAILED(pFilter->QueryFilterInfo (&filterInfo)))
        {
            return E_FAIL;
        }
        CComQIPtr <IServiceProvider> sp(filterInfo.pGraph);
        filterInfo.pGraph->Release ();
        if (!sp)
        {
            return E_FAIL;
        }
        {
            CAutoLock lockMe (&cssLockMe);
            hr = sp->QueryService(SID_SBroadcastEventService, IID_IBroadcastEvent, reinterpret_cast<LPVOID*>(&pBroadcastEventService));
            if (FAILED(hr) || !pBroadcastEventService) 
            {
                hr = pBroadcastEventService.CoCreateInstance(CLSID_BroadcastEventService, 0, CLSCTX_INPROC_SERVER);
                if (FAILED(hr)) 
                {
                    ATLTRACE ("Cannot create the event service");
                    return E_FAIL;
                }
                CComQIPtr <IRegisterServiceProvider> rsp(sp);
                if (!rsp) 
                {
                    ATLTRACE ("Cannot get the IRegisterServiceProvider");
                    return E_FAIL;
                }
                hr = rsp->RegisterService(SID_SBroadcastEventService, pBroadcastEventService);
                if (FAILED(hr)) 
                {
                    ATLTRACE ("Cannot register service");
    		        return E_FAIL;
                }
            }
        }
        ATLASSERT (pBroadcastEventService);
        CComQIPtr <IConnectionPoint> pConPoint(pBroadcastEventService);
        if (!pConPoint)
        {
            ATLTRACE ("Cannot retrieve IConnectionPoint");
            return E_FAIL;
        }
        hr = pConPoint->Advise(
            pImplementation,
            &dwCookie
            );
        if (FAILED(hr)) 
        {
            ATLTRACE ("Unable to advise");
            return E_FAIL;
        }
        hr = pBroadcastEventService->QueryInterface (__uuidof (IBroadcastEvent), 
            reinterpret_cast <PVOID*> (pBroadcastService));
        if (FAILED (hr))
            return E_FAIL;
        dwPublicCookie = dwCookie;
        return S_OK;
    }

};
#endif //__MISCCELL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\proppage\propguid.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// propguid.h
//

// CLSID_MediaTypePropertyPage
// {fd501045-8ebe-11ce-8183-00aa00577da1}
DEFINE_GUID(CLSID_MediaTypePropertyPage,
0xfd501045, 0x8ebe, 0x11ce, 0x81, 0x83, 0x00, 0xaa, 0x00, 0x57, 0x7d, 0xa1);

// CLSID_FileSourcePropertyPage
// {29e07010-bd27-11ce-ab59-00aa00577da1}
DEFINE_GUID(CLSID_FileSourcePropertyPage,
0x29e07010, 0xbd27, 0x11ce, 0xab, 0x59, 0x00, 0xaa, 0x00, 0x57, 0x7d, 0xa1);

// CLSID_FileSinkPropertyPage
// {E0B9CDA0-96E3-11cf-B9FA-00AA00A3F1A6}
DEFINE_GUID(CLSID_FileSinkPropertyPage,
0xe0b9cda0, 0x96e3, 0x11cf, 0xb9, 0xfa, 0x0, 0xaa, 0x0, 0xa3, 0xf1, 0xa6);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\np_commonpage.h ===
// NP_CommonPage.h : Declaration of the CNP_CommonPage

#ifndef __NP_COMMONPAGE_H_
#define __NP_COMMONPAGE_H_

#include "resource.h"       // main symbols
#include "misccell.h"
#include "TreeWin.h"
#include "LastErrorWin.h"

//BUG: C4003: resolution
#undef SubclassWindow 

EXTERN_C const CLSID CLSID_NP_CommonPage;

/////////////////////////////////////////////////////////////////////////////
// CNP_CommonPage
class ATL_NO_VTABLE CNP_CommonPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNP_CommonPage, &CLSID_NP_CommonPage>,
	public IPropertyPageImpl<CNP_CommonPage>,
	public CDialogImpl<CNP_CommonPage>,
    public IBroadcastEvent
{
public:
	CNP_CommonPage():
		m_treeWinControl(this)
	{
		m_dwTitleID = IDS_TITLENP_CommonPage;
		m_dwHelpFileID = IDS_HELPFILENP_CommonPage;
		m_dwDocStringID = IDS_DOCSTRINGNP_CommonPage;
	}

	enum {IDD = IDD_NP_COMMONPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_NP_COMMONPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNP_CommonPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
    COM_INTERFACE_ENTRY(IBroadcastEvent)
END_COM_MAP()

BEGIN_MSG_MAP(CNP_CommonPage)
	CHAIN_MSG_MAP(IPropertyPageImpl<CNP_CommonPage>)
	COMMAND_HANDLER(IDC_BUTTON_SEEK_UP, BN_CLICKED, OnClickedButton_seek_up)
	COMMAND_HANDLER(IDC_BUTTON_SEEK_DOWN, BN_CLICKED, OnClickedButton_seek_down)
	COMMAND_HANDLER(IDC_BUTTON_AUTO_PROGRAM, BN_CLICKED, OnClickedButton_auto_program)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	//MESSAGE_HANDLER(m_NotifyMessage, OnDShowNotify)
	COMMAND_HANDLER(IDC_BUTTON_SCAN_DOWN, BN_CLICKED, OnClickedButton_scan_down)
	COMMAND_HANDLER(IDC_BUTTON_SCAN_UP, BN_CLICKED, OnClickedButton_scan_up)
	COMMAND_HANDLER(IDC_BUTTON_SUBMIT_LOCATOR, BN_CLICKED, OnClickedButton_submit_locator)
	REFLECT_NOTIFICATIONS ()
END_MSG_MAP()
// Handler prototypes:
    
    typedef IPropertyPageImpl<CNP_CommonPage> PPGBaseClass;

	STDMETHOD(SetObjects)(ULONG nObjects, IUnknown** ppUnk)
	{
		// Use SetObjects to perform basic sanity checks on the objects whose properties will be set

		// This page can only handle a single object
		// and that object must support the IBDA_NetworkProvider interface.
		// We return E_INVALIDARG in any other situation

		HRESULT hr = E_INVALIDARG;
		if (nObjects == 1)								// Single object
		{
			CComQIPtr<IBDA_NetworkProvider> pNP(ppUnk[0]);	// Must support IBDA_NetworkProvider
			if (pNP)
				hr = PPGBaseClass::SetObjects(nObjects, ppUnk);
		}
		return hr;
	}
			
	STDMETHOD(Activate)(HWND hWndParent, LPCRECT prc, BOOL bModal)
	{
		// If we don't have any objects, this method should not be called
		// Note that OleCreatePropertyFrame will call Activate even if a call to SetObjects fails, so this check is required
		if (!m_ppUnk)
			return E_UNEXPECTED;

		// Use Activate to update the property page's UI with information
		// obtained from the objects in the m_ppUnk array

		// We update the page to display the Name and ReadOnly properties of the document

		// Call the base class
		HRESULT hr = PPGBaseClass::Activate(hWndParent, prc, bModal);

        if (!m_ppUnk[0])
            return E_UNEXPECTED;

        //if already advised, unadvise
        if (m_pBroadcastEventService)
        {
            CComQIPtr <IConnectionPoint> pConPoint(m_pBroadcastEventService);
            if (pConPoint)
                pConPoint->Unadvise (m_dwEventCookie);
            m_pBroadcastEventService.Release ();
        }

        IBroadcastEvent* pEvent = NULL;
        //register for events
        hr = CBDAMiscellaneous::RegisterForEvents (
            m_ppUnk[0], 
            static_cast<IBroadcastEvent*>(this),
            &pEvent, 
            m_dwEventCookie
            );
        if (SUCCEEDED (hr))
            m_pBroadcastEventService.Attach (pEvent);

		m_pTuner = m_ppUnk[0];
        if (!m_pTuner)
            return E_FAIL;
				
		//make sure the tree is initialized
		RefreshFromNP ();
		RefreshControls ();
		return S_OK;
	}
    
    STDMETHOD(Apply)(void)
	{
		//ATLTRACE(_T("CNP_CommonPage::Apply\n"));
		for (UINT i = 0; i < m_nObjects; i++)
		{
			// Do something interesting here
		}
		m_bDirty = FALSE;
		return S_OK;
	}

	void SendError (
		TCHAR*	szMessage,
		HRESULT	hrErrorCode
		)
	{
		TCHAR	szText[MAX_PATH];
		m_lastHRESULT = hrErrorCode;
		wsprintf (szText, _T("%ld - When...%s"), m_lastHRESULT, szMessage);
		SetDlgItemText (IDC_STATIC_HRESULT, szText);
		//now flash the graphedit window so, 
		//the user will notice he's in trouble
        //we used to flash the window so the user will notice that smtg is wrong
        //but it turned out that the user is actually confused with this
		/*FLASHWINFO flashInfo;
		flashInfo.cbSize = sizeof (FLASHWINFO);
		flashInfo.hwnd = ::GetParent (::GetParent (::GetParent(m_hWnd)));
		flashInfo.dwFlags = FLASHW_ALL;
		flashInfo.uCount = 3;//3 times
		flashInfo.dwTimeout = 500;//half of second
		FlashWindowEx (&flashInfo);*/
	}

	HRESULT
	PutTuningSpace (
		ITuningSpace* pTuneSpace
		)
	{
		ASSERT (m_pTuner);
		return m_pTuner->put_TuningSpace (pTuneSpace);
	}
	
private:
	
	//======================================================================
	//	Will query the NP filter and set all controls according to its props
	//	
	//
	//======================================================================
	HRESULT	RefreshFromNP ()
	{
		if (!m_pTuner)
			return E_FAIL;

		return m_treeWinControl.RefreshTree (m_pTuner);
	}

	void RefreshControls ()
	{
		//now set all controls according to what found
		TCHAR	szText[MAX_PATH];
		HRESULT hr = m_pTuner->get_SignalStrength (&m_lSignalStrength);
		if (FAILED (hr))
		{
			//We got an error 
			SendError (_T("Calling IScanningTuner::get_SignalStrength"), hr);
			//BUGBUG - add a special case for error
			return;
		}
		wsprintf (szText, _T("%ld"), m_lSignalStrength);
		SetDlgItemText (IDC_STATIC_SIGNAL_STRENGTH, szText);
		SendError (_T(""), m_lastHRESULT);
	}
	//
private:
	//member variables
	//couple interfaces we need from NP
	CComQIPtr <IScanningTuner>			m_pTuner;
	CComQIPtr <IMediaEventEx>			m_pEventInterface;
    CComPtr   <IBroadcastEvent>         m_pBroadcastEventService;
    DWORD                               m_dwEventCookie;
    static UINT m_NotifyMessage;

	CTreeWin		m_treeWinControl;
	CLastErrorWin	m_lastErrorControl;
	HRESULT			m_lastHRESULT;
	LONG			m_lSignalStrength;

	HWND GetSafeTreeHWND ();
	HWND GetSafeLastErrorHWND ();

	LRESULT OnClickedButton_seek_up(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (!m_pTuner)
			return E_FAIL;
		m_pTuner->SeekUp ();
		return 0;
	}
	LRESULT OnClickedButton_seek_down(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (!m_pTuner)
			return E_FAIL;
		m_pTuner->SeekDown ();
		return 0;
	}
	LRESULT OnClickedButton_auto_program(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (!m_pTuner)
			return E_FAIL;
		m_pTuner->AutoProgram ();
		return 0;
	}
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		m_treeWinControl.SubclassWindow (GetSafeTreeHWND ());
		m_lastErrorControl.SubclassWindow (GetSafeLastErrorHWND ());
		//RefreshControls ();
		return 0;
	}

	//received notifications from Network Provider
	LRESULT OnDShowNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		RefreshFromNP ();
		RefreshControls ();
		return 0;
	}
	
	LRESULT OnClickedButton_scan_down(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		//scan for 1000 miliseconds
		m_pTuner->ScanDown (1000);
		return 0;
	}
	LRESULT OnClickedButton_scan_up(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		//scan for 1000 miliseconds
		m_pTuner->ScanUp (1000);
		return 0;
	}
	LRESULT OnClickedButton_submit_locator(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		m_treeWinControl.SubmitCurrentLocator ();
		return 0;
	}

    STDMETHOD(Fire)(GUID EventID)
    {
#ifdef DEBUG
        TCHAR szInfo[MAX_PATH];
        CComBSTR bstrEventID;
        USES_CONVERSION;
        StringFromCLSID (EventID, &bstrEventID);
        wsprintf (szInfo, _T("Notification received for %s"), OLE2T (bstrEventID));
        ATLTRACE (szInfo);
#endif
        if (EventID == EVENTID_SignalStatusChanged)
        {
            ATLTRACE ("Starting to refresh");
            RefreshControls ();
        }
        return S_OK;
    }

    virtual void OnFinalMessage( HWND hWnd )
    {
        if (m_pBroadcastEventService)
        {
            CComQIPtr <IConnectionPoint> pConPoint(m_pBroadcastEventService);
            pConPoint->Unadvise (m_dwEventCookie);
        }
    }
};

#endif //__NP_COMMONPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NPPropPage.rc
//
#define IDS_HELPFILEATSCPropPage        107
#define IDS_DOCSTRINGATSCPropPage       108
#define IDR_ATSCPROPPAGE                109
#define IDD_ATSCPROPPAGE                110
#define IDD_DVBSTUNINGSPACES            111
#define IDS_TITLEDVBSTuningSpaces       112
#define IDS_HELPFILEDVBSTuningSpaces    113
#define IDS_DOCSTRINGDVBSTuningSpaces   114
#define IDR_DVBSTUNINGSPACES            115
#define IDS_TITLEDVBSTuneRequestPage    117
#define IDS_HELPFILEDVBSTuneRequestPage 118
#define IDS_DOCSTRINGDVBSTuneRequestPage 119
#define IDR_DVBSTUNEREQUESTPAGE         120
#define IDD_DVBSTUNEREQUESTPAGE         121
#define IDS_TITLEATSCPropPage           122
#define IDD_NP_COMMONPAGE               123
#define IDR_NP_COMMONPAGE               124
#define IDS_DOCSTRINGNP_CommonPage      125
#define IDS_HELPFILENP_CommonPage       126
#define IDS_TITLENP_CommonPage          127
#define IDS_PROJNAME                    128
#define IDS_FAILED_GET_SID              129
#define IDS_FAILED_GET_TSID             130
#define IDS_CANNOT_SET_INNERFEC         131
#define IDS_CANNOT_SET_INNERFECRATE     132
#define IDS_CANNOT_SET_MODULATION       133
#define IDS_CANNOT_SET_OUTERFECRATE     135
#define IDS_CANNOT_SET_SIGNALPOLARISATION 136
#define IDS_CANNOT_SET_CARRIERFREQUENCY 137
#define IDS_CANNOT_SET_SYMBOLRATE       138
#define IDS_CANNOT_SET_AZIMUTH          139
#define IDS_CANNOT_SET_ELEVATION        140
#define IDS_CANNOT_SET_ORBITALPOSITION  141
#define IDS_CANNOT_SET_WESTPOSITION     142
#define IDS_CANNOT_SET_ONID             143
#define IDS_CANNOT_SET_TSID             144
#define IDS_CANNOT_SET_SID              145
#define IDS_CANNOT_GET_DEFLOC           146
#define IDS_CANNOT_GET_DEF_DVBSLOCATOR  147
#define IDS_CANNOT_CREATE_NEW_TUNEREQUEST 148
#define IDS_CANNOT_RETRIEVE_DVBSTUNEREQUEST 149
#define IDS_CANNOT_SET_LOCATOR_FOR_TUNEREQUEST 150
#define IDS_CANNOT_PUT_TUNE_REQUEST     151
#define IDS_CANNOT_GET_UNIQUENAME       152
#define IDS_CANNOT_GET_FRIENDLYNAME     153
#define IDS_CANNOT_GET_FREQUENCYMAPPING 154
#define IDS_CANNOT_GET_NETWORKID        155
#define IDS_CANNOT_GET_HIGHOSCILATOR    156
#define IDS_CANNOT_GET_LNBSWITCH        157
#define IDS_CANNOT_GET_INPUTRANGE       158
#define IDS_CANNOT_GET_LOWOSCILLATOR    159
#define IDS_CANNOT_GET_SPECTRALINVERSION 160
#define IDS_CANNOT_GET_ILOCATOR         161
#define IDS_CANNOT_GET_DVBSLOCATOR      162
#define IDS_CANNOT_SET_OUTERFEC         166
#define IDS_CANNOT_SET_UNIQUENAME       175
#define IDS_CANNOT_SET_FRIENDLYNAME     176
#define IDS_CANNOT_SET_FREQUENCYMAPPING 177
#define IDS_CANNOT_SET_NETWORKID        178
#define IDS_CANNOT_SET_HIGHOSCILATOR    179
#define IDS_CANNOT_SET_LNBSWITCH        180
#define IDS_CANNOT_SET_INPUTRANGE       181
#define IDS_CANNOT_SET_LOWOSCILLATOR    182
#define IDS_CANNOT_SET_SPECTRALINVERSION 183
#define IDS_CANNOT_SET_NETWORKTYPE      184
#define IDS_CANNOT_INSTANTIATE_DVBSTUNE 185
#define IDS_CANNOT_GET_IDVBSLOCATOR     186
#define IDS_CANNOT_INSTANTIATE_TUNECONTAINER 187
#define IDS_ENTER_UNIQUE_NAME           188
#define IDS_CANNOT_RETRIEVE_UNIQUENAME  189
#define IDS_CANNOT_SET_UNIQUE           190
#define IDS_CANNOT_SUBMIT_TUNE          191
#define IDS_CANNOT_FIND_TUNE_IN_CONTAINER 192
#define IDS_CANNOT_REMOVE_TUNINGSPACE   193
#define IDS_PUT_CHANNEL                 194
#define IDS_PUT_MINOR_CHANNEL           195
#define IDS_CANNOT_IATSCLOCATOR         196
#define IDS_PUT_PHYSICAL                197
#define IDS_NOT_VALID_TUNE_REQUEST      198
#define IDS_CANNOT_SUBMIT_TUNE_REQUEST  199
#define IDC_DEFAULT_LOCATOR             200
#define IDC_BUTTON_SEEK_UP              202
#define IDC_BUTTON_SEEK_DOWN            203
#define IDC_BUTTON_AUTO_PROGRAM         204
#define IDC_STATIC_TSID                 206
#define IDC_STATIC_SIGNALQUALITY        207
#define IDC_STATIC_SIGNAL_STRENGTH      208
#define IDC_TREE_TUNING_SPACES          209
#define IDC_STATIC_HRESULT              210
#define IDS_FAILED_GET_ONID             211
#define IDD_NEW                         212
#define IDS_ERROR_CAPTION               212
#define IDC_BUTTON_SCAN_UP              214
#define IDC_BUTTON_SCAN_DOWN            215
#define IDC_BUTTON_SUBMIT_LOCATOR       216
#define IDC_EDIT_PHYSICAL_CHANNEL       217
#define IDC_EDIT_MINOR_CHANNEL          218
#define IDC_EDIT_SID                    219
#define IDC_SPIN_MINOR_CHANNEL          220
#define IDC_EDIT_MAJOR_CHANNEL          221
#define IDC_SPIN_MAJOR_CHANNEL          222
#define IDC_BUTTON_VALIDATE             223
#define IDC_EDIT_UNIQUE_NAME            224
#define IDC_EDIT_FRIENDLY_NAME          225
#define IDC_EDIT_CARRIER_FREQUENCY      226
#define IDC_SPIN_CARRIER                227
#define IDC_EDIT_ONID                   228
#define IDC_SPIN_PHYSICAL_CHANNEL       229
#define IDC_EDIT_SYMBOL_RATE            236
#define IDC_SPIN_SYMBOL_RATE            237
#define IDC_EDIT_TSID                   238
#define IDC_SPIN_TSID                   239
#define IDC_BUTTON_SUBMIT_TUNE_REQUEST  240
#define IDC_COMBO_INNER_FEC             241
#define IDC_COMBO_FEC_RATE              242
#define IDC_COMBO_MODULATION            243
#define IDC_COMBO_OUTER_FEC             244
#define IDC_COMBO_OUTER_FEC_RATE        245
#define IDC_LIST_TUNING_SPACES          246
#define IDC_BUTTON_SUBMIT_TUNING_SPACE  247
#define IDC_COMBO_OUTER_SIGNAL_POLARISATION 248
#define IDC_EDIT_MODULATION             251
#define IDC_BUTTON_NEW_TUNING_SPACE     252
#define IDC_EDIT_MINMINOR_CHANNEL       253
#define IDC_SPIN_MINMINOR_CHANNEL       254
#define IDC_EDIT_HIGH_OSCILLATOR        255
#define IDC_SPIN_HIGH_OSCILLATOR        256
#define IDC_EDIT_LNBSwitch              257
#define IDC_SPIN_LNBSwitch              258
#define IDC_EDIT_INPUT_RANGE            259
#define IDC_SPIN_INPUT_RANGE            260
#define IDC_EDIT_COUNTRY_CODE           261
#define IDC_COMBOINPUT_TYPE             262
#define IDC_EDIT_FREQUENCY_MAPPING      263
#define IDC_EDIT_NETWORKID              264
#define IDC_EDIT_LOW_OSCILATOR          265
#define IDC_EDITSPECTRAL_INVERSION      266
#define IDC_SPIN_SPECTRAL_INVERSION     267
#define IDC_SPIN_LOW_OSCILATOR          268
#define IDC_SPIN_NETWORKID              269
#define IDC_EDIT_AZIMUTH                270
#define IDC_SPIN_AZIMUTH                271
#define IDC_EDIT_ELEVATION              272
#define IDC_SPIN_ELEVATION              273
#define IDC_EDIT_ORBITAL_POSITION       274
#define IDC_SPIN_ORBITAL_POSITION       275
#define IDC_CHECK_WEST_POSITION         276
#define IDC_COMBO_SPECTRAL_INVERSION    277
#define IDC_SPIN_ONID                   279
#define IDC_SPIN_SID                    281
#define IDC_BUTTON_REST_TO_DEFAULT_LOCATOR 282

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         283
#define _APS_NEXT_SYMED_VALUE           122
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__441F7B28_4315_4EB4_AFB9_F461CB8AD90D__INCLUDED_)
#define AFX_STDAFX_H__441F7B28_4315_4EB4_AFB9_F461CB8AD90D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define STRICT
//#ifndef _WIN32_WINNT
//#define _WIN32_WINNT 0x0400
//#endif
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <mmsystem.h>

//#include <debug.h>
//#include "shell.h"

#include <streams.h>
#include <ks.h>
#include <ksmedia.h>
//#include <list.h>
#include <setupapi.h>
#include <wtypes.h>  

// KS
//#include <ks.h>
//#include <ksmedia.h>

#include <tuner.h>
#include <tune.h>
#include <BdaTypes.h>
#include <BdaMedia.h>
//#include <NewMedia.h>
#include <BdaIface.h>

#define MESSAGEBOX(wnd, ID) \
        {\
            TCHAR szPath[MAX_PATH];\
            if (0 != LoadString (_Module.GetModuleInstance (), ID, szPath, MAX_PATH))\
            {\
                TCHAR szCaption[MAX_PATH];\
                if (NULL != LoadString (_Module.GetModuleInstance (), IDS_ERROR_CAPTION, szCaption, MAX_PATH))\
                {\
                    ::MessageBox (wnd->m_hWnd, szPath, szCaption, MB_OK);\
                }\
            }\
        }

#define MESSAGEBOX_ERROR(wnd, ID) \
        {\
            TCHAR szPath[MAX_PATH];\
            if (0 != LoadString (_Module.GetModuleInstance (), ID, szPath, MAX_PATH))\
            {\
                TCHAR szCaption[MAX_PATH];\
                if (NULL != LoadString (_Module.GetModuleInstance (), IDS_ERROR_CAPTION, szCaption, MAX_PATH))\
                {\
                    ::MessageBox (wnd->m_hWnd, szPath, szCaption, MB_OK|MB_ICONSTOP);\
                }\
            }\
        }
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__441F7B28_4315_4EB4_AFB9_F461CB8AD90D__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\treewin.h ===
// TreeWindow.h: interface for the CTreeWindow class.
// implements the subclassed tree control for the common prop page
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TREEWINDOW_H__5AAE4BD7_4DA7_4064_88BB_8C7FDF9A1464__INCLUDED_)
#define AFX_TREEWINDOW_H__5AAE4BD7_4DA7_4064_88BB_8C7FDF9A1464__INCLUDED_

#include "resource.h"       // main symbols
#include "misccell.h"

using namespace std;
class CNP_CommonPage;

class CTreeWin : 
	public CWindowImpl<CTreeWin>
{
public:
	CTreeWin(
		CNP_CommonPage* pParent
		);
	virtual ~CTreeWin();

private:
	//typedef	CAdapt <CComPtr <ILocator> >	PAdaptILocator;
	//typedef	CAdapt <CComPtr <ITuningSpace> >	PAdaptITuningSpace;
	typedef map <ITuningSpace*, ILocator*>	TREE_MAP;
	typedef	enum 
	{
		CarrierFrequency,
		InnerFEC,
		InnerFECRate,
		Modulation,
		OuterFEC,
		OuterFECRate,
		SymbolRate,
		UniqueName,
		FriendlyName,
		TunSpace_CLSID,
		FrequencyMapping
	}TreeParams;	//all possible param values for the Tree leafs
	
	TREE_MAP		m_treeMap;	//list used for the tree
	CNP_CommonPage*	m_pCommonPage;
	CBDAMiscellaneous m_misc;

	void
	CleanMapList ();//release all tree interface pointers	

	//the message map for the sublassed tree control
	BEGIN_MSG_MAP(CTreeWin)
		//we would like to do smtg like that
		//NOTIFY_HANDLER(IDC_TREE_TUNING_SPACES, NM_CLICK, OnClickTree_tuning_spaces)
		//but it seems ATL is not reflecting same WM_NOTIFY MESSAGE
		MESSAGE_HANDLER(OCM__BASE+WM_NOTIFY, ON_REFLECT_WM_NOTIFY)	
		DEFAULT_REFLECTION_HANDLER ()
	END_MSG_MAP()

	LRESULT OnClickTree_tuning_spaces(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		return 0;
	}
	LRESULT OnItemexpandedTree_tuning_spaces(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		return 0;
	}

	LRESULT ON_REFLECT_WM_NOTIFY(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		if (lParam == NM_CLICK )
			return 0;
		LPNMHDR lpnmh = (LPNMHDR) lParam; 
		switch (lpnmh->code)
		{
		case TVN_ITEMEXPANDED:
			return OnItemexpandedTree_tuning_spaces (
				IDC_TREE_TUNING_SPACES, 
				lpnmh, 
				bHandled
				);
		case NM_CLICK:
			return OnClickTree_tuning_spaces (
				IDC_TREE_TUNING_SPACES, 
				lpnmh, 
				bHandled
				);
		}
		return 0;
	}

	HTREEITEM
	InsertLocator (
		HTREEITEM	hParentItem, 
		ILocator*	pLocator
		);

	HTREEITEM
	InsertTuningSpace (
		ITuningSpace*	pTunSpace,
		TCHAR*	szCaption = _T("")
		);

	HTREEITEM
	InsertTreeItem (
		HTREEITEM	hParentItem	,
		LONG		lParam,
		TCHAR*		pszText,
		bool		bBold = false
	);

public:
	//============================================================
	//	It's refreshing the tree with the new TunningSpace info
	//	from the NP.
	//
	//============================================================
	HRESULT	
	RefreshTree (
		IScanningTuner*	pTuner
		);

	//============================================================
	//	Will set the current tuning space locator to the NP
	//	
	//
	//============================================================
	HRESULT
	SubmitCurrentLocator ();
};

#endif // !defined(AFX_TREEWINDOW_H__5AAE4BD7_4DA7_4064_88BB_8C7FDF9A1464__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\proppage\atlproppage.cpp ===
// msdvbnp.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f NPPropPageps.mk in the project directory.

#include "..\msdvbnp\stdafx.h"
#include "..\msdvbnp\resource.h"
#include <initguid.h>
#include "..\msdvbnp\NPPropPage.h"

#include "..\msdvbnp\NPPropPage_i.c"
#include "..\msdvbnp\NP_CommonPage.h"
#include "..\msdvbnp\ATSCPropPage.h"
#include "..\msdvbnp\DVBSTuningSpaces.h"
#include "..\msdvbnp\DVBSTuneRequestPage.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_NP_CommonPage, CNP_CommonPage)
OBJECT_ENTRY(CLSID_ATSCPropPage, CATSCPropPage)
OBJECT_ENTRY(CLSID_DVBSTuningSpaces, CDVBSTuningSpaces)
OBJECT_ENTRY(CLSID_DVBSTuneRequestPage, CDVBSTuneRequestPage)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);

extern "C" 
STDAPI DllCanUnload();

extern "C" 
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);


BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {

    case DLL_PROCESS_ATTACH:
        _Module.Init(ObjectMap, hInstance);
        break;

    case DLL_PROCESS_DETACH:
        _Module.Term();
        break;
    }

    return DllEntryPoint(hInstance, dwReason, lpReserved);
}



/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI PPDllCanUnloadNow(void)
{
    HRESULT hr = DllCanUnloadNow();

    if (hr == S_OK) {
        if (_Module.GetLockCount() != 0) {
            hr = S_FALSE;
        }
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI PPDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;
    hr = DllGetClassObject(rclsid, riid, ppv);
    if (SUCCEEDED(hr))
        return hr;

    return _Module.GetClassObject(rclsid, riid, ppv);
}

STDAPI DllRegisterServer(void)

{ // DllRegisterServer //
    _Module.RegisterServer(TRUE);
  return AMovieDllRegisterServer2(TRUE);

} // DllRegisterServer //

STDAPI DllUnregisterServer(void)
{ // DllUnRegisterServer //

    _Module.UnregisterServer(TRUE);
  return AMovieDllRegisterServer2(FALSE);

} // DllUnRegisterServer //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\proppage\proppage.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
//
// Proppage.cpp
//
// Provides two support property pages for GraphEdt
// File & MediaType

//
// !!! TODO move strings in CFileProperties into *.rc file
//
#include <streams.h>
#include <windowsx.h>
#include <initguid.h>
#include <olectl.h>
#include <memory.h>

#include <string.h>
#include <stdio.h>
#include <tchar.h>
#include <wchar.h>

#include "resource.h"
#include "propguid.h"
#include "texttype.h"
#include "proppage.h"

//
// other property pages we will be including
//

//  VMR
#include "..\vmrprop\vmrprop.h"

//  mpg2splt proppages
#include "..\mp2demux\mp2prop.h"

// *
// * CMediaTypeProperties
// *

// provides a standard property page that
// a pin can support to display its media type

// COM global table of objects in this dll
CFactoryTemplate g_Templates[] = {

    {L"GraphEdt property sheets", &CLSID_MediaTypePropertyPage, CMediaTypeProperties::CreateInstance, NULL, NULL},
    {L"GraphEdt property sheets", &CLSID_FileSourcePropertyPage, CFileSourceProperties::CreateInstance, NULL, NULL},
    {L"GraphEdt property sheets", &CLSID_FileSinkPropertyPage, CFileSinkProperties::CreateInstance, NULL, NULL},
    {L"VMR property sheet", &CLSID_VMRFilterConfigProp, CVMRFilterConfigProp::CreateInstance, NULL, NULL},
    {L"Mpeg2splt Output Pins Sheet", & CLSID_MPEG2DemuxPropOutputPins, CMPEG2PropOutputPins::CreateInstance, NULL, NULL},
    {L"Mpeg2splt PID Map Sheet", & CLSID_MPEG2DemuxPropPIDMap, CMPEG2PropPIDMap::CreateInstance, NULL, NULL},
    {L"Mpeg2splt stream_id Map Sheet", & CLSID_MPEG2DemuxPropStreamIdMap, CMPEG2PropStreamIdMap::CreateInstance, NULL, NULL},
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

//
//  CreateInstance
//
//  The DShow way to create instances.  Look at ATLPropPage.cpp to see how
//  to add ATL property pages.
//
CUnknown *CMediaTypeProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CMediaTypeProperties(lpunk, phr);
    if (punk == NULL) {
    *phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// CMediaTypeProperties::Constructor
//
CMediaTypeProperties::CMediaTypeProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CUnknown(NAME("Media Type Property Page"), lpunk)
    , m_pPin(NULL)
    , m_fUnconnected(FALSE)
    , m_hwnd(NULL) {

}


//
// CMediaTypeProperties::Destructor
//
CMediaTypeProperties::~CMediaTypeProperties(void)
{
    //
    // OleCreatePropertyFrame bug:
    //   - Final SetObjects(NULL) is missing. Might have to release
    //     interfaces at this point.
    //
    ASSERT( m_pPin == NULL );

    /*    if (m_pPin)
    m_pPin->Release();

    m_pPin = NULL; */
}

//
// NonDelegatingQueryInterface
//
// Reveal our property page
STDMETHODIMP CMediaTypeProperties::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    if (riid == IID_IPropertyPage) {
    return GetInterface((IPropertyPage *) this, ppv);
    } else {
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


//
// SetPageSite
//
// called with null as the page shuts down. therefore release the pin
// here.
STDMETHODIMP CMediaTypeProperties::SetPageSite(LPPROPERTYPAGESITE pPageSite) {

    if( !pPageSite && m_pPin ){
        m_pPin->Release();
        m_pPin = NULL;
    }

    return NOERROR;
}


//
// GetPageInfo
//
// set the page info so that the page site can size itself, etc
STDMETHODIMP CMediaTypeProperties::GetPageInfo(LPPROPPAGEINFO pPageInfo) {

    PIN_INFO pi;

    if (m_pPin) {
    m_pPin->QueryPinInfo(&pi);
    QueryPinInfoReleaseFilter(pi);
    }
    else {
    wcscpy(pi.achName, L"Connection Format");
    }

    LPOLESTR pszTitle = (LPOLESTR) CoTaskMemAlloc(sizeof(pi.achName));
    memcpy(pszTitle, &pi.achName, sizeof(pi.achName));

    pPageInfo->cb               = sizeof(PROPPAGEINFO);
    pPageInfo->pszTitle         = pszTitle;

    // set default size values if GetDialogSize fails
    pPageInfo->size.cx = 340;
    pPageInfo->size.cy = 150;
    GetDialogSize( IDD_TYPEPROP, DialogProc, 0L, &pPageInfo->size);

    pPageInfo->pszDocString     = NULL;
    pPageInfo->pszHelpFile      = NULL;
    pPageInfo->dwHelpContext    = 0;

    return NOERROR;

}


//
// DialogProc
//
// Handles the messages for our property window
INT_PTR CALLBACK CMediaTypeProperties::DialogProc( HWND hwnd
                     , UINT uMsg
                     , WPARAM wParam
                     , LPARAM lParam) {

    static CMediaTypeProperties *pThis = NULL;

    // While we try to find the size of our property page
    // this window proc is called with pThis == NULL! Don't
    // do anything in that case.

    switch (uMsg) {
    case WM_INITDIALOG:

    pThis = (CMediaTypeProperties *) lParam;

    if (!pThis)
        return TRUE;


    CreateWindow( TEXT("STATIC")
            , pThis->m_szBuff
            , WS_CHILD | WS_VISIBLE
            , 0, 0
            , 300, 200
            , hwnd
            , NULL
            , g_hInst
            , NULL
            );

    if (pThis->m_fUnconnected) {
        pThis->CreateEditCtrl(hwnd);
        pThis->FillEditCtrl();
    }

    return TRUE;    // I don't call setfocus...

    default:
    return FALSE;

    }
}

//
// CreateEditCtrl
//
// Creates a list box which lists all prefered media types of the pin
//
void CMediaTypeProperties::CreateEditCtrl(HWND hwnd)
{
    m_EditCtrl = CreateWindow( TEXT("EDIT"), NULL,
                  ,WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL
                  | WS_BORDER | ES_LEFT | ES_AUTOHSCROLL | ES_MULTILINE
                  | ES_AUTOVSCROLL | ES_READONLY
                  , 10, 20, 330, 180, hwnd, NULL, g_hInst, NULL);
}

//
// FillEditCtrl
//
// Enumerates all prefered media types of the pin and adds them to the
// list box.
//
void CMediaTypeProperties::FillEditCtrl()
{
    IEnumMediaTypes * pMTEnum;
    AM_MEDIA_TYPE * pMediaType;
    ULONG count;
    ULONG number = 0;
    TCHAR szBuffer[400];
    TCHAR szEditBuffer[2000];
    ULONG iRemainingLength = 2000;

    HRESULT hr = m_pPin->EnumMediaTypes(&pMTEnum);
    szEditBuffer[0] = TEXT('\0');

    if (SUCCEEDED(hr)) {
    ASSERT(pMTEnum);
    pMTEnum->Next(1, &pMediaType, &count);
    while (count == 1) {
        CTextMediaType(*pMediaType).AsText(szBuffer, NUMELMS(szBuffer), TEXT(" - "), TEXT(" - "), TEXT("\r\n"));

        DeleteMediaType(pMediaType);

        _tcsncat(szEditBuffer, szBuffer, iRemainingLength);
        iRemainingLength = 2000 - _tcslen(szEditBuffer);

        if (iRemainingLength <= 20)
        break;
    
        number++;
        pMTEnum->Next(1, &pMediaType, &count);
    }
    pMTEnum->Release();
    }

    // no prefered media types
    if (number == 0) {
    LoadString(g_hInst, IDS_NOTYPE, szEditBuffer, iRemainingLength);
    }
    SetWindowText(m_EditCtrl, szEditBuffer);
}


//
// Activate
//
// Create the window we will use to edit properties
STDMETHODIMP CMediaTypeProperties::Activate(HWND hwndParent, LPCRECT prect, BOOL fModal) {

    ASSERT(!m_hwnd);

    m_hwnd = CreateDialogParam( g_hInst
             , MAKEINTRESOURCE(IDD_TYPEPROP)
             , hwndParent
             , DialogProc
             , (LPARAM) this
             );

    if (m_hwnd == NULL) {
    DWORD dwErr = GetLastError();
    DbgLog((LOG_ERROR, 1, TEXT("Could not create window: 0x%x"), dwErr));
    return E_FAIL;
    }

    Move(prect);
    ShowWindow( m_hwnd, SW_SHOWNORMAL );

    return NOERROR;
}


//
// Show
//
// Display the property dialog
STDMETHODIMP CMediaTypeProperties::Show(UINT nCmdShow) {

    if (m_hwnd == NULL) {
    return E_UNEXPECTED;
    }

    if (!((nCmdShow == SW_SHOW) || (nCmdShow == SW_SHOWNORMAL) || (nCmdShow == SW_HIDE))) {
    return( E_INVALIDARG);
    }

    ShowWindow(m_hwnd, nCmdShow);
    InvalidateRect(m_hwnd, NULL, TRUE);

    return NOERROR;
}


//
// Deactivate
//
// Destroy the dialog
STDMETHODIMP CMediaTypeProperties::Deactivate(void) {
    if (m_hwnd == NULL) {
    return E_UNEXPECTED;
    }

    if (DestroyWindow(m_hwnd)) {
    m_hwnd = NULL;
    return NOERROR;
    }
    else {
    return E_FAIL;
    }
}

//
// Move
//
// put the property page over its home in the parent frame.
STDMETHODIMP CMediaTypeProperties::Move(LPCRECT prect) {

    if (m_hwnd == NULL) {
    return( E_UNEXPECTED );
    }

    if (MoveWindow( m_hwnd
          , prect->left
          , prect->top
          , prect->right - prect->left
          , prect->bottom - prect->top
          , TRUE                // send WM_PAINT
          ) ) {
    return NOERROR;
    }
    else {
    return E_FAIL;
    }
}


//
// SetObjects
//
// Sets the object(s) we are browsing. Confirm they are pins and query them
// for their media type, if connected
STDMETHODIMP CMediaTypeProperties::SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk) {

    if (cObjects == 1) {
    ASSERT(!m_pPin);

    if ((ppunk == NULL) || (*ppunk == NULL)) {
        return( E_POINTER );
    }

    HRESULT hr = (*ppunk)->QueryInterface(IID_IPin, (void **) &m_pPin);
    if (FAILED(hr)) {
        return E_NOINTERFACE;
    }

    //
    // Find the media type of the pin. If we don't succeed, we are
    // not connected. Set the m_fUnconnected flag, which will be used
    // during creation of the dialog.
    //

    CMediaType mt;
    hr = m_pPin->ConnectionMediaType(&mt);

    if (S_OK == hr) {

        //
        // Connected. Convert the media type to a string in m_szBuff.
        //

        CTextMediaType(mt).AsText
        (m_szBuff, sizeof(m_szBuff), TEXT("\n\n"), TEXT("\n"), TEXT(""));

    }
    else {
        //
        // Not connected
        //
        LoadString(g_hInst, IDS_UNCONNECTED, m_szBuff, sizeof(m_szBuff));

        m_fUnconnected = TRUE;
    }
    
    }
    else if (cObjects == 0) {
    //
    // Release the interface ...
    //
    if (m_pPin == NULL) {
        return( E_UNEXPECTED);
    }

    m_pPin->Release();
    m_pPin = NULL;
    }
    else {
    ASSERT(!"No support for more than one object");
    return( E_UNEXPECTED );
    }

    return NOERROR;
}

//////////////////////////////////////////////////////////////////////////
// *
// * CFileProperties
// *


//
// Constructor
//
CFileProperties::CFileProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CUnknown(NAME("File Property Page"), lpunk)
    , m_oszFileName(NULL)
    , m_pPageSite(NULL)
    , m_bDirty(FALSE)
    , m_hwnd(NULL) {

}


//
// Destructor
//
CFileProperties::~CFileProperties(void)
{
     //
     // OleCreatePropertyFrame bug:
     //   - Final SetObjects(NULL) call is missing. Might have to
     //     release interfaces at this point.
     //

     ASSERT(m_pPageSite == NULL);
}


//
// NonDelegatingQueryInterface
//
// Reveal our property page
STDMETHODIMP CFileProperties::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    if (riid == IID_IPropertyPage) {
    return GetInterface((IPropertyPage *) this, ppv);
    } else {
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


//
// SetPageSite
//
// called with null as the page shuts down. therefore release the file interface
// here.
STDMETHODIMP CFileProperties::SetPageSite(LPPROPERTYPAGESITE pPageSite) {

    if (pPageSite == NULL) {

    ASSERT(m_pPageSite);
    m_pPageSite->Release();
    m_pPageSite = NULL;
    }
    else {
    if (m_pPageSite != NULL) {
        return( E_UNEXPECTED );
    }

    m_pPageSite = pPageSite;
    m_pPageSite->AddRef();
    }

    return( S_OK );
}


//
// GetPageInfo
//
// set the page info so that the page site can size itself, etc
STDMETHODIMP CFileProperties::GetPageInfo(LPPROPPAGEINFO pPageInfo) {

    WCHAR szTitle[] = L"File";

    LPOLESTR pszTitle = (LPOLESTR) CoTaskMemAlloc(sizeof(szTitle));
    memcpy(pszTitle, szTitle, sizeof(szTitle));

    pPageInfo->cb               = sizeof(PROPPAGEINFO);
    pPageInfo->pszTitle         = pszTitle;

    // set default size values if GetDialogSize fails
    pPageInfo->size.cx          = 325;
    pPageInfo->size.cy          = 95;
    GetDialogSize(GetPropPageID(), DialogProc, 0L, &pPageInfo->size);

    pPageInfo->pszDocString     = NULL;
    pPageInfo->pszHelpFile      = NULL;
    pPageInfo->dwHelpContext    = 0;

    return NOERROR;

}



//
// Show
//
// Display the property dialog
STDMETHODIMP CFileProperties::Show(UINT nCmdShow) {

    if (m_hwnd == NULL) {
    return E_UNEXPECTED;
    }

    if (!((nCmdShow == SW_SHOW) || (nCmdShow == SW_SHOWNORMAL) || (nCmdShow == SW_HIDE))) {
    return( E_INVALIDARG);
    }

    ShowWindow(m_hwnd, nCmdShow);
    InvalidateRect(m_hwnd, NULL, TRUE);

    return NOERROR;
}


//
// Activate
//
// Create the window we will use to edit properties
STDMETHODIMP CFileProperties::Activate(HWND hwndParent, LPCRECT prect, BOOL fModal) {

    if ( m_hwnd != NULL ) {
    return( E_UNEXPECTED );
    }

    m_hwnd = CreateDialogParam( g_hInst
                  , MAKEINTRESOURCE(GetPropPageID())
                  , hwndParent
                  , DialogProc
                  , (LPARAM) this
                  );

    if (m_hwnd == NULL) {
    DWORD dwErr = GetLastError();
    DbgLog((LOG_ERROR, 1, TEXT("Could not create window: 0x%x"), dwErr));
    return E_FAIL;
    }

    DWORD dwStyle = ::GetWindowLong( m_hwnd, GWL_EXSTYLE );
    dwStyle |= WS_EX_CONTROLPARENT;
    SetWindowLong(m_hwnd, GWL_EXSTYLE, dwStyle);

    if (m_oszFileName) {
    FileNameToDialog();
    }

    Move(prect);
    ShowWindow( m_hwnd, SW_SHOWNORMAL );

    return NOERROR;
}


//
// Deactivate
//
// Destroy the dialog
STDMETHODIMP CFileProperties::Deactivate(void) {

    if (m_hwnd == NULL) {
    return E_UNEXPECTED;
    }

    //
    // HACK: Remove WS_EX_CONTROLPARENT before DestroyWindow call
    //       (or NT crashes!)
    DWORD dwStyle = ::GetWindowLong(m_hwnd, GWL_EXSTYLE);
    dwStyle = dwStyle & (~WS_EX_CONTROLPARENT);
    SetWindowLong(m_hwnd, GWL_EXSTYLE, dwStyle);

    if (DestroyWindow(m_hwnd)) {
    m_hwnd = NULL;
    return NOERROR;
    }
    else {
    return E_FAIL;
    }
}


//
// Move
//
// put the property page over its home in the parent frame.
STDMETHODIMP CFileProperties::Move(LPCRECT prect) {

    if ( m_hwnd == NULL ) {
    return( E_UNEXPECTED );
    }

    if (MoveWindow( m_hwnd
          , prect->left
          , prect->top
          , prect->right - prect->left
          , prect->bottom - prect->top
          , TRUE                // send WM_PAINT
          ) ) {
    return NOERROR;
    }
    else {
    return E_FAIL;
    }
}


//
// IsPageDirty
//
STDMETHODIMP CFileProperties::IsPageDirty(void) {

    if (m_bDirty) {
    return S_OK;
    }
    else {
    return S_FALSE;
    }
}


//
// DialogProc
//
// Handles the window messages for our property page
INT_PTR CALLBACK CFileProperties::DialogProc( HWND hwnd
                     , UINT uMsg
                     , WPARAM wParam
                     , LPARAM lParam) {

    static CFileProperties *pThis = NULL;

    switch (uMsg) {
    case WM_INITDIALOG: // GWLP_USERDATA has not been set yet. pThis in lParam

    pThis = (CFileProperties *) lParam;

    return TRUE;    // I don't call setfocus...

    case WM_COMMAND:
    if (!pThis)
        return( TRUE );

    pThis->OnCommand(HIWORD(wParam), LOWORD(wParam), (HWND) lParam);
    return TRUE;

    default:
    return FALSE;
    }
}

//
// SetDirty
//
// Notify the page site that we are dirty and set our dirty flag, if bDirty = TRUE
// otherwise set the flag to not dirty
void CFileProperties::SetDirty(BOOL bDirty) {

    m_bDirty = bDirty;

    if (bDirty) {
    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
}


//
// OnCommand
//
// handles WM_COMMAND messages from the property page
void CFileProperties::OnCommand(WORD wNotifyCode, WORD wID, HWND hwndCtl) {

    switch (wID) {
    case IDC_FILE_SELECT:
    //
    // Let the user chose a new file name
    //

    ASSERT(m_hwnd);

    TCHAR tszFile[MAX_PATH];
    tszFile[0] = TEXT('\0');

    OPENFILENAME ofn;
    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner   = m_hwnd;
    ofn.lpstrFilter = TEXT("Media files\0*.MPG;*.AVI;*.MOV;*.WAV\0MPEG files\0*.MPG\0AVI files\0*.AVI\0Quick Time files\0*.MOV\0Wave audio files\0*.WAV\0All Files\0*.*\0\0");
    ofn.nFilterIndex = 1;
    ofn.lpstrFile   = tszFile;
    ofn.nMaxFile    = MAX_PATH;
    ofn.lpstrTitle  = TEXT("Select File Source");
    ofn.Flags       = OFN_PATHMUSTEXIST;

    if (GetOpenFileName(&ofn)) {
        SetDirty();

        ASSERT(m_hwnd);
        HWND hWndEdit = GetDlgItem(m_hwnd, IDC_FILENAME);
        SetWindowText(hWndEdit, tszFile);
    }

    break;

    default:
    break;
    }
}

//
// FileNameToDialog
//
void CFileProperties::FileNameToDialog()
{
    ASSERT(m_hwnd);

    //
    // Get window handle for the edit control.
    //
    HWND hWnd = GetDlgItem(m_hwnd, IDC_FILENAME);
    ASSERT(hWnd);

    if (!m_oszFileName) {
    // No name!
    SetWindowText(hWnd, TEXT(""));

    return;
    }

    TCHAR * tszFileName;

#ifndef UNICODE

    CHAR szFileName[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0,
            m_oszFileName, -1,
            szFileName, sizeof(szFileName),
            NULL, NULL);

    tszFileName = szFileName;

#else // UNICODE

    tszFileName = m_oszFileName;
#endif

    SetWindowText(hWnd, tszFileName);
}


//
// CreateInstance
//
// The only allowed way to create File Property pages
CUnknown *CFileSourceProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CFileSourceProperties(lpunk, phr);
    if (punk == NULL) {
    *phr = E_OUTOFMEMORY;
    }

    return punk;
}

CFileSourceProperties::CFileSourceProperties(LPUNKNOWN lpunk, HRESULT *phr) :
    CFileProperties(lpunk, phr)
    , m_pIFileSource(NULL)
{
}

CFileSourceProperties::~CFileSourceProperties()
{
  //
  // OleCreatePropertyFrame bug:
  //   - Final SetObjects(NULL) call is missing. Might have to
  //     release interfaces at this point.
  //

  if (m_pIFileSource)
     m_pIFileSource->Release();
     m_pIFileSource = NULL;
}

//
// SetObjects
//
STDMETHODIMP CFileSourceProperties::SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk) {

    if (cObjects == 1) {
    //
    // Initialise
    //
    if ( (ppunk == NULL) || (*ppunk == NULL) ) {
        return( E_POINTER );
    }

    ASSERT( !m_pIFileSource );

    HRESULT hr = (*ppunk)->QueryInterface(IID_IFileSourceFilter, (void **) &m_pIFileSource);
    if ( FAILED(hr) ) {
        return( E_NOINTERFACE );
    }

    ASSERT( m_pIFileSource );

    //
    // Get file name of file source
    //
    if (m_oszFileName) {
        QzTaskMemFree((PVOID) m_oszFileName);
        m_oszFileName = NULL;
    }

    AM_MEDIA_TYPE mtNotUsed;
    if (FAILED(m_pIFileSource->GetCurFile(&m_oszFileName, &mtNotUsed))) {
        SetDirty();
    }

    if (m_hwnd) {
        FileNameToDialog();
    }
    }
    else if ( cObjects == 0 ) {

    if ( m_pIFileSource == NULL ) {
        return( E_UNEXPECTED );
    }

    ASSERT(m_pIFileSource);
    m_pIFileSource->Release();
    m_pIFileSource = NULL;
    }
    else {
    ASSERT( !"No support for more than 1 object" );
    return( E_UNEXPECTED );
    }

    return( S_OK );
}

//
// Apply
//
STDMETHODIMP CFileSourceProperties::Apply(void) {

    if (IsPageDirty() == S_OK) {

    TCHAR szFileName[MAX_PATH];

    ASSERT(m_hwnd);
    GetWindowText(GetDlgItem(m_hwnd, IDC_FILENAME), szFileName, sizeof(szFileName));

#ifndef UNICODE

    WCHAR wszFileName[MAX_PATH];

    MultiByteToWideChar(CP_ACP, 0,
                szFileName, -1,
                wszFileName, sizeof(wszFileName));
#else
    #define wszFileName szFileName
#endif

        HRESULT hr = m_pIFileSource->Load(wszFileName, NULL);
    if (FAILED(hr)) {
        TCHAR tszMessage[MAX_PATH];
        LoadString(g_hInst, IDS_FAILED_LOAD_FILE, tszMessage, MAX_PATH);
        MessageBox(m_hwnd, tszMessage, NULL, MB_OK);
        return E_FAIL;
    }

    SetDirty(FALSE);
    }
    return NOERROR;
}


//
// CreateInstance
//
// The only allowed way to create File Property pages
CUnknown *CFileSinkProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CFileSinkProperties(lpunk, phr);
    if (punk == NULL) {
    *phr = E_OUTOFMEMORY;
    }

    return punk;
}

CFileSinkProperties::CFileSinkProperties(LPUNKNOWN lpunk, HRESULT *phr) :
    CFileProperties(lpunk, phr)
    , m_fTruncate(FALSE)
    , m_pIFileSink(NULL)
    , m_pIFileSink2(NULL)
{
}

CFileSinkProperties::~CFileSinkProperties()
{
  //
  // OleCreatePropertyFrame bug:
  //   - Final SetObjects(NULL) call is missing. Might have to
  //     release interfaces at this point.
  //

  if (m_pIFileSink)
     m_pIFileSink->Release();
     m_pIFileSink = NULL;
  if (m_pIFileSink2)
     m_pIFileSink2->Release();
     m_pIFileSink = NULL;
}

//
// SetObjects
//
STDMETHODIMP CFileSinkProperties::SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk) {

    if (cObjects == 1) {
    //
    // Initialise
    //
    if ( (ppunk == NULL) || (*ppunk == NULL) ) {
        return( E_POINTER );
    }

    ASSERT( !m_pIFileSink && !m_pIFileSink2);

    HRESULT hr = (*ppunk)->QueryInterface(IID_IFileSinkFilter2, (void **) &m_pIFileSink2);
    if ( FAILED(hr) ) {
            hr = (*ppunk)->QueryInterface(IID_IFileSinkFilter, (void **) &m_pIFileSink);
            if ( FAILED(hr) ) {
                return( E_NOINTERFACE );
            }
    }
        else
        {
            m_pIFileSink = (IFileSinkFilter *)m_pIFileSink2;
            m_pIFileSink2->AddRef();
        }
    

    ASSERT( m_pIFileSink || (m_pIFileSink2 && m_pIFileSink2) );

    //
    // Get file name of file sink
    //
    if (m_oszFileName) {
        QzTaskMemFree((PVOID) m_oszFileName);
        m_oszFileName = NULL;
    }

    AM_MEDIA_TYPE mtNotUsed;
    if (FAILED(m_pIFileSink->GetCurFile(&m_oszFileName, &mtNotUsed))) {
        SetDirty();
    }

        if(m_pIFileSink2)
        {
            DWORD dwFlags;
            if (FAILED(m_pIFileSink2->GetMode(&dwFlags))) {
                SetDirty();
            }
            else
            {
                m_fTruncate = ((dwFlags & AM_FILE_OVERWRITE) != 0);
            }
        }


        if (m_hwnd) {
            FileNameToDialog();
        }
    }
    else if ( cObjects == 0 ) {

    if ( m_pIFileSink == NULL ) {
        return( E_UNEXPECTED );
    }

    ASSERT(m_pIFileSink);
    m_pIFileSink->Release();
    m_pIFileSink = NULL;
        if(m_pIFileSink2)
        {
            m_pIFileSink2->Release();
            m_pIFileSink2 = NULL;
        }
    }
    else {
    ASSERT( !"No support for more than 1 object" );
    return( E_UNEXPECTED );
    }

    return( S_OK );
}

void CFileSinkProperties::OnCommand(WORD wNotifyCode, WORD wID, HWND hwndCtl) {

    switch (wID) {
    case IDC_TRUNCATE:

        m_fTruncate = ::SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED;
        SetDirty();
    break;

    default:
    CFileProperties::OnCommand(wNotifyCode, wID, hwndCtl);
    }
}

void CFileSinkProperties::FileNameToDialog()
{
    ASSERT(m_hwnd);

    //
    // Get window handle for the edit control.
    //
    HWND hWnd = GetDlgItem(m_hwnd, IDC_TRUNCATE);
    ASSERT(hWnd);

    if(m_pIFileSink2)
        CheckDlgButton (m_hwnd, IDC_TRUNCATE, m_fTruncate ? BST_CHECKED : 0);
    else
        Edit_Enable(GetDlgItem(m_hwnd, IDC_TRUNCATE), FALSE);


    CFileProperties::FileNameToDialog();
}

//
// Apply
//
STDMETHODIMP CFileSinkProperties::Apply(void) {

    if (IsPageDirty() == S_OK) {

    TCHAR szFileName[MAX_PATH];

    ASSERT(m_hwnd);
    GetWindowText(GetDlgItem(m_hwnd, IDC_FILENAME), szFileName, sizeof(szFileName));
        BOOL fTruncate = SendMessage(GetDlgItem(m_hwnd, IDC_TRUNCATE), BM_GETCHECK, 0, 0) == BST_CHECKED;

#ifndef UNICODE

    WCHAR wszFileName[MAX_PATH];

    MultiByteToWideChar(CP_ACP, 0,
                szFileName, -1,
                wszFileName, sizeof(wszFileName));
#else
    #define wszFileName szFileName
#endif

        HRESULT hr = m_pIFileSink->SetFileName(wszFileName, NULL);
    if (FAILED(hr)) {
        TCHAR tszMessage[MAX_PATH];
        LoadString(g_hInst, IDS_FAILED_SET_FILENAME, tszMessage, MAX_PATH);
        MessageBox(m_hwnd, tszMessage, NULL, MB_OK);
        return E_FAIL;
    }

        if(m_pIFileSink2)
        {
            hr = m_pIFileSink2->SetMode(fTruncate ? AM_FILE_OVERWRITE : 0);
            if (FAILED(hr)) {
                TCHAR tszMessage[MAX_PATH];
                LoadString(g_hInst, IDS_FAILED_SET_FILENAME, tszMessage, MAX_PATH);
                MessageBox(m_hwnd, tszMessage, NULL, MB_OK);
                return E_FAIL;
            }
        }

    SetDirty(FALSE);
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\proppage\proppage.h ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
//
// TypeProp.h
//

// A property page that allows a pin to display
// its media type.

class CMediaTypeProperties : public IPropertyPage,
			     public CUnknown {

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
    ~CMediaTypeProperties(void);

    DECLARE_IUNKNOWN;

    // override this to reveal our property interface
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    STDMETHODIMP SetPageSite(LPPROPERTYPAGESITE pPageSite);
    STDMETHODIMP Activate(HWND hwndParent, LPCRECT prect, BOOL fModal);
    STDMETHODIMP Deactivate(void);
    STDMETHODIMP GetPageInfo(LPPROPPAGEINFO pPageInfo);
    STDMETHODIMP SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHODIMP Show(UINT nCmdShow);
    STDMETHODIMP Move(LPCRECT prect);
    STDMETHODIMP IsPageDirty(void) 			{ return S_FALSE; }
    STDMETHODIMP Apply(void)				{ return NOERROR; }
    STDMETHODIMP Help(LPCWSTR lpszHelpDir)		{ return E_NOTIMPL; }
    STDMETHODIMP TranslateAccelerator(LPMSG lpMsg)	{ return E_NOTIMPL; }

    void CreateEditCtrl(HWND);
    void FillEditCtrl();

    BOOL        m_fUnconnected;         // True if pin is unconnected

private:

    CMediaTypeProperties(LPUNKNOWN lpunk, HRESULT *phr);

    static INT_PTR CALLBACK DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND	m_hwnd;		// the handle of our property dialog
    TCHAR	m_szBuff[1000]; // media type as a string

    IPin	*m_pPin;        // the pin this page is attached to
    HWND        m_EditCtrl;     // the edit control to display a
                                //  list of media types
};


//
// CFileProperties
//
class CFileProperties : public IPropertyPage,
		        public CUnknown {

public:

    virtual ~CFileProperties(void);

    DECLARE_IUNKNOWN;

    // override this to reveal our property interface
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    STDMETHODIMP SetPageSite(LPPROPERTYPAGESITE pPageSite);
    STDMETHODIMP Activate(HWND hwndParent, LPCRECT prect, BOOL fModal);
    STDMETHODIMP Deactivate(void);
    STDMETHODIMP GetPageInfo(LPPROPPAGEINFO pPageInfo);
    STDMETHODIMP SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk) PURE;
    STDMETHODIMP Show(UINT nCmdShow);
    STDMETHODIMP Move(LPCRECT prect);
    STDMETHODIMP IsPageDirty(void);
    STDMETHODIMP Apply(void) PURE;
    STDMETHODIMP Help(LPCWSTR lpszHelpDir)		{ return E_NOTIMPL; }
    STDMETHODIMP TranslateAccelerator(LPMSG lpMsg)	{ return E_NOTIMPL; }
    virtual ULONG GetPropPageID() PURE;

protected:

    CFileProperties(LPUNKNOWN lpunk, HRESULT *phr);

    static INT_PTR CALLBACK DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND	m_hwnd;		// the handle of our property dialog

    IPropertyPageSite	*m_pPageSite;

    BOOL		m_bDirty;
    LPOLESTR    m_oszFileName;

    void	SetDirty(BOOL bDirty = TRUE);
    virtual void	OnCommand(WORD wNotifyCode, WORD wID, HWND hwndCtl);

    virtual void FileNameToDialog();
};

class CFileSourceProperties : public CFileProperties
{
public:
    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
    ~CFileSourceProperties();
    STDMETHODIMP SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHODIMP Apply(void);
    ULONG GetPropPageID() { return IDD_FILESOURCEPROP; }
private:
    CFileSourceProperties(LPUNKNOWN lpunk, HRESULT *phr);

    IFileSourceFilter   *m_pIFileSource; // the IFileSourceFilter interface to manage
};

class CFileSinkProperties : public CFileProperties
{
public:
    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
    ~CFileSinkProperties();
    STDMETHODIMP SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHODIMP Apply(void);
    ULONG GetPropPageID() { return IDD_FILESINKPROP; }
    void FileNameToDialog();
    
private:

    CFileSinkProperties(LPUNKNOWN lpunk, HRESULT *phr);

    void	OnCommand(WORD wNotifyCode, WORD wID, HWND hwndCtl);
    
    // the IFileSinkFilter interface to manage, and optionally the
    // corresponding IFileSinkFilter2
    IFileSinkFilter   *m_pIFileSink; 
    IFileSinkFilter2  *m_pIFileSink2;

    BOOL m_fTruncate;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\treewin.cpp ===
// TreeWindow.cpp: implementation of the CTreeWindow class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "TreeWin.h"
#include "NP_CommonPage.h"
#include "misccell.h"
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTreeWin::CTreeWin(
			CNP_CommonPage* pParent
			)
{
	m_pCommonPage = pParent;
}

CTreeWin::~CTreeWin()
{
	CleanMapList ();
}

void
CTreeWin::CleanMapList ()
{
	//first make sure we free the existing list
	TREE_MAP::iterator	treeIt = m_treeMap.begin ();
	while (treeIt != m_treeMap.end ())
	{
		if ((*treeIt).first)
			(*treeIt).first->Release ();
		if ((*treeIt).second)
			(*treeIt).second->Release ();
		m_treeMap.erase (treeIt);
		treeIt = m_treeMap.begin ();
	}
}

HRESULT	
CTreeWin::RefreshTree (
	IScanningTuner*	pTuner
	)
{
	HRESULT hr = S_OK;
	USES_CONVERSION;

	if (!m_hWnd)
		return NULL;

	//first make sure we free the existing list
	CleanMapList ();
	//delete all previous items
	TreeView_DeleteAllItems (m_hWnd);
	
	//insert the default TuningSpace
    ITuningSpace*	pTunningSpace;
	CComPtr <ITuneRequest>	pTuneRequest;
	hr = pTuner->get_TuneRequest (&pTuneRequest);
	if (pTuneRequest)
	{
	    pTuneRequest->get_TuningSpace (&pTunningSpace);
	    HTREEITEM hLocatorParent = InsertTuningSpace (
									    pTunningSpace, 
									    _T ("Current TuneRequest")
									    );
	    TreeView_SelectItem (m_hWnd, hLocatorParent);

	    if (hLocatorParent == NULL)
	    {
		    pTunningSpace->Release ();
		    pTunningSpace = NULL;
	    }
        //now let's fill with the ILocator info
        //add to the list
        ILocator* pLocator = NULL;
        hr = pTuneRequest->get_Locator (&pLocator);
        InsertLocator (hLocatorParent, pLocator);
        //add to the maplist
        m_treeMap.insert (TREE_MAP::value_type (pTunningSpace, pLocator));
    }

	//fill the tree with all TunningSpaces this NP knows about them
	CComPtr <IEnumTuningSpaces> pEnumTunningSpaces;
	hr = pTuner->EnumTuningSpaces (&pEnumTunningSpaces);
	if (FAILED (hr) || (!pEnumTunningSpaces))
		return hr;
	while (pEnumTunningSpaces->Next (1, &pTunningSpace, 0) == S_OK)
	{
		HTREEITEM hLocatorParent = InsertTuningSpace (pTunningSpace);
		if (hLocatorParent == NULL)
		{
			pTunningSpace->Release ();
			pTunningSpace = NULL;
			continue;
		}

		//now let's fill with the ILocator info
		//add to the list
		ILocator* pLocator = NULL;
		hr = pTunningSpace->get_DefaultLocator (&pLocator);
		if (FAILED (hr) || (!pLocator))
		{
			pTunningSpace->Release ();
			pTunningSpace = NULL;
			continue;
		}
		InsertLocator (hLocatorParent, pLocator);

		//add to the maplist
		m_treeMap.insert (TREE_MAP::value_type (pTunningSpace, pLocator));
	}
	

	
	return hr;
}

HTREEITEM
CTreeWin::InsertTuningSpace (
	ITuningSpace*	pTunSpace,
	TCHAR*	szCaption
	)
{
	HRESULT	hr = S_OK;
	USES_CONVERSION;
	TCHAR	szText[MAX_PATH];

	CComBSTR	friendlyName;
	hr = pTunSpace->get_FriendlyName (&friendlyName);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ITuningSpace::get_FriendlyName"), hr);
		return NULL;
	}
	bool bBold = false;
	//make sure we write the caption if there is one
	if (_tcslen (szCaption) > 0)
	{
		wsprintf (szText, _T("%s-%s"), szCaption, W2T (friendlyName));
		bBold = true;
	}
	else
	{
		_tcscpy (szText, W2T (friendlyName));
	}
	HTREEITEM hParentItem = InsertTreeItem (
		NULL, 
		reinterpret_cast <DWORD_PTR> (pTunSpace), 
		szText,
		bBold
		);
	//for all the outers add the TreeParams params

	//uniqueName
	CComBSTR	uniqueName;
	hr = pTunSpace->get_UniqueName (&uniqueName);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ITuningSpace::get_UniqueName"), hr);
		return NULL;
	}
	wsprintf (szText, _T("Unique Name - %s"), W2T(uniqueName));
	HTREEITEM hItem = InsertTreeItem (
		hParentItem, 
		UniqueName, 
		szText
		);
	//frequencyMapping
	CComBSTR	frequencyMapping;
	hr = pTunSpace->get_FrequencyMapping (&frequencyMapping);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ITuningSpace::get_FrequencyMapping"), hr);
		return NULL;
	}
	wsprintf (szText, _T("Frequency Mapping - %s"), W2T(frequencyMapping));
	hItem = InsertTreeItem (
		hParentItem, 
		FrequencyMapping, 
		szText
		);
	//TunCLSID
	CComBSTR	TunCLSID;
	hr = pTunSpace->get_CLSID (&TunCLSID);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ITuningSpace::get_CLSID"), hr);
		return NULL;
	}
	wsprintf (szText, _T("CLSID - %s"), W2T(TunCLSID));
	hItem = InsertTreeItem (
		hParentItem, 
		TunSpace_CLSID, 
		szText
		);

	//finally insert the locator parent
	ILocator* pLocator = NULL;
	hr = pTunSpace->get_DefaultLocator (&pLocator);
	if (FAILED (hr) || (!pLocator))
	{
		//first delete the tunning space item
		TreeView_DeleteItem (m_hWnd, hParentItem);
		m_pCommonPage->SendError (_T("Calling ITuningSpace::get_DefaultLocator"), hr);
		return NULL;
	}

	hItem = InsertTreeItem (
		hParentItem, 
		reinterpret_cast <DWORD_PTR> (pLocator),
		_T("Locator")
		);

	return hItem;
}

//==================================================================
//	Will insert in the tree all information for the passed ILocator
//	
//
//==================================================================
HTREEITEM	
CTreeWin::InsertLocator (
	HTREEITEM	hParentItem, 
	ILocator*	pLocator
	)
{
	USES_CONVERSION;
	HRESULT	hr = S_OK;
	TCHAR	szText[MAX_PATH];

	LONG	lFrequency;
	hr = pLocator->get_CarrierFrequency (&lFrequency);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ILocator::get_CarrierFrequency"), hr);
		return NULL;
	}
	wsprintf (szText, _T("Frequency - %ld"), lFrequency);
	HTREEITEM hItem = InsertTreeItem (
		hParentItem, 
		CarrierFrequency, 
		szText
		);

	FECMethod	fecMethod;
	hr = pLocator->get_InnerFEC (&fecMethod);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ILocator::get_InnerFEC"), hr);
		return NULL;
	}
	CComBSTR bstrTemp = m_misc.ConvertFECMethodToString (fecMethod);
	wsprintf (szText, _T("InnerFEC - %s"), W2T (bstrTemp));

	hItem = InsertTreeItem (
		hParentItem, 
		InnerFEC, 
		szText
		);

	BinaryConvolutionCodeRate	binaryConvolutionCodeRate;
	hr = pLocator->get_InnerFECRate (&binaryConvolutionCodeRate);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ILocator::get_InnerFECRate"), hr);
		return NULL;
	}
	bstrTemp = m_misc.ConvertInnerFECRateToString (binaryConvolutionCodeRate);
	wsprintf (szText, _T("InnerFECRate - %s"), W2T (bstrTemp));
	hItem = InsertTreeItem (
		hParentItem, 
		InnerFECRate, 
		szText
		);

	ModulationType	modulationType;
	hr = pLocator->get_Modulation (&modulationType);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ILocator::get_Modulation"), hr);
		return NULL;
	}
	bstrTemp = m_misc.ConvertModulationToString (modulationType);
	wsprintf (szText, _T("Modulation - %s"), W2T (bstrTemp));
	hItem = InsertTreeItem (
		hParentItem, 
		Modulation, 
		szText
		);

	hr = pLocator->get_OuterFEC (&fecMethod);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ILocator::get_OuterFEC"), hr);
		return NULL;
	}
	bstrTemp = m_misc.ConvertFECMethodToString (fecMethod);
	wsprintf (szText, _T("OuterFEC - %s"), W2T (bstrTemp));
	hItem = InsertTreeItem (
		hParentItem, 
		OuterFEC, 
		szText
		);
	
	hr = pLocator->get_OuterFECRate (&binaryConvolutionCodeRate);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ILocator::get_OuterFECRate"), hr);
		return NULL;
	}
	bstrTemp = m_misc.ConvertInnerFECRateToString (binaryConvolutionCodeRate);
	wsprintf (szText, _T("OuterFECRate - %s"), W2T (bstrTemp));
	hItem = InsertTreeItem (
		hParentItem, 
		OuterFECRate, 
		szText
		);
	
	LONG	lRate;
	hr = pLocator->get_SymbolRate (&lRate);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ILocator::get_SymbolRate"), hr);
		return NULL;
	}
	wsprintf (szText, _T("SymbolRate - %ld"), lRate);
	hItem = InsertTreeItem (
		hParentItem, 
		SymbolRate, 
		szText
		);

	return hItem;
}

//================================================
// Helper method to the tree helper macro...
// This will just insert an item in the tree
//================================================
HTREEITEM
CTreeWin::InsertTreeItem (
	HTREEITEM	hParentItem	,
	LONG		lParam,
	TCHAR*		pszText,
	bool		bBold /*= false*/
)
{
	if (!m_hWnd)
		return NULL;
	HTREEITEM hItem = NULL;

	TVINSERTSTRUCT tviInsert;
	tviInsert.hParent = hParentItem;
	tviInsert.hInsertAfter = TVI_LAST;

	TVITEM	tvItem;
	tvItem.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_TEXT;
	if (bBold)
	{
		tvItem.mask |= TVIF_STATE;
		tvItem.state = TVIS_BOLD | TVIS_EXPANDED;
		tvItem.stateMask = TVIS_BOLD;
	}
	tvItem.hItem = NULL;
	tvItem.lParam = lParam;

	tvItem.pszText = pszText;
	tvItem.cchTextMax = _tcslen (pszText);

	tviInsert.item = tvItem;
	hItem = TreeView_InsertItem (m_hWnd, &tviInsert);
	return hItem;
}


HRESULT
CTreeWin::SubmitCurrentLocator ()
{
	ASSERT (m_hWnd);
	HTREEITEM hItem = TreeView_GetSelection (m_hWnd);
	ASSERT (hItem);
	HRESULT hr = S_OK;
	//this state is merely impossible
	if (hItem == NULL)
		return E_FAIL;
	HTREEITEM hRoot = hItem;
	HTREEITEM hParent = hRoot;
	TVITEM	tvItem;
	tvItem.mask = TVIF_PARAM;
	tvItem.lParam = NULL; 
	//just get the parent
	while ( (hRoot = TreeView_GetParent (m_hWnd, hRoot)) != NULL)
	{
		//keep the last parent alive so we can query later
		hParent = hRoot;
	}

	tvItem.hItem = hParent;
	if (!TreeView_GetItem (m_hWnd, &tvItem))
	{
		ASSERT (FALSE);
		return E_FAIL;
	}
	//normally this cast should not be done between different apartments
	//It's ok with DShow apartment model
	ITuningSpace* pTuneSpace = reinterpret_cast <ITuningSpace*> (tvItem.lParam);
	ASSERT (pTuneSpace);
	//TREE_MAP::iterator it = m_treeMap.find (pTuneSpace);
	//ILocator* pLocator = (*it).second;
	if (FAILED (hr = m_pCommonPage->PutTuningSpace (pTuneSpace)))
	{
		m_pCommonPage->SendError (_T("Calling IScaningTuner::put_TuningSpace"), hr);
		return hr;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\proppage\resource.h ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
// Used by typeprop.rc
//
#define IDD_TYPEPROP        101
#define IDD_FILESOURCEPROP  102
#define IDD_FILESINKPROP        103
#define IDR_STATIC      -1

#define IDS_TYPE        104

#define IDS_UNCONNECTED     105

#define IDS_FORMAT_AnalogVideo                     3111
#define IDS_FORMAT_DolbyAC3                3112
#define IDS_FORMAT_MPEG2Audio              3218
#define IDS_FORMAT_DVD_LPCMAudio           3219
#define IDS_FORMAT_DvInfo                  3113
#define IDS_FORMAT_MPEG2Video                  3114
#define IDS_FORMAT_MPEG2_VIDEO                 3115
#define IDS_FORMAT_MPEGStreams                 3116
#define IDS_FORMAT_MPEGVideo                   3117
#define IDS_FORMAT_VIDEOINFO2                  3118
#define IDS_FORMAT_VideoInfo                   3119
#define IDS_FORMAT_VideoInfo2                  3120
#define IDS_FORMAT_WaveFormatEx                3121
#define IDS_MEDIASUBTYPE_AIFF                  3122
#define IDS_MEDIASUBTYPE_AU                3123
#define IDS_MEDIASUBTYPE_AnalogVideo_NTSC_M        3124
#define IDS_MEDIASUBTYPE_AnalogVideo_PAL_B         3125
#define IDS_MEDIASUBTYPE_AnalogVideo_PAL_D         3126
#define IDS_MEDIASUBTYPE_AnalogVideo_PAL_G         3127
#define IDS_MEDIASUBTYPE_AnalogVideo_PAL_H         3128
#define IDS_MEDIASUBTYPE_AnalogVideo_PAL_I         3129
#define IDS_MEDIASUBTYPE_AnalogVideo_PAL_M         3130
#define IDS_MEDIASUBTYPE_AnalogVideo_PAL_N         3131
#define IDS_MEDIASUBTYPE_AnalogVideo_SECAM_B           3132
#define IDS_MEDIASUBTYPE_AnalogVideo_SECAM_D           3133
#define IDS_MEDIASUBTYPE_AnalogVideo_SECAM_G           3134
#define IDS_MEDIASUBTYPE_AnalogVideo_SECAM_H           3135
#define IDS_MEDIASUBTYPE_AnalogVideo_SECAM_K           3136
#define IDS_MEDIASUBTYPE_AnalogVideo_SECAM_K1          3137
#define IDS_MEDIASUBTYPE_AnalogVideo_SECAM_L           3138
#define IDS_MEDIASUBTYPE_Avi                   3139
#define IDS_MEDIASUBTYPE_CFCC                  3140
#define IDS_MEDIASUBTYPE_CLJR                  3141
#define IDS_MEDIASUBTYPE_CPLA                  3142
#define IDS_MEDIASUBTYPE_DOLBY_AC3             3143
#define IDS_MEDIASUBTYPE_DVCS                  3144
#define IDS_MEDIASUBTYPE_DVD_LPCM_AUDIO            3146
#define IDS_MEDIASUBTYPE_DVD_NAVIGATION_DSI        3147
#define IDS_MEDIASUBTYPE_DVD_NAVIGATION_PCI            3148
#define IDS_MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER       3149
#define IDS_MEDIASUBTYPE_DVD_SUBPICTURE            3150
#define IDS_MEDIASUBTYPE_DVSD                   3151
#define IDS_MEDIASUBTYPE_DssAudio               3152
#define IDS_MEDIASUBTYPE_DssVideo               3153
#define IDS_MEDIASUBTYPE_IF09                   3154
#define IDS_MEDIASUBTYPE_IJPG                   3155
#define IDS_MEDIASUBTYPE_Line21_BytePair        3156
#define IDS_MEDIASUBTYPE_Line21_GOPPacket       3157
#define IDS_MEDIASUBTYPE_Line21_VBIRawData      3158
#define IDS_MEDIASUBTYPE_MDVF                   3159
#define IDS_MEDIASUBTYPE_MJPG                   3160
#define IDS_MEDIASUBTYPE_MPEG1Audio             3161
#define IDS_MEDIASUBTYPE_MPEG1Packet            3162
#define IDS_MEDIASUBTYPE_MPEG1Payload           3163
#define IDS_MEDIASUBTYPE_MPEG1System            3164
#define IDS_MEDIASUBTYPE_MPEG1Video             3165
#define IDS_MEDIASUBTYPE_MPEG1VideoCD           3166
#define IDS_MEDIASUBTYPE_MPEG2_AUDIO            3167
#define IDS_MEDIASUBTYPE_MPEG2_PROGRAM          3168
#define IDS_MEDIASUBTYPE_MPEG2_TRANSPORT        3169
#define IDS_MEDIASUBTYPE_MPEG2_VIDEO            3170
#define IDS_MEDIASUBTYPE_Overlay                3171
#define IDS_MEDIASUBTYPE_PCMAudio_Obsolete      3172
#define IDS_MEDIASUBTYPE_Plum                   3173
#define IDS_MEDIASUBTYPE_QTJpeg                 3174
#define IDS_MEDIASUBTYPE_QTMovie                3175
#define IDS_MEDIASUBTYPE_QTRle                  3176
#define IDS_MEDIASUBTYPE_QTRpza                 3177
#define IDS_MEDIASUBTYPE_QTSmc                  3178
#define IDS_MEDIASUBTYPE_RGB1                   3179
#define IDS_MEDIASUBTYPE_RGB24                  3180
#define IDS_MEDIASUBTYPE_RGB32                  3181
#define IDS_MEDIASUBTYPE_RGB4                   3182
#define IDS_MEDIASUBTYPE_RGB555                 3183
#define IDS_MEDIASUBTYPE_RGB565                 3184
#define IDS_MEDIASUBTYPE_RGB8                   3185
#define IDS_MEDIASUBTYPE_TVMJ                   3186
#define IDS_MEDIASUBTYPE_UYVY                   3187
#define IDS_MEDIASUBTYPE_WAKE                   3188
#define IDS_MEDIASUBTYPE_WAVE                   3189
#define IDS_MEDIASUBTYPE_Y211                   3190
#define IDS_MEDIASUBTYPE_Y411                   3191
#define IDS_MEDIASUBTYPE_Y41P                   3192
#define IDS_MEDIASUBTYPE_YUY2                   3193
#define IDS_MEDIASUBTYPE_YV12                   3194
#define IDS_MEDIASUBTYPE_YVU9                   3195
#define IDS_MEDIASUBTYPE_YVYU                   3196
#define IDS_MEDIASUBTYPE_dvhd                   3197
#define IDS_MEDIASUBTYPE_dvsd                   3198
#define IDS_MEDIASUBTYPE_dvsl                   3199
#define IDS_MEDIATYPE_AUXLine21Data             3200
#define IDS_MEDIATYPE_AnalogAudio               3201
#define IDS_MEDIATYPE_AnalogVideo               3202
#define IDS_MEDIATYPE_Audio                     3203
#define IDS_MEDIATYPE_DVD_ENCRYPTED_PACK        3204
#define IDS_MEDIATYPE_DVD_NAVIGATION            3205
#define IDS_MEDIATYPE_File                      3206
#define IDS_MEDIATYPE_Interleaved               3207
#define IDS_MEDIATYPE_MPEG1SystemStream         3208
#define IDS_MEDIATYPE_MPEG2_PES                 3209
#define IDS_MEDIATYPE_Midi                      3210
#define IDS_MEDIATYPE_ScriptCommand             3211
#define IDS_MEDIATYPE_Stream                    3212
#define IDS_MEDIATYPE_Text                      3213
#define IDS_MEDIATYPE_Timecode                  3214
#define IDS_MEDIATYPE_Video                     3215
#define IDS_MEDIASUBTYPE_PCM                    3216
#define IDS_MEDIASUBTYPE_MPEG1AudioPayload      3217
#define IDS_MEDIASUBTYPE_DRM_Audio              3221
#define IDS_MEDIASUBTYPE_IEEE_FLOAT             3222
#define IDS_MEDIASUBTYPE_DOLBY_AC3_SPDIF        3223
#define IDS_MEDIASUBTYPE_RAW_SPORT              3224
#define IDS_MEDIASUBTYPE_SPDIF_TAG_241h         3225

#define IDS_MEDIASUBTYPE_ARGB32                 3226
#define IDS_MEDIASUBTYPE_ARGB1555               3227
#define IDS_MEDIASUBTYPE_ARGB4444               3228
#define IDS_MEDIASUBTYPE_AYUV                   3229

#define IDS_MEDIASUBTYPE_RGB32_D3D_DX7_RT       3230
#define IDS_MEDIASUBTYPE_RGB16_D3D_DX7_RT       3231
#define IDS_MEDIASUBTYPE_ARGB32_D3D_DX7_RT      3232
#define IDS_MEDIASUBTYPE_ARGB1555_D3D_DX7_RT    3233
#define IDS_MEDIASUBTYPE_ARGB4444_D3D_DX7_RT    3234

#define IDS_DXVA_ModeNone                       3235
#define IDS_DXVA_ModeH261_A                     3236
#define IDS_DXVA_ModeH261_B                     3237
#define IDS_DXVA_ModeH263_A                     3238
#define IDS_DXVA_ModeH263_B                     3239
#define IDS_DXVA_ModeH263_C                     3240
#define IDS_DXVA_ModeH263_D                     3241
#define IDS_DXVA_ModeH263_E                     3242
#define IDS_DXVA_ModeH263_F                     3243
#define IDS_DXVA_ModeMPEG1_A                    3244
#define IDS_DXVA_ModeMPEG2_A                    3245
#define IDS_DXVA_ModeMPEG2_B                    3246
#define IDS_DXVA_ModeMPEG2_C                    3247
#define IDS_DXVA_ModeMPEG2_D                    3248
#define IDS_DXVA_NoEncrypt                      3249
#define IDS_DXVA_EncryptProt1                   3250

//
// Last used IDS_... value is 3220 (for IDS_MEDIASUBTYPE_ARGB32)
//

#define IDC_FILENAME        200
#define IDC_FILE_SELECT     201
#define IDC_SAVE        202
#define IDC_TRUNCATE        203

#define IDS_UNKNOWN             300
#define IDS_PREFORMAT           301
#define IDS_PREMAJOR            302
#define IDS_PRESUB              303
#define IDS_NOTYPE              304

#define IDS_FAILED_LOAD_FILE    500
#define IDS_FAILED_SET_FILENAME 501
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\proppage\texttype.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// texttype.h
//


// A CMediaType that can return itsself as text.

class CTextMediaType : public CMediaType {

public:

    CTextMediaType(AM_MEDIA_TYPE mt):CMediaType(mt) {}
    void AsText(LPTSTR szType, unsigned int iLen, LPTSTR szAfterMajor, LPTSTR szAfterOthers, LPTSTR szAtEnd);

    struct TableEntry {
        const GUID * guid;
        UINT stringID;
    };

private:
    void CLSID2String(LPTSTR, UINT, const GUID*, TableEntry*, ULONG);
    void Format2String(LPTSTR, UINT, const GUID*, BYTE*, ULONG);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\proppage\texttype.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
//
// texttype.cpp
//
//
// typetext.cpp
//

// CTextMediaType

#include <streams.h>

#include <string.h>
#include <tchar.h>
#include <dvdmedia.h>   //VIDEOINFOHEADER2 definition

#include <initguid.h>
#include <dxva.h>       //for dxva media subtypes

#include <stdio.h>
#include <wchar.h>

#include "resource.h"
#include "texttype.h"


//
// Global table for this module
//

//
// Text string for Majortypes
//
CTextMediaType::TableEntry g_pMajorTable[] = {
    { NULL, IDS_UNKNOWN},        // THIS ENTRY MUST BE FIRST !!!
    { &MEDIATYPE_AUXLine21Data                      ,IDS_MEDIATYPE_AUXLine21Data},
    { &MEDIATYPE_AnalogAudio                        ,IDS_MEDIATYPE_AnalogAudio},
    { &MEDIATYPE_AnalogVideo                        ,IDS_MEDIATYPE_AnalogVideo},
    { &MEDIATYPE_Audio                              ,IDS_MEDIATYPE_Audio},
    { &MEDIATYPE_DVD_ENCRYPTED_PACK                 ,IDS_MEDIATYPE_DVD_ENCRYPTED_PACK},
    { &MEDIATYPE_DVD_NAVIGATION                     ,IDS_MEDIATYPE_DVD_NAVIGATION},
    { &MEDIATYPE_File                               ,IDS_MEDIATYPE_File},
    { &MEDIATYPE_Interleaved                        ,IDS_MEDIATYPE_Interleaved},
    { &MEDIATYPE_MPEG1SystemStream                  ,IDS_MEDIATYPE_MPEG1SystemStream},
    { &MEDIATYPE_MPEG2_PES                          ,IDS_MEDIATYPE_MPEG2_PES},
    { &MEDIATYPE_Midi                               ,IDS_MEDIATYPE_Midi},
    { &MEDIATYPE_ScriptCommand                      ,IDS_MEDIATYPE_ScriptCommand},
    { &MEDIATYPE_Stream                             ,IDS_MEDIATYPE_Stream},
    { &MEDIATYPE_Text                               ,IDS_MEDIATYPE_Text},
    { &MEDIATYPE_Timecode                           ,IDS_MEDIATYPE_Timecode},
    { &MEDIATYPE_Video                              ,IDS_MEDIATYPE_Video}
};

ULONG g_iMajorTable = sizeof(g_pMajorTable) / sizeof(g_pMajorTable[0]);

//
// Text String for SubMedia types
//
CTextMediaType::TableEntry g_pSubTable[] = {
    { NULL, IDS_UNKNOWN},              // THIS ENTRY MUST BE FIRST !!!
    { &MEDIASUB